{"buggy_code": ["\"\"\"Abstract Apport user interface.\n\nThis encapsulates the workflow and common code for any user interface\nimplementation (like GTK, Qt, or CLI).\n\"\"\"\n\n# Copyright (C) 2007 - 2011 Canonical Ltd.\n# Author: Martin Pitt <martin.pitt@ubuntu.com>\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by the\n# Free Software Foundation; either version 2 of the License, or (at your\n# option) any later version.  See http://www.gnu.org/copyleft/gpl.html for\n# the full text of the license.\n\nimport argparse\nimport ast\nimport configparser\nimport dataclasses\nimport errno\nimport gettext\nimport glob\nimport gzip\nimport io\nimport locale\nimport os.path\nimport pwd\nimport queue\nimport re\nimport shutil\nimport signal\nimport smtplib\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.error\nimport webbrowser\nimport zlib\nfrom gettext import gettext as _\n\nimport apport.crashdb\nimport apport.fileutils\nimport apport.logging\nimport apport.REThread\nfrom apport.packaging_impl import impl as packaging\nfrom apport.user_group import get_process_user_and_group\n\n__version__ = \"2.26.0\"\n\n\nsymptom_script_dir = os.environ.get(\n    \"APPORT_SYMPTOMS_DIR\", \"/usr/share/apport/symptoms\"\n)\nPF_KTHREAD = 0x200000\n\n\ndef get_pid(report):\n    try:\n        pid = re.search(\"Pid:\\t(.*)\\n\", report.get(\"ProcStatus\", \"\")).group(1)\n        return int(pid)\n    except (IndexError, AttributeError):\n        return None\n\n\ndef _get_env_int(\n    key: str, default: typing.Optional[int] = None\n) -> typing.Optional[int]:\n    \"\"\"Get an environment variable as integer.\n\n    Return None if it doesn't exist or failed to convert to integer.\n    The optional second argument can specify an alternate default.\n    \"\"\"\n    try:\n        return int(os.environ[key])\n    except (KeyError, ValueError):\n        return default\n\n\ndef _get_newest_process_for_user(name: str, uid: int) -> typing.Optional[int]:\n    process = subprocess.run(\n        [\"pgrep\", \"-n\", \"-x\", \"-u\", str(uid), name],\n        capture_output=True,\n        check=False,\n        text=True,\n    )\n    if process.returncode != 0 or not process.stdout:\n        return None\n    return int(process.stdout.strip())\n\n\ndef _get_users_environ(uid: int) -> dict[str, str]:\n    \"\"\"Find D-BUS address and XDG_DATA_DIRS for the given user.\n\n    The D-BUS address and XDG_DATA_DIRS is needed for xdg-open. It is\n    incredibly hard, or alternatively, unsafe to funnel it through\n    pkexec/env/sudo, so grab it from gvfsd.\n    \"\"\"\n    gvfsd_pid = _get_newest_process_for_user(\"gvfsd\", uid)\n    if gvfsd_pid is None:\n        return {}\n\n    gvfsd_pid_fd = os.open(\n        f\"/proc/{gvfsd_pid}\", os.O_RDONLY | os.O_PATH | os.O_DIRECTORY\n    )\n    try:\n        gvfsd_env = apport.fileutils.get_process_environ(gvfsd_pid_fd)\n    except OSError:\n        return {}\n    finally:\n        os.close(gvfsd_pid_fd)\n\n    return {\n        key: gvfsd_env[key]\n        for key in [\"DBUS_SESSION_BUS_ADDRESS\", \"XDG_DATA_DIRS\"]\n        if key in gvfsd_env\n    }\n\n\ndef run_as_real_user(args: list[str]) -> None:\n    \"\"\"Call subprocess.run as real user if called via sudo/pkexec.\n\n    If we are called through pkexec/sudo, determine the real user ID and\n    run the command with it to get the user's web browser settings.\n    \"\"\"\n    uid = _get_env_int(\"SUDO_UID\", _get_env_int(\"PKEXEC_UID\"))\n    if uid is None or not get_process_user_and_group().is_root():\n        subprocess.run(args, check=False)\n        return\n\n    pwuid = pwd.getpwuid(uid)\n\n    gid = _get_env_int(\"SUDO_GID\")\n    if gid is None:\n        gid = pwuid.pw_gid\n\n    env = {\n        k: v\n        for k, v in os.environ.items()\n        if not k.startswith(\"SUDO_\") and k != \"PKEXEC_UID\"\n    } | _get_users_environ(uid)\n    env[\"HOME\"] = pwuid.pw_dir\n    subprocess.run(\n        args,\n        check=False,\n        env=env,\n        user=uid,\n        group=gid,\n        extra_groups=os.getgrouplist(pwuid.pw_name, gid),\n    )\n\n\ndef still_running(pid):\n    try:\n        os.kill(int(pid), 0)\n    except OSError as error:\n        if error.errno == errno.ESRCH:\n            return False\n    return True\n\n\ndef thread_collect_info(\n    report,\n    reportfile,\n    package,\n    ui,\n    symptom_script=None,\n    ignore_uninstalled=False,\n):\n    \"\"\"Collect information about report.\n\n    Encapsulate calls to add_*_info() and update given report, so that this\n    function is suitable for threading.\n\n    ui must be a HookUI instance, it gets passed to add_hooks_info().\n\n    If reportfile is not None, the file is written back with the new data.\n\n    If symptom_script is given, it will be run first (for run_symptom()).\n    \"\"\"\n    assert isinstance(ui, HookUI)\n    try:\n        report.add_gdb_info()\n    except OSError:\n        # it's okay if gdb is not installed on the client side; we'll get stack\n        # traces on retracing.\n        pass\n    report.add_os_info()\n\n    if symptom_script:\n        symb = {}\n        try:\n            with open(symptom_script, encoding=\"utf-8\") as f:\n                # legacy, pylint: disable=exec-used\n                exec(compile(f.read(), symptom_script, \"exec\"), symb)\n            package = symb[\"run\"](report, ui)\n            if not package:\n                apport.logging.error(\n                    \"symptom script %s did not determine the affected package\",\n                    symptom_script,\n                )\n                return\n            report[\"Symptom\"] = os.path.splitext(\n                os.path.basename(symptom_script)\n            )[0]\n        except StopIteration:\n            sys.exit(0)\n        except Exception:  # pylint: disable=broad-except\n            apport.logging.error(\"symptom script %s crashed:\", symptom_script)\n            traceback.print_exc()\n            sys.exit(0)\n\n    if not package:\n        if \"ExecutablePath\" in report:\n            package = apport.fileutils.find_file_package(\n                report[\"ExecutablePath\"]\n            )\n        else:\n            raise KeyError(\n                \"called without a package,\"\n                \" and report does not have ExecutablePath\"\n            )\n\n    # check if the package name relates to an installed snap\n    snap = apport.fileutils.find_snap(package)\n    if snap:\n        report.add_snap_info(snap)\n\n    try:\n        report.add_package_info(package)\n    except ValueError:\n        # this happens if we are collecting information on an uninstalled\n        # package\n\n        # we found no package, but a snap, so lets continue\n        if not ignore_uninstalled and \"Snap\" not in report:\n            raise\n    except SystemError as error:\n        report[\"UnreportableReason\"] = str(error)\n\n    if \"UnreportableReason\" not in report:\n        if report.add_hooks_info(ui):\n            sys.exit(0)\n\n        # check package origin; we do that after adding hooks, so that hooks\n        # have the chance to set a third-party CrashDB.\n        try:\n            if (\n                \"CrashDB\" not in report\n                and \"APPORT_DISABLE_DISTRO_CHECK\" not in os.environ\n            ):\n                if \"Package\" not in report and \"Snap\" not in report:\n                    report[\"UnreportableReason\"] = _(\n                        \"This package does not seem to be installed correctly\"\n                    )\n                elif not packaging.is_distro_package(\n                    report[\"Package\"].split()[0]\n                ) and not packaging.is_native_origin_package(\n                    report[\"Package\"].split()[0]\n                ):\n                    # TRANS: %s is the name of the operating system\n                    report[\"UnreportableReason\"] = (\n                        _(\n                            \"This does not seem to be an official %s package.\"\n                            \" Please retry after updating the indexes of\"\n                            \" available packages, if that does not work\"\n                            \" then remove related third party packages\"\n                            \" and try again.\"\n                        )\n                        % report[\"DistroRelease\"].split()[0]\n                    )\n        except ValueError:\n            # this happens if we are collecting information on an uninstalled\n            # package\n\n            # we found no package, but a snap, so lets continue\n            if not ignore_uninstalled and \"Snap\" not in report:\n                raise\n\n    # add title\n    if \"Title\" not in report:\n        title = report.standard_title()\n        if title:\n            report[\"Title\"] = title\n\n    # check obsolete packages\n    if (\n        report.get(\"ProblemType\") == \"Crash\"\n        and \"APPORT_IGNORE_OBSOLETE_PACKAGES\" not in os.environ\n    ):\n        old_pkgs = report.obsolete_packages()\n        if old_pkgs:\n            report[\"UnreportableReason\"] = _(\n                \"You have some obsolete package versions installed.\"\n                \" Please upgrade the following packages\"\n                \" and check if the problem still occurs:\\n\\n%s\"\n            ) % \", \".join(old_pkgs)\n\n    if reportfile:\n        try:\n            with open(reportfile, \"ab\") as f:\n                os.chmod(reportfile, 0)\n                report.write(f, only_new=True)\n        except OSError as error:\n            # this should happen very rarely; presumably a new crash report is\n            # being generated by a background apport instance (which will set\n            # the file to permissions zero while writing), while the first\n            # report is being processed\n            apport.logging.error(\"Cannot update %s: %s\", reportfile, error)\n\n        apport.fileutils.mark_report_seen(reportfile)\n        os.chmod(reportfile, 0o640)\n\n\n@dataclasses.dataclass\nclass Action:\n    examine: bool = False\n    ignore: bool = False\n    remember: bool = False\n    report: bool = False\n    restart: bool = False\n\n\nclass UserInterface:\n    \"\"\"Apport user interface API.\n\n    This provides an abstract base class for encapsulating the workflow and\n    common code for any user interface implementation (like GTK, Qt, or CLI).\n\n    A concrete subclass must implement all the abstract ui_* methods.\n    \"\"\"\n\n    def __init__(self, argv: list[str]):\n        \"\"\"Initialize program state and parse command line options.\"\"\"\n        self.gettext_domain = \"apport\"\n        self.report = None\n        self.report_file = None\n        self.cur_package = None\n        self.offer_restart = False\n        self.specified_a_pkg = False\n        self.upload_progress = None\n\n        try:\n            self.crashdb = apport.crashdb.get_crashdb(None)\n        except ImportError as error:\n            # this can happen while upgrading python packages\n            apport.logging.fatal(\n                \"Could not import module, is a package upgrade in progress?\"\n                \" Error: %s\",\n                str(error),\n            )\n        except KeyError:\n            apport.logging.fatal(\n                \"/etc/apport/crashdb.conf is damaged: No default database\"\n            )\n\n        gettext.textdomain(self.gettext_domain)\n        self.args = self.parse_argv(argv)\n\n    #\n    # main entry points\n    #\n\n    def run_crashes(self):\n        \"\"\"Present all currently pending crash reports.\n\n        Ask the user what to do about them, and offer to file bugs for them.\n\n        Crashes that occurred in a different desktop (logind) session than the\n        one that is currently running are not processed. This skips crashes\n        that happened during logout, which are uninteresting and confusing to\n        see at the next login.\n\n        Return True if at least one crash report was processed, False\n        otherwise.\n        \"\"\"\n        result = False\n        # for iterating over /var/crash (as opposed to running on or clicking\n        # on a particular .crash file) we offer restarting\n        self.offer_restart = True\n\n        if os.geteuid() == 0:\n            reports = apport.fileutils.get_new_system_reports()\n            logind_session = None\n        else:\n            reports = apport.fileutils.get_new_reports()\n            proc_pid_fd = os.open(\n                \"/proc/%s\" % os.getpid(),\n                os.O_RDONLY | os.O_PATH | os.O_DIRECTORY,\n            )\n            logind_session = apport.Report.get_logind_session(\n                proc_pid_fd=proc_pid_fd\n            )\n\n        for f in reports:\n            if not self.load_report(f):\n                continue\n\n            # Skip crashes that happened during logout, which are uninteresting\n            # and confusing to see at the next login. A crash happened and gets\n            # reported in the same session if the logind session paths agree\n            # and the session started before the report's \"Date\".\n            if (\n                logind_session\n                and \"_LogindSession\" in self.report\n                and \"Date\" in self.report\n            ):\n                # report.get_timestamp() can return None\n                if not self.report.get_timestamp():\n                    continue\n                if (\n                    logind_session[0] != self.report[\"_LogindSession\"]\n                    or logind_session[1] > self.report.get_timestamp()\n                ):\n                    continue\n\n            if self.report[\"ProblemType\"] == \"Hang\":\n                self.finish_hang(f)\n            else:\n                self.run_crash(f)\n            result = True\n\n        return result\n\n    def run_crash(self, report_file):\n        \"\"\"Present and report a particular crash.\n\n        If confirm is True, ask the user what to do about it, and offer to file\n        a bug for it.\n\n        If confirm is False, the user will not be asked, and the crash is\n        reported right away.\n        \"\"\"\n        self.report_file = report_file\n\n        try:\n            try:\n                apport.fileutils.mark_report_seen(report_file)\n            except OSError:\n                # not there any more? no problem, then it won't be regarded as\n                # \"seen\" any more anyway\n                pass\n            if not self.report and not self.load_report(report_file):\n                return\n\n            if \"Ignore\" in self.report:\n                return\n\n            # check for absent CoreDumps (removed if they exceed size limit)\n            if (\n                self.report.get(\"ProblemType\") == \"Crash\"\n                and \"Signal\" in self.report\n                and \"CoreDump\" not in self.report\n                and \"Stacktrace\" not in self.report\n            ):\n                subject = os.path.basename(\n                    self.report.get(\"ExecutablePath\", _(\"unknown program\"))\n                )\n                heading = (\n                    _('Sorry, the program \"%s\" closed unexpectedly') % subject\n                )\n                self.ui_error_message(\n                    _(\"Problem in %s\") % subject,\n                    \"%s\\n\\n%s\"\n                    % (\n                        heading,\n                        _(\n                            \"Your computer does not have enough free \"\n                            \"memory to automatically analyze the problem \"\n                            \"and send a report to the developers.\"\n                        ),\n                    ),\n                )\n                return\n\n            allowed_to_report = apport.fileutils.allowed_to_report()\n            response = self.ui_present_report_details(allowed_to_report)\n            if response.report or response.examine:\n                if \"Dependencies\" not in self.report:\n                    self.collect_info()\n\n            if self.report is None:\n                # collect() does that on invalid reports\n                return\n\n            if response.examine:\n                self.examine()\n                return\n            if response.restart:\n                self.restart()\n            if response.ignore:\n                self.report.mark_ignore()\n            try:\n                if response.remember:\n                    self.remember_send_report(response.report)\n            # use try/expect for python2 support. Old reports (generated\n            # pre-apport 2.20.10-0ubuntu4) may not have the remember key\n            # and can be loaded afterwards (or after dist-upgrade)\n            except KeyError:\n                pass\n            if not response.report:\n                return\n\n            # We don't want to send crashes to the crash database for binaries\n            # that changed since the crash happened. See LP: #1039220 for\n            # details.\n            if (\n                \"_MarkForUpload\" in self.report\n                and self.report[\"_MarkForUpload\"] != \"False\"\n            ):\n                apport.fileutils.mark_report_upload(report_file)\n            # We check for duplicates and unreportable crashes here, rather\n            # than before we show the dialog, as we want to submit these to the\n            # crash database, but not Launchpad.\n            if self.crashdb.accepts(self.report):\n                # FIXME: This behaviour is not really correct, but necessary as\n                # long as we only support a single crashdb and have whoopsie\n                # hardcoded. Once we have multiple crash dbs, we need to check\n                # accepts() earlier, and not even present the data if none of\n                # the DBs wants the report. See LP#957177 for details.\n                if self.handle_duplicate():\n                    return\n                if self.check_unreportable():\n                    return\n                self.file_report()\n        except PermissionError:\n            self.ui_error_message(\n                _(\"Invalid problem report\"),\n                _(\"You are not allowed to access this problem report.\"),\n            )\n            sys.exit(1)\n        except OSError as error:\n            if error.errno == errno.ENOMEM:\n                apport.logging.fatal(\"Out of memory, aborting\")\n            elif error.errno == errno.ENOSPC:\n                self.ui_error_message(\n                    _(\"Error\"),\n                    _(\n                        \"There is not enough disk space\"\n                        \" available to process this report.\"\n                    ),\n                )\n                sys.exit(1)\n            elif error.errno == errno.EIO:\n                self.ui_error_message(\n                    _(\"Invalid problem report\"), error.strerror\n                )\n                sys.exit(1)\n            raise\n\n    @staticmethod\n    def finish_hang(f):\n        \"\"\"Finish processing a hanging application after the core pipe handler\n        has handed the report back.\n\n        This will signal to whoopsie that the report needs to be uploaded.\n        \"\"\"\n        apport.fileutils.mark_report_upload(f)\n        apport.fileutils.mark_report_seen(f)\n\n    def run_hang(self, pid):\n        \"\"\"Report an application hanging.\n\n        This will first present a dialog containing the information it can\n        collect from the running application (everything but the trace) with\n        the option of terminating or restarting the application, optionally\n        reporting that this error occurred.\n\n        A SIGABRT will then be sent to the process and a series of\n        noninteractive processes will collect the remaining information and\n        mark the report for uploading.\n        \"\"\"\n        self.report = apport.Report(\"Hang\")\n\n        if not self.args.pid:\n            self.ui_error_message(\n                _(\"No PID specified\"),\n                _(\n                    \"You need to specify a PID.\"\n                    \" See --help for more information.\"\n                ),\n            )\n            return False\n\n        try:\n            self.report.add_proc_info(pid)\n        except ValueError as error:\n            if str(error) == \"invalid process\":\n                self.ui_error_message(\n                    _(\"Invalid PID\"),\n                    _(\"The specified process ID does not exist.\"),\n                )\n                sys.exit(1)\n            elif str(error) == \"not accessible\":\n                self.ui_error_message(\n                    _(\"Not your PID\"),\n                    _(\"The specified process ID does not belong to you.\"),\n                )\n                sys.exit(1)\n        self.report.add_package_info()\n        path = self.report.get(\"ExecutablePath\", \"\")\n        self.cur_package = apport.fileutils.find_file_package(path)\n        self.report.add_os_info()\n        allowed_to_report = apport.fileutils.allowed_to_report()\n        response = self.ui_present_report_details(\n            allowed_to_report, modal_for=pid\n        )\n        if response.report:\n            apport.fileutils.mark_hanging_process(self.report, pid)\n            os.kill(int(pid), signal.SIGABRT)\n        else:\n            os.kill(int(pid), signal.SIGKILL)\n\n        if response.restart:\n            self.wait_for_pid(pid)\n            self.restart()\n        return True\n\n    @staticmethod\n    def wait_for_pid(pid):\n        \"\"\"waitpid() does not work for non-child processes. Query the process\n        state in a loop, waiting for \"no such process.\"\n        \"\"\"\n        while True:\n            try:\n                os.kill(int(pid), 0)\n            except OSError as error:\n                if error.errno == errno.ESRCH:\n                    break\n                raise\n            time.sleep(1)\n\n    @staticmethod\n    def kill_segv(pid):\n        os.kill(int(pid), signal.SIGSEGV)\n\n    def run_report_bug(self, symptom_script=None):\n        \"\"\"Report a bug.\n\n        If a pid is given on the command line, the report will contain runtime\n        debug information. Either a package or a pid must be specified; if none\n        is given, show a list of symptoms.\n\n        If a symptom script is given, this will be run first (used by\n        run_symptom()).\n        \"\"\"\n        if not self.args.package and not self.args.pid and not symptom_script:\n            if self.run_symptoms():\n                return True\n\n            self.ui_error_message(\n                _(\"No package specified\"),\n                _(\n                    \"You need to specify a package or a PID.\"\n                    \" See --help for more information.\"\n                ),\n            )\n            return False\n\n        self.report = apport.Report(\"Bug\")\n\n        # if PID is given, add info\n        if self.args.pid:\n            try:\n                proc_pid_fd = os.open(\n                    \"/proc/%s\" % self.args.pid,\n                    os.O_RDONLY | os.O_PATH | os.O_DIRECTORY,\n                )\n                stat_file = os.open(\"stat\", os.O_RDONLY, dir_fd=proc_pid_fd)\n                with io.open(stat_file, encoding=\"utf-8\") as f:\n                    stat = f.read().split()\n                flags = int(stat[8])\n                if flags & PF_KTHREAD:\n                    # this PID is a kernel thread\n                    self.args.package = \"linux\"\n                else:\n                    self.report.add_proc_info(\n                        pid=self.args.pid, proc_pid_fd=proc_pid_fd\n                    )\n            except PermissionError:\n                self.ui_error_message(\n                    _(\"Permission denied\"),\n                    _(\n                        \"The specified process does not belong to you. Please\"\n                        \" run this program as the process owner or as root.\"\n                    ),\n                )\n                return False\n            except (ValueError, OSError) as error:\n                if getattr(error, \"errno\", None) == errno.ENOENT:\n                    # silently ignore nonexisting PIDs; the user must not\n                    # close the application prematurely\n                    return False\n                self.ui_error_message(\n                    _(\"Invalid PID\"),\n                    _(\n                        \"The specified process ID does not belong\"\n                        \" to a program.\"\n                    ),\n                )\n                return False\n        else:\n            self.report.add_proc_environ()\n\n        if self.args.package:\n            self.args.package = self.args.package.strip()\n        # \"Do what I mean\" for filing against \"linux\"\n        if self.args.package == \"linux\":\n            self.cur_package = packaging.get_kernel_package()\n        else:\n            self.cur_package = self.args.package\n\n        try:\n            self.collect_info(symptom_script)\n        except ValueError as error:\n            if \"package\" in str(error) and \"does not exist\" in str(error):\n                if not self.cur_package:\n                    self.ui_error_message(\n                        _(\"Invalid problem report\"),\n                        _(\n                            \"Symptom script %s did not determine\"\n                            \" an affected package\"\n                        )\n                        % symptom_script,\n                    )\n                else:\n                    self.ui_error_message(\n                        _(\"Invalid problem report\"),\n                        _(\"Package %s does not exist\") % self.cur_package,\n                    )\n                return False\n            raise\n\n        if self.check_unreportable():\n            return False\n\n        self.add_extra_tags()\n\n        if self.handle_duplicate():\n            return True\n\n        # not useful for bug reports, and has potentially sensitive information\n        try:\n            del self.report[\"ProcCmdline\"]\n        except KeyError:\n            pass\n\n        if self.args.save:\n            try:\n                savefile = os.path.expanduser(self.args.save)\n                if savefile.endswith(\".gz\"):\n                    with gzip.open(savefile, \"wb\") as f:\n                        self.report.write(f)\n                else:\n                    with open(os.path.expanduser(self.args.save), \"wb\") as f:\n                        self.report.write(f)\n            except OSError as error:\n                self.ui_error_message(_(\"Cannot create report\"), str(error))\n        else:\n            # show what's being sent\n            allowed_to_report = True\n            response = self.ui_present_report_details(allowed_to_report)\n            if response.report:\n                self.file_report()\n\n        return True\n\n    def run_update_report(self):\n        \"\"\"Update an existing bug with locally collected information.\"\"\"\n        # avoid irrelevant noise\n        if not self.crashdb.can_update(self.args.update_report):\n            self.ui_error_message(\n                _(\"Updating problem report\"),\n                _(\n                    \"You are not the reporter or subscriber of this \"\n                    \"problem report, or the report is a duplicate or already \"\n                    'closed.\\n\\nPlease create a new report using \"apport-bug\".'\n                ),\n            )\n            return False\n\n        is_reporter = self.crashdb.is_reporter(self.args.update_report)\n\n        if not is_reporter:\n            r = self.ui_question_yesno(\n                _(\n                    \"You are not the reporter of this problem report. It is \"\n                    \"much easier to mark a bug as a duplicate of another than \"\n                    \"to move your comments and attachments to a new bug.\\n\\n\"\n                    \"Subsequently, we recommend that you file a new bug \"\n                    'report using \"apport-bug\" and make a comment in this bug '\n                    \"about the one you file.\\n\\nDo you really want to proceed?\"\n                )\n            )\n            if not r:\n                return False\n\n        # list of affected source packages\n        self.report = apport.Report(\"Bug\")\n        if self.args.package:\n            pkgs = [self.args.package.strip()]\n        else:\n            pkgs = self.crashdb.get_affected_packages(self.args.update_report)\n\n        info_collected = False\n        for p in pkgs:\n            # print(f\"Collecting apport information for source package {p}...\")\n            self.cur_package = p\n            self.report[\"SourcePackage\"] = p\n            self.report[\"Package\"] = p  # no way to find this out\n\n            # we either must have the package installed or a source package\n            # hook available to collect sensible information\n            try:\n                packaging.get_version(p)\n            except ValueError:\n                if not os.path.exists(\n                    os.path.join(\n                        apport.report.PACKAGE_HOOK_DIR, \"source_%s.py\" % p\n                    )\n                ):\n                    print(\n                        \"Package %s not installed and no hook available,\"\n                        \" ignoring\" % p\n                    )\n                    continue\n            self.collect_info(ignore_uninstalled=True)\n            info_collected = True\n\n        if not info_collected:\n            self.ui_info_message(\n                _(\"Updating problem report\"),\n                _(\"No additional information collected.\"),\n            )\n            return False\n\n        self.report.add_user_info()\n        self.report.add_proc_environ()\n        self.add_extra_tags()\n\n        # delete the uninteresting keys\n        del self.report[\"Date\"]\n        try:\n            del self.report[\"SourcePackage\"]\n        except KeyError:\n            pass\n\n        if len(self.report) == 0:\n            self.ui_info_message(\n                _(\"Updating problem report\"),\n                _(\"No additional information collected.\"),\n            )\n            return False\n\n        # show what's being sent\n        allowed_to_report = True\n        response = self.ui_present_report_details(allowed_to_report)\n        if response.report:\n            self.crashdb.update(\n                self.args.update_report,\n                self.report,\n                \"apport information\",\n                change_description=is_reporter,\n                attachment_comment=\"apport information\",\n            )\n            return True\n\n        return False\n\n    def run_symptoms(self):\n        \"\"\"Report a bug from a list of available symptoms.\n\n        Return False if no symptoms are available.\n        \"\"\"\n        scripts = glob.glob(os.path.join(symptom_script_dir, \"*.py\"))\n\n        symptom_names = []\n        symptom_descriptions = []\n        for script in scripts:\n            # scripts with an underscore can be used for private libraries\n            if os.path.basename(script).startswith(\"_\"):\n                continue\n            symb = {}\n            try:\n                with open(script, encoding=\"utf-8\") as f:\n                    # legacy, pylint: disable=exec-used\n                    exec(compile(f.read(), script, \"exec\"), symb)\n            except Exception:  # pylint: disable=broad-except\n                apport.logging.error(\"symptom script %s is invalid\", script)\n                traceback.print_exc()\n                continue\n            if \"run\" not in symb:\n                apport.logging.error(\n                    \"symptom script %s does not define run() function\", script\n                )\n                continue\n            symptom_names.append(os.path.splitext(os.path.basename(script))[0])\n            symptom_descriptions.append(\n                symb.get(\"description\", symptom_names[-1])\n            )\n\n        if not symptom_names:\n            return False\n\n        symptom_descriptions, symptom_names = zip(\n            *sorted(zip(symptom_descriptions, symptom_names))\n        )\n        symptom_descriptions = list(symptom_descriptions)\n        symptom_names = list(symptom_names)\n        symptom_names.append(None)\n        symptom_descriptions.append(\"Other problem\")\n\n        ch = self.ui_question_choice(\n            _(\"What kind of problem do you want to report?\"),\n            symptom_descriptions,\n            False,\n        )\n\n        if ch is not None:\n            symptom = symptom_names[ch[0]]\n            if symptom:\n                self.run_report_bug(\n                    os.path.join(symptom_script_dir, symptom + \".py\")\n                )\n            else:\n                return False\n\n        return True\n\n    def run_symptom(self):\n        \"\"\"Report a bug with a symptom script.\"\"\"\n        script = os.path.join(symptom_script_dir, self.args.symptom + \".py\")\n        if not os.path.exists(script):\n            self.ui_error_message(\n                _(\"Unknown symptom\"),\n                _('The symptom \"%s\" is not known.') % self.args.symptom,\n            )\n            return\n\n        self.run_report_bug(script)\n\n    def run_argv(self):\n        \"\"\"Call appopriate run_* method according to command line arguments.\n\n        Return True if at least one report has been processed, and False\n        otherwise.\n        \"\"\"\n        if self.args.symptom:\n            self.run_symptom()\n            return True\n        if self.args.hanging:\n            self.run_hang(self.args.pid)\n            return True\n        if self.args.filebug:\n            return self.run_report_bug()\n        if self.args.update_report is not None:\n            return self.run_update_report()\n        if self.args.version:\n            print(__version__)\n            return True\n        if self.args.crash_file:\n            try:\n                self.run_crash(self.args.crash_file)\n            except OSError as error:\n                self.ui_error_message(_(\"Invalid problem report\"), str(error))\n            return True\n        if self.args.window:\n            if os.getenv(\"XDG_SESSION_TYPE\") == \"wayland\":\n                self.ui_error_message(\n                    _(\"Cannot create report\"),\n                    _(\n                        \"The window option cannot be used on \"\n                        \"Wayland.\\n\\nPlease find the window's \"\n                        \"process ID and then run 'ubuntu-bug \"\n                        \"<process ID>'.\"\n                        \"\\n\\nThe process ID can be found \"\n                        \"by running the System Monitor application. \"\n                        \"In the Processes tab, scroll until you \"\n                        \"find the correct application. The process \"\n                        \"ID is the number listed in the ID column.\"\n                    ),\n                )\n                return True\n\n            self.ui_info_message(\n                \"\",\n                _(\n                    \"After closing this message please click on an\"\n                    \" application window to report a problem about it.\"\n                ),\n            )\n            xprop = subprocess.run(\n                [\"xprop\", \"_NET_WM_PID\"],\n                check=False,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n            )\n            if xprop.returncode == 0:\n                try:\n                    self.args.pid = int(xprop.stdout.split()[-1])\n                except ValueError:\n                    self.ui_error_message(\n                        _(\"Cannot create report\"),\n                        _(\n                            \"xprop failed to determine\"\n                            \" process ID of the window\"\n                        ),\n                    )\n                    return True\n                return self.run_report_bug()\n\n            self.ui_error_message(\n                _(\"Cannot create report\"),\n                _(\"xprop failed to determine process ID of the window\")\n                + \"\\n\\n\"\n                + xprop.stderr.decode(),\n            )\n            return True\n\n        return self.run_crashes()\n\n    #\n    # methods that implement workflow bits\n    #\n\n    @staticmethod\n    def parse_argv_update(argv: typing.Sequence[str]) -> argparse.Namespace:\n        \"\"\"Parse command line options when being invoked in update mode.\"\"\"\n        parser = argparse.ArgumentParser(usage=_(\"%(prog)s <report number>\"))\n        parser.add_argument(\"-p\", \"--package\", help=_(\"Specify package name.\"))\n        parser.add_argument(\n            \"--tag\",\n            action=\"append\",\n            default=[],\n            dest=\"tags\",\n            help=_(\n                \"Add an extra tag to the report.\"\n                \" Can be specified multiple times.\"\n            ),\n        )\n        parser.add_argument(\"update_report\", metavar=\"report_number\", type=int)\n        args = parser.parse_args(argv[1:])\n\n        args.symptom = None\n        args.filebug = False\n        args.crash_file = None\n        args.version = False\n        args.hanging = False\n        return args\n\n    def parse_argv(self, argv: list[str]) -> argparse.Namespace:\n        \"\"\"Parse command line options.\n\n        If a single argument is given without any options, this tries to \"do\n        what I mean\".\n        \"\"\"\n        # invoked in update mode?\n        if len(argv) > 0:\n            if \"APPORT_INVOKED_AS\" in os.environ:\n                argv[0] = os.path.join(\n                    os.path.dirname(argv[0]),\n                    os.path.basename(os.environ[\"APPORT_INVOKED_AS\"]),\n                )\n            cmd = argv[0]\n            if cmd.endswith(\"-update-bug\") or cmd.endswith(\"-collect\"):\n                return self.parse_argv_update(argv)\n\n        if len(argv) > 0 and cmd.endswith(\"-bug\"):\n            suppress = argparse.SUPPRESS\n        else:\n            suppress = None\n\n        parser = argparse.ArgumentParser(\n            usage=_(\n                \"%(prog)s [options]\"\n                \" [symptom|pid|package|program path|.apport/.crash file]\"\n            )\n        )\n        parser.add_argument(\n            \"-f\",\n            \"--file-bug\",\n            action=\"store_true\",\n            dest=\"filebug\",\n            help=suppress\n            or _(\n                \"Start in bug filing mode. Requires --package and an optional\"\n                \" --pid, or just a --pid. If neither is given, display a list\"\n                \" of known symptoms. (Implied if a single argument is given.)\"\n            ),\n        )\n        parser.add_argument(\n            \"-w\",\n            \"--window\",\n            action=\"store_true\",\n            help=_(\"Click a window as a target for filing a problem report.\"),\n        )\n        parser.add_argument(\n            \"-u\",\n            \"--update-bug\",\n            type=int,\n            dest=\"update_report\",\n            help=suppress\n            or _(\n                \"Start in bug updating mode. Can take an optional --package.\"\n            ),\n        )\n        parser.add_argument(\n            \"-s\",\n            \"--symptom\",\n            metavar=\"SYMPTOM\",\n            help=suppress\n            or _(\n                \"File a bug report about a symptom. (Implied if symptom name\"\n                \" is given as only argument.)\"\n            ),\n        )\n        parser.add_argument(\n            \"-p\",\n            \"--package\",\n            help=suppress\n            or _(\n                \"Specify package name in --file-bug mode. This is optional\"\n                \" if a --pid is specified. (Implied if package name\"\n                \" is given as only argument.)\"\n            ),\n        )\n        parser.add_argument(\n            \"-P\",\n            \"--pid\",\n            type=int,\n            help=suppress\n            or _(\n                \"Specify a running program in --file-bug mode. If this is\"\n                \" specified, the bug report will contain more information.\"\n                \"  (Implied if pid is given as only argument.)\"\n            ),\n        )\n        parser.add_argument(\n            \"--hanging\",\n            action=\"store_true\",\n            help=_(\"The provided pid is a hanging application.\"),\n        )\n        parser.add_argument(\n            \"-c\",\n            \"--crash-file\",\n            metavar=\"PATH\",\n            help=suppress\n            or _(\n                \"Report the crash from given .apport or .crash file\"\n                \" instead of the pending ones in %s.\"\n                \" (Implied if file is given as only argument.)\"\n            )\n            % apport.fileutils.report_dir,\n        )\n        parser.add_argument(\n            \"--save\",\n            metavar=\"PATH\",\n            help=_(\n                \"In bug filing mode, save the collected information into\"\n                \" a file instead of reporting it. This file can then be\"\n                \" reported later on from a different machine.\"\n            ),\n        )\n        parser.add_argument(\n            \"--tag\",\n            action=\"append\",\n            default=[],\n            dest=\"tags\",\n            help=_(\n                \"Add an extra tag to the report.\"\n                \" Can be specified multiple times.\"\n            ),\n        )\n        parser.add_argument(\n            \"-v\",\n            \"--version\",\n            action=\"store_true\",\n            help=_(\"Print the Apport version number.\"),\n        )\n        parser.add_argument(\"issue\", nargs=\"?\", help=argparse.SUPPRESS)\n\n        args = parser.parse_args(argv[1:])\n        issue = args.issue\n        del args.issue\n\n        # mutually exclusive arguments\n        if args.update_report:\n            args_only_for_new_reports = [\n                args.filebug,\n                args.window,\n                args.symptom,\n                args.pid,\n                args.crash_file,\n                args.save,\n            ]\n            if any(args_only_for_new_reports):\n                parser.error(\n                    \"-u/--update-bug option cannot be used together\"\n                    \" with options for a new report\"\n                )\n\n        # no argument: default to \"show pending crashes\" except when called in\n        # bug mode\n        # NOTE: uses argv, since args if empty for all the options,\n        # e.g. \"-v\" or \"-u $BUG\"\n        if len(argv) == 1 and cmd.endswith(\"-bug\"):\n            args.filebug = True\n            return args\n\n        # one argument: guess \"file bug\" mode by argument type\n        if issue is None:\n            return args\n\n        # symptom?\n        if os.path.exists(os.path.join(symptom_script_dir, issue + \".py\")):\n            args.filebug = True\n            args.symptom = issue\n\n        # .crash/.apport file?\n        elif issue.endswith(\".crash\") or issue.endswith(\".apport\"):\n            args.crash_file = issue\n\n        # PID?\n        elif issue.isdigit():\n            args.filebug = True\n            args.pid = issue\n\n        # executable?\n        elif \"/\" in issue:\n            if issue.startswith(\"/snap/bin\"):\n                # see if the snap has the same name as the executable\n                snap = apport.fileutils.find_snap(issue.split(\"/\")[-1])\n                if not snap:\n                    parser.error(\n                        \"%s is provided by a snap. No contact address\"\n                        \" has been provided; visit the forum at\"\n                        \" https://forum.snapcraft.io/ for help.\" % issue\n                    )\n                elif snap.get(\"contact\", \"\"):\n                    parser.error(\n                        \"%s is provided by a snap published by %s.\"\n                        \" Contact them via %s for help.\"\n                        % (issue, snap[\"developer\"], snap[\"contact\"])\n                    )\n                else:\n                    parser.error(\n                        \"%s is provided by a snap published by %s.\"\n                        \" No contact address has been provided; visit the\"\n                        \" forum at https://forum.snapcraft.io/ for help.\"\n                        % (issue, snap[\"developer\"])\n                    )\n                sys.exit(1)\n            else:\n                pkg = packaging.get_file_package(issue)\n                if not pkg:\n                    parser.error(\"%s does not belong to a package.\" % issue)\n                    sys.exit(1)\n            args.filebug = True\n            args.package = pkg\n\n        # otherwise: package name\n        else:\n            args.filebug = True\n            self.specified_a_pkg = True\n            args.package = issue\n\n        return args\n\n    @staticmethod\n    def format_filesize(size):\n        \"\"\"Format the given integer as humanly readable and i18n'ed file\n        size.\"\"\"\n        if size < 1000000:\n            return locale.format_string(\"%.1f KB\", size / 1000.0)\n        if size < 1000000000:\n            return locale.format_string(\"%.1f MB\", size / 1000000.0)\n        return locale.format_string(\"%.1f GB\", size / float(1000000000))\n\n    def get_complete_size(self):\n        \"\"\"Return the size of the complete report.\"\"\"\n        # report wasn't loaded, so count manually\n        size = 0\n        for k in self.report:\n            if self.report[k]:\n                try:\n                    # if we have a compressed value, take its size, but take\n                    # base64 overhead into account\n                    size += len(self.report[k].gzipvalue) * 8 / 6\n                except AttributeError:\n                    size += len(self.report[k])\n        return size\n\n    def get_reduced_size(self):\n        \"\"\"Return the size of the reduced report.\"\"\"\n        size = 0\n        for k in self.report:\n            if k != \"CoreDump\":\n                if self.report[k]:\n                    try:\n                        # if we have a compressed value, take its size,\n                        # but take base64 overhead into account\n                        size += len(self.report[k].gzipvalue) * 8 / 6\n                    except AttributeError:\n                        size += len(self.report[k])\n\n        return size\n\n    def can_examine_locally(self):\n        \"\"\"Check whether to offer the \"Examine locally\" button.\n\n        This will be true if the report has a core dump, apport-retrace is\n        installed and a terminal is available (see ui_has_terminal()).\n        \"\"\"\n        if not self.report or \"CoreDump\" not in self.report:\n            return False\n\n        if shutil.which(\"apport-retrace\") is None:\n            return False\n\n        return self.ui_has_terminal()\n\n    def restart(self):\n        \"\"\"Reopen the crashed application.\"\"\"\n        assert \"ProcCmdline\" in self.report\n\n        if os.fork() == 0:\n            os.setsid()\n            os.execlp(\n                \"sh\",\n                \"sh\",\n                \"-c\",\n                self.report.get(\"RespawnCommand\", self.report[\"ProcCmdline\"]),\n            )\n            sys.exit(1)\n\n    def examine(self):\n        \"\"\"Locally examine crash report.\"\"\"\n        response = self.ui_question_choice(\n            _(\n                \"This will launch apport-retrace in a terminal window\"\n                \" to examine the crash.\"\n            ),\n            [\n                _(\"Run gdb session\"),\n                _(\"Run gdb session without downloading debug symbols\"),\n                # TRANSLATORS: %s contains the crash report file name\n                _(\"Update %s with fully symbolic stack trace\")\n                % self.report_file,\n            ],\n            False,\n        )\n\n        if response is None:\n            return\n\n        retrace_with_download = (\n            \"apport-retrace -S system -C %s -v \"\n            % os.path.expanduser(\"~/.cache/apport/retrace\")\n        )\n        retrace_no_download = \"apport-retrace \"\n        filearg = \"'\" + self.report_file.replace(\"'\", \"'\\\\''\") + \"'\"\n\n        cmds = {\n            0: retrace_with_download + \"--gdb \" + filearg,\n            1: retrace_no_download + \"--gdb \" + filearg,\n            2: retrace_with_download + \"--output \" + filearg + \" \" + filearg,\n        }\n\n        self.ui_run_terminal(cmds[response[0]])\n\n    def remember_send_report(self, send_report):\n        \"\"\"Put whoopsie in auto or never mode.\"\"\"\n        if send_report:\n            send_report = \"true\"\n        else:\n            send_report = \"false\"\n        try:\n            subprocess.check_output(\n                [\n                    \"/usr/bin/gdbus\",\n                    \"call\",\n                    \"-y\",\n                    \"-d\",\n                    \"com.ubuntu.WhoopsiePreferences\",\n                    \"-o\",\n                    \"/com/ubuntu/WhoopsiePreferences\",\n                    \"-m\",\n                    \"com.ubuntu.WhoopsiePreferences.SetReportCrashes\",\n                    send_report,\n                ]\n            )\n            subprocess.check_output(\n                [\n                    \"/usr/bin/gdbus\",\n                    \"call\",\n                    \"-y\",\n                    \"-d\",\n                    \"com.ubuntu.WhoopsiePreferences\",\n                    \"-o\",\n                    \"/com/ubuntu/WhoopsiePreferences\",\n                    \"-m\",\n                    \"com.ubuntu.WhoopsiePreferences\"\n                    \".SetAutomaticallyReportCrashes\",\n                    \"true\",\n                ]\n            )\n        except (OSError, subprocess.CalledProcessError) as error:\n            self.ui_error_message(\n                _(\"Can't remember send report status settings\"),\n                \"%s\\n\\n%s\"\n                % (\n                    _(\n                        \"Saving crash reporting state failed.\"\n                        \" Can't set auto or never reporting mode.\"\n                    ),\n                    str(error),\n                ),\n            )\n\n    def check_report_crashdb(self):\n        \"\"\"Process reports' CrashDB field, if present.\"\"\"\n        if \"CrashDB\" not in self.report:\n            return True\n\n        # specification?\n        if self.report[\"CrashDB\"].lstrip().startswith(\"{\"):\n            try:\n                spec = ast.literal_eval(self.report[\"CrashDB\"])\n                assert isinstance(spec, dict)\n                assert \"impl\" in spec\n            except (AssertionError, SyntaxError, ValueError) as error:\n                self.report[\"UnreportableReason\"] = (\n                    \"A package hook defines an invalid crash database\"\n                    \" definition:\\n%s\\n%s\" % (self.report[\"CrashDB\"], error)\n                )\n                return False\n            try:\n                self.crashdb = apport.crashdb.load_crashdb(None, spec)\n            except (ImportError, KeyError):\n                self.report[\"UnreportableReason\"] = (\n                    \"A package hook wants to send this report to the crash\"\n                    ' database \"%s\" which does not exist.'\n                    % self.report[\"CrashDB\"]\n                )\n\n        else:\n            # DB name\n            try:\n                self.crashdb = apport.crashdb.get_crashdb(\n                    None, self.report[\"CrashDB\"]\n                )\n            except (ImportError, KeyError):\n                self.report[\"UnreportableReason\"] = (\n                    \"A package hook wants to send this report to the crash\"\n                    ' database \"%s\" which does not exist.'\n                    % self.report[\"CrashDB\"]\n                )\n                return False\n\n        return True\n\n    def collect_info(\n        self, symptom_script=None, ignore_uninstalled=False, on_finished=None\n    ):\n        \"\"\"Collect additional information.\n\n        Call all the add_*_info() methods and display a progress dialog during\n        this.\n\n        In particular, this adds OS, package and gdb information and checks bug\n        patterns.\n\n        If a symptom script is given, this will be run first (used by\n        run_symptom()).\n        \"\"\"\n        self.report[\"_MarkForUpload\"] = \"True\"\n\n        # skip if we already ran (we might load a processed report)\n        if (\n            self.report.get(\"ProblemType\") == \"Crash\"\n            and \"Stacktrace\" in self.report\n        ) or (\n            self.report.get(\"ProblemType\") != \"Crash\"\n            and \"Dependencies\" in self.report\n        ):\n            if on_finished:\n                on_finished()\n            return\n\n        # ensure that the crashed program is still installed:\n        if self.report.get(\"ProblemType\") == \"Crash\":\n            exe_path = self.report.get(\"ExecutablePath\", \"\")\n            if not os.path.exists(exe_path):\n                msg = _(\n                    \"This problem report applies to a program\"\n                    \" which is not installed any more.\"\n                )\n                if exe_path:\n                    msg = \"%s (%s)\" % (msg, self.report[\"ExecutablePath\"])\n                self.report[\"UnreportableReason\"] = msg\n                if on_finished:\n                    on_finished()\n                return\n\n            if \"InterpreterPath\" in self.report:\n                if not os.path.exists(self.report[\"InterpreterPath\"]):\n                    msg = _(\n                        \"This problem report applies to a program\"\n                        \" which is not installed any more.\"\n                    )\n                    self.report[\"UnreportableReason\"] = \"%s (%s)\" % (\n                        msg,\n                        self.report[\"InterpreterPath\"],\n                    )\n                    if on_finished:\n                        on_finished()\n                    return\n\n        # check if binary changed since the crash happened\n        if (\n            \"ExecutablePath\" in self.report\n            and \"ExecutableTimestamp\" in self.report\n        ):\n            orig_time = int(self.report[\"ExecutableTimestamp\"])\n            del self.report[\"ExecutableTimestamp\"]\n            cur_time = int(os.stat(self.report[\"ExecutablePath\"]).st_mtime)\n\n            if orig_time != cur_time:\n                self.report[\"_MarkForUpload\"] = \"False\"\n                self.report[\"UnreportableReason\"] = (\n                    _(\n                        \"The problem happened with the program %s\"\n                        \" which changed since the crash occurred.\"\n                    )\n                    % self.report[\"ExecutablePath\"]\n                )\n                return\n\n        if (\n            not self.cur_package\n            and \"ExecutablePath\" not in self.report\n            and not symptom_script\n        ):\n            # this happens if we file a bug without specifying a PID or a\n            # package\n            self.report.add_os_info()\n        else:\n            # since this might take a while, create separate threads and\n            # display a progress dialog.\n            self.ui_start_info_collection_progress()\n            # only use a UI for asking questions if the crash db will accept\n            # the report\n            if self.crashdb.accepts(self.report):\n                hookui = HookUI(self)\n            else:\n                hookui = NoninteractiveHookUI()\n\n            if \"Stacktrace\" not in self.report:\n                # save original environment, in case hooks change it\n                orig_env = os.environ.copy()\n                icthread = apport.REThread.REThread(\n                    target=thread_collect_info,\n                    name=\"thread_collect_info\",\n                    args=(\n                        self.report,\n                        self.report_file,\n                        self.cur_package,\n                        hookui,\n                        symptom_script,\n                        ignore_uninstalled,\n                    ),\n                )\n                icthread.start()\n                while icthread.is_alive():\n                    self.ui_pulse_info_collection_progress()\n                    try:\n                        hookui.process_event()\n                    except KeyboardInterrupt:\n                        sys.exit(1)\n\n                icthread.join()\n\n                # restore original environment\n                os.environ.clear()\n                os.environ.update(orig_env)\n\n                try:\n                    icthread.exc_raise()\n                except (OSError, EOFError, zlib.error) as error:\n                    # can happen with broken core dumps\n                    self.report[\"UnreportableReason\"] = \"%s\\n\\n%s\" % (\n                        _(\n                            \"This problem report is damaged\"\n                            \" and cannot be processed.\"\n                        ),\n                        repr(error),\n                    )\n                    self.report[\"_MarkForUpload\"] = \"False\"\n                except ValueError:  # package does not exist\n                    if \"UnreportableReason\" not in self.report:\n                        self.report[\"UnreportableReason\"] = _(\n                            \"This report is about a package\"\n                            \" that is not installed.\"\n                        )\n                        self.report[\"_MarkForUpload\"] = \"False\"\n                except Exception as error:  # pylint: disable=broad-except\n                    apport.logging.error(\"%s\", repr(error))\n                    self.report[\"UnreportableReason\"] = (\n                        _(\n                            \"An error occurred while attempting to \"\n                            \"process this problem report:\"\n                        )\n                        + \"\\n\\n\"\n                        + str(error)\n                    )\n                    self.report[\"_MarkForUpload\"] = \"False\"\n\n            # ask for target, if snap and deb package are installed\n            if \"Snap\" in self.report and \"Package\" in self.report:\n                if \"(not installed)\" in self.report[\"Package\"]:\n                    # choose snap automatically, if deb package\n                    # is not installed\n                    res = [0]\n                else:\n                    res = self.ui_question_choice(\n                        _(\n                            \"You have two versions of this application\"\n                            \" installed, which one do you want to report\"\n                            \" a bug against?\"\n                        ),\n                        [\n                            _(\"%s snap\") % self.report[\"Snap\"],\n                            _(\"%s deb package\") % self.report[\"Package\"],\n                        ],\n                        False,\n                    )\n                # bug report is about the snap, clean deb package info\n                if res == [0]:\n                    del self.report[\"Package\"]\n                    if \"PackageArchitecture\" in self.report:\n                        del self.report[\"PackageArchitecture\"]\n                    if \"SourcePackage\" in self.report:\n                        del self.report[\"SourcePackage\"]\n                # bug report is about the deb package, clean snap info\n                elif res == [1]:\n                    del self.report[\"Snap\"]\n                    if \"SnapSource\" in self.report:\n                        del self.report[\"SnapSource\"]\n                    if \"SnapTags\" in self.report:\n                        del self.report[\"SnapTags\"]\n                else:\n                    self.ui_stop_info_collection_progress()\n                    sys.exit(0)\n\n            # append snap tags, if this report is about the snap\n            if \"Snap\" in self.report and \"SnapTags\" in self.report:\n                self.report.add_tags(self.report.pop(\"SnapTags\").split(\" \"))\n\n            # show a hint if we cannot auto report a snap bug via 'SnapSource'\n            if (\n                \"Snap\" in self.report\n                and (\n                    \"SnapSource\" not in self.report\n                    and \"SnapGitName\" not in self.report\n                )\n                and \"UnreportableReason\" not in self.report\n                and self.specified_a_pkg\n            ):\n                snap = apport.fileutils.find_snap(self.cur_package)\n                if snap.get(\"contact\", \"\"):\n                    self.report[\"UnreportableReason\"] = _(\n                        \"%s is provided by a snap published by %s.\"\n                        \" Contact them via %s for help.\"\n                    ) % (snap[\"name\"], snap[\"developer\"], snap[\"contact\"])\n                else:\n                    self.report[\"UnreportableReason\"] = _(\n                        \"%s is provided by a snap published by %s. No contact\"\n                        \" address has been provided; visit the forum\"\n                        \" at https://forum.snapcraft.io/ for help.\"\n                    ) % (snap[\"name\"], snap[\"developer\"])\n                self.report[\"_MarkForUpload\"] = \"False\"\n\n            if (\n                \"UnreportableReason\" in self.report\n                or not self.check_report_crashdb()\n            ):\n                self.ui_stop_info_collection_progress()\n                if on_finished:\n                    on_finished()\n                return\n\n            # check bug patterns\n            if (\n                self.report.get(\"ProblemType\") == \"KernelCrash\"\n                or self.report.get(\"ProblemType\") == \"KernelOops\"\n                or \"Package\" in self.report\n            ):\n                bpthread = apport.REThread.REThread(\n                    target=self.report.search_bug_patterns,\n                    args=(self.crashdb.get_bugpattern_baseurl(),),\n                )\n                bpthread.start()\n                while bpthread.is_alive():\n                    self.ui_pulse_info_collection_progress()\n                    try:\n                        bpthread.join(0.1)\n                    except KeyboardInterrupt:\n                        sys.exit(1)\n                try:\n                    bpthread.exc_raise()\n                except (OSError, EOFError, zlib.error) as error:\n                    # can happen with broken gz values\n                    self.report[\"UnreportableReason\"] = \"%s\\n\\n%s\" % (\n                        _(\n                            \"This problem report is damaged\"\n                            \" and cannot be processed.\"\n                        ),\n                        repr(error),\n                    )\n                if bpthread.return_value():\n                    self.report[\"_KnownReport\"] = bpthread.return_value()\n\n            # check crash database if problem is known\n            if self.report.get(\"ProblemType\") != \"Bug\":\n                known_thread = apport.REThread.REThread(\n                    target=self.crashdb.known, args=(self.report,)\n                )\n                known_thread.start()\n                while known_thread.is_alive():\n                    self.ui_pulse_info_collection_progress()\n                    try:\n                        known_thread.join(0.1)\n                    except KeyboardInterrupt:\n                        sys.exit(1)\n                known_thread.exc_raise()\n                val = known_thread.return_value()\n                if val is not None:\n                    if val is True:\n                        self.report[\"_KnownReport\"] = \"1\"\n                    else:\n                        self.report[\"_KnownReport\"] = val\n\n            # anonymize; needs to happen after duplicate checking, otherwise we\n            # might damage the stack trace\n            anonymize_thread = apport.REThread.REThread(\n                target=self.report.anonymize\n            )\n            anonymize_thread.start()\n            while anonymize_thread.is_alive():\n                self.ui_pulse_info_collection_progress()\n                try:\n                    anonymize_thread.join(0.1)\n                except KeyboardInterrupt:\n                    sys.exit(1)\n            anonymize_thread.exc_raise()\n\n            self.ui_stop_info_collection_progress()\n\n            # check that we were able to determine package names\n            if \"UnreportableReason\" not in self.report:\n                if (\n                    (\n                        \"SourcePackage\" not in self.report\n                        and \"Dependencies\" not in self.report\n                    )\n                    or (\n                        not self.report.get(\"ProblemType\", \"\").startswith(\n                            \"Kernel\"\n                        )\n                        and \"Package\" not in self.report\n                    )\n                ) and not self._is_snap():\n                    self.ui_error_message(\n                        _(\"Invalid problem report\"),\n                        _(\n                            \"Could not determine the package\"\n                            \" or source package name.\"\n                        ),\n                    )\n                    # TODO This is not called consistently,\n                    # is it really needed?\n                    self.ui_shutdown()\n                    sys.exit(1)\n\n        if on_finished:\n            on_finished()\n\n    def _is_snap(self):\n        return \"SnapSource\" in self.report or \"Snap\" in self.report\n\n    def open_url(self, url):\n        \"\"\"Open the given URL in a new browser window.\n\n        Display an error dialog if everything fails.\n        \"\"\"\n        (r, w) = os.pipe()\n        if os.fork() > 0:\n            os.close(w)\n            status = os.wait()[1]\n            if status:\n                title = _(\"Unable to start web browser\")\n                error = _(\"Unable to start web browser to open %s.\" % url)\n                message = os.fdopen(r).readline()\n                if message:\n                    error += \"\\n\" + message\n                self.ui_error_message(title, error)\n            try:\n                os.close(r)\n            except OSError:\n                pass\n            return\n\n        os.setsid()\n        os.close(r)\n\n        try:\n            try:\n                run_as_real_user([\"xdg-open\", url])\n            except OSError:\n                # fall back to webbrowser\n                webbrowser.open(url, new=True, autoraise=True)\n                sys.exit(0)\n        except Exception as error:  # pylint: disable=broad-except\n            os.write(w, str(error))\n            sys.exit(1)\n        os._exit(0)  # pylint: disable=protected-access\n\n    def file_report(self):\n        \"\"\"Upload the current report and guide the user to the reporting\n        web page.\"\"\"\n        # FIXME: This behaviour is not really correct, but necessary as\n        # long as we only support a single crashdb and have whoopsie\n        # hardcoded. Once we have multiple crash dbs, we need to check\n        # accepts() earlier, and not even present the data if none of\n        # the DBs wants the report. See LP#957177 for details.\n        if not self.crashdb.accepts(self.report):\n            return\n        # drop PackageArchitecture if equal to Architecture\n        if self.report.get(\"PackageArchitecture\") == self.report.get(\n            \"Architecture\"\n        ):\n            try:\n                del self.report[\"PackageArchitecture\"]\n            except KeyError:\n                pass\n\n        # StacktraceAddressSignature is redundant and does not need to clutter\n        # the database\n        try:\n            del self.report[\"StacktraceAddressSignature\"]\n        except KeyError:\n            pass\n\n        self.upload_progress = None\n\n        def progress_callback(sent, total):\n            self.upload_progress = float(sent) / total\n\n        message_queue = queue.SimpleQueue()\n\n        def message_callback(title, text):\n            message_displayed = threading.Event()\n            message_queue.put((title, text, message_displayed))\n            message_displayed.wait()\n\n        # drop internal/uninteresting keys, that start with \"_\"\n        for k in list(self.report):\n            if k.startswith(\"_\"):\n                del self.report[k]\n\n        self.ui_start_upload_progress()\n        upthread = apport.REThread.REThread(\n            target=self.crashdb.upload,\n            args=(self.report, progress_callback, message_callback),\n        )\n        upthread.start()\n        try:\n            while upthread.is_alive():\n                self.ui_set_upload_progress(self.upload_progress)\n                try:\n                    title, text, msg_displayed = message_queue.get(\n                        block=True, timeout=0.1\n                    )\n                    self.ui_info_message(title, text)\n                    msg_displayed.set()\n                    upthread.exc_raise()\n                except queue.Empty:\n                    pass\n\n            upthread.exc_raise()\n        except KeyboardInterrupt:\n            sys.exit(1)\n        except (smtplib.SMTPConnectError, urllib.error.URLError) as error:\n            self.ui_error_message(\n                _(\"Network problem\"),\n                \"%s\\n\\n%s\"\n                % (\n                    _(\n                        \"Cannot connect to crash database,\"\n                        \" please check your Internet connection.\"\n                    ),\n                    str(error),\n                ),\n            )\n            return\n\n        ticket = upthread.return_value()\n        self.ui_stop_upload_progress()\n\n        url = self.crashdb.get_comment_url(self.report, ticket)\n        if url:\n            self.open_url(url)\n\n    def load_report(self, path):\n        \"\"\"Load report from given path and do some consistency checks.\n\n        This might issue an error message and return False if the report cannot\n        be processed, otherwise self.report is initialized and True is\n        returned.\n        \"\"\"\n        try:\n            self.report = apport.Report()\n            with open(path, \"rb\") as f:\n                self.report.load(f, binary=\"compressed\")\n            if \"ProblemType\" not in self.report:\n                raise ValueError('Report does not contain \"ProblemType\" field')\n        except MemoryError:\n            self.report = None\n            self.ui_error_message(\n                _(\"Memory exhaustion\"),\n                _(\n                    \"Your system does not have enough memory\"\n                    \" to process this crash report.\"\n                ),\n            )\n            return False\n        except OSError as error:\n            self.report = None\n            self.ui_error_message(_(\"Invalid problem report\"), error.strerror)\n            return False\n        except (TypeError, ValueError, AssertionError, zlib.error) as error:\n            self.report = None\n            self.ui_error_message(\n                _(\"Invalid problem report\"),\n                \"%s\\n\\n%s\"\n                % (\n                    _(\n                        \"This problem report is damaged\"\n                        \" and cannot be processed.\"\n                    ),\n                    repr(error),\n                ),\n            )\n            return False\n\n        if \"Package\" in self.report:\n            self.cur_package = self.report[\"Package\"].split()[0]\n        else:\n            self.cur_package = apport.fileutils.find_file_package(\n                self.report.get(\"ExecutablePath\", \"\")\n            )\n\n        return True\n\n    def check_unreportable(self):\n        \"\"\"Check if the current report is unreportable.\n\n        If so, display an info message and return True.\n        \"\"\"\n        if not self.crashdb.accepts(self.report):\n            return False\n        if \"UnreportableReason\" in self.report:\n            if isinstance(self.report[\"UnreportableReason\"], bytes):\n                self.report[\"UnreportableReason\"] = self.report[\n                    \"UnreportableReason\"\n                ].decode(\"UTF-8\")\n            if \"Package\" in self.report:\n                title = _(\"Problem in %s\") % self.report[\"Package\"].split()[0]\n            else:\n                title = \"\"\n            self.ui_info_message(\n                title,\n                _(\"The problem cannot be reported:\\n\\n%s\")\n                % self.report[\"UnreportableReason\"],\n            )\n            return True\n        return False\n\n    def get_desktop_entry(self):\n        \"\"\"Return a .desktop info dictionary for the current report.\n\n        Return None if report cannot be associated to a .desktop file.\n        \"\"\"\n        if \"DesktopFile\" in self.report and os.path.exists(\n            self.report[\"DesktopFile\"]\n        ):\n            desktop_file = self.report[\"DesktopFile\"]\n        else:\n            try:\n                desktop_file = apport.fileutils.find_package_desktopfile(\n                    self.cur_package\n                )\n            except ValueError:\n                return None\n\n        if not desktop_file:\n            return None\n\n        cp = configparser.ConfigParser(interpolation=None, strict=False)\n        try:\n            cp.read(desktop_file, encoding=\"UTF-8\")\n        except configparser.Error as error:\n            sys.stderr.write(\n                \"Warning! %s is broken: %s\\n\" % (desktop_file, str(error))\n            )\n            return None\n        if not cp.has_section(\"Desktop Entry\"):\n            return None\n        result = dict(cp.items(\"Desktop Entry\"))\n        if \"name\" not in result:\n            return None\n        return result\n\n    def handle_duplicate(self):\n        \"\"\"Check if current report matches a bug pattern.\n\n        If so, tell the user about it, open the existing bug in a browser, and\n        return True.\n        \"\"\"\n        if not self.crashdb.accepts(self.report):\n            return False\n        if \"_KnownReport\" not in self.report:\n            return False\n\n        # if we have an URL, open it; otherwise this is just a marker that we\n        # know about it\n        if self.report[\"_KnownReport\"].startswith(\"http\"):\n            self.ui_info_message(\n                _(\"Problem already known\"),\n                _(\n                    \"This problem was already reported in the bug report\"\n                    \" displayed in the web browser. Please check\"\n                    \" if you can add any further information\"\n                    \" that might be helpful for the developers.\"\n                ),\n            )\n\n            self.open_url(self.report[\"_KnownReport\"])\n        else:\n            self.ui_info_message(\n                _(\"Problem already known\"),\n                _(\n                    \"This problem was already reported to developers.\"\n                    \" Thank you!\"\n                ),\n            )\n\n        return True\n\n    def add_extra_tags(self):\n        \"\"\"Add extra tags to report specified with --tags on CLI.\"\"\"\n        assert self.report\n        if self.args.tags:\n            self.report.add_tags(self.args.tags)\n\n    #\n    # abstract UI methods that must be implemented in derived classes\n    #\n\n    def ui_present_report_details(\n        self, allowed_to_report=True, modal_for=None\n    ) -> Action:\n        \"\"\"Show details of the bug report.\n\n        Return the action and options as an Action object:\n\n        - Valid attributes are: report the crash ('report'), restart\n          the crashed application ('restart'), or ignore further crashes\n          ('ignore').\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_info_message(self, title, text):\n        \"\"\"Show an information message box with given title and text.\"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_error_message(self, title, text):\n        \"\"\"Show an error message box with given title and text.\"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_start_info_collection_progress(self):\n        \"\"\"Open a indefinite progress bar for data collection.\n\n        This tells the user to wait while debug information is being\n        collected.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_pulse_info_collection_progress(self):\n        \"\"\"Advance the data collection progress bar.\n\n        This function is called every 100 ms.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_stop_info_collection_progress(self):\n        \"\"\"Close debug data collection progress window.\"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_start_upload_progress(self):\n        \"\"\"Open progress bar for data upload.\n\n        This tells the user to wait while debug information is being uploaded.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_set_upload_progress(self, progress: typing.Optional[float]) -> None:\n        \"\"\"Update data upload progress bar.\n\n        Set the progress bar in the debug data upload progress window to the\n        given ratio (between 0 and 1, or None for indefinite progress).\n\n        This function is called every 100 ms.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_stop_upload_progress(self):\n        \"\"\"Close debug data upload progress window.\"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_shutdown(self):\n        \"\"\"Called right before terminating the program.\n\n        This can be used for for cleaning up.\n        \"\"\"\n\n    def ui_has_terminal(self):\n        \"\"\"Check for a terminal window.\n\n        Check if a terminal application is available and can be launched.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_run_terminal(self, command):\n        \"\"\"Run command in a terminal window.\n\n        Run given command in a terminal window; raise an\n        exception if terminal cannot be opened.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    #\n    # Additional UI dialogs; these are not required by Apport itself, but can\n    # be used by interactive package hooks\n    #\n\n    def ui_question_yesno(self, text):\n        \"\"\"Show a yes/no question.\n\n        Return True if the user selected \"Yes\", False if selected \"No\" or\n        \"None\" on cancel/dialog closing.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_question_choice(self, text, options, multiple):\n        \"\"\"Show an question with predefined choices.\n\n        options is a list of strings to present. If multiple is True, they\n        should be check boxes, if multiple is False they should be radio\n        buttons.\n\n        Return list of selected option indexes, or None if the user cancelled.\n        If multiple == False, the list will always have one element.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_question_file(self, text):\n        \"\"\"Show a file selector dialog.\n\n        Return path if the user selected a file, or None if cancelled.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n\nclass HookUI:\n    \"\"\"Interactive functions which can be used in package hooks.\n\n    This provides an interface for package hooks which need to ask interactive\n    questions. Directly passing the UserInterface instance to the hooks needs\n    to be avoided, since we need to call the UI methods in a different thread,\n    and also don't want hooks to be able to poke in the UI.\n    \"\"\"\n\n    def __init__(self, ui):\n        \"\"\"Create a HookUI object.\n\n        ui is the UserInterface instance to wrap.\n        \"\"\"\n        self.ui = ui\n\n        # variables for communicating with the UI thread\n        self._request_event = threading.Event()\n        self._response_event = threading.Event()\n        self._request_fn = None\n        self._request_args = None\n        self._response = None\n\n    #\n    # API for hooks\n    #\n\n    def information(self, text):\n        \"\"\"Show an information with OK/Cancel buttons.\n\n        This can be used for asking the user to perform a particular action,\n        such as plugging in a device which does not work.\n        \"\"\"\n        return self._trigger_ui_request(\"ui_info_message\", \"\", text)\n\n    def yesno(self, text):\n        \"\"\"Show a yes/no question.\n\n        Return True if the user selected \"Yes\", False if selected \"No\" or\n        \"None\" on cancel/dialog closing.\n        \"\"\"\n        return self._trigger_ui_request(\"ui_question_yesno\", text)\n\n    def choice(self, text, options, multiple=False):\n        \"\"\"Show an question with predefined choices.\n\n        options is a list of strings to present. If multiple is True, they\n        should be check boxes, if multiple is False they should be radio\n        buttons.\n\n        Return list of selected option indexes, or None if the user cancelled.\n        If multiple == False, the list will always have one element.\n        \"\"\"\n        return self._trigger_ui_request(\n            \"ui_question_choice\", text, options, multiple\n        )\n\n    def file(self, text):\n        \"\"\"Show a file selector dialog.\n\n        Return path if the user selected a file, or None if cancelled.\n        \"\"\"\n        return self._trigger_ui_request(\"ui_question_file\", text)\n\n    #\n    # internal API for inter-thread communication\n    #\n\n    def _trigger_ui_request(self, fn, *args):\n        \"\"\"Called by HookUi functions in info collection thread.\"\"\"\n        # only one at a time\n        assert not self._request_event.is_set()\n        assert not self._response_event.is_set()\n        assert self._request_fn is None\n\n        self._response = None\n        self._request_fn = fn\n        self._request_args = args\n        self._request_event.set()\n        self._response_event.wait()\n\n        self._request_fn = None\n        self._response_event.clear()\n\n        return self._response\n\n    def process_event(self):\n        \"\"\"Called by GUI thread to check and process hook UI requests.\"\"\"\n        # sleep for 0.1 seconds to wait for events\n        self._request_event.wait(0.1)\n        if not self._request_event.is_set():\n            return\n\n        assert not self._response_event.is_set()\n        self._request_event.clear()\n        self._response = getattr(self.ui, self._request_fn)(\n            *self._request_args\n        )\n        self._response_event.set()\n\n\nclass NoninteractiveHookUI(HookUI):\n    \"\"\"HookUI variant that does not ask the user any questions.\"\"\"\n\n    def __init__(self):\n        super().__init__(None)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}()\"\n\n    def information(self, text):\n        return None\n\n    def yesno(self, text):\n        return None\n\n    def choice(self, text, options, multiple=False):\n        return None\n\n    def file(self, text):\n        return None\n\n    def process_event(self):\n        # Give other threads some chance to run\n        time.sleep(0.1)\n", "#!/usr/bin/python3\n\n\"\"\"Command line Apport user interface.\"\"\"\n\n# Copyright (C) 2007 - 2009 Canonical Ltd.\n# Author: Michael Hofmann <mh21@piware.de>\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by the\n# Free Software Foundation; either version 2 of the License, or (at your\n# option) any later version.  See http://www.gnu.org/copyleft/gpl.html for\n# the full text of the license.\n\n# Web browser support:\n#    w3m, lynx: do not work\n#    elinks: works\n\nimport errno\nimport os\nimport re\nimport subprocess\nimport sys\nimport tempfile\nimport termios\nimport typing\nfrom gettext import gettext as _\n\nimport apport.ui\n\n\nclass CLIDialog:\n    \"\"\"Command line dialog wrapper.\"\"\"\n\n    def __init__(self, heading, text):\n        self.heading = \"\\n*** \" + heading + \"\\n\"\n        self.text = text\n        self.keys = []\n        self.buttons = []\n        self.visible = False\n\n    @staticmethod\n    def raw_input_char(prompt, multi_char=False):\n        \"\"\"raw_input, but read a single character unless multi_char is True.\n\n        @param: prompt: the text presented to the user to solict a response.\n        @param: multi_char: Boolean True if we need to read until <enter>.\n        \"\"\"\n\n        sys.stdout.write(prompt)\n        sys.stdout.write(\" \")\n        sys.stdout.flush()\n\n        file = sys.stdin.fileno()\n        saved_attributes = termios.tcgetattr(file)\n        attributes = termios.tcgetattr(file)\n        attributes[3] = attributes[3] & ~(termios.ICANON)\n        attributes[6][termios.VMIN] = 1\n        attributes[6][termios.VTIME] = 0\n        termios.tcsetattr(file, termios.TCSANOW, attributes)\n        try:\n            if multi_char:\n                response = str(sys.stdin.readline()).strip()\n            else:\n                response = str(sys.stdin.read(1))\n        finally:\n            termios.tcsetattr(file, termios.TCSANOW, saved_attributes)\n\n        sys.stdout.write(\"\\n\")\n        return response\n\n    def show(self):\n        self.visible = True\n        print(self.heading)\n        if self.text:\n            print(self.text)\n\n    def run(self, prompt=None):\n        if not self.visible:\n            self.show()\n\n        sys.stdout.write(\"\\n\")\n        try:\n            # Only one button\n            if len(self.keys) <= 1:\n                self.raw_input_char(_(\"Press any key to continue...\"))\n                return 0\n            # Multiple choices\n            while True:\n                if prompt is not None:\n                    print(prompt)\n                else:\n                    print(_(\"What would you like to do? Your options are:\"))\n                for index, button in enumerate(self.buttons):\n                    print(\"  %s: %s\" % (self.keys[index], button))\n\n                if len(self.keys) <= 10:\n                    # A 10 option prompt would can still be a single character\n                    # response because the 10 options listed will be 1-9 and C.\n                    # Therefore there are 10 unique responses which can be\n                    # given.\n                    multi_char = False\n                else:\n                    multi_char = True\n                response = self.raw_input_char(\n                    _(\"Please choose (%s):\") % (\"/\".join(self.keys)),\n                    multi_char,\n                )\n                try:\n                    return self.keys.index(response.upper()) + 1\n                except ValueError:\n                    pass\n        except KeyboardInterrupt:\n            sys.stdout.write(\"\\n\")\n            sys.exit(1)\n\n    def addbutton(self, button, hotkey=None):\n        if hotkey:\n            self.keys.append(hotkey)\n            self.buttons.append(button)\n        else:\n            self.keys.append(re.search(\"&(.)\", button).group(1).upper())\n            self.buttons.append(re.sub(\"&\", \"\", button))\n        return len(self.keys)\n\n\nclass CLIProgressDialog(CLIDialog):\n    \"\"\"Command line progress dialog wrapper.\"\"\"\n\n    def __init__(self, heading, text):\n        CLIDialog.__init__(self, heading, text)\n        self.progresscount = 0\n\n    def set(self, progress=None):\n        self.progresscount = (self.progresscount + 1) % 5\n        if self.progresscount:\n            return\n\n        if progress is not None:\n            sys.stdout.write(\"\\r%u%%\" % (progress * 100))\n        else:\n            sys.stdout.write(\".\")\n        sys.stdout.flush()\n\n\nclass CLIUserInterface(apport.ui.UserInterface):\n    \"\"\"Command line Apport user interface\"\"\"\n\n    def __init__(self, argv: list[str]):\n        apport.ui.UserInterface.__init__(self, argv)\n        self.in_update_view = False\n        self.progress = None\n\n    def _get_details(self):\n        \"\"\"Build report string for display.\"\"\"\n\n        details = \"\"\n        max_show = 1000000\n        for key in sorted(self.report):\n            # ignore internal keys\n            if key.startswith(\"_\"):\n                continue\n            details += \"== %s =================================\\n\" % key\n            # string value\n            keylen = len(self.report[key])\n            if (\n                not hasattr(self.report[key], \"gzipvalue\")\n                and hasattr(self.report[key], \"isspace\")\n                and not self.report.is_binary(self.report[key])\n                and keylen < max_show\n            ):\n                s = self.report[key]\n            elif keylen >= max_show:\n                s = _(\"(%i bytes)\") % keylen\n            else:\n                s = _(\"(binary data)\")\n\n            if isinstance(s, bytes):\n                s = s.decode(\"UTF-8\", errors=\"ignore\")\n            details += s\n            details += \"\\n\\n\"\n\n        return details\n\n    def ui_update_view(self, stdout=None):\n        self.in_update_view = True\n        report = self._get_details()\n        try:\n            subprocess.run(\n                [\"/usr/bin/sensible-pager\"],\n                check=False,\n                input=report.encode(\"UTF-8\"),\n                stdout=stdout,\n            )\n        except OSError as error:\n            # ignore broken pipe (premature quit)\n            if error.errno == errno.EPIPE:\n                pass\n            else:\n                raise\n        self.in_update_view = False\n\n    #\n    # ui_* implementation of abstract UserInterface classes\n    #\n\n    def ui_present_report_details(\n        self, allowed_to_report=True, modal_for=None\n    ) -> apport.ui.Action:\n        dialog = CLIDialog(\n            _(\"Send problem report to the developers?\"),\n            _(\n                \"After the problem report has been sent,\"\n                \" please fill out the form in the\\n\"\n                \"automatically opened web browser.\"\n            ),\n        )\n\n        complete = dialog.addbutton(\n            _(\"&Send report (%s)\")\n            % self.format_filesize(self.get_complete_size())\n        )\n\n        if self.can_examine_locally():\n            examine = dialog.addbutton(_(\"&Examine locally\"))\n        else:\n            examine = None\n\n        view = dialog.addbutton(_(\"&View report\"))\n        save = dialog.addbutton(\n            _(\n                \"&Keep report file for sending later\"\n                \" or copying to somewhere else\"\n            )\n        )\n        ignore = dialog.addbutton(\n            _(\"Cancel and &ignore future crashes of this program version\")\n        )\n\n        dialog.addbutton(_(\"&Cancel\"))\n\n        while True:\n            response = dialog.run()\n\n            return_value = apport.ui.Action()\n            if response == examine:\n                return_value.examine = True\n                return return_value\n            if response == complete:\n                return_value.report = True\n            if response == ignore:\n                return_value.ignore = True\n            if response == view:\n                self.collect_info()\n                self.ui_update_view()\n                continue\n            if response == save:\n                # we do not already have a report file if we report a bug\n                if not self.report_file:\n                    prefix = \"apport.\"\n                    if \"Package\" in self.report:\n                        prefix += self.report[\"Package\"].split()[0] + \".\"\n                    (fd, self.report_file) = tempfile.mkstemp(\n                        prefix=prefix, suffix=\".apport\"\n                    )\n                    with os.fdopen(fd, \"wb\") as f:\n                        self.report.write(f)\n\n                print(_(\"Problem report file:\") + \" \" + self.report_file)\n\n            return return_value\n\n    def ui_info_message(self, title, text):\n        dialog = CLIDialog(title, text)\n        dialog.addbutton(_(\"&Confirm\"))\n        dialog.run()\n\n    def ui_error_message(self, title, text):\n        dialog = CLIDialog(_(\"Error: %s\") % title, text)\n        dialog.addbutton(_(\"&Confirm\"))\n        dialog.run()\n\n    def ui_start_info_collection_progress(self):\n        self.progress = CLIProgressDialog(\n            _(\"Collecting problem information\"),\n            _(\n                \"The collected information can be sent\"\n                \" to the developers to improve the\\n\"\n                \"application. This might take a few minutes.\"\n            ),\n        )\n        self.progress.show()\n\n    def ui_pulse_info_collection_progress(self):\n        assert self.progress is not None\n        self.progress.set()\n\n    def ui_stop_info_collection_progress(self):\n        sys.stdout.write(\"\\n\")\n\n    def ui_start_upload_progress(self):\n        self.progress = CLIProgressDialog(\n            _(\"Uploading problem information\"),\n            _(\n                \"The collected information is being sent\"\n                \" to the bug tracking system.\\n\"\n                \"This might take a few minutes.\"\n            ),\n        )\n        self.progress.show()\n\n    def ui_set_upload_progress(self, progress: typing.Optional[float]) -> None:\n        assert self.progress is not None\n        self.progress.set(progress)\n\n    def ui_stop_upload_progress(self):\n        sys.stdout.write(\"\\n\")\n\n    def ui_question_yesno(self, text):\n        \"\"\"Show a yes/no question.\n\n        Return True if the user selected \"Yes\", False if selected \"No\" or\n        \"None\" on cancel/dialog closing.\n        \"\"\"\n        dialog = CLIDialog(text, None)\n        r_yes = dialog.addbutton(\"&Yes\")\n        r_no = dialog.addbutton(\"&No\")\n        r_cancel = dialog.addbutton(_(\"&Cancel\"))\n        result = dialog.run()\n        if result == r_yes:\n            return True\n        if result == r_no:\n            return False\n        assert result == r_cancel\n        return None\n\n    def ui_question_choice(self, text, options, multiple):\n        \"\"\"Show an question with predefined choices.\n\n        options is a list of strings to present. If multiple is True, they\n        should be check boxes, if multiple is False they should be radio\n        buttons.\n\n        Return list of selected option indexes, or None if the user cancelled.\n        If multiple == False, the list will always have one element.\n        \"\"\"\n        result = []\n        dialog = CLIDialog(text, None)\n\n        if multiple:\n            while True:\n                dialog = CLIDialog(text, None)\n                index = 0\n                choice_index_map = {}\n                for option in options:\n                    if index not in result:\n                        choice_index_map[\n                            dialog.addbutton(option, str(index + 1))\n                        ] = index\n                    index += 1\n                done = dialog.addbutton(_(\"&Done\"))\n                cancel = dialog.addbutton(_(\"&Cancel\"))\n\n                if result:\n                    cur = \", \".join([str(r + 1) for r in result])\n                else:\n                    cur = _(\"none\")\n                response = dialog.run(\n                    _(\"Selected: %s. Multiple choices:\") % cur\n                )\n                if response == cancel:\n                    return None\n                if response == done:\n                    break\n                result.append(choice_index_map[response])\n\n        else:\n            # single choice (radio button)\n            dialog = CLIDialog(text, None)\n            index = 1\n            for option in options:\n                dialog.addbutton(option, str(index))\n                index += 1\n\n            cancel = dialog.addbutton(_(\"&Cancel\"))\n            response = dialog.run(_(\"Choices:\"))\n            if response == cancel:\n                return None\n            result.append(response - 1)\n\n        return result\n\n    def ui_question_file(self, text):\n        \"\"\"Show a file selector dialog.\n\n        Return path if the user selected a file, or None if cancelled.\n        \"\"\"\n        print(\"\\n***  \" + text)\n        while True:\n            sys.stdout.write(_(\"Path to file (Enter to cancel):\"))\n            sys.stdout.write(\" \")\n            f = sys.stdin.readline().strip()\n            if not f:\n                return None\n            if not os.path.exists(f):\n                print(_(\"File does not exist.\"))\n            elif os.path.isdir(f):\n                print(_(\"This is a directory.\"))\n            else:\n                return f\n\n    def open_url(self, url):\n        text = \"%s\\n\\n  %s\\n\\n%s\" % (\n            _(\"To continue, you must visit the following URL:\"),\n            url,\n            _(\n                \"You can launch a browser now,\"\n                \" or copy this URL into a browser on another computer.\"\n            ),\n        )\n\n        answer = self.ui_question_choice(\n            text, [_(\"Launch a browser now\")], False\n        )\n        if answer == [0]:\n            apport.ui.UserInterface.open_url(self, url)\n\n    def ui_has_terminal(self):\n        # we are already running in a terminal, so this works by definition\n        return True\n\n    def ui_run_terminal(self, command):\n        subprocess.call(command, shell=True)\n\n\nif __name__ == \"__main__\":\n    app = CLIUserInterface(sys.argv)\n    if not app.run_argv():\n        print(_(\"No pending crash reports. Try --help for more information.\"))\n", "import contextlib\nimport errno\nimport glob\nimport io\nimport locale\nimport os\nimport pwd\nimport shutil\nimport signal\nimport stat\nimport subprocess\nimport tempfile\nimport textwrap\nimport time\nimport typing\nimport unittest\nimport unittest.mock\nimport urllib.error\n\nimport apport.crashdb_impl.memory\nimport apport.packaging\nimport apport.report\nimport apport.ui\nimport problem_report\nfrom apport.ui import _, run_as_real_user\nfrom tests.helper import pidof, skip_if_command_is_missing\nfrom tests.paths import (\n    local_test_environment,\n    patch_data_dir,\n    restore_data_dir,\n)\n\nORIGINAL_SUBPROCESS_RUN = subprocess.run\nlogind_session = apport.Report.get_logind_session(os.getpid())\n\n\ndef mock_run_calls_except_pgrep(\n    args: list[str], check: bool = False, **kwargs\n) -> subprocess.CompletedProcess:\n    \"\"\"Wrap subprocess.run() doing no-ops except for pgrep.\"\"\"\n    if args[0] == \"pgrep\":\n        return ORIGINAL_SUBPROCESS_RUN(args, check=check, **kwargs)\n    return subprocess.CompletedProcess(args, 0)\n\n\nclass UserInterfaceMock(apport.ui.UserInterface):\n    \"\"\"Concrete apport.ui.UserInterface suitable for automatic testing\"\"\"\n\n    def __init__(self, argv: typing.Optional[list[str]] = None):\n        # use our memory crashdb which is designed for testing\n        # closed in __del__, pylint: disable=consider-using-with\n        self.crashdb_conf = tempfile.NamedTemporaryFile()\n        self.crashdb_conf.write(\n            textwrap.dedent(\n                \"\"\"\\\n                default = 'testsuite'\n                databases = {\n                    'testsuite': {\n                        'impl': 'memory',\n                        'bug_pattern_url': None,\n                    },\n                    'debug': {\n                        'impl': 'memory',\n                        'distro': 'debug',\n                    },\n                }\n                \"\"\"\n            ).encode()\n        )\n        self.crashdb_conf.flush()\n\n        os.environ[\"APPORT_CRASHDB_CONF\"] = self.crashdb_conf.name\n\n        if argv is None:\n            argv = [\"ui-test\"]\n        apport.ui.UserInterface.__init__(self, argv)\n\n        self.crashdb = apport.crashdb_impl.memory.CrashDatabase(\n            None, {\"sample_data\": 1, \"dupdb_url\": \"\"}\n        )\n\n        # state of progress dialogs\n        self.ic_progress_active = False\n        self.ic_progress_pulses = 0  # count the pulses\n        self.upload_progress_active = False\n        self.upload_progress_pulses = 0\n\n        # store last message box\n        self.msg_title = None\n        self.msg_text = None\n        self.msg_severity = None\n        self.msg_choices = None\n\n        # these store the choices the ui_present_* calls do\n        self.present_package_error_response = None\n        self.present_kernel_error_response = None\n        self.present_details_response = None\n        self.question_yesno_response = None\n        self.question_choice_response = None\n        self.question_file_response = None\n\n        self.opened_url = None\n        self.present_details_shown = False\n\n        self.clear_msg()\n\n    def __del__(self):\n        self.crashdb_conf.close()\n\n    def clear_msg(self):\n        # last message box\n        self.msg_title = None\n        self.msg_text = None\n        self.msg_severity = None  # 'warning' or 'error'\n        self.msg_choices = None\n\n    def ui_present_report_details(\n        self, allowed_to_report=True, modal_for=None\n    ) -> apport.ui.Action:\n        self.present_details_shown = True\n        assert self.present_details_response\n        return self.present_details_response\n\n    def ui_info_message(self, title, text):\n        self.msg_title = title\n        self.msg_text = text\n        self.msg_severity = \"info\"\n\n    def ui_error_message(self, title, text):\n        self.msg_title = title\n        self.msg_text = text\n        self.msg_severity = \"error\"\n\n    def ui_start_info_collection_progress(self):\n        self.ic_progress_pulses = 0\n        self.ic_progress_active = True\n\n    def ui_pulse_info_collection_progress(self):\n        assert self.ic_progress_active\n        self.ic_progress_pulses += 1\n\n    def ui_stop_info_collection_progress(self):\n        self.ic_progress_active = False\n\n    def ui_start_upload_progress(self):\n        self.upload_progress_pulses = 0\n        self.upload_progress_active = True\n\n    def ui_set_upload_progress(self, progress: typing.Optional[float]) -> None:\n        assert self.upload_progress_active\n        self.upload_progress_pulses += 1\n\n    def ui_stop_upload_progress(self):\n        self.upload_progress_active = False\n\n    def ui_has_terminal(self):\n        # The tests are already running in a terminal\n        return True\n\n    def ui_run_terminal(self, command):\n        subprocess.call(command, shell=True)\n\n    def open_url(self, url):\n        self.opened_url = url\n\n    def ui_question_yesno(self, text):\n        self.msg_text = text\n        return self.question_yesno_response\n\n    def ui_question_choice(self, text, options, multiple):\n        self.msg_text = text\n        self.msg_choices = options\n        return self.question_choice_response\n\n    def ui_question_file(self, text):\n        self.msg_text = text\n        return self.question_file_response\n\n\n@unittest.mock.patch(\n    \"apport.hookutils._root_command_prefix\",\n    unittest.mock.MagicMock(return_value=[]),\n)\nclass T(unittest.TestCase):\n    TEST_EXECUTABLE = os.path.realpath(\"/bin/sleep\")\n    TEST_ARGS = [\"86400\"]\n\n    def setUp(self):\n        self.orig_environ = os.environ.copy()\n        os.environ |= local_test_environment()\n\n        # we test a few strings, don't get confused by translations\n        for v in [\"LANG\", \"LANGUAGE\", \"LC_MESSAGES\", \"LC_ALL\"]:\n            try:\n                del os.environ[v]\n            except KeyError:\n                pass\n\n        self.orig_data_dir = patch_data_dir(apport.report)\n\n        # pylint: disable=protected-access\n        self.workdir = tempfile.mkdtemp()\n        self.orig_report_dir = apport.fileutils.report_dir\n        apport.fileutils.report_dir = os.path.join(self.workdir, \"crash\")\n        os.mkdir(apport.fileutils.report_dir)\n        self.orig_symptom_script_dir = apport.ui.symptom_script_dir\n        apport.ui.symptom_script_dir = os.path.join(self.workdir, \"symptoms\")\n        os.mkdir(apport.ui.symptom_script_dir)\n        self.orig_ignore_file = apport.report._ignore_file\n        apport.report._ignore_file = os.path.join(\n            self.workdir, \"apport-ignore.xml\"\n        )\n        os.mknod(apport.report._ignore_file)\n\n        self.ui = UserInterfaceMock()\n\n        # demo report\n        self.report = apport.Report()\n        self.report[\"ExecutablePath\"] = \"/bin/bash\"\n        self.report[\"Package\"] = \"libfoo1 1-1\"\n        self.report[\"SourcePackage\"] = \"foo\"\n        self.report[\"Foo\"] = \"A\" * 1000\n        self.report[\"CoreDump\"] = problem_report.CompressedValue(\n            b\"\\x01\" * 100000\n        )\n\n        # write demo report into temporary file\n        # closed in tearDown, pylint: disable=consider-using-with\n        self.report_file = tempfile.NamedTemporaryFile()\n        self.update_report_file()\n\n        # set up our local hook directory\n        self.hookdir = os.path.join(self.workdir, \"package-hooks\")\n        os.mkdir(self.hookdir)\n        self.orig_package_hook_dir = apport.report.PACKAGE_HOOK_DIR\n        apport.report.PACKAGE_HOOK_DIR = self.hookdir\n\n        # test suite should not stumble over local packages\n        os.environ[\"APPORT_IGNORE_OBSOLETE_PACKAGES\"] = \"1\"\n        os.environ[\"APPORT_DISABLE_DISTRO_CHECK\"] = \"1\"\n\n        self.running_test_executables = pidof(self.TEST_EXECUTABLE)\n\n    def update_report_file(self):\n        self.report_file.seek(0)\n        self.report_file.truncate()\n        self.report.write(self.report_file)\n        self.report_file.flush()\n\n    def tearDown(self):\n        apport.fileutils.report_dir = self.orig_report_dir\n        self.orig_report_dir = None\n        apport.ui.symptom_script_dir = self.orig_symptom_script_dir\n        self.orig_symptom_script_dir = None\n\n        # pylint: disable=protected-access\n        os.unlink(apport.report._ignore_file)\n        apport.report._ignore_file = self.orig_ignore_file\n\n        self.ui = None\n        self.report_file.close()\n\n        self.assertEqual(\n            pidof(self.TEST_EXECUTABLE) - self.running_test_executables,\n            set(),\n            \"no stray test processes\",\n        )\n\n        apport.report.PACKAGE_HOOK_DIR = self.orig_package_hook_dir\n        shutil.rmtree(self.workdir)\n        os.environ.clear()\n        os.environ.update(self.orig_environ)\n\n        restore_data_dir(apport.report, self.orig_data_dir)\n\n    @contextlib.contextmanager\n    def _run_test_executable(\n        self,\n        exename: typing.Optional[str] = None,\n        env: typing.Optional[dict[str, str]] = None,\n    ) -> typing.Generator[int, None, None]:\n        if not exename:\n            exename = self.TEST_EXECUTABLE\n\n        with subprocess.Popen(\n            [exename] + self.TEST_ARGS, env=env\n        ) as test_process:\n            # give the execv() some time to finish\n            time.sleep(0.5)\n            yield test_process.pid\n            test_process.kill()\n\n    @staticmethod\n    def _write_symptom_script(script_name: str, content: str) -> None:\n        path = os.path.join(apport.ui.symptom_script_dir, script_name)\n        with open(path, \"w\", encoding=\"utf-8\") as symptom_script:\n            symptom_script.write(content)\n\n    def test_format_filesize(self):\n        \"\"\"format_filesize()\"\"\"\n        locale_numeric = locale.getlocale(locale.LC_NUMERIC)\n        locale.setlocale(locale.LC_NUMERIC, \"C\")\n        try:\n            self.assertEqual(self.ui.format_filesize(0), \"0.0 KB\")\n            self.assertEqual(self.ui.format_filesize(2048), \"2.0 KB\")\n            self.assertEqual(self.ui.format_filesize(2560), \"2.6 KB\")\n            self.assertEqual(self.ui.format_filesize(999999), \"1000.0 KB\")\n            self.assertEqual(self.ui.format_filesize(1000000), \"1.0 MB\")\n            self.assertEqual(self.ui.format_filesize(2.7 * 1000000), \"2.7 MB\")\n            self.assertEqual(self.ui.format_filesize(1024 * 1000000), \"1.0 GB\")\n            self.assertEqual(self.ui.format_filesize(2560 * 1000000), \"2.6 GB\")\n        finally:\n            locale.setlocale(locale.LC_NUMERIC, locale_numeric)\n\n    def test_get_size_loaded(self):\n        \"\"\"get_complete_size() and get_reduced_size() for loaded Reports\"\"\"\n        self.ui.load_report(self.report_file.name)\n\n        fsize = os.path.getsize(self.report_file.name)\n        complete_ratio = float(self.ui.get_complete_size()) / fsize\n        self.assertAlmostEqual(complete_ratio, 1.0, delta=0.1)\n\n        rs = self.ui.get_reduced_size()\n        self.assertTrue(rs > 1000)\n        self.assertTrue(rs < 10000)\n\n        # now add some information (e. g. from package hooks)\n        self.ui.report[\"ExtraInfo\"] = \"A\" * 50000\n        s = self.ui.get_complete_size()\n        self.assertTrue(s >= fsize + 49900)\n        self.assertTrue(s < fsize + 60000)\n\n        rs = self.ui.get_reduced_size()\n        self.assertTrue(rs > 51000)\n        self.assertTrue(rs < 60000)\n\n    def test_get_size_constructed(self):\n        \"\"\"get_complete_size() and get_reduced_size() for on-the-fly Reports\"\"\"\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.report[\"Hello\"] = \"World\"\n\n        s = self.ui.get_complete_size()\n        self.assertTrue(s > 5)\n        self.assertTrue(s < 100)\n\n        self.assertEqual(s, self.ui.get_reduced_size())\n\n    def test_load_report(self):\n        \"\"\"load_report()\"\"\"\n        # valid report\n        self.ui.load_report(self.report_file.name)\n        self.assertEqual(set(self.ui.report.keys()), set(self.report.keys()))\n        self.assertEqual(self.ui.report[\"Package\"], self.report[\"Package\"])\n        self.assertEqual(\n            self.ui.report[\"CoreDump\"].get_value(),\n            self.report[\"CoreDump\"].get_value(),\n        )\n        self.assertEqual(self.ui.msg_title, None)\n\n        self.ui.clear_msg()\n\n        # invalid base64 encoding\n        self.report_file.seek(0)\n        self.report_file.truncate()\n        self.report_file.write(\n            textwrap.dedent(\n                \"\"\"\\\n                Type: test\n                Package: foo 1-1\n                CoreDump: base64\n                bOgUs=\n                \"\"\"\n            ).encode()\n        )\n        self.report_file.flush()\n\n        self.ui.load_report(self.report_file.name)\n        self.assertTrue(self.ui.report is None)\n        self.assertEqual(self.ui.msg_title, _(\"Invalid problem report\"))\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    def test_restart(self):\n        \"\"\"restart()\"\"\"\n        # test with only ProcCmdline\n        p = os.path.join(apport.fileutils.report_dir, \"ProcCmdline\")\n        r = os.path.join(apport.fileutils.report_dir, \"Custom\")\n        self.report[\"ProcCmdline\"] = \"touch \" + p\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n\n        self.ui.restart()\n        time.sleep(1)  # FIXME: race condition\n        self.assertTrue(os.path.exists(p))\n        self.assertTrue(not os.path.exists(r))\n        os.unlink(p)\n\n        # test with RespawnCommand\n        self.report[\"RespawnCommand\"] = \"touch \" + r\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n\n        self.ui.restart()\n        time.sleep(1)  # FIXME: race condition\n        self.assertTrue(not os.path.exists(p))\n        self.assertTrue(os.path.exists(r))\n        os.unlink(r)\n\n        # test that invalid command does not make us fall apart\n        del self.report[\"RespawnCommand\"]\n        self.report[\"ProcCmdline\"] = \"/nonexisting\"\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n\n    def test_collect_info_distro(self):\n        \"\"\"collect_info() on report without information (distro bug)\"\"\"\n        # report without any information (distro bug)\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.collect_info()\n        self.assertTrue(\n            set([\"Date\", \"Uname\", \"DistroRelease\", \"ProblemType\"]).issubset(\n                set(self.ui.report.keys())\n            )\n        )\n        self.assertEqual(\n            self.ui.ic_progress_pulses,\n            0,\n            \"no progress dialog for distro bug info collection\",\n        )\n\n    def test_collect_info_exepath(self):\n        \"\"\"collect_info() on report with only ExecutablePath\"\"\"\n        # report with only package information\n        self.report = apport.Report(\"Bug\")\n        self.report[\"ExecutablePath\"] = \"/bin/bash\"\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n        # add some tuple values, for robustness testing (might be added by\n        # apport hooks)\n        self.ui.report[\"Fstab\"] = (\"/etc/fstab\", True)\n        self.ui.report[\"CompressedValue\"] = problem_report.CompressedValue(\n            b\"Test\"\n        )\n        self.ui.collect_info()\n        self.assertTrue(\n            set(\n                [\n                    \"SourcePackage\",\n                    \"Package\",\n                    \"ProblemType\",\n                    \"Uname\",\n                    \"Dependencies\",\n                    \"DistroRelease\",\n                    \"Date\",\n                    \"ExecutablePath\",\n                ]\n            ).issubset(set(self.ui.report.keys()))\n        )\n        self.assertTrue(\n            self.ui.ic_progress_pulses > 0,\n            \"progress dialog for package bug info collection\",\n        )\n        self.assertEqual(\n            self.ui.ic_progress_active,\n            False,\n            \"progress dialog for package bug info collection finished\",\n        )\n\n    def test_collect_info_package(self):\n        \"\"\"collect_info() on report with a package\"\"\"\n        # report with only package information\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n\n        def search_bug_patterns(url: str) -> typing.Optional[str]:\n            progress_pulses = self.ui.ic_progress_pulses\n            # wait for ui_pulse_info_collection_progress() call\n            while self.ui.ic_progress_pulses == progress_pulses:\n                time.sleep(0.01)\n            return apport.report.Report.search_bug_patterns(\n                self.ui.report, url\n            )\n\n        with unittest.mock.patch.object(\n            self.ui.report,\n            \"search_bug_patterns\",\n            side_effect=search_bug_patterns,\n        ) as search_bug_patterns_mock:\n            self.ui.collect_info()\n\n        search_bug_patterns_mock.assert_called_once()\n        self.assertTrue(\n            set(\n                [\n                    \"SourcePackage\",\n                    \"Package\",\n                    \"ProblemType\",\n                    \"Uname\",\n                    \"Dependencies\",\n                    \"DistroRelease\",\n                    \"Date\",\n                ]\n            ).issubset(set(self.ui.report.keys()))\n        )\n        self.assertTrue(\n            self.ui.ic_progress_pulses > 0,\n            \"progress dialog for package bug info collection\",\n        )\n        self.assertEqual(\n            self.ui.ic_progress_active,\n            False,\n            \"progress dialog for package bug info collection finished\",\n        )\n\n    def test_collect_info_permissions(self):\n        \"\"\"collect_info() leaves the report accessible to the group\"\"\"\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.report_file = self.report_file.name\n        self.ui.collect_info()\n        self.assertTrue(os.stat(self.report_file.name).st_mode & stat.S_IRGRP)\n\n    def _write_crashdb_config_hook(self, crashdb: str, bash_hook: str = None):\n        \"\"\"Write source_bash.py hook that sets CrashDB\"\"\"\n        with open(\n            os.path.join(self.hookdir, \"source_bash.py\"), \"w\", encoding=\"utf-8\"\n        ) as f:\n            f.write(\n                textwrap.dedent(\n                    f'''\\\n                    def add_info(report, ui):\n                        report['CrashDB'] = \"\"\"{crashdb}\"\"\"\n                    '''\n                )\n            )\n            if bash_hook:\n                f.write(f\"    report['BashHook'] = '{bash_hook}'\\n\")\n\n    def test_collect_info_crashdb_spec(self):\n        \"\"\"collect_info() with package hook that defines a CrashDB\"\"\"\n        self._write_crashdb_config_hook(\n            \"{ 'impl': 'memory', 'local_opt': '1' }\", \"Moo\"\n        )\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertIn(\"CrashDB\", self.ui.report)\n        self.assertNotIn(\"UnreportableReason\", self.ui.report)\n        self.assertEqual(self.ui.report[\"BashHook\"], \"Moo\")\n        self.assertEqual(self.ui.crashdb.options[\"local_opt\"], \"1\")\n\n    def test_collect_info_crashdb_name(self):\n        \"\"\"collect_info() with package hook that chooses a different CrashDB\"\"\"\n        self._write_crashdb_config_hook(\"debug\", \"Moo\")\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertNotIn(\"UnreportableReason\", self.ui.report)\n        self.assertEqual(self.ui.report[\"BashHook\"], \"Moo\")\n        self.assertEqual(self.ui.crashdb.options[\"distro\"], \"debug\")\n\n    def test_collect_info_crashdb_errors(self):\n        \"\"\"collect_info() with package hook setting a broken CrashDB field\"\"\"\n        # nonexisting implementation\n        self._write_crashdb_config_hook(\n            \"{ 'impl': 'nonexisting', 'local_opt': '1' }\"\n        )\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertIn(\"nonexisting\", self.ui.report[\"UnreportableReason\"])\n\n        # invalid syntax\n        self._write_crashdb_config_hook(\"{ 'impl': 'memory', 'local_opt'\")\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertIn(\"package hook\", self.ui.report[\"UnreportableReason\"])\n\n        # nonexisting name\n        self._write_crashdb_config_hook(\"nonexisting\")\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertIn(\"nonexisting\", self.ui.report[\"UnreportableReason\"])\n\n        # string with unsafe contents\n        self._write_crashdb_config_hook(\n            \"\"\"{'impl': 'memory',\"\"\"\n            \"\"\" 'trap': exec('open(\"/tmp/pwned\", \"w\").close()')}\"\"\"\n        )\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertIn(\"package hook\", self.ui.report[\"UnreportableReason\"])\n        self.assertFalse(os.path.exists(\"/tmp/pwned\"))\n\n    def test_handle_duplicate(self):\n        \"\"\"handle_duplicate()\"\"\"\n        self.ui.load_report(self.report_file.name)\n        self.assertEqual(self.ui.handle_duplicate(), False)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n\n        demo_url = \"http://example.com/1\"\n        self.report[\"_KnownReport\"] = demo_url\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n        self.assertEqual(self.ui.handle_duplicate(), True)\n        self.assertEqual(self.ui.msg_severity, \"info\")\n        self.assertEqual(self.ui.opened_url, demo_url)\n\n        self.ui.opened_url = None\n        demo_url = \"http://example.com/1\"\n        self.report[\"_KnownReport\"] = \"1\"\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n        self.assertEqual(self.ui.handle_duplicate(), True)\n        self.assertEqual(self.ui.msg_severity, \"info\")\n        self.assertEqual(self.ui.opened_url, None)\n\n    def test_run_nopending(self):\n        \"\"\"Run the frontend without any pending reports.\"\"\"\n        self.ui = UserInterfaceMock()\n        self.assertEqual(self.ui.run_argv(), False)\n\n    def test_run_restart(self):\n        \"\"\"Running the frontend with pending reports offers restart.\"\"\"\n        r = self._gen_test_crash()\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action()\n        self.ui.run_argv()\n        self.assertEqual(self.ui.offer_restart, True)\n\n    def test_run_report_bug_noargs(self):\n        \"\"\"run_report_bug() without specifying arguments\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\"])\n        self.assertEqual(self.ui.run_argv(), False)\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    @unittest.mock.patch(\"sys.stdout\", new_callable=io.StringIO)\n    def test_run_version(self, stdout_mock):\n        \"\"\"run_report_bug() as \"ubuntu-bug\" with version argument\"\"\"\n        self.ui = UserInterfaceMock([\"ubuntu-bug\", \"-v\"])\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(stdout_mock.getvalue(), apport.ui.__version__ + \"\\n\")\n\n    def test_file_report_nodelay(self):\n        \"\"\"file_report() happy path without polling\"\"\"\n        self.ui = UserInterfaceMock()\n        self.ui.report = self.report\n        previous_id = self.ui.crashdb.latest_id()\n        self.ui.file_report()\n        self.assertNotEqual(self.ui.crashdb.latest_id(), previous_id)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.msg_text, None)\n\n    def test_file_report_upload_delay(self):\n        \"\"\"file_report() with some polling during upload\"\"\"\n        self.ui = UserInterfaceMock()\n        self.ui.report = self.report\n        self.ui.crashdb.upload_delay = 0.2  # Arbitrary value\n        previous_id = self.ui.crashdb.latest_id()\n        self.ui.file_report()\n        self.assertNotEqual(self.ui.crashdb.latest_id(), previous_id)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.msg_text, None)\n\n    def test_file_report_upload_message(self):\n        \"\"\"file_report() with a message to the user\"\"\"\n        self.ui = UserInterfaceMock()\n        self.ui.report = self.report\n        self.ui.crashdb.upload_msg = (\"test title\", \"test content\")\n        previous_id = self.ui.crashdb.latest_id()\n        self.ui.file_report()\n        self.assertNotEqual(self.ui.crashdb.latest_id(), previous_id)\n        self.assertEqual(self.ui.msg_severity, \"info\")\n        self.assertEqual(self.ui.msg_title, \"test title\")\n        self.assertEqual(self.ui.msg_text, \"test content\")\n\n    def test_file_report_http_error(self) -> None:\n        \"\"\"file_report() fails with HTTPError.\"\"\"\n        self.ui = UserInterfaceMock()\n        self.ui.report = self.report\n        with unittest.mock.patch.object(\n            self.ui.crashdb, \"upload\"\n        ) as upload_mock:\n            upload_mock.side_effect = urllib.error.HTTPError(\n                \"https://example.com/\", 502, \"Bad Gateway\", {}, None\n            )\n            self.ui.file_report()\n        self.assertEqual(self.ui.msg_severity, \"error\")\n        self.assertEqual(self.ui.msg_title, \"Network problem\")\n        self.assertEqual(\n            self.ui.msg_text,\n            \"Cannot connect to crash database, please check your Internet\"\n            \" connection.\\n\\nHTTP Error 502: Bad Gateway\",\n        )\n\n    def test_run_report_bug_package(self):\n        \"\"\"run_report_bug() for a package\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-p\", \"bash\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertTrue(self.ui.present_details_shown)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://bash.bugs.example.com/%i\" % self.ui.crashdb.latest_id(),\n        )\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertEqual(self.ui.report[\"SourcePackage\"], \"bash\")\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Bug\")\n\n        # should not crash on nonexisting package\n        argv = [\"ui-test\", \"-f\", \"-p\", \"nonexisting_gibberish\"]\n        self.ui = UserInterfaceMock(argv)\n        try:\n            self.ui.run_argv()\n        except SystemExit:\n            pass\n\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    def test_run_report_bug_pid_tags(self):\n        \"\"\"run_report_bug() for a pid with extra tags\"\"\"\n        with self._run_test_executable() as pid:\n            # report a bug on text executable process\n            argv = [\"ui-test\", \"-f\", \"--tag\", \"foo\", \"-P\", str(pid)]\n            self.ui = UserInterfaceMock(argv)\n            self.ui.present_details_response = apport.ui.Action(report=True)\n            self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertIn(\"SourcePackage\", self.ui.report)\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcMaps\", self.ui.report)\n        self.assertEqual(\n            self.ui.report[\"ExecutablePath\"], self.TEST_EXECUTABLE\n        )\n        self.assertNotIn(\"ProcCmdline\", self.ui.report)  # privacy!\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Bug\")\n        self.assertIn(\"foo\", self.ui.report.get_tags())\n\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://coreutils.bugs.example.com/%i\"\n            % self.ui.crashdb.latest_id(),\n        )\n        self.assertTrue(self.ui.present_details_shown)\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n\n    @staticmethod\n    def _find_unused_pid():\n        \"\"\"Find and return an unused PID.\"\"\"\n        pid = 1\n        while True:\n            pid += 1\n            try:\n                os.kill(pid, 0)\n            except OSError as error:\n                if error.errno == errno.ESRCH:\n                    break\n        return pid\n\n    def test_run_report_bug_wrong_pid(self):\n        \"\"\"run_report_bug() for a nonexisting pid\"\"\"\n        # silently ignore missing PID; this happens when the user closes\n        # the application prematurely\n        pid = self._find_unused_pid()\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-P\", str(pid)])\n        self.ui.run_argv()\n\n    def test_run_report_bug_noperm_pid(self):\n        \"\"\"run_report_bug() for a pid which runs as a different user\"\"\"\n        restore_root = False\n        if os.getuid() == 0:\n            # temporarily drop to normal user \"mail\"\n            os.setresuid(8, 8, -1)\n            restore_root = True\n\n        try:\n            self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-P\", \"1\"])\n            self.ui.run_argv()\n\n            self.assertEqual(self.ui.msg_severity, \"error\")\n        finally:\n            if restore_root:\n                os.setresuid(0, 0, -1)\n\n    def test_run_report_bug_unpackaged_pid(self):\n        \"\"\"run_report_bug() for a pid of an unpackaged program\"\"\"\n        # create unpackaged test program\n        (fd, exename) = tempfile.mkstemp()\n        with open(self.TEST_EXECUTABLE, \"rb\") as f:\n            os.write(fd, f.read())\n        os.close(fd)\n        os.chmod(exename, 0o755)\n\n        with self._run_test_executable(exename) as pid:\n            self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-P\", str(pid)])\n            self.assertRaises(SystemExit, self.ui.run_argv)\n\n        os.unlink(exename)\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    @unittest.mock.patch(\"apport.packaging_impl.impl.get_version\")\n    def test_run_report_bug_kernel_thread(self, get_version_mock):\n        \"\"\"run_report_bug() for a pid of a kernel thread\"\"\"\n        # The kernel package might not be installed in chroot environments.\n        # Therefore mock get_version for the kernel package.\n        get_version_mock.return_value = \"5.15.0-33.34\"\n\n        for path in glob.glob(\"/proc/[0-9]*/stat\"):\n            with open(path, encoding=\"utf-8\") as f:\n                proc_stat = f.read().split()\n            flags = int(proc_stat[8])\n            if flags & apport.ui.PF_KTHREAD:\n                pid = int(proc_stat[0])\n                break\n        else:\n            self.skipTest(\"no kernel thread found\")\n\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-P\", str(pid)])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_argv()\n\n        kernel_package = apport.packaging.get_kernel_package()\n        self.assertEqual(\n            self.ui.report[\"Package\"],\n            f\"{kernel_package} {get_version_mock.return_value}\",\n        )\n        get_version_mock.assert_any_call(kernel_package)\n\n    def test_run_report_bug_file(self):\n        \"\"\"run_report_bug() with saving report into a file\"\"\"\n        d = os.path.join(apport.fileutils.report_dir, \"home\")\n        os.mkdir(d)\n        reportfile = os.path.join(d, \"bashisbad.apport\")\n\n        argv = [\"ui-test\", \"-f\", \"-p\", \"bash\", \"--save\", reportfile]\n        self.ui = UserInterfaceMock(argv)\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertFalse(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n\n        r = apport.Report()\n        with open(reportfile, \"rb\") as f:\n            r.load(f)\n\n        self.assertEqual(r[\"SourcePackage\"], \"bash\")\n        self.assertIn(\"Dependencies\", r)\n        self.assertIn(\"ProcEnviron\", r)\n        self.assertEqual(r[\"ProblemType\"], \"Bug\")\n\n        # report it\n        self.ui = UserInterfaceMock([\"ui-test\", \"-c\", reportfile])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertEqual(self.ui.msg_text, None)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n    def _gen_test_crash(self):\n        \"\"\"Generate a Report with real crash data.\"\"\"\n        core_path = os.path.join(self.workdir, \"core\")\n        try:\n            with subprocess.Popen(\n                [\n                    \"gdb\",\n                    \"--batch\",\n                    \"-iex\",\n                    \"set debuginfod enable off\",\n                    \"--ex\",\n                    f\"run {' '.join(self.TEST_ARGS)}\",\n                    \"--ex\",\n                    f\"generate-core-file {core_path}\",\n                    self.TEST_EXECUTABLE,\n                ],\n                env={\"HOME\": self.workdir},\n                stdout=subprocess.PIPE,\n            ) as gdb:\n                timeout = 10.0\n                while timeout > 0:\n                    pids = (\n                        pidof(self.TEST_EXECUTABLE)\n                        - self.running_test_executables\n                    )\n                    if pids:\n                        pid = pids.pop()\n                        break\n                    time.sleep(0.01)\n                    timeout -= 0.01\n                else:\n                    gdb.kill()\n                    self.fail(\n                        f\"{self.TEST_EXECUTABLE} not started within 10 seconds\"\n                    )\n\n                # generate crash report\n                r = apport.Report()\n                r[\"ExecutablePath\"] = self.TEST_EXECUTABLE\n                r[\"Signal\"] = \"11\"\n                r.add_proc_info(pid)\n                r.add_user_info()\n                r.add_os_info()\n\n                # generate a core dump\n                os.kill(pid, signal.SIGSEGV)\n                os.waitpid(gdb.pid, 0)\n                assert os.path.exists(core_path)\n                r[\"CoreDump\"] = (core_path,)\n        except FileNotFoundError as error:\n            self.skipTest(f\"{error.filename} not available\")\n\n        return r\n\n    def test_run_crash(self):\n        \"\"\"run_crash()\"\"\"\n        r = self._gen_test_crash()\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n\n        # cancel crash notification dialog\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action()\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertEqual(self.ui.ic_progress_pulses, 0)\n        self.assertEqual(self.ui.offer_restart, False)\n\n        # report in crash notification dialog, send full report\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://coreutils.bugs.example.com/%i\"\n            % self.ui.crashdb.latest_id(),\n        )\n        self.assertFalse(self.ui.ic_progress_active)\n        self.assertNotEqual(self.ui.ic_progress_pulses, 0)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertIn(\"SourcePackage\", self.ui.report)\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"Stacktrace\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertNotIn(\"ExecutableTimestamp\", self.ui.report)\n        self.assertNotIn(\"StacktraceAddressSignature\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Crash\")\n        self.assertTrue(len(self.ui.report[\"CoreDump\"]) > 10000)\n        self.assertTrue(\n            self.ui.report[\"Title\"].startswith(\n                f\"{os.path.basename(self.TEST_EXECUTABLE)}\"\n                f\" crashed with SIGSEGV\"\n            )\n        )\n\n        # so far we did not ignorelist, verify that\n        self.assertTrue(not self.ui.report.check_ignored())\n\n        # cancel crash notification dialog and ignorelist\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(ignore=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertEqual(self.ui.ic_progress_pulses, 0)\n\n        self.assertTrue(self.ui.report.check_ignored())\n        self.assertEqual(self.ui.offer_restart, False)\n\n    def test_run_crash_abort(self):\n        \"\"\"run_crash() for an abort() without assertion message\"\"\"\n        r = self._gen_test_crash()\n        r[\"Signal\"] = \"6\"\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n\n        self.assertIn(\"SourcePackage\", self.ui.report)\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"Stacktrace\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertNotIn(\"ExecutableTimestamp\", self.ui.report)\n        self.assertEqual(self.ui.report[\"Signal\"], \"6\")\n\n        # we disable the ABRT filtering, we want these crashes after all\n        # self.assertIn('assert', self.ui.msg_text, '%s: %s' %\n        #     (self.ui.msg_title, self.ui.msg_text))\n        # self.assertEqual(self.ui.msg_severity, 'info')\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n    @skip_if_command_is_missing(\"gdb\")\n    def test_run_crash_broken(self):\n        \"\"\"run_crash() for an invalid core dump\"\"\"\n        # generate broken crash report\n        r = apport.Report()\n        r[\"ExecutablePath\"] = self.TEST_EXECUTABLE\n        r[\"Signal\"] = \"11\"\n        r[\"CoreDump\"] = problem_report.CompressedValue()\n        r[\"CoreDump\"].gzipvalue = b\"AAAAAAAA\"\n        r.add_user_info()\n\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, \"info\", self.ui.msg_text)\n        self.assertIn(\"decompress\", self.ui.msg_text)\n        self.assertTrue(self.ui.present_details_shown)\n\n    @unittest.mock.patch(\n        \"apport.report.Report.add_gdb_info\", unittest.mock.MagicMock()\n    )\n    @unittest.mock.patch(\n        \"apport.hookutils.attach_conffiles\", unittest.mock.MagicMock()\n    )\n    def test_run_crash_argv_file(self):\n        \"\"\"run_crash() through a file specified on the command line\"\"\"\n        # valid\n        self.report[\"Package\"] = \"bash\"\n        self.update_report_file()\n\n        argv = [\"ui-test\", \"-c\", self.report_file.name]\n        self.ui = UserInterfaceMock(argv)\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertEqual(self.ui.msg_text, None)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        # unreportable\n        self.report[\"Package\"] = \"bash\"\n        self.report[\"UnreportableReason\"] = b\"It stinks. \\xe2\\x99\\xa5\".decode(\n            \"UTF-8\"\n        )\n        self.update_report_file()\n\n        argv = [\"ui-test\", \"-c\", self.report_file.name]\n        self.ui = UserInterfaceMock(argv)\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertIn(\n            \"It stinks.\",\n            self.ui.msg_text,\n            \"%s: %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n        self.assertEqual(self.ui.msg_severity, \"info\")\n\n        # should not die with an exception on an invalid name\n        argv = [\"ui-test\", \"-c\", \"/nonexisting.crash\"]\n        self.ui = UserInterfaceMock(argv)\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    @unittest.mock.patch(\n        \"apport.report.Report.add_gdb_info\", unittest.mock.MagicMock()\n    )\n    def test_run_crash_unreportable(self):\n        \"\"\"run_crash() on a crash with the UnreportableReason field\"\"\"\n        self.report[\"UnreportableReason\"] = \"It stinks.\"\n        self.report[\"ExecutablePath\"] = \"/bin/bash\"\n        self.report[\"Package\"] = \"bash 1\"\n        self.update_report_file()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.ui.run_crash(self.report_file.name)\n\n        self.assertIn(\n            \"It stinks.\",\n            self.ui.msg_text,\n            \"%s: %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n        self.assertEqual(self.ui.msg_severity, \"info\")\n\n    @unittest.mock.patch(\n        \"apport.report.Report.add_gdb_info\", unittest.mock.MagicMock()\n    )\n    def test_run_crash_malicious_crashdb(self):\n        \"\"\"run_crash() on a crash with malicious CrashDB\"\"\"\n        self.report[\"ExecutablePath\"] = \"/bin/bash\"\n        self.report[\"Package\"] = \"bash 1\"\n        self.report[\"CrashDB\"] = (\n            \"{'impl': 'memory',\"\n            \" 'crash_config': open('/tmp/pwned', 'w').close()}\"\n        )\n        self.update_report_file()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.ui.run_crash(self.report_file.name)\n\n        self.assertFalse(os.path.exists(\"/tmp/pwned\"))\n        self.assertIn(\"invalid crash database definition\", self.ui.msg_text)\n\n    @unittest.mock.patch(\n        \"apport.report.Report.add_gdb_info\", unittest.mock.MagicMock()\n    )\n    def test_run_crash_malicious_package(self):\n        \"\"\"Package: path traversal\"\"\"\n        with tempfile.NamedTemporaryFile(suffix=\".py\") as bad_hook:\n            bad_hook.write(\n                b\"def add_info(r, u):\\n  open('/tmp/pwned', 'w').close()\"\n            )\n            bad_hook.flush()\n\n            self.report[\"ExecutablePath\"] = \"/bin/bash\"\n            self.report[\"Package\"] = (\n                \"../\" * 20 + os.path.splitext(bad_hook.name)[0]\n            )\n            self.update_report_file()\n            self.ui.present_details_response = apport.ui.Action(report=True)\n\n            self.ui.run_crash(self.report_file.name)\n\n            self.assertFalse(os.path.exists(\"/tmp/pwned\"))\n            self.assertIn(\"invalid Package:\", self.ui.msg_text)\n\n    def test_run_crash_malicious_exec_path(self):\n        \"\"\"ExecutablePath: path traversal\"\"\"\n        hook_dir = \"/tmp/share/apport/package-hooks\"\n        os.makedirs(hook_dir, exist_ok=True)\n        with tempfile.NamedTemporaryFile(\n            dir=hook_dir, suffix=\".py\"\n        ) as bad_hook:\n            bad_hook.write(\n                b\"def add_info(r, u):\\n  open('/tmp/pwned', 'w').close()\"\n            )\n            bad_hook.flush()\n\n            self.report[\"ExecutablePath\"] = \"/opt/../\" + hook_dir\n            self.report[\"Package\"] = os.path.splitext(bad_hook.name)[\n                0\n            ].replace(hook_dir, \"\")\n            self.update_report_file()\n            self.ui.present_details_response = apport.ui.Action(report=True)\n\n            self.ui.run_crash(self.report_file.name)\n\n            self.assertFalse(os.path.exists(\"/tmp/pwned\"))\n\n    def test_run_crash_ignore(self):\n        \"\"\"run_crash() on a crash with the Ignore field\"\"\"\n        self.report[\"Ignore\"] = \"True\"\n        self.report[\"ExecutablePath\"] = \"/bin/bash\"\n        self.report[\"Package\"] = \"bash 1\"\n        self.update_report_file()\n\n        self.ui.run_crash(self.report_file.name)\n        self.assertEqual(self.ui.msg_severity, None)\n\n    def test_run_crash_nocore(self):\n        \"\"\"run_crash() for a crash dump without CoreDump\"\"\"\n        # create a test executable\n        with self._run_test_executable() as pid:\n            # generate crash report\n            r = apport.Report()\n            r[\"ExecutablePath\"] = self.TEST_EXECUTABLE\n            r[\"Signal\"] = \"42\"\n            r.add_proc_info(pid)\n            r.add_user_info()\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        # run\n        self.ui = UserInterfaceMock()\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, \"error\")\n        self.assertIn(\n            \"memory\",\n            self.ui.msg_text,\n            \"%s: %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n\n    def test_run_crash_preretraced(self):\n        \"\"\"run_crash() pre-retraced reports.\n\n        This happens with crashes which are pre-processed by\n        apport-retrace.\n        \"\"\"\n        r = self._gen_test_crash()\n\n        #  effect of apport-retrace -c\n        r.add_gdb_info()\n        del r[\"CoreDump\"]\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n\n        # report in crash notification dialog, cancel details report\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action()\n        self.ui.run_crash(report_file)\n        self.assertEqual(\n            self.ui.msg_severity,\n            None,\n            \"has %s message: %s: %s\"\n            % (\n                self.ui.msg_severity,\n                str(self.ui.msg_title),\n                str(self.ui.msg_text),\n            ),\n        )\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n    def test_run_crash_precollected(self):\n        \"\"\"run_crash() on complete report on uninstalled package\n\n        This happens when reporting a problem from a different machine through\n        copying a .crash file.\n        \"\"\"\n        self.ui.report = self._gen_test_crash()\n        self.ui.collect_info()\n\n        # now pretend to move it to a machine where the package is not\n        # installed\n        self.ui.report[\"Package\"] = \"uninstalled_pkg 1\"\n        self.ui.report[\"ExecutablePath\"] = \"/usr/bin/uninstalled_program\"\n        self.ui.report[\"InterpreterPath\"] = \"/usr/bin/uninstalled_interpreter\"\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            self.ui.report.write(f)\n\n        # report it\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.cur_package, \"uninstalled_pkg\")\n        self.assertEqual(\n            self.ui.msg_severity,\n            None,\n            \"has %s message: %s: %s\"\n            % (\n                self.ui.msg_severity,\n                str(self.ui.msg_title),\n                str(self.ui.msg_text),\n            ),\n        )\n        self.assertTrue(\n            self.ui.opened_url.startswith(\"http://coreutils.bugs.example.com\")\n        )\n        self.assertTrue(self.ui.present_details_shown)\n\n    def test_run_crash_errors(self):\n        \"\"\"run_crash() on various error conditions\"\"\"\n        # crash report with invalid Package name\n        r = apport.Report()\n        r[\"ExecutablePath\"] = \"/bin/bash\"\n        r[\"Package\"] = \"foobarbaz\"\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertRaises(SystemExit, self.ui.run_crash, report_file)\n\n        self.assertEqual(self.ui.msg_title, _(\"Invalid problem report\"))\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    def test_run_crash_uninstalled(self):\n        \"\"\"run_crash() on reports with subsequently uninstalled packages\"\"\"\n        # program got uninstalled between crash and report\n        r = self._gen_test_crash()\n        r[\"ExecutablePath\"] = \"/bin/nonexisting\"\n        r[\"Package\"] = \"bash\"\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n\n        self.assertEqual(self.ui.msg_title, _(\"Problem in bash\"))\n        self.assertIn(\"not installed any more\", self.ui.msg_text)\n\n        # interpreted program got uninstalled between crash and report\n        r = apport.Report()\n        r[\"ExecutablePath\"] = \"/bin/nonexisting\"\n        r[\"InterpreterPath\"] = \"/usr/bin/python\"\n        r[\n            \"Traceback\"\n        ] = \"ZeroDivisionError: integer division or modulo by zero\"\n\n        self.ui.run_crash(report_file)\n\n        self.assertEqual(self.ui.msg_title, _(\"Problem in bash\"))\n        self.assertIn(\"not installed any more\", self.ui.msg_text)\n\n        # interpreter got uninstalled between crash and report\n        r = apport.Report()\n        r[\"ExecutablePath\"] = \"/bin/sh\"\n        r[\"InterpreterPath\"] = \"/usr/bin/nonexisting\"\n        r[\n            \"Traceback\"\n        ] = \"ZeroDivisionError: integer division or modulo by zero\"\n\n        self.ui.run_crash(report_file)\n\n        self.assertEqual(self.ui.msg_title, _(\"Problem in bash\"))\n        self.assertIn(\"not installed any more\", self.ui.msg_text)\n\n    def test_run_crash_updated_binary(self):\n        \"\"\"run_crash() on binary that got updated in the meantime\"\"\"\n        r = self._gen_test_crash()\n        r[\"ExecutableTimestamp\"] = str(int(r[\"ExecutableTimestamp\"]) - 10)\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n\n        self.assertNotIn(\"ExecutableTimestamp\", self.ui.report)\n        self.assertIn(\n            self.ui.report[\"ExecutablePath\"],\n            self.ui.msg_text,\n            \"%s: %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n        self.assertIn(\n            \"changed\",\n            self.ui.msg_text,\n            \"%s: %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n        self.assertEqual(self.ui.msg_severity, \"info\")\n\n    def test_run_crash_package(self):\n        \"\"\"run_crash() for a package error\"\"\"\n        # generate crash report\n        r = apport.Report(\"Package\")\n        r[\"Package\"] = \"bash\"\n        r[\"SourcePackage\"] = \"bash\"\n        r[\"ErrorMessage\"] = \"It broke\"\n        r[\"VarLogPackagerlog\"] = \"foo\\nbar\"\n        r.add_os_info()\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n\n        # cancel crash notification dialog\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action()\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertEqual(self.ui.ic_progress_pulses, 0)\n        self.assertTrue(self.ui.present_details_shown)\n\n        # report in crash notification dialog, send report\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://bash.bugs.example.com/%i\" % self.ui.crashdb.latest_id(),\n        )\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertIn(\"SourcePackage\", self.ui.report)\n        self.assertIn(\"Package\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Package\")\n\n        # verify that additional information has been collected\n        self.assertIn(\"Architecture\", self.ui.report)\n        self.assertIn(\"DistroRelease\", self.ui.report)\n        self.assertIn(\"Uname\", self.ui.report)\n\n    def test_run_crash_kernel(self):\n        \"\"\"run_crash() for a kernel error\"\"\"\n        package = apport.packaging.get_kernel_package()\n        try:\n            src_pkg = apport.packaging.get_source(package)\n        except ValueError:\n            # Kernel package not installed (e.g. in container)\n            src_pkg = \"linux\"\n\n        # set up hook\n        with open(\n            os.path.join(self.hookdir, f\"source_{src_pkg}.py\"),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as hook:\n            hook.write(\n                textwrap.dedent(\n                    \"\"\"\\\n                    def add_info(report, ui):\n                        report['KernelDebug'] = 'LotsMoreInfo'\n                    \"\"\"\n                )\n            )\n\n        # generate crash report\n        r = apport.Report(\"KernelCrash\")\n        r[\"Package\"] = package\n        r[\"SourcePackage\"] = src_pkg\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n\n        # cancel crash notification dialog\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action()\n        self.ui.run_crash(report_file)\n        self.assertEqual(\n            self.ui.msg_severity,\n            None,\n            \"error: %s - %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertEqual(self.ui.ic_progress_pulses, 0)\n        self.assertTrue(self.ui.present_details_shown)\n\n        # report in crash notification dialog, send report\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(\n            self.ui.msg_severity,\n            None,\n            str(self.ui.msg_title) + \" \" + str(self.ui.msg_text),\n        )\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://%s.bugs.example.com/%i\"\n            % (src_pkg, self.ui.crashdb.latest_id()),\n        )\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertIn(\"SourcePackage\", self.ui.report)\n        # did we run the hooks properly?\n        self.assertIn(\"KernelDebug\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"KernelCrash\")\n\n    def test_run_crash_anonymity(self):\n        \"\"\"run_crash() anonymization\"\"\"\n        r = self._gen_test_crash()\n        utf8_val = (\n            b\"\\xc3\\xa4 \" + os.uname()[1].encode(\"UTF-8\") + b\" \\xe2\\x99\\xa5 \"\n        )\n        r[\"ProcUnicodeValue\"] = utf8_val.decode(\"UTF-8\")\n        r[\"ProcByteArrayValue\"] = utf8_val\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n\n        self.assertNotIn(\"ProcCwd\", self.ui.report)\n\n        dump = io.BytesIO()\n        # this contains more or less random characters which might contain the\n        # user name\n        del self.ui.report[\"CoreDump\"]\n        self.ui.report.write(dump)\n        report = dump.getvalue().decode(\"UTF-8\")\n\n        p = pwd.getpwuid(os.getuid())\n        bad_strings = [os.uname()[1], p[0], p[4], p[5], os.getcwd()]\n\n        for s in bad_strings:\n            self.assertNotIn(\n                s,\n                report,\n                \"dump contains sensitive string: %s:\\n%s\" % (s, report),\n            )\n\n    def test_run_crash_anonymity_order(self):\n        \"\"\"run_crash() anonymization runs after info and duplicate\n        collection\"\"\"\n        # pretend the hostname looks like a hex number which matches\n        # the stack trace address\n        uname = os.uname()\n        uname = (uname[0], \"0xDEADBEEF\", uname[2], uname[3], uname[4])\n        orig_uname = os.uname\n        orig_add_gdb_info = apport.report.Report.add_gdb_info\n        os.uname = lambda: uname\n\n        def fake_add_gdb_info(self):\n            self[\"Stacktrace\"] = textwrap.dedent(\n                \"\"\"\\\n                #0  0xDEADBEEF in h (p=0x0) at crash.c:25\n                #1  0x10000042 in g (x=1, y=42) at crash.c:26\n                #1  0x10000001 in main () at crash.c:40\n                \"\"\"\n            )\n            self[\"ProcMaps\"] = (\n                \"10000000-DEADBEF0 r-xp 00000000 08:02 100000\"\n                \"           /bin/crash\\n\"\n            )\n            assert self.crash_signature_addresses() is not None\n\n        try:\n            r = self._gen_test_crash()\n            apport.report.Report.add_gdb_info = fake_add_gdb_info\n            r[\"ProcAuxInfo\"] = \"my 0xDEADBEEF\"\n            report_file = os.path.join(\n                apport.fileutils.report_dir, \"test.crash\"\n            )\n            with open(report_file, \"wb\") as f:\n                r.write(f)\n\n            # if this runs anonymization before the duplicate signature, then\n            # this will fail, as 0xDEADhostname is an invalid address\n            self.ui = UserInterfaceMock()\n            self.ui.present_details_response = apport.ui.Action(report=True)\n            self.ui.run_crash(report_file)\n            self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n\n            self.assertEqual(self.ui.report[\"ProcAuxInfo\"], \"my hostname\")\n            # after anonymization this should mess up Stacktrace; this mostly\n            # confirms that our test logic works\n            self.assertEqual(self.ui.report.crash_signature_addresses(), None)\n        finally:\n            os.uname = orig_uname\n            apport.report.Report.add_gdb_info = orig_add_gdb_info\n\n    def test_run_crash_anonymity_substring(self):\n        \"\"\"run_crash() anonymization only catches whole words\"\"\"\n        # pretend the hostname is \"ed\", a substring of e. g. \"crashed\"\n        uname = os.uname()\n        uname = (uname[0], \"ed\", uname[2], uname[3], uname[4])\n        orig_uname = os.uname\n        os.uname = lambda: uname\n\n        try:\n            r = self._gen_test_crash()\n            r[\"ProcInfo1\"] = \"my ed\"\n            r[\"ProcInfo2\"] = '\"ed.localnet\"'\n            r[\"ProcInfo3\"] = \"education\"\n            report_file = os.path.join(\n                apport.fileutils.report_dir, \"test.crash\"\n            )\n            with open(report_file, \"wb\") as f:\n                r.write(f)\n\n            self.ui = UserInterfaceMock()\n            self.ui.present_details_response = apport.ui.Action(report=True)\n            self.ui.run_crash(report_file)\n            self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n\n            self.assertTrue(\n                self.ui.report[\"Title\"].startswith(\n                    f\"{os.path.basename(self.TEST_EXECUTABLE)}\"\n                    f\" crashed with SIGSEGV\"\n                ),\n                self.ui.report[\"Title\"],\n            )\n            self.assertEqual(self.ui.report[\"ProcInfo1\"], \"my hostname\")\n            self.assertEqual(\n                self.ui.report[\"ProcInfo2\"], '\"hostname.localnet\"'\n            )\n            self.assertEqual(self.ui.report[\"ProcInfo3\"], \"education\")\n        finally:\n            os.uname = orig_uname\n\n    def test_run_crash_anonymity_escaping(self):\n        \"\"\"run_crash() anonymization escapes special chars\"\"\"\n        # inject GECOS field with regexp control chars\n        orig_getpwuid = pwd.getpwuid\n        orig_getuid = os.getuid\n\n        def fake_getpwuid(_unused_uid):\n            r = list(orig_getpwuid(orig_getuid()))\n            r[4] = \"Joe (Hacker,+1 234,,\"\n            return r\n\n        pwd.getpwuid = fake_getpwuid\n        os.getuid = lambda: 1234\n\n        try:\n            r = self._gen_test_crash()\n            r[\"ProcInfo1\"] = \"That was Joe (Hacker and friends\"\n            r[\"ProcInfo2\"] = \"Call +1 234!\"\n            r[\"ProcInfo3\"] = \"(Hacker should stay\"\n            report_file = os.path.join(\n                apport.fileutils.report_dir, \"test.crash\"\n            )\n            with open(report_file, \"wb\") as f:\n                r.write(f)\n\n            self.ui = UserInterfaceMock()\n            self.ui.present_details_response = apport.ui.Action(report=True)\n            self.ui.run_crash(report_file)\n            self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n\n            self.assertEqual(\n                self.ui.report[\"ProcInfo1\"], \"That was User Name and friends\"\n            )\n            self.assertEqual(self.ui.report[\"ProcInfo2\"], \"Call User Name!\")\n            self.assertEqual(\n                self.ui.report[\"ProcInfo3\"], \"(Hacker should stay\"\n            )\n        finally:\n            pwd.getpwuid = orig_getpwuid\n            os.getuid = orig_getuid\n\n    def test_run_crash_known(self):\n        \"\"\"run_crash() for already known problem\"\"\"\n        r = self._gen_test_crash()\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        # known without URL\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui.crashdb.known = lambda r: True\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.report[\"_KnownReport\"], \"1\")\n        self.assertEqual(self.ui.msg_severity, \"info\")\n        self.assertEqual(self.ui.opened_url, None)\n\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        # known with URL\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui.crashdb.known = lambda r: \"http://myreport/1\"\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.report[\"_KnownReport\"], \"http://myreport/1\")\n        self.assertEqual(self.ui.msg_severity, \"info\")\n        self.assertEqual(self.ui.opened_url, \"http://myreport/1\")\n\n    def test_run_crash_private_keys(self):\n        \"\"\"Do not upload private keys to crash DB.\"\"\"\n        r = self._gen_test_crash()\n        r[\"_Temp\"] = \"boring\"\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n\n        # report\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://coreutils.bugs.example.com/%i\"\n            % self.ui.crashdb.latest_id(),\n        )\n        # internal key should not be uploaded to the crash db\n        r = self.ui.crashdb.download(self.ui.crashdb.latest_id())\n        self.assertIn(\"SourcePackage\", r)\n        self.assertNotIn(\"_Temp\", r)\n\n    @unittest.skipIf(logind_session is None, \"not running in logind session\")\n    def test_run_crash_older_session(self):\n        \"\"\"run_crashes() skips crashes from older logind sessions\"\"\"\n        latest_id_before = self.ui.crashdb.latest_id()\n\n        # current crash report\n        r = self._gen_test_crash()\n        cur_date = r[\"Date\"]\n        r[\"Tag\"] = \"cur\"\n        self.assertEqual(r[\"_LogindSession\"], logind_session[0])\n        with open(\n            os.path.join(apport.fileutils.report_dir, \"cur.crash\"), \"wb\"\n        ) as f:\n            r.write(f)\n\n        # old crash report\n        r[\"Date\"] = time.asctime(time.localtime(logind_session[1] - 1))\n        r[\"Tag\"] = \"old\"\n        with open(\n            os.path.join(apport.fileutils.report_dir, \"old.crash\"), \"wb\"\n        ) as f:\n            r.write(f)\n\n        # old crash report without session\n        del r[\"_LogindSession\"]\n        r[\"Tag\"] = \"oldnosession\"\n        with open(\n            os.path.join(apport.fileutils.report_dir, \"oldnosession.crash\"),\n            \"wb\",\n        ) as f:\n            r.write(f)\n        del r\n\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crashes()\n\n        if os.getuid() != 0:\n            # as user: should have reported two reports only\n            self.assertEqual(self.ui.crashdb.latest_id(), latest_id_before + 2)\n            r1 = self.ui.crashdb.download(self.ui.crashdb.latest_id())\n            r2 = self.ui.crashdb.download(self.ui.crashdb.latest_id() - 1)\n            if r1[\"Tag\"] == \"cur\":\n                self.assertEqual(r1[\"Date\"], cur_date)\n                self.assertEqual(r2[\"Tag\"], \"oldnosession\")\n            else:\n                self.assertEqual(r2[\"Date\"], cur_date)\n                self.assertEqual(r1[\"Tag\"], \"oldnosession\")\n                self.assertEqual(r2[\"Tag\"], \"cur\")\n        else:\n            # as root: should have reported all reports\n            self.assertEqual(self.ui.crashdb.latest_id(), latest_id_before + 3)\n\n    def test_run_update_report_nonexisting_package_from_bug(self):\n        \"\"\"run_update_report() on a nonexisting package (from bug)\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-u\", \"1\"])\n\n        self.assertEqual(self.ui.run_argv(), False)\n        self.assertIn(\"No additional information collected.\", self.ui.msg_text)\n        self.assertFalse(self.ui.present_details_shown)\n\n    def test_run_update_report_nonexisting_package_cli(self):\n        \"\"\"run_update_report() on a nonexisting package (CLI argument)\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-u\", \"1\", \"-p\", \"bar\"])\n\n        self.assertEqual(self.ui.run_argv(), False)\n        self.assertIn(\"No additional information collected.\", self.ui.msg_text)\n        self.assertFalse(self.ui.present_details_shown)\n\n    def test_run_update_report_existing_package_from_bug(self):\n        \"\"\"run_update_report() on an existing package (from bug)\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-u\", \"1\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.ui.crashdb.download(1)[\"SourcePackage\"] = \"bash\"\n        self.ui.crashdb.download(1)[\"Package\"] = \"bash\"\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash \"))\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n\n    def test_run_update_report_existing_package_cli_tags(self):\n        \"\"\"run_update_report() on an existing package (CLI argument)\n        with extra tag\"\"\"\n        argv = [\"ui-test\", \"-u\", \"1\", \"-p\", \"bash\", \"--tag\", \"foo\"]\n        self.ui = UserInterfaceMock(argv)\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash \"))\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertIn(\"foo\", self.ui.report.get_tags())\n\n    def test_run_update_report_existing_package_cli_cmdname(self):\n        \"\"\"run_update_report() on an existing package (-collect program)\"\"\"\n        self.ui = UserInterfaceMock([\"apport-collect\", \"-p\", \"bash\", \"1\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash \"))\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n\n    def test_run_update_report_noninstalled_but_hook(self):\n        \"\"\"run_update_report() on an uninstalled package with a source hook\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-u\", \"1\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        with open(\n            os.path.join(self.hookdir, \"source_foo.py\"), \"w\", encoding=\"utf-8\"\n        ) as f:\n            f.write('def add_info(r, ui):\\n  r[\"MachineType\"]=\"Laptop\"\\n')\n\n        self.assertEqual(self.ui.run_argv(), True, self.ui.report)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertEqual(self.ui.report[\"Package\"], \"foo (not installed)\")\n        self.assertEqual(self.ui.report[\"MachineType\"], \"Laptop\")\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n\n    def test_run_update_report_different_binary_source(self):\n        \"\"\"run_update_report() on a source package which does not have\n        a binary of the same name\"\"\"\n        # this test assumes that the source package name is not an\n        # installed binary package\n        source_pkg = \"shadow\"\n        self.assertRaises(ValueError, apport.packaging.get_version, source_pkg)\n\n        argv = [\"ui-test\", \"-p\", source_pkg, \"-u\", \"1\"]\n        self.ui = UserInterfaceMock(argv)\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        with open(\n            os.path.join(self.hookdir, \"source_%s.py\" % source_pkg),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as f:\n            f.write('def add_info(r, ui):\\n  r[\"MachineType\"]=\"Laptop\"\\n')\n\n        self.assertEqual(self.ui.run_argv(), True, self.ui.report)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertEqual(\n            self.ui.report[\"Package\"], \"%s (not installed)\" % source_pkg\n        )\n        self.assertEqual(self.ui.report[\"MachineType\"], \"Laptop\")\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n\n    def _run_hook(self, code):\n        with open(\n            os.path.join(self.hookdir, \"coreutils.py\"), \"w\", encoding=\"utf-8\"\n        ) as hook:\n            hook.write(\n                \"def add_info(report, ui):\\n%s\\n\"\n                % \"\\n\".join([\"    \" + line for line in code.splitlines()])\n            )\n        self.ui.args.package = \"coreutils\"\n        self.ui.run_report_bug()\n\n    def test_interactive_hooks_information(self):\n        \"\"\"Interactive hooks: HookUI.information()\"\"\"\n        self.ui.present_details_response = apport.ui.Action()\n        self._run_hook(\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                ui.information('InfoText')\n                report['end'] = '1'\n                \"\"\"\n            )\n        )\n        self.assertEqual(self.ui.report[\"begin\"], \"1\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n        self.assertEqual(self.ui.msg_text, \"InfoText\")\n\n    def test_interactive_hooks_yesno(self):\n        \"\"\"Interactive hooks: HookUI.yesno()\"\"\"\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.question_yesno_response = True\n        self._run_hook(\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                report['answer'] = str(ui.yesno('YesNo?'))\n                report['end'] = '1'\n                \"\"\"\n            )\n        )\n        self.assertEqual(self.ui.report[\"begin\"], \"1\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n        self.assertEqual(self.ui.msg_text, \"YesNo?\")\n        self.assertEqual(self.ui.report[\"answer\"], \"True\")\n\n        self.ui.question_yesno_response = False\n        self.ui.run_report_bug()\n        self.assertEqual(self.ui.report[\"answer\"], \"False\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n\n        self.ui.question_yesno_response = None\n        self.ui.run_report_bug()\n        self.assertEqual(self.ui.report[\"answer\"], \"None\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n\n    def test_interactive_hooks_file(self):\n        \"\"\"Interactive hooks: HookUI.file()\"\"\"\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.question_file_response = \"/etc/fstab\"\n        self._run_hook(\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                report['answer'] = str(ui.file('YourFile?'))\n                report['end'] = '1'\n                \"\"\"\n            )\n        )\n        self.assertEqual(self.ui.report[\"begin\"], \"1\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n        self.assertEqual(self.ui.msg_text, \"YourFile?\")\n        self.assertEqual(self.ui.report[\"answer\"], \"/etc/fstab\")\n\n        self.ui.question_file_response = None\n        self.ui.run_report_bug()\n        self.assertEqual(self.ui.report[\"answer\"], \"None\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n\n    def test_interactive_hooks_choices(self):\n        \"\"\"Interactive hooks: HookUI.choice()\"\"\"\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.question_choice_response = [1]\n        self._run_hook(\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                answer = ui.choice('YourChoice?', ['foo', 'bar'])\n                report['answer'] = str(answer)\n                report['end'] = '1'\n                \"\"\"\n            )\n        )\n        self.assertEqual(self.ui.report[\"begin\"], \"1\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n        self.assertEqual(self.ui.msg_text, \"YourChoice?\")\n        self.assertEqual(self.ui.report[\"answer\"], \"[1]\")\n\n        self.ui.question_choice_response = None\n        self.ui.run_report_bug()\n        self.assertEqual(self.ui.report[\"answer\"], \"None\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n\n    def test_hooks_choices_db_no_accept(self):\n        \"\"\"HookUI.choice() but DB does not accept report.\"\"\"\n        self.ui.crashdb.accepts = lambda r: False\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.question_choice_response = [1]\n        self._run_hook(\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                answer = ui.choice('YourChoice?', ['foo', 'bar'])\n                report['answer'] = str(answer)\n                report['end'] = '1'\n                \"\"\"\n            )\n        )\n        self.assertEqual(self.ui.report[\"answer\"], \"None\")\n\n    def test_interactive_hooks_cancel(self):\n        \"\"\"Interactive hooks: user cancels\"\"\"\n        self.assertRaises(\n            SystemExit,\n            self._run_hook,\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                raise StopIteration\n                report['end'] = '1'\n                \"\"\"\n            ),\n        )\n\n    @unittest.mock.patch(\n        \"apport.hookutils.attach_conffiles\", unittest.mock.MagicMock()\n    )\n    @unittest.mock.patch(\"sys.stderr\", new_callable=io.StringIO)\n    def test_run_symptom(self, stderr_mock):\n        \"\"\"run_symptom()\"\"\"\n        # unknown symptom\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"foobar\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertIn('foobar\" is not known', self.ui.msg_text)\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n        # does not determine package\n        self._write_symptom_script(\n            \"nopkg.py\", \"def run(report, ui):\\n    pass\\n\"\n        )\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"nopkg\"])\n        stderr_mock.truncate(0)\n        self.assertRaises(SystemExit, self.ui.run_argv)\n        err = stderr_mock.getvalue()\n        self.assertIn(\"did not determine the affected package\", err)\n\n        # does not define run()\n        self._write_symptom_script(\n            \"norun.py\", \"def something(x, y):\\n    return 1\\n\"\n        )\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"norun\"])\n        stderr_mock.truncate(0)\n        self.assertRaises(SystemExit, self.ui.run_argv)\n        err = stderr_mock.getvalue()\n        self.assertIn(\"norun.py crashed:\", err)\n\n        # crashing script\n        self._write_symptom_script(\n            \"crash.py\", \"def run(report, ui):\\n    return 1/0\\n\"\n        )\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"crash\"])\n        stderr_mock.truncate(0)\n        self.assertRaises(SystemExit, self.ui.run_argv)\n        err = stderr_mock.getvalue()\n        self.assertIn(\"crash.py crashed:\", err)\n        self.assertIn(\"ZeroDivisionError:\", err)\n\n        # working noninteractive script\n        self._write_symptom_script(\n            \"itching.py\",\n            \"def run(report, ui):\\n\"\n            '  report[\"itch\"] = \"scratch\"\\n'\n            '  return \"bash\"\\n',\n        )\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"itching\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_text, None)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertEqual(self.ui.report[\"itch\"], \"scratch\")\n        self.assertIn(\"DistroRelease\", self.ui.report)\n        self.assertEqual(self.ui.report[\"SourcePackage\"], \"bash\")\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash \"))\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Bug\")\n\n        # working noninteractive script with extra tag\n        argv = [\"ui-test\", \"--tag\", \"foo\", \"-s\", \"itching\"]\n        self.ui = UserInterfaceMock(argv)\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_text, None)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertEqual(self.ui.report[\"itch\"], \"scratch\")\n        self.assertIn(\"foo\", self.ui.report.get_tags())\n\n        # working interactive script\n        self._write_symptom_script(\n            \"itching.py\",\n            textwrap.dedent(\n                \"\"\"\\\n                def run(report, ui):\n                    report['itch'] = 'slap'\n                    report['q'] = str(ui.yesno('do you?'))\n                    return 'bash'\n                \"\"\"\n            ),\n        )\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"itching\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.question_yesno_response = True\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertTrue(self.ui.present_details_shown)\n        self.assertEqual(self.ui.msg_text, \"do you?\")\n\n        self.assertEqual(self.ui.report[\"itch\"], \"slap\")\n        self.assertIn(\"DistroRelease\", self.ui.report)\n        self.assertEqual(self.ui.report[\"SourcePackage\"], \"bash\")\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash \"))\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Bug\")\n        self.assertEqual(self.ui.report[\"q\"], \"True\")\n\n    def test_run_report_bug_list_symptoms(self):\n        \"\"\"run_report_bug() without specifying arguments and available\n        symptoms\"\"\"\n        self._write_symptom_script(\n            \"foo.py\",\n            textwrap.dedent(\n                \"\"\"\\\n                description = 'foo does not work'\n                def run(report, ui):\n                    return 'bash'\n                \"\"\"\n            ),\n        )\n        self._write_symptom_script(\n            \"bar.py\", 'def run(report, ui):\\n  return \"coreutils\"\\n'\n        )\n\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.ui.question_choice_response = None\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertIn(\"kind of problem\", self.ui.msg_text)\n        self.assertEqual(\n            set(self.ui.msg_choices),\n            set([\"bar\", \"foo does not work\", \"Other problem\"]),\n        )\n\n        # cancelled\n        self.assertEqual(self.ui.ic_progress_pulses, 0)\n        self.assertEqual(self.ui.report, None)\n        self.assertFalse(self.ui.present_details_shown)\n\n        # now, choose foo -> bash report\n        self.ui.question_choice_response = [\n            self.ui.msg_choices.index(\"foo does not work\")\n        ]\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertTrue(self.ui.present_details_shown)\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash\"))\n\n    @unittest.mock.patch(\"sys.stderr\", new_callable=io.StringIO)\n    def test_parse_argv_single_arg(self, stderr_mock):\n        \"\"\"parse_args() option inference for a single argument\"\"\"\n\n        def _chk(program_name, arg, expected_opts):\n            argv = [program_name]\n            if arg:\n                argv.append(arg)\n            ui = apport.ui.UserInterface(argv)\n            expected_opts[\"version\"] = False\n            self.assertEqual(ui.args.__dict__, expected_opts)\n            self.assertEqual(stderr_mock.getvalue(), \"\")\n\n        # no arguments -> show pending crashes\n        _chk(\n            \"apport-gtk\",\n            None,\n            {\n                \"filebug\": False,\n                \"package\": None,\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n        # updating report not allowed without args\n        self.assertRaises(SystemExit, _chk, \"apport-collect\", None, {})\n        self.assertIn(\n            \"error: the following arguments are required: report_number\",\n            stderr_mock.getvalue(),\n        )\n        stderr_mock.truncate(0)\n\n        # package\n        _chk(\n            \"apport-kde\",\n            \"coreutils\",\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # symptom is preferred over package\n        self._write_symptom_script(\n            \"coreutils.py\",\n            textwrap.dedent(\n                \"\"\"\\\n                description = 'foo does not work'\n                def run(report, ui):\n                    return 'bash'\n                \"\"\"\n            ),\n        )\n        _chk(\n            \"apport-cli\",\n            \"coreutils\",\n            {\n                \"filebug\": True,\n                \"package\": None,\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": \"coreutils\",\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # PID\n        _chk(\n            \"apport-cli\",\n            \"1234\",\n            {\n                \"filebug\": True,\n                \"package\": None,\n                \"pid\": \"1234\",\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # .crash/.apport files; check correct handling of spaces\n        for suffix in (\".crash\", \".apport\"):\n            _chk(\n                \"apport-cli\",\n                \"/tmp/f oo\" + suffix,\n                {\n                    \"filebug\": False,\n                    \"package\": None,\n                    \"pid\": None,\n                    \"crash_file\": \"/tmp/f oo\" + suffix,\n                    \"symptom\": None,\n                    \"update_report\": None,\n                    \"save\": None,\n                    \"window\": False,\n                    \"tags\": [],\n                    \"hanging\": False,\n                },\n            )\n\n        # executable\n        _chk(\n            \"apport-cli\",\n            \"/usr/bin/tail\",\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # update existing report\n        _chk(\n            \"apport-collect\",\n            \"1234\",\n            {\n                \"filebug\": False,\n                \"package\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": 1234,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n        _chk(\n            \"apport-update-bug\",\n            \"1234\",\n            {\n                \"filebug\": False,\n                \"package\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": 1234,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n    @unittest.mock.patch(\"sys.stderr\", new_callable=io.StringIO)\n    def test_parse_argv_apport_bug(self, stderr_mock):\n        \"\"\"parse_args() option inference when invoked as *-bug\"\"\"\n\n        def _chk(args, expected_opts):\n            ui = apport.ui.UserInterface([\"apport-bug\"] + args)\n            expected_opts[\"version\"] = False\n            self.assertEqual(ui.args.__dict__, expected_opts)\n            self.assertEqual(stderr_mock.getvalue(), \"\")\n\n        #\n        # no arguments: default to 'ask for symptom' bug mode\n        #\n        _chk(\n            [],\n            {\n                \"filebug\": True,\n                \"package\": None,\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        #\n        # single arguments\n        #\n\n        # package\n        _chk(\n            [\"coreutils\"],\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # symptom (preferred over package)\n        self._write_symptom_script(\n            \"coreutils.py\",\n            textwrap.dedent(\n                \"\"\"\\\n                description = 'foo does not work'\n                def run(report, ui):\n                    return 'bash'\n                \"\"\"\n            ),\n        )\n        _chk(\n            [\"coreutils\"],\n            {\n                \"filebug\": True,\n                \"package\": None,\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": \"coreutils\",\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n        os.unlink(os.path.join(apport.ui.symptom_script_dir, \"coreutils.py\"))\n\n        # PID\n        _chk(\n            [\"1234\"],\n            {\n                \"filebug\": True,\n                \"package\": None,\n                \"pid\": \"1234\",\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # .crash/.apport files; check correct handling of spaces\n        for suffix in (\".crash\", \".apport\"):\n            _chk(\n                [\"/tmp/f oo\" + suffix],\n                {\n                    \"filebug\": False,\n                    \"package\": None,\n                    \"pid\": None,\n                    \"crash_file\": \"/tmp/f oo\" + suffix,\n                    \"symptom\": None,\n                    \"update_report\": None,\n                    \"save\": None,\n                    \"window\": False,\n                    \"tags\": [],\n                    \"hanging\": False,\n                },\n            )\n\n        # executable name\n        _chk(\n            [\"/usr/bin/tail\"],\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        #\n        # supported options\n        #\n\n        # --save\n        _chk(\n            [\"--save\", \"foo.apport\", \"coreutils\"],\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": \"foo.apport\",\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # --tag\n        _chk(\n            [\"--tag\", \"foo\", \"coreutils\"],\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [\"foo\"],\n                \"hanging\": False,\n            },\n        )\n        _chk(\n            [\"--tag\", \"foo\", \"--tag\", \"bar\", \"coreutils\"],\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [\"foo\", \"bar\"],\n                \"hanging\": False,\n            },\n        )\n\n        # mutually exclusive options\n        self.assertRaises(\n            SystemExit, _chk, [\"-c\", \"/tmp/foo.report\", \"-u\", \"1234\"], {}\n        )\n\n    def test_can_examine_locally_crash(self):\n        \"\"\"can_examine_locally() for a crash report\"\"\"\n        self.ui.load_report(self.report_file.name)\n\n        orig_path = os.environ[\"PATH\"]\n        orig_fn = self.ui.ui_has_terminal\n        try:\n            self.ui.ui_has_terminal = lambda command: True\n            os.environ[\"PATH\"] = \"\"\n            self.assertEqual(self.ui.can_examine_locally(), False)\n\n            src_bindir = os.path.join(\n                os.path.dirname(os.path.dirname(os.path.realpath(__file__))),\n                \"bin\",\n            )\n            # this will only work for running the tests in the source tree\n            if os.access(os.path.join(src_bindir, \"apport-retrace\"), os.X_OK):\n                os.environ[\"PATH\"] += src_bindir + \":\" + orig_path\n                self.assertEqual(self.ui.can_examine_locally(), True)\n            else:\n                # if we run tests in installed system, we just check that\n                # it doesn't crash\n                self.assertIn(self.ui.can_examine_locally(), [False, True])\n\n            self.ui.ui_has_terminal = lambda command: False\n            self.assertEqual(self.ui.can_examine_locally(), False)\n\n            # does not crash on NotImplementedError\n            self.ui.ui_has_terminal = orig_fn\n            self.assertEqual(self.ui.can_examine_locally(), False)\n\n        finally:\n            os.environ[\"PATH\"] = orig_path\n            self.ui.ui_has_terminal = orig_fn\n\n    def test_can_examine_locally_nocrash(self):\n        \"\"\"can_examine_locally() for a non-crash report\"\"\"\n        self.ui.load_report(self.report_file.name)\n        del self.ui.report[\"CoreDump\"]\n\n        orig_fn = self.ui.ui_has_terminal\n        try:\n            self.ui.ui_has_terminal = lambda command: True\n            self.assertEqual(self.ui.can_examine_locally(), False)\n        finally:\n            self.ui.ui_has_terminal = orig_fn\n\n    def test_db_no_accept(self):\n        \"\"\"Crash database does not accept report.\"\"\"\n        # FIXME: This behaviour is not really correct, but necessary as long as\n        # we only support a single crashdb and have whoopsie hardcoded\n        # (see LP#957177)\n\n        latest_id_before = self.ui.crashdb.latest_id()\n\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-p\", \"bash\"])\n\n        # Pretend it does not accept report\n        self.ui.crashdb.accepts = lambda r: False\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        # data was collected for whoopsie\n        self.assertEqual(self.ui.report[\"SourcePackage\"], \"bash\")\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Bug\")\n\n        # no upload happend\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertEqual(self.ui.upload_progress_pulses, 0)\n        self.assertEqual(self.ui.crashdb.latest_id(), latest_id_before)\n\n    def test_get_desktop_entry(self):\n        \"\"\"Parsee .desktop files.\"\"\"\n        with tempfile.NamedTemporaryFile(mode=\"w+\") as desktop_file:\n            desktop_file.write(\n                textwrap.dedent(\n                    \"\"\"\\\n                    [Desktop Entry]\n                    Name=gtranslate\n                    GenericName=Translator\n                    GenericName[de]=\u00dcbersetzer\n                    Exec=gedit %U\n                    Categories=GNOME;GTK;Utility;TextEditor;\n                    \"\"\"\n                )\n            )\n            desktop_file.flush()\n\n            self.report[\"DesktopFile\"] = desktop_file.name\n            self.ui.report = self.report\n            info = self.ui.get_desktop_entry()\n\n            self.assertEqual(\n                info,\n                {\n                    \"genericname\": \"Translator\",\n                    \"categories\": \"GNOME;GTK;Utility;TextEditor;\",\n                    \"name\": \"gtranslate\",\n                    \"genericname[de]\": \"\u00dcbersetzer\",\n                    \"exec\": \"gedit %U\",\n                },\n            )\n\n    def test_get_desktop_entry_broken(self):\n        \"\"\"Parse broken .desktop files.\"\"\"\n        # duplicate key\n        with tempfile.NamedTemporaryFile(mode=\"w+\") as desktop_file:\n            desktop_file.write(\n                textwrap.dedent(\n                    \"\"\"\\\n                    [Desktop Entry]\n                    Name=gtranslate\n                    GenericName=Translator\n                    GenericName[de]=\u00dcbersetzer\n                    Exec=gedit %U\n                    Keywords=foo;bar;\n                    Categories=GNOME;GTK;Utility;TextEditor;\n                    Keywords=baz\n                    \"\"\"\n                )\n            )\n            desktop_file.flush()\n\n            self.report[\"DesktopFile\"] = desktop_file.name\n            self.ui.report = self.report\n            info = self.ui.get_desktop_entry()\n            self.assertEqual(\n                info,\n                {\n                    \"genericname\": \"Translator\",\n                    \"categories\": \"GNOME;GTK;Utility;TextEditor;\",\n                    \"name\": \"gtranslate\",\n                    \"genericname[de]\": \"\u00dcbersetzer\",\n                    \"keywords\": \"baz\",\n                    \"exec\": \"gedit %U\",\n                },\n            )\n\n            # no header\n            desktop_file.seek(0)\n            desktop_file.write(\n                textwrap.dedent(\n                    \"\"\"\\\n                    Name=gtranslate\n                    GenericName=Translator\n                    Exec=gedit %U\n                    \"\"\"\n                )\n            )\n            desktop_file.flush()\n\n            self.assertEqual(self.ui.get_desktop_entry(), None)\n\n            # syntax error\n            desktop_file.seek(0)\n            desktop_file.write(\n                textwrap.dedent(\n                    \"\"\"\\\n                    [Desktop Entry]\n                    Name gtranslate\n                    GenericName=Translator\n                    Exec=gedit %U\n                    \"\"\"\n                )\n            )\n            desktop_file.flush()\n\n            self.assertEqual(self.ui.get_desktop_entry(), None)\n\n    def test_wait_for_pid(self):\n        # fork a test process\n        with self._run_test_executable() as pid:\n            pass\n        self.ui.wait_for_pid(pid)\n\n    @unittest.mock.patch(\"os.getgid\", unittest.mock.MagicMock(return_value=0))\n    @unittest.mock.patch(\"os.getuid\", unittest.mock.MagicMock(return_value=0))\n    @unittest.mock.patch.dict(\n        \"os.environ\", {\"SUDO_UID\": str(os.getuid())}, clear=True\n    )\n    def test_run_as_real_user(self) -> None:\n        \"\"\"Test run_as_real_user() with SUDO_UID set.\"\"\"\n        pwuid = pwd.getpwuid(int(os.environ[\"SUDO_UID\"]))\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # rename test program to fake gvfsd\n            gvfsd_mock = os.path.join(tmpdir, \"gvfsd\")\n            shutil.copy(self.TEST_EXECUTABLE, gvfsd_mock)\n            gvfsd_env = {\n                \"XDG_DATA_DIRS\": \"mocked XDG data dir\",\n                \"DBUS_SESSION_BUS_ADDRESS\": \"/fake/dbus/path\",\n            }\n            with self._run_test_executable(gvfsd_mock, env=gvfsd_env):\n                with unittest.mock.patch(\n                    \"subprocess.run\", side_effect=mock_run_calls_except_pgrep\n                ) as run_mock:\n                    run_as_real_user([\"/bin/true\"])\n\n        run_mock.assert_called_with(\n            [\"/bin/true\"],\n            check=False,\n            env={\n                \"DBUS_SESSION_BUS_ADDRESS\": \"/fake/dbus/path\",\n                \"XDG_DATA_DIRS\": \"mocked XDG data dir\",\n                \"HOME\": pwuid.pw_dir,\n            },\n            user=int(os.environ[\"SUDO_UID\"]),\n            group=pwuid.pw_gid,\n            extra_groups=os.getgrouplist(pwuid.pw_name, pwuid.pw_gid),\n        )\n        self.assertEqual(run_mock.call_count, 2)\n\n    @unittest.mock.patch(\"os.getgid\", unittest.mock.MagicMock(return_value=0))\n    @unittest.mock.patch(\"os.getuid\", unittest.mock.MagicMock(return_value=0))\n    @unittest.mock.patch.dict(\"os.environ\", {\"SUDO_UID\": \"1337\"}, clear=True)\n    @unittest.mock.patch(\"pwd.getpwuid\")\n    def test_run_as_real_user_no_gvfsd(\n        self, getpwuid_mock: unittest.mock.MagicMock\n    ) -> None:\n        \"\"\"Test run_as_real_user() without no gvfsd process.\"\"\"\n        getpwuid_mock.return_value = pwd.struct_passwd(\n            (\n                \"testuser\",\n                \"x\",\n                1337,\n                42,\n                \"Test user,,,\",\n                \"/home/testuser\",\n                \"/bin/bash\",\n            )\n        )\n        with unittest.mock.patch(\n            \"subprocess.run\", side_effect=mock_run_calls_except_pgrep\n        ) as run_mock:\n            run_as_real_user([\"/bin/true\"])\n\n        run_mock.assert_called_with(\n            [\"/bin/true\"],\n            check=False,\n            env={\"HOME\": \"/home/testuser\"},\n            user=1337,\n            group=42,\n            extra_groups=[42],\n        )\n        self.assertEqual(run_mock.call_count, 2)\n\n    @unittest.mock.patch.dict(\"os.environ\", {})\n    def test_run_as_real_user_no_sudo(self) -> None:\n        # pylint: disable=no-self-use\n        \"\"\"Test run_as_real_user() without sudo env variables.\"\"\"\n        with unittest.mock.patch(\n            \"subprocess.run\", side_effect=mock_run_calls_except_pgrep\n        ) as run_mock:\n            run_as_real_user([\"/bin/true\"])\n\n        run_mock.assert_called_once_with([\"/bin/true\"], check=False)\n\n    @unittest.mock.patch(\"os.getgid\", unittest.mock.MagicMock(return_value=37))\n    @unittest.mock.patch(\"os.getuid\", unittest.mock.MagicMock(return_value=37))\n    @unittest.mock.patch.dict(\"os.environ\", {\"SUDO_UID\": \"0\"})\n    def test_run_as_real_user_non_root(self) -> None:\n        # pylint: disable=no-self-use\n        \"\"\"Test run_as_real_user() as non-root and SUDO_UID set.\"\"\"\n        with unittest.mock.patch(\n            \"subprocess.run\", side_effect=mock_run_calls_except_pgrep\n        ) as run_mock:\n            run_as_real_user([\"/bin/true\"])\n\n        run_mock.assert_called_once_with([\"/bin/true\"], check=False)\n"], "fixing_code": ["\"\"\"Abstract Apport user interface.\n\nThis encapsulates the workflow and common code for any user interface\nimplementation (like GTK, Qt, or CLI).\n\"\"\"\n\n# Copyright (C) 2007 - 2011 Canonical Ltd.\n# Author: Martin Pitt <martin.pitt@ubuntu.com>\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by the\n# Free Software Foundation; either version 2 of the License, or (at your\n# option) any later version.  See http://www.gnu.org/copyleft/gpl.html for\n# the full text of the license.\n\nimport argparse\nimport ast\nimport configparser\nimport dataclasses\nimport errno\nimport gettext\nimport glob\nimport gzip\nimport io\nimport locale\nimport os.path\nimport pwd\nimport queue\nimport re\nimport shutil\nimport signal\nimport smtplib\nimport subprocess\nimport sys\nimport threading\nimport time\nimport traceback\nimport typing\nimport urllib.error\nimport webbrowser\nimport zlib\nfrom gettext import gettext as _\n\nimport apport.crashdb\nimport apport.fileutils\nimport apport.logging\nimport apport.REThread\nfrom apport.packaging_impl import impl as packaging\nfrom apport.user_group import get_process_user_and_group\n\n__version__ = \"2.26.0\"\n\n\nsymptom_script_dir = os.environ.get(\n    \"APPORT_SYMPTOMS_DIR\", \"/usr/share/apport/symptoms\"\n)\nPF_KTHREAD = 0x200000\n\n\ndef get_pid(report):\n    try:\n        pid = re.search(\"Pid:\\t(.*)\\n\", report.get(\"ProcStatus\", \"\")).group(1)\n        return int(pid)\n    except (IndexError, AttributeError):\n        return None\n\n\ndef _get_env_int(\n    key: str, default: typing.Optional[int] = None\n) -> typing.Optional[int]:\n    \"\"\"Get an environment variable as integer.\n\n    Return None if it doesn't exist or failed to convert to integer.\n    The optional second argument can specify an alternate default.\n    \"\"\"\n    try:\n        return int(os.environ[key])\n    except (KeyError, ValueError):\n        return default\n\n\ndef _get_newest_process_for_user(name: str, uid: int) -> typing.Optional[int]:\n    process = subprocess.run(\n        [\"pgrep\", \"-n\", \"-x\", \"-u\", str(uid), name],\n        capture_output=True,\n        check=False,\n        text=True,\n    )\n    if process.returncode != 0 or not process.stdout:\n        return None\n    return int(process.stdout.strip())\n\n\ndef _get_users_environ(uid: int) -> dict[str, str]:\n    \"\"\"Find D-BUS address and XDG_DATA_DIRS for the given user.\n\n    The D-BUS address and XDG_DATA_DIRS is needed for xdg-open. It is\n    incredibly hard, or alternatively, unsafe to funnel it through\n    pkexec/env/sudo, so grab it from gvfsd.\n    \"\"\"\n    gvfsd_pid = _get_newest_process_for_user(\"gvfsd\", uid)\n    if gvfsd_pid is None:\n        return {}\n\n    gvfsd_pid_fd = os.open(\n        f\"/proc/{gvfsd_pid}\", os.O_RDONLY | os.O_PATH | os.O_DIRECTORY\n    )\n    try:\n        gvfsd_env = apport.fileutils.get_process_environ(gvfsd_pid_fd)\n    except OSError:\n        return {}\n    finally:\n        os.close(gvfsd_pid_fd)\n\n    return {\n        key: gvfsd_env[key]\n        for key in [\"DBUS_SESSION_BUS_ADDRESS\", \"XDG_DATA_DIRS\"]\n        if key in gvfsd_env\n    }\n\n\ndef run_as_real_user(\n    args: list[str], *, get_user_env: bool = False, **kwargs\n) -> None:\n    \"\"\"Call subprocess.run as real user if called via sudo/pkexec.\n\n    If we are called through pkexec/sudo, determine the real user ID and\n    run the command with it to get the user's web browser settings.\n    If get_user_env is set to True, the D-BUS address and XDG_DATA_DIRS\n    is grabbed from a running gvfsd and added to the process environment.\n    \"\"\"\n    uid = _get_env_int(\"SUDO_UID\", _get_env_int(\"PKEXEC_UID\"))\n    if uid is None or not get_process_user_and_group().is_root():\n        subprocess.run(args, check=False, **kwargs)\n        return\n\n    pwuid = pwd.getpwuid(uid)\n\n    gid = _get_env_int(\"SUDO_GID\")\n    if gid is None:\n        gid = pwuid.pw_gid\n\n    env = {\n        k: v\n        for k, v in os.environ.items()\n        if not k.startswith(\"SUDO_\") and k != \"PKEXEC_UID\"\n    }\n    if get_user_env:\n        env |= _get_users_environ(uid)\n    env[\"HOME\"] = pwuid.pw_dir\n    subprocess.run(\n        args,\n        check=False,\n        env=env,\n        user=uid,\n        group=gid,\n        extra_groups=os.getgrouplist(pwuid.pw_name, gid),\n        **kwargs,\n    )\n\n\ndef still_running(pid):\n    try:\n        os.kill(int(pid), 0)\n    except OSError as error:\n        if error.errno == errno.ESRCH:\n            return False\n    return True\n\n\ndef thread_collect_info(\n    report,\n    reportfile,\n    package,\n    ui,\n    symptom_script=None,\n    ignore_uninstalled=False,\n):\n    \"\"\"Collect information about report.\n\n    Encapsulate calls to add_*_info() and update given report, so that this\n    function is suitable for threading.\n\n    ui must be a HookUI instance, it gets passed to add_hooks_info().\n\n    If reportfile is not None, the file is written back with the new data.\n\n    If symptom_script is given, it will be run first (for run_symptom()).\n    \"\"\"\n    assert isinstance(ui, HookUI)\n    try:\n        report.add_gdb_info()\n    except OSError:\n        # it's okay if gdb is not installed on the client side; we'll get stack\n        # traces on retracing.\n        pass\n    report.add_os_info()\n\n    if symptom_script:\n        symb = {}\n        try:\n            with open(symptom_script, encoding=\"utf-8\") as f:\n                # legacy, pylint: disable=exec-used\n                exec(compile(f.read(), symptom_script, \"exec\"), symb)\n            package = symb[\"run\"](report, ui)\n            if not package:\n                apport.logging.error(\n                    \"symptom script %s did not determine the affected package\",\n                    symptom_script,\n                )\n                return\n            report[\"Symptom\"] = os.path.splitext(\n                os.path.basename(symptom_script)\n            )[0]\n        except StopIteration:\n            sys.exit(0)\n        except Exception:  # pylint: disable=broad-except\n            apport.logging.error(\"symptom script %s crashed:\", symptom_script)\n            traceback.print_exc()\n            sys.exit(0)\n\n    if not package:\n        if \"ExecutablePath\" in report:\n            package = apport.fileutils.find_file_package(\n                report[\"ExecutablePath\"]\n            )\n        else:\n            raise KeyError(\n                \"called without a package,\"\n                \" and report does not have ExecutablePath\"\n            )\n\n    # check if the package name relates to an installed snap\n    snap = apport.fileutils.find_snap(package)\n    if snap:\n        report.add_snap_info(snap)\n\n    try:\n        report.add_package_info(package)\n    except ValueError:\n        # this happens if we are collecting information on an uninstalled\n        # package\n\n        # we found no package, but a snap, so lets continue\n        if not ignore_uninstalled and \"Snap\" not in report:\n            raise\n    except SystemError as error:\n        report[\"UnreportableReason\"] = str(error)\n\n    if \"UnreportableReason\" not in report:\n        if report.add_hooks_info(ui):\n            sys.exit(0)\n\n        # check package origin; we do that after adding hooks, so that hooks\n        # have the chance to set a third-party CrashDB.\n        try:\n            if (\n                \"CrashDB\" not in report\n                and \"APPORT_DISABLE_DISTRO_CHECK\" not in os.environ\n            ):\n                if \"Package\" not in report and \"Snap\" not in report:\n                    report[\"UnreportableReason\"] = _(\n                        \"This package does not seem to be installed correctly\"\n                    )\n                elif not packaging.is_distro_package(\n                    report[\"Package\"].split()[0]\n                ) and not packaging.is_native_origin_package(\n                    report[\"Package\"].split()[0]\n                ):\n                    # TRANS: %s is the name of the operating system\n                    report[\"UnreportableReason\"] = (\n                        _(\n                            \"This does not seem to be an official %s package.\"\n                            \" Please retry after updating the indexes of\"\n                            \" available packages, if that does not work\"\n                            \" then remove related third party packages\"\n                            \" and try again.\"\n                        )\n                        % report[\"DistroRelease\"].split()[0]\n                    )\n        except ValueError:\n            # this happens if we are collecting information on an uninstalled\n            # package\n\n            # we found no package, but a snap, so lets continue\n            if not ignore_uninstalled and \"Snap\" not in report:\n                raise\n\n    # add title\n    if \"Title\" not in report:\n        title = report.standard_title()\n        if title:\n            report[\"Title\"] = title\n\n    # check obsolete packages\n    if (\n        report.get(\"ProblemType\") == \"Crash\"\n        and \"APPORT_IGNORE_OBSOLETE_PACKAGES\" not in os.environ\n    ):\n        old_pkgs = report.obsolete_packages()\n        if old_pkgs:\n            report[\"UnreportableReason\"] = _(\n                \"You have some obsolete package versions installed.\"\n                \" Please upgrade the following packages\"\n                \" and check if the problem still occurs:\\n\\n%s\"\n            ) % \", \".join(old_pkgs)\n\n    if reportfile:\n        try:\n            with open(reportfile, \"ab\") as f:\n                os.chmod(reportfile, 0)\n                report.write(f, only_new=True)\n        except OSError as error:\n            # this should happen very rarely; presumably a new crash report is\n            # being generated by a background apport instance (which will set\n            # the file to permissions zero while writing), while the first\n            # report is being processed\n            apport.logging.error(\"Cannot update %s: %s\", reportfile, error)\n\n        apport.fileutils.mark_report_seen(reportfile)\n        os.chmod(reportfile, 0o640)\n\n\n@dataclasses.dataclass\nclass Action:\n    examine: bool = False\n    ignore: bool = False\n    remember: bool = False\n    report: bool = False\n    restart: bool = False\n\n\nclass UserInterface:\n    \"\"\"Apport user interface API.\n\n    This provides an abstract base class for encapsulating the workflow and\n    common code for any user interface implementation (like GTK, Qt, or CLI).\n\n    A concrete subclass must implement all the abstract ui_* methods.\n    \"\"\"\n\n    def __init__(self, argv: list[str]):\n        \"\"\"Initialize program state and parse command line options.\"\"\"\n        self.gettext_domain = \"apport\"\n        self.report = None\n        self.report_file = None\n        self.cur_package = None\n        self.offer_restart = False\n        self.specified_a_pkg = False\n        self.upload_progress = None\n\n        try:\n            self.crashdb = apport.crashdb.get_crashdb(None)\n        except ImportError as error:\n            # this can happen while upgrading python packages\n            apport.logging.fatal(\n                \"Could not import module, is a package upgrade in progress?\"\n                \" Error: %s\",\n                str(error),\n            )\n        except KeyError:\n            apport.logging.fatal(\n                \"/etc/apport/crashdb.conf is damaged: No default database\"\n            )\n\n        gettext.textdomain(self.gettext_domain)\n        self.args = self.parse_argv(argv)\n\n    #\n    # main entry points\n    #\n\n    def run_crashes(self):\n        \"\"\"Present all currently pending crash reports.\n\n        Ask the user what to do about them, and offer to file bugs for them.\n\n        Crashes that occurred in a different desktop (logind) session than the\n        one that is currently running are not processed. This skips crashes\n        that happened during logout, which are uninteresting and confusing to\n        see at the next login.\n\n        Return True if at least one crash report was processed, False\n        otherwise.\n        \"\"\"\n        result = False\n        # for iterating over /var/crash (as opposed to running on or clicking\n        # on a particular .crash file) we offer restarting\n        self.offer_restart = True\n\n        if os.geteuid() == 0:\n            reports = apport.fileutils.get_new_system_reports()\n            logind_session = None\n        else:\n            reports = apport.fileutils.get_new_reports()\n            proc_pid_fd = os.open(\n                \"/proc/%s\" % os.getpid(),\n                os.O_RDONLY | os.O_PATH | os.O_DIRECTORY,\n            )\n            logind_session = apport.Report.get_logind_session(\n                proc_pid_fd=proc_pid_fd\n            )\n\n        for f in reports:\n            if not self.load_report(f):\n                continue\n\n            # Skip crashes that happened during logout, which are uninteresting\n            # and confusing to see at the next login. A crash happened and gets\n            # reported in the same session if the logind session paths agree\n            # and the session started before the report's \"Date\".\n            if (\n                logind_session\n                and \"_LogindSession\" in self.report\n                and \"Date\" in self.report\n            ):\n                # report.get_timestamp() can return None\n                if not self.report.get_timestamp():\n                    continue\n                if (\n                    logind_session[0] != self.report[\"_LogindSession\"]\n                    or logind_session[1] > self.report.get_timestamp()\n                ):\n                    continue\n\n            if self.report[\"ProblemType\"] == \"Hang\":\n                self.finish_hang(f)\n            else:\n                self.run_crash(f)\n            result = True\n\n        return result\n\n    def run_crash(self, report_file):\n        \"\"\"Present and report a particular crash.\n\n        If confirm is True, ask the user what to do about it, and offer to file\n        a bug for it.\n\n        If confirm is False, the user will not be asked, and the crash is\n        reported right away.\n        \"\"\"\n        self.report_file = report_file\n\n        try:\n            try:\n                apport.fileutils.mark_report_seen(report_file)\n            except OSError:\n                # not there any more? no problem, then it won't be regarded as\n                # \"seen\" any more anyway\n                pass\n            if not self.report and not self.load_report(report_file):\n                return\n\n            if \"Ignore\" in self.report:\n                return\n\n            # check for absent CoreDumps (removed if they exceed size limit)\n            if (\n                self.report.get(\"ProblemType\") == \"Crash\"\n                and \"Signal\" in self.report\n                and \"CoreDump\" not in self.report\n                and \"Stacktrace\" not in self.report\n            ):\n                subject = os.path.basename(\n                    self.report.get(\"ExecutablePath\", _(\"unknown program\"))\n                )\n                heading = (\n                    _('Sorry, the program \"%s\" closed unexpectedly') % subject\n                )\n                self.ui_error_message(\n                    _(\"Problem in %s\") % subject,\n                    \"%s\\n\\n%s\"\n                    % (\n                        heading,\n                        _(\n                            \"Your computer does not have enough free \"\n                            \"memory to automatically analyze the problem \"\n                            \"and send a report to the developers.\"\n                        ),\n                    ),\n                )\n                return\n\n            allowed_to_report = apport.fileutils.allowed_to_report()\n            response = self.ui_present_report_details(allowed_to_report)\n            if response.report or response.examine:\n                if \"Dependencies\" not in self.report:\n                    self.collect_info()\n\n            if self.report is None:\n                # collect() does that on invalid reports\n                return\n\n            if response.examine:\n                self.examine()\n                return\n            if response.restart:\n                self.restart()\n            if response.ignore:\n                self.report.mark_ignore()\n            try:\n                if response.remember:\n                    self.remember_send_report(response.report)\n            # use try/expect for python2 support. Old reports (generated\n            # pre-apport 2.20.10-0ubuntu4) may not have the remember key\n            # and can be loaded afterwards (or after dist-upgrade)\n            except KeyError:\n                pass\n            if not response.report:\n                return\n\n            # We don't want to send crashes to the crash database for binaries\n            # that changed since the crash happened. See LP: #1039220 for\n            # details.\n            if (\n                \"_MarkForUpload\" in self.report\n                and self.report[\"_MarkForUpload\"] != \"False\"\n            ):\n                apport.fileutils.mark_report_upload(report_file)\n            # We check for duplicates and unreportable crashes here, rather\n            # than before we show the dialog, as we want to submit these to the\n            # crash database, but not Launchpad.\n            if self.crashdb.accepts(self.report):\n                # FIXME: This behaviour is not really correct, but necessary as\n                # long as we only support a single crashdb and have whoopsie\n                # hardcoded. Once we have multiple crash dbs, we need to check\n                # accepts() earlier, and not even present the data if none of\n                # the DBs wants the report. See LP#957177 for details.\n                if self.handle_duplicate():\n                    return\n                if self.check_unreportable():\n                    return\n                self.file_report()\n        except PermissionError:\n            self.ui_error_message(\n                _(\"Invalid problem report\"),\n                _(\"You are not allowed to access this problem report.\"),\n            )\n            sys.exit(1)\n        except OSError as error:\n            if error.errno == errno.ENOMEM:\n                apport.logging.fatal(\"Out of memory, aborting\")\n            elif error.errno == errno.ENOSPC:\n                self.ui_error_message(\n                    _(\"Error\"),\n                    _(\n                        \"There is not enough disk space\"\n                        \" available to process this report.\"\n                    ),\n                )\n                sys.exit(1)\n            elif error.errno == errno.EIO:\n                self.ui_error_message(\n                    _(\"Invalid problem report\"), error.strerror\n                )\n                sys.exit(1)\n            raise\n\n    @staticmethod\n    def finish_hang(f):\n        \"\"\"Finish processing a hanging application after the core pipe handler\n        has handed the report back.\n\n        This will signal to whoopsie that the report needs to be uploaded.\n        \"\"\"\n        apport.fileutils.mark_report_upload(f)\n        apport.fileutils.mark_report_seen(f)\n\n    def run_hang(self, pid):\n        \"\"\"Report an application hanging.\n\n        This will first present a dialog containing the information it can\n        collect from the running application (everything but the trace) with\n        the option of terminating or restarting the application, optionally\n        reporting that this error occurred.\n\n        A SIGABRT will then be sent to the process and a series of\n        noninteractive processes will collect the remaining information and\n        mark the report for uploading.\n        \"\"\"\n        self.report = apport.Report(\"Hang\")\n\n        if not self.args.pid:\n            self.ui_error_message(\n                _(\"No PID specified\"),\n                _(\n                    \"You need to specify a PID.\"\n                    \" See --help for more information.\"\n                ),\n            )\n            return False\n\n        try:\n            self.report.add_proc_info(pid)\n        except ValueError as error:\n            if str(error) == \"invalid process\":\n                self.ui_error_message(\n                    _(\"Invalid PID\"),\n                    _(\"The specified process ID does not exist.\"),\n                )\n                sys.exit(1)\n            elif str(error) == \"not accessible\":\n                self.ui_error_message(\n                    _(\"Not your PID\"),\n                    _(\"The specified process ID does not belong to you.\"),\n                )\n                sys.exit(1)\n        self.report.add_package_info()\n        path = self.report.get(\"ExecutablePath\", \"\")\n        self.cur_package = apport.fileutils.find_file_package(path)\n        self.report.add_os_info()\n        allowed_to_report = apport.fileutils.allowed_to_report()\n        response = self.ui_present_report_details(\n            allowed_to_report, modal_for=pid\n        )\n        if response.report:\n            apport.fileutils.mark_hanging_process(self.report, pid)\n            os.kill(int(pid), signal.SIGABRT)\n        else:\n            os.kill(int(pid), signal.SIGKILL)\n\n        if response.restart:\n            self.wait_for_pid(pid)\n            self.restart()\n        return True\n\n    @staticmethod\n    def wait_for_pid(pid):\n        \"\"\"waitpid() does not work for non-child processes. Query the process\n        state in a loop, waiting for \"no such process.\"\n        \"\"\"\n        while True:\n            try:\n                os.kill(int(pid), 0)\n            except OSError as error:\n                if error.errno == errno.ESRCH:\n                    break\n                raise\n            time.sleep(1)\n\n    @staticmethod\n    def kill_segv(pid):\n        os.kill(int(pid), signal.SIGSEGV)\n\n    def run_report_bug(self, symptom_script=None):\n        \"\"\"Report a bug.\n\n        If a pid is given on the command line, the report will contain runtime\n        debug information. Either a package or a pid must be specified; if none\n        is given, show a list of symptoms.\n\n        If a symptom script is given, this will be run first (used by\n        run_symptom()).\n        \"\"\"\n        if not self.args.package and not self.args.pid and not symptom_script:\n            if self.run_symptoms():\n                return True\n\n            self.ui_error_message(\n                _(\"No package specified\"),\n                _(\n                    \"You need to specify a package or a PID.\"\n                    \" See --help for more information.\"\n                ),\n            )\n            return False\n\n        self.report = apport.Report(\"Bug\")\n\n        # if PID is given, add info\n        if self.args.pid:\n            try:\n                proc_pid_fd = os.open(\n                    \"/proc/%s\" % self.args.pid,\n                    os.O_RDONLY | os.O_PATH | os.O_DIRECTORY,\n                )\n                stat_file = os.open(\"stat\", os.O_RDONLY, dir_fd=proc_pid_fd)\n                with io.open(stat_file, encoding=\"utf-8\") as f:\n                    stat = f.read().split()\n                flags = int(stat[8])\n                if flags & PF_KTHREAD:\n                    # this PID is a kernel thread\n                    self.args.package = \"linux\"\n                else:\n                    self.report.add_proc_info(\n                        pid=self.args.pid, proc_pid_fd=proc_pid_fd\n                    )\n            except PermissionError:\n                self.ui_error_message(\n                    _(\"Permission denied\"),\n                    _(\n                        \"The specified process does not belong to you. Please\"\n                        \" run this program as the process owner or as root.\"\n                    ),\n                )\n                return False\n            except (ValueError, OSError) as error:\n                if getattr(error, \"errno\", None) == errno.ENOENT:\n                    # silently ignore nonexisting PIDs; the user must not\n                    # close the application prematurely\n                    return False\n                self.ui_error_message(\n                    _(\"Invalid PID\"),\n                    _(\n                        \"The specified process ID does not belong\"\n                        \" to a program.\"\n                    ),\n                )\n                return False\n        else:\n            self.report.add_proc_environ()\n\n        if self.args.package:\n            self.args.package = self.args.package.strip()\n        # \"Do what I mean\" for filing against \"linux\"\n        if self.args.package == \"linux\":\n            self.cur_package = packaging.get_kernel_package()\n        else:\n            self.cur_package = self.args.package\n\n        try:\n            self.collect_info(symptom_script)\n        except ValueError as error:\n            if \"package\" in str(error) and \"does not exist\" in str(error):\n                if not self.cur_package:\n                    self.ui_error_message(\n                        _(\"Invalid problem report\"),\n                        _(\n                            \"Symptom script %s did not determine\"\n                            \" an affected package\"\n                        )\n                        % symptom_script,\n                    )\n                else:\n                    self.ui_error_message(\n                        _(\"Invalid problem report\"),\n                        _(\"Package %s does not exist\") % self.cur_package,\n                    )\n                return False\n            raise\n\n        if self.check_unreportable():\n            return False\n\n        self.add_extra_tags()\n\n        if self.handle_duplicate():\n            return True\n\n        # not useful for bug reports, and has potentially sensitive information\n        try:\n            del self.report[\"ProcCmdline\"]\n        except KeyError:\n            pass\n\n        if self.args.save:\n            try:\n                savefile = os.path.expanduser(self.args.save)\n                if savefile.endswith(\".gz\"):\n                    with gzip.open(savefile, \"wb\") as f:\n                        self.report.write(f)\n                else:\n                    with open(os.path.expanduser(self.args.save), \"wb\") as f:\n                        self.report.write(f)\n            except OSError as error:\n                self.ui_error_message(_(\"Cannot create report\"), str(error))\n        else:\n            # show what's being sent\n            allowed_to_report = True\n            response = self.ui_present_report_details(allowed_to_report)\n            if response.report:\n                self.file_report()\n\n        return True\n\n    def run_update_report(self):\n        \"\"\"Update an existing bug with locally collected information.\"\"\"\n        # avoid irrelevant noise\n        if not self.crashdb.can_update(self.args.update_report):\n            self.ui_error_message(\n                _(\"Updating problem report\"),\n                _(\n                    \"You are not the reporter or subscriber of this \"\n                    \"problem report, or the report is a duplicate or already \"\n                    'closed.\\n\\nPlease create a new report using \"apport-bug\".'\n                ),\n            )\n            return False\n\n        is_reporter = self.crashdb.is_reporter(self.args.update_report)\n\n        if not is_reporter:\n            r = self.ui_question_yesno(\n                _(\n                    \"You are not the reporter of this problem report. It is \"\n                    \"much easier to mark a bug as a duplicate of another than \"\n                    \"to move your comments and attachments to a new bug.\\n\\n\"\n                    \"Subsequently, we recommend that you file a new bug \"\n                    'report using \"apport-bug\" and make a comment in this bug '\n                    \"about the one you file.\\n\\nDo you really want to proceed?\"\n                )\n            )\n            if not r:\n                return False\n\n        # list of affected source packages\n        self.report = apport.Report(\"Bug\")\n        if self.args.package:\n            pkgs = [self.args.package.strip()]\n        else:\n            pkgs = self.crashdb.get_affected_packages(self.args.update_report)\n\n        info_collected = False\n        for p in pkgs:\n            # print(f\"Collecting apport information for source package {p}...\")\n            self.cur_package = p\n            self.report[\"SourcePackage\"] = p\n            self.report[\"Package\"] = p  # no way to find this out\n\n            # we either must have the package installed or a source package\n            # hook available to collect sensible information\n            try:\n                packaging.get_version(p)\n            except ValueError:\n                if not os.path.exists(\n                    os.path.join(\n                        apport.report.PACKAGE_HOOK_DIR, \"source_%s.py\" % p\n                    )\n                ):\n                    print(\n                        \"Package %s not installed and no hook available,\"\n                        \" ignoring\" % p\n                    )\n                    continue\n            self.collect_info(ignore_uninstalled=True)\n            info_collected = True\n\n        if not info_collected:\n            self.ui_info_message(\n                _(\"Updating problem report\"),\n                _(\"No additional information collected.\"),\n            )\n            return False\n\n        self.report.add_user_info()\n        self.report.add_proc_environ()\n        self.add_extra_tags()\n\n        # delete the uninteresting keys\n        del self.report[\"Date\"]\n        try:\n            del self.report[\"SourcePackage\"]\n        except KeyError:\n            pass\n\n        if len(self.report) == 0:\n            self.ui_info_message(\n                _(\"Updating problem report\"),\n                _(\"No additional information collected.\"),\n            )\n            return False\n\n        # show what's being sent\n        allowed_to_report = True\n        response = self.ui_present_report_details(allowed_to_report)\n        if response.report:\n            self.crashdb.update(\n                self.args.update_report,\n                self.report,\n                \"apport information\",\n                change_description=is_reporter,\n                attachment_comment=\"apport information\",\n            )\n            return True\n\n        return False\n\n    def run_symptoms(self):\n        \"\"\"Report a bug from a list of available symptoms.\n\n        Return False if no symptoms are available.\n        \"\"\"\n        scripts = glob.glob(os.path.join(symptom_script_dir, \"*.py\"))\n\n        symptom_names = []\n        symptom_descriptions = []\n        for script in scripts:\n            # scripts with an underscore can be used for private libraries\n            if os.path.basename(script).startswith(\"_\"):\n                continue\n            symb = {}\n            try:\n                with open(script, encoding=\"utf-8\") as f:\n                    # legacy, pylint: disable=exec-used\n                    exec(compile(f.read(), script, \"exec\"), symb)\n            except Exception:  # pylint: disable=broad-except\n                apport.logging.error(\"symptom script %s is invalid\", script)\n                traceback.print_exc()\n                continue\n            if \"run\" not in symb:\n                apport.logging.error(\n                    \"symptom script %s does not define run() function\", script\n                )\n                continue\n            symptom_names.append(os.path.splitext(os.path.basename(script))[0])\n            symptom_descriptions.append(\n                symb.get(\"description\", symptom_names[-1])\n            )\n\n        if not symptom_names:\n            return False\n\n        symptom_descriptions, symptom_names = zip(\n            *sorted(zip(symptom_descriptions, symptom_names))\n        )\n        symptom_descriptions = list(symptom_descriptions)\n        symptom_names = list(symptom_names)\n        symptom_names.append(None)\n        symptom_descriptions.append(\"Other problem\")\n\n        ch = self.ui_question_choice(\n            _(\"What kind of problem do you want to report?\"),\n            symptom_descriptions,\n            False,\n        )\n\n        if ch is not None:\n            symptom = symptom_names[ch[0]]\n            if symptom:\n                self.run_report_bug(\n                    os.path.join(symptom_script_dir, symptom + \".py\")\n                )\n            else:\n                return False\n\n        return True\n\n    def run_symptom(self):\n        \"\"\"Report a bug with a symptom script.\"\"\"\n        script = os.path.join(symptom_script_dir, self.args.symptom + \".py\")\n        if not os.path.exists(script):\n            self.ui_error_message(\n                _(\"Unknown symptom\"),\n                _('The symptom \"%s\" is not known.') % self.args.symptom,\n            )\n            return\n\n        self.run_report_bug(script)\n\n    def run_argv(self):\n        \"\"\"Call appopriate run_* method according to command line arguments.\n\n        Return True if at least one report has been processed, and False\n        otherwise.\n        \"\"\"\n        if self.args.symptom:\n            self.run_symptom()\n            return True\n        if self.args.hanging:\n            self.run_hang(self.args.pid)\n            return True\n        if self.args.filebug:\n            return self.run_report_bug()\n        if self.args.update_report is not None:\n            return self.run_update_report()\n        if self.args.version:\n            print(__version__)\n            return True\n        if self.args.crash_file:\n            try:\n                self.run_crash(self.args.crash_file)\n            except OSError as error:\n                self.ui_error_message(_(\"Invalid problem report\"), str(error))\n            return True\n        if self.args.window:\n            if os.getenv(\"XDG_SESSION_TYPE\") == \"wayland\":\n                self.ui_error_message(\n                    _(\"Cannot create report\"),\n                    _(\n                        \"The window option cannot be used on \"\n                        \"Wayland.\\n\\nPlease find the window's \"\n                        \"process ID and then run 'ubuntu-bug \"\n                        \"<process ID>'.\"\n                        \"\\n\\nThe process ID can be found \"\n                        \"by running the System Monitor application. \"\n                        \"In the Processes tab, scroll until you \"\n                        \"find the correct application. The process \"\n                        \"ID is the number listed in the ID column.\"\n                    ),\n                )\n                return True\n\n            self.ui_info_message(\n                \"\",\n                _(\n                    \"After closing this message please click on an\"\n                    \" application window to report a problem about it.\"\n                ),\n            )\n            xprop = subprocess.run(\n                [\"xprop\", \"_NET_WM_PID\"],\n                check=False,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n            )\n            if xprop.returncode == 0:\n                try:\n                    self.args.pid = int(xprop.stdout.split()[-1])\n                except ValueError:\n                    self.ui_error_message(\n                        _(\"Cannot create report\"),\n                        _(\n                            \"xprop failed to determine\"\n                            \" process ID of the window\"\n                        ),\n                    )\n                    return True\n                return self.run_report_bug()\n\n            self.ui_error_message(\n                _(\"Cannot create report\"),\n                _(\"xprop failed to determine process ID of the window\")\n                + \"\\n\\n\"\n                + xprop.stderr.decode(),\n            )\n            return True\n\n        return self.run_crashes()\n\n    #\n    # methods that implement workflow bits\n    #\n\n    @staticmethod\n    def parse_argv_update(argv: typing.Sequence[str]) -> argparse.Namespace:\n        \"\"\"Parse command line options when being invoked in update mode.\"\"\"\n        parser = argparse.ArgumentParser(usage=_(\"%(prog)s <report number>\"))\n        parser.add_argument(\"-p\", \"--package\", help=_(\"Specify package name.\"))\n        parser.add_argument(\n            \"--tag\",\n            action=\"append\",\n            default=[],\n            dest=\"tags\",\n            help=_(\n                \"Add an extra tag to the report.\"\n                \" Can be specified multiple times.\"\n            ),\n        )\n        parser.add_argument(\"update_report\", metavar=\"report_number\", type=int)\n        args = parser.parse_args(argv[1:])\n\n        args.symptom = None\n        args.filebug = False\n        args.crash_file = None\n        args.version = False\n        args.hanging = False\n        return args\n\n    def parse_argv(self, argv: list[str]) -> argparse.Namespace:\n        \"\"\"Parse command line options.\n\n        If a single argument is given without any options, this tries to \"do\n        what I mean\".\n        \"\"\"\n        # invoked in update mode?\n        if len(argv) > 0:\n            if \"APPORT_INVOKED_AS\" in os.environ:\n                argv[0] = os.path.join(\n                    os.path.dirname(argv[0]),\n                    os.path.basename(os.environ[\"APPORT_INVOKED_AS\"]),\n                )\n            cmd = argv[0]\n            if cmd.endswith(\"-update-bug\") or cmd.endswith(\"-collect\"):\n                return self.parse_argv_update(argv)\n\n        if len(argv) > 0 and cmd.endswith(\"-bug\"):\n            suppress = argparse.SUPPRESS\n        else:\n            suppress = None\n\n        parser = argparse.ArgumentParser(\n            usage=_(\n                \"%(prog)s [options]\"\n                \" [symptom|pid|package|program path|.apport/.crash file]\"\n            )\n        )\n        parser.add_argument(\n            \"-f\",\n            \"--file-bug\",\n            action=\"store_true\",\n            dest=\"filebug\",\n            help=suppress\n            or _(\n                \"Start in bug filing mode. Requires --package and an optional\"\n                \" --pid, or just a --pid. If neither is given, display a list\"\n                \" of known symptoms. (Implied if a single argument is given.)\"\n            ),\n        )\n        parser.add_argument(\n            \"-w\",\n            \"--window\",\n            action=\"store_true\",\n            help=_(\"Click a window as a target for filing a problem report.\"),\n        )\n        parser.add_argument(\n            \"-u\",\n            \"--update-bug\",\n            type=int,\n            dest=\"update_report\",\n            help=suppress\n            or _(\n                \"Start in bug updating mode. Can take an optional --package.\"\n            ),\n        )\n        parser.add_argument(\n            \"-s\",\n            \"--symptom\",\n            metavar=\"SYMPTOM\",\n            help=suppress\n            or _(\n                \"File a bug report about a symptom. (Implied if symptom name\"\n                \" is given as only argument.)\"\n            ),\n        )\n        parser.add_argument(\n            \"-p\",\n            \"--package\",\n            help=suppress\n            or _(\n                \"Specify package name in --file-bug mode. This is optional\"\n                \" if a --pid is specified. (Implied if package name\"\n                \" is given as only argument.)\"\n            ),\n        )\n        parser.add_argument(\n            \"-P\",\n            \"--pid\",\n            type=int,\n            help=suppress\n            or _(\n                \"Specify a running program in --file-bug mode. If this is\"\n                \" specified, the bug report will contain more information.\"\n                \"  (Implied if pid is given as only argument.)\"\n            ),\n        )\n        parser.add_argument(\n            \"--hanging\",\n            action=\"store_true\",\n            help=_(\"The provided pid is a hanging application.\"),\n        )\n        parser.add_argument(\n            \"-c\",\n            \"--crash-file\",\n            metavar=\"PATH\",\n            help=suppress\n            or _(\n                \"Report the crash from given .apport or .crash file\"\n                \" instead of the pending ones in %s.\"\n                \" (Implied if file is given as only argument.)\"\n            )\n            % apport.fileutils.report_dir,\n        )\n        parser.add_argument(\n            \"--save\",\n            metavar=\"PATH\",\n            help=_(\n                \"In bug filing mode, save the collected information into\"\n                \" a file instead of reporting it. This file can then be\"\n                \" reported later on from a different machine.\"\n            ),\n        )\n        parser.add_argument(\n            \"--tag\",\n            action=\"append\",\n            default=[],\n            dest=\"tags\",\n            help=_(\n                \"Add an extra tag to the report.\"\n                \" Can be specified multiple times.\"\n            ),\n        )\n        parser.add_argument(\n            \"-v\",\n            \"--version\",\n            action=\"store_true\",\n            help=_(\"Print the Apport version number.\"),\n        )\n        parser.add_argument(\"issue\", nargs=\"?\", help=argparse.SUPPRESS)\n\n        args = parser.parse_args(argv[1:])\n        issue = args.issue\n        del args.issue\n\n        # mutually exclusive arguments\n        if args.update_report:\n            args_only_for_new_reports = [\n                args.filebug,\n                args.window,\n                args.symptom,\n                args.pid,\n                args.crash_file,\n                args.save,\n            ]\n            if any(args_only_for_new_reports):\n                parser.error(\n                    \"-u/--update-bug option cannot be used together\"\n                    \" with options for a new report\"\n                )\n\n        # no argument: default to \"show pending crashes\" except when called in\n        # bug mode\n        # NOTE: uses argv, since args if empty for all the options,\n        # e.g. \"-v\" or \"-u $BUG\"\n        if len(argv) == 1 and cmd.endswith(\"-bug\"):\n            args.filebug = True\n            return args\n\n        # one argument: guess \"file bug\" mode by argument type\n        if issue is None:\n            return args\n\n        # symptom?\n        if os.path.exists(os.path.join(symptom_script_dir, issue + \".py\")):\n            args.filebug = True\n            args.symptom = issue\n\n        # .crash/.apport file?\n        elif issue.endswith(\".crash\") or issue.endswith(\".apport\"):\n            args.crash_file = issue\n\n        # PID?\n        elif issue.isdigit():\n            args.filebug = True\n            args.pid = issue\n\n        # executable?\n        elif \"/\" in issue:\n            if issue.startswith(\"/snap/bin\"):\n                # see if the snap has the same name as the executable\n                snap = apport.fileutils.find_snap(issue.split(\"/\")[-1])\n                if not snap:\n                    parser.error(\n                        \"%s is provided by a snap. No contact address\"\n                        \" has been provided; visit the forum at\"\n                        \" https://forum.snapcraft.io/ for help.\" % issue\n                    )\n                elif snap.get(\"contact\", \"\"):\n                    parser.error(\n                        \"%s is provided by a snap published by %s.\"\n                        \" Contact them via %s for help.\"\n                        % (issue, snap[\"developer\"], snap[\"contact\"])\n                    )\n                else:\n                    parser.error(\n                        \"%s is provided by a snap published by %s.\"\n                        \" No contact address has been provided; visit the\"\n                        \" forum at https://forum.snapcraft.io/ for help.\"\n                        % (issue, snap[\"developer\"])\n                    )\n                sys.exit(1)\n            else:\n                pkg = packaging.get_file_package(issue)\n                if not pkg:\n                    parser.error(\"%s does not belong to a package.\" % issue)\n                    sys.exit(1)\n            args.filebug = True\n            args.package = pkg\n\n        # otherwise: package name\n        else:\n            args.filebug = True\n            self.specified_a_pkg = True\n            args.package = issue\n\n        return args\n\n    @staticmethod\n    def format_filesize(size):\n        \"\"\"Format the given integer as humanly readable and i18n'ed file\n        size.\"\"\"\n        if size < 1000000:\n            return locale.format_string(\"%.1f KB\", size / 1000.0)\n        if size < 1000000000:\n            return locale.format_string(\"%.1f MB\", size / 1000000.0)\n        return locale.format_string(\"%.1f GB\", size / float(1000000000))\n\n    def get_complete_size(self):\n        \"\"\"Return the size of the complete report.\"\"\"\n        # report wasn't loaded, so count manually\n        size = 0\n        for k in self.report:\n            if self.report[k]:\n                try:\n                    # if we have a compressed value, take its size, but take\n                    # base64 overhead into account\n                    size += len(self.report[k].gzipvalue) * 8 / 6\n                except AttributeError:\n                    size += len(self.report[k])\n        return size\n\n    def get_reduced_size(self):\n        \"\"\"Return the size of the reduced report.\"\"\"\n        size = 0\n        for k in self.report:\n            if k != \"CoreDump\":\n                if self.report[k]:\n                    try:\n                        # if we have a compressed value, take its size,\n                        # but take base64 overhead into account\n                        size += len(self.report[k].gzipvalue) * 8 / 6\n                    except AttributeError:\n                        size += len(self.report[k])\n\n        return size\n\n    def can_examine_locally(self):\n        \"\"\"Check whether to offer the \"Examine locally\" button.\n\n        This will be true if the report has a core dump, apport-retrace is\n        installed and a terminal is available (see ui_has_terminal()).\n        \"\"\"\n        if not self.report or \"CoreDump\" not in self.report:\n            return False\n\n        if shutil.which(\"apport-retrace\") is None:\n            return False\n\n        return self.ui_has_terminal()\n\n    def restart(self):\n        \"\"\"Reopen the crashed application.\"\"\"\n        assert \"ProcCmdline\" in self.report\n\n        if os.fork() == 0:\n            os.setsid()\n            os.execlp(\n                \"sh\",\n                \"sh\",\n                \"-c\",\n                self.report.get(\"RespawnCommand\", self.report[\"ProcCmdline\"]),\n            )\n            sys.exit(1)\n\n    def examine(self):\n        \"\"\"Locally examine crash report.\"\"\"\n        response = self.ui_question_choice(\n            _(\n                \"This will launch apport-retrace in a terminal window\"\n                \" to examine the crash.\"\n            ),\n            [\n                _(\"Run gdb session\"),\n                _(\"Run gdb session without downloading debug symbols\"),\n                # TRANSLATORS: %s contains the crash report file name\n                _(\"Update %s with fully symbolic stack trace\")\n                % self.report_file,\n            ],\n            False,\n        )\n\n        if response is None:\n            return\n\n        retrace_with_download = (\n            \"apport-retrace -S system -C %s -v \"\n            % os.path.expanduser(\"~/.cache/apport/retrace\")\n        )\n        retrace_no_download = \"apport-retrace \"\n        filearg = \"'\" + self.report_file.replace(\"'\", \"'\\\\''\") + \"'\"\n\n        cmds = {\n            0: retrace_with_download + \"--gdb \" + filearg,\n            1: retrace_no_download + \"--gdb \" + filearg,\n            2: retrace_with_download + \"--output \" + filearg + \" \" + filearg,\n        }\n\n        self.ui_run_terminal(cmds[response[0]])\n\n    def remember_send_report(self, send_report):\n        \"\"\"Put whoopsie in auto or never mode.\"\"\"\n        if send_report:\n            send_report = \"true\"\n        else:\n            send_report = \"false\"\n        try:\n            subprocess.check_output(\n                [\n                    \"/usr/bin/gdbus\",\n                    \"call\",\n                    \"-y\",\n                    \"-d\",\n                    \"com.ubuntu.WhoopsiePreferences\",\n                    \"-o\",\n                    \"/com/ubuntu/WhoopsiePreferences\",\n                    \"-m\",\n                    \"com.ubuntu.WhoopsiePreferences.SetReportCrashes\",\n                    send_report,\n                ]\n            )\n            subprocess.check_output(\n                [\n                    \"/usr/bin/gdbus\",\n                    \"call\",\n                    \"-y\",\n                    \"-d\",\n                    \"com.ubuntu.WhoopsiePreferences\",\n                    \"-o\",\n                    \"/com/ubuntu/WhoopsiePreferences\",\n                    \"-m\",\n                    \"com.ubuntu.WhoopsiePreferences\"\n                    \".SetAutomaticallyReportCrashes\",\n                    \"true\",\n                ]\n            )\n        except (OSError, subprocess.CalledProcessError) as error:\n            self.ui_error_message(\n                _(\"Can't remember send report status settings\"),\n                \"%s\\n\\n%s\"\n                % (\n                    _(\n                        \"Saving crash reporting state failed.\"\n                        \" Can't set auto or never reporting mode.\"\n                    ),\n                    str(error),\n                ),\n            )\n\n    def check_report_crashdb(self):\n        \"\"\"Process reports' CrashDB field, if present.\"\"\"\n        if \"CrashDB\" not in self.report:\n            return True\n\n        # specification?\n        if self.report[\"CrashDB\"].lstrip().startswith(\"{\"):\n            try:\n                spec = ast.literal_eval(self.report[\"CrashDB\"])\n                assert isinstance(spec, dict)\n                assert \"impl\" in spec\n            except (AssertionError, SyntaxError, ValueError) as error:\n                self.report[\"UnreportableReason\"] = (\n                    \"A package hook defines an invalid crash database\"\n                    \" definition:\\n%s\\n%s\" % (self.report[\"CrashDB\"], error)\n                )\n                return False\n            try:\n                self.crashdb = apport.crashdb.load_crashdb(None, spec)\n            except (ImportError, KeyError):\n                self.report[\"UnreportableReason\"] = (\n                    \"A package hook wants to send this report to the crash\"\n                    ' database \"%s\" which does not exist.'\n                    % self.report[\"CrashDB\"]\n                )\n\n        else:\n            # DB name\n            try:\n                self.crashdb = apport.crashdb.get_crashdb(\n                    None, self.report[\"CrashDB\"]\n                )\n            except (ImportError, KeyError):\n                self.report[\"UnreportableReason\"] = (\n                    \"A package hook wants to send this report to the crash\"\n                    ' database \"%s\" which does not exist.'\n                    % self.report[\"CrashDB\"]\n                )\n                return False\n\n        return True\n\n    def collect_info(\n        self, symptom_script=None, ignore_uninstalled=False, on_finished=None\n    ):\n        \"\"\"Collect additional information.\n\n        Call all the add_*_info() methods and display a progress dialog during\n        this.\n\n        In particular, this adds OS, package and gdb information and checks bug\n        patterns.\n\n        If a symptom script is given, this will be run first (used by\n        run_symptom()).\n        \"\"\"\n        self.report[\"_MarkForUpload\"] = \"True\"\n\n        # skip if we already ran (we might load a processed report)\n        if (\n            self.report.get(\"ProblemType\") == \"Crash\"\n            and \"Stacktrace\" in self.report\n        ) or (\n            self.report.get(\"ProblemType\") != \"Crash\"\n            and \"Dependencies\" in self.report\n        ):\n            if on_finished:\n                on_finished()\n            return\n\n        # ensure that the crashed program is still installed:\n        if self.report.get(\"ProblemType\") == \"Crash\":\n            exe_path = self.report.get(\"ExecutablePath\", \"\")\n            if not os.path.exists(exe_path):\n                msg = _(\n                    \"This problem report applies to a program\"\n                    \" which is not installed any more.\"\n                )\n                if exe_path:\n                    msg = \"%s (%s)\" % (msg, self.report[\"ExecutablePath\"])\n                self.report[\"UnreportableReason\"] = msg\n                if on_finished:\n                    on_finished()\n                return\n\n            if \"InterpreterPath\" in self.report:\n                if not os.path.exists(self.report[\"InterpreterPath\"]):\n                    msg = _(\n                        \"This problem report applies to a program\"\n                        \" which is not installed any more.\"\n                    )\n                    self.report[\"UnreportableReason\"] = \"%s (%s)\" % (\n                        msg,\n                        self.report[\"InterpreterPath\"],\n                    )\n                    if on_finished:\n                        on_finished()\n                    return\n\n        # check if binary changed since the crash happened\n        if (\n            \"ExecutablePath\" in self.report\n            and \"ExecutableTimestamp\" in self.report\n        ):\n            orig_time = int(self.report[\"ExecutableTimestamp\"])\n            del self.report[\"ExecutableTimestamp\"]\n            cur_time = int(os.stat(self.report[\"ExecutablePath\"]).st_mtime)\n\n            if orig_time != cur_time:\n                self.report[\"_MarkForUpload\"] = \"False\"\n                self.report[\"UnreportableReason\"] = (\n                    _(\n                        \"The problem happened with the program %s\"\n                        \" which changed since the crash occurred.\"\n                    )\n                    % self.report[\"ExecutablePath\"]\n                )\n                return\n\n        if (\n            not self.cur_package\n            and \"ExecutablePath\" not in self.report\n            and not symptom_script\n        ):\n            # this happens if we file a bug without specifying a PID or a\n            # package\n            self.report.add_os_info()\n        else:\n            # since this might take a while, create separate threads and\n            # display a progress dialog.\n            self.ui_start_info_collection_progress()\n            # only use a UI for asking questions if the crash db will accept\n            # the report\n            if self.crashdb.accepts(self.report):\n                hookui = HookUI(self)\n            else:\n                hookui = NoninteractiveHookUI()\n\n            if \"Stacktrace\" not in self.report:\n                # save original environment, in case hooks change it\n                orig_env = os.environ.copy()\n                icthread = apport.REThread.REThread(\n                    target=thread_collect_info,\n                    name=\"thread_collect_info\",\n                    args=(\n                        self.report,\n                        self.report_file,\n                        self.cur_package,\n                        hookui,\n                        symptom_script,\n                        ignore_uninstalled,\n                    ),\n                )\n                icthread.start()\n                while icthread.is_alive():\n                    self.ui_pulse_info_collection_progress()\n                    try:\n                        hookui.process_event()\n                    except KeyboardInterrupt:\n                        sys.exit(1)\n\n                icthread.join()\n\n                # restore original environment\n                os.environ.clear()\n                os.environ.update(orig_env)\n\n                try:\n                    icthread.exc_raise()\n                except (OSError, EOFError, zlib.error) as error:\n                    # can happen with broken core dumps\n                    self.report[\"UnreportableReason\"] = \"%s\\n\\n%s\" % (\n                        _(\n                            \"This problem report is damaged\"\n                            \" and cannot be processed.\"\n                        ),\n                        repr(error),\n                    )\n                    self.report[\"_MarkForUpload\"] = \"False\"\n                except ValueError:  # package does not exist\n                    if \"UnreportableReason\" not in self.report:\n                        self.report[\"UnreportableReason\"] = _(\n                            \"This report is about a package\"\n                            \" that is not installed.\"\n                        )\n                        self.report[\"_MarkForUpload\"] = \"False\"\n                except Exception as error:  # pylint: disable=broad-except\n                    apport.logging.error(\"%s\", repr(error))\n                    self.report[\"UnreportableReason\"] = (\n                        _(\n                            \"An error occurred while attempting to \"\n                            \"process this problem report:\"\n                        )\n                        + \"\\n\\n\"\n                        + str(error)\n                    )\n                    self.report[\"_MarkForUpload\"] = \"False\"\n\n            # ask for target, if snap and deb package are installed\n            if \"Snap\" in self.report and \"Package\" in self.report:\n                if \"(not installed)\" in self.report[\"Package\"]:\n                    # choose snap automatically, if deb package\n                    # is not installed\n                    res = [0]\n                else:\n                    res = self.ui_question_choice(\n                        _(\n                            \"You have two versions of this application\"\n                            \" installed, which one do you want to report\"\n                            \" a bug against?\"\n                        ),\n                        [\n                            _(\"%s snap\") % self.report[\"Snap\"],\n                            _(\"%s deb package\") % self.report[\"Package\"],\n                        ],\n                        False,\n                    )\n                # bug report is about the snap, clean deb package info\n                if res == [0]:\n                    del self.report[\"Package\"]\n                    if \"PackageArchitecture\" in self.report:\n                        del self.report[\"PackageArchitecture\"]\n                    if \"SourcePackage\" in self.report:\n                        del self.report[\"SourcePackage\"]\n                # bug report is about the deb package, clean snap info\n                elif res == [1]:\n                    del self.report[\"Snap\"]\n                    if \"SnapSource\" in self.report:\n                        del self.report[\"SnapSource\"]\n                    if \"SnapTags\" in self.report:\n                        del self.report[\"SnapTags\"]\n                else:\n                    self.ui_stop_info_collection_progress()\n                    sys.exit(0)\n\n            # append snap tags, if this report is about the snap\n            if \"Snap\" in self.report and \"SnapTags\" in self.report:\n                self.report.add_tags(self.report.pop(\"SnapTags\").split(\" \"))\n\n            # show a hint if we cannot auto report a snap bug via 'SnapSource'\n            if (\n                \"Snap\" in self.report\n                and (\n                    \"SnapSource\" not in self.report\n                    and \"SnapGitName\" not in self.report\n                )\n                and \"UnreportableReason\" not in self.report\n                and self.specified_a_pkg\n            ):\n                snap = apport.fileutils.find_snap(self.cur_package)\n                if snap.get(\"contact\", \"\"):\n                    self.report[\"UnreportableReason\"] = _(\n                        \"%s is provided by a snap published by %s.\"\n                        \" Contact them via %s for help.\"\n                    ) % (snap[\"name\"], snap[\"developer\"], snap[\"contact\"])\n                else:\n                    self.report[\"UnreportableReason\"] = _(\n                        \"%s is provided by a snap published by %s. No contact\"\n                        \" address has been provided; visit the forum\"\n                        \" at https://forum.snapcraft.io/ for help.\"\n                    ) % (snap[\"name\"], snap[\"developer\"])\n                self.report[\"_MarkForUpload\"] = \"False\"\n\n            if (\n                \"UnreportableReason\" in self.report\n                or not self.check_report_crashdb()\n            ):\n                self.ui_stop_info_collection_progress()\n                if on_finished:\n                    on_finished()\n                return\n\n            # check bug patterns\n            if (\n                self.report.get(\"ProblemType\") == \"KernelCrash\"\n                or self.report.get(\"ProblemType\") == \"KernelOops\"\n                or \"Package\" in self.report\n            ):\n                bpthread = apport.REThread.REThread(\n                    target=self.report.search_bug_patterns,\n                    args=(self.crashdb.get_bugpattern_baseurl(),),\n                )\n                bpthread.start()\n                while bpthread.is_alive():\n                    self.ui_pulse_info_collection_progress()\n                    try:\n                        bpthread.join(0.1)\n                    except KeyboardInterrupt:\n                        sys.exit(1)\n                try:\n                    bpthread.exc_raise()\n                except (OSError, EOFError, zlib.error) as error:\n                    # can happen with broken gz values\n                    self.report[\"UnreportableReason\"] = \"%s\\n\\n%s\" % (\n                        _(\n                            \"This problem report is damaged\"\n                            \" and cannot be processed.\"\n                        ),\n                        repr(error),\n                    )\n                if bpthread.return_value():\n                    self.report[\"_KnownReport\"] = bpthread.return_value()\n\n            # check crash database if problem is known\n            if self.report.get(\"ProblemType\") != \"Bug\":\n                known_thread = apport.REThread.REThread(\n                    target=self.crashdb.known, args=(self.report,)\n                )\n                known_thread.start()\n                while known_thread.is_alive():\n                    self.ui_pulse_info_collection_progress()\n                    try:\n                        known_thread.join(0.1)\n                    except KeyboardInterrupt:\n                        sys.exit(1)\n                known_thread.exc_raise()\n                val = known_thread.return_value()\n                if val is not None:\n                    if val is True:\n                        self.report[\"_KnownReport\"] = \"1\"\n                    else:\n                        self.report[\"_KnownReport\"] = val\n\n            # anonymize; needs to happen after duplicate checking, otherwise we\n            # might damage the stack trace\n            anonymize_thread = apport.REThread.REThread(\n                target=self.report.anonymize\n            )\n            anonymize_thread.start()\n            while anonymize_thread.is_alive():\n                self.ui_pulse_info_collection_progress()\n                try:\n                    anonymize_thread.join(0.1)\n                except KeyboardInterrupt:\n                    sys.exit(1)\n            anonymize_thread.exc_raise()\n\n            self.ui_stop_info_collection_progress()\n\n            # check that we were able to determine package names\n            if \"UnreportableReason\" not in self.report:\n                if (\n                    (\n                        \"SourcePackage\" not in self.report\n                        and \"Dependencies\" not in self.report\n                    )\n                    or (\n                        not self.report.get(\"ProblemType\", \"\").startswith(\n                            \"Kernel\"\n                        )\n                        and \"Package\" not in self.report\n                    )\n                ) and not self._is_snap():\n                    self.ui_error_message(\n                        _(\"Invalid problem report\"),\n                        _(\n                            \"Could not determine the package\"\n                            \" or source package name.\"\n                        ),\n                    )\n                    # TODO This is not called consistently,\n                    # is it really needed?\n                    self.ui_shutdown()\n                    sys.exit(1)\n\n        if on_finished:\n            on_finished()\n\n    def _is_snap(self):\n        return \"SnapSource\" in self.report or \"Snap\" in self.report\n\n    def open_url(self, url):\n        \"\"\"Open the given URL in a new browser window.\n\n        Display an error dialog if everything fails.\n        \"\"\"\n        (r, w) = os.pipe()\n        if os.fork() > 0:\n            os.close(w)\n            status = os.wait()[1]\n            if status:\n                title = _(\"Unable to start web browser\")\n                error = _(\"Unable to start web browser to open %s.\" % url)\n                message = os.fdopen(r).readline()\n                if message:\n                    error += \"\\n\" + message\n                self.ui_error_message(title, error)\n            try:\n                os.close(r)\n            except OSError:\n                pass\n            return\n\n        os.setsid()\n        os.close(r)\n\n        try:\n            try:\n                run_as_real_user([\"xdg-open\", url], get_user_env=True)\n            except OSError:\n                # fall back to webbrowser\n                webbrowser.open(url, new=True, autoraise=True)\n                sys.exit(0)\n        except Exception as error:  # pylint: disable=broad-except\n            os.write(w, str(error))\n            sys.exit(1)\n        os._exit(0)  # pylint: disable=protected-access\n\n    def file_report(self):\n        \"\"\"Upload the current report and guide the user to the reporting\n        web page.\"\"\"\n        # FIXME: This behaviour is not really correct, but necessary as\n        # long as we only support a single crashdb and have whoopsie\n        # hardcoded. Once we have multiple crash dbs, we need to check\n        # accepts() earlier, and not even present the data if none of\n        # the DBs wants the report. See LP#957177 for details.\n        if not self.crashdb.accepts(self.report):\n            return\n        # drop PackageArchitecture if equal to Architecture\n        if self.report.get(\"PackageArchitecture\") == self.report.get(\n            \"Architecture\"\n        ):\n            try:\n                del self.report[\"PackageArchitecture\"]\n            except KeyError:\n                pass\n\n        # StacktraceAddressSignature is redundant and does not need to clutter\n        # the database\n        try:\n            del self.report[\"StacktraceAddressSignature\"]\n        except KeyError:\n            pass\n\n        self.upload_progress = None\n\n        def progress_callback(sent, total):\n            self.upload_progress = float(sent) / total\n\n        message_queue = queue.SimpleQueue()\n\n        def message_callback(title, text):\n            message_displayed = threading.Event()\n            message_queue.put((title, text, message_displayed))\n            message_displayed.wait()\n\n        # drop internal/uninteresting keys, that start with \"_\"\n        for k in list(self.report):\n            if k.startswith(\"_\"):\n                del self.report[k]\n\n        self.ui_start_upload_progress()\n        upthread = apport.REThread.REThread(\n            target=self.crashdb.upload,\n            args=(self.report, progress_callback, message_callback),\n        )\n        upthread.start()\n        try:\n            while upthread.is_alive():\n                self.ui_set_upload_progress(self.upload_progress)\n                try:\n                    title, text, msg_displayed = message_queue.get(\n                        block=True, timeout=0.1\n                    )\n                    self.ui_info_message(title, text)\n                    msg_displayed.set()\n                    upthread.exc_raise()\n                except queue.Empty:\n                    pass\n\n            upthread.exc_raise()\n        except KeyboardInterrupt:\n            sys.exit(1)\n        except (smtplib.SMTPConnectError, urllib.error.URLError) as error:\n            self.ui_error_message(\n                _(\"Network problem\"),\n                \"%s\\n\\n%s\"\n                % (\n                    _(\n                        \"Cannot connect to crash database,\"\n                        \" please check your Internet connection.\"\n                    ),\n                    str(error),\n                ),\n            )\n            return\n\n        ticket = upthread.return_value()\n        self.ui_stop_upload_progress()\n\n        url = self.crashdb.get_comment_url(self.report, ticket)\n        if url:\n            self.open_url(url)\n\n    def load_report(self, path):\n        \"\"\"Load report from given path and do some consistency checks.\n\n        This might issue an error message and return False if the report cannot\n        be processed, otherwise self.report is initialized and True is\n        returned.\n        \"\"\"\n        try:\n            self.report = apport.Report()\n            with open(path, \"rb\") as f:\n                self.report.load(f, binary=\"compressed\")\n            if \"ProblemType\" not in self.report:\n                raise ValueError('Report does not contain \"ProblemType\" field')\n        except MemoryError:\n            self.report = None\n            self.ui_error_message(\n                _(\"Memory exhaustion\"),\n                _(\n                    \"Your system does not have enough memory\"\n                    \" to process this crash report.\"\n                ),\n            )\n            return False\n        except OSError as error:\n            self.report = None\n            self.ui_error_message(_(\"Invalid problem report\"), error.strerror)\n            return False\n        except (TypeError, ValueError, AssertionError, zlib.error) as error:\n            self.report = None\n            self.ui_error_message(\n                _(\"Invalid problem report\"),\n                \"%s\\n\\n%s\"\n                % (\n                    _(\n                        \"This problem report is damaged\"\n                        \" and cannot be processed.\"\n                    ),\n                    repr(error),\n                ),\n            )\n            return False\n\n        if \"Package\" in self.report:\n            self.cur_package = self.report[\"Package\"].split()[0]\n        else:\n            self.cur_package = apport.fileutils.find_file_package(\n                self.report.get(\"ExecutablePath\", \"\")\n            )\n\n        return True\n\n    def check_unreportable(self):\n        \"\"\"Check if the current report is unreportable.\n\n        If so, display an info message and return True.\n        \"\"\"\n        if not self.crashdb.accepts(self.report):\n            return False\n        if \"UnreportableReason\" in self.report:\n            if isinstance(self.report[\"UnreportableReason\"], bytes):\n                self.report[\"UnreportableReason\"] = self.report[\n                    \"UnreportableReason\"\n                ].decode(\"UTF-8\")\n            if \"Package\" in self.report:\n                title = _(\"Problem in %s\") % self.report[\"Package\"].split()[0]\n            else:\n                title = \"\"\n            self.ui_info_message(\n                title,\n                _(\"The problem cannot be reported:\\n\\n%s\")\n                % self.report[\"UnreportableReason\"],\n            )\n            return True\n        return False\n\n    def get_desktop_entry(self):\n        \"\"\"Return a .desktop info dictionary for the current report.\n\n        Return None if report cannot be associated to a .desktop file.\n        \"\"\"\n        if \"DesktopFile\" in self.report and os.path.exists(\n            self.report[\"DesktopFile\"]\n        ):\n            desktop_file = self.report[\"DesktopFile\"]\n        else:\n            try:\n                desktop_file = apport.fileutils.find_package_desktopfile(\n                    self.cur_package\n                )\n            except ValueError:\n                return None\n\n        if not desktop_file:\n            return None\n\n        cp = configparser.ConfigParser(interpolation=None, strict=False)\n        try:\n            cp.read(desktop_file, encoding=\"UTF-8\")\n        except configparser.Error as error:\n            sys.stderr.write(\n                \"Warning! %s is broken: %s\\n\" % (desktop_file, str(error))\n            )\n            return None\n        if not cp.has_section(\"Desktop Entry\"):\n            return None\n        result = dict(cp.items(\"Desktop Entry\"))\n        if \"name\" not in result:\n            return None\n        return result\n\n    def handle_duplicate(self):\n        \"\"\"Check if current report matches a bug pattern.\n\n        If so, tell the user about it, open the existing bug in a browser, and\n        return True.\n        \"\"\"\n        if not self.crashdb.accepts(self.report):\n            return False\n        if \"_KnownReport\" not in self.report:\n            return False\n\n        # if we have an URL, open it; otherwise this is just a marker that we\n        # know about it\n        if self.report[\"_KnownReport\"].startswith(\"http\"):\n            self.ui_info_message(\n                _(\"Problem already known\"),\n                _(\n                    \"This problem was already reported in the bug report\"\n                    \" displayed in the web browser. Please check\"\n                    \" if you can add any further information\"\n                    \" that might be helpful for the developers.\"\n                ),\n            )\n\n            self.open_url(self.report[\"_KnownReport\"])\n        else:\n            self.ui_info_message(\n                _(\"Problem already known\"),\n                _(\n                    \"This problem was already reported to developers.\"\n                    \" Thank you!\"\n                ),\n            )\n\n        return True\n\n    def add_extra_tags(self):\n        \"\"\"Add extra tags to report specified with --tags on CLI.\"\"\"\n        assert self.report\n        if self.args.tags:\n            self.report.add_tags(self.args.tags)\n\n    #\n    # abstract UI methods that must be implemented in derived classes\n    #\n\n    def ui_present_report_details(\n        self, allowed_to_report=True, modal_for=None\n    ) -> Action:\n        \"\"\"Show details of the bug report.\n\n        Return the action and options as an Action object:\n\n        - Valid attributes are: report the crash ('report'), restart\n          the crashed application ('restart'), or ignore further crashes\n          ('ignore').\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_info_message(self, title, text):\n        \"\"\"Show an information message box with given title and text.\"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_error_message(self, title, text):\n        \"\"\"Show an error message box with given title and text.\"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_start_info_collection_progress(self):\n        \"\"\"Open a indefinite progress bar for data collection.\n\n        This tells the user to wait while debug information is being\n        collected.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_pulse_info_collection_progress(self):\n        \"\"\"Advance the data collection progress bar.\n\n        This function is called every 100 ms.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_stop_info_collection_progress(self):\n        \"\"\"Close debug data collection progress window.\"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_start_upload_progress(self):\n        \"\"\"Open progress bar for data upload.\n\n        This tells the user to wait while debug information is being uploaded.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_set_upload_progress(self, progress: typing.Optional[float]) -> None:\n        \"\"\"Update data upload progress bar.\n\n        Set the progress bar in the debug data upload progress window to the\n        given ratio (between 0 and 1, or None for indefinite progress).\n\n        This function is called every 100 ms.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_stop_upload_progress(self):\n        \"\"\"Close debug data upload progress window.\"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_shutdown(self):\n        \"\"\"Called right before terminating the program.\n\n        This can be used for for cleaning up.\n        \"\"\"\n\n    def ui_has_terminal(self):\n        \"\"\"Check for a terminal window.\n\n        Check if a terminal application is available and can be launched.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_run_terminal(self, command):\n        \"\"\"Run command in a terminal window.\n\n        Run given command in a terminal window; raise an\n        exception if terminal cannot be opened.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    #\n    # Additional UI dialogs; these are not required by Apport itself, but can\n    # be used by interactive package hooks\n    #\n\n    def ui_question_yesno(self, text):\n        \"\"\"Show a yes/no question.\n\n        Return True if the user selected \"Yes\", False if selected \"No\" or\n        \"None\" on cancel/dialog closing.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_question_choice(self, text, options, multiple):\n        \"\"\"Show an question with predefined choices.\n\n        options is a list of strings to present. If multiple is True, they\n        should be check boxes, if multiple is False they should be radio\n        buttons.\n\n        Return list of selected option indexes, or None if the user cancelled.\n        If multiple == False, the list will always have one element.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n    def ui_question_file(self, text):\n        \"\"\"Show a file selector dialog.\n\n        Return path if the user selected a file, or None if cancelled.\n        \"\"\"\n        raise NotImplementedError(\n            \"this function must be overridden by subclasses\"\n        )\n\n\nclass HookUI:\n    \"\"\"Interactive functions which can be used in package hooks.\n\n    This provides an interface for package hooks which need to ask interactive\n    questions. Directly passing the UserInterface instance to the hooks needs\n    to be avoided, since we need to call the UI methods in a different thread,\n    and also don't want hooks to be able to poke in the UI.\n    \"\"\"\n\n    def __init__(self, ui):\n        \"\"\"Create a HookUI object.\n\n        ui is the UserInterface instance to wrap.\n        \"\"\"\n        self.ui = ui\n\n        # variables for communicating with the UI thread\n        self._request_event = threading.Event()\n        self._response_event = threading.Event()\n        self._request_fn = None\n        self._request_args = None\n        self._response = None\n\n    #\n    # API for hooks\n    #\n\n    def information(self, text):\n        \"\"\"Show an information with OK/Cancel buttons.\n\n        This can be used for asking the user to perform a particular action,\n        such as plugging in a device which does not work.\n        \"\"\"\n        return self._trigger_ui_request(\"ui_info_message\", \"\", text)\n\n    def yesno(self, text):\n        \"\"\"Show a yes/no question.\n\n        Return True if the user selected \"Yes\", False if selected \"No\" or\n        \"None\" on cancel/dialog closing.\n        \"\"\"\n        return self._trigger_ui_request(\"ui_question_yesno\", text)\n\n    def choice(self, text, options, multiple=False):\n        \"\"\"Show an question with predefined choices.\n\n        options is a list of strings to present. If multiple is True, they\n        should be check boxes, if multiple is False they should be radio\n        buttons.\n\n        Return list of selected option indexes, or None if the user cancelled.\n        If multiple == False, the list will always have one element.\n        \"\"\"\n        return self._trigger_ui_request(\n            \"ui_question_choice\", text, options, multiple\n        )\n\n    def file(self, text):\n        \"\"\"Show a file selector dialog.\n\n        Return path if the user selected a file, or None if cancelled.\n        \"\"\"\n        return self._trigger_ui_request(\"ui_question_file\", text)\n\n    #\n    # internal API for inter-thread communication\n    #\n\n    def _trigger_ui_request(self, fn, *args):\n        \"\"\"Called by HookUi functions in info collection thread.\"\"\"\n        # only one at a time\n        assert not self._request_event.is_set()\n        assert not self._response_event.is_set()\n        assert self._request_fn is None\n\n        self._response = None\n        self._request_fn = fn\n        self._request_args = args\n        self._request_event.set()\n        self._response_event.wait()\n\n        self._request_fn = None\n        self._response_event.clear()\n\n        return self._response\n\n    def process_event(self):\n        \"\"\"Called by GUI thread to check and process hook UI requests.\"\"\"\n        # sleep for 0.1 seconds to wait for events\n        self._request_event.wait(0.1)\n        if not self._request_event.is_set():\n            return\n\n        assert not self._response_event.is_set()\n        self._request_event.clear()\n        self._response = getattr(self.ui, self._request_fn)(\n            *self._request_args\n        )\n        self._response_event.set()\n\n\nclass NoninteractiveHookUI(HookUI):\n    \"\"\"HookUI variant that does not ask the user any questions.\"\"\"\n\n    def __init__(self):\n        super().__init__(None)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}()\"\n\n    def information(self, text):\n        return None\n\n    def yesno(self, text):\n        return None\n\n    def choice(self, text, options, multiple=False):\n        return None\n\n    def file(self, text):\n        return None\n\n    def process_event(self):\n        # Give other threads some chance to run\n        time.sleep(0.1)\n", "#!/usr/bin/python3\n\n\"\"\"Command line Apport user interface.\"\"\"\n\n# Copyright (C) 2007 - 2009 Canonical Ltd.\n# Author: Michael Hofmann <mh21@piware.de>\n#\n# This program is free software; you can redistribute it and/or modify it\n# under the terms of the GNU General Public License as published by the\n# Free Software Foundation; either version 2 of the License, or (at your\n# option) any later version.  See http://www.gnu.org/copyleft/gpl.html for\n# the full text of the license.\n\n# Web browser support:\n#    w3m, lynx: do not work\n#    elinks: works\n\nimport errno\nimport os\nimport re\nimport subprocess\nimport sys\nimport tempfile\nimport termios\nimport typing\nfrom gettext import gettext as _\n\nimport apport.ui\n\n\nclass CLIDialog:\n    \"\"\"Command line dialog wrapper.\"\"\"\n\n    def __init__(self, heading, text):\n        self.heading = \"\\n*** \" + heading + \"\\n\"\n        self.text = text\n        self.keys = []\n        self.buttons = []\n        self.visible = False\n\n    @staticmethod\n    def raw_input_char(prompt, multi_char=False):\n        \"\"\"raw_input, but read a single character unless multi_char is True.\n\n        @param: prompt: the text presented to the user to solict a response.\n        @param: multi_char: Boolean True if we need to read until <enter>.\n        \"\"\"\n\n        sys.stdout.write(prompt)\n        sys.stdout.write(\" \")\n        sys.stdout.flush()\n\n        file = sys.stdin.fileno()\n        saved_attributes = termios.tcgetattr(file)\n        attributes = termios.tcgetattr(file)\n        attributes[3] = attributes[3] & ~(termios.ICANON)\n        attributes[6][termios.VMIN] = 1\n        attributes[6][termios.VTIME] = 0\n        termios.tcsetattr(file, termios.TCSANOW, attributes)\n        try:\n            if multi_char:\n                response = str(sys.stdin.readline()).strip()\n            else:\n                response = str(sys.stdin.read(1))\n        finally:\n            termios.tcsetattr(file, termios.TCSANOW, saved_attributes)\n\n        sys.stdout.write(\"\\n\")\n        return response\n\n    def show(self):\n        self.visible = True\n        print(self.heading)\n        if self.text:\n            print(self.text)\n\n    def run(self, prompt=None):\n        if not self.visible:\n            self.show()\n\n        sys.stdout.write(\"\\n\")\n        try:\n            # Only one button\n            if len(self.keys) <= 1:\n                self.raw_input_char(_(\"Press any key to continue...\"))\n                return 0\n            # Multiple choices\n            while True:\n                if prompt is not None:\n                    print(prompt)\n                else:\n                    print(_(\"What would you like to do? Your options are:\"))\n                for index, button in enumerate(self.buttons):\n                    print(\"  %s: %s\" % (self.keys[index], button))\n\n                if len(self.keys) <= 10:\n                    # A 10 option prompt would can still be a single character\n                    # response because the 10 options listed will be 1-9 and C.\n                    # Therefore there are 10 unique responses which can be\n                    # given.\n                    multi_char = False\n                else:\n                    multi_char = True\n                response = self.raw_input_char(\n                    _(\"Please choose (%s):\") % (\"/\".join(self.keys)),\n                    multi_char,\n                )\n                try:\n                    return self.keys.index(response.upper()) + 1\n                except ValueError:\n                    pass\n        except KeyboardInterrupt:\n            sys.stdout.write(\"\\n\")\n            sys.exit(1)\n\n    def addbutton(self, button, hotkey=None):\n        if hotkey:\n            self.keys.append(hotkey)\n            self.buttons.append(button)\n        else:\n            self.keys.append(re.search(\"&(.)\", button).group(1).upper())\n            self.buttons.append(re.sub(\"&\", \"\", button))\n        return len(self.keys)\n\n\nclass CLIProgressDialog(CLIDialog):\n    \"\"\"Command line progress dialog wrapper.\"\"\"\n\n    def __init__(self, heading, text):\n        CLIDialog.__init__(self, heading, text)\n        self.progresscount = 0\n\n    def set(self, progress=None):\n        self.progresscount = (self.progresscount + 1) % 5\n        if self.progresscount:\n            return\n\n        if progress is not None:\n            sys.stdout.write(\"\\r%u%%\" % (progress * 100))\n        else:\n            sys.stdout.write(\".\")\n        sys.stdout.flush()\n\n\nclass CLIUserInterface(apport.ui.UserInterface):\n    \"\"\"Command line Apport user interface\"\"\"\n\n    def __init__(self, argv: list[str]):\n        apport.ui.UserInterface.__init__(self, argv)\n        self.in_update_view = False\n        self.progress = None\n\n    def _get_details(self):\n        \"\"\"Build report string for display.\"\"\"\n\n        details = \"\"\n        max_show = 1000000\n        for key in sorted(self.report):\n            # ignore internal keys\n            if key.startswith(\"_\"):\n                continue\n            details += \"== %s =================================\\n\" % key\n            # string value\n            keylen = len(self.report[key])\n            if (\n                not hasattr(self.report[key], \"gzipvalue\")\n                and hasattr(self.report[key], \"isspace\")\n                and not self.report.is_binary(self.report[key])\n                and keylen < max_show\n            ):\n                s = self.report[key]\n            elif keylen >= max_show:\n                s = _(\"(%i bytes)\") % keylen\n            else:\n                s = _(\"(binary data)\")\n\n            if isinstance(s, bytes):\n                s = s.decode(\"UTF-8\", errors=\"ignore\")\n            details += s\n            details += \"\\n\\n\"\n\n        return details\n\n    def ui_update_view(self, stdout=None):\n        self.in_update_view = True\n        report = self._get_details()\n        try:\n            apport.ui.run_as_real_user(\n                [\"/usr/bin/sensible-pager\"],\n                input=report.encode(\"UTF-8\"),\n                stdout=stdout,\n            )\n        except OSError as error:\n            # ignore broken pipe (premature quit)\n            if error.errno == errno.EPIPE:\n                pass\n            else:\n                raise\n        self.in_update_view = False\n\n    #\n    # ui_* implementation of abstract UserInterface classes\n    #\n\n    def ui_present_report_details(\n        self, allowed_to_report=True, modal_for=None\n    ) -> apport.ui.Action:\n        dialog = CLIDialog(\n            _(\"Send problem report to the developers?\"),\n            _(\n                \"After the problem report has been sent,\"\n                \" please fill out the form in the\\n\"\n                \"automatically opened web browser.\"\n            ),\n        )\n\n        complete = dialog.addbutton(\n            _(\"&Send report (%s)\")\n            % self.format_filesize(self.get_complete_size())\n        )\n\n        if self.can_examine_locally():\n            examine = dialog.addbutton(_(\"&Examine locally\"))\n        else:\n            examine = None\n\n        view = dialog.addbutton(_(\"&View report\"))\n        save = dialog.addbutton(\n            _(\n                \"&Keep report file for sending later\"\n                \" or copying to somewhere else\"\n            )\n        )\n        ignore = dialog.addbutton(\n            _(\"Cancel and &ignore future crashes of this program version\")\n        )\n\n        dialog.addbutton(_(\"&Cancel\"))\n\n        while True:\n            response = dialog.run()\n\n            return_value = apport.ui.Action()\n            if response == examine:\n                return_value.examine = True\n                return return_value\n            if response == complete:\n                return_value.report = True\n            if response == ignore:\n                return_value.ignore = True\n            if response == view:\n                self.collect_info()\n                self.ui_update_view()\n                continue\n            if response == save:\n                # we do not already have a report file if we report a bug\n                if not self.report_file:\n                    prefix = \"apport.\"\n                    if \"Package\" in self.report:\n                        prefix += self.report[\"Package\"].split()[0] + \".\"\n                    (fd, self.report_file) = tempfile.mkstemp(\n                        prefix=prefix, suffix=\".apport\"\n                    )\n                    with os.fdopen(fd, \"wb\") as f:\n                        self.report.write(f)\n\n                print(_(\"Problem report file:\") + \" \" + self.report_file)\n\n            return return_value\n\n    def ui_info_message(self, title, text):\n        dialog = CLIDialog(title, text)\n        dialog.addbutton(_(\"&Confirm\"))\n        dialog.run()\n\n    def ui_error_message(self, title, text):\n        dialog = CLIDialog(_(\"Error: %s\") % title, text)\n        dialog.addbutton(_(\"&Confirm\"))\n        dialog.run()\n\n    def ui_start_info_collection_progress(self):\n        self.progress = CLIProgressDialog(\n            _(\"Collecting problem information\"),\n            _(\n                \"The collected information can be sent\"\n                \" to the developers to improve the\\n\"\n                \"application. This might take a few minutes.\"\n            ),\n        )\n        self.progress.show()\n\n    def ui_pulse_info_collection_progress(self):\n        assert self.progress is not None\n        self.progress.set()\n\n    def ui_stop_info_collection_progress(self):\n        sys.stdout.write(\"\\n\")\n\n    def ui_start_upload_progress(self):\n        self.progress = CLIProgressDialog(\n            _(\"Uploading problem information\"),\n            _(\n                \"The collected information is being sent\"\n                \" to the bug tracking system.\\n\"\n                \"This might take a few minutes.\"\n            ),\n        )\n        self.progress.show()\n\n    def ui_set_upload_progress(self, progress: typing.Optional[float]) -> None:\n        assert self.progress is not None\n        self.progress.set(progress)\n\n    def ui_stop_upload_progress(self):\n        sys.stdout.write(\"\\n\")\n\n    def ui_question_yesno(self, text):\n        \"\"\"Show a yes/no question.\n\n        Return True if the user selected \"Yes\", False if selected \"No\" or\n        \"None\" on cancel/dialog closing.\n        \"\"\"\n        dialog = CLIDialog(text, None)\n        r_yes = dialog.addbutton(\"&Yes\")\n        r_no = dialog.addbutton(\"&No\")\n        r_cancel = dialog.addbutton(_(\"&Cancel\"))\n        result = dialog.run()\n        if result == r_yes:\n            return True\n        if result == r_no:\n            return False\n        assert result == r_cancel\n        return None\n\n    def ui_question_choice(self, text, options, multiple):\n        \"\"\"Show an question with predefined choices.\n\n        options is a list of strings to present. If multiple is True, they\n        should be check boxes, if multiple is False they should be radio\n        buttons.\n\n        Return list of selected option indexes, or None if the user cancelled.\n        If multiple == False, the list will always have one element.\n        \"\"\"\n        result = []\n        dialog = CLIDialog(text, None)\n\n        if multiple:\n            while True:\n                dialog = CLIDialog(text, None)\n                index = 0\n                choice_index_map = {}\n                for option in options:\n                    if index not in result:\n                        choice_index_map[\n                            dialog.addbutton(option, str(index + 1))\n                        ] = index\n                    index += 1\n                done = dialog.addbutton(_(\"&Done\"))\n                cancel = dialog.addbutton(_(\"&Cancel\"))\n\n                if result:\n                    cur = \", \".join([str(r + 1) for r in result])\n                else:\n                    cur = _(\"none\")\n                response = dialog.run(\n                    _(\"Selected: %s. Multiple choices:\") % cur\n                )\n                if response == cancel:\n                    return None\n                if response == done:\n                    break\n                result.append(choice_index_map[response])\n\n        else:\n            # single choice (radio button)\n            dialog = CLIDialog(text, None)\n            index = 1\n            for option in options:\n                dialog.addbutton(option, str(index))\n                index += 1\n\n            cancel = dialog.addbutton(_(\"&Cancel\"))\n            response = dialog.run(_(\"Choices:\"))\n            if response == cancel:\n                return None\n            result.append(response - 1)\n\n        return result\n\n    def ui_question_file(self, text):\n        \"\"\"Show a file selector dialog.\n\n        Return path if the user selected a file, or None if cancelled.\n        \"\"\"\n        print(\"\\n***  \" + text)\n        while True:\n            sys.stdout.write(_(\"Path to file (Enter to cancel):\"))\n            sys.stdout.write(\" \")\n            f = sys.stdin.readline().strip()\n            if not f:\n                return None\n            if not os.path.exists(f):\n                print(_(\"File does not exist.\"))\n            elif os.path.isdir(f):\n                print(_(\"This is a directory.\"))\n            else:\n                return f\n\n    def open_url(self, url):\n        text = \"%s\\n\\n  %s\\n\\n%s\" % (\n            _(\"To continue, you must visit the following URL:\"),\n            url,\n            _(\n                \"You can launch a browser now,\"\n                \" or copy this URL into a browser on another computer.\"\n            ),\n        )\n\n        answer = self.ui_question_choice(\n            text, [_(\"Launch a browser now\")], False\n        )\n        if answer == [0]:\n            apport.ui.UserInterface.open_url(self, url)\n\n    def ui_has_terminal(self):\n        # we are already running in a terminal, so this works by definition\n        return True\n\n    def ui_run_terminal(self, command):\n        subprocess.call(command, shell=True)\n\n\nif __name__ == \"__main__\":\n    app = CLIUserInterface(sys.argv)\n    if not app.run_argv():\n        print(_(\"No pending crash reports. Try --help for more information.\"))\n", "import contextlib\nimport errno\nimport glob\nimport io\nimport locale\nimport os\nimport pwd\nimport shutil\nimport signal\nimport stat\nimport subprocess\nimport tempfile\nimport textwrap\nimport time\nimport typing\nimport unittest\nimport unittest.mock\nimport urllib.error\n\nimport apport.crashdb_impl.memory\nimport apport.packaging\nimport apport.report\nimport apport.ui\nimport problem_report\nfrom apport.ui import _, run_as_real_user\nfrom tests.helper import pidof, skip_if_command_is_missing\nfrom tests.paths import (\n    local_test_environment,\n    patch_data_dir,\n    restore_data_dir,\n)\n\nORIGINAL_SUBPROCESS_RUN = subprocess.run\nlogind_session = apport.Report.get_logind_session(os.getpid())\n\n\ndef mock_run_calls_except_pgrep(\n    args: list[str], check: bool = False, **kwargs\n) -> subprocess.CompletedProcess:\n    \"\"\"Wrap subprocess.run() doing no-ops except for pgrep.\"\"\"\n    if args[0] == \"pgrep\":\n        return ORIGINAL_SUBPROCESS_RUN(args, check=check, **kwargs)\n    return subprocess.CompletedProcess(args, 0)\n\n\nclass UserInterfaceMock(apport.ui.UserInterface):\n    \"\"\"Concrete apport.ui.UserInterface suitable for automatic testing\"\"\"\n\n    def __init__(self, argv: typing.Optional[list[str]] = None):\n        # use our memory crashdb which is designed for testing\n        # closed in __del__, pylint: disable=consider-using-with\n        self.crashdb_conf = tempfile.NamedTemporaryFile()\n        self.crashdb_conf.write(\n            textwrap.dedent(\n                \"\"\"\\\n                default = 'testsuite'\n                databases = {\n                    'testsuite': {\n                        'impl': 'memory',\n                        'bug_pattern_url': None,\n                    },\n                    'debug': {\n                        'impl': 'memory',\n                        'distro': 'debug',\n                    },\n                }\n                \"\"\"\n            ).encode()\n        )\n        self.crashdb_conf.flush()\n\n        os.environ[\"APPORT_CRASHDB_CONF\"] = self.crashdb_conf.name\n\n        if argv is None:\n            argv = [\"ui-test\"]\n        apport.ui.UserInterface.__init__(self, argv)\n\n        self.crashdb = apport.crashdb_impl.memory.CrashDatabase(\n            None, {\"sample_data\": 1, \"dupdb_url\": \"\"}\n        )\n\n        # state of progress dialogs\n        self.ic_progress_active = False\n        self.ic_progress_pulses = 0  # count the pulses\n        self.upload_progress_active = False\n        self.upload_progress_pulses = 0\n\n        # store last message box\n        self.msg_title = None\n        self.msg_text = None\n        self.msg_severity = None\n        self.msg_choices = None\n\n        # these store the choices the ui_present_* calls do\n        self.present_package_error_response = None\n        self.present_kernel_error_response = None\n        self.present_details_response = None\n        self.question_yesno_response = None\n        self.question_choice_response = None\n        self.question_file_response = None\n\n        self.opened_url = None\n        self.present_details_shown = False\n\n        self.clear_msg()\n\n    def __del__(self):\n        self.crashdb_conf.close()\n\n    def clear_msg(self):\n        # last message box\n        self.msg_title = None\n        self.msg_text = None\n        self.msg_severity = None  # 'warning' or 'error'\n        self.msg_choices = None\n\n    def ui_present_report_details(\n        self, allowed_to_report=True, modal_for=None\n    ) -> apport.ui.Action:\n        self.present_details_shown = True\n        assert self.present_details_response\n        return self.present_details_response\n\n    def ui_info_message(self, title, text):\n        self.msg_title = title\n        self.msg_text = text\n        self.msg_severity = \"info\"\n\n    def ui_error_message(self, title, text):\n        self.msg_title = title\n        self.msg_text = text\n        self.msg_severity = \"error\"\n\n    def ui_start_info_collection_progress(self):\n        self.ic_progress_pulses = 0\n        self.ic_progress_active = True\n\n    def ui_pulse_info_collection_progress(self):\n        assert self.ic_progress_active\n        self.ic_progress_pulses += 1\n\n    def ui_stop_info_collection_progress(self):\n        self.ic_progress_active = False\n\n    def ui_start_upload_progress(self):\n        self.upload_progress_pulses = 0\n        self.upload_progress_active = True\n\n    def ui_set_upload_progress(self, progress: typing.Optional[float]) -> None:\n        assert self.upload_progress_active\n        self.upload_progress_pulses += 1\n\n    def ui_stop_upload_progress(self):\n        self.upload_progress_active = False\n\n    def ui_has_terminal(self):\n        # The tests are already running in a terminal\n        return True\n\n    def ui_run_terminal(self, command):\n        subprocess.call(command, shell=True)\n\n    def open_url(self, url):\n        self.opened_url = url\n\n    def ui_question_yesno(self, text):\n        self.msg_text = text\n        return self.question_yesno_response\n\n    def ui_question_choice(self, text, options, multiple):\n        self.msg_text = text\n        self.msg_choices = options\n        return self.question_choice_response\n\n    def ui_question_file(self, text):\n        self.msg_text = text\n        return self.question_file_response\n\n\n@unittest.mock.patch(\n    \"apport.hookutils._root_command_prefix\",\n    unittest.mock.MagicMock(return_value=[]),\n)\nclass T(unittest.TestCase):\n    TEST_EXECUTABLE = os.path.realpath(\"/bin/sleep\")\n    TEST_ARGS = [\"86400\"]\n\n    def setUp(self):\n        self.orig_environ = os.environ.copy()\n        os.environ |= local_test_environment()\n\n        # we test a few strings, don't get confused by translations\n        for v in [\"LANG\", \"LANGUAGE\", \"LC_MESSAGES\", \"LC_ALL\"]:\n            try:\n                del os.environ[v]\n            except KeyError:\n                pass\n\n        self.orig_data_dir = patch_data_dir(apport.report)\n\n        # pylint: disable=protected-access\n        self.workdir = tempfile.mkdtemp()\n        self.orig_report_dir = apport.fileutils.report_dir\n        apport.fileutils.report_dir = os.path.join(self.workdir, \"crash\")\n        os.mkdir(apport.fileutils.report_dir)\n        self.orig_symptom_script_dir = apport.ui.symptom_script_dir\n        apport.ui.symptom_script_dir = os.path.join(self.workdir, \"symptoms\")\n        os.mkdir(apport.ui.symptom_script_dir)\n        self.orig_ignore_file = apport.report._ignore_file\n        apport.report._ignore_file = os.path.join(\n            self.workdir, \"apport-ignore.xml\"\n        )\n        os.mknod(apport.report._ignore_file)\n\n        self.ui = UserInterfaceMock()\n\n        # demo report\n        self.report = apport.Report()\n        self.report[\"ExecutablePath\"] = \"/bin/bash\"\n        self.report[\"Package\"] = \"libfoo1 1-1\"\n        self.report[\"SourcePackage\"] = \"foo\"\n        self.report[\"Foo\"] = \"A\" * 1000\n        self.report[\"CoreDump\"] = problem_report.CompressedValue(\n            b\"\\x01\" * 100000\n        )\n\n        # write demo report into temporary file\n        # closed in tearDown, pylint: disable=consider-using-with\n        self.report_file = tempfile.NamedTemporaryFile()\n        self.update_report_file()\n\n        # set up our local hook directory\n        self.hookdir = os.path.join(self.workdir, \"package-hooks\")\n        os.mkdir(self.hookdir)\n        self.orig_package_hook_dir = apport.report.PACKAGE_HOOK_DIR\n        apport.report.PACKAGE_HOOK_DIR = self.hookdir\n\n        # test suite should not stumble over local packages\n        os.environ[\"APPORT_IGNORE_OBSOLETE_PACKAGES\"] = \"1\"\n        os.environ[\"APPORT_DISABLE_DISTRO_CHECK\"] = \"1\"\n\n        self.running_test_executables = pidof(self.TEST_EXECUTABLE)\n\n    def update_report_file(self):\n        self.report_file.seek(0)\n        self.report_file.truncate()\n        self.report.write(self.report_file)\n        self.report_file.flush()\n\n    def tearDown(self):\n        apport.fileutils.report_dir = self.orig_report_dir\n        self.orig_report_dir = None\n        apport.ui.symptom_script_dir = self.orig_symptom_script_dir\n        self.orig_symptom_script_dir = None\n\n        # pylint: disable=protected-access\n        os.unlink(apport.report._ignore_file)\n        apport.report._ignore_file = self.orig_ignore_file\n\n        self.ui = None\n        self.report_file.close()\n\n        self.assertEqual(\n            pidof(self.TEST_EXECUTABLE) - self.running_test_executables,\n            set(),\n            \"no stray test processes\",\n        )\n\n        apport.report.PACKAGE_HOOK_DIR = self.orig_package_hook_dir\n        shutil.rmtree(self.workdir)\n        os.environ.clear()\n        os.environ.update(self.orig_environ)\n\n        restore_data_dir(apport.report, self.orig_data_dir)\n\n    @contextlib.contextmanager\n    def _run_test_executable(\n        self,\n        exename: typing.Optional[str] = None,\n        env: typing.Optional[dict[str, str]] = None,\n    ) -> typing.Generator[int, None, None]:\n        if not exename:\n            exename = self.TEST_EXECUTABLE\n\n        with subprocess.Popen(\n            [exename] + self.TEST_ARGS, env=env\n        ) as test_process:\n            # give the execv() some time to finish\n            time.sleep(0.5)\n            yield test_process.pid\n            test_process.kill()\n\n    @staticmethod\n    def _write_symptom_script(script_name: str, content: str) -> None:\n        path = os.path.join(apport.ui.symptom_script_dir, script_name)\n        with open(path, \"w\", encoding=\"utf-8\") as symptom_script:\n            symptom_script.write(content)\n\n    def test_format_filesize(self):\n        \"\"\"format_filesize()\"\"\"\n        locale_numeric = locale.getlocale(locale.LC_NUMERIC)\n        locale.setlocale(locale.LC_NUMERIC, \"C\")\n        try:\n            self.assertEqual(self.ui.format_filesize(0), \"0.0 KB\")\n            self.assertEqual(self.ui.format_filesize(2048), \"2.0 KB\")\n            self.assertEqual(self.ui.format_filesize(2560), \"2.6 KB\")\n            self.assertEqual(self.ui.format_filesize(999999), \"1000.0 KB\")\n            self.assertEqual(self.ui.format_filesize(1000000), \"1.0 MB\")\n            self.assertEqual(self.ui.format_filesize(2.7 * 1000000), \"2.7 MB\")\n            self.assertEqual(self.ui.format_filesize(1024 * 1000000), \"1.0 GB\")\n            self.assertEqual(self.ui.format_filesize(2560 * 1000000), \"2.6 GB\")\n        finally:\n            locale.setlocale(locale.LC_NUMERIC, locale_numeric)\n\n    def test_get_size_loaded(self):\n        \"\"\"get_complete_size() and get_reduced_size() for loaded Reports\"\"\"\n        self.ui.load_report(self.report_file.name)\n\n        fsize = os.path.getsize(self.report_file.name)\n        complete_ratio = float(self.ui.get_complete_size()) / fsize\n        self.assertAlmostEqual(complete_ratio, 1.0, delta=0.1)\n\n        rs = self.ui.get_reduced_size()\n        self.assertTrue(rs > 1000)\n        self.assertTrue(rs < 10000)\n\n        # now add some information (e. g. from package hooks)\n        self.ui.report[\"ExtraInfo\"] = \"A\" * 50000\n        s = self.ui.get_complete_size()\n        self.assertTrue(s >= fsize + 49900)\n        self.assertTrue(s < fsize + 60000)\n\n        rs = self.ui.get_reduced_size()\n        self.assertTrue(rs > 51000)\n        self.assertTrue(rs < 60000)\n\n    def test_get_size_constructed(self):\n        \"\"\"get_complete_size() and get_reduced_size() for on-the-fly Reports\"\"\"\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.report[\"Hello\"] = \"World\"\n\n        s = self.ui.get_complete_size()\n        self.assertTrue(s > 5)\n        self.assertTrue(s < 100)\n\n        self.assertEqual(s, self.ui.get_reduced_size())\n\n    def test_load_report(self):\n        \"\"\"load_report()\"\"\"\n        # valid report\n        self.ui.load_report(self.report_file.name)\n        self.assertEqual(set(self.ui.report.keys()), set(self.report.keys()))\n        self.assertEqual(self.ui.report[\"Package\"], self.report[\"Package\"])\n        self.assertEqual(\n            self.ui.report[\"CoreDump\"].get_value(),\n            self.report[\"CoreDump\"].get_value(),\n        )\n        self.assertEqual(self.ui.msg_title, None)\n\n        self.ui.clear_msg()\n\n        # invalid base64 encoding\n        self.report_file.seek(0)\n        self.report_file.truncate()\n        self.report_file.write(\n            textwrap.dedent(\n                \"\"\"\\\n                Type: test\n                Package: foo 1-1\n                CoreDump: base64\n                bOgUs=\n                \"\"\"\n            ).encode()\n        )\n        self.report_file.flush()\n\n        self.ui.load_report(self.report_file.name)\n        self.assertTrue(self.ui.report is None)\n        self.assertEqual(self.ui.msg_title, _(\"Invalid problem report\"))\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    def test_restart(self):\n        \"\"\"restart()\"\"\"\n        # test with only ProcCmdline\n        p = os.path.join(apport.fileutils.report_dir, \"ProcCmdline\")\n        r = os.path.join(apport.fileutils.report_dir, \"Custom\")\n        self.report[\"ProcCmdline\"] = \"touch \" + p\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n\n        self.ui.restart()\n        time.sleep(1)  # FIXME: race condition\n        self.assertTrue(os.path.exists(p))\n        self.assertTrue(not os.path.exists(r))\n        os.unlink(p)\n\n        # test with RespawnCommand\n        self.report[\"RespawnCommand\"] = \"touch \" + r\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n\n        self.ui.restart()\n        time.sleep(1)  # FIXME: race condition\n        self.assertTrue(not os.path.exists(p))\n        self.assertTrue(os.path.exists(r))\n        os.unlink(r)\n\n        # test that invalid command does not make us fall apart\n        del self.report[\"RespawnCommand\"]\n        self.report[\"ProcCmdline\"] = \"/nonexisting\"\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n\n    def test_collect_info_distro(self):\n        \"\"\"collect_info() on report without information (distro bug)\"\"\"\n        # report without any information (distro bug)\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.collect_info()\n        self.assertTrue(\n            set([\"Date\", \"Uname\", \"DistroRelease\", \"ProblemType\"]).issubset(\n                set(self.ui.report.keys())\n            )\n        )\n        self.assertEqual(\n            self.ui.ic_progress_pulses,\n            0,\n            \"no progress dialog for distro bug info collection\",\n        )\n\n    def test_collect_info_exepath(self):\n        \"\"\"collect_info() on report with only ExecutablePath\"\"\"\n        # report with only package information\n        self.report = apport.Report(\"Bug\")\n        self.report[\"ExecutablePath\"] = \"/bin/bash\"\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n        # add some tuple values, for robustness testing (might be added by\n        # apport hooks)\n        self.ui.report[\"Fstab\"] = (\"/etc/fstab\", True)\n        self.ui.report[\"CompressedValue\"] = problem_report.CompressedValue(\n            b\"Test\"\n        )\n        self.ui.collect_info()\n        self.assertTrue(\n            set(\n                [\n                    \"SourcePackage\",\n                    \"Package\",\n                    \"ProblemType\",\n                    \"Uname\",\n                    \"Dependencies\",\n                    \"DistroRelease\",\n                    \"Date\",\n                    \"ExecutablePath\",\n                ]\n            ).issubset(set(self.ui.report.keys()))\n        )\n        self.assertTrue(\n            self.ui.ic_progress_pulses > 0,\n            \"progress dialog for package bug info collection\",\n        )\n        self.assertEqual(\n            self.ui.ic_progress_active,\n            False,\n            \"progress dialog for package bug info collection finished\",\n        )\n\n    def test_collect_info_package(self):\n        \"\"\"collect_info() on report with a package\"\"\"\n        # report with only package information\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n\n        def search_bug_patterns(url: str) -> typing.Optional[str]:\n            progress_pulses = self.ui.ic_progress_pulses\n            # wait for ui_pulse_info_collection_progress() call\n            while self.ui.ic_progress_pulses == progress_pulses:\n                time.sleep(0.01)\n            return apport.report.Report.search_bug_patterns(\n                self.ui.report, url\n            )\n\n        with unittest.mock.patch.object(\n            self.ui.report,\n            \"search_bug_patterns\",\n            side_effect=search_bug_patterns,\n        ) as search_bug_patterns_mock:\n            self.ui.collect_info()\n\n        search_bug_patterns_mock.assert_called_once()\n        self.assertTrue(\n            set(\n                [\n                    \"SourcePackage\",\n                    \"Package\",\n                    \"ProblemType\",\n                    \"Uname\",\n                    \"Dependencies\",\n                    \"DistroRelease\",\n                    \"Date\",\n                ]\n            ).issubset(set(self.ui.report.keys()))\n        )\n        self.assertTrue(\n            self.ui.ic_progress_pulses > 0,\n            \"progress dialog for package bug info collection\",\n        )\n        self.assertEqual(\n            self.ui.ic_progress_active,\n            False,\n            \"progress dialog for package bug info collection finished\",\n        )\n\n    def test_collect_info_permissions(self):\n        \"\"\"collect_info() leaves the report accessible to the group\"\"\"\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.report_file = self.report_file.name\n        self.ui.collect_info()\n        self.assertTrue(os.stat(self.report_file.name).st_mode & stat.S_IRGRP)\n\n    def _write_crashdb_config_hook(self, crashdb: str, bash_hook: str = None):\n        \"\"\"Write source_bash.py hook that sets CrashDB\"\"\"\n        with open(\n            os.path.join(self.hookdir, \"source_bash.py\"), \"w\", encoding=\"utf-8\"\n        ) as f:\n            f.write(\n                textwrap.dedent(\n                    f'''\\\n                    def add_info(report, ui):\n                        report['CrashDB'] = \"\"\"{crashdb}\"\"\"\n                    '''\n                )\n            )\n            if bash_hook:\n                f.write(f\"    report['BashHook'] = '{bash_hook}'\\n\")\n\n    def test_collect_info_crashdb_spec(self):\n        \"\"\"collect_info() with package hook that defines a CrashDB\"\"\"\n        self._write_crashdb_config_hook(\n            \"{ 'impl': 'memory', 'local_opt': '1' }\", \"Moo\"\n        )\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertIn(\"CrashDB\", self.ui.report)\n        self.assertNotIn(\"UnreportableReason\", self.ui.report)\n        self.assertEqual(self.ui.report[\"BashHook\"], \"Moo\")\n        self.assertEqual(self.ui.crashdb.options[\"local_opt\"], \"1\")\n\n    def test_collect_info_crashdb_name(self):\n        \"\"\"collect_info() with package hook that chooses a different CrashDB\"\"\"\n        self._write_crashdb_config_hook(\"debug\", \"Moo\")\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertNotIn(\"UnreportableReason\", self.ui.report)\n        self.assertEqual(self.ui.report[\"BashHook\"], \"Moo\")\n        self.assertEqual(self.ui.crashdb.options[\"distro\"], \"debug\")\n\n    def test_collect_info_crashdb_errors(self):\n        \"\"\"collect_info() with package hook setting a broken CrashDB field\"\"\"\n        # nonexisting implementation\n        self._write_crashdb_config_hook(\n            \"{ 'impl': 'nonexisting', 'local_opt': '1' }\"\n        )\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertIn(\"nonexisting\", self.ui.report[\"UnreportableReason\"])\n\n        # invalid syntax\n        self._write_crashdb_config_hook(\"{ 'impl': 'memory', 'local_opt'\")\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertIn(\"package hook\", self.ui.report[\"UnreportableReason\"])\n\n        # nonexisting name\n        self._write_crashdb_config_hook(\"nonexisting\")\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertIn(\"nonexisting\", self.ui.report[\"UnreportableReason\"])\n\n        # string with unsafe contents\n        self._write_crashdb_config_hook(\n            \"\"\"{'impl': 'memory',\"\"\"\n            \"\"\" 'trap': exec('open(\"/tmp/pwned\", \"w\").close()')}\"\"\"\n        )\n        self.ui.report = apport.Report(\"Bug\")\n        self.ui.cur_package = \"bash\"\n        self.ui.collect_info()\n        self.assertIn(\"package hook\", self.ui.report[\"UnreportableReason\"])\n        self.assertFalse(os.path.exists(\"/tmp/pwned\"))\n\n    def test_handle_duplicate(self):\n        \"\"\"handle_duplicate()\"\"\"\n        self.ui.load_report(self.report_file.name)\n        self.assertEqual(self.ui.handle_duplicate(), False)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n\n        demo_url = \"http://example.com/1\"\n        self.report[\"_KnownReport\"] = demo_url\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n        self.assertEqual(self.ui.handle_duplicate(), True)\n        self.assertEqual(self.ui.msg_severity, \"info\")\n        self.assertEqual(self.ui.opened_url, demo_url)\n\n        self.ui.opened_url = None\n        demo_url = \"http://example.com/1\"\n        self.report[\"_KnownReport\"] = \"1\"\n        self.update_report_file()\n        self.ui.load_report(self.report_file.name)\n        self.assertEqual(self.ui.handle_duplicate(), True)\n        self.assertEqual(self.ui.msg_severity, \"info\")\n        self.assertEqual(self.ui.opened_url, None)\n\n    def test_run_nopending(self):\n        \"\"\"Run the frontend without any pending reports.\"\"\"\n        self.ui = UserInterfaceMock()\n        self.assertEqual(self.ui.run_argv(), False)\n\n    def test_run_restart(self):\n        \"\"\"Running the frontend with pending reports offers restart.\"\"\"\n        r = self._gen_test_crash()\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action()\n        self.ui.run_argv()\n        self.assertEqual(self.ui.offer_restart, True)\n\n    def test_run_report_bug_noargs(self):\n        \"\"\"run_report_bug() without specifying arguments\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\"])\n        self.assertEqual(self.ui.run_argv(), False)\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    @unittest.mock.patch(\"sys.stdout\", new_callable=io.StringIO)\n    def test_run_version(self, stdout_mock):\n        \"\"\"run_report_bug() as \"ubuntu-bug\" with version argument\"\"\"\n        self.ui = UserInterfaceMock([\"ubuntu-bug\", \"-v\"])\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(stdout_mock.getvalue(), apport.ui.__version__ + \"\\n\")\n\n    def test_file_report_nodelay(self):\n        \"\"\"file_report() happy path without polling\"\"\"\n        self.ui = UserInterfaceMock()\n        self.ui.report = self.report\n        previous_id = self.ui.crashdb.latest_id()\n        self.ui.file_report()\n        self.assertNotEqual(self.ui.crashdb.latest_id(), previous_id)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.msg_text, None)\n\n    def test_file_report_upload_delay(self):\n        \"\"\"file_report() with some polling during upload\"\"\"\n        self.ui = UserInterfaceMock()\n        self.ui.report = self.report\n        self.ui.crashdb.upload_delay = 0.2  # Arbitrary value\n        previous_id = self.ui.crashdb.latest_id()\n        self.ui.file_report()\n        self.assertNotEqual(self.ui.crashdb.latest_id(), previous_id)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.msg_text, None)\n\n    def test_file_report_upload_message(self):\n        \"\"\"file_report() with a message to the user\"\"\"\n        self.ui = UserInterfaceMock()\n        self.ui.report = self.report\n        self.ui.crashdb.upload_msg = (\"test title\", \"test content\")\n        previous_id = self.ui.crashdb.latest_id()\n        self.ui.file_report()\n        self.assertNotEqual(self.ui.crashdb.latest_id(), previous_id)\n        self.assertEqual(self.ui.msg_severity, \"info\")\n        self.assertEqual(self.ui.msg_title, \"test title\")\n        self.assertEqual(self.ui.msg_text, \"test content\")\n\n    def test_file_report_http_error(self) -> None:\n        \"\"\"file_report() fails with HTTPError.\"\"\"\n        self.ui = UserInterfaceMock()\n        self.ui.report = self.report\n        with unittest.mock.patch.object(\n            self.ui.crashdb, \"upload\"\n        ) as upload_mock:\n            upload_mock.side_effect = urllib.error.HTTPError(\n                \"https://example.com/\", 502, \"Bad Gateway\", {}, None\n            )\n            self.ui.file_report()\n        self.assertEqual(self.ui.msg_severity, \"error\")\n        self.assertEqual(self.ui.msg_title, \"Network problem\")\n        self.assertEqual(\n            self.ui.msg_text,\n            \"Cannot connect to crash database, please check your Internet\"\n            \" connection.\\n\\nHTTP Error 502: Bad Gateway\",\n        )\n\n    def test_run_report_bug_package(self):\n        \"\"\"run_report_bug() for a package\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-p\", \"bash\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertTrue(self.ui.present_details_shown)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://bash.bugs.example.com/%i\" % self.ui.crashdb.latest_id(),\n        )\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertEqual(self.ui.report[\"SourcePackage\"], \"bash\")\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Bug\")\n\n        # should not crash on nonexisting package\n        argv = [\"ui-test\", \"-f\", \"-p\", \"nonexisting_gibberish\"]\n        self.ui = UserInterfaceMock(argv)\n        try:\n            self.ui.run_argv()\n        except SystemExit:\n            pass\n\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    def test_run_report_bug_pid_tags(self):\n        \"\"\"run_report_bug() for a pid with extra tags\"\"\"\n        with self._run_test_executable() as pid:\n            # report a bug on text executable process\n            argv = [\"ui-test\", \"-f\", \"--tag\", \"foo\", \"-P\", str(pid)]\n            self.ui = UserInterfaceMock(argv)\n            self.ui.present_details_response = apport.ui.Action(report=True)\n            self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertIn(\"SourcePackage\", self.ui.report)\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcMaps\", self.ui.report)\n        self.assertEqual(\n            self.ui.report[\"ExecutablePath\"], self.TEST_EXECUTABLE\n        )\n        self.assertNotIn(\"ProcCmdline\", self.ui.report)  # privacy!\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Bug\")\n        self.assertIn(\"foo\", self.ui.report.get_tags())\n\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://coreutils.bugs.example.com/%i\"\n            % self.ui.crashdb.latest_id(),\n        )\n        self.assertTrue(self.ui.present_details_shown)\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n\n    @staticmethod\n    def _find_unused_pid():\n        \"\"\"Find and return an unused PID.\"\"\"\n        pid = 1\n        while True:\n            pid += 1\n            try:\n                os.kill(pid, 0)\n            except OSError as error:\n                if error.errno == errno.ESRCH:\n                    break\n        return pid\n\n    def test_run_report_bug_wrong_pid(self):\n        \"\"\"run_report_bug() for a nonexisting pid\"\"\"\n        # silently ignore missing PID; this happens when the user closes\n        # the application prematurely\n        pid = self._find_unused_pid()\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-P\", str(pid)])\n        self.ui.run_argv()\n\n    def test_run_report_bug_noperm_pid(self):\n        \"\"\"run_report_bug() for a pid which runs as a different user\"\"\"\n        restore_root = False\n        if os.getuid() == 0:\n            # temporarily drop to normal user \"mail\"\n            os.setresuid(8, 8, -1)\n            restore_root = True\n\n        try:\n            self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-P\", \"1\"])\n            self.ui.run_argv()\n\n            self.assertEqual(self.ui.msg_severity, \"error\")\n        finally:\n            if restore_root:\n                os.setresuid(0, 0, -1)\n\n    def test_run_report_bug_unpackaged_pid(self):\n        \"\"\"run_report_bug() for a pid of an unpackaged program\"\"\"\n        # create unpackaged test program\n        (fd, exename) = tempfile.mkstemp()\n        with open(self.TEST_EXECUTABLE, \"rb\") as f:\n            os.write(fd, f.read())\n        os.close(fd)\n        os.chmod(exename, 0o755)\n\n        with self._run_test_executable(exename) as pid:\n            self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-P\", str(pid)])\n            self.assertRaises(SystemExit, self.ui.run_argv)\n\n        os.unlink(exename)\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    @unittest.mock.patch(\"apport.packaging_impl.impl.get_version\")\n    def test_run_report_bug_kernel_thread(self, get_version_mock):\n        \"\"\"run_report_bug() for a pid of a kernel thread\"\"\"\n        # The kernel package might not be installed in chroot environments.\n        # Therefore mock get_version for the kernel package.\n        get_version_mock.return_value = \"5.15.0-33.34\"\n\n        for path in glob.glob(\"/proc/[0-9]*/stat\"):\n            with open(path, encoding=\"utf-8\") as f:\n                proc_stat = f.read().split()\n            flags = int(proc_stat[8])\n            if flags & apport.ui.PF_KTHREAD:\n                pid = int(proc_stat[0])\n                break\n        else:\n            self.skipTest(\"no kernel thread found\")\n\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-P\", str(pid)])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_argv()\n\n        kernel_package = apport.packaging.get_kernel_package()\n        self.assertEqual(\n            self.ui.report[\"Package\"],\n            f\"{kernel_package} {get_version_mock.return_value}\",\n        )\n        get_version_mock.assert_any_call(kernel_package)\n\n    def test_run_report_bug_file(self):\n        \"\"\"run_report_bug() with saving report into a file\"\"\"\n        d = os.path.join(apport.fileutils.report_dir, \"home\")\n        os.mkdir(d)\n        reportfile = os.path.join(d, \"bashisbad.apport\")\n\n        argv = [\"ui-test\", \"-f\", \"-p\", \"bash\", \"--save\", reportfile]\n        self.ui = UserInterfaceMock(argv)\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertFalse(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n\n        r = apport.Report()\n        with open(reportfile, \"rb\") as f:\n            r.load(f)\n\n        self.assertEqual(r[\"SourcePackage\"], \"bash\")\n        self.assertIn(\"Dependencies\", r)\n        self.assertIn(\"ProcEnviron\", r)\n        self.assertEqual(r[\"ProblemType\"], \"Bug\")\n\n        # report it\n        self.ui = UserInterfaceMock([\"ui-test\", \"-c\", reportfile])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertEqual(self.ui.msg_text, None)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n    def _gen_test_crash(self):\n        \"\"\"Generate a Report with real crash data.\"\"\"\n        core_path = os.path.join(self.workdir, \"core\")\n        try:\n            with subprocess.Popen(\n                [\n                    \"gdb\",\n                    \"--batch\",\n                    \"-iex\",\n                    \"set debuginfod enable off\",\n                    \"--ex\",\n                    f\"run {' '.join(self.TEST_ARGS)}\",\n                    \"--ex\",\n                    f\"generate-core-file {core_path}\",\n                    self.TEST_EXECUTABLE,\n                ],\n                env={\"HOME\": self.workdir},\n                stdout=subprocess.PIPE,\n            ) as gdb:\n                timeout = 10.0\n                while timeout > 0:\n                    pids = (\n                        pidof(self.TEST_EXECUTABLE)\n                        - self.running_test_executables\n                    )\n                    if pids:\n                        pid = pids.pop()\n                        break\n                    time.sleep(0.01)\n                    timeout -= 0.01\n                else:\n                    gdb.kill()\n                    self.fail(\n                        f\"{self.TEST_EXECUTABLE} not started within 10 seconds\"\n                    )\n\n                # generate crash report\n                r = apport.Report()\n                r[\"ExecutablePath\"] = self.TEST_EXECUTABLE\n                r[\"Signal\"] = \"11\"\n                r.add_proc_info(pid)\n                r.add_user_info()\n                r.add_os_info()\n\n                # generate a core dump\n                os.kill(pid, signal.SIGSEGV)\n                os.waitpid(gdb.pid, 0)\n                assert os.path.exists(core_path)\n                r[\"CoreDump\"] = (core_path,)\n        except FileNotFoundError as error:\n            self.skipTest(f\"{error.filename} not available\")\n\n        return r\n\n    def test_run_crash(self):\n        \"\"\"run_crash()\"\"\"\n        r = self._gen_test_crash()\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n\n        # cancel crash notification dialog\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action()\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertEqual(self.ui.ic_progress_pulses, 0)\n        self.assertEqual(self.ui.offer_restart, False)\n\n        # report in crash notification dialog, send full report\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://coreutils.bugs.example.com/%i\"\n            % self.ui.crashdb.latest_id(),\n        )\n        self.assertFalse(self.ui.ic_progress_active)\n        self.assertNotEqual(self.ui.ic_progress_pulses, 0)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertIn(\"SourcePackage\", self.ui.report)\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"Stacktrace\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertNotIn(\"ExecutableTimestamp\", self.ui.report)\n        self.assertNotIn(\"StacktraceAddressSignature\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Crash\")\n        self.assertTrue(len(self.ui.report[\"CoreDump\"]) > 10000)\n        self.assertTrue(\n            self.ui.report[\"Title\"].startswith(\n                f\"{os.path.basename(self.TEST_EXECUTABLE)}\"\n                f\" crashed with SIGSEGV\"\n            )\n        )\n\n        # so far we did not ignorelist, verify that\n        self.assertTrue(not self.ui.report.check_ignored())\n\n        # cancel crash notification dialog and ignorelist\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(ignore=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertEqual(self.ui.ic_progress_pulses, 0)\n\n        self.assertTrue(self.ui.report.check_ignored())\n        self.assertEqual(self.ui.offer_restart, False)\n\n    def test_run_crash_abort(self):\n        \"\"\"run_crash() for an abort() without assertion message\"\"\"\n        r = self._gen_test_crash()\n        r[\"Signal\"] = \"6\"\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n\n        self.assertIn(\"SourcePackage\", self.ui.report)\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"Stacktrace\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertNotIn(\"ExecutableTimestamp\", self.ui.report)\n        self.assertEqual(self.ui.report[\"Signal\"], \"6\")\n\n        # we disable the ABRT filtering, we want these crashes after all\n        # self.assertIn('assert', self.ui.msg_text, '%s: %s' %\n        #     (self.ui.msg_title, self.ui.msg_text))\n        # self.assertEqual(self.ui.msg_severity, 'info')\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n    @skip_if_command_is_missing(\"gdb\")\n    def test_run_crash_broken(self):\n        \"\"\"run_crash() for an invalid core dump\"\"\"\n        # generate broken crash report\n        r = apport.Report()\n        r[\"ExecutablePath\"] = self.TEST_EXECUTABLE\n        r[\"Signal\"] = \"11\"\n        r[\"CoreDump\"] = problem_report.CompressedValue()\n        r[\"CoreDump\"].gzipvalue = b\"AAAAAAAA\"\n        r.add_user_info()\n\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, \"info\", self.ui.msg_text)\n        self.assertIn(\"decompress\", self.ui.msg_text)\n        self.assertTrue(self.ui.present_details_shown)\n\n    @unittest.mock.patch(\n        \"apport.report.Report.add_gdb_info\", unittest.mock.MagicMock()\n    )\n    @unittest.mock.patch(\n        \"apport.hookutils.attach_conffiles\", unittest.mock.MagicMock()\n    )\n    def test_run_crash_argv_file(self):\n        \"\"\"run_crash() through a file specified on the command line\"\"\"\n        # valid\n        self.report[\"Package\"] = \"bash\"\n        self.update_report_file()\n\n        argv = [\"ui-test\", \"-c\", self.report_file.name]\n        self.ui = UserInterfaceMock(argv)\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertEqual(self.ui.msg_text, None)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        # unreportable\n        self.report[\"Package\"] = \"bash\"\n        self.report[\"UnreportableReason\"] = b\"It stinks. \\xe2\\x99\\xa5\".decode(\n            \"UTF-8\"\n        )\n        self.update_report_file()\n\n        argv = [\"ui-test\", \"-c\", self.report_file.name]\n        self.ui = UserInterfaceMock(argv)\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertIn(\n            \"It stinks.\",\n            self.ui.msg_text,\n            \"%s: %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n        self.assertEqual(self.ui.msg_severity, \"info\")\n\n        # should not die with an exception on an invalid name\n        argv = [\"ui-test\", \"-c\", \"/nonexisting.crash\"]\n        self.ui = UserInterfaceMock(argv)\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    @unittest.mock.patch(\n        \"apport.report.Report.add_gdb_info\", unittest.mock.MagicMock()\n    )\n    def test_run_crash_unreportable(self):\n        \"\"\"run_crash() on a crash with the UnreportableReason field\"\"\"\n        self.report[\"UnreportableReason\"] = \"It stinks.\"\n        self.report[\"ExecutablePath\"] = \"/bin/bash\"\n        self.report[\"Package\"] = \"bash 1\"\n        self.update_report_file()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.ui.run_crash(self.report_file.name)\n\n        self.assertIn(\n            \"It stinks.\",\n            self.ui.msg_text,\n            \"%s: %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n        self.assertEqual(self.ui.msg_severity, \"info\")\n\n    @unittest.mock.patch(\n        \"apport.report.Report.add_gdb_info\", unittest.mock.MagicMock()\n    )\n    def test_run_crash_malicious_crashdb(self):\n        \"\"\"run_crash() on a crash with malicious CrashDB\"\"\"\n        self.report[\"ExecutablePath\"] = \"/bin/bash\"\n        self.report[\"Package\"] = \"bash 1\"\n        self.report[\"CrashDB\"] = (\n            \"{'impl': 'memory',\"\n            \" 'crash_config': open('/tmp/pwned', 'w').close()}\"\n        )\n        self.update_report_file()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.ui.run_crash(self.report_file.name)\n\n        self.assertFalse(os.path.exists(\"/tmp/pwned\"))\n        self.assertIn(\"invalid crash database definition\", self.ui.msg_text)\n\n    @unittest.mock.patch(\n        \"apport.report.Report.add_gdb_info\", unittest.mock.MagicMock()\n    )\n    def test_run_crash_malicious_package(self):\n        \"\"\"Package: path traversal\"\"\"\n        with tempfile.NamedTemporaryFile(suffix=\".py\") as bad_hook:\n            bad_hook.write(\n                b\"def add_info(r, u):\\n  open('/tmp/pwned', 'w').close()\"\n            )\n            bad_hook.flush()\n\n            self.report[\"ExecutablePath\"] = \"/bin/bash\"\n            self.report[\"Package\"] = (\n                \"../\" * 20 + os.path.splitext(bad_hook.name)[0]\n            )\n            self.update_report_file()\n            self.ui.present_details_response = apport.ui.Action(report=True)\n\n            self.ui.run_crash(self.report_file.name)\n\n            self.assertFalse(os.path.exists(\"/tmp/pwned\"))\n            self.assertIn(\"invalid Package:\", self.ui.msg_text)\n\n    def test_run_crash_malicious_exec_path(self):\n        \"\"\"ExecutablePath: path traversal\"\"\"\n        hook_dir = \"/tmp/share/apport/package-hooks\"\n        os.makedirs(hook_dir, exist_ok=True)\n        with tempfile.NamedTemporaryFile(\n            dir=hook_dir, suffix=\".py\"\n        ) as bad_hook:\n            bad_hook.write(\n                b\"def add_info(r, u):\\n  open('/tmp/pwned', 'w').close()\"\n            )\n            bad_hook.flush()\n\n            self.report[\"ExecutablePath\"] = \"/opt/../\" + hook_dir\n            self.report[\"Package\"] = os.path.splitext(bad_hook.name)[\n                0\n            ].replace(hook_dir, \"\")\n            self.update_report_file()\n            self.ui.present_details_response = apport.ui.Action(report=True)\n\n            self.ui.run_crash(self.report_file.name)\n\n            self.assertFalse(os.path.exists(\"/tmp/pwned\"))\n\n    def test_run_crash_ignore(self):\n        \"\"\"run_crash() on a crash with the Ignore field\"\"\"\n        self.report[\"Ignore\"] = \"True\"\n        self.report[\"ExecutablePath\"] = \"/bin/bash\"\n        self.report[\"Package\"] = \"bash 1\"\n        self.update_report_file()\n\n        self.ui.run_crash(self.report_file.name)\n        self.assertEqual(self.ui.msg_severity, None)\n\n    def test_run_crash_nocore(self):\n        \"\"\"run_crash() for a crash dump without CoreDump\"\"\"\n        # create a test executable\n        with self._run_test_executable() as pid:\n            # generate crash report\n            r = apport.Report()\n            r[\"ExecutablePath\"] = self.TEST_EXECUTABLE\n            r[\"Signal\"] = \"42\"\n            r.add_proc_info(pid)\n            r.add_user_info()\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        # run\n        self.ui = UserInterfaceMock()\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, \"error\")\n        self.assertIn(\n            \"memory\",\n            self.ui.msg_text,\n            \"%s: %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n\n    def test_run_crash_preretraced(self):\n        \"\"\"run_crash() pre-retraced reports.\n\n        This happens with crashes which are pre-processed by\n        apport-retrace.\n        \"\"\"\n        r = self._gen_test_crash()\n\n        #  effect of apport-retrace -c\n        r.add_gdb_info()\n        del r[\"CoreDump\"]\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n\n        # report in crash notification dialog, cancel details report\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action()\n        self.ui.run_crash(report_file)\n        self.assertEqual(\n            self.ui.msg_severity,\n            None,\n            \"has %s message: %s: %s\"\n            % (\n                self.ui.msg_severity,\n                str(self.ui.msg_title),\n                str(self.ui.msg_text),\n            ),\n        )\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n    def test_run_crash_precollected(self):\n        \"\"\"run_crash() on complete report on uninstalled package\n\n        This happens when reporting a problem from a different machine through\n        copying a .crash file.\n        \"\"\"\n        self.ui.report = self._gen_test_crash()\n        self.ui.collect_info()\n\n        # now pretend to move it to a machine where the package is not\n        # installed\n        self.ui.report[\"Package\"] = \"uninstalled_pkg 1\"\n        self.ui.report[\"ExecutablePath\"] = \"/usr/bin/uninstalled_program\"\n        self.ui.report[\"InterpreterPath\"] = \"/usr/bin/uninstalled_interpreter\"\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            self.ui.report.write(f)\n\n        # report it\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.cur_package, \"uninstalled_pkg\")\n        self.assertEqual(\n            self.ui.msg_severity,\n            None,\n            \"has %s message: %s: %s\"\n            % (\n                self.ui.msg_severity,\n                str(self.ui.msg_title),\n                str(self.ui.msg_text),\n            ),\n        )\n        self.assertTrue(\n            self.ui.opened_url.startswith(\"http://coreutils.bugs.example.com\")\n        )\n        self.assertTrue(self.ui.present_details_shown)\n\n    def test_run_crash_errors(self):\n        \"\"\"run_crash() on various error conditions\"\"\"\n        # crash report with invalid Package name\n        r = apport.Report()\n        r[\"ExecutablePath\"] = \"/bin/bash\"\n        r[\"Package\"] = \"foobarbaz\"\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertRaises(SystemExit, self.ui.run_crash, report_file)\n\n        self.assertEqual(self.ui.msg_title, _(\"Invalid problem report\"))\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n    def test_run_crash_uninstalled(self):\n        \"\"\"run_crash() on reports with subsequently uninstalled packages\"\"\"\n        # program got uninstalled between crash and report\n        r = self._gen_test_crash()\n        r[\"ExecutablePath\"] = \"/bin/nonexisting\"\n        r[\"Package\"] = \"bash\"\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n\n        self.assertEqual(self.ui.msg_title, _(\"Problem in bash\"))\n        self.assertIn(\"not installed any more\", self.ui.msg_text)\n\n        # interpreted program got uninstalled between crash and report\n        r = apport.Report()\n        r[\"ExecutablePath\"] = \"/bin/nonexisting\"\n        r[\"InterpreterPath\"] = \"/usr/bin/python\"\n        r[\n            \"Traceback\"\n        ] = \"ZeroDivisionError: integer division or modulo by zero\"\n\n        self.ui.run_crash(report_file)\n\n        self.assertEqual(self.ui.msg_title, _(\"Problem in bash\"))\n        self.assertIn(\"not installed any more\", self.ui.msg_text)\n\n        # interpreter got uninstalled between crash and report\n        r = apport.Report()\n        r[\"ExecutablePath\"] = \"/bin/sh\"\n        r[\"InterpreterPath\"] = \"/usr/bin/nonexisting\"\n        r[\n            \"Traceback\"\n        ] = \"ZeroDivisionError: integer division or modulo by zero\"\n\n        self.ui.run_crash(report_file)\n\n        self.assertEqual(self.ui.msg_title, _(\"Problem in bash\"))\n        self.assertIn(\"not installed any more\", self.ui.msg_text)\n\n    def test_run_crash_updated_binary(self):\n        \"\"\"run_crash() on binary that got updated in the meantime\"\"\"\n        r = self._gen_test_crash()\n        r[\"ExecutableTimestamp\"] = str(int(r[\"ExecutableTimestamp\"]) - 10)\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n\n        self.assertNotIn(\"ExecutableTimestamp\", self.ui.report)\n        self.assertIn(\n            self.ui.report[\"ExecutablePath\"],\n            self.ui.msg_text,\n            \"%s: %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n        self.assertIn(\n            \"changed\",\n            self.ui.msg_text,\n            \"%s: %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n        self.assertEqual(self.ui.msg_severity, \"info\")\n\n    def test_run_crash_package(self):\n        \"\"\"run_crash() for a package error\"\"\"\n        # generate crash report\n        r = apport.Report(\"Package\")\n        r[\"Package\"] = \"bash\"\n        r[\"SourcePackage\"] = \"bash\"\n        r[\"ErrorMessage\"] = \"It broke\"\n        r[\"VarLogPackagerlog\"] = \"foo\\nbar\"\n        r.add_os_info()\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n\n        # cancel crash notification dialog\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action()\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertEqual(self.ui.ic_progress_pulses, 0)\n        self.assertTrue(self.ui.present_details_shown)\n\n        # report in crash notification dialog, send report\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://bash.bugs.example.com/%i\" % self.ui.crashdb.latest_id(),\n        )\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertIn(\"SourcePackage\", self.ui.report)\n        self.assertIn(\"Package\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Package\")\n\n        # verify that additional information has been collected\n        self.assertIn(\"Architecture\", self.ui.report)\n        self.assertIn(\"DistroRelease\", self.ui.report)\n        self.assertIn(\"Uname\", self.ui.report)\n\n    def test_run_crash_kernel(self):\n        \"\"\"run_crash() for a kernel error\"\"\"\n        package = apport.packaging.get_kernel_package()\n        try:\n            src_pkg = apport.packaging.get_source(package)\n        except ValueError:\n            # Kernel package not installed (e.g. in container)\n            src_pkg = \"linux\"\n\n        # set up hook\n        with open(\n            os.path.join(self.hookdir, f\"source_{src_pkg}.py\"),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as hook:\n            hook.write(\n                textwrap.dedent(\n                    \"\"\"\\\n                    def add_info(report, ui):\n                        report['KernelDebug'] = 'LotsMoreInfo'\n                    \"\"\"\n                )\n            )\n\n        # generate crash report\n        r = apport.Report(\"KernelCrash\")\n        r[\"Package\"] = package\n        r[\"SourcePackage\"] = src_pkg\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n\n        # cancel crash notification dialog\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action()\n        self.ui.run_crash(report_file)\n        self.assertEqual(\n            self.ui.msg_severity,\n            None,\n            \"error: %s - %s\" % (self.ui.msg_title, self.ui.msg_text),\n        )\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertEqual(self.ui.ic_progress_pulses, 0)\n        self.assertTrue(self.ui.present_details_shown)\n\n        # report in crash notification dialog, send report\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(\n            self.ui.msg_severity,\n            None,\n            str(self.ui.msg_title) + \" \" + str(self.ui.msg_text),\n        )\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://%s.bugs.example.com/%i\"\n            % (src_pkg, self.ui.crashdb.latest_id()),\n        )\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertIn(\"SourcePackage\", self.ui.report)\n        # did we run the hooks properly?\n        self.assertIn(\"KernelDebug\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"KernelCrash\")\n\n    def test_run_crash_anonymity(self):\n        \"\"\"run_crash() anonymization\"\"\"\n        r = self._gen_test_crash()\n        utf8_val = (\n            b\"\\xc3\\xa4 \" + os.uname()[1].encode(\"UTF-8\") + b\" \\xe2\\x99\\xa5 \"\n        )\n        r[\"ProcUnicodeValue\"] = utf8_val.decode(\"UTF-8\")\n        r[\"ProcByteArrayValue\"] = utf8_val\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n\n        self.assertNotIn(\"ProcCwd\", self.ui.report)\n\n        dump = io.BytesIO()\n        # this contains more or less random characters which might contain the\n        # user name\n        del self.ui.report[\"CoreDump\"]\n        self.ui.report.write(dump)\n        report = dump.getvalue().decode(\"UTF-8\")\n\n        p = pwd.getpwuid(os.getuid())\n        bad_strings = [os.uname()[1], p[0], p[4], p[5], os.getcwd()]\n\n        for s in bad_strings:\n            self.assertNotIn(\n                s,\n                report,\n                \"dump contains sensitive string: %s:\\n%s\" % (s, report),\n            )\n\n    def test_run_crash_anonymity_order(self):\n        \"\"\"run_crash() anonymization runs after info and duplicate\n        collection\"\"\"\n        # pretend the hostname looks like a hex number which matches\n        # the stack trace address\n        uname = os.uname()\n        uname = (uname[0], \"0xDEADBEEF\", uname[2], uname[3], uname[4])\n        orig_uname = os.uname\n        orig_add_gdb_info = apport.report.Report.add_gdb_info\n        os.uname = lambda: uname\n\n        def fake_add_gdb_info(self):\n            self[\"Stacktrace\"] = textwrap.dedent(\n                \"\"\"\\\n                #0  0xDEADBEEF in h (p=0x0) at crash.c:25\n                #1  0x10000042 in g (x=1, y=42) at crash.c:26\n                #1  0x10000001 in main () at crash.c:40\n                \"\"\"\n            )\n            self[\"ProcMaps\"] = (\n                \"10000000-DEADBEF0 r-xp 00000000 08:02 100000\"\n                \"           /bin/crash\\n\"\n            )\n            assert self.crash_signature_addresses() is not None\n\n        try:\n            r = self._gen_test_crash()\n            apport.report.Report.add_gdb_info = fake_add_gdb_info\n            r[\"ProcAuxInfo\"] = \"my 0xDEADBEEF\"\n            report_file = os.path.join(\n                apport.fileutils.report_dir, \"test.crash\"\n            )\n            with open(report_file, \"wb\") as f:\n                r.write(f)\n\n            # if this runs anonymization before the duplicate signature, then\n            # this will fail, as 0xDEADhostname is an invalid address\n            self.ui = UserInterfaceMock()\n            self.ui.present_details_response = apport.ui.Action(report=True)\n            self.ui.run_crash(report_file)\n            self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n\n            self.assertEqual(self.ui.report[\"ProcAuxInfo\"], \"my hostname\")\n            # after anonymization this should mess up Stacktrace; this mostly\n            # confirms that our test logic works\n            self.assertEqual(self.ui.report.crash_signature_addresses(), None)\n        finally:\n            os.uname = orig_uname\n            apport.report.Report.add_gdb_info = orig_add_gdb_info\n\n    def test_run_crash_anonymity_substring(self):\n        \"\"\"run_crash() anonymization only catches whole words\"\"\"\n        # pretend the hostname is \"ed\", a substring of e. g. \"crashed\"\n        uname = os.uname()\n        uname = (uname[0], \"ed\", uname[2], uname[3], uname[4])\n        orig_uname = os.uname\n        os.uname = lambda: uname\n\n        try:\n            r = self._gen_test_crash()\n            r[\"ProcInfo1\"] = \"my ed\"\n            r[\"ProcInfo2\"] = '\"ed.localnet\"'\n            r[\"ProcInfo3\"] = \"education\"\n            report_file = os.path.join(\n                apport.fileutils.report_dir, \"test.crash\"\n            )\n            with open(report_file, \"wb\") as f:\n                r.write(f)\n\n            self.ui = UserInterfaceMock()\n            self.ui.present_details_response = apport.ui.Action(report=True)\n            self.ui.run_crash(report_file)\n            self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n\n            self.assertTrue(\n                self.ui.report[\"Title\"].startswith(\n                    f\"{os.path.basename(self.TEST_EXECUTABLE)}\"\n                    f\" crashed with SIGSEGV\"\n                ),\n                self.ui.report[\"Title\"],\n            )\n            self.assertEqual(self.ui.report[\"ProcInfo1\"], \"my hostname\")\n            self.assertEqual(\n                self.ui.report[\"ProcInfo2\"], '\"hostname.localnet\"'\n            )\n            self.assertEqual(self.ui.report[\"ProcInfo3\"], \"education\")\n        finally:\n            os.uname = orig_uname\n\n    def test_run_crash_anonymity_escaping(self):\n        \"\"\"run_crash() anonymization escapes special chars\"\"\"\n        # inject GECOS field with regexp control chars\n        orig_getpwuid = pwd.getpwuid\n        orig_getuid = os.getuid\n\n        def fake_getpwuid(_unused_uid):\n            r = list(orig_getpwuid(orig_getuid()))\n            r[4] = \"Joe (Hacker,+1 234,,\"\n            return r\n\n        pwd.getpwuid = fake_getpwuid\n        os.getuid = lambda: 1234\n\n        try:\n            r = self._gen_test_crash()\n            r[\"ProcInfo1\"] = \"That was Joe (Hacker and friends\"\n            r[\"ProcInfo2\"] = \"Call +1 234!\"\n            r[\"ProcInfo3\"] = \"(Hacker should stay\"\n            report_file = os.path.join(\n                apport.fileutils.report_dir, \"test.crash\"\n            )\n            with open(report_file, \"wb\") as f:\n                r.write(f)\n\n            self.ui = UserInterfaceMock()\n            self.ui.present_details_response = apport.ui.Action(report=True)\n            self.ui.run_crash(report_file)\n            self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n\n            self.assertEqual(\n                self.ui.report[\"ProcInfo1\"], \"That was User Name and friends\"\n            )\n            self.assertEqual(self.ui.report[\"ProcInfo2\"], \"Call User Name!\")\n            self.assertEqual(\n                self.ui.report[\"ProcInfo3\"], \"(Hacker should stay\"\n            )\n        finally:\n            pwd.getpwuid = orig_getpwuid\n            os.getuid = orig_getuid\n\n    def test_run_crash_known(self):\n        \"\"\"run_crash() for already known problem\"\"\"\n        r = self._gen_test_crash()\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        # known without URL\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui.crashdb.known = lambda r: True\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.report[\"_KnownReport\"], \"1\")\n        self.assertEqual(self.ui.msg_severity, \"info\")\n        self.assertEqual(self.ui.opened_url, None)\n\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        # known with URL\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui.crashdb.known = lambda r: \"http://myreport/1\"\n        self.ui.run_crash(report_file)\n        self.assertEqual(self.ui.report[\"_KnownReport\"], \"http://myreport/1\")\n        self.assertEqual(self.ui.msg_severity, \"info\")\n        self.assertEqual(self.ui.opened_url, \"http://myreport/1\")\n\n    def test_run_crash_private_keys(self):\n        \"\"\"Do not upload private keys to crash DB.\"\"\"\n        r = self._gen_test_crash()\n        r[\"_Temp\"] = \"boring\"\n\n        # write crash report\n        report_file = os.path.join(apport.fileutils.report_dir, \"test.crash\")\n\n        # report\n        with open(report_file, \"wb\") as f:\n            r.write(f)\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crash(report_file)\n        self.assertEqual(\n            self.ui.opened_url,\n            \"http://coreutils.bugs.example.com/%i\"\n            % self.ui.crashdb.latest_id(),\n        )\n        # internal key should not be uploaded to the crash db\n        r = self.ui.crashdb.download(self.ui.crashdb.latest_id())\n        self.assertIn(\"SourcePackage\", r)\n        self.assertNotIn(\"_Temp\", r)\n\n    @unittest.skipIf(logind_session is None, \"not running in logind session\")\n    def test_run_crash_older_session(self):\n        \"\"\"run_crashes() skips crashes from older logind sessions\"\"\"\n        latest_id_before = self.ui.crashdb.latest_id()\n\n        # current crash report\n        r = self._gen_test_crash()\n        cur_date = r[\"Date\"]\n        r[\"Tag\"] = \"cur\"\n        self.assertEqual(r[\"_LogindSession\"], logind_session[0])\n        with open(\n            os.path.join(apport.fileutils.report_dir, \"cur.crash\"), \"wb\"\n        ) as f:\n            r.write(f)\n\n        # old crash report\n        r[\"Date\"] = time.asctime(time.localtime(logind_session[1] - 1))\n        r[\"Tag\"] = \"old\"\n        with open(\n            os.path.join(apport.fileutils.report_dir, \"old.crash\"), \"wb\"\n        ) as f:\n            r.write(f)\n\n        # old crash report without session\n        del r[\"_LogindSession\"]\n        r[\"Tag\"] = \"oldnosession\"\n        with open(\n            os.path.join(apport.fileutils.report_dir, \"oldnosession.crash\"),\n            \"wb\",\n        ) as f:\n            r.write(f)\n        del r\n\n        self.ui = UserInterfaceMock()\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.run_crashes()\n\n        if os.getuid() != 0:\n            # as user: should have reported two reports only\n            self.assertEqual(self.ui.crashdb.latest_id(), latest_id_before + 2)\n            r1 = self.ui.crashdb.download(self.ui.crashdb.latest_id())\n            r2 = self.ui.crashdb.download(self.ui.crashdb.latest_id() - 1)\n            if r1[\"Tag\"] == \"cur\":\n                self.assertEqual(r1[\"Date\"], cur_date)\n                self.assertEqual(r2[\"Tag\"], \"oldnosession\")\n            else:\n                self.assertEqual(r2[\"Date\"], cur_date)\n                self.assertEqual(r1[\"Tag\"], \"oldnosession\")\n                self.assertEqual(r2[\"Tag\"], \"cur\")\n        else:\n            # as root: should have reported all reports\n            self.assertEqual(self.ui.crashdb.latest_id(), latest_id_before + 3)\n\n    def test_run_update_report_nonexisting_package_from_bug(self):\n        \"\"\"run_update_report() on a nonexisting package (from bug)\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-u\", \"1\"])\n\n        self.assertEqual(self.ui.run_argv(), False)\n        self.assertIn(\"No additional information collected.\", self.ui.msg_text)\n        self.assertFalse(self.ui.present_details_shown)\n\n    def test_run_update_report_nonexisting_package_cli(self):\n        \"\"\"run_update_report() on a nonexisting package (CLI argument)\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-u\", \"1\", \"-p\", \"bar\"])\n\n        self.assertEqual(self.ui.run_argv(), False)\n        self.assertIn(\"No additional information collected.\", self.ui.msg_text)\n        self.assertFalse(self.ui.present_details_shown)\n\n    def test_run_update_report_existing_package_from_bug(self):\n        \"\"\"run_update_report() on an existing package (from bug)\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-u\", \"1\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.ui.crashdb.download(1)[\"SourcePackage\"] = \"bash\"\n        self.ui.crashdb.download(1)[\"Package\"] = \"bash\"\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash \"))\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n\n    def test_run_update_report_existing_package_cli_tags(self):\n        \"\"\"run_update_report() on an existing package (CLI argument)\n        with extra tag\"\"\"\n        argv = [\"ui-test\", \"-u\", \"1\", \"-p\", \"bash\", \"--tag\", \"foo\"]\n        self.ui = UserInterfaceMock(argv)\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash \"))\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertIn(\"foo\", self.ui.report.get_tags())\n\n    def test_run_update_report_existing_package_cli_cmdname(self):\n        \"\"\"run_update_report() on an existing package (-collect program)\"\"\"\n        self.ui = UserInterfaceMock([\"apport-collect\", \"-p\", \"bash\", \"1\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash \"))\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n\n    def test_run_update_report_noninstalled_but_hook(self):\n        \"\"\"run_update_report() on an uninstalled package with a source hook\"\"\"\n        self.ui = UserInterfaceMock([\"ui-test\", \"-u\", \"1\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        with open(\n            os.path.join(self.hookdir, \"source_foo.py\"), \"w\", encoding=\"utf-8\"\n        ) as f:\n            f.write('def add_info(r, ui):\\n  r[\"MachineType\"]=\"Laptop\"\\n')\n\n        self.assertEqual(self.ui.run_argv(), True, self.ui.report)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertEqual(self.ui.report[\"Package\"], \"foo (not installed)\")\n        self.assertEqual(self.ui.report[\"MachineType\"], \"Laptop\")\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n\n    def test_run_update_report_different_binary_source(self):\n        \"\"\"run_update_report() on a source package which does not have\n        a binary of the same name\"\"\"\n        # this test assumes that the source package name is not an\n        # installed binary package\n        source_pkg = \"shadow\"\n        self.assertRaises(ValueError, apport.packaging.get_version, source_pkg)\n\n        argv = [\"ui-test\", \"-p\", source_pkg, \"-u\", \"1\"]\n        self.ui = UserInterfaceMock(argv)\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        with open(\n            os.path.join(self.hookdir, \"source_%s.py\" % source_pkg),\n            \"w\",\n            encoding=\"utf-8\",\n        ) as f:\n            f.write('def add_info(r, ui):\\n  r[\"MachineType\"]=\"Laptop\"\\n')\n\n        self.assertEqual(self.ui.run_argv(), True, self.ui.report)\n        self.assertEqual(self.ui.msg_severity, None, self.ui.msg_text)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertEqual(\n            self.ui.report[\"Package\"], \"%s (not installed)\" % source_pkg\n        )\n        self.assertEqual(self.ui.report[\"MachineType\"], \"Laptop\")\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n\n    def _run_hook(self, code):\n        with open(\n            os.path.join(self.hookdir, \"coreutils.py\"), \"w\", encoding=\"utf-8\"\n        ) as hook:\n            hook.write(\n                \"def add_info(report, ui):\\n%s\\n\"\n                % \"\\n\".join([\"    \" + line for line in code.splitlines()])\n            )\n        self.ui.args.package = \"coreutils\"\n        self.ui.run_report_bug()\n\n    def test_interactive_hooks_information(self):\n        \"\"\"Interactive hooks: HookUI.information()\"\"\"\n        self.ui.present_details_response = apport.ui.Action()\n        self._run_hook(\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                ui.information('InfoText')\n                report['end'] = '1'\n                \"\"\"\n            )\n        )\n        self.assertEqual(self.ui.report[\"begin\"], \"1\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n        self.assertEqual(self.ui.msg_text, \"InfoText\")\n\n    def test_interactive_hooks_yesno(self):\n        \"\"\"Interactive hooks: HookUI.yesno()\"\"\"\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.question_yesno_response = True\n        self._run_hook(\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                report['answer'] = str(ui.yesno('YesNo?'))\n                report['end'] = '1'\n                \"\"\"\n            )\n        )\n        self.assertEqual(self.ui.report[\"begin\"], \"1\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n        self.assertEqual(self.ui.msg_text, \"YesNo?\")\n        self.assertEqual(self.ui.report[\"answer\"], \"True\")\n\n        self.ui.question_yesno_response = False\n        self.ui.run_report_bug()\n        self.assertEqual(self.ui.report[\"answer\"], \"False\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n\n        self.ui.question_yesno_response = None\n        self.ui.run_report_bug()\n        self.assertEqual(self.ui.report[\"answer\"], \"None\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n\n    def test_interactive_hooks_file(self):\n        \"\"\"Interactive hooks: HookUI.file()\"\"\"\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.question_file_response = \"/etc/fstab\"\n        self._run_hook(\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                report['answer'] = str(ui.file('YourFile?'))\n                report['end'] = '1'\n                \"\"\"\n            )\n        )\n        self.assertEqual(self.ui.report[\"begin\"], \"1\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n        self.assertEqual(self.ui.msg_text, \"YourFile?\")\n        self.assertEqual(self.ui.report[\"answer\"], \"/etc/fstab\")\n\n        self.ui.question_file_response = None\n        self.ui.run_report_bug()\n        self.assertEqual(self.ui.report[\"answer\"], \"None\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n\n    def test_interactive_hooks_choices(self):\n        \"\"\"Interactive hooks: HookUI.choice()\"\"\"\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.question_choice_response = [1]\n        self._run_hook(\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                answer = ui.choice('YourChoice?', ['foo', 'bar'])\n                report['answer'] = str(answer)\n                report['end'] = '1'\n                \"\"\"\n            )\n        )\n        self.assertEqual(self.ui.report[\"begin\"], \"1\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n        self.assertEqual(self.ui.msg_text, \"YourChoice?\")\n        self.assertEqual(self.ui.report[\"answer\"], \"[1]\")\n\n        self.ui.question_choice_response = None\n        self.ui.run_report_bug()\n        self.assertEqual(self.ui.report[\"answer\"], \"None\")\n        self.assertEqual(self.ui.report[\"end\"], \"1\")\n\n    def test_hooks_choices_db_no_accept(self):\n        \"\"\"HookUI.choice() but DB does not accept report.\"\"\"\n        self.ui.crashdb.accepts = lambda r: False\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.question_choice_response = [1]\n        self._run_hook(\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                answer = ui.choice('YourChoice?', ['foo', 'bar'])\n                report['answer'] = str(answer)\n                report['end'] = '1'\n                \"\"\"\n            )\n        )\n        self.assertEqual(self.ui.report[\"answer\"], \"None\")\n\n    def test_interactive_hooks_cancel(self):\n        \"\"\"Interactive hooks: user cancels\"\"\"\n        self.assertRaises(\n            SystemExit,\n            self._run_hook,\n            textwrap.dedent(\n                \"\"\"\\\n                report['begin'] = '1'\n                raise StopIteration\n                report['end'] = '1'\n                \"\"\"\n            ),\n        )\n\n    @unittest.mock.patch(\n        \"apport.hookutils.attach_conffiles\", unittest.mock.MagicMock()\n    )\n    @unittest.mock.patch(\"sys.stderr\", new_callable=io.StringIO)\n    def test_run_symptom(self, stderr_mock):\n        \"\"\"run_symptom()\"\"\"\n        # unknown symptom\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"foobar\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertIn('foobar\" is not known', self.ui.msg_text)\n        self.assertEqual(self.ui.msg_severity, \"error\")\n\n        # does not determine package\n        self._write_symptom_script(\n            \"nopkg.py\", \"def run(report, ui):\\n    pass\\n\"\n        )\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"nopkg\"])\n        stderr_mock.truncate(0)\n        self.assertRaises(SystemExit, self.ui.run_argv)\n        err = stderr_mock.getvalue()\n        self.assertIn(\"did not determine the affected package\", err)\n\n        # does not define run()\n        self._write_symptom_script(\n            \"norun.py\", \"def something(x, y):\\n    return 1\\n\"\n        )\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"norun\"])\n        stderr_mock.truncate(0)\n        self.assertRaises(SystemExit, self.ui.run_argv)\n        err = stderr_mock.getvalue()\n        self.assertIn(\"norun.py crashed:\", err)\n\n        # crashing script\n        self._write_symptom_script(\n            \"crash.py\", \"def run(report, ui):\\n    return 1/0\\n\"\n        )\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"crash\"])\n        stderr_mock.truncate(0)\n        self.assertRaises(SystemExit, self.ui.run_argv)\n        err = stderr_mock.getvalue()\n        self.assertIn(\"crash.py crashed:\", err)\n        self.assertIn(\"ZeroDivisionError:\", err)\n\n        # working noninteractive script\n        self._write_symptom_script(\n            \"itching.py\",\n            \"def run(report, ui):\\n\"\n            '  report[\"itch\"] = \"scratch\"\\n'\n            '  return \"bash\"\\n',\n        )\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"itching\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_text, None)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertEqual(self.ui.report[\"itch\"], \"scratch\")\n        self.assertIn(\"DistroRelease\", self.ui.report)\n        self.assertEqual(self.ui.report[\"SourcePackage\"], \"bash\")\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash \"))\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Bug\")\n\n        # working noninteractive script with extra tag\n        argv = [\"ui-test\", \"--tag\", \"foo\", \"-s\", \"itching\"]\n        self.ui = UserInterfaceMock(argv)\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_text, None)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        self.assertEqual(self.ui.report[\"itch\"], \"scratch\")\n        self.assertIn(\"foo\", self.ui.report.get_tags())\n\n        # working interactive script\n        self._write_symptom_script(\n            \"itching.py\",\n            textwrap.dedent(\n                \"\"\"\\\n                def run(report, ui):\n                    report['itch'] = 'slap'\n                    report['q'] = str(ui.yesno('do you?'))\n                    return 'bash'\n                \"\"\"\n            ),\n        )\n        self.ui = UserInterfaceMock([\"ui-test\", \"-s\", \"itching\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.ui.question_yesno_response = True\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertTrue(self.ui.present_details_shown)\n        self.assertEqual(self.ui.msg_text, \"do you?\")\n\n        self.assertEqual(self.ui.report[\"itch\"], \"slap\")\n        self.assertIn(\"DistroRelease\", self.ui.report)\n        self.assertEqual(self.ui.report[\"SourcePackage\"], \"bash\")\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash \"))\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Bug\")\n        self.assertEqual(self.ui.report[\"q\"], \"True\")\n\n    def test_run_report_bug_list_symptoms(self):\n        \"\"\"run_report_bug() without specifying arguments and available\n        symptoms\"\"\"\n        self._write_symptom_script(\n            \"foo.py\",\n            textwrap.dedent(\n                \"\"\"\\\n                description = 'foo does not work'\n                def run(report, ui):\n                    return 'bash'\n                \"\"\"\n            ),\n        )\n        self._write_symptom_script(\n            \"bar.py\", 'def run(report, ui):\\n  return \"coreutils\"\\n'\n        )\n\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\"])\n        self.ui.present_details_response = apport.ui.Action(report=True)\n\n        self.ui.question_choice_response = None\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertIn(\"kind of problem\", self.ui.msg_text)\n        self.assertEqual(\n            set(self.ui.msg_choices),\n            set([\"bar\", \"foo does not work\", \"Other problem\"]),\n        )\n\n        # cancelled\n        self.assertEqual(self.ui.ic_progress_pulses, 0)\n        self.assertEqual(self.ui.report, None)\n        self.assertFalse(self.ui.present_details_shown)\n\n        # now, choose foo -> bash report\n        self.ui.question_choice_response = [\n            self.ui.msg_choices.index(\"foo does not work\")\n        ]\n        self.assertEqual(self.ui.run_argv(), True)\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertTrue(self.ui.ic_progress_pulses > 0)\n        self.assertTrue(self.ui.present_details_shown)\n        self.assertTrue(self.ui.report[\"Package\"].startswith(\"bash\"))\n\n    @unittest.mock.patch(\"sys.stderr\", new_callable=io.StringIO)\n    def test_parse_argv_single_arg(self, stderr_mock):\n        \"\"\"parse_args() option inference for a single argument\"\"\"\n\n        def _chk(program_name, arg, expected_opts):\n            argv = [program_name]\n            if arg:\n                argv.append(arg)\n            ui = apport.ui.UserInterface(argv)\n            expected_opts[\"version\"] = False\n            self.assertEqual(ui.args.__dict__, expected_opts)\n            self.assertEqual(stderr_mock.getvalue(), \"\")\n\n        # no arguments -> show pending crashes\n        _chk(\n            \"apport-gtk\",\n            None,\n            {\n                \"filebug\": False,\n                \"package\": None,\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n        # updating report not allowed without args\n        self.assertRaises(SystemExit, _chk, \"apport-collect\", None, {})\n        self.assertIn(\n            \"error: the following arguments are required: report_number\",\n            stderr_mock.getvalue(),\n        )\n        stderr_mock.truncate(0)\n\n        # package\n        _chk(\n            \"apport-kde\",\n            \"coreutils\",\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # symptom is preferred over package\n        self._write_symptom_script(\n            \"coreutils.py\",\n            textwrap.dedent(\n                \"\"\"\\\n                description = 'foo does not work'\n                def run(report, ui):\n                    return 'bash'\n                \"\"\"\n            ),\n        )\n        _chk(\n            \"apport-cli\",\n            \"coreutils\",\n            {\n                \"filebug\": True,\n                \"package\": None,\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": \"coreutils\",\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # PID\n        _chk(\n            \"apport-cli\",\n            \"1234\",\n            {\n                \"filebug\": True,\n                \"package\": None,\n                \"pid\": \"1234\",\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # .crash/.apport files; check correct handling of spaces\n        for suffix in (\".crash\", \".apport\"):\n            _chk(\n                \"apport-cli\",\n                \"/tmp/f oo\" + suffix,\n                {\n                    \"filebug\": False,\n                    \"package\": None,\n                    \"pid\": None,\n                    \"crash_file\": \"/tmp/f oo\" + suffix,\n                    \"symptom\": None,\n                    \"update_report\": None,\n                    \"save\": None,\n                    \"window\": False,\n                    \"tags\": [],\n                    \"hanging\": False,\n                },\n            )\n\n        # executable\n        _chk(\n            \"apport-cli\",\n            \"/usr/bin/tail\",\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # update existing report\n        _chk(\n            \"apport-collect\",\n            \"1234\",\n            {\n                \"filebug\": False,\n                \"package\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": 1234,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n        _chk(\n            \"apport-update-bug\",\n            \"1234\",\n            {\n                \"filebug\": False,\n                \"package\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": 1234,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n    @unittest.mock.patch(\"sys.stderr\", new_callable=io.StringIO)\n    def test_parse_argv_apport_bug(self, stderr_mock):\n        \"\"\"parse_args() option inference when invoked as *-bug\"\"\"\n\n        def _chk(args, expected_opts):\n            ui = apport.ui.UserInterface([\"apport-bug\"] + args)\n            expected_opts[\"version\"] = False\n            self.assertEqual(ui.args.__dict__, expected_opts)\n            self.assertEqual(stderr_mock.getvalue(), \"\")\n\n        #\n        # no arguments: default to 'ask for symptom' bug mode\n        #\n        _chk(\n            [],\n            {\n                \"filebug\": True,\n                \"package\": None,\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        #\n        # single arguments\n        #\n\n        # package\n        _chk(\n            [\"coreutils\"],\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # symptom (preferred over package)\n        self._write_symptom_script(\n            \"coreutils.py\",\n            textwrap.dedent(\n                \"\"\"\\\n                description = 'foo does not work'\n                def run(report, ui):\n                    return 'bash'\n                \"\"\"\n            ),\n        )\n        _chk(\n            [\"coreutils\"],\n            {\n                \"filebug\": True,\n                \"package\": None,\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": \"coreutils\",\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n        os.unlink(os.path.join(apport.ui.symptom_script_dir, \"coreutils.py\"))\n\n        # PID\n        _chk(\n            [\"1234\"],\n            {\n                \"filebug\": True,\n                \"package\": None,\n                \"pid\": \"1234\",\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # .crash/.apport files; check correct handling of spaces\n        for suffix in (\".crash\", \".apport\"):\n            _chk(\n                [\"/tmp/f oo\" + suffix],\n                {\n                    \"filebug\": False,\n                    \"package\": None,\n                    \"pid\": None,\n                    \"crash_file\": \"/tmp/f oo\" + suffix,\n                    \"symptom\": None,\n                    \"update_report\": None,\n                    \"save\": None,\n                    \"window\": False,\n                    \"tags\": [],\n                    \"hanging\": False,\n                },\n            )\n\n        # executable name\n        _chk(\n            [\"/usr/bin/tail\"],\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        #\n        # supported options\n        #\n\n        # --save\n        _chk(\n            [\"--save\", \"foo.apport\", \"coreutils\"],\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": \"foo.apport\",\n                \"window\": False,\n                \"tags\": [],\n                \"hanging\": False,\n            },\n        )\n\n        # --tag\n        _chk(\n            [\"--tag\", \"foo\", \"coreutils\"],\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [\"foo\"],\n                \"hanging\": False,\n            },\n        )\n        _chk(\n            [\"--tag\", \"foo\", \"--tag\", \"bar\", \"coreutils\"],\n            {\n                \"filebug\": True,\n                \"package\": \"coreutils\",\n                \"pid\": None,\n                \"crash_file\": None,\n                \"symptom\": None,\n                \"update_report\": None,\n                \"save\": None,\n                \"window\": False,\n                \"tags\": [\"foo\", \"bar\"],\n                \"hanging\": False,\n            },\n        )\n\n        # mutually exclusive options\n        self.assertRaises(\n            SystemExit, _chk, [\"-c\", \"/tmp/foo.report\", \"-u\", \"1234\"], {}\n        )\n\n    def test_can_examine_locally_crash(self):\n        \"\"\"can_examine_locally() for a crash report\"\"\"\n        self.ui.load_report(self.report_file.name)\n\n        orig_path = os.environ[\"PATH\"]\n        orig_fn = self.ui.ui_has_terminal\n        try:\n            self.ui.ui_has_terminal = lambda command: True\n            os.environ[\"PATH\"] = \"\"\n            self.assertEqual(self.ui.can_examine_locally(), False)\n\n            src_bindir = os.path.join(\n                os.path.dirname(os.path.dirname(os.path.realpath(__file__))),\n                \"bin\",\n            )\n            # this will only work for running the tests in the source tree\n            if os.access(os.path.join(src_bindir, \"apport-retrace\"), os.X_OK):\n                os.environ[\"PATH\"] += src_bindir + \":\" + orig_path\n                self.assertEqual(self.ui.can_examine_locally(), True)\n            else:\n                # if we run tests in installed system, we just check that\n                # it doesn't crash\n                self.assertIn(self.ui.can_examine_locally(), [False, True])\n\n            self.ui.ui_has_terminal = lambda command: False\n            self.assertEqual(self.ui.can_examine_locally(), False)\n\n            # does not crash on NotImplementedError\n            self.ui.ui_has_terminal = orig_fn\n            self.assertEqual(self.ui.can_examine_locally(), False)\n\n        finally:\n            os.environ[\"PATH\"] = orig_path\n            self.ui.ui_has_terminal = orig_fn\n\n    def test_can_examine_locally_nocrash(self):\n        \"\"\"can_examine_locally() for a non-crash report\"\"\"\n        self.ui.load_report(self.report_file.name)\n        del self.ui.report[\"CoreDump\"]\n\n        orig_fn = self.ui.ui_has_terminal\n        try:\n            self.ui.ui_has_terminal = lambda command: True\n            self.assertEqual(self.ui.can_examine_locally(), False)\n        finally:\n            self.ui.ui_has_terminal = orig_fn\n\n    def test_db_no_accept(self):\n        \"\"\"Crash database does not accept report.\"\"\"\n        # FIXME: This behaviour is not really correct, but necessary as long as\n        # we only support a single crashdb and have whoopsie hardcoded\n        # (see LP#957177)\n\n        latest_id_before = self.ui.crashdb.latest_id()\n\n        self.ui = UserInterfaceMock([\"ui-test\", \"-f\", \"-p\", \"bash\"])\n\n        # Pretend it does not accept report\n        self.ui.crashdb.accepts = lambda r: False\n        self.ui.present_details_response = apport.ui.Action(report=True)\n        self.assertEqual(self.ui.run_argv(), True)\n\n        self.assertEqual(self.ui.msg_severity, None)\n        self.assertEqual(self.ui.msg_title, None)\n        self.assertTrue(self.ui.present_details_shown)\n\n        # data was collected for whoopsie\n        self.assertEqual(self.ui.report[\"SourcePackage\"], \"bash\")\n        self.assertIn(\"Dependencies\", self.ui.report)\n        self.assertIn(\"ProcEnviron\", self.ui.report)\n        self.assertEqual(self.ui.report[\"ProblemType\"], \"Bug\")\n\n        # no upload happend\n        self.assertEqual(self.ui.opened_url, None)\n        self.assertEqual(self.ui.upload_progress_pulses, 0)\n        self.assertEqual(self.ui.crashdb.latest_id(), latest_id_before)\n\n    def test_get_desktop_entry(self):\n        \"\"\"Parsee .desktop files.\"\"\"\n        with tempfile.NamedTemporaryFile(mode=\"w+\") as desktop_file:\n            desktop_file.write(\n                textwrap.dedent(\n                    \"\"\"\\\n                    [Desktop Entry]\n                    Name=gtranslate\n                    GenericName=Translator\n                    GenericName[de]=\u00dcbersetzer\n                    Exec=gedit %U\n                    Categories=GNOME;GTK;Utility;TextEditor;\n                    \"\"\"\n                )\n            )\n            desktop_file.flush()\n\n            self.report[\"DesktopFile\"] = desktop_file.name\n            self.ui.report = self.report\n            info = self.ui.get_desktop_entry()\n\n            self.assertEqual(\n                info,\n                {\n                    \"genericname\": \"Translator\",\n                    \"categories\": \"GNOME;GTK;Utility;TextEditor;\",\n                    \"name\": \"gtranslate\",\n                    \"genericname[de]\": \"\u00dcbersetzer\",\n                    \"exec\": \"gedit %U\",\n                },\n            )\n\n    def test_get_desktop_entry_broken(self):\n        \"\"\"Parse broken .desktop files.\"\"\"\n        # duplicate key\n        with tempfile.NamedTemporaryFile(mode=\"w+\") as desktop_file:\n            desktop_file.write(\n                textwrap.dedent(\n                    \"\"\"\\\n                    [Desktop Entry]\n                    Name=gtranslate\n                    GenericName=Translator\n                    GenericName[de]=\u00dcbersetzer\n                    Exec=gedit %U\n                    Keywords=foo;bar;\n                    Categories=GNOME;GTK;Utility;TextEditor;\n                    Keywords=baz\n                    \"\"\"\n                )\n            )\n            desktop_file.flush()\n\n            self.report[\"DesktopFile\"] = desktop_file.name\n            self.ui.report = self.report\n            info = self.ui.get_desktop_entry()\n            self.assertEqual(\n                info,\n                {\n                    \"genericname\": \"Translator\",\n                    \"categories\": \"GNOME;GTK;Utility;TextEditor;\",\n                    \"name\": \"gtranslate\",\n                    \"genericname[de]\": \"\u00dcbersetzer\",\n                    \"keywords\": \"baz\",\n                    \"exec\": \"gedit %U\",\n                },\n            )\n\n            # no header\n            desktop_file.seek(0)\n            desktop_file.write(\n                textwrap.dedent(\n                    \"\"\"\\\n                    Name=gtranslate\n                    GenericName=Translator\n                    Exec=gedit %U\n                    \"\"\"\n                )\n            )\n            desktop_file.flush()\n\n            self.assertEqual(self.ui.get_desktop_entry(), None)\n\n            # syntax error\n            desktop_file.seek(0)\n            desktop_file.write(\n                textwrap.dedent(\n                    \"\"\"\\\n                    [Desktop Entry]\n                    Name gtranslate\n                    GenericName=Translator\n                    Exec=gedit %U\n                    \"\"\"\n                )\n            )\n            desktop_file.flush()\n\n            self.assertEqual(self.ui.get_desktop_entry(), None)\n\n    def test_wait_for_pid(self):\n        # fork a test process\n        with self._run_test_executable() as pid:\n            pass\n        self.ui.wait_for_pid(pid)\n\n    @unittest.mock.patch(\"os.getgid\", unittest.mock.MagicMock(return_value=0))\n    @unittest.mock.patch(\"os.getuid\", unittest.mock.MagicMock(return_value=0))\n    @unittest.mock.patch.dict(\n        \"os.environ\", {\"SUDO_UID\": str(os.getuid())}, clear=True\n    )\n    def test_run_as_real_user(self) -> None:\n        \"\"\"Test run_as_real_user() with SUDO_UID set.\"\"\"\n        pwuid = pwd.getpwuid(int(os.environ[\"SUDO_UID\"]))\n        with tempfile.TemporaryDirectory() as tmpdir:\n            # rename test program to fake gvfsd\n            gvfsd_mock = os.path.join(tmpdir, \"gvfsd\")\n            shutil.copy(self.TEST_EXECUTABLE, gvfsd_mock)\n            gvfsd_env = {\n                \"XDG_DATA_DIRS\": \"mocked XDG data dir\",\n                \"DBUS_SESSION_BUS_ADDRESS\": \"/fake/dbus/path\",\n            }\n            with self._run_test_executable(gvfsd_mock, env=gvfsd_env):\n                with unittest.mock.patch(\n                    \"subprocess.run\", side_effect=mock_run_calls_except_pgrep\n                ) as run_mock:\n                    run_as_real_user([\"/bin/true\"], get_user_env=True)\n\n        run_mock.assert_called_with(\n            [\"/bin/true\"],\n            check=False,\n            env={\n                \"DBUS_SESSION_BUS_ADDRESS\": \"/fake/dbus/path\",\n                \"XDG_DATA_DIRS\": \"mocked XDG data dir\",\n                \"HOME\": pwuid.pw_dir,\n            },\n            user=int(os.environ[\"SUDO_UID\"]),\n            group=pwuid.pw_gid,\n            extra_groups=os.getgrouplist(pwuid.pw_name, pwuid.pw_gid),\n        )\n        self.assertEqual(run_mock.call_count, 2)\n\n    @unittest.mock.patch(\"os.getgid\", unittest.mock.MagicMock(return_value=0))\n    @unittest.mock.patch(\"os.getuid\", unittest.mock.MagicMock(return_value=0))\n    @unittest.mock.patch.dict(\"os.environ\", {\"SUDO_UID\": \"1337\"}, clear=True)\n    @unittest.mock.patch(\"pwd.getpwuid\")\n    def test_run_as_real_user_no_gvfsd(\n        self, getpwuid_mock: unittest.mock.MagicMock\n    ) -> None:\n        \"\"\"Test run_as_real_user() without no gvfsd process.\"\"\"\n        getpwuid_mock.return_value = pwd.struct_passwd(\n            (\n                \"testuser\",\n                \"x\",\n                1337,\n                42,\n                \"Test user,,,\",\n                \"/home/testuser\",\n                \"/bin/bash\",\n            )\n        )\n        with unittest.mock.patch(\n            \"subprocess.run\", side_effect=mock_run_calls_except_pgrep\n        ) as run_mock:\n            run_as_real_user([\"/bin/true\"], get_user_env=True)\n\n        run_mock.assert_called_with(\n            [\"/bin/true\"],\n            check=False,\n            env={\"HOME\": \"/home/testuser\"},\n            user=1337,\n            group=42,\n            extra_groups=[42],\n        )\n        self.assertEqual(run_mock.call_count, 2)\n\n    @unittest.mock.patch.dict(\"os.environ\", {})\n    def test_run_as_real_user_no_sudo(self) -> None:\n        # pylint: disable=no-self-use\n        \"\"\"Test run_as_real_user() without sudo env variables.\"\"\"\n        with unittest.mock.patch(\n            \"subprocess.run\", side_effect=mock_run_calls_except_pgrep\n        ) as run_mock:\n            run_as_real_user([\"/bin/true\"])\n\n        run_mock.assert_called_once_with([\"/bin/true\"], check=False)\n\n    @unittest.mock.patch(\"os.getgid\", unittest.mock.MagicMock(return_value=37))\n    @unittest.mock.patch(\"os.getuid\", unittest.mock.MagicMock(return_value=37))\n    @unittest.mock.patch.dict(\"os.environ\", {\"SUDO_UID\": \"0\"})\n    def test_run_as_real_user_non_root(self) -> None:\n        # pylint: disable=no-self-use\n        \"\"\"Test run_as_real_user() as non-root and SUDO_UID set.\"\"\"\n        with unittest.mock.patch(\n            \"subprocess.run\", side_effect=mock_run_calls_except_pgrep\n        ) as run_mock:\n            run_as_real_user([\"/bin/true\"])\n\n        run_mock.assert_called_once_with([\"/bin/true\"], check=False)\n"], "filenames": ["apport/ui.py", "bin/apport-cli", "tests/integration/test_ui.py"], "buggy_code_start_loc": [122, 188, 2720], "buggy_code_end_loc": [1821, 191, 2759], "fixing_code_start_loc": [122, 188, 2720], "fixing_code_end_loc": [1828, 189, 2759], "type": "CWE-269", "message": "A privilege escalation attack was found in apport-cli 2.26.0 and earlier which is similar to CVE-2023-26604. If a system is specially configured to allow unprivileged users to run sudo apport-cli, less is configured as the pager, and the terminal size can be set: a local attacker can escalate privilege. It is extremely unlikely that a system administrator would configure sudo to allow unprivileged users to perform this class of exploit.", "other": {"cve": {"id": "CVE-2023-1326", "sourceIdentifier": "security@ubuntu.com", "published": "2023-04-13T23:15:07.180", "lastModified": "2023-04-19T19:15:24.627", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A privilege escalation attack was found in apport-cli 2.26.0 and earlier which is similar to CVE-2023-26604. If a system is specially configured to allow unprivileged users to run sudo apport-cli, less is configured as the pager, and the terminal size can be set: a local attacker can escalate privilege. It is extremely unlikely that a system administrator would configure sudo to allow unprivileged users to perform this class of exploit."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security@ubuntu.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:R/S:C/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.1, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}, {"source": "security@ubuntu.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:canonical:apport:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.26.0", "matchCriteriaId": "9C318FA9-3356-49C8-A8F8-06A20616D446"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:22.04:*:*:*:lts:*:*:*", "matchCriteriaId": "359012F1-2C63-415A-88B8-6726A87830DE"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:22.10:*:*:*:-:*:*:*", "matchCriteriaId": "47842532-D2B6-44CB-ADE2-4AC8630A4D8C"}]}]}], "references": [{"url": "https://github.com/canonical/apport/commit/e5f78cc89f1f5888b6a56b785dddcb0364c48ecb", "source": "security@ubuntu.com", "tags": ["Patch"]}, {"url": "https://ubuntu.com/security/notices/USN-6018-1", "source": "security@ubuntu.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/canonical/apport/commit/e5f78cc89f1f5888b6a56b785dddcb0364c48ecb"}}