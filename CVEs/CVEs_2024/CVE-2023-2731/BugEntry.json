{"buggy_code": ["/*\n * Copyright (c) 1988-1997 Sam Leffler\n * Copyright (c) 1991-1997 Silicon Graphics, Inc.\n * Copyright (c) 2022 Even Rouault\n *\n * Permission to use, copy, modify, distribute, and sell this software and\n * its documentation for any purpose is hereby granted without fee, provided\n * that (i) the above copyright notices and this permission notice appear in\n * all copies of the software and related documentation, and (ii) the names of\n * Sam Leffler and Silicon Graphics may not be used in any advertising or\n * publicity relating to the software without the specific, prior written\n * permission of Sam Leffler and Silicon Graphics.\n *\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n *\n * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR\n * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,\n * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF\n * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n * OF THIS SOFTWARE.\n */\n\n#include \"tiffiop.h\"\n#ifdef LZW_SUPPORT\n/*\n * TIFF Library.\n * Rev 5.0 Lempel-Ziv & Welch Compression Support\n *\n * This code is derived from the compress program whose code is\n * derived from software contributed to Berkeley by James A. Woods,\n * derived from original work by Spencer Thomas and Joseph Orost.\n *\n * The original Berkeley copyright notice appears below in its entirety.\n */\n#include \"tif_predict.h\"\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/* Select the plausible largest natural integer type for the architecture */\n#define SIZEOF_WORDTYPE SIZEOF_SIZE_T\ntypedef size_t WordType;\n\n/*\n * NB: The 5.0 spec describes a different algorithm than Aldus\n *     implements.  Specifically, Aldus does code length transitions\n *     one code earlier than should be done (for real LZW).\n *     Earlier versions of this library implemented the correct\n *     LZW algorithm, but emitted codes in a bit order opposite\n *     to the TIFF spec.  Thus, to maintain compatibility w/ Aldus\n *     we interpret MSB-LSB ordered codes to be images written w/\n *     old versions of this library, but otherwise adhere to the\n *     Aldus \"off by one\" algorithm.\n *\n * Future revisions to the TIFF spec are expected to \"clarify this issue\".\n */\n#define LZW_COMPAT /* include backwards compatibility code */\n\n#define MAXCODE(n) ((1L << (n)) - 1)\n/*\n * The TIFF spec specifies that encoded bit\n * strings range from 9 to 12 bits.\n */\n#define BITS_MIN 9  /* start with 9 bits */\n#define BITS_MAX 12 /* max of 12 bit strings */\n/* predefined codes */\n#define CODE_CLEAR 256 /* code to clear string table */\n#define CODE_EOI 257   /* end-of-information code */\n#define CODE_FIRST 258 /* first free code entry */\n#define CODE_MAX MAXCODE(BITS_MAX)\n#define HSIZE 9001L /* 91% occupancy */\n#define HSHIFT (13 - 8)\n#ifdef LZW_COMPAT\n/* NB: +1024 is for compatibility with old files */\n#define CSIZE (MAXCODE(BITS_MAX) + 1024L)\n#else\n#define CSIZE (MAXCODE(BITS_MAX) + 1L)\n#endif\n\n/*\n * State block for each open TIFF file using LZW\n * compression/decompression.  Note that the predictor\n * state block must be first in this data structure.\n */\ntypedef struct\n{\n    TIFFPredictorState predict; /* predictor super class */\n\n    unsigned short nbits;    /* # of bits/code */\n    unsigned short maxcode;  /* maximum code for lzw_nbits */\n    unsigned short free_ent; /* next free entry in hash table */\n    WordType nextdata;       /* next bits of i/o */\n    long nextbits;           /* # of valid bits in lzw_nextdata */\n\n    int rw_mode; /* preserve rw_mode from init */\n} LZWBaseState;\n\n#define lzw_nbits base.nbits\n#define lzw_maxcode base.maxcode\n#define lzw_free_ent base.free_ent\n#define lzw_nextdata base.nextdata\n#define lzw_nextbits base.nextbits\n\n/*\n * Encoding-specific state.\n */\ntypedef uint16_t hcode_t; /* codes fit in 16 bits */\ntypedef struct\n{\n    long hash;\n    hcode_t code;\n} hash_t;\n\n/*\n * Decoding-specific state.\n */\ntypedef struct code_ent\n{\n    struct code_ent *next;\n    unsigned short length; /* string len, including this token */\n    /* firstchar should be placed immediately before value in this structure */\n    unsigned char firstchar; /* first token of string */\n    unsigned char value;     /* data value */\n    bool repeated;\n} code_t;\n\ntypedef int (*decodeFunc)(TIFF *, uint8_t *, tmsize_t, uint16_t);\n\ntypedef struct\n{\n    LZWBaseState base;\n\n    /* Decoding specific data */\n    long dec_nbitsmask;     /* lzw_nbits 1 bits, right adjusted */\n    tmsize_t dec_restart;   /* restart count */\n    uint64_t dec_bitsleft;  /* available bits in raw data */\n    tmsize_t old_tif_rawcc; /* value of tif_rawcc at the end of the previous\n                               TIFLZWDecode() call */\n    decodeFunc dec_decode;  /* regular or backwards compatible */\n    code_t *dec_codep;      /* current recognized code */\n    code_t *dec_oldcodep;   /* previously recognized code */\n    code_t *dec_free_entp;  /* next free entry */\n    code_t *dec_maxcodep;   /* max available entry */\n    code_t *dec_codetab;    /* kept separate for small machines */\n    int read_error; /* whether a read error has occurred, and which should cause\n                       further reads in the same strip/tile to be aborted */\n\n    /* Encoding specific data */\n    int enc_oldcode;         /* last code encountered */\n    tmsize_t enc_checkpoint; /* point at which to clear table */\n#define CHECK_GAP 10000      /* enc_ratio check interval */\n    tmsize_t enc_ratio;      /* current compression ratio */\n    tmsize_t enc_incount;    /* (input) data bytes encoded */\n    tmsize_t enc_outcount;   /* encoded (output) bytes */\n    uint8_t *enc_rawlimit;   /* bound on tif_rawdata buffer */\n    hash_t *enc_hashtab;     /* kept separate for small machines */\n} LZWCodecState;\n\n#define LZWState(tif) ((LZWBaseState *)(tif)->tif_data)\n#define DecoderState(tif) ((LZWCodecState *)LZWState(tif))\n#define EncoderState(tif) ((LZWCodecState *)LZWState(tif))\n\nstatic int LZWDecode(TIFF *tif, uint8_t *op0, tmsize_t occ0, uint16_t s);\n#ifdef LZW_COMPAT\nstatic int LZWDecodeCompat(TIFF *tif, uint8_t *op0, tmsize_t occ0, uint16_t s);\n#endif\nstatic void cl_hash(LZWCodecState *);\n\n/*\n * LZW Decoder.\n */\n\nstatic int LZWFixupTags(TIFF *tif)\n{\n    (void)tif;\n    return (1);\n}\n\nstatic int LZWSetupDecode(TIFF *tif)\n{\n    static const char module[] = \"LZWSetupDecode\";\n    LZWCodecState *sp = DecoderState(tif);\n    int code;\n\n    if (sp == NULL)\n    {\n        /*\n         * Allocate state block so tag methods have storage to record\n         * values.\n         */\n        tif->tif_data = (uint8_t *)_TIFFmallocExt(tif, sizeof(LZWCodecState));\n        if (tif->tif_data == NULL)\n        {\n            TIFFErrorExtR(tif, module, \"No space for LZW state block\");\n            return (0);\n        }\n\n        sp = DecoderState(tif);\n        sp->dec_codetab = NULL;\n        sp->dec_decode = NULL;\n\n        /*\n         * Setup predictor setup.\n         */\n        (void)TIFFPredictorInit(tif);\n    }\n\n    if (sp->dec_codetab == NULL)\n    {\n        sp->dec_codetab = (code_t *)_TIFFmallocExt(tif, CSIZE * sizeof(code_t));\n        if (sp->dec_codetab == NULL)\n        {\n            TIFFErrorExtR(tif, module, \"No space for LZW code table\");\n            return (0);\n        }\n        /*\n         * Pre-load the table.\n         */\n        code = 255;\n        do\n        {\n            sp->dec_codetab[code].firstchar = (unsigned char)code;\n            sp->dec_codetab[code].value = (unsigned char)code;\n            sp->dec_codetab[code].repeated = true;\n            sp->dec_codetab[code].length = 1;\n            sp->dec_codetab[code].next = NULL;\n        } while (code--);\n        /*\n         * Zero-out the unused entries  */\n        /* Silence false positive */\n        /* coverity[overrun-buffer-arg] */\n        memset(&sp->dec_codetab[CODE_CLEAR], 0,\n               (CODE_FIRST - CODE_CLEAR) * sizeof(code_t));\n    }\n    return (1);\n}\n\n/*\n * Setup state for decoding a strip.\n */\nstatic int LZWPreDecode(TIFF *tif, uint16_t s)\n{\n    static const char module[] = \"LZWPreDecode\";\n    LZWCodecState *sp = DecoderState(tif);\n\n    (void)s;\n    assert(sp != NULL);\n    if (sp->dec_codetab == NULL)\n    {\n        tif->tif_setupdecode(tif);\n        if (sp->dec_codetab == NULL)\n            return (0);\n    }\n\n    /*\n     * Check for old bit-reversed codes.\n     */\n    if (tif->tif_rawcc >= 2 && tif->tif_rawdata[0] == 0 &&\n        (tif->tif_rawdata[1] & 0x1))\n    {\n#ifdef LZW_COMPAT\n        if (!sp->dec_decode)\n        {\n            TIFFWarningExtR(tif, module, \"Old-style LZW codes, convert file\");\n            /*\n             * Override default decoding methods with\n             * ones that deal with the old coding.\n             * Otherwise the predictor versions set\n             * above will call the compatibility routines\n             * through the dec_decode method.\n             */\n            tif->tif_decoderow = LZWDecodeCompat;\n            tif->tif_decodestrip = LZWDecodeCompat;\n            tif->tif_decodetile = LZWDecodeCompat;\n            /*\n             * If doing horizontal differencing, must\n             * re-setup the predictor logic since we\n             * switched the basic decoder methods...\n             */\n            (*tif->tif_setupdecode)(tif);\n            sp->dec_decode = LZWDecodeCompat;\n        }\n        sp->lzw_maxcode = MAXCODE(BITS_MIN);\n#else  /* !LZW_COMPAT */\n        if (!sp->dec_decode)\n        {\n            TIFFErrorExtR(tif, module, \"Old-style LZW codes not supported\");\n            sp->dec_decode = LZWDecode;\n        }\n        return (0);\n#endif /* !LZW_COMPAT */\n    }\n    else\n    {\n        sp->lzw_maxcode = MAXCODE(BITS_MIN) - 1;\n        sp->dec_decode = LZWDecode;\n    }\n    sp->lzw_nbits = BITS_MIN;\n    sp->lzw_nextbits = 0;\n    sp->lzw_nextdata = 0;\n\n    sp->dec_restart = 0;\n    sp->dec_nbitsmask = MAXCODE(BITS_MIN);\n    sp->dec_bitsleft = 0;\n    sp->old_tif_rawcc = 0;\n    sp->dec_free_entp = sp->dec_codetab - 1; // + CODE_FIRST;\n    /*\n     * Zero entries that are not yet filled in.  We do\n     * this to guard against bogus input data that causes\n     * us to index into undefined entries.  If you can\n     * come up with a way to safely bounds-check input codes\n     * while decoding then you can remove this operation.\n     */\n    sp->dec_oldcodep = &sp->dec_codetab[0];\n    sp->dec_maxcodep = &sp->dec_codetab[sp->dec_nbitsmask - 1];\n    sp->read_error = 0;\n    return (1);\n}\n\n/*\n * Decode a \"hunk of data\".\n */\n\n/* Get the next 32 or 64-bit from the input data */\n#ifdef WORDS_BIGENDIAN\n#define GetNextData(nextdata, bp) memcpy(&nextdata, bp, sizeof(nextdata))\n#elif SIZEOF_WORDTYPE == 8\n#if defined(__GNUC__) && defined(__x86_64__)\n#define GetNextData(nextdata, bp)                                              \\\n    nextdata = __builtin_bswap64(*(uint64_t *)(bp))\n#elif defined(_M_X64)\n#define GetNextData(nextdata, bp) nextdata = _byteswap_uint64(*(uint64_t *)(bp))\n#elif defined(__GNUC__)\n#define GetNextData(nextdata, bp)                                              \\\n    memcpy(&nextdata, bp, sizeof(nextdata));                                   \\\n    nextdata = __builtin_bswap64(nextdata)\n#else\n#define GetNextData(nextdata, bp)                                              \\\n    nextdata = (((uint64_t)bp[0]) << 56) | (((uint64_t)bp[1]) << 48) |         \\\n               (((uint64_t)bp[2]) << 40) | (((uint64_t)bp[3]) << 32) |         \\\n               (((uint64_t)bp[4]) << 24) | (((uint64_t)bp[5]) << 16) |         \\\n               (((uint64_t)bp[6]) << 8) | (((uint64_t)bp[7]))\n#endif\n#elif SIZEOF_WORDTYPE == 4\n#if defined(__GNUC__) && defined(__i386__)\n#define GetNextData(nextdata, bp)                                              \\\n    nextdata = __builtin_bswap32(*(uint32_t *)(bp))\n#elif defined(_M_X86)\n#define GetNextData(nextdata, bp)                                              \\\n    nextdata = _byteswap_ulong(*(unsigned long *)(bp))\n#elif defined(__GNUC__)\n#define GetNextData(nextdata, bp)                                              \\\n    memcpy(&nextdata, bp, sizeof(nextdata));                                   \\\n    nextdata = __builtin_bswap32(nextdata)\n#else\n#define GetNextData(nextdata, bp)                                              \\\n    nextdata = (((uint32_t)bp[0]) << 24) | (((uint32_t)bp[1]) << 16) |         \\\n               (((uint32_t)bp[2]) << 8) | (((uint32_t)bp[3]))\n#endif\n#else\n#error \"Unhandled SIZEOF_WORDTYPE\"\n#endif\n\n#define GetNextCodeLZW()                                                       \\\n    do                                                                         \\\n    {                                                                          \\\n        nextbits -= nbits;                                                     \\\n        if (nextbits < 0)                                                      \\\n        {                                                                      \\\n            if (dec_bitsleft >= 8 * SIZEOF_WORDTYPE)                           \\\n            {                                                                  \\\n                unsigned codetmp = (unsigned)(nextdata << (-nextbits));        \\\n                GetNextData(nextdata, bp);                                     \\\n                bp += SIZEOF_WORDTYPE;                                         \\\n                nextbits += 8 * SIZEOF_WORDTYPE;                               \\\n                dec_bitsleft -= 8 * SIZEOF_WORDTYPE;                           \\\n                code = (WordType)((codetmp | (nextdata >> nextbits)) &         \\\n                                  nbitsmask);                                  \\\n                break;                                                         \\\n            }                                                                  \\\n            else                                                               \\\n            {                                                                  \\\n                if (dec_bitsleft < 8)                                          \\\n                {                                                              \\\n                    goto no_eoi;                                               \\\n                }                                                              \\\n                nextdata = (nextdata << 8) | *(bp)++;                          \\\n                nextbits += 8;                                                 \\\n                dec_bitsleft -= 8;                                             \\\n                if (nextbits < 0)                                              \\\n                {                                                              \\\n                    if (dec_bitsleft < 8)                                      \\\n                    {                                                          \\\n                        goto no_eoi;                                           \\\n                    }                                                          \\\n                    nextdata = (nextdata << 8) | *(bp)++;                      \\\n                    nextbits += 8;                                             \\\n                    dec_bitsleft -= 8;                                         \\\n                }                                                              \\\n            }                                                                  \\\n        }                                                                      \\\n        code = (WordType)((nextdata >> nextbits) & nbitsmask);                 \\\n    } while (0)\n\nstatic int LZWDecode(TIFF *tif, uint8_t *op0, tmsize_t occ0, uint16_t s)\n{\n    static const char module[] = \"LZWDecode\";\n    LZWCodecState *sp = DecoderState(tif);\n    uint8_t *op = (uint8_t *)op0;\n    tmsize_t occ = occ0;\n    uint8_t *bp;\n    long nbits, nextbits, nbitsmask;\n    WordType nextdata;\n    code_t *free_entp, *maxcodep, *oldcodep;\n\n    (void)s;\n    assert(sp != NULL);\n    assert(sp->dec_codetab != NULL);\n\n    if (sp->read_error)\n    {\n        return 0;\n    }\n\n    /*\n     * Restart interrupted output operation.\n     */\n    if (sp->dec_restart)\n    {\n        tmsize_t residue;\n\n        code_t *codep = sp->dec_codep;\n        residue = codep->length - sp->dec_restart;\n        if (residue > occ)\n        {\n            /*\n             * Residue from previous decode is sufficient\n             * to satisfy decode request.  Skip to the\n             * start of the decoded string, place decoded\n             * values in the output buffer, and return.\n             */\n            sp->dec_restart += occ;\n            do\n            {\n                codep = codep->next;\n            } while (--residue > occ && codep);\n            if (codep)\n            {\n                uint8_t *tp = op + occ;\n                do\n                {\n                    *--tp = codep->value;\n                    codep = codep->next;\n                } while (--occ && codep);\n            }\n            return (1);\n        }\n        /*\n         * Residue satisfies only part of the decode request.\n         */\n        op += residue;\n        occ -= residue;\n        uint8_t *tp = op;\n        do\n        {\n            *--tp = codep->value;\n            codep = codep->next;\n        } while (--residue && codep);\n        sp->dec_restart = 0;\n    }\n\n    bp = (uint8_t *)tif->tif_rawcp;\n    sp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3);\n    uint64_t dec_bitsleft = sp->dec_bitsleft;\n    nbits = sp->lzw_nbits;\n    nextdata = sp->lzw_nextdata;\n    nextbits = sp->lzw_nextbits;\n    nbitsmask = sp->dec_nbitsmask;\n    oldcodep = sp->dec_oldcodep;\n    free_entp = sp->dec_free_entp;\n    maxcodep = sp->dec_maxcodep;\n    code_t *const dec_codetab = sp->dec_codetab;\n    code_t *codep;\n\n    if (occ == 0)\n    {\n        goto after_loop;\n    }\n\nbegin:\n{\n    WordType code;\n    GetNextCodeLZW();\n    codep = dec_codetab + code;\n    if (code >= CODE_FIRST)\n        goto code_above_or_equal_to_258;\n    if (code < 256)\n        goto code_below_256;\n    if (code == CODE_EOI)\n        goto after_loop;\n    goto code_clear;\n\ncode_below_256:\n{\n    if (codep > free_entp)\n        goto error_code;\n    free_entp->next = oldcodep;\n    free_entp->firstchar = oldcodep->firstchar;\n    free_entp->length = oldcodep->length + 1;\n    free_entp->value = (uint8_t)code;\n    free_entp->repeated =\n        (bool)(oldcodep->repeated & (oldcodep->value == code));\n    if (++free_entp > maxcodep)\n    {\n        if (++nbits > BITS_MAX) /* should not happen for a conformant encoder */\n            nbits = BITS_MAX;\n        nbitsmask = MAXCODE(nbits);\n        maxcodep = dec_codetab + nbitsmask - 1;\n        if (free_entp >= &dec_codetab[CSIZE])\n        {\n            /* At that point, the next valid states are either EOI or a */\n            /* CODE_CLEAR. If a regular code is read, at the next */\n            /* attempt at registering a new entry, we will error out */\n            /* due to setting free_entp before any valid code */\n            free_entp = dec_codetab - 1;\n        }\n    }\n    oldcodep = codep;\n    *op++ = (uint8_t)code;\n    occ--;\n    if (occ == 0)\n        goto after_loop;\n    goto begin;\n}\n\ncode_above_or_equal_to_258:\n{\n    /*\n     * Add the new entry to the code table.\n     */\n\n    if (codep >= free_entp)\n    {\n        if (codep != free_entp)\n            goto error_code;\n        free_entp->value = oldcodep->firstchar;\n    }\n    else\n    {\n        free_entp->value = codep->firstchar;\n    }\n    free_entp->repeated =\n        (bool)(oldcodep->repeated & (oldcodep->value == free_entp->value));\n    free_entp->next = oldcodep;\n\n    free_entp->firstchar = oldcodep->firstchar;\n    free_entp->length = oldcodep->length + 1;\n    if (++free_entp > maxcodep)\n    {\n        if (++nbits > BITS_MAX) /* should not happen for a conformant encoder */\n            nbits = BITS_MAX;\n        nbitsmask = MAXCODE(nbits);\n        maxcodep = dec_codetab + nbitsmask - 1;\n        if (free_entp >= &dec_codetab[CSIZE])\n        {\n            /* At that point, the next valid states are either EOI or a */\n            /* CODE_CLEAR. If a regular code is read, at the next */\n            /* attempt at registering a new entry, we will error out */\n            /* due to setting free_entp before any valid code */\n            free_entp = dec_codetab - 1;\n        }\n    }\n    oldcodep = codep;\n\n    /*\n     * Code maps to a string, copy string\n     * value to output (written in reverse).\n     */\n    /* tiny bit faster on x86_64 to store in unsigned short than int */\n    unsigned short len = codep->length;\n\n    if (len < 3) /* equivalent to len == 2 given all other conditions */\n    {\n        if (occ <= 2)\n        {\n            if (occ == 2)\n            {\n                memcpy(op, &(codep->firstchar), 2);\n                op += 2;\n                occ -= 2;\n                goto after_loop;\n            }\n            goto too_short_buffer;\n        }\n\n        memcpy(op, &(codep->firstchar), 2);\n        op += 2;\n        occ -= 2;\n        goto begin; /* we can save the comparison occ > 0 */\n    }\n\n    if (len == 3)\n    {\n        if (occ <= 3)\n        {\n            if (occ == 3)\n            {\n                op[0] = codep->firstchar;\n                op[1] = codep->next->value;\n                op[2] = codep->value;\n                op += 3;\n                occ -= 3;\n                goto after_loop;\n            }\n            goto too_short_buffer;\n        }\n\n        op[0] = codep->firstchar;\n        op[1] = codep->next->value;\n        op[2] = codep->value;\n        op += 3;\n        occ -= 3;\n        goto begin; /* we can save the comparison occ > 0 */\n    }\n\n    if (len > occ)\n    {\n        goto too_short_buffer;\n    }\n\n    if (codep->repeated)\n    {\n        memset(op, codep->value, len);\n        op += len;\n        occ -= len;\n        if (occ == 0)\n            goto after_loop;\n        goto begin;\n    }\n\n    uint8_t *tp = op + len;\n\n    assert(len >= 4);\n\n    *--tp = codep->value;\n    codep = codep->next;\n    *--tp = codep->value;\n    codep = codep->next;\n    *--tp = codep->value;\n    codep = codep->next;\n    *--tp = codep->value;\n    if (tp > op)\n    {\n        do\n        {\n            codep = codep->next;\n            *--tp = codep->value;\n        } while (tp > op);\n    }\n\n    assert(occ >= len);\n    op += len;\n    occ -= len;\n    if (occ == 0)\n        goto after_loop;\n    goto begin;\n}\n\ncode_clear:\n{\n    free_entp = dec_codetab + CODE_FIRST;\n    nbits = BITS_MIN;\n    nbitsmask = MAXCODE(BITS_MIN);\n    maxcodep = dec_codetab + nbitsmask - 1;\n    do\n    {\n        GetNextCodeLZW();\n    } while (code == CODE_CLEAR); /* consecutive CODE_CLEAR codes */\n    if (code == CODE_EOI)\n        goto after_loop;\n    if (code > CODE_EOI)\n    {\n        goto error_code;\n    }\n    *op++ = (uint8_t)code;\n    occ--;\n    oldcodep = dec_codetab + code;\n    if (occ == 0)\n        goto after_loop;\n    goto begin;\n}\n}\n\ntoo_short_buffer:\n{\n    /*\n     * String is too long for decode buffer,\n     * locate portion that will fit, copy to\n     * the decode buffer, and setup restart\n     * logic for the next decoding call.\n     */\n    sp->dec_codep = codep;\n    do\n    {\n        codep = codep->next;\n    } while (codep->length > occ);\n\n    sp->dec_restart = occ;\n    uint8_t *tp = op + occ;\n    do\n    {\n        *--tp = codep->value;\n        codep = codep->next;\n    } while (--occ);\n}\n\nafter_loop:\n    tif->tif_rawcc -= (tmsize_t)((uint8_t *)bp - tif->tif_rawcp);\n    tif->tif_rawcp = (uint8_t *)bp;\n    sp->old_tif_rawcc = tif->tif_rawcc;\n    sp->dec_bitsleft = dec_bitsleft;\n    sp->lzw_nbits = (unsigned short)nbits;\n    sp->lzw_nextdata = nextdata;\n    sp->lzw_nextbits = nextbits;\n    sp->dec_nbitsmask = nbitsmask;\n    sp->dec_oldcodep = oldcodep;\n    sp->dec_free_entp = free_entp;\n    sp->dec_maxcodep = maxcodep;\n\n    if (occ > 0)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Not enough data at scanline %\" PRIu32 \" (short %\" PRIu64\n                      \" bytes)\",\n                      tif->tif_row, (uint64_t)occ);\n        return (0);\n    }\n    return (1);\n\nno_eoi:\n    TIFFErrorExtR(tif, module,\n                  \"LZWDecode: Strip %\" PRIu32 \" not terminated with EOI code\",\n                  tif->tif_curstrip);\n    return 0;\nerror_code:\n    sp->read_error = 1;\n    TIFFErrorExtR(tif, tif->tif_name, \"Using code not yet in table\");\n    return 0;\n}\n\n#ifdef LZW_COMPAT\n\n/*\n * This check shouldn't be necessary because each\n * strip is suppose to be terminated with CODE_EOI.\n */\n#define NextCode(_tif, _sp, _bp, _code, _get, dec_bitsleft)                    \\\n    {                                                                          \\\n        if (dec_bitsleft < (uint64_t)nbits)                                    \\\n        {                                                                      \\\n            TIFFWarningExtR(_tif, module,                                      \\\n                            \"LZWDecode: Strip %\" PRIu32                        \\\n                            \" not terminated with EOI code\",                   \\\n                            _tif->tif_curstrip);                               \\\n            _code = CODE_EOI;                                                  \\\n        }                                                                      \\\n        else                                                                   \\\n        {                                                                      \\\n            _get(_sp, _bp, _code);                                             \\\n            dec_bitsleft -= nbits;                                             \\\n        }                                                                      \\\n    }\n\n/*\n * Decode a \"hunk of data\" for old images.\n */\n#define GetNextCodeCompat(sp, bp, code)                                        \\\n    {                                                                          \\\n        nextdata |= (unsigned long)*(bp)++ << nextbits;                        \\\n        nextbits += 8;                                                         \\\n        if (nextbits < nbits)                                                  \\\n        {                                                                      \\\n            nextdata |= (unsigned long)*(bp)++ << nextbits;                    \\\n            nextbits += 8;                                                     \\\n        }                                                                      \\\n        code = (hcode_t)(nextdata & nbitsmask);                                \\\n        nextdata >>= nbits;                                                    \\\n        nextbits -= nbits;                                                     \\\n    }\n\nstatic int LZWDecodeCompat(TIFF *tif, uint8_t *op0, tmsize_t occ0, uint16_t s)\n{\n    static const char module[] = \"LZWDecodeCompat\";\n    LZWCodecState *sp = DecoderState(tif);\n    uint8_t *op = (uint8_t *)op0;\n    tmsize_t occ = occ0;\n    uint8_t *tp;\n    uint8_t *bp;\n    int code, nbits;\n    int len;\n    long nextbits, nbitsmask;\n    WordType nextdata;\n    code_t *codep, *free_entp, *maxcodep, *oldcodep;\n\n    (void)s;\n    assert(sp != NULL);\n\n    /*\n     * Restart interrupted output operation.\n     */\n    if (sp->dec_restart)\n    {\n        tmsize_t residue;\n\n        codep = sp->dec_codep;\n        residue = codep->length - sp->dec_restart;\n        if (residue > occ)\n        {\n            /*\n             * Residue from previous decode is sufficient\n             * to satisfy decode request.  Skip to the\n             * start of the decoded string, place decoded\n             * values in the output buffer, and return.\n             */\n            sp->dec_restart += occ;\n            do\n            {\n                codep = codep->next;\n            } while (--residue > occ);\n            tp = op + occ;\n            do\n            {\n                *--tp = codep->value;\n                codep = codep->next;\n            } while (--occ);\n            return (1);\n        }\n        /*\n         * Residue satisfies only part of the decode request.\n         */\n        op += residue;\n        occ -= residue;\n        tp = op;\n        do\n        {\n            *--tp = codep->value;\n            codep = codep->next;\n        } while (--residue);\n        sp->dec_restart = 0;\n    }\n\n    bp = (uint8_t *)tif->tif_rawcp;\n\n    sp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3);\n    uint64_t dec_bitsleft = sp->dec_bitsleft;\n\n    nbits = sp->lzw_nbits;\n    nextdata = sp->lzw_nextdata;\n    nextbits = sp->lzw_nextbits;\n    nbitsmask = sp->dec_nbitsmask;\n    oldcodep = sp->dec_oldcodep;\n    free_entp = sp->dec_free_entp;\n    maxcodep = sp->dec_maxcodep;\n\n    while (occ > 0)\n    {\n        NextCode(tif, sp, bp, code, GetNextCodeCompat, dec_bitsleft);\n        if (code == CODE_EOI)\n            break;\n        if (code == CODE_CLEAR)\n        {\n            do\n            {\n                free_entp = sp->dec_codetab + CODE_FIRST;\n                _TIFFmemset(free_entp, 0,\n                            (CSIZE - CODE_FIRST) * sizeof(code_t));\n                nbits = BITS_MIN;\n                nbitsmask = MAXCODE(BITS_MIN);\n                maxcodep = sp->dec_codetab + nbitsmask;\n                NextCode(tif, sp, bp, code, GetNextCodeCompat, dec_bitsleft);\n            } while (code == CODE_CLEAR); /* consecutive CODE_CLEAR codes */\n            if (code == CODE_EOI)\n                break;\n            if (code > CODE_CLEAR)\n            {\n                TIFFErrorExtR(\n                    tif, tif->tif_name,\n                    \"LZWDecode: Corrupted LZW table at scanline %\" PRIu32,\n                    tif->tif_row);\n                return (0);\n            }\n            *op++ = (uint8_t)code;\n            occ--;\n            oldcodep = sp->dec_codetab + code;\n            continue;\n        }\n        codep = sp->dec_codetab + code;\n\n        /*\n         * Add the new entry to the code table.\n         */\n        if (free_entp < &sp->dec_codetab[0] ||\n            free_entp >= &sp->dec_codetab[CSIZE])\n        {\n            TIFFErrorExtR(tif, module,\n                          \"Corrupted LZW table at scanline %\" PRIu32,\n                          tif->tif_row);\n            return (0);\n        }\n\n        free_entp->next = oldcodep;\n        if (free_entp->next < &sp->dec_codetab[0] ||\n            free_entp->next >= &sp->dec_codetab[CSIZE])\n        {\n            TIFFErrorExtR(tif, module,\n                          \"Corrupted LZW table at scanline %\" PRIu32,\n                          tif->tif_row);\n            return (0);\n        }\n        free_entp->firstchar = free_entp->next->firstchar;\n        free_entp->length = free_entp->next->length + 1;\n        free_entp->value =\n            (codep < free_entp) ? codep->firstchar : free_entp->firstchar;\n        if (++free_entp > maxcodep)\n        {\n            if (++nbits > BITS_MAX) /* should not happen */\n                nbits = BITS_MAX;\n            nbitsmask = MAXCODE(nbits);\n            maxcodep = sp->dec_codetab + nbitsmask;\n        }\n        oldcodep = codep;\n        if (code >= 256)\n        {\n            /*\n             * Code maps to a string, copy string\n             * value to output (written in reverse).\n             */\n            if (codep->length == 0)\n            {\n                TIFFErrorExtR(\n                    tif, module,\n                    \"Wrong length of decoded \"\n                    \"string: data probably corrupted at scanline %\" PRIu32,\n                    tif->tif_row);\n                return (0);\n            }\n            if (codep->length > occ)\n            {\n                /*\n                 * String is too long for decode buffer,\n                 * locate portion that will fit, copy to\n                 * the decode buffer, and setup restart\n                 * logic for the next decoding call.\n                 */\n                sp->dec_codep = codep;\n                do\n                {\n                    codep = codep->next;\n                } while (codep->length > occ);\n                sp->dec_restart = occ;\n                tp = op + occ;\n                do\n                {\n                    *--tp = codep->value;\n                    codep = codep->next;\n                } while (--occ);\n                break;\n            }\n            len = codep->length;\n            tp = op + len;\n            do\n            {\n                *--tp = codep->value;\n                codep = codep->next;\n            } while (codep && tp > op);\n            assert(occ >= len);\n            op += len;\n            occ -= len;\n        }\n        else\n        {\n            *op++ = (uint8_t)code;\n            occ--;\n        }\n    }\n\n    tif->tif_rawcc -= (tmsize_t)((uint8_t *)bp - tif->tif_rawcp);\n    tif->tif_rawcp = (uint8_t *)bp;\n\n    sp->old_tif_rawcc = tif->tif_rawcc;\n    sp->dec_bitsleft = dec_bitsleft;\n\n    sp->lzw_nbits = (unsigned short)nbits;\n    sp->lzw_nextdata = nextdata;\n    sp->lzw_nextbits = nextbits;\n    sp->dec_nbitsmask = nbitsmask;\n    sp->dec_oldcodep = oldcodep;\n    sp->dec_free_entp = free_entp;\n    sp->dec_maxcodep = maxcodep;\n\n    if (occ > 0)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Not enough data at scanline %\" PRIu32 \" (short %\" PRIu64\n                      \" bytes)\",\n                      tif->tif_row, (uint64_t)occ);\n        return (0);\n    }\n    return (1);\n}\n#endif /* LZW_COMPAT */\n\n/*\n * LZW Encoding.\n */\n\nstatic int LZWSetupEncode(TIFF *tif)\n{\n    static const char module[] = \"LZWSetupEncode\";\n    LZWCodecState *sp = EncoderState(tif);\n\n    assert(sp != NULL);\n    sp->enc_hashtab = (hash_t *)_TIFFmallocExt(tif, HSIZE * sizeof(hash_t));\n    if (sp->enc_hashtab == NULL)\n    {\n        TIFFErrorExtR(tif, module, \"No space for LZW hash table\");\n        return (0);\n    }\n    return (1);\n}\n\n/*\n * Reset encoding state at the start of a strip.\n */\nstatic int LZWPreEncode(TIFF *tif, uint16_t s)\n{\n    LZWCodecState *sp = EncoderState(tif);\n\n    (void)s;\n    assert(sp != NULL);\n\n    if (sp->enc_hashtab == NULL)\n    {\n        tif->tif_setupencode(tif);\n    }\n\n    sp->lzw_nbits = BITS_MIN;\n    sp->lzw_maxcode = MAXCODE(BITS_MIN);\n    sp->lzw_free_ent = CODE_FIRST;\n    sp->lzw_nextbits = 0;\n    sp->lzw_nextdata = 0;\n    sp->enc_checkpoint = CHECK_GAP;\n    sp->enc_ratio = 0;\n    sp->enc_incount = 0;\n    sp->enc_outcount = 0;\n    /*\n     * The 4 here insures there is space for 2 max-sized\n     * codes in LZWEncode and LZWPostDecode.\n     */\n    sp->enc_rawlimit = tif->tif_rawdata + tif->tif_rawdatasize - 1 - 4;\n    cl_hash(sp);                   /* clear hash table */\n    sp->enc_oldcode = (hcode_t)-1; /* generates CODE_CLEAR in LZWEncode */\n    return (1);\n}\n\n#define CALCRATIO(sp, rat)                                                     \\\n    {                                                                          \\\n        if (incount > 0x007fffff)                                              \\\n        { /* NB: shift will overflow */                                        \\\n            rat = outcount >> 8;                                               \\\n            rat = (rat == 0 ? 0x7fffffff : incount / rat);                     \\\n        }                                                                      \\\n        else                                                                   \\\n            rat = (incount << 8) / outcount;                                   \\\n    }\n\n/* Explicit 0xff masking to make icc -check=conversions happy */\n#define PutNextCode(op, c)                                                     \\\n    {                                                                          \\\n        nextdata = (nextdata << nbits) | c;                                    \\\n        nextbits += nbits;                                                     \\\n        *op++ = (unsigned char)((nextdata >> (nextbits - 8)) & 0xff);          \\\n        nextbits -= 8;                                                         \\\n        if (nextbits >= 8)                                                     \\\n        {                                                                      \\\n            *op++ = (unsigned char)((nextdata >> (nextbits - 8)) & 0xff);      \\\n            nextbits -= 8;                                                     \\\n        }                                                                      \\\n        outcount += nbits;                                                     \\\n    }\n\n/*\n * Encode a chunk of pixels.\n *\n * Uses an open addressing double hashing (no chaining) on the\n * prefix code/next character combination.  We do a variant of\n * Knuth's algorithm D (vol. 3, sec. 6.4) along with G. Knott's\n * relatively-prime secondary probe.  Here, the modular division\n * first probe is gives way to a faster exclusive-or manipulation.\n * Also do block compression with an adaptive reset, whereby the\n * code table is cleared when the compression ratio decreases,\n * but after the table fills.  The variable-length output codes\n * are re-sized at this point, and a CODE_CLEAR is generated\n * for the decoder.\n */\nstatic int LZWEncode(TIFF *tif, uint8_t *bp, tmsize_t cc, uint16_t s)\n{\n    register LZWCodecState *sp = EncoderState(tif);\n    register long fcode;\n    register hash_t *hp;\n    register int h, c;\n    hcode_t ent;\n    long disp;\n    tmsize_t incount, outcount, checkpoint;\n    WordType nextdata;\n    long nextbits;\n    int free_ent, maxcode, nbits;\n    uint8_t *op;\n    uint8_t *limit;\n\n    (void)s;\n    if (sp == NULL)\n        return (0);\n\n    assert(sp->enc_hashtab != NULL);\n\n    /*\n     * Load local state.\n     */\n    incount = sp->enc_incount;\n    outcount = sp->enc_outcount;\n    checkpoint = sp->enc_checkpoint;\n    nextdata = sp->lzw_nextdata;\n    nextbits = sp->lzw_nextbits;\n    free_ent = sp->lzw_free_ent;\n    maxcode = sp->lzw_maxcode;\n    nbits = sp->lzw_nbits;\n    op = tif->tif_rawcp;\n    limit = sp->enc_rawlimit;\n    ent = (hcode_t)sp->enc_oldcode;\n\n    if (ent == (hcode_t)-1 && cc > 0)\n    {\n        /*\n         * NB: This is safe because it can only happen\n         *     at the start of a strip where we know there\n         *     is space in the data buffer.\n         */\n        PutNextCode(op, CODE_CLEAR);\n        ent = *bp++;\n        cc--;\n        incount++;\n    }\n    while (cc > 0)\n    {\n        c = *bp++;\n        cc--;\n        incount++;\n        fcode = ((long)c << BITS_MAX) + ent;\n        h = (c << HSHIFT) ^ ent; /* xor hashing */\n#ifdef _WINDOWS\n        /*\n         * Check hash index for an overflow.\n         */\n        if (h >= HSIZE)\n            h -= HSIZE;\n#endif\n        hp = &sp->enc_hashtab[h];\n        if (hp->hash == fcode)\n        {\n            ent = hp->code;\n            continue;\n        }\n        if (hp->hash >= 0)\n        {\n            /*\n             * Primary hash failed, check secondary hash.\n             */\n            disp = HSIZE - h;\n            if (h == 0)\n                disp = 1;\n            do\n            {\n                /*\n                 * Avoid pointer arithmetic because of\n                 * wraparound problems with segments.\n                 */\n                if ((h -= disp) < 0)\n                    h += HSIZE;\n                hp = &sp->enc_hashtab[h];\n                if (hp->hash == fcode)\n                {\n                    ent = hp->code;\n                    goto hit;\n                }\n            } while (hp->hash >= 0);\n        }\n        /*\n         * New entry, emit code and add to table.\n         */\n        /*\n         * Verify there is space in the buffer for the code\n         * and any potential Clear code that might be emitted\n         * below.  The value of limit is setup so that there\n         * are at least 4 bytes free--room for 2 codes.\n         */\n        if (op > limit)\n        {\n            tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\n            if (!TIFFFlushData1(tif))\n                return 0;\n            op = tif->tif_rawdata;\n        }\n        PutNextCode(op, ent);\n        ent = (hcode_t)c;\n        hp->code = (hcode_t)(free_ent++);\n        hp->hash = fcode;\n        if (free_ent == CODE_MAX - 1)\n        {\n            /* table is full, emit clear code and reset */\n            cl_hash(sp);\n            sp->enc_ratio = 0;\n            incount = 0;\n            outcount = 0;\n            free_ent = CODE_FIRST;\n            PutNextCode(op, CODE_CLEAR);\n            nbits = BITS_MIN;\n            maxcode = MAXCODE(BITS_MIN);\n        }\n        else\n        {\n            /*\n             * If the next entry is going to be too big for\n             * the code size, then increase it, if possible.\n             */\n            if (free_ent > maxcode)\n            {\n                nbits++;\n                assert(nbits <= BITS_MAX);\n                maxcode = (int)MAXCODE(nbits);\n            }\n            else if (incount >= checkpoint)\n            {\n                tmsize_t rat;\n                /*\n                 * Check compression ratio and, if things seem\n                 * to be slipping, clear the hash table and\n                 * reset state.  The compression ratio is a\n                 * 24+8-bit fractional number.\n                 */\n                checkpoint = incount + CHECK_GAP;\n                CALCRATIO(sp, rat);\n                if (rat <= sp->enc_ratio)\n                {\n                    cl_hash(sp);\n                    sp->enc_ratio = 0;\n                    incount = 0;\n                    outcount = 0;\n                    free_ent = CODE_FIRST;\n                    PutNextCode(op, CODE_CLEAR);\n                    nbits = BITS_MIN;\n                    maxcode = MAXCODE(BITS_MIN);\n                }\n                else\n                    sp->enc_ratio = rat;\n            }\n        }\n    hit:;\n    }\n\n    /*\n     * Restore global state.\n     */\n    sp->enc_incount = incount;\n    sp->enc_outcount = outcount;\n    sp->enc_checkpoint = checkpoint;\n    sp->enc_oldcode = ent;\n    sp->lzw_nextdata = nextdata;\n    sp->lzw_nextbits = nextbits;\n    sp->lzw_free_ent = (unsigned short)free_ent;\n    sp->lzw_maxcode = (unsigned short)maxcode;\n    sp->lzw_nbits = (unsigned short)nbits;\n    tif->tif_rawcp = op;\n    return (1);\n}\n\n/*\n * Finish off an encoded strip by flushing the last\n * string and tacking on an End Of Information code.\n */\nstatic int LZWPostEncode(TIFF *tif)\n{\n    register LZWCodecState *sp = EncoderState(tif);\n    uint8_t *op = tif->tif_rawcp;\n    long nextbits = sp->lzw_nextbits;\n    WordType nextdata = sp->lzw_nextdata;\n    tmsize_t outcount = sp->enc_outcount;\n    int nbits = sp->lzw_nbits;\n\n    if (op > sp->enc_rawlimit)\n    {\n        tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\n        if (!TIFFFlushData1(tif))\n            return 0;\n        op = tif->tif_rawdata;\n    }\n    if (sp->enc_oldcode != (hcode_t)-1)\n    {\n        int free_ent = sp->lzw_free_ent;\n\n        PutNextCode(op, sp->enc_oldcode);\n        sp->enc_oldcode = (hcode_t)-1;\n        free_ent++;\n\n        if (free_ent == CODE_MAX - 1)\n        {\n            /* table is full, emit clear code and reset */\n            outcount = 0;\n            PutNextCode(op, CODE_CLEAR);\n            nbits = BITS_MIN;\n        }\n        else\n        {\n            /*\n             * If the next entry is going to be too big for\n             * the code size, then increase it, if possible.\n             */\n            if (free_ent > sp->lzw_maxcode)\n            {\n                nbits++;\n                assert(nbits <= BITS_MAX);\n            }\n        }\n    }\n    PutNextCode(op, CODE_EOI);\n    /* Explicit 0xff masking to make icc -check=conversions happy */\n    if (nextbits > 0)\n        *op++ = (unsigned char)((nextdata << (8 - nextbits)) & 0xff);\n    tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\n    (void)outcount;\n    return (1);\n}\n\n/*\n * Reset encoding hash table.\n */\nstatic void cl_hash(LZWCodecState *sp)\n{\n    register hash_t *hp = &sp->enc_hashtab[HSIZE - 1];\n    register long i = HSIZE - 8;\n\n    do\n    {\n        i -= 8;\n        hp[-7].hash = -1;\n        hp[-6].hash = -1;\n        hp[-5].hash = -1;\n        hp[-4].hash = -1;\n        hp[-3].hash = -1;\n        hp[-2].hash = -1;\n        hp[-1].hash = -1;\n        hp[0].hash = -1;\n        hp -= 8;\n    } while (i >= 0);\n    for (i += 8; i > 0; i--, hp--)\n        hp->hash = -1;\n}\n\nstatic void LZWCleanup(TIFF *tif)\n{\n    (void)TIFFPredictorCleanup(tif);\n\n    assert(tif->tif_data != 0);\n\n    if (DecoderState(tif)->dec_codetab)\n        _TIFFfreeExt(tif, DecoderState(tif)->dec_codetab);\n\n    if (EncoderState(tif)->enc_hashtab)\n        _TIFFfreeExt(tif, EncoderState(tif)->enc_hashtab);\n\n    _TIFFfreeExt(tif, tif->tif_data);\n    tif->tif_data = NULL;\n\n    _TIFFSetDefaultCompressionState(tif);\n}\n\nint TIFFInitLZW(TIFF *tif, int scheme)\n{\n    static const char module[] = \"TIFFInitLZW\";\n    (void)scheme;\n    assert(scheme == COMPRESSION_LZW);\n    /*\n     * Allocate state block so tag methods have storage to record values.\n     */\n    tif->tif_data = (uint8_t *)_TIFFmallocExt(tif, sizeof(LZWCodecState));\n    if (tif->tif_data == NULL)\n        goto bad;\n    DecoderState(tif)->dec_codetab = NULL;\n    DecoderState(tif)->dec_decode = NULL;\n    EncoderState(tif)->enc_hashtab = NULL;\n    LZWState(tif)->rw_mode = tif->tif_mode;\n\n    /*\n     * Install codec methods.\n     */\n    tif->tif_fixuptags = LZWFixupTags;\n    tif->tif_setupdecode = LZWSetupDecode;\n    tif->tif_predecode = LZWPreDecode;\n    tif->tif_decoderow = LZWDecode;\n    tif->tif_decodestrip = LZWDecode;\n    tif->tif_decodetile = LZWDecode;\n    tif->tif_setupencode = LZWSetupEncode;\n    tif->tif_preencode = LZWPreEncode;\n    tif->tif_postencode = LZWPostEncode;\n    tif->tif_encoderow = LZWEncode;\n    tif->tif_encodestrip = LZWEncode;\n    tif->tif_encodetile = LZWEncode;\n    tif->tif_cleanup = LZWCleanup;\n    /*\n     * Setup predictor setup.\n     */\n    (void)TIFFPredictorInit(tif);\n    return (1);\nbad:\n    TIFFErrorExtR(tif, module, \"No space for LZW state block\");\n    return (0);\n}\n\n/*\n * Copyright (c) 1985, 1986 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * James A. Woods, derived from original work by Spencer Thomas\n * and Joseph Orost.\n *\n * Redistribution and use in source and binary forms are permitted\n * provided that the above copyright notice and this paragraph are\n * duplicated in all such forms and that any documentation,\n * advertising materials, and other materials related to such\n * distribution and use acknowledge that the software was developed\n * by the University of California, Berkeley.  The name of the\n * University may not be used to endorse or promote products derived\n * from this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n#endif /* LZW_SUPPORT */\n"], "fixing_code": ["/*\n * Copyright (c) 1988-1997 Sam Leffler\n * Copyright (c) 1991-1997 Silicon Graphics, Inc.\n * Copyright (c) 2022 Even Rouault\n *\n * Permission to use, copy, modify, distribute, and sell this software and\n * its documentation for any purpose is hereby granted without fee, provided\n * that (i) the above copyright notices and this permission notice appear in\n * all copies of the software and related documentation, and (ii) the names of\n * Sam Leffler and Silicon Graphics may not be used in any advertising or\n * publicity relating to the software without the specific, prior written\n * permission of Sam Leffler and Silicon Graphics.\n *\n * THE SOFTWARE IS PROVIDED \"AS-IS\" AND WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY\n * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n *\n * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR\n * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,\n * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\n * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF\n * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE\n * OF THIS SOFTWARE.\n */\n\n#include \"tiffiop.h\"\n#ifdef LZW_SUPPORT\n/*\n * TIFF Library.\n * Rev 5.0 Lempel-Ziv & Welch Compression Support\n *\n * This code is derived from the compress program whose code is\n * derived from software contributed to Berkeley by James A. Woods,\n * derived from original work by Spencer Thomas and Joseph Orost.\n *\n * The original Berkeley copyright notice appears below in its entirety.\n */\n#include \"tif_predict.h\"\n\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/* Select the plausible largest natural integer type for the architecture */\n#define SIZEOF_WORDTYPE SIZEOF_SIZE_T\ntypedef size_t WordType;\n\n/*\n * NB: The 5.0 spec describes a different algorithm than Aldus\n *     implements.  Specifically, Aldus does code length transitions\n *     one code earlier than should be done (for real LZW).\n *     Earlier versions of this library implemented the correct\n *     LZW algorithm, but emitted codes in a bit order opposite\n *     to the TIFF spec.  Thus, to maintain compatibility w/ Aldus\n *     we interpret MSB-LSB ordered codes to be images written w/\n *     old versions of this library, but otherwise adhere to the\n *     Aldus \"off by one\" algorithm.\n *\n * Future revisions to the TIFF spec are expected to \"clarify this issue\".\n */\n#define LZW_COMPAT /* include backwards compatibility code */\n\n#define MAXCODE(n) ((1L << (n)) - 1)\n/*\n * The TIFF spec specifies that encoded bit\n * strings range from 9 to 12 bits.\n */\n#define BITS_MIN 9  /* start with 9 bits */\n#define BITS_MAX 12 /* max of 12 bit strings */\n/* predefined codes */\n#define CODE_CLEAR 256 /* code to clear string table */\n#define CODE_EOI 257   /* end-of-information code */\n#define CODE_FIRST 258 /* first free code entry */\n#define CODE_MAX MAXCODE(BITS_MAX)\n#define HSIZE 9001L /* 91% occupancy */\n#define HSHIFT (13 - 8)\n#ifdef LZW_COMPAT\n/* NB: +1024 is for compatibility with old files */\n#define CSIZE (MAXCODE(BITS_MAX) + 1024L)\n#else\n#define CSIZE (MAXCODE(BITS_MAX) + 1L)\n#endif\n\n/*\n * State block for each open TIFF file using LZW\n * compression/decompression.  Note that the predictor\n * state block must be first in this data structure.\n */\ntypedef struct\n{\n    TIFFPredictorState predict; /* predictor super class */\n\n    unsigned short nbits;    /* # of bits/code */\n    unsigned short maxcode;  /* maximum code for lzw_nbits */\n    unsigned short free_ent; /* next free entry in hash table */\n    WordType nextdata;       /* next bits of i/o */\n    long nextbits;           /* # of valid bits in lzw_nextdata */\n\n    int rw_mode; /* preserve rw_mode from init */\n} LZWBaseState;\n\n#define lzw_nbits base.nbits\n#define lzw_maxcode base.maxcode\n#define lzw_free_ent base.free_ent\n#define lzw_nextdata base.nextdata\n#define lzw_nextbits base.nextbits\n\n/*\n * Encoding-specific state.\n */\ntypedef uint16_t hcode_t; /* codes fit in 16 bits */\ntypedef struct\n{\n    long hash;\n    hcode_t code;\n} hash_t;\n\n/*\n * Decoding-specific state.\n */\ntypedef struct code_ent\n{\n    struct code_ent *next;\n    unsigned short length; /* string len, including this token */\n    /* firstchar should be placed immediately before value in this structure */\n    unsigned char firstchar; /* first token of string */\n    unsigned char value;     /* data value */\n    bool repeated;\n} code_t;\n\ntypedef int (*decodeFunc)(TIFF *, uint8_t *, tmsize_t, uint16_t);\n\ntypedef struct\n{\n    LZWBaseState base;\n\n    /* Decoding specific data */\n    long dec_nbitsmask;     /* lzw_nbits 1 bits, right adjusted */\n    tmsize_t dec_restart;   /* restart count */\n    uint64_t dec_bitsleft;  /* available bits in raw data */\n    tmsize_t old_tif_rawcc; /* value of tif_rawcc at the end of the previous\n                               TIFLZWDecode() call */\n    decodeFunc dec_decode;  /* regular or backwards compatible */\n    code_t *dec_codep;      /* current recognized code */\n    code_t *dec_oldcodep;   /* previously recognized code */\n    code_t *dec_free_entp;  /* next free entry */\n    code_t *dec_maxcodep;   /* max available entry */\n    code_t *dec_codetab;    /* kept separate for small machines */\n    int read_error; /* whether a read error has occurred, and which should cause\n                       further reads in the same strip/tile to be aborted */\n\n    /* Encoding specific data */\n    int enc_oldcode;         /* last code encountered */\n    tmsize_t enc_checkpoint; /* point at which to clear table */\n#define CHECK_GAP 10000      /* enc_ratio check interval */\n    tmsize_t enc_ratio;      /* current compression ratio */\n    tmsize_t enc_incount;    /* (input) data bytes encoded */\n    tmsize_t enc_outcount;   /* encoded (output) bytes */\n    uint8_t *enc_rawlimit;   /* bound on tif_rawdata buffer */\n    hash_t *enc_hashtab;     /* kept separate for small machines */\n} LZWCodecState;\n\n#define LZWState(tif) ((LZWBaseState *)(tif)->tif_data)\n#define DecoderState(tif) ((LZWCodecState *)LZWState(tif))\n#define EncoderState(tif) ((LZWCodecState *)LZWState(tif))\n\nstatic int LZWDecode(TIFF *tif, uint8_t *op0, tmsize_t occ0, uint16_t s);\n#ifdef LZW_COMPAT\nstatic int LZWDecodeCompat(TIFF *tif, uint8_t *op0, tmsize_t occ0, uint16_t s);\n#endif\nstatic void cl_hash(LZWCodecState *);\n\n/*\n * LZW Decoder.\n */\n\nstatic int LZWFixupTags(TIFF *tif)\n{\n    (void)tif;\n    return (1);\n}\n\nstatic int LZWSetupDecode(TIFF *tif)\n{\n    static const char module[] = \"LZWSetupDecode\";\n    LZWCodecState *sp = DecoderState(tif);\n    int code;\n\n    if (sp == NULL)\n    {\n        /*\n         * Allocate state block so tag methods have storage to record\n         * values.\n         */\n        tif->tif_data = (uint8_t *)_TIFFmallocExt(tif, sizeof(LZWCodecState));\n        if (tif->tif_data == NULL)\n        {\n            TIFFErrorExtR(tif, module, \"No space for LZW state block\");\n            return (0);\n        }\n\n        sp = DecoderState(tif);\n        sp->dec_codetab = NULL;\n        sp->dec_decode = NULL;\n\n        /*\n         * Setup predictor setup.\n         */\n        (void)TIFFPredictorInit(tif);\n    }\n\n    if (sp->dec_codetab == NULL)\n    {\n        sp->dec_codetab = (code_t *)_TIFFmallocExt(tif, CSIZE * sizeof(code_t));\n        if (sp->dec_codetab == NULL)\n        {\n            TIFFErrorExtR(tif, module, \"No space for LZW code table\");\n            return (0);\n        }\n        /*\n         * Pre-load the table.\n         */\n        code = 255;\n        do\n        {\n            sp->dec_codetab[code].firstchar = (unsigned char)code;\n            sp->dec_codetab[code].value = (unsigned char)code;\n            sp->dec_codetab[code].repeated = true;\n            sp->dec_codetab[code].length = 1;\n            sp->dec_codetab[code].next = NULL;\n        } while (code--);\n        /*\n         * Zero-out the unused entries  */\n        /* Silence false positive */\n        /* coverity[overrun-buffer-arg] */\n        memset(&sp->dec_codetab[CODE_CLEAR], 0,\n               (CODE_FIRST - CODE_CLEAR) * sizeof(code_t));\n    }\n    return (1);\n}\n\n/*\n * Setup state for decoding a strip.\n */\nstatic int LZWPreDecode(TIFF *tif, uint16_t s)\n{\n    static const char module[] = \"LZWPreDecode\";\n    LZWCodecState *sp = DecoderState(tif);\n\n    (void)s;\n    assert(sp != NULL);\n    if (sp->dec_codetab == NULL)\n    {\n        tif->tif_setupdecode(tif);\n        if (sp->dec_codetab == NULL)\n            return (0);\n    }\n\n    /*\n     * Check for old bit-reversed codes.\n     */\n    if (tif->tif_rawcc >= 2 && tif->tif_rawdata[0] == 0 &&\n        (tif->tif_rawdata[1] & 0x1))\n    {\n#ifdef LZW_COMPAT\n        if (!sp->dec_decode)\n        {\n            TIFFWarningExtR(tif, module, \"Old-style LZW codes, convert file\");\n            /*\n             * Override default decoding methods with\n             * ones that deal with the old coding.\n             * Otherwise the predictor versions set\n             * above will call the compatibility routines\n             * through the dec_decode method.\n             */\n            tif->tif_decoderow = LZWDecodeCompat;\n            tif->tif_decodestrip = LZWDecodeCompat;\n            tif->tif_decodetile = LZWDecodeCompat;\n            /*\n             * If doing horizontal differencing, must\n             * re-setup the predictor logic since we\n             * switched the basic decoder methods...\n             */\n            (*tif->tif_setupdecode)(tif);\n            sp->dec_decode = LZWDecodeCompat;\n        }\n        sp->lzw_maxcode = MAXCODE(BITS_MIN);\n#else  /* !LZW_COMPAT */\n        if (!sp->dec_decode)\n        {\n            TIFFErrorExtR(tif, module, \"Old-style LZW codes not supported\");\n            sp->dec_decode = LZWDecode;\n        }\n        return (0);\n#endif /* !LZW_COMPAT */\n    }\n    else\n    {\n        sp->lzw_maxcode = MAXCODE(BITS_MIN) - 1;\n        sp->dec_decode = LZWDecode;\n    }\n    sp->lzw_nbits = BITS_MIN;\n    sp->lzw_nextbits = 0;\n    sp->lzw_nextdata = 0;\n\n    sp->dec_restart = 0;\n    sp->dec_nbitsmask = MAXCODE(BITS_MIN);\n    sp->dec_bitsleft = 0;\n    sp->old_tif_rawcc = 0;\n    sp->dec_free_entp = sp->dec_codetab - 1; // + CODE_FIRST;\n    /*\n     * Zero entries that are not yet filled in.  We do\n     * this to guard against bogus input data that causes\n     * us to index into undefined entries.  If you can\n     * come up with a way to safely bounds-check input codes\n     * while decoding then you can remove this operation.\n     */\n    sp->dec_oldcodep = &sp->dec_codetab[0];\n    sp->dec_maxcodep = &sp->dec_codetab[sp->dec_nbitsmask - 1];\n    sp->read_error = 0;\n    return (1);\n}\n\n/*\n * Decode a \"hunk of data\".\n */\n\n/* Get the next 32 or 64-bit from the input data */\n#ifdef WORDS_BIGENDIAN\n#define GetNextData(nextdata, bp) memcpy(&nextdata, bp, sizeof(nextdata))\n#elif SIZEOF_WORDTYPE == 8\n#if defined(__GNUC__) && defined(__x86_64__)\n#define GetNextData(nextdata, bp)                                              \\\n    nextdata = __builtin_bswap64(*(uint64_t *)(bp))\n#elif defined(_M_X64)\n#define GetNextData(nextdata, bp) nextdata = _byteswap_uint64(*(uint64_t *)(bp))\n#elif defined(__GNUC__)\n#define GetNextData(nextdata, bp)                                              \\\n    memcpy(&nextdata, bp, sizeof(nextdata));                                   \\\n    nextdata = __builtin_bswap64(nextdata)\n#else\n#define GetNextData(nextdata, bp)                                              \\\n    nextdata = (((uint64_t)bp[0]) << 56) | (((uint64_t)bp[1]) << 48) |         \\\n               (((uint64_t)bp[2]) << 40) | (((uint64_t)bp[3]) << 32) |         \\\n               (((uint64_t)bp[4]) << 24) | (((uint64_t)bp[5]) << 16) |         \\\n               (((uint64_t)bp[6]) << 8) | (((uint64_t)bp[7]))\n#endif\n#elif SIZEOF_WORDTYPE == 4\n#if defined(__GNUC__) && defined(__i386__)\n#define GetNextData(nextdata, bp)                                              \\\n    nextdata = __builtin_bswap32(*(uint32_t *)(bp))\n#elif defined(_M_X86)\n#define GetNextData(nextdata, bp)                                              \\\n    nextdata = _byteswap_ulong(*(unsigned long *)(bp))\n#elif defined(__GNUC__)\n#define GetNextData(nextdata, bp)                                              \\\n    memcpy(&nextdata, bp, sizeof(nextdata));                                   \\\n    nextdata = __builtin_bswap32(nextdata)\n#else\n#define GetNextData(nextdata, bp)                                              \\\n    nextdata = (((uint32_t)bp[0]) << 24) | (((uint32_t)bp[1]) << 16) |         \\\n               (((uint32_t)bp[2]) << 8) | (((uint32_t)bp[3]))\n#endif\n#else\n#error \"Unhandled SIZEOF_WORDTYPE\"\n#endif\n\n#define GetNextCodeLZW()                                                       \\\n    do                                                                         \\\n    {                                                                          \\\n        nextbits -= nbits;                                                     \\\n        if (nextbits < 0)                                                      \\\n        {                                                                      \\\n            if (dec_bitsleft >= 8 * SIZEOF_WORDTYPE)                           \\\n            {                                                                  \\\n                unsigned codetmp = (unsigned)(nextdata << (-nextbits));        \\\n                GetNextData(nextdata, bp);                                     \\\n                bp += SIZEOF_WORDTYPE;                                         \\\n                nextbits += 8 * SIZEOF_WORDTYPE;                               \\\n                dec_bitsleft -= 8 * SIZEOF_WORDTYPE;                           \\\n                code = (WordType)((codetmp | (nextdata >> nextbits)) &         \\\n                                  nbitsmask);                                  \\\n                break;                                                         \\\n            }                                                                  \\\n            else                                                               \\\n            {                                                                  \\\n                if (dec_bitsleft < 8)                                          \\\n                {                                                              \\\n                    goto no_eoi;                                               \\\n                }                                                              \\\n                nextdata = (nextdata << 8) | *(bp)++;                          \\\n                nextbits += 8;                                                 \\\n                dec_bitsleft -= 8;                                             \\\n                if (nextbits < 0)                                              \\\n                {                                                              \\\n                    if (dec_bitsleft < 8)                                      \\\n                    {                                                          \\\n                        goto no_eoi;                                           \\\n                    }                                                          \\\n                    nextdata = (nextdata << 8) | *(bp)++;                      \\\n                    nextbits += 8;                                             \\\n                    dec_bitsleft -= 8;                                         \\\n                }                                                              \\\n            }                                                                  \\\n        }                                                                      \\\n        code = (WordType)((nextdata >> nextbits) & nbitsmask);                 \\\n    } while (0)\n\nstatic int LZWDecode(TIFF *tif, uint8_t *op0, tmsize_t occ0, uint16_t s)\n{\n    static const char module[] = \"LZWDecode\";\n    LZWCodecState *sp = DecoderState(tif);\n    uint8_t *op = (uint8_t *)op0;\n    tmsize_t occ = occ0;\n    uint8_t *bp;\n    long nbits, nextbits, nbitsmask;\n    WordType nextdata;\n    code_t *free_entp, *maxcodep, *oldcodep;\n\n    (void)s;\n    assert(sp != NULL);\n    assert(sp->dec_codetab != NULL);\n\n    if (sp->read_error)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"LZWDecode: Scanline %\" PRIu32 \" cannot be read due to \"\n                      \"previous error\",\n                      tif->tif_row);\n        return 0;\n    }\n\n    /*\n     * Restart interrupted output operation.\n     */\n    if (sp->dec_restart)\n    {\n        tmsize_t residue;\n\n        code_t *codep = sp->dec_codep;\n        residue = codep->length - sp->dec_restart;\n        if (residue > occ)\n        {\n            /*\n             * Residue from previous decode is sufficient\n             * to satisfy decode request.  Skip to the\n             * start of the decoded string, place decoded\n             * values in the output buffer, and return.\n             */\n            sp->dec_restart += occ;\n            do\n            {\n                codep = codep->next;\n            } while (--residue > occ && codep);\n            if (codep)\n            {\n                uint8_t *tp = op + occ;\n                do\n                {\n                    *--tp = codep->value;\n                    codep = codep->next;\n                } while (--occ && codep);\n            }\n            return (1);\n        }\n        /*\n         * Residue satisfies only part of the decode request.\n         */\n        op += residue;\n        occ -= residue;\n        uint8_t *tp = op;\n        do\n        {\n            *--tp = codep->value;\n            codep = codep->next;\n        } while (--residue && codep);\n        sp->dec_restart = 0;\n    }\n\n    bp = (uint8_t *)tif->tif_rawcp;\n    sp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3);\n    uint64_t dec_bitsleft = sp->dec_bitsleft;\n    nbits = sp->lzw_nbits;\n    nextdata = sp->lzw_nextdata;\n    nextbits = sp->lzw_nextbits;\n    nbitsmask = sp->dec_nbitsmask;\n    oldcodep = sp->dec_oldcodep;\n    free_entp = sp->dec_free_entp;\n    maxcodep = sp->dec_maxcodep;\n    code_t *const dec_codetab = sp->dec_codetab;\n    code_t *codep;\n\n    if (occ == 0)\n    {\n        goto after_loop;\n    }\n\nbegin:\n{\n    WordType code;\n    GetNextCodeLZW();\n    codep = dec_codetab + code;\n    if (code >= CODE_FIRST)\n        goto code_above_or_equal_to_258;\n    if (code < 256)\n        goto code_below_256;\n    if (code == CODE_EOI)\n        goto after_loop;\n    goto code_clear;\n\ncode_below_256:\n{\n    if (codep > free_entp)\n        goto error_code;\n    free_entp->next = oldcodep;\n    free_entp->firstchar = oldcodep->firstchar;\n    free_entp->length = oldcodep->length + 1;\n    free_entp->value = (uint8_t)code;\n    free_entp->repeated =\n        (bool)(oldcodep->repeated & (oldcodep->value == code));\n    if (++free_entp > maxcodep)\n    {\n        if (++nbits > BITS_MAX) /* should not happen for a conformant encoder */\n            nbits = BITS_MAX;\n        nbitsmask = MAXCODE(nbits);\n        maxcodep = dec_codetab + nbitsmask - 1;\n        if (free_entp >= &dec_codetab[CSIZE])\n        {\n            /* At that point, the next valid states are either EOI or a */\n            /* CODE_CLEAR. If a regular code is read, at the next */\n            /* attempt at registering a new entry, we will error out */\n            /* due to setting free_entp before any valid code */\n            free_entp = dec_codetab - 1;\n        }\n    }\n    oldcodep = codep;\n    *op++ = (uint8_t)code;\n    occ--;\n    if (occ == 0)\n        goto after_loop;\n    goto begin;\n}\n\ncode_above_or_equal_to_258:\n{\n    /*\n     * Add the new entry to the code table.\n     */\n\n    if (codep >= free_entp)\n    {\n        if (codep != free_entp)\n            goto error_code;\n        free_entp->value = oldcodep->firstchar;\n    }\n    else\n    {\n        free_entp->value = codep->firstchar;\n    }\n    free_entp->repeated =\n        (bool)(oldcodep->repeated & (oldcodep->value == free_entp->value));\n    free_entp->next = oldcodep;\n\n    free_entp->firstchar = oldcodep->firstchar;\n    free_entp->length = oldcodep->length + 1;\n    if (++free_entp > maxcodep)\n    {\n        if (++nbits > BITS_MAX) /* should not happen for a conformant encoder */\n            nbits = BITS_MAX;\n        nbitsmask = MAXCODE(nbits);\n        maxcodep = dec_codetab + nbitsmask - 1;\n        if (free_entp >= &dec_codetab[CSIZE])\n        {\n            /* At that point, the next valid states are either EOI or a */\n            /* CODE_CLEAR. If a regular code is read, at the next */\n            /* attempt at registering a new entry, we will error out */\n            /* due to setting free_entp before any valid code */\n            free_entp = dec_codetab - 1;\n        }\n    }\n    oldcodep = codep;\n\n    /*\n     * Code maps to a string, copy string\n     * value to output (written in reverse).\n     */\n    /* tiny bit faster on x86_64 to store in unsigned short than int */\n    unsigned short len = codep->length;\n\n    if (len < 3) /* equivalent to len == 2 given all other conditions */\n    {\n        if (occ <= 2)\n        {\n            if (occ == 2)\n            {\n                memcpy(op, &(codep->firstchar), 2);\n                op += 2;\n                occ -= 2;\n                goto after_loop;\n            }\n            goto too_short_buffer;\n        }\n\n        memcpy(op, &(codep->firstchar), 2);\n        op += 2;\n        occ -= 2;\n        goto begin; /* we can save the comparison occ > 0 */\n    }\n\n    if (len == 3)\n    {\n        if (occ <= 3)\n        {\n            if (occ == 3)\n            {\n                op[0] = codep->firstchar;\n                op[1] = codep->next->value;\n                op[2] = codep->value;\n                op += 3;\n                occ -= 3;\n                goto after_loop;\n            }\n            goto too_short_buffer;\n        }\n\n        op[0] = codep->firstchar;\n        op[1] = codep->next->value;\n        op[2] = codep->value;\n        op += 3;\n        occ -= 3;\n        goto begin; /* we can save the comparison occ > 0 */\n    }\n\n    if (len > occ)\n    {\n        goto too_short_buffer;\n    }\n\n    if (codep->repeated)\n    {\n        memset(op, codep->value, len);\n        op += len;\n        occ -= len;\n        if (occ == 0)\n            goto after_loop;\n        goto begin;\n    }\n\n    uint8_t *tp = op + len;\n\n    assert(len >= 4);\n\n    *--tp = codep->value;\n    codep = codep->next;\n    *--tp = codep->value;\n    codep = codep->next;\n    *--tp = codep->value;\n    codep = codep->next;\n    *--tp = codep->value;\n    if (tp > op)\n    {\n        do\n        {\n            codep = codep->next;\n            *--tp = codep->value;\n        } while (tp > op);\n    }\n\n    assert(occ >= len);\n    op += len;\n    occ -= len;\n    if (occ == 0)\n        goto after_loop;\n    goto begin;\n}\n\ncode_clear:\n{\n    free_entp = dec_codetab + CODE_FIRST;\n    nbits = BITS_MIN;\n    nbitsmask = MAXCODE(BITS_MIN);\n    maxcodep = dec_codetab + nbitsmask - 1;\n    do\n    {\n        GetNextCodeLZW();\n    } while (code == CODE_CLEAR); /* consecutive CODE_CLEAR codes */\n    if (code == CODE_EOI)\n        goto after_loop;\n    if (code > CODE_EOI)\n    {\n        goto error_code;\n    }\n    *op++ = (uint8_t)code;\n    occ--;\n    oldcodep = dec_codetab + code;\n    if (occ == 0)\n        goto after_loop;\n    goto begin;\n}\n}\n\ntoo_short_buffer:\n{\n    /*\n     * String is too long for decode buffer,\n     * locate portion that will fit, copy to\n     * the decode buffer, and setup restart\n     * logic for the next decoding call.\n     */\n    sp->dec_codep = codep;\n    do\n    {\n        codep = codep->next;\n    } while (codep->length > occ);\n\n    sp->dec_restart = occ;\n    uint8_t *tp = op + occ;\n    do\n    {\n        *--tp = codep->value;\n        codep = codep->next;\n    } while (--occ);\n}\n\nafter_loop:\n    tif->tif_rawcc -= (tmsize_t)((uint8_t *)bp - tif->tif_rawcp);\n    tif->tif_rawcp = (uint8_t *)bp;\n    sp->old_tif_rawcc = tif->tif_rawcc;\n    sp->dec_bitsleft = dec_bitsleft;\n    sp->lzw_nbits = (unsigned short)nbits;\n    sp->lzw_nextdata = nextdata;\n    sp->lzw_nextbits = nextbits;\n    sp->dec_nbitsmask = nbitsmask;\n    sp->dec_oldcodep = oldcodep;\n    sp->dec_free_entp = free_entp;\n    sp->dec_maxcodep = maxcodep;\n\n    if (occ > 0)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Not enough data at scanline %\" PRIu32 \" (short %\" PRIu64\n                      \" bytes)\",\n                      tif->tif_row, (uint64_t)occ);\n        return (0);\n    }\n    return (1);\n\nno_eoi:\n    sp->read_error = 1;\n    TIFFErrorExtR(tif, module,\n                  \"LZWDecode: Strip %\" PRIu32 \" not terminated with EOI code\",\n                  tif->tif_curstrip);\n    return 0;\nerror_code:\n    sp->read_error = 1;\n    TIFFErrorExtR(tif, tif->tif_name, \"Using code not yet in table\");\n    return 0;\n}\n\n#ifdef LZW_COMPAT\n\n/*\n * This check shouldn't be necessary because each\n * strip is suppose to be terminated with CODE_EOI.\n */\n#define NextCode(_tif, _sp, _bp, _code, _get, dec_bitsleft)                    \\\n    {                                                                          \\\n        if (dec_bitsleft < (uint64_t)nbits)                                    \\\n        {                                                                      \\\n            TIFFWarningExtR(_tif, module,                                      \\\n                            \"LZWDecode: Strip %\" PRIu32                        \\\n                            \" not terminated with EOI code\",                   \\\n                            _tif->tif_curstrip);                               \\\n            _code = CODE_EOI;                                                  \\\n        }                                                                      \\\n        else                                                                   \\\n        {                                                                      \\\n            _get(_sp, _bp, _code);                                             \\\n            dec_bitsleft -= nbits;                                             \\\n        }                                                                      \\\n    }\n\n/*\n * Decode a \"hunk of data\" for old images.\n */\n#define GetNextCodeCompat(sp, bp, code)                                        \\\n    {                                                                          \\\n        nextdata |= (unsigned long)*(bp)++ << nextbits;                        \\\n        nextbits += 8;                                                         \\\n        if (nextbits < nbits)                                                  \\\n        {                                                                      \\\n            nextdata |= (unsigned long)*(bp)++ << nextbits;                    \\\n            nextbits += 8;                                                     \\\n        }                                                                      \\\n        code = (hcode_t)(nextdata & nbitsmask);                                \\\n        nextdata >>= nbits;                                                    \\\n        nextbits -= nbits;                                                     \\\n    }\n\nstatic int LZWDecodeCompat(TIFF *tif, uint8_t *op0, tmsize_t occ0, uint16_t s)\n{\n    static const char module[] = \"LZWDecodeCompat\";\n    LZWCodecState *sp = DecoderState(tif);\n    uint8_t *op = (uint8_t *)op0;\n    tmsize_t occ = occ0;\n    uint8_t *tp;\n    uint8_t *bp;\n    int code, nbits;\n    int len;\n    long nextbits, nbitsmask;\n    WordType nextdata;\n    code_t *codep, *free_entp, *maxcodep, *oldcodep;\n\n    (void)s;\n    assert(sp != NULL);\n\n    /*\n     * Restart interrupted output operation.\n     */\n    if (sp->dec_restart)\n    {\n        tmsize_t residue;\n\n        codep = sp->dec_codep;\n        residue = codep->length - sp->dec_restart;\n        if (residue > occ)\n        {\n            /*\n             * Residue from previous decode is sufficient\n             * to satisfy decode request.  Skip to the\n             * start of the decoded string, place decoded\n             * values in the output buffer, and return.\n             */\n            sp->dec_restart += occ;\n            do\n            {\n                codep = codep->next;\n            } while (--residue > occ);\n            tp = op + occ;\n            do\n            {\n                *--tp = codep->value;\n                codep = codep->next;\n            } while (--occ);\n            return (1);\n        }\n        /*\n         * Residue satisfies only part of the decode request.\n         */\n        op += residue;\n        occ -= residue;\n        tp = op;\n        do\n        {\n            *--tp = codep->value;\n            codep = codep->next;\n        } while (--residue);\n        sp->dec_restart = 0;\n    }\n\n    bp = (uint8_t *)tif->tif_rawcp;\n\n    sp->dec_bitsleft += (((uint64_t)tif->tif_rawcc - sp->old_tif_rawcc) << 3);\n    uint64_t dec_bitsleft = sp->dec_bitsleft;\n\n    nbits = sp->lzw_nbits;\n    nextdata = sp->lzw_nextdata;\n    nextbits = sp->lzw_nextbits;\n    nbitsmask = sp->dec_nbitsmask;\n    oldcodep = sp->dec_oldcodep;\n    free_entp = sp->dec_free_entp;\n    maxcodep = sp->dec_maxcodep;\n\n    while (occ > 0)\n    {\n        NextCode(tif, sp, bp, code, GetNextCodeCompat, dec_bitsleft);\n        if (code == CODE_EOI)\n            break;\n        if (code == CODE_CLEAR)\n        {\n            do\n            {\n                free_entp = sp->dec_codetab + CODE_FIRST;\n                _TIFFmemset(free_entp, 0,\n                            (CSIZE - CODE_FIRST) * sizeof(code_t));\n                nbits = BITS_MIN;\n                nbitsmask = MAXCODE(BITS_MIN);\n                maxcodep = sp->dec_codetab + nbitsmask;\n                NextCode(tif, sp, bp, code, GetNextCodeCompat, dec_bitsleft);\n            } while (code == CODE_CLEAR); /* consecutive CODE_CLEAR codes */\n            if (code == CODE_EOI)\n                break;\n            if (code > CODE_CLEAR)\n            {\n                TIFFErrorExtR(\n                    tif, tif->tif_name,\n                    \"LZWDecode: Corrupted LZW table at scanline %\" PRIu32,\n                    tif->tif_row);\n                return (0);\n            }\n            *op++ = (uint8_t)code;\n            occ--;\n            oldcodep = sp->dec_codetab + code;\n            continue;\n        }\n        codep = sp->dec_codetab + code;\n\n        /*\n         * Add the new entry to the code table.\n         */\n        if (free_entp < &sp->dec_codetab[0] ||\n            free_entp >= &sp->dec_codetab[CSIZE])\n        {\n            TIFFErrorExtR(tif, module,\n                          \"Corrupted LZW table at scanline %\" PRIu32,\n                          tif->tif_row);\n            return (0);\n        }\n\n        free_entp->next = oldcodep;\n        if (free_entp->next < &sp->dec_codetab[0] ||\n            free_entp->next >= &sp->dec_codetab[CSIZE])\n        {\n            TIFFErrorExtR(tif, module,\n                          \"Corrupted LZW table at scanline %\" PRIu32,\n                          tif->tif_row);\n            return (0);\n        }\n        free_entp->firstchar = free_entp->next->firstchar;\n        free_entp->length = free_entp->next->length + 1;\n        free_entp->value =\n            (codep < free_entp) ? codep->firstchar : free_entp->firstchar;\n        if (++free_entp > maxcodep)\n        {\n            if (++nbits > BITS_MAX) /* should not happen */\n                nbits = BITS_MAX;\n            nbitsmask = MAXCODE(nbits);\n            maxcodep = sp->dec_codetab + nbitsmask;\n        }\n        oldcodep = codep;\n        if (code >= 256)\n        {\n            /*\n             * Code maps to a string, copy string\n             * value to output (written in reverse).\n             */\n            if (codep->length == 0)\n            {\n                TIFFErrorExtR(\n                    tif, module,\n                    \"Wrong length of decoded \"\n                    \"string: data probably corrupted at scanline %\" PRIu32,\n                    tif->tif_row);\n                return (0);\n            }\n            if (codep->length > occ)\n            {\n                /*\n                 * String is too long for decode buffer,\n                 * locate portion that will fit, copy to\n                 * the decode buffer, and setup restart\n                 * logic for the next decoding call.\n                 */\n                sp->dec_codep = codep;\n                do\n                {\n                    codep = codep->next;\n                } while (codep->length > occ);\n                sp->dec_restart = occ;\n                tp = op + occ;\n                do\n                {\n                    *--tp = codep->value;\n                    codep = codep->next;\n                } while (--occ);\n                break;\n            }\n            len = codep->length;\n            tp = op + len;\n            do\n            {\n                *--tp = codep->value;\n                codep = codep->next;\n            } while (codep && tp > op);\n            assert(occ >= len);\n            op += len;\n            occ -= len;\n        }\n        else\n        {\n            *op++ = (uint8_t)code;\n            occ--;\n        }\n    }\n\n    tif->tif_rawcc -= (tmsize_t)((uint8_t *)bp - tif->tif_rawcp);\n    tif->tif_rawcp = (uint8_t *)bp;\n\n    sp->old_tif_rawcc = tif->tif_rawcc;\n    sp->dec_bitsleft = dec_bitsleft;\n\n    sp->lzw_nbits = (unsigned short)nbits;\n    sp->lzw_nextdata = nextdata;\n    sp->lzw_nextbits = nextbits;\n    sp->dec_nbitsmask = nbitsmask;\n    sp->dec_oldcodep = oldcodep;\n    sp->dec_free_entp = free_entp;\n    sp->dec_maxcodep = maxcodep;\n\n    if (occ > 0)\n    {\n        TIFFErrorExtR(tif, module,\n                      \"Not enough data at scanline %\" PRIu32 \" (short %\" PRIu64\n                      \" bytes)\",\n                      tif->tif_row, (uint64_t)occ);\n        return (0);\n    }\n    return (1);\n}\n#endif /* LZW_COMPAT */\n\n/*\n * LZW Encoding.\n */\n\nstatic int LZWSetupEncode(TIFF *tif)\n{\n    static const char module[] = \"LZWSetupEncode\";\n    LZWCodecState *sp = EncoderState(tif);\n\n    assert(sp != NULL);\n    sp->enc_hashtab = (hash_t *)_TIFFmallocExt(tif, HSIZE * sizeof(hash_t));\n    if (sp->enc_hashtab == NULL)\n    {\n        TIFFErrorExtR(tif, module, \"No space for LZW hash table\");\n        return (0);\n    }\n    return (1);\n}\n\n/*\n * Reset encoding state at the start of a strip.\n */\nstatic int LZWPreEncode(TIFF *tif, uint16_t s)\n{\n    LZWCodecState *sp = EncoderState(tif);\n\n    (void)s;\n    assert(sp != NULL);\n\n    if (sp->enc_hashtab == NULL)\n    {\n        tif->tif_setupencode(tif);\n    }\n\n    sp->lzw_nbits = BITS_MIN;\n    sp->lzw_maxcode = MAXCODE(BITS_MIN);\n    sp->lzw_free_ent = CODE_FIRST;\n    sp->lzw_nextbits = 0;\n    sp->lzw_nextdata = 0;\n    sp->enc_checkpoint = CHECK_GAP;\n    sp->enc_ratio = 0;\n    sp->enc_incount = 0;\n    sp->enc_outcount = 0;\n    /*\n     * The 4 here insures there is space for 2 max-sized\n     * codes in LZWEncode and LZWPostDecode.\n     */\n    sp->enc_rawlimit = tif->tif_rawdata + tif->tif_rawdatasize - 1 - 4;\n    cl_hash(sp);                   /* clear hash table */\n    sp->enc_oldcode = (hcode_t)-1; /* generates CODE_CLEAR in LZWEncode */\n    return (1);\n}\n\n#define CALCRATIO(sp, rat)                                                     \\\n    {                                                                          \\\n        if (incount > 0x007fffff)                                              \\\n        { /* NB: shift will overflow */                                        \\\n            rat = outcount >> 8;                                               \\\n            rat = (rat == 0 ? 0x7fffffff : incount / rat);                     \\\n        }                                                                      \\\n        else                                                                   \\\n            rat = (incount << 8) / outcount;                                   \\\n    }\n\n/* Explicit 0xff masking to make icc -check=conversions happy */\n#define PutNextCode(op, c)                                                     \\\n    {                                                                          \\\n        nextdata = (nextdata << nbits) | c;                                    \\\n        nextbits += nbits;                                                     \\\n        *op++ = (unsigned char)((nextdata >> (nextbits - 8)) & 0xff);          \\\n        nextbits -= 8;                                                         \\\n        if (nextbits >= 8)                                                     \\\n        {                                                                      \\\n            *op++ = (unsigned char)((nextdata >> (nextbits - 8)) & 0xff);      \\\n            nextbits -= 8;                                                     \\\n        }                                                                      \\\n        outcount += nbits;                                                     \\\n    }\n\n/*\n * Encode a chunk of pixels.\n *\n * Uses an open addressing double hashing (no chaining) on the\n * prefix code/next character combination.  We do a variant of\n * Knuth's algorithm D (vol. 3, sec. 6.4) along with G. Knott's\n * relatively-prime secondary probe.  Here, the modular division\n * first probe is gives way to a faster exclusive-or manipulation.\n * Also do block compression with an adaptive reset, whereby the\n * code table is cleared when the compression ratio decreases,\n * but after the table fills.  The variable-length output codes\n * are re-sized at this point, and a CODE_CLEAR is generated\n * for the decoder.\n */\nstatic int LZWEncode(TIFF *tif, uint8_t *bp, tmsize_t cc, uint16_t s)\n{\n    register LZWCodecState *sp = EncoderState(tif);\n    register long fcode;\n    register hash_t *hp;\n    register int h, c;\n    hcode_t ent;\n    long disp;\n    tmsize_t incount, outcount, checkpoint;\n    WordType nextdata;\n    long nextbits;\n    int free_ent, maxcode, nbits;\n    uint8_t *op;\n    uint8_t *limit;\n\n    (void)s;\n    if (sp == NULL)\n        return (0);\n\n    assert(sp->enc_hashtab != NULL);\n\n    /*\n     * Load local state.\n     */\n    incount = sp->enc_incount;\n    outcount = sp->enc_outcount;\n    checkpoint = sp->enc_checkpoint;\n    nextdata = sp->lzw_nextdata;\n    nextbits = sp->lzw_nextbits;\n    free_ent = sp->lzw_free_ent;\n    maxcode = sp->lzw_maxcode;\n    nbits = sp->lzw_nbits;\n    op = tif->tif_rawcp;\n    limit = sp->enc_rawlimit;\n    ent = (hcode_t)sp->enc_oldcode;\n\n    if (ent == (hcode_t)-1 && cc > 0)\n    {\n        /*\n         * NB: This is safe because it can only happen\n         *     at the start of a strip where we know there\n         *     is space in the data buffer.\n         */\n        PutNextCode(op, CODE_CLEAR);\n        ent = *bp++;\n        cc--;\n        incount++;\n    }\n    while (cc > 0)\n    {\n        c = *bp++;\n        cc--;\n        incount++;\n        fcode = ((long)c << BITS_MAX) + ent;\n        h = (c << HSHIFT) ^ ent; /* xor hashing */\n#ifdef _WINDOWS\n        /*\n         * Check hash index for an overflow.\n         */\n        if (h >= HSIZE)\n            h -= HSIZE;\n#endif\n        hp = &sp->enc_hashtab[h];\n        if (hp->hash == fcode)\n        {\n            ent = hp->code;\n            continue;\n        }\n        if (hp->hash >= 0)\n        {\n            /*\n             * Primary hash failed, check secondary hash.\n             */\n            disp = HSIZE - h;\n            if (h == 0)\n                disp = 1;\n            do\n            {\n                /*\n                 * Avoid pointer arithmetic because of\n                 * wraparound problems with segments.\n                 */\n                if ((h -= disp) < 0)\n                    h += HSIZE;\n                hp = &sp->enc_hashtab[h];\n                if (hp->hash == fcode)\n                {\n                    ent = hp->code;\n                    goto hit;\n                }\n            } while (hp->hash >= 0);\n        }\n        /*\n         * New entry, emit code and add to table.\n         */\n        /*\n         * Verify there is space in the buffer for the code\n         * and any potential Clear code that might be emitted\n         * below.  The value of limit is setup so that there\n         * are at least 4 bytes free--room for 2 codes.\n         */\n        if (op > limit)\n        {\n            tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\n            if (!TIFFFlushData1(tif))\n                return 0;\n            op = tif->tif_rawdata;\n        }\n        PutNextCode(op, ent);\n        ent = (hcode_t)c;\n        hp->code = (hcode_t)(free_ent++);\n        hp->hash = fcode;\n        if (free_ent == CODE_MAX - 1)\n        {\n            /* table is full, emit clear code and reset */\n            cl_hash(sp);\n            sp->enc_ratio = 0;\n            incount = 0;\n            outcount = 0;\n            free_ent = CODE_FIRST;\n            PutNextCode(op, CODE_CLEAR);\n            nbits = BITS_MIN;\n            maxcode = MAXCODE(BITS_MIN);\n        }\n        else\n        {\n            /*\n             * If the next entry is going to be too big for\n             * the code size, then increase it, if possible.\n             */\n            if (free_ent > maxcode)\n            {\n                nbits++;\n                assert(nbits <= BITS_MAX);\n                maxcode = (int)MAXCODE(nbits);\n            }\n            else if (incount >= checkpoint)\n            {\n                tmsize_t rat;\n                /*\n                 * Check compression ratio and, if things seem\n                 * to be slipping, clear the hash table and\n                 * reset state.  The compression ratio is a\n                 * 24+8-bit fractional number.\n                 */\n                checkpoint = incount + CHECK_GAP;\n                CALCRATIO(sp, rat);\n                if (rat <= sp->enc_ratio)\n                {\n                    cl_hash(sp);\n                    sp->enc_ratio = 0;\n                    incount = 0;\n                    outcount = 0;\n                    free_ent = CODE_FIRST;\n                    PutNextCode(op, CODE_CLEAR);\n                    nbits = BITS_MIN;\n                    maxcode = MAXCODE(BITS_MIN);\n                }\n                else\n                    sp->enc_ratio = rat;\n            }\n        }\n    hit:;\n    }\n\n    /*\n     * Restore global state.\n     */\n    sp->enc_incount = incount;\n    sp->enc_outcount = outcount;\n    sp->enc_checkpoint = checkpoint;\n    sp->enc_oldcode = ent;\n    sp->lzw_nextdata = nextdata;\n    sp->lzw_nextbits = nextbits;\n    sp->lzw_free_ent = (unsigned short)free_ent;\n    sp->lzw_maxcode = (unsigned short)maxcode;\n    sp->lzw_nbits = (unsigned short)nbits;\n    tif->tif_rawcp = op;\n    return (1);\n}\n\n/*\n * Finish off an encoded strip by flushing the last\n * string and tacking on an End Of Information code.\n */\nstatic int LZWPostEncode(TIFF *tif)\n{\n    register LZWCodecState *sp = EncoderState(tif);\n    uint8_t *op = tif->tif_rawcp;\n    long nextbits = sp->lzw_nextbits;\n    WordType nextdata = sp->lzw_nextdata;\n    tmsize_t outcount = sp->enc_outcount;\n    int nbits = sp->lzw_nbits;\n\n    if (op > sp->enc_rawlimit)\n    {\n        tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\n        if (!TIFFFlushData1(tif))\n            return 0;\n        op = tif->tif_rawdata;\n    }\n    if (sp->enc_oldcode != (hcode_t)-1)\n    {\n        int free_ent = sp->lzw_free_ent;\n\n        PutNextCode(op, sp->enc_oldcode);\n        sp->enc_oldcode = (hcode_t)-1;\n        free_ent++;\n\n        if (free_ent == CODE_MAX - 1)\n        {\n            /* table is full, emit clear code and reset */\n            outcount = 0;\n            PutNextCode(op, CODE_CLEAR);\n            nbits = BITS_MIN;\n        }\n        else\n        {\n            /*\n             * If the next entry is going to be too big for\n             * the code size, then increase it, if possible.\n             */\n            if (free_ent > sp->lzw_maxcode)\n            {\n                nbits++;\n                assert(nbits <= BITS_MAX);\n            }\n        }\n    }\n    PutNextCode(op, CODE_EOI);\n    /* Explicit 0xff masking to make icc -check=conversions happy */\n    if (nextbits > 0)\n        *op++ = (unsigned char)((nextdata << (8 - nextbits)) & 0xff);\n    tif->tif_rawcc = (tmsize_t)(op - tif->tif_rawdata);\n    (void)outcount;\n    return (1);\n}\n\n/*\n * Reset encoding hash table.\n */\nstatic void cl_hash(LZWCodecState *sp)\n{\n    register hash_t *hp = &sp->enc_hashtab[HSIZE - 1];\n    register long i = HSIZE - 8;\n\n    do\n    {\n        i -= 8;\n        hp[-7].hash = -1;\n        hp[-6].hash = -1;\n        hp[-5].hash = -1;\n        hp[-4].hash = -1;\n        hp[-3].hash = -1;\n        hp[-2].hash = -1;\n        hp[-1].hash = -1;\n        hp[0].hash = -1;\n        hp -= 8;\n    } while (i >= 0);\n    for (i += 8; i > 0; i--, hp--)\n        hp->hash = -1;\n}\n\nstatic void LZWCleanup(TIFF *tif)\n{\n    (void)TIFFPredictorCleanup(tif);\n\n    assert(tif->tif_data != 0);\n\n    if (DecoderState(tif)->dec_codetab)\n        _TIFFfreeExt(tif, DecoderState(tif)->dec_codetab);\n\n    if (EncoderState(tif)->enc_hashtab)\n        _TIFFfreeExt(tif, EncoderState(tif)->enc_hashtab);\n\n    _TIFFfreeExt(tif, tif->tif_data);\n    tif->tif_data = NULL;\n\n    _TIFFSetDefaultCompressionState(tif);\n}\n\nint TIFFInitLZW(TIFF *tif, int scheme)\n{\n    static const char module[] = \"TIFFInitLZW\";\n    (void)scheme;\n    assert(scheme == COMPRESSION_LZW);\n    /*\n     * Allocate state block so tag methods have storage to record values.\n     */\n    tif->tif_data = (uint8_t *)_TIFFmallocExt(tif, sizeof(LZWCodecState));\n    if (tif->tif_data == NULL)\n        goto bad;\n    DecoderState(tif)->dec_codetab = NULL;\n    DecoderState(tif)->dec_decode = NULL;\n    EncoderState(tif)->enc_hashtab = NULL;\n    LZWState(tif)->rw_mode = tif->tif_mode;\n\n    /*\n     * Install codec methods.\n     */\n    tif->tif_fixuptags = LZWFixupTags;\n    tif->tif_setupdecode = LZWSetupDecode;\n    tif->tif_predecode = LZWPreDecode;\n    tif->tif_decoderow = LZWDecode;\n    tif->tif_decodestrip = LZWDecode;\n    tif->tif_decodetile = LZWDecode;\n    tif->tif_setupencode = LZWSetupEncode;\n    tif->tif_preencode = LZWPreEncode;\n    tif->tif_postencode = LZWPostEncode;\n    tif->tif_encoderow = LZWEncode;\n    tif->tif_encodestrip = LZWEncode;\n    tif->tif_encodetile = LZWEncode;\n    tif->tif_cleanup = LZWCleanup;\n    /*\n     * Setup predictor setup.\n     */\n    (void)TIFFPredictorInit(tif);\n    return (1);\nbad:\n    TIFFErrorExtR(tif, module, \"No space for LZW state block\");\n    return (0);\n}\n\n/*\n * Copyright (c) 1985, 1986 The Regents of the University of California.\n * All rights reserved.\n *\n * This code is derived from software contributed to Berkeley by\n * James A. Woods, derived from original work by Spencer Thomas\n * and Joseph Orost.\n *\n * Redistribution and use in source and binary forms are permitted\n * provided that the above copyright notice and this paragraph are\n * duplicated in all such forms and that any documentation,\n * advertising materials, and other materials related to such\n * distribution and use acknowledge that the software was developed\n * by the University of California, Berkeley.  The name of the\n * University may not be used to endorse or promote products derived\n * from this software without specific prior written permission.\n * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.\n */\n#endif /* LZW_SUPPORT */\n"], "filenames": ["libtiff/tif_lzw.c"], "buggy_code_start_loc": [425], "buggy_code_end_loc": [744], "fixing_code_start_loc": [426], "fixing_code_end_loc": [750], "type": "CWE-476", "message": "A NULL pointer dereference flaw was found in Libtiff's LZWDecode() function in the libtiff/tif_lzw.c file. This flaw allows a local attacker to craft specific input data that can cause the program to dereference a NULL pointer when decompressing a TIFF format file, resulting in a program crash or denial of service.", "other": {"cve": {"id": "CVE-2023-2731", "sourceIdentifier": "secalert@redhat.com", "published": "2023-05-17T22:15:11.047", "lastModified": "2023-05-25T17:17:07.247", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A NULL pointer dereference flaw was found in Libtiff's LZWDecode() function in the libtiff/tif_lzw.c file. This flaw allows a local attacker to craft specific input data that can cause the program to dereference a NULL pointer when decompressing a TIFF format file, resulting in a program crash or denial of service."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libtiff:libtiff:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.5.0", "matchCriteriaId": "A16AFDD6-3B2B-4DC9-876E-9D53B126201C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2023-2731", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2207635", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/libsdl-org/libtiff/commit/9be22b639ea69e102d3847dca4c53ef025e9527b", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://gitlab.com/libtiff/libtiff/-/issues/548", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/libsdl-org/libtiff/commit/9be22b639ea69e102d3847dca4c53ef025e9527b"}}