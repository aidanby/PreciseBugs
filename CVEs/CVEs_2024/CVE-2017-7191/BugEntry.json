{"buggy_code": ["/*\n fe-netjoin.c : irssi\n\n    Copyright (C) 2000 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include \"module-formats.h\"\n#include \"signals.h\"\n#include \"levels.h\"\n#include \"misc.h\"\n#include \"settings.h\"\n\n#include \"irc-servers.h\"\n#include \"modes.h\"\n#include \"ignore.h\"\n#include \"netsplit.h\"\n\n#include \"printtext.h\"\n\n#define NETJOIN_WAIT_TIME 5 /* how many seconds to wait for the netsplitted JOIN messages to stop */\n#define NETJOIN_MAX_WAIT 30 /* how many seconds to wait for nick to join to the rest of the channels she was before the netsplit */\n\ntypedef struct {\n\tchar *nick;\n\tGSList *old_channels;\n\tGSList *now_channels;\n} NETJOIN_REC;\n\ntypedef struct {\n\tIRC_SERVER_REC *server;\n\ttime_t last_netjoin;\n\n\tGSList *netjoins;\n} NETJOIN_SERVER_REC;\n\ntypedef struct {\n\tint count;\n        GString *nicks;\n} TEMP_PRINT_REC;\n\nstatic int join_tag;\nstatic int netjoin_max_nicks, hide_netsplit_quits;\nstatic int printing_joins;\nstatic GSList *joinservers;\n\nstatic NETJOIN_SERVER_REC *netjoin_find_server(IRC_SERVER_REC *server)\n{\n\tGSList *tmp;\n\n\tg_return_val_if_fail(server != NULL, NULL);\n\n\tfor (tmp = joinservers; tmp != NULL; tmp = tmp->next) {\n\t\tNETJOIN_SERVER_REC *rec = tmp->data;\n\n\t\tif (rec->server == server)\n                        return rec;\n\t}\n\n\treturn NULL;\n}\n\nstatic NETJOIN_REC *netjoin_add(IRC_SERVER_REC *server, const char *nick,\n\t\t\t\tGSList *channels)\n{\n\tNETJOIN_REC *rec;\n\tNETJOIN_SERVER_REC *srec;\n\n\tg_return_val_if_fail(server != NULL, NULL);\n\tg_return_val_if_fail(nick != NULL, NULL);\n\n\trec = g_new0(NETJOIN_REC, 1);\n\trec->nick = g_strdup(nick);\n\twhile (channels != NULL) {\n\t\tNETSPLIT_CHAN_REC *channel = channels->data;\n\n\t\trec->old_channels = g_slist_append(rec->old_channels,\n\t\t\t\t\t\t   g_strdup(channel->name));\n\t\tchannels = channels->next;\n\t}\n\n\tsrec = netjoin_find_server(server);\n\tif (srec == NULL) {\n\t\tsrec = g_new0(NETJOIN_SERVER_REC, 1);\n\t\tsrec->server = server;\n                joinservers = g_slist_append(joinservers, srec);\n\t}\n\n\tsrec->last_netjoin = time(NULL);\n\tsrec->netjoins = g_slist_append(srec->netjoins, rec);\n\treturn rec;\n}\n\nstatic NETJOIN_REC *netjoin_find(IRC_SERVER_REC *server, const char *nick)\n{\n\tNETJOIN_SERVER_REC *srec;\n\tGSList *tmp;\n\n\tg_return_val_if_fail(server != NULL, NULL);\n\tg_return_val_if_fail(nick != NULL, NULL);\n\n\tsrec = netjoin_find_server(server);\n        if (srec == NULL) return NULL;\n\n\tfor (tmp = srec->netjoins; tmp != NULL; tmp = tmp->next) {\n\t\tNETJOIN_REC *rec = tmp->data;\n\n\t\tif (g_ascii_strcasecmp(rec->nick, nick) == 0)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}\n\nstatic void netjoin_remove(NETJOIN_SERVER_REC *server, NETJOIN_REC *rec)\n{\n\tserver->netjoins = g_slist_remove(server->netjoins, rec);\n\n        g_slist_foreach(rec->old_channels, (GFunc) g_free, NULL);\n\tg_slist_foreach(rec->now_channels, (GFunc) g_free, NULL);\n\tg_slist_free(rec->old_channels);\n\tg_slist_free(rec->now_channels);\n\n\tg_free(rec->nick);\n\tg_free(rec);\n}\n\nstatic void netjoin_server_remove(NETJOIN_SERVER_REC *server)\n{\n\tjoinservers = g_slist_remove(joinservers, server);\n\n\twhile (server->netjoins != NULL)\n\t\tnetjoin_remove(server, server->netjoins->data);\n        g_free(server);\n}\n\nstatic void print_channel_netjoins(char *channel, TEMP_PRINT_REC *rec,\n\t\t\t\t   NETJOIN_SERVER_REC *server)\n{\n\tif (rec->nicks->len > 0)\n\t\tg_string_truncate(rec->nicks, rec->nicks->len-2);\n\n\tprintformat(server->server, channel, MSGLEVEL_JOINS,\n\t\t    rec->count > netjoin_max_nicks ?\n\t\t    IRCTXT_NETSPLIT_JOIN_MORE : IRCTXT_NETSPLIT_JOIN,\n\t\t    rec->nicks->str, rec->count-netjoin_max_nicks);\n\n\tg_string_free(rec->nicks, TRUE);\n\tg_free(rec);\n\tg_free(channel);\n}\n\nstatic void print_netjoins(NETJOIN_SERVER_REC *server, const char *filter_channel)\n{\n\tTEMP_PRINT_REC *temp;\n\tGHashTable *channels;\n\tGSList *tmp, *tmp2, *next, *next2, *old;\n\n\tg_return_if_fail(server != NULL);\n\n\tprinting_joins = TRUE;\n\n\t/* save nicks to string, clear now_channels and remove the same\n\t   channels from old_channels list */\n\tchannels = g_hash_table_new((GHashFunc) g_istr_hash,\n\t\t\t\t    (GCompareFunc) g_istr_equal);\n\tfor (tmp = server->netjoins; tmp != NULL; tmp = next) {\n\t\tNETJOIN_REC *rec = tmp->data;\n\n\t\tnext = g_slist_next(tmp);\n\n\t\tfor (tmp2 = rec->now_channels; tmp2 != NULL; tmp2 = next2) {\n\t\t\tchar *channel = tmp2->data;\n\t\t\tchar *realchannel = channel + 1;\n\n\t\t\tnext2 = g_slist_next(tmp2);\n\n\t\t\t/* Filter the results by channel if asked to do so */\n\t\t\tif (filter_channel != NULL &&\n\t\t\t    strcasecmp(realchannel, filter_channel) != 0)\n\t\t\t\tcontinue;\n\n\t\t\ttemp = g_hash_table_lookup(channels, realchannel);\n\t\t\tif (temp == NULL) {\n\t\t\t\ttemp = g_new0(TEMP_PRINT_REC, 1);\n\t\t\t\ttemp->nicks = g_string_new(NULL);\n\t\t\t\tg_hash_table_insert(channels,\n\t\t\t\t\t\t    g_strdup(realchannel),\n\t\t\t\t\t\t    temp);\n\t\t\t}\n\n\t\t\ttemp->count++;\n\t\t\tif (temp->count <= netjoin_max_nicks) {\n\t\t\t\tif (*channel != ' ')\n\t\t\t\t\tg_string_append_c(temp->nicks,\n\t\t\t\t\t\t\t  *channel);\n\t\t\t\tg_string_append_printf(temp->nicks, \"%s, \",\n\t\t\t\t\t\t  rec->nick);\n\t\t\t}\n\n\t\t\t/* remove the channel from old_channels too */\n\t\t\told = gslist_find_icase_string(rec->old_channels,\n\t\t\t\t\t\t       realchannel);\n\t\t\tif (old != NULL) {\n\t\t\t\tvoid *data = old->data;\n\t\t\t\trec->old_channels =\n\t\t\t\t\tg_slist_remove(rec->old_channels, data);\n\t\t\t\tg_free(data);\n\t\t\t}\n\n\t\t\t/* drop tmp2 from the list */\n\t\t\trec->now_channels = g_slist_delete_link(rec->now_channels, tmp2);\n\t\t\tg_free(channel);\n\t\t}\n\n\t\tif (rec->old_channels == NULL)\n                        netjoin_remove(server, rec);\n\t}\n\n\tg_hash_table_foreach(channels, (GHFunc) print_channel_netjoins,\n\t\t\t     server);\n\tg_hash_table_destroy(channels);\n\n\tif (server->netjoins == NULL)\n\t\tnetjoin_server_remove(server);\n\n\tprinting_joins = FALSE;\n}\n\n/* something is going to be printed to screen, print our current netsplit\n   message before it. */\nstatic void sig_print_starting(TEXT_DEST_REC *dest)\n{\n\tNETJOIN_SERVER_REC *rec;\n\n\tif (printing_joins)\n\t\treturn;\n\n\tif (!IS_IRC_SERVER(dest->server))\n\t\treturn;\n\n\tif (!(dest->level & MSGLEVEL_PUBLIC))\n\t\treturn;\n\n\tif (!server_ischannel(dest->server, dest->target))\n\t\treturn;\n\n\trec = netjoin_find_server(IRC_SERVER(dest->server));\n\tif (rec != NULL && rec->netjoins != NULL)\n\t\tprint_netjoins(rec, dest->target);\n}\n\nstatic int sig_check_netjoins(void)\n{\n\tGSList *tmp, *next;\n\tint diff;\n\ttime_t now;\n\n\tnow = time(NULL);\n\t/* first print all netjoins which haven't had any new joins\n\t * for NETJOIN_WAIT_TIME; this may cause them to be removed\n\t * (all users who rejoined, rejoined all channels) */\n\tfor (tmp = joinservers; tmp != NULL; tmp = next) {\n\t\tNETJOIN_SERVER_REC *server = tmp->data;\n\n\t\tnext = tmp->next;\n\t\tdiff = now-server->last_netjoin;\n\t\tif (diff <= NETJOIN_WAIT_TIME) {\n\t\t\t/* wait for more JOINs */\n\t\t\tcontinue;\n\t\t}\n\n                if (server->netjoins != NULL)\n\t\t\tprint_netjoins(server, NULL);\n\t}\n\n\t/* now remove all netjoins which haven't had any new joins\n\t * for NETJOIN_MAX_WAIT (user rejoined some but not all channels\n\t * after split) */\n\tfor (tmp = joinservers; tmp != NULL; tmp = next) {\n\t\tNETJOIN_SERVER_REC *server = tmp->data;\n\n\t\tnext = tmp->next;\n\t\tdiff = now-server->last_netjoin;\n\t\tif (diff >= NETJOIN_MAX_WAIT) {\n\t\t\t/* waited long enough, forget about the rest */\n                        netjoin_server_remove(server);\n\t\t}\n\t}\n\n\tif (joinservers == NULL) {\n\t\tg_source_remove(join_tag);\n\t\tsignal_remove(\"print starting\", (SIGNAL_FUNC) sig_print_starting);\n                join_tag = -1;\n\t}\n\treturn 1;\n}\n\nstatic void msg_quit(IRC_SERVER_REC *server, const char *nick,\n\t\t     const char *address, const char *reason)\n{\n\tif (IS_IRC_SERVER(server) && quitmsg_is_split(reason))\n\t\tsignal_stop();\n}\n\nstatic void msg_join(IRC_SERVER_REC *server, const char *channel,\n\t\t     const char *nick, const char *address)\n{\n\tNETSPLIT_REC *split;\n\tNETJOIN_REC *netjoin;\n\tGSList *channels;\n\tint rejoin = 1;\n\n\tif (!IS_IRC_SERVER(server))\n\t\treturn;\n\n\tif (ignore_check(SERVER(server), nick, address,\n\t\t\t channel, NULL, MSGLEVEL_JOINS))\n\t\treturn;\n\n\tsplit = netsplit_find(server, nick, address);\n\tnetjoin = netjoin_find(server, nick);\n\tif (split == NULL && netjoin == NULL)\n                return;\n\n\t/* if this was not a channel they split from, treat it normally */\n\tif (netjoin != NULL) {\n\t\tif (!gslist_find_icase_string(netjoin->old_channels, channel))\n\t\t\treturn;\n\t} else {\n\t\tchannels = split->channels;\n\t\twhile (channels != NULL) {\n\t\t\tNETSPLIT_CHAN_REC *schannel = channels->data;\n\n\t\t\tif (!strcasecmp(schannel->name, channel))\n\t\t\t\tbreak;\n\t\t\tchannels = channels->next;\n\t\t}\n\t\t/* we still need to create a NETJOIN_REC now as the\n\t\t * NETSPLIT_REC will be destroyed */\n\t\tif (channels == NULL)\n\t\t\trejoin = 0;\n\t}\n\n\tif (join_tag == -1) {\n\t\tjoin_tag = g_timeout_add(1000, (GSourceFunc)\n\t\t\t\t\t sig_check_netjoins, NULL);\n\t\tsignal_add(\"print starting\", (SIGNAL_FUNC) sig_print_starting);\n\t}\n\n\tif (netjoin == NULL)\n\t\tnetjoin = netjoin_add(server, nick, split->channels);\n\n\tif (rejoin)\n\t{\n\t\tnetjoin->now_channels = g_slist_append(netjoin->now_channels,\n\t\t\t\t\t\t       g_strconcat(\" \", channel, NULL));\n\t\tsignal_stop();\n\t}\n}\n\nstatic int netjoin_set_nickmode(IRC_SERVER_REC *server, NETJOIN_REC *rec,\n\t\t\t\tconst char *channel, char prefix)\n{\n\tGSList *pos;\n\tconst char *flags;\n\tchar *found_chan = NULL;\n\n\tfor (pos = rec->now_channels; pos != NULL; pos = pos->next) {\n\t\tchar *chan = pos->data;\n\t\tif (strcasecmp(chan+1, channel) == 0) {\n\t\t\tfound_chan = chan;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_chan == NULL)\n\t\treturn FALSE;\n\n\tflags = server->get_nick_flags(SERVER(server));\n\twhile (*flags != '\\0') {\n\t\tif (found_chan[0] == *flags)\n\t\t\tbreak;\n\t\tif (prefix == *flags) {\n\t\t\tfound_chan[0] = prefix;\n\t\t\tbreak;\n\t\t}\n\t\tflags++;\n\t}\n\treturn TRUE;\n}\n\nstatic void msg_mode(IRC_SERVER_REC *server, const char *channel,\n\t\t     const char *sender, const char *addr, const char *data)\n{\n\tNETJOIN_REC *rec;\n\tchar *params, *mode, *nicks;\n\tchar **nicklist, **nick, type, prefix;\n\tint show;\n\n\tg_return_if_fail(data != NULL);\n\tif (!server_ischannel(SERVER(server), channel) || addr != NULL)\n\t\treturn;\n\n\tparams = event_get_params(data, 2 | PARAM_FLAG_GETREST,\n\t\t\t\t  &mode, &nicks);\n\n\t/* parse server mode changes - hide operator status changes and\n\t   show them in the netjoin message instead as @ before the nick */\n\tnick = nicklist = g_strsplit(nicks, \" \", -1);\n\n\ttype = '+'; show = FALSE;\n\tfor (; *mode != '\\0'; mode++) {\n\t\tif (*mode == '+' || *mode == '-') {\n\t\t\ttype = *mode;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*nick != NULL && GET_MODE_PREFIX(server, *mode)) {\n                        /* give/remove ops */\n\t\t\trec = netjoin_find(server, *nick);\n\t\t\tprefix = GET_MODE_PREFIX(server, *mode);\n\t\t\tif (rec == NULL || type != '+' || prefix == '\\0' ||\n\t\t\t    !netjoin_set_nickmode(server, rec, channel, prefix))\n\t\t\t\tshow = TRUE;\n                        nick++;\n\t\t} else {\n\t\t\tif (HAS_MODE_ARG(server, type, *mode) && *nick != NULL)\n\t\t\t\tnick++;\n\t\t\tshow = TRUE;\n\t\t}\n\t}\n\n\tif (!show) signal_stop();\n\n\tg_strfreev(nicklist);\n\tg_free(params);\n}\n\nstatic void read_settings(void)\n{\n\tint old_hide;\n\n        old_hide = hide_netsplit_quits;\n\thide_netsplit_quits = settings_get_bool(\"hide_netsplit_quits\");\n\tnetjoin_max_nicks = settings_get_int(\"netjoin_max_nicks\");\n\n\tif (old_hide && !hide_netsplit_quits) {\n\t\tsignal_remove(\"message quit\", (SIGNAL_FUNC) msg_quit);\n\t\tsignal_remove(\"message join\", (SIGNAL_FUNC) msg_join);\n\t\tsignal_remove(\"message irc mode\", (SIGNAL_FUNC) msg_mode);\n\t} else if (!old_hide && hide_netsplit_quits) {\n\t\tsignal_add(\"message quit\", (SIGNAL_FUNC) msg_quit);\n\t\tsignal_add(\"message join\", (SIGNAL_FUNC) msg_join);\n\t\tsignal_add(\"message irc mode\", (SIGNAL_FUNC) msg_mode);\n\t}\n}\n\nvoid fe_netjoin_init(void)\n{\n\tsettings_add_bool(\"misc\", \"hide_netsplit_quits\", TRUE);\n\tsettings_add_int(\"misc\", \"netjoin_max_nicks\", 10);\n\n\tjoin_tag = -1;\n\tprinting_joins = FALSE;\n\n\tread_settings();\n\tsignal_add(\"setup changed\", (SIGNAL_FUNC) read_settings);\n}\n\nvoid fe_netjoin_deinit(void)\n{\n\twhile (joinservers != NULL)\n\t\tnetjoin_server_remove(joinservers->data);\n\tif (join_tag != -1) {\n\t\tg_source_remove(join_tag);\n\t\tsignal_remove(\"print starting\", (SIGNAL_FUNC) sig_print_starting);\n\t}\n\n\tsignal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);\n\n\tsignal_remove(\"message quit\", (SIGNAL_FUNC) msg_quit);\n\tsignal_remove(\"message join\", (SIGNAL_FUNC) msg_join);\n\tsignal_remove(\"message irc mode\", (SIGNAL_FUNC) msg_mode);\n}\n"], "fixing_code": ["/*\n fe-netjoin.c : irssi\n\n    Copyright (C) 2000 Timo Sirainen\n\n    This program is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\n\n#include \"module.h\"\n#include \"module-formats.h\"\n#include \"signals.h\"\n#include \"levels.h\"\n#include \"misc.h\"\n#include \"settings.h\"\n\n#include \"irc-servers.h\"\n#include \"modes.h\"\n#include \"ignore.h\"\n#include \"netsplit.h\"\n\n#include \"printtext.h\"\n\n#define NETJOIN_WAIT_TIME 5 /* how many seconds to wait for the netsplitted JOIN messages to stop */\n#define NETJOIN_MAX_WAIT 30 /* how many seconds to wait for nick to join to the rest of the channels she was before the netsplit */\n\ntypedef struct {\n\tchar *nick;\n\tGSList *old_channels;\n\tGSList *now_channels;\n} NETJOIN_REC;\n\ntypedef struct {\n\tIRC_SERVER_REC *server;\n\ttime_t last_netjoin;\n\n\tGSList *netjoins;\n} NETJOIN_SERVER_REC;\n\ntypedef struct {\n\tint count;\n        GString *nicks;\n} TEMP_PRINT_REC;\n\nstatic int join_tag;\nstatic int netjoin_max_nicks, hide_netsplit_quits;\nstatic int printing_joins;\nstatic GSList *joinservers;\n\nstatic NETJOIN_SERVER_REC *netjoin_find_server(IRC_SERVER_REC *server)\n{\n\tGSList *tmp;\n\n\tg_return_val_if_fail(server != NULL, NULL);\n\n\tfor (tmp = joinservers; tmp != NULL; tmp = tmp->next) {\n\t\tNETJOIN_SERVER_REC *rec = tmp->data;\n\n\t\tif (rec->server == server)\n                        return rec;\n\t}\n\n\treturn NULL;\n}\n\nstatic NETJOIN_REC *netjoin_add(IRC_SERVER_REC *server, const char *nick,\n\t\t\t\tGSList *channels)\n{\n\tNETJOIN_REC *rec;\n\tNETJOIN_SERVER_REC *srec;\n\n\tg_return_val_if_fail(server != NULL, NULL);\n\tg_return_val_if_fail(nick != NULL, NULL);\n\n\trec = g_new0(NETJOIN_REC, 1);\n\trec->nick = g_strdup(nick);\n\twhile (channels != NULL) {\n\t\tNETSPLIT_CHAN_REC *channel = channels->data;\n\n\t\trec->old_channels = g_slist_append(rec->old_channels,\n\t\t\t\t\t\t   g_strdup(channel->name));\n\t\tchannels = channels->next;\n\t}\n\n\tsrec = netjoin_find_server(server);\n\tif (srec == NULL) {\n\t\tsrec = g_new0(NETJOIN_SERVER_REC, 1);\n\t\tsrec->server = server;\n                joinservers = g_slist_append(joinservers, srec);\n\t}\n\n\tsrec->last_netjoin = time(NULL);\n\tsrec->netjoins = g_slist_append(srec->netjoins, rec);\n\treturn rec;\n}\n\nstatic NETJOIN_REC *netjoin_find(IRC_SERVER_REC *server, const char *nick)\n{\n\tNETJOIN_SERVER_REC *srec;\n\tGSList *tmp;\n\n\tg_return_val_if_fail(server != NULL, NULL);\n\tg_return_val_if_fail(nick != NULL, NULL);\n\n\tsrec = netjoin_find_server(server);\n        if (srec == NULL) return NULL;\n\n\tfor (tmp = srec->netjoins; tmp != NULL; tmp = tmp->next) {\n\t\tNETJOIN_REC *rec = tmp->data;\n\n\t\tif (g_ascii_strcasecmp(rec->nick, nick) == 0)\n\t\t\treturn rec;\n\t}\n\n\treturn NULL;\n}\n\nstatic void netjoin_remove(NETJOIN_SERVER_REC *server, NETJOIN_REC *rec)\n{\n\tserver->netjoins = g_slist_remove(server->netjoins, rec);\n\n        g_slist_foreach(rec->old_channels, (GFunc) g_free, NULL);\n\tg_slist_foreach(rec->now_channels, (GFunc) g_free, NULL);\n\tg_slist_free(rec->old_channels);\n\tg_slist_free(rec->now_channels);\n\n\tg_free(rec->nick);\n\tg_free(rec);\n}\n\nstatic void netjoin_server_remove(NETJOIN_SERVER_REC *server)\n{\n\tjoinservers = g_slist_remove(joinservers, server);\n\n\twhile (server->netjoins != NULL)\n\t\tnetjoin_remove(server, server->netjoins->data);\n        g_free(server);\n}\n\nstatic void print_channel_netjoins(char *channel, TEMP_PRINT_REC *rec,\n\t\t\t\t   NETJOIN_SERVER_REC *server)\n{\n\tif (rec->nicks->len > 0)\n\t\tg_string_truncate(rec->nicks, rec->nicks->len-2);\n\n\tprintformat(server->server, channel, MSGLEVEL_JOINS,\n\t\t    rec->count > netjoin_max_nicks ?\n\t\t    IRCTXT_NETSPLIT_JOIN_MORE : IRCTXT_NETSPLIT_JOIN,\n\t\t    rec->nicks->str, rec->count-netjoin_max_nicks);\n\n\tg_string_free(rec->nicks, TRUE);\n\tg_free(rec);\n\tg_free(channel);\n}\n\nstatic void print_netjoins(NETJOIN_SERVER_REC *server, const char *filter_channel)\n{\n\tTEMP_PRINT_REC *temp;\n\tGHashTable *channels;\n\tGSList *tmp, *tmp2, *next, *next2, *old;\n\n\tg_return_if_fail(server != NULL);\n\n\tprinting_joins = TRUE;\n\n\t/* save nicks to string, clear now_channels and remove the same\n\t   channels from old_channels list */\n\tchannels = g_hash_table_new((GHashFunc) g_istr_hash,\n\t\t\t\t    (GCompareFunc) g_istr_equal);\n\tfor (tmp = server->netjoins; tmp != NULL; tmp = next) {\n\t\tNETJOIN_REC *rec = tmp->data;\n\n\t\tnext = g_slist_next(tmp);\n\n\t\tfor (tmp2 = rec->now_channels; tmp2 != NULL; tmp2 = next2) {\n\t\t\tchar *channel = tmp2->data;\n\t\t\tchar *realchannel = channel + 1;\n\n\t\t\tnext2 = g_slist_next(tmp2);\n\n\t\t\t/* Filter the results by channel if asked to do so */\n\t\t\tif (filter_channel != NULL &&\n\t\t\t    strcasecmp(realchannel, filter_channel) != 0)\n\t\t\t\tcontinue;\n\n\t\t\ttemp = g_hash_table_lookup(channels, realchannel);\n\t\t\tif (temp == NULL) {\n\t\t\t\ttemp = g_new0(TEMP_PRINT_REC, 1);\n\t\t\t\ttemp->nicks = g_string_new(NULL);\n\t\t\t\tg_hash_table_insert(channels,\n\t\t\t\t\t\t    g_strdup(realchannel),\n\t\t\t\t\t\t    temp);\n\t\t\t}\n\n\t\t\ttemp->count++;\n\t\t\tif (temp->count <= netjoin_max_nicks) {\n\t\t\t\tif (*channel != ' ')\n\t\t\t\t\tg_string_append_c(temp->nicks,\n\t\t\t\t\t\t\t  *channel);\n\t\t\t\tg_string_append_printf(temp->nicks, \"%s, \",\n\t\t\t\t\t\t  rec->nick);\n\t\t\t}\n\n\t\t\t/* remove the channel from old_channels too */\n\t\t\told = gslist_find_icase_string(rec->old_channels,\n\t\t\t\t\t\t       realchannel);\n\t\t\tif (old != NULL) {\n\t\t\t\tvoid *data = old->data;\n\t\t\t\trec->old_channels =\n\t\t\t\t\tg_slist_remove(rec->old_channels, data);\n\t\t\t\tg_free(data);\n\t\t\t}\n\n\t\t\t/* drop tmp2 from the list */\n\t\t\trec->now_channels = g_slist_delete_link(rec->now_channels, tmp2);\n\t\t\tg_free(channel);\n\t\t}\n\n\t\tif (rec->old_channels == NULL)\n                        netjoin_remove(server, rec);\n\t}\n\n\tg_hash_table_foreach(channels, (GHFunc) print_channel_netjoins,\n\t\t\t     server);\n\tg_hash_table_destroy(channels);\n\n\tif (server->netjoins == NULL)\n\t\tnetjoin_server_remove(server);\n\n\tprinting_joins = FALSE;\n}\n\n/* something is going to be printed to screen, print our current netsplit\n   message before it. */\nstatic void sig_print_starting(TEXT_DEST_REC *dest)\n{\n\tNETJOIN_SERVER_REC *rec;\n\n\tif (printing_joins)\n\t\treturn;\n\n\tif (!IS_IRC_SERVER(dest->server))\n\t\treturn;\n\n\tif (!(dest->level & MSGLEVEL_PUBLIC))\n\t\treturn;\n\n\tif (!server_ischannel(dest->server, dest->target))\n\t\treturn;\n\n\trec = netjoin_find_server(IRC_SERVER(dest->server));\n\tif (rec != NULL && rec->netjoins != NULL)\n\t\tprint_netjoins(rec, dest->target);\n}\n\nstatic int sig_check_netjoins(void)\n{\n\tGSList *tmp, *next;\n\tint diff;\n\ttime_t now;\n\n\tnow = time(NULL);\n\t/* first print all netjoins which haven't had any new joins\n\t * for NETJOIN_WAIT_TIME; this may cause them to be removed\n\t * (all users who rejoined, rejoined all channels) */\n\tfor (tmp = joinservers; tmp != NULL; tmp = next) {\n\t\tNETJOIN_SERVER_REC *server = tmp->data;\n\n\t\tnext = tmp->next;\n\t\tdiff = now-server->last_netjoin;\n\t\tif (diff <= NETJOIN_WAIT_TIME) {\n\t\t\t/* wait for more JOINs */\n\t\t\tcontinue;\n\t\t}\n\n                if (server->netjoins != NULL)\n\t\t\tprint_netjoins(server, NULL);\n\t}\n\n\t/* now remove all netjoins which haven't had any new joins\n\t * for NETJOIN_MAX_WAIT (user rejoined some but not all channels\n\t * after split) */\n\tfor (tmp = joinservers; tmp != NULL; tmp = next) {\n\t\tNETJOIN_SERVER_REC *server = tmp->data;\n\n\t\tnext = tmp->next;\n\t\tdiff = now-server->last_netjoin;\n\t\tif (diff >= NETJOIN_MAX_WAIT) {\n\t\t\t/* waited long enough, forget about the rest */\n                        netjoin_server_remove(server);\n\t\t}\n\t}\n\n\tif (joinservers == NULL) {\n\t\tg_source_remove(join_tag);\n\t\tsignal_remove(\"print starting\", (SIGNAL_FUNC) sig_print_starting);\n                join_tag = -1;\n\t}\n\treturn 1;\n}\n\nstatic void msg_quit(IRC_SERVER_REC *server, const char *nick,\n\t\t     const char *address, const char *reason)\n{\n\tif (IS_IRC_SERVER(server) && quitmsg_is_split(reason))\n\t\tsignal_stop();\n}\n\nstatic void msg_join(IRC_SERVER_REC *server, const char *channel,\n\t\t     const char *nick, const char *address)\n{\n\tNETSPLIT_REC *split;\n\tNETJOIN_REC *netjoin;\n\tGSList *channels;\n\tint rejoin = 1;\n\n\tif (!IS_IRC_SERVER(server))\n\t\treturn;\n\n\tif (ignore_check(SERVER(server), nick, address,\n\t\t\t channel, NULL, MSGLEVEL_JOINS))\n\t\treturn;\n\n\tsplit = netsplit_find(server, nick, address);\n\tnetjoin = netjoin_find(server, nick);\n\tif (split == NULL && netjoin == NULL)\n                return;\n\n\t/* if this was not a channel they split from, treat it normally */\n\tif (netjoin != NULL) {\n\t\tif (!gslist_find_icase_string(netjoin->old_channels, channel))\n\t\t\treturn;\n\t} else {\n\t\tchannels = split->channels;\n\t\twhile (channels != NULL) {\n\t\t\tNETSPLIT_CHAN_REC *schannel = channels->data;\n\n\t\t\tif (!strcasecmp(schannel->name, channel))\n\t\t\t\tbreak;\n\t\t\tchannels = channels->next;\n\t\t}\n\t\t/* we still need to create a NETJOIN_REC now as the\n\t\t * NETSPLIT_REC will be destroyed */\n\t\tif (channels == NULL)\n\t\t\trejoin = 0;\n\t}\n\n\tif (join_tag == -1) {\n\t\tjoin_tag = g_timeout_add(1000, (GSourceFunc)\n\t\t\t\t\t sig_check_netjoins, NULL);\n\t\tsignal_add(\"print starting\", (SIGNAL_FUNC) sig_print_starting);\n\t}\n\n\tif (netjoin == NULL)\n\t\tnetjoin = netjoin_add(server, nick, split->channels);\n\n\tif (rejoin)\n\t{\n\t\tnetjoin->now_channels = g_slist_append(netjoin->now_channels,\n\t\t\t\t\t\t       g_strconcat(\" \", channel, NULL));\n\t\tsignal_stop();\n\t}\n}\n\nstatic int netjoin_set_nickmode(IRC_SERVER_REC *server, NETJOIN_REC *rec,\n\t\t\t\tconst char *channel, char prefix)\n{\n\tGSList *pos;\n\tconst char *flags;\n\tchar *found_chan = NULL;\n\n\tfor (pos = rec->now_channels; pos != NULL; pos = pos->next) {\n\t\tchar *chan = pos->data;\n\t\tif (strcasecmp(chan+1, channel) == 0) {\n\t\t\tfound_chan = chan;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found_chan == NULL)\n\t\treturn FALSE;\n\n\tflags = server->get_nick_flags(SERVER(server));\n\twhile (*flags != '\\0') {\n\t\tif (found_chan[0] == *flags)\n\t\t\tbreak;\n\t\tif (prefix == *flags) {\n\t\t\tfound_chan[0] = prefix;\n\t\t\tbreak;\n\t\t}\n\t\tflags++;\n\t}\n\treturn TRUE;\n}\n\nstatic void msg_mode(IRC_SERVER_REC *server, const char *channel,\n\t\t     const char *sender, const char *addr, const char *data)\n{\n\tNETJOIN_REC *rec;\n\tchar *params, *mode, *nicks;\n\tchar **nicklist, **nick, type, prefix;\n\tint show;\n\n\tg_return_if_fail(data != NULL);\n\tif (!server_ischannel(SERVER(server), channel) || addr != NULL)\n\t\treturn;\n\n\tparams = event_get_params(data, 2 | PARAM_FLAG_GETREST,\n\t\t\t\t  &mode, &nicks);\n\n\t/* parse server mode changes - hide operator status changes and\n\t   show them in the netjoin message instead as @ before the nick */\n\tnick = nicklist = g_strsplit(nicks, \" \", -1);\n\n\ttype = '+'; show = FALSE;\n\tfor (; *mode != '\\0'; mode++) {\n\t\tif (*mode == '+' || *mode == '-') {\n\t\t\ttype = *mode;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (*nick != NULL && GET_MODE_PREFIX(server, *mode)) {\n                        /* give/remove ops */\n\t\t\trec = netjoin_find(server, *nick);\n\t\t\tprefix = GET_MODE_PREFIX(server, *mode);\n\t\t\tif (rec == NULL || type != '+' || prefix == '\\0' ||\n\t\t\t    !netjoin_set_nickmode(server, rec, channel, prefix))\n\t\t\t\tshow = TRUE;\n                        nick++;\n\t\t} else {\n\t\t\tif (HAS_MODE_ARG(server, type, *mode) && *nick != NULL)\n\t\t\t\tnick++;\n\t\t\tshow = TRUE;\n\t\t}\n\t}\n\n\tif (!show) signal_stop();\n\n\tg_strfreev(nicklist);\n\tg_free(params);\n}\n\nstatic void read_settings(void)\n{\n\tint old_hide;\n\n        old_hide = hide_netsplit_quits;\n\thide_netsplit_quits = settings_get_bool(\"hide_netsplit_quits\");\n\tnetjoin_max_nicks = settings_get_int(\"netjoin_max_nicks\");\n\n\tif (old_hide && !hide_netsplit_quits) {\n\t\tsignal_remove(\"message quit\", (SIGNAL_FUNC) msg_quit);\n\t\tsignal_remove(\"message join\", (SIGNAL_FUNC) msg_join);\n\t\tsignal_remove(\"message irc mode\", (SIGNAL_FUNC) msg_mode);\n\t} else if (!old_hide && hide_netsplit_quits) {\n\t\tsignal_add(\"message quit\", (SIGNAL_FUNC) msg_quit);\n\t\tsignal_add(\"message join\", (SIGNAL_FUNC) msg_join);\n\t\tsignal_add(\"message irc mode\", (SIGNAL_FUNC) msg_mode);\n\t}\n}\n\nstatic void sig_server_disconnected(IRC_SERVER_REC *server)\n{\n\tNETJOIN_SERVER_REC *netjoin_server;\n\n\tg_return_if_fail(server != NULL);\n\n\tif (!IS_IRC_SERVER(server))\n\t\treturn;\n\n\tif ((netjoin_server = netjoin_find_server(server))) {\n\t\tnetjoin_server_remove(netjoin_server);\n\t}\n}\n\nvoid fe_netjoin_init(void)\n{\n\tsettings_add_bool(\"misc\", \"hide_netsplit_quits\", TRUE);\n\tsettings_add_int(\"misc\", \"netjoin_max_nicks\", 10);\n\n\tjoin_tag = -1;\n\tprinting_joins = FALSE;\n\n\tread_settings();\n\tsignal_add(\"setup changed\", (SIGNAL_FUNC) read_settings);\n\tsignal_add(\"server disconnected\", (SIGNAL_FUNC) sig_server_disconnected);\n}\n\nvoid fe_netjoin_deinit(void)\n{\n\twhile (joinservers != NULL)\n\t\tnetjoin_server_remove(joinservers->data);\n\tif (join_tag != -1) {\n\t\tg_source_remove(join_tag);\n\t\tsignal_remove(\"print starting\", (SIGNAL_FUNC) sig_print_starting);\n\t}\n\n\tsignal_remove(\"setup changed\", (SIGNAL_FUNC) read_settings);\n\tsignal_remove(\"server disconnected\", (SIGNAL_FUNC) sig_server_disconnected);\n\n\tsignal_remove(\"message quit\", (SIGNAL_FUNC) msg_quit);\n\tsignal_remove(\"message join\", (SIGNAL_FUNC) msg_join);\n\tsignal_remove(\"message irc mode\", (SIGNAL_FUNC) msg_mode);\n}\n"], "filenames": ["src/fe-common/irc/fe-netjoin.c"], "buggy_code_start_loc": [472], "buggy_code_end_loc": [494], "fixing_code_start_loc": [473], "fixing_code_end_loc": [511], "type": "CWE-416", "message": "The netjoin processing in Irssi 1.x before 1.0.2 allows attackers to cause a denial of service (use-after-free) and possibly execute arbitrary code via unspecified vectors.", "other": {"cve": {"id": "CVE-2017-7191", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-27T17:59:00.913", "lastModified": "2017-03-31T11:52:21.200", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The netjoin processing in Irssi 1.x before 1.0.2 allows attackers to cause a denial of service (use-after-free) and possibly execute arbitrary code via unspecified vectors."}, {"lang": "es", "value": "El procesamiento de netjoin en Irssi 1.x en versiones anteriores a 1.0.2 permite a atacantes provocar una denegaci\u00f3n de servicio (uso despu\u00e9s de liberaci\u00f3n de memoria) y posiblemente ejecutar c\u00f3digo arbitrario a trav\u00e9s de vectores no especificados."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:irssi:irssi:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.1", "matchCriteriaId": "13F6C09B-FD53-426E-AF05-F013B09CE5FD"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/97185", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/irssi/irssi/commit/77b2631c78461965bc9a7414aae206b5c514e1b3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://irssi.org/security/irssi_sa_2017_03.txt", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/irssi/irssi/commit/77b2631c78461965bc9a7414aae206b5c514e1b3"}}