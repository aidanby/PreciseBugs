{"buggy_code": ["varnishtest \"HTTP request tests: H1 to H1 (HTX mode supported only for HAProxy >= 1.9)\"\n\n# Run it with HAPROXY_PROGRAM=$PWD/haproxy varnishtest -l -k -t 1 \"$1\"\n\nfeature ignore_unknown_macro\n\nserver s1 {\n\t##\n\t## Handle GET requests\n\t##\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 1\"\n\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 2\"\n\n\trxreq\n\texpect req.bodylen == 38\n\texpect req.body == \"this must be delivered, like it or not\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 3\"\n\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 4\"\n\n\taccept\n\n\t##\n\t## Handle HEAD requests\n\t##\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 1\"\n\n\taccept\n\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 2\"\n\n\taccept\n\n\trxreq\n\texpect req.bodylen == 38\n\texpect req.body == \"this must be delivered, like it or not\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 3\"\n\n\taccept\n\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 4\"\n\n\taccept\n\n\t##\n\t## Handle POST requests\n\t##\n\t# POST request without body\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 1\"\n\n\t# POST request without body\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 2\"\n\n\t# POST request with a body\n\trxreq\n\texpect req.bodylen == 12\n\texpect req.body == \"this is sent\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 3\"\n\n\t# POST request without body\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 4\"\n} -repeat 3 -start\n\nhaproxy h1 -conf {\n    global\n        # WT: limit false-positives causing \"HTTP header incomplete\" due to\n        # idle server connections being randomly used and randomly expiring\n        # under us.\n        tune.idle-pool.shared off\n\n    defaults\n\tmode http\n\ttimeout connect \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\ttimeout client  \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\ttimeout server  \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\n    listen feh1\n\tbind \"fd@${feh1}\"\n\t#bind \"fd@${feh2}\" proto h2\n\tserver s1 ${s1_addr}:${s1_port}\n} -start\n\n# GET requests\nclient c1h1 -connect ${h1_feh1_sock} {\n\t# first request is valid\n\ttxreq \\\n\t  -req \"GET\" \\\n\t  -url \"/test1.html\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 1\"\n\n\t# second request is valid and advertises C-L:0\n\ttxreq \\\n\t  -req \"GET\" \\\n\t  -url \"/test2.html\" \\\n          -hdr \"content-length: 0\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 2\"\n\n\t# third request sends a body with a GET\n\ttxreq \\\n\t  -req \"GET\" \\\n\t  -url \"/test3.html\" \\\n          -body \"this must be delivered, like it or not\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 3\"\n\n\t# fourth request is valid and advertises C-L:0, and close, and is\n\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which must be\n\t# dropped.\n\ttxreq \\\n\t  -req \"GET\" \\\n\t  -url \"/test4.html\" \\\n          -hdr \"content-length: 0\" \\\n          -hdr \"connection: close\"\n\t# \"this is not sent\"\n\tsendhex \"74787973207973206E6F742073656E740D0A0D0A\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 4\"\n\n\t# the connection is expected to be closed and no more response must\n\t# arrive here.\n\texpect_close\n} -run\n\n# HEAD requests\n# Note: for now they fail with varnishtest, which expects the amount of\n# data advertised in the content-length response.\nclient c2h1 -connect ${h1_feh1_sock} {\n\t# first request is valid\n\ttxreq \\\n\t  -req \"HEAD\" \\\n\t  -url \"/test11.html\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"\"\n\n\t# second request is valid and advertises C-L:0\n\ttxreq \\\n\t  -req \"HEAD\" \\\n\t  -url \"/test12.html\" \\\n          -hdr \"content-length: 0\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"\"\n\n\t# third request sends a body with a HEAD\n\ttxreq \\\n\t  -req \"HEAD\" \\\n\t  -url \"/test13.html\" \\\n          -body \"this must be delivered, like it or not\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"\"\n\n\t# fourth request is valid and advertises C-L:0, and close, and is\n\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which must be\n\t# dropped.\n\ttxreq \\\n\t  -req \"HEAD\" \\\n\t  -url \"/test14.html\" \\\n          -hdr \"content-length: 0\" \\\n          -hdr \"connection: close\"\n\t# \"this is not sent\"\n\tsendhex \"74787973207973206E6F742073656E740D0A0D0A\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"\"\n\n\t# the connection is expected to be closed and no more response must\n\t# arrive here.\n\texpect_close\n} -run\n\nclient c3h1 -connect ${h1_feh1_sock} {\n\t# first request is valid\n\ttxreq \\\n\t  -req \"POST\" \\\n\t  -url \"/test21.html\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 1\"\n\n\t# second request is valid and advertises C-L:0\n\ttxreq \\\n\t  -req \"POST\" \\\n\t  -url \"/test22.html\" \\\n          -hdr \"content-length: 0\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 2\"\n\n\t# third request is valid and advertises (and sends) some contents\n\ttxreq \\\n\t  -req \"POST\" \\\n\t  -url \"/test23.html\" \\\n\t  -body \"this is sent\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 3\"\n\n\t# fourth request is valid and advertises C-L:0, and close, and is\n\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which must be\n\t# dropped.\n\ttxreq \\\n\t  -req \"POST\" \\\n\t  -url \"/test24.html\" \\\n          -hdr \"content-length: 0\" \\\n          -hdr \"connection: close\"\n\t# \"this is not sent\"\n\tsendhex \"74787973207973206E6F742073656E740D0A0D0A\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 4\"\n\n\t# the connection is expected to be closed and no more response must\n\t# arrive here.\n\texpect_close\n} -run\n", "varnishtest \"HTTP request tests: H2 to H1 (HTX and legacy mode)\"\n\n# Run it with HAPROXY_PROGRAM=$PWD/haproxy varnishtest -l -k -t 1 \"$1\"\n\nfeature ignore_unknown_macro\n\n# synchronize requests between streams\nbarrier b1 cond 2 -cyclic\nbarrier b2 cond 2 -cyclic\nbarrier b3 cond 2 -cyclic\nbarrier b4 cond 2 -cyclic\n\nserver s1 {\n\trxreq\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 1\"\n\n\tbarrier b2 sync\n\trxreq\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 2\"\n\n\tbarrier b3 sync\n\trxreq\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 3\"\n\n\tbarrier b4 sync\n\t# the next request is never received\n} -repeat 2 -start\n\nhaproxy h1 -conf {\n    global\n        # WT: limit false-positives causing \"HTTP header incomplete\" due to\n        # idle server connections being randomly used and randomly expiring\n        # under us.\n        tune.idle-pool.shared off\n\n    defaults\n\t#log stdout format raw daemon\n\tmode http\n\toption http-buffer-request\n\ttimeout connect \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\ttimeout client  \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\ttimeout server  \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\n    listen feh1\n\tbind \"fd@${feh1}\"\n\tbind \"fd@${feh2}\" proto h2\n\tserver s1 ${s1_addr}:${s1_port}\n} -start\n\nclient c1h2 -connect ${h1_feh2_sock} {\n\ttxpri\n\tstream 0 {\n\t\ttxsettings\n\t\trxsettings\n\t\ttxsettings -ack\n\t\trxsettings\n\t\texpect settings.ack == true\n\t} -run\n\n\t# first request is valid\n\tstream 1 {\n\t\ttxreq \\\n\t\t  -req \"GET\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test1.html\"\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 1\"\n\t} -run\n\n\t# second request is valid and advertises C-L:0\n\tstream 3 {\n\t\tbarrier b2 sync\n\t\ttxreq \\\n\t\t  -req \"GET\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test2.html\" \\\n\t\t  -hdr \"content-length\" \"0\"\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 2\"\n\t} -run\n\n\t# third request sends a body with a GET\n\tstream 5 {\n\t\tbarrier b3 sync\n\t\ttxreq \\\n\t\t  -req \"GET\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test3.html\" \\\n\t\t  -nostrend \\\n\t\t  -body \"this must be delivered, like it or not\"\n\t\trxwinup\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 3\"\n\t} -run\n\n\t# fourth request is valid and advertises C-L:2, and close, and is\n\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which causes a\n\t# stream error of type PROTOCOL_ERROR.\n\tstream 7 {\n\t\tbarrier b4 sync\n\t\ttxreq \\\n\t\t  -req \"GET\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test4.html\" \\\n\t\t  -hdr \"content-length\" \"2\" \\\n\t\t  -nostrend\n\t\ttxdata -data \"this is sent and ignored\"\n\t\trxrst\n\t} -run\n} -run\n\n# HEAD requests : don't work well yet\n#client c2h2 -connect ${h1_feh2_sock} {\n#\ttxpri\n#\tstream 0 {\n#\t\ttxsettings\n#\t\trxsettings\n#\t\ttxsettings -ack\n#\t\trxsettings\n#\t\texpect settings.ack == true\n#\t} -run\n#\n#\t# first request is valid\n#\tstream 1 {\n#\t\ttxreq \\\n#\t\t  -req \"HEAD\" \\\n#\t\t  -scheme \"https\" \\\n#\t\t  -url \"/test11.html\"\n#\t\trxhdrs\n#\t\texpect resp.status == 200\n#\t\trxdata -all\n#\t\texpect resp.bodylen == 0\n#\t} -run\n#\n#\t# second request is valid and advertises C-L:0\n#\tstream 3 {\n#\t\tbarrier b2 sync\n#\t\ttxreq \\\n#\t\t  -req \"HEAD\" \\\n#\t\t  -scheme \"https\" \\\n#\t\t  -url \"/test12.html\" \\\n#\t\t  -hdr \"content-length\" \"0\"\n#\t\trxhdrs\n#\t\texpect resp.status == 200\n#\t\trxdata -all\n#\t\texpect resp.bodylen == 0\n#\t} -run\n#\n#\t# third request sends a body with a GET\n#\tstream 5 {\n#\t\tbarrier b3 sync\n#\t\ttxreq \\\n#\t\t  -req \"HEAD\" \\\n#\t\t  -scheme \"https\" \\\n#\t\t  -url \"/test13.html\" \\\n#\t\t  -nostrend \\\n#\t\t  -body \"this must be delivered, like it or not\"\n#\t\trxwinup\n#\t\trxhdrs\n#\t\texpect resp.status == 200\n#\t\trxdata -all\n#\t\texpect resp.bodylen == 0\n#\t} -run\n#\n#\t# fourth request is valid and advertises C-L:0, and close, and is\n#\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which must be\n#\t# dropped.\n#\tstream 7 {\n#\t\tbarrier b4 sync\n#\t\ttxreq \\\n#\t\t  -req \"HEAD\" \\\n#\t\t  -scheme \"https\" \\\n#\t\t  -url \"/test14.html\" \\\n#\t\t  -hdr \"content-length\" \"0\" \\\n#\t\t  -nostrend\n#\t\ttxdata -data \"this is sent and ignored\"\n#\t\trxwinup\n#\t\trxhdrs\n#\t\texpect resp.status == 200\n#\t\trxdata -all\n#\t\texpect resp.bodylen == 0\n#\t} -run\n#} -run\n\n# POST requests\nclient c3h2 -connect ${h1_feh2_sock} {\n\ttxpri\n\tstream 0 {\n\t\ttxsettings\n\t\trxsettings\n\t\ttxsettings -ack\n\t\trxsettings\n\t\texpect settings.ack == true\n\t} -run\n\n\t# first request is valid\n\tstream 1 {\n\t\ttxreq \\\n\t\t  -req \"POST\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test21.html\"\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 1\"\n\t} -run\n\n\t# second request is valid and advertises C-L:0\n\tstream 3 {\n\t\tbarrier b2 sync\n\t\ttxreq \\\n\t\t  -req \"POST\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test22.html\" \\\n\t\t  -hdr \"content-length\" \"0\"\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 2\"\n\t} -run\n\n\t# third request sends a body with a GET\n\tstream 5 {\n\t\tbarrier b3 sync\n\t\ttxreq \\\n\t\t  -req \"POST\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test23.html\" \\\n\t\t  -nostrend \\\n\t\t  -body \"this must be delivered, like it or not\"\n\t\trxwinup\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 3\"\n\t} -run\n\n\t# fourth request is valid and advertises C-L:2, and close, and is\n\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which results\n\t# in a stream error.\n\tstream 7 {\n\t\tbarrier b4 sync\n\t\ttxreq \\\n\t\t  -req \"POST\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test24.html\" \\\n\t\t  -hdr \"content-length\" \"2\" \\\n\t\t  -nostrend\n\t\ttxdata -data \"this is sent and ignored\"\n\t\trxrst\n\t} -run\n} -run\n", "/*\n * HTTP/1 protocol analyzer\n *\n * Copyright 2000-2017 Willy Tarreau <w@1wt.eu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n */\n\n#include <ctype.h>\n\n#include <import/sha1.h>\n\n#include <haproxy/api.h>\n#include <haproxy/base64.h>\n#include <haproxy/h1.h>\n#include <haproxy/http-hdr.h>\n#include <haproxy/tools.h>\n\n/* Parse the Content-Length header field of an HTTP/1 request. The function\n * checks all possible occurrences of a comma-delimited value, and verifies\n * if any of them doesn't match a previous value. It returns <0 if a value\n * differs, 0 if the whole header can be dropped (i.e. already known), or >0\n * if the value can be indexed (first one). In the last case, the value might\n * be adjusted and the caller must only add the updated value.\n */\nint h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t}\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}\n\n/* Parse the Transfer-Encoding: header field of an HTTP/1 request, looking for\n * \"chunked\" encoding to perform some checks (it must be the last encoding for\n * the request and must not be performed twice for any message). The\n * H1_MF_TE_CHUNKED is set if a valid \"chunked\" encoding is found. The\n * H1_MF_TE_OTHER flag is set if any other encoding is found. The H1_MF_XFER_ENC\n * flag is always set. The H1_MF_CHNK is set when \"chunked\" encoding is the last\n * one. Note that transfer codings are case-insensitive (cf RFC7230#4). This\n * function returns <0 if a error is found, 0 if the whole header can be dropped\n * (not used yet), or >0 if the value can be indexed.\n */\nint h1_parse_xfer_enc_header(struct h1m *h1m, struct ist value)\n{\n\tchar *e, *n;\n\tstruct ist word;\n\n\th1m->flags |= H1_MF_XFER_ENC;\n\n\tword.ptr = value.ptr - 1; // -1 for next loop's pre-increment\n\te = istend(value);\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (HTTP_IS_LWS(*word.ptr))\n\t\t\tcontinue;\n\n\t\tn = http_find_hdr_value_end(word.ptr, e); // next comma or end of line\n\t\tword.len = n - word.ptr;\n\n\t\t/* trim trailing blanks */\n\t\twhile (word.len && HTTP_IS_LWS(word.ptr[word.len-1]))\n\t\t\tword.len--;\n\n\t\th1m->flags &= ~H1_MF_CHNK;\n\t\tif (isteqi(word, ist(\"chunked\"))) {\n\t\t\tif (h1m->flags & H1_MF_TE_CHUNKED) {\n\t\t\t\t/* cf RFC7230#3.3.1 : A sender MUST NOT apply\n\t\t\t\t * chunked more than once to a message body\n\t\t\t\t * (i.e., chunking an already chunked message is\n\t\t\t\t * not allowed)\n\t\t\t\t */\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\th1m->flags |= (H1_MF_TE_CHUNKED|H1_MF_CHNK);\n\t\t}\n\t\telse {\n\t\t\tif ((h1m->flags & (H1_MF_RESP|H1_MF_TE_CHUNKED)) == H1_MF_TE_CHUNKED) {\n\t\t\t\t/* cf RFC7230#3.3.1 : If any transfer coding\n\t\t\t\t * other than chunked is applied to a request\n\t\t\t\t * payload body, the sender MUST apply chunked\n\t\t\t\t * as the final transfer coding to ensure that\n\t\t\t\t * the message is properly framed.\n\t\t\t\t */\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\th1m->flags |= H1_MF_TE_OTHER;\n\t\t}\n\n\t\tword.ptr = n;\n\t}\n\n\treturn 1;\n  fail:\n\treturn -1;\n}\n\n/* Validate the authority and the host header value for CONNECT method. If there\n * is hast header, its value is normalized. 0 is returned on success, -1 if the\n * authority is invalid and -2 if the host is invalid.\n */\nstatic int h1_validate_connect_authority(struct ist authority, struct ist *host_hdr)\n{\n\tstruct ist uri_host, uri_port, host, host_port;\n\n\tif (!isttest(authority))\n\t\tgoto invalid_authority;\n\turi_host = authority;\n\turi_port = http_get_host_port(authority);\n\tif (!istlen(uri_port))\n\t\tgoto invalid_authority;\n\turi_host.len -= (istlen(uri_port) + 1);\n\n\tif (!host_hdr || !isttest(*host_hdr))\n\t\tgoto end;\n\n\t/* Get the port of the host header value, if any */\n\thost = *host_hdr;\n\thost_port = http_get_host_port(*host_hdr);\n\tif (isttest(host_port))\n\t\thost.len -= (istlen(host_port) + 1);\n\n\tif (istlen(host_port)) {\n\t\tif (!isteqi(host, uri_host) || !isteq(host_port, uri_port))\n\t\t\tgoto invalid_host;\n\t\tif (http_is_default_port(IST_NULL, uri_port))\n\t\t\t*host_hdr = host; /* normalize */\n\t}\n\telse {\n\t\tif (!http_is_default_port(IST_NULL, uri_port) || !isteqi(host, uri_host))\n\t\t\tgoto invalid_host;\n\t}\n\n  end:\n\treturn 0;\n\n  invalid_authority:\n\treturn -1;\n\n  invalid_host:\n\treturn -2;\n}\n\n\n/* Validate the authority and the host header value for non-CONNECT method, when\n * an absolute-URI is detected but when it does not exactly match the host\n * value. The idea is to detect default port (http or https). authority and host\n * are defined here. 0 is returned on success, -1 if the host is does not match\n * the authority.\n */\nstatic int h1_validate_mismatch_authority(struct ist scheme, struct ist authority, struct ist host_hdr)\n{\n\tstruct ist uri_host, uri_port, host, host_port;\n\n\tif (!isttest(scheme))\n\t\tgoto mismatch;\n\n\turi_host = authority;\n\turi_port = http_get_host_port(authority);\n\tif (isttest(uri_port))\n\t\turi_host.len -= (istlen(uri_port) + 1);\n\n\thost = host_hdr;\n\thost_port = http_get_host_port(host_hdr);\n\tif (isttest(host_port))\n\t    host.len -= (istlen(host_port) + 1);\n\n\tif (!isttest(uri_port) && !isttest(host_port)) {\n\t\t/* No port on both: we already know the authority does not match\n\t\t * the host value\n\t\t */\n\t\tgoto mismatch;\n\t}\n\telse if (isttest(uri_port) && !http_is_default_port(scheme, uri_port)) {\n\t\t/* here there is no port for the host value and the port for the\n\t\t * authority is not the default one\n\t\t */\n\t\tgoto mismatch;\n\t}\n\telse if (isttest(host_port) && !http_is_default_port(scheme, host_port)) {\n\t\t/* here there is no port for the authority and the port for the\n\t\t * host value is not the default one\n\t\t */\n\t\tgoto mismatch;\n\t}\n\telse {\n\t\t/* the authority or the host value contain a default port and\n\t\t * there is no port on the other value\n\t\t */\n\t\tif (!isteqi(uri_host, host))\n\t\t\tgoto mismatch;\n\t}\n\n\treturn 0;\n\n  mismatch:\n\treturn -1;\n}\n\n\n/* Parse the Connection: header of an HTTP/1 request, looking for \"close\",\n * \"keep-alive\", and \"upgrade\" values, and updating h1m->flags according to\n * what was found there. Note that flags are only added, not removed, so the\n * function is safe for being called multiple times if multiple occurrences\n * are found. If the flag H1_MF_CLEAN_CONN_HDR, the header value is cleaned\n * up from \"keep-alive\" and \"close\" values. To do so, the header value is\n * rewritten in place and its length is updated.\n */\nvoid h1_parse_connection_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n, *p;\n\tstruct ist word;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\tp = value->ptr;\n\te = value->ptr + value->len;\n\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR)\n\t\tvalue->len = 0;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (HTTP_IS_LWS(*word.ptr))\n\t\t\tcontinue;\n\n\t\tn = http_find_hdr_value_end(word.ptr, e); // next comma or end of line\n\t\tword.len = n - word.ptr;\n\n\t\t/* trim trailing blanks */\n\t\twhile (word.len && HTTP_IS_LWS(word.ptr[word.len-1]))\n\t\t\tword.len--;\n\n\t\tif (isteqi(word, ist(\"keep-alive\"))) {\n\t\t\th1m->flags |= H1_MF_CONN_KAL;\n\t\t\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR)\n\t\t\t\tgoto skip_val;\n\t\t}\n\t\telse if (isteqi(word, ist(\"close\"))) {\n\t\t\th1m->flags |= H1_MF_CONN_CLO;\n\t\t\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR)\n\t\t\t\tgoto skip_val;\n\t\t}\n\t\telse if (isteqi(word, ist(\"upgrade\")))\n\t\t\th1m->flags |= H1_MF_CONN_UPG;\n\n\t\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR) {\n\t\t\tif (value->ptr + value->len == p) {\n\t\t\t\t/* no rewrite done till now */\n\t\t\t\tvalue->len = n - value->ptr;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (value->len)\n\t\t\t\t\tvalue->ptr[value->len++] = ',';\n\t\t\t\tistcat(value, word, e - value->ptr);\n\t\t\t}\n\t\t}\n\n\t  skip_val:\n\t\tword.ptr = p = n;\n\t}\n}\n\n/* Parse the Upgrade: header of an HTTP/1 request.\n * If \"websocket\" is found, set H1_MF_UPG_WEBSOCKET flag\n */\nvoid h1_parse_upgrade_header(struct h1m *h1m, struct ist value)\n{\n\tchar *e, *n;\n\tstruct ist word;\n\n\th1m->flags &= ~H1_MF_UPG_WEBSOCKET;\n\n\tword.ptr = value.ptr - 1; // -1 for next loop's pre-increment\n\te = istend(value);\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (HTTP_IS_LWS(*word.ptr))\n\t\t\tcontinue;\n\n\t\tn = http_find_hdr_value_end(word.ptr, e); // next comma or end of line\n\t\tword.len = n - word.ptr;\n\n\t\t/* trim trailing blanks */\n\t\twhile (word.len && HTTP_IS_LWS(word.ptr[word.len-1]))\n\t\t\tword.len--;\n\n\t\tif (isteqi(word, ist(\"websocket\")))\n\t\t\th1m->flags |= H1_MF_UPG_WEBSOCKET;\n\n\t\tword.ptr = n;\n\t}\n}\n\n/* Macros used in the HTTP/1 parser, to check for the expected presence of\n * certain bytes (ef: LF) or to skip to next byte and yield in case of failure.\n */\n\n/* Expects to find an LF at <ptr>. If not, set <state> to <where> and jump to\n * <bad>.\n */\n#define EXPECT_LF_HERE(ptr, bad, state, where)                  \\\n\tdo {                                                    \\\n\t\tif (unlikely(*(ptr) != '\\n')) {                 \\\n\t\t\tstate = (where);                        \\\n\t\t\tgoto bad;                               \\\n\t\t}                                               \\\n\t} while (0)\n\n/* Increments pointer <ptr>, continues to label <more> if it's still below\n * pointer <end>, or goes to <stop> and sets <state> to <where> if the end\n * of buffer was reached.\n */\n#define EAT_AND_JUMP_OR_RETURN(ptr, end, more, stop, state, where)        \\\n\tdo {                                                              \\\n\t\tif (likely(++(ptr) < (end)))                              \\\n\t\t\tgoto more;                                        \\\n\t\telse {                                                    \\\n\t\t\tstate = (where);                                  \\\n\t\t\tgoto stop;                                        \\\n\t\t}                                                         \\\n\t} while (0)\n\n/* This function parses a contiguous HTTP/1 headers block starting at <start>\n * and ending before <stop>, at once, and converts it a list of (name,value)\n * pairs representing header fields into the array <hdr> of size <hdr_num>,\n * whose last entry will have an empty name and an empty value. If <hdr_num> is\n * too small to represent the whole message, an error is returned. Some\n * protocol elements such as content-length and transfer-encoding will be\n * parsed and stored into h1m as well. <hdr> may be null, in which case only\n * the parsing state will be updated. This may be used to restart the parsing\n * where it stopped for example.\n *\n * For now it's limited to the response. If the header block is incomplete,\n * 0 is returned, waiting to be called again with more data to try it again.\n * The caller is responsible for initializing h1m->state to H1_MSG_RPBEFORE,\n * and h1m->next to zero on the first call, the parser will do the rest. If\n * an incomplete message is seen, the caller only needs to present h1m->state\n * and h1m->next again, with an empty header list so that the parser can start\n * again. In this case, it will detect that it interrupted a previous session\n * and will first look for the end of the message before reparsing it again and\n * indexing it at the same time. This ensures that incomplete messages fed 1\n * character at a time are never processed entirely more than exactly twice,\n * and that there is no need to store all the internal state and pre-parsed\n * headers or start line between calls.\n *\n * A pointer to a start line descriptor may be passed in <slp>, in which case\n * the parser will fill it with whatever it found.\n *\n * The code derived from the main HTTP/1 parser above but was simplified and\n * optimized to process responses produced or forwarded by haproxy. The caller\n * is responsible for ensuring that the message doesn't wrap, and should ensure\n * it is complete to avoid having to retry the operation after a failed\n * attempt. The message is not supposed to be invalid, which is why a few\n * properties such as the character set used in the header field names are not\n * checked. In case of an unparsable response message, a negative value will be\n * returned with h1m->err_pos and h1m->err_state matching the location and\n * state where the error was met. Leading blank likes are tolerated but not\n * recommended. If flag H1_MF_HDRS_ONLY is set in h1m->flags, only headers are\n * parsed and the start line is skipped. It is not required to set h1m->state\n * nor h1m->next in this case.\n *\n * This function returns :\n *    -1 in case of error. In this case, h1m->err_state is filled (if h1m is\n *       set) with the state the error occurred in and h1m->err_pos with the\n *       the position relative to <start>\n *    -2 if the output is full (hdr_num reached). err_state and err_pos also\n *       indicate where it failed.\n *     0 in case of missing data.\n *   > 0 on success, it then corresponds to the number of bytes read since\n *       <start> so that the caller can go on with the payload.\n */\nint h1_headers_to_hdr_list(char *start, const char *stop,\n                           struct http_hdr *hdr, unsigned int hdr_num,\n                           struct h1m *h1m, union h1_sl *slp)\n{\n\tenum h1m_state state;\n\tregister char *ptr;\n\tregister const char *end;\n\tunsigned int hdr_count;\n\tunsigned int skip; /* number of bytes skipped at the beginning */\n\tunsigned int sol;  /* start of line */\n\tunsigned int col;  /* position of the colon */\n\tunsigned int eol;  /* end of line */\n\tunsigned int sov;  /* start of value */\n\tunion h1_sl sl;\n\tint skip_update;\n\tint restarting;\n\tint host_idx;\n\tstruct ist n, v;       /* header name and value during parsing */\n\n\tskip = 0; // do it only once to keep track of the leading CRLF.\n\n try_again:\n\thdr_count = sol = col = eol = sov = 0;\n\tsl.st.status = 0;\n\tskip_update = restarting = 0;\n\thost_idx = -1;\n\n\tif (h1m->flags & H1_MF_HDRS_ONLY) {\n\t\tstate = H1_MSG_HDR_FIRST;\n\t\th1m->next = 0;\n\t}\n\telse {\n\t\tstate = h1m->state;\n\t\tif (h1m->state != H1_MSG_RQBEFORE && h1m->state != H1_MSG_RPBEFORE)\n\t\t\trestarting = 1;\n\t}\n\n\tptr   = start + h1m->next;\n\tend   = stop;\n\n\tif (unlikely(ptr >= end))\n\t\tgoto http_msg_ood;\n\n\t/* don't update output if hdr is NULL or if we're restarting */\n\tif (!hdr || restarting)\n\t\tskip_update = 1;\n\n\tswitch (state)\t{\n\tcase H1_MSG_RQBEFORE:\n\thttp_msg_rqbefore:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\t/* we have a start of message, we may have skipped some\n\t\t\t * heading CRLF. Skip them now.\n\t\t\t */\n\t\t\tskip += ptr - start;\n\t\t\tstart = ptr;\n\n\t\t\tsol = 0;\n\t\t\tsl.rq.m.ptr = ptr;\n\t\t\thdr_count = 0;\n\t\t\tstate = H1_MSG_RQMETH;\n\t\t\tgoto http_msg_rqmeth;\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tstate = H1_MSG_RQBEFORE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (unlikely(*ptr == '\\n'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore, http_msg_ood, state, H1_MSG_RQBEFORE);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore_cr, http_msg_ood, state, H1_MSG_RQBEFORE_CR);\n\t\t/* stop here */\n\n\tcase H1_MSG_RQBEFORE_CR:\n\thttp_msg_rqbefore_cr:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RQBEFORE_CR);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore, http_msg_ood, state, H1_MSG_RQBEFORE);\n\t\t/* stop here */\n\n\tcase H1_MSG_RQMETH:\n\thttp_msg_rqmeth:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth, http_msg_ood, state, H1_MSG_RQMETH);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.rq.m.len = ptr - sl.rq.m.ptr;\n\t\t\tsl.rq.meth = find_http_meth(start, sl.rq.m.len);\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth_sp, http_msg_ood, state, H1_MSG_RQMETH_SP);\n\t\t}\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\t/* HTTP 0.9 request */\n\t\t\tsl.rq.m.len = ptr - sl.rq.m.ptr;\n\t\t\tsl.rq.meth = find_http_meth(sl.rq.m.ptr, sl.rq.m.len);\n\t\thttp_msg_req09_uri:\n\t\t\tsl.rq.u.ptr = ptr;\n\t\thttp_msg_req09_uri_e:\n\t\t\tsl.rq.u.len = ptr - sl.rq.u.ptr;\n\t\thttp_msg_req09_ver:\n\t\t\tsl.rq.v = ist2(ptr, 0);\n\t\t\tgoto http_msg_rqline_eol;\n\t\t}\n\t\tstate = H1_MSG_RQMETH;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQMETH_SP:\n\thttp_msg_rqmeth_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.rq.u.ptr = ptr;\n\t\t\tgoto http_msg_rquri;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth_sp, http_msg_ood, state, H1_MSG_RQMETH_SP);\n\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\tgoto http_msg_req09_uri;\n\n\tcase H1_MSG_RQURI:\n\thttp_msg_rquri:\n#ifdef HA_UNALIGNED_LE\n\t\t/* speedup: skip bytes not between 0x24 and 0x7e inclusive */\n\t\twhile (ptr <= end - sizeof(int)) {\n\t\t\tint x = *(int *)ptr - 0x24242424;\n\t\t\tif (x & 0x80808080)\n\t\t\t\tbreak;\n\n\t\t\tx -= 0x5b5b5b5b;\n\t\t\tif (!(x & 0x80808080))\n\t\t\t\tbreak;\n\n\t\t\tptr += sizeof(int);\n\t\t}\n#endif\n\t\tif (ptr >= end) {\n\t\t\tstate = H1_MSG_RQURI;\n\t\t\tgoto http_msg_ood;\n\t\t}\n\thttp_msg_rquri2:\n\t\tif (likely((unsigned char)(*ptr - 33) <= 93)) { /* 33 to 126 included */\n\t\t\tif (*ptr == '#') {\n\t\t\t\tif (h1m->err_pos < -1) /* PR_O2_REQBUG_OK not set */\n\t\t\t\t\tgoto invalid_char;\n\t\t\t\tif (h1m->err_pos == -1) /* PR_O2_REQBUG_OK set: just log */\n\t\t\t\t\th1m->err_pos = ptr - start + skip;\n\t\t\t}\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri2, http_msg_ood, state, H1_MSG_RQURI);\n\t\t}\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.rq.u.len = ptr - sl.rq.u.ptr;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri_sp, http_msg_ood, state, H1_MSG_RQURI_SP);\n\t\t}\n\t\tif (likely((unsigned char)*ptr >= 128)) {\n\t\t\t/* non-ASCII chars are forbidden unless option\n\t\t\t * accept-invalid-http-request is enabled in the frontend.\n\t\t\t * In any case, we capture the faulty char.\n\t\t\t */\n\t\t\tif (h1m->err_pos < -1)\n\t\t\t\tgoto invalid_char;\n\t\t\tif (h1m->err_pos == -1)\n\t\t\t\th1m->err_pos = ptr - start + skip;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri, http_msg_ood, state, H1_MSG_RQURI);\n\t\t}\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\t\tgoto http_msg_req09_uri_e;\n\t\t}\n\n\t\t/* OK forbidden chars, 0..31 or 127 */\n\tinvalid_char:\n\t\tstate = H1_MSG_RQURI;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQURI_SP:\n\thttp_msg_rquri_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.rq.v.ptr = ptr;\n\t\t\tgoto http_msg_rqver;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri_sp, http_msg_ood, state, H1_MSG_RQURI_SP);\n\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\tgoto http_msg_req09_ver;\n\n\n\tcase H1_MSG_RQVER:\n\thttp_msg_rqver:\n\t\tif (likely(HTTP_IS_VER_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqver, http_msg_ood, state, H1_MSG_RQVER);\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\tsl.rq.v.len = ptr - sl.rq.v.ptr;\n\t\thttp_msg_rqline_eol:\n\t\t\t/* We have seen the end of line. Note that we do not\n\t\t\t * necessarily have the \\n yet, but at least we know that we\n\t\t\t * have EITHER \\r OR \\n, otherwise the request would not be\n\t\t\t * complete. We can then record the request length and return\n\t\t\t * to the caller which will be able to register it.\n\t\t\t */\n\n\t\t\tif (likely(!skip_update)) {\n\t\t\t\tif ((sl.rq.v.len == 8) &&\n\t\t\t\t    (*(sl.rq.v.ptr + 5) > '1' ||\n\t\t\t\t     (*(sl.rq.v.ptr + 5) == '1' && *(sl.rq.v.ptr + 7) >= '1')))\n\t\t\t\t\th1m->flags |= H1_MF_VER_11;\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_RQVER;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\t\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\":method\"), sl.rq.m);\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_RQVER;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\t\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\":path\"), sl.rq.u);\n\t\t\t}\n\n\t\t\tsol = ptr - start;\n\t\t\tif (likely(*ptr == '\\r'))\n\t\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqline_end, http_msg_ood, state, H1_MSG_RQLINE_END);\n\t\t\tgoto http_msg_rqline_end;\n\t\t}\n\n\t\t/* neither an HTTP_VER token nor a CRLF */\n\t\tstate = H1_MSG_RQVER;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQLINE_END:\n\thttp_msg_rqline_end:\n\t\t/* check for HTTP/0.9 request : no version information\n\t\t * available. sol must point to the first of CR or LF. However\n\t\t * since we don't save these elements between calls, if we come\n\t\t * here from a restart, we don't necessarily know. Thus in this\n\t\t * case we simply start over.\n\t\t */\n\t\tif (restarting)\n\t\t\tgoto restart;\n\n\t\tif (unlikely(sl.rq.v.len == 0))\n\t\t\tgoto http_msg_last_lf;\n\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RQLINE_END);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_first, http_msg_ood, state, H1_MSG_HDR_FIRST);\n\t\t/* stop here */\n\n\t/*\n\t * Common states below\n\t */\n\tcase H1_MSG_RPBEFORE:\n\thttp_msg_rpbefore:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\t/* we have a start of message, we may have skipped some\n\t\t\t * heading CRLF. Skip them now.\n\t\t\t */\n\t\t\tskip += ptr - start;\n\t\t\tstart = ptr;\n\n\t\t\tsol = 0;\n\t\t\tsl.st.v.ptr = ptr;\n\t\t\thdr_count = 0;\n\t\t\tstate = H1_MSG_RPVER;\n\t\t\tgoto http_msg_rpver;\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tstate = H1_MSG_RPBEFORE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (unlikely(*ptr == '\\n'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore, http_msg_ood, state, H1_MSG_RPBEFORE);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore_cr, http_msg_ood, state, H1_MSG_RPBEFORE_CR);\n\t\t/* stop here */\n\n\tcase H1_MSG_RPBEFORE_CR:\n\thttp_msg_rpbefore_cr:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RPBEFORE_CR);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore, http_msg_ood, state, H1_MSG_RPBEFORE);\n\t\t/* stop here */\n\n\tcase H1_MSG_RPVER:\n\thttp_msg_rpver:\n\t\tif (likely(HTTP_IS_VER_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver, http_msg_ood, state, H1_MSG_RPVER);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.st.v.len = ptr - sl.st.v.ptr;\n\n\t\t\tif ((sl.st.v.len == 8) &&\n\t\t\t    (*(sl.st.v.ptr + 5) > '1' ||\n\t\t\t     (*(sl.st.v.ptr + 5) == '1' && *(sl.st.v.ptr + 7) >= '1')))\n\t\t\t\th1m->flags |= H1_MF_VER_11;\n\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver_sp, http_msg_ood, state, H1_MSG_RPVER_SP);\n\t\t}\n\t\tstate = H1_MSG_RPVER;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RPVER_SP:\n\thttp_msg_rpver_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.st.status = 0;\n\t\t\tsl.st.c.ptr = ptr;\n\t\t\tgoto http_msg_rpcode;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver_sp, http_msg_ood, state, H1_MSG_RPVER_SP);\n\t\t/* so it's a CR/LF, this is invalid */\n\t\tstate = H1_MSG_RPVER_SP;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RPCODE:\n\thttp_msg_rpcode:\n\t\tif (likely(HTTP_IS_DIGIT(*ptr))) {\n\t\t\tsl.st.status = sl.st.status * 10 + *ptr - '0';\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode, http_msg_ood, state, H1_MSG_RPCODE);\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tstate = H1_MSG_RPCODE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.st.c.len = ptr - sl.st.c.ptr;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode_sp, http_msg_ood, state, H1_MSG_RPCODE_SP);\n\t\t}\n\n\t\t/* so it's a CR/LF, so there is no reason phrase */\n\t\tsl.st.c.len = ptr - sl.st.c.ptr;\n\n\thttp_msg_rsp_reason:\n\t\tsl.st.r = ist2(ptr, 0);\n\t\tgoto http_msg_rpline_eol;\n\n\tcase H1_MSG_RPCODE_SP:\n\thttp_msg_rpcode_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.st.r.ptr = ptr;\n\t\t\tgoto http_msg_rpreason;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode_sp, http_msg_ood, state, H1_MSG_RPCODE_SP);\n\t\t/* so it's a CR/LF, so there is no reason phrase */\n\t\tgoto http_msg_rsp_reason;\n\n\tcase H1_MSG_RPREASON:\n\thttp_msg_rpreason:\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpreason, http_msg_ood, state, H1_MSG_RPREASON);\n\t\tsl.st.r.len = ptr - sl.st.r.ptr;\n\thttp_msg_rpline_eol:\n\t\t/* We have seen the end of line. Note that we do not\n\t\t * necessarily have the \\n yet, but at least we know that we\n\t\t * have EITHER \\r OR \\n, otherwise the response would not be\n\t\t * complete. We can then record the response length and return\n\t\t * to the caller which will be able to register it.\n\t\t */\n\n\t\tif (likely(!skip_update)) {\n\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\tstate = H1_MSG_RPREASON;\n\t\t\t\tgoto http_output_full;\n\t\t\t}\n\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\":status\"), sl.st.c);\n\t\t}\n\n\t\tsol = ptr - start;\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpline_end, http_msg_ood, state, H1_MSG_RPLINE_END);\n\t\tgoto http_msg_rpline_end;\n\n\tcase H1_MSG_RPLINE_END:\n\thttp_msg_rpline_end:\n\t\t/* sol must point to the first of CR or LF. */\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RPLINE_END);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_first, http_msg_ood, state, H1_MSG_HDR_FIRST);\n\t\t/* stop here */\n\n\tcase H1_MSG_HDR_FIRST:\n\thttp_msg_hdr_first:\n\t\tsol = ptr - start;\n\t\tif (likely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tgoto http_msg_hdr_name;\n\t\t}\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_last_lf, http_msg_ood, state, H1_MSG_LAST_LF);\n\t\tgoto http_msg_last_lf;\n\n\tcase H1_MSG_HDR_NAME:\n\thttp_msg_hdr_name:\n\t\t/* assumes sol points to the first char */\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* turn it to lower case if needed */\n\t\t\t\tif (isupper((unsigned char)*ptr) && h1m->flags & H1_MF_TOLOWER)\n\t\t\t\t\t*ptr = tolower((unsigned char)*ptr);\n\t\t\t}\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_name, http_msg_ood, state, H1_MSG_HDR_NAME);\n\t\t}\n\n\t\tif (likely(*ptr == ':')) {\n\t\t\tcol = ptr - start;\n\t\t\tif (col <= sol) {\n\t\t\t\tstate = H1_MSG_HDR_NAME;\n\t\t\t\tgoto http_msg_invalid;\n\t\t\t}\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_sp, http_msg_ood, state, H1_MSG_HDR_L1_SP);\n\t\t}\n\n\t\tif (likely(h1m->err_pos < -1) || *ptr == '\\n') {\n\t\t\tstate = H1_MSG_HDR_NAME;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\th1m->err_pos = ptr - start + skip; /* >= 0 now */\n\n\t\t/* and we still accept this non-token character */\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_name, http_msg_ood, state, H1_MSG_HDR_NAME);\n\n\tcase H1_MSG_HDR_L1_SP:\n\thttp_msg_hdr_l1_sp:\n\t\t/* assumes sol points to the first char */\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_sp, http_msg_ood, state, H1_MSG_HDR_L1_SP);\n\n\t\t/* header value can be basically anything except CR/LF */\n\t\tsov = ptr - start;\n\n\t\tif (likely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tgoto http_msg_hdr_val;\n\t\t}\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_lf, http_msg_ood, state, H1_MSG_HDR_L1_LF);\n\t\tgoto http_msg_hdr_l1_lf;\n\n\tcase H1_MSG_HDR_L1_LF:\n\thttp_msg_hdr_l1_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_HDR_L1_LF);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_lws, http_msg_ood, state, H1_MSG_HDR_L1_LWS);\n\n\tcase H1_MSG_HDR_L1_LWS:\n\thttp_msg_hdr_l1_lws:\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* replace HT,CR,LF with spaces */\n\t\t\t\tfor (; start + sov < ptr; sov++)\n\t\t\t\t\tstart[sov] = ' ';\n\t\t\t}\n\t\t\tgoto http_msg_hdr_l1_sp;\n\t\t}\n\t\t/* we had a header consisting only in spaces ! */\n\t\teol = sov;\n\t\tgoto http_msg_complete_header;\n\n\tcase H1_MSG_HDR_VAL:\n\thttp_msg_hdr_val:\n\t\t/* assumes sol points to the first char, and sov\n\t\t * points to the first character of the value.\n\t\t */\n\n\t\t/* speedup: we'll skip packs of 4 or 8 bytes not containing bytes 0x0D\n\t\t * and lower. In fact since most of the time is spent in the loop, we\n\t\t * also remove the sign bit test so that bytes 0x8e..0x0d break the\n\t\t * loop, but we don't care since they're very rare in header values.\n\t\t */\n#ifdef HA_UNALIGNED_LE64\n\t\twhile (ptr <= end - sizeof(long)) {\n\t\t\tif ((*(long *)ptr - 0x0e0e0e0e0e0e0e0eULL) & 0x8080808080808080ULL)\n\t\t\t\tgoto http_msg_hdr_val2;\n\t\t\tptr += sizeof(long);\n\t\t}\n#endif\n#ifdef HA_UNALIGNED_LE\n\t\twhile (ptr <= end - sizeof(int)) {\n\t\t\tif ((*(int*)ptr - 0x0e0e0e0e) & 0x80808080)\n\t\t\t\tgoto http_msg_hdr_val2;\n\t\t\tptr += sizeof(int);\n\t\t}\n#endif\n\t\tif (ptr >= end) {\n\t\t\tstate = H1_MSG_HDR_VAL;\n\t\t\tgoto http_msg_ood;\n\t\t}\n\thttp_msg_hdr_val2:\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_val2, http_msg_ood, state, H1_MSG_HDR_VAL);\n\n\t\teol = ptr - start;\n\t\t/* Note: we could also copy eol into ->eoh so that we have the\n\t\t * real header end in case it ends with lots of LWS, but is this\n\t\t * really needed ?\n\t\t */\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l2_lf, http_msg_ood, state, H1_MSG_HDR_L2_LF);\n\t\tgoto http_msg_hdr_l2_lf;\n\n\tcase H1_MSG_HDR_L2_LF:\n\thttp_msg_hdr_l2_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_HDR_L2_LF);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l2_lws, http_msg_ood, state, H1_MSG_HDR_L2_LWS);\n\n\tcase H1_MSG_HDR_L2_LWS:\n\thttp_msg_hdr_l2_lws:\n\t\tif (unlikely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* LWS: replace HT,CR,LF with spaces */\n\t\t\t\tfor (; start + eol < ptr; eol++)\n\t\t\t\t\tstart[eol] = ' ';\n\t\t\t}\n\t\t\tgoto http_msg_hdr_val;\n\t\t}\n\thttp_msg_complete_header:\n\t\t/*\n\t\t * It was a new header, so the last one is finished. Assumes\n\t\t * <sol> points to the first char of the name, <col> to the\n\t\t * colon, <sov> points to the first character of the value and\n\t\t * <eol> to the first CR or LF so we know how the line ends. We\n\t\t * will trim spaces around the value. It's possible to do it by\n\t\t * adjusting <eol> and <sov> which are no more used after this.\n\t\t * We can add the header field to the list.\n\t\t */\n\t\tif (likely(!skip_update)) {\n\t\t\twhile (sov < eol && HTTP_IS_LWS(start[sov]))\n\t\t\t\tsov++;\n\n\t\t\twhile (eol - 1 > sov && HTTP_IS_LWS(start[eol - 1]))\n\t\t\t\teol--;\n\n\n\t\t\tn = ist2(start + sol, col - sol);\n\t\t\tv = ist2(start + sov, eol - sov);\n\n\t\t\tdo {\n\t\t\t\tint ret;\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\n\t\t\t\tif (isteqi(n, ist(\"transfer-encoding\"))) {\n\t\t\t\t\tret = h1_parse_xfer_enc_header(h1m, v);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ret == 0) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\"content-length\"))) {\n\t\t\t\t\tret = h1_parse_cont_len_header(h1m, &v);\n\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ret == 0) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\"connection\"))) {\n\t\t\t\t\th1_parse_connection_header(h1m, &v);\n\t\t\t\t\tif (!v.len) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\"upgrade\"))) {\n\t\t\t\t\th1_parse_upgrade_header(h1m, v);\n\t\t\t\t}\n\t\t\t\telse if (!(h1m->flags & H1_MF_RESP) && isteqi(n, ist(\"host\"))) {\n\t\t\t\t\tif (host_idx == -1)\n\t\t\t\t\t\thost_idx = hdr_count;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!isteqi(v, hdr[host_idx].v)) {\n\t\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* if the same host, skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thttp_set_hdr(&hdr[hdr_count++], n, v);\n\t\t\t} while (0);\n\t\t}\n\n\t\tsol = ptr - start;\n\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tgoto http_msg_hdr_name;\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_last_lf, http_msg_ood, state, H1_MSG_LAST_LF);\n\t\tgoto http_msg_last_lf;\n\n\tcase H1_MSG_LAST_LF:\n\thttp_msg_last_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_LAST_LF);\n\t\tptr++;\n\t\t/* <ptr> now points to the first byte of payload. If needed sol\n\t\t * still points to the first of either CR or LF of the empty\n\t\t * line ending the headers block.\n\t\t */\n\t\tif (likely(!skip_update)) {\n\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\tstate = H1_MSG_LAST_LF;\n\t\t\t\tgoto http_output_full;\n\t\t\t}\n\t\t\thttp_set_hdr(&hdr[hdr_count++], ist2(start+sol, 0), ist(\"\"));\n\t\t}\n\n\t\t/* reaching here we've parsed the whole message. We may detect\n\t\t * that we were already continuing an interrupted parsing pass\n\t\t * so we were silently looking for the end of message not\n\t\t * updating anything before deciding to parse it fully at once.\n\t\t * It's guaranteed that we won't match this test twice in a row\n\t\t * since restarting will turn zero.\n\t\t */\n\t\tif (restarting)\n\t\t\tgoto restart;\n\n\n\t\tif (!(h1m->flags & (H1_MF_HDRS_ONLY|H1_MF_RESP))) {\n\t\t\tstruct http_uri_parser parser = http_uri_parser_init(sl.rq.u);\n\t\t\tstruct ist scheme, authority;\n\t\t\tint ret;\n\n\t\t\tscheme = http_parse_scheme(&parser);\n\t\t\tauthority = http_parse_authority(&parser, 1);\n\t\t\tif (sl.rq.meth == HTTP_METH_CONNECT) {\n\t\t\t\tstruct ist *host = ((host_idx != -1) ? &hdr[host_idx].v : NULL);\n\n\t\t\t\tret = h1_validate_connect_authority(authority, host);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (h1m->err_pos < -1) {\n\t\t\t\t\t\tstate = H1_MSG_LAST_LF;\n\t\t\t\t\t\t/* WT: gcc seems to see a path where sl.rq.u.ptr was used\n\t\t\t\t\t\t * uninitialized, but it doesn't know that the function is\n\t\t\t\t\t\t * called with initial states making this impossible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tALREADY_CHECKED(sl.rq.u.ptr);\n\t\t\t\t\t\tptr = ((ret == -1) ? sl.rq.u.ptr : host->ptr); /* Set ptr on the error */\n\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t}\n\t\t\t\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\t\t\t\th1m->err_pos = ((ret == -1) ? sl.rq.u.ptr : host->ptr) - start + skip; /* >= 0 now */\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (host_idx != -1 && istlen(authority)) {\n\t\t\t\tstruct ist host = hdr[host_idx].v;\n\n\t\t\t\t/* For non-CONNECT method, the authority must match the host header value */\n\t\t\t\tif (!isteqi(authority, host)) {\n\t\t\t\t\tret = h1_validate_mismatch_authority(scheme, authority, host);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tif (h1m->err_pos < -1) {\n\t\t\t\t\t\t\tstate = H1_MSG_LAST_LF;\n\t\t\t\t\t\t\tptr = host.ptr; /* Set ptr on the error */\n\t\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\t\t\t\t\th1m->err_pos = v.ptr - start + skip; /* >= 0 now */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstate = H1_MSG_DATA;\n\t\tif (h1m->flags & H1_MF_XFER_ENC) {\n\t\t\tif (h1m->flags & H1_MF_CLEN) {\n\t\t\t\t/* T-E + C-L: force close and remove C-L */\n\t\t\t\th1m->flags |= H1_MF_CONN_CLO;\n\t\t\t\th1m->flags &= ~H1_MF_CLEN;\n\t\t\t\thdr_count = http_del_hdr(hdr, ist(\"content-length\"));\n\t\t\t}\n\t\t\telse if (!(h1m->flags & H1_MF_VER_11)) {\n\t\t\t\t/* T-E + HTTP/1.0: force close */\n\t\t\t\th1m->flags |= H1_MF_CONN_CLO;\n\t\t\t}\n\n\t\t\tif (h1m->flags & H1_MF_CHNK)\n\t\t\t\tstate = H1_MSG_CHUNK_SIZE;\n\t\t\telse if (!(h1m->flags & H1_MF_RESP)) {\n\t\t\t\t/* cf RFC7230#3.3.3 : transfer-encoding in\n\t\t\t\t * request without chunked encoding is invalid.\n\t\t\t\t */\n\t\t\t\tgoto http_msg_invalid;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\t/* impossible states */\n\t\tgoto http_msg_invalid;\n\t}\n\n\t/* Now we've left the headers state and are either in H1_MSG_DATA or\n\t * H1_MSG_CHUNK_SIZE.\n\t */\n\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->state = state;\n\th1m->next  = ptr - start + skip;\n\treturn h1m->next;\n\n http_msg_ood:\n\t/* out of data at <ptr> during state <state> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->state = state;\n\th1m->next  = ptr - start + skip;\n\treturn 0;\n\n http_msg_invalid:\n\t/* invalid message, error at <ptr> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->err_state = h1m->state = state;\n\th1m->err_pos   = h1m->next  = ptr - start + skip;\n\treturn -1;\n\n http_output_full:\n\t/* no more room to store the current header, error at <ptr> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->err_state = h1m->state = state;\n\th1m->err_pos   = h1m->next  = ptr - start + skip;\n\treturn -2;\n\n restart:\n\th1m->flags &= H1_MF_RESTART_MASK;\n\th1m->curr_len = h1m->body_len = h1m->next  = 0;\n\tif (h1m->flags & H1_MF_RESP)\n\t\th1m->state = H1_MSG_RPBEFORE;\n\telse\n\t\th1m->state = H1_MSG_RQBEFORE;\n\tgoto try_again;\n}\n\n/* This function performs a very minimal parsing of the trailers block present\n * at offset <ofs> in <buf> for up to <max> bytes, and returns the number of\n * bytes to delete to skip the trailers. It may return 0 if it's missing some\n * input data, or < 0 in case of parse error (in which case the caller may have\n * to decide how to proceed, possibly eating everything).\n */\nint h1_measure_trailers(const struct buffer *buf, unsigned int ofs, unsigned int max)\n{\n\tconst char *stop = b_peek(buf, ofs + max);\n\tint count = ofs;\n\n\twhile (1) {\n\t\tconst char *p1 = NULL, *p2 = NULL;\n\t\tconst char *start = b_peek(buf, count);\n\t\tconst char *ptr   = start;\n\n\t\t/* scan current line and stop at LF or CRLF */\n\t\twhile (1) {\n\t\t\tif (ptr == stop)\n\t\t\t\treturn 0;\n\n\t\t\tif (*ptr == '\\n') {\n\t\t\t\tif (!p1)\n\t\t\t\t\tp1 = ptr;\n\t\t\t\tp2 = ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (*ptr == '\\r') {\n\t\t\t\tif (p1)\n\t\t\t\t\treturn -1;\n\t\t\t\tp1 = ptr;\n\t\t\t}\n\n\t\t\tptr = b_next(buf, ptr);\n\t\t}\n\n\t\t/* after LF; point to beginning of next line */\n\t\tp2 = b_next(buf, p2);\n\t\tcount += b_dist(buf, start, p2);\n\n\t\t/* LF/CRLF at beginning of line => end of trailers at p2.\n\t\t * Everything was scheduled for forwarding, there's nothing left\n\t\t * from this message. */\n\t\tif (p1 == start)\n\t\t\tbreak;\n\t\t/* OK, next line then */\n\t}\n\treturn count - ofs;\n}\n\n/* Generate a random key for a WebSocket Handshake in respect with rfc6455\n * The key is 128-bits long encoded as a base64 string in <key_out> parameter\n * (25 bytes long).\n */\nvoid h1_generate_random_ws_input_key(char key_out[25])\n{\n\t/* generate a random websocket key */\n\tconst uint64_t rand1 = ha_random64(), rand2 = ha_random64();\n\tchar key[16];\n\n\tmemcpy(key, &rand1, 8);\n\tmemcpy(&key[8], &rand2, 8);\n\ta2base64(key, 16, key_out, 25);\n}\n\n#define H1_WS_KEY_SUFFIX_GUID \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n\n/*\n * Calculate the WebSocket handshake response key from <key_in>. Following the\n * rfc6455, <key_in> must be 24 bytes longs. The result is  stored in <key_out>\n * as a 29 bytes long string.\n */\nvoid h1_calculate_ws_output_key(const char *key, char *result)\n{\n\tblk_SHA_CTX sha1_ctx;\n\tchar hash_in[60], hash_out[20];\n\n\t/* concatenate the key with a fixed suffix */\n\tmemcpy(hash_in, key, 24);\n\tmemcpy(&hash_in[24], H1_WS_KEY_SUFFIX_GUID, 36);\n\n\t/* sha1 the result */\n\tblk_SHA1_Init(&sha1_ctx);\n\tblk_SHA1_Update(&sha1_ctx, hash_in, 60);\n\tblk_SHA1_Final((unsigned char *)hash_out, &sha1_ctx);\n\n\t/* encode in base64 the hash */\n\ta2base64(hash_out, 20, result, 29);\n}\n", "/*\n * HTTP semantics\n *\n * Copyright 2000-2018 Willy Tarreau <w@1wt.eu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n */\n\n#include <ctype.h>\n#include <haproxy/api.h>\n#include <haproxy/http.h>\n#include <haproxy/tools.h>\n\n/* It is about twice as fast on recent architectures to lookup a byte in a\n * table than to perform a boolean AND or OR between two tests. Refer to\n * RFC2616/RFC5234/RFC7230 for those chars. A token is any ASCII char that is\n * neither a separator nor a CTL char. An http ver_token is any ASCII which can\n * be found in an HTTP version, which includes 'H', 'T', 'P', '/', '.' and any\n * digit. Note: please do not overwrite values in assignment since gcc-2.95\n * will not handle them correctly. It's worth noting that chars 128..255 are\n * nothing, not even control chars.\n */\nconst unsigned char http_char_classes[256] = {\n\t[  0] = HTTP_FLG_CTL,\n\t[  1] = HTTP_FLG_CTL,\n\t[  2] = HTTP_FLG_CTL,\n\t[  3] = HTTP_FLG_CTL,\n\t[  4] = HTTP_FLG_CTL,\n\t[  5] = HTTP_FLG_CTL,\n\t[  6] = HTTP_FLG_CTL,\n\t[  7] = HTTP_FLG_CTL,\n\t[  8] = HTTP_FLG_CTL,\n\t[  9] = HTTP_FLG_SPHT | HTTP_FLG_LWS | HTTP_FLG_SEP | HTTP_FLG_CTL,\n\t[ 10] = HTTP_FLG_CRLF | HTTP_FLG_LWS | HTTP_FLG_CTL,\n\t[ 11] = HTTP_FLG_CTL,\n\t[ 12] = HTTP_FLG_CTL,\n\t[ 13] = HTTP_FLG_CRLF | HTTP_FLG_LWS | HTTP_FLG_CTL,\n\t[ 14] = HTTP_FLG_CTL,\n\t[ 15] = HTTP_FLG_CTL,\n\t[ 16] = HTTP_FLG_CTL,\n\t[ 17] = HTTP_FLG_CTL,\n\t[ 18] = HTTP_FLG_CTL,\n\t[ 19] = HTTP_FLG_CTL,\n\t[ 20] = HTTP_FLG_CTL,\n\t[ 21] = HTTP_FLG_CTL,\n\t[ 22] = HTTP_FLG_CTL,\n\t[ 23] = HTTP_FLG_CTL,\n\t[ 24] = HTTP_FLG_CTL,\n\t[ 25] = HTTP_FLG_CTL,\n\t[ 26] = HTTP_FLG_CTL,\n\t[ 27] = HTTP_FLG_CTL,\n\t[ 28] = HTTP_FLG_CTL,\n\t[ 29] = HTTP_FLG_CTL,\n\t[ 30] = HTTP_FLG_CTL,\n\t[ 31] = HTTP_FLG_CTL,\n\t[' '] = HTTP_FLG_SPHT | HTTP_FLG_LWS | HTTP_FLG_SEP,\n\t['!'] = HTTP_FLG_TOK,\n\t['\"'] = HTTP_FLG_SEP,\n\t['#'] = HTTP_FLG_TOK,\n\t['$'] = HTTP_FLG_TOK,\n\t['%'] = HTTP_FLG_TOK,\n\t['&'] = HTTP_FLG_TOK,\n\t[ 39] = HTTP_FLG_TOK,\n\t['('] = HTTP_FLG_SEP,\n\t[')'] = HTTP_FLG_SEP,\n\t['*'] = HTTP_FLG_TOK,\n\t['+'] = HTTP_FLG_TOK,\n\t[','] = HTTP_FLG_SEP,\n\t['-'] = HTTP_FLG_TOK,\n\t['.'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['/'] = HTTP_FLG_SEP | HTTP_FLG_VER,\n\t['0'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['1'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['2'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['3'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['4'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['5'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['6'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['7'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['8'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['9'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t[':'] = HTTP_FLG_SEP,\n\t[';'] = HTTP_FLG_SEP,\n\t['<'] = HTTP_FLG_SEP,\n\t['='] = HTTP_FLG_SEP,\n\t['>'] = HTTP_FLG_SEP,\n\t['?'] = HTTP_FLG_SEP,\n\t['@'] = HTTP_FLG_SEP,\n\t['A'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['B'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['C'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['D'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['E'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['F'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['G'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['H'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['I'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['J'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['K'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['L'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['M'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['N'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['O'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['P'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['Q'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['R'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['S'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['T'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['U'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['V'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['W'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['X'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['Y'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['Z'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['['] = HTTP_FLG_SEP,\n\t[ 92] = HTTP_FLG_SEP,\n\t[']'] = HTTP_FLG_SEP,\n\t['^'] = HTTP_FLG_TOK,\n\t['_'] = HTTP_FLG_TOK,\n\t['`'] = HTTP_FLG_TOK,\n\t['a'] = HTTP_FLG_TOK,\n\t['b'] = HTTP_FLG_TOK,\n\t['c'] = HTTP_FLG_TOK,\n\t['d'] = HTTP_FLG_TOK,\n\t['e'] = HTTP_FLG_TOK,\n\t['f'] = HTTP_FLG_TOK,\n\t['g'] = HTTP_FLG_TOK,\n\t['h'] = HTTP_FLG_TOK,\n\t['i'] = HTTP_FLG_TOK,\n\t['j'] = HTTP_FLG_TOK,\n\t['k'] = HTTP_FLG_TOK,\n\t['l'] = HTTP_FLG_TOK,\n\t['m'] = HTTP_FLG_TOK,\n\t['n'] = HTTP_FLG_TOK,\n\t['o'] = HTTP_FLG_TOK,\n\t['p'] = HTTP_FLG_TOK,\n\t['q'] = HTTP_FLG_TOK,\n\t['r'] = HTTP_FLG_TOK,\n\t['s'] = HTTP_FLG_TOK,\n\t['t'] = HTTP_FLG_TOK,\n\t['u'] = HTTP_FLG_TOK,\n\t['v'] = HTTP_FLG_TOK,\n\t['w'] = HTTP_FLG_TOK,\n\t['x'] = HTTP_FLG_TOK,\n\t['y'] = HTTP_FLG_TOK,\n\t['z'] = HTTP_FLG_TOK,\n\t['{'] = HTTP_FLG_SEP,\n\t['|'] = HTTP_FLG_TOK,\n\t['}'] = HTTP_FLG_SEP,\n\t['~'] = HTTP_FLG_TOK,\n\t[127] = HTTP_FLG_CTL,\n};\n\nconst int http_err_codes[HTTP_ERR_SIZE] = {\n\t[HTTP_ERR_200] = 200,  /* used by \"monitor-uri\" */\n\t[HTTP_ERR_400] = 400,\n\t[HTTP_ERR_401] = 401,\n\t[HTTP_ERR_403] = 403,\n\t[HTTP_ERR_404] = 404,\n\t[HTTP_ERR_405] = 405,\n\t[HTTP_ERR_407] = 407,\n\t[HTTP_ERR_408] = 408,\n\t[HTTP_ERR_410] = 410,\n\t[HTTP_ERR_413] = 413,\n\t[HTTP_ERR_421] = 421,\n\t[HTTP_ERR_422] = 422,\n\t[HTTP_ERR_425] = 425,\n\t[HTTP_ERR_429] = 429,\n\t[HTTP_ERR_500] = 500,\n\t[HTTP_ERR_501] = 501,\n\t[HTTP_ERR_502] = 502,\n\t[HTTP_ERR_503] = 503,\n\t[HTTP_ERR_504] = 504,\n};\n\nconst char *http_err_msgs[HTTP_ERR_SIZE] = {\n\t[HTTP_ERR_200] =\n\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\"Content-length: 58\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>200 OK</h1>\\nService ready.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_400] =\n\t\"HTTP/1.1 400 Bad request\\r\\n\"\n\t\"Content-length: 90\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Connection: close\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>400 Bad request</h1>\\nYour browser sent an invalid request.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_401] =\n\t\"HTTP/1.1 401 Unauthorized\\r\\n\"\n\t\"Content-length: 112\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>401 Unauthorized</h1>\\nYou need a valid user and password to access this content.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_403] =\n\t\"HTTP/1.1 403 Forbidden\\r\\n\"\n\t\"Content-length: 93\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>403 Forbidden</h1>\\nRequest forbidden by administrative rules.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_404] =\n\t\"HTTP/1.1 404 Not Found\\r\\n\"\n\t\"Content-length: 83\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>404 Not Found</h1>\\nThe resource could not be found.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_405] =\n\t\"HTTP/1.1 405 Method Not Allowed\\r\\n\"\n\t\"Content-length: 146\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>405 Method Not Allowed</h1>\\nA request was made of a resource using a request method not supported by that resource\\n</body></html>\\n\",\n\n\t[HTTP_ERR_407] =\n\t\"HTTP/1.1 407 Unauthorized\\r\\n\"\n\t\"Content-length: 112\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>407 Unauthorized</h1>\\nYou need a valid user and password to access this content.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_408] =\n\t\"HTTP/1.1 408 Request Time-out\\r\\n\"\n\t\"Content-length: 110\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Connection: close\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>408 Request Time-out</h1>\\nYour browser didn't send a complete request in time.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_410] =\n\t\"HTTP/1.1 410 Gone\\r\\n\"\n\t\"Content-length: 114\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>410 Gone</h1>\\nThe resource is no longer available and will not be available again.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_413] =\n\t\"HTTP/1.1 413 Payload Too Large\\r\\n\"\n\t\"Content-length: 106\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>413 Payload Too Large</h1>\\nThe request entity exceeds the maximum allowed.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_421] =\n\t\"HTTP/1.1 421 Misdirected Request\\r\\n\"\n\t\"Content-length: 104\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>421 Misdirected Request</h1>\\nRequest sent to a non-authoritative server.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_422] =\n\t\"HTTP/1.1 422 Unprocessable Content\\r\\n\"\n\t\"Content-length: 116\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>422 Unprocessable Content</h1>\\nThe server cannot process the contained instructions.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_425] =\n\t\"HTTP/1.1 425 Too Early\\r\\n\"\n\t\"Content-length: 80\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>425 Too Early</h1>\\nYour browser sent early data.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_429] =\n\t\"HTTP/1.1 429 Too Many Requests\\r\\n\"\n\t\"Content-length: 117\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>429 Too Many Requests</h1>\\nYou have sent too many requests in a given amount of time.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_500] =\n\t\"HTTP/1.1 500 Internal Server Error\\r\\n\"\n\t\"Content-length: 97\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>500 Internal Server Error</h1>\\nAn internal server error occurred.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_501] =\n\t\"HTTP/1.1 501 Not Implemented\\r\\n\"\n\t\"Content-length: 136\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>501 Not Implemented</h1>\\n.The server does not support the functionality required to fulfill the request.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_502] =\n\t\"HTTP/1.1 502 Bad Gateway\\r\\n\"\n\t\"Content-length: 107\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>502 Bad Gateway</h1>\\nThe server returned an invalid or incomplete response.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_503] =\n\t\"HTTP/1.1 503 Service Unavailable\\r\\n\"\n\t\"Content-length: 107\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>503 Service Unavailable</h1>\\nNo server is available to handle this request.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_504] =\n\t\"HTTP/1.1 504 Gateway Time-out\\r\\n\"\n\t\"Content-length: 92\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>504 Gateway Time-out</h1>\\nThe server didn't respond in time.\\n</body></html>\\n\",\n};\n\nconst struct ist http_known_methods[HTTP_METH_OTHER] = {\n\t[HTTP_METH_OPTIONS] = IST(\"OPTIONS\"),\n\t[HTTP_METH_GET]     = IST(\"GET\"),\n\t[HTTP_METH_HEAD]    = IST(\"HEAD\"),\n\t[HTTP_METH_POST]    = IST(\"POST\"),\n\t[HTTP_METH_PUT]     = IST(\"PUT\"),\n\t[HTTP_METH_DELETE]  = IST(\"DELETE\"),\n\t[HTTP_METH_TRACE]   = IST(\"TRACE\"),\n\t[HTTP_METH_CONNECT] = IST(\"CONNECT\"),\n};\n\n/*\n * returns a known method among HTTP_METH_* or HTTP_METH_OTHER for all unknown\n * ones.\n */\nenum http_meth_t find_http_meth(const char *str, const int len)\n{\n\tconst struct ist m = ist2(str, len);\n\n\tif      (isteq(m, ist(\"GET\")))     return HTTP_METH_GET;\n\telse if (isteq(m, ist(\"HEAD\")))    return HTTP_METH_HEAD;\n\telse if (isteq(m, ist(\"POST\")))    return HTTP_METH_POST;\n\telse if (isteq(m, ist(\"CONNECT\"))) return HTTP_METH_CONNECT;\n\telse if (isteq(m, ist(\"PUT\")))     return HTTP_METH_PUT;\n\telse if (isteq(m, ist(\"OPTIONS\"))) return HTTP_METH_OPTIONS;\n\telse if (isteq(m, ist(\"DELETE\")))  return HTTP_METH_DELETE;\n\telse if (isteq(m, ist(\"TRACE\")))   return HTTP_METH_TRACE;\n\telse                               return HTTP_METH_OTHER;\n}\n\n/* This function returns HTTP_ERR_<num> (enum) matching http status code.\n * Returned value should match codes from http_err_codes.\n */\nint http_get_status_idx(unsigned int status)\n{\n\tswitch (status) {\n\tcase 200: return HTTP_ERR_200;\n\tcase 400: return HTTP_ERR_400;\n\tcase 401: return HTTP_ERR_401;\n\tcase 403: return HTTP_ERR_403;\n\tcase 404: return HTTP_ERR_404;\n\tcase 405: return HTTP_ERR_405;\n\tcase 407: return HTTP_ERR_407;\n\tcase 408: return HTTP_ERR_408;\n\tcase 410: return HTTP_ERR_410;\n\tcase 413: return HTTP_ERR_413;\n\tcase 421: return HTTP_ERR_421;\n\tcase 422: return HTTP_ERR_422;\n\tcase 425: return HTTP_ERR_425;\n\tcase 429: return HTTP_ERR_429;\n\tcase 500: return HTTP_ERR_500;\n\tcase 501: return HTTP_ERR_501;\n\tcase 502: return HTTP_ERR_502;\n\tcase 503: return HTTP_ERR_503;\n\tcase 504: return HTTP_ERR_504;\n\tdefault: return HTTP_ERR_500;\n\t}\n}\n\n/* This function returns a reason associated with the HTTP status.\n * This function never fails, a message is always returned.\n */\nconst char *http_get_reason(unsigned int status)\n{\n\tswitch (status) {\n\tcase 100: return \"Continue\";\n\tcase 101: return \"Switching Protocols\";\n\tcase 102: return \"Processing\";\n\tcase 200: return \"OK\";\n\tcase 201: return \"Created\";\n\tcase 202: return \"Accepted\";\n\tcase 203: return \"Non-Authoritative Information\";\n\tcase 204: return \"No Content\";\n\tcase 205: return \"Reset Content\";\n\tcase 206: return \"Partial Content\";\n\tcase 207: return \"Multi-Status\";\n\tcase 210: return \"Content Different\";\n\tcase 226: return \"IM Used\";\n\tcase 300: return \"Multiple Choices\";\n\tcase 301: return \"Moved Permanently\";\n\tcase 302: return \"Found\";\n\tcase 303: return \"See Other\";\n\tcase 304: return \"Not Modified\";\n\tcase 305: return \"Use Proxy\";\n\tcase 307: return \"Temporary Redirect\";\n\tcase 308: return \"Permanent Redirect\";\n\tcase 310: return \"Too many Redirects\";\n\tcase 400: return \"Bad Request\";\n\tcase 401: return \"Unauthorized\";\n\tcase 402: return \"Payment Required\";\n\tcase 403: return \"Forbidden\";\n\tcase 404: return \"Not Found\";\n\tcase 405: return \"Method Not Allowed\";\n\tcase 406: return \"Not Acceptable\";\n\tcase 407: return \"Proxy Authentication Required\";\n\tcase 408: return \"Request Time-out\";\n\tcase 409: return \"Conflict\";\n\tcase 410: return \"Gone\";\n\tcase 411: return \"Length Required\";\n\tcase 412: return \"Precondition Failed\";\n\tcase 413: return \"Request Entity Too Large\";\n\tcase 414: return \"Request-URI Too Long\";\n\tcase 415: return \"Unsupported Media Type\";\n\tcase 416: return \"Requested range unsatisfiable\";\n\tcase 417: return \"Expectation failed\";\n\tcase 418: return \"I'm a teapot\";\n\tcase 421: return \"Misdirected Request\";\n\tcase 422: return \"Unprocessable Content\";\n\tcase 423: return \"Locked\";\n\tcase 424: return \"Method failure\";\n\tcase 425: return \"Too Early\";\n\tcase 426: return \"Upgrade Required\";\n\tcase 428: return \"Precondition Required\";\n\tcase 429: return \"Too Many Requests\";\n\tcase 431: return \"Request Header Fields Too Large\";\n\tcase 449: return \"Retry With\";\n\tcase 450: return \"Blocked by Windows Parental Controls\";\n\tcase 451: return \"Unavailable For Legal Reasons\";\n\tcase 456: return \"Unrecoverable Error\";\n\tcase 499: return \"client has closed connection\";\n\tcase 500: return \"Internal Server Error\";\n\tcase 501: return \"Not Implemented\";\n\tcase 502: return \"Bad Gateway or Proxy Error\";\n\tcase 503: return \"Service Unavailable\";\n\tcase 504: return \"Gateway Time-out\";\n\tcase 505: return \"HTTP Version not supported\";\n\tcase 506: return \"Variant also negotiate\";\n\tcase 507: return \"Insufficient storage\";\n\tcase 508: return \"Loop detected\";\n\tcase 509: return \"Bandwidth Limit Exceeded\";\n\tcase 510: return \"Not extended\";\n\tcase 511: return \"Network authentication required\";\n\tcase 520: return \"Web server is returning an unknown error\";\n\tdefault:\n\t\tswitch (status) {\n\t\tcase 100 ... 199: return \"Informational\";\n\t\tcase 200 ... 299: return \"Success\";\n\t\tcase 300 ... 399: return \"Redirection\";\n\t\tcase 400 ... 499: return \"Client Error\";\n\t\tcase 500 ... 599: return \"Server Error\";\n\t\tdefault:          return \"Other\";\n\t\t}\n\t}\n}\n\n/* Returns the ist string corresponding to port part (without ':') in the host\n * <host>, IST_NULL if no ':' is found or an empty IST if there is no digit. In\n * the last case, the result is the original ist trimmed to 0. So be sure to test\n * the result length before doing any pointer arithmetic.\n*/\nstruct ist http_get_host_port(const struct ist host)\n{\n\tchar *start, *end, *ptr;\n\n\tstart = istptr(host);\n\tend = istend(host);\n\tfor (ptr = end; ptr > start && isdigit((unsigned char)*--ptr););\n\n\t/* no port found */\n\tif (likely(*ptr != ':'))\n\t\treturn IST_NULL;\n\tif (ptr+1 == end)\n\t\treturn isttrim(host, 0);\n\n\treturn istnext(ist2(ptr, end - ptr));\n}\n\n\n/* Return non-zero if the port <port> is a default port. If the scheme <schm> is\n * set, it is used to detect default ports (HTTP => 80 and HTTPS => 443)\n * port. Otherwise, both are considered as default ports.\n */\nint http_is_default_port(const struct ist schm, const struct ist port)\n{\n\tif (!istlen(port))\n\t\treturn 1;\n\n\tif (!isttest(schm))\n\t\treturn (isteq(port, ist(\"443\")) || isteq(port, ist(\"80\")));\n\telse\n\t\treturn (isteq(port, ist(\"443\")) && isteqi(schm, ist(\"https://\"))) ||\n\t\t\t(isteq(port, ist(\"80\")) && isteqi(schm, ist(\"http://\")));\n}\n\n/* Returns non-zero if the scheme <schm> is syntactically correct according to\n * RFC3986#3.1, otherwise zero. It expects only the scheme and nothing else\n * (particularly not the following \"://\").\n *     Scheme = alpha *(alpha|digit|'+'|'-'|'.')\n */\nint http_validate_scheme(const struct ist schm)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < schm.len; i++) {\n\t\tif (likely((schm.ptr[i] >= 'a' && schm.ptr[i] <= 'z') ||\n\t\t\t   (schm.ptr[i] >= 'A' && schm.ptr[i] <= 'Z')))\n\t\t\tcontinue;\n\t\tif (unlikely(!i)) // first char must be alpha\n\t\t\treturn 0;\n\t\tif ((schm.ptr[i] >= '0' && schm.ptr[i] <= '9') ||\n\t\t    schm.ptr[i] == '+' || schm.ptr[i] == '-' || schm.ptr[i] == '.')\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\treturn !!i;\n}\n\n/* Parse the uri and looks for the scheme. If not found, an empty ist is\n * returned. Otherwise, the ist pointing to the scheme is returned.\n *\n * <parser> must have been initialized via http_uri_parser_init. See the\n * related http_uri_parser documentation for the specific API usage.\n */\nstruct ist http_parse_scheme(struct http_uri_parser *parser)\n{\n\tconst char *ptr, *start, *end;\n\n\tif (parser->state >= URI_PARSER_STATE_SCHEME_DONE)\n\t\tgoto not_found;\n\n\tif (parser->format != URI_PARSER_FORMAT_ABSURI_OR_AUTHORITY)\n\t\tgoto not_found;\n\n\tptr = start = istptr(parser->uri);\n\tend = istend(parser->uri);\n\n\tif (isalpha((unsigned char)*ptr)) {\n\t\t/* this is a scheme as described by RFC3986, par. 3.1, or only\n\t\t * an authority (in case of a CONNECT method).\n\t\t */\n\t\tptr++;\n\t\t/* retrieve the scheme up to the suffix '://'. If the suffix is\n\t\t * not found, this means there is no scheme and it is an\n\t\t * authority-only uri.\n\t\t */\n\t\twhile (ptr < end &&\n\t\t       (isalnum((unsigned char)*ptr) || *ptr == '+' || *ptr == '-' || *ptr == '.'))\n\t\t\tptr++;\n\t\tif (ptr == end || *ptr++ != ':')\n\t\t\tgoto not_found;\n\t\tif (ptr == end || *ptr++ != '/')\n\t\t\tgoto not_found;\n\t\tif (ptr == end || *ptr++ != '/')\n\t\t\tgoto not_found;\n\t}\n\telse {\n\t\tgoto not_found;\n\t}\n\n\tparser->uri = ist2(ptr, end - ptr);\n\tparser->state = URI_PARSER_STATE_SCHEME_DONE;\n\treturn ist2(start, ptr - start);\n\n not_found:\n\tparser->state = URI_PARSER_STATE_SCHEME_DONE;\n\treturn IST_NULL;\n}\n\n/* Parse the uri and looks for the authority, between the scheme and the\n * path. if no_userinfo is not zero, the part before the '@' (including it) is\n * skipped. If not found, an empty ist is returned. Otherwise, the ist pointing\n * on the authority is returned.\n *\n * <parser> must have been initialized via http_uri_parser_init. See the\n * related http_uri_parser documentation for the specific API usage.\n */\nstruct ist http_parse_authority(struct http_uri_parser *parser, int no_userinfo)\n{\n\tconst char *ptr, *start, *end;\n\n\tif (parser->state >= URI_PARSER_STATE_AUTHORITY_DONE)\n\t\tgoto not_found;\n\n\tif (parser->format != URI_PARSER_FORMAT_ABSURI_OR_AUTHORITY)\n\t\tgoto not_found;\n\n\tif (parser->state < URI_PARSER_STATE_SCHEME_DONE)\n\t\thttp_parse_scheme(parser);\n\n\tptr = start = istptr(parser->uri);\n\tend = istend(parser->uri);\n\n\twhile (ptr < end && *ptr != '/') {\n\t\tif (*ptr++ == '@' && no_userinfo)\n\t\t\tstart = ptr;\n\t}\n\n\t/* OK, ptr point on the '/' or the end */\n\n  authority:\n\tparser->uri = ist2(ptr, end - ptr);\n\tparser->state = URI_PARSER_STATE_AUTHORITY_DONE;\n\treturn ist2(start, ptr - start);\n\n  not_found:\n\tparser->state = URI_PARSER_STATE_AUTHORITY_DONE;\n\treturn IST_NULL;\n}\n\n/* Parse the URI from the given transaction (which is assumed to be in request\n * phase) and look for the \"/\" beginning the PATH. If not found, ist2(0,0) is\n * returned. Otherwise the pointer and length are returned.\n *\n * <parser> must have been initialized via http_uri_parser_init. See the\n * related http_uri_parser documentation for the specific API usage.\n */\nstruct ist http_parse_path(struct http_uri_parser *parser)\n{\n\tconst char *ptr, *end;\n\n\tif (parser->state >= URI_PARSER_STATE_PATH_DONE)\n\t\tgoto not_found;\n\n\tif (parser->format == URI_PARSER_FORMAT_EMPTY ||\n\t    parser->format == URI_PARSER_FORMAT_ASTERISK) {\n\t\tgoto not_found;\n\t}\n\n\tptr = istptr(parser->uri);\n\tend = istend(parser->uri);\n\n\t/* If the uri is in absolute-path format, first skip the scheme and\n\t * authority parts. No scheme will be found if the uri is in authority\n\t * format, which indicates that the path won't be present.\n\t */\n\tif (parser->format == URI_PARSER_FORMAT_ABSURI_OR_AUTHORITY) {\n\t\tif (parser->state < URI_PARSER_STATE_SCHEME_DONE) {\n\t\t\t/* If no scheme found, uri is in authority format. No\n\t\t\t * path is present.\n\t\t\t */\n\t\t\tif (!isttest(http_parse_scheme(parser)))\n\t\t\t\tgoto not_found;\n\t\t}\n\n\t\tif (parser->state < URI_PARSER_STATE_AUTHORITY_DONE)\n\t\t\thttp_parse_authority(parser, 1);\n\n\t\tptr = istptr(parser->uri);\n\n\t\tif (ptr == end)\n\t\t\tgoto not_found;\n\t}\n\n\tparser->state = URI_PARSER_STATE_PATH_DONE;\n\treturn ist2(ptr, end - ptr);\n\n not_found:\n\tparser->state = URI_PARSER_STATE_PATH_DONE;\n\treturn IST_NULL;\n}\n\n/* Parse <value> Content-Length header field of an HTTP request. The function\n * checks all possible occurrences of a comma-delimited value, and verifies if\n * any of them doesn't match a previous value. <value> is sanitized on return\n * to contain a single value if several identical values were found.\n *\n * <body_len> must be a valid pointer and is used to return the parsed length\n * unless values differ. Also if <not_first> is true, <body_len> is assumed to\n * point to previously parsed value and which must be equal to the new length.\n * This is useful if an HTTP message contains several Content-Length headers.\n *\n * Returns <0 if a value differs, 0 if the whole header can be dropped (i.e.\n * already known), or >0 if the value can be indexed (first one). In the last\n * case, the value might be adjusted and the caller must only add the updated\n * value.\n */\nint http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}\n\n/*\n * Checks if <hdr> is exactly <name> for <len> chars, and ends with a colon.\n * If so, returns the position of the first non-space character relative to\n * <hdr>, or <end>-<hdr> if not found before. If no value is found, it tries\n * to return a pointer to the place after the first space. Returns 0 if the\n * header name does not match. Checks are case-insensitive.\n */\nint http_header_match2(const char *hdr, const char *end,\n\t\t       const char *name, int len)\n{\n\tconst char *val;\n\n\tif (hdr + len >= end)\n\t\treturn 0;\n\tif (hdr[len] != ':')\n\t\treturn 0;\n\tif (strncasecmp(hdr, name, len) != 0)\n\t\treturn 0;\n\tval = hdr + len + 1;\n\twhile (val < end && HTTP_IS_SPHT(*val))\n\t\tval++;\n\tif ((val >= end) && (len + 2 <= end - hdr))\n\t\treturn len + 2; /* we may replace starting from second space */\n\treturn val - hdr;\n}\n\n/* Find the end of the header value contained between <s> and <e>. See RFC7230,\n * par 3.2 for more information. Note that it requires a valid header to return\n * a valid result. This works for headers defined as comma-separated lists.\n */\nchar *http_find_hdr_value_end(char *s, const char *e)\n{\n\tint quoted, qdpair;\n\n\tquoted = qdpair = 0;\n\n#ifdef HA_UNALIGNED_LE\n\t/* speedup: skip everything not a comma nor a double quote */\n\tfor (; s <= e - sizeof(int); s += sizeof(int)) {\n\t\tunsigned int c = *(int *)s; // comma\n\t\tunsigned int q = c;         // quote\n\n\t\tc ^= 0x2c2c2c2c; // contains one zero on a comma\n\t\tq ^= 0x22222222; // contains one zero on a quote\n\n\t\tc = (c - 0x01010101) & ~c; // contains 0x80 below a comma\n\t\tq = (q - 0x01010101) & ~q; // contains 0x80 below a quote\n\n\t\tif ((c | q) & 0x80808080)\n\t\t\tbreak; // found a comma or a quote\n\t}\n#endif\n\tfor (; s < e; s++) {\n\t\tif (qdpair)                    qdpair = 0;\n\t\telse if (quoted) {\n\t\t\tif (*s == '\\\\')        qdpair = 1;\n\t\t\telse if (*s == '\"')    quoted = 0;\n\t\t}\n\t\telse if (*s == '\"')            quoted = 1;\n\t\telse if (*s == ',')            return s;\n\t}\n\treturn s;\n}\n\n/* Find the end of a cookie value contained between <s> and <e>. It works the\n * same way as with headers above except that the semi-colon also ends a token.\n * See RFC2965 for more information. Note that it requires a valid header to\n * return a valid result.\n */\nchar *http_find_cookie_value_end(char *s, const char *e)\n{\n\tint quoted, qdpair;\n\n\tquoted = qdpair = 0;\n\tfor (; s < e; s++) {\n\t\tif (qdpair)                    qdpair = 0;\n\t\telse if (quoted) {\n\t\t\tif (*s == '\\\\')        qdpair = 1;\n\t\t\telse if (*s == '\"')    quoted = 0;\n\t\t}\n\t\telse if (*s == '\"')            quoted = 1;\n\t\telse if (*s == ',' || *s == ';') return s;\n\t}\n\treturn s;\n}\n\n/* Try to find the next occurrence of a cookie name in a cookie header value.\n * To match on any cookie name, <cookie_name_l> must be set to 0.\n * The lookup begins at <hdr>. The pointer and size of the next occurrence of\n * the cookie value is returned into *value and *value_l, and the function\n * returns a pointer to the next pointer to search from if the value was found.\n * Otherwise if the cookie was not found, NULL is returned and neither value\n * nor value_l are touched. The input <hdr> string should first point to the\n * header's value, and the <hdr_end> pointer must point to the first character\n * not part of the value. <list> must be non-zero if value may represent a list\n * of values (cookie headers). This makes it faster to abort parsing when no\n * list is expected.\n */\nchar *http_extract_cookie_value(char *hdr, const char *hdr_end,\n                                char *cookie_name, size_t cookie_name_l,\n                                int list, char **value, size_t *value_l)\n{\n\tchar *equal, *att_end, *att_beg, *val_beg, *val_end;\n\tchar *next;\n\n\t/* we search at least a cookie name followed by an equal, and more\n\t * generally something like this :\n\t * Cookie:    NAME1  =  VALUE 1  ; NAME2 = VALUE2 ; NAME3 = VALUE3\\r\\n\n\t */\n\tfor (att_beg = hdr; att_beg + cookie_name_l + 1 < hdr_end; att_beg = next + 1) {\n\t\t/* Iterate through all cookies on this line */\n\n\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\tatt_beg++;\n\n\t\t/* find att_end : this is the first character after the last non\n\t\t * space before the equal. It may be equal to hdr_end.\n\t\t */\n\t\tequal = att_end = att_beg;\n\n\t\twhile (equal < hdr_end) {\n\t\t\tif (*equal == '=' || *equal == ';' || (list && *equal == ','))\n\t\t\t\tbreak;\n\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\tcontinue;\n\t\t\tatt_end = equal;\n\t\t}\n\n\t\t/* here, <equal> points to '=', a delimiter or the end. <att_end>\n\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t */\n\n\t\t/* look for end of cookie if there is an equal sign */\n\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t/* look for the beginning of the value */\n\t\t\tval_beg = equal + 1;\n\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\tval_beg++;\n\n\t\t\t/* find the end of the value, respecting quotes */\n\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t/* make val_end point to the first white space or delimiter after the value */\n\t\t\tval_end = next;\n\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\tval_end--;\n\t\t} else {\n\t\t\tval_beg = val_end = next = equal;\n\t\t}\n\n\t\t/* We have nothing to do with attributes beginning with '$'. However,\n\t\t * they will automatically be removed if a header before them is removed,\n\t\t * since they're supposed to be linked together.\n\t\t */\n\t\tif (*att_beg == '$')\n\t\t\tcontinue;\n\n\t\t/* Ignore cookies with no equal sign */\n\t\tif (equal == next)\n\t\t\tcontinue;\n\n\t\t/* Now we have the cookie name between att_beg and att_end, and\n\t\t * its value between val_beg and val_end.\n\t\t */\n\n\t\tif (cookie_name_l == 0 || (att_end - att_beg == cookie_name_l &&\n\t\t    memcmp(att_beg, cookie_name, cookie_name_l) == 0)) {\n\t\t\t/* let's return this value and indicate where to go on from */\n\t\t\t*value = val_beg;\n\t\t\t*value_l = val_end - val_beg;\n\t\t\treturn next + 1;\n\t\t}\n\n\t\t/* Set-Cookie headers only have the name in the first attr=value part */\n\t\tif (!list)\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\n/* Parses a qvalue and returns it multiplied by 1000, from 0 to 1000. If the\n * value is larger than 1000, it is bound to 1000. The parser consumes up to\n * 1 digit, one dot and 3 digits and stops on the first invalid character.\n * Unparsable qvalues return 1000 as \"q=1.000\".\n */\nint http_parse_qvalue(const char *qvalue, const char **end)\n{\n\tint q = 1000;\n\n\tif (!isdigit((unsigned char)*qvalue))\n\t\tgoto out;\n\tq = (*qvalue++ - '0') * 1000;\n\n\tif (*qvalue++ != '.')\n\t\tgoto out;\n\n\tif (!isdigit((unsigned char)*qvalue))\n\t\tgoto out;\n\tq += (*qvalue++ - '0') * 100;\n\n\tif (!isdigit((unsigned char)*qvalue))\n\t\tgoto out;\n\tq += (*qvalue++ - '0') * 10;\n\n\tif (!isdigit((unsigned char)*qvalue))\n\t\tgoto out;\n\tq += (*qvalue++ - '0') * 1;\n out:\n\tif (q > 1000)\n\t\tq = 1000;\n\tif (end)\n\t\t*end = qvalue;\n\treturn q;\n}\n\n/*\n * Given a url parameter, find the starting position of the first occurrence,\n * or NULL if the parameter is not found.\n *\n * Example: if query_string is \"yo=mama;ye=daddy\" and url_param_name is \"ye\",\n * the function will return query_string+8.\n *\n * Warning: this function returns a pointer that can point to the first chunk\n * or the second chunk. The caller must be check the position before using the\n * result.\n */\nconst char *http_find_url_param_pos(const char **chunks,\n                                    const char* url_param_name, size_t url_param_name_l,\n                                    char delim, char insensitive)\n{\n\tconst char *pos, *last, *equal;\n\tconst char **bufs = chunks;\n\tint l1, l2;\n\n\n\tpos  = bufs[0];\n\tlast = bufs[1];\n\twhile (pos < last) {\n\t\t/* Check the equal. */\n\t\tequal = pos + url_param_name_l;\n\t\tif (fix_pointer_if_wrap(chunks, &equal)) {\n\t\t\tif (equal >= chunks[3])\n\t\t\t\treturn NULL;\n\t\t} else {\n\t\t\tif (equal >= chunks[1])\n\t\t\t\treturn NULL;\n\t\t}\n\t\tif (*equal == '=') {\n\t\t\tif (pos + url_param_name_l > last) {\n\t\t\t\t/* process wrap case, we detect a wrap. In this case, the\n\t\t\t\t * comparison is performed in two parts.\n\t\t\t\t */\n\n\t\t\t\t/* This is the end, we don't have any other chunk. */\n\t\t\t\tif (bufs != chunks || !bufs[2])\n\t\t\t\t\treturn NULL;\n\n\t\t\t\t/* Compute the length of each part of the comparison. */\n\t\t\t\tl1 = last - pos;\n\t\t\t\tl2 = url_param_name_l - l1;\n\n\t\t\t\t/* The second buffer is too short to contain the compared string. */\n\t\t\t\tif (bufs[2] + l2 > bufs[3])\n\t\t\t\t\treturn NULL;\n\n\t\t\t\tif (insensitive) {\n\t\t\t\t\tif (strncasecmp(pos,     url_param_name,    l1) == 0 &&\n\t\t\t\t\t\tstrncasecmp(bufs[2], url_param_name+l1, l2) == 0)\n\t\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (memcmp(pos,     url_param_name,    l1) == 0 &&\n\t\t\t\t\t\tmemcmp(bufs[2], url_param_name+l1, l2) == 0)\n\t\t\t\t\t\treturn pos;\n\t\t\t\t}\n\n\t\t\t\t/* Perform wrapping and jump the string who fail the comparison. */\n\t\t\t\tbufs += 2;\n\t\t\t\tpos = bufs[0] + l2;\n\t\t\t\tlast = bufs[1];\n\n\t\t\t} else {\n\t\t\t\t\t/* process a simple comparison.*/\n\t\t\t\tif (insensitive) {\n\t\t\t\t\tif (strncasecmp(pos, url_param_name, url_param_name_l) == 0)\n\t\t\t\t\t\treturn pos;\n\t\t\t\t} else {\n\t\t\t\t\tif (memcmp(pos, url_param_name, url_param_name_l) == 0)\n\t\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t\tpos += url_param_name_l + 1;\n\t\t\t\tif (fix_pointer_if_wrap(chunks, &pos))\n\t\t\t\t\tlast = bufs[2];\n\t\t\t}\n\t\t}\n\n\t\twhile (1) {\n\t\t\t/* Look for the next delimiter. */\n\t\t\twhile (pos < last && !http_is_param_delimiter(*pos, delim))\n\t\t\t\tpos++;\n\t\t\tif (pos < last)\n\t\t\t\tbreak;\n\t\t\t/* process buffer wrapping. */\n\t\t\tif (bufs != chunks || !bufs[2])\n\t\t\t\treturn NULL;\n\t\t\tbufs += 2;\n\t\t\tpos = bufs[0];\n\t\t\tlast = bufs[1];\n\t\t}\n\t\tpos++;\n\t}\n\treturn NULL;\n}\n\n/*\n * Given a url parameter name and a query string, find the next value.\n * An empty url_param_name matches the first available parameter.\n * If the parameter is found, 1 is returned and *vstart / *vend are updated to\n * respectively provide a pointer to the value and its end.\n * Otherwise, 0 is returned and vstart/vend are not modified.\n */\nint http_find_next_url_param(const char **chunks,\n                             const char* url_param_name, size_t url_param_name_l,\n                             const char **vstart, const char **vend, char delim, char insensitive)\n{\n\tconst char *arg_start, *qs_end;\n\tconst char *value_start, *value_end;\n\n\targ_start = chunks[0];\n\tqs_end = chunks[1];\n\tif (url_param_name_l) {\n\t\t/* Looks for an argument name. */\n\t\targ_start = http_find_url_param_pos(chunks,\n\t\t                                    url_param_name, url_param_name_l,\n\t\t                                    delim, insensitive);\n\t\t/* Check for wrapping. */\n\t\tif (arg_start >= qs_end)\n\t\t\tqs_end = chunks[3];\n\t}\n\tif (!arg_start)\n\t\treturn 0;\n\n\tif (!url_param_name_l) {\n\t\twhile (1) {\n\t\t\t/* looks for the first argument. */\n\t\t\tvalue_start = memchr(arg_start, '=', qs_end - arg_start);\n\t\t\tif (!value_start) {\n\t\t\t\t/* Check for wrapping. */\n\t\t\t\tif (arg_start >= chunks[0] &&\n\t\t\t\t    arg_start < chunks[1] &&\n\t\t\t\t    chunks[2]) {\n\t\t\t\t\targ_start = chunks[2];\n\t\t\t\t\tqs_end = chunks[3];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tvalue_start++;\n\t}\n\telse {\n\t\t/* Jump the argument length. */\n\t\tvalue_start = arg_start + url_param_name_l + 1;\n\n\t\t/* Check for pointer wrapping. */\n\t\tif (fix_pointer_if_wrap(chunks, &value_start)) {\n\t\t\t/* Update the end pointer. */\n\t\t\tqs_end = chunks[3];\n\n\t\t\t/* Check for overflow. */\n\t\t\tif (value_start >= qs_end)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvalue_end = value_start;\n\n\twhile (1) {\n\t\twhile ((value_end < qs_end) && !http_is_param_delimiter(*value_end, delim))\n\t\t\tvalue_end++;\n\t\tif (value_end < qs_end)\n\t\t\tbreak;\n\t\t/* process buffer wrapping. */\n\t\tif (value_end >= chunks[0] &&\n\t\t    value_end < chunks[1] &&\n\t\t    chunks[2]) {\n\t\t\tvalue_end = chunks[2];\n\t\t\tqs_end = chunks[3];\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t*vstart = value_start;\n\t*vend = value_end;\n\treturn 1;\n}\n\n/* Parses a single header line (without the CRLF) and splits it into its name\n * and its value. The parsing is pretty naive and just skip spaces.\n */\nint http_parse_header(const struct ist hdr, struct ist *name, struct ist *value)\n{\n        char *p   = hdr.ptr;\n        char *end = p + hdr.len;\n\n        name->len = value->len = 0;\n\n        /* Skip leading spaces */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* Set the header name */\n        name->ptr = p;\n        for (; p < end && HTTP_IS_TOKEN(*p); p++);\n        name->len = p - name->ptr;\n\n        /* Skip the ':' and spaces before and after it */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n        if (p < end && *p == ':') p++;\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* Set the header value */\n        value->ptr = p;\n        value->len = end - p;\n\n        return 1;\n}\n\n/* Parses a single start line (without the CRLF) and splits it into 3 parts. The\n * parsing is pretty naive and just skip spaces.\n */\nint http_parse_stline(const struct ist line, struct ist *p1, struct ist *p2, struct ist *p3)\n{\n        char *p   = line.ptr;\n        char *end = p + line.len;\n\n        p1->len = p2->len = p3->len = 0;\n\n        /* Skip leading spaces */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* Set the first part */\n        p1->ptr = p;\n        for (; p < end && HTTP_IS_TOKEN(*p); p++);\n        p1->len = p - p1->ptr;\n\n        /* Skip spaces between p1 and p2 */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* Set the second part */\n        p2->ptr = p;\n        for (; p < end && !HTTP_IS_SPHT(*p); p++);\n        p2->len = p - p2->ptr;\n\n        /* Skip spaces between p2 and p3 */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* The remaining is the third value */\n        p3->ptr = p;\n        p3->len = end - p;\n\n        return 1;\n}\n\n/* Parses value of a Status header with the following format: \"Status: Code[\n * Reason]\".  The parsing is pretty naive and just skip spaces. It return the\n * numeric value of the status code.\n */\nint http_parse_status_val(const struct ist value, struct ist *status, struct ist *reason)\n{\n\tchar *p   = value.ptr;\n        char *end = p + value.len;\n\tuint16_t code;\n\n\tstatus->len = reason->len = 0;\n\n\t/* Skip leading spaces */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* Set the status part */\n        status->ptr = p;\n        for (; p < end && HTTP_IS_TOKEN(*p); p++);\n        status->len = p - status->ptr;\n\n\t/* Skip spaces between status and reason */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n\t/* the remaining is the reason */\n        reason->ptr = p;\n        reason->len = end - p;\n\n\tcode = strl2ui(status->ptr, status->len);\n\treturn code;\n}\n\n\n/* Returns non-zero if the two ETags are comparable (see RFC 7232#2.3.2).\n * If any of them is a weak ETag, we discard the weakness prefix and perform\n * a strict string comparison.\n * Returns 0 otherwise.\n */\nint http_compare_etags(struct ist etag1, struct ist etag2)\n{\n\tenum http_etag_type etag_type1;\n\tenum http_etag_type etag_type2;\n\n\tetag_type1 = http_get_etag_type(etag1);\n\tetag_type2 = http_get_etag_type(etag2);\n\n\tif (etag_type1 == ETAG_INVALID || etag_type2 == ETAG_INVALID)\n\t\treturn 0;\n\n\t/* Discard the 'W/' prefix an ETag is a weak one. */\n\tif (etag_type1 == ETAG_WEAK)\n\t\tetag1 = istadv(etag1, 2);\n\tif (etag_type2 == ETAG_WEAK)\n\t\tetag2 = istadv(etag2, 2);\n\n\treturn isteq(etag1, etag2);\n}\n\n\n/*\n * Trim leading space or horizontal tab characters from <value> string.\n * Returns the trimmed string.\n */\nstruct ist http_trim_leading_spht(struct ist value)\n{\n\tstruct ist ret = value;\n\n\twhile (ret.len && HTTP_IS_SPHT(ret.ptr[0])) {\n\t\t++ret.ptr;\n\t\t--ret.len;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Trim trailing space or horizontal tab characters from <value> string.\n * Returns the trimmed string.\n */\nstruct ist http_trim_trailing_spht(struct ist value)\n{\n\tstruct ist ret = value;\n\n\twhile (ret.len && HTTP_IS_SPHT(ret.ptr[-1]))\n\t\t--ret.len;\n\n\treturn ret;\n}\n"], "fixing_code": ["varnishtest \"HTTP request tests: H1 to H1 (HTX mode supported only for HAProxy >= 1.9)\"\n\n# Run it with HAPROXY_PROGRAM=$PWD/haproxy varnishtest -l -k -t 1 \"$1\"\n\nfeature ignore_unknown_macro\n\nserver s1 {\n\t##\n\t## Handle GET requests\n\t##\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 1\"\n\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 2\"\n\n\trxreq\n\texpect req.bodylen == 38\n\texpect req.body == \"this must be delivered, like it or not\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 3\"\n\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 4\"\n\n\taccept\n\n\t##\n\t## Handle HEAD requests\n\t##\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 1\"\n\n\taccept\n\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 2\"\n\n\taccept\n\n\trxreq\n\texpect req.bodylen == 38\n\texpect req.body == \"this must be delivered, like it or not\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 3\"\n\n\taccept\n\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 4\"\n\n\taccept\n\n\t##\n\t## Handle POST requests\n\t##\n\t# POST request without body\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 1\"\n\n\t# POST request without body\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 2\"\n\n\t# POST request with a body\n\trxreq\n\texpect req.bodylen == 12\n\texpect req.body == \"this is sent\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 3\"\n\n\t# POST request without body\n\trxreq\n\texpect req.bodylen == 0\n\texpect req.body == \"\"\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 4\"\n} -repeat 3 -start\n\nhaproxy h1 -conf {\n    global\n        # WT: limit false-positives causing \"HTTP header incomplete\" due to\n        # idle server connections being randomly used and randomly expiring\n        # under us.\n        tune.idle-pool.shared off\n\n    defaults\n\tmode http\n\ttimeout connect \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\ttimeout client  \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\ttimeout server  \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\n    listen feh1\n\tbind \"fd@${feh1}\"\n\t#bind \"fd@${feh2}\" proto h2\n\tserver s1 ${s1_addr}:${s1_port}\n} -start\n\n# GET requests\nclient c1h1 -connect ${h1_feh1_sock} {\n\t# first request is valid\n\ttxreq \\\n\t  -req \"GET\" \\\n\t  -url \"/test1.html\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 1\"\n\n\t# second request is valid and advertises C-L:0\n\ttxreq \\\n\t  -req \"GET\" \\\n\t  -url \"/test2.html\" \\\n          -hdr \"content-length: 0\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 2\"\n\n\t# third request sends a body with a GET\n\ttxreq \\\n\t  -req \"GET\" \\\n\t  -url \"/test3.html\" \\\n          -body \"this must be delivered, like it or not\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 3\"\n\n\t# fourth request is valid and advertises C-L:0, and close, and is\n\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which must be\n\t# dropped.\n\ttxreq \\\n\t  -req \"GET\" \\\n\t  -url \"/test4.html\" \\\n          -hdr \"content-length: 0\" \\\n          -hdr \"connection: close\"\n\t# \"this is not sent\"\n\tsendhex \"74787973207973206E6F742073656E740D0A0D0A\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 4\"\n\n\t# the connection is expected to be closed and no more response must\n\t# arrive here.\n\texpect_close\n} -run\n\n# HEAD requests\n# Note: for now they fail with varnishtest, which expects the amount of\n# data advertised in the content-length response.\nclient c2h1 -connect ${h1_feh1_sock} {\n\t# first request is valid\n\ttxreq \\\n\t  -req \"HEAD\" \\\n\t  -url \"/test11.html\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"\"\n\n\t# second request is valid and advertises C-L:0\n\ttxreq \\\n\t  -req \"HEAD\" \\\n\t  -url \"/test12.html\" \\\n          -hdr \"content-length: 0\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"\"\n\n\t# third request sends a body with a HEAD\n\ttxreq \\\n\t  -req \"HEAD\" \\\n\t  -url \"/test13.html\" \\\n          -body \"this must be delivered, like it or not\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"\"\n\n\t# fourth request is valid and advertises C-L:0, and close, and is\n\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which must be\n\t# dropped.\n\ttxreq \\\n\t  -req \"HEAD\" \\\n\t  -url \"/test14.html\" \\\n          -hdr \"content-length: 0\" \\\n          -hdr \"connection: close\"\n\t# \"this is not sent\"\n\tsendhex \"74787973207973206E6F742073656E740D0A0D0A\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"\"\n\n\t# the connection is expected to be closed and no more response must\n\t# arrive here.\n\texpect_close\n} -run\n\nclient c3h1 -connect ${h1_feh1_sock} {\n\t# first request is valid\n\ttxreq \\\n\t  -req \"POST\" \\\n\t  -url \"/test21.html\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 1\"\n\n\t# second request is valid and advertises C-L:0\n\ttxreq \\\n\t  -req \"POST\" \\\n\t  -url \"/test22.html\" \\\n          -hdr \"content-length: 0\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 2\"\n\n\t# third request is valid and advertises (and sends) some contents\n\ttxreq \\\n\t  -req \"POST\" \\\n\t  -url \"/test23.html\" \\\n\t  -body \"this is sent\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 3\"\n\n\t# fourth request is valid and advertises C-L:0, and close, and is\n\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which must be\n\t# dropped.\n\ttxreq \\\n\t  -req \"POST\" \\\n\t  -url \"/test24.html\" \\\n          -hdr \"content-length: 0\" \\\n          -hdr \"connection: close\"\n\t# \"this is not sent\"\n\tsendhex \"74787973207973206E6F742073656E740D0A0D0A\"\n\trxresp\n\texpect resp.status == 200\n\texpect resp.body == \"response 4\"\n\n\t# the connection is expected to be closed and no more response must\n\t# arrive here.\n\texpect_close\n} -run\n\nclient c4h1 -connect ${h1_feh1_sock} {\n\t# this request is invalid and advertises an invalid C-L ending with an\n        # empty value, which results in a stream error.\n\ttxreq \\\n\t  -req \"GET\" \\\n\t  -url \"/test31.html\" \\\n          -hdr \"content-length: 0,\" \\\n          -hdr \"connection: close\"\n\trxresp\n\texpect resp.status == 400\n\texpect_close\n} -run\n\nclient c5h1 -connect ${h1_feh1_sock} {\n\t# this request is invalid and advertises an empty C-L, which results\n\t# in a stream error.\n\ttxreq \\\n\t  -req \"GET\" \\\n\t  -url \"/test41.html\" \\\n          -hdr \"content-length:\" \\\n          -hdr \"connection: close\"\n\trxresp\n\texpect resp.status == 400\n\texpect_close\n} -run\n", "varnishtest \"HTTP request tests: H2 to H1 (HTX and legacy mode)\"\n\n# Run it with HAPROXY_PROGRAM=$PWD/haproxy varnishtest -l -k -t 1 \"$1\"\n\nfeature ignore_unknown_macro\n\n# synchronize requests between streams\nbarrier b1 cond 2 -cyclic\nbarrier b2 cond 2 -cyclic\nbarrier b3 cond 2 -cyclic\nbarrier b4 cond 2 -cyclic\nbarrier b5 cond 2 -cyclic\nbarrier b6 cond 2 -cyclic\n\nserver s1 {\n\trxreq\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 1\"\n\n\tbarrier b2 sync\n\trxreq\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 2\"\n\n\tbarrier b3 sync\n\trxreq\n\ttxresp \\\n\t  -status 200 \\\n\t  -body \"response 3\"\n\n\tbarrier b4 sync\n\t# the next request is never received\n\n\tbarrier b5 sync\n\t# the next request is never received\n\n\tbarrier b6 sync\n\t# the next request is never received\n} -repeat 2 -start\n\nhaproxy h1 -conf {\n    global\n        # WT: limit false-positives causing \"HTTP header incomplete\" due to\n        # idle server connections being randomly used and randomly expiring\n        # under us.\n        tune.idle-pool.shared off\n\n    defaults\n\t#log stdout format raw daemon\n\tmode http\n\toption http-buffer-request\n\ttimeout connect \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\ttimeout client  \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\ttimeout server  \"${HAPROXY_TEST_TIMEOUT-5s}\"\n\n    listen feh1\n\tbind \"fd@${feh1}\"\n\tbind \"fd@${feh2}\" proto h2\n\tserver s1 ${s1_addr}:${s1_port}\n} -start\n\nclient c1h2 -connect ${h1_feh2_sock} {\n\ttxpri\n\tstream 0 {\n\t\ttxsettings\n\t\trxsettings\n\t\ttxsettings -ack\n\t\trxsettings\n\t\texpect settings.ack == true\n\t} -run\n\n\t# first request is valid\n\tstream 1 {\n\t\ttxreq \\\n\t\t  -req \"GET\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test1.html\"\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 1\"\n\t} -run\n\n\t# second request is valid and advertises C-L:0\n\tstream 3 {\n\t\tbarrier b2 sync\n\t\ttxreq \\\n\t\t  -req \"GET\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test2.html\" \\\n\t\t  -hdr \"content-length\" \"0\"\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 2\"\n\t} -run\n\n\t# third request sends a body with a GET\n\tstream 5 {\n\t\tbarrier b3 sync\n\t\ttxreq \\\n\t\t  -req \"GET\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test3.html\" \\\n\t\t  -nostrend \\\n\t\t  -body \"this must be delivered, like it or not\"\n\t\trxwinup\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 3\"\n\t} -run\n\n\t# fourth request is valid and advertises C-L:2, and close, and is\n\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which causes a\n\t# stream error of type PROTOCOL_ERROR.\n\tstream 7 {\n\t\tbarrier b4 sync\n\t\ttxreq \\\n\t\t  -req \"GET\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test4.html\" \\\n\t\t  -hdr \"content-length\" \"2\" \\\n\t\t  -nostrend\n\t\ttxdata -data \"this is sent and ignored\"\n\t\trxrst\n\t} -run\n\n\t# fifth request is invalid and advertises an invalid C-L ending with an\n        # empty value, which results in a stream error.\n\tstream 9 {\n\t\tbarrier b5 sync\n\t\ttxreq \\\n\t\t  -req \"GET\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test5.html\" \\\n\t\t  -hdr \"content-length\" \"0,\" \\\n\t\t  -nostrend\n\t\trxrst\n\t} -run\n\n\t# sixth request is invalid and advertises an empty C-L, which results\n\t# in a stream error.\n\tstream 11 {\n\t\tbarrier b6 sync\n\t\ttxreq \\\n\t\t  -req \"GET\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test6.html\" \\\n\t\t  -hdr \"content-length\" \"\" \\\n\t\t  -nostrend\n\t\trxrst\n\t} -run\n} -run\n\n# HEAD requests : don't work well yet\n#client c2h2 -connect ${h1_feh2_sock} {\n#\ttxpri\n#\tstream 0 {\n#\t\ttxsettings\n#\t\trxsettings\n#\t\ttxsettings -ack\n#\t\trxsettings\n#\t\texpect settings.ack == true\n#\t} -run\n#\n#\t# first request is valid\n#\tstream 1 {\n#\t\ttxreq \\\n#\t\t  -req \"HEAD\" \\\n#\t\t  -scheme \"https\" \\\n#\t\t  -url \"/test11.html\"\n#\t\trxhdrs\n#\t\texpect resp.status == 200\n#\t\trxdata -all\n#\t\texpect resp.bodylen == 0\n#\t} -run\n#\n#\t# second request is valid and advertises C-L:0\n#\tstream 3 {\n#\t\tbarrier b2 sync\n#\t\ttxreq \\\n#\t\t  -req \"HEAD\" \\\n#\t\t  -scheme \"https\" \\\n#\t\t  -url \"/test12.html\" \\\n#\t\t  -hdr \"content-length\" \"0\"\n#\t\trxhdrs\n#\t\texpect resp.status == 200\n#\t\trxdata -all\n#\t\texpect resp.bodylen == 0\n#\t} -run\n#\n#\t# third request sends a body with a GET\n#\tstream 5 {\n#\t\tbarrier b3 sync\n#\t\ttxreq \\\n#\t\t  -req \"HEAD\" \\\n#\t\t  -scheme \"https\" \\\n#\t\t  -url \"/test13.html\" \\\n#\t\t  -nostrend \\\n#\t\t  -body \"this must be delivered, like it or not\"\n#\t\trxwinup\n#\t\trxhdrs\n#\t\texpect resp.status == 200\n#\t\trxdata -all\n#\t\texpect resp.bodylen == 0\n#\t} -run\n#\n#\t# fourth request is valid and advertises C-L:0, and close, and is\n#\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which must be\n#\t# dropped.\n#\tstream 7 {\n#\t\tbarrier b4 sync\n#\t\ttxreq \\\n#\t\t  -req \"HEAD\" \\\n#\t\t  -scheme \"https\" \\\n#\t\t  -url \"/test14.html\" \\\n#\t\t  -hdr \"content-length\" \"0\" \\\n#\t\t  -nostrend\n#\t\ttxdata -data \"this is sent and ignored\"\n#\t\trxwinup\n#\t\trxhdrs\n#\t\texpect resp.status == 200\n#\t\trxdata -all\n#\t\texpect resp.bodylen == 0\n#\t} -run\n#} -run\n\n# POST requests\nclient c3h2 -connect ${h1_feh2_sock} {\n\ttxpri\n\tstream 0 {\n\t\ttxsettings\n\t\trxsettings\n\t\ttxsettings -ack\n\t\trxsettings\n\t\texpect settings.ack == true\n\t} -run\n\n\t# first request is valid\n\tstream 1 {\n\t\ttxreq \\\n\t\t  -req \"POST\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test21.html\"\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 1\"\n\t} -run\n\n\t# second request is valid and advertises C-L:0\n\tstream 3 {\n\t\tbarrier b2 sync\n\t\ttxreq \\\n\t\t  -req \"POST\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test22.html\" \\\n\t\t  -hdr \"content-length\" \"0\"\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 2\"\n\t} -run\n\n\t# third request sends a body with a GET\n\tstream 5 {\n\t\tbarrier b3 sync\n\t\ttxreq \\\n\t\t  -req \"POST\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test23.html\" \\\n\t\t  -nostrend \\\n\t\t  -body \"this must be delivered, like it or not\"\n\t\trxwinup\n\t\trxhdrs\n\t\texpect resp.status == 200\n\t\trxdata -all\n\t\texpect resp.body == \"response 3\"\n\t} -run\n\n\t# fourth request is valid and advertises C-L:2, and close, and is\n\t# followed by a string \"this is not sent\\r\\n\\r\\n\" which results\n\t# in a stream error.\n\tstream 7 {\n\t\tbarrier b4 sync\n\t\ttxreq \\\n\t\t  -req \"POST\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test24.html\" \\\n\t\t  -hdr \"content-length\" \"2\" \\\n\t\t  -nostrend\n\t\ttxdata -data \"this is sent and ignored\"\n\t\trxrst\n\t} -run\n\n\t# fifth request is invalid and advertises invalid C-L ending with an\n        # empty value, which results in a stream error.\n\tstream 9 {\n\t\tbarrier b5 sync\n\t\ttxreq \\\n\t\t  -req \"POST\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test25.html\" \\\n\t\t  -hdr \"content-length\" \"0,\" \\\n\t\t  -nostrend\n\t\trxrst\n\t} -run\n\n\t# sixth request is invalid and advertises an empty C-L, which results\n\t# in a stream error.\n\tstream 11 {\n\t\tbarrier b6 sync\n\t\ttxreq \\\n\t\t  -req \"POST\" \\\n\t\t  -scheme \"https\" \\\n\t\t  -url \"/test26.html\" \\\n\t\t  -hdr \"content-length\" \"\" \\\n\t\t  -nostrend\n\t\trxrst\n\t} -run\n} -run\n", "/*\n * HTTP/1 protocol analyzer\n *\n * Copyright 2000-2017 Willy Tarreau <w@1wt.eu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n */\n\n#include <ctype.h>\n\n#include <import/sha1.h>\n\n#include <haproxy/api.h>\n#include <haproxy/base64.h>\n#include <haproxy/h1.h>\n#include <haproxy/http-hdr.h>\n#include <haproxy/tools.h>\n\n/* Parse the Content-Length header field of an HTTP/1 request. The function\n * checks all possible occurrences of a comma-delimited value, and verifies\n * if any of them doesn't match a previous value. It returns <0 if a value\n * differs, 0 if the whole header can be dropped (i.e. already known), or >0\n * if the value can be indexed (first one). In the last case, the value might\n * be adjusted and the caller must only add the updated value.\n */\nint h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t}\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}\n\n/* Parse the Transfer-Encoding: header field of an HTTP/1 request, looking for\n * \"chunked\" encoding to perform some checks (it must be the last encoding for\n * the request and must not be performed twice for any message). The\n * H1_MF_TE_CHUNKED is set if a valid \"chunked\" encoding is found. The\n * H1_MF_TE_OTHER flag is set if any other encoding is found. The H1_MF_XFER_ENC\n * flag is always set. The H1_MF_CHNK is set when \"chunked\" encoding is the last\n * one. Note that transfer codings are case-insensitive (cf RFC7230#4). This\n * function returns <0 if a error is found, 0 if the whole header can be dropped\n * (not used yet), or >0 if the value can be indexed.\n */\nint h1_parse_xfer_enc_header(struct h1m *h1m, struct ist value)\n{\n\tchar *e, *n;\n\tstruct ist word;\n\n\th1m->flags |= H1_MF_XFER_ENC;\n\n\tword.ptr = value.ptr - 1; // -1 for next loop's pre-increment\n\te = istend(value);\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (HTTP_IS_LWS(*word.ptr))\n\t\t\tcontinue;\n\n\t\tn = http_find_hdr_value_end(word.ptr, e); // next comma or end of line\n\t\tword.len = n - word.ptr;\n\n\t\t/* trim trailing blanks */\n\t\twhile (word.len && HTTP_IS_LWS(word.ptr[word.len-1]))\n\t\t\tword.len--;\n\n\t\th1m->flags &= ~H1_MF_CHNK;\n\t\tif (isteqi(word, ist(\"chunked\"))) {\n\t\t\tif (h1m->flags & H1_MF_TE_CHUNKED) {\n\t\t\t\t/* cf RFC7230#3.3.1 : A sender MUST NOT apply\n\t\t\t\t * chunked more than once to a message body\n\t\t\t\t * (i.e., chunking an already chunked message is\n\t\t\t\t * not allowed)\n\t\t\t\t */\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\th1m->flags |= (H1_MF_TE_CHUNKED|H1_MF_CHNK);\n\t\t}\n\t\telse {\n\t\t\tif ((h1m->flags & (H1_MF_RESP|H1_MF_TE_CHUNKED)) == H1_MF_TE_CHUNKED) {\n\t\t\t\t/* cf RFC7230#3.3.1 : If any transfer coding\n\t\t\t\t * other than chunked is applied to a request\n\t\t\t\t * payload body, the sender MUST apply chunked\n\t\t\t\t * as the final transfer coding to ensure that\n\t\t\t\t * the message is properly framed.\n\t\t\t\t */\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\th1m->flags |= H1_MF_TE_OTHER;\n\t\t}\n\n\t\tword.ptr = n;\n\t}\n\n\treturn 1;\n  fail:\n\treturn -1;\n}\n\n/* Validate the authority and the host header value for CONNECT method. If there\n * is hast header, its value is normalized. 0 is returned on success, -1 if the\n * authority is invalid and -2 if the host is invalid.\n */\nstatic int h1_validate_connect_authority(struct ist authority, struct ist *host_hdr)\n{\n\tstruct ist uri_host, uri_port, host, host_port;\n\n\tif (!isttest(authority))\n\t\tgoto invalid_authority;\n\turi_host = authority;\n\turi_port = http_get_host_port(authority);\n\tif (!istlen(uri_port))\n\t\tgoto invalid_authority;\n\turi_host.len -= (istlen(uri_port) + 1);\n\n\tif (!host_hdr || !isttest(*host_hdr))\n\t\tgoto end;\n\n\t/* Get the port of the host header value, if any */\n\thost = *host_hdr;\n\thost_port = http_get_host_port(*host_hdr);\n\tif (isttest(host_port))\n\t\thost.len -= (istlen(host_port) + 1);\n\n\tif (istlen(host_port)) {\n\t\tif (!isteqi(host, uri_host) || !isteq(host_port, uri_port))\n\t\t\tgoto invalid_host;\n\t\tif (http_is_default_port(IST_NULL, uri_port))\n\t\t\t*host_hdr = host; /* normalize */\n\t}\n\telse {\n\t\tif (!http_is_default_port(IST_NULL, uri_port) || !isteqi(host, uri_host))\n\t\t\tgoto invalid_host;\n\t}\n\n  end:\n\treturn 0;\n\n  invalid_authority:\n\treturn -1;\n\n  invalid_host:\n\treturn -2;\n}\n\n\n/* Validate the authority and the host header value for non-CONNECT method, when\n * an absolute-URI is detected but when it does not exactly match the host\n * value. The idea is to detect default port (http or https). authority and host\n * are defined here. 0 is returned on success, -1 if the host is does not match\n * the authority.\n */\nstatic int h1_validate_mismatch_authority(struct ist scheme, struct ist authority, struct ist host_hdr)\n{\n\tstruct ist uri_host, uri_port, host, host_port;\n\n\tif (!isttest(scheme))\n\t\tgoto mismatch;\n\n\turi_host = authority;\n\turi_port = http_get_host_port(authority);\n\tif (isttest(uri_port))\n\t\turi_host.len -= (istlen(uri_port) + 1);\n\n\thost = host_hdr;\n\thost_port = http_get_host_port(host_hdr);\n\tif (isttest(host_port))\n\t    host.len -= (istlen(host_port) + 1);\n\n\tif (!isttest(uri_port) && !isttest(host_port)) {\n\t\t/* No port on both: we already know the authority does not match\n\t\t * the host value\n\t\t */\n\t\tgoto mismatch;\n\t}\n\telse if (isttest(uri_port) && !http_is_default_port(scheme, uri_port)) {\n\t\t/* here there is no port for the host value and the port for the\n\t\t * authority is not the default one\n\t\t */\n\t\tgoto mismatch;\n\t}\n\telse if (isttest(host_port) && !http_is_default_port(scheme, host_port)) {\n\t\t/* here there is no port for the authority and the port for the\n\t\t * host value is not the default one\n\t\t */\n\t\tgoto mismatch;\n\t}\n\telse {\n\t\t/* the authority or the host value contain a default port and\n\t\t * there is no port on the other value\n\t\t */\n\t\tif (!isteqi(uri_host, host))\n\t\t\tgoto mismatch;\n\t}\n\n\treturn 0;\n\n  mismatch:\n\treturn -1;\n}\n\n\n/* Parse the Connection: header of an HTTP/1 request, looking for \"close\",\n * \"keep-alive\", and \"upgrade\" values, and updating h1m->flags according to\n * what was found there. Note that flags are only added, not removed, so the\n * function is safe for being called multiple times if multiple occurrences\n * are found. If the flag H1_MF_CLEAN_CONN_HDR, the header value is cleaned\n * up from \"keep-alive\" and \"close\" values. To do so, the header value is\n * rewritten in place and its length is updated.\n */\nvoid h1_parse_connection_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n, *p;\n\tstruct ist word;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\tp = value->ptr;\n\te = value->ptr + value->len;\n\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR)\n\t\tvalue->len = 0;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (HTTP_IS_LWS(*word.ptr))\n\t\t\tcontinue;\n\n\t\tn = http_find_hdr_value_end(word.ptr, e); // next comma or end of line\n\t\tword.len = n - word.ptr;\n\n\t\t/* trim trailing blanks */\n\t\twhile (word.len && HTTP_IS_LWS(word.ptr[word.len-1]))\n\t\t\tword.len--;\n\n\t\tif (isteqi(word, ist(\"keep-alive\"))) {\n\t\t\th1m->flags |= H1_MF_CONN_KAL;\n\t\t\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR)\n\t\t\t\tgoto skip_val;\n\t\t}\n\t\telse if (isteqi(word, ist(\"close\"))) {\n\t\t\th1m->flags |= H1_MF_CONN_CLO;\n\t\t\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR)\n\t\t\t\tgoto skip_val;\n\t\t}\n\t\telse if (isteqi(word, ist(\"upgrade\")))\n\t\t\th1m->flags |= H1_MF_CONN_UPG;\n\n\t\tif (h1m->flags & H1_MF_CLEAN_CONN_HDR) {\n\t\t\tif (value->ptr + value->len == p) {\n\t\t\t\t/* no rewrite done till now */\n\t\t\t\tvalue->len = n - value->ptr;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (value->len)\n\t\t\t\t\tvalue->ptr[value->len++] = ',';\n\t\t\t\tistcat(value, word, e - value->ptr);\n\t\t\t}\n\t\t}\n\n\t  skip_val:\n\t\tword.ptr = p = n;\n\t}\n}\n\n/* Parse the Upgrade: header of an HTTP/1 request.\n * If \"websocket\" is found, set H1_MF_UPG_WEBSOCKET flag\n */\nvoid h1_parse_upgrade_header(struct h1m *h1m, struct ist value)\n{\n\tchar *e, *n;\n\tstruct ist word;\n\n\th1m->flags &= ~H1_MF_UPG_WEBSOCKET;\n\n\tword.ptr = value.ptr - 1; // -1 for next loop's pre-increment\n\te = istend(value);\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (HTTP_IS_LWS(*word.ptr))\n\t\t\tcontinue;\n\n\t\tn = http_find_hdr_value_end(word.ptr, e); // next comma or end of line\n\t\tword.len = n - word.ptr;\n\n\t\t/* trim trailing blanks */\n\t\twhile (word.len && HTTP_IS_LWS(word.ptr[word.len-1]))\n\t\t\tword.len--;\n\n\t\tif (isteqi(word, ist(\"websocket\")))\n\t\t\th1m->flags |= H1_MF_UPG_WEBSOCKET;\n\n\t\tword.ptr = n;\n\t}\n}\n\n/* Macros used in the HTTP/1 parser, to check for the expected presence of\n * certain bytes (ef: LF) or to skip to next byte and yield in case of failure.\n */\n\n/* Expects to find an LF at <ptr>. If not, set <state> to <where> and jump to\n * <bad>.\n */\n#define EXPECT_LF_HERE(ptr, bad, state, where)                  \\\n\tdo {                                                    \\\n\t\tif (unlikely(*(ptr) != '\\n')) {                 \\\n\t\t\tstate = (where);                        \\\n\t\t\tgoto bad;                               \\\n\t\t}                                               \\\n\t} while (0)\n\n/* Increments pointer <ptr>, continues to label <more> if it's still below\n * pointer <end>, or goes to <stop> and sets <state> to <where> if the end\n * of buffer was reached.\n */\n#define EAT_AND_JUMP_OR_RETURN(ptr, end, more, stop, state, where)        \\\n\tdo {                                                              \\\n\t\tif (likely(++(ptr) < (end)))                              \\\n\t\t\tgoto more;                                        \\\n\t\telse {                                                    \\\n\t\t\tstate = (where);                                  \\\n\t\t\tgoto stop;                                        \\\n\t\t}                                                         \\\n\t} while (0)\n\n/* This function parses a contiguous HTTP/1 headers block starting at <start>\n * and ending before <stop>, at once, and converts it a list of (name,value)\n * pairs representing header fields into the array <hdr> of size <hdr_num>,\n * whose last entry will have an empty name and an empty value. If <hdr_num> is\n * too small to represent the whole message, an error is returned. Some\n * protocol elements such as content-length and transfer-encoding will be\n * parsed and stored into h1m as well. <hdr> may be null, in which case only\n * the parsing state will be updated. This may be used to restart the parsing\n * where it stopped for example.\n *\n * For now it's limited to the response. If the header block is incomplete,\n * 0 is returned, waiting to be called again with more data to try it again.\n * The caller is responsible for initializing h1m->state to H1_MSG_RPBEFORE,\n * and h1m->next to zero on the first call, the parser will do the rest. If\n * an incomplete message is seen, the caller only needs to present h1m->state\n * and h1m->next again, with an empty header list so that the parser can start\n * again. In this case, it will detect that it interrupted a previous session\n * and will first look for the end of the message before reparsing it again and\n * indexing it at the same time. This ensures that incomplete messages fed 1\n * character at a time are never processed entirely more than exactly twice,\n * and that there is no need to store all the internal state and pre-parsed\n * headers or start line between calls.\n *\n * A pointer to a start line descriptor may be passed in <slp>, in which case\n * the parser will fill it with whatever it found.\n *\n * The code derived from the main HTTP/1 parser above but was simplified and\n * optimized to process responses produced or forwarded by haproxy. The caller\n * is responsible for ensuring that the message doesn't wrap, and should ensure\n * it is complete to avoid having to retry the operation after a failed\n * attempt. The message is not supposed to be invalid, which is why a few\n * properties such as the character set used in the header field names are not\n * checked. In case of an unparsable response message, a negative value will be\n * returned with h1m->err_pos and h1m->err_state matching the location and\n * state where the error was met. Leading blank likes are tolerated but not\n * recommended. If flag H1_MF_HDRS_ONLY is set in h1m->flags, only headers are\n * parsed and the start line is skipped. It is not required to set h1m->state\n * nor h1m->next in this case.\n *\n * This function returns :\n *    -1 in case of error. In this case, h1m->err_state is filled (if h1m is\n *       set) with the state the error occurred in and h1m->err_pos with the\n *       the position relative to <start>\n *    -2 if the output is full (hdr_num reached). err_state and err_pos also\n *       indicate where it failed.\n *     0 in case of missing data.\n *   > 0 on success, it then corresponds to the number of bytes read since\n *       <start> so that the caller can go on with the payload.\n */\nint h1_headers_to_hdr_list(char *start, const char *stop,\n                           struct http_hdr *hdr, unsigned int hdr_num,\n                           struct h1m *h1m, union h1_sl *slp)\n{\n\tenum h1m_state state;\n\tregister char *ptr;\n\tregister const char *end;\n\tunsigned int hdr_count;\n\tunsigned int skip; /* number of bytes skipped at the beginning */\n\tunsigned int sol;  /* start of line */\n\tunsigned int col;  /* position of the colon */\n\tunsigned int eol;  /* end of line */\n\tunsigned int sov;  /* start of value */\n\tunion h1_sl sl;\n\tint skip_update;\n\tint restarting;\n\tint host_idx;\n\tstruct ist n, v;       /* header name and value during parsing */\n\n\tskip = 0; // do it only once to keep track of the leading CRLF.\n\n try_again:\n\thdr_count = sol = col = eol = sov = 0;\n\tsl.st.status = 0;\n\tskip_update = restarting = 0;\n\thost_idx = -1;\n\n\tif (h1m->flags & H1_MF_HDRS_ONLY) {\n\t\tstate = H1_MSG_HDR_FIRST;\n\t\th1m->next = 0;\n\t}\n\telse {\n\t\tstate = h1m->state;\n\t\tif (h1m->state != H1_MSG_RQBEFORE && h1m->state != H1_MSG_RPBEFORE)\n\t\t\trestarting = 1;\n\t}\n\n\tptr   = start + h1m->next;\n\tend   = stop;\n\n\tif (unlikely(ptr >= end))\n\t\tgoto http_msg_ood;\n\n\t/* don't update output if hdr is NULL or if we're restarting */\n\tif (!hdr || restarting)\n\t\tskip_update = 1;\n\n\tswitch (state)\t{\n\tcase H1_MSG_RQBEFORE:\n\thttp_msg_rqbefore:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\t/* we have a start of message, we may have skipped some\n\t\t\t * heading CRLF. Skip them now.\n\t\t\t */\n\t\t\tskip += ptr - start;\n\t\t\tstart = ptr;\n\n\t\t\tsol = 0;\n\t\t\tsl.rq.m.ptr = ptr;\n\t\t\thdr_count = 0;\n\t\t\tstate = H1_MSG_RQMETH;\n\t\t\tgoto http_msg_rqmeth;\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tstate = H1_MSG_RQBEFORE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (unlikely(*ptr == '\\n'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore, http_msg_ood, state, H1_MSG_RQBEFORE);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore_cr, http_msg_ood, state, H1_MSG_RQBEFORE_CR);\n\t\t/* stop here */\n\n\tcase H1_MSG_RQBEFORE_CR:\n\thttp_msg_rqbefore_cr:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RQBEFORE_CR);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqbefore, http_msg_ood, state, H1_MSG_RQBEFORE);\n\t\t/* stop here */\n\n\tcase H1_MSG_RQMETH:\n\thttp_msg_rqmeth:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth, http_msg_ood, state, H1_MSG_RQMETH);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.rq.m.len = ptr - sl.rq.m.ptr;\n\t\t\tsl.rq.meth = find_http_meth(start, sl.rq.m.len);\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth_sp, http_msg_ood, state, H1_MSG_RQMETH_SP);\n\t\t}\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\t/* HTTP 0.9 request */\n\t\t\tsl.rq.m.len = ptr - sl.rq.m.ptr;\n\t\t\tsl.rq.meth = find_http_meth(sl.rq.m.ptr, sl.rq.m.len);\n\t\thttp_msg_req09_uri:\n\t\t\tsl.rq.u.ptr = ptr;\n\t\thttp_msg_req09_uri_e:\n\t\t\tsl.rq.u.len = ptr - sl.rq.u.ptr;\n\t\thttp_msg_req09_ver:\n\t\t\tsl.rq.v = ist2(ptr, 0);\n\t\t\tgoto http_msg_rqline_eol;\n\t\t}\n\t\tstate = H1_MSG_RQMETH;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQMETH_SP:\n\thttp_msg_rqmeth_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.rq.u.ptr = ptr;\n\t\t\tgoto http_msg_rquri;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqmeth_sp, http_msg_ood, state, H1_MSG_RQMETH_SP);\n\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\tgoto http_msg_req09_uri;\n\n\tcase H1_MSG_RQURI:\n\thttp_msg_rquri:\n#ifdef HA_UNALIGNED_LE\n\t\t/* speedup: skip bytes not between 0x24 and 0x7e inclusive */\n\t\twhile (ptr <= end - sizeof(int)) {\n\t\t\tint x = *(int *)ptr - 0x24242424;\n\t\t\tif (x & 0x80808080)\n\t\t\t\tbreak;\n\n\t\t\tx -= 0x5b5b5b5b;\n\t\t\tif (!(x & 0x80808080))\n\t\t\t\tbreak;\n\n\t\t\tptr += sizeof(int);\n\t\t}\n#endif\n\t\tif (ptr >= end) {\n\t\t\tstate = H1_MSG_RQURI;\n\t\t\tgoto http_msg_ood;\n\t\t}\n\thttp_msg_rquri2:\n\t\tif (likely((unsigned char)(*ptr - 33) <= 93)) { /* 33 to 126 included */\n\t\t\tif (*ptr == '#') {\n\t\t\t\tif (h1m->err_pos < -1) /* PR_O2_REQBUG_OK not set */\n\t\t\t\t\tgoto invalid_char;\n\t\t\t\tif (h1m->err_pos == -1) /* PR_O2_REQBUG_OK set: just log */\n\t\t\t\t\th1m->err_pos = ptr - start + skip;\n\t\t\t}\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri2, http_msg_ood, state, H1_MSG_RQURI);\n\t\t}\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.rq.u.len = ptr - sl.rq.u.ptr;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri_sp, http_msg_ood, state, H1_MSG_RQURI_SP);\n\t\t}\n\t\tif (likely((unsigned char)*ptr >= 128)) {\n\t\t\t/* non-ASCII chars are forbidden unless option\n\t\t\t * accept-invalid-http-request is enabled in the frontend.\n\t\t\t * In any case, we capture the faulty char.\n\t\t\t */\n\t\t\tif (h1m->err_pos < -1)\n\t\t\t\tgoto invalid_char;\n\t\t\tif (h1m->err_pos == -1)\n\t\t\t\th1m->err_pos = ptr - start + skip;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri, http_msg_ood, state, H1_MSG_RQURI);\n\t\t}\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\t\tgoto http_msg_req09_uri_e;\n\t\t}\n\n\t\t/* OK forbidden chars, 0..31 or 127 */\n\tinvalid_char:\n\t\tstate = H1_MSG_RQURI;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQURI_SP:\n\thttp_msg_rquri_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.rq.v.ptr = ptr;\n\t\t\tgoto http_msg_rqver;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rquri_sp, http_msg_ood, state, H1_MSG_RQURI_SP);\n\t\t/* so it's a CR/LF, meaning an HTTP 0.9 request */\n\t\tgoto http_msg_req09_ver;\n\n\n\tcase H1_MSG_RQVER:\n\thttp_msg_rqver:\n\t\tif (likely(HTTP_IS_VER_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqver, http_msg_ood, state, H1_MSG_RQVER);\n\n\t\tif (likely(HTTP_IS_CRLF(*ptr))) {\n\t\t\tsl.rq.v.len = ptr - sl.rq.v.ptr;\n\t\thttp_msg_rqline_eol:\n\t\t\t/* We have seen the end of line. Note that we do not\n\t\t\t * necessarily have the \\n yet, but at least we know that we\n\t\t\t * have EITHER \\r OR \\n, otherwise the request would not be\n\t\t\t * complete. We can then record the request length and return\n\t\t\t * to the caller which will be able to register it.\n\t\t\t */\n\n\t\t\tif (likely(!skip_update)) {\n\t\t\t\tif ((sl.rq.v.len == 8) &&\n\t\t\t\t    (*(sl.rq.v.ptr + 5) > '1' ||\n\t\t\t\t     (*(sl.rq.v.ptr + 5) == '1' && *(sl.rq.v.ptr + 7) >= '1')))\n\t\t\t\t\th1m->flags |= H1_MF_VER_11;\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_RQVER;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\t\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\":method\"), sl.rq.m);\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_RQVER;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\t\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\":path\"), sl.rq.u);\n\t\t\t}\n\n\t\t\tsol = ptr - start;\n\t\t\tif (likely(*ptr == '\\r'))\n\t\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rqline_end, http_msg_ood, state, H1_MSG_RQLINE_END);\n\t\t\tgoto http_msg_rqline_end;\n\t\t}\n\n\t\t/* neither an HTTP_VER token nor a CRLF */\n\t\tstate = H1_MSG_RQVER;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RQLINE_END:\n\thttp_msg_rqline_end:\n\t\t/* check for HTTP/0.9 request : no version information\n\t\t * available. sol must point to the first of CR or LF. However\n\t\t * since we don't save these elements between calls, if we come\n\t\t * here from a restart, we don't necessarily know. Thus in this\n\t\t * case we simply start over.\n\t\t */\n\t\tif (restarting)\n\t\t\tgoto restart;\n\n\t\tif (unlikely(sl.rq.v.len == 0))\n\t\t\tgoto http_msg_last_lf;\n\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RQLINE_END);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_first, http_msg_ood, state, H1_MSG_HDR_FIRST);\n\t\t/* stop here */\n\n\t/*\n\t * Common states below\n\t */\n\tcase H1_MSG_RPBEFORE:\n\thttp_msg_rpbefore:\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\t/* we have a start of message, we may have skipped some\n\t\t\t * heading CRLF. Skip them now.\n\t\t\t */\n\t\t\tskip += ptr - start;\n\t\t\tstart = ptr;\n\n\t\t\tsol = 0;\n\t\t\tsl.st.v.ptr = ptr;\n\t\t\thdr_count = 0;\n\t\t\tstate = H1_MSG_RPVER;\n\t\t\tgoto http_msg_rpver;\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tstate = H1_MSG_RPBEFORE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (unlikely(*ptr == '\\n'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore, http_msg_ood, state, H1_MSG_RPBEFORE);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore_cr, http_msg_ood, state, H1_MSG_RPBEFORE_CR);\n\t\t/* stop here */\n\n\tcase H1_MSG_RPBEFORE_CR:\n\thttp_msg_rpbefore_cr:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RPBEFORE_CR);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpbefore, http_msg_ood, state, H1_MSG_RPBEFORE);\n\t\t/* stop here */\n\n\tcase H1_MSG_RPVER:\n\thttp_msg_rpver:\n\t\tif (likely(HTTP_IS_VER_TOKEN(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver, http_msg_ood, state, H1_MSG_RPVER);\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.st.v.len = ptr - sl.st.v.ptr;\n\n\t\t\tif ((sl.st.v.len == 8) &&\n\t\t\t    (*(sl.st.v.ptr + 5) > '1' ||\n\t\t\t     (*(sl.st.v.ptr + 5) == '1' && *(sl.st.v.ptr + 7) >= '1')))\n\t\t\t\th1m->flags |= H1_MF_VER_11;\n\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver_sp, http_msg_ood, state, H1_MSG_RPVER_SP);\n\t\t}\n\t\tstate = H1_MSG_RPVER;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RPVER_SP:\n\thttp_msg_rpver_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.st.status = 0;\n\t\t\tsl.st.c.ptr = ptr;\n\t\t\tgoto http_msg_rpcode;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpver_sp, http_msg_ood, state, H1_MSG_RPVER_SP);\n\t\t/* so it's a CR/LF, this is invalid */\n\t\tstate = H1_MSG_RPVER_SP;\n\t\tgoto http_msg_invalid;\n\n\tcase H1_MSG_RPCODE:\n\thttp_msg_rpcode:\n\t\tif (likely(HTTP_IS_DIGIT(*ptr))) {\n\t\t\tsl.st.status = sl.st.status * 10 + *ptr - '0';\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode, http_msg_ood, state, H1_MSG_RPCODE);\n\t\t}\n\n\t\tif (unlikely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tstate = H1_MSG_RPCODE;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tsl.st.c.len = ptr - sl.st.c.ptr;\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode_sp, http_msg_ood, state, H1_MSG_RPCODE_SP);\n\t\t}\n\n\t\t/* so it's a CR/LF, so there is no reason phrase */\n\t\tsl.st.c.len = ptr - sl.st.c.ptr;\n\n\thttp_msg_rsp_reason:\n\t\tsl.st.r = ist2(ptr, 0);\n\t\tgoto http_msg_rpline_eol;\n\n\tcase H1_MSG_RPCODE_SP:\n\thttp_msg_rpcode_sp:\n\t\tif (likely(!HTTP_IS_LWS(*ptr))) {\n\t\t\tsl.st.r.ptr = ptr;\n\t\t\tgoto http_msg_rpreason;\n\t\t}\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpcode_sp, http_msg_ood, state, H1_MSG_RPCODE_SP);\n\t\t/* so it's a CR/LF, so there is no reason phrase */\n\t\tgoto http_msg_rsp_reason;\n\n\tcase H1_MSG_RPREASON:\n\thttp_msg_rpreason:\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpreason, http_msg_ood, state, H1_MSG_RPREASON);\n\t\tsl.st.r.len = ptr - sl.st.r.ptr;\n\thttp_msg_rpline_eol:\n\t\t/* We have seen the end of line. Note that we do not\n\t\t * necessarily have the \\n yet, but at least we know that we\n\t\t * have EITHER \\r OR \\n, otherwise the response would not be\n\t\t * complete. We can then record the response length and return\n\t\t * to the caller which will be able to register it.\n\t\t */\n\n\t\tif (likely(!skip_update)) {\n\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\tstate = H1_MSG_RPREASON;\n\t\t\t\tgoto http_output_full;\n\t\t\t}\n\t\t\tif (!(h1m->flags & H1_MF_NO_PHDR))\n\t\t\t\thttp_set_hdr(&hdr[hdr_count++], ist(\":status\"), sl.st.c);\n\t\t}\n\n\t\tsol = ptr - start;\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_rpline_end, http_msg_ood, state, H1_MSG_RPLINE_END);\n\t\tgoto http_msg_rpline_end;\n\n\tcase H1_MSG_RPLINE_END:\n\thttp_msg_rpline_end:\n\t\t/* sol must point to the first of CR or LF. */\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_RPLINE_END);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_first, http_msg_ood, state, H1_MSG_HDR_FIRST);\n\t\t/* stop here */\n\n\tcase H1_MSG_HDR_FIRST:\n\thttp_msg_hdr_first:\n\t\tsol = ptr - start;\n\t\tif (likely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tgoto http_msg_hdr_name;\n\t\t}\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_last_lf, http_msg_ood, state, H1_MSG_LAST_LF);\n\t\tgoto http_msg_last_lf;\n\n\tcase H1_MSG_HDR_NAME:\n\thttp_msg_hdr_name:\n\t\t/* assumes sol points to the first char */\n\t\tif (likely(HTTP_IS_TOKEN(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* turn it to lower case if needed */\n\t\t\t\tif (isupper((unsigned char)*ptr) && h1m->flags & H1_MF_TOLOWER)\n\t\t\t\t\t*ptr = tolower((unsigned char)*ptr);\n\t\t\t}\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_name, http_msg_ood, state, H1_MSG_HDR_NAME);\n\t\t}\n\n\t\tif (likely(*ptr == ':')) {\n\t\t\tcol = ptr - start;\n\t\t\tif (col <= sol) {\n\t\t\t\tstate = H1_MSG_HDR_NAME;\n\t\t\t\tgoto http_msg_invalid;\n\t\t\t}\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_sp, http_msg_ood, state, H1_MSG_HDR_L1_SP);\n\t\t}\n\n\t\tif (likely(h1m->err_pos < -1) || *ptr == '\\n') {\n\t\t\tstate = H1_MSG_HDR_NAME;\n\t\t\tgoto http_msg_invalid;\n\t\t}\n\n\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\th1m->err_pos = ptr - start + skip; /* >= 0 now */\n\n\t\t/* and we still accept this non-token character */\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_name, http_msg_ood, state, H1_MSG_HDR_NAME);\n\n\tcase H1_MSG_HDR_L1_SP:\n\thttp_msg_hdr_l1_sp:\n\t\t/* assumes sol points to the first char */\n\t\tif (likely(HTTP_IS_SPHT(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_sp, http_msg_ood, state, H1_MSG_HDR_L1_SP);\n\n\t\t/* header value can be basically anything except CR/LF */\n\t\tsov = ptr - start;\n\n\t\tif (likely(!HTTP_IS_CRLF(*ptr))) {\n\t\t\tgoto http_msg_hdr_val;\n\t\t}\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_lf, http_msg_ood, state, H1_MSG_HDR_L1_LF);\n\t\tgoto http_msg_hdr_l1_lf;\n\n\tcase H1_MSG_HDR_L1_LF:\n\thttp_msg_hdr_l1_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_HDR_L1_LF);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l1_lws, http_msg_ood, state, H1_MSG_HDR_L1_LWS);\n\n\tcase H1_MSG_HDR_L1_LWS:\n\thttp_msg_hdr_l1_lws:\n\t\tif (likely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* replace HT,CR,LF with spaces */\n\t\t\t\tfor (; start + sov < ptr; sov++)\n\t\t\t\t\tstart[sov] = ' ';\n\t\t\t}\n\t\t\tgoto http_msg_hdr_l1_sp;\n\t\t}\n\t\t/* we had a header consisting only in spaces ! */\n\t\teol = sov;\n\t\tgoto http_msg_complete_header;\n\n\tcase H1_MSG_HDR_VAL:\n\thttp_msg_hdr_val:\n\t\t/* assumes sol points to the first char, and sov\n\t\t * points to the first character of the value.\n\t\t */\n\n\t\t/* speedup: we'll skip packs of 4 or 8 bytes not containing bytes 0x0D\n\t\t * and lower. In fact since most of the time is spent in the loop, we\n\t\t * also remove the sign bit test so that bytes 0x8e..0x0d break the\n\t\t * loop, but we don't care since they're very rare in header values.\n\t\t */\n#ifdef HA_UNALIGNED_LE64\n\t\twhile (ptr <= end - sizeof(long)) {\n\t\t\tif ((*(long *)ptr - 0x0e0e0e0e0e0e0e0eULL) & 0x8080808080808080ULL)\n\t\t\t\tgoto http_msg_hdr_val2;\n\t\t\tptr += sizeof(long);\n\t\t}\n#endif\n#ifdef HA_UNALIGNED_LE\n\t\twhile (ptr <= end - sizeof(int)) {\n\t\t\tif ((*(int*)ptr - 0x0e0e0e0e) & 0x80808080)\n\t\t\t\tgoto http_msg_hdr_val2;\n\t\t\tptr += sizeof(int);\n\t\t}\n#endif\n\t\tif (ptr >= end) {\n\t\t\tstate = H1_MSG_HDR_VAL;\n\t\t\tgoto http_msg_ood;\n\t\t}\n\thttp_msg_hdr_val2:\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_val2, http_msg_ood, state, H1_MSG_HDR_VAL);\n\n\t\teol = ptr - start;\n\t\t/* Note: we could also copy eol into ->eoh so that we have the\n\t\t * real header end in case it ends with lots of LWS, but is this\n\t\t * really needed ?\n\t\t */\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l2_lf, http_msg_ood, state, H1_MSG_HDR_L2_LF);\n\t\tgoto http_msg_hdr_l2_lf;\n\n\tcase H1_MSG_HDR_L2_LF:\n\thttp_msg_hdr_l2_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_HDR_L2_LF);\n\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_hdr_l2_lws, http_msg_ood, state, H1_MSG_HDR_L2_LWS);\n\n\tcase H1_MSG_HDR_L2_LWS:\n\thttp_msg_hdr_l2_lws:\n\t\tif (unlikely(HTTP_IS_SPHT(*ptr))) {\n\t\t\tif (!skip_update) {\n\t\t\t\t/* LWS: replace HT,CR,LF with spaces */\n\t\t\t\tfor (; start + eol < ptr; eol++)\n\t\t\t\t\tstart[eol] = ' ';\n\t\t\t}\n\t\t\tgoto http_msg_hdr_val;\n\t\t}\n\thttp_msg_complete_header:\n\t\t/*\n\t\t * It was a new header, so the last one is finished. Assumes\n\t\t * <sol> points to the first char of the name, <col> to the\n\t\t * colon, <sov> points to the first character of the value and\n\t\t * <eol> to the first CR or LF so we know how the line ends. We\n\t\t * will trim spaces around the value. It's possible to do it by\n\t\t * adjusting <eol> and <sov> which are no more used after this.\n\t\t * We can add the header field to the list.\n\t\t */\n\t\tif (likely(!skip_update)) {\n\t\t\twhile (sov < eol && HTTP_IS_LWS(start[sov]))\n\t\t\t\tsov++;\n\n\t\t\twhile (eol - 1 > sov && HTTP_IS_LWS(start[eol - 1]))\n\t\t\t\teol--;\n\n\n\t\t\tn = ist2(start + sol, col - sol);\n\t\t\tv = ist2(start + sov, eol - sov);\n\n\t\t\tdo {\n\t\t\t\tint ret;\n\n\t\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\tgoto http_output_full;\n\t\t\t\t}\n\n\t\t\t\tif (isteqi(n, ist(\"transfer-encoding\"))) {\n\t\t\t\t\tret = h1_parse_xfer_enc_header(h1m, v);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ret == 0) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\"content-length\"))) {\n\t\t\t\t\tret = h1_parse_cont_len_header(h1m, &v);\n\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ret == 0) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\"connection\"))) {\n\t\t\t\t\th1_parse_connection_header(h1m, &v);\n\t\t\t\t\tif (!v.len) {\n\t\t\t\t\t\t/* skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (isteqi(n, ist(\"upgrade\"))) {\n\t\t\t\t\th1_parse_upgrade_header(h1m, v);\n\t\t\t\t}\n\t\t\t\telse if (!(h1m->flags & H1_MF_RESP) && isteqi(n, ist(\"host\"))) {\n\t\t\t\t\tif (host_idx == -1)\n\t\t\t\t\t\thost_idx = hdr_count;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (!isteqi(v, hdr[host_idx].v)) {\n\t\t\t\t\t\t\tstate = H1_MSG_HDR_L2_LWS;\n\t\t\t\t\t\t\tptr = v.ptr; /* Set ptr on the error */\n\t\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* if the same host, skip it */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\thttp_set_hdr(&hdr[hdr_count++], n, v);\n\t\t\t} while (0);\n\t\t}\n\n\t\tsol = ptr - start;\n\n\t\tif (likely(!HTTP_IS_CRLF(*ptr)))\n\t\t\tgoto http_msg_hdr_name;\n\n\t\tif (likely(*ptr == '\\r'))\n\t\t\tEAT_AND_JUMP_OR_RETURN(ptr, end, http_msg_last_lf, http_msg_ood, state, H1_MSG_LAST_LF);\n\t\tgoto http_msg_last_lf;\n\n\tcase H1_MSG_LAST_LF:\n\thttp_msg_last_lf:\n\t\tEXPECT_LF_HERE(ptr, http_msg_invalid, state, H1_MSG_LAST_LF);\n\t\tptr++;\n\t\t/* <ptr> now points to the first byte of payload. If needed sol\n\t\t * still points to the first of either CR or LF of the empty\n\t\t * line ending the headers block.\n\t\t */\n\t\tif (likely(!skip_update)) {\n\t\t\tif (unlikely(hdr_count >= hdr_num)) {\n\t\t\t\tstate = H1_MSG_LAST_LF;\n\t\t\t\tgoto http_output_full;\n\t\t\t}\n\t\t\thttp_set_hdr(&hdr[hdr_count++], ist2(start+sol, 0), ist(\"\"));\n\t\t}\n\n\t\t/* reaching here we've parsed the whole message. We may detect\n\t\t * that we were already continuing an interrupted parsing pass\n\t\t * so we were silently looking for the end of message not\n\t\t * updating anything before deciding to parse it fully at once.\n\t\t * It's guaranteed that we won't match this test twice in a row\n\t\t * since restarting will turn zero.\n\t\t */\n\t\tif (restarting)\n\t\t\tgoto restart;\n\n\n\t\tif (!(h1m->flags & (H1_MF_HDRS_ONLY|H1_MF_RESP))) {\n\t\t\tstruct http_uri_parser parser = http_uri_parser_init(sl.rq.u);\n\t\t\tstruct ist scheme, authority;\n\t\t\tint ret;\n\n\t\t\tscheme = http_parse_scheme(&parser);\n\t\t\tauthority = http_parse_authority(&parser, 1);\n\t\t\tif (sl.rq.meth == HTTP_METH_CONNECT) {\n\t\t\t\tstruct ist *host = ((host_idx != -1) ? &hdr[host_idx].v : NULL);\n\n\t\t\t\tret = h1_validate_connect_authority(authority, host);\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tif (h1m->err_pos < -1) {\n\t\t\t\t\t\tstate = H1_MSG_LAST_LF;\n\t\t\t\t\t\t/* WT: gcc seems to see a path where sl.rq.u.ptr was used\n\t\t\t\t\t\t * uninitialized, but it doesn't know that the function is\n\t\t\t\t\t\t * called with initial states making this impossible.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tALREADY_CHECKED(sl.rq.u.ptr);\n\t\t\t\t\t\tptr = ((ret == -1) ? sl.rq.u.ptr : host->ptr); /* Set ptr on the error */\n\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t}\n\t\t\t\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\t\t\t\th1m->err_pos = ((ret == -1) ? sl.rq.u.ptr : host->ptr) - start + skip; /* >= 0 now */\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (host_idx != -1 && istlen(authority)) {\n\t\t\t\tstruct ist host = hdr[host_idx].v;\n\n\t\t\t\t/* For non-CONNECT method, the authority must match the host header value */\n\t\t\t\tif (!isteqi(authority, host)) {\n\t\t\t\t\tret = h1_validate_mismatch_authority(scheme, authority, host);\n\t\t\t\t\tif (ret < 0) {\n\t\t\t\t\t\tif (h1m->err_pos < -1) {\n\t\t\t\t\t\t\tstate = H1_MSG_LAST_LF;\n\t\t\t\t\t\t\tptr = host.ptr; /* Set ptr on the error */\n\t\t\t\t\t\t\tgoto http_msg_invalid;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (h1m->err_pos == -1) /* capture the error pointer */\n\t\t\t\t\t\t\th1m->err_pos = v.ptr - start + skip; /* >= 0 now */\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstate = H1_MSG_DATA;\n\t\tif (h1m->flags & H1_MF_XFER_ENC) {\n\t\t\tif (h1m->flags & H1_MF_CLEN) {\n\t\t\t\t/* T-E + C-L: force close and remove C-L */\n\t\t\t\th1m->flags |= H1_MF_CONN_CLO;\n\t\t\t\th1m->flags &= ~H1_MF_CLEN;\n\t\t\t\thdr_count = http_del_hdr(hdr, ist(\"content-length\"));\n\t\t\t}\n\t\t\telse if (!(h1m->flags & H1_MF_VER_11)) {\n\t\t\t\t/* T-E + HTTP/1.0: force close */\n\t\t\t\th1m->flags |= H1_MF_CONN_CLO;\n\t\t\t}\n\n\t\t\tif (h1m->flags & H1_MF_CHNK)\n\t\t\t\tstate = H1_MSG_CHUNK_SIZE;\n\t\t\telse if (!(h1m->flags & H1_MF_RESP)) {\n\t\t\t\t/* cf RFC7230#3.3.3 : transfer-encoding in\n\t\t\t\t * request without chunked encoding is invalid.\n\t\t\t\t */\n\t\t\t\tgoto http_msg_invalid;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\n\tdefault:\n\t\t/* impossible states */\n\t\tgoto http_msg_invalid;\n\t}\n\n\t/* Now we've left the headers state and are either in H1_MSG_DATA or\n\t * H1_MSG_CHUNK_SIZE.\n\t */\n\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->state = state;\n\th1m->next  = ptr - start + skip;\n\treturn h1m->next;\n\n http_msg_ood:\n\t/* out of data at <ptr> during state <state> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->state = state;\n\th1m->next  = ptr - start + skip;\n\treturn 0;\n\n http_msg_invalid:\n\t/* invalid message, error at <ptr> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->err_state = h1m->state = state;\n\th1m->err_pos   = h1m->next  = ptr - start + skip;\n\treturn -1;\n\n http_output_full:\n\t/* no more room to store the current header, error at <ptr> */\n\tif (slp && !skip_update)\n\t\t*slp = sl;\n\n\th1m->err_state = h1m->state = state;\n\th1m->err_pos   = h1m->next  = ptr - start + skip;\n\treturn -2;\n\n restart:\n\th1m->flags &= H1_MF_RESTART_MASK;\n\th1m->curr_len = h1m->body_len = h1m->next  = 0;\n\tif (h1m->flags & H1_MF_RESP)\n\t\th1m->state = H1_MSG_RPBEFORE;\n\telse\n\t\th1m->state = H1_MSG_RQBEFORE;\n\tgoto try_again;\n}\n\n/* This function performs a very minimal parsing of the trailers block present\n * at offset <ofs> in <buf> for up to <max> bytes, and returns the number of\n * bytes to delete to skip the trailers. It may return 0 if it's missing some\n * input data, or < 0 in case of parse error (in which case the caller may have\n * to decide how to proceed, possibly eating everything).\n */\nint h1_measure_trailers(const struct buffer *buf, unsigned int ofs, unsigned int max)\n{\n\tconst char *stop = b_peek(buf, ofs + max);\n\tint count = ofs;\n\n\twhile (1) {\n\t\tconst char *p1 = NULL, *p2 = NULL;\n\t\tconst char *start = b_peek(buf, count);\n\t\tconst char *ptr   = start;\n\n\t\t/* scan current line and stop at LF or CRLF */\n\t\twhile (1) {\n\t\t\tif (ptr == stop)\n\t\t\t\treturn 0;\n\n\t\t\tif (*ptr == '\\n') {\n\t\t\t\tif (!p1)\n\t\t\t\t\tp1 = ptr;\n\t\t\t\tp2 = ptr;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (*ptr == '\\r') {\n\t\t\t\tif (p1)\n\t\t\t\t\treturn -1;\n\t\t\t\tp1 = ptr;\n\t\t\t}\n\n\t\t\tptr = b_next(buf, ptr);\n\t\t}\n\n\t\t/* after LF; point to beginning of next line */\n\t\tp2 = b_next(buf, p2);\n\t\tcount += b_dist(buf, start, p2);\n\n\t\t/* LF/CRLF at beginning of line => end of trailers at p2.\n\t\t * Everything was scheduled for forwarding, there's nothing left\n\t\t * from this message. */\n\t\tif (p1 == start)\n\t\t\tbreak;\n\t\t/* OK, next line then */\n\t}\n\treturn count - ofs;\n}\n\n/* Generate a random key for a WebSocket Handshake in respect with rfc6455\n * The key is 128-bits long encoded as a base64 string in <key_out> parameter\n * (25 bytes long).\n */\nvoid h1_generate_random_ws_input_key(char key_out[25])\n{\n\t/* generate a random websocket key */\n\tconst uint64_t rand1 = ha_random64(), rand2 = ha_random64();\n\tchar key[16];\n\n\tmemcpy(key, &rand1, 8);\n\tmemcpy(&key[8], &rand2, 8);\n\ta2base64(key, 16, key_out, 25);\n}\n\n#define H1_WS_KEY_SUFFIX_GUID \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n\n/*\n * Calculate the WebSocket handshake response key from <key_in>. Following the\n * rfc6455, <key_in> must be 24 bytes longs. The result is  stored in <key_out>\n * as a 29 bytes long string.\n */\nvoid h1_calculate_ws_output_key(const char *key, char *result)\n{\n\tblk_SHA_CTX sha1_ctx;\n\tchar hash_in[60], hash_out[20];\n\n\t/* concatenate the key with a fixed suffix */\n\tmemcpy(hash_in, key, 24);\n\tmemcpy(&hash_in[24], H1_WS_KEY_SUFFIX_GUID, 36);\n\n\t/* sha1 the result */\n\tblk_SHA1_Init(&sha1_ctx);\n\tblk_SHA1_Update(&sha1_ctx, hash_in, 60);\n\tblk_SHA1_Final((unsigned char *)hash_out, &sha1_ctx);\n\n\t/* encode in base64 the hash */\n\ta2base64(hash_out, 20, result, 29);\n}\n", "/*\n * HTTP semantics\n *\n * Copyright 2000-2018 Willy Tarreau <w@1wt.eu>\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version\n * 2 of the License, or (at your option) any later version.\n *\n */\n\n#include <ctype.h>\n#include <haproxy/api.h>\n#include <haproxy/http.h>\n#include <haproxy/tools.h>\n\n/* It is about twice as fast on recent architectures to lookup a byte in a\n * table than to perform a boolean AND or OR between two tests. Refer to\n * RFC2616/RFC5234/RFC7230 for those chars. A token is any ASCII char that is\n * neither a separator nor a CTL char. An http ver_token is any ASCII which can\n * be found in an HTTP version, which includes 'H', 'T', 'P', '/', '.' and any\n * digit. Note: please do not overwrite values in assignment since gcc-2.95\n * will not handle them correctly. It's worth noting that chars 128..255 are\n * nothing, not even control chars.\n */\nconst unsigned char http_char_classes[256] = {\n\t[  0] = HTTP_FLG_CTL,\n\t[  1] = HTTP_FLG_CTL,\n\t[  2] = HTTP_FLG_CTL,\n\t[  3] = HTTP_FLG_CTL,\n\t[  4] = HTTP_FLG_CTL,\n\t[  5] = HTTP_FLG_CTL,\n\t[  6] = HTTP_FLG_CTL,\n\t[  7] = HTTP_FLG_CTL,\n\t[  8] = HTTP_FLG_CTL,\n\t[  9] = HTTP_FLG_SPHT | HTTP_FLG_LWS | HTTP_FLG_SEP | HTTP_FLG_CTL,\n\t[ 10] = HTTP_FLG_CRLF | HTTP_FLG_LWS | HTTP_FLG_CTL,\n\t[ 11] = HTTP_FLG_CTL,\n\t[ 12] = HTTP_FLG_CTL,\n\t[ 13] = HTTP_FLG_CRLF | HTTP_FLG_LWS | HTTP_FLG_CTL,\n\t[ 14] = HTTP_FLG_CTL,\n\t[ 15] = HTTP_FLG_CTL,\n\t[ 16] = HTTP_FLG_CTL,\n\t[ 17] = HTTP_FLG_CTL,\n\t[ 18] = HTTP_FLG_CTL,\n\t[ 19] = HTTP_FLG_CTL,\n\t[ 20] = HTTP_FLG_CTL,\n\t[ 21] = HTTP_FLG_CTL,\n\t[ 22] = HTTP_FLG_CTL,\n\t[ 23] = HTTP_FLG_CTL,\n\t[ 24] = HTTP_FLG_CTL,\n\t[ 25] = HTTP_FLG_CTL,\n\t[ 26] = HTTP_FLG_CTL,\n\t[ 27] = HTTP_FLG_CTL,\n\t[ 28] = HTTP_FLG_CTL,\n\t[ 29] = HTTP_FLG_CTL,\n\t[ 30] = HTTP_FLG_CTL,\n\t[ 31] = HTTP_FLG_CTL,\n\t[' '] = HTTP_FLG_SPHT | HTTP_FLG_LWS | HTTP_FLG_SEP,\n\t['!'] = HTTP_FLG_TOK,\n\t['\"'] = HTTP_FLG_SEP,\n\t['#'] = HTTP_FLG_TOK,\n\t['$'] = HTTP_FLG_TOK,\n\t['%'] = HTTP_FLG_TOK,\n\t['&'] = HTTP_FLG_TOK,\n\t[ 39] = HTTP_FLG_TOK,\n\t['('] = HTTP_FLG_SEP,\n\t[')'] = HTTP_FLG_SEP,\n\t['*'] = HTTP_FLG_TOK,\n\t['+'] = HTTP_FLG_TOK,\n\t[','] = HTTP_FLG_SEP,\n\t['-'] = HTTP_FLG_TOK,\n\t['.'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['/'] = HTTP_FLG_SEP | HTTP_FLG_VER,\n\t['0'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['1'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['2'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['3'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['4'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['5'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['6'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['7'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['8'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t['9'] = HTTP_FLG_TOK | HTTP_FLG_VER | HTTP_FLG_DIG,\n\t[':'] = HTTP_FLG_SEP,\n\t[';'] = HTTP_FLG_SEP,\n\t['<'] = HTTP_FLG_SEP,\n\t['='] = HTTP_FLG_SEP,\n\t['>'] = HTTP_FLG_SEP,\n\t['?'] = HTTP_FLG_SEP,\n\t['@'] = HTTP_FLG_SEP,\n\t['A'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['B'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['C'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['D'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['E'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['F'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['G'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['H'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['I'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['J'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['K'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['L'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['M'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['N'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['O'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['P'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['Q'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['R'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['S'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['T'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['U'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['V'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['W'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['X'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['Y'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['Z'] = HTTP_FLG_TOK | HTTP_FLG_VER,\n\t['['] = HTTP_FLG_SEP,\n\t[ 92] = HTTP_FLG_SEP,\n\t[']'] = HTTP_FLG_SEP,\n\t['^'] = HTTP_FLG_TOK,\n\t['_'] = HTTP_FLG_TOK,\n\t['`'] = HTTP_FLG_TOK,\n\t['a'] = HTTP_FLG_TOK,\n\t['b'] = HTTP_FLG_TOK,\n\t['c'] = HTTP_FLG_TOK,\n\t['d'] = HTTP_FLG_TOK,\n\t['e'] = HTTP_FLG_TOK,\n\t['f'] = HTTP_FLG_TOK,\n\t['g'] = HTTP_FLG_TOK,\n\t['h'] = HTTP_FLG_TOK,\n\t['i'] = HTTP_FLG_TOK,\n\t['j'] = HTTP_FLG_TOK,\n\t['k'] = HTTP_FLG_TOK,\n\t['l'] = HTTP_FLG_TOK,\n\t['m'] = HTTP_FLG_TOK,\n\t['n'] = HTTP_FLG_TOK,\n\t['o'] = HTTP_FLG_TOK,\n\t['p'] = HTTP_FLG_TOK,\n\t['q'] = HTTP_FLG_TOK,\n\t['r'] = HTTP_FLG_TOK,\n\t['s'] = HTTP_FLG_TOK,\n\t['t'] = HTTP_FLG_TOK,\n\t['u'] = HTTP_FLG_TOK,\n\t['v'] = HTTP_FLG_TOK,\n\t['w'] = HTTP_FLG_TOK,\n\t['x'] = HTTP_FLG_TOK,\n\t['y'] = HTTP_FLG_TOK,\n\t['z'] = HTTP_FLG_TOK,\n\t['{'] = HTTP_FLG_SEP,\n\t['|'] = HTTP_FLG_TOK,\n\t['}'] = HTTP_FLG_SEP,\n\t['~'] = HTTP_FLG_TOK,\n\t[127] = HTTP_FLG_CTL,\n};\n\nconst int http_err_codes[HTTP_ERR_SIZE] = {\n\t[HTTP_ERR_200] = 200,  /* used by \"monitor-uri\" */\n\t[HTTP_ERR_400] = 400,\n\t[HTTP_ERR_401] = 401,\n\t[HTTP_ERR_403] = 403,\n\t[HTTP_ERR_404] = 404,\n\t[HTTP_ERR_405] = 405,\n\t[HTTP_ERR_407] = 407,\n\t[HTTP_ERR_408] = 408,\n\t[HTTP_ERR_410] = 410,\n\t[HTTP_ERR_413] = 413,\n\t[HTTP_ERR_421] = 421,\n\t[HTTP_ERR_422] = 422,\n\t[HTTP_ERR_425] = 425,\n\t[HTTP_ERR_429] = 429,\n\t[HTTP_ERR_500] = 500,\n\t[HTTP_ERR_501] = 501,\n\t[HTTP_ERR_502] = 502,\n\t[HTTP_ERR_503] = 503,\n\t[HTTP_ERR_504] = 504,\n};\n\nconst char *http_err_msgs[HTTP_ERR_SIZE] = {\n\t[HTTP_ERR_200] =\n\t\"HTTP/1.1 200 OK\\r\\n\"\n\t\"Content-length: 58\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>200 OK</h1>\\nService ready.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_400] =\n\t\"HTTP/1.1 400 Bad request\\r\\n\"\n\t\"Content-length: 90\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Connection: close\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>400 Bad request</h1>\\nYour browser sent an invalid request.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_401] =\n\t\"HTTP/1.1 401 Unauthorized\\r\\n\"\n\t\"Content-length: 112\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>401 Unauthorized</h1>\\nYou need a valid user and password to access this content.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_403] =\n\t\"HTTP/1.1 403 Forbidden\\r\\n\"\n\t\"Content-length: 93\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>403 Forbidden</h1>\\nRequest forbidden by administrative rules.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_404] =\n\t\"HTTP/1.1 404 Not Found\\r\\n\"\n\t\"Content-length: 83\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>404 Not Found</h1>\\nThe resource could not be found.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_405] =\n\t\"HTTP/1.1 405 Method Not Allowed\\r\\n\"\n\t\"Content-length: 146\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>405 Method Not Allowed</h1>\\nA request was made of a resource using a request method not supported by that resource\\n</body></html>\\n\",\n\n\t[HTTP_ERR_407] =\n\t\"HTTP/1.1 407 Unauthorized\\r\\n\"\n\t\"Content-length: 112\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>407 Unauthorized</h1>\\nYou need a valid user and password to access this content.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_408] =\n\t\"HTTP/1.1 408 Request Time-out\\r\\n\"\n\t\"Content-length: 110\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Connection: close\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>408 Request Time-out</h1>\\nYour browser didn't send a complete request in time.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_410] =\n\t\"HTTP/1.1 410 Gone\\r\\n\"\n\t\"Content-length: 114\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>410 Gone</h1>\\nThe resource is no longer available and will not be available again.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_413] =\n\t\"HTTP/1.1 413 Payload Too Large\\r\\n\"\n\t\"Content-length: 106\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>413 Payload Too Large</h1>\\nThe request entity exceeds the maximum allowed.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_421] =\n\t\"HTTP/1.1 421 Misdirected Request\\r\\n\"\n\t\"Content-length: 104\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>421 Misdirected Request</h1>\\nRequest sent to a non-authoritative server.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_422] =\n\t\"HTTP/1.1 422 Unprocessable Content\\r\\n\"\n\t\"Content-length: 116\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>422 Unprocessable Content</h1>\\nThe server cannot process the contained instructions.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_425] =\n\t\"HTTP/1.1 425 Too Early\\r\\n\"\n\t\"Content-length: 80\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>425 Too Early</h1>\\nYour browser sent early data.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_429] =\n\t\"HTTP/1.1 429 Too Many Requests\\r\\n\"\n\t\"Content-length: 117\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>429 Too Many Requests</h1>\\nYou have sent too many requests in a given amount of time.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_500] =\n\t\"HTTP/1.1 500 Internal Server Error\\r\\n\"\n\t\"Content-length: 97\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>500 Internal Server Error</h1>\\nAn internal server error occurred.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_501] =\n\t\"HTTP/1.1 501 Not Implemented\\r\\n\"\n\t\"Content-length: 136\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>501 Not Implemented</h1>\\n.The server does not support the functionality required to fulfill the request.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_502] =\n\t\"HTTP/1.1 502 Bad Gateway\\r\\n\"\n\t\"Content-length: 107\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>502 Bad Gateway</h1>\\nThe server returned an invalid or incomplete response.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_503] =\n\t\"HTTP/1.1 503 Service Unavailable\\r\\n\"\n\t\"Content-length: 107\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>503 Service Unavailable</h1>\\nNo server is available to handle this request.\\n</body></html>\\n\",\n\n\t[HTTP_ERR_504] =\n\t\"HTTP/1.1 504 Gateway Time-out\\r\\n\"\n\t\"Content-length: 92\\r\\n\"\n\t\"Cache-Control: no-cache\\r\\n\"\n\t\"Content-Type: text/html\\r\\n\"\n\t\"\\r\\n\"\n\t\"<html><body><h1>504 Gateway Time-out</h1>\\nThe server didn't respond in time.\\n</body></html>\\n\",\n};\n\nconst struct ist http_known_methods[HTTP_METH_OTHER] = {\n\t[HTTP_METH_OPTIONS] = IST(\"OPTIONS\"),\n\t[HTTP_METH_GET]     = IST(\"GET\"),\n\t[HTTP_METH_HEAD]    = IST(\"HEAD\"),\n\t[HTTP_METH_POST]    = IST(\"POST\"),\n\t[HTTP_METH_PUT]     = IST(\"PUT\"),\n\t[HTTP_METH_DELETE]  = IST(\"DELETE\"),\n\t[HTTP_METH_TRACE]   = IST(\"TRACE\"),\n\t[HTTP_METH_CONNECT] = IST(\"CONNECT\"),\n};\n\n/*\n * returns a known method among HTTP_METH_* or HTTP_METH_OTHER for all unknown\n * ones.\n */\nenum http_meth_t find_http_meth(const char *str, const int len)\n{\n\tconst struct ist m = ist2(str, len);\n\n\tif      (isteq(m, ist(\"GET\")))     return HTTP_METH_GET;\n\telse if (isteq(m, ist(\"HEAD\")))    return HTTP_METH_HEAD;\n\telse if (isteq(m, ist(\"POST\")))    return HTTP_METH_POST;\n\telse if (isteq(m, ist(\"CONNECT\"))) return HTTP_METH_CONNECT;\n\telse if (isteq(m, ist(\"PUT\")))     return HTTP_METH_PUT;\n\telse if (isteq(m, ist(\"OPTIONS\"))) return HTTP_METH_OPTIONS;\n\telse if (isteq(m, ist(\"DELETE\")))  return HTTP_METH_DELETE;\n\telse if (isteq(m, ist(\"TRACE\")))   return HTTP_METH_TRACE;\n\telse                               return HTTP_METH_OTHER;\n}\n\n/* This function returns HTTP_ERR_<num> (enum) matching http status code.\n * Returned value should match codes from http_err_codes.\n */\nint http_get_status_idx(unsigned int status)\n{\n\tswitch (status) {\n\tcase 200: return HTTP_ERR_200;\n\tcase 400: return HTTP_ERR_400;\n\tcase 401: return HTTP_ERR_401;\n\tcase 403: return HTTP_ERR_403;\n\tcase 404: return HTTP_ERR_404;\n\tcase 405: return HTTP_ERR_405;\n\tcase 407: return HTTP_ERR_407;\n\tcase 408: return HTTP_ERR_408;\n\tcase 410: return HTTP_ERR_410;\n\tcase 413: return HTTP_ERR_413;\n\tcase 421: return HTTP_ERR_421;\n\tcase 422: return HTTP_ERR_422;\n\tcase 425: return HTTP_ERR_425;\n\tcase 429: return HTTP_ERR_429;\n\tcase 500: return HTTP_ERR_500;\n\tcase 501: return HTTP_ERR_501;\n\tcase 502: return HTTP_ERR_502;\n\tcase 503: return HTTP_ERR_503;\n\tcase 504: return HTTP_ERR_504;\n\tdefault: return HTTP_ERR_500;\n\t}\n}\n\n/* This function returns a reason associated with the HTTP status.\n * This function never fails, a message is always returned.\n */\nconst char *http_get_reason(unsigned int status)\n{\n\tswitch (status) {\n\tcase 100: return \"Continue\";\n\tcase 101: return \"Switching Protocols\";\n\tcase 102: return \"Processing\";\n\tcase 200: return \"OK\";\n\tcase 201: return \"Created\";\n\tcase 202: return \"Accepted\";\n\tcase 203: return \"Non-Authoritative Information\";\n\tcase 204: return \"No Content\";\n\tcase 205: return \"Reset Content\";\n\tcase 206: return \"Partial Content\";\n\tcase 207: return \"Multi-Status\";\n\tcase 210: return \"Content Different\";\n\tcase 226: return \"IM Used\";\n\tcase 300: return \"Multiple Choices\";\n\tcase 301: return \"Moved Permanently\";\n\tcase 302: return \"Found\";\n\tcase 303: return \"See Other\";\n\tcase 304: return \"Not Modified\";\n\tcase 305: return \"Use Proxy\";\n\tcase 307: return \"Temporary Redirect\";\n\tcase 308: return \"Permanent Redirect\";\n\tcase 310: return \"Too many Redirects\";\n\tcase 400: return \"Bad Request\";\n\tcase 401: return \"Unauthorized\";\n\tcase 402: return \"Payment Required\";\n\tcase 403: return \"Forbidden\";\n\tcase 404: return \"Not Found\";\n\tcase 405: return \"Method Not Allowed\";\n\tcase 406: return \"Not Acceptable\";\n\tcase 407: return \"Proxy Authentication Required\";\n\tcase 408: return \"Request Time-out\";\n\tcase 409: return \"Conflict\";\n\tcase 410: return \"Gone\";\n\tcase 411: return \"Length Required\";\n\tcase 412: return \"Precondition Failed\";\n\tcase 413: return \"Request Entity Too Large\";\n\tcase 414: return \"Request-URI Too Long\";\n\tcase 415: return \"Unsupported Media Type\";\n\tcase 416: return \"Requested range unsatisfiable\";\n\tcase 417: return \"Expectation failed\";\n\tcase 418: return \"I'm a teapot\";\n\tcase 421: return \"Misdirected Request\";\n\tcase 422: return \"Unprocessable Content\";\n\tcase 423: return \"Locked\";\n\tcase 424: return \"Method failure\";\n\tcase 425: return \"Too Early\";\n\tcase 426: return \"Upgrade Required\";\n\tcase 428: return \"Precondition Required\";\n\tcase 429: return \"Too Many Requests\";\n\tcase 431: return \"Request Header Fields Too Large\";\n\tcase 449: return \"Retry With\";\n\tcase 450: return \"Blocked by Windows Parental Controls\";\n\tcase 451: return \"Unavailable For Legal Reasons\";\n\tcase 456: return \"Unrecoverable Error\";\n\tcase 499: return \"client has closed connection\";\n\tcase 500: return \"Internal Server Error\";\n\tcase 501: return \"Not Implemented\";\n\tcase 502: return \"Bad Gateway or Proxy Error\";\n\tcase 503: return \"Service Unavailable\";\n\tcase 504: return \"Gateway Time-out\";\n\tcase 505: return \"HTTP Version not supported\";\n\tcase 506: return \"Variant also negotiate\";\n\tcase 507: return \"Insufficient storage\";\n\tcase 508: return \"Loop detected\";\n\tcase 509: return \"Bandwidth Limit Exceeded\";\n\tcase 510: return \"Not extended\";\n\tcase 511: return \"Network authentication required\";\n\tcase 520: return \"Web server is returning an unknown error\";\n\tdefault:\n\t\tswitch (status) {\n\t\tcase 100 ... 199: return \"Informational\";\n\t\tcase 200 ... 299: return \"Success\";\n\t\tcase 300 ... 399: return \"Redirection\";\n\t\tcase 400 ... 499: return \"Client Error\";\n\t\tcase 500 ... 599: return \"Server Error\";\n\t\tdefault:          return \"Other\";\n\t\t}\n\t}\n}\n\n/* Returns the ist string corresponding to port part (without ':') in the host\n * <host>, IST_NULL if no ':' is found or an empty IST if there is no digit. In\n * the last case, the result is the original ist trimmed to 0. So be sure to test\n * the result length before doing any pointer arithmetic.\n*/\nstruct ist http_get_host_port(const struct ist host)\n{\n\tchar *start, *end, *ptr;\n\n\tstart = istptr(host);\n\tend = istend(host);\n\tfor (ptr = end; ptr > start && isdigit((unsigned char)*--ptr););\n\n\t/* no port found */\n\tif (likely(*ptr != ':'))\n\t\treturn IST_NULL;\n\tif (ptr+1 == end)\n\t\treturn isttrim(host, 0);\n\n\treturn istnext(ist2(ptr, end - ptr));\n}\n\n\n/* Return non-zero if the port <port> is a default port. If the scheme <schm> is\n * set, it is used to detect default ports (HTTP => 80 and HTTPS => 443)\n * port. Otherwise, both are considered as default ports.\n */\nint http_is_default_port(const struct ist schm, const struct ist port)\n{\n\tif (!istlen(port))\n\t\treturn 1;\n\n\tif (!isttest(schm))\n\t\treturn (isteq(port, ist(\"443\")) || isteq(port, ist(\"80\")));\n\telse\n\t\treturn (isteq(port, ist(\"443\")) && isteqi(schm, ist(\"https://\"))) ||\n\t\t\t(isteq(port, ist(\"80\")) && isteqi(schm, ist(\"http://\")));\n}\n\n/* Returns non-zero if the scheme <schm> is syntactically correct according to\n * RFC3986#3.1, otherwise zero. It expects only the scheme and nothing else\n * (particularly not the following \"://\").\n *     Scheme = alpha *(alpha|digit|'+'|'-'|'.')\n */\nint http_validate_scheme(const struct ist schm)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < schm.len; i++) {\n\t\tif (likely((schm.ptr[i] >= 'a' && schm.ptr[i] <= 'z') ||\n\t\t\t   (schm.ptr[i] >= 'A' && schm.ptr[i] <= 'Z')))\n\t\t\tcontinue;\n\t\tif (unlikely(!i)) // first char must be alpha\n\t\t\treturn 0;\n\t\tif ((schm.ptr[i] >= '0' && schm.ptr[i] <= '9') ||\n\t\t    schm.ptr[i] == '+' || schm.ptr[i] == '-' || schm.ptr[i] == '.')\n\t\t\tcontinue;\n\t\treturn 0;\n\t}\n\treturn !!i;\n}\n\n/* Parse the uri and looks for the scheme. If not found, an empty ist is\n * returned. Otherwise, the ist pointing to the scheme is returned.\n *\n * <parser> must have been initialized via http_uri_parser_init. See the\n * related http_uri_parser documentation for the specific API usage.\n */\nstruct ist http_parse_scheme(struct http_uri_parser *parser)\n{\n\tconst char *ptr, *start, *end;\n\n\tif (parser->state >= URI_PARSER_STATE_SCHEME_DONE)\n\t\tgoto not_found;\n\n\tif (parser->format != URI_PARSER_FORMAT_ABSURI_OR_AUTHORITY)\n\t\tgoto not_found;\n\n\tptr = start = istptr(parser->uri);\n\tend = istend(parser->uri);\n\n\tif (isalpha((unsigned char)*ptr)) {\n\t\t/* this is a scheme as described by RFC3986, par. 3.1, or only\n\t\t * an authority (in case of a CONNECT method).\n\t\t */\n\t\tptr++;\n\t\t/* retrieve the scheme up to the suffix '://'. If the suffix is\n\t\t * not found, this means there is no scheme and it is an\n\t\t * authority-only uri.\n\t\t */\n\t\twhile (ptr < end &&\n\t\t       (isalnum((unsigned char)*ptr) || *ptr == '+' || *ptr == '-' || *ptr == '.'))\n\t\t\tptr++;\n\t\tif (ptr == end || *ptr++ != ':')\n\t\t\tgoto not_found;\n\t\tif (ptr == end || *ptr++ != '/')\n\t\t\tgoto not_found;\n\t\tif (ptr == end || *ptr++ != '/')\n\t\t\tgoto not_found;\n\t}\n\telse {\n\t\tgoto not_found;\n\t}\n\n\tparser->uri = ist2(ptr, end - ptr);\n\tparser->state = URI_PARSER_STATE_SCHEME_DONE;\n\treturn ist2(start, ptr - start);\n\n not_found:\n\tparser->state = URI_PARSER_STATE_SCHEME_DONE;\n\treturn IST_NULL;\n}\n\n/* Parse the uri and looks for the authority, between the scheme and the\n * path. if no_userinfo is not zero, the part before the '@' (including it) is\n * skipped. If not found, an empty ist is returned. Otherwise, the ist pointing\n * on the authority is returned.\n *\n * <parser> must have been initialized via http_uri_parser_init. See the\n * related http_uri_parser documentation for the specific API usage.\n */\nstruct ist http_parse_authority(struct http_uri_parser *parser, int no_userinfo)\n{\n\tconst char *ptr, *start, *end;\n\n\tif (parser->state >= URI_PARSER_STATE_AUTHORITY_DONE)\n\t\tgoto not_found;\n\n\tif (parser->format != URI_PARSER_FORMAT_ABSURI_OR_AUTHORITY)\n\t\tgoto not_found;\n\n\tif (parser->state < URI_PARSER_STATE_SCHEME_DONE)\n\t\thttp_parse_scheme(parser);\n\n\tptr = start = istptr(parser->uri);\n\tend = istend(parser->uri);\n\n\twhile (ptr < end && *ptr != '/') {\n\t\tif (*ptr++ == '@' && no_userinfo)\n\t\t\tstart = ptr;\n\t}\n\n\t/* OK, ptr point on the '/' or the end */\n\n  authority:\n\tparser->uri = ist2(ptr, end - ptr);\n\tparser->state = URI_PARSER_STATE_AUTHORITY_DONE;\n\treturn ist2(start, ptr - start);\n\n  not_found:\n\tparser->state = URI_PARSER_STATE_AUTHORITY_DONE;\n\treturn IST_NULL;\n}\n\n/* Parse the URI from the given transaction (which is assumed to be in request\n * phase) and look for the \"/\" beginning the PATH. If not found, ist2(0,0) is\n * returned. Otherwise the pointer and length are returned.\n *\n * <parser> must have been initialized via http_uri_parser_init. See the\n * related http_uri_parser documentation for the specific API usage.\n */\nstruct ist http_parse_path(struct http_uri_parser *parser)\n{\n\tconst char *ptr, *end;\n\n\tif (parser->state >= URI_PARSER_STATE_PATH_DONE)\n\t\tgoto not_found;\n\n\tif (parser->format == URI_PARSER_FORMAT_EMPTY ||\n\t    parser->format == URI_PARSER_FORMAT_ASTERISK) {\n\t\tgoto not_found;\n\t}\n\n\tptr = istptr(parser->uri);\n\tend = istend(parser->uri);\n\n\t/* If the uri is in absolute-path format, first skip the scheme and\n\t * authority parts. No scheme will be found if the uri is in authority\n\t * format, which indicates that the path won't be present.\n\t */\n\tif (parser->format == URI_PARSER_FORMAT_ABSURI_OR_AUTHORITY) {\n\t\tif (parser->state < URI_PARSER_STATE_SCHEME_DONE) {\n\t\t\t/* If no scheme found, uri is in authority format. No\n\t\t\t * path is present.\n\t\t\t */\n\t\t\tif (!isttest(http_parse_scheme(parser)))\n\t\t\t\tgoto not_found;\n\t\t}\n\n\t\tif (parser->state < URI_PARSER_STATE_AUTHORITY_DONE)\n\t\t\thttp_parse_authority(parser, 1);\n\n\t\tptr = istptr(parser->uri);\n\n\t\tif (ptr == end)\n\t\t\tgoto not_found;\n\t}\n\n\tparser->state = URI_PARSER_STATE_PATH_DONE;\n\treturn ist2(ptr, end - ptr);\n\n not_found:\n\tparser->state = URI_PARSER_STATE_PATH_DONE;\n\treturn IST_NULL;\n}\n\n/* Parse <value> Content-Length header field of an HTTP request. The function\n * checks all possible occurrences of a comma-delimited value, and verifies if\n * any of them doesn't match a previous value. <value> is sanitized on return\n * to contain a single value if several identical values were found.\n *\n * <body_len> must be a valid pointer and is used to return the parsed length\n * unless values differ. Also if <not_first> is true, <body_len> is assumed to\n * point to previously parsed value and which must be equal to the new length.\n * This is useful if an HTTP message contains several Content-Length headers.\n *\n * Returns <0 if a value differs, 0 if the whole header can be dropped (i.e.\n * already known), or >0 if the value can be indexed (first one). In the last\n * case, the value might be adjusted and the caller must only add the updated\n * value.\n */\nint http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}\n\n/*\n * Checks if <hdr> is exactly <name> for <len> chars, and ends with a colon.\n * If so, returns the position of the first non-space character relative to\n * <hdr>, or <end>-<hdr> if not found before. If no value is found, it tries\n * to return a pointer to the place after the first space. Returns 0 if the\n * header name does not match. Checks are case-insensitive.\n */\nint http_header_match2(const char *hdr, const char *end,\n\t\t       const char *name, int len)\n{\n\tconst char *val;\n\n\tif (hdr + len >= end)\n\t\treturn 0;\n\tif (hdr[len] != ':')\n\t\treturn 0;\n\tif (strncasecmp(hdr, name, len) != 0)\n\t\treturn 0;\n\tval = hdr + len + 1;\n\twhile (val < end && HTTP_IS_SPHT(*val))\n\t\tval++;\n\tif ((val >= end) && (len + 2 <= end - hdr))\n\t\treturn len + 2; /* we may replace starting from second space */\n\treturn val - hdr;\n}\n\n/* Find the end of the header value contained between <s> and <e>. See RFC7230,\n * par 3.2 for more information. Note that it requires a valid header to return\n * a valid result. This works for headers defined as comma-separated lists.\n */\nchar *http_find_hdr_value_end(char *s, const char *e)\n{\n\tint quoted, qdpair;\n\n\tquoted = qdpair = 0;\n\n#ifdef HA_UNALIGNED_LE\n\t/* speedup: skip everything not a comma nor a double quote */\n\tfor (; s <= e - sizeof(int); s += sizeof(int)) {\n\t\tunsigned int c = *(int *)s; // comma\n\t\tunsigned int q = c;         // quote\n\n\t\tc ^= 0x2c2c2c2c; // contains one zero on a comma\n\t\tq ^= 0x22222222; // contains one zero on a quote\n\n\t\tc = (c - 0x01010101) & ~c; // contains 0x80 below a comma\n\t\tq = (q - 0x01010101) & ~q; // contains 0x80 below a quote\n\n\t\tif ((c | q) & 0x80808080)\n\t\t\tbreak; // found a comma or a quote\n\t}\n#endif\n\tfor (; s < e; s++) {\n\t\tif (qdpair)                    qdpair = 0;\n\t\telse if (quoted) {\n\t\t\tif (*s == '\\\\')        qdpair = 1;\n\t\t\telse if (*s == '\"')    quoted = 0;\n\t\t}\n\t\telse if (*s == '\"')            quoted = 1;\n\t\telse if (*s == ',')            return s;\n\t}\n\treturn s;\n}\n\n/* Find the end of a cookie value contained between <s> and <e>. It works the\n * same way as with headers above except that the semi-colon also ends a token.\n * See RFC2965 for more information. Note that it requires a valid header to\n * return a valid result.\n */\nchar *http_find_cookie_value_end(char *s, const char *e)\n{\n\tint quoted, qdpair;\n\n\tquoted = qdpair = 0;\n\tfor (; s < e; s++) {\n\t\tif (qdpair)                    qdpair = 0;\n\t\telse if (quoted) {\n\t\t\tif (*s == '\\\\')        qdpair = 1;\n\t\t\telse if (*s == '\"')    quoted = 0;\n\t\t}\n\t\telse if (*s == '\"')            quoted = 1;\n\t\telse if (*s == ',' || *s == ';') return s;\n\t}\n\treturn s;\n}\n\n/* Try to find the next occurrence of a cookie name in a cookie header value.\n * To match on any cookie name, <cookie_name_l> must be set to 0.\n * The lookup begins at <hdr>. The pointer and size of the next occurrence of\n * the cookie value is returned into *value and *value_l, and the function\n * returns a pointer to the next pointer to search from if the value was found.\n * Otherwise if the cookie was not found, NULL is returned and neither value\n * nor value_l are touched. The input <hdr> string should first point to the\n * header's value, and the <hdr_end> pointer must point to the first character\n * not part of the value. <list> must be non-zero if value may represent a list\n * of values (cookie headers). This makes it faster to abort parsing when no\n * list is expected.\n */\nchar *http_extract_cookie_value(char *hdr, const char *hdr_end,\n                                char *cookie_name, size_t cookie_name_l,\n                                int list, char **value, size_t *value_l)\n{\n\tchar *equal, *att_end, *att_beg, *val_beg, *val_end;\n\tchar *next;\n\n\t/* we search at least a cookie name followed by an equal, and more\n\t * generally something like this :\n\t * Cookie:    NAME1  =  VALUE 1  ; NAME2 = VALUE2 ; NAME3 = VALUE3\\r\\n\n\t */\n\tfor (att_beg = hdr; att_beg + cookie_name_l + 1 < hdr_end; att_beg = next + 1) {\n\t\t/* Iterate through all cookies on this line */\n\n\t\twhile (att_beg < hdr_end && HTTP_IS_SPHT(*att_beg))\n\t\t\tatt_beg++;\n\n\t\t/* find att_end : this is the first character after the last non\n\t\t * space before the equal. It may be equal to hdr_end.\n\t\t */\n\t\tequal = att_end = att_beg;\n\n\t\twhile (equal < hdr_end) {\n\t\t\tif (*equal == '=' || *equal == ';' || (list && *equal == ','))\n\t\t\t\tbreak;\n\t\t\tif (HTTP_IS_SPHT(*equal++))\n\t\t\t\tcontinue;\n\t\t\tatt_end = equal;\n\t\t}\n\n\t\t/* here, <equal> points to '=', a delimiter or the end. <att_end>\n\t\t * is between <att_beg> and <equal>, both may be identical.\n\t\t */\n\n\t\t/* look for end of cookie if there is an equal sign */\n\t\tif (equal < hdr_end && *equal == '=') {\n\t\t\t/* look for the beginning of the value */\n\t\t\tval_beg = equal + 1;\n\t\t\twhile (val_beg < hdr_end && HTTP_IS_SPHT(*val_beg))\n\t\t\t\tval_beg++;\n\n\t\t\t/* find the end of the value, respecting quotes */\n\t\t\tnext = http_find_cookie_value_end(val_beg, hdr_end);\n\n\t\t\t/* make val_end point to the first white space or delimiter after the value */\n\t\t\tval_end = next;\n\t\t\twhile (val_end > val_beg && HTTP_IS_SPHT(*(val_end - 1)))\n\t\t\t\tval_end--;\n\t\t} else {\n\t\t\tval_beg = val_end = next = equal;\n\t\t}\n\n\t\t/* We have nothing to do with attributes beginning with '$'. However,\n\t\t * they will automatically be removed if a header before them is removed,\n\t\t * since they're supposed to be linked together.\n\t\t */\n\t\tif (*att_beg == '$')\n\t\t\tcontinue;\n\n\t\t/* Ignore cookies with no equal sign */\n\t\tif (equal == next)\n\t\t\tcontinue;\n\n\t\t/* Now we have the cookie name between att_beg and att_end, and\n\t\t * its value between val_beg and val_end.\n\t\t */\n\n\t\tif (cookie_name_l == 0 || (att_end - att_beg == cookie_name_l &&\n\t\t    memcmp(att_beg, cookie_name, cookie_name_l) == 0)) {\n\t\t\t/* let's return this value and indicate where to go on from */\n\t\t\t*value = val_beg;\n\t\t\t*value_l = val_end - val_beg;\n\t\t\treturn next + 1;\n\t\t}\n\n\t\t/* Set-Cookie headers only have the name in the first attr=value part */\n\t\tif (!list)\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\n/* Parses a qvalue and returns it multiplied by 1000, from 0 to 1000. If the\n * value is larger than 1000, it is bound to 1000. The parser consumes up to\n * 1 digit, one dot and 3 digits and stops on the first invalid character.\n * Unparsable qvalues return 1000 as \"q=1.000\".\n */\nint http_parse_qvalue(const char *qvalue, const char **end)\n{\n\tint q = 1000;\n\n\tif (!isdigit((unsigned char)*qvalue))\n\t\tgoto out;\n\tq = (*qvalue++ - '0') * 1000;\n\n\tif (*qvalue++ != '.')\n\t\tgoto out;\n\n\tif (!isdigit((unsigned char)*qvalue))\n\t\tgoto out;\n\tq += (*qvalue++ - '0') * 100;\n\n\tif (!isdigit((unsigned char)*qvalue))\n\t\tgoto out;\n\tq += (*qvalue++ - '0') * 10;\n\n\tif (!isdigit((unsigned char)*qvalue))\n\t\tgoto out;\n\tq += (*qvalue++ - '0') * 1;\n out:\n\tif (q > 1000)\n\t\tq = 1000;\n\tif (end)\n\t\t*end = qvalue;\n\treturn q;\n}\n\n/*\n * Given a url parameter, find the starting position of the first occurrence,\n * or NULL if the parameter is not found.\n *\n * Example: if query_string is \"yo=mama;ye=daddy\" and url_param_name is \"ye\",\n * the function will return query_string+8.\n *\n * Warning: this function returns a pointer that can point to the first chunk\n * or the second chunk. The caller must be check the position before using the\n * result.\n */\nconst char *http_find_url_param_pos(const char **chunks,\n                                    const char* url_param_name, size_t url_param_name_l,\n                                    char delim, char insensitive)\n{\n\tconst char *pos, *last, *equal;\n\tconst char **bufs = chunks;\n\tint l1, l2;\n\n\n\tpos  = bufs[0];\n\tlast = bufs[1];\n\twhile (pos < last) {\n\t\t/* Check the equal. */\n\t\tequal = pos + url_param_name_l;\n\t\tif (fix_pointer_if_wrap(chunks, &equal)) {\n\t\t\tif (equal >= chunks[3])\n\t\t\t\treturn NULL;\n\t\t} else {\n\t\t\tif (equal >= chunks[1])\n\t\t\t\treturn NULL;\n\t\t}\n\t\tif (*equal == '=') {\n\t\t\tif (pos + url_param_name_l > last) {\n\t\t\t\t/* process wrap case, we detect a wrap. In this case, the\n\t\t\t\t * comparison is performed in two parts.\n\t\t\t\t */\n\n\t\t\t\t/* This is the end, we don't have any other chunk. */\n\t\t\t\tif (bufs != chunks || !bufs[2])\n\t\t\t\t\treturn NULL;\n\n\t\t\t\t/* Compute the length of each part of the comparison. */\n\t\t\t\tl1 = last - pos;\n\t\t\t\tl2 = url_param_name_l - l1;\n\n\t\t\t\t/* The second buffer is too short to contain the compared string. */\n\t\t\t\tif (bufs[2] + l2 > bufs[3])\n\t\t\t\t\treturn NULL;\n\n\t\t\t\tif (insensitive) {\n\t\t\t\t\tif (strncasecmp(pos,     url_param_name,    l1) == 0 &&\n\t\t\t\t\t\tstrncasecmp(bufs[2], url_param_name+l1, l2) == 0)\n\t\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (memcmp(pos,     url_param_name,    l1) == 0 &&\n\t\t\t\t\t\tmemcmp(bufs[2], url_param_name+l1, l2) == 0)\n\t\t\t\t\t\treturn pos;\n\t\t\t\t}\n\n\t\t\t\t/* Perform wrapping and jump the string who fail the comparison. */\n\t\t\t\tbufs += 2;\n\t\t\t\tpos = bufs[0] + l2;\n\t\t\t\tlast = bufs[1];\n\n\t\t\t} else {\n\t\t\t\t\t/* process a simple comparison.*/\n\t\t\t\tif (insensitive) {\n\t\t\t\t\tif (strncasecmp(pos, url_param_name, url_param_name_l) == 0)\n\t\t\t\t\t\treturn pos;\n\t\t\t\t} else {\n\t\t\t\t\tif (memcmp(pos, url_param_name, url_param_name_l) == 0)\n\t\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t\tpos += url_param_name_l + 1;\n\t\t\t\tif (fix_pointer_if_wrap(chunks, &pos))\n\t\t\t\t\tlast = bufs[2];\n\t\t\t}\n\t\t}\n\n\t\twhile (1) {\n\t\t\t/* Look for the next delimiter. */\n\t\t\twhile (pos < last && !http_is_param_delimiter(*pos, delim))\n\t\t\t\tpos++;\n\t\t\tif (pos < last)\n\t\t\t\tbreak;\n\t\t\t/* process buffer wrapping. */\n\t\t\tif (bufs != chunks || !bufs[2])\n\t\t\t\treturn NULL;\n\t\t\tbufs += 2;\n\t\t\tpos = bufs[0];\n\t\t\tlast = bufs[1];\n\t\t}\n\t\tpos++;\n\t}\n\treturn NULL;\n}\n\n/*\n * Given a url parameter name and a query string, find the next value.\n * An empty url_param_name matches the first available parameter.\n * If the parameter is found, 1 is returned and *vstart / *vend are updated to\n * respectively provide a pointer to the value and its end.\n * Otherwise, 0 is returned and vstart/vend are not modified.\n */\nint http_find_next_url_param(const char **chunks,\n                             const char* url_param_name, size_t url_param_name_l,\n                             const char **vstart, const char **vend, char delim, char insensitive)\n{\n\tconst char *arg_start, *qs_end;\n\tconst char *value_start, *value_end;\n\n\targ_start = chunks[0];\n\tqs_end = chunks[1];\n\tif (url_param_name_l) {\n\t\t/* Looks for an argument name. */\n\t\targ_start = http_find_url_param_pos(chunks,\n\t\t                                    url_param_name, url_param_name_l,\n\t\t                                    delim, insensitive);\n\t\t/* Check for wrapping. */\n\t\tif (arg_start >= qs_end)\n\t\t\tqs_end = chunks[3];\n\t}\n\tif (!arg_start)\n\t\treturn 0;\n\n\tif (!url_param_name_l) {\n\t\twhile (1) {\n\t\t\t/* looks for the first argument. */\n\t\t\tvalue_start = memchr(arg_start, '=', qs_end - arg_start);\n\t\t\tif (!value_start) {\n\t\t\t\t/* Check for wrapping. */\n\t\t\t\tif (arg_start >= chunks[0] &&\n\t\t\t\t    arg_start < chunks[1] &&\n\t\t\t\t    chunks[2]) {\n\t\t\t\t\targ_start = chunks[2];\n\t\t\t\t\tqs_end = chunks[3];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tvalue_start++;\n\t}\n\telse {\n\t\t/* Jump the argument length. */\n\t\tvalue_start = arg_start + url_param_name_l + 1;\n\n\t\t/* Check for pointer wrapping. */\n\t\tif (fix_pointer_if_wrap(chunks, &value_start)) {\n\t\t\t/* Update the end pointer. */\n\t\t\tqs_end = chunks[3];\n\n\t\t\t/* Check for overflow. */\n\t\t\tif (value_start >= qs_end)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tvalue_end = value_start;\n\n\twhile (1) {\n\t\twhile ((value_end < qs_end) && !http_is_param_delimiter(*value_end, delim))\n\t\t\tvalue_end++;\n\t\tif (value_end < qs_end)\n\t\t\tbreak;\n\t\t/* process buffer wrapping. */\n\t\tif (value_end >= chunks[0] &&\n\t\t    value_end < chunks[1] &&\n\t\t    chunks[2]) {\n\t\t\tvalue_end = chunks[2];\n\t\t\tqs_end = chunks[3];\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\t*vstart = value_start;\n\t*vend = value_end;\n\treturn 1;\n}\n\n/* Parses a single header line (without the CRLF) and splits it into its name\n * and its value. The parsing is pretty naive and just skip spaces.\n */\nint http_parse_header(const struct ist hdr, struct ist *name, struct ist *value)\n{\n        char *p   = hdr.ptr;\n        char *end = p + hdr.len;\n\n        name->len = value->len = 0;\n\n        /* Skip leading spaces */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* Set the header name */\n        name->ptr = p;\n        for (; p < end && HTTP_IS_TOKEN(*p); p++);\n        name->len = p - name->ptr;\n\n        /* Skip the ':' and spaces before and after it */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n        if (p < end && *p == ':') p++;\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* Set the header value */\n        value->ptr = p;\n        value->len = end - p;\n\n        return 1;\n}\n\n/* Parses a single start line (without the CRLF) and splits it into 3 parts. The\n * parsing is pretty naive and just skip spaces.\n */\nint http_parse_stline(const struct ist line, struct ist *p1, struct ist *p2, struct ist *p3)\n{\n        char *p   = line.ptr;\n        char *end = p + line.len;\n\n        p1->len = p2->len = p3->len = 0;\n\n        /* Skip leading spaces */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* Set the first part */\n        p1->ptr = p;\n        for (; p < end && HTTP_IS_TOKEN(*p); p++);\n        p1->len = p - p1->ptr;\n\n        /* Skip spaces between p1 and p2 */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* Set the second part */\n        p2->ptr = p;\n        for (; p < end && !HTTP_IS_SPHT(*p); p++);\n        p2->len = p - p2->ptr;\n\n        /* Skip spaces between p2 and p3 */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* The remaining is the third value */\n        p3->ptr = p;\n        p3->len = end - p;\n\n        return 1;\n}\n\n/* Parses value of a Status header with the following format: \"Status: Code[\n * Reason]\".  The parsing is pretty naive and just skip spaces. It return the\n * numeric value of the status code.\n */\nint http_parse_status_val(const struct ist value, struct ist *status, struct ist *reason)\n{\n\tchar *p   = value.ptr;\n        char *end = p + value.len;\n\tuint16_t code;\n\n\tstatus->len = reason->len = 0;\n\n\t/* Skip leading spaces */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n        /* Set the status part */\n        status->ptr = p;\n        for (; p < end && HTTP_IS_TOKEN(*p); p++);\n        status->len = p - status->ptr;\n\n\t/* Skip spaces between status and reason */\n        for (; p < end && HTTP_IS_SPHT(*p); p++);\n\n\t/* the remaining is the reason */\n        reason->ptr = p;\n        reason->len = end - p;\n\n\tcode = strl2ui(status->ptr, status->len);\n\treturn code;\n}\n\n\n/* Returns non-zero if the two ETags are comparable (see RFC 7232#2.3.2).\n * If any of them is a weak ETag, we discard the weakness prefix and perform\n * a strict string comparison.\n * Returns 0 otherwise.\n */\nint http_compare_etags(struct ist etag1, struct ist etag2)\n{\n\tenum http_etag_type etag_type1;\n\tenum http_etag_type etag_type2;\n\n\tetag_type1 = http_get_etag_type(etag1);\n\tetag_type2 = http_get_etag_type(etag2);\n\n\tif (etag_type1 == ETAG_INVALID || etag_type2 == ETAG_INVALID)\n\t\treturn 0;\n\n\t/* Discard the 'W/' prefix an ETag is a weak one. */\n\tif (etag_type1 == ETAG_WEAK)\n\t\tetag1 = istadv(etag1, 2);\n\tif (etag_type2 == ETAG_WEAK)\n\t\tetag2 = istadv(etag2, 2);\n\n\treturn isteq(etag1, etag2);\n}\n\n\n/*\n * Trim leading space or horizontal tab characters from <value> string.\n * Returns the trimmed string.\n */\nstruct ist http_trim_leading_spht(struct ist value)\n{\n\tstruct ist ret = value;\n\n\twhile (ret.len && HTTP_IS_SPHT(ret.ptr[0])) {\n\t\t++ret.ptr;\n\t\t--ret.len;\n\t}\n\n\treturn ret;\n}\n\n/*\n * Trim trailing space or horizontal tab characters from <value> string.\n * Returns the trimmed string.\n */\nstruct ist http_trim_trailing_spht(struct ist value)\n{\n\tstruct ist ret = value;\n\n\twhile (ret.len && HTTP_IS_SPHT(ret.ptr[-1]))\n\t\t--ret.len;\n\n\treturn ret;\n}\n"], "filenames": ["reg-tests/http-messaging/h1_to_h1.vtc", "reg-tests/http-messaging/h2_to_h1.vtc", "src/h1.c", "src/http.c"], "buggy_code_start_loc": [275, 11, 37, 710], "buggy_code_end_loc": [275, 263, 81, 753], "fixing_code_start_loc": [276, 12, 37, 710], "fixing_code_end_loc": [302, 324, 96, 768], "type": "CWE-444", "message": "HAProxy through 2.0.32, 2.1.x and 2.2.x through 2.2.30, 2.3.x and 2.4.x through 2.4.23, 2.5.x and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forwards empty Content-Length headers, violating RFC 9110 section 8.6. In uncommon cases, an HTTP/1 server behind HAProxy may interpret the payload as an extra request.", "other": {"cve": {"id": "CVE-2023-40225", "sourceIdentifier": "cve@mitre.org", "published": "2023-08-10T21:15:10.743", "lastModified": "2023-08-18T20:03:17.290", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "HAProxy through 2.0.32, 2.1.x and 2.2.x through 2.2.30, 2.3.x and 2.4.x through 2.4.23, 2.5.x and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forwards empty Content-Length headers, violating RFC 9110 section 8.6. In uncommon cases, an HTTP/1 server behind HAProxy may interpret the payload as an extra request."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-444"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.0.32", "matchCriteriaId": "023D059D-3A23-4CD9-85DF-119A32FB24B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndIncluding": "2.2.30", "matchCriteriaId": "26AB82A2-31F2-4ECA-838A-9A94520B5AEE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndIncluding": "2.4.23", "matchCriteriaId": "B3F72E80-3A75-46BA-BC3A-40D87B7BFAF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.5.0", "versionEndExcluding": "2.6.15", "matchCriteriaId": "11561968-E0DC-4BFD-930F-52F96B4A4BBD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.7.0", "versionEndExcluding": "2.7.10", "matchCriteriaId": "855FF6D8-8F0E-4402-AF4D-9810A5080E72"}, {"vulnerable": true, "criteria": "cpe:2.3:a:haproxy:haproxy:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.2", "matchCriteriaId": "8D4FC3EF-9132-46E7-A43B-9074EC0C2EC1"}]}]}], "references": [{"url": "https://cwe.mitre.org/data/definitions/436.html", "source": "cve@mitre.org", "tags": ["Technical Description"]}, {"url": "https://github.com/haproxy/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/haproxy/haproxy/issues/2237", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}, {"url": "https://www.haproxy.org/download/2.6/src/CHANGELOG", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.haproxy.org/download/2.7/src/CHANGELOG", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://www.haproxy.org/download/2.8/src/CHANGELOG", "source": "cve@mitre.org", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/haproxy/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856"}}