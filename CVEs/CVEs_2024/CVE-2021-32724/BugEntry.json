{"buggy_code": ["#!/bin/bash\nif [ \"$INITIALIZED\" != defined ]; then\n  now() {\n    date +'%s%N'\n  }\n  start=$(now)\n  temp=\"${temp:-/tmp/spelling}\"\n  mkdir -p $temp\n  export temp\n  if [ -n \"$DEBUG\" ]; then\n    set -x\n    begin_group() {\n      echo \"::group::$1\"\n    }\n    end_group() {\n      echo '::end_group::'\n    }\n  else\n    begin_group() {\n      echo \"(...$1...)\"\n    }\n    end_group() {\n      :\n    }\n    INITIALIZED=defined\n  fi\nfi\n", "#!/bin/sh\n#! -*-perl-*-\neval 'exec perl -x -T -w $0 ${1+\"$@\"}'\n  if 0;\n# ~/bin/w\n# Search for potentially misspelled words\n# Output is:\n# misspellled\n# woord (WOORD, Woord, woord, woord's)\n\nuse File::Basename;\nuse Cwd 'abs_path';\nuse File::Temp qw/ tempfile tempdir /;\n\nmy $dirname = dirname(abs_path(__FILE__));\n\n# skip files that don't exist (including dangling symlinks)\nif (scalar @ARGV) {\n  @ARGV = grep {-r || $_ eq '-'} @ARGV;\n  unless (scalar @ARGV) {\n    print STDERR \"None of the provided files are readable\\n\";\n    exit 0;\n  }\n}\n\nmy $patterns_re = '^$';\nif (open(PATTERNS, '<', \"$dirname/patterns.txt\")) {\n  my @patterns;\n  local $/=undef;\n  local $file=<PATTERNS>;\n  close PATTERNS;\n  for (split /\\R/, $file) {\n    next if /^#/;\n    chomp;\n    next unless s/^(.+)/(?:$1)/;\n    push @patterns, $_;\n  }\n  $patterns_re = join \"|\", @patterns if scalar @patterns;\n}\n\nmy $longest_word = get_val_from_env('INPUT_LONGEST_WORD', '');\nmy $shortest_word = get_val_from_env('INPUT_SHORTEST_WORD', '');\n\nmy ($shortest, $longest) = (undef, undef);\nsub valid_word {\n  # shortest_word is an absolute\n  $shortest = $shortest_word if $shortest_word;\n  if ($longest_word) {\n    # longest_word is an absolute\n    $longest = $longest_word;\n  } elsif (defined $longest) {\n    # we allow for some sloppiness (a couple of stuck keys per word)\n    # it's possible that this should scale with word length\n    $longest += 2;\n  }\n  return /.../ if (defined $shortest && defined $longest) && ($shortest > $longest);\n  $shortest = 3 unless defined $shortest;\n  $longest = '' unless defined $longest;\n  $word_match = \".{$shortest,$longest}\";\n  return qr/\\b$word_match\\b/;\n}\n\nmy $word_match = valid_word();\n($shortest, $longest) = (255, 0);\n# load dictionary\nmy $dict = \"$dirname/words\";\n$dict = '/usr/share/dict/words' unless -e $dict;\nopen(DICT, '<', $dict);\nmy %dictionary=();\nwhile ($word = <DICT>) {\n  chomp $word;\n  next unless $word =~ $word_match;\n  my $l = length $word;\n  $longest = $l if $l > $longest;\n  $shortest = $l if $l < $shortest;\n  $dictionary{$word}=1;\n}\nclose DICT;\n\nsub get_val_from_env {\n  my ($var, $fallback) = @_;\n  return $fallback unless defined $ENV{$var};\n  $ENV{$var} =~ /^(\\d+)$/;\n  return $1 || $fallback;\n}\n\n$word_match = valid_word();\n\n# read all input\nmy ($last_file, $temp_dir, $words, $unrecognized) = ('', '', 0, 0);\nmy %unique;\nmy %unique_unrecognized;\nmy @reports;\n\nsub report_stats() {\n  if ($unrecognized) {\n    open(STATS, '>', \"$temp_dir/stats\");\n      print STATS \"{words: $words, unrecognized: $unrecognized, unknown: \".(keys %unique_unrecognized).\", unique: \".(keys %unique).\"}\";\n    close STATS;\n    open(UNKNOWN, '>', \"$temp_dir/unknown\");\n      print UNKNOWN join \"\\n\", sort keys %unique_unrecognized;\n    close UNKNOWN;\n    close WARNINGS;\n  }\n}\n\nwhile (<<>>) {\n  if ($last_file ne $ARGV) {\n    $. = 1;\n    $last_file = $ARGV;\n    report_stats();\n\n    $temp_dir = tempdir();\n    push @reports, \"$temp_dir\\n\";\n    open(NAME, '>', \"$temp_dir/name\");\n      print NAME $last_file;\n    close NAME;\n    ($words, $unrecognized) = (0, 0);\n    %unique = ();\n    %unique_unrecognized = ();\n    open(WARNINGS, '>', \"$temp_dir/warnings\");\n  }\n  next unless /./;\n  my $raw_line = $_;\n  # hook for custom line based text exclusions:\n  s/$patterns_re/ /g;\n  # This is to make it easier to deal w/ rules:\n  s/^/ /;\n  while (s/([^\\\\])\\\\[rtn]/$1 /g) {}\n  # https://www.fileformat.info/info/unicode/char/2019/\n  my $rsqm = \"\\xE2\\x80\\x99\";\n  s/$rsqm|&apos;|&#39;/'/g;\n  s/[^a-zA-Z']+/ /g;\n  while (s/([A-Z]{2,})([A-Z][a-z]{2,})/ $1 $2 /g) {}\n  while (s/([a-z']+)([A-Z])/$1 $2/g) {}\n  my %unrecognized_line_items = ();\n  for my $token (split /\\s+/, $_) {\n    $token =~ s/^(?:'|$rsqm)+//g;\n    $token =~ s/(?:'|$rsqm)+s?$//g;\n    my $raw_token = $token;\n    $token =~ s/^[^Ii]?'+(.*)/$1/;\n    $token =~ s/(.*?)'+$/$1/;\n    next unless $token =~ $word_match;\n    if (defined $dictionary{$token}) {\n      ++$words;\n      $unique{$token}=1;\n      next;\n    }\n    my $key = lc $token;\n    $key =~ s/''+/'/g;\n    $key =~ s/'[sd]$//;\n    if (defined $dictionary{$key}) {\n      ++$words;\n      $unique{$key}=1;\n      next;\n    }\n    ++$unrecognized;\n    $unique_unrecognized{$raw_token}=1;\n    $unrecognized_line_items{$raw_token}=1;\n  }\n  for my $token (keys %unrecognized_line_items) {\n    $token =~ s/'/(?:'|$rsqm)+/g;\n    while ($raw_line =~ /\\b($token)\\b/g) {\n      my ($begin, $end, $match) = ($-[0] + 1, $+[0] + 1, $1);\n      next unless $match =~ /./;\n      print WARNINGS \"line $. cols $begin-$end: '$match'\\n\";\n    }\n  }\n}\nreport_stats();\nprint join '', @reports;\n", "#!/bin/bash\n# This CI acceptance test is based on:\n# https://github.com/jsoref/spelling/tree/04648bdc63723e5cdf5cbeaff2225a462807abc8\n# It is conceptually `f` which runs `w` (spelling-unknown-word-splitter)\n# plus `fchurn` which uses `dn` mostly rolled together.\nset -e\nexport spellchecker=${spellchecker:-/app}\n. \"$spellchecker/common.sh\"\n\nmain() {\n  GITHUB_TOKEN=${GITHUB_TOKEN:-$INPUT_GITHUB_TOKEN}\n  if [ -z \"$GITHUB_EVENT_PATH\" ] || [ ! -e \"$GITHUB_EVENT_PATH\" ]; then\n    GITHUB_EVENT_PATH=/dev/null\n  fi\n  case \"$GITHUB_EVENT_NAME\" in\n    schedule)\n      exec \"$spellchecker/check-pull-requests.sh\"\n      ;;\n    issue_comment)\n      if [ -n \"$DEBUG\" ]; then\n        set -x\n      fi\n      handle_comment\n      ;;\n    pull_request_review_comment)\n      (\n        echo 'check-spelling does not currently support comments on code.'\n        echo 'If you are trying to ask @check-spelling-bot to update a PR,'\n        echo 'please quote the comment link as a top level comment instead'\n        echo 'of in a comment on a block of code.'\n        echo\n        echo 'Future versions may support this feature.'\n        echo 'For the time being, early adopters should remove the'\n        echo '`pull_request_review_comment` event from their workflow.'\n        echo 'workflow.'\n       ) >&2\n      exit 0\n      ;;\n  esac\n}\n\noffer_quote_reply() {\n  case \"$INPUT_EXPERIMENTAL_APPLY_CHANGES_VIA_BOT\" in\n    1|true|TRUE)\n      case \"$GITHUB_EVENT_NAME\" in\n        issue_comment|pull_request|pull_request_target)\n          true;;\n        *)\n          false;;\n        esac\n      ;;\n    *)\n      false\n      ;;\n  esac\n}\n\nrepo_is_private() {\n  private=$(jq -r .repository.private < \"$GITHUB_EVENT_PATH\")\n  [ \"$private\" = \"true\" ]\n}\n\ncommand_v() {\n  command -v \"$1\" >/dev/null 2>/dev/null\n}\n\nreact_comment_and_die() {\n  trigger_comment_url=\"$1\"\n  message=\"$2\"\n  react=\"$3\"\n  echo \"::error ::$message\"\n  react \"$trigger_comment_url\" \"$react\" > /dev/null\n  if [ -n \"$COMMENTS_URL\" ] && [ -z \"${COMMENTS_URL##*:*}\" ]; then\n    PAYLOAD=$(mktemp_json)\n    echo '{}' | jq --arg body \"@check-spelling-bot: $react_prefix $message\" '.body = $body' > $PAYLOAD\n\n    res=0\n    comment \"$COMMENTS_URL\" \"$PAYLOAD\" > /dev/null || res=$?\n    if [ $res -gt 0 ]; then\n      if [ -z \"$DEBUG\" ]; then\n        echo \"failed posting to $COMMENTS_URL\"\n        echo \"$PAYLOAD\"\n      fi\n      return $res\n    fi\n\n    rm $PAYLOAD\n  fi\n  exit 1\n}\n\nconfused_comment() {\n  react_comment_and_die \"$1\" \"$2\" \"confused\"\n}\n\ngithub_user_and_email() {\n  user_json=$(mktemp_json)\n  curl -s \\\n    -H \"Authorization: token $GITHUB_TOKEN\" \\\n    \"$GITHUB_API_URL/users/$1\" > $user_json\n\n  github_name=$(jq -r '.name // empty' < $user_json)\n  if [ -z \"$github_name\" ]; then\n    github_name=$1\n  fi\n  github_email=$(jq -r '.email // empty' < $user_json)\n  rm $user_json\n  if [ -z \"$github_email\" ]; then\n    github_email=\"$1@users.noreply.github.com\"\n  fi\n  COMMIT_AUTHOR=\"--author=$github_name <$github_email>\"\n}\n\ngit_commit() {\n  reason=\"$1\"\n  git add -u\n  git config user.email \"check-spelling-bot@users.noreply.github.com\"\n  git config user.name \"check-spelling-bot\"\n  git commit \\\n    \"$COMMIT_AUTHOR\" \\\n    --date=\"$created_at\" \\\n    -m \"$(echo \"[check-spelling] Applying automated metadata updates\n\n                $reason\n\n                Signed-off-by: check-spelling-bot <check-spelling-bot@users.noreply.github.com>\n                \" | strip_lead)\"\n}\n\nmktemp_json() {\n  file=$(mktemp)\n  mv \"$file\" \"$file.json\"\n  echo \"$file.json\"\n}\n\nhandle_comment() {\n  if ! offer_quote_reply; then\n    exit 0\n  fi\n\n  action=$(jq -r .action < \"$GITHUB_EVENT_PATH\")\n  if [ \"$action\" != \"created\" ]; then\n    exit 0\n  fi\n\n  comment=$(mktemp_json)\n  jq -r .comment < \"$GITHUB_EVENT_PATH\" > $comment\n  body=$(mktemp)\n  jq -r .body $comment > $body\n\n  trigger=$(perl -ne 'print if /\\@check-spelling-bot(?:\\s+|:\\s*)apply/' < $body)\n  rm $body\n  if [ -z \"$trigger\" ]; then\n    exit 0\n  fi\n\n  trigger_comment_url=$(jq -r .url < $comment)\n  sender_login=$(jq -r .sender.login < \"$GITHUB_EVENT_PATH\")\n  issue_user_login=$(jq -r .issue.user.login < \"$GITHUB_EVENT_PATH\")\n  issue=$(mktemp_json)\n  jq -r .issue < \"$GITHUB_EVENT_PATH\" > $issue\n  pull_request_url=$(jq -r .pull_request.url < $issue)\n  pull_request_info=$(mktemp_json)\n  pull_request \"$pull_request_url\" | jq .head > $pull_request_info\n  pull_request_sha=$(jq -r .sha < $pull_request_info)\n  set_comments_url \"$GITHUB_EVENT_NAME\" \"$GITHUB_EVENT_PATH\" \"$pull_request_sha\"\n  react_prefix_base=\"Could not perform [request]($trigger_comment_url).\"\n  react_prefix=\"$react_prefix_base\"\n  if [ \"$sender_login\" != \"$issue_user_login\" ]; then\n    collaborators_url=$(jq -r .repository.collaborators_url < \"$GITHUB_EVENT_PATH\")\n    collaborators_url=$(echo \"$collaborators_url\" | perl -pne \"s<\\{/collaborator\\}></$sender_login/permission>\")\n    collaborator_permission=$(collaborator \"$collaborators_url\" | jq -r .permission)\n    case $collaborator_permission in\n      admin)\n        ;;\n      write)\n        ;;\n      *)\n        confused_comment \"$trigger_comment_url\" \"Commenter (@$sender_login) isn't author (@$issue_user_login) / collaborator\"\n        ;;\n    esac\n  fi\n  number=$(jq -r .number < $issue)\n  created_at=$(jq -r .created_at < $comment)\n  issue_url=$(jq -r .url < $issue)\n  pull_request_ref=$(jq -r .ref < $pull_request_info)\n  pull_request_repo=$(jq -r .repo.clone_url < $pull_request_info)\n  git remote add request $pull_request_repo\n  git fetch request \"$pull_request_sha\"\n  git config advice.detachedHead false\n  git reset --hard\n  git checkout \"$pull_request_sha\"\n\n  number_filter() {\n    perl -pne 's/\\{.*\\}//'\n  }\n  comments_base=$(jq -r .repository.comments_url < \"$GITHUB_EVENT_PATH\" | number_filter)\n  issue_comments_base=$(jq -r .repository.issue_comment_url < \"$GITHUB_EVENT_PATH\" | number_filter)\n  export comments_url=\"$comments_base|$issue_comments_base\"\n  comment_url=$(echo \"$trigger\" | perl -ne 'next unless m{((?:$ENV{comments_url})/\\d+)}; print \"$1\\n\";')\n  [ -n \"$comment_url\" ] ||\n    confused_comment \"$trigger_comment_url\" \"Did not find $comments_url in comment\"\n\n  res=0\n  comment \"$comment_url\" > $comment || res=$?\n  if [ $res -gt 0 ]; then\n    if [ -z \"$DEBUG\" ]; then\n      echo \"failed to retrieve $comment_url\"\n    fi\n    return $res\n  fi\n\n  comment_body=$(mktemp)\n  jq -r .body < $comment > $comment_body\n  bot_comment_author=$(jq -r .user.login < $comment)\n  bot_comment_node_id=$(jq -r .node_id < $comment)\n  bot_comment_url=$(jq -r '.issue_url // .comment.url' < $comment)\n  rm $comment\n  github_actions_bot=\"github-actions[bot]\"\n  [ \"$bot_comment_author\" = \"$github_actions_bot\" ] ||\n    confused_comment \"$trigger_comment_url\" \"Expected @$github_actions_bot to be author of $comment_url (found @$bot_comment_author)\"\n  [ \"$issue_url\" = \"$bot_comment_url\" ] ||\n    confused_comment \"$trigger_comment_url\" \"Referenced comment was for a different object: $bot_comment_url\"\n  capture_items() {\n    perl -ne 'next unless s{^\\s*my \\@'$1'=qw\\('$q$Q'(.*)'$Q$q'\\);$}{$1}; print'\n  }\n  capture_item() {\n    perl -ne 'next unless s{^\\s*my \\$'$1'=\"(.*)\";$}{$1}; print'\n  }\n  skip_wrapping=1\n\n  instructions_head=$(mktemp)\n  (\n    patch_add=1\n    patch_remove=1\n    should_exclude_patterns=1\n    patch_variables $comment_body > $instructions_head\n  )\n  git restore $bucket/$project\n\n  res=0\n  . $instructions_head || res=$?\n  if [ $res -gt 0 ]; then\n    echo \"instructions_head failed ($res)\"\n    cat $instructions_head\n    return $res\n  fi\n  rm $comment_body $instructions_head\n  instructions=$(generate_instructions)\n\n  react_prefix=\"$react_prefix [Instructions]($comment_url)\"\n  . $instructions || res=$?\n  if [ $res -gt 0 ]; then\n    echo \"instructions failed ($res)\"\n    cat $instructions\n    res=0\n    confused_comment \"$trigger_comment_url\" \"failed to apply\"\n  fi\n  rm $instructions\n  git status --u=no --porcelain | grep -q . ||\n    confused_comment \"$trigger_comment_url\" \"didn't change repository\"\n  react_prefix=\"$react_prefix_base\"\n  github_user_and_email $sender_login\n  git_commit \"$(echo \"Update per $comment_url\n                      Accepted in $trigger_comment_url\n                    \"|strip_lead)\" ||\n    confused_comment \"$trigger_comment_url\" \"Failed to generate commit\"\n  git push request \"HEAD:$pull_request_ref\" ||\n    confused_comment \"$trigger_comment_url\" \"Failed to push to $pull_request_repo\"\n\n  react \"$trigger_comment_url\" 'eyes' > /dev/null\n  react \"$comment_url\" 'rocket' > /dev/null\n  trigger_node=$(jq -r .comment.node_id < \"$GITHUB_EVENT_PATH\")\n  collapse_comment $trigger_node $bot_comment_node_id\n\n  echo \"# end\"\n  exit 0\n}\n\ndefine_variables() {\n  bucket=${INPUT_BUCKET:-$bucket}\n  project=${INPUT_PROJECT:-$project}\n  if [ -z \"$bucket\" ] && [ -z \"$project\" ] && [ -n \"$INPUT_CONFIG\" ]; then\n    bucket=${INPUT_CONFIG%/*}\n    project=${INPUT_CONFIG##*/}\n  fi\n  job_count=${INPUT_EXPERIMENTAL_PARALLEL_JOBS:-2}\n  if ! [ \"$job_count\" -eq \"$job_count\" ] 2>/dev/null || [ \"$job_count\" -lt 2 ]; then\n    job_count=1\n  fi\n\n  dict=\"$spellchecker/words\"\n  patterns=\"$spellchecker/patterns.txt\"\n  excludes=\"$spellchecker/excludes.txt\"\n  excludes_path=\"$temp/excludes.txt\"\n  only=\"$spellchecker/only.txt\"\n  only_path=\"$temp/only.txt\"\n  dictionary_path=\"$temp/dictionary.txt\"\n  allow_path=\"$temp/allow.txt\"\n  reject_path=\"$temp/reject.txt\"\n  expect_path=\"$temp/expect.words.txt\"\n  excludelist_path=\"$temp/excludes.txt\"\n  patterns_path=\"$temp/patterns.txt\"\n  advice_path=\"$temp/advice.md\"\n  advice_path_txt=\"$temp/advice.txt\"\n  word_splitter=\"$spellchecker/spelling-unknown-word-splitter.pl\"\n  word_collator=\"$spellchecker/spelling-collator.pl\"\n  run_output=\"$temp/unknown.words.txt\"\n  run_files=\"$temp/reporter-input.txt\"\n  tokens_file=\"$temp/tokens.txt\"\n}\n\nsort_unique() {\n  sort -u -f \"$@\" | perl -ne 'next unless /./; print'\n}\n\nproject_file_path() {\n  ext=$(echo \"$2\" | sed -e 's/^.*\\.//')\n  echo $bucket/$project/$1.${ext:-txt}\n}\n\ncheck_pattern_file() {\n  perl -i -e 'while (<>) {\n    next if /^#/;\n    next unless /./;\n    if (eval {qr/$_/}) {\n      print;\n    } else {\n      $@ =~ s/(.*?)\\n.*/$1/m;\n      chomp $@;\n      my $err = $@;\n      $err =~ s{^.*? in regex; marked by <-- HERE in m/(.*) <-- HERE.*$}{$1};\n      print STDERR \"$ARGV: line $., columns $-[0]-$-[0], Warning - bad regex (bad-regex)\\n$@\\n\";\n      print \"^\\$\\n\";\n    }\n  }' $1\n}\n\ncheck_for_newline_at_eof() {\n  maybe_missing_eol=\"$1\"\n  if [ -s \"$maybe_missing_eol\" ] && [ $(tail -1 \"$maybe_missing_eol\" | wc -l) -eq 0 ]; then\n    line=$(( $(cat \"$maybe_missing_eol\" | wc -l) + 1 ))\n    start=$(tail -1 \"$maybe_missing_eol\" | wc -c)\n    stop=$(( $start + 1 ))\n    echo \"$maybe_missing_eol: line $line, columns $start-$stop, Warning - no newline at eof (no-newline-at-eof)\" >&2\n    echo >> \"$maybe_missing_eol\"\n  fi\n}\n\ncheck_dictionary() {\n  file=\"$1\"\n  expected_chars=\"[a-zA-Z']\"\n  unexpected_chars=\"[^a-zA-Z']\"\n  (perl -pi -e '\n  chomp;\n  my $messy = 0;\n  my $orig = $_;\n  if (s/\\n|\\r|\\x0b|\\f|\\x85|\\x2028|\\x2029/a/g) {\n    $messy = 1;\n  }\n  if ('\"/^${expected_chars}*(${unexpected_chars}+)/\"') {\n    print STDERR \"$ARGV: line $., columns $-[1]-$+[1], Warning - ignoring entry because it contains non alpha characters (non-alpha-in-dictionary)\\n\";\n    $_ = \"\";\n  } else {\n    if ($messy) {\n      $_ = $orig;\n      s/\\R//;\n      print STDERR \"$ARGV: line $., columns $-[0]-$+[0], Warning - entry has unexpected whitespace (whitespace-in-dictionary)\\n\";\n    }\n    $_ .= \"\\n\";\n  }\n' \"$file\") 2>&1\n}\n\ncleanup_file() {\n  maybe_bad=\"$1\"\n  type=\"$2\"\n  case \"$type\" in\n    patterns|excludes|only)\n      check_pattern_file \"$maybe_bad\"\n    ;;\n    dictionary|expect|allow)\n      check_dictionary \"$maybe_bad\"\n    ;;\n    # reject isn't checked, it allows for regular expressions\n  esac\n  check_for_newline_at_eof \"$maybe_bad\"\n}\n\nget_project_files() {\n  file=$1\n  dest=$2\n  type=$1\n  if [ ! -e \"$dest\" ] && [ -n \"$bucket\" ] && [ -n \"$project\" ]; then\n    from=$(project_file_path $file $dest)\n    case \"$from\" in\n      .*)\n        append_to=\"$from\"\n        append_to_generated=\"\"\n        if [ -f \"$from\" ]; then\n          echo \"Retrieving $file from $from\"\n          cleanup_file \"$from\" \"$type\"\n          cp \"$from\" $dest\n          from_expanded=\"$from\"\n        else\n          if [ ! -e \"$from\" ]; then\n            ext=$(echo \"$from\" | sed -e 's/^.*\\.//')\n            from=$(echo $from | sed -e \"s/\\.$ext$//\")\n          fi\n          if [ -d \"$from\" ]; then\n            from_expanded=$(ls $from/*$ext |sort)\n            append_to=$from/${GITHUB_SHA:-$(date +%Y%M%d%H%m%S)}.$ext\n            append_to_generated=new\n            touch $dest\n            echo \"Retrieving $file from $from_expanded\"\n            for item in $from_expanded; do\n              if [ -s $item ]; then\n                cleanup_file \"$item\" \"$type\"\n                cat \"$item\" >> $dest\n              fi\n            done\n            from=\"$from/$(basename \"$from\")\".$ext\n          fi\n        fi;;\n      ssh://git@*|git@*)\n        (\n          echo \"Retrieving $file from $from\"\n          cd $temp\n          repo=$(echo \"$bucket\" | perl -pne 's#(?:ssh://|)git\\@github.com[:/]([^/]*)/(.*.git)#https://github.com/$1/$2#')\n          [ -d metadata ] || git clone --depth 1 $repo --single-branch --branch $project metadata\n          cleanup_file \"metadata/$file.txt\" \"$type\"\n          cp metadata/$file.txt $dest 2> /dev/null || touch $dest\n        );;\n      gs://*)\n        echo \"Retrieving $file from $from\"\n        gsutil cp -Z $from $dest >/dev/null 2>/dev/null || touch $dest\n        cleanup_file \"$dest\" \"$type\"\n        ;;\n      *://*)\n        echo \"Retrieving $file from $from\"\n        download \"$from\" \"$dest\" || touch $dest\n        cleanup_file \"$dest\" \"$type\"\n        ;;\n    esac\n  fi\n}\nget_project_files_deprecated() {\n  # \"preferred\" \"deprecated\" \"path\"\n  if [ ! -s \"$3\" ]; then\n    save_append_to=\"$append_to\"\n    get_project_files \"$2\" \"$3\"\n    if [ -s \"$3\" ]; then\n      example=$(for file in $from_expanded; do echo $file; done|head -1)\n      if [ $(basename $(dirname $example)) = \"$2\" ]; then\n        note=\" directory\"\n      else\n        note=\"\"\n      fi\n      echo \"::warning file=$example::deprecation: please rename '$2'$note to '$1'\"\n    else\n      append_to=\"$save_append_to\"\n    fi\n  fi\n}\n\ndownload() {\n  curl -L -s \"$1\" -o \"$2\" -f\n  exit_value=$?\n  if [ $exit_value = 0 ]; then\n    echo \"Downloaded $1 (to $2)\" >&2\n  fi\n  return $exit_value\n}\n\ndownload_or_quit_with_error() {\n  exit_code=$(mktemp)\n  download \"$1\" \"$2\" || (\n    echo $? > $exit_code\n    echo \"Could not download $1 (to $2)\" >&2\n  )\n  if [ -s $exit_code ]; then\n    exit_value=$(cat $exit_code)\n    rm $exit_code\n    quit $exit_value\n  fi\n}\n\nset_up_tools() {\n  apps=\"\"\n  add_app() {\n    if ! command_v $1; then\n      apps=\"$apps $@\"\n    fi\n  }\n  add_app curl ca-certificates\n  add_app git\n  add_app parallel\n  if [ -n \"$apps\" ]; then\n    if command_v apt-get; then\n      export DEBIAN_FRONTEND=noninteractive\n      apt-get -qq update &&\n      apt-get -qq install --no-install-recommends -y $apps >/dev/null 2>/dev/null\n      echo Installed: $apps >&2\n    elif command_v brew; then\n      brew install $apps\n    else\n      echo missing $apps -- things will fail >&2\n    fi\n  fi\n  set_up_jq\n}\n\nset_up_jq() {\n  if ! command_v jq || jq --version | perl -ne 'exit 0 unless s/^jq-//;exit 1 if /^(?:[2-9]|1\\d|1\\.(?:[6-9]|1\\d+))/; exit 0'; then\n    jq_url=https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\n    spellchecker_bin=\"$spellchecker/bin\"\n    jq_bin=\"$spellchecker_bin/jq\"\n    mkdir -p $spellchecker_bin\n    download_or_quit_with_error \"$jq_url\" \"$jq_bin\"\n    chmod 0755 \"$jq_bin\"\n    PATH=$spellchecker_bin:$PATH\n  fi\n}\n\nset_up_files() {\n  mkdir -p .git\n  cp $spellchecker/reporter.json .git/\n  echo \"::add-matcher::.git/reporter.json\"\n  get_project_files expect $expect_path\n  get_project_files_deprecated expect whitelist $expect_path\n  expect_files=$from_expanded\n  expect_file=$from\n  touch $expect_path\n  new_expect_file=$append_to\n  new_expect_file_new=$append_to_generated\n  get_project_files excludes $excludelist_path\n  excludes_files=$from_expanded\n  excludes_file=$from\n  if [ -s \"$excludes_path\" ]; then\n    cp \"$excludes_path\" \"$excludes\"\n  fi\n  should_exclude_file=$(mktemp)\n  get_project_files dictionary $dictionary_path\n  if [ -s \"$dictionary_path\" ]; then\n    cp \"$dictionary_path\" \"$dict\"\n  fi\n  if [ ! -s \"$dict\" ]; then\n    DICTIONARY_VERSION=${DICTIONARY_VERSION:-$INPUT_DICTIONARY_VERSION}\n    DICTIONARY_URL=${DICTIONARY_URL:-$INPUT_DICTIONARY_URL}\n    eval download_or_quit_with_error \"$DICTIONARY_URL\" \"$dict\"\n  fi\n  get_project_files allow $allow_path\n  if [ -s \"$allow_path\" ]; then\n    cat \"$allow_path\" >> \"$dict\"\n  fi\n  get_project_files reject $reject_path\n  if [ -s \"$reject_path\" ]; then\n    dictionary_temp=$(mktemp)\n    if grep_v_string '^('$(echo $(cat \"$reject_path\")|tr \" \" '|')')$' < \"$dict\" > $dictionary_temp; then\n      cat $dictionary_temp > \"$dict\"\n    fi\n  fi\n  get_project_files only $only_path\n  if [ -s \"$only_path\" ]; then\n    cp \"$only_path\" \"$only\"\n  fi\n  get_project_files patterns $patterns_path\n  if [ -s \"$patterns_path\" ]; then\n    cp \"$patterns_path\" \"$patterns\"\n  fi\n  get_project_files advice $advice_path\n  if [ ! -s \"$advice_path\" ]; then\n    get_project_files advice $advice_path_txt\n    if [ -s \"$advice_path\" ]; then\n      cp \"$advice_path_txt\" \"$advice_path\"\n    fi\n  fi\n\n  if [ -n \"$debug\" ]; then\n    echo \"Clean up from previous run\"\n  fi\n  rm -f \"$run_output\"\n}\n\nwelcome() {\n  echo \"Checking spelling...\"\n  if [ -n \"$DEBUG\" ]; then\n    begin_group 'Excluded paths'\n    if [ -e \"$excludes\" ]; then\n      echo 'Excluded paths:'\n      cat \"$excludes\"\n    else\n      echo 'No excluded paths file'\n    fi\n    end_group\n    begin_group 'Only paths restriction'\n    if [ -e \"$only\" ]; then\n      echo 'Only paths restriction:'\n      cat \"$only\"\n    else\n      echo 'No only paths restriction file'\n    fi\n    end_group\n  fi\n  if [ -n \"$INPUT_PATH\" ]; then\n    cd \"$INPUT_PATH\"\n  fi\n}\n\nxargs_zero() {\n  if command_v parallel; then\n    parallel --no-notice --no-run-if-empty -0 -n1 \"$@\"\n  elif [ $(uname) = \"Linux\" ]; then\n    xargs --no-run-if-empty -0 -n1 \"$@\"\n  else\n    arguments=\"$*\" \"$spellchecker/xargs_zero\"\n  fi\n}\n\nrun_spell_check() {\n  begin_group 'Spell check files'\n  file_list=$(mktemp)\n    git 'ls-files' -z 2> /dev/null |\\\n    \"$spellchecker/exclude.pl\" > $file_list\n  perl -e '$/=\"\\0\"; $count=0; while (<>) {s/\\R//; $count++ if /./;}; print \"Checking $count files\\n\";' $file_list\n  end_group\n\n  begin_group 'Spell check'\n  warning_output=$(mktemp)\n  more_warnings=$(mktemp)\n  (\n    # Technically $should_exclude_file is an append race under parallel\n    # since the file isn't critical -- it's advisory, I'm going to wait\n    # on reports before fixing it.\n    # The fix is to have a directory and have each process append to a\n    # file named for its pid inside that directory, and then have the\n    # caller can collate...\n    cat $file_list) |\\\n  parallel -0 -n8 \"-j$job_count\" \"$word_splitter\" |\\\n  expect=\"$expect_path\" warning_output=\"$warning_output\" more_warnings=\"$more_warnings\" should_exclude_file=\"$should_exclude_file\" \"$word_collator\" |\\\n  perl -p -n -e 's/ \\(.*//' > \"$run_output\"\n  word_splitter_status=\"${PIPESTATUS[2]} ${PIPESTATUS[3]}\"\n  cat \"$warning_output\" \"$more_warnings\"\n  rm \"$warning_output\" \"$more_warnings\"\n  end_group\n  if [ \"$word_splitter_status\" != '0 0' ]; then\n    echo \"$word_splitter failed ($word_splitter_status)\"\n    exit 2\n  fi\n  rm $file_list\n}\n\nprintDetails() {\n  echo ''\n  echo 'If you are ok with the output of this run, you will need to'\n}\n\nrelative_note() {\n  if [ -n \"$bucket\" ] && [ -n \"$project\" ]; then\n    from=$(project_file_path $file)\n    case \"$from\" in\n      .*)\n        ;;\n      ssh://git@*|git@*|gs://|*://*)\n        echo '(They can be run anywhere with permissions to update the bucket.)';;\n    esac\n  fi\n}\nto_retrieve_expect() {\n  expect_file=expect.txt\n  case \"$bucket\" in\n    '')\n      echo '# no bucket defined -- you can specify one per the README.md using the file defined below:';;\n    ssh://git@*|git@*)\n      echo \"git clone --depth 1 $bucket --single-branch --branch $project metadata; cp metadata/expect.txt .\";;\n    gs://*)\n      echo gsutil cp -Z $(project_file_path expect) expect.txt;;\n    *://*)\n      echo curl -L -s \"$(project_file_path expect)\" -o expect.txt;;\n  esac\n}\nto_publish_expect() {\n  case \"$bucket\" in\n    '')\n      echo \"# no bucket defined -- copy $1 to a bucket and configure it per the README.md\";;\n    ssh://git@*|git@*)\n      echo \"cp $1 metadata/expect.txt; (cd metadata; git commit expect.txt -m 'Updating expect'; git push)\";;\n    gs://*)\n      echo gsutil cp -Z $1 $(project_file_path expect);;\n    *://*)\n      echo \"# command to publish $1 is not known. URL: $(project_file_path expect)\";;\n    *)\n      if [ \"$2\" = new ]; then\n        cmd=\"git add $bucket/$project || echo '... you want to ensure $1 is added to your repository...'\"\n        case $(realpath --relative-base=\"$bucket\" \"$1\") in\n          /*)\n            cmd=\"cp $1 $(project_file_path expect); $cmd\";;\n        esac\n        echo \"$cmd\"\n      fi\n      ;;\n  esac\n}\n\nremove_items() {\n  patch_remove=$(echo \"$diff_output\" | perl -ne 'next unless s/^-([^-])/$1/; s/\\n/ /; print')\n  if [ -n \"$patch_remove\" ]; then\n    echo \"\n<details><summary>Previously acknowledged words that are now absent\n</summary>$patch_remove</details>\n\"\n    if [ -n \"$INPUT_CAPTURE_STALE_WORDS\" ]; then\n      remove_words=$(mktemp)\n      echo \"$patch_remove\" > $remove_words\n      echo \"::set-output name=stale_words::$remove_words\"\n    fi\n  else\n    rm \"$fewer_misspellings_canary\"\n  fi\n}\n\nspelling_warning() {\n  OUTPUT=\"#### $1:\n\"\n  spelling_body \"$2\" \"$3\"\n  post_commit_comment\n}\nspelling_info() {\n  if [ -z \"$2\" ]; then\n    out=\"$1\"\n  else\n    out=\"$1\n\n$2\"\n  fi\n  spelling_body \"$out\" \"$3\"\n  if [ -n \"$VERBOSE\" ]; then\n    OUTPUT=\"## @check-spelling-bot Report\n\n$OUTPUT\"\n    post_commit_comment\n  else\n    echo \"$OUTPUT\"\n  fi\n}\nspelling_body() {\n  err=\"$2\"\n  if [ -n \"$OUTPUT\" ]; then\n    header=\"$OUTPUT\n\n\"\n  else\n    header=\"\"\n  fi\n  header=\"# @check-spelling-bot Report\n\n$header\"\n  if [ -z \"$err\" ]; then\n    OUTPUT=\"$header$1\"\n  else\n    if [ -e \"$fewer_misspellings_canary\" ]; then\n      cleanup_text=\" (and remove the previously acknowledged and now absent words)\"\n    fi\n    if [ -n \"$GITHUB_HEAD_REF\" ]; then\n      remote_url_ssh=$(jq -r .pull_request.head.repo.ssh_url < $GITHUB_EVENT_PATH)\n      remote_url_https=$(jq -r .pull_request.head.repo.clone_url < $GITHUB_EVENT_PATH)\n      remote_ref=$GITHUB_HEAD_REF\n    else\n      remote_url_ssh=$(jq -r .repository.ssh_url < $GITHUB_EVENT_PATH)\n      remote_url_https=$(jq -r .repository.clone_url < $GITHUB_EVENT_PATH)\n      remote_ref=$GITHUB_REF\n    fi\n    remote_ref=${remote_ref#refs/heads/}\n    OUTPUT=\"$header$1\n\n\"\n    if [ -s \"$should_exclude_file\" ]; then\n      if [ -n \"$INPUT_CAPTURE_SKIPPED_FILES\" ]; then\n        echo \"::set-output name=skipped_files::$should_exclude_file\"\n      fi\n      OUTPUT=\"$OUTPUT\n<details><summary>Some files were were automatically ignored</summary>\n\nThese sample patterns would exclude them:\n\"'```'\"\n$should_exclude_patterns\n\"'```'\nif [ $(wc -l \"$should_exclude_file\" |perl -pne 's/(\\d+)\\s+.*/$1/') -gt 10 ]; then\n      OUTPUT=\"$OUTPUT\n\"'You should consider excluding directory paths (e.g. `(?:^|/)vendor/`), filenames (e.g. `(?:^|/)yarn\\.lock$`), or file extensions (e.g. `\\.gz$`)\n'\nfi\n      OUTPUT=\"$OUTPUT\n\"'You should consider adding them to:\n```'\"\n$(echo \"$excludes_files\" | xargs -n1 echo)\n\"'```\n\nFile matching is via Perl regular expressions.\n\nTo check these files, more of their words need to be in the dictionary than not. You can use `patterns.txt` to exclude portions, add items to the dictionary (e.g. by adding them to `allow.txt`), or fix typos.\n</details>\n'\n    fi\n    OUTPUT=\"$OUTPUT\n<details><summary>To accept these unrecognized words as correct$cleanup_text,\nrun the following commands</summary>\n\n... in a clone of the [$remote_url_ssh]($remote_url_https) repository\non the \\`$remote_ref\\` branch:\n\"$(relative_note)\"\n\n\"'```'\"\n$err\n\"'```\n</details>\n'\n    if [ -s \"$advice_path\" ]; then\n      OUTPUT=\"$OUTPUT\n\n`cat \"$advice_path\"`\n\"\n    fi\n  fi\n}\nbullet_words_and_warn() {\n  echo \"$1\" > \"$tokens_file\"\n  if [ -n \"$INPUT_CAPTURE_UNKNOWN_WORDS\" ]; then\n    file_with_unknown_words=$(mktemp)\n    cp \"$tokens_file\" $file_with_unknown_words\n    echo \"::set-output name=unknown_words::$file_with_unknown_words\"\n  fi\n  perl -pne 's/^(.)/* $1/' \"$tokens_file\"\n  remove_items\n  rm -f \"$tokens_file\"\n}\n\nquit() {\n  echo \"::remove-matcher owner=check-spelling::\"\n  if [ -n \"$junit\" ]; then\n    exit\n  fi\n  exit $1\n}\n\nbody_to_payload() {\n  BODY=\"$1\"\n  PAYLOAD=$(mktemp)\n  echo '{}' | jq --rawfile body \"$BODY\" '.body = $body' > $PAYLOAD\n  if [ -n \"$DEBUG\" ]; then\n    cat $PAYLOAD >&2\n  fi\n}\n\ncollaborator() {\n  collaborator_url=\"$1\"\n  curl -L -s \\\n    -H \"Authorization: token $GITHUB_TOKEN\" \\\n    -H \"Accept: application/vnd.github.v3+json\" \\\n    \"$collaborator_url\" 2> /dev/null\n}\n\npull_request() {\n  pull_request_url=\"$1\"\n  curl -L -s -S \\\n    -H \"Authorization: token $GITHUB_TOKEN\" \\\n    --header \"Content-Type: application/json\" \\\n    \"$pull_request_url\"\n}\n\nreact() {\n  url=\"$1\"\n  reaction=\"$2\"\n  curl -L -s -S \\\n    -X POST \\\n    -H \"Authorization: token $GITHUB_TOKEN\" \\\n    -H \"Accept: application/vnd.github.squirrel-girl-preview+json\" \\\n    \"$url\"/reactions \\\n    -d '{\"content\":\"'\"$reaction\"'\"}'\n}\n\ncomment() {\n  comments_url=\"$1\"\n  payload=\"$2\"\n  if [ -n \"$payload\" ]; then\n    payload=\"--data @$payload\"\n    method=\"$3\"\n    if [ -n \"$method\" ]; then\n      method=\"-X $method\"\n    fi\n  fi\n  curl -L -s -S \\\n    $method \\\n    -H \"Authorization: token $GITHUB_TOKEN\" \\\n    --header \"Content-Type: application/json\" \\\n    -H 'Accept: application/vnd.github.comfort-fade-preview+json' \\\n    $payload \\\n    \"$comments_url\"\n}\n\nset_comments_url() {\n  event=\"$1\"\n  file=\"$2\"\n  sha=\"$3\"\n  case \"$event\" in\n    issue_comment)\n      COMMENTS_URL=$(cat $file | jq -r .issue.comments_url);;\n    pull_request|pull_request_target|pull_request_review_comment)\n      COMMENTS_URL=$(cat $file | jq -r .pull_request.comments_url);;\n    push|commit_comment)\n      COMMENTS_URL=$(cat $file | jq -r .repository.commits_url | perl -pne 's#\\{/sha}#/'$sha'/comments#');;\n  esac\n}\n\npost_commit_comment() {\n  if [ -n \"$OUTPUT\" ]; then\n    if [ -n \"$INPUT_POST_COMMENT\" ]; then\n      echo \"Preparing a comment for $GITHUB_EVENT_NAME\"\n      set_comments_url \"$GITHUB_EVENT_NAME\" \"$GITHUB_EVENT_PATH\" \"$GITHUB_SHA\"\n      if [ -n \"$COMMENTS_URL\" ] && [ -z \"${COMMENTS_URL##*:*}\" ]; then\n        BODY=$(mktemp)\n        echo \"$OUTPUT\" > $BODY\n        body_to_payload $BODY\n        echo $COMMENTS_URL\n        response=$(mktemp_json)\n\n        res=0\n        comment \"$COMMENTS_URL\" \"$PAYLOAD\" > $response || res=$?\n        if [ $res -gt 0 ]; then\n          if [ -z \"$DEBUG\" ]; then\n            echo \"failed posting to $COMMENTS_URL\"\n            echo \"$PAYLOAD\"\n          fi\n          return $res\n        fi\n\n        if [ -n \"$DEBUG\" ]; then\n          cat $response\n        fi\n        COMMENT_URL=$(jq -r .url < $response)\n        perl -p -i.orig -e 's<COMMENT_URL><'\"$COMMENT_URL\"'>' $BODY\n        if diff -q \"$BODY.orig\" \"$BODY\" > /dev/null; then\n          no_patch=1\n        fi\n        rm \"$BODY.orig\"\n        if offer_quote_reply; then\n          (\n            echo\n            echo \"Alternatively, the bot can do this for you if you reply quoting the following line:\"\n            echo \"@check-spelling-bot apply [changes]($COMMENT_URL).\"\n          )>> $BODY\n          no_patch=\n        fi\n        if [ -z \"$no_patch\" ]; then\n          body_to_payload $BODY\n          comment \"$COMMENT_URL\" \"$PAYLOAD\" \"PATCH\" > $response\n          if [ -n \"$DEBUG\" ]; then\n            cat $response\n          fi\n        fi\n        rm -f $BODY\n      else\n        echo \"$OUTPUT\"\n      fi\n    else\n      echo \"$OUTPUT\"\n    fi\n  fi\n}\n\nstrip_lines() {\n  tr \"\\n\" \" \"\n}\n\nminimize_comment_call() {\n  comment_node=\"$1\"\n  echo \"\n      minimizeComment(\n      input:\n      {\n        subjectId: ${Q}$comment_node${Q},\n        classifier: RESOLVED\n      }\n    ){\n      minimizedComment {\n        isMinimized\n      }\n    }\n\" | strip_lead | strip_lines\n}\n\ncollapse_comment_mutation() {\n  comment_node=\"$1\"\n  query_head=\"mutation {\"\n  query_tail=\"}\"\n  query_body=\"\"\n  i=0\n  while [ -n \"$1\" ]; do\n    query_body=\"$query_body q$i: \"$(minimize_comment_call \"$1\")\n    i=\"$((i+1))\"\n    shift\n  done\n  query=\"$query_head$query_body$query_tail\"\n  echo '{}' | jq --arg query \"$query\" '.query = $query'\n}\n\ncollapse_comment() {\n  curl -s \\\n  -H \"Authorization: token $GITHUB_TOKEN\" \\\n  --header \"Content-Type: application/json\" \\\n  --data-binary \"$(collapse_comment_mutation \"$@\")\" \\\n  $GITHUB_GRAPHQL_URL\n}\n\nexit_if_no_unknown_words() {\n  if [ ! -s \"$run_output\" ]; then\n    quit 0\n  fi\n}\n\ngrep_v_spellchecker() {\n  grep_v_string \"$spellchecker\"\n}\n\ngrep_v_string() {\n  perl -ne \"next if m{$1}; print\"\n}\n\ncompare_new_output() {\n  begin_group 'Compare expect with new output'\n    sorted_expect=\"$temp/expect.sorted.txt\"\n    (sed -e 's/#.*//' \"$expect_path\" | sort_unique) > \"$sorted_expect\"\n    expect_path=\"$sorted_expect\"\n\n    diff_output=$(\n      diff -w -U0 \"$expect_path\" \"$run_output\" |\n      grep_v_spellchecker)\n  end_group\n\n  if [ -z \"$diff_output\" ]; then\n    begin_group 'No misspellings'\n    title=\"No new words with misspellings found\"\n      spelling_info \"$title\" \"There are currently $(wc -l $expect_path|sed -e 's/ .*//') expected items.\" \"\"\n    end_group\n    quit 0\n  fi\n\n  begin_group 'New output'\n    new_output=$(\n      diff -i -w -U0 \"$expect_path\" \"$run_output\" |\n      grep_v_spellchecker |\\\n      perl -n -w -e 'next unless /^\\+/; next if /^\\+{3} /; s/^.//; print;')\n  end_group\n\n  should_exclude_patterns=$(sort \"$should_exclude_file\" | path_to_pattern)\n}\n\ngenerate_curl_instructions() {\n  instructions=$(mktemp)\n  (\n    echo 'update_files() {'\n    (\n      skip_wrapping=1\n      if [ -n \"$patch_remove\" ]; then\n        patch_remove='$patch_remove'\n      fi\n      if [ -n \"$patch_add\" ]; then\n        patch_add='$patch_add'\n      fi\n      if [ -n \"$should_exclude_patterns\" ]; then\n        should_exclude_patterns='$should_exclude_patterns'\n      fi\n      generated=$(generate_instructions)\n      cat $generated\n      rm $generated\n    )\n    echo '}'\n  ) >> $instructions\n  echo '\n    comment_json=$(mktemp)\n    curl -L -s -S \\\n      --header \"Content-Type: application/json\" \\\n      \"COMMENT_URL\" > \"$comment_json\"\n    comment_body=$(mktemp)\n    jq -r .body < \"$comment_json\" > $comment_body\n    rm $comment_json\n    '\"$(patch_variables $Q'$comment_body'$Q)\"'\n    update_files\n    rm $comment_body\n    git add -u\n    ' | sed -e 's/^    //' >> $instructions\n  echo $instructions\n}\n\nskip_curl() {\n  [ -n \"$SKIP_CURL\" ] || repo_is_private\n}\n\nmake_instructions() {\n  patch_remove=$(echo \"$diff_output\" | perl -ne 'next unless s/^-([^-])/$1/; s/\\n/ /; print')\n  patch_add=$(echo \"$diff_output\" | perl -ne 'next unless s/^\\+([^+])/$1/; s/\\n/ /; print')\n  if skip_curl; then\n    instructions=$(generate_instructions)\n    if [ -n \"$patch_add\" ]; then\n      to_publish_expect \"$new_expect_file\" $new_expect_file_new >> $instructions\n    fi\n  else\n    instructions=$(generate_curl_instructions)\n  fi\n  cat $instructions\n  rm $instructions\n}\n\nfewer_misspellings() {\n  if [ -n \"$new_output\" ]; then\n    return\n  fi\n\n  begin_group 'Fewer misspellings'\n  title='There are now fewer misspellings than before'\n  SKIP_CURL=1\n  instructions=$(\n    make_instructions\n  )\n  if [ -n \"$INPUT_EXPERIMENTAL_COMMIT_NOTE\" ]; then\n    . \"$spellchecker/update-state.sh\"\n    skip_push_and_pop=1\n\n    instructions_head=$(mktemp)\n    (\n      patch_add=1\n      patch_remove=1\n      patch_variables $comment_body > $instructions_head\n    )\n    . $instructions_head\n    rm $instructions_head\n    instructions=$(generate_instructions)\n\n    . $instructions &&\n    git_commit \"$INPUT_EXPERIMENTAL_COMMIT_NOTE\" &&\n    git push origin ${GITHUB_HEAD_REF:-$GITHUB_REF}\n    spelling_info \"$title\" \"\" \"Applied\"\n  else\n    spelling_info \"$title\" \"\" \"$instructions\"\n  fi\n  end_group\n  quit\n}\nmore_misspellings() {\n  begin_group 'Unrecognized'\n  title='Unrecognized words, please review'\n  instructions=$(\n    make_instructions\n  )\n  spelling_warning \"$title\" \"$(bullet_words_and_warn \"$new_output\")\" \"$instructions\"\n  end_group\n  quit 1\n}\n\ndefine_variables\nset_up_tools\nset_up_files\n. \"$spellchecker/update-state.sh\"\nmain\nwelcome\nrun_spell_check\nexit_if_no_unknown_words\ncompare_new_output\nfewer_misspellings_canary=$(mktemp)\nfewer_misspellings\nmore_misspellings\n"], "fixing_code": ["#!/bin/bash\nif [ \"$INITIALIZED\" != defined ]; then\n  if [ \"$RUNNER_OS\" = \"Windows\" ]; then\n    echo \"::error ::Windows isn't currently supported\"\n    exit 5\n  fi\n\n  now() {\n    date +'%s%N'\n  }\n  start=$(now)\n  temp=\"${temp:-/tmp/spelling}\"\n  mkdir -p $temp\n  export temp\n  if [ -n \"$DEBUG\" ]; then\n    set -x\n    begin_group() {\n      echo \"::group::$1\"\n    }\n    end_group() {\n      echo '::end_group::'\n    }\n  else\n    begin_group() {\n      echo \"(...$1...)\"\n    }\n    end_group() {\n      :\n    }\n    INITIALIZED=defined\n  fi\nfi\n", "#!/bin/sh\n#! -*-perl-*-\neval 'exec perl -x -T -w $0 ${1+\"$@\"}'\n  if 0;\n# ~/bin/w\n# Search for potentially misspelled words\n# Output is:\n# misspellled\n# woord (WOORD, Woord, woord, woord's)\n\nuse File::Basename;\nuse Cwd 'abs_path';\nuse File::Temp qw/ tempfile tempdir /;\n\nmy $dirname = dirname(abs_path(__FILE__));\n\n# skip files that don't exist (including dangling symlinks)\nif (scalar @ARGV) {\n  @ARGV = grep {! -l && -f && -r} @ARGV;\n  unless (scalar @ARGV) {\n    print STDERR \"::warning ::Was not provided any regular readable files\\n\";\n    exit 0;\n  }\n}\n\nmy $patterns_re = '^$';\nif (open(PATTERNS, '<', \"$dirname/patterns.txt\")) {\n  my @patterns;\n  local $/=undef;\n  local $file=<PATTERNS>;\n  close PATTERNS;\n  for (split /\\R/, $file) {\n    next if /^#/;\n    chomp;\n    next unless s/^(.+)/(?:$1)/;\n    push @patterns, $_;\n  }\n  $patterns_re = join \"|\", @patterns if scalar @patterns;\n}\n\nmy $longest_word = get_val_from_env('INPUT_LONGEST_WORD', '');\nmy $shortest_word = get_val_from_env('INPUT_SHORTEST_WORD', '');\n\nmy ($shortest, $longest) = (undef, undef);\nsub valid_word {\n  # shortest_word is an absolute\n  $shortest = $shortest_word if $shortest_word;\n  if ($longest_word) {\n    # longest_word is an absolute\n    $longest = $longest_word;\n  } elsif (defined $longest) {\n    # we allow for some sloppiness (a couple of stuck keys per word)\n    # it's possible that this should scale with word length\n    $longest += 2;\n  }\n  return /.../ if (defined $shortest && defined $longest) && ($shortest > $longest);\n  $shortest = 3 unless defined $shortest;\n  $longest = '' unless defined $longest;\n  $word_match = \".{$shortest,$longest}\";\n  return qr/\\b$word_match\\b/;\n}\n\nmy $word_match = valid_word();\n($shortest, $longest) = (255, 0);\n# load dictionary\nmy $dict = \"$dirname/words\";\n$dict = '/usr/share/dict/words' unless -e $dict;\nopen(DICT, '<', $dict);\nmy %dictionary=();\nwhile ($word = <DICT>) {\n  chomp $word;\n  next unless $word =~ $word_match;\n  my $l = length $word;\n  $longest = $l if $l > $longest;\n  $shortest = $l if $l < $shortest;\n  $dictionary{$word}=1;\n}\nclose DICT;\n\nsub get_val_from_env {\n  my ($var, $fallback) = @_;\n  return $fallback unless defined $ENV{$var};\n  $ENV{$var} =~ /^(\\d+)$/;\n  return $1 || $fallback;\n}\n\n$word_match = valid_word();\n\n# read all input\nmy ($last_file, $temp_dir, $words, $unrecognized) = ('', '', 0, 0);\nmy %unique;\nmy %unique_unrecognized;\nmy @reports;\n\nsub report_stats() {\n  if ($unrecognized) {\n    open(STATS, '>', \"$temp_dir/stats\");\n      print STATS \"{words: $words, unrecognized: $unrecognized, unknown: \".(keys %unique_unrecognized).\", unique: \".(keys %unique).\"}\";\n    close STATS;\n    open(UNKNOWN, '>', \"$temp_dir/unknown\");\n      print UNKNOWN join \"\\n\", sort keys %unique_unrecognized;\n    close UNKNOWN;\n    close WARNINGS;\n  }\n}\n\nwhile (<<>>) {\n  if ($last_file ne $ARGV) {\n    $. = 1;\n    $last_file = $ARGV;\n    report_stats();\n\n    $temp_dir = tempdir();\n    push @reports, \"$temp_dir\\n\";\n    open(NAME, '>', \"$temp_dir/name\");\n      print NAME $last_file;\n    close NAME;\n    ($words, $unrecognized) = (0, 0);\n    %unique = ();\n    %unique_unrecognized = ();\n    open(WARNINGS, '>', \"$temp_dir/warnings\");\n  }\n  next unless /./;\n  my $raw_line = $_;\n  # hook for custom line based text exclusions:\n  s/$patterns_re/ /g;\n  # This is to make it easier to deal w/ rules:\n  s/^/ /;\n  while (s/([^\\\\])\\\\[rtn]/$1 /g) {}\n  # https://www.fileformat.info/info/unicode/char/2019/\n  my $rsqm = \"\\xE2\\x80\\x99\";\n  s/$rsqm|&apos;|&#39;/'/g;\n  s/[^a-zA-Z']+/ /g;\n  while (s/([A-Z]{2,})([A-Z][a-z]{2,})/ $1 $2 /g) {}\n  while (s/([a-z']+)([A-Z])/$1 $2/g) {}\n  my %unrecognized_line_items = ();\n  for my $token (split /\\s+/, $_) {\n    $token =~ s/^(?:'|$rsqm)+//g;\n    $token =~ s/(?:'|$rsqm)+s?$//g;\n    my $raw_token = $token;\n    $token =~ s/^[^Ii]?'+(.*)/$1/;\n    $token =~ s/(.*?)'+$/$1/;\n    next unless $token =~ $word_match;\n    if (defined $dictionary{$token}) {\n      ++$words;\n      $unique{$token}=1;\n      next;\n    }\n    my $key = lc $token;\n    $key =~ s/''+/'/g;\n    $key =~ s/'[sd]$//;\n    if (defined $dictionary{$key}) {\n      ++$words;\n      $unique{$key}=1;\n      next;\n    }\n    ++$unrecognized;\n    $unique_unrecognized{$raw_token}=1;\n    $unrecognized_line_items{$raw_token}=1;\n  }\n  for my $token (keys %unrecognized_line_items) {\n    $token =~ s/'/(?:'|$rsqm)+/g;\n    while ($raw_line =~ /\\b($token)\\b/g) {\n      my ($begin, $end, $match) = ($-[0] + 1, $+[0] + 1, $1);\n      next unless $match =~ /./;\n      print WARNINGS \"line $. cols $begin-$end: '$match'\\n\";\n    }\n  }\n}\nreport_stats();\nprint join '', @reports;\n", "#!/bin/bash\n# This CI acceptance test is based on:\n# https://github.com/jsoref/spelling/tree/04648bdc63723e5cdf5cbeaff2225a462807abc8\n# It is conceptually `f` which runs `w` (spelling-unknown-word-splitter)\n# plus `fchurn` which uses `dn` mostly rolled together.\nset -e\nexport spellchecker=${spellchecker:-/app}\n. \"$spellchecker/common.sh\"\n\nmain() {\n  GITHUB_TOKEN=${GITHUB_TOKEN:-$INPUT_GITHUB_TOKEN}\n  if [ -z \"$GITHUB_EVENT_PATH\" ] || [ ! -e \"$GITHUB_EVENT_PATH\" ]; then\n    GITHUB_EVENT_PATH=/dev/null\n  fi\n  case \"$GITHUB_EVENT_NAME\" in\n    schedule)\n      exec \"$spellchecker/check-pull-requests.sh\"\n      ;;\n    issue_comment)\n      if [ -n \"$DEBUG\" ]; then\n        set -x\n      fi\n      handle_comment\n      ;;\n    pull_request_review_comment)\n      (\n        echo 'check-spelling does not currently support comments on code.'\n        echo 'If you are trying to ask @check-spelling-bot to update a PR,'\n        echo 'please quote the comment link as a top level comment instead'\n        echo 'of in a comment on a block of code.'\n        echo\n        echo 'Future versions may support this feature.'\n        echo 'For the time being, early adopters should remove the'\n        echo '`pull_request_review_comment` event from their workflow.'\n        echo 'workflow.'\n       ) >&2\n      exit 0\n      ;;\n  esac\n}\n\noffer_quote_reply() {\n  case \"$INPUT_EXPERIMENTAL_APPLY_CHANGES_VIA_BOT\" in\n    1|true|TRUE)\n      case \"$GITHUB_EVENT_NAME\" in\n        issue_comment|pull_request|pull_request_target)\n          true;;\n        *)\n          false;;\n        esac\n      ;;\n    *)\n      false\n      ;;\n  esac\n}\n\nrepo_is_private() {\n  private=$(jq -r .repository.private < \"$GITHUB_EVENT_PATH\")\n  [ \"$private\" = \"true\" ]\n}\n\ncommand_v() {\n  command -v \"$1\" >/dev/null 2>/dev/null\n}\n\nreact_comment_and_die() {\n  trigger_comment_url=\"$1\"\n  message=\"$2\"\n  react=\"$3\"\n  echo \"::error ::$message\"\n  react \"$trigger_comment_url\" \"$react\" > /dev/null\n  if [ -n \"$COMMENTS_URL\" ] && [ -z \"${COMMENTS_URL##*:*}\" ]; then\n    PAYLOAD=$(mktemp_json)\n    echo '{}' | jq --arg body \"@check-spelling-bot: $react_prefix $message\" '.body = $body' > $PAYLOAD\n\n    res=0\n    comment \"$COMMENTS_URL\" \"$PAYLOAD\" > /dev/null || res=$?\n    if [ $res -gt 0 ]; then\n      if [ -z \"$DEBUG\" ]; then\n        echo \"failed posting to $COMMENTS_URL\"\n        echo \"$PAYLOAD\"\n      fi\n      return $res\n    fi\n\n    rm $PAYLOAD\n  fi\n  exit 1\n}\n\nconfused_comment() {\n  react_comment_and_die \"$1\" \"$2\" \"confused\"\n}\n\ngithub_user_and_email() {\n  user_json=$(mktemp_json)\n  curl -s \\\n    -H \"Authorization: token $GITHUB_TOKEN\" \\\n    \"$GITHUB_API_URL/users/$1\" > $user_json\n\n  github_name=$(jq -r '.name // empty' < $user_json)\n  if [ -z \"$github_name\" ]; then\n    github_name=$1\n  fi\n  github_email=$(jq -r '.email // empty' < $user_json)\n  rm $user_json\n  if [ -z \"$github_email\" ]; then\n    github_email=\"$1@users.noreply.github.com\"\n  fi\n  COMMIT_AUTHOR=\"--author=$github_name <$github_email>\"\n}\n\ngit_commit() {\n  reason=\"$1\"\n  git add -u\n  git config user.email \"check-spelling-bot@users.noreply.github.com\"\n  git config user.name \"check-spelling-bot\"\n  git commit \\\n    \"$COMMIT_AUTHOR\" \\\n    --date=\"$created_at\" \\\n    -m \"$(echo \"[check-spelling] Applying automated metadata updates\n\n                $reason\n\n                Signed-off-by: check-spelling-bot <check-spelling-bot@users.noreply.github.com>\n                \" | strip_lead)\"\n}\n\nmktemp_json() {\n  file=$(mktemp)\n  mv \"$file\" \"$file.json\"\n  echo \"$file.json\"\n}\n\nhandle_comment() {\n  if ! offer_quote_reply; then\n    exit 0\n  fi\n\n  action=$(jq -r .action < \"$GITHUB_EVENT_PATH\")\n  if [ \"$action\" != \"created\" ]; then\n    exit 0\n  fi\n\n  comment=$(mktemp_json)\n  jq -r .comment < \"$GITHUB_EVENT_PATH\" > $comment\n  body=$(mktemp)\n  jq -r .body $comment > $body\n\n  trigger=$(perl -ne 'print if /\\@check-spelling-bot(?:\\s+|:\\s*)apply/' < $body)\n  rm $body\n  if [ -z \"$trigger\" ]; then\n    exit 0\n  fi\n\n  trigger_comment_url=$(jq -r .url < $comment)\n  sender_login=$(jq -r .sender.login < \"$GITHUB_EVENT_PATH\")\n  issue_user_login=$(jq -r .issue.user.login < \"$GITHUB_EVENT_PATH\")\n  issue=$(mktemp_json)\n  jq -r .issue < \"$GITHUB_EVENT_PATH\" > $issue\n  pull_request_url=$(jq -r .pull_request.url < $issue)\n  pull_request_info=$(mktemp_json)\n  pull_request \"$pull_request_url\" | jq .head > $pull_request_info\n  pull_request_sha=$(jq -r .sha < $pull_request_info)\n  set_comments_url \"$GITHUB_EVENT_NAME\" \"$GITHUB_EVENT_PATH\" \"$pull_request_sha\"\n  react_prefix_base=\"Could not perform [request]($trigger_comment_url).\"\n  react_prefix=\"$react_prefix_base\"\n  if [ \"$sender_login\" != \"$issue_user_login\" ]; then\n    collaborators_url=$(jq -r .repository.collaborators_url < \"$GITHUB_EVENT_PATH\")\n    collaborators_url=$(echo \"$collaborators_url\" | perl -pne \"s<\\{/collaborator\\}></$sender_login/permission>\")\n    collaborator_permission=$(collaborator \"$collaborators_url\" | jq -r .permission)\n    case $collaborator_permission in\n      admin)\n        ;;\n      write)\n        ;;\n      *)\n        confused_comment \"$trigger_comment_url\" \"Commenter (@$sender_login) isn't author (@$issue_user_login) / collaborator\"\n        ;;\n    esac\n  fi\n  number=$(jq -r .number < $issue)\n  created_at=$(jq -r .created_at < $comment)\n  issue_url=$(jq -r .url < $issue)\n  pull_request_ref=$(jq -r .ref < $pull_request_info)\n  pull_request_repo=$(jq -r .repo.clone_url < $pull_request_info)\n  git remote add request $pull_request_repo\n  git fetch request \"$pull_request_sha\"\n  git config advice.detachedHead false\n  git reset --hard\n  git checkout \"$pull_request_sha\"\n\n  number_filter() {\n    perl -pne 's/\\{.*\\}//'\n  }\n  comments_base=$(jq -r .repository.comments_url < \"$GITHUB_EVENT_PATH\" | number_filter)\n  issue_comments_base=$(jq -r .repository.issue_comment_url < \"$GITHUB_EVENT_PATH\" | number_filter)\n  export comments_url=\"$comments_base|$issue_comments_base\"\n  comment_url=$(echo \"$trigger\" | perl -ne 'next unless m{((?:$ENV{comments_url})/\\d+)}; print \"$1\\n\";')\n  [ -n \"$comment_url\" ] ||\n    confused_comment \"$trigger_comment_url\" \"Did not find $comments_url in comment\"\n\n  res=0\n  comment \"$comment_url\" > $comment || res=$?\n  if [ $res -gt 0 ]; then\n    if [ -z \"$DEBUG\" ]; then\n      echo \"failed to retrieve $comment_url\"\n    fi\n    return $res\n  fi\n\n  comment_body=$(mktemp)\n  jq -r .body < $comment > $comment_body\n  bot_comment_author=$(jq -r .user.login < $comment)\n  bot_comment_node_id=$(jq -r .node_id < $comment)\n  bot_comment_url=$(jq -r '.issue_url // .comment.url' < $comment)\n  rm $comment\n  github_actions_bot=\"github-actions[bot]\"\n  [ \"$bot_comment_author\" = \"$github_actions_bot\" ] ||\n    confused_comment \"$trigger_comment_url\" \"Expected @$github_actions_bot to be author of $comment_url (found @$bot_comment_author)\"\n  [ \"$issue_url\" = \"$bot_comment_url\" ] ||\n    confused_comment \"$trigger_comment_url\" \"Referenced comment was for a different object: $bot_comment_url\"\n  capture_items() {\n    perl -ne 'next unless s{^\\s*my \\@'$1'=qw\\('$q$Q'(.*)'$Q$q'\\);$}{$1}; print'\n  }\n  capture_item() {\n    perl -ne 'next unless s{^\\s*my \\$'$1'=\"(.*)\";$}{$1}; print'\n  }\n  skip_wrapping=1\n\n  instructions_head=$(mktemp)\n  (\n    patch_add=1\n    patch_remove=1\n    should_exclude_patterns=1\n    patch_variables $comment_body > $instructions_head\n  )\n  git restore $bucket/$project\n\n  res=0\n  . $instructions_head || res=$?\n  if [ $res -gt 0 ]; then\n    echo \"instructions_head failed ($res)\"\n    cat $instructions_head\n    return $res\n  fi\n  rm $comment_body $instructions_head\n  instructions=$(generate_instructions)\n\n  react_prefix=\"$react_prefix [Instructions]($comment_url)\"\n  . $instructions || res=$?\n  if [ $res -gt 0 ]; then\n    echo \"instructions failed ($res)\"\n    cat $instructions\n    res=0\n    confused_comment \"$trigger_comment_url\" \"failed to apply\"\n  fi\n  rm $instructions\n  git status --u=no --porcelain | grep -q . ||\n    confused_comment \"$trigger_comment_url\" \"didn't change repository\"\n  react_prefix=\"$react_prefix_base\"\n  github_user_and_email $sender_login\n  git_commit \"$(echo \"Update per $comment_url\n                      Accepted in $trigger_comment_url\n                    \"|strip_lead)\" ||\n    confused_comment \"$trigger_comment_url\" \"Failed to generate commit\"\n  git push request \"HEAD:$pull_request_ref\" ||\n    confused_comment \"$trigger_comment_url\" \"Failed to push to $pull_request_repo\"\n\n  react \"$trigger_comment_url\" 'eyes' > /dev/null\n  react \"$comment_url\" 'rocket' > /dev/null\n  trigger_node=$(jq -r .comment.node_id < \"$GITHUB_EVENT_PATH\")\n  collapse_comment $trigger_node $bot_comment_node_id\n\n  echo \"# end\"\n  exit 0\n}\n\ndefine_variables() {\n  bucket=${INPUT_BUCKET:-$bucket}\n  project=${INPUT_PROJECT:-$project}\n  if [ -z \"$bucket\" ] && [ -z \"$project\" ] && [ -n \"$INPUT_CONFIG\" ]; then\n    bucket=${INPUT_CONFIG%/*}\n    project=${INPUT_CONFIG##*/}\n  fi\n  job_count=${INPUT_EXPERIMENTAL_PARALLEL_JOBS:-2}\n  if ! [ \"$job_count\" -eq \"$job_count\" ] 2>/dev/null || [ \"$job_count\" -lt 2 ]; then\n    job_count=1\n  fi\n\n  dict=\"$spellchecker/words\"\n  patterns=\"$spellchecker/patterns.txt\"\n  excludes=\"$spellchecker/excludes.txt\"\n  excludes_path=\"$temp/excludes.txt\"\n  only=\"$spellchecker/only.txt\"\n  only_path=\"$temp/only.txt\"\n  dictionary_path=\"$temp/dictionary.txt\"\n  allow_path=\"$temp/allow.txt\"\n  reject_path=\"$temp/reject.txt\"\n  expect_path=\"$temp/expect.words.txt\"\n  excludelist_path=\"$temp/excludes.txt\"\n  patterns_path=\"$temp/patterns.txt\"\n  advice_path=\"$temp/advice.md\"\n  advice_path_txt=\"$temp/advice.txt\"\n  word_splitter=\"$spellchecker/spelling-unknown-word-splitter.pl\"\n  word_collator=\"$spellchecker/spelling-collator.pl\"\n  run_output=\"$temp/unknown.words.txt\"\n  run_files=\"$temp/reporter-input.txt\"\n  tokens_file=\"$temp/tokens.txt\"\n}\n\nsort_unique() {\n  sort -u -f \"$@\" | perl -ne 'next unless /./; print'\n}\n\nproject_file_path() {\n  ext=$(echo \"$2\" | sed -e 's/^.*\\.//')\n  echo $bucket/$project/$1.${ext:-txt}\n}\n\ncheck_pattern_file() {\n  perl -i -e 'while (<>) {\n    next if /^#/;\n    next unless /./;\n    if (eval {qr/$_/}) {\n      print;\n    } else {\n      $@ =~ s/(.*?)\\n.*/$1/m;\n      chomp $@;\n      my $err = $@;\n      $err =~ s{^.*? in regex; marked by <-- HERE in m/(.*) <-- HERE.*$}{$1};\n      print STDERR \"$ARGV: line $., columns $-[0]-$-[0], Warning - bad regex (bad-regex)\\n$@\\n\";\n      print \"^\\$\\n\";\n    }\n  }' $1\n}\n\ncheck_for_newline_at_eof() {\n  maybe_missing_eol=\"$1\"\n  if [ -s \"$maybe_missing_eol\" ] && [ $(tail -1 \"$maybe_missing_eol\" | wc -l) -eq 0 ]; then\n    line=$(( $(cat \"$maybe_missing_eol\" | wc -l) + 1 ))\n    start=$(tail -1 \"$maybe_missing_eol\" | wc -c)\n    stop=$(( $start + 1 ))\n    echo \"$maybe_missing_eol: line $line, columns $start-$stop, Warning - no newline at eof (no-newline-at-eof)\" >&2\n    echo >> \"$maybe_missing_eol\"\n  fi\n}\n\ncheck_dictionary() {\n  file=\"$1\"\n  expected_chars=\"[a-zA-Z']\"\n  unexpected_chars=\"[^a-zA-Z']\"\n  (perl -pi -e '\n  chomp;\n  my $messy = 0;\n  my $orig = $_;\n  if (s/\\n|\\r|\\x0b|\\f|\\x85|\\x2028|\\x2029/a/g) {\n    $messy = 1;\n  }\n  if ('\"/^${expected_chars}*(${unexpected_chars}+)/\"') {\n    print STDERR \"$ARGV: line $., columns $-[1]-$+[1], Warning - ignoring entry because it contains non alpha characters (non-alpha-in-dictionary)\\n\";\n    $_ = \"\";\n  } else {\n    if ($messy) {\n      $_ = $orig;\n      s/\\R//;\n      print STDERR \"$ARGV: line $., columns $-[0]-$+[0], Warning - entry has unexpected whitespace (whitespace-in-dictionary)\\n\";\n    }\n    $_ .= \"\\n\";\n  }\n' \"$file\") 2>&1\n}\n\ncleanup_file() {\n  export maybe_bad=\"$1\"\n\n  result=0\n  perl -e '\n    use Cwd qw(abs_path);\n    my $maybe_bad=abs_path($ENV{maybe_bad});\n    my $workspace_path=abs_path($ENV{GITHUB_WORKSPACE});\n    if ($maybe_bad !~ /^\\Q$workspace_path\\E/) {\n      print \"::error ::Configuration files must live within $workspace_path...\\n\";\n      print \"::error ::Unfortunately, file $maybe_bad appears to reside elsewhere.\\n\";\n      exit 3;\n    }\n    if ($maybe_bad =~ m{/\\.git/}i) {\n      print \"::error ::Configuration files must not live within `.git/`...\\n\";\n      print \"::error ::Unfortunately, file $maybe_bad appears to.\\n\";\n      exit 4;\n    }\n  ' || result=$?\n  if [ $result -gt 0 ]; then\n    quit $result\n  fi\n\n  type=\"$2\"\n  case \"$type\" in\n    patterns|excludes|only)\n      check_pattern_file \"$maybe_bad\"\n    ;;\n    dictionary|expect|allow)\n      check_dictionary \"$maybe_bad\"\n    ;;\n    # reject isn't checked, it allows for regular expressions\n  esac\n  check_for_newline_at_eof \"$maybe_bad\"\n}\n\nget_project_files() {\n  file=$1\n  dest=$2\n  type=$1\n  if [ ! -e \"$dest\" ] && [ -n \"$bucket\" ] && [ -n \"$project\" ]; then\n    from=$(project_file_path $file $dest)\n    case \"$from\" in\n      .*)\n        append_to=\"$from\"\n        append_to_generated=\"\"\n        if [ -f \"$from\" ]; then\n          echo \"Retrieving $file from $from\"\n          cleanup_file \"$from\" \"$type\"\n          cp \"$from\" $dest\n          from_expanded=\"$from\"\n        else\n          if [ ! -e \"$from\" ]; then\n            ext=$(echo \"$from\" | sed -e 's/^.*\\.//')\n            from=$(echo $from | sed -e \"s/\\.$ext$//\")\n          fi\n          if [ -d \"$from\" ]; then\n            from_expanded=$(ls $from/*$ext |sort)\n            append_to=$from/${GITHUB_SHA:-$(date +%Y%M%d%H%m%S)}.$ext\n            append_to_generated=new\n            touch $dest\n            echo \"Retrieving $file from $from_expanded\"\n            for item in $from_expanded; do\n              if [ -s $item ]; then\n                cleanup_file \"$item\" \"$type\"\n                cat \"$item\" >> $dest\n              fi\n            done\n            from=\"$from/$(basename \"$from\")\".$ext\n          fi\n        fi;;\n      ssh://git@*|git@*)\n        (\n          echo \"Retrieving $file from $from\"\n          cd $temp\n          repo=$(echo \"$bucket\" | perl -pne 's#(?:ssh://|)git\\@github.com[:/]([^/]*)/(.*.git)#https://github.com/$1/$2#')\n          [ -d metadata ] || git clone --depth 1 $repo --single-branch --branch $project metadata\n          cleanup_file \"metadata/$file.txt\" \"$type\"\n          cp metadata/$file.txt $dest 2> /dev/null || touch $dest\n        );;\n      gs://*)\n        echo \"Retrieving $file from $from\"\n        gsutil cp -Z $from $dest >/dev/null 2>/dev/null || touch $dest\n        cleanup_file \"$dest\" \"$type\"\n        ;;\n      *://*)\n        echo \"Retrieving $file from $from\"\n        download \"$from\" \"$dest\" || touch $dest\n        cleanup_file \"$dest\" \"$type\"\n        ;;\n    esac\n  fi\n}\nget_project_files_deprecated() {\n  # \"preferred\" \"deprecated\" \"path\"\n  if [ ! -s \"$3\" ]; then\n    save_append_to=\"$append_to\"\n    get_project_files \"$2\" \"$3\"\n    if [ -s \"$3\" ]; then\n      example=$(for file in $from_expanded; do echo $file; done|head -1)\n      if [ $(basename $(dirname $example)) = \"$2\" ]; then\n        note=\" directory\"\n      else\n        note=\"\"\n      fi\n      echo \"::warning file=$example::deprecation: please rename '$2'$note to '$1'\"\n    else\n      append_to=\"$save_append_to\"\n    fi\n  fi\n}\n\ndownload() {\n  curl -L -s \"$1\" -o \"$2\" -f\n  exit_value=$?\n  if [ $exit_value = 0 ]; then\n    echo \"Downloaded $1 (to $2)\" >&2\n  fi\n  return $exit_value\n}\n\ndownload_or_quit_with_error() {\n  exit_code=$(mktemp)\n  download \"$1\" \"$2\" || (\n    echo $? > $exit_code\n    echo \"Could not download $1 (to $2)\" >&2\n  )\n  if [ -s $exit_code ]; then\n    exit_value=$(cat $exit_code)\n    rm $exit_code\n    quit $exit_value\n  fi\n}\n\nset_up_tools() {\n  apps=\"\"\n  add_app() {\n    if ! command_v $1; then\n      apps=\"$apps $@\"\n    fi\n  }\n  add_app curl ca-certificates\n  add_app git\n  add_app parallel\n  if [ -n \"$apps\" ]; then\n    if command_v apt-get; then\n      export DEBIAN_FRONTEND=noninteractive\n      apt-get -qq update &&\n      apt-get -qq install --no-install-recommends -y $apps >/dev/null 2>/dev/null\n      echo Installed: $apps >&2\n    elif command_v brew; then\n      brew install $apps\n    else\n      echo missing $apps -- things will fail >&2\n    fi\n  fi\n  set_up_jq\n}\n\nset_up_jq() {\n  if ! command_v jq || jq --version | perl -ne 'exit 0 unless s/^jq-//;exit 1 if /^(?:[2-9]|1\\d|1\\.(?:[6-9]|1\\d+))/; exit 0'; then\n    jq_url=https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64\n    spellchecker_bin=\"$spellchecker/bin\"\n    jq_bin=\"$spellchecker_bin/jq\"\n    mkdir -p $spellchecker_bin\n    download_or_quit_with_error \"$jq_url\" \"$jq_bin\"\n    chmod 0755 \"$jq_bin\"\n    PATH=$spellchecker_bin:$PATH\n  fi\n}\n\nset_up_files() {\n  mkdir -p .git\n  cp $spellchecker/reporter.json .git/\n  echo \"::add-matcher::.git/reporter.json\"\n  get_project_files expect $expect_path\n  get_project_files_deprecated expect whitelist $expect_path\n  expect_files=$from_expanded\n  expect_file=$from\n  touch $expect_path\n  new_expect_file=$append_to\n  new_expect_file_new=$append_to_generated\n  get_project_files excludes $excludelist_path\n  excludes_files=$from_expanded\n  excludes_file=$from\n  if [ -s \"$excludes_path\" ]; then\n    cp \"$excludes_path\" \"$excludes\"\n  fi\n  should_exclude_file=$(mktemp)\n  get_project_files dictionary $dictionary_path\n  if [ -s \"$dictionary_path\" ]; then\n    cp \"$dictionary_path\" \"$dict\"\n  fi\n  if [ ! -s \"$dict\" ]; then\n    DICTIONARY_VERSION=${DICTIONARY_VERSION:-$INPUT_DICTIONARY_VERSION}\n    DICTIONARY_URL=${DICTIONARY_URL:-$INPUT_DICTIONARY_URL}\n    eval download_or_quit_with_error \"$DICTIONARY_URL\" \"$dict\"\n  fi\n  get_project_files allow $allow_path\n  if [ -s \"$allow_path\" ]; then\n    cat \"$allow_path\" >> \"$dict\"\n  fi\n  get_project_files reject $reject_path\n  if [ -s \"$reject_path\" ]; then\n    dictionary_temp=$(mktemp)\n    if grep_v_string '^('$(echo $(cat \"$reject_path\")|tr \" \" '|')')$' < \"$dict\" > $dictionary_temp; then\n      cat $dictionary_temp > \"$dict\"\n    fi\n  fi\n  get_project_files only $only_path\n  if [ -s \"$only_path\" ]; then\n    cp \"$only_path\" \"$only\"\n  fi\n  get_project_files patterns $patterns_path\n  if [ -s \"$patterns_path\" ]; then\n    cp \"$patterns_path\" \"$patterns\"\n  fi\n  get_project_files advice $advice_path\n  if [ ! -s \"$advice_path\" ]; then\n    get_project_files advice $advice_path_txt\n    if [ -s \"$advice_path\" ]; then\n      cp \"$advice_path_txt\" \"$advice_path\"\n    fi\n  fi\n\n  if [ -n \"$debug\" ]; then\n    echo \"Clean up from previous run\"\n  fi\n  rm -f \"$run_output\"\n}\n\nwelcome() {\n  echo \"Checking spelling...\"\n  if [ -n \"$DEBUG\" ]; then\n    begin_group 'Excluded paths'\n    if [ -e \"$excludes\" ]; then\n      echo 'Excluded paths:'\n      cat \"$excludes\"\n    else\n      echo 'No excluded paths file'\n    fi\n    end_group\n    begin_group 'Only paths restriction'\n    if [ -e \"$only\" ]; then\n      echo 'Only paths restriction:'\n      cat \"$only\"\n    else\n      echo 'No only paths restriction file'\n    fi\n    end_group\n  fi\n  if [ -n \"$INPUT_PATH\" ]; then\n    cd \"$INPUT_PATH\"\n  fi\n}\n\nxargs_zero() {\n  if command_v parallel; then\n    parallel --no-notice --no-run-if-empty -0 -n1 \"$@\"\n  elif [ $(uname) = \"Linux\" ]; then\n    xargs --no-run-if-empty -0 -n1 \"$@\"\n  else\n    arguments=\"$*\" \"$spellchecker/xargs_zero\"\n  fi\n}\n\nrun_spell_check() {\n  begin_group 'Spell check files'\n  file_list=$(mktemp)\n    git 'ls-files' -z 2> /dev/null |\\\n    \"$spellchecker/exclude.pl\" > $file_list\n  perl -e '$/=\"\\0\"; $count=0; while (<>) {s/\\R//; $count++ if /./;}; print \"Checking $count files\\n\";' $file_list\n  end_group\n\n  begin_group 'Spell check'\n  warning_output=$(mktemp)\n  more_warnings=$(mktemp)\n  (\n    # Technically $should_exclude_file is an append race under parallel\n    # since the file isn't critical -- it's advisory, I'm going to wait\n    # on reports before fixing it.\n    # The fix is to have a directory and have each process append to a\n    # file named for its pid inside that directory, and then have the\n    # caller can collate...\n    cat $file_list) |\\\n  parallel -0 -n8 \"-j$job_count\" \"$word_splitter\" |\\\n  expect=\"$expect_path\" warning_output=\"$warning_output\" more_warnings=\"$more_warnings\" should_exclude_file=\"$should_exclude_file\" \"$word_collator\" |\\\n  perl -p -n -e 's/ \\(.*//' > \"$run_output\"\n  word_splitter_status=\"${PIPESTATUS[2]} ${PIPESTATUS[3]}\"\n  cat \"$warning_output\" \"$more_warnings\"\n  rm \"$warning_output\" \"$more_warnings\"\n  end_group\n  if [ \"$word_splitter_status\" != '0 0' ]; then\n    echo \"$word_splitter failed ($word_splitter_status)\"\n    exit 2\n  fi\n  rm $file_list\n}\n\nprintDetails() {\n  echo ''\n  echo 'If you are ok with the output of this run, you will need to'\n}\n\nrelative_note() {\n  if [ -n \"$bucket\" ] && [ -n \"$project\" ]; then\n    from=$(project_file_path $file)\n    case \"$from\" in\n      .*)\n        ;;\n      ssh://git@*|git@*|gs://|*://*)\n        echo '(They can be run anywhere with permissions to update the bucket.)';;\n    esac\n  fi\n}\nto_retrieve_expect() {\n  expect_file=expect.txt\n  case \"$bucket\" in\n    '')\n      echo '# no bucket defined -- you can specify one per the README.md using the file defined below:';;\n    ssh://git@*|git@*)\n      echo \"git clone --depth 1 $bucket --single-branch --branch $project metadata; cp metadata/expect.txt .\";;\n    gs://*)\n      echo gsutil cp -Z $(project_file_path expect) expect.txt;;\n    *://*)\n      echo curl -L -s \"$(project_file_path expect)\" -o expect.txt;;\n  esac\n}\nto_publish_expect() {\n  case \"$bucket\" in\n    '')\n      echo \"# no bucket defined -- copy $1 to a bucket and configure it per the README.md\";;\n    ssh://git@*|git@*)\n      echo \"cp $1 metadata/expect.txt; (cd metadata; git commit expect.txt -m 'Updating expect'; git push)\";;\n    gs://*)\n      echo gsutil cp -Z $1 $(project_file_path expect);;\n    *://*)\n      echo \"# command to publish $1 is not known. URL: $(project_file_path expect)\";;\n    *)\n      if [ \"$2\" = new ]; then\n        cmd=\"git add $bucket/$project || echo '... you want to ensure $1 is added to your repository...'\"\n        case $(realpath --relative-base=\"$bucket\" \"$1\") in\n          /*)\n            cmd=\"cp $1 $(project_file_path expect); $cmd\";;\n        esac\n        echo \"$cmd\"\n      fi\n      ;;\n  esac\n}\n\nremove_items() {\n  patch_remove=$(echo \"$diff_output\" | perl -ne 'next unless s/^-([^-])/$1/; s/\\n/ /; print')\n  if [ -n \"$patch_remove\" ]; then\n    echo \"\n<details><summary>Previously acknowledged words that are now absent\n</summary>$patch_remove</details>\n\"\n    if [ -n \"$INPUT_CAPTURE_STALE_WORDS\" ]; then\n      remove_words=$(mktemp)\n      echo \"$patch_remove\" > $remove_words\n      echo \"::set-output name=stale_words::$remove_words\"\n    fi\n  else\n    rm \"$fewer_misspellings_canary\"\n  fi\n}\n\nspelling_warning() {\n  OUTPUT=\"#### $1:\n\"\n  spelling_body \"$2\" \"$3\"\n  post_commit_comment\n}\nspelling_info() {\n  if [ -z \"$2\" ]; then\n    out=\"$1\"\n  else\n    out=\"$1\n\n$2\"\n  fi\n  spelling_body \"$out\" \"$3\"\n  if [ -n \"$VERBOSE\" ]; then\n    OUTPUT=\"## @check-spelling-bot Report\n\n$OUTPUT\"\n    post_commit_comment\n  else\n    echo \"$OUTPUT\"\n  fi\n}\nspelling_body() {\n  err=\"$2\"\n  if [ -n \"$OUTPUT\" ]; then\n    header=\"$OUTPUT\n\n\"\n  else\n    header=\"\"\n  fi\n  header=\"# @check-spelling-bot Report\n\n$header\"\n  if [ -z \"$err\" ]; then\n    OUTPUT=\"$header$1\"\n  else\n    if [ -e \"$fewer_misspellings_canary\" ]; then\n      cleanup_text=\" (and remove the previously acknowledged and now absent words)\"\n    fi\n    if [ -n \"$GITHUB_HEAD_REF\" ]; then\n      remote_url_ssh=$(jq -r .pull_request.head.repo.ssh_url < $GITHUB_EVENT_PATH)\n      remote_url_https=$(jq -r .pull_request.head.repo.clone_url < $GITHUB_EVENT_PATH)\n      remote_ref=$GITHUB_HEAD_REF\n    else\n      remote_url_ssh=$(jq -r .repository.ssh_url < $GITHUB_EVENT_PATH)\n      remote_url_https=$(jq -r .repository.clone_url < $GITHUB_EVENT_PATH)\n      remote_ref=$GITHUB_REF\n    fi\n    remote_ref=${remote_ref#refs/heads/}\n    OUTPUT=\"$header$1\n\n\"\n    if [ -s \"$should_exclude_file\" ]; then\n      if [ -n \"$INPUT_CAPTURE_SKIPPED_FILES\" ]; then\n        echo \"::set-output name=skipped_files::$should_exclude_file\"\n      fi\n      OUTPUT=\"$OUTPUT\n<details><summary>Some files were were automatically ignored</summary>\n\nThese sample patterns would exclude them:\n\"'```'\"\n$should_exclude_patterns\n\"'```'\nif [ $(wc -l \"$should_exclude_file\" |perl -pne 's/(\\d+)\\s+.*/$1/') -gt 10 ]; then\n      OUTPUT=\"$OUTPUT\n\"'You should consider excluding directory paths (e.g. `(?:^|/)vendor/`), filenames (e.g. `(?:^|/)yarn\\.lock$`), or file extensions (e.g. `\\.gz$`)\n'\nfi\n      OUTPUT=\"$OUTPUT\n\"'You should consider adding them to:\n```'\"\n$(echo \"$excludes_files\" | xargs -n1 echo)\n\"'```\n\nFile matching is via Perl regular expressions.\n\nTo check these files, more of their words need to be in the dictionary than not. You can use `patterns.txt` to exclude portions, add items to the dictionary (e.g. by adding them to `allow.txt`), or fix typos.\n</details>\n'\n    fi\n    OUTPUT=\"$OUTPUT\n<details><summary>To accept these unrecognized words as correct$cleanup_text,\nrun the following commands</summary>\n\n... in a clone of the [$remote_url_ssh]($remote_url_https) repository\non the \\`$remote_ref\\` branch:\n\"$(relative_note)\"\n\n\"'```'\"\n$err\n\"'```\n</details>\n'\n    if [ -s \"$advice_path\" ]; then\n      OUTPUT=\"$OUTPUT\n\n`cat \"$advice_path\"`\n\"\n    fi\n  fi\n}\nbullet_words_and_warn() {\n  echo \"$1\" > \"$tokens_file\"\n  if [ -n \"$INPUT_CAPTURE_UNKNOWN_WORDS\" ]; then\n    file_with_unknown_words=$(mktemp)\n    cp \"$tokens_file\" $file_with_unknown_words\n    echo \"::set-output name=unknown_words::$file_with_unknown_words\"\n  fi\n  perl -pne 's/^(.)/* $1/' \"$tokens_file\"\n  remove_items\n  rm -f \"$tokens_file\"\n}\n\nquit() {\n  echo \"::remove-matcher owner=check-spelling::\"\n  if [ -n \"$junit\" ]; then\n    exit\n  fi\n  exit $1\n}\n\nbody_to_payload() {\n  BODY=\"$1\"\n  PAYLOAD=$(mktemp)\n  echo '{}' | jq --rawfile body \"$BODY\" '.body = $body' > $PAYLOAD\n  if [ -n \"$DEBUG\" ]; then\n    cat $PAYLOAD >&2\n  fi\n}\n\ncollaborator() {\n  collaborator_url=\"$1\"\n  curl -L -s \\\n    -H \"Authorization: token $GITHUB_TOKEN\" \\\n    -H \"Accept: application/vnd.github.v3+json\" \\\n    \"$collaborator_url\" 2> /dev/null\n}\n\npull_request() {\n  pull_request_url=\"$1\"\n  curl -L -s -S \\\n    -H \"Authorization: token $GITHUB_TOKEN\" \\\n    --header \"Content-Type: application/json\" \\\n    \"$pull_request_url\"\n}\n\nreact() {\n  url=\"$1\"\n  reaction=\"$2\"\n  curl -L -s -S \\\n    -X POST \\\n    -H \"Authorization: token $GITHUB_TOKEN\" \\\n    -H \"Accept: application/vnd.github.squirrel-girl-preview+json\" \\\n    \"$url\"/reactions \\\n    -d '{\"content\":\"'\"$reaction\"'\"}'\n}\n\ncomment() {\n  comments_url=\"$1\"\n  payload=\"$2\"\n  if [ -n \"$payload\" ]; then\n    payload=\"--data @$payload\"\n    method=\"$3\"\n    if [ -n \"$method\" ]; then\n      method=\"-X $method\"\n    fi\n  fi\n  curl -L -s -S \\\n    $method \\\n    -H \"Authorization: token $GITHUB_TOKEN\" \\\n    --header \"Content-Type: application/json\" \\\n    -H 'Accept: application/vnd.github.comfort-fade-preview+json' \\\n    $payload \\\n    \"$comments_url\"\n}\n\nset_comments_url() {\n  event=\"$1\"\n  file=\"$2\"\n  sha=\"$3\"\n  case \"$event\" in\n    issue_comment)\n      COMMENTS_URL=$(cat $file | jq -r .issue.comments_url);;\n    pull_request|pull_request_target|pull_request_review_comment)\n      COMMENTS_URL=$(cat $file | jq -r .pull_request.comments_url);;\n    push|commit_comment)\n      COMMENTS_URL=$(cat $file | jq -r .repository.commits_url | perl -pne 's#\\{/sha}#/'$sha'/comments#');;\n  esac\n}\n\npost_commit_comment() {\n  if [ -n \"$OUTPUT\" ]; then\n    if [ -n \"$INPUT_POST_COMMENT\" ]; then\n      echo \"Preparing a comment for $GITHUB_EVENT_NAME\"\n      set_comments_url \"$GITHUB_EVENT_NAME\" \"$GITHUB_EVENT_PATH\" \"$GITHUB_SHA\"\n      if [ -n \"$COMMENTS_URL\" ] && [ -z \"${COMMENTS_URL##*:*}\" ]; then\n        BODY=$(mktemp)\n        echo \"$OUTPUT\" > $BODY\n        body_to_payload $BODY\n        echo $COMMENTS_URL\n        response=$(mktemp_json)\n\n        res=0\n        comment \"$COMMENTS_URL\" \"$PAYLOAD\" > $response || res=$?\n        if [ $res -gt 0 ]; then\n          if [ -z \"$DEBUG\" ]; then\n            echo \"failed posting to $COMMENTS_URL\"\n            echo \"$PAYLOAD\"\n          fi\n          return $res\n        fi\n\n        if [ -n \"$DEBUG\" ]; then\n          cat $response\n        fi\n        COMMENT_URL=$(jq -r .url < $response)\n        perl -p -i.orig -e 's<COMMENT_URL><'\"$COMMENT_URL\"'>' $BODY\n        if diff -q \"$BODY.orig\" \"$BODY\" > /dev/null; then\n          no_patch=1\n        fi\n        rm \"$BODY.orig\"\n        if offer_quote_reply; then\n          (\n            echo\n            echo \"Alternatively, the bot can do this for you if you reply quoting the following line:\"\n            echo \"@check-spelling-bot apply [changes]($COMMENT_URL).\"\n          )>> $BODY\n          no_patch=\n        fi\n        if [ -z \"$no_patch\" ]; then\n          body_to_payload $BODY\n          comment \"$COMMENT_URL\" \"$PAYLOAD\" \"PATCH\" > $response\n          if [ -n \"$DEBUG\" ]; then\n            cat $response\n          fi\n        fi\n        rm -f $BODY\n      else\n        echo \"$OUTPUT\"\n      fi\n    else\n      echo \"$OUTPUT\"\n    fi\n  fi\n}\n\nstrip_lines() {\n  tr \"\\n\" \" \"\n}\n\nminimize_comment_call() {\n  comment_node=\"$1\"\n  echo \"\n      minimizeComment(\n      input:\n      {\n        subjectId: ${Q}$comment_node${Q},\n        classifier: RESOLVED\n      }\n    ){\n      minimizedComment {\n        isMinimized\n      }\n    }\n\" | strip_lead | strip_lines\n}\n\ncollapse_comment_mutation() {\n  comment_node=\"$1\"\n  query_head=\"mutation {\"\n  query_tail=\"}\"\n  query_body=\"\"\n  i=0\n  while [ -n \"$1\" ]; do\n    query_body=\"$query_body q$i: \"$(minimize_comment_call \"$1\")\n    i=\"$((i+1))\"\n    shift\n  done\n  query=\"$query_head$query_body$query_tail\"\n  echo '{}' | jq --arg query \"$query\" '.query = $query'\n}\n\ncollapse_comment() {\n  curl -s \\\n  -H \"Authorization: token $GITHUB_TOKEN\" \\\n  --header \"Content-Type: application/json\" \\\n  --data-binary \"$(collapse_comment_mutation \"$@\")\" \\\n  $GITHUB_GRAPHQL_URL\n}\n\nexit_if_no_unknown_words() {\n  if [ ! -s \"$run_output\" ]; then\n    quit 0\n  fi\n}\n\ngrep_v_spellchecker() {\n  grep_v_string \"$spellchecker\"\n}\n\ngrep_v_string() {\n  perl -ne \"next if m{$1}; print\"\n}\n\ncompare_new_output() {\n  begin_group 'Compare expect with new output'\n    sorted_expect=\"$temp/expect.sorted.txt\"\n    (sed -e 's/#.*//' \"$expect_path\" | sort_unique) > \"$sorted_expect\"\n    expect_path=\"$sorted_expect\"\n\n    diff_output=$(\n      diff -w -U0 \"$expect_path\" \"$run_output\" |\n      grep_v_spellchecker)\n  end_group\n\n  if [ -z \"$diff_output\" ]; then\n    begin_group 'No misspellings'\n    title=\"No new words with misspellings found\"\n      spelling_info \"$title\" \"There are currently $(wc -l $expect_path|sed -e 's/ .*//') expected items.\" \"\"\n    end_group\n    quit 0\n  fi\n\n  begin_group 'New output'\n    new_output=$(\n      diff -i -w -U0 \"$expect_path\" \"$run_output\" |\n      grep_v_spellchecker |\\\n      perl -n -w -e 'next unless /^\\+/; next if /^\\+{3} /; s/^.//; print;')\n  end_group\n\n  should_exclude_patterns=$(sort \"$should_exclude_file\" | path_to_pattern)\n}\n\ngenerate_curl_instructions() {\n  instructions=$(mktemp)\n  (\n    echo 'update_files() {'\n    (\n      skip_wrapping=1\n      if [ -n \"$patch_remove\" ]; then\n        patch_remove='$patch_remove'\n      fi\n      if [ -n \"$patch_add\" ]; then\n        patch_add='$patch_add'\n      fi\n      if [ -n \"$should_exclude_patterns\" ]; then\n        should_exclude_patterns='$should_exclude_patterns'\n      fi\n      generated=$(generate_instructions)\n      cat $generated\n      rm $generated\n    )\n    echo '}'\n  ) >> $instructions\n  echo '\n    comment_json=$(mktemp)\n    curl -L -s -S \\\n      --header \"Content-Type: application/json\" \\\n      \"COMMENT_URL\" > \"$comment_json\"\n    comment_body=$(mktemp)\n    jq -r .body < \"$comment_json\" > $comment_body\n    rm $comment_json\n    '\"$(patch_variables $Q'$comment_body'$Q)\"'\n    update_files\n    rm $comment_body\n    git add -u\n    ' | sed -e 's/^    //' >> $instructions\n  echo $instructions\n}\n\nskip_curl() {\n  [ -n \"$SKIP_CURL\" ] || repo_is_private\n}\n\nmake_instructions() {\n  patch_remove=$(echo \"$diff_output\" | perl -ne 'next unless s/^-([^-])/$1/; s/\\n/ /; print')\n  patch_add=$(echo \"$diff_output\" | perl -ne 'next unless s/^\\+([^+])/$1/; s/\\n/ /; print')\n  if skip_curl; then\n    instructions=$(generate_instructions)\n    if [ -n \"$patch_add\" ]; then\n      to_publish_expect \"$new_expect_file\" $new_expect_file_new >> $instructions\n    fi\n  else\n    instructions=$(generate_curl_instructions)\n  fi\n  cat $instructions\n  rm $instructions\n}\n\nfewer_misspellings() {\n  if [ -n \"$new_output\" ]; then\n    return\n  fi\n\n  begin_group 'Fewer misspellings'\n  title='There are now fewer misspellings than before'\n  SKIP_CURL=1\n  instructions=$(\n    make_instructions\n  )\n  if [ -n \"$INPUT_EXPERIMENTAL_COMMIT_NOTE\" ]; then\n    . \"$spellchecker/update-state.sh\"\n    skip_push_and_pop=1\n\n    instructions_head=$(mktemp)\n    (\n      patch_add=1\n      patch_remove=1\n      patch_variables $comment_body > $instructions_head\n    )\n    . $instructions_head\n    rm $instructions_head\n    instructions=$(generate_instructions)\n\n    . $instructions &&\n    git_commit \"$INPUT_EXPERIMENTAL_COMMIT_NOTE\" &&\n    git push origin ${GITHUB_HEAD_REF:-$GITHUB_REF}\n    spelling_info \"$title\" \"\" \"Applied\"\n  else\n    spelling_info \"$title\" \"\" \"$instructions\"\n  fi\n  end_group\n  quit\n}\nmore_misspellings() {\n  begin_group 'Unrecognized'\n  title='Unrecognized words, please review'\n  instructions=$(\n    make_instructions\n  )\n  spelling_warning \"$title\" \"$(bullet_words_and_warn \"$new_output\")\" \"$instructions\"\n  end_group\n  quit 1\n}\n\ndefine_variables\nset_up_tools\nset_up_files\n. \"$spellchecker/update-state.sh\"\nmain\nwelcome\nrun_spell_check\nexit_if_no_unknown_words\ncompare_new_output\nfewer_misspellings_canary=$(mktemp)\nfewer_misspellings\nmore_misspellings\n"], "filenames": ["common.sh", "spelling-unknown-word-splitter.pl", "unknown-words.sh"], "buggy_code_start_loc": [2, 19, 376], "buggy_code_end_loc": [2, 22, 377], "fixing_code_start_loc": [3, 19, 376], "fixing_code_end_loc": [8, 22, 398], "type": "CWE-532", "message": "check-spelling is a github action which provides CI spell checking. In affected versions and for a repository with the [check-spelling action](https://github.com/marketplace/actions/check-spelling) enabled that triggers on `pull_request_target` (or `schedule`), an attacker can send a crafted Pull Request that causes a `GITHUB_TOKEN` to be exposed. With the `GITHUB_TOKEN`, it's possible to push commits to the repository bypassing standard approval processes. Commits to the repository could then steal any/all secrets available to the repository. As a workaround users may can either: [Disable the workflow](https://docs.github.com/en/actions/managing-workflow-runs/disabling-and-enabling-a-workflow) until you've fixed all branches or Set repository to [Allow specific actions](https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/disabling-or-limiting-github-actions-for-a-repository#allowing-specific-actions-to-run). check-spelling isn't a verified creator and it certainly won't be anytime soon. You could then explicitly add other actions that your repository uses. Set repository [Workflow permissions](https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/disabling-or-limiting-github-actions-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository) to `Read repository contents permission`. Workflows using `check-spelling/check-spelling@main` will get the fix automatically. Workflows using a pinned sha or tagged version will need to change the affected workflows for all repository branches to the latest version. Users can verify who and which Pull Requests have been running the action by looking up the spelling.yml action in the Actions tab of their repositories, e.g., https://github.com/check-spelling/check-spelling/actions/workflows/spelling.yml - you can filter PRs by adding ?query=event%3Apull_request_target, e.g., https://github.com/check-spelling/check-spelling/actions/workflows/spelling.yml?query=event%3Apull_request_target.", "other": {"cve": {"id": "CVE-2021-32724", "sourceIdentifier": "security-advisories@github.com", "published": "2021-09-09T21:15:07.250", "lastModified": "2021-09-27T14:21:55.153", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "check-spelling is a github action which provides CI spell checking. In affected versions and for a repository with the [check-spelling action](https://github.com/marketplace/actions/check-spelling) enabled that triggers on `pull_request_target` (or `schedule`), an attacker can send a crafted Pull Request that causes a `GITHUB_TOKEN` to be exposed. With the `GITHUB_TOKEN`, it's possible to push commits to the repository bypassing standard approval processes. Commits to the repository could then steal any/all secrets available to the repository. As a workaround users may can either: [Disable the workflow](https://docs.github.com/en/actions/managing-workflow-runs/disabling-and-enabling-a-workflow) until you've fixed all branches or Set repository to [Allow specific actions](https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/disabling-or-limiting-github-actions-for-a-repository#allowing-specific-actions-to-run). check-spelling isn't a verified creator and it certainly won't be anytime soon. You could then explicitly add other actions that your repository uses. Set repository [Workflow permissions](https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/disabling-or-limiting-github-actions-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository) to `Read repository contents permission`. Workflows using `check-spelling/check-spelling@main` will get the fix automatically. Workflows using a pinned sha or tagged version will need to change the affected workflows for all repository branches to the latest version. Users can verify who and which Pull Requests have been running the action by looking up the spelling.yml action in the Actions tab of their repositories, e.g., https://github.com/check-spelling/check-spelling/actions/workflows/spelling.yml - you can filter PRs by adding ?query=event%3Apull_request_target, e.g., https://github.com/check-spelling/check-spelling/actions/workflows/spelling.yml?query=event%3Apull_request_target."}, {"lang": "es", "value": "check-spelling es una acci\u00f3n de github que proporciona una comprobaci\u00f3n ortogr\u00e1fica de CI. En versiones afectadas  y para un repositorio con la acci\u00f3n [check-spelling](https://github.com/marketplace/actions/check-spelling) habilitada que desencadena en \"pull_request_target\" (o \"schedule\"), un atacante puede enviar un Pull Request dise\u00f1ado que cause que un \"GITHUB_TOKEN\" sea expuesto. Con el \"GITHUB_TOKEN\", es posible enviar confirmaciones al commit omitiendo los procesos de aprobaci\u00f3n est\u00e1ndar. Los commits al repositorio podr\u00edan entonces robar cualquier/todos los secretos disponibles en el repositorio. Como soluci\u00f3n, los usuarios pueden: [Desactivar el flujo de trabajo](https://docs.github.com/en/actions/managing-workflow-runs/disabling-and-enabling-a-workflow) hasta que haya corregido todas las ramas o Configurar el repositorio para [Permitir acciones espec\u00edficas](https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/disabling-or-limiting-github-actions-for-a-repository#allowing-specific-actions-to-run). la comprobaci\u00f3n de la ortograf\u00eda no es un creador verificado y ciertamente no lo ser\u00e1 pronto. Entonces podr\u00eda a\u00f1adir expl\u00edcitamente otras acciones que su repositorio usa. Ajuste el repositorio [Permisos de flujo de trabajo](https://docs.github.com/en/github/administering-a-repository/managing-repository-settings/disabling-or-limiting-github-actions-for-a-repository#setting-the-permissions-of-the-github_token-for-your-repository) a \"Read repository contents permission\". Los flujos de trabajo que usen \"check-spelling/check-spelling@main\" obtendr\u00e1n la correcci\u00f3n autom\u00e1ticamente. Los flujos de trabajo que usen una versi\u00f3n con anclaje o etiquetada tendr\u00e1n que cambiar los flujos de trabajo afectados para todas las ramas del repositorio a la \u00faltima versi\u00f3n. Los usuarios pueden verificar qui\u00e9n y qu\u00e9 Pull Requests han ejecutado la acci\u00f3n buscando la acci\u00f3n spelling.yml en la pesta\u00f1a Acciones de sus repositorios, por ejemplo, https://github.com/check-spelling/check-spelling/actions/workflows/spelling.yml - puede filtrar los PRs al a\u00f1adir ?query=event%3Apull_request_target, por ejemplo, https://github.com/check-spelling/check-spelling/actions/workflows/spelling.yml?query=event%3Apull_request_target"}], "metrics": {"cvssMetricV31": [{"source": "security-advisories@github.com", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:check-spelling:check-spelling:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.0.19", "matchCriteriaId": "A4A73141-03F7-4AAB-A7E3-6D2331D73257"}]}]}], "references": [{"url": "https://github.com/check-spelling/check-spelling/commit/436362fc6b588d9d561cbdb575260ca593c8dc56", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/check-spelling/check-spelling/security/advisories/GHSA-g86g-chm8-7r2p", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/check-spelling/check-spelling/commit/436362fc6b588d9d561cbdb575260ca593c8dc56"}}