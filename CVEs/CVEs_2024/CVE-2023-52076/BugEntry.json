{"buggy_code": ["/* this file is part of atril, a mate document viewer\n *\n *  Copyright (C) 2014 Avishkar Gupta\n *\n *  Author:\n *   Avishkar Gupta <avishkar.gupta.delhi@gmail.com>\n *\n * Atril is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Atril is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n#include \"epub-document.h\"\n#include \"ev-file-helpers.h\"\n#include \"unzip.h\"\n#include \"ev-document-thumbnails.h\"\n#include \"ev-document-find.h\"\n#include \"ev-backends-manager.h\"\n#include \"ev-document-links.h\"\n#include \"ev-document-misc.h\"\n#include <libxml/parser.h>\n#include <libxml/xmlmemory.h>\n#include <libxml/HTMLparser.h>\n\n#include <config.h>\n#include <glib/gi18n-lib.h>\n#include <glib/gstdio.h>\n\n#include <gtk/gtk.h>\n\n/*For strcasestr(),strstr()*/\n#include <string.h>\n\ntypedef enum _xmlParseReturnType\n{\n    XML_ATTRIBUTE,\n    XML_KEYWORD\n}xmlParseReturnType;\n\ntypedef struct _contentListNode {\n    gchar* key ;\n    gchar* value ;\n    gint index ;\n}contentListNode;\n\ntypedef struct _linknode {\n    gchar *pagelink;\n    GList *children;\n    gchar *linktext;\n    guint page;\n}linknode;\n\ntypedef struct _EpubDocumentClass EpubDocumentClass;\n\nstruct _EpubDocumentClass\n{\n    EvDocumentClass parent_class;\n};\n\nstruct _EpubDocument\n{\n    EvDocument parent_instance;\n    /*Stores the path to the source archive*/\n    gchar* archivename ;\n    /*Stores the path of the directory where we unzipped the epub*/\n    gchar* tmp_archive_dir ;\n    /*Stores the contentlist in a sorted manner*/\n    GList* contentList ;\n    /* A variable to hold our epubDocument for unzipping*/\n    unzFile epubDocument ;\n    /*The (sub)directory that actually houses the document*/\n    gchar* documentdir;\n    /*Stores the table of contents*/\n    GList *index;\n    /*Document title, for the sidebar links*/\n    gchar *docTitle;\n};\n\nstatic void       epub_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface);\nstatic void       epub_document_document_find_iface_init       (EvDocumentFindInterface       *iface);\nstatic void       epub_document_document_links_iface_init      (EvDocumentLinksInterface      *iface);\n\nEV_BACKEND_REGISTER_WITH_CODE (EpubDocument, epub_document,\n    {\n        EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_THUMBNAILS,\n                                        epub_document_document_thumbnails_iface_init);\n        EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_FIND,\n                                        epub_document_document_find_iface_init);\n        EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_LINKS,\n                                        epub_document_document_links_iface_init);\n\n    } );\n\nstatic void\nepub_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n                                         EvRenderContext      *rc,\n                                         gint                 *width,\n                                         gint                 *height)\n{\n    gdouble page_width, page_height;\n\n    page_width = 800;\n    page_height = 1080;\n\n    *width = MAX ((gint)(page_width * rc->scale + 0.5), 1);\n    *height = MAX ((gint)(page_height * rc->scale + 0.5), 1);\n}\n\nstatic GdkPixbuf *\nepub_document_thumbnails_get_thumbnail (EvDocumentThumbnails *document,\n                                        EvRenderContext      *rc,\n                                        gboolean              border)\n{\n    cairo_surface_t *webpage;\n    GdkPixbuf *thumbnailpix = NULL ;\n    gint width,height;\n    epub_document_thumbnails_get_dimensions (document, rc, &width, &height);\n    webpage = ev_document_misc_surface_rotate_and_scale (rc->page->backend_page,\n                                                         width, height, 0);\n    thumbnailpix = ev_document_misc_pixbuf_from_surface (webpage);\n    return thumbnailpix;\n}\n\nstatic gboolean\nin_tag(const char* found)\n{\n    const char* bracket = found ;\n\n    /* Since the dump started with the body tag, the '<' will be the first\n     * character in the haystack.\n     */\n    while (*bracket != '<') {\n        bracket--;\n        if (*bracket == '>') {\n            /*We encounted a close brace before an open*/\n            return FALSE ;\n        }\n    }\n\n    return TRUE;\n}\n\nstatic int\nget_substr_count(const char * haystack,const char *needle,gboolean case_sensitive)\n{\n    const char* tmp = haystack ;\n    char* (*string_compare_function)(const char*,const char*);\n    int count=0;\n    if (case_sensitive) {\n        string_compare_function = strstr ;\n    }\n    else {\n        string_compare_function = strcasestr;\n    }\n\n    while ((tmp=string_compare_function(tmp,needle))) {\n        if (!in_tag(tmp)) {\n            count++;\n        }\n        tmp = tmp + strlen(needle);\n    }\n\n    return count;\n}\n\nstatic guint\nepub_document_check_hits(EvDocumentFind *document_find,\n                         EvPage         *page,\n                         const gchar    *text,\n                         gboolean        case_sensitive)\n{\n    gchar *filepath = g_filename_from_uri((gchar*)page->backend_page,NULL,NULL);\n    htmlDocPtr htmldoc =  xmlParseFile(filepath);\n    if (htmldoc == NULL) {\n        g_free(filepath);\n        return 0;\n    }\n    htmlNodePtr htmltag = xmlDocGetRootElement(htmldoc);\n    if (htmltag == NULL) {\n        g_free(filepath);\n        xmlFreeDoc (htmldoc);\n        return 0;\n    }\n\n    int count=0;\n    htmlNodePtr bodytag = htmltag->xmlChildrenNode;\n\n    while ( xmlStrcmp(bodytag->name,(xmlChar*)\"body\") ) {\n        bodytag = bodytag->next;\n    }\n\n    xmlBufferPtr bodybuffer = xmlBufferCreate();\n    xmlNodeDump(bodybuffer,htmldoc,bodytag,0,1);\n\n    count = get_substr_count((char*)bodybuffer->content,text,case_sensitive);\n\n    xmlBufferFree(bodybuffer);\n    xmlFreeDoc(htmldoc);\n    g_free (filepath);\n\n    return count;\n}\n\nstatic gboolean\nepub_document_links_has_document_links(EvDocumentLinks *document_links)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document_links);\n\n    g_return_val_if_fail(EPUB_IS_DOCUMENT(epub_document), FALSE);\n\n    if (!epub_document->index)\n        return FALSE;\n\n    return TRUE;\n}\n\ntypedef struct _LinksCBStruct {\n    GtkTreeModel *model;\n    GtkTreeIter  *parent;\n}LinksCBStruct;\n\nstatic void\nepub_document_make_tree_entry(linknode* ListData,LinksCBStruct* UserData)\n{\n    GtkTreeIter tree_iter;\n    EvLink *link = NULL;\n    gboolean expand;\n    char *title_markup;\n\n    if (ListData->children) {\n        expand=TRUE;\n    }\n    else {\n        expand=FALSE;\n    }\n\n    EvLinkDest *ev_dest = NULL;\n    EvLinkAction *ev_action;\n\n    /* We shall use a EV_LINK_DEST_TYPE_PAGE for page links,\n     * and a EV_LINK_DEST_TYPE_HLINK(custom) for refs on a page of type url#label\n     * because we need both dest and page label for this.\n     */\n\n    if (g_strrstr(ListData->pagelink,\"#\") == NULL) {\n        ev_dest = ev_link_dest_new_page(ListData->page);\n    }\n    else {\n        ev_dest = ev_link_dest_new_hlink((gchar*)ListData->pagelink,ListData->page);\n    }\n\n    ev_action = ev_link_action_new_dest (ev_dest);\n\n    link = ev_link_new((gchar*)ListData->linktext,ev_action);\n\n    gtk_tree_store_append (GTK_TREE_STORE (UserData->model), &tree_iter,(UserData->parent));\n    title_markup = g_markup_escape_text ((gchar*)ListData->linktext, -1);\n\n    gtk_tree_store_set (GTK_TREE_STORE (UserData->model), &tree_iter,\n                        EV_DOCUMENT_LINKS_COLUMN_MARKUP, title_markup,\n                        EV_DOCUMENT_LINKS_COLUMN_LINK, link,\n                        EV_DOCUMENT_LINKS_COLUMN_EXPAND, expand,\n                        -1);\n\n    if (ListData->children) {\n        LinksCBStruct cbstruct;\n        cbstruct.parent = &tree_iter;\n        cbstruct.model = UserData->model;\n        g_list_foreach (ListData->children,(GFunc)epub_document_make_tree_entry,&cbstruct);\n    }\n\n    g_free (title_markup);\n    g_object_unref (link);\n}\n\nstatic GtkTreeModel *\nepub_document_links_get_links_model(EvDocumentLinks *document_links)\n{\n    GtkTreeModel *model = NULL;\n\n    g_return_val_if_fail (EPUB_IS_DOCUMENT (document_links), NULL);\n\n    EpubDocument *epub_document = EPUB_DOCUMENT(document_links);\n\n    model = (GtkTreeModel*) gtk_tree_store_new (EV_DOCUMENT_LINKS_COLUMN_NUM_COLUMNS,\n                                                G_TYPE_STRING,\n                                                G_TYPE_OBJECT,\n                                                G_TYPE_BOOLEAN,\n                                                G_TYPE_STRING);\n\n    LinksCBStruct linkStruct;\n    linkStruct.model = model;\n    EvLink *link = ev_link_new(epub_document->docTitle,\n                               ev_link_action_new_dest(ev_link_dest_new_page(0)));\n    GtkTreeIter parent;\n\n    linkStruct.parent = &parent;\n\n    gtk_tree_store_append (GTK_TREE_STORE (model), &parent,NULL);\n\n    gtk_tree_store_set (GTK_TREE_STORE (model), &parent,\n                        EV_DOCUMENT_LINKS_COLUMN_MARKUP, epub_document->docTitle,\n                        EV_DOCUMENT_LINKS_COLUMN_LINK, link,\n                        EV_DOCUMENT_LINKS_COLUMN_EXPAND, TRUE,\n                        -1);\n\n    g_object_unref(link);\n\n    if (epub_document->index) {\n        g_list_foreach (epub_document->index,(GFunc)epub_document_make_tree_entry,&linkStruct);\n    }\n\n    return model;\n}\n\nstatic EvMappingList *\nepub_document_links_get_links (EvDocumentLinks *document_links,\n                               EvPage          *page)\n{\n    /* TODO\n     * ev_mapping_list_new()\n     */\n    return NULL;\n}\n\nstatic void\nepub_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n    iface->get_thumbnail = epub_document_thumbnails_get_thumbnail;\n    iface->get_dimensions = epub_document_thumbnails_get_dimensions;\n}\n\nstatic void\nepub_document_document_find_iface_init (EvDocumentFindInterface *iface)\n{\n    iface->check_for_hits = epub_document_check_hits;\n}\n\nstatic void\nepub_document_document_links_iface_init(EvDocumentLinksInterface *iface)\n{\n    iface->has_document_links = epub_document_links_has_document_links;\n    iface->get_links_model = epub_document_links_get_links_model;\n    iface->get_links = epub_document_links_get_links;\n}\n\nstatic gboolean\nepub_document_save (EvDocument *document,\n                    const char *uri,\n                    GError    **error)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT (document);\n\n    gchar *source_uri = g_filename_to_uri (epub_document->archivename, NULL, error);\n    if (source_uri == NULL)\n        return FALSE;\n\n    return ev_xfer_uri_simple (source_uri, uri, error);\n}\n\nstatic int\nepub_document_get_n_pages (EvDocument *document)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT (document);\n\n        if (epub_document-> contentList == NULL)\n            return 0;\n\n    return g_list_length(epub_document->contentList);\n}\n\n/**\n * epub_remove_temporary_dir : Removes a directory recursively.\n * This function is same as comics_remove_temporary_dir\n * Returns:\n * 0 if it was successfully deleted,\n * -1 if an error occurred\n */\nstatic int\nepub_remove_temporary_dir (gchar *path_name)\n{\n    GDir  *content_dir;\n    const gchar *filename;\n    gchar *filename_with_path;\n\n    if (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n        content_dir = g_dir_open  (path_name, 0, NULL);\n        filename  = g_dir_read_name (content_dir);\n        while (filename) {\n            filename_with_path =\n                g_build_filename (path_name,\n                                  filename, NULL);\n            epub_remove_temporary_dir (filename_with_path);\n            g_free (filename_with_path);\n            filename = g_dir_read_name (content_dir);\n        }\n        g_dir_close (content_dir);\n    }\n    /* Note from g_remove() documentation: on Windows, it is in general not\n     * possible to remove a file that is open to some process, or mapped\n     * into memory.*/\n    return (g_remove (path_name));\n}\n\nstatic gboolean\ncheck_mime_type             (const gchar* uri,\n                             GError** error);\n\nstatic gboolean\nopen_xml_document           (const gchar* filename);\n\nstatic gboolean\nset_xml_root_node           (xmlChar* rootname);\n\nstatic xmlNodePtr\nxml_get_pointer_to_node     (xmlChar* parserfor,\n                             xmlChar* attributename,\n                             xmlChar* attributevalue);\nstatic void\nxml_parse_children_of_node  (xmlNodePtr parent,\n                             xmlChar* parserfor,\n                             xmlChar* attributename,\n                             xmlChar* attributevalue);\n\nstatic gboolean\nxml_check_attribute_value   (xmlNode* node,\n                             xmlChar * attributename,\n                             xmlChar* attributevalue);\n\nstatic xmlChar*\nxml_get_data_from_node      (xmlNodePtr node,\n                             xmlParseReturnType rettype,\n                             xmlChar* attributename);\n\nstatic void\nxml_free_doc                (void);\n\nstatic void\nfree_tree_nodes             (gpointer data);\n\n/*Global variables for XML parsing*/\nstatic xmlDocPtr    xmldocument ;\nstatic xmlNodePtr   xmlroot ;\nstatic xmlNodePtr   xmlretval ;\n\n/*\n**Functions to parse the xml files.\n**Open a XML document for reading\n*/\nstatic gboolean\nopen_xml_document ( const gchar* filename )\n{\n    xmldocument = xmlParseFile(filename);\n\n    if ( xmldocument == NULL )\n    {\n        return FALSE ;\n    }\n    else\n    {\n        return TRUE ;\n    }\n}\n\n/**\n *Check if the root value is same as rootname .\n *if supplied rootvalue = NULL ,just set root to rootnode .\n**/\nstatic gboolean\nset_xml_root_node(xmlChar* rootname)\n{\n    xmlroot = xmlDocGetRootElement(xmldocument);\n\n    if (xmlroot == NULL) {\n\n        xmlFreeDoc(xmldocument);\n        return FALSE;\n    }\n\n    if ( rootname == NULL )\n    {\n        return TRUE ;\n    }\n\n    if ( !xmlStrcmp(xmlroot->name,rootname))\n    {\n        return TRUE ;\n    }\n    else\n    {\n       return FALSE;\n    }\n}\n\nstatic xmlNodePtr\nxml_get_pointer_to_node(xmlChar* parserfor,\n                        xmlChar*  attributename,\n                        xmlChar* attributevalue )\n{\n    xmlNodePtr topchild;\n\n    xmlretval = NULL ;\n\n    if ( !xmlStrcmp( xmlroot->name, parserfor) )\n    {\n        return xmlroot ;\n    }\n\n    topchild = xmlroot->xmlChildrenNode ;\n\n    while ( topchild != NULL )\n    {\n        if ( !xmlStrcmp(topchild->name,parserfor) )\n        {\n            if ( xml_check_attribute_value(topchild,attributename,attributevalue) == TRUE )\n            {\n                 xmlretval = topchild;\n                 return xmlretval;\n            }\n            else\n            {\n                /*No need to parse children node*/\n                topchild = topchild->next ;\n                continue ;\n            }\n        }\n\n        xml_parse_children_of_node(topchild , parserfor, attributename, attributevalue) ;\n\n        topchild = topchild->next ;\n    }\n\n    return xmlretval ;\n}\n\nstatic void\nxml_parse_children_of_node(xmlNodePtr parent,\n                           xmlChar* parserfor,\n                           xmlChar* attributename,\n                           xmlChar* attributevalue )\n{\n    xmlNodePtr child = parent->xmlChildrenNode ;\n\n    while ( child != NULL )\n    {\n        if ( !xmlStrcmp(child->name,parserfor))\n        {\n            if ( xml_check_attribute_value(child,attributename,attributevalue) == TRUE )\n            {\n                 xmlretval = child;\n                 return ;\n            }\n            else\n            {\n                /*No need to parse children node*/\n                child = child->next ;\n                continue ;\n            }\n        }\n\n        /*return already if we have xmlretval set*/\n        if ( xmlretval != NULL )\n        {\n            return ;\n        }\n\n        xml_parse_children_of_node(child,parserfor,attributename,attributevalue) ;\n        child = child->next ;\n    }\n}\n\nstatic void\nxml_free_doc()\n{\n    xmlFreeDoc(xmldocument);\n    xmldocument = NULL;\n}\n\nstatic gboolean\nxml_check_attribute_value(xmlNode* node,\n                          xmlChar * attributename,\n                          xmlChar* attributevalue)\n{\n    xmlChar* attributefromfile ;\n    if ( attributename == NULL || attributevalue == NULL )\n    {\n         return TRUE ;\n    }\n    else if ( !xmlStrcmp(( attributefromfile = xmlGetProp(node,attributename)),\n                           attributevalue) )\n    {\n        xmlFree(attributefromfile);\n        return TRUE ;\n    }\n    xmlFree(attributefromfile);\n    return FALSE ;\n}\n\nstatic xmlChar*\nxml_get_data_from_node(xmlNodePtr node,\n                       xmlParseReturnType rettype,\n                       xmlChar* attributename)\n{\n    xmlChar* datastring ;\n    if ( rettype == XML_ATTRIBUTE )\n       datastring= xmlGetProp(node,attributename);\n    else\n       datastring= xmlNodeListGetString(xmldocument,node->xmlChildrenNode, 1);\n\n    return datastring;\n}\n\nstatic gboolean\ncheck_mime_type(const gchar* uri,GError** error)\n{\n    GError * err = NULL;\n    const gchar* mimeFromFile;\n\n    mimeFromFile = ev_file_get_mime_type(uri, FALSE, &err);\n    if (mimeFromFile)\n    {\n        const gchar* mimetypes[] = {\"application/epub+zip\", \"application/x-booki+zip\", NULL};\n        guint i;\n\n        for (i = 0; i < g_strv_length (mimetypes); i++) {\n           if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                return TRUE;\n\t}\n\n        /* fallback for malformed epub files */\n        if (strcmp (mimeFromFile, \"application/zip\") == 0)\n        {\n            mimeFromFile = ev_file_get_mime_type (uri, TRUE, &err);\n            if (mimeFromFile)\n            {\n                for (i = 0; i < g_strv_length (mimetypes); i++) {\n                    if (g_strcmp0(mimeFromFile, mimetypes[i]) == 0)\n                        return TRUE;\n                }\n\n                /*We didn't find a match*/\n                g_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"Not an ePub document\"));\n\n                return FALSE;\n            }\n        }\n    }\n\n    if (err)\n        g_propagate_error (error, err);\n    else\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"Unknown MIME Type\"));\n\n    return FALSE;\n}\n\nstatic gboolean\nextract_one_file(EpubDocument* epub_document,GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n\n    gboolean result = TRUE;\n\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n\n    if ( directory != NULL )\n        directory++;\n\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n\n    /*if we encounter a directory, make a directory inside our temporary folder.*/\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        /*Since a substring can't be longer than the parent string, allocating space equal to the parent's size should suffice*/\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        /* Add the name of the directory and subdirectories,if any to a buffer and then create it */\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n\n    outfile = g_file_new_for_path(gfilepath->str);\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outfile) ;\n    g_object_unref(outstream) ;\n\nout:\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}\n\nstatic gboolean\nextract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n\n    gboolean result = FALSE;\n\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document,&err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n            goto out;\n        }\n\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\n\nout:\n    unzClose(epub_document->epubDocument);\n    return result;\n}\n\nstatic gchar*\nget_uri_to_content(const gchar* uri,GError ** error,EpubDocument *epub_document)\n{\n    gchar* tmp_archive_dir = epub_document->tmp_archive_dir;\n    GError *err = NULL ;\n\n    gchar *containerpath = g_filename_from_uri(uri,NULL,&err);\n    if ( !containerpath )\n    {\n        if (err) {\n            g_propagate_error (error,err);\n        }\n        else    {\n            g_set_error_literal (error,\n                                 EV_DOCUMENT_ERROR,\n                                 EV_DOCUMENT_ERROR_INVALID,\n                                 _(\"could not retrieve container file\"));\n        }\n        return NULL ;\n    }\n\n    gboolean result = open_xml_document(containerpath);\n    g_free (containerpath);\n    if ( result == FALSE )\n    {\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"could not open container file\"));\n\n        return NULL ;\n    }\n\n    if ( set_xml_root_node((xmlChar*)\"container\") == FALSE)  {\n\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"container file is corrupt\"));\n        return NULL ;\n    }\n\n    xmlNodePtr rootfileNode = xml_get_pointer_to_node((xmlChar*)\"rootfile\",(xmlChar*)\"media-type\",(xmlChar*)\"application/oebps-package+xml\");\n    if ( rootfileNode == NULL)\n    {\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"epub file is invalid or corrupt\"));\n        return NULL ;\n    }\n\n    xmlChar *relativepath = xml_get_data_from_node(rootfileNode,XML_ATTRIBUTE,(xmlChar*)\"full-path\") ;\n    if ( relativepath == NULL )\n    {\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"epub file is corrupt, no container\"));\n        return NULL ;\n    }\n\n    gchar* documentfolder = g_strrstr((gchar*)relativepath,\"/\");\n    if (documentfolder != NULL) {\n        gchar* copybuffer = (gchar*)relativepath ;\n        gchar* directorybuffer = g_malloc0(sizeof(gchar*)*100);\n        gchar* writer = directorybuffer;\n\n        while(copybuffer != documentfolder) {\n            (*writer) = (*copybuffer);\n            writer++;copybuffer++;\n        }\n        *writer = '\\0';\n\n        GString *documentdir = g_string_new(tmp_archive_dir);\n        g_string_append_printf(documentdir,\"/%s\",directorybuffer);\n        g_free(directorybuffer);\n        epub_document->documentdir = g_string_free(documentdir,FALSE);\n    }\n    else\n    {\n        epub_document->documentdir = g_strdup(tmp_archive_dir);\n    }\n\n    GString *absolutepath = g_string_new(tmp_archive_dir);\n    g_string_append_printf(absolutepath,\"/%s\",relativepath);\n    g_free (relativepath);\n\n    gchar *content_uri = g_filename_to_uri(absolutepath->str,NULL,&err);\n    g_string_free(absolutepath,TRUE);\n    if ( !content_uri )  {\n        if (err) {\n            g_propagate_error (error,err);\n        }\n        else\n        {\n            g_set_error_literal (error,\n                                 EV_DOCUMENT_ERROR,\n                                 EV_DOCUMENT_ERROR_INVALID,\n                                 _(\"could not retrieve container file\"));\n        }\n        return NULL ;\n    }\n    xml_free_doc();\n    return content_uri ;\n}\n\nstatic gboolean\nlink_present_on_page(const gchar* link,const gchar *page_uri)\n{\n    gchar *res;\n    if ((res=g_strrstr(link, page_uri)) != NULL) {\n        return TRUE;\n    }\n    else {\n        return FALSE;\n    }\n}\n\nstatic GList*\nsetup_document_content_list(const gchar* content_uri, GError** error,gchar *documentdir)\n{\n    GError *err = NULL;\n    gint indexcounter = 1;\n    xmlNodePtr manifest,spine,itemrefptr,itemptr;\n    gboolean errorflag = FALSE;\n\n    if ( open_xml_document(content_uri) == FALSE )\n    {\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"could not parse content manifest\"));\n\n        return FALSE ;\n    }\n    if ( set_xml_root_node((xmlChar*)\"package\") == FALSE)  {\n\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"content file is invalid\"));\n        return FALSE ;\n    }\n\n    if ( ( spine = xml_get_pointer_to_node((xmlChar*)\"spine\",NULL,NULL) )== NULL )\n    {\n         g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"epub file has no spine\"));\n        return FALSE ;\n    }\n\n    if ( ( manifest = xml_get_pointer_to_node((xmlChar*)\"manifest\",NULL,NULL) )== NULL )\n    {\n         g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"epub file has no manifest\"));\n        return FALSE ;\n    }\n\n    xmlretval = NULL ;\n\n    /*Get first instance of itemref from the spine*/\n    xml_parse_children_of_node(spine,(xmlChar*)\"itemref\",NULL,NULL);\n\n    if ( xmlretval != NULL )\n        itemrefptr = xmlretval ;\n    else\n    {\n        errorflag=TRUE;\n    }\n\n    GList *newlist = NULL;\n\n    /*Parse the spine for remaining itemrefs*/\n    do\n    {\n        /*for the first time that we enter the loop, if errorflag is set we break*/\n        if ( errorflag )\n        {\n            break;\n        }\n        if ( xmlStrcmp(itemrefptr->name,(xmlChar*)\"itemref\") == 0)\n        {\n            contentListNode *newnode = g_malloc0(sizeof(newnode));\n            newnode->key = (gchar*)xml_get_data_from_node(itemrefptr,XML_ATTRIBUTE,(xmlChar*)\"idref\");\n            if ( newnode->key == NULL )\n            {\n                g_free (newnode);\n                errorflag = TRUE;\n                break;\n            }\n            xmlretval=NULL ;\n            xml_parse_children_of_node(manifest,(xmlChar*)\"item\",(xmlChar*)\"id\",(xmlChar*)newnode->key);\n\n            if ( xmlretval != NULL )\n            {\n                itemptr = xmlretval ;\n            }\n            else\n            {\n                g_free (newnode->key);\n                g_free (newnode);\n                errorflag = TRUE;\n                break;\n            }\n\n            GString* absolutepath = g_string_new(documentdir);\n            gchar *relativepath = (gchar*)xml_get_data_from_node(itemptr,XML_ATTRIBUTE,(xmlChar*)\"href\");\n            g_string_append_printf(absolutepath,\"/%s\",relativepath);\n            g_free (relativepath);\n\n            newnode->value = g_filename_to_uri(absolutepath->str,NULL,&err);\n            g_string_free(absolutepath,TRUE);\n\n            if ( newnode->value == NULL )\n            {\n                g_free (newnode->key);\n                g_free (newnode);\n                errorflag = TRUE;\n                break;\n            }\n\n            newnode->index = indexcounter++ ;\n\n            newlist = g_list_prepend(newlist, newnode);\n        }\n        itemrefptr = itemrefptr->next ;\n    }\n    while ( itemrefptr != NULL );\n\n    if ( errorflag )\n    {\n        if ( err )\n        {\n            g_propagate_error(error,err);\n        }\n        else\n        {\n            g_set_error_literal(error,\n                                EV_DOCUMENT_ERROR,\n                                EV_DOCUMENT_ERROR_INVALID,\n                                _(\"Could not set up document tree for loading, some files missing\"));\n        }\n        /*free any nodes that were set up and return empty*/\n        g_list_free_full(newlist, (GDestroyNotify)free_tree_nodes);\n        return NULL;\n    }\n\n    newlist = g_list_reverse(newlist);\n    xml_free_doc();\n    return newlist;\n\n}\n\n/* Callback function to free the contentlist.*/\nstatic void\nfree_tree_nodes(gpointer data)\n{\n    contentListNode* dataptr = data ;\n    g_free(dataptr->value);\n    g_free(dataptr->key);\n    g_free(dataptr);\n}\n\nstatic void\nfree_link_nodes(gpointer data)\n{\n    linknode* dataptr = data ;\n    g_free(dataptr->pagelink);\n    g_free(dataptr->linktext);\n\n    if (dataptr->children) {\n        g_list_free_full(dataptr->children,(GDestroyNotify)free_link_nodes);\n    }\n    g_free(dataptr);\n}\n\nstatic gchar*\nget_toc_file_name(gchar *containeruri)\n{\n    gchar *containerfilename = g_filename_from_uri(containeruri,NULL,NULL);\n    open_xml_document(containerfilename);\n    g_free (containerfilename);\n\n    set_xml_root_node(NULL);\n\n    xmlNodePtr manifest = xml_get_pointer_to_node((xmlChar*)\"manifest\",NULL,NULL);\n    xmlNodePtr spine = xml_get_pointer_to_node((xmlChar*)\"spine\",NULL,NULL);\n\n    xmlChar *ncx = xml_get_data_from_node(spine,XML_ATTRIBUTE,(xmlChar*)\"toc\");\n\n    /*In an epub3, there is sometimes no toc, and we need to then use the nav file for this.*/\n    if (ncx == NULL) {\n        return NULL;\n    }\n\n    xmlretval = NULL;\n    xml_parse_children_of_node(manifest,(xmlChar*)\"item\",(xmlChar*)\"id\",ncx);\n\n    gchar* tocfilename = (gchar*)xml_get_data_from_node(xmlretval,XML_ATTRIBUTE,(xmlChar*)\"href\");\n    xml_free_doc();\n\n    return tocfilename;\n}\n\nstatic gchar*\nepub_document_get_nav_file(gchar* containeruri)\n{\n    open_xml_document(containeruri);\n    set_xml_root_node(NULL);\n    xmlNodePtr manifest = xml_get_pointer_to_node((xmlChar*)\"manifest\",NULL,NULL);\n    xmlretval = NULL;\n    xml_parse_children_of_node(manifest,(xmlChar*)\"item\",(xmlChar*)\"properties\",(xmlChar*)\"nav\");\n\n    gchar *uri = (gchar*)xml_get_data_from_node(xmlretval,XML_ATTRIBUTE, (xmlChar*)\"href\");\n\n    xml_free_doc();\n    return uri;\n}\n\nstatic GList*\nget_child_list(xmlNodePtr ol,gchar* documentdir)\n{\n    GList *childlist = NULL;\n    xmlNodePtr li = ol->xmlChildrenNode;\n\n    while (li != NULL) {\n        if (xmlStrcmp(li->name,(xmlChar*)\"li\")) {\n            li = li->next;\n            continue;\n        }\n        xmlNodePtr children = li->xmlChildrenNode;\n        linknode *newlinknode = g_new0(linknode, 1);\n        while (children != NULL) {\n            if ( !xmlStrcmp(children->name,(xmlChar*)\"a\")) {\n                newlinknode->linktext = (gchar*)xml_get_data_from_node(children,XML_KEYWORD,NULL);\n                gchar* filename = (gchar*)xml_get_data_from_node(children,XML_ATTRIBUTE,(xmlChar*)\"href\");\n                gchar *filepath = g_strdup_printf(\"%s/%s\",documentdir,filename);\n                newlinknode->pagelink = g_filename_to_uri(filepath,NULL,NULL);\n                g_free(filename);\n                g_free(filepath);\n                newlinknode->children = NULL;\n                childlist = g_list_prepend(childlist,newlinknode);\n            }\n            else if ( !xmlStrcmp(children->name,(xmlChar*)\"ol\")){\n                newlinknode->children = get_child_list(children,documentdir);\n            }\n\n            children = children->next;\n        }\n\n        li = li->next;\n    }\n\n    return g_list_reverse(childlist);\n}\n\n/* For an epub3 style navfile */\nstatic GList*\nsetup_index_from_navfile(gchar *tocpath)\n{\n    GList *index = NULL;\n    open_xml_document(tocpath);\n    set_xml_root_node(NULL);\n    xmlNodePtr nav = xml_get_pointer_to_node((xmlChar*)\"nav\",(xmlChar*)\"type\",(xmlChar*)\"toc\");\n\n    if (nav == NULL) {\n        xml_free_doc();\n        return NULL;\n    }\n\n    xmlretval=NULL;\n    xml_parse_children_of_node(nav,(xmlChar*)\"ol\", NULL,NULL);\n    gchar *navdirend = g_strrstr(tocpath,\"/\");\n    gchar *navdir = g_malloc0(strlen(tocpath));\n    gchar *reader = tocpath;\n    gchar *writer = navdir;\n\n    while (reader != navdirend) {\n        (*writer) = (*reader) ;\n        writer++;reader++;\n    }\n    index = get_child_list(xmlretval,navdir);\n    g_free(navdir);\n    xml_free_doc();\n    return index;\n}\n\nstatic GList*\nsetup_document_index(EpubDocument *epub_document,gchar *containeruri)\n{\n    GString *tocpath = g_string_new(epub_document->documentdir);\n    gchar *tocfilename = get_toc_file_name(containeruri);\n    GList *index = NULL;\n\n    if (tocfilename == NULL) {\n        tocfilename = epub_document_get_nav_file(containeruri);\n\n        //Apparently, sometimes authors don't even care to add a TOC!! Guess standards are just guidelines.\n\n        if (tocfilename == NULL) {\n            //We didn't even find a nav file.The document has no TOC.\n            g_string_free(tocpath,TRUE);\n            return NULL;\n        }\n\n        g_string_append_printf (tocpath,\"/%s\",tocfilename);\n        index = setup_index_from_navfile(tocpath->str);\n        g_string_free(tocpath,TRUE);\n        g_free (tocfilename);\n        return index;\n    }\n\n    g_string_append_printf (tocpath,\"/%s\",tocfilename);\n    g_free (tocfilename);\n\n    GString *pagelink;\n    open_xml_document(tocpath->str);\n    g_string_free(tocpath,TRUE);\n    set_xml_root_node((xmlChar*)\"ncx\");\n\n    xmlNodePtr docTitle = xml_get_pointer_to_node((xmlChar*)\"docTitle\",NULL,NULL);\n    xmlretval = NULL;\n    xml_parse_children_of_node(docTitle,(xmlChar*)\"text\",NULL,NULL);\n\n    while (epub_document->docTitle == NULL && xmlretval != NULL) {\n        epub_document->docTitle = (gchar*)xml_get_data_from_node(xmlretval,XML_KEYWORD,NULL);\n        xmlretval = xmlretval->next;\n    }\n    xmlNodePtr navMap = xml_get_pointer_to_node((xmlChar*)\"navMap\",NULL,NULL);\n    xmlretval = NULL;\n    xml_parse_children_of_node(navMap,(xmlChar*)\"navPoint\",NULL,NULL);\n\n    xmlNodePtr navPoint = xmlretval;\n\n    while(navPoint != NULL) {\n\n        if ( !xmlStrcmp(navPoint->name,(xmlChar*)\"navPoint\")) {\n            xmlretval = NULL;\n            xml_parse_children_of_node(navPoint,(xmlChar*)\"navLabel\",NULL,NULL);\n            xmlNodePtr navLabel = xmlretval;\n            xmlretval = NULL;\n            gchar *fragment=NULL,*end=NULL;\n            GString *uri = NULL;\n\n            xml_parse_children_of_node(navLabel,(xmlChar*)\"text\",NULL,NULL);\n            linknode *newnode = g_new0(linknode,1);\n            newnode->linktext = NULL;\n            while (newnode->linktext == NULL) {\n                newnode->linktext = (gchar*)xml_get_data_from_node(xmlretval,XML_KEYWORD,NULL);\n                xmlretval = xmlretval->next;\n            }\n            xmlretval = NULL;\n            xml_parse_children_of_node(navPoint,(xmlChar*)\"content\",NULL,NULL);\n            pagelink = g_string_new(epub_document->documentdir);\n            newnode->pagelink = (gchar*)xml_get_data_from_node(xmlretval,XML_ATTRIBUTE,(xmlChar*)\"src\");\n            g_string_append_printf(pagelink,\"/%s\",newnode->pagelink);\n            xmlFree(newnode->pagelink);\n\n            gchar *escaped = g_strdup(pagelink->str);\n\n            //unescaping any special characters\n            pagelink->str = g_uri_unescape_string (escaped,NULL);\n            g_free(escaped);\n\n            if ((end = g_strrstr(pagelink->str,\"#\")) != NULL) {\n                fragment = g_strdup(g_strrstr(pagelink->str,\"#\"));\n                *end = '\\0';\n            }\n            uri = g_string_new(g_filename_to_uri(pagelink->str,NULL,NULL));\n            g_string_free(pagelink,TRUE);\n\n            if (fragment) {\n                g_string_append(uri,fragment);\n            }\n\n            newnode->pagelink = g_strdup(uri->str);\n            g_string_free(uri,TRUE);\n            index = g_list_prepend(index,newnode);\n        }\n\n        navPoint = navPoint->next;\n\n    }\n\n    xml_free_doc();\n\n    return g_list_reverse(index);\n}\n\nstatic EvDocumentInfo*\nepub_document_get_info(EvDocument *document)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document);\n    GError *error = NULL ;\n    gchar* infofile ;\n    xmlNodePtr metanode ;\n    GString* buffer ;\n\n    GString* containerpath = g_string_new(epub_document->tmp_archive_dir);\n    g_string_append_printf(containerpath,\"/META-INF/container.xml\");\n    gchar* containeruri = g_filename_to_uri(containerpath->str,NULL,&error);\n    g_string_free (containerpath, TRUE);\n    if ( error )\n    {\n        return NULL ;\n    }\n\n    gchar* uri = get_uri_to_content (containeruri,&error,epub_document);\n    g_free (containeruri);\n    if ( error )\n    {\n        return NULL ;\n    }\n\n    EvDocumentInfo* epubinfo = g_new0 (EvDocumentInfo, 1);\n\n    epubinfo->fields_mask = EV_DOCUMENT_INFO_TITLE |\n                EV_DOCUMENT_INFO_FORMAT |\n                EV_DOCUMENT_INFO_AUTHOR |\n                EV_DOCUMENT_INFO_SUBJECT |\n                EV_DOCUMENT_INFO_KEYWORDS |\n                EV_DOCUMENT_INFO_LAYOUT |\n                EV_DOCUMENT_INFO_CREATOR |\n                EV_DOCUMENT_INFO_LINEARIZED |\n                EV_DOCUMENT_INFO_PERMISSIONS |\n                EV_DOCUMENT_INFO_N_PAGES ;\n\n    infofile = g_filename_from_uri(uri,NULL,&error);\n    g_free (uri);\n    if ( error )\n    {\n        return epubinfo;\n    }\n\n    open_xml_document(infofile);\n    g_free (infofile);\n\n    set_xml_root_node((xmlChar*)\"package\");\n\n    metanode = xml_get_pointer_to_node((xmlChar*)\"title\",NULL,NULL);\n    if ( metanode == NULL )\n        epubinfo->title = NULL ;\n    else\n        epubinfo->title = (char*)xml_get_data_from_node(metanode,XML_KEYWORD,NULL);\n\n    metanode = xml_get_pointer_to_node((xmlChar*)\"creator\",NULL,NULL);\n    if ( metanode == NULL )\n        epubinfo->author = g_strdup(\"unknown\");\n    else\n        epubinfo->author = (char*)xml_get_data_from_node(metanode,XML_KEYWORD,NULL);\n\n    metanode = xml_get_pointer_to_node((xmlChar*)\"subject\",NULL,NULL);\n    if ( metanode == NULL )\n        epubinfo->subject = g_strdup(\"unknown\");\n    else\n        epubinfo->subject = (char*)xml_get_data_from_node(metanode,XML_KEYWORD,NULL);\n\n    buffer = g_string_new((gchar*)xml_get_data_from_node (xmlroot,XML_ATTRIBUTE,(xmlChar*)\"version\"));\n    g_string_prepend(buffer,\"epub \");\n    epubinfo->format = g_string_free(buffer,FALSE);\n\n    /*FIXME: Add more of these as you write the corresponding modules*/\n\n    epubinfo->layout = EV_DOCUMENT_LAYOUT_SINGLE_PAGE;\n\n    metanode = xml_get_pointer_to_node((xmlChar*)\"publisher\",NULL,NULL);\n    if ( metanode == NULL )\n        epubinfo->creator = g_strdup(\"unknown\");\n    else\n        epubinfo->creator = (char*)xml_get_data_from_node(metanode,XML_KEYWORD,NULL);\n\n    /* number of pages */\n    epubinfo->n_pages = epub_document_get_n_pages(document);\n\n    /*Copying*/\n    epubinfo->permissions = EV_DOCUMENT_PERMISSIONS_OK_TO_COPY;\n    /*TODO : Add a function to get date*/\n\n    if (xmldocument)\n        xml_free_doc();\n    return epubinfo ;\n}\n\nstatic EvPage*\nepub_document_get_page(EvDocument *document,\n                       gint index)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document);\n    EvPage* page = ev_page_new(index);\n    contentListNode *listptr = g_list_nth_data (epub_document->contentList,index);\n    page->backend_page = g_strdup(listptr->value);\n    return page ;\n}\n\nstatic void\nchange_to_night_sheet(contentListNode *nodedata,gpointer user_data)\n{\n    gchar *filename = g_filename_from_uri(nodedata->value,NULL,NULL);\n    open_xml_document(filename);\n    set_xml_root_node(NULL);\n    xmlNodePtr head =xml_get_pointer_to_node((xmlChar*)\"head\",NULL,NULL);\n    gchar *class = NULL;\n    xmlretval = NULL;\n    xml_parse_children_of_node(head,(xmlChar*)\"link\",(xmlChar*)\"rel\",(xmlChar*)\"stylesheet\");\n\n    xmlNodePtr day = xmlretval;\n    if ( (class = (gchar*)xml_get_data_from_node(day,XML_ATTRIBUTE,(xmlChar*)\"class\")) == NULL) {\n        xmlSetProp(day,(xmlChar*)\"class\",(xmlChar*)\"day\");\n    }\n    g_free(class);\n    xmlSetProp(day,(xmlChar*)\"rel\",(xmlChar*)\"alternate stylesheet\");\n    xmlretval = NULL;\n    xml_parse_children_of_node(head,(xmlChar*)\"link\",(xmlChar*)\"class\",(xmlChar*)\"night\");\n    xmlSetProp(xmlretval,(xmlChar*)\"rel\",(xmlChar*)\"stylesheet\");\n    xmlSaveFormatFile (filename, xmldocument, 0);\n    xml_free_doc();\n    g_free(filename);\n}\n\nstatic void\nchange_to_day_sheet(contentListNode *nodedata,gpointer user_data)\n{\n    gchar *filename = g_filename_from_uri(nodedata->value,NULL,NULL);\n    open_xml_document(filename);\n    set_xml_root_node(NULL);\n    xmlNodePtr head =xml_get_pointer_to_node((xmlChar*)\"head\",NULL,NULL);\n\n    xmlretval = NULL;\n    xml_parse_children_of_node(head,(xmlChar*)\"link\",(xmlChar*)\"rel\",(xmlChar*)\"stylesheet\");\n\n    xmlNodePtr day = xmlretval;\n    xmlSetProp(day,(xmlChar*)\"rel\",(xmlChar*)\"alternate stylesheet\");\n\n    xmlretval = NULL;\n    xml_parse_children_of_node(head,(xmlChar*)\"link\",(xmlChar*)\"class\",(xmlChar*)\"day\");\n    xmlSetProp(xmlretval,(xmlChar*)\"rel\",(xmlChar*)\"stylesheet\");\n    xmlSaveFormatFile (filename, xmldocument, 0);\n    xml_free_doc();\n    g_free(filename);\n}\n\nstatic gchar*\nepub_document_get_alternate_stylesheet(gchar *docuri)\n{\n    gchar *filename = g_filename_from_uri(docuri,NULL,NULL);\n    open_xml_document(filename);\n    g_free(filename);\n\n    set_xml_root_node(NULL);\n\n    xmlNodePtr head= xml_get_pointer_to_node((xmlChar*)\"head\",NULL,NULL);\n\n    xmlretval = NULL;\n\n    xml_parse_children_of_node(head,(xmlChar*)\"link\",(xmlChar*)\"class\",(xmlChar*)\"night\");\n\n    if (xmlretval != NULL) {\n        return (gchar*)xml_get_data_from_node(xmlretval,XML_ATTRIBUTE,(xmlChar*)\"href\");\n    }\n    xml_free_doc();\n    return NULL;\n}\n\nstatic void\nadd_night_sheet(contentListNode *listdata,gchar *sheet)\n{\n    gchar *sheeturi = g_filename_to_uri(sheet,NULL,NULL);\n    open_xml_document(listdata->value);\n\n    set_xml_root_node(NULL);\n    xmlNodePtr head = xml_get_pointer_to_node((xmlChar*)\"head\",NULL,NULL);\n\n    xmlNodePtr link = xmlNewTextChild (head, NULL, (xmlChar*) \"link\", NULL);\n    xmlNewProp (link, (xmlChar*) \"href\", (xmlChar*) sheeturi);\n    xmlNewProp (link, (xmlChar*) \"rel\", (xmlChar*) \"alternate stylesheet\");\n    xmlNewProp (link, (xmlChar*) \"class\", (xmlChar*) \"night\");\n\n    xmlSaveFormatFile (listdata->value, xmldocument, 0);\n    xml_free_doc();\n    g_free(sheeturi);\n}\n\nstatic void\nepub_document_check_add_night_sheet(EvDocument *document)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document);\n\n    g_return_if_fail(EPUB_IS_DOCUMENT(epub_document));\n\n    /*\n     * We'll only check the first page for a supplied night mode stylesheet.\n     * Odds are, if this one has it, all others have it too.\n     */\n    contentListNode *node = epub_document->contentList->data;\n    gchar* stylesheetfilename = epub_document_get_alternate_stylesheet((gchar*)node->value) ;\n\n    if (stylesheetfilename == NULL) {\n        gchar *style = \"body {color:rgb(255,255,255);\\\n                        background-color:rgb(0,0,0);\\\n                        text-align:justify;\\\n                        line-spacing:1.8;\\\n                        margin-top:0px;\\\n                        margin-bottom:4px;\\\n                        margin-right:50px;\\\n                        margin-left:50px;\\\n                        text-indent:3em;}\\\n                        h1, h2, h3, h4, h5, h6\\\n                        {color:white;\\\n                        text-align:center;\\\n                        font-style:italic;\\\n                        font-weight:bold;}\";\n\n        gchar *csspath = g_strdup_printf(\"%s/atrilnightstyle.css\",epub_document->documentdir);\n\n        GFile *styles = g_file_new_for_path (csspath);\n        GOutputStream *outstream = (GOutputStream*)g_file_create(styles,G_FILE_CREATE_PRIVATE,NULL,NULL);\n        if ( g_output_stream_write((GOutputStream*)outstream,style,strlen(style),NULL,NULL) == -1 )\n        {\n            return ;\n        }\n        g_output_stream_close((GOutputStream*)outstream,NULL,NULL);\n        g_object_unref(styles) ;\n        g_object_unref(outstream) ;\n        //add this stylesheet to each document, for later.\n        g_list_foreach(epub_document->contentList,(GFunc)add_night_sheet,csspath);\n        g_free(csspath);\n    }\n    g_free(stylesheetfilename);\n}\n\nstatic void\nepub_document_toggle_night_mode(EvDocument *document,gboolean night)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document);\n\n    g_return_if_fail(EPUB_IS_DOCUMENT(epub_document));\n    if (night)\n        g_list_foreach(epub_document->contentList,(GFunc)change_to_night_sheet,NULL);\n    else\n        g_list_foreach(epub_document->contentList,(GFunc)change_to_day_sheet,NULL);\n}\n\nstatic gchar*\nepub_document_set_document_title(gchar *containeruri)\n{\n    open_xml_document(containeruri);\n    gchar *doctitle;\n    set_xml_root_node(NULL);\n\n    xmlNodePtr title = xml_get_pointer_to_node((xmlChar*)\"title\",NULL,NULL);\n\n    doctitle = (gchar*)xml_get_data_from_node(title, XML_KEYWORD, NULL);\n    xml_free_doc();\n\n    return doctitle;\n}\n\nstatic void\npage_set_function(linknode *Link, GList *contentList)\n{\n    GList *listiter = contentList;\n    contentListNode *pagedata;\n\n    guint flag=0;\n    while (!flag) {\n        pagedata = listiter->data;\n        if (link_present_on_page(Link->pagelink, pagedata->value)) {\n            flag=1;\n            Link->page = pagedata->index - 1;\n        }\n        listiter = listiter->next;\n    }\n\n    if (Link->children) {\n        g_list_foreach(Link->children,(GFunc)page_set_function,contentList);\n    }\n}\n\nstatic void\nepub_document_set_index_pages(GList *index,GList *contentList)\n{\n    g_return_if_fail (index != NULL);\n    g_return_if_fail (contentList != NULL);\n\n    g_list_foreach(index,(GFunc)page_set_function,contentList);\n}\n\nstatic void\nadd_mathjax_script_node_to_file(gchar *filename, gchar *data)\n{\n    xmlDocPtr mathdocument = xmlParseFile (filename);\n    xmlNodePtr mathroot = xmlDocGetRootElement(mathdocument);\n\n    if (mathroot == NULL)\n        return;\n\n    xmlNodePtr head = mathroot->children;\n\n    while(head != NULL) {\n        if (!xmlStrcmp(head->name,(xmlChar*)\"head\")) {\n            break;\n        }\n        head = head->next;\n    }\n\n    if (xmlStrcmp(head->name,(xmlChar*)\"head\")) {\n        return ;\n    }\n\n    xmlNodePtr script = xmlNewTextChild (head,NULL,(xmlChar*)\"script\",(xmlChar*)\"\");\n    xmlNewProp(script,(xmlChar*)\"type\",(xmlChar*)\"text/javascript\");\n    xmlNewProp(script,(xmlChar*)\"src\",(xmlChar*)data);\n\n    xmlSaveFormatFile(filename, mathdocument, 0);\n    xmlFreeDoc (mathdocument);\n}\n\nstatic void\nepub_document_add_mathJax(gchar* containeruri,gchar* documentdir)\n{\n    gchar *containerfilename= g_filename_from_uri(containeruri,NULL,NULL);\n    GString *mathjaxdir = g_string_new(\"/usr/share/javascript/mathjax\");\n\n    gchar *mathjaxref = g_filename_to_uri(mathjaxdir->str,NULL,NULL);\n    gchar *nodedata = g_strdup_printf(\"%s/MathJax.js?config=TeX-AMS-MML_SVG\",mathjaxref);\n\n    open_xml_document(containerfilename);\n    set_xml_root_node(NULL);\n    xmlNodePtr manifest = xml_get_pointer_to_node((xmlChar*)\"manifest\",NULL,NULL);\n\n    xmlNodePtr item = manifest->xmlChildrenNode;\n\n    while (item != NULL) {\n        if (xmlStrcmp(item->name,(xmlChar*)\"item\")) {\n            item = item->next;\n            continue;\n        }\n\n        xmlChar *mathml = xml_get_data_from_node(item,XML_ATTRIBUTE, (xmlChar*)\"properties\");\n\n        if (mathml != NULL &&\n            !xmlStrcmp(mathml, (xmlChar*)\"mathml\") ) {\n            gchar *href = (gchar*)xml_get_data_from_node(item, XML_ATTRIBUTE, (xmlChar*)\"href\");\n            gchar *filename = g_strdup_printf(\"%s/%s\",documentdir,href);\n\n            add_mathjax_script_node_to_file(filename,nodedata);\n            g_free(href);\n            g_free(filename);\n        }\n        g_free(mathml);\n        item = item->next;\n    }\n    xml_free_doc();\n    g_free(mathjaxref);\n    g_free(containerfilename);\n    g_free(nodedata);\n    g_string_free(mathjaxdir,TRUE);\n}\n\nstatic gboolean\nepub_document_load (EvDocument* document,\n                    const char* uri,\n                    GError**    error)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document);\n    GError *err = NULL;\n\n    if ( check_mime_type (uri, &err) == FALSE )\n    {\n        /*Error would've been set by the function*/\n        g_propagate_error(error,err);\n        return FALSE;\n    }\n\n    extract_epub_from_container (uri,epub_document,&err);\n\n    if ( err )\n    {\n        g_propagate_error( error,err );\n        return FALSE;\n    }\n\n    /*FIXME : can this be different, ever?*/\n    GString *containerpath = g_string_new(epub_document->tmp_archive_dir);\n    g_string_append_printf(containerpath,\"/META-INF/container.xml\");\n    gchar *containeruri = g_filename_to_uri(containerpath->str,NULL,&err);\n    g_string_free (containerpath, TRUE);\n\n    if ( err )\n    {\n        g_propagate_error(error,err);\n        return FALSE;\n    }\n\n    gchar *contentOpfUri = get_uri_to_content (containeruri,&err,epub_document);\n    g_free (containeruri);\n\n    if ( contentOpfUri == NULL )\n    {\n        g_propagate_error(error,err);\n        return FALSE;\n    }\n\n    epub_document->docTitle = epub_document_set_document_title(contentOpfUri);\n    epub_document->index = setup_document_index(epub_document,contentOpfUri);\n\n    epub_document->contentList = setup_document_content_list (contentOpfUri,&err,epub_document->documentdir);\n\n    if (epub_document->index != NULL && epub_document->contentList != NULL)\n        epub_document_set_index_pages(epub_document->index, epub_document->contentList);\n\n    epub_document_add_mathJax(contentOpfUri,epub_document->documentdir);\n    g_free (contentOpfUri);\n\n    if ( epub_document->contentList == NULL )\n    {\n        g_propagate_error(error,err);\n        return FALSE;\n    }\n\n    return TRUE;\n}\n\nstatic void\nepub_document_init (EpubDocument *epub_document)\n{\n    epub_document->archivename = NULL ;\n    epub_document->tmp_archive_dir = NULL ;\n    epub_document->contentList = NULL ;\n    epub_document->documentdir = NULL;\n    epub_document->index = NULL;\n    epub_document->docTitle = NULL;\n}\n\nstatic void\nepub_document_finalize (GObject *object)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT (object);\n\n    if (epub_document->epubDocument != NULL) {\n        if (epub_remove_temporary_dir (epub_document->tmp_archive_dir) == -1)\n            g_warning (_(\"There was an error deleting \u201c%s\u201d.\"),\n                       epub_document->tmp_archive_dir);\n    }\n\n    if ( epub_document->contentList ) {\n            g_list_free_full(epub_document->contentList,(GDestroyNotify)free_tree_nodes);\n            epub_document->contentList = NULL;\n    }\n\n    if (epub_document->index) {\n        g_list_free_full(epub_document->index,(GDestroyNotify)free_link_nodes);\n        epub_document->index = NULL;\n    }\n\n    if ( epub_document->tmp_archive_dir) {\n        g_free (epub_document->tmp_archive_dir);\n        epub_document->tmp_archive_dir = NULL;\n    }\n\n    if (epub_document->docTitle) {\n        g_free(epub_document->docTitle);\n        epub_document->docTitle = NULL;\n    }\n    if ( epub_document->archivename) {\n        g_free (epub_document->archivename);\n        epub_document->archivename = NULL;\n    }\n    if ( epub_document->documentdir) {\n        g_free (epub_document->documentdir);\n        epub_document->documentdir = NULL;\n    }\n    G_OBJECT_CLASS (epub_document_parent_class)->finalize (object);\n}\n\nstatic void\nepub_document_class_init (EpubDocumentClass *klass)\n{\n    GObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n    EvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\n    gobject_class->finalize = epub_document_finalize;\n    ev_document_class->load = epub_document_load;\n    ev_document_class->save = epub_document_save;\n    ev_document_class->get_n_pages = epub_document_get_n_pages;\n    ev_document_class->get_info = epub_document_get_info;\n    ev_document_class->get_page = epub_document_get_page;\n    ev_document_class->toggle_night_mode = epub_document_toggle_night_mode;\n    ev_document_class->check_add_night_sheet = epub_document_check_add_night_sheet;\n}\n"], "fixing_code": ["/* this file is part of atril, a mate document viewer\n *\n *  Copyright (C) 2014 Avishkar Gupta\n *\n *  Author:\n *   Avishkar Gupta <avishkar.gupta.delhi@gmail.com>\n *\n * Atril is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * Atril is distributed in the hope that it will be useful, but\n * WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.\n */\n\n#include \"epub-document.h\"\n#include \"ev-file-helpers.h\"\n#include \"unzip.h\"\n#include \"ev-document-thumbnails.h\"\n#include \"ev-document-find.h\"\n#include \"ev-backends-manager.h\"\n#include \"ev-document-links.h\"\n#include \"ev-document-misc.h\"\n#include <libxml/parser.h>\n#include <libxml/xmlmemory.h>\n#include <libxml/HTMLparser.h>\n\n#include <config.h>\n#include <glib/gi18n-lib.h>\n#include <glib/gstdio.h>\n\n#include <gtk/gtk.h>\n\n/*For strcasestr(),strstr()*/\n#include <string.h>\n\ntypedef enum _xmlParseReturnType\n{\n    XML_ATTRIBUTE,\n    XML_KEYWORD\n}xmlParseReturnType;\n\ntypedef struct _contentListNode {\n    gchar* key ;\n    gchar* value ;\n    gint index ;\n}contentListNode;\n\ntypedef struct _linknode {\n    gchar *pagelink;\n    GList *children;\n    gchar *linktext;\n    guint page;\n}linknode;\n\ntypedef struct _EpubDocumentClass EpubDocumentClass;\n\nstruct _EpubDocumentClass\n{\n    EvDocumentClass parent_class;\n};\n\nstruct _EpubDocument\n{\n    EvDocument parent_instance;\n    /*Stores the path to the source archive*/\n    gchar* archivename ;\n    /*Stores the path of the directory where we unzipped the epub*/\n    gchar* tmp_archive_dir ;\n    /*Stores the contentlist in a sorted manner*/\n    GList* contentList ;\n    /* A variable to hold our epubDocument for unzipping*/\n    unzFile epubDocument ;\n    /*The (sub)directory that actually houses the document*/\n    gchar* documentdir;\n    /*Stores the table of contents*/\n    GList *index;\n    /*Document title, for the sidebar links*/\n    gchar *docTitle;\n};\n\nstatic void       epub_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface);\nstatic void       epub_document_document_find_iface_init       (EvDocumentFindInterface       *iface);\nstatic void       epub_document_document_links_iface_init      (EvDocumentLinksInterface      *iface);\n\nEV_BACKEND_REGISTER_WITH_CODE (EpubDocument, epub_document,\n    {\n        EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_THUMBNAILS,\n                                        epub_document_document_thumbnails_iface_init);\n        EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_FIND,\n                                        epub_document_document_find_iface_init);\n        EV_BACKEND_IMPLEMENT_INTERFACE (EV_TYPE_DOCUMENT_LINKS,\n                                        epub_document_document_links_iface_init);\n\n    } );\n\nstatic void\nepub_document_thumbnails_get_dimensions (EvDocumentThumbnails *document,\n                                         EvRenderContext      *rc,\n                                         gint                 *width,\n                                         gint                 *height)\n{\n    gdouble page_width, page_height;\n\n    page_width = 800;\n    page_height = 1080;\n\n    *width = MAX ((gint)(page_width * rc->scale + 0.5), 1);\n    *height = MAX ((gint)(page_height * rc->scale + 0.5), 1);\n}\n\nstatic GdkPixbuf *\nepub_document_thumbnails_get_thumbnail (EvDocumentThumbnails *document,\n                                        EvRenderContext      *rc,\n                                        gboolean              border)\n{\n    cairo_surface_t *webpage;\n    GdkPixbuf *thumbnailpix = NULL ;\n    gint width,height;\n    epub_document_thumbnails_get_dimensions (document, rc, &width, &height);\n    webpage = ev_document_misc_surface_rotate_and_scale (rc->page->backend_page,\n                                                         width, height, 0);\n    thumbnailpix = ev_document_misc_pixbuf_from_surface (webpage);\n    return thumbnailpix;\n}\n\nstatic gboolean\nin_tag(const char* found)\n{\n    const char* bracket = found ;\n\n    /* Since the dump started with the body tag, the '<' will be the first\n     * character in the haystack.\n     */\n    while (*bracket != '<') {\n        bracket--;\n        if (*bracket == '>') {\n            /*We encounted a close brace before an open*/\n            return FALSE ;\n        }\n    }\n\n    return TRUE;\n}\n\nstatic int\nget_substr_count(const char * haystack,const char *needle,gboolean case_sensitive)\n{\n    const char* tmp = haystack ;\n    char* (*string_compare_function)(const char*,const char*);\n    int count=0;\n    if (case_sensitive) {\n        string_compare_function = strstr ;\n    }\n    else {\n        string_compare_function = strcasestr;\n    }\n\n    while ((tmp=string_compare_function(tmp,needle))) {\n        if (!in_tag(tmp)) {\n            count++;\n        }\n        tmp = tmp + strlen(needle);\n    }\n\n    return count;\n}\n\nstatic guint\nepub_document_check_hits(EvDocumentFind *document_find,\n                         EvPage         *page,\n                         const gchar    *text,\n                         gboolean        case_sensitive)\n{\n    gchar *filepath = g_filename_from_uri((gchar*)page->backend_page,NULL,NULL);\n    htmlDocPtr htmldoc =  xmlParseFile(filepath);\n    if (htmldoc == NULL) {\n        g_free(filepath);\n        return 0;\n    }\n    htmlNodePtr htmltag = xmlDocGetRootElement(htmldoc);\n    if (htmltag == NULL) {\n        g_free(filepath);\n        xmlFreeDoc (htmldoc);\n        return 0;\n    }\n\n    int count=0;\n    htmlNodePtr bodytag = htmltag->xmlChildrenNode;\n\n    while ( xmlStrcmp(bodytag->name,(xmlChar*)\"body\") ) {\n        bodytag = bodytag->next;\n    }\n\n    xmlBufferPtr bodybuffer = xmlBufferCreate();\n    xmlNodeDump(bodybuffer,htmldoc,bodytag,0,1);\n\n    count = get_substr_count((char*)bodybuffer->content,text,case_sensitive);\n\n    xmlBufferFree(bodybuffer);\n    xmlFreeDoc(htmldoc);\n    g_free (filepath);\n\n    return count;\n}\n\nstatic gboolean\nepub_document_links_has_document_links(EvDocumentLinks *document_links)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document_links);\n\n    g_return_val_if_fail(EPUB_IS_DOCUMENT(epub_document), FALSE);\n\n    if (!epub_document->index)\n        return FALSE;\n\n    return TRUE;\n}\n\ntypedef struct _LinksCBStruct {\n    GtkTreeModel *model;\n    GtkTreeIter  *parent;\n}LinksCBStruct;\n\nstatic void\nepub_document_make_tree_entry(linknode* ListData,LinksCBStruct* UserData)\n{\n    GtkTreeIter tree_iter;\n    EvLink *link = NULL;\n    gboolean expand;\n    char *title_markup;\n\n    if (ListData->children) {\n        expand=TRUE;\n    }\n    else {\n        expand=FALSE;\n    }\n\n    EvLinkDest *ev_dest = NULL;\n    EvLinkAction *ev_action;\n\n    /* We shall use a EV_LINK_DEST_TYPE_PAGE for page links,\n     * and a EV_LINK_DEST_TYPE_HLINK(custom) for refs on a page of type url#label\n     * because we need both dest and page label for this.\n     */\n\n    if (g_strrstr(ListData->pagelink,\"#\") == NULL) {\n        ev_dest = ev_link_dest_new_page(ListData->page);\n    }\n    else {\n        ev_dest = ev_link_dest_new_hlink((gchar*)ListData->pagelink,ListData->page);\n    }\n\n    ev_action = ev_link_action_new_dest (ev_dest);\n\n    link = ev_link_new((gchar*)ListData->linktext,ev_action);\n\n    gtk_tree_store_append (GTK_TREE_STORE (UserData->model), &tree_iter,(UserData->parent));\n    title_markup = g_markup_escape_text ((gchar*)ListData->linktext, -1);\n\n    gtk_tree_store_set (GTK_TREE_STORE (UserData->model), &tree_iter,\n                        EV_DOCUMENT_LINKS_COLUMN_MARKUP, title_markup,\n                        EV_DOCUMENT_LINKS_COLUMN_LINK, link,\n                        EV_DOCUMENT_LINKS_COLUMN_EXPAND, expand,\n                        -1);\n\n    if (ListData->children) {\n        LinksCBStruct cbstruct;\n        cbstruct.parent = &tree_iter;\n        cbstruct.model = UserData->model;\n        g_list_foreach (ListData->children,(GFunc)epub_document_make_tree_entry,&cbstruct);\n    }\n\n    g_free (title_markup);\n    g_object_unref (link);\n}\n\nstatic GtkTreeModel *\nepub_document_links_get_links_model(EvDocumentLinks *document_links)\n{\n    GtkTreeModel *model = NULL;\n\n    g_return_val_if_fail (EPUB_IS_DOCUMENT (document_links), NULL);\n\n    EpubDocument *epub_document = EPUB_DOCUMENT(document_links);\n\n    model = (GtkTreeModel*) gtk_tree_store_new (EV_DOCUMENT_LINKS_COLUMN_NUM_COLUMNS,\n                                                G_TYPE_STRING,\n                                                G_TYPE_OBJECT,\n                                                G_TYPE_BOOLEAN,\n                                                G_TYPE_STRING);\n\n    LinksCBStruct linkStruct;\n    linkStruct.model = model;\n    EvLink *link = ev_link_new(epub_document->docTitle,\n                               ev_link_action_new_dest(ev_link_dest_new_page(0)));\n    GtkTreeIter parent;\n\n    linkStruct.parent = &parent;\n\n    gtk_tree_store_append (GTK_TREE_STORE (model), &parent,NULL);\n\n    gtk_tree_store_set (GTK_TREE_STORE (model), &parent,\n                        EV_DOCUMENT_LINKS_COLUMN_MARKUP, epub_document->docTitle,\n                        EV_DOCUMENT_LINKS_COLUMN_LINK, link,\n                        EV_DOCUMENT_LINKS_COLUMN_EXPAND, TRUE,\n                        -1);\n\n    g_object_unref(link);\n\n    if (epub_document->index) {\n        g_list_foreach (epub_document->index,(GFunc)epub_document_make_tree_entry,&linkStruct);\n    }\n\n    return model;\n}\n\nstatic EvMappingList *\nepub_document_links_get_links (EvDocumentLinks *document_links,\n                               EvPage          *page)\n{\n    /* TODO\n     * ev_mapping_list_new()\n     */\n    return NULL;\n}\n\nstatic void\nepub_document_document_thumbnails_iface_init (EvDocumentThumbnailsInterface *iface)\n{\n    iface->get_thumbnail = epub_document_thumbnails_get_thumbnail;\n    iface->get_dimensions = epub_document_thumbnails_get_dimensions;\n}\n\nstatic void\nepub_document_document_find_iface_init (EvDocumentFindInterface *iface)\n{\n    iface->check_for_hits = epub_document_check_hits;\n}\n\nstatic void\nepub_document_document_links_iface_init(EvDocumentLinksInterface *iface)\n{\n    iface->has_document_links = epub_document_links_has_document_links;\n    iface->get_links_model = epub_document_links_get_links_model;\n    iface->get_links = epub_document_links_get_links;\n}\n\nstatic gboolean\nepub_document_save (EvDocument *document,\n                    const char *uri,\n                    GError    **error)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT (document);\n\n    gchar *source_uri = g_filename_to_uri (epub_document->archivename, NULL, error);\n    if (source_uri == NULL)\n        return FALSE;\n\n    return ev_xfer_uri_simple (source_uri, uri, error);\n}\n\nstatic int\nepub_document_get_n_pages (EvDocument *document)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT (document);\n\n        if (epub_document-> contentList == NULL)\n            return 0;\n\n    return g_list_length(epub_document->contentList);\n}\n\n/**\n * epub_remove_temporary_dir : Removes a directory recursively.\n * This function is same as comics_remove_temporary_dir\n * Returns:\n * 0 if it was successfully deleted,\n * -1 if an error occurred\n */\nstatic int\nepub_remove_temporary_dir (gchar *path_name)\n{\n    GDir  *content_dir;\n    const gchar *filename;\n    gchar *filename_with_path;\n\n    if (g_file_test (path_name, G_FILE_TEST_IS_DIR)) {\n        content_dir = g_dir_open  (path_name, 0, NULL);\n        filename  = g_dir_read_name (content_dir);\n        while (filename) {\n            filename_with_path =\n                g_build_filename (path_name,\n                                  filename, NULL);\n            epub_remove_temporary_dir (filename_with_path);\n            g_free (filename_with_path);\n            filename = g_dir_read_name (content_dir);\n        }\n        g_dir_close (content_dir);\n    }\n    /* Note from g_remove() documentation: on Windows, it is in general not\n     * possible to remove a file that is open to some process, or mapped\n     * into memory.*/\n    return (g_remove (path_name));\n}\n\nstatic gboolean\ncheck_mime_type             (const gchar* uri,\n                             GError** error);\n\nstatic gboolean\nopen_xml_document           (const gchar* filename);\n\nstatic gboolean\nset_xml_root_node           (xmlChar* rootname);\n\nstatic xmlNodePtr\nxml_get_pointer_to_node     (xmlChar* parserfor,\n                             xmlChar* attributename,\n                             xmlChar* attributevalue);\nstatic void\nxml_parse_children_of_node  (xmlNodePtr parent,\n                             xmlChar* parserfor,\n                             xmlChar* attributename,\n                             xmlChar* attributevalue);\n\nstatic gboolean\nxml_check_attribute_value   (xmlNode* node,\n                             xmlChar * attributename,\n                             xmlChar* attributevalue);\n\nstatic xmlChar*\nxml_get_data_from_node      (xmlNodePtr node,\n                             xmlParseReturnType rettype,\n                             xmlChar* attributename);\n\nstatic void\nxml_free_doc                (void);\n\nstatic void\nfree_tree_nodes             (gpointer data);\n\n/*Global variables for XML parsing*/\nstatic xmlDocPtr    xmldocument ;\nstatic xmlNodePtr   xmlroot ;\nstatic xmlNodePtr   xmlretval ;\n\n/*\n**Functions to parse the xml files.\n**Open a XML document for reading\n*/\nstatic gboolean\nopen_xml_document ( const gchar* filename )\n{\n    xmldocument = xmlParseFile(filename);\n\n    if ( xmldocument == NULL )\n    {\n        return FALSE ;\n    }\n    else\n    {\n        return TRUE ;\n    }\n}\n\n/**\n *Check if the root value is same as rootname .\n *if supplied rootvalue = NULL ,just set root to rootnode .\n**/\nstatic gboolean\nset_xml_root_node(xmlChar* rootname)\n{\n    xmlroot = xmlDocGetRootElement(xmldocument);\n\n    if (xmlroot == NULL) {\n\n        xmlFreeDoc(xmldocument);\n        return FALSE;\n    }\n\n    if ( rootname == NULL )\n    {\n        return TRUE ;\n    }\n\n    if ( !xmlStrcmp(xmlroot->name,rootname))\n    {\n        return TRUE ;\n    }\n    else\n    {\n       return FALSE;\n    }\n}\n\nstatic xmlNodePtr\nxml_get_pointer_to_node(xmlChar* parserfor,\n                        xmlChar*  attributename,\n                        xmlChar* attributevalue )\n{\n    xmlNodePtr topchild;\n\n    xmlretval = NULL ;\n\n    if ( !xmlStrcmp( xmlroot->name, parserfor) )\n    {\n        return xmlroot ;\n    }\n\n    topchild = xmlroot->xmlChildrenNode ;\n\n    while ( topchild != NULL )\n    {\n        if ( !xmlStrcmp(topchild->name,parserfor) )\n        {\n            if ( xml_check_attribute_value(topchild,attributename,attributevalue) == TRUE )\n            {\n                 xmlretval = topchild;\n                 return xmlretval;\n            }\n            else\n            {\n                /*No need to parse children node*/\n                topchild = topchild->next ;\n                continue ;\n            }\n        }\n\n        xml_parse_children_of_node(topchild , parserfor, attributename, attributevalue) ;\n\n        topchild = topchild->next ;\n    }\n\n    return xmlretval ;\n}\n\nstatic void\nxml_parse_children_of_node(xmlNodePtr parent,\n                           xmlChar* parserfor,\n                           xmlChar* attributename,\n                           xmlChar* attributevalue )\n{\n    xmlNodePtr child = parent->xmlChildrenNode ;\n\n    while ( child != NULL )\n    {\n        if ( !xmlStrcmp(child->name,parserfor))\n        {\n            if ( xml_check_attribute_value(child,attributename,attributevalue) == TRUE )\n            {\n                 xmlretval = child;\n                 return ;\n            }\n            else\n            {\n                /*No need to parse children node*/\n                child = child->next ;\n                continue ;\n            }\n        }\n\n        /*return already if we have xmlretval set*/\n        if ( xmlretval != NULL )\n        {\n            return ;\n        }\n\n        xml_parse_children_of_node(child,parserfor,attributename,attributevalue) ;\n        child = child->next ;\n    }\n}\n\nstatic void\nxml_free_doc()\n{\n    xmlFreeDoc(xmldocument);\n    xmldocument = NULL;\n}\n\nstatic gboolean\nxml_check_attribute_value(xmlNode* node,\n                          xmlChar * attributename,\n                          xmlChar* attributevalue)\n{\n    xmlChar* attributefromfile ;\n    if ( attributename == NULL || attributevalue == NULL )\n    {\n         return TRUE ;\n    }\n    else if ( !xmlStrcmp(( attributefromfile = xmlGetProp(node,attributename)),\n                           attributevalue) )\n    {\n        xmlFree(attributefromfile);\n        return TRUE ;\n    }\n    xmlFree(attributefromfile);\n    return FALSE ;\n}\n\nstatic xmlChar*\nxml_get_data_from_node(xmlNodePtr node,\n                       xmlParseReturnType rettype,\n                       xmlChar* attributename)\n{\n    xmlChar* datastring ;\n    if ( rettype == XML_ATTRIBUTE )\n       datastring= xmlGetProp(node,attributename);\n    else\n       datastring= xmlNodeListGetString(xmldocument,node->xmlChildrenNode, 1);\n\n    return datastring;\n}\n\nstatic gboolean\ncheck_mime_type(const gchar* uri,GError** error)\n{\n    GError * err = NULL;\n    const gchar* mimeFromFile;\n\n    mimeFromFile = ev_file_get_mime_type(uri, FALSE, &err);\n    if (mimeFromFile)\n    {\n        const gchar* mimetypes[] = {\"application/epub+zip\", \"application/x-booki+zip\", NULL};\n        guint i;\n\n        for (i = 0; i < g_strv_length (mimetypes); i++) {\n           if (strcmp(mimeFromFile, mimetypes[i]) == 0)\n                return TRUE;\n        }\n\n        /* fallback for malformed epub files */\n        if (strcmp (mimeFromFile, \"application/zip\") == 0)\n        {\n            mimeFromFile = ev_file_get_mime_type (uri, TRUE, &err);\n            if (mimeFromFile)\n            {\n                for (i = 0; i < g_strv_length (mimetypes); i++) {\n                    if (g_strcmp0(mimeFromFile, mimetypes[i]) == 0)\n                        return TRUE;\n                }\n\n                /*We didn't find a match*/\n                g_set_error_literal (error,\n                                     EV_DOCUMENT_ERROR,\n                                     EV_DOCUMENT_ERROR_INVALID,\n                                     _(\"Not an ePub document\"));\n\n                return FALSE;\n            }\n        }\n    }\n\n    if (err)\n        g_propagate_error (error, err);\n    else\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"Unknown MIME Type\"));\n\n    return FALSE;\n}\n\nstatic gboolean\nextract_one_file(EpubDocument* epub_document, GFile *tmp_gfile, GError ** error)\n{\n    GFile * outfile ;\n    gsize writesize = 0;\n    GString * gfilepath ;\n    unz_file_info64 info ;\n    gchar* directory;\n    GString* dir_create;\n    GFileOutputStream * outstream ;\n\n    if ( unzOpenCurrentFile(epub_document->epubDocument) != UNZ_OK )\n    {\n            return FALSE ;\n    }\n\n    gboolean result = TRUE;\n\n    gpointer currentfilename = g_malloc0(512);\n    unzGetCurrentFileInfo64(epub_document->epubDocument,&info,currentfilename,512,NULL,0,NULL,0) ;\n    directory = g_strrstr(currentfilename,\"/\") ;\n\n    if ( directory != NULL )\n        directory++;\n\n    gfilepath = g_string_new(epub_document->tmp_archive_dir) ;\n    g_string_append_printf(gfilepath,\"/%s\",(gchar*)currentfilename);\n\n    outfile = g_file_new_for_path (gfilepath->str);\n    g_autofree gchar *rpath = g_file_get_relative_path (tmp_gfile, outfile);\n\n    if (rpath == NULL)\n    {\n        g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"epub file is invalid or corrupt\"));\n        g_critical (\"Invalid filename in Epub container - '%s'\", (gchar *) currentfilename);\n        result = FALSE;\n        goto out;\n    }\n\n    /*if we encounter a directory, make a directory inside our temporary folder.*/\n    if (directory != NULL && *directory == '\\0')\n    {\n        g_mkdir(gfilepath->str,0777);\n        goto out;\n    }\n    else if (directory != NULL && *directory != '\\0' ) {\n        gchar* createdir = currentfilename;\n        /*Since a substring can't be longer than the parent string, allocating space equal to the parent's size should suffice*/\n        gchar *createdirname = g_malloc0(strlen(currentfilename));\n        /* Add the name of the directory and subdirectories,if any to a buffer and then create it */\n        gchar *createdirnametemp = createdirname;\n        while ( createdir != directory ) {\n            (*createdirnametemp) = (*createdir);\n            createdirnametemp++;\n            createdir++;\n        }\n        (*createdirnametemp) = '\\0';\n\n        dir_create = g_string_new(epub_document->tmp_archive_dir);\n        g_string_append_printf(dir_create,\"/%s\",createdirname);\n        g_free(createdirname);\n\n        g_mkdir_with_parents(dir_create->str,0777);\n        g_string_free(dir_create,TRUE);\n    }\n\n    outstream = g_file_create(outfile,G_FILE_CREATE_PRIVATE,NULL,error);\n    gpointer buffer = g_malloc0(512);\n    while ( (writesize = unzReadCurrentFile(epub_document->epubDocument,buffer,512) ) != 0 )\n    {\n        if ( g_output_stream_write((GOutputStream*)outstream,buffer,writesize,NULL,error) == -1 )\n        {\n            result = FALSE;\n            break;\n        }\n    }\n    g_free(buffer);\n    g_output_stream_close((GOutputStream*)outstream,NULL,error);\n    g_object_unref(outstream);\n\nout:\n    g_object_unref(outfile);\n    unzCloseCurrentFile (epub_document->epubDocument) ;\n    g_string_free(gfilepath,TRUE);\n    g_free(currentfilename);\n    return result;\n}\n\nstatic gboolean\nextract_epub_from_container (const gchar* uri,\n                             EpubDocument *epub_document,\n                             GError ** error)\n{\n    GFile *tmp_gfile = NULL;\n    GError *err = NULL;\n    epub_document->archivename = g_filename_from_uri(uri,NULL,error);\n\n    if ( !epub_document->archivename )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not retrieve filename\"));\n        }\n        return FALSE;\n    }\n\n    gchar *epubfilename = g_strrstr(epub_document->archivename,\"/\");\n    if ( *epubfilename == '/' )\n        epubfilename++ ;\n\n    GString *temporary_sub_directory = g_string_new(epubfilename);\n    g_string_append(temporary_sub_directory,\"XXXXXX\") ;\n    epub_document->tmp_archive_dir = ev_mkdtemp(temporary_sub_directory->str, error);\n    g_string_free(temporary_sub_directory, TRUE);\n\n    if (!epub_document->tmp_archive_dir) {\n        return FALSE;\n    }\n\n    epub_document->epubDocument = unzOpen64(epub_document->archivename);\n    if ( epub_document->epubDocument == NULL )\n    {\n        if (err)    {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not open archive\"));\n        }\n        return FALSE;\n    }\n\n    gboolean result = FALSE;\n\n    if ( unzGoToFirstFile(epub_document->epubDocument) != UNZ_OK )\n    {\n        if (err) {\n            g_propagate_error (error, err);\n        }\n        else    {\n            g_set_error_literal (error,\n                         EV_DOCUMENT_ERROR,\n                         EV_DOCUMENT_ERROR_INVALID,\n                         _(\"could not extract archive\"));\n        }\n        goto out;\n    }\n\n    tmp_gfile = g_file_new_for_path (epub_document->tmp_archive_dir);\n    while ( TRUE )\n    {\n        if ( extract_one_file(epub_document, tmp_gfile, &err) == FALSE )\n        {\n            if (err) {\n                g_propagate_error (error, err);\n            }\n            else    {\n                g_set_error_literal (error,\n                             EV_DOCUMENT_ERROR,\n                             EV_DOCUMENT_ERROR_INVALID,\n                             _(\"could not extract archive\"));\n            }\n            goto out;\n        }\n\n        if ( unzGoToNextFile(epub_document->epubDocument) == UNZ_END_OF_LIST_OF_FILE ) {\n            result = TRUE;\n            break;\n        }\n    }\n\nout:\n    g_clear_object (&tmp_gfile);\n    unzClose(epub_document->epubDocument);\n    return result;\n}\n\nstatic gchar*\nget_uri_to_content(const gchar* uri,GError ** error,EpubDocument *epub_document)\n{\n    gchar* tmp_archive_dir = epub_document->tmp_archive_dir;\n    GError *err = NULL ;\n\n    gchar *containerpath = g_filename_from_uri(uri,NULL,&err);\n    if ( !containerpath )\n    {\n        if (err) {\n            g_propagate_error (error,err);\n        }\n        else    {\n            g_set_error_literal (error,\n                                 EV_DOCUMENT_ERROR,\n                                 EV_DOCUMENT_ERROR_INVALID,\n                                 _(\"could not retrieve container file\"));\n        }\n        return NULL ;\n    }\n\n    gboolean result = open_xml_document(containerpath);\n    g_free (containerpath);\n    if ( result == FALSE )\n    {\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"could not open container file\"));\n\n        return NULL ;\n    }\n\n    if ( set_xml_root_node((xmlChar*)\"container\") == FALSE)  {\n\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"container file is corrupt\"));\n        return NULL ;\n    }\n\n    xmlNodePtr rootfileNode = xml_get_pointer_to_node((xmlChar*)\"rootfile\",(xmlChar*)\"media-type\",(xmlChar*)\"application/oebps-package+xml\");\n    if ( rootfileNode == NULL)\n    {\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"epub file is invalid or corrupt\"));\n        return NULL ;\n    }\n\n    xmlChar *relativepath = xml_get_data_from_node(rootfileNode,XML_ATTRIBUTE,(xmlChar*)\"full-path\") ;\n    if ( relativepath == NULL )\n    {\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"epub file is corrupt, no container\"));\n        return NULL ;\n    }\n\n    gchar* documentfolder = g_strrstr((gchar*)relativepath,\"/\");\n    if (documentfolder != NULL) {\n        gchar* copybuffer = (gchar*)relativepath ;\n        gchar* directorybuffer = g_malloc0(sizeof(gchar*)*100);\n        gchar* writer = directorybuffer;\n\n        while(copybuffer != documentfolder) {\n            (*writer) = (*copybuffer);\n            writer++;copybuffer++;\n        }\n        *writer = '\\0';\n\n        GString *documentdir = g_string_new(tmp_archive_dir);\n        g_string_append_printf(documentdir,\"/%s\",directorybuffer);\n        g_free(directorybuffer);\n        epub_document->documentdir = g_string_free(documentdir,FALSE);\n    }\n    else\n    {\n        epub_document->documentdir = g_strdup(tmp_archive_dir);\n    }\n\n    GString *absolutepath = g_string_new(tmp_archive_dir);\n    g_string_append_printf(absolutepath,\"/%s\",relativepath);\n    g_free (relativepath);\n\n    gchar *content_uri = g_filename_to_uri(absolutepath->str,NULL,&err);\n    g_string_free(absolutepath,TRUE);\n    if ( !content_uri )  {\n        if (err) {\n            g_propagate_error (error,err);\n        }\n        else\n        {\n            g_set_error_literal (error,\n                                 EV_DOCUMENT_ERROR,\n                                 EV_DOCUMENT_ERROR_INVALID,\n                                 _(\"could not retrieve container file\"));\n        }\n        return NULL ;\n    }\n    xml_free_doc();\n    return content_uri ;\n}\n\nstatic gboolean\nlink_present_on_page(const gchar* link,const gchar *page_uri)\n{\n    gchar *res;\n    if ((res=g_strrstr(link, page_uri)) != NULL) {\n        return TRUE;\n    }\n    else {\n        return FALSE;\n    }\n}\n\nstatic GList*\nsetup_document_content_list(const gchar* content_uri, GError** error,gchar *documentdir)\n{\n    GError *err = NULL;\n    gint indexcounter = 1;\n    xmlNodePtr manifest,spine,itemrefptr,itemptr;\n    gboolean errorflag = FALSE;\n\n    if ( open_xml_document(content_uri) == FALSE )\n    {\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"could not parse content manifest\"));\n\n        return FALSE ;\n    }\n    if ( set_xml_root_node((xmlChar*)\"package\") == FALSE)  {\n\n        g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"content file is invalid\"));\n        return FALSE ;\n    }\n\n    if ( ( spine = xml_get_pointer_to_node((xmlChar*)\"spine\",NULL,NULL) )== NULL )\n    {\n         g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"epub file has no spine\"));\n        return FALSE ;\n    }\n\n    if ( ( manifest = xml_get_pointer_to_node((xmlChar*)\"manifest\",NULL,NULL) )== NULL )\n    {\n         g_set_error_literal(error,\n                            EV_DOCUMENT_ERROR,\n                            EV_DOCUMENT_ERROR_INVALID,\n                            _(\"epub file has no manifest\"));\n        return FALSE ;\n    }\n\n    xmlretval = NULL ;\n\n    /*Get first instance of itemref from the spine*/\n    xml_parse_children_of_node(spine,(xmlChar*)\"itemref\",NULL,NULL);\n\n    if ( xmlretval != NULL )\n        itemrefptr = xmlretval ;\n    else\n    {\n        errorflag=TRUE;\n    }\n\n    GList *newlist = NULL;\n\n    /*Parse the spine for remaining itemrefs*/\n    do\n    {\n        /*for the first time that we enter the loop, if errorflag is set we break*/\n        if ( errorflag )\n        {\n            break;\n        }\n        if ( xmlStrcmp(itemrefptr->name,(xmlChar*)\"itemref\") == 0)\n        {\n            contentListNode *newnode = g_malloc0(sizeof(newnode));\n            newnode->key = (gchar*)xml_get_data_from_node(itemrefptr,XML_ATTRIBUTE,(xmlChar*)\"idref\");\n            if ( newnode->key == NULL )\n            {\n                g_free (newnode);\n                errorflag = TRUE;\n                break;\n            }\n            xmlretval=NULL ;\n            xml_parse_children_of_node(manifest,(xmlChar*)\"item\",(xmlChar*)\"id\",(xmlChar*)newnode->key);\n\n            if ( xmlretval != NULL )\n            {\n                itemptr = xmlretval ;\n            }\n            else\n            {\n                g_free (newnode->key);\n                g_free (newnode);\n                errorflag = TRUE;\n                break;\n            }\n\n            GString* absolutepath = g_string_new(documentdir);\n            gchar *relativepath = (gchar*)xml_get_data_from_node(itemptr,XML_ATTRIBUTE,(xmlChar*)\"href\");\n            g_string_append_printf(absolutepath,\"/%s\",relativepath);\n            g_free (relativepath);\n\n            newnode->value = g_filename_to_uri(absolutepath->str,NULL,&err);\n            g_string_free(absolutepath,TRUE);\n\n            if ( newnode->value == NULL )\n            {\n                g_free (newnode->key);\n                g_free (newnode);\n                errorflag = TRUE;\n                break;\n            }\n\n            newnode->index = indexcounter++ ;\n\n            newlist = g_list_prepend(newlist, newnode);\n        }\n        itemrefptr = itemrefptr->next ;\n    }\n    while ( itemrefptr != NULL );\n\n    if ( errorflag )\n    {\n        if ( err )\n        {\n            g_propagate_error(error,err);\n        }\n        else\n        {\n            g_set_error_literal(error,\n                                EV_DOCUMENT_ERROR,\n                                EV_DOCUMENT_ERROR_INVALID,\n                                _(\"Could not set up document tree for loading, some files missing\"));\n        }\n        /*free any nodes that were set up and return empty*/\n        g_list_free_full(newlist, (GDestroyNotify)free_tree_nodes);\n        return NULL;\n    }\n\n    newlist = g_list_reverse(newlist);\n    xml_free_doc();\n    return newlist;\n\n}\n\n/* Callback function to free the contentlist.*/\nstatic void\nfree_tree_nodes(gpointer data)\n{\n    contentListNode* dataptr = data ;\n    g_free(dataptr->value);\n    g_free(dataptr->key);\n    g_free(dataptr);\n}\n\nstatic void\nfree_link_nodes(gpointer data)\n{\n    linknode* dataptr = data ;\n    g_free(dataptr->pagelink);\n    g_free(dataptr->linktext);\n\n    if (dataptr->children) {\n        g_list_free_full(dataptr->children,(GDestroyNotify)free_link_nodes);\n    }\n    g_free(dataptr);\n}\n\nstatic gchar*\nget_toc_file_name(gchar *containeruri)\n{\n    gchar *containerfilename = g_filename_from_uri(containeruri,NULL,NULL);\n    open_xml_document(containerfilename);\n    g_free (containerfilename);\n\n    set_xml_root_node(NULL);\n\n    xmlNodePtr manifest = xml_get_pointer_to_node((xmlChar*)\"manifest\",NULL,NULL);\n    xmlNodePtr spine = xml_get_pointer_to_node((xmlChar*)\"spine\",NULL,NULL);\n\n    xmlChar *ncx = xml_get_data_from_node(spine,XML_ATTRIBUTE,(xmlChar*)\"toc\");\n\n    /*In an epub3, there is sometimes no toc, and we need to then use the nav file for this.*/\n    if (ncx == NULL) {\n        return NULL;\n    }\n\n    xmlretval = NULL;\n    xml_parse_children_of_node(manifest,(xmlChar*)\"item\",(xmlChar*)\"id\",ncx);\n\n    gchar* tocfilename = (gchar*)xml_get_data_from_node(xmlretval,XML_ATTRIBUTE,(xmlChar*)\"href\");\n    xml_free_doc();\n\n    return tocfilename;\n}\n\nstatic gchar*\nepub_document_get_nav_file(gchar* containeruri)\n{\n    open_xml_document(containeruri);\n    set_xml_root_node(NULL);\n    xmlNodePtr manifest = xml_get_pointer_to_node((xmlChar*)\"manifest\",NULL,NULL);\n    xmlretval = NULL;\n    xml_parse_children_of_node(manifest,(xmlChar*)\"item\",(xmlChar*)\"properties\",(xmlChar*)\"nav\");\n\n    gchar *uri = (gchar*)xml_get_data_from_node(xmlretval,XML_ATTRIBUTE, (xmlChar*)\"href\");\n\n    xml_free_doc();\n    return uri;\n}\n\nstatic GList*\nget_child_list(xmlNodePtr ol,gchar* documentdir)\n{\n    GList *childlist = NULL;\n    xmlNodePtr li = ol->xmlChildrenNode;\n\n    while (li != NULL) {\n        if (xmlStrcmp(li->name,(xmlChar*)\"li\")) {\n            li = li->next;\n            continue;\n        }\n        xmlNodePtr children = li->xmlChildrenNode;\n        linknode *newlinknode = g_new0(linknode, 1);\n        while (children != NULL) {\n            if ( !xmlStrcmp(children->name,(xmlChar*)\"a\")) {\n                newlinknode->linktext = (gchar*)xml_get_data_from_node(children,XML_KEYWORD,NULL);\n                gchar* filename = (gchar*)xml_get_data_from_node(children,XML_ATTRIBUTE,(xmlChar*)\"href\");\n                gchar *filepath = g_strdup_printf(\"%s/%s\",documentdir,filename);\n                newlinknode->pagelink = g_filename_to_uri(filepath,NULL,NULL);\n                g_free(filename);\n                g_free(filepath);\n                newlinknode->children = NULL;\n                childlist = g_list_prepend(childlist,newlinknode);\n            }\n            else if ( !xmlStrcmp(children->name,(xmlChar*)\"ol\")){\n                newlinknode->children = get_child_list(children,documentdir);\n            }\n\n            children = children->next;\n        }\n\n        li = li->next;\n    }\n\n    return g_list_reverse(childlist);\n}\n\n/* For an epub3 style navfile */\nstatic GList*\nsetup_index_from_navfile(gchar *tocpath)\n{\n    GList *index = NULL;\n    open_xml_document(tocpath);\n    set_xml_root_node(NULL);\n    xmlNodePtr nav = xml_get_pointer_to_node((xmlChar*)\"nav\",(xmlChar*)\"type\",(xmlChar*)\"toc\");\n\n    if (nav == NULL) {\n        xml_free_doc();\n        return NULL;\n    }\n\n    xmlretval=NULL;\n    xml_parse_children_of_node(nav,(xmlChar*)\"ol\", NULL,NULL);\n    gchar *navdirend = g_strrstr(tocpath,\"/\");\n    gchar *navdir = g_malloc0(strlen(tocpath));\n    gchar *reader = tocpath;\n    gchar *writer = navdir;\n\n    while (reader != navdirend) {\n        (*writer) = (*reader) ;\n        writer++;reader++;\n    }\n    index = get_child_list(xmlretval,navdir);\n    g_free(navdir);\n    xml_free_doc();\n    return index;\n}\n\nstatic GList*\nsetup_document_index(EpubDocument *epub_document,gchar *containeruri)\n{\n    GString *tocpath = g_string_new(epub_document->documentdir);\n    gchar *tocfilename = get_toc_file_name(containeruri);\n    GList *index = NULL;\n\n    if (tocfilename == NULL) {\n        tocfilename = epub_document_get_nav_file(containeruri);\n\n        //Apparently, sometimes authors don't even care to add a TOC!! Guess standards are just guidelines.\n\n        if (tocfilename == NULL) {\n            //We didn't even find a nav file.The document has no TOC.\n            g_string_free(tocpath,TRUE);\n            return NULL;\n        }\n\n        g_string_append_printf (tocpath,\"/%s\",tocfilename);\n        index = setup_index_from_navfile(tocpath->str);\n        g_string_free(tocpath,TRUE);\n        g_free (tocfilename);\n        return index;\n    }\n\n    g_string_append_printf (tocpath,\"/%s\",tocfilename);\n    g_free (tocfilename);\n\n    GString *pagelink;\n    open_xml_document(tocpath->str);\n    g_string_free(tocpath,TRUE);\n    set_xml_root_node((xmlChar*)\"ncx\");\n\n    xmlNodePtr docTitle = xml_get_pointer_to_node((xmlChar*)\"docTitle\",NULL,NULL);\n    xmlretval = NULL;\n    xml_parse_children_of_node(docTitle,(xmlChar*)\"text\",NULL,NULL);\n\n    while (epub_document->docTitle == NULL && xmlretval != NULL) {\n        epub_document->docTitle = (gchar*)xml_get_data_from_node(xmlretval,XML_KEYWORD,NULL);\n        xmlretval = xmlretval->next;\n    }\n    xmlNodePtr navMap = xml_get_pointer_to_node((xmlChar*)\"navMap\",NULL,NULL);\n    xmlretval = NULL;\n    xml_parse_children_of_node(navMap,(xmlChar*)\"navPoint\",NULL,NULL);\n\n    xmlNodePtr navPoint = xmlretval;\n\n    while(navPoint != NULL) {\n\n        if ( !xmlStrcmp(navPoint->name,(xmlChar*)\"navPoint\")) {\n            xmlretval = NULL;\n            xml_parse_children_of_node(navPoint,(xmlChar*)\"navLabel\",NULL,NULL);\n            xmlNodePtr navLabel = xmlretval;\n            xmlretval = NULL;\n            gchar *fragment=NULL,*end=NULL;\n            GString *uri = NULL;\n\n            xml_parse_children_of_node(navLabel,(xmlChar*)\"text\",NULL,NULL);\n            linknode *newnode = g_new0(linknode,1);\n            newnode->linktext = NULL;\n            while (newnode->linktext == NULL) {\n                newnode->linktext = (gchar*)xml_get_data_from_node(xmlretval,XML_KEYWORD,NULL);\n                xmlretval = xmlretval->next;\n            }\n            xmlretval = NULL;\n            xml_parse_children_of_node(navPoint,(xmlChar*)\"content\",NULL,NULL);\n            pagelink = g_string_new(epub_document->documentdir);\n            newnode->pagelink = (gchar*)xml_get_data_from_node(xmlretval,XML_ATTRIBUTE,(xmlChar*)\"src\");\n            g_string_append_printf(pagelink,\"/%s\",newnode->pagelink);\n            xmlFree(newnode->pagelink);\n\n            gchar *escaped = g_strdup(pagelink->str);\n\n            //unescaping any special characters\n            pagelink->str = g_uri_unescape_string (escaped,NULL);\n            g_free(escaped);\n\n            if ((end = g_strrstr(pagelink->str,\"#\")) != NULL) {\n                fragment = g_strdup(g_strrstr(pagelink->str,\"#\"));\n                *end = '\\0';\n            }\n            uri = g_string_new(g_filename_to_uri(pagelink->str,NULL,NULL));\n            g_string_free(pagelink,TRUE);\n\n            if (fragment) {\n                g_string_append(uri,fragment);\n            }\n\n            newnode->pagelink = g_strdup(uri->str);\n            g_string_free(uri,TRUE);\n            index = g_list_prepend(index,newnode);\n        }\n\n        navPoint = navPoint->next;\n\n    }\n\n    xml_free_doc();\n\n    return g_list_reverse(index);\n}\n\nstatic EvDocumentInfo*\nepub_document_get_info(EvDocument *document)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document);\n    GError *error = NULL ;\n    gchar* infofile ;\n    xmlNodePtr metanode ;\n    GString* buffer ;\n\n    GString* containerpath = g_string_new(epub_document->tmp_archive_dir);\n    g_string_append_printf(containerpath,\"/META-INF/container.xml\");\n    gchar* containeruri = g_filename_to_uri(containerpath->str,NULL,&error);\n    g_string_free (containerpath, TRUE);\n    if ( error )\n    {\n        return NULL ;\n    }\n\n    gchar* uri = get_uri_to_content (containeruri,&error,epub_document);\n    g_free (containeruri);\n    if ( error )\n    {\n        return NULL ;\n    }\n\n    EvDocumentInfo* epubinfo = g_new0 (EvDocumentInfo, 1);\n\n    epubinfo->fields_mask = EV_DOCUMENT_INFO_TITLE |\n                EV_DOCUMENT_INFO_FORMAT |\n                EV_DOCUMENT_INFO_AUTHOR |\n                EV_DOCUMENT_INFO_SUBJECT |\n                EV_DOCUMENT_INFO_KEYWORDS |\n                EV_DOCUMENT_INFO_LAYOUT |\n                EV_DOCUMENT_INFO_CREATOR |\n                EV_DOCUMENT_INFO_LINEARIZED |\n                EV_DOCUMENT_INFO_PERMISSIONS |\n                EV_DOCUMENT_INFO_N_PAGES ;\n\n    infofile = g_filename_from_uri(uri,NULL,&error);\n    g_free (uri);\n    if ( error )\n    {\n        return epubinfo;\n    }\n\n    open_xml_document(infofile);\n    g_free (infofile);\n\n    set_xml_root_node((xmlChar*)\"package\");\n\n    metanode = xml_get_pointer_to_node((xmlChar*)\"title\",NULL,NULL);\n    if ( metanode == NULL )\n        epubinfo->title = NULL ;\n    else\n        epubinfo->title = (char*)xml_get_data_from_node(metanode,XML_KEYWORD,NULL);\n\n    metanode = xml_get_pointer_to_node((xmlChar*)\"creator\",NULL,NULL);\n    if ( metanode == NULL )\n        epubinfo->author = g_strdup(\"unknown\");\n    else\n        epubinfo->author = (char*)xml_get_data_from_node(metanode,XML_KEYWORD,NULL);\n\n    metanode = xml_get_pointer_to_node((xmlChar*)\"subject\",NULL,NULL);\n    if ( metanode == NULL )\n        epubinfo->subject = g_strdup(\"unknown\");\n    else\n        epubinfo->subject = (char*)xml_get_data_from_node(metanode,XML_KEYWORD,NULL);\n\n    buffer = g_string_new((gchar*)xml_get_data_from_node (xmlroot,XML_ATTRIBUTE,(xmlChar*)\"version\"));\n    g_string_prepend(buffer,\"epub \");\n    epubinfo->format = g_string_free(buffer,FALSE);\n\n    /*FIXME: Add more of these as you write the corresponding modules*/\n\n    epubinfo->layout = EV_DOCUMENT_LAYOUT_SINGLE_PAGE;\n\n    metanode = xml_get_pointer_to_node((xmlChar*)\"publisher\",NULL,NULL);\n    if ( metanode == NULL )\n        epubinfo->creator = g_strdup(\"unknown\");\n    else\n        epubinfo->creator = (char*)xml_get_data_from_node(metanode,XML_KEYWORD,NULL);\n\n    /* number of pages */\n    epubinfo->n_pages = epub_document_get_n_pages(document);\n\n    /*Copying*/\n    epubinfo->permissions = EV_DOCUMENT_PERMISSIONS_OK_TO_COPY;\n    /*TODO : Add a function to get date*/\n\n    if (xmldocument)\n        xml_free_doc();\n    return epubinfo ;\n}\n\nstatic EvPage*\nepub_document_get_page(EvDocument *document,\n                       gint index)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document);\n    EvPage* page = ev_page_new(index);\n    contentListNode *listptr = g_list_nth_data (epub_document->contentList,index);\n    page->backend_page = g_strdup(listptr->value);\n    return page ;\n}\n\nstatic void\nchange_to_night_sheet(contentListNode *nodedata,gpointer user_data)\n{\n    gchar *filename = g_filename_from_uri(nodedata->value,NULL,NULL);\n    open_xml_document(filename);\n    set_xml_root_node(NULL);\n    xmlNodePtr head =xml_get_pointer_to_node((xmlChar*)\"head\",NULL,NULL);\n    gchar *class = NULL;\n    xmlretval = NULL;\n    xml_parse_children_of_node(head,(xmlChar*)\"link\",(xmlChar*)\"rel\",(xmlChar*)\"stylesheet\");\n\n    xmlNodePtr day = xmlretval;\n    if ( (class = (gchar*)xml_get_data_from_node(day,XML_ATTRIBUTE,(xmlChar*)\"class\")) == NULL) {\n        xmlSetProp(day,(xmlChar*)\"class\",(xmlChar*)\"day\");\n    }\n    g_free(class);\n    xmlSetProp(day,(xmlChar*)\"rel\",(xmlChar*)\"alternate stylesheet\");\n    xmlretval = NULL;\n    xml_parse_children_of_node(head,(xmlChar*)\"link\",(xmlChar*)\"class\",(xmlChar*)\"night\");\n    xmlSetProp(xmlretval,(xmlChar*)\"rel\",(xmlChar*)\"stylesheet\");\n    xmlSaveFormatFile (filename, xmldocument, 0);\n    xml_free_doc();\n    g_free(filename);\n}\n\nstatic void\nchange_to_day_sheet(contentListNode *nodedata,gpointer user_data)\n{\n    gchar *filename = g_filename_from_uri(nodedata->value,NULL,NULL);\n    open_xml_document(filename);\n    set_xml_root_node(NULL);\n    xmlNodePtr head =xml_get_pointer_to_node((xmlChar*)\"head\",NULL,NULL);\n\n    xmlretval = NULL;\n    xml_parse_children_of_node(head,(xmlChar*)\"link\",(xmlChar*)\"rel\",(xmlChar*)\"stylesheet\");\n\n    xmlNodePtr day = xmlretval;\n    xmlSetProp(day,(xmlChar*)\"rel\",(xmlChar*)\"alternate stylesheet\");\n\n    xmlretval = NULL;\n    xml_parse_children_of_node(head,(xmlChar*)\"link\",(xmlChar*)\"class\",(xmlChar*)\"day\");\n    xmlSetProp(xmlretval,(xmlChar*)\"rel\",(xmlChar*)\"stylesheet\");\n    xmlSaveFormatFile (filename, xmldocument, 0);\n    xml_free_doc();\n    g_free(filename);\n}\n\nstatic gchar*\nepub_document_get_alternate_stylesheet(gchar *docuri)\n{\n    gchar *filename = g_filename_from_uri(docuri,NULL,NULL);\n    open_xml_document(filename);\n    g_free(filename);\n\n    set_xml_root_node(NULL);\n\n    xmlNodePtr head= xml_get_pointer_to_node((xmlChar*)\"head\",NULL,NULL);\n\n    xmlretval = NULL;\n\n    xml_parse_children_of_node(head,(xmlChar*)\"link\",(xmlChar*)\"class\",(xmlChar*)\"night\");\n\n    if (xmlretval != NULL) {\n        return (gchar*)xml_get_data_from_node(xmlretval,XML_ATTRIBUTE,(xmlChar*)\"href\");\n    }\n    xml_free_doc();\n    return NULL;\n}\n\nstatic void\nadd_night_sheet(contentListNode *listdata,gchar *sheet)\n{\n    gchar *sheeturi = g_filename_to_uri(sheet,NULL,NULL);\n    open_xml_document(listdata->value);\n\n    set_xml_root_node(NULL);\n    xmlNodePtr head = xml_get_pointer_to_node((xmlChar*)\"head\",NULL,NULL);\n\n    xmlNodePtr link = xmlNewTextChild (head, NULL, (xmlChar*) \"link\", NULL);\n    xmlNewProp (link, (xmlChar*) \"href\", (xmlChar*) sheeturi);\n    xmlNewProp (link, (xmlChar*) \"rel\", (xmlChar*) \"alternate stylesheet\");\n    xmlNewProp (link, (xmlChar*) \"class\", (xmlChar*) \"night\");\n\n    xmlSaveFormatFile (listdata->value, xmldocument, 0);\n    xml_free_doc();\n    g_free(sheeturi);\n}\n\nstatic void\nepub_document_check_add_night_sheet(EvDocument *document)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document);\n\n    g_return_if_fail(EPUB_IS_DOCUMENT(epub_document));\n\n    /*\n     * We'll only check the first page for a supplied night mode stylesheet.\n     * Odds are, if this one has it, all others have it too.\n     */\n    contentListNode *node = epub_document->contentList->data;\n    gchar* stylesheetfilename = epub_document_get_alternate_stylesheet((gchar*)node->value) ;\n\n    if (stylesheetfilename == NULL) {\n        gchar *style = \"body {color:rgb(255,255,255);\\\n                        background-color:rgb(0,0,0);\\\n                        text-align:justify;\\\n                        line-spacing:1.8;\\\n                        margin-top:0px;\\\n                        margin-bottom:4px;\\\n                        margin-right:50px;\\\n                        margin-left:50px;\\\n                        text-indent:3em;}\\\n                        h1, h2, h3, h4, h5, h6\\\n                        {color:white;\\\n                        text-align:center;\\\n                        font-style:italic;\\\n                        font-weight:bold;}\";\n\n        gchar *csspath = g_strdup_printf(\"%s/atrilnightstyle.css\",epub_document->documentdir);\n\n        GFile *styles = g_file_new_for_path (csspath);\n        GOutputStream *outstream = (GOutputStream*)g_file_create(styles,G_FILE_CREATE_PRIVATE,NULL,NULL);\n        if ( g_output_stream_write((GOutputStream*)outstream,style,strlen(style),NULL,NULL) == -1 )\n        {\n            return ;\n        }\n        g_output_stream_close((GOutputStream*)outstream,NULL,NULL);\n        g_object_unref(styles) ;\n        g_object_unref(outstream) ;\n        //add this stylesheet to each document, for later.\n        g_list_foreach(epub_document->contentList,(GFunc)add_night_sheet,csspath);\n        g_free(csspath);\n    }\n    g_free(stylesheetfilename);\n}\n\nstatic void\nepub_document_toggle_night_mode(EvDocument *document,gboolean night)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document);\n\n    g_return_if_fail(EPUB_IS_DOCUMENT(epub_document));\n    if (night)\n        g_list_foreach(epub_document->contentList,(GFunc)change_to_night_sheet,NULL);\n    else\n        g_list_foreach(epub_document->contentList,(GFunc)change_to_day_sheet,NULL);\n}\n\nstatic gchar*\nepub_document_set_document_title(gchar *containeruri)\n{\n    open_xml_document(containeruri);\n    gchar *doctitle;\n    set_xml_root_node(NULL);\n\n    xmlNodePtr title = xml_get_pointer_to_node((xmlChar*)\"title\",NULL,NULL);\n\n    doctitle = (gchar*)xml_get_data_from_node(title, XML_KEYWORD, NULL);\n    xml_free_doc();\n\n    return doctitle;\n}\n\nstatic void\npage_set_function(linknode *Link, GList *contentList)\n{\n    GList *listiter = contentList;\n    contentListNode *pagedata;\n\n    guint flag=0;\n    while (!flag) {\n        pagedata = listiter->data;\n        if (link_present_on_page(Link->pagelink, pagedata->value)) {\n            flag=1;\n            Link->page = pagedata->index - 1;\n        }\n        listiter = listiter->next;\n    }\n\n    if (Link->children) {\n        g_list_foreach(Link->children,(GFunc)page_set_function,contentList);\n    }\n}\n\nstatic void\nepub_document_set_index_pages(GList *index,GList *contentList)\n{\n    g_return_if_fail (index != NULL);\n    g_return_if_fail (contentList != NULL);\n\n    g_list_foreach(index,(GFunc)page_set_function,contentList);\n}\n\nstatic void\nadd_mathjax_script_node_to_file(gchar *filename, gchar *data)\n{\n    xmlDocPtr mathdocument = xmlParseFile (filename);\n    xmlNodePtr mathroot = xmlDocGetRootElement(mathdocument);\n\n    if (mathroot == NULL)\n        return;\n\n    xmlNodePtr head = mathroot->children;\n\n    while(head != NULL) {\n        if (!xmlStrcmp(head->name,(xmlChar*)\"head\")) {\n            break;\n        }\n        head = head->next;\n    }\n\n    if (xmlStrcmp(head->name,(xmlChar*)\"head\")) {\n        return ;\n    }\n\n    xmlNodePtr script = xmlNewTextChild (head,NULL,(xmlChar*)\"script\",(xmlChar*)\"\");\n    xmlNewProp(script,(xmlChar*)\"type\",(xmlChar*)\"text/javascript\");\n    xmlNewProp(script,(xmlChar*)\"src\",(xmlChar*)data);\n\n    xmlSaveFormatFile(filename, mathdocument, 0);\n    xmlFreeDoc (mathdocument);\n}\n\nstatic void\nepub_document_add_mathJax(gchar* containeruri,gchar* documentdir)\n{\n    gchar *containerfilename= g_filename_from_uri(containeruri,NULL,NULL);\n    GString *mathjaxdir = g_string_new(\"/usr/share/javascript/mathjax\");\n\n    gchar *mathjaxref = g_filename_to_uri(mathjaxdir->str,NULL,NULL);\n    gchar *nodedata = g_strdup_printf(\"%s/MathJax.js?config=TeX-AMS-MML_SVG\",mathjaxref);\n\n    open_xml_document(containerfilename);\n    set_xml_root_node(NULL);\n    xmlNodePtr manifest = xml_get_pointer_to_node((xmlChar*)\"manifest\",NULL,NULL);\n\n    xmlNodePtr item = manifest->xmlChildrenNode;\n\n    while (item != NULL) {\n        if (xmlStrcmp(item->name,(xmlChar*)\"item\")) {\n            item = item->next;\n            continue;\n        }\n\n        xmlChar *mathml = xml_get_data_from_node(item,XML_ATTRIBUTE, (xmlChar*)\"properties\");\n\n        if (mathml != NULL &&\n            !xmlStrcmp(mathml, (xmlChar*)\"mathml\") ) {\n            gchar *href = (gchar*)xml_get_data_from_node(item, XML_ATTRIBUTE, (xmlChar*)\"href\");\n            gchar *filename = g_strdup_printf(\"%s/%s\",documentdir,href);\n\n            add_mathjax_script_node_to_file(filename,nodedata);\n            g_free(href);\n            g_free(filename);\n        }\n        g_free(mathml);\n        item = item->next;\n    }\n    xml_free_doc();\n    g_free(mathjaxref);\n    g_free(containerfilename);\n    g_free(nodedata);\n    g_string_free(mathjaxdir,TRUE);\n}\n\nstatic gboolean\nepub_document_load (EvDocument* document,\n                    const char* uri,\n                    GError**    error)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT(document);\n    GError *err = NULL;\n\n    if ( check_mime_type (uri, &err) == FALSE )\n    {\n        /*Error would've been set by the function*/\n        g_propagate_error(error,err);\n        return FALSE;\n    }\n\n    extract_epub_from_container (uri,epub_document,&err);\n\n    if ( err )\n    {\n        g_propagate_error( error,err );\n        return FALSE;\n    }\n\n    /*FIXME : can this be different, ever?*/\n    GString *containerpath = g_string_new(epub_document->tmp_archive_dir);\n    g_string_append_printf(containerpath,\"/META-INF/container.xml\");\n    gchar *containeruri = g_filename_to_uri(containerpath->str,NULL,&err);\n    g_string_free (containerpath, TRUE);\n\n    if ( err )\n    {\n        g_propagate_error(error,err);\n        return FALSE;\n    }\n\n    gchar *contentOpfUri = get_uri_to_content (containeruri,&err,epub_document);\n    g_free (containeruri);\n\n    if ( contentOpfUri == NULL )\n    {\n        g_propagate_error(error,err);\n        return FALSE;\n    }\n\n    epub_document->docTitle = epub_document_set_document_title(contentOpfUri);\n    epub_document->index = setup_document_index(epub_document,contentOpfUri);\n\n    epub_document->contentList = setup_document_content_list (contentOpfUri,&err,epub_document->documentdir);\n\n    if (epub_document->index != NULL && epub_document->contentList != NULL)\n        epub_document_set_index_pages(epub_document->index, epub_document->contentList);\n\n    epub_document_add_mathJax(contentOpfUri,epub_document->documentdir);\n    g_free (contentOpfUri);\n\n    if ( epub_document->contentList == NULL )\n    {\n        g_propagate_error(error,err);\n        return FALSE;\n    }\n\n    return TRUE;\n}\n\nstatic void\nepub_document_init (EpubDocument *epub_document)\n{\n    epub_document->archivename = NULL ;\n    epub_document->tmp_archive_dir = NULL ;\n    epub_document->contentList = NULL ;\n    epub_document->documentdir = NULL;\n    epub_document->index = NULL;\n    epub_document->docTitle = NULL;\n}\n\nstatic void\nepub_document_finalize (GObject *object)\n{\n    EpubDocument *epub_document = EPUB_DOCUMENT (object);\n\n    if (epub_document->epubDocument != NULL) {\n        if (epub_remove_temporary_dir (epub_document->tmp_archive_dir) == -1)\n            g_warning (_(\"There was an error deleting \u201c%s\u201d.\"),\n                       epub_document->tmp_archive_dir);\n    }\n\n    if ( epub_document->contentList ) {\n            g_list_free_full(epub_document->contentList,(GDestroyNotify)free_tree_nodes);\n            epub_document->contentList = NULL;\n    }\n\n    if (epub_document->index) {\n        g_list_free_full(epub_document->index,(GDestroyNotify)free_link_nodes);\n        epub_document->index = NULL;\n    }\n\n    if ( epub_document->tmp_archive_dir) {\n        g_free (epub_document->tmp_archive_dir);\n        epub_document->tmp_archive_dir = NULL;\n    }\n\n    if (epub_document->docTitle) {\n        g_free(epub_document->docTitle);\n        epub_document->docTitle = NULL;\n    }\n    if ( epub_document->archivename) {\n        g_free (epub_document->archivename);\n        epub_document->archivename = NULL;\n    }\n    if ( epub_document->documentdir) {\n        g_free (epub_document->documentdir);\n        epub_document->documentdir = NULL;\n    }\n    G_OBJECT_CLASS (epub_document_parent_class)->finalize (object);\n}\n\nstatic void\nepub_document_class_init (EpubDocumentClass *klass)\n{\n    GObjectClass    *gobject_class = G_OBJECT_CLASS (klass);\n    EvDocumentClass *ev_document_class = EV_DOCUMENT_CLASS (klass);\n\n    gobject_class->finalize = epub_document_finalize;\n    ev_document_class->load = epub_document_load;\n    ev_document_class->save = epub_document_save;\n    ev_document_class->get_n_pages = epub_document_get_n_pages;\n    ev_document_class->get_info = epub_document_get_info;\n    ev_document_class->get_page = epub_document_get_page;\n    ev_document_class->toggle_night_mode = epub_document_toggle_night_mode;\n    ev_document_class->check_add_night_sheet = epub_document_check_add_night_sheet;\n}\n"], "filenames": ["backend/epub/epub-document.c"], "buggy_code_start_loc": [638], "buggy_code_end_loc": [839], "fixing_code_start_loc": [638], "fixing_code_end_loc": [856], "type": "CWE-22", "message": "Atril Document Viewer is the default document reader of the MATE desktop environment for Linux. A path traversal and arbitrary file write vulnerability exists in versions of Atril prior to 1.26.2. This vulnerability is capable of writing arbitrary files anywhere on the filesystem to which the user opening a crafted document has access. The only limitation is that this vulnerability cannot be exploited to overwrite existing files, but that doesn't stop an attacker from achieving Remote Command Execution on the target system. Version 1.26.2 of Atril contains a patch for this vulnerability.", "other": {"cve": {"id": "CVE-2023-52076", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-25T16:15:07.930", "lastModified": "2024-02-02T17:14:24.893", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Atril Document Viewer is the default document reader of the MATE desktop environment for Linux. A path traversal and arbitrary file write vulnerability exists in versions of Atril prior to 1.26.2. This vulnerability is capable of writing arbitrary files anywhere on the filesystem to which the user opening a crafted document has access. The only limitation is that this vulnerability cannot be exploited to overwrite existing files, but that doesn't stop an attacker from achieving Remote Command Execution on the target system. Version 1.26.2 of Atril contains a patch for this vulnerability."}, {"lang": "es", "value": "Atril Document Viewer es el lector de documentos predeterminado del entorno de escritorio MATE para Linux. Existe una vulnerabilidad de path traversal y escritura de archivos arbitrarios en versiones de Atril anteriores a la 1.26.2. Esta vulnerabilidad es capaz de escribir archivos arbitrarios en cualquier parte del sistema de archivos al que tiene acceso el usuario que abre un documento manipulado. La \u00fanica limitaci\u00f3n es que esta vulnerabilidad no se puede aprovechar para sobrescribir archivos existentes, pero eso no impide que un atacante logre la ejecuci\u00f3n remota de comandos en el sistema de destino. La versi\u00f3n 1.26.2 de Atril contiene un parche para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "LOW", "baseScore": 8.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}, {"lang": "en", "value": "CWE-24"}, {"lang": "en", "value": "CWE-25"}, {"lang": "en", "value": "CWE-27"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mate-desktop:atril:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.26.2", "matchCriteriaId": "5535D08A-28B9-4B48-8621-69F5DD6B1F01"}]}]}], "references": [{"url": "https://github.com/mate-desktop/atril/commit/e70b21c815418a1e6ebedf6d8d31b8477c03ba50", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/mate-desktop/atril/releases/tag/v1.26.2", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/mate-desktop/atril/security/advisories/GHSA-6mf6-mxpc-jc37", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/mate-desktop/atril/commit/e70b21c815418a1e6ebedf6d8d31b8477c03ba50"}}