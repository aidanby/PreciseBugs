{"buggy_code": ["use std::cmp::min;\nuse std::time::Duration;\n\nuse irc::{\n    client::{prelude::Config, Client, ClientStream},\n    error::Error::{self, PingTimeout},\n};\nuse tokio::{sync::mpsc::Sender, time::sleep};\n\nuse crate::handlers::{\n    config::CompleteConfig,\n    data::{DataBuilder, MessageData},\n};\n\n/// Initialize the config and send it to the client to connect to an IRC channel.\nasync fn create_client_stream(config: CompleteConfig) -> Result<(Client, ClientStream), Error> {\n    let irc_config = Config {\n        nickname: Some(config.twitch.username.clone()),\n        server: Some(config.twitch.server.clone()),\n        channels: vec![format!(\"#{}\", config.twitch.channel)],\n        password: config.twitch.token.clone(),\n        port: Some(6667),\n        use_tls: Some(false),\n        ping_timeout: Some(10),\n        ping_time: Some(10),\n        ..Default::default()\n    };\n\n    let mut client = Client::from_config(irc_config.clone()).await?;\n\n    client.identify()?;\n\n    let stream = client.stream()?;\n\n    Ok((client, stream))\n}\n\npub async fn wait_client_stream(\n    tx: Sender<MessageData>,\n    data_builder: DataBuilder<'_>,\n    config: CompleteConfig,\n) -> (Client, ClientStream) {\n    let mut timeout = 1;\n\n    loop {\n        match create_client_stream(config.clone()).await {\n            Ok(v) => return v,\n            Err(err) => match err {\n                Error::Io(io) => tx\n                    .send(data_builder.system(format!(\"Unable to connect: {io}\")))\n                    .await\n                    .unwrap(),\n                _ => {\n                    tx.send(data_builder.system(format!(\"Fatal error: {err:?}\").to_string()))\n                        .await\n                        .unwrap();\n                }\n            },\n        };\n\n        sleep(Duration::from_secs(timeout)).await;\n\n        timeout = min(timeout * 2, 30);\n    }\n}\n\n/// If an error of any kind occurs, attempt to reconnect to the IRC channel.\npub async fn client_stream_reconnect(\n    err: Error,\n    tx: Sender<MessageData>,\n    data_builder: DataBuilder<'_>,\n    config: &CompleteConfig,\n) -> (Client, ClientStream) {\n    match err {\n        PingTimeout => {\n            tx.send(data_builder.system(\"Ping to Twitch has timed out.\".to_string()))\n                .await\n                .unwrap();\n        }\n        _ => {\n            tx.send(data_builder.system(format!(\"Fatal error: {err:?}\").to_string()))\n                .await\n                .unwrap();\n        }\n    }\n\n    sleep(Duration::from_millis(1000)).await;\n\n    tx.send(data_builder.system(\"Attempting reconnect...\".to_string()))\n        .await\n        .unwrap();\n\n    let (client, stream) = wait_client_stream(tx, data_builder, config.clone()).await;\n\n    (client, stream)\n}\n"], "fixing_code": ["use std::cmp::min;\nuse std::time::Duration;\n\nuse irc::{\n    client::{prelude::Config, Client, ClientStream},\n    error::Error::{self, PingTimeout},\n};\nuse tokio::{sync::mpsc::Sender, time::sleep};\n\nuse crate::handlers::{\n    config::CompleteConfig,\n    data::{DataBuilder, MessageData},\n};\n\n/// Initialize the config and send it to the client to connect to an IRC channel.\nasync fn create_client_stream(config: CompleteConfig) -> Result<(Client, ClientStream), Error> {\n    let irc_config = Config {\n        nickname: Some(config.twitch.username.clone()),\n        server: Some(config.twitch.server.clone()),\n        channels: vec![format!(\"#{}\", config.twitch.channel)],\n        password: config.twitch.token.clone(),\n        port: Some(6697),\n        use_tls: Some(true),\n        ping_timeout: Some(10),\n        ping_time: Some(10),\n        ..Default::default()\n    };\n\n    let mut client = Client::from_config(irc_config.clone()).await?;\n\n    client.identify()?;\n\n    let stream = client.stream()?;\n\n    Ok((client, stream))\n}\n\npub async fn wait_client_stream(\n    tx: Sender<MessageData>,\n    data_builder: DataBuilder<'_>,\n    config: CompleteConfig,\n) -> (Client, ClientStream) {\n    let mut timeout = 1;\n\n    loop {\n        match create_client_stream(config.clone()).await {\n            Ok(v) => return v,\n            Err(err) => match err {\n                Error::Io(io) => tx\n                    .send(data_builder.system(format!(\"Unable to connect: {io}\")))\n                    .await\n                    .unwrap(),\n                _ => {\n                    tx.send(data_builder.system(format!(\"Fatal error: {err:?}\").to_string()))\n                        .await\n                        .unwrap();\n                }\n            },\n        };\n\n        sleep(Duration::from_secs(timeout)).await;\n\n        timeout = min(timeout * 2, 30);\n    }\n}\n\n/// If an error of any kind occurs, attempt to reconnect to the IRC channel.\npub async fn client_stream_reconnect(\n    err: Error,\n    tx: Sender<MessageData>,\n    data_builder: DataBuilder<'_>,\n    config: &CompleteConfig,\n) -> (Client, ClientStream) {\n    match err {\n        PingTimeout => {\n            tx.send(data_builder.system(\"Ping to Twitch has timed out.\".to_string()))\n                .await\n                .unwrap();\n        }\n        _ => {\n            tx.send(data_builder.system(format!(\"Fatal error: {err:?}\").to_string()))\n                .await\n                .unwrap();\n        }\n    }\n\n    sleep(Duration::from_millis(1000)).await;\n\n    tx.send(data_builder.system(\"Attempting reconnect...\".to_string()))\n        .await\n        .unwrap();\n\n    let (client, stream) = wait_client_stream(tx, data_builder, config.clone()).await;\n\n    (client, stream)\n}\n"], "filenames": ["src/twitch/connection.rs"], "buggy_code_start_loc": [22], "buggy_code_end_loc": [24], "fixing_code_start_loc": [22], "fixing_code_end_loc": [24], "type": "CWE-311", "message": "twitch-tui provides Twitch chat in a terminal. Prior to version 2.4.1, the connection is not using TLS for communication. In the configuration of the irc connection, the software disables TLS, which makes all communication to Twitch IRC servers unencrypted. As a result, communication, including auth tokens, can be sniffed. Version 2.4.1 has a patch for this issue.", "other": {"cve": {"id": "CVE-2023-38688", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-04T17:15:10.097", "lastModified": "2023-08-09T21:05:36.740", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "twitch-tui provides Twitch chat in a terminal. Prior to version 2.4.1, the connection is not using TLS for communication. In the configuration of the irc connection, the software disables TLS, which makes all communication to Twitch IRC servers unencrypted. As a result, communication, including auth tokens, can be sniffed. Version 2.4.1 has a patch for this issue."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-311"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xithrius:twitch-tui:*:*:*:*:*:rust:*:*", "versionEndIncluding": "2.4.0", "matchCriteriaId": "51E1B391-7145-4B2F-8183-B007928C21E7"}]}]}], "references": [{"url": "https://github.com/Xithrius/twitch-tui/blob/340afc3c8c07a83289fe6ef614aa7563c8b70756/src/twitch/connection.rs#L23", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/Xithrius/twitch-tui/commit/74d13ddca35f8f0816f4933c229da1fd95c0350a", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/Xithrius/twitch-tui/security/advisories/GHSA-779w-xvpm-78jx", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/Xithrius/twitch-tui/commit/74d13ddca35f8f0816f4933c229da1fd95c0350a"}}