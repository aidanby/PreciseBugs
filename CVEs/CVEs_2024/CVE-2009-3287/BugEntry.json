{"buggy_code": ["== 1.2.3\n * Fix uninitialized constant ActionController::Dispatcher error with Rails 1.2.3 [Chris Anderton] [#103 state:resolved]\n\n== 1.2.2 I Find Your Lack of Sauce Disturbing release\n * Fix force kill under 1.9 [Alexey Chebotar]\n * Fix regression when --only option is used w/ --socket.\n * Add process name 'tag' functionality. Easier to distinguish thin daemons \n   from eachother in process listing [ctcherry]\n\n== 1.2.1 Asynctilicious Ultra Supreme release\n * Require Rack 1.0.0\n * Require EventMachine 0.12.6\n * Use Rails Rack based dispatcher when available\n * Allow String for response body\n * Require openssl before eventmachine to prevent crash in 1.9\n\n== 1.2.0 Asynctilicious Supreme release \n * Add support for Windows mingw Ruby distro [Juan C. Rodriguez]\n * Add async response support, see example/async_*.ru [raggi]\n\n== 1.1.1 Super Disco Power Plus release \n * Fix bug when running with only options [hasimo]\n\n== 1.1.0 Super Disco Power release\n * Require EventMachine 0.12.4\n * Remove Thin handler, now part of Rack 0.9.1\n * Fix Rack protocol version to 0.1 in environment hash.\n * Fix error when passing no_epoll option to a cluster.\n * Omit parsing #defined strings [J\u00e9r\u00e9my Zurcher]\n * Defaults SERVER_NAME to localhost like webrick does [#87 state:resolved]\n * Namespace parser to prevent error when mongrel is required [cliffmoon]\n * Set RACK_ENV based on environment option when loading rackup file [Curtis Summers] [#83 state:resolved]\n * Fixes a warning RE relative_url_root when using a prefix with Rails 2.1.1 [seriph] [#85 state:resolved]\n * --only can work as a sequence number (if < 80) or a port number (if >= 80) [jmay] [#81 state:resolved]\n\n== 1.0.0 That's What She Said release\n * Fixed vlad.rake to allow TCP or socket [hellekin]\n * Updated Mack adapter to handle both <0.8.0 and >0.8.0 [Mark Bates]\n * rails rack adapter uses File.readable_real? so it recognizes ACL permissions [Ricardo Chimal]\n * Log a warning if Rack application returns nil body [Michael S. Klishin]\n * Handle nil and Time header values correctly [#76 state:resolved] [tmm1]\n * Add Content-Length header to response automatically when possible [#74 state:resolved] [dkubb]\n * Runner now remembers -r, -D and -V parameters so that clustered servers inherit those and\n   `restart` keep your parameters.\n * Make Set-Cookie header, in Rails adapter, compatible with current Rack spec [Pedro Belo]\n   [#73, state:resolved]\n * Add --no-epoll option to disable epoll usage on Linux [#61 state:resolved]\n * Add --force (-f) option to force stopping of a daemonized server [#72 state:resolved]\n * Update halycon adapter loader [mtodd]\n\n== 0.8.2 Double Margarita release\n * Require EventMachine 0.12.0\n * [bug] Fix timeout handling when running command\n * [bug] Fix hanging when restarting and no process is running in single server move, fixes #67\n * Added Mack adapter [markbates]\n * Allow rackup .rb files by getting a conventionally named constant as the app [bmizerany]\n\n== 0.8.1 Rebel Porpoise release\n * [bug] Rescue all types of errors when processing request, fixes #62\n * [bug] Use Swiftiply backend when -y option is specified, fixes #63 and #64\n * Allow passing port as a string in Server.new\n * Define deferred?(env) in your Rack application to set if a request is handled in a\n\t thread (return true) or not (return false).\n\n== 0.8.0 Dodgy Dentist release\n * [bug] Fix server crash when header too large.\n * Add --require (-r) option to require a library, before executing your script.\n * Rename --rackup short option to -R, warn and load as rackup when file ends with .ru.\n * List supported adapters in command usage.\n * Add file adapter to built-in adapter, serve static files in current directory.\n * Allow disabling signal handling in Server with :signals => false\n * Make Server.new arguments more flexible, can now specify any of host, port, app or hash options.\n * Add --backend option to specified which backend to use, closes #55\n * [bug] Serve static file only on GET and HEAD requests in Rails adapter, fixes #58\n * Add threaded option to run server in threaded mode, calling the application in a\n   thread allowing for concurrency in the Rack adapter, closes #46\n * Guess which adapter to use from directory (chdir option)\n   or use specified one in 'adapter' option, re #47.\n\n== 0.7.1 Fancy Pants release\n * Clean stale PID files when starting as daemon, fixes #53 [Chu Yeow]\n * Require EventMachine 0.11.0 for UNIX domain sockets. Until it's released, install from:\n   gem install eventmachine --source http://code.macournoyer.com\n * Ruby 1.8.5 compatibility, closes #49 [Wincent Colaiuta]\n * Move all EventMachine stuff out of Server, you can now create a Thin Backend that\n   does not depend on EventMachine.\n * Rename Connector to Backend. Extend Thin::Backends::Base to implement your own.\n * Fix high memory usage with big POST body, fixes #48\n\n== 0.7.0 Spherical Cow release\n * Add --max-persistent-conns option to sets the maximum number of persistent connections.\n   Set to 0 to disable Keep-Alive.\n * INT signal now force stop and QUIT signal gracefully stops.\n * Warn when descriptors table size can't be set as high as expected.\n * Eval Rackup config file using top level bindings.\n * Remove daemons gem dependency on Windows plateform, fixes #45.\n * Change default timeout from 60 to 30 seconds.\n * Add --max-conns option to sets the maximum number of file or socket descriptors that\n   your process may open, defaults to 1024.\n * Tail logfile when stopping and restarting a demonized server, fixes #26.\n * Wrap application in a Rack::CommonLogger adapter in debug mode.\n * --debug (-D) option no longer set $DEBUG so logging will be less verbose\n   and Ruby won't be too strict, fixes #36.\n * Deprecate Server#silent in favour of Logging.silent.\n * Persistent connection (keep-alive) support.\n * Fix -s option not being included in generated config file, fixes #37.\n * Add Swiftiply support. Use w/ the --swiftiply (-y) option in the thin script,\n   closes #28 [Alex MacCaw]\n\n== 0.6.4 Sexy Lobster release\n * Fix error when stopping server on UNIX domain socket, fixes #42\n * Rescue errors in Connection#get_peername more gracefully, setting REMOTE_ADDR to nil, fixes #43\n\n== 0.6.3 Ninja Cookie release\n * Add tasks for Vlad the Deployer in example/vlad.rake [cnantais]\n * Add Ramaze Rackup config file in example dir [tmm1]\n   Use like this from you Ramaze app dir:\n   \n     thin start -r /path/to/thin/example/ramaze.ru\n   \n * Add the --rackup option to load a Rack config file instead of the Rails adapter.\n   So you can use any framework with the thin script and start cluster and stuff like that.\n   A Rack config file is one that is usable through the rackup command and looks like this:\n     \n     use Rack::CommonLogger\n     run MyCrazyRackAdapter.new(:uterly, 'cool')\n     \n   Then use it with thin like this:\n     \n     thin start --rackup config.ru\n     \n * thin config --chrdir ... -C thin/yml do not change current directory anymore, fixes #33.\n * Add a better sample god config file in example/thin.god that loads all info from config\n   files in /etc/thin. Drop-in replacement for the thin runlevel service [Gump].\n * Add support for specifying a custom Connector to the server and add more doc about Server\n   configuration.\n * Add a script to run thin as a runlevel service that can start at startup, closes #31 [Gump]\n   Setup the service like this:\n   \n     sudo thin install /etc/thin\n   \n   This will install the boot script under /etc/init.d/thin. Then copy your config files to\n   /etc/thin. Works only under Linux.\n * Set process name to 'thin server (0.0.0.0:3000)' when running as a daemon, closes #32.\n * Make sure chdir option from config file is used when present.\n * Raise an error when starting a server as a daemon and pid file already exist, fixes #27.\n\n== 0.6.2 Rambo release\n * Server now let current connections finish before stopping, fixes #18\n * Fix uploading hanging bug when body is moved to a tempfile,\n   also delete the tempfile properly upon completion, fixes #25\n * 'thin restart' now sends HUP signals rather then stopping & starting, closes #17\n * HUP signal now launches a new process with the same options.\n * Add PID and more info from the last request to the Stats adapter\n   mostly taken from Rack::ShowException.\n * pid and log files in cluster are no longer required to be relative to the\n   app directory (chdir option), fixes #24\n * Revert to using #each when building response headers under Ruby 1.8,\n   solves an issue w/ Camping adapter, fixes #22\n * Restructure thin script options in 3 sections: server, daemon and cluster\n * Add --only (-o) option to control only one server of a cluster.\n * Stylize stats page and make the url configurable from the thin script.\n * Raise error if attempting to use unix sockets on windows.\n * Add example config files for http://www.tildeslash.com/monit usage.\n   Include the example file using \"include /path/to/thin/monit/file\" in your monitrc file.\n   The group settings let you do this to manage your clusters:\n   \n     sudo monit -g blog restart all\n    \n   There are examples of thin listening on sockets and thin listening on unix sockets.\n\n== 0.6.1 Cheesecake release\n * Remove socket file when server stops.\n * Set back cluster to use 'thin' command to launch servers.\n\n== 0.6.0 Big Pony release\n * Add support for connection through UNIX domain socket.\n   Use the --socket (-S) option w/ the thin script to configure the socket filename.\n   Nginx support binding to a UNIX socket like this:\n   \n     upstream  backend {\n       server   unix:/tmp/thin.0.sock;\n       server   unix:/tmp/thin.1.sock;\n       server   unix:/tmp/thin.2.sock;\n     }\n  \n   Start your servers like this:\n   \n     thin start -s3 -S/tmp/thin.sock\n   \n * Remove Server#listen! method. Use Server#start instead.\n * Server can now yield a Rack::Builder to allow building an app in one call:\n \n     Server.start '0.0.0.0', 3000 do\n       use Rack::CommonLogger\n       use Rack::ShowExceptions\n       map \"/lobster\" do\n         use Rack::Lint\n         run Rack::Lobster.new\n       end\n     end\n     \n * Add a very basic stats page through Stats adapter, load w/ --stats and browse to /stats.\n * Add --trace (-V) option to trace request/response and get backtrace w/out all Ruby debug stuff.\n * Add --config (-C) option to load options from a config file in thin script [Matt Todd].\n * Alter response headers to output directly to a string.\n * Improve specs stability.\n * Move request body to a Tempfile if too big (> 112 MB)\n * Remove useless check for max header size in Request (already done in the parser)\n\n== 0.5.4 Flying Mustard release\n * Don't read the full body, use direct streaming when sending response.\n   See: Response#each\n   As a result, the Content-Length can not be calculated anymore.\n   You have to do set this in your adapter. All frameworks do it anyway.\n   It improve memory usage and boost speed for low concurrency.\n   Thanks to Kent Sibilev and Ezra for their help on that one.\n * Add 'Server' response header\n * Fix --user and --group option not changing daemon process privileges\n \n== 0.5.3 Purple Yogurt release\n * win32 pre-compiled gem now available\n * change rake task configuration to allow win32 gem build\n * Add prefix option to thin script to mount app under a given path.\n\n== 0.5.2 Cheezburger release\n * Add cluster support through the -s option in the thin script, start 3 thins like this:\n    thin start -s3 -p3000\n   3 thin servers will be started on port 3000, 3001, 3002, also the port number will be\n   injected in the pid and log filenames.\n * Fix IOError when writing to logger when starting server as a daemon.\n * Really change directory when the -c option is specified.\n * Add restart command to thin script.\n * Fix typos in thin script usage message and expand chdir path.\n * Rename thin script options to be the same as mongrel_rails script [thronedrk]:\n     -o --host  => -a --address\n     --log-file => --log\n     --pid-file => --pid\n     --env      => --environment\n \n== 0.5.1 LOLCAT release\n * Add URL rewriting to Rails adapter so that page caching works and / fetches index.html if present.\n * Fix bug in multiline response header parsing.\n * Add specs for the Rails adapter.\n * Fix Set-Cookie headers in Rails adapter to handle multiple values correctly.\n * Fix Ruby 1.9 incompatibility in Response#headers= and Rakefile.\n * Fix parser to be Ruby 1.9 compatible [Aman Gupta]\n * Set gemspec to use EventMachine version 0.8.1 as it's the latest one having precompiled windows binaries.\n   [Francis Cianfrocca].\n * Add -D option to thin script to set debugging on.\n * Output incoming data and response when debugging is on.\n\n== 0.5.0\n * Full rewrite to use EventMachine, Rack and Mongrel parser\n \n== 0.4.1\n * Fix Rails environment option not being used in thin script.\n \n== 0.4.0\n * First alphaish release as a gem.\n", "require 'socket'\n\nmodule Thin\n  # Connection between the server and client.\n  # This class is instanciated by EventMachine on each new connection\n  # that is opened.\n  class Connection < EventMachine::Connection\n    CONTENT_LENGTH    = 'Content-Length'.freeze\n    TRANSFER_ENCODING = 'Transfer-Encoding'.freeze\n    CHUNKED_REGEXP    = /\\bchunked\\b/i.freeze\n\n    include Logging\n    \n    # This is a template async response. N.B. Can't use string for body on 1.9\n    AsyncResponse = [-1, {}, []].freeze\n    \n    # Rack application (adapter) served by this connection.\n    attr_accessor :app\n\n    # Backend to the server\n    attr_accessor :backend\n\n    # Current request served by the connection\n    attr_accessor :request\n\n    # Next response sent through the connection\n    attr_accessor :response\n\n    # Calling the application in a threaded allowing\n    # concurrent processing of requests.\n    attr_writer :threaded\n\n    # Get the connection ready to process a request.\n    def post_init\n      @request  = Request.new\n      @response = Response.new\n    end\n\n    # Called when data is received from the client.\n    def receive_data(data)\n      trace { data }\n      process if @request.parse(data)\n    rescue InvalidRequest => e\n      log \"!! Invalid request\"\n      log_error e\n      close_connection\n    end\n\n    # Called when all data was received and the request\n    # is ready to be processed.\n    def process\n      if threaded?\n        @request.threaded = true\n        EventMachine.defer(method(:pre_process), method(:post_process))\n      else\n        @request.threaded = false\n        post_process(pre_process)\n      end\n    end\n\n    def pre_process\n      # Add client info to the request env\n      @request.remote_address = remote_address\n\n      # Connection may be closed unless the App#call response was a [-1, ...]\n      # It should be noted that connection objects will linger until this \n      # callback is no longer referenced, so be tidy!\n      @request.async_callback = method(:post_process)\n      \n      # When we're under a non-async framework like rails, we can still spawn\n      # off async responses using the callback info, so there's little point\n      # in removing this.\n      response = AsyncResponse\n      catch(:async) do\n        # Process the request calling the Rack adapter\n        response = @app.call(@request.env)\n      end\n      response\n    rescue Exception\n      handle_error\n      terminate_request\n      nil # Signal to post_process that the request could not be processed\n    end\n\n    def post_process(result)\n      return unless result\n      result = result.to_a\n      \n      # Status code -1 indicates that we're going to respond later (async).\n      return if result.first == AsyncResponse.first\n\n      # Set the Content-Length header if possible\n      set_content_length(result) if need_content_length?(result)\n      \n      @response.status, @response.headers, @response.body = *result\n\n      log \"!! Rack application returned nil body. Probably you wanted it to be an empty string?\" if @response.body.nil?\n\n      # Make the response persistent if requested by the client\n      @response.persistent! if @request.persistent?\n\n      # Send the response\n      @response.each do |chunk|\n        trace { chunk }\n        send_data chunk\n      end\n\n    rescue Exception\n      handle_error\n    ensure\n      # If the body is being deferred, then terminate afterward.\n      if @response.body.respond_to?(:callback) && @response.body.respond_to?(:errback)\n        @response.body.callback { terminate_request }\n        @response.body.errback  { terminate_request }\n      else\n        # Don't terminate the response if we're going async.\n        terminate_request unless result && result.first == AsyncResponse.first\n      end\n    end\n\n    # Logs catched exception and closes the connection.\n    def handle_error\n      log \"!! Unexpected error while processing request: #{$!.message}\"\n      log_error\n      close_connection rescue nil\n    end\n\n    def close_request_response\n      @request.async_close.succeed if @request.async_close\n      @request.close  rescue nil\n      @response.close rescue nil\n    end\n\n    # Does request and response cleanup (closes open IO streams and\n    # deletes created temporary files).\n    # Re-initializes response and request if client supports persistent\n    # connection.\n    def terminate_request\n      unless persistent?\n        close_connection_after_writing rescue nil\n        close_request_response\n      else\n        close_request_response\n        # Prepare the connection for another request if the client\n        # supports HTTP pipelining (persistent connection).\n        post_init\n      end\n    end\n\n    # Called when the connection is unbinded from the socket\n    # and can no longer be used to process requests.\n    def unbind\n      @request.async_close.succeed if @request.async_close\n      @response.body.fail if @response.body.respond_to?(:fail)\n      @backend.connection_finished(self)\n    end\n\n    # Allows this connection to be persistent.\n    def can_persist!\n      @can_persist = true\n    end\n\n    # Return +true+ if this connection is allowed to stay open and be persistent.\n    def can_persist?\n      @can_persist\n    end\n\n    # Return +true+ if the connection must be left open\n    # and ready to be reused for another request.\n    def persistent?\n      @can_persist && @response.persistent?\n    end\n\n    # +true+ if <tt>app.call</tt> will be called inside a thread.\n    # You can set all requests as threaded setting <tt>Connection#threaded=true</tt>\n    # or on a per-request case returning +true+ in <tt>app.deferred?</tt>.\n    def threaded?\n      @threaded || (@app.respond_to?(:deferred?) && @app.deferred?(@request.env))\n    end\n\n    # IP Address of the remote client.\n    def remote_address\n      @request.forwarded_for || socket_address\n    rescue Exception\n      log_error\n      nil\n    end\n\n    protected\n\n      # Returns IP address of peer as a string.\n      def socket_address\n        Socket.unpack_sockaddr_in(get_peername)[1]\n      end\n\n    private\n      def need_content_length?(result)\n        status, headers, body = result\n        return false if status == -1\n        return false if headers.has_key?(CONTENT_LENGTH)\n        return false if (100..199).include?(status) || status == 204 || status == 304\n        return false if headers.has_key?(TRANSFER_ENCODING) && headers[TRANSFER_ENCODING] =~ CHUNKED_REGEXP\n        return false unless body.kind_of?(String) || body.kind_of?(Array)\n        true\n      end\n\n      def set_content_length(result)\n        headers, body = result[1..2]\n        case body\n        when String\n          # See http://redmine.ruby-lang.org/issues/show/203\n          headers[CONTENT_LENGTH] = (body.respond_to?(:bytesize) ? body.bytesize : body.size).to_s\n        when Array\n           bytes = 0\n           body.each do |p|\n             bytes += p.respond_to?(:bytesize) ? p.bytesize : p.size\n           end\n           headers[CONTENT_LENGTH] = bytes.to_s\n        end\n      end\n  end\nend\n", "require 'thin_parser'\nrequire 'tempfile'\n\nmodule Thin\n  # Raised when an incoming request is not valid\n  # and the server can not process it.\n  class InvalidRequest < IOError; end\n\n  # A request sent by the client to the server.\n  class Request\n    # Maximum request body size before it is moved out of memory\n    # and into a tempfile for reading.\n    MAX_BODY          = 1024 * (80 + 32)\n    BODY_TMPFILE      = 'thin-body'.freeze\n    MAX_HEADER        = 1024 * (80 + 32)\n\n    # Freeze some HTTP header names & values\n    SERVER_SOFTWARE   = 'SERVER_SOFTWARE'.freeze\n    SERVER_NAME       = 'SERVER_NAME'.freeze\n    LOCALHOST         = 'localhost'.freeze\n    HTTP_VERSION      = 'HTTP_VERSION'.freeze\n    HTTP_1_0          = 'HTTP/1.0'.freeze\n    REMOTE_ADDR       = 'REMOTE_ADDR'.freeze\n    FORWARDED_FOR     = 'HTTP_X_FORWARDED_FOR'.freeze\n    CONTENT_LENGTH    = 'CONTENT_LENGTH'.freeze\n    CONNECTION        = 'HTTP_CONNECTION'.freeze\n    KEEP_ALIVE_REGEXP = /\\bkeep-alive\\b/i.freeze\n    CLOSE_REGEXP      = /\\bclose\\b/i.freeze\n    \n    # Freeze some Rack header names\n    RACK_INPUT        = 'rack.input'.freeze\n    RACK_VERSION      = 'rack.version'.freeze\n    RACK_ERRORS       = 'rack.errors'.freeze\n    RACK_MULTITHREAD  = 'rack.multithread'.freeze\n    RACK_MULTIPROCESS = 'rack.multiprocess'.freeze\n    RACK_RUN_ONCE     = 'rack.run_once'.freeze\n    ASYNC_CALLBACK    = 'async.callback'.freeze\n    ASYNC_CLOSE       = 'async.close'.freeze\n\n    # CGI-like request environment variables\n    attr_reader :env\n\n    # Unparsed data of the request\n    attr_reader :data\n\n    # Request body\n    attr_reader :body\n\n    def initialize\n      @parser   = Thin::HttpParser.new\n      @data     = ''\n      @nparsed  = 0\n      @body     = StringIO.new\n      @env      = {\n        SERVER_SOFTWARE   => SERVER,\n        SERVER_NAME       => LOCALHOST,\n\n        # Rack stuff\n        RACK_INPUT        => @body,\n\n        RACK_VERSION      => VERSION::RACK,\n        RACK_ERRORS       => STDERR,\n\n        RACK_MULTITHREAD  => false,\n        RACK_MULTIPROCESS => false,\n        RACK_RUN_ONCE     => false\n      }\n    end\n\n    # Parse a chunk of data into the request environment\n    # Raises a +InvalidRequest+ if invalid.\n    # Returns +true+ if the parsing is complete.\n    def parse(data)\n      if @parser.finished?  # Header finished, can only be some more body\n        body << data\n      else                  # Parse more header using the super parser\n        @data << data\n        raise InvalidRequest, 'Header longer than allowed' if @data.size > MAX_HEADER\n\n        @nparsed = @parser.execute(@env, @data, @nparsed)\n\n        # Transfert to a tempfile if body is very big\n        move_body_to_tempfile if @parser.finished? && content_length > MAX_BODY\n      end\n\n\n      if finished?   # Check if header and body are complete\n        @data = nil\n        @body.rewind\n        true         # Request is fully parsed\n      else\n        false        # Not finished, need more data\n      end\n    end\n\n    # +true+ if headers and body are finished parsing\n    def finished?\n      @parser.finished? && @body.size >= content_length\n    end\n\n    # Expected size of the body\n    def content_length\n      @env[CONTENT_LENGTH].to_i\n    end\n\n    # Returns +true+ if the client expect the connection to be persistent.\n    def persistent?\n      # Clients and servers SHOULD NOT assume that a persistent connection\n      # is maintained for HTTP versions less than 1.1 unless it is explicitly\n      # signaled. (http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html)\n      if @env[HTTP_VERSION] == HTTP_1_0\n        @env[CONNECTION] =~ KEEP_ALIVE_REGEXP\n\n      # HTTP/1.1 client intends to maintain a persistent connection unless\n      # a Connection header including the connection-token \"close\" was sent\n      # in the request\n      else\n        @env[CONNECTION].nil? || @env[CONNECTION] !~ CLOSE_REGEXP\n      end\n    end\n\n    def remote_address=(address)\n      @env[REMOTE_ADDR] = address\n    end\n\n    def forwarded_for\n      @env[FORWARDED_FOR]\n    end\n\n    def threaded=(value)\n      @env[RACK_MULTITHREAD] = value\n    end\n    \n    def async_callback=(callback)\n      @env[ASYNC_CALLBACK] = callback\n      @env[ASYNC_CLOSE] = EventMachine::DefaultDeferrable.new\n    end\n    \n    def async_close\n      @async_close ||= @env[ASYNC_CLOSE]\n    end\n\n    # Close any resource used by the request\n    def close\n      @body.delete if @body.class == Tempfile\n    end\n\n    private\n      def move_body_to_tempfile\n        current_body = @body\n        current_body.rewind\n        @body = Tempfile.new(BODY_TMPFILE)\n        @body.binmode\n        @body << current_body.read\n        @env[RACK_INPUT] = @body\n      end\n  end\nend\n", "module Thin  \n  # Raised when a feature is not supported on the\n  # current platform.\n  class PlatformNotSupported < RuntimeError; end\n  \n  module VERSION #:nodoc:\n    MAJOR    = 1\n    MINOR    = 2\n    TINY     = 2\n    \n    STRING   = [MAJOR, MINOR, TINY].join('.')\n    \n    CODENAME = \"I Find Your Lack of Sauce Disturbing\".freeze\n    \n    RACK     = [1, 0].freeze # Rack protocol version\n  end\n  \n  NAME    = 'thin'.freeze\n  SERVER  = \"#{NAME} #{VERSION::STRING} codename #{VERSION::CODENAME}\".freeze  \n  \n  def self.win?\n    RUBY_PLATFORM =~ /mswin|mingw/\n  end\n  \n  def self.linux?\n    RUBY_PLATFORM =~ /linux/\n  end\n  \n  def self.ruby_18?\n    RUBY_VERSION =~ /^1\\.8/\n  end\nend\n", "require File.dirname(__FILE__) + '/spec_helper'\n\ndescribe Connection do\n  before do\n    @connection = Connection.new(mock('EM', :null_object => true))\n    @connection.post_init\n    @connection.app = proc do |env|\n      [200, {}, ['']]\n    end\n  end\n  \n  it \"should parse on receive_data\" do\n    @connection.request.should_receive(:parse).with('GET')\n    @connection.receive_data('GET')\n  end\n\n  it \"should close connection on InvalidRequest error in receive_data\" do\n    @connection.request.stub!(:parse).and_raise(InvalidRequest)\n    @connection.should_receive(:close_connection)\n    @connection.receive_data('')\n  end\n  \n  it \"should process when parsing complete\" do\n    @connection.request.should_receive(:parse).and_return(true)\n    @connection.should_receive(:process)\n    @connection.receive_data('GET')\n  end\n  \n  it \"should process\" do\n    @connection.process\n  end\n  \n  it \"should rescue error in process\" do\n    @connection.app.should_receive(:call).and_raise(StandardError)\n    @connection.process\n  end\n  \n  it \"should rescue Timeout error in process\" do\n    @connection.app.should_receive(:call).and_raise(Timeout::Error.new(\"timeout error not rescued\"))\n    @connection.process\n  end\n  \n  it \"should return HTTP_X_FORWARDED_FOR as remote_address\" do\n    @connection.request.env['HTTP_X_FORWARDED_FOR'] = '1.2.3.4'\n    @connection.remote_address.should == '1.2.3.4'\n  end\n  \n  it \"should return nil on error retreiving remote_address\" do\n    @connection.stub!(:get_peername).and_raise(RuntimeError)\n    @connection.remote_address.should be_nil\n  end\n  \n  it \"should return nil on nil get_peername\" do\n    @connection.stub!(:get_peername).and_return(nil)\n    @connection.remote_address.should be_nil\n  end\n  \n  it \"should return nil on empty get_peername\" do\n    @connection.stub!(:get_peername).and_return('')\n    @connection.remote_address.should be_nil\n  end\n  \n  it \"should return remote_address\" do\n    @connection.stub!(:get_peername).and_return(Socket.pack_sockaddr_in(3000, '127.0.0.1'))\n    @connection.remote_address.should == '127.0.0.1'\n  end\n  \n  it \"should not be persistent\" do\n    @connection.should_not be_persistent\n  end\n\n  it \"should be persistent when response is and allowed\" do\n    @connection.response.stub!(:persistent?).and_return(true)\n    @connection.can_persist!\n    @connection.should be_persistent\n  end\n\n  it \"should not be persistent when response is but not allowed\" do\n    @connection.response.persistent!\n    @connection.should_not be_persistent\n  end\n  \n  it \"should set request env as rack.multithread\" do\n    EventMachine.should_receive(:defer)\n    \n    @connection.threaded = true\n    @connection.process\n    \n    @connection.request.env[\"rack.multithread\"].should == true\n  end\n  \n  it \"should set as threaded when app.deferred? is true\" do\n    @connection.app.should_receive(:deferred?).and_return(true)\n    @connection.should be_threaded\n  end\n  \n  it \"should not set as threaded when app.deferred? is false\" do\n    @connection.app.should_receive(:deferred?).and_return(false)\n    @connection.should_not be_threaded\n  end\n\n  it \"should not set as threaded when app do not respond to deferred?\" do\n    @connection.should_not be_threaded\n  end\nend"], "fixing_code": ["== 1.2.3\n * Fix Remote address spoofing vulnerability in Connection#remote_address [Alexey Borzenkov]\n * Fix uninitialized constant ActionController::Dispatcher error with Rails 1.2.3 [Chris Anderton] [#103 state:resolved]\n\n== 1.2.2 I Find Your Lack of Sauce Disturbing release\n * Fix force kill under 1.9 [Alexey Chebotar]\n * Fix regression when --only option is used w/ --socket.\n * Add process name 'tag' functionality. Easier to distinguish thin daemons \n   from eachother in process listing [ctcherry]\n\n== 1.2.1 Asynctilicious Ultra Supreme release\n * Require Rack 1.0.0\n * Require EventMachine 0.12.6\n * Use Rails Rack based dispatcher when available\n * Allow String for response body\n * Require openssl before eventmachine to prevent crash in 1.9\n\n== 1.2.0 Asynctilicious Supreme release \n * Add support for Windows mingw Ruby distro [Juan C. Rodriguez]\n * Add async response support, see example/async_*.ru [raggi]\n\n== 1.1.1 Super Disco Power Plus release \n * Fix bug when running with only options [hasimo]\n\n== 1.1.0 Super Disco Power release\n * Require EventMachine 0.12.4\n * Remove Thin handler, now part of Rack 0.9.1\n * Fix Rack protocol version to 0.1 in environment hash.\n * Fix error when passing no_epoll option to a cluster.\n * Omit parsing #defined strings [J\u00e9r\u00e9my Zurcher]\n * Defaults SERVER_NAME to localhost like webrick does [#87 state:resolved]\n * Namespace parser to prevent error when mongrel is required [cliffmoon]\n * Set RACK_ENV based on environment option when loading rackup file [Curtis Summers] [#83 state:resolved]\n * Fixes a warning RE relative_url_root when using a prefix with Rails 2.1.1 [seriph] [#85 state:resolved]\n * --only can work as a sequence number (if < 80) or a port number (if >= 80) [jmay] [#81 state:resolved]\n\n== 1.0.0 That's What She Said release\n * Fixed vlad.rake to allow TCP or socket [hellekin]\n * Updated Mack adapter to handle both <0.8.0 and >0.8.0 [Mark Bates]\n * rails rack adapter uses File.readable_real? so it recognizes ACL permissions [Ricardo Chimal]\n * Log a warning if Rack application returns nil body [Michael S. Klishin]\n * Handle nil and Time header values correctly [#76 state:resolved] [tmm1]\n * Add Content-Length header to response automatically when possible [#74 state:resolved] [dkubb]\n * Runner now remembers -r, -D and -V parameters so that clustered servers inherit those and\n   `restart` keep your parameters.\n * Make Set-Cookie header, in Rails adapter, compatible with current Rack spec [Pedro Belo]\n   [#73, state:resolved]\n * Add --no-epoll option to disable epoll usage on Linux [#61 state:resolved]\n * Add --force (-f) option to force stopping of a daemonized server [#72 state:resolved]\n * Update halycon adapter loader [mtodd]\n\n== 0.8.2 Double Margarita release\n * Require EventMachine 0.12.0\n * [bug] Fix timeout handling when running command\n * [bug] Fix hanging when restarting and no process is running in single server move, fixes #67\n * Added Mack adapter [markbates]\n * Allow rackup .rb files by getting a conventionally named constant as the app [bmizerany]\n\n== 0.8.1 Rebel Porpoise release\n * [bug] Rescue all types of errors when processing request, fixes #62\n * [bug] Use Swiftiply backend when -y option is specified, fixes #63 and #64\n * Allow passing port as a string in Server.new\n * Define deferred?(env) in your Rack application to set if a request is handled in a\n\t thread (return true) or not (return false).\n\n== 0.8.0 Dodgy Dentist release\n * [bug] Fix server crash when header too large.\n * Add --require (-r) option to require a library, before executing your script.\n * Rename --rackup short option to -R, warn and load as rackup when file ends with .ru.\n * List supported adapters in command usage.\n * Add file adapter to built-in adapter, serve static files in current directory.\n * Allow disabling signal handling in Server with :signals => false\n * Make Server.new arguments more flexible, can now specify any of host, port, app or hash options.\n * Add --backend option to specified which backend to use, closes #55\n * [bug] Serve static file only on GET and HEAD requests in Rails adapter, fixes #58\n * Add threaded option to run server in threaded mode, calling the application in a\n   thread allowing for concurrency in the Rack adapter, closes #46\n * Guess which adapter to use from directory (chdir option)\n   or use specified one in 'adapter' option, re #47.\n\n== 0.7.1 Fancy Pants release\n * Clean stale PID files when starting as daemon, fixes #53 [Chu Yeow]\n * Require EventMachine 0.11.0 for UNIX domain sockets. Until it's released, install from:\n   gem install eventmachine --source http://code.macournoyer.com\n * Ruby 1.8.5 compatibility, closes #49 [Wincent Colaiuta]\n * Move all EventMachine stuff out of Server, you can now create a Thin Backend that\n   does not depend on EventMachine.\n * Rename Connector to Backend. Extend Thin::Backends::Base to implement your own.\n * Fix high memory usage with big POST body, fixes #48\n\n== 0.7.0 Spherical Cow release\n * Add --max-persistent-conns option to sets the maximum number of persistent connections.\n   Set to 0 to disable Keep-Alive.\n * INT signal now force stop and QUIT signal gracefully stops.\n * Warn when descriptors table size can't be set as high as expected.\n * Eval Rackup config file using top level bindings.\n * Remove daemons gem dependency on Windows plateform, fixes #45.\n * Change default timeout from 60 to 30 seconds.\n * Add --max-conns option to sets the maximum number of file or socket descriptors that\n   your process may open, defaults to 1024.\n * Tail logfile when stopping and restarting a demonized server, fixes #26.\n * Wrap application in a Rack::CommonLogger adapter in debug mode.\n * --debug (-D) option no longer set $DEBUG so logging will be less verbose\n   and Ruby won't be too strict, fixes #36.\n * Deprecate Server#silent in favour of Logging.silent.\n * Persistent connection (keep-alive) support.\n * Fix -s option not being included in generated config file, fixes #37.\n * Add Swiftiply support. Use w/ the --swiftiply (-y) option in the thin script,\n   closes #28 [Alex MacCaw]\n\n== 0.6.4 Sexy Lobster release\n * Fix error when stopping server on UNIX domain socket, fixes #42\n * Rescue errors in Connection#get_peername more gracefully, setting REMOTE_ADDR to nil, fixes #43\n\n== 0.6.3 Ninja Cookie release\n * Add tasks for Vlad the Deployer in example/vlad.rake [cnantais]\n * Add Ramaze Rackup config file in example dir [tmm1]\n   Use like this from you Ramaze app dir:\n   \n     thin start -r /path/to/thin/example/ramaze.ru\n   \n * Add the --rackup option to load a Rack config file instead of the Rails adapter.\n   So you can use any framework with the thin script and start cluster and stuff like that.\n   A Rack config file is one that is usable through the rackup command and looks like this:\n     \n     use Rack::CommonLogger\n     run MyCrazyRackAdapter.new(:uterly, 'cool')\n     \n   Then use it with thin like this:\n     \n     thin start --rackup config.ru\n     \n * thin config --chrdir ... -C thin/yml do not change current directory anymore, fixes #33.\n * Add a better sample god config file in example/thin.god that loads all info from config\n   files in /etc/thin. Drop-in replacement for the thin runlevel service [Gump].\n * Add support for specifying a custom Connector to the server and add more doc about Server\n   configuration.\n * Add a script to run thin as a runlevel service that can start at startup, closes #31 [Gump]\n   Setup the service like this:\n   \n     sudo thin install /etc/thin\n   \n   This will install the boot script under /etc/init.d/thin. Then copy your config files to\n   /etc/thin. Works only under Linux.\n * Set process name to 'thin server (0.0.0.0:3000)' when running as a daemon, closes #32.\n * Make sure chdir option from config file is used when present.\n * Raise an error when starting a server as a daemon and pid file already exist, fixes #27.\n\n== 0.6.2 Rambo release\n * Server now let current connections finish before stopping, fixes #18\n * Fix uploading hanging bug when body is moved to a tempfile,\n   also delete the tempfile properly upon completion, fixes #25\n * 'thin restart' now sends HUP signals rather then stopping & starting, closes #17\n * HUP signal now launches a new process with the same options.\n * Add PID and more info from the last request to the Stats adapter\n   mostly taken from Rack::ShowException.\n * pid and log files in cluster are no longer required to be relative to the\n   app directory (chdir option), fixes #24\n * Revert to using #each when building response headers under Ruby 1.8,\n   solves an issue w/ Camping adapter, fixes #22\n * Restructure thin script options in 3 sections: server, daemon and cluster\n * Add --only (-o) option to control only one server of a cluster.\n * Stylize stats page and make the url configurable from the thin script.\n * Raise error if attempting to use unix sockets on windows.\n * Add example config files for http://www.tildeslash.com/monit usage.\n   Include the example file using \"include /path/to/thin/monit/file\" in your monitrc file.\n   The group settings let you do this to manage your clusters:\n   \n     sudo monit -g blog restart all\n    \n   There are examples of thin listening on sockets and thin listening on unix sockets.\n\n== 0.6.1 Cheesecake release\n * Remove socket file when server stops.\n * Set back cluster to use 'thin' command to launch servers.\n\n== 0.6.0 Big Pony release\n * Add support for connection through UNIX domain socket.\n   Use the --socket (-S) option w/ the thin script to configure the socket filename.\n   Nginx support binding to a UNIX socket like this:\n   \n     upstream  backend {\n       server   unix:/tmp/thin.0.sock;\n       server   unix:/tmp/thin.1.sock;\n       server   unix:/tmp/thin.2.sock;\n     }\n  \n   Start your servers like this:\n   \n     thin start -s3 -S/tmp/thin.sock\n   \n * Remove Server#listen! method. Use Server#start instead.\n * Server can now yield a Rack::Builder to allow building an app in one call:\n \n     Server.start '0.0.0.0', 3000 do\n       use Rack::CommonLogger\n       use Rack::ShowExceptions\n       map \"/lobster\" do\n         use Rack::Lint\n         run Rack::Lobster.new\n       end\n     end\n     \n * Add a very basic stats page through Stats adapter, load w/ --stats and browse to /stats.\n * Add --trace (-V) option to trace request/response and get backtrace w/out all Ruby debug stuff.\n * Add --config (-C) option to load options from a config file in thin script [Matt Todd].\n * Alter response headers to output directly to a string.\n * Improve specs stability.\n * Move request body to a Tempfile if too big (> 112 MB)\n * Remove useless check for max header size in Request (already done in the parser)\n\n== 0.5.4 Flying Mustard release\n * Don't read the full body, use direct streaming when sending response.\n   See: Response#each\n   As a result, the Content-Length can not be calculated anymore.\n   You have to do set this in your adapter. All frameworks do it anyway.\n   It improve memory usage and boost speed for low concurrency.\n   Thanks to Kent Sibilev and Ezra for their help on that one.\n * Add 'Server' response header\n * Fix --user and --group option not changing daemon process privileges\n \n== 0.5.3 Purple Yogurt release\n * win32 pre-compiled gem now available\n * change rake task configuration to allow win32 gem build\n * Add prefix option to thin script to mount app under a given path.\n\n== 0.5.2 Cheezburger release\n * Add cluster support through the -s option in the thin script, start 3 thins like this:\n    thin start -s3 -p3000\n   3 thin servers will be started on port 3000, 3001, 3002, also the port number will be\n   injected in the pid and log filenames.\n * Fix IOError when writing to logger when starting server as a daemon.\n * Really change directory when the -c option is specified.\n * Add restart command to thin script.\n * Fix typos in thin script usage message and expand chdir path.\n * Rename thin script options to be the same as mongrel_rails script [thronedrk]:\n     -o --host  => -a --address\n     --log-file => --log\n     --pid-file => --pid\n     --env      => --environment\n \n== 0.5.1 LOLCAT release\n * Add URL rewriting to Rails adapter so that page caching works and / fetches index.html if present.\n * Fix bug in multiline response header parsing.\n * Add specs for the Rails adapter.\n * Fix Set-Cookie headers in Rails adapter to handle multiple values correctly.\n * Fix Ruby 1.9 incompatibility in Response#headers= and Rakefile.\n * Fix parser to be Ruby 1.9 compatible [Aman Gupta]\n * Set gemspec to use EventMachine version 0.8.1 as it's the latest one having precompiled windows binaries.\n   [Francis Cianfrocca].\n * Add -D option to thin script to set debugging on.\n * Output incoming data and response when debugging is on.\n\n== 0.5.0\n * Full rewrite to use EventMachine, Rack and Mongrel parser\n \n== 0.4.1\n * Fix Rails environment option not being used in thin script.\n \n== 0.4.0\n * First alphaish release as a gem.\n", "require 'socket'\n\nmodule Thin\n  # Connection between the server and client.\n  # This class is instanciated by EventMachine on each new connection\n  # that is opened.\n  class Connection < EventMachine::Connection\n    CONTENT_LENGTH    = 'Content-Length'.freeze\n    TRANSFER_ENCODING = 'Transfer-Encoding'.freeze\n    CHUNKED_REGEXP    = /\\bchunked\\b/i.freeze\n\n    include Logging\n    \n    # This is a template async response. N.B. Can't use string for body on 1.9\n    AsyncResponse = [-1, {}, []].freeze\n    \n    # Rack application (adapter) served by this connection.\n    attr_accessor :app\n\n    # Backend to the server\n    attr_accessor :backend\n\n    # Current request served by the connection\n    attr_accessor :request\n\n    # Next response sent through the connection\n    attr_accessor :response\n\n    # Calling the application in a threaded allowing\n    # concurrent processing of requests.\n    attr_writer :threaded\n\n    # Get the connection ready to process a request.\n    def post_init\n      @request  = Request.new\n      @response = Response.new\n    end\n\n    # Called when data is received from the client.\n    def receive_data(data)\n      trace { data }\n      process if @request.parse(data)\n    rescue InvalidRequest => e\n      log \"!! Invalid request\"\n      log_error e\n      close_connection\n    end\n\n    # Called when all data was received and the request\n    # is ready to be processed.\n    def process\n      if threaded?\n        @request.threaded = true\n        EventMachine.defer(method(:pre_process), method(:post_process))\n      else\n        @request.threaded = false\n        post_process(pre_process)\n      end\n    end\n\n    def pre_process\n      # Add client info to the request env\n      @request.remote_address = remote_address\n\n      # Connection may be closed unless the App#call response was a [-1, ...]\n      # It should be noted that connection objects will linger until this \n      # callback is no longer referenced, so be tidy!\n      @request.async_callback = method(:post_process)\n      \n      # When we're under a non-async framework like rails, we can still spawn\n      # off async responses using the callback info, so there's little point\n      # in removing this.\n      response = AsyncResponse\n      catch(:async) do\n        # Process the request calling the Rack adapter\n        response = @app.call(@request.env)\n      end\n      response\n    rescue Exception\n      handle_error\n      terminate_request\n      nil # Signal to post_process that the request could not be processed\n    end\n\n    def post_process(result)\n      return unless result\n      result = result.to_a\n      \n      # Status code -1 indicates that we're going to respond later (async).\n      return if result.first == AsyncResponse.first\n\n      # Set the Content-Length header if possible\n      set_content_length(result) if need_content_length?(result)\n      \n      @response.status, @response.headers, @response.body = *result\n\n      log \"!! Rack application returned nil body. Probably you wanted it to be an empty string?\" if @response.body.nil?\n\n      # Make the response persistent if requested by the client\n      @response.persistent! if @request.persistent?\n\n      # Send the response\n      @response.each do |chunk|\n        trace { chunk }\n        send_data chunk\n      end\n\n    rescue Exception\n      handle_error\n    ensure\n      # If the body is being deferred, then terminate afterward.\n      if @response.body.respond_to?(:callback) && @response.body.respond_to?(:errback)\n        @response.body.callback { terminate_request }\n        @response.body.errback  { terminate_request }\n      else\n        # Don't terminate the response if we're going async.\n        terminate_request unless result && result.first == AsyncResponse.first\n      end\n    end\n\n    # Logs catched exception and closes the connection.\n    def handle_error\n      log \"!! Unexpected error while processing request: #{$!.message}\"\n      log_error\n      close_connection rescue nil\n    end\n\n    def close_request_response\n      @request.async_close.succeed if @request.async_close\n      @request.close  rescue nil\n      @response.close rescue nil\n    end\n\n    # Does request and response cleanup (closes open IO streams and\n    # deletes created temporary files).\n    # Re-initializes response and request if client supports persistent\n    # connection.\n    def terminate_request\n      unless persistent?\n        close_connection_after_writing rescue nil\n        close_request_response\n      else\n        close_request_response\n        # Prepare the connection for another request if the client\n        # supports HTTP pipelining (persistent connection).\n        post_init\n      end\n    end\n\n    # Called when the connection is unbinded from the socket\n    # and can no longer be used to process requests.\n    def unbind\n      @request.async_close.succeed if @request.async_close\n      @response.body.fail if @response.body.respond_to?(:fail)\n      @backend.connection_finished(self)\n    end\n\n    # Allows this connection to be persistent.\n    def can_persist!\n      @can_persist = true\n    end\n\n    # Return +true+ if this connection is allowed to stay open and be persistent.\n    def can_persist?\n      @can_persist\n    end\n\n    # Return +true+ if the connection must be left open\n    # and ready to be reused for another request.\n    def persistent?\n      @can_persist && @response.persistent?\n    end\n\n    # +true+ if <tt>app.call</tt> will be called inside a thread.\n    # You can set all requests as threaded setting <tt>Connection#threaded=true</tt>\n    # or on a per-request case returning +true+ in <tt>app.deferred?</tt>.\n    def threaded?\n      @threaded || (@app.respond_to?(:deferred?) && @app.deferred?(@request.env))\n    end\n\n    # IP Address of the remote client.\n    def remote_address\n      socket_address\n    rescue Exception\n      log_error\n      nil\n    end\n\n    protected\n\n      # Returns IP address of peer as a string.\n      def socket_address\n        Socket.unpack_sockaddr_in(get_peername)[1]\n      end\n\n    private\n      def need_content_length?(result)\n        status, headers, body = result\n        return false if status == -1\n        return false if headers.has_key?(CONTENT_LENGTH)\n        return false if (100..199).include?(status) || status == 204 || status == 304\n        return false if headers.has_key?(TRANSFER_ENCODING) && headers[TRANSFER_ENCODING] =~ CHUNKED_REGEXP\n        return false unless body.kind_of?(String) || body.kind_of?(Array)\n        true\n      end\n\n      def set_content_length(result)\n        headers, body = result[1..2]\n        case body\n        when String\n          # See http://redmine.ruby-lang.org/issues/show/203\n          headers[CONTENT_LENGTH] = (body.respond_to?(:bytesize) ? body.bytesize : body.size).to_s\n        when Array\n           bytes = 0\n           body.each do |p|\n             bytes += p.respond_to?(:bytesize) ? p.bytesize : p.size\n           end\n           headers[CONTENT_LENGTH] = bytes.to_s\n        end\n      end\n  end\nend\n", "require 'thin_parser'\nrequire 'tempfile'\n\nmodule Thin\n  # Raised when an incoming request is not valid\n  # and the server can not process it.\n  class InvalidRequest < IOError; end\n\n  # A request sent by the client to the server.\n  class Request\n    # Maximum request body size before it is moved out of memory\n    # and into a tempfile for reading.\n    MAX_BODY          = 1024 * (80 + 32)\n    BODY_TMPFILE      = 'thin-body'.freeze\n    MAX_HEADER        = 1024 * (80 + 32)\n\n    # Freeze some HTTP header names & values\n    SERVER_SOFTWARE   = 'SERVER_SOFTWARE'.freeze\n    SERVER_NAME       = 'SERVER_NAME'.freeze\n    LOCALHOST         = 'localhost'.freeze\n    HTTP_VERSION      = 'HTTP_VERSION'.freeze\n    HTTP_1_0          = 'HTTP/1.0'.freeze\n    REMOTE_ADDR       = 'REMOTE_ADDR'.freeze\n    CONTENT_LENGTH    = 'CONTENT_LENGTH'.freeze\n    CONNECTION        = 'HTTP_CONNECTION'.freeze\n    KEEP_ALIVE_REGEXP = /\\bkeep-alive\\b/i.freeze\n    CLOSE_REGEXP      = /\\bclose\\b/i.freeze\n    \n    # Freeze some Rack header names\n    RACK_INPUT        = 'rack.input'.freeze\n    RACK_VERSION      = 'rack.version'.freeze\n    RACK_ERRORS       = 'rack.errors'.freeze\n    RACK_MULTITHREAD  = 'rack.multithread'.freeze\n    RACK_MULTIPROCESS = 'rack.multiprocess'.freeze\n    RACK_RUN_ONCE     = 'rack.run_once'.freeze\n    ASYNC_CALLBACK    = 'async.callback'.freeze\n    ASYNC_CLOSE       = 'async.close'.freeze\n\n    # CGI-like request environment variables\n    attr_reader :env\n\n    # Unparsed data of the request\n    attr_reader :data\n\n    # Request body\n    attr_reader :body\n\n    def initialize\n      @parser   = Thin::HttpParser.new\n      @data     = ''\n      @nparsed  = 0\n      @body     = StringIO.new\n      @env      = {\n        SERVER_SOFTWARE   => SERVER,\n        SERVER_NAME       => LOCALHOST,\n\n        # Rack stuff\n        RACK_INPUT        => @body,\n\n        RACK_VERSION      => VERSION::RACK,\n        RACK_ERRORS       => STDERR,\n\n        RACK_MULTITHREAD  => false,\n        RACK_MULTIPROCESS => false,\n        RACK_RUN_ONCE     => false\n      }\n    end\n\n    # Parse a chunk of data into the request environment\n    # Raises a +InvalidRequest+ if invalid.\n    # Returns +true+ if the parsing is complete.\n    def parse(data)\n      if @parser.finished?  # Header finished, can only be some more body\n        body << data\n      else                  # Parse more header using the super parser\n        @data << data\n        raise InvalidRequest, 'Header longer than allowed' if @data.size > MAX_HEADER\n\n        @nparsed = @parser.execute(@env, @data, @nparsed)\n\n        # Transfert to a tempfile if body is very big\n        move_body_to_tempfile if @parser.finished? && content_length > MAX_BODY\n      end\n\n\n      if finished?   # Check if header and body are complete\n        @data = nil\n        @body.rewind\n        true         # Request is fully parsed\n      else\n        false        # Not finished, need more data\n      end\n    end\n\n    # +true+ if headers and body are finished parsing\n    def finished?\n      @parser.finished? && @body.size >= content_length\n    end\n\n    # Expected size of the body\n    def content_length\n      @env[CONTENT_LENGTH].to_i\n    end\n\n    # Returns +true+ if the client expect the connection to be persistent.\n    def persistent?\n      # Clients and servers SHOULD NOT assume that a persistent connection\n      # is maintained for HTTP versions less than 1.1 unless it is explicitly\n      # signaled. (http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html)\n      if @env[HTTP_VERSION] == HTTP_1_0\n        @env[CONNECTION] =~ KEEP_ALIVE_REGEXP\n\n      # HTTP/1.1 client intends to maintain a persistent connection unless\n      # a Connection header including the connection-token \"close\" was sent\n      # in the request\n      else\n        @env[CONNECTION].nil? || @env[CONNECTION] !~ CLOSE_REGEXP\n      end\n    end\n\n    def remote_address=(address)\n      @env[REMOTE_ADDR] = address\n    end\n\n    def threaded=(value)\n      @env[RACK_MULTITHREAD] = value\n    end\n    \n    def async_callback=(callback)\n      @env[ASYNC_CALLBACK] = callback\n      @env[ASYNC_CLOSE] = EventMachine::DefaultDeferrable.new\n    end\n    \n    def async_close\n      @async_close ||= @env[ASYNC_CLOSE]\n    end\n\n    # Close any resource used by the request\n    def close\n      @body.delete if @body.class == Tempfile\n    end\n\n    private\n      def move_body_to_tempfile\n        current_body = @body\n        current_body.rewind\n        @body = Tempfile.new(BODY_TMPFILE)\n        @body.binmode\n        @body << current_body.read\n        @env[RACK_INPUT] = @body\n      end\n  end\nend\n", "module Thin  \n  # Raised when a feature is not supported on the\n  # current platform.\n  class PlatformNotSupported < RuntimeError; end\n  \n  module VERSION #:nodoc:\n    MAJOR    = 1\n    MINOR    = 2\n    TINY     = 3\n    \n    STRING   = [MAJOR, MINOR, TINY].join('.')\n    \n    CODENAME = \"Astroboy\".freeze\n    \n    RACK     = [1, 0].freeze # Rack protocol version\n  end\n  \n  NAME    = 'thin'.freeze\n  SERVER  = \"#{NAME} #{VERSION::STRING} codename #{VERSION::CODENAME}\".freeze  \n  \n  def self.win?\n    RUBY_PLATFORM =~ /mswin|mingw/\n  end\n  \n  def self.linux?\n    RUBY_PLATFORM =~ /linux/\n  end\n  \n  def self.ruby_18?\n    RUBY_VERSION =~ /^1\\.8/\n  end\nend\n", "require File.dirname(__FILE__) + '/spec_helper'\n\ndescribe Connection do\n  before do\n    @connection = Connection.new(mock('EM', :null_object => true))\n    @connection.post_init\n    @connection.app = proc do |env|\n      [200, {}, ['']]\n    end\n  end\n  \n  it \"should parse on receive_data\" do\n    @connection.request.should_receive(:parse).with('GET')\n    @connection.receive_data('GET')\n  end\n\n  it \"should close connection on InvalidRequest error in receive_data\" do\n    @connection.request.stub!(:parse).and_raise(InvalidRequest)\n    @connection.should_receive(:close_connection)\n    @connection.receive_data('')\n  end\n  \n  it \"should process when parsing complete\" do\n    @connection.request.should_receive(:parse).and_return(true)\n    @connection.should_receive(:process)\n    @connection.receive_data('GET')\n  end\n  \n  it \"should process\" do\n    @connection.process\n  end\n  \n  it \"should rescue error in process\" do\n    @connection.app.should_receive(:call).and_raise(StandardError)\n    @connection.process\n  end\n  \n  it \"should rescue Timeout error in process\" do\n    @connection.app.should_receive(:call).and_raise(Timeout::Error.new(\"timeout error not rescued\"))\n    @connection.process\n  end\n  \n  it \"should not return HTTP_X_FORWARDED_FOR as remote_address\" do\n    @connection.request.env['HTTP_X_FORWARDED_FOR'] = '1.2.3.4'\n    @connection.stub!(:socket_address).and_return(\"127.0.0.1\")\n    @connection.remote_address.should == \"127.0.0.1\"\n  end\n  \n  it \"should return nil on error retreiving remote_address\" do\n    @connection.stub!(:get_peername).and_raise(RuntimeError)\n    @connection.remote_address.should be_nil\n  end\n  \n  it \"should return nil on nil get_peername\" do\n    @connection.stub!(:get_peername).and_return(nil)\n    @connection.remote_address.should be_nil\n  end\n  \n  it \"should return nil on empty get_peername\" do\n    @connection.stub!(:get_peername).and_return('')\n    @connection.remote_address.should be_nil\n  end\n  \n  it \"should return remote_address\" do\n    @connection.stub!(:get_peername).and_return(Socket.pack_sockaddr_in(3000, '127.0.0.1'))\n    @connection.remote_address.should == '127.0.0.1'\n  end\n  \n  it \"should not be persistent\" do\n    @connection.should_not be_persistent\n  end\n\n  it \"should be persistent when response is and allowed\" do\n    @connection.response.stub!(:persistent?).and_return(true)\n    @connection.can_persist!\n    @connection.should be_persistent\n  end\n\n  it \"should not be persistent when response is but not allowed\" do\n    @connection.response.persistent!\n    @connection.should_not be_persistent\n  end\n  \n  it \"should set request env as rack.multithread\" do\n    EventMachine.should_receive(:defer)\n    \n    @connection.threaded = true\n    @connection.process\n    \n    @connection.request.env[\"rack.multithread\"].should == true\n  end\n  \n  it \"should set as threaded when app.deferred? is true\" do\n    @connection.app.should_receive(:deferred?).and_return(true)\n    @connection.should be_threaded\n  end\n  \n  it \"should not set as threaded when app.deferred? is false\" do\n    @connection.app.should_receive(:deferred?).and_return(false)\n    @connection.should_not be_threaded\n  end\n\n  it \"should not set as threaded when app do not respond to deferred?\" do\n    @connection.should_not be_threaded\n  end\nend"], "filenames": ["CHANGELOG", "lib/thin/connection.rb", "lib/thin/request.rb", "lib/thin/version.rb", "spec/connection_spec.rb"], "buggy_code_start_loc": [1, 183, 24, 9, 43], "buggy_code_end_loc": [1, 184, 130, 14, 46], "fixing_code_start_loc": [2, 183, 23, 9, 43], "fixing_code_end_loc": [3, 184, 124, 14, 47], "type": "CWE-20", "message": "lib/thin/connection.rb in Thin web server before 1.2.4 relies on the X-Forwarded-For header to determine the IP address of the client, which allows remote attackers to spoof the IP address and hide activities via a modified X-Forwarded-For header.", "other": {"cve": {"id": "CVE-2009-3287", "sourceIdentifier": "cve@mitre.org", "published": "2009-09-22T10:30:00.640", "lastModified": "2009-09-22T10:30:00.640", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lib/thin/connection.rb in Thin web server before 1.2.4 relies on the X-Forwarded-For header to determine the IP address of the client, which allows remote attackers to spoof the IP address and hide activities via a modified X-Forwarded-For header."}, {"lang": "es", "value": "lib/thin/connection.rb en el servidor web Thin anterior a v1.2.4 permite determinar la direcci\u00f3n IP del cliente sobre la cabecera X-Forwarded-For, lo que permite a atacantes remotos suplantar la direcci\u00f3n IP y ocultar la actividad a trav\u00e9s de una cabecera X-Forwarded-For."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.2", "matchCriteriaId": "DDB8B96B-7544-4ED1-97AF-BED85A6E02A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "3722C121-CA76-4BD6-9B17-059C1051BD3D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "A8DFE094-2523-47F6-9310-BE48DF205825"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "DCA76B41-8699-4AB9-8569-98D792359C53"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "D9BDC31A-0F16-4817-802B-C603050D7E83"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.5.2:*:*:*:*:*:*:*", "matchCriteriaId": "EB082342-11F8-479C-B884-0D3E6074A600"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.5.3:*:*:*:*:*:*:*", "matchCriteriaId": "C5367748-33ED-4AFC-951A-B3B10B9CA94F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.5.4:*:*:*:*:*:*:*", "matchCriteriaId": "627C15A0-669D-4E56-9C31-8B8FBF60F3C0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "72D1B13B-96DE-4151-BEEC-2D438CBD4B7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "F90B1079-9276-486F-86B8-B7E2FEF49B84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "9A8E67F2-6A68-4DF2-BBFC-CD5FB8401CCF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "7D151CA6-9C63-489D-B4AC-19F357E75C73"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "A47C57AC-1892-40FE-9F03-DAFBAF509976"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "9EB06946-318C-4E86-8F73-43E16A9EFEA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "5F03A874-0753-49F6-A9BD-3798929B3C1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:0.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "57048132-7659-444A-B78A-12B199E935B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "F00DA27E-EB76-4773-A7DE-14246C24FFFA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "1A8B33E0-77F2-405F-8755-02C30509C652"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "49E5A94C-3262-4AA3-90F0-5E7B45E213A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "63C61B64-0B37-4F7B-8C47-BCA425E09A97"}, {"vulnerable": true, "criteria": "cpe:2.3:a:macournoyer:thin:1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "2F2E2ACB-9ED2-4712-8A25-DE288DBF27DE"}]}]}], "references": [{"url": "http://github.com/macournoyer/thin/blob/master/CHANGELOG", "source": "cve@mitre.org"}, {"url": "http://github.com/macournoyer/thin/commit/7bd027914c5ffd36bb408ef47dc749de3b6e063a", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2009/09/12/1", "source": "cve@mitre.org"}]}, "github_commit_url": "http://github.com/macournoyer/thin/commit/7bd027914c5ffd36bb408ef47dc749de3b6e063a"}}