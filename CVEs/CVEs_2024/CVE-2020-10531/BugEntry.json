{"buggy_code": ["// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n******************************************************************************\n* Copyright (C) 1999-2016, International Business Machines Corporation and\n* others. All Rights Reserved.\n******************************************************************************\n*\n* File unistr.cpp\n*\n* Modification History:\n*\n*   Date        Name        Description\n*   09/25/98    stephen     Creation.\n*   04/20/99    stephen     Overhauled per 4/16 code review.\n*   07/09/99    stephen     Renamed {hi,lo},{byte,word} to icu_X for HP/UX\n*   11/18/99    aliu        Added handleReplaceBetween() to make inherit from\n*                           Replaceable.\n*   06/25/01    grhoten     Removed the dependency on iostream\n******************************************************************************\n*/\n\n#include \"unicode/utypes.h\"\n#include \"unicode/appendable.h\"\n#include \"unicode/putil.h\"\n#include \"cstring.h\"\n#include \"cmemory.h\"\n#include \"unicode/ustring.h\"\n#include \"unicode/unistr.h\"\n#include \"unicode/utf.h\"\n#include \"unicode/utf16.h\"\n#include \"uelement.h\"\n#include \"ustr_imp.h\"\n#include \"umutex.h\"\n#include \"uassert.h\"\n\n#if 0\n\n#include <iostream>\nusing namespace std;\n\n//DEBUGGING\nvoid\nprint(const UnicodeString& s,\n      const char *name)\n{\n  UChar c;\n  cout << name << \":|\";\n  for(int i = 0; i < s.length(); ++i) {\n    c = s[i];\n    if(c>= 0x007E || c < 0x0020)\n      cout << \"[0x\" << hex << s[i] << \"]\";\n    else\n      cout << (char) s[i];\n  }\n  cout << '|' << endl;\n}\n\nvoid\nprint(const UChar *s,\n      int32_t len,\n      const char *name)\n{\n  UChar c;\n  cout << name << \":|\";\n  for(int i = 0; i < len; ++i) {\n    c = s[i];\n    if(c>= 0x007E || c < 0x0020)\n      cout << \"[0x\" << hex << s[i] << \"]\";\n    else\n      cout << (char) s[i];\n  }\n  cout << '|' << endl;\n}\n// END DEBUGGING\n#endif\n\n// Local function definitions for now\n\n// need to copy areas that may overlap\nstatic\ninline void\nus_arrayCopy(const UChar *src, int32_t srcStart,\n         UChar *dst, int32_t dstStart, int32_t count)\n{\n  if(count>0) {\n    uprv_memmove(dst+dstStart, src+srcStart, (size_t)count*sizeof(*src));\n  }\n}\n\n// u_unescapeAt() callback to get a UChar from a UnicodeString\nU_CDECL_BEGIN\nstatic UChar U_CALLCONV\nUnicodeString_charAt(int32_t offset, void *context) {\n    return ((icu::UnicodeString*) context)->charAt(offset);\n}\nU_CDECL_END\n\nU_NAMESPACE_BEGIN\n\n/* The Replaceable virtual destructor can't be defined in the header\n   due to how AIX works with multiple definitions of virtual functions.\n*/\nReplaceable::~Replaceable() {}\n\nUOBJECT_DEFINE_RTTI_IMPLEMENTATION(UnicodeString)\n\nUnicodeString U_EXPORT2\noperator+ (const UnicodeString &s1, const UnicodeString &s2) {\n    return\n        UnicodeString(s1.length()+s2.length()+1, (UChar32)0, 0).\n            append(s1).\n                append(s2);\n}\n\n//========================================\n// Reference Counting functions, put at top of file so that optimizing compilers\n//                               have a chance to automatically inline.\n//========================================\n\nvoid\nUnicodeString::addRef() {\n  umtx_atomic_inc((u_atomic_int32_t *)fUnion.fFields.fArray - 1);\n}\n\nint32_t\nUnicodeString::removeRef() {\n  return umtx_atomic_dec((u_atomic_int32_t *)fUnion.fFields.fArray - 1);\n}\n\nint32_t\nUnicodeString::refCount() const {\n  return umtx_loadAcquire(*((u_atomic_int32_t *)fUnion.fFields.fArray - 1));\n}\n\nvoid\nUnicodeString::releaseArray() {\n  if((fUnion.fFields.fLengthAndFlags & kRefCounted) && removeRef() == 0) {\n    uprv_free((int32_t *)fUnion.fFields.fArray - 1);\n  }\n}\n\n\n\n//========================================\n// Constructors\n//========================================\n\n// The default constructor is inline in unistr.h.\n\nUnicodeString::UnicodeString(int32_t capacity, UChar32 c, int32_t count) {\n  fUnion.fFields.fLengthAndFlags = 0;\n  if(count <= 0 || (uint32_t)c > 0x10ffff) {\n    // just allocate and do not do anything else\n    allocate(capacity);\n  } else if(c <= 0xffff) {\n    int32_t length = count;\n    if(capacity < length) {\n      capacity = length;\n    }\n    if(allocate(capacity)) {\n      UChar *array = getArrayStart();\n      UChar unit = (UChar)c;\n      for(int32_t i = 0; i < length; ++i) {\n        array[i] = unit;\n      }\n      setLength(length);\n    }\n  } else {  // supplementary code point, write surrogate pairs\n    if(count > (INT32_MAX / 2)) {\n      // We would get more than 2G UChars.\n      allocate(capacity);\n      return;\n    }\n    int32_t length = count * 2;\n    if(capacity < length) {\n      capacity = length;\n    }\n    if(allocate(capacity)) {\n      UChar *array = getArrayStart();\n      UChar lead = U16_LEAD(c);\n      UChar trail = U16_TRAIL(c);\n      for(int32_t i = 0; i < length; i += 2) {\n        array[i] = lead;\n        array[i + 1] = trail;\n      }\n      setLength(length);\n    }\n  }\n}\n\nUnicodeString::UnicodeString(UChar ch) {\n  fUnion.fFields.fLengthAndFlags = kLength1 | kShortString;\n  fUnion.fStackFields.fBuffer[0] = ch;\n}\n\nUnicodeString::UnicodeString(UChar32 ch) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  int32_t i = 0;\n  UBool isError = FALSE;\n  U16_APPEND(fUnion.fStackFields.fBuffer, i, US_STACKBUF_SIZE, ch, isError);\n  // We test isError so that the compiler does not complain that we don't.\n  // If isError then i==0 which is what we want anyway.\n  if(!isError) {\n    setShortLength(i);\n  }\n}\n\nUnicodeString::UnicodeString(const UChar *text) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  doAppend(text, 0, -1);\n}\n\nUnicodeString::UnicodeString(const UChar *text,\n                             int32_t textLength) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  doAppend(text, 0, textLength);\n}\n\nUnicodeString::UnicodeString(UBool isTerminated,\n                             ConstChar16Ptr textPtr,\n                             int32_t textLength) {\n  fUnion.fFields.fLengthAndFlags = kReadonlyAlias;\n  const UChar *text = textPtr;\n  if(text == NULL) {\n    // treat as an empty string, do not alias\n    setToEmpty();\n  } else if(textLength < -1 ||\n            (textLength == -1 && !isTerminated) ||\n            (textLength >= 0 && isTerminated && text[textLength] != 0)\n  ) {\n    setToBogus();\n  } else {\n    if(textLength == -1) {\n      // text is terminated, or else it would have failed the above test\n      textLength = u_strlen(text);\n    }\n    setArray(const_cast<UChar *>(text), textLength,\n             isTerminated ? textLength + 1 : textLength);\n  }\n}\n\nUnicodeString::UnicodeString(UChar *buff,\n                             int32_t buffLength,\n                             int32_t buffCapacity) {\n  fUnion.fFields.fLengthAndFlags = kWritableAlias;\n  if(buff == NULL) {\n    // treat as an empty string, do not alias\n    setToEmpty();\n  } else if(buffLength < -1 || buffCapacity < 0 || buffLength > buffCapacity) {\n    setToBogus();\n  } else {\n    if(buffLength == -1) {\n      // fLength = u_strlen(buff); but do not look beyond buffCapacity\n      const UChar *p = buff, *limit = buff + buffCapacity;\n      while(p != limit && *p != 0) {\n        ++p;\n      }\n      buffLength = (int32_t)(p - buff);\n    }\n    setArray(buff, buffLength, buffCapacity);\n  }\n}\n\nUnicodeString::UnicodeString(const char *src, int32_t length, EInvariant) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  if(src==NULL) {\n    // treat as an empty string\n  } else {\n    if(length<0) {\n      length=(int32_t)uprv_strlen(src);\n    }\n    if(cloneArrayIfNeeded(length, length, FALSE)) {\n      u_charsToUChars(src, getArrayStart(), length);\n      setLength(length);\n    } else {\n      setToBogus();\n    }\n  }\n}\n\n#if U_CHARSET_IS_UTF8\n\nUnicodeString::UnicodeString(const char *codepageData) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  if(codepageData != 0) {\n    setToUTF8(codepageData);\n  }\n}\n\nUnicodeString::UnicodeString(const char *codepageData, int32_t dataLength) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  // if there's nothing to convert, do nothing\n  if(codepageData == 0 || dataLength == 0 || dataLength < -1) {\n    return;\n  }\n  if(dataLength == -1) {\n    dataLength = (int32_t)uprv_strlen(codepageData);\n  }\n  setToUTF8(StringPiece(codepageData, dataLength));\n}\n\n// else see unistr_cnv.cpp\n#endif\n\nUnicodeString::UnicodeString(const UnicodeString& that) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  copyFrom(that);\n}\n\nUnicodeString::UnicodeString(UnicodeString &&src) U_NOEXCEPT {\n  copyFieldsFrom(src, TRUE);\n}\n\nUnicodeString::UnicodeString(const UnicodeString& that,\n                             int32_t srcStart) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  setTo(that, srcStart);\n}\n\nUnicodeString::UnicodeString(const UnicodeString& that,\n                             int32_t srcStart,\n                             int32_t srcLength) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  setTo(that, srcStart, srcLength);\n}\n\n// Replaceable base class clone() default implementation, does not clone\nReplaceable *\nReplaceable::clone() const {\n  return NULL;\n}\n\n// UnicodeString overrides clone() with a real implementation\nUnicodeString *\nUnicodeString::clone() const {\n  return new UnicodeString(*this);\n}\n\n//========================================\n// array allocation\n//========================================\n\nnamespace {\n\nconst int32_t kGrowSize = 128;\n\n// The number of bytes for one int32_t reference counter and capacity UChars\n// must fit into a 32-bit size_t (at least when on a 32-bit platform).\n// We also add one for the NUL terminator, to avoid reallocation in getTerminatedBuffer(),\n// and round up to a multiple of 16 bytes.\n// This means that capacity must be at most (0xfffffff0 - 4) / 2 - 1 = 0x7ffffff5.\n// (With more complicated checks we could go up to 0x7ffffffd without rounding up,\n// but that does not seem worth it.)\nconst int32_t kMaxCapacity = 0x7ffffff5;\n\nint32_t getGrowCapacity(int32_t newLength) {\n  int32_t growSize = (newLength >> 2) + kGrowSize;\n  if(growSize <= (kMaxCapacity - newLength)) {\n    return newLength + growSize;\n  } else {\n    return kMaxCapacity;\n  }\n}\n\n}  // namespace\n\nUBool\nUnicodeString::allocate(int32_t capacity) {\n  if(capacity <= US_STACKBUF_SIZE) {\n    fUnion.fFields.fLengthAndFlags = kShortString;\n    return TRUE;\n  }\n  if(capacity <= kMaxCapacity) {\n    ++capacity;  // for the NUL\n    // Switch to size_t which is unsigned so that we can allocate up to 4GB.\n    // Reference counter + UChars.\n    size_t numBytes = sizeof(int32_t) + (size_t)capacity * U_SIZEOF_UCHAR;\n    // Round up to a multiple of 16.\n    numBytes = (numBytes + 15) & ~15;\n    int32_t *array = (int32_t *) uprv_malloc(numBytes);\n    if(array != NULL) {\n      // set initial refCount and point behind the refCount\n      *array++ = 1;\n      numBytes -= sizeof(int32_t);\n\n      // have fArray point to the first UChar\n      fUnion.fFields.fArray = (UChar *)array;\n      fUnion.fFields.fCapacity = (int32_t)(numBytes / U_SIZEOF_UCHAR);\n      fUnion.fFields.fLengthAndFlags = kLongString;\n      return TRUE;\n    }\n  }\n  fUnion.fFields.fLengthAndFlags = kIsBogus;\n  fUnion.fFields.fArray = 0;\n  fUnion.fFields.fCapacity = 0;\n  return FALSE;\n}\n\n//========================================\n// Destructor\n//========================================\n\n#ifdef UNISTR_COUNT_FINAL_STRING_LENGTHS\nstatic u_atomic_int32_t finalLengthCounts[0x400];  // UnicodeString::kMaxShortLength+1\nstatic u_atomic_int32_t beyondCount(0);\n\nU_CAPI void unistr_printLengths() {\n  int32_t i;\n  for(i = 0; i <= 59; ++i) {\n    printf(\"%2d,  %9d\\n\", i, (int32_t)finalLengthCounts[i]);\n  }\n  int32_t beyond = beyondCount;\n  for(; i < UPRV_LENGTHOF(finalLengthCounts); ++i) {\n    beyond += finalLengthCounts[i];\n  }\n  printf(\">59, %9d\\n\", beyond);\n}\n#endif\n\nUnicodeString::~UnicodeString()\n{\n#ifdef UNISTR_COUNT_FINAL_STRING_LENGTHS\n  // Count lengths of strings at the end of their lifetime.\n  // Useful for discussion of a desirable stack buffer size.\n  // Count the contents length, not the optional NUL terminator nor further capacity.\n  // Ignore open-buffer strings and strings which alias external storage.\n  if((fUnion.fFields.fLengthAndFlags&(kOpenGetBuffer|kReadonlyAlias|kWritableAlias)) == 0) {\n    if(hasShortLength()) {\n      umtx_atomic_inc(finalLengthCounts + getShortLength());\n    } else {\n      umtx_atomic_inc(&beyondCount);\n    }\n  }\n#endif\n\n  releaseArray();\n}\n\n//========================================\n// Factory methods\n//========================================\n\nUnicodeString UnicodeString::fromUTF8(StringPiece utf8) {\n  UnicodeString result;\n  result.setToUTF8(utf8);\n  return result;\n}\n\nUnicodeString UnicodeString::fromUTF32(const UChar32 *utf32, int32_t length) {\n  UnicodeString result;\n  int32_t capacity;\n  // Most UTF-32 strings will be BMP-only and result in a same-length\n  // UTF-16 string. We overestimate the capacity just slightly,\n  // just in case there are a few supplementary characters.\n  if(length <= US_STACKBUF_SIZE) {\n    capacity = US_STACKBUF_SIZE;\n  } else {\n    capacity = length + (length >> 4) + 4;\n  }\n  do {\n    UChar *utf16 = result.getBuffer(capacity);\n    int32_t length16;\n    UErrorCode errorCode = U_ZERO_ERROR;\n    u_strFromUTF32WithSub(utf16, result.getCapacity(), &length16,\n        utf32, length,\n        0xfffd,  // Substitution character.\n        NULL,    // Don't care about number of substitutions.\n        &errorCode);\n    result.releaseBuffer(length16);\n    if(errorCode == U_BUFFER_OVERFLOW_ERROR) {\n      capacity = length16 + 1;  // +1 for the terminating NUL.\n      continue;\n    } else if(U_FAILURE(errorCode)) {\n      result.setToBogus();\n    }\n    break;\n  } while(TRUE);\n  return result;\n}\n\n//========================================\n// Assignment\n//========================================\n\nUnicodeString &\nUnicodeString::operator=(const UnicodeString &src) {\n  return copyFrom(src);\n}\n\nUnicodeString &\nUnicodeString::fastCopyFrom(const UnicodeString &src) {\n  return copyFrom(src, TRUE);\n}\n\nUnicodeString &\nUnicodeString::copyFrom(const UnicodeString &src, UBool fastCopy) {\n  // if assigning to ourselves, do nothing\n  if(this == &src) {\n    return *this;\n  }\n\n  // is the right side bogus?\n  if(src.isBogus()) {\n    setToBogus();\n    return *this;\n  }\n\n  // delete the current contents\n  releaseArray();\n\n  if(src.isEmpty()) {\n    // empty string - use the stack buffer\n    setToEmpty();\n    return *this;\n  }\n\n  // fLength>0 and not an \"open\" src.getBuffer(minCapacity)\n  fUnion.fFields.fLengthAndFlags = src.fUnion.fFields.fLengthAndFlags;\n  switch(src.fUnion.fFields.fLengthAndFlags & kAllStorageFlags) {\n  case kShortString:\n    // short string using the stack buffer, do the same\n    uprv_memcpy(fUnion.fStackFields.fBuffer, src.fUnion.fStackFields.fBuffer,\n                getShortLength() * U_SIZEOF_UCHAR);\n    break;\n  case kLongString:\n    // src uses a refCounted string buffer, use that buffer with refCount\n    // src is const, use a cast - we don't actually change it\n    ((UnicodeString &)src).addRef();\n    // copy all fields, share the reference-counted buffer\n    fUnion.fFields.fArray = src.fUnion.fFields.fArray;\n    fUnion.fFields.fCapacity = src.fUnion.fFields.fCapacity;\n    if(!hasShortLength()) {\n      fUnion.fFields.fLength = src.fUnion.fFields.fLength;\n    }\n    break;\n  case kReadonlyAlias:\n    if(fastCopy) {\n      // src is a readonly alias, do the same\n      // -> maintain the readonly alias as such\n      fUnion.fFields.fArray = src.fUnion.fFields.fArray;\n      fUnion.fFields.fCapacity = src.fUnion.fFields.fCapacity;\n      if(!hasShortLength()) {\n        fUnion.fFields.fLength = src.fUnion.fFields.fLength;\n      }\n      break;\n    }\n    // else if(!fastCopy) fall through to case kWritableAlias\n    // -> allocate a new buffer and copy the contents\n    U_FALLTHROUGH;\n  case kWritableAlias: {\n    // src is a writable alias; we make a copy of that instead\n    int32_t srcLength = src.length();\n    if(allocate(srcLength)) {\n      u_memcpy(getArrayStart(), src.getArrayStart(), srcLength);\n      setLength(srcLength);\n      break;\n    }\n    // if there is not enough memory, then fall through to setting to bogus\n    U_FALLTHROUGH;\n  }\n  default:\n    // if src is bogus, set ourselves to bogus\n    // do not call setToBogus() here because fArray and flags are not consistent here\n    fUnion.fFields.fLengthAndFlags = kIsBogus;\n    fUnion.fFields.fArray = 0;\n    fUnion.fFields.fCapacity = 0;\n    break;\n  }\n\n  return *this;\n}\n\nUnicodeString &UnicodeString::operator=(UnicodeString &&src) U_NOEXCEPT {\n  // No explicit check for self move assignment, consistent with standard library.\n  // Self move assignment causes no crash nor leak but might make the object bogus.\n  releaseArray();\n  copyFieldsFrom(src, TRUE);\n  return *this;\n}\n\n// Same as move assignment except without memory management.\nvoid UnicodeString::copyFieldsFrom(UnicodeString &src, UBool setSrcToBogus) U_NOEXCEPT {\n  int16_t lengthAndFlags = fUnion.fFields.fLengthAndFlags = src.fUnion.fFields.fLengthAndFlags;\n  if(lengthAndFlags & kUsingStackBuffer) {\n    // Short string using the stack buffer, copy the contents.\n    // Check for self assignment to prevent \"overlap in memcpy\" warnings,\n    // although it should be harmless to copy a buffer to itself exactly.\n    if(this != &src) {\n      uprv_memcpy(fUnion.fStackFields.fBuffer, src.fUnion.fStackFields.fBuffer,\n                  getShortLength() * U_SIZEOF_UCHAR);\n    }\n  } else {\n    // In all other cases, copy all fields.\n    fUnion.fFields.fArray = src.fUnion.fFields.fArray;\n    fUnion.fFields.fCapacity = src.fUnion.fFields.fCapacity;\n    if(!hasShortLength()) {\n      fUnion.fFields.fLength = src.fUnion.fFields.fLength;\n    }\n    if(setSrcToBogus) {\n      // Set src to bogus without releasing any memory.\n      src.fUnion.fFields.fLengthAndFlags = kIsBogus;\n      src.fUnion.fFields.fArray = NULL;\n      src.fUnion.fFields.fCapacity = 0;\n    }\n  }\n}\n\nvoid UnicodeString::swap(UnicodeString &other) U_NOEXCEPT {\n  UnicodeString temp;  // Empty short string: Known not to need releaseArray().\n  // Copy fields without resetting source values in between.\n  temp.copyFieldsFrom(*this, FALSE);\n  this->copyFieldsFrom(other, FALSE);\n  other.copyFieldsFrom(temp, FALSE);\n  // Set temp to an empty string so that other's memory is not released twice.\n  temp.fUnion.fFields.fLengthAndFlags = kShortString;\n}\n\n//========================================\n// Miscellaneous operations\n//========================================\n\nUnicodeString UnicodeString::unescape() const {\n    UnicodeString result(length(), (UChar32)0, (int32_t)0); // construct with capacity\n    if (result.isBogus()) {\n        return result;\n    }\n    const UChar *array = getBuffer();\n    int32_t len = length();\n    int32_t prev = 0;\n    for (int32_t i=0;;) {\n        if (i == len) {\n            result.append(array, prev, len - prev);\n            break;\n        }\n        if (array[i++] == 0x5C /*'\\\\'*/) {\n            result.append(array, prev, (i - 1) - prev);\n            UChar32 c = unescapeAt(i); // advances i\n            if (c < 0) {\n                result.remove(); // return empty string\n                break; // invalid escape sequence\n            }\n            result.append(c);\n            prev = i;\n        }\n    }\n    return result;\n}\n\nUChar32 UnicodeString::unescapeAt(int32_t &offset) const {\n    return u_unescapeAt(UnicodeString_charAt, &offset, length(), (void*)this);\n}\n\n//========================================\n// Read-only implementation\n//========================================\nUBool\nUnicodeString::doEquals(const UnicodeString &text, int32_t len) const {\n  // Requires: this & text not bogus and have same lengths.\n  // Byte-wise comparison works for equality regardless of endianness.\n  return uprv_memcmp(getArrayStart(), text.getArrayStart(), len * U_SIZEOF_UCHAR) == 0;\n}\n\nint8_t\nUnicodeString::doCompare( int32_t start,\n              int32_t length,\n              const UChar *srcChars,\n              int32_t srcStart,\n              int32_t srcLength) const\n{\n  // compare illegal string values\n  if(isBogus()) {\n    return -1;\n  }\n  \n  // pin indices to legal values\n  pinIndices(start, length);\n\n  if(srcChars == NULL) {\n    // treat const UChar *srcChars==NULL as an empty string\n    return length == 0 ? 0 : 1;\n  }\n\n  // get the correct pointer\n  const UChar *chars = getArrayStart();\n\n  chars += start;\n  srcChars += srcStart;\n\n  int32_t minLength;\n  int8_t lengthResult;\n\n  // get the srcLength if necessary\n  if(srcLength < 0) {\n    srcLength = u_strlen(srcChars + srcStart);\n  }\n\n  // are we comparing different lengths?\n  if(length != srcLength) {\n    if(length < srcLength) {\n      minLength = length;\n      lengthResult = -1;\n    } else {\n      minLength = srcLength;\n      lengthResult = 1;\n    }\n  } else {\n    minLength = length;\n    lengthResult = 0;\n  }\n\n  /*\n   * note that uprv_memcmp() returns an int but we return an int8_t;\n   * we need to take care not to truncate the result -\n   * one way to do this is to right-shift the value to\n   * move the sign bit into the lower 8 bits and making sure that this\n   * does not become 0 itself\n   */\n\n  if(minLength > 0 && chars != srcChars) {\n    int32_t result;\n\n#   if U_IS_BIG_ENDIAN \n      // big-endian: byte comparison works\n      result = uprv_memcmp(chars, srcChars, minLength * sizeof(UChar));\n      if(result != 0) {\n        return (int8_t)(result >> 15 | 1);\n      }\n#   else\n      // little-endian: compare UChar units\n      do {\n        result = ((int32_t)*(chars++) - (int32_t)*(srcChars++));\n        if(result != 0) {\n          return (int8_t)(result >> 15 | 1);\n        }\n      } while(--minLength > 0);\n#   endif\n  }\n  return lengthResult;\n}\n\n/* String compare in code point order - doCompare() compares in code unit order. */\nint8_t\nUnicodeString::doCompareCodePointOrder(int32_t start,\n                                       int32_t length,\n                                       const UChar *srcChars,\n                                       int32_t srcStart,\n                                       int32_t srcLength) const\n{\n  // compare illegal string values\n  // treat const UChar *srcChars==NULL as an empty string\n  if(isBogus()) {\n    return -1;\n  }\n\n  // pin indices to legal values\n  pinIndices(start, length);\n\n  if(srcChars == NULL) {\n    srcStart = srcLength = 0;\n  }\n\n  int32_t diff = uprv_strCompare(getArrayStart() + start, length, (srcChars!=NULL)?(srcChars + srcStart):NULL, srcLength, FALSE, TRUE);\n  /* translate the 32-bit result into an 8-bit one */\n  if(diff!=0) {\n    return (int8_t)(diff >> 15 | 1);\n  } else {\n    return 0;\n  }\n}\n\nint32_t\nUnicodeString::getLength() const {\n    return length();\n}\n\nUChar\nUnicodeString::getCharAt(int32_t offset) const {\n  return charAt(offset);\n}\n\nUChar32\nUnicodeString::getChar32At(int32_t offset) const {\n  return char32At(offset);\n}\n\nUChar32\nUnicodeString::char32At(int32_t offset) const\n{\n  int32_t len = length();\n  if((uint32_t)offset < (uint32_t)len) {\n    const UChar *array = getArrayStart();\n    UChar32 c;\n    U16_GET(array, 0, offset, len, c);\n    return c;\n  } else {\n    return kInvalidUChar;\n  }\n}\n\nint32_t\nUnicodeString::getChar32Start(int32_t offset) const {\n  if((uint32_t)offset < (uint32_t)length()) {\n    const UChar *array = getArrayStart();\n    U16_SET_CP_START(array, 0, offset);\n    return offset;\n  } else {\n    return 0;\n  }\n}\n\nint32_t\nUnicodeString::getChar32Limit(int32_t offset) const {\n  int32_t len = length();\n  if((uint32_t)offset < (uint32_t)len) {\n    const UChar *array = getArrayStart();\n    U16_SET_CP_LIMIT(array, 0, offset, len);\n    return offset;\n  } else {\n    return len;\n  }\n}\n\nint32_t\nUnicodeString::countChar32(int32_t start, int32_t length) const {\n  pinIndices(start, length);\n  // if(isBogus()) then fArray==0 and start==0 - u_countChar32() checks for NULL\n  return u_countChar32(getArrayStart()+start, length);\n}\n\nUBool\nUnicodeString::hasMoreChar32Than(int32_t start, int32_t length, int32_t number) const {\n  pinIndices(start, length);\n  // if(isBogus()) then fArray==0 and start==0 - u_strHasMoreChar32Than() checks for NULL\n  return u_strHasMoreChar32Than(getArrayStart()+start, length, number);\n}\n\nint32_t\nUnicodeString::moveIndex32(int32_t index, int32_t delta) const {\n  // pin index\n  int32_t len = length();\n  if(index<0) {\n    index=0;\n  } else if(index>len) {\n    index=len;\n  }\n\n  const UChar *array = getArrayStart();\n  if(delta>0) {\n    U16_FWD_N(array, index, len, delta);\n  } else {\n    U16_BACK_N(array, 0, index, -delta);\n  }\n\n  return index;\n}\n\nvoid\nUnicodeString::doExtract(int32_t start,\n             int32_t length,\n             UChar *dst,\n             int32_t dstStart) const\n{\n  // pin indices to legal values\n  pinIndices(start, length);\n\n  // do not copy anything if we alias dst itself\n  const UChar *array = getArrayStart();\n  if(array + start != dst + dstStart) {\n    us_arrayCopy(array, start, dst, dstStart, length);\n  }\n}\n\nint32_t\nUnicodeString::extract(Char16Ptr dest, int32_t destCapacity,\n                       UErrorCode &errorCode) const {\n  int32_t len = length();\n  if(U_SUCCESS(errorCode)) {\n    if(isBogus() || destCapacity<0 || (destCapacity>0 && dest==0)) {\n      errorCode=U_ILLEGAL_ARGUMENT_ERROR;\n    } else {\n      const UChar *array = getArrayStart();\n      if(len>0 && len<=destCapacity && array!=dest) {\n        u_memcpy(dest, array, len);\n      }\n      return u_terminateUChars(dest, destCapacity, len, &errorCode);\n    }\n  }\n\n  return len;\n}\n\nint32_t\nUnicodeString::extract(int32_t start,\n                       int32_t length,\n                       char *target,\n                       int32_t targetCapacity,\n                       enum EInvariant) const\n{\n  // if the arguments are illegal, then do nothing\n  if(targetCapacity < 0 || (targetCapacity > 0 && target == NULL)) {\n    return 0;\n  }\n\n  // pin the indices to legal values\n  pinIndices(start, length);\n\n  if(length <= targetCapacity) {\n    u_UCharsToChars(getArrayStart() + start, target, length);\n  }\n  UErrorCode status = U_ZERO_ERROR;\n  return u_terminateChars(target, targetCapacity, length, &status);\n}\n\nUnicodeString\nUnicodeString::tempSubString(int32_t start, int32_t len) const {\n  pinIndices(start, len);\n  const UChar *array = getBuffer();  // not getArrayStart() to check kIsBogus & kOpenGetBuffer\n  if(array==NULL) {\n    array=fUnion.fStackFields.fBuffer;  // anything not NULL because that would make an empty string\n    len=-2;  // bogus result string\n  }\n  return UnicodeString(FALSE, array + start, len);\n}\n\nint32_t\nUnicodeString::toUTF8(int32_t start, int32_t len,\n                      char *target, int32_t capacity) const {\n  pinIndices(start, len);\n  int32_t length8;\n  UErrorCode errorCode = U_ZERO_ERROR;\n  u_strToUTF8WithSub(target, capacity, &length8,\n                     getBuffer() + start, len,\n                     0xFFFD,  // Standard substitution character.\n                     NULL,    // Don't care about number of substitutions.\n                     &errorCode);\n  return length8;\n}\n\n#if U_CHARSET_IS_UTF8\n\nint32_t\nUnicodeString::extract(int32_t start, int32_t len,\n                       char *target, uint32_t dstSize) const {\n  // if the arguments are illegal, then do nothing\n  if(/*dstSize < 0 || */(dstSize > 0 && target == 0)) {\n    return 0;\n  }\n  return toUTF8(start, len, target, dstSize <= 0x7fffffff ? (int32_t)dstSize : 0x7fffffff);\n}\n\n// else see unistr_cnv.cpp\n#endif\n\nvoid \nUnicodeString::extractBetween(int32_t start,\n                  int32_t limit,\n                  UnicodeString& target) const {\n  pinIndex(start);\n  pinIndex(limit);\n  doExtract(start, limit - start, target);\n}\n\n// When converting from UTF-16 to UTF-8, the result will have at most 3 times\n// as many bytes as the source has UChars.\n// The \"worst cases\" are writing systems like Indic, Thai and CJK with\n// 3:1 bytes:UChars.\nvoid\nUnicodeString::toUTF8(ByteSink &sink) const {\n  int32_t length16 = length();\n  if(length16 != 0) {\n    char stackBuffer[1024];\n    int32_t capacity = (int32_t)sizeof(stackBuffer);\n    UBool utf8IsOwned = FALSE;\n    char *utf8 = sink.GetAppendBuffer(length16 < capacity ? length16 : capacity,\n                                      3*length16,\n                                      stackBuffer, capacity,\n                                      &capacity);\n    int32_t length8 = 0;\n    UErrorCode errorCode = U_ZERO_ERROR;\n    u_strToUTF8WithSub(utf8, capacity, &length8,\n                       getBuffer(), length16,\n                       0xFFFD,  // Standard substitution character.\n                       NULL,    // Don't care about number of substitutions.\n                       &errorCode);\n    if(errorCode == U_BUFFER_OVERFLOW_ERROR) {\n      utf8 = (char *)uprv_malloc(length8);\n      if(utf8 != NULL) {\n        utf8IsOwned = TRUE;\n        errorCode = U_ZERO_ERROR;\n        u_strToUTF8WithSub(utf8, length8, &length8,\n                           getBuffer(), length16,\n                           0xFFFD,  // Standard substitution character.\n                           NULL,    // Don't care about number of substitutions.\n                           &errorCode);\n      } else {\n        errorCode = U_MEMORY_ALLOCATION_ERROR;\n      }\n    }\n    if(U_SUCCESS(errorCode)) {\n      sink.Append(utf8, length8);\n      sink.Flush();\n    }\n    if(utf8IsOwned) {\n      uprv_free(utf8);\n    }\n  }\n}\n\nint32_t\nUnicodeString::toUTF32(UChar32 *utf32, int32_t capacity, UErrorCode &errorCode) const {\n  int32_t length32=0;\n  if(U_SUCCESS(errorCode)) {\n    // getBuffer() and u_strToUTF32WithSub() check for illegal arguments.\n    u_strToUTF32WithSub(utf32, capacity, &length32,\n        getBuffer(), length(),\n        0xfffd,  // Substitution character.\n        NULL,    // Don't care about number of substitutions.\n        &errorCode);\n  }\n  return length32;\n}\n\nint32_t \nUnicodeString::indexOf(const UChar *srcChars,\n               int32_t srcStart,\n               int32_t srcLength,\n               int32_t start,\n               int32_t length) const\n{\n  if(isBogus() || srcChars == 0 || srcStart < 0 || srcLength == 0) {\n    return -1;\n  }\n\n  // UnicodeString does not find empty substrings\n  if(srcLength < 0 && srcChars[srcStart] == 0) {\n    return -1;\n  }\n\n  // get the indices within bounds\n  pinIndices(start, length);\n\n  // find the first occurrence of the substring\n  const UChar *array = getArrayStart();\n  const UChar *match = u_strFindFirst(array + start, length, srcChars + srcStart, srcLength);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\nint32_t\nUnicodeString::doIndexOf(UChar c,\n             int32_t start,\n             int32_t length) const\n{\n  // pin indices\n  pinIndices(start, length);\n\n  // find the first occurrence of c\n  const UChar *array = getArrayStart();\n  const UChar *match = u_memchr(array + start, c, length);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\nint32_t\nUnicodeString::doIndexOf(UChar32 c,\n                         int32_t start,\n                         int32_t length) const {\n  // pin indices\n  pinIndices(start, length);\n\n  // find the first occurrence of c\n  const UChar *array = getArrayStart();\n  const UChar *match = u_memchr32(array + start, c, length);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\nint32_t \nUnicodeString::lastIndexOf(const UChar *srcChars,\n               int32_t srcStart,\n               int32_t srcLength,\n               int32_t start,\n               int32_t length) const\n{\n  if(isBogus() || srcChars == 0 || srcStart < 0 || srcLength == 0) {\n    return -1;\n  }\n\n  // UnicodeString does not find empty substrings\n  if(srcLength < 0 && srcChars[srcStart] == 0) {\n    return -1;\n  }\n\n  // get the indices within bounds\n  pinIndices(start, length);\n\n  // find the last occurrence of the substring\n  const UChar *array = getArrayStart();\n  const UChar *match = u_strFindLast(array + start, length, srcChars + srcStart, srcLength);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\nint32_t\nUnicodeString::doLastIndexOf(UChar c,\n                 int32_t start,\n                 int32_t length) const\n{\n  if(isBogus()) {\n    return -1;\n  }\n\n  // pin indices\n  pinIndices(start, length);\n\n  // find the last occurrence of c\n  const UChar *array = getArrayStart();\n  const UChar *match = u_memrchr(array + start, c, length);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\nint32_t\nUnicodeString::doLastIndexOf(UChar32 c,\n                             int32_t start,\n                             int32_t length) const {\n  // pin indices\n  pinIndices(start, length);\n\n  // find the last occurrence of c\n  const UChar *array = getArrayStart();\n  const UChar *match = u_memrchr32(array + start, c, length);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\n//========================================\n// Write implementation\n//========================================\n\nUnicodeString& \nUnicodeString::findAndReplace(int32_t start,\n                  int32_t length,\n                  const UnicodeString& oldText,\n                  int32_t oldStart,\n                  int32_t oldLength,\n                  const UnicodeString& newText,\n                  int32_t newStart,\n                  int32_t newLength)\n{\n  if(isBogus() || oldText.isBogus() || newText.isBogus()) {\n    return *this;\n  }\n\n  pinIndices(start, length);\n  oldText.pinIndices(oldStart, oldLength);\n  newText.pinIndices(newStart, newLength);\n\n  if(oldLength == 0) {\n    return *this;\n  }\n\n  while(length > 0 && length >= oldLength) {\n    int32_t pos = indexOf(oldText, oldStart, oldLength, start, length);\n    if(pos < 0) {\n      // no more oldText's here: done\n      break;\n    } else {\n      // we found oldText, replace it by newText and go beyond it\n      replace(pos, oldLength, newText, newStart, newLength);\n      length -= pos + oldLength - start;\n      start = pos + newLength;\n    }\n  }\n\n  return *this;\n}\n\n\nvoid\nUnicodeString::setToBogus()\n{\n  releaseArray();\n\n  fUnion.fFields.fLengthAndFlags = kIsBogus;\n  fUnion.fFields.fArray = 0;\n  fUnion.fFields.fCapacity = 0;\n}\n\n// turn a bogus string into an empty one\nvoid\nUnicodeString::unBogus() {\n  if(fUnion.fFields.fLengthAndFlags & kIsBogus) {\n    setToEmpty();\n  }\n}\n\nconst char16_t *\nUnicodeString::getTerminatedBuffer() {\n  if(!isWritable()) {\n    return nullptr;\n  }\n  UChar *array = getArrayStart();\n  int32_t len = length();\n  if(len < getCapacity()) {\n    if(fUnion.fFields.fLengthAndFlags & kBufferIsReadonly) {\n      // If len<capacity on a read-only alias, then array[len] is\n      // either the original NUL (if constructed with (TRUE, s, length))\n      // or one of the original string contents characters (if later truncated),\n      // therefore we can assume that array[len] is initialized memory.\n      if(array[len] == 0) {\n        return array;\n      }\n    } else if(((fUnion.fFields.fLengthAndFlags & kRefCounted) == 0 || refCount() == 1)) {\n      // kRefCounted: Do not write the NUL if the buffer is shared.\n      // That is mostly safe, except when the length of one copy was modified\n      // without copy-on-write, e.g., via truncate(newLength) or remove(void).\n      // Then the NUL would be written into the middle of another copy's string.\n\n      // Otherwise, the buffer is fully writable and it is anyway safe to write the NUL.\n      // Do not test if there is a NUL already because it might be uninitialized memory.\n      // (That would be safe, but tools like valgrind & Purify would complain.)\n      array[len] = 0;\n      return array;\n    }\n  }\n  if(len<INT32_MAX && cloneArrayIfNeeded(len+1)) {\n    array = getArrayStart();\n    array[len] = 0;\n    return array;\n  } else {\n    return nullptr;\n  }\n}\n\n// setTo() analogous to the readonly-aliasing constructor with the same signature\nUnicodeString &\nUnicodeString::setTo(UBool isTerminated,\n                     ConstChar16Ptr textPtr,\n                     int32_t textLength)\n{\n  if(fUnion.fFields.fLengthAndFlags & kOpenGetBuffer) {\n    // do not modify a string that has an \"open\" getBuffer(minCapacity)\n    return *this;\n  }\n\n  const UChar *text = textPtr;\n  if(text == NULL) {\n    // treat as an empty string, do not alias\n    releaseArray();\n    setToEmpty();\n    return *this;\n  }\n\n  if( textLength < -1 ||\n      (textLength == -1 && !isTerminated) ||\n      (textLength >= 0 && isTerminated && text[textLength] != 0)\n  ) {\n    setToBogus();\n    return *this;\n  }\n\n  releaseArray();\n\n  if(textLength == -1) {\n    // text is terminated, or else it would have failed the above test\n    textLength = u_strlen(text);\n  }\n  fUnion.fFields.fLengthAndFlags = kReadonlyAlias;\n  setArray((UChar *)text, textLength, isTerminated ? textLength + 1 : textLength);\n  return *this;\n}\n\n// setTo() analogous to the writable-aliasing constructor with the same signature\nUnicodeString &\nUnicodeString::setTo(UChar *buffer,\n                     int32_t buffLength,\n                     int32_t buffCapacity) {\n  if(fUnion.fFields.fLengthAndFlags & kOpenGetBuffer) {\n    // do not modify a string that has an \"open\" getBuffer(minCapacity)\n    return *this;\n  }\n\n  if(buffer == NULL) {\n    // treat as an empty string, do not alias\n    releaseArray();\n    setToEmpty();\n    return *this;\n  }\n\n  if(buffLength < -1 || buffCapacity < 0 || buffLength > buffCapacity) {\n    setToBogus();\n    return *this;\n  } else if(buffLength == -1) {\n    // buffLength = u_strlen(buff); but do not look beyond buffCapacity\n    const UChar *p = buffer, *limit = buffer + buffCapacity;\n    while(p != limit && *p != 0) {\n      ++p;\n    }\n    buffLength = (int32_t)(p - buffer);\n  }\n\n  releaseArray();\n\n  fUnion.fFields.fLengthAndFlags = kWritableAlias;\n  setArray(buffer, buffLength, buffCapacity);\n  return *this;\n}\n\nUnicodeString &UnicodeString::setToUTF8(StringPiece utf8) {\n  unBogus();\n  int32_t length = utf8.length();\n  int32_t capacity;\n  // The UTF-16 string will be at most as long as the UTF-8 string.\n  if(length <= US_STACKBUF_SIZE) {\n    capacity = US_STACKBUF_SIZE;\n  } else {\n    capacity = length + 1;  // +1 for the terminating NUL.\n  }\n  UChar *utf16 = getBuffer(capacity);\n  int32_t length16;\n  UErrorCode errorCode = U_ZERO_ERROR;\n  u_strFromUTF8WithSub(utf16, getCapacity(), &length16,\n      utf8.data(), length,\n      0xfffd,  // Substitution character.\n      NULL,    // Don't care about number of substitutions.\n      &errorCode);\n  releaseBuffer(length16);\n  if(U_FAILURE(errorCode)) {\n    setToBogus();\n  }\n  return *this;\n}\n\nUnicodeString&\nUnicodeString::setCharAt(int32_t offset,\n             UChar c)\n{\n  int32_t len = length();\n  if(cloneArrayIfNeeded() && len > 0) {\n    if(offset < 0) {\n      offset = 0;\n    } else if(offset >= len) {\n      offset = len - 1;\n    }\n\n    getArrayStart()[offset] = c;\n  }\n  return *this;\n}\n\nUnicodeString&\nUnicodeString::replace(int32_t start,\n               int32_t _length,\n               UChar32 srcChar) {\n  UChar buffer[U16_MAX_LENGTH];\n  int32_t count = 0;\n  UBool isError = FALSE;\n  U16_APPEND(buffer, count, U16_MAX_LENGTH, srcChar, isError);\n  // We test isError so that the compiler does not complain that we don't.\n  // If isError (srcChar is not a valid code point) then count==0 which means\n  // we remove the source segment rather than replacing it with srcChar.\n  return doReplace(start, _length, buffer, 0, isError ? 0 : count);\n}\n\nUnicodeString&\nUnicodeString::append(UChar32 srcChar) {\n  UChar buffer[U16_MAX_LENGTH];\n  int32_t _length = 0;\n  UBool isError = FALSE;\n  U16_APPEND(buffer, _length, U16_MAX_LENGTH, srcChar, isError);\n  // We test isError so that the compiler does not complain that we don't.\n  // If isError then _length==0 which turns the doAppend() into a no-op anyway.\n  return isError ? *this : doAppend(buffer, 0, _length);\n}\n\nUnicodeString&\nUnicodeString::doReplace( int32_t start,\n              int32_t length,\n              const UnicodeString& src,\n              int32_t srcStart,\n              int32_t srcLength)\n{\n  // pin the indices to legal values\n  src.pinIndices(srcStart, srcLength);\n\n  // get the characters from src\n  // and replace the range in ourselves with them\n  return doReplace(start, length, src.getArrayStart(), srcStart, srcLength);\n}\n\nUnicodeString&\nUnicodeString::doReplace(int32_t start,\n             int32_t length,\n             const UChar *srcChars,\n             int32_t srcStart,\n             int32_t srcLength)\n{\n  if(!isWritable()) {\n    return *this;\n  }\n\n  int32_t oldLength = this->length();\n\n  // optimize (read-only alias).remove(0, start) and .remove(start, end)\n  if((fUnion.fFields.fLengthAndFlags&kBufferIsReadonly) && srcLength == 0) {\n    if(start == 0) {\n      // remove prefix by adjusting the array pointer\n      pinIndex(length);\n      fUnion.fFields.fArray += length;\n      fUnion.fFields.fCapacity -= length;\n      setLength(oldLength - length);\n      return *this;\n    } else {\n      pinIndex(start);\n      if(length >= (oldLength - start)) {\n        // remove suffix by reducing the length (like truncate())\n        setLength(start);\n        fUnion.fFields.fCapacity = start;  // not NUL-terminated any more\n        return *this;\n      }\n    }\n  }\n\n  if(start == oldLength) {\n    return doAppend(srcChars, srcStart, srcLength);\n  }\n\n  if(srcChars == 0) {\n    srcLength = 0;\n  } else {\n    // Perform all remaining operations relative to srcChars + srcStart.\n    // From this point forward, do not use srcStart.\n    srcChars += srcStart;\n    if (srcLength < 0) {\n      // get the srcLength if necessary\n      srcLength = u_strlen(srcChars);\n    }\n  }\n\n  // pin the indices to legal values\n  pinIndices(start, length);\n\n  // Calculate the size of the string after the replace.\n  // Avoid int32_t overflow.\n  int32_t newLength = oldLength - length;\n  if(srcLength > (INT32_MAX - newLength)) {\n    setToBogus();\n    return *this;\n  }\n  newLength += srcLength;\n\n  // Check for insertion into ourself\n  const UChar *oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    // Copy into a new UnicodeString and start over\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doReplace(start, length, copy.getArrayStart(), 0, srcLength);\n  }\n\n  // cloneArrayIfNeeded(doCopyArray=FALSE) may change fArray but will not copy the current contents;\n  // therefore we need to keep the current fArray\n  UChar oldStackBuffer[US_STACKBUF_SIZE];\n  if((fUnion.fFields.fLengthAndFlags&kUsingStackBuffer) && (newLength > US_STACKBUF_SIZE)) {\n    // copy the stack buffer contents because it will be overwritten with\n    // fUnion.fFields values\n    u_memcpy(oldStackBuffer, oldArray, oldLength);\n    oldArray = oldStackBuffer;\n  }\n\n  // clone our array and allocate a bigger array if needed\n  int32_t *bufferToDelete = 0;\n  if(!cloneArrayIfNeeded(newLength, getGrowCapacity(newLength),\n                         FALSE, &bufferToDelete)\n  ) {\n    return *this;\n  }\n\n  // now do the replace\n\n  UChar *newArray = getArrayStart();\n  if(newArray != oldArray) {\n    // if fArray changed, then we need to copy everything except what will change\n    us_arrayCopy(oldArray, 0, newArray, 0, start);\n    us_arrayCopy(oldArray, start + length,\n                 newArray, start + srcLength,\n                 oldLength - (start + length));\n  } else if(length != srcLength) {\n    // fArray did not change; copy only the portion that isn't changing, leaving a hole\n    us_arrayCopy(oldArray, start + length,\n                 newArray, start + srcLength,\n                 oldLength - (start + length));\n  }\n\n  // now fill in the hole with the new string\n  us_arrayCopy(srcChars, 0, newArray, start, srcLength);\n\n  setLength(newLength);\n\n  // delayed delete in case srcChars == fArray when we started, and\n  // to keep oldArray alive for the above operations\n  if (bufferToDelete) {\n    uprv_free(bufferToDelete);\n  }\n\n  return *this;\n}\n\n// Versions of doReplace() only for append() variants.\n// doReplace() and doAppend() optimize for different cases.\n\nUnicodeString&\nUnicodeString::doAppend(const UnicodeString& src, int32_t srcStart, int32_t srcLength) {\n  if(srcLength == 0) {\n    return *this;\n  }\n\n  // pin the indices to legal values\n  src.pinIndices(srcStart, srcLength);\n  return doAppend(src.getArrayStart(), srcStart, srcLength);\n}\n\nUnicodeString&\nUnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n\n  // Perform all remaining operations relative to srcChars + srcStart.\n  // From this point forward, do not use srcStart.\n  srcChars += srcStart;\n\n  if(srcLength < 0) {\n    // get the srcLength if necessary\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n\n  int32_t oldLength = length();\n  int32_t newLength = oldLength + srcLength;\n\n  // Check for append onto ourself\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    // Copy into a new UnicodeString and start over\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n\n  // optimize append() onto a large-enough, owned string\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    // Do not copy characters when\n    //   UChar *buffer=str.getAppendBuffer(...);\n    // is followed by\n    //   str.append(buffer, length);\n    // or\n    //   str.appendString(buffer, length)\n    // or similar.\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}\n\n/**\n * Replaceable API\n */\nvoid\nUnicodeString::handleReplaceBetween(int32_t start,\n                                    int32_t limit,\n                                    const UnicodeString& text) {\n    replaceBetween(start, limit, text);\n}\n\n/**\n * Replaceable API\n */\nvoid \nUnicodeString::copy(int32_t start, int32_t limit, int32_t dest) {\n    if (limit <= start) {\n        return; // Nothing to do; avoid bogus malloc call\n    }\n    UChar* text = (UChar*) uprv_malloc( sizeof(UChar) * (limit - start) );\n    // Check to make sure text is not null.\n    if (text != NULL) {\n\t    extractBetween(start, limit, text, 0);\n\t    insert(dest, text, 0, limit - start);    \n\t    uprv_free(text);\n    }\n}\n\n/**\n * Replaceable API\n *\n * NOTE: This is for the Replaceable class.  There is no rep.cpp,\n * so we implement this function here.\n */\nUBool Replaceable::hasMetaData() const {\n    return TRUE;\n}\n\n/**\n * Replaceable API\n */\nUBool UnicodeString::hasMetaData() const {\n    return FALSE;\n}\n\nUnicodeString&\nUnicodeString::doReverse(int32_t start, int32_t length) {\n  if(length <= 1 || !cloneArrayIfNeeded()) {\n    return *this;\n  }\n\n  // pin the indices to legal values\n  pinIndices(start, length);\n  if(length <= 1) {  // pinIndices() might have shrunk the length\n    return *this;\n  }\n\n  UChar *left = getArrayStart() + start;\n  UChar *right = left + length - 1;  // -1 for inclusive boundary (length>=2)\n  UChar swap;\n  UBool hasSupplementary = FALSE;\n\n  // Before the loop we know left<right because length>=2.\n  do {\n    hasSupplementary |= (UBool)U16_IS_LEAD(swap = *left);\n    hasSupplementary |= (UBool)U16_IS_LEAD(*left++ = *right);\n    *right-- = swap;\n  } while(left < right);\n  // Make sure to test the middle code unit of an odd-length string.\n  // Redundant if the length is even.\n  hasSupplementary |= (UBool)U16_IS_LEAD(*left);\n\n  /* if there are supplementary code points in the reversed range, then re-swap their surrogates */\n  if(hasSupplementary) {\n    UChar swap2;\n\n    left = getArrayStart() + start;\n    right = left + length - 1; // -1 so that we can look at *(left+1) if left<right\n    while(left < right) {\n      if(U16_IS_TRAIL(swap = *left) && U16_IS_LEAD(swap2 = *(left + 1))) {\n        *left++ = swap2;\n        *left++ = swap;\n      } else {\n        ++left;\n      }\n    }\n  }\n\n  return *this;\n}\n\nUBool \nUnicodeString::padLeading(int32_t targetLength,\n                          UChar padChar)\n{\n  int32_t oldLength = length();\n  if(oldLength >= targetLength || !cloneArrayIfNeeded(targetLength)) {\n    return FALSE;\n  } else {\n    // move contents up by padding width\n    UChar *array = getArrayStart();\n    int32_t start = targetLength - oldLength;\n    us_arrayCopy(array, 0, array, start, oldLength);\n\n    // fill in padding character\n    while(--start >= 0) {\n      array[start] = padChar;\n    }\n    setLength(targetLength);\n    return TRUE;\n  }\n}\n\nUBool \nUnicodeString::padTrailing(int32_t targetLength,\n                           UChar padChar)\n{\n  int32_t oldLength = length();\n  if(oldLength >= targetLength || !cloneArrayIfNeeded(targetLength)) {\n    return FALSE;\n  } else {\n    // fill in padding character\n    UChar *array = getArrayStart();\n    int32_t length = targetLength;\n    while(--length >= oldLength) {\n      array[length] = padChar;\n    }\n    setLength(targetLength);\n    return TRUE;\n  }\n}\n\n//========================================\n// Hashing\n//========================================\nint32_t\nUnicodeString::doHashCode() const\n{\n    /* Delegate hash computation to uhash.  This makes UnicodeString\n     * hashing consistent with UChar* hashing.  */\n    int32_t hashCode = ustr_hashUCharsN(getArrayStart(), length());\n    if (hashCode == kInvalidHashCode) {\n        hashCode = kEmptyHashCode;\n    }\n    return hashCode;\n}\n\n//========================================\n// External Buffer\n//========================================\n\nchar16_t *\nUnicodeString::getBuffer(int32_t minCapacity) {\n  if(minCapacity>=-1 && cloneArrayIfNeeded(minCapacity)) {\n    fUnion.fFields.fLengthAndFlags|=kOpenGetBuffer;\n    setZeroLength();\n    return getArrayStart();\n  } else {\n    return nullptr;\n  }\n}\n\nvoid\nUnicodeString::releaseBuffer(int32_t newLength) {\n  if(fUnion.fFields.fLengthAndFlags&kOpenGetBuffer && newLength>=-1) {\n    // set the new fLength\n    int32_t capacity=getCapacity();\n    if(newLength==-1) {\n      // the new length is the string length, capped by fCapacity\n      const UChar *array=getArrayStart(), *p=array, *limit=array+capacity;\n      while(p<limit && *p!=0) {\n        ++p;\n      }\n      newLength=(int32_t)(p-array);\n    } else if(newLength>capacity) {\n      newLength=capacity;\n    }\n    setLength(newLength);\n    fUnion.fFields.fLengthAndFlags&=~kOpenGetBuffer;\n  }\n}\n\n//========================================\n// Miscellaneous\n//========================================\nUBool\nUnicodeString::cloneArrayIfNeeded(int32_t newCapacity,\n                                  int32_t growCapacity,\n                                  UBool doCopyArray,\n                                  int32_t **pBufferToDelete,\n                                  UBool forceClone) {\n  // default parameters need to be static, therefore\n  // the defaults are -1 to have convenience defaults\n  if(newCapacity == -1) {\n    newCapacity = getCapacity();\n  }\n\n  // while a getBuffer(minCapacity) is \"open\",\n  // prevent any modifications of the string by returning FALSE here\n  // if the string is bogus, then only an assignment or similar can revive it\n  if(!isWritable()) {\n    return FALSE;\n  }\n\n  /*\n   * We need to make a copy of the array if\n   * the buffer is read-only, or\n   * the buffer is refCounted (shared), and refCount>1, or\n   * the buffer is too small.\n   * Return FALSE if memory could not be allocated.\n   */\n  if(forceClone ||\n     fUnion.fFields.fLengthAndFlags & kBufferIsReadonly ||\n     (fUnion.fFields.fLengthAndFlags & kRefCounted && refCount() > 1) ||\n     newCapacity > getCapacity()\n  ) {\n    // check growCapacity for default value and use of the stack buffer\n    if(growCapacity < 0) {\n      growCapacity = newCapacity;\n    } else if(newCapacity <= US_STACKBUF_SIZE && growCapacity > US_STACKBUF_SIZE) {\n      growCapacity = US_STACKBUF_SIZE;\n    }\n\n    // save old values\n    UChar oldStackBuffer[US_STACKBUF_SIZE];\n    UChar *oldArray;\n    int32_t oldLength = length();\n    int16_t flags = fUnion.fFields.fLengthAndFlags;\n\n    if(flags&kUsingStackBuffer) {\n      U_ASSERT(!(flags&kRefCounted)); /* kRefCounted and kUsingStackBuffer are mutally exclusive */\n      if(doCopyArray && growCapacity > US_STACKBUF_SIZE) {\n        // copy the stack buffer contents because it will be overwritten with\n        // fUnion.fFields values\n        us_arrayCopy(fUnion.fStackFields.fBuffer, 0, oldStackBuffer, 0, oldLength);\n        oldArray = oldStackBuffer;\n      } else {\n        oldArray = NULL; // no need to copy from the stack buffer to itself\n      }\n    } else {\n      oldArray = fUnion.fFields.fArray;\n      U_ASSERT(oldArray!=NULL); /* when stack buffer is not used, oldArray must have a non-NULL reference */\n    }\n\n    // allocate a new array\n    if(allocate(growCapacity) ||\n       (newCapacity < growCapacity && allocate(newCapacity))\n    ) {\n      if(doCopyArray) {\n        // copy the contents\n        // do not copy more than what fits - it may be smaller than before\n        int32_t minLength = oldLength;\n        newCapacity = getCapacity();\n        if(newCapacity < minLength) {\n          minLength = newCapacity;\n        }\n        if(oldArray != NULL) {\n          us_arrayCopy(oldArray, 0, getArrayStart(), 0, minLength);\n        }\n        setLength(minLength);\n      } else {\n        setZeroLength();\n      }\n\n      // release the old array\n      if(flags & kRefCounted) {\n        // the array is refCounted; decrement and release if 0\n        u_atomic_int32_t *pRefCount = ((u_atomic_int32_t *)oldArray - 1);\n        if(umtx_atomic_dec(pRefCount) == 0) {\n          if(pBufferToDelete == 0) {\n              // Note: cast to (void *) is needed with MSVC, where u_atomic_int32_t\n              // is defined as volatile. (Volatile has useful non-standard behavior\n              //   with this compiler.)\n            uprv_free((void *)pRefCount);\n          } else {\n            // the caller requested to delete it himself\n            *pBufferToDelete = (int32_t *)pRefCount;\n          }\n        }\n      }\n    } else {\n      // not enough memory for growCapacity and not even for the smaller newCapacity\n      // reset the old values for setToBogus() to release the array\n      if(!(flags&kUsingStackBuffer)) {\n        fUnion.fFields.fArray = oldArray;\n      }\n      fUnion.fFields.fLengthAndFlags = flags;\n      setToBogus();\n      return FALSE;\n    }\n  }\n  return TRUE;\n}\n\n// UnicodeStringAppendable ------------------------------------------------- ***\n\nUnicodeStringAppendable::~UnicodeStringAppendable() {}\n\nUBool\nUnicodeStringAppendable::appendCodeUnit(UChar c) {\n  return str.doAppend(&c, 0, 1).isWritable();\n}\n\nUBool\nUnicodeStringAppendable::appendCodePoint(UChar32 c) {\n  UChar buffer[U16_MAX_LENGTH];\n  int32_t cLength = 0;\n  UBool isError = FALSE;\n  U16_APPEND(buffer, cLength, U16_MAX_LENGTH, c, isError);\n  return !isError && str.doAppend(buffer, 0, cLength).isWritable();\n}\n\nUBool\nUnicodeStringAppendable::appendString(const UChar *s, int32_t length) {\n  return str.doAppend(s, 0, length).isWritable();\n}\n\nUBool\nUnicodeStringAppendable::reserveAppendCapacity(int32_t appendCapacity) {\n  return str.cloneArrayIfNeeded(str.length() + appendCapacity);\n}\n\nUChar *\nUnicodeStringAppendable::getAppendBuffer(int32_t minCapacity,\n                                         int32_t desiredCapacityHint,\n                                         UChar *scratch, int32_t scratchCapacity,\n                                         int32_t *resultCapacity) {\n  if(minCapacity < 1 || scratchCapacity < minCapacity) {\n    *resultCapacity = 0;\n    return NULL;\n  }\n  int32_t oldLength = str.length();\n  if(minCapacity <= (kMaxCapacity - oldLength) &&\n      desiredCapacityHint <= (kMaxCapacity - oldLength) &&\n      str.cloneArrayIfNeeded(oldLength + minCapacity, oldLength + desiredCapacityHint)) {\n    *resultCapacity = str.getCapacity() - oldLength;\n    return str.getArrayStart() + oldLength;\n  }\n  *resultCapacity = scratchCapacity;\n  return scratch;\n}\n\nU_NAMESPACE_END\n\nU_NAMESPACE_USE\n\nU_CAPI int32_t U_EXPORT2\nuhash_hashUnicodeString(const UElement key) {\n    const UnicodeString *str = (const UnicodeString*) key.pointer;\n    return (str == NULL) ? 0 : str->hashCode();\n}\n\n// Moved here from uhash_us.cpp so that using a UVector of UnicodeString*\n// does not depend on hashtable code.\nU_CAPI UBool U_EXPORT2\nuhash_compareUnicodeString(const UElement key1, const UElement key2) {\n    const UnicodeString *str1 = (const UnicodeString*) key1.pointer;\n    const UnicodeString *str2 = (const UnicodeString*) key2.pointer;\n    if (str1 == str2) {\n        return TRUE;\n    }\n    if (str1 == NULL || str2 == NULL) {\n        return FALSE;\n    }\n    return *str1 == *str2;\n}\n\n#ifdef U_STATIC_IMPLEMENTATION\n/*\nThis should never be called. It is defined here to make sure that the\nvirtual vector deleting destructor is defined within unistr.cpp.\nThe vector deleting destructor is already a part of UObject,\nbut defining it here makes sure that it is included with this object file.\nThis makes sure that static library dependencies are kept to a minimum.\n*/\nstatic void uprv_UnicodeStringDummy(void) {\n    delete [] (new UnicodeString[2]);\n}\n#endif\n", "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/********************************************************************\n * COPYRIGHT: \n * Copyright (c) 1997-2016, International Business Machines Corporation and\n * others. All Rights Reserved.\n ********************************************************************/\n\n#include <utility>\n\n#include \"ustrtest.h\"\n#include \"unicode/appendable.h\"\n#include \"unicode/std_string.h\"\n#include \"unicode/unistr.h\"\n#include \"unicode/uchar.h\"\n#include \"unicode/ustring.h\"\n#include \"unicode/locid.h\"\n#include \"unicode/strenum.h\"\n#include \"unicode/ucnv.h\"\n#include \"unicode/uenum.h\"\n#include \"unicode/utf16.h\"\n#include \"cmemory.h\"\n#include \"charstr.h\"\n\n#if 0\n#include \"unicode/ustream.h\"\n\n#include <iostream>\nusing namespace std;\n\n#endif\n\nUnicodeStringTest::~UnicodeStringTest() {}\n\nextern IntlTest *createStringCaseTest();\n\nvoid UnicodeStringTest::runIndexedTest( int32_t index, UBool exec, const char* &name, char *par)\n{\n    if (exec) logln(\"TestSuite UnicodeStringTest: \");\n    TESTCASE_AUTO_BEGIN;\n    TESTCASE_AUTO_CREATE_CLASS(StringCaseTest);\n    TESTCASE_AUTO(TestBasicManipulation);\n    TESTCASE_AUTO(TestCompare);\n    TESTCASE_AUTO(TestExtract);\n    TESTCASE_AUTO(TestRemoveReplace);\n    TESTCASE_AUTO(TestSearching);\n    TESTCASE_AUTO(TestSpacePadding);\n    TESTCASE_AUTO(TestPrefixAndSuffix);\n    TESTCASE_AUTO(TestFindAndReplace);\n    TESTCASE_AUTO(TestBogus);\n    TESTCASE_AUTO(TestReverse);\n    TESTCASE_AUTO(TestMiscellaneous);\n    TESTCASE_AUTO(TestStackAllocation);\n    TESTCASE_AUTO(TestUnescape);\n    TESTCASE_AUTO(TestCountChar32);\n    TESTCASE_AUTO(TestStringEnumeration);\n    TESTCASE_AUTO(TestNameSpace);\n    TESTCASE_AUTO(TestUTF32);\n    TESTCASE_AUTO(TestUTF8);\n    TESTCASE_AUTO(TestReadOnlyAlias);\n    TESTCASE_AUTO(TestAppendable);\n    TESTCASE_AUTO(TestUnicodeStringImplementsAppendable);\n    TESTCASE_AUTO(TestSizeofUnicodeString);\n    TESTCASE_AUTO(TestStartsWithAndEndsWithNulTerminated);\n    TESTCASE_AUTO(TestMoveSwap);\n    TESTCASE_AUTO(TestUInt16Pointers);\n    TESTCASE_AUTO(TestWCharPointers);\n    TESTCASE_AUTO(TestNullPointers);\n    TESTCASE_AUTO(TestUnicodeStringInsertAppendToSelf);\n    TESTCASE_AUTO_END;\n}\n\nvoid\nUnicodeStringTest::TestBasicManipulation()\n{\n    UnicodeString   test1(\"Now is the time for all men to come swiftly to the aid of the party.\\n\");\n    UnicodeString   expectedValue;\n    UnicodeString   *c;\n\n    c=test1.clone();\n    test1.insert(24, \"good \");\n    expectedValue = \"Now is the time for all good men to come swiftly to the aid of the party.\\n\";\n    if (test1 != expectedValue)\n        errln(\"insert() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + test1 + \"\\\"\");\n\n    c->insert(24, \"good \");\n    if(*c != expectedValue) {\n        errln(\"clone()->insert() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + *c + \"\\\"\");\n    }\n    delete c;\n\n    test1.remove(41, 8);\n    expectedValue = \"Now is the time for all good men to come to the aid of the party.\\n\";\n    if (test1 != expectedValue)\n        errln(\"remove() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + test1 + \"\\\"\");\n    \n    test1.replace(58, 6, \"ir country\");\n    expectedValue = \"Now is the time for all good men to come to the aid of their country.\\n\";\n    if (test1 != expectedValue)\n        errln(\"replace() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + test1 + \"\\\"\");\n    \n    UChar     temp[80];\n    test1.extract(0, 15, temp);\n    \n    UnicodeString       test2(temp, 15);\n    \n    expectedValue = \"Now is the time\";\n    if (test2 != expectedValue)\n        errln(\"extract() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + test2 + \"\\\"\");\n    \n    test2 += \" for me to go!\\n\";\n    expectedValue = \"Now is the time for me to go!\\n\";\n    if (test2 != expectedValue)\n        errln(\"operator+=() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + test2 + \"\\\"\");\n    \n    if (test1.length() != 70)\n        errln(UnicodeString(\"length() failed: expected 70, got \") + test1.length());\n    if (test2.length() != 30)\n        errln(UnicodeString(\"length() failed: expected 30, got \") + test2.length());\n\n    UnicodeString test3;\n    test3.append((UChar32)0x20402);\n    if(test3 != CharsToUnicodeString(\"\\\\uD841\\\\uDC02\")){\n        errln((UnicodeString)\"append failed for UChar32, expected \\\"\\\\\\\\ud841\\\\\\\\udc02\\\", got \" + prettify(test3));\n    }\n    if(test3.length() != 2){\n        errln(UnicodeString(\"append or length failed for UChar32, expected 2, got \") + test3.length());\n    }\n    test3.append((UChar32)0x0074);\n    if(test3 != CharsToUnicodeString(\"\\\\uD841\\\\uDC02t\")){\n        errln((UnicodeString)\"append failed for UChar32, expected \\\"\\\\\\\\uD841\\\\\\\\uDC02t\\\", got \" + prettify(test3));\n    }\n    if(test3.length() != 3){\n        errln((UnicodeString)\"append or length failed for UChar32, expected 2, got \" + test3.length());\n    }\n\n    // test some UChar32 overloads\n    if( test3.setTo((UChar32)0x10330).length() != 2 ||\n        test3.insert(0, (UChar32)0x20100).length() != 4 ||\n        test3.replace(2, 2, (UChar32)0xe0061).length() != 4 ||\n        (test3 = (UChar32)0x14001).length() != 2\n    ) {\n        errln((UnicodeString)\"simple UChar32 overloads for replace, insert, setTo or = failed\");\n    }\n\n    {\n        // test moveIndex32()\n        UnicodeString s=UNICODE_STRING(\"\\\\U0002f999\\\\U0001d15f\\\\u00c4\\\\u1ed0\", 32).unescape();\n\n        if(\n            s.moveIndex32(2, -1)!=0 ||\n            s.moveIndex32(2, 1)!=4 ||\n            s.moveIndex32(2, 2)!=5 ||\n            s.moveIndex32(5, -2)!=2 ||\n            s.moveIndex32(0, -1)!=0 ||\n            s.moveIndex32(6, 1)!=6\n        ) {\n            errln(\"UnicodeString::moveIndex32() failed\");\n        }\n\n        if(s.getChar32Start(1)!=0 || s.getChar32Start(2)!=2) {\n            errln(\"UnicodeString::getChar32Start() failed\");\n        }\n\n        if(s.getChar32Limit(1)!=2 || s.getChar32Limit(2)!=2) {\n            errln(\"UnicodeString::getChar32Limit() failed\");\n        }\n    }\n\n    {\n        // test new 2.2 constructors and setTo function that parallel Java's substring function.\n        UnicodeString src(\"Hello folks how are you?\");\n        UnicodeString target1(\"how are you?\");\n        if (target1 != UnicodeString(src, 12)) {\n            errln(\"UnicodeString(const UnicodeString&, int32_t) failed\");\n        }\n        UnicodeString target2(\"folks\");\n        if (target2 != UnicodeString(src, 6, 5)) {\n            errln(\"UnicodeString(const UnicodeString&, int32_t, int32_t) failed\");\n        }\n        if (target1 != target2.setTo(src, 12)) {\n            errln(\"UnicodeString::setTo(const UnicodeString&, int32_t) failed\");\n        }\n    }\n\n    {\n        // op+ is new in ICU 2.8\n        UnicodeString s=UnicodeString(\"abc\", \"\")+UnicodeString(\"def\", \"\")+UnicodeString(\"ghi\", \"\");\n        if(s!=UnicodeString(\"abcdefghi\", \"\")) {\n            errln(\"operator+(UniStr, UniStr) failed\");\n        }\n    }\n\n    {\n        // tests for Jitterbug 2360\n        // verify that APIs with source pointer + length accept length == -1\n        // mostly test only where modified, only few functions did not already do this\n        if(UnicodeString(\"abc\", -1, \"\")!=UnicodeString(\"abc\", \"\")) {\n            errln(\"UnicodeString(codepageData, dataLength, codepage) does not work with dataLength==-1\");\n        }\n\n        UChar buffer[10]={ 0x61, 0x62, 0x20ac, 0xd900, 0xdc05, 0,   0x62, 0xffff, 0xdbff, 0xdfff };\n        UnicodeString s, t(buffer, -1, UPRV_LENGTHOF(buffer));\n\n        if(s.setTo(buffer, -1, UPRV_LENGTHOF(buffer)).length()!=u_strlen(buffer)) {\n            errln(\"UnicodeString.setTo(buffer, length, capacity) does not work with length==-1\");\n        }\n        if(t.length()!=u_strlen(buffer)) {\n            errln(\"UnicodeString(buffer, length, capacity) does not work with length==-1\");\n        }\n\n        if(0!=s.caseCompare(buffer, -1, U_FOLD_CASE_DEFAULT)) {\n            errln(\"UnicodeString.caseCompare(const UChar *, length, options) does not work with length==-1\");\n        }\n        if(0!=s.caseCompare(0, s.length(), buffer, U_FOLD_CASE_DEFAULT)) {\n            errln(\"UnicodeString.caseCompare(start, _length, const UChar *, options) does not work\");\n        }\n\n        buffer[u_strlen(buffer)]=0xe4;\n        UnicodeString u(buffer, -1, UPRV_LENGTHOF(buffer));\n        if(s.setTo(buffer, -1, UPRV_LENGTHOF(buffer)).length()!=UPRV_LENGTHOF(buffer)) {\n            errln(\"UnicodeString.setTo(buffer without NUL, length, capacity) does not work with length==-1\");\n        }\n        if(u.length()!=UPRV_LENGTHOF(buffer)) {\n            errln(\"UnicodeString(buffer without NUL, length, capacity) does not work with length==-1\");\n        }\n\n        static const char cs[]={ 0x61, (char)0xe4, (char)0x85, 0 };\n        UConverter *cnv;\n        UErrorCode errorCode=U_ZERO_ERROR;\n\n        cnv=ucnv_open(\"ISO-8859-1\", &errorCode);\n        UnicodeString v(cs, -1, cnv, errorCode);\n        ucnv_close(cnv);\n        if(v!=CharsToUnicodeString(\"a\\\\xe4\\\\x85\")) {\n            errln(\"UnicodeString(const char *, length, cnv, errorCode) does not work with length==-1\");\n        }\n    }\n\n#if U_CHARSET_IS_UTF8\n    {\n        // Test the hardcoded-UTF-8 UnicodeString optimizations.\n        static const uint8_t utf8[]={ 0x61, 0xC3, 0xA4, 0xC3, 0x9F, 0xE4, 0xB8, 0x80, 0 };\n        static const UChar utf16[]={ 0x61, 0xE4, 0xDF, 0x4E00 };\n        UnicodeString from8a = UnicodeString((const char *)utf8);\n        UnicodeString from8b = UnicodeString((const char *)utf8, (int32_t)sizeof(utf8)-1);\n        UnicodeString from16(FALSE, utf16, UPRV_LENGTHOF(utf16));\n        if(from8a != from16 || from8b != from16) {\n            errln(\"UnicodeString(const char * U_CHARSET_IS_UTF8) failed\");\n        }\n        char buffer[16];\n        int32_t length8=from16.extract(0, 0x7fffffff, buffer, (uint32_t)sizeof(buffer));\n        if(length8!=((int32_t)sizeof(utf8)-1) || 0!=uprv_memcmp(buffer, utf8, sizeof(utf8))) {\n            errln(\"UnicodeString::extract(char * U_CHARSET_IS_UTF8) failed\");\n        }\n        length8=from16.extract(1, 2, buffer, (uint32_t)sizeof(buffer));\n        if(length8!=4 || buffer[length8]!=0 || 0!=uprv_memcmp(buffer, utf8+1, length8)) {\n            errln(\"UnicodeString::extract(substring to char * U_CHARSET_IS_UTF8) failed\");\n        }\n    }\n#endif\n}\n\nvoid\nUnicodeStringTest::TestCompare()\n{\n    UnicodeString   test1(\"this is a test\");\n    UnicodeString   test2(\"this is a test\");\n    UnicodeString   test3(\"this is a test of the emergency broadcast system\");\n    UnicodeString   test4(\"never say, \\\"this is a test\\\"!!\");\n\n    UnicodeString   test5((UChar)0x5000);\n    UnicodeString   test6((UChar)0x5100);\n\n    UChar         uniChars[] = { 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, \n                 0x20, 0x61, 0x20, 0x74, 0x65, 0x73, 0x74, 0 };\n    char            chars[] = \"this is a test\";\n\n    // test operator== and operator!=\n    if (test1 != test2 || test1 == test3 || test1 == test4)\n        errln(\"operator== or operator!= failed\");\n\n    // test operator> and operator<\n    if (test1 > test2 || test1 < test2 || !(test1 < test3) || !(test1 > test4) ||\n        !(test5 < test6)\n    ) {\n        errln(\"operator> or operator< failed\");\n    }\n\n    // test operator>= and operator<=\n    if (!(test1 >= test2) || !(test1 <= test2) || !(test1 <= test3) || !(test1 >= test4))\n        errln(\"operator>= or operator<= failed\");\n\n    // test compare(UnicodeString)\n    if (test1.compare(test2) != 0 || test1.compare(test3) >= 0 || test1.compare(test4) <= 0)\n        errln(\"compare(UnicodeString) failed\");\n\n    //test compare(offset, length, UnicodeString)\n    if(test1.compare(0, 14, test2) != 0 ||\n        test3.compare(0, 14, test2) != 0 ||\n        test4.compare(12, 14, test2) != 0 ||\n        test3.compare(0, 18, test1) <=0  )\n        errln(\"compare(offset, length, UnicodeString) failes\");\n\n    // test compare(UChar*)\n    if (test2.compare(uniChars) != 0 || test3.compare(uniChars) <= 0 || test4.compare(uniChars) >= 0)\n        errln(\"compare(UChar*) failed\");\n\n    // test compare(char*)\n    if (test2.compare(chars) != 0 || test3.compare(chars) <= 0 || test4.compare(chars) >= 0)\n        errln(\"compare(char*) failed\");\n\n    // test compare(UChar*, length)\n    if (test1.compare(uniChars, 4) <= 0 || test1.compare(uniChars, 4) <= 0)\n        errln(\"compare(UChar*, length) failed\");\n\n    // test compare(thisOffset, thisLength, that, thatOffset, thatLength)\n    if (test1.compare(0, 14, test2, 0, 14) != 0 \n    || test1.compare(0, 14, test3, 0, 14) != 0\n    || test1.compare(0, 14, test4, 12, 14) != 0)\n        errln(\"1. compare(thisOffset, thisLength, that, thatOffset, thatLength) failed\");\n\n    if (test1.compare(10, 4, test2, 0, 4) >= 0 \n    || test1.compare(10, 4, test3, 22, 9) <= 0\n    || test1.compare(10, 4, test4, 22, 4) != 0)\n        errln(\"2. compare(thisOffset, thisLength, that, thatOffset, thatLength) failed\");\n\n    // test compareBetween\n    if (test1.compareBetween(0, 14, test2, 0, 14) != 0 || test1.compareBetween(0, 14, test3, 0, 14) != 0\n                    || test1.compareBetween(0, 14, test4, 12, 26) != 0)\n        errln(\"compareBetween failed\");\n\n    if (test1.compareBetween(10, 14, test2, 0, 4) >= 0 || test1.compareBetween(10, 14, test3, 22, 31) <= 0\n                    || test1.compareBetween(10, 14, test4, 22, 26) != 0)\n        errln(\"compareBetween failed\");\n\n    // test compare() etc. with strings that share a buffer but are not equal\n    test2=test1; // share the buffer, length() too large for the stackBuffer\n    test2.truncate(1); // change only the length, not the buffer\n    if( test1==test2 || test1<=test2 ||\n        test1.compare(test2)<=0 ||\n        test1.compareCodePointOrder(test2)<=0 ||\n        test1.compareCodePointOrder(0, INT32_MAX, test2)<=0 ||\n        test1.compareCodePointOrder(0, INT32_MAX, test2, 0, INT32_MAX)<=0 ||\n        test1.compareCodePointOrderBetween(0, INT32_MAX, test2, 0, INT32_MAX)<=0 ||\n        test1.caseCompare(test2, U_FOLD_CASE_DEFAULT)<=0\n    ) {\n        errln(\"UnicodeStrings that share a buffer but have different lengths compare as equal\");\n    }\n\n    /* test compareCodePointOrder() */\n    {\n        /* these strings are in ascending order */\n        static const UChar strings[][4]={\n            { 0x61, 0 },                    /* U+0061 */\n            { 0x20ac, 0xd801, 0 },          /* U+20ac U+d801 */\n            { 0x20ac, 0xd800, 0xdc00, 0 },  /* U+20ac U+10000 */\n            { 0xd800, 0 },                  /* U+d800 */\n            { 0xd800, 0xff61, 0 },          /* U+d800 U+ff61 */\n            { 0xdfff, 0 },                  /* U+dfff */\n            { 0xff61, 0xdfff, 0 },          /* U+ff61 U+dfff */\n            { 0xff61, 0xd800, 0xdc02, 0 },  /* U+ff61 U+10002 */\n            { 0xd800, 0xdc02, 0 },          /* U+10002 */\n            { 0xd84d, 0xdc56, 0 }           /* U+23456 */\n        };\n        UnicodeString u[20]; // must be at least as long as strings[]\n        int32_t i;\n\n        for(i=0; i<UPRV_LENGTHOF(strings); ++i) {\n            u[i]=UnicodeString(TRUE, strings[i], -1);\n        }\n\n        for(i=0; i<UPRV_LENGTHOF(strings)-1; ++i) {\n            if(u[i].compareCodePointOrder(u[i+1])>=0 || u[i].compareCodePointOrder(0, INT32_MAX, u[i+1].getBuffer())>=0) {\n                errln(\"error: UnicodeString::compareCodePointOrder() fails for string %d and the following one\\n\", i);\n            }\n        }\n    }\n\n    /* test caseCompare() */\n    {\n        static const UChar\n        _mixed[]=               { 0x61, 0x42, 0x131, 0x3a3, 0xdf,       0x130,       0x49,  0xfb03,           0xd93f, 0xdfff, 0 },\n        _otherDefault[]=        { 0x41, 0x62, 0x131, 0x3c3, 0x73, 0x53, 0x69, 0x307, 0x69,  0x46, 0x66, 0x49, 0xd93f, 0xdfff, 0 },\n        _otherExcludeSpecialI[]={ 0x41, 0x62, 0x131, 0x3c3, 0x53, 0x73, 0x69,        0x131, 0x66, 0x46, 0x69, 0xd93f, 0xdfff, 0 },\n        _different[]=           { 0x41, 0x62, 0x131, 0x3c3, 0x73, 0x53, 0x130,       0x49,  0x46, 0x66, 0x49, 0xd93f, 0xdffd, 0 };\n\n        UnicodeString\n            mixed(TRUE, _mixed, -1),\n            otherDefault(TRUE, _otherDefault, -1),\n            otherExcludeSpecialI(TRUE, _otherExcludeSpecialI, -1),\n            different(TRUE, _different, -1);\n\n        int8_t result;\n\n        /* test caseCompare() */\n        result=mixed.caseCompare(otherDefault, U_FOLD_CASE_DEFAULT);\n        if(result!=0 || 0!=mixed.caseCompareBetween(0, INT32_MAX, otherDefault, 0, INT32_MAX, U_FOLD_CASE_DEFAULT)) {\n            errln(\"error: mixed.caseCompare(other, default)=%ld instead of 0\\n\", result);\n        }\n        result=mixed.caseCompare(otherExcludeSpecialI, U_FOLD_CASE_EXCLUDE_SPECIAL_I);\n        if(result!=0) {\n            errln(\"error: mixed.caseCompare(otherExcludeSpecialI, U_FOLD_CASE_EXCLUDE_SPECIAL_I)=%ld instead of 0\\n\", result);\n        }\n        result=mixed.caseCompare(otherDefault, U_FOLD_CASE_EXCLUDE_SPECIAL_I);\n        if(result==0 || 0==mixed.caseCompareBetween(0, INT32_MAX, otherDefault, 0, INT32_MAX, U_FOLD_CASE_EXCLUDE_SPECIAL_I)) {\n            errln(\"error: mixed.caseCompare(other, U_FOLD_CASE_EXCLUDE_SPECIAL_I)=0 instead of !=0\\n\");\n        }\n\n        /* test caseCompare() */\n        result=mixed.caseCompare(different, U_FOLD_CASE_DEFAULT);\n        if(result<=0) {\n            errln(\"error: mixed.caseCompare(different, default)=%ld instead of positive\\n\", result);\n        }\n\n        /* test caseCompare() - include the folded sharp s (U+00df) with different lengths */\n        result=mixed.caseCompare(1, 4, different, 1, 5, U_FOLD_CASE_DEFAULT);\n        if(result!=0 || 0!=mixed.caseCompareBetween(1, 5, different, 1, 6, U_FOLD_CASE_DEFAULT)) {\n            errln(\"error: mixed.caseCompare(mixed, 1, 4, different, 1, 5, default)=%ld instead of 0\\n\", result);\n        }\n\n        /* test caseCompare() - stop in the middle of the sharp s (U+00df) */\n        result=mixed.caseCompare(1, 4, different, 1, 4, U_FOLD_CASE_DEFAULT);\n        if(result<=0) {\n            errln(\"error: mixed.caseCompare(1, 4, different, 1, 4, default)=%ld instead of positive\\n\", result);\n        }\n    }\n\n    // test that srcLength=-1 is handled in functions that\n    // take input const UChar */int32_t srcLength (j785)\n    {\n        static const UChar u[]={ 0x61, 0x308, 0x62, 0 };\n        UnicodeString s=UNICODE_STRING(\"a\\\\u0308b\", 8).unescape();\n\n        if(s.compare(u, -1)!=0 || s.compare(0, 999, u, 0, -1)!=0) {\n            errln(\"error UnicodeString::compare(..., const UChar *, srcLength=-1) does not work\");\n        }\n\n        if(s.compareCodePointOrder(u, -1)!=0 || s.compareCodePointOrder(0, 999, u, 0, -1)!=0) {\n            errln(\"error UnicodeString::compareCodePointOrder(..., const UChar *, srcLength=-1, ...) does not work\");\n        }\n\n        if(s.caseCompare(u, -1, U_FOLD_CASE_DEFAULT)!=0 || s.caseCompare(0, 999, u, 0, -1, U_FOLD_CASE_DEFAULT)!=0) {\n            errln(\"error UnicodeString::caseCompare(..., const UChar *, srcLength=-1, ...) does not work\");\n        }\n\n        if(s.indexOf(u, 1, -1, 0, 999)!=1 || s.indexOf(u+1, -1, 0, 999)!=1 || s.indexOf(u+1, -1, 0)!=1) {\n            errln(\"error UnicodeString::indexOf(const UChar *, srcLength=-1, ...) does not work\");\n        }\n\n        if(s.lastIndexOf(u, 1, -1, 0, 999)!=1 || s.lastIndexOf(u+1, -1, 0, 999)!=1 || s.lastIndexOf(u+1, -1, 0)!=1) {\n            errln(\"error UnicodeString::lastIndexOf(const UChar *, srcLength=-1, ...) does not work\");\n        }\n\n        UnicodeString s2, s3;\n        s2.replace(0, 0, u+1, -1);\n        s3.replace(0, 0, u, 1, -1);\n        if(s.compare(1, 999, s2)!=0 || s2!=s3) {\n            errln(\"error UnicodeString::replace(..., const UChar *, srcLength=-1, ...) does not work\");\n        }\n    }\n}\n\nvoid\nUnicodeStringTest::TestExtract()\n{\n    UnicodeString  test1(\"Now is the time for all good men to come to the aid of their country.\", \"\");\n    UnicodeString  test2;\n    UChar          test3[13] = {1, 2, 3, 4, 5, 6, 7, 8, 8, 10, 11, 12, 13};\n    char           test4[13] = {1, 2, 3, 4, 5, 6, 7, 8, 8, 10, 11, 12, 13};\n    UnicodeString  test5;\n    char           test6[13] = {1, 2, 3, 4, 5, 6, 7, 8, 8, 10, 11, 12, 13};\n\n    test1.extract(11, 12, test2);\n    test1.extract(11, 12, test3);\n    if (test1.extract(11, 12, test4) != 12 || test4[12] != 0) {\n        errln(\"UnicodeString.extract(char *) failed to return the correct size of destination buffer.\");\n    }\n\n    // test proper pinning in extractBetween()\n    test1.extractBetween(-3, 7, test5);\n    if(test5!=UNICODE_STRING(\"Now is \", 7)) {\n        errln(\"UnicodeString.extractBetween(-3, 7) did not pin properly.\");\n    }\n\n    test1.extractBetween(11, 23, test5);\n    if (test1.extract(60, 71, test6) != 9) {\n        errln(\"UnicodeString.extract() failed to return the correct size of destination buffer for end of buffer.\");\n    }\n    if (test1.extract(11, 12, test6) != 12) {\n        errln(\"UnicodeString.extract() failed to return the correct size of destination buffer.\");\n    }\n\n    // convert test4 back to Unicode for comparison\n    UnicodeString test4b(test4, 12);\n\n    if (test1.extract(11, 12, (char *)NULL) != 12) {\n        errln(\"UnicodeString.extract(NULL) failed to return the correct size of destination buffer.\");\n    }\n    if (test1.extract(11, -1, test6) != 0) {\n        errln(\"UnicodeString.extract(-1) failed to stop reading the string.\");\n    }\n\n    for (int32_t i = 0; i < 12; i++) {\n        if (test1.charAt((int32_t)(11 + i)) != test2.charAt(i)) {\n            errln(UnicodeString(\"extracting into a UnicodeString failed at position \") + i);\n            break;\n        }\n        if (test1.charAt((int32_t)(11 + i)) != test3[i]) {\n            errln(UnicodeString(\"extracting into an array of UChar failed at position \") + i);\n            break;\n        }\n        if (((char)test1.charAt((int32_t)(11 + i))) != test4b.charAt(i)) {\n            errln(UnicodeString(\"extracting into an array of char failed at position \") + i);\n            break;\n        }\n        if (test1.charAt((int32_t)(11 + i)) != test5.charAt(i)) {\n            errln(UnicodeString(\"extracting with extractBetween failed at position \") + i);\n            break;\n        }\n    }\n\n    // test preflighting and overflows with invariant conversion\n    if (test1.extract(0, 10, (char *)NULL, \"\") != 10) {\n        errln(\"UnicodeString.extract(0, 10, (char *)NULL, \\\"\\\") != 10\");\n    }\n\n    test4[2] = (char)0xff;\n    if (test1.extract(0, 10, test4, 2, \"\") != 10) {\n        errln(\"UnicodeString.extract(0, 10, test4, 2, \\\"\\\") != 10\");\n    }\n    if (test4[2] != (char)0xff) {\n        errln(\"UnicodeString.extract(0, 10, test4, 2, \\\"\\\") overwrote test4[2]\");\n    }\n\n    {\n        // test new, NUL-terminating extract() function\n        UnicodeString s(\"terminate\", \"\");\n        UChar dest[20]={\n            0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,\n            0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5\n        };\n        UErrorCode errorCode;\n        int32_t length;\n\n        errorCode=U_ZERO_ERROR;\n        length=s.extract((UChar *)NULL, 0, errorCode);\n        if(errorCode!=U_BUFFER_OVERFLOW_ERROR || length!=s.length()) {\n            errln(\"UnicodeString.extract(NULL, 0)==%d (%s) expected %d (U_BUFFER_OVERFLOW_ERROR)\", length, s.length(), u_errorName(errorCode));\n        }\n\n        errorCode=U_ZERO_ERROR;\n        length=s.extract(dest, s.length()-1, errorCode);\n        if(errorCode!=U_BUFFER_OVERFLOW_ERROR || length!=s.length()) {\n            errln(\"UnicodeString.extract(dest too short)==%d (%s) expected %d (U_BUFFER_OVERFLOW_ERROR)\",\n                length, u_errorName(errorCode), s.length());\n        }\n\n        errorCode=U_ZERO_ERROR;\n        length=s.extract(dest, s.length(), errorCode);\n        if(errorCode!=U_STRING_NOT_TERMINATED_WARNING || length!=s.length()) {\n            errln(\"UnicodeString.extract(dest just right without NUL)==%d (%s) expected %d (U_STRING_NOT_TERMINATED_WARNING)\",\n                length, u_errorName(errorCode), s.length());\n        }\n        if(dest[length-1]!=s[length-1] || dest[length]!=0xa5) {\n            errln(\"UnicodeString.extract(dest just right without NUL) did not extract the string correctly\");\n        }\n\n        errorCode=U_ZERO_ERROR;\n        length=s.extract(dest, s.length()+1, errorCode);\n        if(errorCode!=U_ZERO_ERROR || length!=s.length()) {\n            errln(\"UnicodeString.extract(dest large enough)==%d (%s) expected %d (U_ZERO_ERROR)\",\n                length, u_errorName(errorCode), s.length());\n        }\n        if(dest[length-1]!=s[length-1] || dest[length]!=0 || dest[length+1]!=0xa5) {\n            errln(\"UnicodeString.extract(dest large enough) did not extract the string correctly\");\n        }\n    }\n\n    {\n        // test new UConverter extract() and constructor\n        UnicodeString s=UNICODE_STRING(\"\\\\U0002f999\\\\U0001d15f\\\\u00c4\\\\u1ed0\", 32).unescape();\n        char buffer[32];\n        static const char expect[]={\n            (char)0xf0, (char)0xaf, (char)0xa6, (char)0x99,\n            (char)0xf0, (char)0x9d, (char)0x85, (char)0x9f,\n            (char)0xc3, (char)0x84,\n            (char)0xe1, (char)0xbb, (char)0x90\n        };\n        UErrorCode errorCode=U_ZERO_ERROR;\n        UConverter *cnv=ucnv_open(\"UTF-8\", &errorCode);\n        int32_t length;\n\n        if(U_SUCCESS(errorCode)) {\n            // test preflighting\n            if( (length=s.extract(NULL, 0, cnv, errorCode))!=13 ||\n                errorCode!=U_BUFFER_OVERFLOW_ERROR\n            ) {\n                errln(\"UnicodeString::extract(NULL, UConverter) preflighting failed (length=%ld, %s)\",\n                      length, u_errorName(errorCode));\n            }\n            errorCode=U_ZERO_ERROR;\n            if( (length=s.extract(buffer, 2, cnv, errorCode))!=13 ||\n                errorCode!=U_BUFFER_OVERFLOW_ERROR\n            ) {\n                errln(\"UnicodeString::extract(too small, UConverter) preflighting failed (length=%ld, %s)\",\n                      length, u_errorName(errorCode));\n            }\n\n            // try error cases\n            errorCode=U_ZERO_ERROR;\n            if( s.extract(NULL, 2, cnv, errorCode)==13 || U_SUCCESS(errorCode)) {\n                errln(\"UnicodeString::extract(UConverter) succeeded with an illegal destination\");\n            }\n            errorCode=U_ILLEGAL_ARGUMENT_ERROR;\n            if( s.extract(NULL, 0, cnv, errorCode)==13 || U_SUCCESS(errorCode)) {\n                errln(\"UnicodeString::extract(UConverter) succeeded with a previous error code\");\n            }\n            errorCode=U_ZERO_ERROR;\n\n            // extract for real\n            if( (length=s.extract(buffer, sizeof(buffer), cnv, errorCode))!=13 ||\n                uprv_memcmp(buffer, expect, 13)!=0 ||\n                buffer[13]!=0 ||\n                U_FAILURE(errorCode)\n            ) {\n                errln(\"UnicodeString::extract(UConverter) conversion failed (length=%ld, %s)\",\n                      length, u_errorName(errorCode));\n            }\n            // Test again with just the converter name.\n            if( (length=s.extract(0, s.length(), buffer, sizeof(buffer), \"UTF-8\"))!=13 ||\n                uprv_memcmp(buffer, expect, 13)!=0 ||\n                buffer[13]!=0 ||\n                U_FAILURE(errorCode)\n            ) {\n                errln(\"UnicodeString::extract(\\\"UTF-8\\\") conversion failed (length=%ld, %s)\",\n                      length, u_errorName(errorCode));\n            }\n\n            // try the constructor\n            UnicodeString t(expect, sizeof(expect), cnv, errorCode);\n            if(U_FAILURE(errorCode) || s!=t) {\n                errln(\"UnicodeString(UConverter) conversion failed (%s)\",\n                      u_errorName(errorCode));\n            }\n\n            ucnv_close(cnv);\n        }\n    }\n}\n\nvoid\nUnicodeStringTest::TestRemoveReplace()\n{\n    UnicodeString   test1(\"The rain in Spain stays mainly on the plain\");\n    UnicodeString   test2(\"eat SPAMburgers!\");\n    UChar         test3[] = { 0x53, 0x50, 0x41, 0x4d, 0x4d, 0 };\n    char            test4[] = \"SPAM\";\n    UnicodeString&  test5 = test1;\n\n    test1.replace(4, 4, test2, 4, 4);\n    test1.replace(12, 5, test3, 4);\n    test3[4] = 0;\n    test1.replace(17, 4, test3);\n    test1.replace(23, 4, test4);\n    test1.replaceBetween(37, 42, test2, 4, 8);\n\n    if (test1 != \"The SPAM in SPAM SPAMs SPAMly on the SPAM\")\n        errln(\"One of the replace methods failed:\\n\"\n              \"  expected \\\"The SPAM in SPAM SPAMs SPAMly on the SPAM\\\",\\n\"\n              \"  got \\\"\" + test1 + \"\\\"\");\n\n    test1.remove(21, 1);\n    test1.removeBetween(26, 28);\n\n    if (test1 != \"The SPAM in SPAM SPAM SPAM on the SPAM\")\n        errln(\"One of the remove methods failed:\\n\"\n              \"  expected \\\"The SPAM in SPAM SPAM SPAM on the SPAM\\\",\\n\"\n              \"  got \\\"\" + test1 + \"\\\"\");\n\n    for (int32_t i = 0; i < test1.length(); i++) {\n        if (test5[i] != 0x53 && test5[i] != 0x50 && test5[i] != 0x41 && test5[i] != 0x4d && test5[i] != 0x20) {\n            test1.setCharAt(i, 0x78);\n        }\n    }\n\n    if (test1 != \"xxx SPAM xx SPAM SPAM SPAM xx xxx SPAM\")\n        errln(\"One of the remove methods failed:\\n\"\n              \"  expected \\\"xxx SPAM xx SPAM SPAM SPAM xx xxx SPAM\\\",\\n\"\n              \"  got \\\"\" + test1 + \"\\\"\");\n\n    test1.remove();\n    if (test1.length() != 0)\n        errln(\"Remove() failed: expected empty string, got \\\"\" + test1 + \"\\\"\");\n}\n\nvoid\nUnicodeStringTest::TestSearching()\n{\n    UnicodeString test1(\"test test ttest tetest testesteststt\");\n    UnicodeString test2(\"test\");\n    UChar testChar = 0x74;\n    \n    UChar32 testChar32 = 0x20402;\n    UChar testData[]={\n        //   0       1       2       3       4       5       6       7\n        0xd841, 0xdc02, 0x0071, 0xdc02, 0xd841, 0x0071, 0xd841, 0xdc02,\n\n        //   8       9      10      11      12      13      14      15\n        0x0071, 0x0072, 0xd841, 0xdc02, 0x0071, 0xd841, 0xdc02, 0x0071,\n\n        //  16      17      18      19\n        0xdc02, 0xd841, 0x0073, 0x0000\n    };\n    UnicodeString test3(testData);\n    UnicodeString test4(testChar32);\n\n    uint16_t occurrences = 0;\n    int32_t startPos = 0;\n    for ( ;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(test2, startPos)) != -1 ? (++occurrences, startPos += 4) : 0)\n        ;\n    if (occurrences != 6)\n        errln(UnicodeString(\"indexOf failed: expected to find 6 occurrences, found \") + occurrences);\n\n    for ( occurrences = 0, startPos = 10;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(test2, startPos)) != -1 ? (++occurrences, startPos += 4) : 0)\n        ;\n    if (occurrences != 4)\n        errln(UnicodeString(\"indexOf with starting offset failed: \"\n                            \"expected to find 4 occurrences, found \") + occurrences);\n\n    int32_t endPos = 28;\n    for ( occurrences = 0, startPos = 5;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(test2, startPos, endPos - startPos)) != -1 ? (++occurrences, startPos += 4) : 0)\n        ;\n    if (occurrences != 4)\n        errln(UnicodeString(\"indexOf with starting and ending offsets failed: \"\n                            \"expected to find 4 occurrences, found \") + occurrences);\n\n    //using UChar32 string\n    for ( startPos=0, occurrences=0;\n          startPos != -1 && startPos < test3.length();\n          (startPos = test3.indexOf(test4, startPos)) != -1 ? (++occurrences, startPos += 2) : 0)\n        ;\n    if (occurrences != 4)\n        errln((UnicodeString)\"indexOf failed: expected to find 4 occurrences, found \" + occurrences);\n\n    for ( startPos=10, occurrences=0;\n          startPos != -1 && startPos < test3.length();\n          (startPos = test3.indexOf(test4, startPos)) != -1 ? (++occurrences, startPos += 2) : 0)\n        ;\n    if (occurrences != 2)\n        errln(UnicodeString(\"indexOf failed: expected to find 2 occurrences, found \") + occurrences);\n    //---\n\n    for ( occurrences = 0, startPos = 0;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(testChar, startPos)) != -1 ? (++occurrences, startPos += 1) : 0)\n        ;\n    if (occurrences != 16)\n        errln(UnicodeString(\"indexOf with character failed: \"\n                            \"expected to find 16 occurrences, found \") + occurrences);\n\n    for ( occurrences = 0, startPos = 10;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(testChar, startPos)) != -1 ? (++occurrences, startPos += 1) : 0)\n        ;\n    if (occurrences != 12)\n        errln(UnicodeString(\"indexOf with character & start offset failed: \"\n                            \"expected to find 12 occurrences, found \") + occurrences);\n\n    for ( occurrences = 0, startPos = 5, endPos = 28;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(testChar, startPos, endPos - startPos)) != -1 ? (++occurrences, startPos += 1) : 0)\n        ;\n    if (occurrences != 10)\n        errln(UnicodeString(\"indexOf with character & start & end offsets failed: \"\n                            \"expected to find 10 occurrences, found \") + occurrences);\n\n    //testing for UChar32\n    UnicodeString subString;\n    for( occurrences =0, startPos=0; startPos < test3.length(); startPos +=1){\n        subString.append(test3, startPos, test3.length());\n        if(subString.indexOf(testChar32) != -1 ){\n             ++occurrences;\n        }\n        subString.remove();\n    }\n    if (occurrences != 14)\n        errln((UnicodeString)\"indexOf failed: expected to find 14 occurrences, found \" + occurrences);\n\n    for ( occurrences = 0, startPos = 0;\n          startPos != -1 && startPos < test3.length();\n          (startPos = test3.indexOf(testChar32, startPos)) != -1 ? (++occurrences, startPos += 1) : 0)\n        ;\n    if (occurrences != 4)\n        errln((UnicodeString)\"indexOf failed: expected to find 4 occurrences, found \" + occurrences);\n     \n    endPos=test3.length();\n    for ( occurrences = 0, startPos = 5;\n          startPos != -1 && startPos < test3.length();\n          (startPos = test3.indexOf(testChar32, startPos, endPos - startPos)) != -1 ? (++occurrences, startPos += 1) : 0)\n        ;\n    if (occurrences != 3)\n        errln((UnicodeString)\"indexOf with character & start & end offsets failed: expected to find 2 occurrences, found \" + occurrences);\n    //---\n\n    if(test1.lastIndexOf(test2)!=29) {\n        errln(\"test1.lastIndexOf(test2)!=29\");\n    }\n\n    if(test1.lastIndexOf(test2, 15)!=29 || test1.lastIndexOf(test2, 29)!=29 || test1.lastIndexOf(test2, 30)!=-1) {\n        errln(\"test1.lastIndexOf(test2, start) failed\");\n    }\n\n    for ( occurrences = 0, startPos = 32;\n          startPos != -1;\n          (startPos = test1.lastIndexOf(test2, 5, startPos - 5)) != -1 ? ++occurrences : 0)\n        ;\n    if (occurrences != 4)\n        errln(UnicodeString(\"lastIndexOf with starting and ending offsets failed: \"\n                            \"expected to find 4 occurrences, found \") + occurrences);\n\n    for ( occurrences = 0, startPos = 32;\n          startPos != -1;\n          (startPos = test1.lastIndexOf(testChar, 5, startPos - 5)) != -1 ? ++occurrences : 0)\n        ;\n    if (occurrences != 11)\n        errln(UnicodeString(\"lastIndexOf with character & start & end offsets failed: \"\n                            \"expected to find 11 occurrences, found \") + occurrences);\n\n    //testing UChar32\n    startPos=test3.length();\n    for ( occurrences = 0;\n          startPos != -1;\n          (startPos = test3.lastIndexOf(testChar32, 5, startPos - 5)) != -1 ? ++occurrences : 0)\n        ;\n    if (occurrences != 3)\n        errln((UnicodeString)\"lastIndexOf with character & start & end offsets failed: expected to find 3 occurrences, found \" + occurrences);\n\n\n    for ( occurrences = 0, endPos = test3.length();  endPos > 0; endPos -= 1){\n        subString.remove();\n        subString.append(test3, 0, endPos);\n        if(subString.lastIndexOf(testChar32) != -1 ){\n            ++occurrences;\n        }\n    }\n    if (occurrences != 18)\n        errln((UnicodeString)\"indexOf failed: expected to find 18 occurrences, found \" + occurrences);\n    //---\n\n    // test that indexOf(UChar32) and lastIndexOf(UChar32)\n    // do not find surrogate code points when they are part of matched pairs\n    // (= part of supplementary code points)\n    // Jitterbug 1542\n    if(test3.indexOf((UChar32)0xd841) != 4 || test3.indexOf((UChar32)0xdc02) != 3) {\n        errln(\"error: UnicodeString::indexOf(UChar32 surrogate) finds a partial supplementary code point\");\n    }\n    if( UnicodeString(test3, 0, 17).lastIndexOf((UChar)0xd841, 0) != 4 ||\n        UnicodeString(test3, 0, 17).lastIndexOf((UChar32)0xd841, 2) != 4 ||\n        test3.lastIndexOf((UChar32)0xd841, 0, 17) != 4 || test3.lastIndexOf((UChar32)0xdc02, 0, 17) != 16\n    ) {\n        errln(\"error: UnicodeString::lastIndexOf(UChar32 surrogate) finds a partial supplementary code point\");\n    }\n}\n\nvoid\nUnicodeStringTest::TestSpacePadding()\n{\n    UnicodeString test1(\"hello\");\n    UnicodeString test2(\"   there\");\n    UnicodeString test3(\"Hi!  How ya doin'?  Beautiful day, isn't it?\");\n    UnicodeString test4;\n    UBool returnVal;\n    UnicodeString expectedValue;\n\n    returnVal = test1.padLeading(15);\n    expectedValue = \"          hello\";\n    if (returnVal == FALSE || test1 != expectedValue)\n        errln(\"padLeading() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test1 + \"\\\".\");\n\n    returnVal = test2.padTrailing(15);\n    expectedValue = \"   there       \";\n    if (returnVal == FALSE || test2 != expectedValue)\n        errln(\"padTrailing() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test2 + \"\\\".\");\n\n    expectedValue = test3;\n    returnVal = test3.padTrailing(15);\n    if (returnVal == TRUE || test3 != expectedValue)\n        errln(\"padTrailing() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test3 + \"\\\".\");\n\n    expectedValue = \"hello\";\n    test4.setTo(test1).trim();\n\n    if (test4 != expectedValue || test1 == expectedValue || test4 != expectedValue)\n        errln(\"trim(UnicodeString&) failed\");\n    \n    test1.trim();\n    if (test1 != expectedValue)\n        errln(\"trim() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test1 + \"\\\".\");\n\n    test2.trim();\n    expectedValue = \"there\";\n    if (test2 != expectedValue)\n        errln(\"trim() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test2 + \"\\\".\");\n\n    test3.trim();\n    expectedValue = \"Hi!  How ya doin'?  Beautiful day, isn't it?\";\n    if (test3 != expectedValue)\n        errln(\"trim() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test3 + \"\\\".\");\n\n    returnVal = test1.truncate(15);\n    expectedValue = \"hello\";\n    if (returnVal == TRUE || test1 != expectedValue)\n        errln(\"truncate() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test1 + \"\\\".\");\n\n    returnVal = test2.truncate(15);\n    expectedValue = \"there\";\n    if (returnVal == TRUE || test2 != expectedValue)\n        errln(\"truncate() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test2 + \"\\\".\");\n\n    returnVal = test3.truncate(15);\n    expectedValue = \"Hi!  How ya doi\";\n    if (returnVal == FALSE || test3 != expectedValue)\n        errln(\"truncate() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test3 + \"\\\".\");\n}\n\nvoid\nUnicodeStringTest::TestPrefixAndSuffix()\n{\n    UnicodeString test1(\"Now is the time for all good men to come to the aid of their country.\");\n    UnicodeString test2(\"Now\");\n    UnicodeString test3(\"country.\");\n    UnicodeString test4(\"count\");\n\n    if (!test1.startsWith(test2) || !test1.startsWith(test2, 0, test2.length())) {\n        errln(\"startsWith() failed: \\\"\" + test2 + \"\\\" should be a prefix of \\\"\" + test1 + \"\\\".\");\n    }\n\n    if (test1.startsWith(test3) ||\n        test1.startsWith(test3.getBuffer(), test3.length()) ||\n        test1.startsWith(test3.getTerminatedBuffer(), 0, -1)\n    ) {\n        errln(\"startsWith() failed: \\\"\" + test3 + \"\\\" shouldn't be a prefix of \\\"\" + test1 + \"\\\".\");\n    }\n\n    if (test1.endsWith(test2)) {\n        errln(\"endsWith() failed: \\\"\" + test2 + \"\\\" shouldn't be a suffix of \\\"\" + test1 + \"\\\".\");\n    }\n\n    if (!test1.endsWith(test3)) { \n        errln(\"endsWith(test3) failed: \\\"\" + test3 + \"\\\" should be a suffix of \\\"\" + test1 + \"\\\".\");\n    }\n    if (!test1.endsWith(test3, 0, INT32_MAX)) {\n        errln(\"endsWith(test3, 0, INT32_MAX) failed: \\\"\" + test3 + \"\\\" should be a suffix of \\\"\" + test1 + \"\\\".\");\n    }\n\n    if(!test1.endsWith(test3.getBuffer(), test3.length())) {\n        errln(\"endsWith(test3.getBuffer(), test3.length()) failed: \\\"\" + test3 + \"\\\" should be a suffix of \\\"\" + test1 + \"\\\".\");\n    }\n    if(!test1.endsWith(test3.getTerminatedBuffer(), 0, -1)) {\n        errln(\"endsWith(test3.getTerminatedBuffer(), 0, -1) failed: \\\"\" + test3 + \"\\\" should be a suffix of \\\"\" + test1 + \"\\\".\");\n    }\n\n    if (!test3.startsWith(test4)) {\n        errln(\"endsWith(test4) failed: \\\"\" + test4 + \"\\\" should be a prefix of \\\"\" + test3 + \"\\\".\");\n    }\n\n    if (test4.startsWith(test3)) {\n        errln(\"startsWith(test3) failed: \\\"\" + test3 + \"\\\" shouldn't be a prefix of \\\"\" + test4 + \"\\\".\");\n    }\n}\n\nvoid\nUnicodeStringTest::TestStartsWithAndEndsWithNulTerminated() {\n    UnicodeString test(\"abcde\");\n    const UChar ab[] = { 0x61, 0x62, 0 };\n    const UChar de[] = { 0x64, 0x65, 0 };\n    assertTrue(\"abcde.startsWith(ab, -1)\", test.startsWith(ab, -1));\n    assertTrue(\"abcde.startsWith(ab, 0, -1)\", test.startsWith(ab, 0, -1));\n    assertTrue(\"abcde.endsWith(de, -1)\", test.endsWith(de, -1));\n    assertTrue(\"abcde.endsWith(de, 0, -1)\", test.endsWith(de, 0, -1));\n}\n\nvoid\nUnicodeStringTest::TestFindAndReplace()\n{\n    UnicodeString test1(\"One potato, two potato, three potato, four\\n\");\n    UnicodeString test2(\"potato\");\n    UnicodeString test3(\"MISSISSIPPI\");\n\n    UnicodeString expectedValue;\n\n    test1.findAndReplace(test2, test3);\n    expectedValue = \"One MISSISSIPPI, two MISSISSIPPI, three MISSISSIPPI, four\\n\";\n    if (test1 != expectedValue)\n        errln(\"findAndReplace failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test1 + \"\\\".\");\n    test1.findAndReplace(2, 32, test3, test2);\n    expectedValue = \"One potato, two potato, three MISSISSIPPI, four\\n\";\n    if (test1 != expectedValue)\n        errln(\"findAndReplace failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test1 + \"\\\".\");\n}\n\nvoid\nUnicodeStringTest::TestReverse()\n{\n    UnicodeString test(\"backwards words say to used I\");\n\n    test.reverse();\n    test.reverse(2, 4);\n    test.reverse(7, 2);\n    test.reverse(10, 3);\n    test.reverse(14, 5);\n    test.reverse(20, 9);\n\n    if (test != \"I used to say words backwards\")\n        errln(\"reverse() failed:  Expected \\\"I used to say words backwards\\\",\\n got \\\"\"\n            + test + \"\\\"\");\n\n    test=UNICODE_STRING(\"\\\\U0002f999\\\\U0001d15f\\\\u00c4\\\\u1ed0\", 32).unescape();\n    test.reverse();\n    if(test.char32At(0)!=0x1ed0 || test.char32At(1)!=0xc4 || test.char32At(2)!=0x1d15f || test.char32At(4)!=0x2f999) {\n        errln(\"reverse() failed with supplementary characters\");\n    }\n\n    // Test case for ticket #8091:\n    // UnicodeString::reverse() failed to see a lead surrogate in the middle of\n    // an odd-length string that contains no other lead surrogates.\n    test=UNICODE_STRING_SIMPLE(\"ab\\\\U0001F4A9e\").unescape();\n    UnicodeString expected=UNICODE_STRING_SIMPLE(\"e\\\\U0001F4A9ba\").unescape();\n    test.reverse();\n    if(test!=expected) {\n        errln(\"reverse() failed with only lead surrogate in the middle\");\n    }\n}\n\nvoid\nUnicodeStringTest::TestMiscellaneous()\n{\n    UnicodeString   test1(\"This is a test\");\n    UnicodeString   test2(\"This is a test\");\n    UnicodeString   test3(\"Me too!\");\n\n    // test getBuffer(minCapacity) and releaseBuffer()\n    test1=UnicodeString(); // make sure that it starts with its stackBuffer\n    UChar *p=test1.getBuffer(20);\n    if(test1.getCapacity()<20) {\n        errln(\"UnicodeString::getBuffer(20).getCapacity()<20\");\n    }\n\n    test1.append((UChar)7); // must not be able to modify the string here\n    test1.setCharAt(3, 7);\n    test1.reverse();\n    if( test1.length()!=0 ||\n        test1.charAt(0)!=0xffff || test1.charAt(3)!=0xffff ||\n        test1.getBuffer(10)!=0 || test1.getBuffer()!=0\n    ) {\n        errln(\"UnicodeString::getBuffer(minCapacity) allows read or write access to the UnicodeString\");\n    }\n\n    p[0]=1;\n    p[1]=2;\n    p[2]=3;\n    test1.releaseBuffer(3);\n    test1.append((UChar)4);\n\n    if(test1.length()!=4 || test1.charAt(0)!=1 || test1.charAt(1)!=2 || test1.charAt(2)!=3 || test1.charAt(3)!=4) {\n        errln(\"UnicodeString::releaseBuffer(newLength) does not properly reallow access to the UnicodeString\");\n    }\n\n    // test releaseBuffer() without getBuffer(minCapacity) - must not have any effect\n    test1.releaseBuffer(1);\n    if(test1.length()!=4 || test1.charAt(0)!=1 || test1.charAt(1)!=2 || test1.charAt(2)!=3 || test1.charAt(3)!=4) {\n        errln(\"UnicodeString::releaseBuffer(newLength) without getBuffer(minCapacity) changed the UnicodeString\");\n    }\n\n    // test getBuffer(const)\n    const UChar *q=test1.getBuffer(), *r=test1.getBuffer();\n    if( test1.length()!=4 ||\n        q[0]!=1 || q[1]!=2 || q[2]!=3 || q[3]!=4 ||\n        r[0]!=1 || r[1]!=2 || r[2]!=3 || r[3]!=4\n    ) {\n        errln(\"UnicodeString::getBuffer(const) does not return a usable buffer pointer\");\n    }\n\n    // test releaseBuffer() with a NUL-terminated buffer\n    test1.getBuffer(20)[2]=0;\n    test1.releaseBuffer(); // implicit -1\n    if(test1.length()!=2 || test1.charAt(0)!=1 || test1.charAt(1) !=2) {\n        errln(\"UnicodeString::releaseBuffer(-1) does not properly set the length of the UnicodeString\");\n    }\n\n    // test releaseBuffer() with a non-NUL-terminated buffer\n    p=test1.getBuffer(256);\n    for(int32_t i=0; i<test1.getCapacity(); ++i) {\n        p[i]=(UChar)1;      // fill the buffer with all non-NUL code units\n    }\n    test1.releaseBuffer();  // implicit -1\n    if(test1.length()!=test1.getCapacity() || test1.charAt(1)!=1 || test1.charAt(100)!=1 || test1.charAt(test1.getCapacity()-1)!=1) {\n        errln(\"UnicodeString::releaseBuffer(-1 but no NUL) does not properly set the length of the UnicodeString\");\n    }\n\n    // test getTerminatedBuffer()\n    test1=UnicodeString(\"This is another test.\", \"\");\n    test2=UnicodeString(\"This is another test.\", \"\");\n    q=test1.getTerminatedBuffer();\n    if(q[test1.length()]!=0 || test1!=test2 || test2.compare(q, -1)!=0) {\n        errln(\"getTerminatedBuffer()[length]!=0\");\n    }\n\n    const UChar u[]={ 5, 6, 7, 8, 0 };\n    test1.setTo(FALSE, u, 3);\n    q=test1.getTerminatedBuffer();\n    if(q==u || q[0]!=5 || q[1]!=6 || q[2]!=7 || q[3]!=0) {\n        errln(\"UnicodeString(u[3]).getTerminatedBuffer() returns a bad buffer\");\n    }\n\n    test1.setTo(TRUE, u, -1);\n    q=test1.getTerminatedBuffer();\n    if(q!=u || test1.length()!=4 || q[3]!=8 || q[4]!=0) {\n        errln(\"UnicodeString(u[-1]).getTerminatedBuffer() returns a bad buffer\");\n    }\n\n    // NOTE: Some compilers will optimize u\"la\" to point to the same static memory\n    // as u\" lila\", offset by 3 code units\n    test1=UnicodeString(TRUE, u\"la\", 2);\n    test1.append(UnicodeString(TRUE, u\" lila\", 5).getTerminatedBuffer(), 0, -1);\n    assertEquals(\"UnicodeString::append(const UChar *, start, length) failed\",\n        u\"la lila\", test1);\n\n    test1.insert(3, UnicodeString(TRUE, u\"dudum \", 6), 0, INT32_MAX);\n    assertEquals(\"UnicodeString::insert(start, const UniStr &, start, length) failed\",\n        u\"la dudum lila\", test1);\n\n    static const UChar ucs[]={ 0x68, 0x6d, 0x20, 0 };\n    test1.insert(9, ucs, -1);\n    assertEquals(\"UnicodeString::insert(start, const UChar *, length) failed\",\n        u\"la dudum hm lila\", test1);\n\n    test1.replace(9, 2, (UChar)0x2b);\n    assertEquals(\"UnicodeString::replace(start, length, UChar) failed\",\n        u\"la dudum + lila\", test1);\n\n    if(test1.hasMetaData() || UnicodeString().hasMetaData()) {\n        errln(\"UnicodeString::hasMetaData() returns TRUE\");\n    }\n\n    // test getTerminatedBuffer() on a truncated, shared, heap-allocated string\n    test1=UNICODE_STRING_SIMPLE(\"abcdefghijklmnopqrstuvwxyz0123456789.\");\n    test1.truncate(36);  // ensure length()<getCapacity()\n    test2=test1;  // share the buffer\n    test1.truncate(5);\n    if(test1.length()!=5 || test1.getTerminatedBuffer()[5]!=0) {\n        errln(\"UnicodeString(shared buffer).truncate() failed\");\n    }\n    if(test2.length()!=36 || test2[5]!=0x66 || u_strlen(test2.getTerminatedBuffer())!=36) {\n        errln(\"UnicodeString(shared buffer).truncate().getTerminatedBuffer() \"\n              \"modified another copy of the string!\");\n    }\n    test1=UNICODE_STRING_SIMPLE(\"abcdefghijklmnopqrstuvwxyz0123456789.\");\n    test1.truncate(36);  // ensure length()<getCapacity()\n    test2=test1;  // share the buffer\n    test1.remove();\n    if(test1.length()!=0 || test1.getTerminatedBuffer()[0]!=0) {\n        errln(\"UnicodeString(shared buffer).remove() failed\");\n    }\n    if(test2.length()!=36 || test2[0]!=0x61 || u_strlen(test2.getTerminatedBuffer())!=36) {\n        errln(\"UnicodeString(shared buffer).remove().getTerminatedBuffer() \"\n              \"modified another copy of the string!\");\n    }\n\n    // ticket #9740\n    test1.setTo(TRUE, ucs, 3);\n    assertEquals(\"length of read-only alias\", 3, test1.length());\n    test1.trim();\n    assertEquals(\"length of read-only alias after trim()\", 2, test1.length());\n    assertEquals(\"length of terminated buffer of read-only alias + trim()\",\n                 2, u_strlen(test1.getTerminatedBuffer()));\n}\n\nvoid\nUnicodeStringTest::TestStackAllocation()\n{\n    UChar           testString[] ={ \n        0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x63, 0x72, 0x61, 0x7a, 0x79, 0x20, 0x74, 0x65, 0x73, 0x74, 0x2e, 0 };\n    UChar           guardWord = 0x4DED;\n    UnicodeString*  test = 0;\n\n    test = new  UnicodeString(testString);\n    if (*test != \"This is a crazy test.\")\n        errln(\"Test string failed to initialize properly.\");\n    if (guardWord != 0x04DED)\n        errln(\"Test string initialization overwrote guard word!\");\n\n    test->insert(8, \"only \");\n    test->remove(15, 6);\n    if (*test != \"This is only a test.\")\n        errln(\"Manipulation of test string failed to work right.\");\n    if (guardWord != 0x4DED)\n        errln(\"Manipulation of test string overwrote guard word!\");\n\n    // we have to deinitialize and release the backing store by calling the destructor\n    // explicitly, since we can't overload operator delete\n    delete test;\n\n    UChar workingBuffer[] = {\n        0x4e, 0x6f, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20,\n        0x66, 0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6d, 0x65, 0x6e, 0x20, 0x74, 0x6f, 0x20,\n        0x63, 0x6f, 0x6d, 0x65, 0xffff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n    UChar guardWord2 = 0x4DED;\n\n    test = new UnicodeString(workingBuffer, 35, 100);\n    if (*test != \"Now is the time for all men to come\")\n        errln(\"Stack-allocated backing store failed to initialize correctly.\");\n    if (guardWord2 != 0x4DED)\n        errln(\"Stack-allocated backing store overwrote guard word!\");\n\n    test->insert(24, \"good \");\n    if (*test != \"Now is the time for all good men to come\")\n        errln(\"insert() on stack-allocated UnicodeString didn't work right\");\n    if (guardWord2 != 0x4DED)\n        errln(\"insert() on stack-allocated UnicodeString overwrote guard word!\");\n\n    if (workingBuffer[24] != 0x67)\n        errln(\"insert() on stack-allocated UnicodeString didn't affect backing store\");\n\n    *test += \" to the aid of their country.\";\n    if (*test != \"Now is the time for all good men to come to the aid of their country.\")\n        errln(\"Stack-allocated UnicodeString overflow didn't work\");\n    if (guardWord2 != 0x4DED)\n        errln(\"Stack-allocated UnicodeString overflow overwrote guard word!\");\n\n    *test = \"ha!\";\n    if (*test != \"ha!\")\n        errln(\"Assignment to stack-allocated UnicodeString didn't work\");\n    if (workingBuffer[0] != 0x4e)\n        errln(\"Change to UnicodeString after overflow are still affecting original buffer\");\n    if (guardWord2 != 0x4DED)\n        errln(\"Change to UnicodeString after overflow overwrote guard word!\");\n\n    // test read-only aliasing with setTo()\n    workingBuffer[0] = 0x20ac;\n    workingBuffer[1] = 0x125;\n    workingBuffer[2] = 0;\n    test->setTo(TRUE, workingBuffer, 2);\n    if(test->length() != 2 || test->charAt(0) != 0x20ac || test->charAt(1) != 0x125) {\n        errln(\"UnicodeString.setTo(readonly alias) does not alias correctly\");\n    }\n\n    UnicodeString *c=test->clone();\n\n    workingBuffer[1] = 0x109;\n    if(test->charAt(1) != 0x109) {\n        errln(\"UnicodeString.setTo(readonly alias) made a copy: did not see change in buffer\");\n    }\n\n    if(c->length() != 2 || c->charAt(1) != 0x125) {\n        errln(\"clone(alias) did not copy the buffer\");\n    }\n    delete c;\n\n    test->setTo(TRUE, workingBuffer, -1);\n    if(test->length() != 2 || test->charAt(0) != 0x20ac || test->charAt(1) != 0x109) {\n        errln(\"UnicodeString.setTo(readonly alias, length -1) does not alias correctly\");\n    }\n\n    test->setTo(FALSE, workingBuffer, -1);\n    if(!test->isBogus()) {\n        errln(\"UnicodeString.setTo(unterminated readonly alias, length -1) does not result in isBogus()\");\n    }\n    \n    delete test;\n     \n    test=new UnicodeString();\n    UChar buffer[]={0x0061, 0x0062, 0x20ac, 0x0043, 0x0042, 0x0000};\n    test->setTo(buffer, 4, 10);\n    if(test->length() !=4 || test->charAt(0) != 0x0061 || test->charAt(1) != 0x0062 ||\n        test->charAt(2) != 0x20ac || test->charAt(3) != 0x0043){\n        errln((UnicodeString)\"UnicodeString.setTo(UChar*, length, capacity) does not work correctly\\n\" + prettify(*test));\n    }\n    delete test;\n\n\n    // test the UChar32 constructor\n    UnicodeString c32Test((UChar32)0x10ff2a);\n    if( c32Test.length() != U16_LENGTH(0x10ff2a) ||\n        c32Test.char32At(c32Test.length() - 1) != 0x10ff2a\n    ) {\n        errln(\"The UnicodeString(UChar32) constructor does not work with a 0x10ff2a filler\");\n    }\n\n    // test the (new) capacity constructor\n    UnicodeString capTest(5, (UChar32)0x2a, 5);\n    if( capTest.length() != 5 * U16_LENGTH(0x2a) ||\n        capTest.char32At(0) != 0x2a ||\n        capTest.char32At(4) != 0x2a\n    ) {\n        errln(\"The UnicodeString capacity constructor does not work with an ASCII filler\");\n    }\n\n    capTest = UnicodeString(5, (UChar32)0x10ff2a, 5);\n    if( capTest.length() != 5 * U16_LENGTH(0x10ff2a) ||\n        capTest.char32At(0) != 0x10ff2a ||\n        capTest.char32At(4) != 0x10ff2a\n    ) {\n        errln(\"The UnicodeString capacity constructor does not work with a 0x10ff2a filler\");\n    }\n\n    capTest = UnicodeString(5, (UChar32)0, 0);\n    if(capTest.length() != 0) {\n        errln(\"The UnicodeString capacity constructor does not work with a 0x10ff2a filler\");\n    }\n}\n\n/**\n * Test the unescape() function.\n */\nvoid UnicodeStringTest::TestUnescape(void) {\n    UnicodeString IN(\"abc\\\\u4567 \\\\n\\\\r \\\\U00101234xyz\\\\x1\\\\x{5289}\\\\x1b\", -1, US_INV);\n    UnicodeString OUT(\"abc\");\n    OUT.append((UChar)0x4567);\n    OUT.append(\" \");\n    OUT.append((UChar)0xA);\n    OUT.append((UChar)0xD);\n    OUT.append(\" \");\n    OUT.append((UChar32)0x00101234);\n    OUT.append(\"xyz\");\n    OUT.append((UChar32)1).append((UChar32)0x5289).append((UChar)0x1b);\n    UnicodeString result = IN.unescape();\n    if (result != OUT) {\n        errln(\"FAIL: \" + prettify(IN) + \".unescape() -> \" +\n              prettify(result) + \", expected \" +\n              prettify(OUT));\n    }\n\n    // test that an empty string is returned in case of an error\n    if (!UNICODE_STRING(\"wrong \\\\u sequence\", 17).unescape().isEmpty()) {\n        errln(\"FAIL: unescaping of a string with an illegal escape sequence did not return an empty string\");\n    }\n}\n\n/* test code point counting functions --------------------------------------- */\n\n/* reference implementation of UnicodeString::hasMoreChar32Than() */\nstatic int32_t\n_refUnicodeStringHasMoreChar32Than(const UnicodeString &s, int32_t start, int32_t length, int32_t number) {\n    int32_t count=s.countChar32(start, length);\n    return count>number;\n}\n\n/* compare the real function against the reference */\nvoid\nUnicodeStringTest::_testUnicodeStringHasMoreChar32Than(const UnicodeString &s, int32_t start, int32_t length, int32_t number) {\n    if(s.hasMoreChar32Than(start, length, number)!=_refUnicodeStringHasMoreChar32Than(s, start, length, number)) {\n        errln(\"hasMoreChar32Than(%d, %d, %d)=%hd is wrong\\n\",\n                start, length, number, s.hasMoreChar32Than(start, length, number));\n    }\n}\n\nvoid\nUnicodeStringTest::TestCountChar32(void) {\n    {\n        UnicodeString s=UNICODE_STRING(\"\\\\U0002f999\\\\U0001d15f\\\\u00c4\\\\u1ed0\", 32).unescape();\n\n        // test countChar32()\n        // note that this also calls and tests u_countChar32(length>=0)\n        if(\n            s.countChar32()!=4 ||\n            s.countChar32(1)!=4 ||\n            s.countChar32(2)!=3 ||\n            s.countChar32(2, 3)!=2 ||\n            s.countChar32(2, 0)!=0\n        ) {\n            errln(\"UnicodeString::countChar32() failed\");\n        }\n\n        // NUL-terminate the string buffer and test u_countChar32(length=-1)\n        const UChar *buffer=s.getTerminatedBuffer();\n        if(\n            u_countChar32(buffer, -1)!=4 ||\n            u_countChar32(buffer+1, -1)!=4 ||\n            u_countChar32(buffer+2, -1)!=3 ||\n            u_countChar32(buffer+3, -1)!=3 ||\n            u_countChar32(buffer+4, -1)!=2 ||\n            u_countChar32(buffer+5, -1)!=1 ||\n            u_countChar32(buffer+6, -1)!=0\n        ) {\n            errln(\"u_countChar32(length=-1) failed\");\n        }\n\n        // test u_countChar32() with bad input\n        if(u_countChar32(NULL, 5)!=0 || u_countChar32(buffer, -2)!=0) {\n            errln(\"u_countChar32(bad input) failed (returned non-zero counts)\");\n        }\n    }\n\n    /* test data and variables for hasMoreChar32Than() */\n    static const UChar str[]={\n        0x61, 0x62, 0xd800, 0xdc00,\n        0xd801, 0xdc01, 0x63, 0xd802,\n        0x64, 0xdc03, 0x65, 0x66,\n        0xd804, 0xdc04, 0xd805, 0xdc05,\n        0x67\n    };\n    UnicodeString string(str, UPRV_LENGTHOF(str));\n    int32_t start, length, number;\n\n    /* test hasMoreChar32Than() */\n    for(length=string.length(); length>=0; --length) {\n        for(start=0; start<=length; ++start) {\n            for(number=-1; number<=((length-start)+2); ++number) {\n                _testUnicodeStringHasMoreChar32Than(string, start, length-start, number);\n            }\n        }\n    }\n\n    /* test hasMoreChar32Than() with pinning */\n    for(start=-1; start<=string.length()+1; ++start) {\n        for(number=-1; number<=((string.length()-start)+2); ++number) {\n            _testUnicodeStringHasMoreChar32Than(string, start, 0x7fffffff, number);\n        }\n    }\n\n    /* test hasMoreChar32Than() with a bogus string */\n    string.setToBogus();\n    for(length=-1; length<=1; ++length) {\n        for(start=-1; start<=length; ++start) {\n            for(number=-1; number<=((length-start)+2); ++number) {\n                _testUnicodeStringHasMoreChar32Than(string, start, length-start, number);\n            }\n        }\n    }\n}\n\nvoid\nUnicodeStringTest::TestBogus() {\n    UnicodeString   test1(\"This is a test\");\n    UnicodeString   test2(\"This is a test\");\n    UnicodeString   test3(\"Me too!\");\n\n    // test isBogus() and setToBogus()\n    if (test1.isBogus() || test2.isBogus() || test3.isBogus()) {\n        errln(\"A string returned TRUE for isBogus()!\");\n    }\n\n    // NULL pointers are treated like empty strings\n    // use other illegal arguments to make a bogus string\n    test3.setTo(FALSE, test1.getBuffer(), -2);\n    if(!test3.isBogus()) {\n        errln(\"A bogus string returned FALSE for isBogus()!\");\n    }\n    if (test1.hashCode() != test2.hashCode() || test1.hashCode() == test3.hashCode()) {\n        errln(\"hashCode() failed\");\n    }\n    if(test3.getBuffer()!=0 || test3.getBuffer(20)!=0 || test3.getTerminatedBuffer()!=0) {\n        errln(\"bogus.getBuffer()!=0\");\n    }\n    if (test1.indexOf(test3) != -1) {\n        errln(\"bogus.indexOf() != -1\");\n    }\n    if (test1.lastIndexOf(test3) != -1) {\n        errln(\"bogus.lastIndexOf() != -1\");\n    }\n    if (test1.caseCompare(test3, U_FOLD_CASE_DEFAULT) != 1 || test3.caseCompare(test1, U_FOLD_CASE_DEFAULT) != -1) {\n        errln(\"caseCompare() doesn't work with bogus strings\");\n    }\n    if (test1.compareCodePointOrder(test3) != 1 || test3.compareCodePointOrder(test1) != -1) {\n        errln(\"compareCodePointOrder() doesn't work with bogus strings\");\n    }\n\n    // verify that non-assignment modifications fail and do not revive a bogus string\n    test3.setToBogus();\n    test3.append((UChar)0x61);\n    if(!test3.isBogus() || test3.getBuffer()!=0) {\n        errln(\"bogus.append('a') worked but must not\");\n    }\n\n    test3.setToBogus();\n    test3.findAndReplace(UnicodeString((UChar)0x61), test2);\n    if(!test3.isBogus() || test3.getBuffer()!=0) {\n        errln(\"bogus.findAndReplace() worked but must not\");\n    }\n\n    test3.setToBogus();\n    test3.trim();\n    if(!test3.isBogus() || test3.getBuffer()!=0) {\n        errln(\"bogus.trim() revived bogus but must not\");\n    }\n\n    test3.setToBogus();\n    test3.remove(1);\n    if(!test3.isBogus() || test3.getBuffer()!=0) {\n        errln(\"bogus.remove(1) revived bogus but must not\");\n    }\n\n    test3.setToBogus();\n    if(!test3.setCharAt(0, 0x62).isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.setCharAt(0, 'b') worked but must not\");\n    }\n\n    test3.setToBogus();\n    if(test3.truncate(1) || !test3.isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.truncate(1) revived bogus but must not\");\n    }\n\n    // verify that assignments revive a bogus string\n    test3.setToBogus();\n    if(!test3.isBogus() || (test3=test1).isBogus() || test3!=test1) {\n        errln(\"bogus.operator=() failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.fastCopyFrom(test1).isBogus() || test3!=test1) {\n        errln(\"bogus.fastCopyFrom() failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(test1).isBogus() || test3!=test1) {\n        errln(\"bogus.setTo(UniStr) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(test1, 0).isBogus() || test3!=test1) {\n        errln(\"bogus.setTo(UniStr, 0) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(test1, 0, 0x7fffffff).isBogus() || test3!=test1) {\n        errln(\"bogus.setTo(UniStr, 0, len) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(test1.getBuffer(), test1.length()).isBogus() || test3!=test1) {\n        errln(\"bogus.setTo(const UChar *, len) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo((UChar)0x2028).isBogus() || test3!=UnicodeString((UChar)0x2028)) {\n        errln(\"bogus.setTo(UChar) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo((UChar32)0x1d157).isBogus() || test3!=UnicodeString((UChar32)0x1d157)) {\n        errln(\"bogus.setTo(UChar32) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(FALSE, test1.getBuffer(), test1.length()).isBogus() || test3!=test1) {\n        errln(\"bogus.setTo(readonly alias) failed\");\n    }\n\n    // writable alias to another string's buffer: very bad idea, just convenient for this test\n    test3.setToBogus();\n    if(!test3.isBogus() ||\n            test3.setTo(const_cast<UChar *>(test1.getBuffer()),\n                        test1.length(), test1.getCapacity()).isBogus() ||\n            test3!=test1) {\n        errln(\"bogus.setTo(writable alias) failed\");\n    }\n\n    // verify simple, documented ways to turn a bogus string into an empty one\n    test3.setToBogus();\n    if(!test3.isBogus() || (test3=UnicodeString()).isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.operator=(UnicodeString()) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(UnicodeString()).isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.setTo(UnicodeString()) failed\");\n    }\n\n    test3.setToBogus();\n    if(test3.remove().isBogus() || test3.getBuffer()==0 || !test3.isEmpty()) {\n        errln(\"bogus.remove() failed\");\n    }\n\n    test3.setToBogus();\n    if(test3.remove(0, INT32_MAX).isBogus() || test3.getBuffer()==0 || !test3.isEmpty()) {\n        errln(\"bogus.remove(0, INT32_MAX) failed\");\n    }\n\n    test3.setToBogus();\n    if(test3.truncate(0) || test3.isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.truncate(0) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo((UChar32)-1).isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.setTo((UChar32)-1) failed\");\n    }\n\n    static const UChar nul=0;\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(&nul, 0).isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.setTo(&nul, 0) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.getBuffer()!=0) {\n        errln(\"setToBogus() failed to make a string bogus\");\n    }\n\n    test3.setToBogus();\n    if(test1.isBogus() || !(test1=test3).isBogus()) {\n        errln(\"normal=bogus failed to make the left string bogus\");\n    }\n\n    // test that NULL primitive input string values are treated like\n    // empty strings, not errors (bogus)\n    test2.setTo((UChar32)0x10005);\n    if(test2.insert(1, nullptr, 1).length()!=2) {\n        errln(\"UniStr.insert(...nullptr...) should not modify the string but does\");\n    }\n\n    UErrorCode errorCode=U_ZERO_ERROR;\n    UnicodeString\n        test4((const UChar *)NULL),\n        test5(TRUE, (const UChar *)NULL, 1),\n        test6((UChar *)NULL, 5, 5),\n        test7((const char *)NULL, 3, NULL, errorCode);\n    if(test4.isBogus() || test5.isBogus() || test6.isBogus() || test7.isBogus()) {\n        errln(\"a constructor set to bogus for a NULL input string, should be empty\");\n    }\n\n    test4.setTo(NULL, 3);\n    test5.setTo(TRUE, (const UChar *)NULL, 1);\n    test6.setTo((UChar *)NULL, 5, 5);\n    if(test4.isBogus() || test5.isBogus() || test6.isBogus()) {\n        errln(\"a setTo() set to bogus for a NULL input string, should be empty\");\n    }\n\n    // test that bogus==bogus<any\n    if(test1!=test3 || test1.compare(test3)!=0) {\n        errln(\"bogus==bogus failed\");\n    }\n\n    test2.remove();\n    if(test1>=test2 || !(test2>test1) || test1.compare(test2)>=0 || !(test2.compare(test1)>0)) {\n        errln(\"bogus<empty failed\");\n    }\n}\n\n// StringEnumeration ------------------------------------------------------- ***\n// most of StringEnumeration is tested elsewhere\n// this test improves code coverage\n\nstatic const char *const\ntestEnumStrings[]={\n    \"a\",\n    \"b\",\n    \"c\",\n    \"this is a long string which helps us test some buffer limits\",\n    \"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\"\n};\n\nclass TestEnumeration : public StringEnumeration {\npublic:\n    TestEnumeration() : i(0) {}\n\n    virtual int32_t count(UErrorCode& /*status*/) const {\n        return UPRV_LENGTHOF(testEnumStrings);\n    }\n\n    virtual const UnicodeString *snext(UErrorCode &status) {\n        if(U_SUCCESS(status) && i<UPRV_LENGTHOF(testEnumStrings)) {\n            unistr=UnicodeString(testEnumStrings[i++], \"\");\n            return &unistr;\n        }\n\n        return NULL;\n    }\n\n    virtual void reset(UErrorCode& /*status*/) {\n        i=0;\n    }\n\n    static inline UClassID getStaticClassID() {\n        return (UClassID)&fgClassID;\n    }\n    virtual UClassID getDynamicClassID() const {\n        return getStaticClassID();\n    }\n\nprivate:\n    static const char fgClassID;\n\n    int32_t i;\n};\n\nconst char TestEnumeration::fgClassID=0;\n\nvoid\nUnicodeStringTest::TestStringEnumeration() {\n    UnicodeString s;\n    TestEnumeration ten;\n    int32_t i, length;\n    UErrorCode status;\n\n    const UChar *pu;\n    const char *pc;\n\n    // test the next() default implementation and ensureCharsCapacity()\n    for(i=0; i<UPRV_LENGTHOF(testEnumStrings); ++i) {\n        status=U_ZERO_ERROR;\n        pc=ten.next(&length, status);\n        s=UnicodeString(testEnumStrings[i], \"\");\n        if(U_FAILURE(status) || pc==NULL || length!=s.length() || UnicodeString(pc, length, \"\")!=s) {\n            errln(\"StringEnumeration.next(%d) failed\", i);\n        }\n    }\n    status=U_ZERO_ERROR;\n    if(ten.next(&length, status)!=NULL) {\n        errln(\"StringEnumeration.next(done)!=NULL\");\n    }\n\n    // test the unext() default implementation\n    ten.reset(status);\n    for(i=0; i<UPRV_LENGTHOF(testEnumStrings); ++i) {\n        status=U_ZERO_ERROR;\n        pu=ten.unext(&length, status);\n        s=UnicodeString(testEnumStrings[i], \"\");\n        if(U_FAILURE(status) || pu==NULL || length!=s.length() || UnicodeString(TRUE, pu, length)!=s) {\n            errln(\"StringEnumeration.unext(%d) failed\", i);\n        }\n    }\n    status=U_ZERO_ERROR;\n    if(ten.unext(&length, status)!=NULL) {\n        errln(\"StringEnumeration.unext(done)!=NULL\");\n    }\n\n    // test that the default clone() implementation works, and returns NULL\n    if(ten.clone()!=NULL) {\n        errln(\"StringEnumeration.clone()!=NULL\");\n    }\n\n    // test that uenum_openFromStringEnumeration() works\n    // Need a heap allocated string enumeration because it is adopted by the UEnumeration.\n    StringEnumeration *newTen = new TestEnumeration;\n    status=U_ZERO_ERROR;\n    UEnumeration *uten = uenum_openFromStringEnumeration(newTen, &status);\n    if (uten==NULL || U_FAILURE(status)) {\n        errln(\"fail at file %s, line %d, UErrorCode is %s\\n\", __FILE__, __LINE__, u_errorName(status));\n        return;\n    }\n    \n    // test  uenum_next()\n    for(i=0; i<UPRV_LENGTHOF(testEnumStrings); ++i) {\n        status=U_ZERO_ERROR;\n        pc=uenum_next(uten, &length, &status);\n        if(U_FAILURE(status) || pc==NULL || strcmp(pc, testEnumStrings[i]) != 0) {\n            errln(\"File %s, line %d, StringEnumeration.next(%d) failed\", __FILE__, __LINE__, i);\n        }\n    }\n    status=U_ZERO_ERROR;\n    if(uenum_next(uten, &length, &status)!=NULL) {\n        errln(\"File %s, line %d, uenum_next(done)!=NULL\");\n    }\n\n    // test the uenum_unext()\n    uenum_reset(uten, &status);\n    for(i=0; i<UPRV_LENGTHOF(testEnumStrings); ++i) {\n        status=U_ZERO_ERROR;\n        pu=uenum_unext(uten, &length, &status);\n        s=UnicodeString(testEnumStrings[i], \"\");\n        if(U_FAILURE(status) || pu==NULL || length!=s.length() || UnicodeString(TRUE, pu, length)!=s) {\n            errln(\"File %s, Line %d, uenum_unext(%d) failed\", __FILE__, __LINE__, i);\n        }\n    }\n    status=U_ZERO_ERROR;\n    if(uenum_unext(uten, &length, &status)!=NULL) {\n        errln(\"File %s, Line %d, uenum_unext(done)!=NULL\" __FILE__, __LINE__);\n    }\n\n    uenum_close(uten);\n}\n\n/*\n * Namespace test, to make sure that macros like UNICODE_STRING include the\n * namespace qualifier.\n *\n * Define a (bogus) UnicodeString class in another namespace and check for ambiguity.\n */\nnamespace bogus {\n    class UnicodeString {\n    public:\n        enum EInvariant { kInvariant };\n        UnicodeString() : i(1) {}\n        UnicodeString(UBool /*isTerminated*/, const UChar * /*text*/, int32_t textLength) : i(textLength) {(void)i;}\n        UnicodeString(const char * /*src*/, int32_t length, enum EInvariant /*inv*/\n) : i(length) {}\n    private:\n        int32_t i;\n    };\n}\n\nvoid\nUnicodeStringTest::TestNameSpace() {\n    // Provoke name collision unless the UnicodeString macros properly\n    // qualify the icu::UnicodeString class.\n    using namespace bogus;\n\n    // Use all UnicodeString macros from unistr.h.\n    icu::UnicodeString s1=icu::UnicodeString(\"abc\", 3, US_INV);\n    icu::UnicodeString s2=UNICODE_STRING(\"def\", 3);\n    icu::UnicodeString s3=UNICODE_STRING_SIMPLE(\"ghi\");\n\n    // Make sure the compiler does not optimize away instantiation of s1, s2, s3.\n    icu::UnicodeString s4=s1+s2+s3;\n    if(s4.length()!=9) {\n        errln(\"Something wrong with UnicodeString::operator+().\");\n    }\n}\n\nvoid\nUnicodeStringTest::TestUTF32() {\n    // Input string length US_STACKBUF_SIZE to cause overflow of the\n    // initially chosen fStackBuffer due to supplementary characters.\n    static const UChar32 utf32[] = {\n        0x41, 0xd900, 0x61, 0xdc00, -1, 0x110000, 0x5a, 0x50000, 0x7a,\n        0x10000, 0x20000, 0xe0000, 0x10ffff\n    };\n    static const UChar expected_utf16[] = {\n        0x41, 0xfffd, 0x61, 0xfffd, 0xfffd, 0xfffd, 0x5a, 0xd900, 0xdc00, 0x7a,\n        0xd800, 0xdc00, 0xd840, 0xdc00, 0xdb40, 0xdc00, 0xdbff, 0xdfff\n    };\n    UnicodeString from32 = UnicodeString::fromUTF32(utf32, UPRV_LENGTHOF(utf32));\n    UnicodeString expected(FALSE, expected_utf16, UPRV_LENGTHOF(expected_utf16));\n    if(from32 != expected) {\n        errln(\"UnicodeString::fromUTF32() did not create the expected string.\");\n    }\n\n    static const UChar utf16[] = {\n        0x41, 0xd900, 0x61, 0xdc00, 0x5a, 0xd900, 0xdc00, 0x7a, 0xd800, 0xdc00, 0xdbff, 0xdfff\n    };\n    static const UChar32 expected_utf32[] = {\n        0x41, 0xfffd, 0x61, 0xfffd, 0x5a, 0x50000, 0x7a, 0x10000, 0x10ffff\n    };\n    UChar32 result32[16];\n    UErrorCode errorCode = U_ZERO_ERROR;\n    int32_t length32 =\n        UnicodeString(FALSE, utf16, UPRV_LENGTHOF(utf16)).\n        toUTF32(result32, UPRV_LENGTHOF(result32), errorCode);\n    if( length32 != UPRV_LENGTHOF(expected_utf32) ||\n        0 != uprv_memcmp(result32, expected_utf32, length32*4) ||\n        result32[length32] != 0\n    ) {\n        errln(\"UnicodeString::toUTF32() did not create the expected string.\");\n    }\n}\n\nclass TestCheckedArrayByteSink : public CheckedArrayByteSink {\npublic:\n    TestCheckedArrayByteSink(char* outbuf, int32_t capacity)\n            : CheckedArrayByteSink(outbuf, capacity), calledFlush(FALSE) {}\n    virtual void Flush() { calledFlush = TRUE; }\n    UBool calledFlush;\n};\n\nvoid\nUnicodeStringTest::TestUTF8() {\n    static const uint8_t utf8[] = {\n        // Code points:\n        // 0x41, 0xd900,\n        // 0x61, 0xdc00,\n        // 0x110000, 0x5a,\n        // 0x50000, 0x7a,\n        // 0x10000, 0x20000,\n        // 0xe0000, 0x10ffff\n        0x41, 0xed, 0xa4, 0x80,\n        0x61, 0xed, 0xb0, 0x80,\n        0xf4, 0x90, 0x80, 0x80, 0x5a,\n        0xf1, 0x90, 0x80, 0x80, 0x7a,\n        0xf0, 0x90, 0x80, 0x80, 0xf0, 0xa0, 0x80, 0x80,\n        0xf3, 0xa0, 0x80, 0x80, 0xf4, 0x8f, 0xbf, 0xbf\n    };\n    static const UChar expected_utf16[] = {\n        0x41, 0xfffd, 0xfffd, 0xfffd,\n        0x61, 0xfffd, 0xfffd, 0xfffd,\n        0xfffd,  0xfffd, 0xfffd, 0xfffd,0x5a,\n        0xd900, 0xdc00, 0x7a,\n        0xd800, 0xdc00, 0xd840, 0xdc00,\n        0xdb40, 0xdc00, 0xdbff, 0xdfff\n    };\n    UnicodeString from8 = UnicodeString::fromUTF8(StringPiece((const char *)utf8, (int32_t)sizeof(utf8)));\n    UnicodeString expected(FALSE, expected_utf16, UPRV_LENGTHOF(expected_utf16));\n\n    if(from8 != expected) {\n        errln(\"UnicodeString::fromUTF8(StringPiece) did not create the expected string.\");\n    }\n    std::string utf8_string((const char *)utf8, sizeof(utf8));\n    UnicodeString from8b = UnicodeString::fromUTF8(utf8_string);\n    if(from8b != expected) {\n        errln(\"UnicodeString::fromUTF8(std::string) did not create the expected string.\");\n    }\n\n    static const UChar utf16[] = {\n        0x41, 0xd900, 0x61, 0xdc00, 0x5a, 0xd900, 0xdc00, 0x7a, 0xd800, 0xdc00, 0xdbff, 0xdfff\n    };\n    static const uint8_t expected_utf8[] = {\n        0x41, 0xef, 0xbf, 0xbd, 0x61, 0xef, 0xbf, 0xbd, 0x5a, 0xf1, 0x90, 0x80, 0x80, 0x7a,\n        0xf0, 0x90, 0x80, 0x80, 0xf4, 0x8f, 0xbf, 0xbf\n    };\n    UnicodeString us(FALSE, utf16, UPRV_LENGTHOF(utf16));\n\n    char buffer[64];\n    TestCheckedArrayByteSink sink(buffer, (int32_t)sizeof(buffer));\n    us.toUTF8(sink);\n    if( sink.NumberOfBytesWritten() != (int32_t)sizeof(expected_utf8) ||\n        0 != uprv_memcmp(buffer, expected_utf8, sizeof(expected_utf8))\n    ) {\n        errln(\"UnicodeString::toUTF8() did not create the expected string.\");\n    }\n    if(!sink.calledFlush) {\n        errln(\"UnicodeString::toUTF8(sink) did not sink.Flush().\");\n    }\n    // Initial contents for testing that toUTF8String() appends.\n    std::string result8 = \"-->\";\n    std::string expected8 = \"-->\" + std::string((const char *)expected_utf8, sizeof(expected_utf8));\n    // Use the return value just for testing.\n    std::string &result8r = us.toUTF8String(result8);\n    if(result8r != expected8 || &result8r != &result8) {\n        errln(\"UnicodeString::toUTF8String() did not create the expected string.\");\n    }\n}\n\n// Test if this compiler supports Return Value Optimization of unnamed temporary objects.\nstatic UnicodeString wrapUChars(const UChar *uchars) {\n    return UnicodeString(TRUE, uchars, -1);\n}\n\nvoid\nUnicodeStringTest::TestReadOnlyAlias() {\n    UChar uchars[]={ 0x61, 0x62, 0 };\n    UnicodeString alias(TRUE, uchars, 2);\n    if(alias.length()!=2 || alias.getBuffer()!=uchars || alias.getTerminatedBuffer()!=uchars) {\n        errln(\"UnicodeString read-only-aliasing constructor does not behave as expected.\");\n        return;\n    }\n    alias.truncate(1);\n    if(alias.length()!=1 || alias.getBuffer()!=uchars) {\n        errln(\"UnicodeString(read-only-alias).truncate() did not preserve aliasing as expected.\");\n    }\n    if(alias.getTerminatedBuffer()==uchars) {\n        errln(\"UnicodeString(read-only-alias).truncate().getTerminatedBuffer() \"\n              \"did not allocate and copy as expected.\");\n    }\n    if(uchars[1]!=0x62) {\n        errln(\"UnicodeString(read-only-alias).truncate().getTerminatedBuffer() \"\n              \"modified the original buffer.\");\n    }\n    if(1!=u_strlen(alias.getTerminatedBuffer())) {\n        errln(\"UnicodeString(read-only-alias).truncate().getTerminatedBuffer() \"\n              \"does not return a buffer terminated at the proper length.\");\n    }\n\n    alias.setTo(TRUE, uchars, 2);\n    if(alias.length()!=2 || alias.getBuffer()!=uchars || alias.getTerminatedBuffer()!=uchars) {\n        errln(\"UnicodeString read-only-aliasing setTo() does not behave as expected.\");\n        return;\n    }\n    alias.remove();\n    if(alias.length()!=0) {\n        errln(\"UnicodeString(read-only-alias).remove() did not work.\");\n    }\n    if(alias.getTerminatedBuffer()==uchars) {\n        errln(\"UnicodeString(read-only-alias).remove().getTerminatedBuffer() \"\n              \"did not un-alias as expected.\");\n    }\n    if(uchars[0]!=0x61) {\n        errln(\"UnicodeString(read-only-alias).remove().getTerminatedBuffer() \"\n              \"modified the original buffer.\");\n    }\n    if(0!=u_strlen(alias.getTerminatedBuffer())) {\n        errln(\"UnicodeString.setTo(read-only-alias).remove().getTerminatedBuffer() \"\n              \"does not return a buffer terminated at length 0.\");\n    }\n\n    UnicodeString longString=UNICODE_STRING_SIMPLE(\"abcdefghijklmnopqrstuvwxyz0123456789\");\n    alias.setTo(FALSE, longString.getBuffer(), longString.length());\n    alias.remove(0, 10);\n    if(longString.compare(10, INT32_MAX, alias)!=0 || alias.getBuffer()!=longString.getBuffer()+10) {\n        errln(\"UnicodeString.setTo(read-only-alias).remove(0, 10) did not preserve aliasing as expected.\");\n    }\n    alias.setTo(FALSE, longString.getBuffer(), longString.length());\n    alias.remove(27, 99);\n    if(longString.compare(0, 27, alias)!=0 || alias.getBuffer()!=longString.getBuffer()) {\n        errln(\"UnicodeString.setTo(read-only-alias).remove(27, 99) did not preserve aliasing as expected.\");\n    }\n    alias.setTo(FALSE, longString.getBuffer(), longString.length());\n    alias.retainBetween(6, 30);\n    if(longString.compare(6, 24, alias)!=0 || alias.getBuffer()!=longString.getBuffer()+6) {\n        errln(\"UnicodeString.setTo(read-only-alias).retainBetween(6, 30) did not preserve aliasing as expected.\");\n    }\n\n    UChar abc[]={ 0x61, 0x62, 0x63, 0 };\n    UBool hasRVO= wrapUChars(abc).getBuffer()==abc;\n\n    UnicodeString temp;\n    temp.fastCopyFrom(longString.tempSubString());\n    if(temp!=longString || (hasRVO && temp.getBuffer()!=longString.getBuffer())) {\n        errln(\"UnicodeString.tempSubString() failed\");\n    }\n    temp.fastCopyFrom(longString.tempSubString(-3, 5));\n    if(longString.compare(0, 5, temp)!=0 || (hasRVO && temp.getBuffer()!=longString.getBuffer())) {\n        errln(\"UnicodeString.tempSubString(-3, 5) failed\");\n    }\n    temp.fastCopyFrom(longString.tempSubString(17));\n    if(longString.compare(17, INT32_MAX, temp)!=0 || (hasRVO && temp.getBuffer()!=longString.getBuffer()+17)) {\n        errln(\"UnicodeString.tempSubString(17) failed\");\n    }\n    temp.fastCopyFrom(longString.tempSubString(99));\n    if(!temp.isEmpty()) {\n        errln(\"UnicodeString.tempSubString(99) failed\");\n    }\n    temp.fastCopyFrom(longString.tempSubStringBetween(6));\n    if(longString.compare(6, INT32_MAX, temp)!=0 || (hasRVO && temp.getBuffer()!=longString.getBuffer()+6)) {\n        errln(\"UnicodeString.tempSubStringBetween(6) failed\");\n    }\n    temp.fastCopyFrom(longString.tempSubStringBetween(8, 18));\n    if(longString.compare(8, 10, temp)!=0 || (hasRVO && temp.getBuffer()!=longString.getBuffer()+8)) {\n        errln(\"UnicodeString.tempSubStringBetween(8, 18) failed\");\n    }\n    UnicodeString bogusString;\n    bogusString.setToBogus();\n    temp.fastCopyFrom(bogusString.tempSubStringBetween(8, 18));\n    if(!temp.isBogus()) {\n        errln(\"UnicodeString.setToBogus().tempSubStringBetween(8, 18) failed\");\n    }\n}\n\nvoid\nUnicodeStringTest::doTestAppendable(UnicodeString &dest, Appendable &app) {\n    static const UChar cde[3]={ 0x63, 0x64, 0x65 };\n    static const UChar fg[3]={ 0x66, 0x67, 0 };\n    if(!app.reserveAppendCapacity(12)) {\n        errln(\"Appendable.reserve(12) failed\");\n    }\n    app.appendCodeUnit(0x61);\n    app.appendCodePoint(0x62);\n    app.appendCodePoint(0x50000);\n    app.appendString(cde, 3);\n    app.appendString(fg, -1);\n    UChar scratch[3];\n    int32_t capacity=-1;\n    UChar *buffer=app.getAppendBuffer(3, 3, scratch, 3, &capacity);\n    if(capacity<3) {\n        errln(\"Appendable.getAppendBuffer(min=3) returned capacity=%d<3\", (int)capacity);\n        return;\n    }\n    static const UChar hij[3]={ 0x68, 0x69, 0x6a };\n    u_memcpy(buffer, hij, 3);\n    app.appendString(buffer, 3);\n    if(dest!=UNICODE_STRING_SIMPLE(\"ab\\\\U00050000cdefghij\").unescape()) {\n        errln(\"Appendable.append(...) failed\");\n    }\n    buffer=app.getAppendBuffer(0, 3, scratch, 3, &capacity);\n    if(buffer!=NULL || capacity!=0) {\n        errln(\"Appendable.getAppendBuffer(min=0) failed\");\n    }\n    capacity=1;\n    buffer=app.getAppendBuffer(3, 3, scratch, 2, &capacity);\n    if(buffer!=NULL || capacity!=0) {\n        errln(\"Appendable.getAppendBuffer(scratch<min) failed\");\n    }\n}\n\nclass SimpleAppendable : public Appendable {\npublic:\n    explicit SimpleAppendable(UnicodeString &dest) : str(dest) {}\n    virtual UBool appendCodeUnit(UChar c) { str.append(c); return TRUE; }\n    SimpleAppendable &reset() { str.remove(); return *this; }\nprivate:\n    UnicodeString &str;\n};\n\nvoid\nUnicodeStringTest::TestAppendable() {\n    UnicodeString dest;\n    SimpleAppendable app(dest);\n    doTestAppendable(dest, app);\n}\n\nvoid\nUnicodeStringTest::TestUnicodeStringImplementsAppendable() {\n    UnicodeString dest;\n    UnicodeStringAppendable app(dest);\n    doTestAppendable(dest, app);\n}\n\nvoid\nUnicodeStringTest::TestSizeofUnicodeString() {\n    // See the comments in unistr.h near the declaration of UnicodeString's fields.\n    // See the API comments for UNISTR_OBJECT_SIZE.\n    size_t sizeofUniStr=sizeof(UnicodeString);\n    size_t expected=UNISTR_OBJECT_SIZE;\n    if(expected!=sizeofUniStr) {\n        // Possible cause: UNISTR_OBJECT_SIZE may not be a multiple of sizeof(pointer),\n        // of the compiler might add more internal padding than expected.\n        errln(\"sizeof(UnicodeString)=%d, expected UNISTR_OBJECT_SIZE=%d\",\n              (int)sizeofUniStr, (int)expected);\n    }\n    if(sizeofUniStr<32) {\n        errln(\"sizeof(UnicodeString)=%d < 32, probably too small\", (int)sizeofUniStr);\n    }\n    // We assume that the entire UnicodeString object,\n    // minus the vtable pointer and 2 bytes for flags and short length,\n    // is available for internal storage of UChars.\n    int32_t expectedStackBufferLength=((int32_t)UNISTR_OBJECT_SIZE-sizeof(void *)-2)/U_SIZEOF_UCHAR;\n    UnicodeString s;\n    const UChar *emptyBuffer=s.getBuffer();\n    for(int32_t i=0; i<expectedStackBufferLength; ++i) {\n        s.append((UChar)0x2e);\n    }\n    const UChar *fullBuffer=s.getBuffer();\n    if(fullBuffer!=emptyBuffer) {\n        errln(\"unexpected reallocation when filling with assumed stack buffer size of %d\",\n              expectedStackBufferLength);\n    }\n    const UChar *terminatedBuffer=s.getTerminatedBuffer();\n    if(terminatedBuffer==emptyBuffer) {\n        errln(\"unexpected keeping stack buffer when overfilling assumed stack buffer size of %d\",\n              expectedStackBufferLength);\n    }\n}\n\n// Try to avoid clang -Wself-move warnings from s1 = std::move(s1);\nvoid moveFrom(UnicodeString &dest, UnicodeString &src) {\n    dest = std::move(src);\n}\n\nvoid\nUnicodeStringTest::TestMoveSwap() {\n    static const UChar abc[3] = { 0x61, 0x62, 0x63 };  // \"abc\"\n    UnicodeString s1(FALSE, abc, UPRV_LENGTHOF(abc));  // read-only alias\n    UnicodeString s2(100, 0x7a, 100);  // 100 * 'z' should be on the heap\n    UnicodeString s3(\"defg\", 4, US_INV);  // in stack buffer\n    const UChar *p = s2.getBuffer();\n    s1.swap(s2);\n    if(s1.getBuffer() != p || s1.length() != 100 || s2.getBuffer() != abc || s2.length() != 3) {\n        errln(\"UnicodeString.swap() did not swap\");\n    }\n    swap(s2, s3);\n    if(s2 != UNICODE_STRING_SIMPLE(\"defg\") || s3.getBuffer() != abc || s3.length() != 3) {\n        errln(\"swap(UnicodeString) did not swap back\");\n    }\n    UnicodeString s4;\n    s4 = std::move(s1);\n    if(s4.getBuffer() != p || s4.length() != 100 || !s1.isBogus()) {\n        errln(\"UnicodeString = std::move(heap) did not move\");\n    }\n    UnicodeString s5;\n    s5 = std::move(s2);\n    if(s5 != UNICODE_STRING_SIMPLE(\"defg\")) {\n        errln(\"UnicodeString = std::move(stack) did not move\");\n    }\n    UnicodeString s6;\n    s6 = std::move(s3);\n    if(s6.getBuffer() != abc || s6.length() != 3) {\n        errln(\"UnicodeString = std::move(alias) did not move\");\n    }\n    infoln(\"TestMoveSwap() with rvalue references\");\n    s1 = static_cast<UnicodeString &&>(s6);\n    if(s1.getBuffer() != abc || s1.length() != 3) {\n        errln(\"UnicodeString move assignment operator did not move\");\n    }\n    UnicodeString s7(static_cast<UnicodeString &&>(s4));\n    if(s7.getBuffer() != p || s7.length() != 100 || !s4.isBogus()) {\n        errln(\"UnicodeString move constructor did not move\");\n    }\n\n    // Move self assignment leaves the object valid but in an undefined state.\n    // Do it to make sure there is no crash,\n    // but do not check for any particular resulting value.\n    moveFrom(s1, s1);\n    moveFrom(s2, s2);\n    moveFrom(s3, s3);\n    moveFrom(s4, s4);\n    moveFrom(s5, s5);\n    moveFrom(s6, s6);\n    moveFrom(s7, s7);\n    // Simple copy assignment must work.\n    UnicodeString simple = UNICODE_STRING_SIMPLE(\"simple\");\n    s1 = s6 = s4 = s7 = simple;\n    if(s1 != simple || s4 != simple || s6 != simple || s7 != simple) {\n        errln(\"UnicodeString copy after self-move did not work\");\n    }\n}\n\nvoid\nUnicodeStringTest::TestUInt16Pointers() {\n    static const uint16_t carr[] = { 0x61, 0x62, 0x63, 0 };\n    uint16_t arr[4];\n\n    UnicodeString expected(u\"abc\");\n    assertEquals(\"abc from pointer\", expected, UnicodeString(carr));\n    assertEquals(\"abc from pointer+length\", expected, UnicodeString(carr, 3));\n    assertEquals(\"abc from read-only-alias pointer\", expected, UnicodeString(TRUE, carr, 3));\n\n    UnicodeString alias(arr, 0, 4);\n    alias.append(u'a').append(u'b').append(u'c');\n    assertEquals(\"abc from writable alias\", expected, alias);\n    assertEquals(\"buffer=abc from writable alias\", expected, UnicodeString(arr, 3));\n\n    UErrorCode errorCode = U_ZERO_ERROR;\n    int32_t length = UnicodeString(u\"def\").extract(arr, 4, errorCode);\n    assertSuccess(WHERE, errorCode);\n    assertEquals(\"def from extract()\", UnicodeString(u\"def\"), UnicodeString(arr, length));\n}\n\nvoid\nUnicodeStringTest::TestWCharPointers() {\n#if U_SIZEOF_WCHAR_T==2\n    static const wchar_t carr[] = { 0x61, 0x62, 0x63, 0 };\n    wchar_t arr[4];\n\n    UnicodeString expected(u\"abc\");\n    assertEquals(\"abc from pointer\", expected, UnicodeString(carr));\n    assertEquals(\"abc from pointer+length\", expected, UnicodeString(carr, 3));\n    assertEquals(\"abc from read-only-alias pointer\", expected, UnicodeString(TRUE, carr, 3));\n\n    UnicodeString alias(arr, 0, 4);\n    alias.append(u'a').append(u'b').append(u'c');\n    assertEquals(\"abc from writable alias\", expected, alias);\n    assertEquals(\"buffer=abc from writable alias\", expected, UnicodeString(arr, 3));\n\n    UErrorCode errorCode = U_ZERO_ERROR;\n    int32_t length = UnicodeString(u\"def\").extract(arr, 4, errorCode);\n    assertSuccess(WHERE, errorCode);\n    assertEquals(\"def from extract()\", UnicodeString(u\"def\"), UnicodeString(arr, length));\n#endif\n}\n\nvoid\nUnicodeStringTest::TestNullPointers() {\n    assertTrue(\"empty from nullptr\", UnicodeString(nullptr).isEmpty());\n    assertTrue(\"empty from nullptr+length\", UnicodeString(nullptr, 2).isEmpty());\n    assertTrue(\"empty from read-only-alias nullptr\", UnicodeString(TRUE, nullptr, 3).isEmpty());\n\n    UnicodeString alias(nullptr, 4, 4);  // empty, no alias\n    assertTrue(\"empty from writable alias\", alias.isEmpty());\n    alias.append(u'a').append(u'b').append(u'c');\n    UnicodeString expected(u\"abc\");\n    assertEquals(\"abc from writable alias\", expected, alias);\n\n    UErrorCode errorCode = U_ZERO_ERROR;\n    UnicodeString(u\"def\").extract(nullptr, 0, errorCode);\n    assertEquals(\"buffer overflow extracting to nullptr\", U_BUFFER_OVERFLOW_ERROR, errorCode);\n}\n\nvoid UnicodeStringTest::TestUnicodeStringInsertAppendToSelf() {\n    IcuTestErrorCode status(*this, \"TestUnicodeStringAppendToSelf\");\n\n    // Test append operation\n    UnicodeString str(u\"foo \");\n    str.append(str);\n    str.append(str);\n    str.append(str);\n    assertEquals(\"\", u\"foo foo foo foo foo foo foo foo \", str);\n\n    // Test append operation with readonly alias to start\n    str = UnicodeString(TRUE, u\"foo \", 4);\n    str.append(str);\n    str.append(str);\n    str.append(str);\n    assertEquals(\"\", u\"foo foo foo foo foo foo foo foo \", str);\n\n    // Test append operation with aliased substring\n    str = u\"abcde\";\n    UnicodeString sub = str.tempSubString(1, 2);\n    str.append(sub);\n    assertEquals(\"\", u\"abcdebc\", str);\n\n    // Test append operation with double-aliased substring\n    str = UnicodeString(TRUE, u\"abcde\", 5);\n    sub = str.tempSubString(1, 2);\n    str.append(sub);\n    assertEquals(\"\", u\"abcdebc\", str);\n\n    // Test insert operation\n    str = u\"a-*b\";\n    str.insert(2, str);\n    str.insert(4, str);\n    str.insert(8, str);\n    assertEquals(\"\", u\"a-a-a-a-a-a-a-a-*b*b*b*b*b*b*b*b\", str);\n\n    // Test insert operation with readonly alias to start\n    str = UnicodeString(TRUE, u\"a-*b\", 4);\n    str.insert(2, str);\n    str.insert(4, str);\n    str.insert(8, str);\n    assertEquals(\"\", u\"a-a-a-a-a-a-a-a-*b*b*b*b*b*b*b*b\", str);\n\n    // Test insert operation with aliased substring\n    str = u\"abcde\";\n    sub = str.tempSubString(1, 3);\n    str.insert(2, sub);\n    assertEquals(\"\", u\"abbcdcde\", str);\n\n    // Test insert operation with double-aliased substring\n    str = UnicodeString(TRUE, u\"abcde\", 5);\n    sub = str.tempSubString(1, 3);\n    str.insert(2, sub);\n    assertEquals(\"\", u\"abbcdcde\", str);\n}\n", "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/********************************************************************\n * COPYRIGHT: \n * Copyright (c) 1997-2015, International Business Machines Corporation and\n * others. All Rights Reserved.\n ********************************************************************/\n\n#ifndef UNICODESTRINGTEST_H\n#define UNICODESTRINGTEST_H\n\n#include \"unicode/locid.h\"\n#include \"unicode/unistr.h\"\n#include \"intltest.h\"\n\nU_NAMESPACE_BEGIN\n\nclass Appendable;\n\nU_NAMESPACE_END\n\n/**\n * Perform API and functionality tests for class UnicodeString\n **/\nclass UnicodeStringTest: public IntlTest {\npublic:\n    UnicodeStringTest() {}\n    virtual ~UnicodeStringTest();\n    \n    void runIndexedTest( int32_t index, UBool exec, const char* &name, char* par = NULL );\n\n    /**\n     * Test some basic methods (insert, remove, replace, ...)\n     **/\n    void TestBasicManipulation(void);\n    /**\n     * Test the methods for comparison\n     **/\n    void TestCompare(void);\n    /**\n     * Test the methods for extracting\n     **/\n    void TestExtract(void);\n    /**\n     * More extensively test methods for removing and replacing\n     **/\n    void TestRemoveReplace(void);\n    /**\n     * Test language specific case conversions\n     **/\n    void TestSearching(void);\n    /**\n     * Test methods for padding, trimmimg and truncating\n     **/\n    void TestSpacePadding(void);\n    /**\n     * Test methods startsWith and endsWith\n     **/\n    void TestPrefixAndSuffix(void);\n    void TestStartsWithAndEndsWithNulTerminated();\n    /**\n     * Test method findAndReplace\n     **/\n    void TestFindAndReplace(void);\n    /**\n     * Test method reverse\n     **/\n    void TestReverse(void);\n    /**\n     * Test a few miscellaneous methods (isBogus, hashCode,...)\n     **/\n    void TestMiscellaneous(void);\n    /**\n     * Test the functionality of allocating UnicodeStrings on the stack\n     **/\n    void TestStackAllocation(void);\n    /**\n     * Test the unescape() function.\n     */\n    void TestUnescape(void);\n\n    void _testUnicodeStringHasMoreChar32Than(const UnicodeString &s, int32_t start, int32_t length, int32_t number);\n    void TestCountChar32();\n    void TestBogus();\n    void TestStringEnumeration();\n    void TestNameSpace();\n    void TestUTF32();\n    void TestUTF8();\n    void TestReadOnlyAlias();\n    void doTestAppendable(UnicodeString &dest, Appendable &app);\n    void TestAppendable();\n    void TestUnicodeStringImplementsAppendable();\n    void TestSizeofUnicodeString();\n    void TestMoveSwap();\n\n    void TestUInt16Pointers();\n    void TestWCharPointers();\n    void TestNullPointers();\n    void TestUnicodeStringInsertAppendToSelf();\n};\n\n#endif\n"], "fixing_code": ["// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/*\n******************************************************************************\n* Copyright (C) 1999-2016, International Business Machines Corporation and\n* others. All Rights Reserved.\n******************************************************************************\n*\n* File unistr.cpp\n*\n* Modification History:\n*\n*   Date        Name        Description\n*   09/25/98    stephen     Creation.\n*   04/20/99    stephen     Overhauled per 4/16 code review.\n*   07/09/99    stephen     Renamed {hi,lo},{byte,word} to icu_X for HP/UX\n*   11/18/99    aliu        Added handleReplaceBetween() to make inherit from\n*                           Replaceable.\n*   06/25/01    grhoten     Removed the dependency on iostream\n******************************************************************************\n*/\n\n#include \"unicode/utypes.h\"\n#include \"unicode/appendable.h\"\n#include \"unicode/putil.h\"\n#include \"cstring.h\"\n#include \"cmemory.h\"\n#include \"unicode/ustring.h\"\n#include \"unicode/unistr.h\"\n#include \"unicode/utf.h\"\n#include \"unicode/utf16.h\"\n#include \"uelement.h\"\n#include \"ustr_imp.h\"\n#include \"umutex.h\"\n#include \"uassert.h\"\n\n#if 0\n\n#include <iostream>\nusing namespace std;\n\n//DEBUGGING\nvoid\nprint(const UnicodeString& s,\n      const char *name)\n{\n  UChar c;\n  cout << name << \":|\";\n  for(int i = 0; i < s.length(); ++i) {\n    c = s[i];\n    if(c>= 0x007E || c < 0x0020)\n      cout << \"[0x\" << hex << s[i] << \"]\";\n    else\n      cout << (char) s[i];\n  }\n  cout << '|' << endl;\n}\n\nvoid\nprint(const UChar *s,\n      int32_t len,\n      const char *name)\n{\n  UChar c;\n  cout << name << \":|\";\n  for(int i = 0; i < len; ++i) {\n    c = s[i];\n    if(c>= 0x007E || c < 0x0020)\n      cout << \"[0x\" << hex << s[i] << \"]\";\n    else\n      cout << (char) s[i];\n  }\n  cout << '|' << endl;\n}\n// END DEBUGGING\n#endif\n\n// Local function definitions for now\n\n// need to copy areas that may overlap\nstatic\ninline void\nus_arrayCopy(const UChar *src, int32_t srcStart,\n         UChar *dst, int32_t dstStart, int32_t count)\n{\n  if(count>0) {\n    uprv_memmove(dst+dstStart, src+srcStart, (size_t)count*sizeof(*src));\n  }\n}\n\n// u_unescapeAt() callback to get a UChar from a UnicodeString\nU_CDECL_BEGIN\nstatic UChar U_CALLCONV\nUnicodeString_charAt(int32_t offset, void *context) {\n    return ((icu::UnicodeString*) context)->charAt(offset);\n}\nU_CDECL_END\n\nU_NAMESPACE_BEGIN\n\n/* The Replaceable virtual destructor can't be defined in the header\n   due to how AIX works with multiple definitions of virtual functions.\n*/\nReplaceable::~Replaceable() {}\n\nUOBJECT_DEFINE_RTTI_IMPLEMENTATION(UnicodeString)\n\nUnicodeString U_EXPORT2\noperator+ (const UnicodeString &s1, const UnicodeString &s2) {\n    return\n        UnicodeString(s1.length()+s2.length()+1, (UChar32)0, 0).\n            append(s1).\n                append(s2);\n}\n\n//========================================\n// Reference Counting functions, put at top of file so that optimizing compilers\n//                               have a chance to automatically inline.\n//========================================\n\nvoid\nUnicodeString::addRef() {\n  umtx_atomic_inc((u_atomic_int32_t *)fUnion.fFields.fArray - 1);\n}\n\nint32_t\nUnicodeString::removeRef() {\n  return umtx_atomic_dec((u_atomic_int32_t *)fUnion.fFields.fArray - 1);\n}\n\nint32_t\nUnicodeString::refCount() const {\n  return umtx_loadAcquire(*((u_atomic_int32_t *)fUnion.fFields.fArray - 1));\n}\n\nvoid\nUnicodeString::releaseArray() {\n  if((fUnion.fFields.fLengthAndFlags & kRefCounted) && removeRef() == 0) {\n    uprv_free((int32_t *)fUnion.fFields.fArray - 1);\n  }\n}\n\n\n\n//========================================\n// Constructors\n//========================================\n\n// The default constructor is inline in unistr.h.\n\nUnicodeString::UnicodeString(int32_t capacity, UChar32 c, int32_t count) {\n  fUnion.fFields.fLengthAndFlags = 0;\n  if(count <= 0 || (uint32_t)c > 0x10ffff) {\n    // just allocate and do not do anything else\n    allocate(capacity);\n  } else if(c <= 0xffff) {\n    int32_t length = count;\n    if(capacity < length) {\n      capacity = length;\n    }\n    if(allocate(capacity)) {\n      UChar *array = getArrayStart();\n      UChar unit = (UChar)c;\n      for(int32_t i = 0; i < length; ++i) {\n        array[i] = unit;\n      }\n      setLength(length);\n    }\n  } else {  // supplementary code point, write surrogate pairs\n    if(count > (INT32_MAX / 2)) {\n      // We would get more than 2G UChars.\n      allocate(capacity);\n      return;\n    }\n    int32_t length = count * 2;\n    if(capacity < length) {\n      capacity = length;\n    }\n    if(allocate(capacity)) {\n      UChar *array = getArrayStart();\n      UChar lead = U16_LEAD(c);\n      UChar trail = U16_TRAIL(c);\n      for(int32_t i = 0; i < length; i += 2) {\n        array[i] = lead;\n        array[i + 1] = trail;\n      }\n      setLength(length);\n    }\n  }\n}\n\nUnicodeString::UnicodeString(UChar ch) {\n  fUnion.fFields.fLengthAndFlags = kLength1 | kShortString;\n  fUnion.fStackFields.fBuffer[0] = ch;\n}\n\nUnicodeString::UnicodeString(UChar32 ch) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  int32_t i = 0;\n  UBool isError = FALSE;\n  U16_APPEND(fUnion.fStackFields.fBuffer, i, US_STACKBUF_SIZE, ch, isError);\n  // We test isError so that the compiler does not complain that we don't.\n  // If isError then i==0 which is what we want anyway.\n  if(!isError) {\n    setShortLength(i);\n  }\n}\n\nUnicodeString::UnicodeString(const UChar *text) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  doAppend(text, 0, -1);\n}\n\nUnicodeString::UnicodeString(const UChar *text,\n                             int32_t textLength) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  doAppend(text, 0, textLength);\n}\n\nUnicodeString::UnicodeString(UBool isTerminated,\n                             ConstChar16Ptr textPtr,\n                             int32_t textLength) {\n  fUnion.fFields.fLengthAndFlags = kReadonlyAlias;\n  const UChar *text = textPtr;\n  if(text == NULL) {\n    // treat as an empty string, do not alias\n    setToEmpty();\n  } else if(textLength < -1 ||\n            (textLength == -1 && !isTerminated) ||\n            (textLength >= 0 && isTerminated && text[textLength] != 0)\n  ) {\n    setToBogus();\n  } else {\n    if(textLength == -1) {\n      // text is terminated, or else it would have failed the above test\n      textLength = u_strlen(text);\n    }\n    setArray(const_cast<UChar *>(text), textLength,\n             isTerminated ? textLength + 1 : textLength);\n  }\n}\n\nUnicodeString::UnicodeString(UChar *buff,\n                             int32_t buffLength,\n                             int32_t buffCapacity) {\n  fUnion.fFields.fLengthAndFlags = kWritableAlias;\n  if(buff == NULL) {\n    // treat as an empty string, do not alias\n    setToEmpty();\n  } else if(buffLength < -1 || buffCapacity < 0 || buffLength > buffCapacity) {\n    setToBogus();\n  } else {\n    if(buffLength == -1) {\n      // fLength = u_strlen(buff); but do not look beyond buffCapacity\n      const UChar *p = buff, *limit = buff + buffCapacity;\n      while(p != limit && *p != 0) {\n        ++p;\n      }\n      buffLength = (int32_t)(p - buff);\n    }\n    setArray(buff, buffLength, buffCapacity);\n  }\n}\n\nUnicodeString::UnicodeString(const char *src, int32_t length, EInvariant) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  if(src==NULL) {\n    // treat as an empty string\n  } else {\n    if(length<0) {\n      length=(int32_t)uprv_strlen(src);\n    }\n    if(cloneArrayIfNeeded(length, length, FALSE)) {\n      u_charsToUChars(src, getArrayStart(), length);\n      setLength(length);\n    } else {\n      setToBogus();\n    }\n  }\n}\n\n#if U_CHARSET_IS_UTF8\n\nUnicodeString::UnicodeString(const char *codepageData) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  if(codepageData != 0) {\n    setToUTF8(codepageData);\n  }\n}\n\nUnicodeString::UnicodeString(const char *codepageData, int32_t dataLength) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  // if there's nothing to convert, do nothing\n  if(codepageData == 0 || dataLength == 0 || dataLength < -1) {\n    return;\n  }\n  if(dataLength == -1) {\n    dataLength = (int32_t)uprv_strlen(codepageData);\n  }\n  setToUTF8(StringPiece(codepageData, dataLength));\n}\n\n// else see unistr_cnv.cpp\n#endif\n\nUnicodeString::UnicodeString(const UnicodeString& that) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  copyFrom(that);\n}\n\nUnicodeString::UnicodeString(UnicodeString &&src) U_NOEXCEPT {\n  copyFieldsFrom(src, TRUE);\n}\n\nUnicodeString::UnicodeString(const UnicodeString& that,\n                             int32_t srcStart) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  setTo(that, srcStart);\n}\n\nUnicodeString::UnicodeString(const UnicodeString& that,\n                             int32_t srcStart,\n                             int32_t srcLength) {\n  fUnion.fFields.fLengthAndFlags = kShortString;\n  setTo(that, srcStart, srcLength);\n}\n\n// Replaceable base class clone() default implementation, does not clone\nReplaceable *\nReplaceable::clone() const {\n  return NULL;\n}\n\n// UnicodeString overrides clone() with a real implementation\nUnicodeString *\nUnicodeString::clone() const {\n  return new UnicodeString(*this);\n}\n\n//========================================\n// array allocation\n//========================================\n\nnamespace {\n\nconst int32_t kGrowSize = 128;\n\n// The number of bytes for one int32_t reference counter and capacity UChars\n// must fit into a 32-bit size_t (at least when on a 32-bit platform).\n// We also add one for the NUL terminator, to avoid reallocation in getTerminatedBuffer(),\n// and round up to a multiple of 16 bytes.\n// This means that capacity must be at most (0xfffffff0 - 4) / 2 - 1 = 0x7ffffff5.\n// (With more complicated checks we could go up to 0x7ffffffd without rounding up,\n// but that does not seem worth it.)\nconst int32_t kMaxCapacity = 0x7ffffff5;\n\nint32_t getGrowCapacity(int32_t newLength) {\n  int32_t growSize = (newLength >> 2) + kGrowSize;\n  if(growSize <= (kMaxCapacity - newLength)) {\n    return newLength + growSize;\n  } else {\n    return kMaxCapacity;\n  }\n}\n\n}  // namespace\n\nUBool\nUnicodeString::allocate(int32_t capacity) {\n  if(capacity <= US_STACKBUF_SIZE) {\n    fUnion.fFields.fLengthAndFlags = kShortString;\n    return TRUE;\n  }\n  if(capacity <= kMaxCapacity) {\n    ++capacity;  // for the NUL\n    // Switch to size_t which is unsigned so that we can allocate up to 4GB.\n    // Reference counter + UChars.\n    size_t numBytes = sizeof(int32_t) + (size_t)capacity * U_SIZEOF_UCHAR;\n    // Round up to a multiple of 16.\n    numBytes = (numBytes + 15) & ~15;\n    int32_t *array = (int32_t *) uprv_malloc(numBytes);\n    if(array != NULL) {\n      // set initial refCount and point behind the refCount\n      *array++ = 1;\n      numBytes -= sizeof(int32_t);\n\n      // have fArray point to the first UChar\n      fUnion.fFields.fArray = (UChar *)array;\n      fUnion.fFields.fCapacity = (int32_t)(numBytes / U_SIZEOF_UCHAR);\n      fUnion.fFields.fLengthAndFlags = kLongString;\n      return TRUE;\n    }\n  }\n  fUnion.fFields.fLengthAndFlags = kIsBogus;\n  fUnion.fFields.fArray = 0;\n  fUnion.fFields.fCapacity = 0;\n  return FALSE;\n}\n\n//========================================\n// Destructor\n//========================================\n\n#ifdef UNISTR_COUNT_FINAL_STRING_LENGTHS\nstatic u_atomic_int32_t finalLengthCounts[0x400];  // UnicodeString::kMaxShortLength+1\nstatic u_atomic_int32_t beyondCount(0);\n\nU_CAPI void unistr_printLengths() {\n  int32_t i;\n  for(i = 0; i <= 59; ++i) {\n    printf(\"%2d,  %9d\\n\", i, (int32_t)finalLengthCounts[i]);\n  }\n  int32_t beyond = beyondCount;\n  for(; i < UPRV_LENGTHOF(finalLengthCounts); ++i) {\n    beyond += finalLengthCounts[i];\n  }\n  printf(\">59, %9d\\n\", beyond);\n}\n#endif\n\nUnicodeString::~UnicodeString()\n{\n#ifdef UNISTR_COUNT_FINAL_STRING_LENGTHS\n  // Count lengths of strings at the end of their lifetime.\n  // Useful for discussion of a desirable stack buffer size.\n  // Count the contents length, not the optional NUL terminator nor further capacity.\n  // Ignore open-buffer strings and strings which alias external storage.\n  if((fUnion.fFields.fLengthAndFlags&(kOpenGetBuffer|kReadonlyAlias|kWritableAlias)) == 0) {\n    if(hasShortLength()) {\n      umtx_atomic_inc(finalLengthCounts + getShortLength());\n    } else {\n      umtx_atomic_inc(&beyondCount);\n    }\n  }\n#endif\n\n  releaseArray();\n}\n\n//========================================\n// Factory methods\n//========================================\n\nUnicodeString UnicodeString::fromUTF8(StringPiece utf8) {\n  UnicodeString result;\n  result.setToUTF8(utf8);\n  return result;\n}\n\nUnicodeString UnicodeString::fromUTF32(const UChar32 *utf32, int32_t length) {\n  UnicodeString result;\n  int32_t capacity;\n  // Most UTF-32 strings will be BMP-only and result in a same-length\n  // UTF-16 string. We overestimate the capacity just slightly,\n  // just in case there are a few supplementary characters.\n  if(length <= US_STACKBUF_SIZE) {\n    capacity = US_STACKBUF_SIZE;\n  } else {\n    capacity = length + (length >> 4) + 4;\n  }\n  do {\n    UChar *utf16 = result.getBuffer(capacity);\n    int32_t length16;\n    UErrorCode errorCode = U_ZERO_ERROR;\n    u_strFromUTF32WithSub(utf16, result.getCapacity(), &length16,\n        utf32, length,\n        0xfffd,  // Substitution character.\n        NULL,    // Don't care about number of substitutions.\n        &errorCode);\n    result.releaseBuffer(length16);\n    if(errorCode == U_BUFFER_OVERFLOW_ERROR) {\n      capacity = length16 + 1;  // +1 for the terminating NUL.\n      continue;\n    } else if(U_FAILURE(errorCode)) {\n      result.setToBogus();\n    }\n    break;\n  } while(TRUE);\n  return result;\n}\n\n//========================================\n// Assignment\n//========================================\n\nUnicodeString &\nUnicodeString::operator=(const UnicodeString &src) {\n  return copyFrom(src);\n}\n\nUnicodeString &\nUnicodeString::fastCopyFrom(const UnicodeString &src) {\n  return copyFrom(src, TRUE);\n}\n\nUnicodeString &\nUnicodeString::copyFrom(const UnicodeString &src, UBool fastCopy) {\n  // if assigning to ourselves, do nothing\n  if(this == &src) {\n    return *this;\n  }\n\n  // is the right side bogus?\n  if(src.isBogus()) {\n    setToBogus();\n    return *this;\n  }\n\n  // delete the current contents\n  releaseArray();\n\n  if(src.isEmpty()) {\n    // empty string - use the stack buffer\n    setToEmpty();\n    return *this;\n  }\n\n  // fLength>0 and not an \"open\" src.getBuffer(minCapacity)\n  fUnion.fFields.fLengthAndFlags = src.fUnion.fFields.fLengthAndFlags;\n  switch(src.fUnion.fFields.fLengthAndFlags & kAllStorageFlags) {\n  case kShortString:\n    // short string using the stack buffer, do the same\n    uprv_memcpy(fUnion.fStackFields.fBuffer, src.fUnion.fStackFields.fBuffer,\n                getShortLength() * U_SIZEOF_UCHAR);\n    break;\n  case kLongString:\n    // src uses a refCounted string buffer, use that buffer with refCount\n    // src is const, use a cast - we don't actually change it\n    ((UnicodeString &)src).addRef();\n    // copy all fields, share the reference-counted buffer\n    fUnion.fFields.fArray = src.fUnion.fFields.fArray;\n    fUnion.fFields.fCapacity = src.fUnion.fFields.fCapacity;\n    if(!hasShortLength()) {\n      fUnion.fFields.fLength = src.fUnion.fFields.fLength;\n    }\n    break;\n  case kReadonlyAlias:\n    if(fastCopy) {\n      // src is a readonly alias, do the same\n      // -> maintain the readonly alias as such\n      fUnion.fFields.fArray = src.fUnion.fFields.fArray;\n      fUnion.fFields.fCapacity = src.fUnion.fFields.fCapacity;\n      if(!hasShortLength()) {\n        fUnion.fFields.fLength = src.fUnion.fFields.fLength;\n      }\n      break;\n    }\n    // else if(!fastCopy) fall through to case kWritableAlias\n    // -> allocate a new buffer and copy the contents\n    U_FALLTHROUGH;\n  case kWritableAlias: {\n    // src is a writable alias; we make a copy of that instead\n    int32_t srcLength = src.length();\n    if(allocate(srcLength)) {\n      u_memcpy(getArrayStart(), src.getArrayStart(), srcLength);\n      setLength(srcLength);\n      break;\n    }\n    // if there is not enough memory, then fall through to setting to bogus\n    U_FALLTHROUGH;\n  }\n  default:\n    // if src is bogus, set ourselves to bogus\n    // do not call setToBogus() here because fArray and flags are not consistent here\n    fUnion.fFields.fLengthAndFlags = kIsBogus;\n    fUnion.fFields.fArray = 0;\n    fUnion.fFields.fCapacity = 0;\n    break;\n  }\n\n  return *this;\n}\n\nUnicodeString &UnicodeString::operator=(UnicodeString &&src) U_NOEXCEPT {\n  // No explicit check for self move assignment, consistent with standard library.\n  // Self move assignment causes no crash nor leak but might make the object bogus.\n  releaseArray();\n  copyFieldsFrom(src, TRUE);\n  return *this;\n}\n\n// Same as move assignment except without memory management.\nvoid UnicodeString::copyFieldsFrom(UnicodeString &src, UBool setSrcToBogus) U_NOEXCEPT {\n  int16_t lengthAndFlags = fUnion.fFields.fLengthAndFlags = src.fUnion.fFields.fLengthAndFlags;\n  if(lengthAndFlags & kUsingStackBuffer) {\n    // Short string using the stack buffer, copy the contents.\n    // Check for self assignment to prevent \"overlap in memcpy\" warnings,\n    // although it should be harmless to copy a buffer to itself exactly.\n    if(this != &src) {\n      uprv_memcpy(fUnion.fStackFields.fBuffer, src.fUnion.fStackFields.fBuffer,\n                  getShortLength() * U_SIZEOF_UCHAR);\n    }\n  } else {\n    // In all other cases, copy all fields.\n    fUnion.fFields.fArray = src.fUnion.fFields.fArray;\n    fUnion.fFields.fCapacity = src.fUnion.fFields.fCapacity;\n    if(!hasShortLength()) {\n      fUnion.fFields.fLength = src.fUnion.fFields.fLength;\n    }\n    if(setSrcToBogus) {\n      // Set src to bogus without releasing any memory.\n      src.fUnion.fFields.fLengthAndFlags = kIsBogus;\n      src.fUnion.fFields.fArray = NULL;\n      src.fUnion.fFields.fCapacity = 0;\n    }\n  }\n}\n\nvoid UnicodeString::swap(UnicodeString &other) U_NOEXCEPT {\n  UnicodeString temp;  // Empty short string: Known not to need releaseArray().\n  // Copy fields without resetting source values in between.\n  temp.copyFieldsFrom(*this, FALSE);\n  this->copyFieldsFrom(other, FALSE);\n  other.copyFieldsFrom(temp, FALSE);\n  // Set temp to an empty string so that other's memory is not released twice.\n  temp.fUnion.fFields.fLengthAndFlags = kShortString;\n}\n\n//========================================\n// Miscellaneous operations\n//========================================\n\nUnicodeString UnicodeString::unescape() const {\n    UnicodeString result(length(), (UChar32)0, (int32_t)0); // construct with capacity\n    if (result.isBogus()) {\n        return result;\n    }\n    const UChar *array = getBuffer();\n    int32_t len = length();\n    int32_t prev = 0;\n    for (int32_t i=0;;) {\n        if (i == len) {\n            result.append(array, prev, len - prev);\n            break;\n        }\n        if (array[i++] == 0x5C /*'\\\\'*/) {\n            result.append(array, prev, (i - 1) - prev);\n            UChar32 c = unescapeAt(i); // advances i\n            if (c < 0) {\n                result.remove(); // return empty string\n                break; // invalid escape sequence\n            }\n            result.append(c);\n            prev = i;\n        }\n    }\n    return result;\n}\n\nUChar32 UnicodeString::unescapeAt(int32_t &offset) const {\n    return u_unescapeAt(UnicodeString_charAt, &offset, length(), (void*)this);\n}\n\n//========================================\n// Read-only implementation\n//========================================\nUBool\nUnicodeString::doEquals(const UnicodeString &text, int32_t len) const {\n  // Requires: this & text not bogus and have same lengths.\n  // Byte-wise comparison works for equality regardless of endianness.\n  return uprv_memcmp(getArrayStart(), text.getArrayStart(), len * U_SIZEOF_UCHAR) == 0;\n}\n\nint8_t\nUnicodeString::doCompare( int32_t start,\n              int32_t length,\n              const UChar *srcChars,\n              int32_t srcStart,\n              int32_t srcLength) const\n{\n  // compare illegal string values\n  if(isBogus()) {\n    return -1;\n  }\n  \n  // pin indices to legal values\n  pinIndices(start, length);\n\n  if(srcChars == NULL) {\n    // treat const UChar *srcChars==NULL as an empty string\n    return length == 0 ? 0 : 1;\n  }\n\n  // get the correct pointer\n  const UChar *chars = getArrayStart();\n\n  chars += start;\n  srcChars += srcStart;\n\n  int32_t minLength;\n  int8_t lengthResult;\n\n  // get the srcLength if necessary\n  if(srcLength < 0) {\n    srcLength = u_strlen(srcChars + srcStart);\n  }\n\n  // are we comparing different lengths?\n  if(length != srcLength) {\n    if(length < srcLength) {\n      minLength = length;\n      lengthResult = -1;\n    } else {\n      minLength = srcLength;\n      lengthResult = 1;\n    }\n  } else {\n    minLength = length;\n    lengthResult = 0;\n  }\n\n  /*\n   * note that uprv_memcmp() returns an int but we return an int8_t;\n   * we need to take care not to truncate the result -\n   * one way to do this is to right-shift the value to\n   * move the sign bit into the lower 8 bits and making sure that this\n   * does not become 0 itself\n   */\n\n  if(minLength > 0 && chars != srcChars) {\n    int32_t result;\n\n#   if U_IS_BIG_ENDIAN \n      // big-endian: byte comparison works\n      result = uprv_memcmp(chars, srcChars, minLength * sizeof(UChar));\n      if(result != 0) {\n        return (int8_t)(result >> 15 | 1);\n      }\n#   else\n      // little-endian: compare UChar units\n      do {\n        result = ((int32_t)*(chars++) - (int32_t)*(srcChars++));\n        if(result != 0) {\n          return (int8_t)(result >> 15 | 1);\n        }\n      } while(--minLength > 0);\n#   endif\n  }\n  return lengthResult;\n}\n\n/* String compare in code point order - doCompare() compares in code unit order. */\nint8_t\nUnicodeString::doCompareCodePointOrder(int32_t start,\n                                       int32_t length,\n                                       const UChar *srcChars,\n                                       int32_t srcStart,\n                                       int32_t srcLength) const\n{\n  // compare illegal string values\n  // treat const UChar *srcChars==NULL as an empty string\n  if(isBogus()) {\n    return -1;\n  }\n\n  // pin indices to legal values\n  pinIndices(start, length);\n\n  if(srcChars == NULL) {\n    srcStart = srcLength = 0;\n  }\n\n  int32_t diff = uprv_strCompare(getArrayStart() + start, length, (srcChars!=NULL)?(srcChars + srcStart):NULL, srcLength, FALSE, TRUE);\n  /* translate the 32-bit result into an 8-bit one */\n  if(diff!=0) {\n    return (int8_t)(diff >> 15 | 1);\n  } else {\n    return 0;\n  }\n}\n\nint32_t\nUnicodeString::getLength() const {\n    return length();\n}\n\nUChar\nUnicodeString::getCharAt(int32_t offset) const {\n  return charAt(offset);\n}\n\nUChar32\nUnicodeString::getChar32At(int32_t offset) const {\n  return char32At(offset);\n}\n\nUChar32\nUnicodeString::char32At(int32_t offset) const\n{\n  int32_t len = length();\n  if((uint32_t)offset < (uint32_t)len) {\n    const UChar *array = getArrayStart();\n    UChar32 c;\n    U16_GET(array, 0, offset, len, c);\n    return c;\n  } else {\n    return kInvalidUChar;\n  }\n}\n\nint32_t\nUnicodeString::getChar32Start(int32_t offset) const {\n  if((uint32_t)offset < (uint32_t)length()) {\n    const UChar *array = getArrayStart();\n    U16_SET_CP_START(array, 0, offset);\n    return offset;\n  } else {\n    return 0;\n  }\n}\n\nint32_t\nUnicodeString::getChar32Limit(int32_t offset) const {\n  int32_t len = length();\n  if((uint32_t)offset < (uint32_t)len) {\n    const UChar *array = getArrayStart();\n    U16_SET_CP_LIMIT(array, 0, offset, len);\n    return offset;\n  } else {\n    return len;\n  }\n}\n\nint32_t\nUnicodeString::countChar32(int32_t start, int32_t length) const {\n  pinIndices(start, length);\n  // if(isBogus()) then fArray==0 and start==0 - u_countChar32() checks for NULL\n  return u_countChar32(getArrayStart()+start, length);\n}\n\nUBool\nUnicodeString::hasMoreChar32Than(int32_t start, int32_t length, int32_t number) const {\n  pinIndices(start, length);\n  // if(isBogus()) then fArray==0 and start==0 - u_strHasMoreChar32Than() checks for NULL\n  return u_strHasMoreChar32Than(getArrayStart()+start, length, number);\n}\n\nint32_t\nUnicodeString::moveIndex32(int32_t index, int32_t delta) const {\n  // pin index\n  int32_t len = length();\n  if(index<0) {\n    index=0;\n  } else if(index>len) {\n    index=len;\n  }\n\n  const UChar *array = getArrayStart();\n  if(delta>0) {\n    U16_FWD_N(array, index, len, delta);\n  } else {\n    U16_BACK_N(array, 0, index, -delta);\n  }\n\n  return index;\n}\n\nvoid\nUnicodeString::doExtract(int32_t start,\n             int32_t length,\n             UChar *dst,\n             int32_t dstStart) const\n{\n  // pin indices to legal values\n  pinIndices(start, length);\n\n  // do not copy anything if we alias dst itself\n  const UChar *array = getArrayStart();\n  if(array + start != dst + dstStart) {\n    us_arrayCopy(array, start, dst, dstStart, length);\n  }\n}\n\nint32_t\nUnicodeString::extract(Char16Ptr dest, int32_t destCapacity,\n                       UErrorCode &errorCode) const {\n  int32_t len = length();\n  if(U_SUCCESS(errorCode)) {\n    if(isBogus() || destCapacity<0 || (destCapacity>0 && dest==0)) {\n      errorCode=U_ILLEGAL_ARGUMENT_ERROR;\n    } else {\n      const UChar *array = getArrayStart();\n      if(len>0 && len<=destCapacity && array!=dest) {\n        u_memcpy(dest, array, len);\n      }\n      return u_terminateUChars(dest, destCapacity, len, &errorCode);\n    }\n  }\n\n  return len;\n}\n\nint32_t\nUnicodeString::extract(int32_t start,\n                       int32_t length,\n                       char *target,\n                       int32_t targetCapacity,\n                       enum EInvariant) const\n{\n  // if the arguments are illegal, then do nothing\n  if(targetCapacity < 0 || (targetCapacity > 0 && target == NULL)) {\n    return 0;\n  }\n\n  // pin the indices to legal values\n  pinIndices(start, length);\n\n  if(length <= targetCapacity) {\n    u_UCharsToChars(getArrayStart() + start, target, length);\n  }\n  UErrorCode status = U_ZERO_ERROR;\n  return u_terminateChars(target, targetCapacity, length, &status);\n}\n\nUnicodeString\nUnicodeString::tempSubString(int32_t start, int32_t len) const {\n  pinIndices(start, len);\n  const UChar *array = getBuffer();  // not getArrayStart() to check kIsBogus & kOpenGetBuffer\n  if(array==NULL) {\n    array=fUnion.fStackFields.fBuffer;  // anything not NULL because that would make an empty string\n    len=-2;  // bogus result string\n  }\n  return UnicodeString(FALSE, array + start, len);\n}\n\nint32_t\nUnicodeString::toUTF8(int32_t start, int32_t len,\n                      char *target, int32_t capacity) const {\n  pinIndices(start, len);\n  int32_t length8;\n  UErrorCode errorCode = U_ZERO_ERROR;\n  u_strToUTF8WithSub(target, capacity, &length8,\n                     getBuffer() + start, len,\n                     0xFFFD,  // Standard substitution character.\n                     NULL,    // Don't care about number of substitutions.\n                     &errorCode);\n  return length8;\n}\n\n#if U_CHARSET_IS_UTF8\n\nint32_t\nUnicodeString::extract(int32_t start, int32_t len,\n                       char *target, uint32_t dstSize) const {\n  // if the arguments are illegal, then do nothing\n  if(/*dstSize < 0 || */(dstSize > 0 && target == 0)) {\n    return 0;\n  }\n  return toUTF8(start, len, target, dstSize <= 0x7fffffff ? (int32_t)dstSize : 0x7fffffff);\n}\n\n// else see unistr_cnv.cpp\n#endif\n\nvoid \nUnicodeString::extractBetween(int32_t start,\n                  int32_t limit,\n                  UnicodeString& target) const {\n  pinIndex(start);\n  pinIndex(limit);\n  doExtract(start, limit - start, target);\n}\n\n// When converting from UTF-16 to UTF-8, the result will have at most 3 times\n// as many bytes as the source has UChars.\n// The \"worst cases\" are writing systems like Indic, Thai and CJK with\n// 3:1 bytes:UChars.\nvoid\nUnicodeString::toUTF8(ByteSink &sink) const {\n  int32_t length16 = length();\n  if(length16 != 0) {\n    char stackBuffer[1024];\n    int32_t capacity = (int32_t)sizeof(stackBuffer);\n    UBool utf8IsOwned = FALSE;\n    char *utf8 = sink.GetAppendBuffer(length16 < capacity ? length16 : capacity,\n                                      3*length16,\n                                      stackBuffer, capacity,\n                                      &capacity);\n    int32_t length8 = 0;\n    UErrorCode errorCode = U_ZERO_ERROR;\n    u_strToUTF8WithSub(utf8, capacity, &length8,\n                       getBuffer(), length16,\n                       0xFFFD,  // Standard substitution character.\n                       NULL,    // Don't care about number of substitutions.\n                       &errorCode);\n    if(errorCode == U_BUFFER_OVERFLOW_ERROR) {\n      utf8 = (char *)uprv_malloc(length8);\n      if(utf8 != NULL) {\n        utf8IsOwned = TRUE;\n        errorCode = U_ZERO_ERROR;\n        u_strToUTF8WithSub(utf8, length8, &length8,\n                           getBuffer(), length16,\n                           0xFFFD,  // Standard substitution character.\n                           NULL,    // Don't care about number of substitutions.\n                           &errorCode);\n      } else {\n        errorCode = U_MEMORY_ALLOCATION_ERROR;\n      }\n    }\n    if(U_SUCCESS(errorCode)) {\n      sink.Append(utf8, length8);\n      sink.Flush();\n    }\n    if(utf8IsOwned) {\n      uprv_free(utf8);\n    }\n  }\n}\n\nint32_t\nUnicodeString::toUTF32(UChar32 *utf32, int32_t capacity, UErrorCode &errorCode) const {\n  int32_t length32=0;\n  if(U_SUCCESS(errorCode)) {\n    // getBuffer() and u_strToUTF32WithSub() check for illegal arguments.\n    u_strToUTF32WithSub(utf32, capacity, &length32,\n        getBuffer(), length(),\n        0xfffd,  // Substitution character.\n        NULL,    // Don't care about number of substitutions.\n        &errorCode);\n  }\n  return length32;\n}\n\nint32_t \nUnicodeString::indexOf(const UChar *srcChars,\n               int32_t srcStart,\n               int32_t srcLength,\n               int32_t start,\n               int32_t length) const\n{\n  if(isBogus() || srcChars == 0 || srcStart < 0 || srcLength == 0) {\n    return -1;\n  }\n\n  // UnicodeString does not find empty substrings\n  if(srcLength < 0 && srcChars[srcStart] == 0) {\n    return -1;\n  }\n\n  // get the indices within bounds\n  pinIndices(start, length);\n\n  // find the first occurrence of the substring\n  const UChar *array = getArrayStart();\n  const UChar *match = u_strFindFirst(array + start, length, srcChars + srcStart, srcLength);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\nint32_t\nUnicodeString::doIndexOf(UChar c,\n             int32_t start,\n             int32_t length) const\n{\n  // pin indices\n  pinIndices(start, length);\n\n  // find the first occurrence of c\n  const UChar *array = getArrayStart();\n  const UChar *match = u_memchr(array + start, c, length);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\nint32_t\nUnicodeString::doIndexOf(UChar32 c,\n                         int32_t start,\n                         int32_t length) const {\n  // pin indices\n  pinIndices(start, length);\n\n  // find the first occurrence of c\n  const UChar *array = getArrayStart();\n  const UChar *match = u_memchr32(array + start, c, length);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\nint32_t \nUnicodeString::lastIndexOf(const UChar *srcChars,\n               int32_t srcStart,\n               int32_t srcLength,\n               int32_t start,\n               int32_t length) const\n{\n  if(isBogus() || srcChars == 0 || srcStart < 0 || srcLength == 0) {\n    return -1;\n  }\n\n  // UnicodeString does not find empty substrings\n  if(srcLength < 0 && srcChars[srcStart] == 0) {\n    return -1;\n  }\n\n  // get the indices within bounds\n  pinIndices(start, length);\n\n  // find the last occurrence of the substring\n  const UChar *array = getArrayStart();\n  const UChar *match = u_strFindLast(array + start, length, srcChars + srcStart, srcLength);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\nint32_t\nUnicodeString::doLastIndexOf(UChar c,\n                 int32_t start,\n                 int32_t length) const\n{\n  if(isBogus()) {\n    return -1;\n  }\n\n  // pin indices\n  pinIndices(start, length);\n\n  // find the last occurrence of c\n  const UChar *array = getArrayStart();\n  const UChar *match = u_memrchr(array + start, c, length);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\nint32_t\nUnicodeString::doLastIndexOf(UChar32 c,\n                             int32_t start,\n                             int32_t length) const {\n  // pin indices\n  pinIndices(start, length);\n\n  // find the last occurrence of c\n  const UChar *array = getArrayStart();\n  const UChar *match = u_memrchr32(array + start, c, length);\n  if(match == NULL) {\n    return -1;\n  } else {\n    return (int32_t)(match - array);\n  }\n}\n\n//========================================\n// Write implementation\n//========================================\n\nUnicodeString& \nUnicodeString::findAndReplace(int32_t start,\n                  int32_t length,\n                  const UnicodeString& oldText,\n                  int32_t oldStart,\n                  int32_t oldLength,\n                  const UnicodeString& newText,\n                  int32_t newStart,\n                  int32_t newLength)\n{\n  if(isBogus() || oldText.isBogus() || newText.isBogus()) {\n    return *this;\n  }\n\n  pinIndices(start, length);\n  oldText.pinIndices(oldStart, oldLength);\n  newText.pinIndices(newStart, newLength);\n\n  if(oldLength == 0) {\n    return *this;\n  }\n\n  while(length > 0 && length >= oldLength) {\n    int32_t pos = indexOf(oldText, oldStart, oldLength, start, length);\n    if(pos < 0) {\n      // no more oldText's here: done\n      break;\n    } else {\n      // we found oldText, replace it by newText and go beyond it\n      replace(pos, oldLength, newText, newStart, newLength);\n      length -= pos + oldLength - start;\n      start = pos + newLength;\n    }\n  }\n\n  return *this;\n}\n\n\nvoid\nUnicodeString::setToBogus()\n{\n  releaseArray();\n\n  fUnion.fFields.fLengthAndFlags = kIsBogus;\n  fUnion.fFields.fArray = 0;\n  fUnion.fFields.fCapacity = 0;\n}\n\n// turn a bogus string into an empty one\nvoid\nUnicodeString::unBogus() {\n  if(fUnion.fFields.fLengthAndFlags & kIsBogus) {\n    setToEmpty();\n  }\n}\n\nconst char16_t *\nUnicodeString::getTerminatedBuffer() {\n  if(!isWritable()) {\n    return nullptr;\n  }\n  UChar *array = getArrayStart();\n  int32_t len = length();\n  if(len < getCapacity()) {\n    if(fUnion.fFields.fLengthAndFlags & kBufferIsReadonly) {\n      // If len<capacity on a read-only alias, then array[len] is\n      // either the original NUL (if constructed with (TRUE, s, length))\n      // or one of the original string contents characters (if later truncated),\n      // therefore we can assume that array[len] is initialized memory.\n      if(array[len] == 0) {\n        return array;\n      }\n    } else if(((fUnion.fFields.fLengthAndFlags & kRefCounted) == 0 || refCount() == 1)) {\n      // kRefCounted: Do not write the NUL if the buffer is shared.\n      // That is mostly safe, except when the length of one copy was modified\n      // without copy-on-write, e.g., via truncate(newLength) or remove(void).\n      // Then the NUL would be written into the middle of another copy's string.\n\n      // Otherwise, the buffer is fully writable and it is anyway safe to write the NUL.\n      // Do not test if there is a NUL already because it might be uninitialized memory.\n      // (That would be safe, but tools like valgrind & Purify would complain.)\n      array[len] = 0;\n      return array;\n    }\n  }\n  if(len<INT32_MAX && cloneArrayIfNeeded(len+1)) {\n    array = getArrayStart();\n    array[len] = 0;\n    return array;\n  } else {\n    return nullptr;\n  }\n}\n\n// setTo() analogous to the readonly-aliasing constructor with the same signature\nUnicodeString &\nUnicodeString::setTo(UBool isTerminated,\n                     ConstChar16Ptr textPtr,\n                     int32_t textLength)\n{\n  if(fUnion.fFields.fLengthAndFlags & kOpenGetBuffer) {\n    // do not modify a string that has an \"open\" getBuffer(minCapacity)\n    return *this;\n  }\n\n  const UChar *text = textPtr;\n  if(text == NULL) {\n    // treat as an empty string, do not alias\n    releaseArray();\n    setToEmpty();\n    return *this;\n  }\n\n  if( textLength < -1 ||\n      (textLength == -1 && !isTerminated) ||\n      (textLength >= 0 && isTerminated && text[textLength] != 0)\n  ) {\n    setToBogus();\n    return *this;\n  }\n\n  releaseArray();\n\n  if(textLength == -1) {\n    // text is terminated, or else it would have failed the above test\n    textLength = u_strlen(text);\n  }\n  fUnion.fFields.fLengthAndFlags = kReadonlyAlias;\n  setArray((UChar *)text, textLength, isTerminated ? textLength + 1 : textLength);\n  return *this;\n}\n\n// setTo() analogous to the writable-aliasing constructor with the same signature\nUnicodeString &\nUnicodeString::setTo(UChar *buffer,\n                     int32_t buffLength,\n                     int32_t buffCapacity) {\n  if(fUnion.fFields.fLengthAndFlags & kOpenGetBuffer) {\n    // do not modify a string that has an \"open\" getBuffer(minCapacity)\n    return *this;\n  }\n\n  if(buffer == NULL) {\n    // treat as an empty string, do not alias\n    releaseArray();\n    setToEmpty();\n    return *this;\n  }\n\n  if(buffLength < -1 || buffCapacity < 0 || buffLength > buffCapacity) {\n    setToBogus();\n    return *this;\n  } else if(buffLength == -1) {\n    // buffLength = u_strlen(buff); but do not look beyond buffCapacity\n    const UChar *p = buffer, *limit = buffer + buffCapacity;\n    while(p != limit && *p != 0) {\n      ++p;\n    }\n    buffLength = (int32_t)(p - buffer);\n  }\n\n  releaseArray();\n\n  fUnion.fFields.fLengthAndFlags = kWritableAlias;\n  setArray(buffer, buffLength, buffCapacity);\n  return *this;\n}\n\nUnicodeString &UnicodeString::setToUTF8(StringPiece utf8) {\n  unBogus();\n  int32_t length = utf8.length();\n  int32_t capacity;\n  // The UTF-16 string will be at most as long as the UTF-8 string.\n  if(length <= US_STACKBUF_SIZE) {\n    capacity = US_STACKBUF_SIZE;\n  } else {\n    capacity = length + 1;  // +1 for the terminating NUL.\n  }\n  UChar *utf16 = getBuffer(capacity);\n  int32_t length16;\n  UErrorCode errorCode = U_ZERO_ERROR;\n  u_strFromUTF8WithSub(utf16, getCapacity(), &length16,\n      utf8.data(), length,\n      0xfffd,  // Substitution character.\n      NULL,    // Don't care about number of substitutions.\n      &errorCode);\n  releaseBuffer(length16);\n  if(U_FAILURE(errorCode)) {\n    setToBogus();\n  }\n  return *this;\n}\n\nUnicodeString&\nUnicodeString::setCharAt(int32_t offset,\n             UChar c)\n{\n  int32_t len = length();\n  if(cloneArrayIfNeeded() && len > 0) {\n    if(offset < 0) {\n      offset = 0;\n    } else if(offset >= len) {\n      offset = len - 1;\n    }\n\n    getArrayStart()[offset] = c;\n  }\n  return *this;\n}\n\nUnicodeString&\nUnicodeString::replace(int32_t start,\n               int32_t _length,\n               UChar32 srcChar) {\n  UChar buffer[U16_MAX_LENGTH];\n  int32_t count = 0;\n  UBool isError = FALSE;\n  U16_APPEND(buffer, count, U16_MAX_LENGTH, srcChar, isError);\n  // We test isError so that the compiler does not complain that we don't.\n  // If isError (srcChar is not a valid code point) then count==0 which means\n  // we remove the source segment rather than replacing it with srcChar.\n  return doReplace(start, _length, buffer, 0, isError ? 0 : count);\n}\n\nUnicodeString&\nUnicodeString::append(UChar32 srcChar) {\n  UChar buffer[U16_MAX_LENGTH];\n  int32_t _length = 0;\n  UBool isError = FALSE;\n  U16_APPEND(buffer, _length, U16_MAX_LENGTH, srcChar, isError);\n  // We test isError so that the compiler does not complain that we don't.\n  // If isError then _length==0 which turns the doAppend() into a no-op anyway.\n  return isError ? *this : doAppend(buffer, 0, _length);\n}\n\nUnicodeString&\nUnicodeString::doReplace( int32_t start,\n              int32_t length,\n              const UnicodeString& src,\n              int32_t srcStart,\n              int32_t srcLength)\n{\n  // pin the indices to legal values\n  src.pinIndices(srcStart, srcLength);\n\n  // get the characters from src\n  // and replace the range in ourselves with them\n  return doReplace(start, length, src.getArrayStart(), srcStart, srcLength);\n}\n\nUnicodeString&\nUnicodeString::doReplace(int32_t start,\n             int32_t length,\n             const UChar *srcChars,\n             int32_t srcStart,\n             int32_t srcLength)\n{\n  if(!isWritable()) {\n    return *this;\n  }\n\n  int32_t oldLength = this->length();\n\n  // optimize (read-only alias).remove(0, start) and .remove(start, end)\n  if((fUnion.fFields.fLengthAndFlags&kBufferIsReadonly) && srcLength == 0) {\n    if(start == 0) {\n      // remove prefix by adjusting the array pointer\n      pinIndex(length);\n      fUnion.fFields.fArray += length;\n      fUnion.fFields.fCapacity -= length;\n      setLength(oldLength - length);\n      return *this;\n    } else {\n      pinIndex(start);\n      if(length >= (oldLength - start)) {\n        // remove suffix by reducing the length (like truncate())\n        setLength(start);\n        fUnion.fFields.fCapacity = start;  // not NUL-terminated any more\n        return *this;\n      }\n    }\n  }\n\n  if(start == oldLength) {\n    return doAppend(srcChars, srcStart, srcLength);\n  }\n\n  if(srcChars == 0) {\n    srcLength = 0;\n  } else {\n    // Perform all remaining operations relative to srcChars + srcStart.\n    // From this point forward, do not use srcStart.\n    srcChars += srcStart;\n    if (srcLength < 0) {\n      // get the srcLength if necessary\n      srcLength = u_strlen(srcChars);\n    }\n  }\n\n  // pin the indices to legal values\n  pinIndices(start, length);\n\n  // Calculate the size of the string after the replace.\n  // Avoid int32_t overflow.\n  int32_t newLength = oldLength - length;\n  if(srcLength > (INT32_MAX - newLength)) {\n    setToBogus();\n    return *this;\n  }\n  newLength += srcLength;\n\n  // Check for insertion into ourself\n  const UChar *oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    // Copy into a new UnicodeString and start over\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doReplace(start, length, copy.getArrayStart(), 0, srcLength);\n  }\n\n  // cloneArrayIfNeeded(doCopyArray=FALSE) may change fArray but will not copy the current contents;\n  // therefore we need to keep the current fArray\n  UChar oldStackBuffer[US_STACKBUF_SIZE];\n  if((fUnion.fFields.fLengthAndFlags&kUsingStackBuffer) && (newLength > US_STACKBUF_SIZE)) {\n    // copy the stack buffer contents because it will be overwritten with\n    // fUnion.fFields values\n    u_memcpy(oldStackBuffer, oldArray, oldLength);\n    oldArray = oldStackBuffer;\n  }\n\n  // clone our array and allocate a bigger array if needed\n  int32_t *bufferToDelete = 0;\n  if(!cloneArrayIfNeeded(newLength, getGrowCapacity(newLength),\n                         FALSE, &bufferToDelete)\n  ) {\n    return *this;\n  }\n\n  // now do the replace\n\n  UChar *newArray = getArrayStart();\n  if(newArray != oldArray) {\n    // if fArray changed, then we need to copy everything except what will change\n    us_arrayCopy(oldArray, 0, newArray, 0, start);\n    us_arrayCopy(oldArray, start + length,\n                 newArray, start + srcLength,\n                 oldLength - (start + length));\n  } else if(length != srcLength) {\n    // fArray did not change; copy only the portion that isn't changing, leaving a hole\n    us_arrayCopy(oldArray, start + length,\n                 newArray, start + srcLength,\n                 oldLength - (start + length));\n  }\n\n  // now fill in the hole with the new string\n  us_arrayCopy(srcChars, 0, newArray, start, srcLength);\n\n  setLength(newLength);\n\n  // delayed delete in case srcChars == fArray when we started, and\n  // to keep oldArray alive for the above operations\n  if (bufferToDelete) {\n    uprv_free(bufferToDelete);\n  }\n\n  return *this;\n}\n\n// Versions of doReplace() only for append() variants.\n// doReplace() and doAppend() optimize for different cases.\n\nUnicodeString&\nUnicodeString::doAppend(const UnicodeString& src, int32_t srcStart, int32_t srcLength) {\n  if(srcLength == 0) {\n    return *this;\n  }\n\n  // pin the indices to legal values\n  src.pinIndices(srcStart, srcLength);\n  return doAppend(src.getArrayStart(), srcStart, srcLength);\n}\n\nUnicodeString&\nUnicodeString::doAppend(const UChar *srcChars, int32_t srcStart, int32_t srcLength) {\n  if(!isWritable() || srcLength == 0 || srcChars == NULL) {\n    return *this;\n  }\n\n  // Perform all remaining operations relative to srcChars + srcStart.\n  // From this point forward, do not use srcStart.\n  srcChars += srcStart;\n\n  if(srcLength < 0) {\n    // get the srcLength if necessary\n    if((srcLength = u_strlen(srcChars)) == 0) {\n      return *this;\n    }\n  }\n\n  int32_t oldLength = length();\n  int32_t newLength;\n  if (uprv_add32_overflow(oldLength, srcLength, &newLength)) {\n    setToBogus();\n    return *this;\n  }\n\n  // Check for append onto ourself\n  const UChar* oldArray = getArrayStart();\n  if (isBufferWritable() &&\n      oldArray < srcChars + srcLength &&\n      srcChars < oldArray + oldLength) {\n    // Copy into a new UnicodeString and start over\n    UnicodeString copy(srcChars, srcLength);\n    if (copy.isBogus()) {\n      setToBogus();\n      return *this;\n    }\n    return doAppend(copy.getArrayStart(), 0, srcLength);\n  }\n\n  // optimize append() onto a large-enough, owned string\n  if((newLength <= getCapacity() && isBufferWritable()) ||\n      cloneArrayIfNeeded(newLength, getGrowCapacity(newLength))) {\n    UChar *newArray = getArrayStart();\n    // Do not copy characters when\n    //   UChar *buffer=str.getAppendBuffer(...);\n    // is followed by\n    //   str.append(buffer, length);\n    // or\n    //   str.appendString(buffer, length)\n    // or similar.\n    if(srcChars != newArray + oldLength) {\n      us_arrayCopy(srcChars, 0, newArray, oldLength, srcLength);\n    }\n    setLength(newLength);\n  }\n  return *this;\n}\n\n/**\n * Replaceable API\n */\nvoid\nUnicodeString::handleReplaceBetween(int32_t start,\n                                    int32_t limit,\n                                    const UnicodeString& text) {\n    replaceBetween(start, limit, text);\n}\n\n/**\n * Replaceable API\n */\nvoid \nUnicodeString::copy(int32_t start, int32_t limit, int32_t dest) {\n    if (limit <= start) {\n        return; // Nothing to do; avoid bogus malloc call\n    }\n    UChar* text = (UChar*) uprv_malloc( sizeof(UChar) * (limit - start) );\n    // Check to make sure text is not null.\n    if (text != NULL) {\n\t    extractBetween(start, limit, text, 0);\n\t    insert(dest, text, 0, limit - start);    \n\t    uprv_free(text);\n    }\n}\n\n/**\n * Replaceable API\n *\n * NOTE: This is for the Replaceable class.  There is no rep.cpp,\n * so we implement this function here.\n */\nUBool Replaceable::hasMetaData() const {\n    return TRUE;\n}\n\n/**\n * Replaceable API\n */\nUBool UnicodeString::hasMetaData() const {\n    return FALSE;\n}\n\nUnicodeString&\nUnicodeString::doReverse(int32_t start, int32_t length) {\n  if(length <= 1 || !cloneArrayIfNeeded()) {\n    return *this;\n  }\n\n  // pin the indices to legal values\n  pinIndices(start, length);\n  if(length <= 1) {  // pinIndices() might have shrunk the length\n    return *this;\n  }\n\n  UChar *left = getArrayStart() + start;\n  UChar *right = left + length - 1;  // -1 for inclusive boundary (length>=2)\n  UChar swap;\n  UBool hasSupplementary = FALSE;\n\n  // Before the loop we know left<right because length>=2.\n  do {\n    hasSupplementary |= (UBool)U16_IS_LEAD(swap = *left);\n    hasSupplementary |= (UBool)U16_IS_LEAD(*left++ = *right);\n    *right-- = swap;\n  } while(left < right);\n  // Make sure to test the middle code unit of an odd-length string.\n  // Redundant if the length is even.\n  hasSupplementary |= (UBool)U16_IS_LEAD(*left);\n\n  /* if there are supplementary code points in the reversed range, then re-swap their surrogates */\n  if(hasSupplementary) {\n    UChar swap2;\n\n    left = getArrayStart() + start;\n    right = left + length - 1; // -1 so that we can look at *(left+1) if left<right\n    while(left < right) {\n      if(U16_IS_TRAIL(swap = *left) && U16_IS_LEAD(swap2 = *(left + 1))) {\n        *left++ = swap2;\n        *left++ = swap;\n      } else {\n        ++left;\n      }\n    }\n  }\n\n  return *this;\n}\n\nUBool \nUnicodeString::padLeading(int32_t targetLength,\n                          UChar padChar)\n{\n  int32_t oldLength = length();\n  if(oldLength >= targetLength || !cloneArrayIfNeeded(targetLength)) {\n    return FALSE;\n  } else {\n    // move contents up by padding width\n    UChar *array = getArrayStart();\n    int32_t start = targetLength - oldLength;\n    us_arrayCopy(array, 0, array, start, oldLength);\n\n    // fill in padding character\n    while(--start >= 0) {\n      array[start] = padChar;\n    }\n    setLength(targetLength);\n    return TRUE;\n  }\n}\n\nUBool \nUnicodeString::padTrailing(int32_t targetLength,\n                           UChar padChar)\n{\n  int32_t oldLength = length();\n  if(oldLength >= targetLength || !cloneArrayIfNeeded(targetLength)) {\n    return FALSE;\n  } else {\n    // fill in padding character\n    UChar *array = getArrayStart();\n    int32_t length = targetLength;\n    while(--length >= oldLength) {\n      array[length] = padChar;\n    }\n    setLength(targetLength);\n    return TRUE;\n  }\n}\n\n//========================================\n// Hashing\n//========================================\nint32_t\nUnicodeString::doHashCode() const\n{\n    /* Delegate hash computation to uhash.  This makes UnicodeString\n     * hashing consistent with UChar* hashing.  */\n    int32_t hashCode = ustr_hashUCharsN(getArrayStart(), length());\n    if (hashCode == kInvalidHashCode) {\n        hashCode = kEmptyHashCode;\n    }\n    return hashCode;\n}\n\n//========================================\n// External Buffer\n//========================================\n\nchar16_t *\nUnicodeString::getBuffer(int32_t minCapacity) {\n  if(minCapacity>=-1 && cloneArrayIfNeeded(minCapacity)) {\n    fUnion.fFields.fLengthAndFlags|=kOpenGetBuffer;\n    setZeroLength();\n    return getArrayStart();\n  } else {\n    return nullptr;\n  }\n}\n\nvoid\nUnicodeString::releaseBuffer(int32_t newLength) {\n  if(fUnion.fFields.fLengthAndFlags&kOpenGetBuffer && newLength>=-1) {\n    // set the new fLength\n    int32_t capacity=getCapacity();\n    if(newLength==-1) {\n      // the new length is the string length, capped by fCapacity\n      const UChar *array=getArrayStart(), *p=array, *limit=array+capacity;\n      while(p<limit && *p!=0) {\n        ++p;\n      }\n      newLength=(int32_t)(p-array);\n    } else if(newLength>capacity) {\n      newLength=capacity;\n    }\n    setLength(newLength);\n    fUnion.fFields.fLengthAndFlags&=~kOpenGetBuffer;\n  }\n}\n\n//========================================\n// Miscellaneous\n//========================================\nUBool\nUnicodeString::cloneArrayIfNeeded(int32_t newCapacity,\n                                  int32_t growCapacity,\n                                  UBool doCopyArray,\n                                  int32_t **pBufferToDelete,\n                                  UBool forceClone) {\n  // default parameters need to be static, therefore\n  // the defaults are -1 to have convenience defaults\n  if(newCapacity == -1) {\n    newCapacity = getCapacity();\n  }\n\n  // while a getBuffer(minCapacity) is \"open\",\n  // prevent any modifications of the string by returning FALSE here\n  // if the string is bogus, then only an assignment or similar can revive it\n  if(!isWritable()) {\n    return FALSE;\n  }\n\n  /*\n   * We need to make a copy of the array if\n   * the buffer is read-only, or\n   * the buffer is refCounted (shared), and refCount>1, or\n   * the buffer is too small.\n   * Return FALSE if memory could not be allocated.\n   */\n  if(forceClone ||\n     fUnion.fFields.fLengthAndFlags & kBufferIsReadonly ||\n     (fUnion.fFields.fLengthAndFlags & kRefCounted && refCount() > 1) ||\n     newCapacity > getCapacity()\n  ) {\n    // check growCapacity for default value and use of the stack buffer\n    if(growCapacity < 0) {\n      growCapacity = newCapacity;\n    } else if(newCapacity <= US_STACKBUF_SIZE && growCapacity > US_STACKBUF_SIZE) {\n      growCapacity = US_STACKBUF_SIZE;\n    }\n\n    // save old values\n    UChar oldStackBuffer[US_STACKBUF_SIZE];\n    UChar *oldArray;\n    int32_t oldLength = length();\n    int16_t flags = fUnion.fFields.fLengthAndFlags;\n\n    if(flags&kUsingStackBuffer) {\n      U_ASSERT(!(flags&kRefCounted)); /* kRefCounted and kUsingStackBuffer are mutally exclusive */\n      if(doCopyArray && growCapacity > US_STACKBUF_SIZE) {\n        // copy the stack buffer contents because it will be overwritten with\n        // fUnion.fFields values\n        us_arrayCopy(fUnion.fStackFields.fBuffer, 0, oldStackBuffer, 0, oldLength);\n        oldArray = oldStackBuffer;\n      } else {\n        oldArray = NULL; // no need to copy from the stack buffer to itself\n      }\n    } else {\n      oldArray = fUnion.fFields.fArray;\n      U_ASSERT(oldArray!=NULL); /* when stack buffer is not used, oldArray must have a non-NULL reference */\n    }\n\n    // allocate a new array\n    if(allocate(growCapacity) ||\n       (newCapacity < growCapacity && allocate(newCapacity))\n    ) {\n      if(doCopyArray) {\n        // copy the contents\n        // do not copy more than what fits - it may be smaller than before\n        int32_t minLength = oldLength;\n        newCapacity = getCapacity();\n        if(newCapacity < minLength) {\n          minLength = newCapacity;\n        }\n        if(oldArray != NULL) {\n          us_arrayCopy(oldArray, 0, getArrayStart(), 0, minLength);\n        }\n        setLength(minLength);\n      } else {\n        setZeroLength();\n      }\n\n      // release the old array\n      if(flags & kRefCounted) {\n        // the array is refCounted; decrement and release if 0\n        u_atomic_int32_t *pRefCount = ((u_atomic_int32_t *)oldArray - 1);\n        if(umtx_atomic_dec(pRefCount) == 0) {\n          if(pBufferToDelete == 0) {\n              // Note: cast to (void *) is needed with MSVC, where u_atomic_int32_t\n              // is defined as volatile. (Volatile has useful non-standard behavior\n              //   with this compiler.)\n            uprv_free((void *)pRefCount);\n          } else {\n            // the caller requested to delete it himself\n            *pBufferToDelete = (int32_t *)pRefCount;\n          }\n        }\n      }\n    } else {\n      // not enough memory for growCapacity and not even for the smaller newCapacity\n      // reset the old values for setToBogus() to release the array\n      if(!(flags&kUsingStackBuffer)) {\n        fUnion.fFields.fArray = oldArray;\n      }\n      fUnion.fFields.fLengthAndFlags = flags;\n      setToBogus();\n      return FALSE;\n    }\n  }\n  return TRUE;\n}\n\n// UnicodeStringAppendable ------------------------------------------------- ***\n\nUnicodeStringAppendable::~UnicodeStringAppendable() {}\n\nUBool\nUnicodeStringAppendable::appendCodeUnit(UChar c) {\n  return str.doAppend(&c, 0, 1).isWritable();\n}\n\nUBool\nUnicodeStringAppendable::appendCodePoint(UChar32 c) {\n  UChar buffer[U16_MAX_LENGTH];\n  int32_t cLength = 0;\n  UBool isError = FALSE;\n  U16_APPEND(buffer, cLength, U16_MAX_LENGTH, c, isError);\n  return !isError && str.doAppend(buffer, 0, cLength).isWritable();\n}\n\nUBool\nUnicodeStringAppendable::appendString(const UChar *s, int32_t length) {\n  return str.doAppend(s, 0, length).isWritable();\n}\n\nUBool\nUnicodeStringAppendable::reserveAppendCapacity(int32_t appendCapacity) {\n  return str.cloneArrayIfNeeded(str.length() + appendCapacity);\n}\n\nUChar *\nUnicodeStringAppendable::getAppendBuffer(int32_t minCapacity,\n                                         int32_t desiredCapacityHint,\n                                         UChar *scratch, int32_t scratchCapacity,\n                                         int32_t *resultCapacity) {\n  if(minCapacity < 1 || scratchCapacity < minCapacity) {\n    *resultCapacity = 0;\n    return NULL;\n  }\n  int32_t oldLength = str.length();\n  if(minCapacity <= (kMaxCapacity - oldLength) &&\n      desiredCapacityHint <= (kMaxCapacity - oldLength) &&\n      str.cloneArrayIfNeeded(oldLength + minCapacity, oldLength + desiredCapacityHint)) {\n    *resultCapacity = str.getCapacity() - oldLength;\n    return str.getArrayStart() + oldLength;\n  }\n  *resultCapacity = scratchCapacity;\n  return scratch;\n}\n\nU_NAMESPACE_END\n\nU_NAMESPACE_USE\n\nU_CAPI int32_t U_EXPORT2\nuhash_hashUnicodeString(const UElement key) {\n    const UnicodeString *str = (const UnicodeString*) key.pointer;\n    return (str == NULL) ? 0 : str->hashCode();\n}\n\n// Moved here from uhash_us.cpp so that using a UVector of UnicodeString*\n// does not depend on hashtable code.\nU_CAPI UBool U_EXPORT2\nuhash_compareUnicodeString(const UElement key1, const UElement key2) {\n    const UnicodeString *str1 = (const UnicodeString*) key1.pointer;\n    const UnicodeString *str2 = (const UnicodeString*) key2.pointer;\n    if (str1 == str2) {\n        return TRUE;\n    }\n    if (str1 == NULL || str2 == NULL) {\n        return FALSE;\n    }\n    return *str1 == *str2;\n}\n\n#ifdef U_STATIC_IMPLEMENTATION\n/*\nThis should never be called. It is defined here to make sure that the\nvirtual vector deleting destructor is defined within unistr.cpp.\nThe vector deleting destructor is already a part of UObject,\nbut defining it here makes sure that it is included with this object file.\nThis makes sure that static library dependencies are kept to a minimum.\n*/\nstatic void uprv_UnicodeStringDummy(void) {\n    delete [] (new UnicodeString[2]);\n}\n#endif\n", "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/********************************************************************\n * COPYRIGHT: \n * Copyright (c) 1997-2016, International Business Machines Corporation and\n * others. All Rights Reserved.\n ********************************************************************/\n\n#include <utility>\n\n#include \"ustrtest.h\"\n#include \"unicode/appendable.h\"\n#include \"unicode/std_string.h\"\n#include \"unicode/unistr.h\"\n#include \"unicode/uchar.h\"\n#include \"unicode/ustring.h\"\n#include \"unicode/locid.h\"\n#include \"unicode/strenum.h\"\n#include \"unicode/ucnv.h\"\n#include \"unicode/uenum.h\"\n#include \"unicode/utf16.h\"\n#include \"cmemory.h\"\n#include \"charstr.h\"\n\n#if 0\n#include \"unicode/ustream.h\"\n\n#include <iostream>\nusing namespace std;\n\n#endif\n\nUnicodeStringTest::~UnicodeStringTest() {}\n\nextern IntlTest *createStringCaseTest();\n\nvoid UnicodeStringTest::runIndexedTest( int32_t index, UBool exec, const char* &name, char *par)\n{\n    if (exec) logln(\"TestSuite UnicodeStringTest: \");\n    TESTCASE_AUTO_BEGIN;\n    TESTCASE_AUTO_CREATE_CLASS(StringCaseTest);\n    TESTCASE_AUTO(TestBasicManipulation);\n    TESTCASE_AUTO(TestCompare);\n    TESTCASE_AUTO(TestExtract);\n    TESTCASE_AUTO(TestRemoveReplace);\n    TESTCASE_AUTO(TestSearching);\n    TESTCASE_AUTO(TestSpacePadding);\n    TESTCASE_AUTO(TestPrefixAndSuffix);\n    TESTCASE_AUTO(TestFindAndReplace);\n    TESTCASE_AUTO(TestBogus);\n    TESTCASE_AUTO(TestReverse);\n    TESTCASE_AUTO(TestMiscellaneous);\n    TESTCASE_AUTO(TestStackAllocation);\n    TESTCASE_AUTO(TestUnescape);\n    TESTCASE_AUTO(TestCountChar32);\n    TESTCASE_AUTO(TestStringEnumeration);\n    TESTCASE_AUTO(TestNameSpace);\n    TESTCASE_AUTO(TestUTF32);\n    TESTCASE_AUTO(TestUTF8);\n    TESTCASE_AUTO(TestReadOnlyAlias);\n    TESTCASE_AUTO(TestAppendable);\n    TESTCASE_AUTO(TestUnicodeStringImplementsAppendable);\n    TESTCASE_AUTO(TestSizeofUnicodeString);\n    TESTCASE_AUTO(TestStartsWithAndEndsWithNulTerminated);\n    TESTCASE_AUTO(TestMoveSwap);\n    TESTCASE_AUTO(TestUInt16Pointers);\n    TESTCASE_AUTO(TestWCharPointers);\n    TESTCASE_AUTO(TestNullPointers);\n    TESTCASE_AUTO(TestUnicodeStringInsertAppendToSelf);\n    TESTCASE_AUTO(TestLargeAppend);\n    TESTCASE_AUTO_END;\n}\n\nvoid\nUnicodeStringTest::TestBasicManipulation()\n{\n    UnicodeString   test1(\"Now is the time for all men to come swiftly to the aid of the party.\\n\");\n    UnicodeString   expectedValue;\n    UnicodeString   *c;\n\n    c=test1.clone();\n    test1.insert(24, \"good \");\n    expectedValue = \"Now is the time for all good men to come swiftly to the aid of the party.\\n\";\n    if (test1 != expectedValue)\n        errln(\"insert() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + test1 + \"\\\"\");\n\n    c->insert(24, \"good \");\n    if(*c != expectedValue) {\n        errln(\"clone()->insert() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + *c + \"\\\"\");\n    }\n    delete c;\n\n    test1.remove(41, 8);\n    expectedValue = \"Now is the time for all good men to come to the aid of the party.\\n\";\n    if (test1 != expectedValue)\n        errln(\"remove() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + test1 + \"\\\"\");\n    \n    test1.replace(58, 6, \"ir country\");\n    expectedValue = \"Now is the time for all good men to come to the aid of their country.\\n\";\n    if (test1 != expectedValue)\n        errln(\"replace() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + test1 + \"\\\"\");\n    \n    UChar     temp[80];\n    test1.extract(0, 15, temp);\n    \n    UnicodeString       test2(temp, 15);\n    \n    expectedValue = \"Now is the time\";\n    if (test2 != expectedValue)\n        errln(\"extract() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + test2 + \"\\\"\");\n    \n    test2 += \" for me to go!\\n\";\n    expectedValue = \"Now is the time for me to go!\\n\";\n    if (test2 != expectedValue)\n        errln(\"operator+=() failed:  expected \\\"\" + expectedValue + \"\\\"\\n,got \\\"\" + test2 + \"\\\"\");\n    \n    if (test1.length() != 70)\n        errln(UnicodeString(\"length() failed: expected 70, got \") + test1.length());\n    if (test2.length() != 30)\n        errln(UnicodeString(\"length() failed: expected 30, got \") + test2.length());\n\n    UnicodeString test3;\n    test3.append((UChar32)0x20402);\n    if(test3 != CharsToUnicodeString(\"\\\\uD841\\\\uDC02\")){\n        errln((UnicodeString)\"append failed for UChar32, expected \\\"\\\\\\\\ud841\\\\\\\\udc02\\\", got \" + prettify(test3));\n    }\n    if(test3.length() != 2){\n        errln(UnicodeString(\"append or length failed for UChar32, expected 2, got \") + test3.length());\n    }\n    test3.append((UChar32)0x0074);\n    if(test3 != CharsToUnicodeString(\"\\\\uD841\\\\uDC02t\")){\n        errln((UnicodeString)\"append failed for UChar32, expected \\\"\\\\\\\\uD841\\\\\\\\uDC02t\\\", got \" + prettify(test3));\n    }\n    if(test3.length() != 3){\n        errln((UnicodeString)\"append or length failed for UChar32, expected 2, got \" + test3.length());\n    }\n\n    // test some UChar32 overloads\n    if( test3.setTo((UChar32)0x10330).length() != 2 ||\n        test3.insert(0, (UChar32)0x20100).length() != 4 ||\n        test3.replace(2, 2, (UChar32)0xe0061).length() != 4 ||\n        (test3 = (UChar32)0x14001).length() != 2\n    ) {\n        errln((UnicodeString)\"simple UChar32 overloads for replace, insert, setTo or = failed\");\n    }\n\n    {\n        // test moveIndex32()\n        UnicodeString s=UNICODE_STRING(\"\\\\U0002f999\\\\U0001d15f\\\\u00c4\\\\u1ed0\", 32).unescape();\n\n        if(\n            s.moveIndex32(2, -1)!=0 ||\n            s.moveIndex32(2, 1)!=4 ||\n            s.moveIndex32(2, 2)!=5 ||\n            s.moveIndex32(5, -2)!=2 ||\n            s.moveIndex32(0, -1)!=0 ||\n            s.moveIndex32(6, 1)!=6\n        ) {\n            errln(\"UnicodeString::moveIndex32() failed\");\n        }\n\n        if(s.getChar32Start(1)!=0 || s.getChar32Start(2)!=2) {\n            errln(\"UnicodeString::getChar32Start() failed\");\n        }\n\n        if(s.getChar32Limit(1)!=2 || s.getChar32Limit(2)!=2) {\n            errln(\"UnicodeString::getChar32Limit() failed\");\n        }\n    }\n\n    {\n        // test new 2.2 constructors and setTo function that parallel Java's substring function.\n        UnicodeString src(\"Hello folks how are you?\");\n        UnicodeString target1(\"how are you?\");\n        if (target1 != UnicodeString(src, 12)) {\n            errln(\"UnicodeString(const UnicodeString&, int32_t) failed\");\n        }\n        UnicodeString target2(\"folks\");\n        if (target2 != UnicodeString(src, 6, 5)) {\n            errln(\"UnicodeString(const UnicodeString&, int32_t, int32_t) failed\");\n        }\n        if (target1 != target2.setTo(src, 12)) {\n            errln(\"UnicodeString::setTo(const UnicodeString&, int32_t) failed\");\n        }\n    }\n\n    {\n        // op+ is new in ICU 2.8\n        UnicodeString s=UnicodeString(\"abc\", \"\")+UnicodeString(\"def\", \"\")+UnicodeString(\"ghi\", \"\");\n        if(s!=UnicodeString(\"abcdefghi\", \"\")) {\n            errln(\"operator+(UniStr, UniStr) failed\");\n        }\n    }\n\n    {\n        // tests for Jitterbug 2360\n        // verify that APIs with source pointer + length accept length == -1\n        // mostly test only where modified, only few functions did not already do this\n        if(UnicodeString(\"abc\", -1, \"\")!=UnicodeString(\"abc\", \"\")) {\n            errln(\"UnicodeString(codepageData, dataLength, codepage) does not work with dataLength==-1\");\n        }\n\n        UChar buffer[10]={ 0x61, 0x62, 0x20ac, 0xd900, 0xdc05, 0,   0x62, 0xffff, 0xdbff, 0xdfff };\n        UnicodeString s, t(buffer, -1, UPRV_LENGTHOF(buffer));\n\n        if(s.setTo(buffer, -1, UPRV_LENGTHOF(buffer)).length()!=u_strlen(buffer)) {\n            errln(\"UnicodeString.setTo(buffer, length, capacity) does not work with length==-1\");\n        }\n        if(t.length()!=u_strlen(buffer)) {\n            errln(\"UnicodeString(buffer, length, capacity) does not work with length==-1\");\n        }\n\n        if(0!=s.caseCompare(buffer, -1, U_FOLD_CASE_DEFAULT)) {\n            errln(\"UnicodeString.caseCompare(const UChar *, length, options) does not work with length==-1\");\n        }\n        if(0!=s.caseCompare(0, s.length(), buffer, U_FOLD_CASE_DEFAULT)) {\n            errln(\"UnicodeString.caseCompare(start, _length, const UChar *, options) does not work\");\n        }\n\n        buffer[u_strlen(buffer)]=0xe4;\n        UnicodeString u(buffer, -1, UPRV_LENGTHOF(buffer));\n        if(s.setTo(buffer, -1, UPRV_LENGTHOF(buffer)).length()!=UPRV_LENGTHOF(buffer)) {\n            errln(\"UnicodeString.setTo(buffer without NUL, length, capacity) does not work with length==-1\");\n        }\n        if(u.length()!=UPRV_LENGTHOF(buffer)) {\n            errln(\"UnicodeString(buffer without NUL, length, capacity) does not work with length==-1\");\n        }\n\n        static const char cs[]={ 0x61, (char)0xe4, (char)0x85, 0 };\n        UConverter *cnv;\n        UErrorCode errorCode=U_ZERO_ERROR;\n\n        cnv=ucnv_open(\"ISO-8859-1\", &errorCode);\n        UnicodeString v(cs, -1, cnv, errorCode);\n        ucnv_close(cnv);\n        if(v!=CharsToUnicodeString(\"a\\\\xe4\\\\x85\")) {\n            errln(\"UnicodeString(const char *, length, cnv, errorCode) does not work with length==-1\");\n        }\n    }\n\n#if U_CHARSET_IS_UTF8\n    {\n        // Test the hardcoded-UTF-8 UnicodeString optimizations.\n        static const uint8_t utf8[]={ 0x61, 0xC3, 0xA4, 0xC3, 0x9F, 0xE4, 0xB8, 0x80, 0 };\n        static const UChar utf16[]={ 0x61, 0xE4, 0xDF, 0x4E00 };\n        UnicodeString from8a = UnicodeString((const char *)utf8);\n        UnicodeString from8b = UnicodeString((const char *)utf8, (int32_t)sizeof(utf8)-1);\n        UnicodeString from16(FALSE, utf16, UPRV_LENGTHOF(utf16));\n        if(from8a != from16 || from8b != from16) {\n            errln(\"UnicodeString(const char * U_CHARSET_IS_UTF8) failed\");\n        }\n        char buffer[16];\n        int32_t length8=from16.extract(0, 0x7fffffff, buffer, (uint32_t)sizeof(buffer));\n        if(length8!=((int32_t)sizeof(utf8)-1) || 0!=uprv_memcmp(buffer, utf8, sizeof(utf8))) {\n            errln(\"UnicodeString::extract(char * U_CHARSET_IS_UTF8) failed\");\n        }\n        length8=from16.extract(1, 2, buffer, (uint32_t)sizeof(buffer));\n        if(length8!=4 || buffer[length8]!=0 || 0!=uprv_memcmp(buffer, utf8+1, length8)) {\n            errln(\"UnicodeString::extract(substring to char * U_CHARSET_IS_UTF8) failed\");\n        }\n    }\n#endif\n}\n\nvoid\nUnicodeStringTest::TestCompare()\n{\n    UnicodeString   test1(\"this is a test\");\n    UnicodeString   test2(\"this is a test\");\n    UnicodeString   test3(\"this is a test of the emergency broadcast system\");\n    UnicodeString   test4(\"never say, \\\"this is a test\\\"!!\");\n\n    UnicodeString   test5((UChar)0x5000);\n    UnicodeString   test6((UChar)0x5100);\n\n    UChar         uniChars[] = { 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, \n                 0x20, 0x61, 0x20, 0x74, 0x65, 0x73, 0x74, 0 };\n    char            chars[] = \"this is a test\";\n\n    // test operator== and operator!=\n    if (test1 != test2 || test1 == test3 || test1 == test4)\n        errln(\"operator== or operator!= failed\");\n\n    // test operator> and operator<\n    if (test1 > test2 || test1 < test2 || !(test1 < test3) || !(test1 > test4) ||\n        !(test5 < test6)\n    ) {\n        errln(\"operator> or operator< failed\");\n    }\n\n    // test operator>= and operator<=\n    if (!(test1 >= test2) || !(test1 <= test2) || !(test1 <= test3) || !(test1 >= test4))\n        errln(\"operator>= or operator<= failed\");\n\n    // test compare(UnicodeString)\n    if (test1.compare(test2) != 0 || test1.compare(test3) >= 0 || test1.compare(test4) <= 0)\n        errln(\"compare(UnicodeString) failed\");\n\n    //test compare(offset, length, UnicodeString)\n    if(test1.compare(0, 14, test2) != 0 ||\n        test3.compare(0, 14, test2) != 0 ||\n        test4.compare(12, 14, test2) != 0 ||\n        test3.compare(0, 18, test1) <=0  )\n        errln(\"compare(offset, length, UnicodeString) failes\");\n\n    // test compare(UChar*)\n    if (test2.compare(uniChars) != 0 || test3.compare(uniChars) <= 0 || test4.compare(uniChars) >= 0)\n        errln(\"compare(UChar*) failed\");\n\n    // test compare(char*)\n    if (test2.compare(chars) != 0 || test3.compare(chars) <= 0 || test4.compare(chars) >= 0)\n        errln(\"compare(char*) failed\");\n\n    // test compare(UChar*, length)\n    if (test1.compare(uniChars, 4) <= 0 || test1.compare(uniChars, 4) <= 0)\n        errln(\"compare(UChar*, length) failed\");\n\n    // test compare(thisOffset, thisLength, that, thatOffset, thatLength)\n    if (test1.compare(0, 14, test2, 0, 14) != 0 \n    || test1.compare(0, 14, test3, 0, 14) != 0\n    || test1.compare(0, 14, test4, 12, 14) != 0)\n        errln(\"1. compare(thisOffset, thisLength, that, thatOffset, thatLength) failed\");\n\n    if (test1.compare(10, 4, test2, 0, 4) >= 0 \n    || test1.compare(10, 4, test3, 22, 9) <= 0\n    || test1.compare(10, 4, test4, 22, 4) != 0)\n        errln(\"2. compare(thisOffset, thisLength, that, thatOffset, thatLength) failed\");\n\n    // test compareBetween\n    if (test1.compareBetween(0, 14, test2, 0, 14) != 0 || test1.compareBetween(0, 14, test3, 0, 14) != 0\n                    || test1.compareBetween(0, 14, test4, 12, 26) != 0)\n        errln(\"compareBetween failed\");\n\n    if (test1.compareBetween(10, 14, test2, 0, 4) >= 0 || test1.compareBetween(10, 14, test3, 22, 31) <= 0\n                    || test1.compareBetween(10, 14, test4, 22, 26) != 0)\n        errln(\"compareBetween failed\");\n\n    // test compare() etc. with strings that share a buffer but are not equal\n    test2=test1; // share the buffer, length() too large for the stackBuffer\n    test2.truncate(1); // change only the length, not the buffer\n    if( test1==test2 || test1<=test2 ||\n        test1.compare(test2)<=0 ||\n        test1.compareCodePointOrder(test2)<=0 ||\n        test1.compareCodePointOrder(0, INT32_MAX, test2)<=0 ||\n        test1.compareCodePointOrder(0, INT32_MAX, test2, 0, INT32_MAX)<=0 ||\n        test1.compareCodePointOrderBetween(0, INT32_MAX, test2, 0, INT32_MAX)<=0 ||\n        test1.caseCompare(test2, U_FOLD_CASE_DEFAULT)<=0\n    ) {\n        errln(\"UnicodeStrings that share a buffer but have different lengths compare as equal\");\n    }\n\n    /* test compareCodePointOrder() */\n    {\n        /* these strings are in ascending order */\n        static const UChar strings[][4]={\n            { 0x61, 0 },                    /* U+0061 */\n            { 0x20ac, 0xd801, 0 },          /* U+20ac U+d801 */\n            { 0x20ac, 0xd800, 0xdc00, 0 },  /* U+20ac U+10000 */\n            { 0xd800, 0 },                  /* U+d800 */\n            { 0xd800, 0xff61, 0 },          /* U+d800 U+ff61 */\n            { 0xdfff, 0 },                  /* U+dfff */\n            { 0xff61, 0xdfff, 0 },          /* U+ff61 U+dfff */\n            { 0xff61, 0xd800, 0xdc02, 0 },  /* U+ff61 U+10002 */\n            { 0xd800, 0xdc02, 0 },          /* U+10002 */\n            { 0xd84d, 0xdc56, 0 }           /* U+23456 */\n        };\n        UnicodeString u[20]; // must be at least as long as strings[]\n        int32_t i;\n\n        for(i=0; i<UPRV_LENGTHOF(strings); ++i) {\n            u[i]=UnicodeString(TRUE, strings[i], -1);\n        }\n\n        for(i=0; i<UPRV_LENGTHOF(strings)-1; ++i) {\n            if(u[i].compareCodePointOrder(u[i+1])>=0 || u[i].compareCodePointOrder(0, INT32_MAX, u[i+1].getBuffer())>=0) {\n                errln(\"error: UnicodeString::compareCodePointOrder() fails for string %d and the following one\\n\", i);\n            }\n        }\n    }\n\n    /* test caseCompare() */\n    {\n        static const UChar\n        _mixed[]=               { 0x61, 0x42, 0x131, 0x3a3, 0xdf,       0x130,       0x49,  0xfb03,           0xd93f, 0xdfff, 0 },\n        _otherDefault[]=        { 0x41, 0x62, 0x131, 0x3c3, 0x73, 0x53, 0x69, 0x307, 0x69,  0x46, 0x66, 0x49, 0xd93f, 0xdfff, 0 },\n        _otherExcludeSpecialI[]={ 0x41, 0x62, 0x131, 0x3c3, 0x53, 0x73, 0x69,        0x131, 0x66, 0x46, 0x69, 0xd93f, 0xdfff, 0 },\n        _different[]=           { 0x41, 0x62, 0x131, 0x3c3, 0x73, 0x53, 0x130,       0x49,  0x46, 0x66, 0x49, 0xd93f, 0xdffd, 0 };\n\n        UnicodeString\n            mixed(TRUE, _mixed, -1),\n            otherDefault(TRUE, _otherDefault, -1),\n            otherExcludeSpecialI(TRUE, _otherExcludeSpecialI, -1),\n            different(TRUE, _different, -1);\n\n        int8_t result;\n\n        /* test caseCompare() */\n        result=mixed.caseCompare(otherDefault, U_FOLD_CASE_DEFAULT);\n        if(result!=0 || 0!=mixed.caseCompareBetween(0, INT32_MAX, otherDefault, 0, INT32_MAX, U_FOLD_CASE_DEFAULT)) {\n            errln(\"error: mixed.caseCompare(other, default)=%ld instead of 0\\n\", result);\n        }\n        result=mixed.caseCompare(otherExcludeSpecialI, U_FOLD_CASE_EXCLUDE_SPECIAL_I);\n        if(result!=0) {\n            errln(\"error: mixed.caseCompare(otherExcludeSpecialI, U_FOLD_CASE_EXCLUDE_SPECIAL_I)=%ld instead of 0\\n\", result);\n        }\n        result=mixed.caseCompare(otherDefault, U_FOLD_CASE_EXCLUDE_SPECIAL_I);\n        if(result==0 || 0==mixed.caseCompareBetween(0, INT32_MAX, otherDefault, 0, INT32_MAX, U_FOLD_CASE_EXCLUDE_SPECIAL_I)) {\n            errln(\"error: mixed.caseCompare(other, U_FOLD_CASE_EXCLUDE_SPECIAL_I)=0 instead of !=0\\n\");\n        }\n\n        /* test caseCompare() */\n        result=mixed.caseCompare(different, U_FOLD_CASE_DEFAULT);\n        if(result<=0) {\n            errln(\"error: mixed.caseCompare(different, default)=%ld instead of positive\\n\", result);\n        }\n\n        /* test caseCompare() - include the folded sharp s (U+00df) with different lengths */\n        result=mixed.caseCompare(1, 4, different, 1, 5, U_FOLD_CASE_DEFAULT);\n        if(result!=0 || 0!=mixed.caseCompareBetween(1, 5, different, 1, 6, U_FOLD_CASE_DEFAULT)) {\n            errln(\"error: mixed.caseCompare(mixed, 1, 4, different, 1, 5, default)=%ld instead of 0\\n\", result);\n        }\n\n        /* test caseCompare() - stop in the middle of the sharp s (U+00df) */\n        result=mixed.caseCompare(1, 4, different, 1, 4, U_FOLD_CASE_DEFAULT);\n        if(result<=0) {\n            errln(\"error: mixed.caseCompare(1, 4, different, 1, 4, default)=%ld instead of positive\\n\", result);\n        }\n    }\n\n    // test that srcLength=-1 is handled in functions that\n    // take input const UChar */int32_t srcLength (j785)\n    {\n        static const UChar u[]={ 0x61, 0x308, 0x62, 0 };\n        UnicodeString s=UNICODE_STRING(\"a\\\\u0308b\", 8).unescape();\n\n        if(s.compare(u, -1)!=0 || s.compare(0, 999, u, 0, -1)!=0) {\n            errln(\"error UnicodeString::compare(..., const UChar *, srcLength=-1) does not work\");\n        }\n\n        if(s.compareCodePointOrder(u, -1)!=0 || s.compareCodePointOrder(0, 999, u, 0, -1)!=0) {\n            errln(\"error UnicodeString::compareCodePointOrder(..., const UChar *, srcLength=-1, ...) does not work\");\n        }\n\n        if(s.caseCompare(u, -1, U_FOLD_CASE_DEFAULT)!=0 || s.caseCompare(0, 999, u, 0, -1, U_FOLD_CASE_DEFAULT)!=0) {\n            errln(\"error UnicodeString::caseCompare(..., const UChar *, srcLength=-1, ...) does not work\");\n        }\n\n        if(s.indexOf(u, 1, -1, 0, 999)!=1 || s.indexOf(u+1, -1, 0, 999)!=1 || s.indexOf(u+1, -1, 0)!=1) {\n            errln(\"error UnicodeString::indexOf(const UChar *, srcLength=-1, ...) does not work\");\n        }\n\n        if(s.lastIndexOf(u, 1, -1, 0, 999)!=1 || s.lastIndexOf(u+1, -1, 0, 999)!=1 || s.lastIndexOf(u+1, -1, 0)!=1) {\n            errln(\"error UnicodeString::lastIndexOf(const UChar *, srcLength=-1, ...) does not work\");\n        }\n\n        UnicodeString s2, s3;\n        s2.replace(0, 0, u+1, -1);\n        s3.replace(0, 0, u, 1, -1);\n        if(s.compare(1, 999, s2)!=0 || s2!=s3) {\n            errln(\"error UnicodeString::replace(..., const UChar *, srcLength=-1, ...) does not work\");\n        }\n    }\n}\n\nvoid\nUnicodeStringTest::TestExtract()\n{\n    UnicodeString  test1(\"Now is the time for all good men to come to the aid of their country.\", \"\");\n    UnicodeString  test2;\n    UChar          test3[13] = {1, 2, 3, 4, 5, 6, 7, 8, 8, 10, 11, 12, 13};\n    char           test4[13] = {1, 2, 3, 4, 5, 6, 7, 8, 8, 10, 11, 12, 13};\n    UnicodeString  test5;\n    char           test6[13] = {1, 2, 3, 4, 5, 6, 7, 8, 8, 10, 11, 12, 13};\n\n    test1.extract(11, 12, test2);\n    test1.extract(11, 12, test3);\n    if (test1.extract(11, 12, test4) != 12 || test4[12] != 0) {\n        errln(\"UnicodeString.extract(char *) failed to return the correct size of destination buffer.\");\n    }\n\n    // test proper pinning in extractBetween()\n    test1.extractBetween(-3, 7, test5);\n    if(test5!=UNICODE_STRING(\"Now is \", 7)) {\n        errln(\"UnicodeString.extractBetween(-3, 7) did not pin properly.\");\n    }\n\n    test1.extractBetween(11, 23, test5);\n    if (test1.extract(60, 71, test6) != 9) {\n        errln(\"UnicodeString.extract() failed to return the correct size of destination buffer for end of buffer.\");\n    }\n    if (test1.extract(11, 12, test6) != 12) {\n        errln(\"UnicodeString.extract() failed to return the correct size of destination buffer.\");\n    }\n\n    // convert test4 back to Unicode for comparison\n    UnicodeString test4b(test4, 12);\n\n    if (test1.extract(11, 12, (char *)NULL) != 12) {\n        errln(\"UnicodeString.extract(NULL) failed to return the correct size of destination buffer.\");\n    }\n    if (test1.extract(11, -1, test6) != 0) {\n        errln(\"UnicodeString.extract(-1) failed to stop reading the string.\");\n    }\n\n    for (int32_t i = 0; i < 12; i++) {\n        if (test1.charAt((int32_t)(11 + i)) != test2.charAt(i)) {\n            errln(UnicodeString(\"extracting into a UnicodeString failed at position \") + i);\n            break;\n        }\n        if (test1.charAt((int32_t)(11 + i)) != test3[i]) {\n            errln(UnicodeString(\"extracting into an array of UChar failed at position \") + i);\n            break;\n        }\n        if (((char)test1.charAt((int32_t)(11 + i))) != test4b.charAt(i)) {\n            errln(UnicodeString(\"extracting into an array of char failed at position \") + i);\n            break;\n        }\n        if (test1.charAt((int32_t)(11 + i)) != test5.charAt(i)) {\n            errln(UnicodeString(\"extracting with extractBetween failed at position \") + i);\n            break;\n        }\n    }\n\n    // test preflighting and overflows with invariant conversion\n    if (test1.extract(0, 10, (char *)NULL, \"\") != 10) {\n        errln(\"UnicodeString.extract(0, 10, (char *)NULL, \\\"\\\") != 10\");\n    }\n\n    test4[2] = (char)0xff;\n    if (test1.extract(0, 10, test4, 2, \"\") != 10) {\n        errln(\"UnicodeString.extract(0, 10, test4, 2, \\\"\\\") != 10\");\n    }\n    if (test4[2] != (char)0xff) {\n        errln(\"UnicodeString.extract(0, 10, test4, 2, \\\"\\\") overwrote test4[2]\");\n    }\n\n    {\n        // test new, NUL-terminating extract() function\n        UnicodeString s(\"terminate\", \"\");\n        UChar dest[20]={\n            0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5,\n            0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5, 0xa5\n        };\n        UErrorCode errorCode;\n        int32_t length;\n\n        errorCode=U_ZERO_ERROR;\n        length=s.extract((UChar *)NULL, 0, errorCode);\n        if(errorCode!=U_BUFFER_OVERFLOW_ERROR || length!=s.length()) {\n            errln(\"UnicodeString.extract(NULL, 0)==%d (%s) expected %d (U_BUFFER_OVERFLOW_ERROR)\", length, s.length(), u_errorName(errorCode));\n        }\n\n        errorCode=U_ZERO_ERROR;\n        length=s.extract(dest, s.length()-1, errorCode);\n        if(errorCode!=U_BUFFER_OVERFLOW_ERROR || length!=s.length()) {\n            errln(\"UnicodeString.extract(dest too short)==%d (%s) expected %d (U_BUFFER_OVERFLOW_ERROR)\",\n                length, u_errorName(errorCode), s.length());\n        }\n\n        errorCode=U_ZERO_ERROR;\n        length=s.extract(dest, s.length(), errorCode);\n        if(errorCode!=U_STRING_NOT_TERMINATED_WARNING || length!=s.length()) {\n            errln(\"UnicodeString.extract(dest just right without NUL)==%d (%s) expected %d (U_STRING_NOT_TERMINATED_WARNING)\",\n                length, u_errorName(errorCode), s.length());\n        }\n        if(dest[length-1]!=s[length-1] || dest[length]!=0xa5) {\n            errln(\"UnicodeString.extract(dest just right without NUL) did not extract the string correctly\");\n        }\n\n        errorCode=U_ZERO_ERROR;\n        length=s.extract(dest, s.length()+1, errorCode);\n        if(errorCode!=U_ZERO_ERROR || length!=s.length()) {\n            errln(\"UnicodeString.extract(dest large enough)==%d (%s) expected %d (U_ZERO_ERROR)\",\n                length, u_errorName(errorCode), s.length());\n        }\n        if(dest[length-1]!=s[length-1] || dest[length]!=0 || dest[length+1]!=0xa5) {\n            errln(\"UnicodeString.extract(dest large enough) did not extract the string correctly\");\n        }\n    }\n\n    {\n        // test new UConverter extract() and constructor\n        UnicodeString s=UNICODE_STRING(\"\\\\U0002f999\\\\U0001d15f\\\\u00c4\\\\u1ed0\", 32).unescape();\n        char buffer[32];\n        static const char expect[]={\n            (char)0xf0, (char)0xaf, (char)0xa6, (char)0x99,\n            (char)0xf0, (char)0x9d, (char)0x85, (char)0x9f,\n            (char)0xc3, (char)0x84,\n            (char)0xe1, (char)0xbb, (char)0x90\n        };\n        UErrorCode errorCode=U_ZERO_ERROR;\n        UConverter *cnv=ucnv_open(\"UTF-8\", &errorCode);\n        int32_t length;\n\n        if(U_SUCCESS(errorCode)) {\n            // test preflighting\n            if( (length=s.extract(NULL, 0, cnv, errorCode))!=13 ||\n                errorCode!=U_BUFFER_OVERFLOW_ERROR\n            ) {\n                errln(\"UnicodeString::extract(NULL, UConverter) preflighting failed (length=%ld, %s)\",\n                      length, u_errorName(errorCode));\n            }\n            errorCode=U_ZERO_ERROR;\n            if( (length=s.extract(buffer, 2, cnv, errorCode))!=13 ||\n                errorCode!=U_BUFFER_OVERFLOW_ERROR\n            ) {\n                errln(\"UnicodeString::extract(too small, UConverter) preflighting failed (length=%ld, %s)\",\n                      length, u_errorName(errorCode));\n            }\n\n            // try error cases\n            errorCode=U_ZERO_ERROR;\n            if( s.extract(NULL, 2, cnv, errorCode)==13 || U_SUCCESS(errorCode)) {\n                errln(\"UnicodeString::extract(UConverter) succeeded with an illegal destination\");\n            }\n            errorCode=U_ILLEGAL_ARGUMENT_ERROR;\n            if( s.extract(NULL, 0, cnv, errorCode)==13 || U_SUCCESS(errorCode)) {\n                errln(\"UnicodeString::extract(UConverter) succeeded with a previous error code\");\n            }\n            errorCode=U_ZERO_ERROR;\n\n            // extract for real\n            if( (length=s.extract(buffer, sizeof(buffer), cnv, errorCode))!=13 ||\n                uprv_memcmp(buffer, expect, 13)!=0 ||\n                buffer[13]!=0 ||\n                U_FAILURE(errorCode)\n            ) {\n                errln(\"UnicodeString::extract(UConverter) conversion failed (length=%ld, %s)\",\n                      length, u_errorName(errorCode));\n            }\n            // Test again with just the converter name.\n            if( (length=s.extract(0, s.length(), buffer, sizeof(buffer), \"UTF-8\"))!=13 ||\n                uprv_memcmp(buffer, expect, 13)!=0 ||\n                buffer[13]!=0 ||\n                U_FAILURE(errorCode)\n            ) {\n                errln(\"UnicodeString::extract(\\\"UTF-8\\\") conversion failed (length=%ld, %s)\",\n                      length, u_errorName(errorCode));\n            }\n\n            // try the constructor\n            UnicodeString t(expect, sizeof(expect), cnv, errorCode);\n            if(U_FAILURE(errorCode) || s!=t) {\n                errln(\"UnicodeString(UConverter) conversion failed (%s)\",\n                      u_errorName(errorCode));\n            }\n\n            ucnv_close(cnv);\n        }\n    }\n}\n\nvoid\nUnicodeStringTest::TestRemoveReplace()\n{\n    UnicodeString   test1(\"The rain in Spain stays mainly on the plain\");\n    UnicodeString   test2(\"eat SPAMburgers!\");\n    UChar         test3[] = { 0x53, 0x50, 0x41, 0x4d, 0x4d, 0 };\n    char            test4[] = \"SPAM\";\n    UnicodeString&  test5 = test1;\n\n    test1.replace(4, 4, test2, 4, 4);\n    test1.replace(12, 5, test3, 4);\n    test3[4] = 0;\n    test1.replace(17, 4, test3);\n    test1.replace(23, 4, test4);\n    test1.replaceBetween(37, 42, test2, 4, 8);\n\n    if (test1 != \"The SPAM in SPAM SPAMs SPAMly on the SPAM\")\n        errln(\"One of the replace methods failed:\\n\"\n              \"  expected \\\"The SPAM in SPAM SPAMs SPAMly on the SPAM\\\",\\n\"\n              \"  got \\\"\" + test1 + \"\\\"\");\n\n    test1.remove(21, 1);\n    test1.removeBetween(26, 28);\n\n    if (test1 != \"The SPAM in SPAM SPAM SPAM on the SPAM\")\n        errln(\"One of the remove methods failed:\\n\"\n              \"  expected \\\"The SPAM in SPAM SPAM SPAM on the SPAM\\\",\\n\"\n              \"  got \\\"\" + test1 + \"\\\"\");\n\n    for (int32_t i = 0; i < test1.length(); i++) {\n        if (test5[i] != 0x53 && test5[i] != 0x50 && test5[i] != 0x41 && test5[i] != 0x4d && test5[i] != 0x20) {\n            test1.setCharAt(i, 0x78);\n        }\n    }\n\n    if (test1 != \"xxx SPAM xx SPAM SPAM SPAM xx xxx SPAM\")\n        errln(\"One of the remove methods failed:\\n\"\n              \"  expected \\\"xxx SPAM xx SPAM SPAM SPAM xx xxx SPAM\\\",\\n\"\n              \"  got \\\"\" + test1 + \"\\\"\");\n\n    test1.remove();\n    if (test1.length() != 0)\n        errln(\"Remove() failed: expected empty string, got \\\"\" + test1 + \"\\\"\");\n}\n\nvoid\nUnicodeStringTest::TestSearching()\n{\n    UnicodeString test1(\"test test ttest tetest testesteststt\");\n    UnicodeString test2(\"test\");\n    UChar testChar = 0x74;\n    \n    UChar32 testChar32 = 0x20402;\n    UChar testData[]={\n        //   0       1       2       3       4       5       6       7\n        0xd841, 0xdc02, 0x0071, 0xdc02, 0xd841, 0x0071, 0xd841, 0xdc02,\n\n        //   8       9      10      11      12      13      14      15\n        0x0071, 0x0072, 0xd841, 0xdc02, 0x0071, 0xd841, 0xdc02, 0x0071,\n\n        //  16      17      18      19\n        0xdc02, 0xd841, 0x0073, 0x0000\n    };\n    UnicodeString test3(testData);\n    UnicodeString test4(testChar32);\n\n    uint16_t occurrences = 0;\n    int32_t startPos = 0;\n    for ( ;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(test2, startPos)) != -1 ? (++occurrences, startPos += 4) : 0)\n        ;\n    if (occurrences != 6)\n        errln(UnicodeString(\"indexOf failed: expected to find 6 occurrences, found \") + occurrences);\n\n    for ( occurrences = 0, startPos = 10;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(test2, startPos)) != -1 ? (++occurrences, startPos += 4) : 0)\n        ;\n    if (occurrences != 4)\n        errln(UnicodeString(\"indexOf with starting offset failed: \"\n                            \"expected to find 4 occurrences, found \") + occurrences);\n\n    int32_t endPos = 28;\n    for ( occurrences = 0, startPos = 5;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(test2, startPos, endPos - startPos)) != -1 ? (++occurrences, startPos += 4) : 0)\n        ;\n    if (occurrences != 4)\n        errln(UnicodeString(\"indexOf with starting and ending offsets failed: \"\n                            \"expected to find 4 occurrences, found \") + occurrences);\n\n    //using UChar32 string\n    for ( startPos=0, occurrences=0;\n          startPos != -1 && startPos < test3.length();\n          (startPos = test3.indexOf(test4, startPos)) != -1 ? (++occurrences, startPos += 2) : 0)\n        ;\n    if (occurrences != 4)\n        errln((UnicodeString)\"indexOf failed: expected to find 4 occurrences, found \" + occurrences);\n\n    for ( startPos=10, occurrences=0;\n          startPos != -1 && startPos < test3.length();\n          (startPos = test3.indexOf(test4, startPos)) != -1 ? (++occurrences, startPos += 2) : 0)\n        ;\n    if (occurrences != 2)\n        errln(UnicodeString(\"indexOf failed: expected to find 2 occurrences, found \") + occurrences);\n    //---\n\n    for ( occurrences = 0, startPos = 0;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(testChar, startPos)) != -1 ? (++occurrences, startPos += 1) : 0)\n        ;\n    if (occurrences != 16)\n        errln(UnicodeString(\"indexOf with character failed: \"\n                            \"expected to find 16 occurrences, found \") + occurrences);\n\n    for ( occurrences = 0, startPos = 10;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(testChar, startPos)) != -1 ? (++occurrences, startPos += 1) : 0)\n        ;\n    if (occurrences != 12)\n        errln(UnicodeString(\"indexOf with character & start offset failed: \"\n                            \"expected to find 12 occurrences, found \") + occurrences);\n\n    for ( occurrences = 0, startPos = 5, endPos = 28;\n          startPos != -1 && startPos < test1.length();\n          (startPos = test1.indexOf(testChar, startPos, endPos - startPos)) != -1 ? (++occurrences, startPos += 1) : 0)\n        ;\n    if (occurrences != 10)\n        errln(UnicodeString(\"indexOf with character & start & end offsets failed: \"\n                            \"expected to find 10 occurrences, found \") + occurrences);\n\n    //testing for UChar32\n    UnicodeString subString;\n    for( occurrences =0, startPos=0; startPos < test3.length(); startPos +=1){\n        subString.append(test3, startPos, test3.length());\n        if(subString.indexOf(testChar32) != -1 ){\n             ++occurrences;\n        }\n        subString.remove();\n    }\n    if (occurrences != 14)\n        errln((UnicodeString)\"indexOf failed: expected to find 14 occurrences, found \" + occurrences);\n\n    for ( occurrences = 0, startPos = 0;\n          startPos != -1 && startPos < test3.length();\n          (startPos = test3.indexOf(testChar32, startPos)) != -1 ? (++occurrences, startPos += 1) : 0)\n        ;\n    if (occurrences != 4)\n        errln((UnicodeString)\"indexOf failed: expected to find 4 occurrences, found \" + occurrences);\n     \n    endPos=test3.length();\n    for ( occurrences = 0, startPos = 5;\n          startPos != -1 && startPos < test3.length();\n          (startPos = test3.indexOf(testChar32, startPos, endPos - startPos)) != -1 ? (++occurrences, startPos += 1) : 0)\n        ;\n    if (occurrences != 3)\n        errln((UnicodeString)\"indexOf with character & start & end offsets failed: expected to find 2 occurrences, found \" + occurrences);\n    //---\n\n    if(test1.lastIndexOf(test2)!=29) {\n        errln(\"test1.lastIndexOf(test2)!=29\");\n    }\n\n    if(test1.lastIndexOf(test2, 15)!=29 || test1.lastIndexOf(test2, 29)!=29 || test1.lastIndexOf(test2, 30)!=-1) {\n        errln(\"test1.lastIndexOf(test2, start) failed\");\n    }\n\n    for ( occurrences = 0, startPos = 32;\n          startPos != -1;\n          (startPos = test1.lastIndexOf(test2, 5, startPos - 5)) != -1 ? ++occurrences : 0)\n        ;\n    if (occurrences != 4)\n        errln(UnicodeString(\"lastIndexOf with starting and ending offsets failed: \"\n                            \"expected to find 4 occurrences, found \") + occurrences);\n\n    for ( occurrences = 0, startPos = 32;\n          startPos != -1;\n          (startPos = test1.lastIndexOf(testChar, 5, startPos - 5)) != -1 ? ++occurrences : 0)\n        ;\n    if (occurrences != 11)\n        errln(UnicodeString(\"lastIndexOf with character & start & end offsets failed: \"\n                            \"expected to find 11 occurrences, found \") + occurrences);\n\n    //testing UChar32\n    startPos=test3.length();\n    for ( occurrences = 0;\n          startPos != -1;\n          (startPos = test3.lastIndexOf(testChar32, 5, startPos - 5)) != -1 ? ++occurrences : 0)\n        ;\n    if (occurrences != 3)\n        errln((UnicodeString)\"lastIndexOf with character & start & end offsets failed: expected to find 3 occurrences, found \" + occurrences);\n\n\n    for ( occurrences = 0, endPos = test3.length();  endPos > 0; endPos -= 1){\n        subString.remove();\n        subString.append(test3, 0, endPos);\n        if(subString.lastIndexOf(testChar32) != -1 ){\n            ++occurrences;\n        }\n    }\n    if (occurrences != 18)\n        errln((UnicodeString)\"indexOf failed: expected to find 18 occurrences, found \" + occurrences);\n    //---\n\n    // test that indexOf(UChar32) and lastIndexOf(UChar32)\n    // do not find surrogate code points when they are part of matched pairs\n    // (= part of supplementary code points)\n    // Jitterbug 1542\n    if(test3.indexOf((UChar32)0xd841) != 4 || test3.indexOf((UChar32)0xdc02) != 3) {\n        errln(\"error: UnicodeString::indexOf(UChar32 surrogate) finds a partial supplementary code point\");\n    }\n    if( UnicodeString(test3, 0, 17).lastIndexOf((UChar)0xd841, 0) != 4 ||\n        UnicodeString(test3, 0, 17).lastIndexOf((UChar32)0xd841, 2) != 4 ||\n        test3.lastIndexOf((UChar32)0xd841, 0, 17) != 4 || test3.lastIndexOf((UChar32)0xdc02, 0, 17) != 16\n    ) {\n        errln(\"error: UnicodeString::lastIndexOf(UChar32 surrogate) finds a partial supplementary code point\");\n    }\n}\n\nvoid\nUnicodeStringTest::TestSpacePadding()\n{\n    UnicodeString test1(\"hello\");\n    UnicodeString test2(\"   there\");\n    UnicodeString test3(\"Hi!  How ya doin'?  Beautiful day, isn't it?\");\n    UnicodeString test4;\n    UBool returnVal;\n    UnicodeString expectedValue;\n\n    returnVal = test1.padLeading(15);\n    expectedValue = \"          hello\";\n    if (returnVal == FALSE || test1 != expectedValue)\n        errln(\"padLeading() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test1 + \"\\\".\");\n\n    returnVal = test2.padTrailing(15);\n    expectedValue = \"   there       \";\n    if (returnVal == FALSE || test2 != expectedValue)\n        errln(\"padTrailing() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test2 + \"\\\".\");\n\n    expectedValue = test3;\n    returnVal = test3.padTrailing(15);\n    if (returnVal == TRUE || test3 != expectedValue)\n        errln(\"padTrailing() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test3 + \"\\\".\");\n\n    expectedValue = \"hello\";\n    test4.setTo(test1).trim();\n\n    if (test4 != expectedValue || test1 == expectedValue || test4 != expectedValue)\n        errln(\"trim(UnicodeString&) failed\");\n    \n    test1.trim();\n    if (test1 != expectedValue)\n        errln(\"trim() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test1 + \"\\\".\");\n\n    test2.trim();\n    expectedValue = \"there\";\n    if (test2 != expectedValue)\n        errln(\"trim() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test2 + \"\\\".\");\n\n    test3.trim();\n    expectedValue = \"Hi!  How ya doin'?  Beautiful day, isn't it?\";\n    if (test3 != expectedValue)\n        errln(\"trim() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test3 + \"\\\".\");\n\n    returnVal = test1.truncate(15);\n    expectedValue = \"hello\";\n    if (returnVal == TRUE || test1 != expectedValue)\n        errln(\"truncate() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test1 + \"\\\".\");\n\n    returnVal = test2.truncate(15);\n    expectedValue = \"there\";\n    if (returnVal == TRUE || test2 != expectedValue)\n        errln(\"truncate() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test2 + \"\\\".\");\n\n    returnVal = test3.truncate(15);\n    expectedValue = \"Hi!  How ya doi\";\n    if (returnVal == FALSE || test3 != expectedValue)\n        errln(\"truncate() failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test3 + \"\\\".\");\n}\n\nvoid\nUnicodeStringTest::TestPrefixAndSuffix()\n{\n    UnicodeString test1(\"Now is the time for all good men to come to the aid of their country.\");\n    UnicodeString test2(\"Now\");\n    UnicodeString test3(\"country.\");\n    UnicodeString test4(\"count\");\n\n    if (!test1.startsWith(test2) || !test1.startsWith(test2, 0, test2.length())) {\n        errln(\"startsWith() failed: \\\"\" + test2 + \"\\\" should be a prefix of \\\"\" + test1 + \"\\\".\");\n    }\n\n    if (test1.startsWith(test3) ||\n        test1.startsWith(test3.getBuffer(), test3.length()) ||\n        test1.startsWith(test3.getTerminatedBuffer(), 0, -1)\n    ) {\n        errln(\"startsWith() failed: \\\"\" + test3 + \"\\\" shouldn't be a prefix of \\\"\" + test1 + \"\\\".\");\n    }\n\n    if (test1.endsWith(test2)) {\n        errln(\"endsWith() failed: \\\"\" + test2 + \"\\\" shouldn't be a suffix of \\\"\" + test1 + \"\\\".\");\n    }\n\n    if (!test1.endsWith(test3)) { \n        errln(\"endsWith(test3) failed: \\\"\" + test3 + \"\\\" should be a suffix of \\\"\" + test1 + \"\\\".\");\n    }\n    if (!test1.endsWith(test3, 0, INT32_MAX)) {\n        errln(\"endsWith(test3, 0, INT32_MAX) failed: \\\"\" + test3 + \"\\\" should be a suffix of \\\"\" + test1 + \"\\\".\");\n    }\n\n    if(!test1.endsWith(test3.getBuffer(), test3.length())) {\n        errln(\"endsWith(test3.getBuffer(), test3.length()) failed: \\\"\" + test3 + \"\\\" should be a suffix of \\\"\" + test1 + \"\\\".\");\n    }\n    if(!test1.endsWith(test3.getTerminatedBuffer(), 0, -1)) {\n        errln(\"endsWith(test3.getTerminatedBuffer(), 0, -1) failed: \\\"\" + test3 + \"\\\" should be a suffix of \\\"\" + test1 + \"\\\".\");\n    }\n\n    if (!test3.startsWith(test4)) {\n        errln(\"endsWith(test4) failed: \\\"\" + test4 + \"\\\" should be a prefix of \\\"\" + test3 + \"\\\".\");\n    }\n\n    if (test4.startsWith(test3)) {\n        errln(\"startsWith(test3) failed: \\\"\" + test3 + \"\\\" shouldn't be a prefix of \\\"\" + test4 + \"\\\".\");\n    }\n}\n\nvoid\nUnicodeStringTest::TestStartsWithAndEndsWithNulTerminated() {\n    UnicodeString test(\"abcde\");\n    const UChar ab[] = { 0x61, 0x62, 0 };\n    const UChar de[] = { 0x64, 0x65, 0 };\n    assertTrue(\"abcde.startsWith(ab, -1)\", test.startsWith(ab, -1));\n    assertTrue(\"abcde.startsWith(ab, 0, -1)\", test.startsWith(ab, 0, -1));\n    assertTrue(\"abcde.endsWith(de, -1)\", test.endsWith(de, -1));\n    assertTrue(\"abcde.endsWith(de, 0, -1)\", test.endsWith(de, 0, -1));\n}\n\nvoid\nUnicodeStringTest::TestFindAndReplace()\n{\n    UnicodeString test1(\"One potato, two potato, three potato, four\\n\");\n    UnicodeString test2(\"potato\");\n    UnicodeString test3(\"MISSISSIPPI\");\n\n    UnicodeString expectedValue;\n\n    test1.findAndReplace(test2, test3);\n    expectedValue = \"One MISSISSIPPI, two MISSISSIPPI, three MISSISSIPPI, four\\n\";\n    if (test1 != expectedValue)\n        errln(\"findAndReplace failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test1 + \"\\\".\");\n    test1.findAndReplace(2, 32, test3, test2);\n    expectedValue = \"One potato, two potato, three MISSISSIPPI, four\\n\";\n    if (test1 != expectedValue)\n        errln(\"findAndReplace failed: expected \\\"\" + expectedValue + \"\\\", got \\\"\" + test1 + \"\\\".\");\n}\n\nvoid\nUnicodeStringTest::TestReverse()\n{\n    UnicodeString test(\"backwards words say to used I\");\n\n    test.reverse();\n    test.reverse(2, 4);\n    test.reverse(7, 2);\n    test.reverse(10, 3);\n    test.reverse(14, 5);\n    test.reverse(20, 9);\n\n    if (test != \"I used to say words backwards\")\n        errln(\"reverse() failed:  Expected \\\"I used to say words backwards\\\",\\n got \\\"\"\n            + test + \"\\\"\");\n\n    test=UNICODE_STRING(\"\\\\U0002f999\\\\U0001d15f\\\\u00c4\\\\u1ed0\", 32).unescape();\n    test.reverse();\n    if(test.char32At(0)!=0x1ed0 || test.char32At(1)!=0xc4 || test.char32At(2)!=0x1d15f || test.char32At(4)!=0x2f999) {\n        errln(\"reverse() failed with supplementary characters\");\n    }\n\n    // Test case for ticket #8091:\n    // UnicodeString::reverse() failed to see a lead surrogate in the middle of\n    // an odd-length string that contains no other lead surrogates.\n    test=UNICODE_STRING_SIMPLE(\"ab\\\\U0001F4A9e\").unescape();\n    UnicodeString expected=UNICODE_STRING_SIMPLE(\"e\\\\U0001F4A9ba\").unescape();\n    test.reverse();\n    if(test!=expected) {\n        errln(\"reverse() failed with only lead surrogate in the middle\");\n    }\n}\n\nvoid\nUnicodeStringTest::TestMiscellaneous()\n{\n    UnicodeString   test1(\"This is a test\");\n    UnicodeString   test2(\"This is a test\");\n    UnicodeString   test3(\"Me too!\");\n\n    // test getBuffer(minCapacity) and releaseBuffer()\n    test1=UnicodeString(); // make sure that it starts with its stackBuffer\n    UChar *p=test1.getBuffer(20);\n    if(test1.getCapacity()<20) {\n        errln(\"UnicodeString::getBuffer(20).getCapacity()<20\");\n    }\n\n    test1.append((UChar)7); // must not be able to modify the string here\n    test1.setCharAt(3, 7);\n    test1.reverse();\n    if( test1.length()!=0 ||\n        test1.charAt(0)!=0xffff || test1.charAt(3)!=0xffff ||\n        test1.getBuffer(10)!=0 || test1.getBuffer()!=0\n    ) {\n        errln(\"UnicodeString::getBuffer(minCapacity) allows read or write access to the UnicodeString\");\n    }\n\n    p[0]=1;\n    p[1]=2;\n    p[2]=3;\n    test1.releaseBuffer(3);\n    test1.append((UChar)4);\n\n    if(test1.length()!=4 || test1.charAt(0)!=1 || test1.charAt(1)!=2 || test1.charAt(2)!=3 || test1.charAt(3)!=4) {\n        errln(\"UnicodeString::releaseBuffer(newLength) does not properly reallow access to the UnicodeString\");\n    }\n\n    // test releaseBuffer() without getBuffer(minCapacity) - must not have any effect\n    test1.releaseBuffer(1);\n    if(test1.length()!=4 || test1.charAt(0)!=1 || test1.charAt(1)!=2 || test1.charAt(2)!=3 || test1.charAt(3)!=4) {\n        errln(\"UnicodeString::releaseBuffer(newLength) without getBuffer(minCapacity) changed the UnicodeString\");\n    }\n\n    // test getBuffer(const)\n    const UChar *q=test1.getBuffer(), *r=test1.getBuffer();\n    if( test1.length()!=4 ||\n        q[0]!=1 || q[1]!=2 || q[2]!=3 || q[3]!=4 ||\n        r[0]!=1 || r[1]!=2 || r[2]!=3 || r[3]!=4\n    ) {\n        errln(\"UnicodeString::getBuffer(const) does not return a usable buffer pointer\");\n    }\n\n    // test releaseBuffer() with a NUL-terminated buffer\n    test1.getBuffer(20)[2]=0;\n    test1.releaseBuffer(); // implicit -1\n    if(test1.length()!=2 || test1.charAt(0)!=1 || test1.charAt(1) !=2) {\n        errln(\"UnicodeString::releaseBuffer(-1) does not properly set the length of the UnicodeString\");\n    }\n\n    // test releaseBuffer() with a non-NUL-terminated buffer\n    p=test1.getBuffer(256);\n    for(int32_t i=0; i<test1.getCapacity(); ++i) {\n        p[i]=(UChar)1;      // fill the buffer with all non-NUL code units\n    }\n    test1.releaseBuffer();  // implicit -1\n    if(test1.length()!=test1.getCapacity() || test1.charAt(1)!=1 || test1.charAt(100)!=1 || test1.charAt(test1.getCapacity()-1)!=1) {\n        errln(\"UnicodeString::releaseBuffer(-1 but no NUL) does not properly set the length of the UnicodeString\");\n    }\n\n    // test getTerminatedBuffer()\n    test1=UnicodeString(\"This is another test.\", \"\");\n    test2=UnicodeString(\"This is another test.\", \"\");\n    q=test1.getTerminatedBuffer();\n    if(q[test1.length()]!=0 || test1!=test2 || test2.compare(q, -1)!=0) {\n        errln(\"getTerminatedBuffer()[length]!=0\");\n    }\n\n    const UChar u[]={ 5, 6, 7, 8, 0 };\n    test1.setTo(FALSE, u, 3);\n    q=test1.getTerminatedBuffer();\n    if(q==u || q[0]!=5 || q[1]!=6 || q[2]!=7 || q[3]!=0) {\n        errln(\"UnicodeString(u[3]).getTerminatedBuffer() returns a bad buffer\");\n    }\n\n    test1.setTo(TRUE, u, -1);\n    q=test1.getTerminatedBuffer();\n    if(q!=u || test1.length()!=4 || q[3]!=8 || q[4]!=0) {\n        errln(\"UnicodeString(u[-1]).getTerminatedBuffer() returns a bad buffer\");\n    }\n\n    // NOTE: Some compilers will optimize u\"la\" to point to the same static memory\n    // as u\" lila\", offset by 3 code units\n    test1=UnicodeString(TRUE, u\"la\", 2);\n    test1.append(UnicodeString(TRUE, u\" lila\", 5).getTerminatedBuffer(), 0, -1);\n    assertEquals(\"UnicodeString::append(const UChar *, start, length) failed\",\n        u\"la lila\", test1);\n\n    test1.insert(3, UnicodeString(TRUE, u\"dudum \", 6), 0, INT32_MAX);\n    assertEquals(\"UnicodeString::insert(start, const UniStr &, start, length) failed\",\n        u\"la dudum lila\", test1);\n\n    static const UChar ucs[]={ 0x68, 0x6d, 0x20, 0 };\n    test1.insert(9, ucs, -1);\n    assertEquals(\"UnicodeString::insert(start, const UChar *, length) failed\",\n        u\"la dudum hm lila\", test1);\n\n    test1.replace(9, 2, (UChar)0x2b);\n    assertEquals(\"UnicodeString::replace(start, length, UChar) failed\",\n        u\"la dudum + lila\", test1);\n\n    if(test1.hasMetaData() || UnicodeString().hasMetaData()) {\n        errln(\"UnicodeString::hasMetaData() returns TRUE\");\n    }\n\n    // test getTerminatedBuffer() on a truncated, shared, heap-allocated string\n    test1=UNICODE_STRING_SIMPLE(\"abcdefghijklmnopqrstuvwxyz0123456789.\");\n    test1.truncate(36);  // ensure length()<getCapacity()\n    test2=test1;  // share the buffer\n    test1.truncate(5);\n    if(test1.length()!=5 || test1.getTerminatedBuffer()[5]!=0) {\n        errln(\"UnicodeString(shared buffer).truncate() failed\");\n    }\n    if(test2.length()!=36 || test2[5]!=0x66 || u_strlen(test2.getTerminatedBuffer())!=36) {\n        errln(\"UnicodeString(shared buffer).truncate().getTerminatedBuffer() \"\n              \"modified another copy of the string!\");\n    }\n    test1=UNICODE_STRING_SIMPLE(\"abcdefghijklmnopqrstuvwxyz0123456789.\");\n    test1.truncate(36);  // ensure length()<getCapacity()\n    test2=test1;  // share the buffer\n    test1.remove();\n    if(test1.length()!=0 || test1.getTerminatedBuffer()[0]!=0) {\n        errln(\"UnicodeString(shared buffer).remove() failed\");\n    }\n    if(test2.length()!=36 || test2[0]!=0x61 || u_strlen(test2.getTerminatedBuffer())!=36) {\n        errln(\"UnicodeString(shared buffer).remove().getTerminatedBuffer() \"\n              \"modified another copy of the string!\");\n    }\n\n    // ticket #9740\n    test1.setTo(TRUE, ucs, 3);\n    assertEquals(\"length of read-only alias\", 3, test1.length());\n    test1.trim();\n    assertEquals(\"length of read-only alias after trim()\", 2, test1.length());\n    assertEquals(\"length of terminated buffer of read-only alias + trim()\",\n                 2, u_strlen(test1.getTerminatedBuffer()));\n}\n\nvoid\nUnicodeStringTest::TestStackAllocation()\n{\n    UChar           testString[] ={ \n        0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x61, 0x20, 0x63, 0x72, 0x61, 0x7a, 0x79, 0x20, 0x74, 0x65, 0x73, 0x74, 0x2e, 0 };\n    UChar           guardWord = 0x4DED;\n    UnicodeString*  test = 0;\n\n    test = new  UnicodeString(testString);\n    if (*test != \"This is a crazy test.\")\n        errln(\"Test string failed to initialize properly.\");\n    if (guardWord != 0x04DED)\n        errln(\"Test string initialization overwrote guard word!\");\n\n    test->insert(8, \"only \");\n    test->remove(15, 6);\n    if (*test != \"This is only a test.\")\n        errln(\"Manipulation of test string failed to work right.\");\n    if (guardWord != 0x4DED)\n        errln(\"Manipulation of test string overwrote guard word!\");\n\n    // we have to deinitialize and release the backing store by calling the destructor\n    // explicitly, since we can't overload operator delete\n    delete test;\n\n    UChar workingBuffer[] = {\n        0x4e, 0x6f, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x20, 0x74, 0x69, 0x6d, 0x65, 0x20,\n        0x66, 0x6f, 0x72, 0x20, 0x61, 0x6c, 0x6c, 0x20, 0x6d, 0x65, 0x6e, 0x20, 0x74, 0x6f, 0x20,\n        0x63, 0x6f, 0x6d, 0x65, 0xffff, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n    UChar guardWord2 = 0x4DED;\n\n    test = new UnicodeString(workingBuffer, 35, 100);\n    if (*test != \"Now is the time for all men to come\")\n        errln(\"Stack-allocated backing store failed to initialize correctly.\");\n    if (guardWord2 != 0x4DED)\n        errln(\"Stack-allocated backing store overwrote guard word!\");\n\n    test->insert(24, \"good \");\n    if (*test != \"Now is the time for all good men to come\")\n        errln(\"insert() on stack-allocated UnicodeString didn't work right\");\n    if (guardWord2 != 0x4DED)\n        errln(\"insert() on stack-allocated UnicodeString overwrote guard word!\");\n\n    if (workingBuffer[24] != 0x67)\n        errln(\"insert() on stack-allocated UnicodeString didn't affect backing store\");\n\n    *test += \" to the aid of their country.\";\n    if (*test != \"Now is the time for all good men to come to the aid of their country.\")\n        errln(\"Stack-allocated UnicodeString overflow didn't work\");\n    if (guardWord2 != 0x4DED)\n        errln(\"Stack-allocated UnicodeString overflow overwrote guard word!\");\n\n    *test = \"ha!\";\n    if (*test != \"ha!\")\n        errln(\"Assignment to stack-allocated UnicodeString didn't work\");\n    if (workingBuffer[0] != 0x4e)\n        errln(\"Change to UnicodeString after overflow are still affecting original buffer\");\n    if (guardWord2 != 0x4DED)\n        errln(\"Change to UnicodeString after overflow overwrote guard word!\");\n\n    // test read-only aliasing with setTo()\n    workingBuffer[0] = 0x20ac;\n    workingBuffer[1] = 0x125;\n    workingBuffer[2] = 0;\n    test->setTo(TRUE, workingBuffer, 2);\n    if(test->length() != 2 || test->charAt(0) != 0x20ac || test->charAt(1) != 0x125) {\n        errln(\"UnicodeString.setTo(readonly alias) does not alias correctly\");\n    }\n\n    UnicodeString *c=test->clone();\n\n    workingBuffer[1] = 0x109;\n    if(test->charAt(1) != 0x109) {\n        errln(\"UnicodeString.setTo(readonly alias) made a copy: did not see change in buffer\");\n    }\n\n    if(c->length() != 2 || c->charAt(1) != 0x125) {\n        errln(\"clone(alias) did not copy the buffer\");\n    }\n    delete c;\n\n    test->setTo(TRUE, workingBuffer, -1);\n    if(test->length() != 2 || test->charAt(0) != 0x20ac || test->charAt(1) != 0x109) {\n        errln(\"UnicodeString.setTo(readonly alias, length -1) does not alias correctly\");\n    }\n\n    test->setTo(FALSE, workingBuffer, -1);\n    if(!test->isBogus()) {\n        errln(\"UnicodeString.setTo(unterminated readonly alias, length -1) does not result in isBogus()\");\n    }\n    \n    delete test;\n     \n    test=new UnicodeString();\n    UChar buffer[]={0x0061, 0x0062, 0x20ac, 0x0043, 0x0042, 0x0000};\n    test->setTo(buffer, 4, 10);\n    if(test->length() !=4 || test->charAt(0) != 0x0061 || test->charAt(1) != 0x0062 ||\n        test->charAt(2) != 0x20ac || test->charAt(3) != 0x0043){\n        errln((UnicodeString)\"UnicodeString.setTo(UChar*, length, capacity) does not work correctly\\n\" + prettify(*test));\n    }\n    delete test;\n\n\n    // test the UChar32 constructor\n    UnicodeString c32Test((UChar32)0x10ff2a);\n    if( c32Test.length() != U16_LENGTH(0x10ff2a) ||\n        c32Test.char32At(c32Test.length() - 1) != 0x10ff2a\n    ) {\n        errln(\"The UnicodeString(UChar32) constructor does not work with a 0x10ff2a filler\");\n    }\n\n    // test the (new) capacity constructor\n    UnicodeString capTest(5, (UChar32)0x2a, 5);\n    if( capTest.length() != 5 * U16_LENGTH(0x2a) ||\n        capTest.char32At(0) != 0x2a ||\n        capTest.char32At(4) != 0x2a\n    ) {\n        errln(\"The UnicodeString capacity constructor does not work with an ASCII filler\");\n    }\n\n    capTest = UnicodeString(5, (UChar32)0x10ff2a, 5);\n    if( capTest.length() != 5 * U16_LENGTH(0x10ff2a) ||\n        capTest.char32At(0) != 0x10ff2a ||\n        capTest.char32At(4) != 0x10ff2a\n    ) {\n        errln(\"The UnicodeString capacity constructor does not work with a 0x10ff2a filler\");\n    }\n\n    capTest = UnicodeString(5, (UChar32)0, 0);\n    if(capTest.length() != 0) {\n        errln(\"The UnicodeString capacity constructor does not work with a 0x10ff2a filler\");\n    }\n}\n\n/**\n * Test the unescape() function.\n */\nvoid UnicodeStringTest::TestUnescape(void) {\n    UnicodeString IN(\"abc\\\\u4567 \\\\n\\\\r \\\\U00101234xyz\\\\x1\\\\x{5289}\\\\x1b\", -1, US_INV);\n    UnicodeString OUT(\"abc\");\n    OUT.append((UChar)0x4567);\n    OUT.append(\" \");\n    OUT.append((UChar)0xA);\n    OUT.append((UChar)0xD);\n    OUT.append(\" \");\n    OUT.append((UChar32)0x00101234);\n    OUT.append(\"xyz\");\n    OUT.append((UChar32)1).append((UChar32)0x5289).append((UChar)0x1b);\n    UnicodeString result = IN.unescape();\n    if (result != OUT) {\n        errln(\"FAIL: \" + prettify(IN) + \".unescape() -> \" +\n              prettify(result) + \", expected \" +\n              prettify(OUT));\n    }\n\n    // test that an empty string is returned in case of an error\n    if (!UNICODE_STRING(\"wrong \\\\u sequence\", 17).unescape().isEmpty()) {\n        errln(\"FAIL: unescaping of a string with an illegal escape sequence did not return an empty string\");\n    }\n}\n\n/* test code point counting functions --------------------------------------- */\n\n/* reference implementation of UnicodeString::hasMoreChar32Than() */\nstatic int32_t\n_refUnicodeStringHasMoreChar32Than(const UnicodeString &s, int32_t start, int32_t length, int32_t number) {\n    int32_t count=s.countChar32(start, length);\n    return count>number;\n}\n\n/* compare the real function against the reference */\nvoid\nUnicodeStringTest::_testUnicodeStringHasMoreChar32Than(const UnicodeString &s, int32_t start, int32_t length, int32_t number) {\n    if(s.hasMoreChar32Than(start, length, number)!=_refUnicodeStringHasMoreChar32Than(s, start, length, number)) {\n        errln(\"hasMoreChar32Than(%d, %d, %d)=%hd is wrong\\n\",\n                start, length, number, s.hasMoreChar32Than(start, length, number));\n    }\n}\n\nvoid\nUnicodeStringTest::TestCountChar32(void) {\n    {\n        UnicodeString s=UNICODE_STRING(\"\\\\U0002f999\\\\U0001d15f\\\\u00c4\\\\u1ed0\", 32).unescape();\n\n        // test countChar32()\n        // note that this also calls and tests u_countChar32(length>=0)\n        if(\n            s.countChar32()!=4 ||\n            s.countChar32(1)!=4 ||\n            s.countChar32(2)!=3 ||\n            s.countChar32(2, 3)!=2 ||\n            s.countChar32(2, 0)!=0\n        ) {\n            errln(\"UnicodeString::countChar32() failed\");\n        }\n\n        // NUL-terminate the string buffer and test u_countChar32(length=-1)\n        const UChar *buffer=s.getTerminatedBuffer();\n        if(\n            u_countChar32(buffer, -1)!=4 ||\n            u_countChar32(buffer+1, -1)!=4 ||\n            u_countChar32(buffer+2, -1)!=3 ||\n            u_countChar32(buffer+3, -1)!=3 ||\n            u_countChar32(buffer+4, -1)!=2 ||\n            u_countChar32(buffer+5, -1)!=1 ||\n            u_countChar32(buffer+6, -1)!=0\n        ) {\n            errln(\"u_countChar32(length=-1) failed\");\n        }\n\n        // test u_countChar32() with bad input\n        if(u_countChar32(NULL, 5)!=0 || u_countChar32(buffer, -2)!=0) {\n            errln(\"u_countChar32(bad input) failed (returned non-zero counts)\");\n        }\n    }\n\n    /* test data and variables for hasMoreChar32Than() */\n    static const UChar str[]={\n        0x61, 0x62, 0xd800, 0xdc00,\n        0xd801, 0xdc01, 0x63, 0xd802,\n        0x64, 0xdc03, 0x65, 0x66,\n        0xd804, 0xdc04, 0xd805, 0xdc05,\n        0x67\n    };\n    UnicodeString string(str, UPRV_LENGTHOF(str));\n    int32_t start, length, number;\n\n    /* test hasMoreChar32Than() */\n    for(length=string.length(); length>=0; --length) {\n        for(start=0; start<=length; ++start) {\n            for(number=-1; number<=((length-start)+2); ++number) {\n                _testUnicodeStringHasMoreChar32Than(string, start, length-start, number);\n            }\n        }\n    }\n\n    /* test hasMoreChar32Than() with pinning */\n    for(start=-1; start<=string.length()+1; ++start) {\n        for(number=-1; number<=((string.length()-start)+2); ++number) {\n            _testUnicodeStringHasMoreChar32Than(string, start, 0x7fffffff, number);\n        }\n    }\n\n    /* test hasMoreChar32Than() with a bogus string */\n    string.setToBogus();\n    for(length=-1; length<=1; ++length) {\n        for(start=-1; start<=length; ++start) {\n            for(number=-1; number<=((length-start)+2); ++number) {\n                _testUnicodeStringHasMoreChar32Than(string, start, length-start, number);\n            }\n        }\n    }\n}\n\nvoid\nUnicodeStringTest::TestBogus() {\n    UnicodeString   test1(\"This is a test\");\n    UnicodeString   test2(\"This is a test\");\n    UnicodeString   test3(\"Me too!\");\n\n    // test isBogus() and setToBogus()\n    if (test1.isBogus() || test2.isBogus() || test3.isBogus()) {\n        errln(\"A string returned TRUE for isBogus()!\");\n    }\n\n    // NULL pointers are treated like empty strings\n    // use other illegal arguments to make a bogus string\n    test3.setTo(FALSE, test1.getBuffer(), -2);\n    if(!test3.isBogus()) {\n        errln(\"A bogus string returned FALSE for isBogus()!\");\n    }\n    if (test1.hashCode() != test2.hashCode() || test1.hashCode() == test3.hashCode()) {\n        errln(\"hashCode() failed\");\n    }\n    if(test3.getBuffer()!=0 || test3.getBuffer(20)!=0 || test3.getTerminatedBuffer()!=0) {\n        errln(\"bogus.getBuffer()!=0\");\n    }\n    if (test1.indexOf(test3) != -1) {\n        errln(\"bogus.indexOf() != -1\");\n    }\n    if (test1.lastIndexOf(test3) != -1) {\n        errln(\"bogus.lastIndexOf() != -1\");\n    }\n    if (test1.caseCompare(test3, U_FOLD_CASE_DEFAULT) != 1 || test3.caseCompare(test1, U_FOLD_CASE_DEFAULT) != -1) {\n        errln(\"caseCompare() doesn't work with bogus strings\");\n    }\n    if (test1.compareCodePointOrder(test3) != 1 || test3.compareCodePointOrder(test1) != -1) {\n        errln(\"compareCodePointOrder() doesn't work with bogus strings\");\n    }\n\n    // verify that non-assignment modifications fail and do not revive a bogus string\n    test3.setToBogus();\n    test3.append((UChar)0x61);\n    if(!test3.isBogus() || test3.getBuffer()!=0) {\n        errln(\"bogus.append('a') worked but must not\");\n    }\n\n    test3.setToBogus();\n    test3.findAndReplace(UnicodeString((UChar)0x61), test2);\n    if(!test3.isBogus() || test3.getBuffer()!=0) {\n        errln(\"bogus.findAndReplace() worked but must not\");\n    }\n\n    test3.setToBogus();\n    test3.trim();\n    if(!test3.isBogus() || test3.getBuffer()!=0) {\n        errln(\"bogus.trim() revived bogus but must not\");\n    }\n\n    test3.setToBogus();\n    test3.remove(1);\n    if(!test3.isBogus() || test3.getBuffer()!=0) {\n        errln(\"bogus.remove(1) revived bogus but must not\");\n    }\n\n    test3.setToBogus();\n    if(!test3.setCharAt(0, 0x62).isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.setCharAt(0, 'b') worked but must not\");\n    }\n\n    test3.setToBogus();\n    if(test3.truncate(1) || !test3.isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.truncate(1) revived bogus but must not\");\n    }\n\n    // verify that assignments revive a bogus string\n    test3.setToBogus();\n    if(!test3.isBogus() || (test3=test1).isBogus() || test3!=test1) {\n        errln(\"bogus.operator=() failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.fastCopyFrom(test1).isBogus() || test3!=test1) {\n        errln(\"bogus.fastCopyFrom() failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(test1).isBogus() || test3!=test1) {\n        errln(\"bogus.setTo(UniStr) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(test1, 0).isBogus() || test3!=test1) {\n        errln(\"bogus.setTo(UniStr, 0) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(test1, 0, 0x7fffffff).isBogus() || test3!=test1) {\n        errln(\"bogus.setTo(UniStr, 0, len) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(test1.getBuffer(), test1.length()).isBogus() || test3!=test1) {\n        errln(\"bogus.setTo(const UChar *, len) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo((UChar)0x2028).isBogus() || test3!=UnicodeString((UChar)0x2028)) {\n        errln(\"bogus.setTo(UChar) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo((UChar32)0x1d157).isBogus() || test3!=UnicodeString((UChar32)0x1d157)) {\n        errln(\"bogus.setTo(UChar32) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(FALSE, test1.getBuffer(), test1.length()).isBogus() || test3!=test1) {\n        errln(\"bogus.setTo(readonly alias) failed\");\n    }\n\n    // writable alias to another string's buffer: very bad idea, just convenient for this test\n    test3.setToBogus();\n    if(!test3.isBogus() ||\n            test3.setTo(const_cast<UChar *>(test1.getBuffer()),\n                        test1.length(), test1.getCapacity()).isBogus() ||\n            test3!=test1) {\n        errln(\"bogus.setTo(writable alias) failed\");\n    }\n\n    // verify simple, documented ways to turn a bogus string into an empty one\n    test3.setToBogus();\n    if(!test3.isBogus() || (test3=UnicodeString()).isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.operator=(UnicodeString()) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(UnicodeString()).isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.setTo(UnicodeString()) failed\");\n    }\n\n    test3.setToBogus();\n    if(test3.remove().isBogus() || test3.getBuffer()==0 || !test3.isEmpty()) {\n        errln(\"bogus.remove() failed\");\n    }\n\n    test3.setToBogus();\n    if(test3.remove(0, INT32_MAX).isBogus() || test3.getBuffer()==0 || !test3.isEmpty()) {\n        errln(\"bogus.remove(0, INT32_MAX) failed\");\n    }\n\n    test3.setToBogus();\n    if(test3.truncate(0) || test3.isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.truncate(0) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo((UChar32)-1).isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.setTo((UChar32)-1) failed\");\n    }\n\n    static const UChar nul=0;\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.setTo(&nul, 0).isBogus() || !test3.isEmpty()) {\n        errln(\"bogus.setTo(&nul, 0) failed\");\n    }\n\n    test3.setToBogus();\n    if(!test3.isBogus() || test3.getBuffer()!=0) {\n        errln(\"setToBogus() failed to make a string bogus\");\n    }\n\n    test3.setToBogus();\n    if(test1.isBogus() || !(test1=test3).isBogus()) {\n        errln(\"normal=bogus failed to make the left string bogus\");\n    }\n\n    // test that NULL primitive input string values are treated like\n    // empty strings, not errors (bogus)\n    test2.setTo((UChar32)0x10005);\n    if(test2.insert(1, nullptr, 1).length()!=2) {\n        errln(\"UniStr.insert(...nullptr...) should not modify the string but does\");\n    }\n\n    UErrorCode errorCode=U_ZERO_ERROR;\n    UnicodeString\n        test4((const UChar *)NULL),\n        test5(TRUE, (const UChar *)NULL, 1),\n        test6((UChar *)NULL, 5, 5),\n        test7((const char *)NULL, 3, NULL, errorCode);\n    if(test4.isBogus() || test5.isBogus() || test6.isBogus() || test7.isBogus()) {\n        errln(\"a constructor set to bogus for a NULL input string, should be empty\");\n    }\n\n    test4.setTo(NULL, 3);\n    test5.setTo(TRUE, (const UChar *)NULL, 1);\n    test6.setTo((UChar *)NULL, 5, 5);\n    if(test4.isBogus() || test5.isBogus() || test6.isBogus()) {\n        errln(\"a setTo() set to bogus for a NULL input string, should be empty\");\n    }\n\n    // test that bogus==bogus<any\n    if(test1!=test3 || test1.compare(test3)!=0) {\n        errln(\"bogus==bogus failed\");\n    }\n\n    test2.remove();\n    if(test1>=test2 || !(test2>test1) || test1.compare(test2)>=0 || !(test2.compare(test1)>0)) {\n        errln(\"bogus<empty failed\");\n    }\n}\n\n// StringEnumeration ------------------------------------------------------- ***\n// most of StringEnumeration is tested elsewhere\n// this test improves code coverage\n\nstatic const char *const\ntestEnumStrings[]={\n    \"a\",\n    \"b\",\n    \"c\",\n    \"this is a long string which helps us test some buffer limits\",\n    \"eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee\"\n};\n\nclass TestEnumeration : public StringEnumeration {\npublic:\n    TestEnumeration() : i(0) {}\n\n    virtual int32_t count(UErrorCode& /*status*/) const {\n        return UPRV_LENGTHOF(testEnumStrings);\n    }\n\n    virtual const UnicodeString *snext(UErrorCode &status) {\n        if(U_SUCCESS(status) && i<UPRV_LENGTHOF(testEnumStrings)) {\n            unistr=UnicodeString(testEnumStrings[i++], \"\");\n            return &unistr;\n        }\n\n        return NULL;\n    }\n\n    virtual void reset(UErrorCode& /*status*/) {\n        i=0;\n    }\n\n    static inline UClassID getStaticClassID() {\n        return (UClassID)&fgClassID;\n    }\n    virtual UClassID getDynamicClassID() const {\n        return getStaticClassID();\n    }\n\nprivate:\n    static const char fgClassID;\n\n    int32_t i;\n};\n\nconst char TestEnumeration::fgClassID=0;\n\nvoid\nUnicodeStringTest::TestStringEnumeration() {\n    UnicodeString s;\n    TestEnumeration ten;\n    int32_t i, length;\n    UErrorCode status;\n\n    const UChar *pu;\n    const char *pc;\n\n    // test the next() default implementation and ensureCharsCapacity()\n    for(i=0; i<UPRV_LENGTHOF(testEnumStrings); ++i) {\n        status=U_ZERO_ERROR;\n        pc=ten.next(&length, status);\n        s=UnicodeString(testEnumStrings[i], \"\");\n        if(U_FAILURE(status) || pc==NULL || length!=s.length() || UnicodeString(pc, length, \"\")!=s) {\n            errln(\"StringEnumeration.next(%d) failed\", i);\n        }\n    }\n    status=U_ZERO_ERROR;\n    if(ten.next(&length, status)!=NULL) {\n        errln(\"StringEnumeration.next(done)!=NULL\");\n    }\n\n    // test the unext() default implementation\n    ten.reset(status);\n    for(i=0; i<UPRV_LENGTHOF(testEnumStrings); ++i) {\n        status=U_ZERO_ERROR;\n        pu=ten.unext(&length, status);\n        s=UnicodeString(testEnumStrings[i], \"\");\n        if(U_FAILURE(status) || pu==NULL || length!=s.length() || UnicodeString(TRUE, pu, length)!=s) {\n            errln(\"StringEnumeration.unext(%d) failed\", i);\n        }\n    }\n    status=U_ZERO_ERROR;\n    if(ten.unext(&length, status)!=NULL) {\n        errln(\"StringEnumeration.unext(done)!=NULL\");\n    }\n\n    // test that the default clone() implementation works, and returns NULL\n    if(ten.clone()!=NULL) {\n        errln(\"StringEnumeration.clone()!=NULL\");\n    }\n\n    // test that uenum_openFromStringEnumeration() works\n    // Need a heap allocated string enumeration because it is adopted by the UEnumeration.\n    StringEnumeration *newTen = new TestEnumeration;\n    status=U_ZERO_ERROR;\n    UEnumeration *uten = uenum_openFromStringEnumeration(newTen, &status);\n    if (uten==NULL || U_FAILURE(status)) {\n        errln(\"fail at file %s, line %d, UErrorCode is %s\\n\", __FILE__, __LINE__, u_errorName(status));\n        return;\n    }\n    \n    // test  uenum_next()\n    for(i=0; i<UPRV_LENGTHOF(testEnumStrings); ++i) {\n        status=U_ZERO_ERROR;\n        pc=uenum_next(uten, &length, &status);\n        if(U_FAILURE(status) || pc==NULL || strcmp(pc, testEnumStrings[i]) != 0) {\n            errln(\"File %s, line %d, StringEnumeration.next(%d) failed\", __FILE__, __LINE__, i);\n        }\n    }\n    status=U_ZERO_ERROR;\n    if(uenum_next(uten, &length, &status)!=NULL) {\n        errln(\"File %s, line %d, uenum_next(done)!=NULL\");\n    }\n\n    // test the uenum_unext()\n    uenum_reset(uten, &status);\n    for(i=0; i<UPRV_LENGTHOF(testEnumStrings); ++i) {\n        status=U_ZERO_ERROR;\n        pu=uenum_unext(uten, &length, &status);\n        s=UnicodeString(testEnumStrings[i], \"\");\n        if(U_FAILURE(status) || pu==NULL || length!=s.length() || UnicodeString(TRUE, pu, length)!=s) {\n            errln(\"File %s, Line %d, uenum_unext(%d) failed\", __FILE__, __LINE__, i);\n        }\n    }\n    status=U_ZERO_ERROR;\n    if(uenum_unext(uten, &length, &status)!=NULL) {\n        errln(\"File %s, Line %d, uenum_unext(done)!=NULL\" __FILE__, __LINE__);\n    }\n\n    uenum_close(uten);\n}\n\n/*\n * Namespace test, to make sure that macros like UNICODE_STRING include the\n * namespace qualifier.\n *\n * Define a (bogus) UnicodeString class in another namespace and check for ambiguity.\n */\nnamespace bogus {\n    class UnicodeString {\n    public:\n        enum EInvariant { kInvariant };\n        UnicodeString() : i(1) {}\n        UnicodeString(UBool /*isTerminated*/, const UChar * /*text*/, int32_t textLength) : i(textLength) {(void)i;}\n        UnicodeString(const char * /*src*/, int32_t length, enum EInvariant /*inv*/\n) : i(length) {}\n    private:\n        int32_t i;\n    };\n}\n\nvoid\nUnicodeStringTest::TestNameSpace() {\n    // Provoke name collision unless the UnicodeString macros properly\n    // qualify the icu::UnicodeString class.\n    using namespace bogus;\n\n    // Use all UnicodeString macros from unistr.h.\n    icu::UnicodeString s1=icu::UnicodeString(\"abc\", 3, US_INV);\n    icu::UnicodeString s2=UNICODE_STRING(\"def\", 3);\n    icu::UnicodeString s3=UNICODE_STRING_SIMPLE(\"ghi\");\n\n    // Make sure the compiler does not optimize away instantiation of s1, s2, s3.\n    icu::UnicodeString s4=s1+s2+s3;\n    if(s4.length()!=9) {\n        errln(\"Something wrong with UnicodeString::operator+().\");\n    }\n}\n\nvoid\nUnicodeStringTest::TestUTF32() {\n    // Input string length US_STACKBUF_SIZE to cause overflow of the\n    // initially chosen fStackBuffer due to supplementary characters.\n    static const UChar32 utf32[] = {\n        0x41, 0xd900, 0x61, 0xdc00, -1, 0x110000, 0x5a, 0x50000, 0x7a,\n        0x10000, 0x20000, 0xe0000, 0x10ffff\n    };\n    static const UChar expected_utf16[] = {\n        0x41, 0xfffd, 0x61, 0xfffd, 0xfffd, 0xfffd, 0x5a, 0xd900, 0xdc00, 0x7a,\n        0xd800, 0xdc00, 0xd840, 0xdc00, 0xdb40, 0xdc00, 0xdbff, 0xdfff\n    };\n    UnicodeString from32 = UnicodeString::fromUTF32(utf32, UPRV_LENGTHOF(utf32));\n    UnicodeString expected(FALSE, expected_utf16, UPRV_LENGTHOF(expected_utf16));\n    if(from32 != expected) {\n        errln(\"UnicodeString::fromUTF32() did not create the expected string.\");\n    }\n\n    static const UChar utf16[] = {\n        0x41, 0xd900, 0x61, 0xdc00, 0x5a, 0xd900, 0xdc00, 0x7a, 0xd800, 0xdc00, 0xdbff, 0xdfff\n    };\n    static const UChar32 expected_utf32[] = {\n        0x41, 0xfffd, 0x61, 0xfffd, 0x5a, 0x50000, 0x7a, 0x10000, 0x10ffff\n    };\n    UChar32 result32[16];\n    UErrorCode errorCode = U_ZERO_ERROR;\n    int32_t length32 =\n        UnicodeString(FALSE, utf16, UPRV_LENGTHOF(utf16)).\n        toUTF32(result32, UPRV_LENGTHOF(result32), errorCode);\n    if( length32 != UPRV_LENGTHOF(expected_utf32) ||\n        0 != uprv_memcmp(result32, expected_utf32, length32*4) ||\n        result32[length32] != 0\n    ) {\n        errln(\"UnicodeString::toUTF32() did not create the expected string.\");\n    }\n}\n\nclass TestCheckedArrayByteSink : public CheckedArrayByteSink {\npublic:\n    TestCheckedArrayByteSink(char* outbuf, int32_t capacity)\n            : CheckedArrayByteSink(outbuf, capacity), calledFlush(FALSE) {}\n    virtual void Flush() { calledFlush = TRUE; }\n    UBool calledFlush;\n};\n\nvoid\nUnicodeStringTest::TestUTF8() {\n    static const uint8_t utf8[] = {\n        // Code points:\n        // 0x41, 0xd900,\n        // 0x61, 0xdc00,\n        // 0x110000, 0x5a,\n        // 0x50000, 0x7a,\n        // 0x10000, 0x20000,\n        // 0xe0000, 0x10ffff\n        0x41, 0xed, 0xa4, 0x80,\n        0x61, 0xed, 0xb0, 0x80,\n        0xf4, 0x90, 0x80, 0x80, 0x5a,\n        0xf1, 0x90, 0x80, 0x80, 0x7a,\n        0xf0, 0x90, 0x80, 0x80, 0xf0, 0xa0, 0x80, 0x80,\n        0xf3, 0xa0, 0x80, 0x80, 0xf4, 0x8f, 0xbf, 0xbf\n    };\n    static const UChar expected_utf16[] = {\n        0x41, 0xfffd, 0xfffd, 0xfffd,\n        0x61, 0xfffd, 0xfffd, 0xfffd,\n        0xfffd,  0xfffd, 0xfffd, 0xfffd,0x5a,\n        0xd900, 0xdc00, 0x7a,\n        0xd800, 0xdc00, 0xd840, 0xdc00,\n        0xdb40, 0xdc00, 0xdbff, 0xdfff\n    };\n    UnicodeString from8 = UnicodeString::fromUTF8(StringPiece((const char *)utf8, (int32_t)sizeof(utf8)));\n    UnicodeString expected(FALSE, expected_utf16, UPRV_LENGTHOF(expected_utf16));\n\n    if(from8 != expected) {\n        errln(\"UnicodeString::fromUTF8(StringPiece) did not create the expected string.\");\n    }\n    std::string utf8_string((const char *)utf8, sizeof(utf8));\n    UnicodeString from8b = UnicodeString::fromUTF8(utf8_string);\n    if(from8b != expected) {\n        errln(\"UnicodeString::fromUTF8(std::string) did not create the expected string.\");\n    }\n\n    static const UChar utf16[] = {\n        0x41, 0xd900, 0x61, 0xdc00, 0x5a, 0xd900, 0xdc00, 0x7a, 0xd800, 0xdc00, 0xdbff, 0xdfff\n    };\n    static const uint8_t expected_utf8[] = {\n        0x41, 0xef, 0xbf, 0xbd, 0x61, 0xef, 0xbf, 0xbd, 0x5a, 0xf1, 0x90, 0x80, 0x80, 0x7a,\n        0xf0, 0x90, 0x80, 0x80, 0xf4, 0x8f, 0xbf, 0xbf\n    };\n    UnicodeString us(FALSE, utf16, UPRV_LENGTHOF(utf16));\n\n    char buffer[64];\n    TestCheckedArrayByteSink sink(buffer, (int32_t)sizeof(buffer));\n    us.toUTF8(sink);\n    if( sink.NumberOfBytesWritten() != (int32_t)sizeof(expected_utf8) ||\n        0 != uprv_memcmp(buffer, expected_utf8, sizeof(expected_utf8))\n    ) {\n        errln(\"UnicodeString::toUTF8() did not create the expected string.\");\n    }\n    if(!sink.calledFlush) {\n        errln(\"UnicodeString::toUTF8(sink) did not sink.Flush().\");\n    }\n    // Initial contents for testing that toUTF8String() appends.\n    std::string result8 = \"-->\";\n    std::string expected8 = \"-->\" + std::string((const char *)expected_utf8, sizeof(expected_utf8));\n    // Use the return value just for testing.\n    std::string &result8r = us.toUTF8String(result8);\n    if(result8r != expected8 || &result8r != &result8) {\n        errln(\"UnicodeString::toUTF8String() did not create the expected string.\");\n    }\n}\n\n// Test if this compiler supports Return Value Optimization of unnamed temporary objects.\nstatic UnicodeString wrapUChars(const UChar *uchars) {\n    return UnicodeString(TRUE, uchars, -1);\n}\n\nvoid\nUnicodeStringTest::TestReadOnlyAlias() {\n    UChar uchars[]={ 0x61, 0x62, 0 };\n    UnicodeString alias(TRUE, uchars, 2);\n    if(alias.length()!=2 || alias.getBuffer()!=uchars || alias.getTerminatedBuffer()!=uchars) {\n        errln(\"UnicodeString read-only-aliasing constructor does not behave as expected.\");\n        return;\n    }\n    alias.truncate(1);\n    if(alias.length()!=1 || alias.getBuffer()!=uchars) {\n        errln(\"UnicodeString(read-only-alias).truncate() did not preserve aliasing as expected.\");\n    }\n    if(alias.getTerminatedBuffer()==uchars) {\n        errln(\"UnicodeString(read-only-alias).truncate().getTerminatedBuffer() \"\n              \"did not allocate and copy as expected.\");\n    }\n    if(uchars[1]!=0x62) {\n        errln(\"UnicodeString(read-only-alias).truncate().getTerminatedBuffer() \"\n              \"modified the original buffer.\");\n    }\n    if(1!=u_strlen(alias.getTerminatedBuffer())) {\n        errln(\"UnicodeString(read-only-alias).truncate().getTerminatedBuffer() \"\n              \"does not return a buffer terminated at the proper length.\");\n    }\n\n    alias.setTo(TRUE, uchars, 2);\n    if(alias.length()!=2 || alias.getBuffer()!=uchars || alias.getTerminatedBuffer()!=uchars) {\n        errln(\"UnicodeString read-only-aliasing setTo() does not behave as expected.\");\n        return;\n    }\n    alias.remove();\n    if(alias.length()!=0) {\n        errln(\"UnicodeString(read-only-alias).remove() did not work.\");\n    }\n    if(alias.getTerminatedBuffer()==uchars) {\n        errln(\"UnicodeString(read-only-alias).remove().getTerminatedBuffer() \"\n              \"did not un-alias as expected.\");\n    }\n    if(uchars[0]!=0x61) {\n        errln(\"UnicodeString(read-only-alias).remove().getTerminatedBuffer() \"\n              \"modified the original buffer.\");\n    }\n    if(0!=u_strlen(alias.getTerminatedBuffer())) {\n        errln(\"UnicodeString.setTo(read-only-alias).remove().getTerminatedBuffer() \"\n              \"does not return a buffer terminated at length 0.\");\n    }\n\n    UnicodeString longString=UNICODE_STRING_SIMPLE(\"abcdefghijklmnopqrstuvwxyz0123456789\");\n    alias.setTo(FALSE, longString.getBuffer(), longString.length());\n    alias.remove(0, 10);\n    if(longString.compare(10, INT32_MAX, alias)!=0 || alias.getBuffer()!=longString.getBuffer()+10) {\n        errln(\"UnicodeString.setTo(read-only-alias).remove(0, 10) did not preserve aliasing as expected.\");\n    }\n    alias.setTo(FALSE, longString.getBuffer(), longString.length());\n    alias.remove(27, 99);\n    if(longString.compare(0, 27, alias)!=0 || alias.getBuffer()!=longString.getBuffer()) {\n        errln(\"UnicodeString.setTo(read-only-alias).remove(27, 99) did not preserve aliasing as expected.\");\n    }\n    alias.setTo(FALSE, longString.getBuffer(), longString.length());\n    alias.retainBetween(6, 30);\n    if(longString.compare(6, 24, alias)!=0 || alias.getBuffer()!=longString.getBuffer()+6) {\n        errln(\"UnicodeString.setTo(read-only-alias).retainBetween(6, 30) did not preserve aliasing as expected.\");\n    }\n\n    UChar abc[]={ 0x61, 0x62, 0x63, 0 };\n    UBool hasRVO= wrapUChars(abc).getBuffer()==abc;\n\n    UnicodeString temp;\n    temp.fastCopyFrom(longString.tempSubString());\n    if(temp!=longString || (hasRVO && temp.getBuffer()!=longString.getBuffer())) {\n        errln(\"UnicodeString.tempSubString() failed\");\n    }\n    temp.fastCopyFrom(longString.tempSubString(-3, 5));\n    if(longString.compare(0, 5, temp)!=0 || (hasRVO && temp.getBuffer()!=longString.getBuffer())) {\n        errln(\"UnicodeString.tempSubString(-3, 5) failed\");\n    }\n    temp.fastCopyFrom(longString.tempSubString(17));\n    if(longString.compare(17, INT32_MAX, temp)!=0 || (hasRVO && temp.getBuffer()!=longString.getBuffer()+17)) {\n        errln(\"UnicodeString.tempSubString(17) failed\");\n    }\n    temp.fastCopyFrom(longString.tempSubString(99));\n    if(!temp.isEmpty()) {\n        errln(\"UnicodeString.tempSubString(99) failed\");\n    }\n    temp.fastCopyFrom(longString.tempSubStringBetween(6));\n    if(longString.compare(6, INT32_MAX, temp)!=0 || (hasRVO && temp.getBuffer()!=longString.getBuffer()+6)) {\n        errln(\"UnicodeString.tempSubStringBetween(6) failed\");\n    }\n    temp.fastCopyFrom(longString.tempSubStringBetween(8, 18));\n    if(longString.compare(8, 10, temp)!=0 || (hasRVO && temp.getBuffer()!=longString.getBuffer()+8)) {\n        errln(\"UnicodeString.tempSubStringBetween(8, 18) failed\");\n    }\n    UnicodeString bogusString;\n    bogusString.setToBogus();\n    temp.fastCopyFrom(bogusString.tempSubStringBetween(8, 18));\n    if(!temp.isBogus()) {\n        errln(\"UnicodeString.setToBogus().tempSubStringBetween(8, 18) failed\");\n    }\n}\n\nvoid\nUnicodeStringTest::doTestAppendable(UnicodeString &dest, Appendable &app) {\n    static const UChar cde[3]={ 0x63, 0x64, 0x65 };\n    static const UChar fg[3]={ 0x66, 0x67, 0 };\n    if(!app.reserveAppendCapacity(12)) {\n        errln(\"Appendable.reserve(12) failed\");\n    }\n    app.appendCodeUnit(0x61);\n    app.appendCodePoint(0x62);\n    app.appendCodePoint(0x50000);\n    app.appendString(cde, 3);\n    app.appendString(fg, -1);\n    UChar scratch[3];\n    int32_t capacity=-1;\n    UChar *buffer=app.getAppendBuffer(3, 3, scratch, 3, &capacity);\n    if(capacity<3) {\n        errln(\"Appendable.getAppendBuffer(min=3) returned capacity=%d<3\", (int)capacity);\n        return;\n    }\n    static const UChar hij[3]={ 0x68, 0x69, 0x6a };\n    u_memcpy(buffer, hij, 3);\n    app.appendString(buffer, 3);\n    if(dest!=UNICODE_STRING_SIMPLE(\"ab\\\\U00050000cdefghij\").unescape()) {\n        errln(\"Appendable.append(...) failed\");\n    }\n    buffer=app.getAppendBuffer(0, 3, scratch, 3, &capacity);\n    if(buffer!=NULL || capacity!=0) {\n        errln(\"Appendable.getAppendBuffer(min=0) failed\");\n    }\n    capacity=1;\n    buffer=app.getAppendBuffer(3, 3, scratch, 2, &capacity);\n    if(buffer!=NULL || capacity!=0) {\n        errln(\"Appendable.getAppendBuffer(scratch<min) failed\");\n    }\n}\n\nclass SimpleAppendable : public Appendable {\npublic:\n    explicit SimpleAppendable(UnicodeString &dest) : str(dest) {}\n    virtual UBool appendCodeUnit(UChar c) { str.append(c); return TRUE; }\n    SimpleAppendable &reset() { str.remove(); return *this; }\nprivate:\n    UnicodeString &str;\n};\n\nvoid\nUnicodeStringTest::TestAppendable() {\n    UnicodeString dest;\n    SimpleAppendable app(dest);\n    doTestAppendable(dest, app);\n}\n\nvoid\nUnicodeStringTest::TestUnicodeStringImplementsAppendable() {\n    UnicodeString dest;\n    UnicodeStringAppendable app(dest);\n    doTestAppendable(dest, app);\n}\n\nvoid\nUnicodeStringTest::TestSizeofUnicodeString() {\n    // See the comments in unistr.h near the declaration of UnicodeString's fields.\n    // See the API comments for UNISTR_OBJECT_SIZE.\n    size_t sizeofUniStr=sizeof(UnicodeString);\n    size_t expected=UNISTR_OBJECT_SIZE;\n    if(expected!=sizeofUniStr) {\n        // Possible cause: UNISTR_OBJECT_SIZE may not be a multiple of sizeof(pointer),\n        // of the compiler might add more internal padding than expected.\n        errln(\"sizeof(UnicodeString)=%d, expected UNISTR_OBJECT_SIZE=%d\",\n              (int)sizeofUniStr, (int)expected);\n    }\n    if(sizeofUniStr<32) {\n        errln(\"sizeof(UnicodeString)=%d < 32, probably too small\", (int)sizeofUniStr);\n    }\n    // We assume that the entire UnicodeString object,\n    // minus the vtable pointer and 2 bytes for flags and short length,\n    // is available for internal storage of UChars.\n    int32_t expectedStackBufferLength=((int32_t)UNISTR_OBJECT_SIZE-sizeof(void *)-2)/U_SIZEOF_UCHAR;\n    UnicodeString s;\n    const UChar *emptyBuffer=s.getBuffer();\n    for(int32_t i=0; i<expectedStackBufferLength; ++i) {\n        s.append((UChar)0x2e);\n    }\n    const UChar *fullBuffer=s.getBuffer();\n    if(fullBuffer!=emptyBuffer) {\n        errln(\"unexpected reallocation when filling with assumed stack buffer size of %d\",\n              expectedStackBufferLength);\n    }\n    const UChar *terminatedBuffer=s.getTerminatedBuffer();\n    if(terminatedBuffer==emptyBuffer) {\n        errln(\"unexpected keeping stack buffer when overfilling assumed stack buffer size of %d\",\n              expectedStackBufferLength);\n    }\n}\n\n// Try to avoid clang -Wself-move warnings from s1 = std::move(s1);\nvoid moveFrom(UnicodeString &dest, UnicodeString &src) {\n    dest = std::move(src);\n}\n\nvoid\nUnicodeStringTest::TestMoveSwap() {\n    static const UChar abc[3] = { 0x61, 0x62, 0x63 };  // \"abc\"\n    UnicodeString s1(FALSE, abc, UPRV_LENGTHOF(abc));  // read-only alias\n    UnicodeString s2(100, 0x7a, 100);  // 100 * 'z' should be on the heap\n    UnicodeString s3(\"defg\", 4, US_INV);  // in stack buffer\n    const UChar *p = s2.getBuffer();\n    s1.swap(s2);\n    if(s1.getBuffer() != p || s1.length() != 100 || s2.getBuffer() != abc || s2.length() != 3) {\n        errln(\"UnicodeString.swap() did not swap\");\n    }\n    swap(s2, s3);\n    if(s2 != UNICODE_STRING_SIMPLE(\"defg\") || s3.getBuffer() != abc || s3.length() != 3) {\n        errln(\"swap(UnicodeString) did not swap back\");\n    }\n    UnicodeString s4;\n    s4 = std::move(s1);\n    if(s4.getBuffer() != p || s4.length() != 100 || !s1.isBogus()) {\n        errln(\"UnicodeString = std::move(heap) did not move\");\n    }\n    UnicodeString s5;\n    s5 = std::move(s2);\n    if(s5 != UNICODE_STRING_SIMPLE(\"defg\")) {\n        errln(\"UnicodeString = std::move(stack) did not move\");\n    }\n    UnicodeString s6;\n    s6 = std::move(s3);\n    if(s6.getBuffer() != abc || s6.length() != 3) {\n        errln(\"UnicodeString = std::move(alias) did not move\");\n    }\n    infoln(\"TestMoveSwap() with rvalue references\");\n    s1 = static_cast<UnicodeString &&>(s6);\n    if(s1.getBuffer() != abc || s1.length() != 3) {\n        errln(\"UnicodeString move assignment operator did not move\");\n    }\n    UnicodeString s7(static_cast<UnicodeString &&>(s4));\n    if(s7.getBuffer() != p || s7.length() != 100 || !s4.isBogus()) {\n        errln(\"UnicodeString move constructor did not move\");\n    }\n\n    // Move self assignment leaves the object valid but in an undefined state.\n    // Do it to make sure there is no crash,\n    // but do not check for any particular resulting value.\n    moveFrom(s1, s1);\n    moveFrom(s2, s2);\n    moveFrom(s3, s3);\n    moveFrom(s4, s4);\n    moveFrom(s5, s5);\n    moveFrom(s6, s6);\n    moveFrom(s7, s7);\n    // Simple copy assignment must work.\n    UnicodeString simple = UNICODE_STRING_SIMPLE(\"simple\");\n    s1 = s6 = s4 = s7 = simple;\n    if(s1 != simple || s4 != simple || s6 != simple || s7 != simple) {\n        errln(\"UnicodeString copy after self-move did not work\");\n    }\n}\n\nvoid\nUnicodeStringTest::TestUInt16Pointers() {\n    static const uint16_t carr[] = { 0x61, 0x62, 0x63, 0 };\n    uint16_t arr[4];\n\n    UnicodeString expected(u\"abc\");\n    assertEquals(\"abc from pointer\", expected, UnicodeString(carr));\n    assertEquals(\"abc from pointer+length\", expected, UnicodeString(carr, 3));\n    assertEquals(\"abc from read-only-alias pointer\", expected, UnicodeString(TRUE, carr, 3));\n\n    UnicodeString alias(arr, 0, 4);\n    alias.append(u'a').append(u'b').append(u'c');\n    assertEquals(\"abc from writable alias\", expected, alias);\n    assertEquals(\"buffer=abc from writable alias\", expected, UnicodeString(arr, 3));\n\n    UErrorCode errorCode = U_ZERO_ERROR;\n    int32_t length = UnicodeString(u\"def\").extract(arr, 4, errorCode);\n    assertSuccess(WHERE, errorCode);\n    assertEquals(\"def from extract()\", UnicodeString(u\"def\"), UnicodeString(arr, length));\n}\n\nvoid\nUnicodeStringTest::TestWCharPointers() {\n#if U_SIZEOF_WCHAR_T==2\n    static const wchar_t carr[] = { 0x61, 0x62, 0x63, 0 };\n    wchar_t arr[4];\n\n    UnicodeString expected(u\"abc\");\n    assertEquals(\"abc from pointer\", expected, UnicodeString(carr));\n    assertEquals(\"abc from pointer+length\", expected, UnicodeString(carr, 3));\n    assertEquals(\"abc from read-only-alias pointer\", expected, UnicodeString(TRUE, carr, 3));\n\n    UnicodeString alias(arr, 0, 4);\n    alias.append(u'a').append(u'b').append(u'c');\n    assertEquals(\"abc from writable alias\", expected, alias);\n    assertEquals(\"buffer=abc from writable alias\", expected, UnicodeString(arr, 3));\n\n    UErrorCode errorCode = U_ZERO_ERROR;\n    int32_t length = UnicodeString(u\"def\").extract(arr, 4, errorCode);\n    assertSuccess(WHERE, errorCode);\n    assertEquals(\"def from extract()\", UnicodeString(u\"def\"), UnicodeString(arr, length));\n#endif\n}\n\nvoid\nUnicodeStringTest::TestNullPointers() {\n    assertTrue(\"empty from nullptr\", UnicodeString(nullptr).isEmpty());\n    assertTrue(\"empty from nullptr+length\", UnicodeString(nullptr, 2).isEmpty());\n    assertTrue(\"empty from read-only-alias nullptr\", UnicodeString(TRUE, nullptr, 3).isEmpty());\n\n    UnicodeString alias(nullptr, 4, 4);  // empty, no alias\n    assertTrue(\"empty from writable alias\", alias.isEmpty());\n    alias.append(u'a').append(u'b').append(u'c');\n    UnicodeString expected(u\"abc\");\n    assertEquals(\"abc from writable alias\", expected, alias);\n\n    UErrorCode errorCode = U_ZERO_ERROR;\n    UnicodeString(u\"def\").extract(nullptr, 0, errorCode);\n    assertEquals(\"buffer overflow extracting to nullptr\", U_BUFFER_OVERFLOW_ERROR, errorCode);\n}\n\nvoid UnicodeStringTest::TestUnicodeStringInsertAppendToSelf() {\n    IcuTestErrorCode status(*this, \"TestUnicodeStringAppendToSelf\");\n\n    // Test append operation\n    UnicodeString str(u\"foo \");\n    str.append(str);\n    str.append(str);\n    str.append(str);\n    assertEquals(\"\", u\"foo foo foo foo foo foo foo foo \", str);\n\n    // Test append operation with readonly alias to start\n    str = UnicodeString(TRUE, u\"foo \", 4);\n    str.append(str);\n    str.append(str);\n    str.append(str);\n    assertEquals(\"\", u\"foo foo foo foo foo foo foo foo \", str);\n\n    // Test append operation with aliased substring\n    str = u\"abcde\";\n    UnicodeString sub = str.tempSubString(1, 2);\n    str.append(sub);\n    assertEquals(\"\", u\"abcdebc\", str);\n\n    // Test append operation with double-aliased substring\n    str = UnicodeString(TRUE, u\"abcde\", 5);\n    sub = str.tempSubString(1, 2);\n    str.append(sub);\n    assertEquals(\"\", u\"abcdebc\", str);\n\n    // Test insert operation\n    str = u\"a-*b\";\n    str.insert(2, str);\n    str.insert(4, str);\n    str.insert(8, str);\n    assertEquals(\"\", u\"a-a-a-a-a-a-a-a-*b*b*b*b*b*b*b*b\", str);\n\n    // Test insert operation with readonly alias to start\n    str = UnicodeString(TRUE, u\"a-*b\", 4);\n    str.insert(2, str);\n    str.insert(4, str);\n    str.insert(8, str);\n    assertEquals(\"\", u\"a-a-a-a-a-a-a-a-*b*b*b*b*b*b*b*b\", str);\n\n    // Test insert operation with aliased substring\n    str = u\"abcde\";\n    sub = str.tempSubString(1, 3);\n    str.insert(2, sub);\n    assertEquals(\"\", u\"abbcdcde\", str);\n\n    // Test insert operation with double-aliased substring\n    str = UnicodeString(TRUE, u\"abcde\", 5);\n    sub = str.tempSubString(1, 3);\n    str.insert(2, sub);\n    assertEquals(\"\", u\"abbcdcde\", str);\n}\n\nvoid UnicodeStringTest::TestLargeAppend() {\n    if(quick) return;\n\n    IcuTestErrorCode status(*this, \"TestLargeAppend\");\n    // Make a large UnicodeString\n    int32_t len = 0xAFFFFFF;\n    UnicodeString str;\n    char16_t *buf = str.getBuffer(len);\n    // A fast way to set buffer to valid Unicode.\n    // 4E4E is a valid unicode character\n    uprv_memset(buf, 0x4e, len * 2);\n    str.releaseBuffer(len);\n    UnicodeString dest;\n    // Append it 16 times\n    // 0xAFFFFFF times 16 is 0xA4FFFFF1,\n    // which is greater than INT32_MAX, which is 0x7FFFFFFF.\n    int64_t total = 0;\n    for (int32_t i = 0; i < 16; i++) {\n        dest.append(str);\n        total += len;\n        if (total <= INT32_MAX) {\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n        } else {\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        }\n    }\n    dest.remove();\n    total = 0;\n    for (int32_t i = 0; i < 16; i++) {\n        dest.append(str);\n        total += len;\n        if (total + len <= INT32_MAX) {\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n        } else if (total <= INT32_MAX) {\n            // Check that a string of exactly the maximum size works\n            UnicodeString str2;\n            int32_t remain = INT32_MAX - total;\n            char16_t *buf2 = str2.getBuffer(remain);\n            if (buf2 == nullptr) {\n                // if somehow memory allocation fail, return the test\n                return;\n            }\n            uprv_memset(buf2, 0x4e, remain * 2);\n            str2.releaseBuffer(remain);\n            dest.append(str2);\n            total += remain;\n            assertEquals(\"When a string of exactly the maximum size works\", (int64_t)INT32_MAX, total);\n            assertEquals(\"When a string of exactly the maximum size works\", INT32_MAX, dest.length());\n            assertFalse(\"dest is not bogus\", dest.isBogus());\n\n            // Check that a string size+1 goes bogus\n            str2.truncate(1);\n            dest.append(str2);\n            total++;\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        } else {\n            assertTrue(\"dest should be bogus\", dest.isBogus());\n        }\n    }\n}\n", "// \u00a9 2016 and later: Unicode, Inc. and others.\n// License & terms of use: http://www.unicode.org/copyright.html\n/********************************************************************\n * COPYRIGHT: \n * Copyright (c) 1997-2015, International Business Machines Corporation and\n * others. All Rights Reserved.\n ********************************************************************/\n\n#ifndef UNICODESTRINGTEST_H\n#define UNICODESTRINGTEST_H\n\n#include \"unicode/locid.h\"\n#include \"unicode/unistr.h\"\n#include \"intltest.h\"\n\nU_NAMESPACE_BEGIN\n\nclass Appendable;\n\nU_NAMESPACE_END\n\n/**\n * Perform API and functionality tests for class UnicodeString\n **/\nclass UnicodeStringTest: public IntlTest {\npublic:\n    UnicodeStringTest() {}\n    virtual ~UnicodeStringTest();\n    \n    void runIndexedTest( int32_t index, UBool exec, const char* &name, char* par = NULL );\n\n    /**\n     * Test some basic methods (insert, remove, replace, ...)\n     **/\n    void TestBasicManipulation(void);\n    /**\n     * Test the methods for comparison\n     **/\n    void TestCompare(void);\n    /**\n     * Test the methods for extracting\n     **/\n    void TestExtract(void);\n    /**\n     * More extensively test methods for removing and replacing\n     **/\n    void TestRemoveReplace(void);\n    /**\n     * Test language specific case conversions\n     **/\n    void TestSearching(void);\n    /**\n     * Test methods for padding, trimmimg and truncating\n     **/\n    void TestSpacePadding(void);\n    /**\n     * Test methods startsWith and endsWith\n     **/\n    void TestPrefixAndSuffix(void);\n    void TestStartsWithAndEndsWithNulTerminated();\n    /**\n     * Test method findAndReplace\n     **/\n    void TestFindAndReplace(void);\n    /**\n     * Test method reverse\n     **/\n    void TestReverse(void);\n    /**\n     * Test a few miscellaneous methods (isBogus, hashCode,...)\n     **/\n    void TestMiscellaneous(void);\n    /**\n     * Test the functionality of allocating UnicodeStrings on the stack\n     **/\n    void TestStackAllocation(void);\n    /**\n     * Test the unescape() function.\n     */\n    void TestUnescape(void);\n\n    void _testUnicodeStringHasMoreChar32Than(const UnicodeString &s, int32_t start, int32_t length, int32_t number);\n    void TestCountChar32();\n    void TestBogus();\n    void TestStringEnumeration();\n    void TestNameSpace();\n    void TestUTF32();\n    void TestUTF8();\n    void TestReadOnlyAlias();\n    void doTestAppendable(UnicodeString &dest, Appendable &app);\n    void TestAppendable();\n    void TestUnicodeStringImplementsAppendable();\n    void TestSizeofUnicodeString();\n    void TestMoveSwap();\n\n    void TestUInt16Pointers();\n    void TestWCharPointers();\n    void TestNullPointers();\n    void TestUnicodeStringInsertAppendToSelf();\n    void TestLargeAppend();\n};\n\n#endif\n"], "filenames": ["icu4c/source/common/unistr.cpp", "icu4c/source/test/intltest/ustrtest.cpp", "icu4c/source/test/intltest/ustrtest.h"], "buggy_code_start_loc": [1566, 69, 99], "buggy_code_end_loc": [1567, 2312, 99], "fixing_code_start_loc": [1566, 70, 100], "fixing_code_end_loc": [1571, 2375, 101], "type": "CWE-190", "message": "An issue was discovered in International Components for Unicode (ICU) for C/C++ through 66.1. An integer overflow, leading to a heap-based buffer overflow, exists in the UnicodeString::doAppend() function in common/unistr.cpp.", "other": {"cve": {"id": "CVE-2020-10531", "sourceIdentifier": "cve@mitre.org", "published": "2020-03-12T19:15:13.227", "lastModified": "2022-08-12T18:28:08.843", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in International Components for Unicode (ICU) for C/C++ through 66.1. An integer overflow, leading to a heap-based buffer overflow, exists in the UnicodeString::doAppend() function in common/unistr.cpp."}, {"lang": "es", "value": "Se detect\u00f3 un problema en International Components for Unicode (ICU) para C/C++ versiones hasta 66.1. Se presenta un desbordamiento de enteros, conllevando a un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria, en la funci\u00f3n UnicodeString::doAppend() en el archivo common/unistr.cpp."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}, {"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:icu-project:international_components_for_unicode:*:*:*:*:*:c\\/c\\+\\+:*:*", "versionEndIncluding": "66.1", "matchCriteriaId": "2894DF6A-AC41-4844-8DA4-B9322993B699"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:chrome:*:*:*:*:*:*:*:*", "versionEndExcluding": "80.0.3987.122", "matchCriteriaId": "D165035A-62F6-4ADC-A3B4-1FD602E03D84"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:33:*:*:*:*:*:*:*", "matchCriteriaId": "E460AA51-FCDA-46B9-AE97-E6676AA5E194"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_extensibility_workbench:14.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "EABAFD73-150F-4DFE-B721-29EB4475D979"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_extensibility_workbench:14.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "DE57039D-E2EE-4014-A7B1-D7380D26098E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:*:*:*:*:-:*:*:*", "versionStartIncluding": "10.0.0", "versionEndIncluding": "10.12.0", "matchCriteriaId": "25A3180B-21AF-4010-9DAB-41ADFD2D8031"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nodejs:node.js:*:*:*:*:lts:*:*:*", "versionStartIncluding": "10.13.0", "versionEndExcluding": "10.21.0", "matchCriteriaId": "E9E9BD86-6374-45B3-8727-AACED7C8F3B9"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-04/msg00004.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0738", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.chromium.org/p/chromium/issues/detail?id=1044570", "source": "cve@mitre.org", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://chromereleases.googleblog.com/2020/02/stable-channel-update-for-desktop_24.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://chromium.googlesource.com/chromium/deps/icu/+/9f4020916eb1f28f3666f018fdcbe6c9a37f0e08", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/unicode-org/icu/commit/b7d08bc04a4296982fcef8b6b8a354a9e4e7afca", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/unicode-org/icu/pull/971", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00024.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4OOYAMJVLLCLXDTHW3V5UXNULZBBK4O6/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6IOHSO6BUKC6I66J5PZOMAGFVJ66ZS57/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/X3B5RWJQD5LA45MYLLR55KZJOJ5NVZGP/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202003-15", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://unicode-org.atlassian.net/browse/ICU-20958", "source": "cve@mitre.org", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4305-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4646", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "cve@mitre.org", "tags": ["Not Applicable", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/unicode-org/icu/commit/b7d08bc04a4296982fcef8b6b8a354a9e4e7afca"}}