{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (c) 2015 Tim Theede <pez2001@voyagerproject.de>\n *               2015 Terry Cain <terry@terrys-home.co.uk>\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hid.h>\n\n\n#include \"razercommon.h\"\n\n/**\n * Send USB control report to the keyboard\n * USUALLY index = 0x02\n * FIREFLY is 0\n */\nint razer_send_control_msg(struct usb_device *usb_dev,void const *data, uint report_index, ulong wait_min, ulong wait_max)\n{\n    uint request = HID_REQ_SET_REPORT; // 0x09\n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21\n    uint value = 0x300;\n    uint size = RAZER_USB_REPORT_LEN;\n    char *buf;\n    int len;\n\n    buf = kmemdup(data, size, GFP_KERNEL);\n    if (buf == NULL)\n        return -ENOMEM;\n\n    // Send usb control message\n    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n                          request,      // Request\n                          request_type, // RequestType\n                          value,        // Value\n                          report_index, // Index\n                          buf,          // Data\n                          size,         // Length\n                          USB_CTRL_SET_TIMEOUT);\n\n    // Wait\n    usleep_range(wait_min, wait_max);\n\n    kfree(buf);\n    if(len!=size)\n        printk(KERN_WARNING \"razer driver: Device data transfer failed.\\n\");\n\n    return ((len < 0) ? len : ((len != size) ? -EIO : 0));\n}\n\n/**\n * Get a response from the razer device\n *\n * Makes a request like normal, this must change a variable in the device as then we\n * tell it give us data and it gives us a report.\n *\n * Supported Devices:\n *   Razer Chroma\n *   Razer Mamba\n *   Razer BlackWidow Ultimate 2013*\n *   Razer Firefly*\n *\n * Request report is the report sent to the device specifying what response we want\n * Response report will get populated with a response\n *\n * Returns 0 when successful, 1 if the report length is invalid.\n */\nint razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max)\n{\n    uint request = HID_REQ_GET_REPORT; // 0x01\n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN; // 0xA1\n    uint value = 0x300;\n\n    uint size = RAZER_USB_REPORT_LEN; // 0x90\n    int len;\n    int retval;\n    int result = 0;\n    char *buf;\n\n    buf = kzalloc(sizeof(struct razer_report), GFP_KERNEL);\n    if (buf == NULL)\n        return -ENOMEM;\n\n    // Send the request to the device.\n    // TODO look to see if index needs to be different for the request and the response\n    retval = razer_send_control_msg(usb_dev, request_report, report_index, wait_min, wait_max);\n\n    // Now ask for response\n    len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n                          request,         // Request\n                          request_type,    // RequestType\n                          value,           // Value\n                          response_index,  // Index\n                          buf,             // Data\n                          size,\n                          USB_CTRL_SET_TIMEOUT);\n\n    memcpy(response_report, buf, sizeof(struct razer_report));\n    kfree(buf);\n\n    // Error if report is wrong length\n    if(len != 90) {\n        printk(KERN_WARNING \"razer driver: Invalid USB response. USB Report length: %d\\n\", len);\n        result = 1;\n    }\n\n    return result;\n}\n\n/**\n * Calculate the checksum for the usb message\n *\n * Checksum byte is stored in the 2nd last byte in the messages payload.\n * The checksum is generated by XORing all the bytes in the report starting\n * at byte number 2 (0 based) and ending at byte 88.\n */\nunsigned char razer_calculate_crc(struct razer_report *report)\n{\n    /*second to last byte of report is a simple checksum*/\n    /*just xor all bytes up with overflow and you are done*/\n    unsigned char crc = 0;\n    unsigned char *_report = (unsigned char*)report;\n\n    unsigned int i;\n    for(i = 2; i < 88; i++) {\n        crc ^= _report[i];\n    }\n\n    return crc;\n}\n\n/**\n * Get initialised razer report\n */\nstruct razer_report get_razer_report(unsigned char command_class, unsigned char command_id, unsigned char data_size)\n{\n    struct razer_report new_report = {0};\n    memset(&new_report, 0, sizeof(struct razer_report));\n\n    new_report.status = 0x00;\n    new_report.transaction_id.id = 0xFF;\n    new_report.remaining_packets = 0x00;\n    new_report.protocol_type = 0x00;\n    new_report.command_class = command_class;\n    new_report.command_id.id = command_id;\n    new_report.data_size = data_size;\n\n    return new_report;\n}\n\n/**\n * Get empty razer report\n */\nstruct razer_report get_empty_razer_report(void)\n{\n    struct razer_report new_report = {0};\n    memset(&new_report, 0, sizeof(struct razer_report));\n\n    return new_report;\n}\n\n/**\n * Print report to syslog\n */\nvoid print_erroneous_report(struct razer_report* report, char* driver_name, char* message)\n{\n    printk(KERN_WARNING \"%s: %s. status: %02x transaction_id.id: %02x remaining_packets: %02x protocol_type: %02x data_size: %02x, command_class: %02x, command_id.id: %02x Params: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x .\\n\",\n           driver_name,\n           message,\n           report->status,\n           report->transaction_id.id,\n           report->remaining_packets,\n           report->protocol_type,\n           report->data_size,\n           report->command_class,\n           report->command_id.id,\n           report->arguments[0], report->arguments[1], report->arguments[2], report->arguments[3], report->arguments[4], report->arguments[5],\n           report->arguments[6], report->arguments[7], report->arguments[8], report->arguments[9], report->arguments[10], report->arguments[11],\n           report->arguments[12], report->arguments[13], report->arguments[14], report->arguments[15]);\n}\n\n/**\n * Clamp a value to a min,max\n */\nunsigned char clamp_u8(unsigned char value, unsigned char min, unsigned char max)\n{\n    if(value > max)\n        return max;\n    if(value < min)\n        return min;\n    return value;\n}\nunsigned short clamp_u16(unsigned short value, unsigned short min, unsigned short max)\n{\n    if(value > max)\n        return max;\n    if(value < min)\n        return min;\n    return value;\n}\n\n\nint razer_send_control_msg_old_device(struct usb_device *usb_dev,void const *data, uint report_value, uint report_index, uint report_size, ulong wait_min, ulong wait_max)\n{\n    uint request = HID_REQ_SET_REPORT; // 0x09\n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21\n    char *buf;\n    int len;\n\n    buf = kmemdup(data, report_size, GFP_KERNEL);\n    if (buf == NULL)\n        return -ENOMEM;\n\n    // Send usb control message\n    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n                          request,      // Request\n                          request_type, // RequestType\n                          report_value, // Value\n                          report_index, // Index\n                          buf,          // Data\n                          report_size,  // Length\n                          USB_CTRL_SET_TIMEOUT);\n\n    // Wait\n    usleep_range(wait_min, wait_max);\n\n    kfree(buf);\n    if(len!=report_size)\n        printk(KERN_WARNING \"razer driver: Device data transfer failed.\\n\");\n\n    return ((len < 0) ? len : ((len != report_size) ? -EIO : 0));\n}\n\nint razer_send_argb_msg(struct usb_device* usb_dev, unsigned char channel, unsigned char size, void const* data)\n{\n    uint request = HID_REQ_SET_REPORT; // 0x09\n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21\n    uint value = 0x300;\n    int len;\n    char *buf;\n\n    struct razer_argb_report report;\n\n    if (channel < 5) {\n        report.report_id = 0x04;\n    } else {\n        report.report_id = 0x84;\n    }\n\n    report.channel_1 = channel;\n    report.channel_2 = channel;\n\n    report.pad = 0;\n\n    report.last_idx = size - 1;\n\n    if (size * 3 > ARRAY_SIZE(report.color_data)) {\n        printk(KERN_ERR \"razer driver: size too big\\n\");\n        return -EINVAL;\n    }\n\n    memcpy(report.color_data, data, size * 3);\n\n    buf = kmemdup(&report, sizeof(report), GFP_KERNEL);\n\n    // Send usb control message\n    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n                          request,            // Request\n                          request_type,       // RequestType\n                          value,              // Value\n                          0x01,               // Index\n                          buf,                // Data\n                          sizeof(report),     // Length\n                          USB_CTRL_SET_TIMEOUT);\n\n    if (len != sizeof(report))\n        printk(KERN_WARNING \"razer driver: Device data transfer failed. len = %d\", len);\n\n    return ((len < 0) ? len : ((len != size) ? -EIO : 0));\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright (c) 2015 Tim Theede <pez2001@voyagerproject.de>\n *               2015 Terry Cain <terry@terrys-home.co.uk>\n */\n\n#include <linux/kernel.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hid.h>\n\n\n#include \"razercommon.h\"\n\n/**\n * Send USB control report to the keyboard\n * USUALLY index = 0x02\n * FIREFLY is 0\n */\nint razer_send_control_msg(struct usb_device *usb_dev,void const *data, uint report_index, ulong wait_min, ulong wait_max)\n{\n    uint request = HID_REQ_SET_REPORT; // 0x09\n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21\n    uint value = 0x300;\n    uint size = RAZER_USB_REPORT_LEN;\n    char *buf;\n    int len;\n\n    buf = kmemdup(data, size, GFP_KERNEL);\n    if (buf == NULL)\n        return -ENOMEM;\n\n    // Send usb control message\n    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n                          request,      // Request\n                          request_type, // RequestType\n                          value,        // Value\n                          report_index, // Index\n                          buf,          // Data\n                          size,         // Length\n                          USB_CTRL_SET_TIMEOUT);\n\n    // Wait\n    usleep_range(wait_min, wait_max);\n\n    kfree(buf);\n    if(len!=size)\n        printk(KERN_WARNING \"razer driver: Device data transfer failed.\\n\");\n\n    return ((len < 0) ? len : ((len != size) ? -EIO : 0));\n}\n\n/**\n * Get a response from the razer device\n *\n * Makes a request like normal, this must change a variable in the device as then we\n * tell it give us data and it gives us a report.\n *\n * Supported Devices:\n *   Razer Chroma\n *   Razer Mamba\n *   Razer BlackWidow Ultimate 2013*\n *   Razer Firefly*\n *\n * Request report is the report sent to the device specifying what response we want\n * Response report will get populated with a response\n *\n * Returns 0 when successful, 1 if the report length is invalid.\n */\nint razer_get_usb_response(struct usb_device *usb_dev, uint report_index, struct razer_report* request_report, uint response_index, struct razer_report* response_report, ulong wait_min, ulong wait_max)\n{\n    uint request = HID_REQ_GET_REPORT; // 0x01\n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN; // 0xA1\n    uint value = 0x300;\n\n    uint size = RAZER_USB_REPORT_LEN; // 0x90\n    int len;\n    int retval;\n    int result = 0;\n    char *buf;\n\n    buf = kzalloc(sizeof(struct razer_report), GFP_KERNEL);\n    if (buf == NULL)\n        return -ENOMEM;\n\n    // Send the request to the device.\n    // TODO look to see if index needs to be different for the request and the response\n    retval = razer_send_control_msg(usb_dev, request_report, report_index, wait_min, wait_max);\n\n    // Now ask for response\n    len = usb_control_msg(usb_dev, usb_rcvctrlpipe(usb_dev, 0),\n                          request,         // Request\n                          request_type,    // RequestType\n                          value,           // Value\n                          response_index,  // Index\n                          buf,             // Data\n                          size,\n                          USB_CTRL_SET_TIMEOUT);\n\n    memcpy(response_report, buf, sizeof(struct razer_report));\n    kfree(buf);\n\n    // Error if report is wrong length\n    if(len != 90) {\n        printk(KERN_WARNING \"razer driver: Invalid USB response. USB Report length: %d\\n\", len);\n        result = 1;\n    }\n\n    if (WARN_ONCE(response_report->data_size > ARRAY_SIZE(response_report->arguments),\n                  \"Field data_size %d in response is bigger than arguments\\n\",\n                  response_report->data_size)) {\n        /* Sanitize the value since at the moment callers don't respect the return code */\n        response_report->data_size = ARRAY_SIZE(response_report->arguments);\n        return -EINVAL;\n    }\n\n    return result;\n}\n\n/**\n * Calculate the checksum for the usb message\n *\n * Checksum byte is stored in the 2nd last byte in the messages payload.\n * The checksum is generated by XORing all the bytes in the report starting\n * at byte number 2 (0 based) and ending at byte 88.\n */\nunsigned char razer_calculate_crc(struct razer_report *report)\n{\n    /*second to last byte of report is a simple checksum*/\n    /*just xor all bytes up with overflow and you are done*/\n    unsigned char crc = 0;\n    unsigned char *_report = (unsigned char*)report;\n\n    unsigned int i;\n    for(i = 2; i < 88; i++) {\n        crc ^= _report[i];\n    }\n\n    return crc;\n}\n\n/**\n * Get initialised razer report\n */\nstruct razer_report get_razer_report(unsigned char command_class, unsigned char command_id, unsigned char data_size)\n{\n    struct razer_report new_report = {0};\n    memset(&new_report, 0, sizeof(struct razer_report));\n\n    new_report.status = 0x00;\n    new_report.transaction_id.id = 0xFF;\n    new_report.remaining_packets = 0x00;\n    new_report.protocol_type = 0x00;\n    new_report.command_class = command_class;\n    new_report.command_id.id = command_id;\n    new_report.data_size = data_size;\n\n    return new_report;\n}\n\n/**\n * Get empty razer report\n */\nstruct razer_report get_empty_razer_report(void)\n{\n    struct razer_report new_report = {0};\n    memset(&new_report, 0, sizeof(struct razer_report));\n\n    return new_report;\n}\n\n/**\n * Print report to syslog\n */\nvoid print_erroneous_report(struct razer_report* report, char* driver_name, char* message)\n{\n    printk(KERN_WARNING \"%s: %s. status: %02x transaction_id.id: %02x remaining_packets: %02x protocol_type: %02x data_size: %02x, command_class: %02x, command_id.id: %02x Params: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x .\\n\",\n           driver_name,\n           message,\n           report->status,\n           report->transaction_id.id,\n           report->remaining_packets,\n           report->protocol_type,\n           report->data_size,\n           report->command_class,\n           report->command_id.id,\n           report->arguments[0], report->arguments[1], report->arguments[2], report->arguments[3], report->arguments[4], report->arguments[5],\n           report->arguments[6], report->arguments[7], report->arguments[8], report->arguments[9], report->arguments[10], report->arguments[11],\n           report->arguments[12], report->arguments[13], report->arguments[14], report->arguments[15]);\n}\n\n/**\n * Clamp a value to a min,max\n */\nunsigned char clamp_u8(unsigned char value, unsigned char min, unsigned char max)\n{\n    if(value > max)\n        return max;\n    if(value < min)\n        return min;\n    return value;\n}\nunsigned short clamp_u16(unsigned short value, unsigned short min, unsigned short max)\n{\n    if(value > max)\n        return max;\n    if(value < min)\n        return min;\n    return value;\n}\n\n\nint razer_send_control_msg_old_device(struct usb_device *usb_dev,void const *data, uint report_value, uint report_index, uint report_size, ulong wait_min, ulong wait_max)\n{\n    uint request = HID_REQ_SET_REPORT; // 0x09\n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21\n    char *buf;\n    int len;\n\n    buf = kmemdup(data, report_size, GFP_KERNEL);\n    if (buf == NULL)\n        return -ENOMEM;\n\n    // Send usb control message\n    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n                          request,      // Request\n                          request_type, // RequestType\n                          report_value, // Value\n                          report_index, // Index\n                          buf,          // Data\n                          report_size,  // Length\n                          USB_CTRL_SET_TIMEOUT);\n\n    // Wait\n    usleep_range(wait_min, wait_max);\n\n    kfree(buf);\n    if(len!=report_size)\n        printk(KERN_WARNING \"razer driver: Device data transfer failed.\\n\");\n\n    return ((len < 0) ? len : ((len != report_size) ? -EIO : 0));\n}\n\nint razer_send_argb_msg(struct usb_device* usb_dev, unsigned char channel, unsigned char size, void const* data)\n{\n    uint request = HID_REQ_SET_REPORT; // 0x09\n    uint request_type = USB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_OUT; // 0x21\n    uint value = 0x300;\n    int len;\n    char *buf;\n\n    struct razer_argb_report report;\n\n    if (channel < 5) {\n        report.report_id = 0x04;\n    } else {\n        report.report_id = 0x84;\n    }\n\n    report.channel_1 = channel;\n    report.channel_2 = channel;\n\n    report.pad = 0;\n\n    report.last_idx = size - 1;\n\n    if (size * 3 > ARRAY_SIZE(report.color_data)) {\n        printk(KERN_ERR \"razer driver: size too big\\n\");\n        return -EINVAL;\n    }\n\n    memcpy(report.color_data, data, size * 3);\n\n    buf = kmemdup(&report, sizeof(report), GFP_KERNEL);\n\n    // Send usb control message\n    len = usb_control_msg(usb_dev, usb_sndctrlpipe(usb_dev, 0),\n                          request,            // Request\n                          request_type,       // RequestType\n                          value,              // Value\n                          0x01,               // Index\n                          buf,                // Data\n                          sizeof(report),     // Length\n                          USB_CTRL_SET_TIMEOUT);\n\n    if (len != sizeof(report))\n        printk(KERN_WARNING \"razer driver: Device data transfer failed. len = %d\", len);\n\n    return ((len < 0) ? len : ((len != size) ? -EIO : 0));\n}\n"], "filenames": ["driver/razercommon.c"], "buggy_code_start_loc": [107], "buggy_code_end_loc": [107], "fixing_code_start_loc": [108], "fixing_code_end_loc": [116], "type": "CWE-125", "message": "OpenRazer is an open source driver and user-space daemon to control Razer device lighting and other features on GNU/Linux. Using a modified USB device an attacker can leak stack addresses of the `razer_attr_read_dpi_stages`, potentially bypassing KASLR. To exploit this vulnerability an attacker would need to access to a users keyboard or mouse or would need to convince a user to use a modified device. The issue has been patched in v3.5.1. Users are advised to upgrade and should be reminded not to plug in unknown USB devices.", "other": {"cve": {"id": "CVE-2022-23467", "sourceIdentifier": "security-advisories@github.com", "published": "2022-12-05T20:15:10.133", "lastModified": "2022-12-06T20:34:49.993", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenRazer is an open source driver and user-space daemon to control Razer device lighting and other features on GNU/Linux. Using a modified USB device an attacker can leak stack addresses of the `razer_attr_read_dpi_stages`, potentially bypassing KASLR. To exploit this vulnerability an attacker would need to access to a users keyboard or mouse or would need to convince a user to use a modified device. The issue has been patched in v3.5.1. Users are advised to upgrade and should be reminded not to plug in unknown USB devices."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:P/AC:H/PR:L/UI:R/S:C/C:L/I:L/A:L", "attackVector": "PHYSICAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.3, "impactScore": 3.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openrazer_project:openrazer:*:*:*:*:*:linux:*:*", "versionEndExcluding": "3.5.1", "matchCriteriaId": "6DC7A7BD-6A98-4B2B-98BE-5BDD21768F26"}]}]}], "references": [{"url": "https://github.com/openrazer/openrazer/commit/33aa7f07d54ae066f201c6d298cb4a2181cb90e6", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openrazer/openrazer/security/advisories/GHSA-39hg-jvc9-fg7h", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openrazer/openrazer/commit/33aa7f07d54ae066f201c6d298cb4a2181cb90e6"}}