{"buggy_code": ["# Changes in HTMLDOC v1.9.12\n\n- Fixed a crash bug with \"data:\" URIs and EPUB output (Issue #410)\n- Fixed some issues reported by Coverity.\n\n\n# Changes in HTMLDOC v1.9.11\n\n- Added high-resolution desktop icons for Linux.\n- Updated the internal HTTP library to fix truncation of redirection URLs\n  (Issue #396)\n- Fixed a regression in the handling of character entities for UTF-8 input\n  (Issue #401)\n- The `--numbered` option did not work when the table-of-contents was disabled\n  (Issue #405)\n\n\n# Changes in HTMLDOC v1.9.10\n\n- Updated local zlib to v1.2.11.\n- Updated local libpng to v1.6.37.\n- Fixed packaging issues on macOS and Windows (Issue #377, Issue #386)\n- Now ignore sRGB profile errors in PNG files (Issue #390)\n- The GUI would crash when saving (Issue #391)\n- Page comments are now allowed in `pre` text (Issue #394)\n\n\n# Changes in HTMLDOC v1.9.9\n\n- Fixed a redirection issue - some sites (incorrectly) provide an incomplete\n  Location: URL in the HTTP response.\n- Fixed https: support on newer versions of Windows (Issue #378)\n- Fixed a problem with remote URLs containing spaces (Issue #379)\n- Fixed a UTF-8 processing bug for Markdown files (Issue #383)\n- Added support for `<FONT FACE=\"monospace\">` (Issue #385)\n\n\n# Changes in HTMLDOC v1.9.8\n\n- Added support for a `HTMLDOC.filename` META keyword that controls the filename\n  reported in CGI mode; the default remains \"htmldoc.pdf\" (Issue #367)\n- Fixed a paragraph formatting issue with large inline images (Issue #369)\n- Fixed a buffer underflow issue (Issue #370)\n- Fixed PDF page numbers (Issue #371)\n- Added support for a new `L` header/footer format (`$LETTERHEAD`), which\n  inserts a letterhead image at its full size (Issue #372, Issue #373,\n  Issue #375)\n- Updated the build documentation (Issue #374)\n\n\n# Changes in HTMLDOC v1.9.7\n\n- Refactored the PRE rendering code to work around compiler optimization bugs\n  (Issue #349)\n- Added support for links with targets (Issue #351)\n- Fixed a table rowspan + valign bug (Issue #360)\n\n\n# Changes in HTMLDOC v1.9.6\n\n- Added support for data URIs (Issue #340)\n- HTMLDOC no longer includes a PDF table of contents when converting a single\n  web page (Issue #344)\n- Updated the markdown support with external links, additional inline markup,\n  and hard line breaks.\n- Links in markdown text no longer render with a leading space as part of the\n  link (Issue #346)\n- Fixed a buffer underflow bug discovered by AddressSanitizer.\n- Fixed a bug in UTF-8 support (Issue #348)\n- PDF output now includes the base language of the input document(s)\n  (Issue #350)\n- Optimized the loading of font widths (Issue #354)\n- Optimized PDF page resources (Issue #356)\n- Optimized the base memory used for font widths (Issue #357)\n- Added proper `&shy;` support (Issue #361)\n- Title files can now be markdown.\n\n\n# Changes in HTMLDOC v1.9.5\n\n- The GUI did not support EPUB output.\n- Empty markdown table cells were not rendered in PDF or PostScript output.\n- The automatically-generated title page now supports both \"docnumber\" and\n  \"version\" metadata.\n- Added support for dc:subject and dc:language metadata in EPUB output from the\n  HTML keywords and lang values.\n- Added support for the subject and language metadata in markdown input.\n- Fixed a buffer underflow bug (Issue #338)\n- `htmldoc --help` now reports whether HTTPS URLs are supported (Issue #339)\n- Fixed an issue with HTML title pages and EPUB output.\n\n\n# Changes in HTMLDOC v1.9.4\n\n- Inline fixed-width text is no longer reduced in size automatically\n  (Issue #309)\n- Optimized initialization of font width data (Issue #334)\n\n\n# Changes in HTMLDOC v1.9.3\n\n- Fixed formatting bugs with aligned images (Issue #322, Issue #324)\n- Fixed support for three digit \"#RGB\" color values (Issue #323)\n- Fixed character set support for markdown metadata.\n- Updated libpng to v1.6.34 (Issue #326)\n- The makefiles did not use the CPPFLAGS value (Issue #328)\n\n\n# Changes in HTMLDOC v1.9.2\n\n- Added Markdown table support.\n- Fixed parsing of TBODY, TFOOT, and THEAD elements in HTML files.\n\n\n# Changes in HTMLDOC v1.9.1\n\n- Fixed monospace font size issue (Issue #309)\n- Added support for reproducible builds (Issue #310)\n- Added limited support for the HTML 4.0 SPAN element (Issue #311)\n- Added (extremely limited) UTF-8 support for input files (Issue #314)\n- Fixed buffer underflow for (invalid) short HTML comments (Issue #316)\n- Now indent PRE text, by popular request.\n- EPUB output now makes sure that `<element property>` is written as\n  `<element property=\"property\">`.\n- Now support both NAME and ID for table-of-contents targets.\n\n\n# Changes in HTMLDOC v1.9\n\n- Added support for repeating a single header row for tables that span multiple\n  pages (Issue #16)\n- Added support for embedding the current filename/URL in the header or footer\n  (Issue #50)\n- Added EPUB support (Issue #301)\n- Added Markdown support (Issue #302)\n- Fixed a regression in header/footer image scaling (Issue #303)\n- Documentation updates (Issue #305)\n- Compiler fixes (Issue #304, Issue #306)\n- Fixed a bug when running HTMLDOC as a macOS application.\n- Updated the bundled libpng to v1.6.29.\n\n\n# Changes in HTMLDOC v1.8.30\n\n- Updated documentation to reflect new project page on Github.\n- Dropped old CDE and IRIX desktop integration files.\n- Cleaned up the GUI and adopted new default text editors for Linux and macOS.\n- PAGE BREAK comments at the end of a file in web page mode would lose the\n  first page (Issue #251)\n- Fixed the scaling of header/footer images to limit them to the height of the\n  header or footer (Issue #273)\n- Fixed an issue with the top-level makefile not exiting with an error as\n  needed (Issue #282)\n- Fixed a URL referencing bug when the same hostname but a different port was\n  used (Issue #290)\n- Fixed build issue on macOS (Issue #291)\n- Fixed handling of indexed+alpha PNG images (Issue #295)\n\n\n# Changes in HTMLDOC v1.8.29\n\n- Updated local PNG library to version 1.6.20.\n- Updated local JPEG library to version 9b.\n- Dropped support for OpenSSL.\n- Added configure script support for libjpeg-turbo.\n- Updated HTTP code to latest CUPS/ippsample sources.\n- Duplex PDF output incorrectly forced an even number of pages\n- The table of contents showed the wrong page numbers after headings containing\n  the \"_HD_OMIT_TOC\" attribute.\n- Fixed reported build issues\n- The configure script's --enable-local* options did not work.\n\n\n# Changes in HTMLDOC v1.8.28\n\n- Updated local zlib to version 1.2.8.\n- Updated local PNG library to version 1.6.8.\n- Updated local JPEG library to version 9.\n- Updated default PDF version to 1.4.\n- SECURITY: Fixed three buffer overflow issues when reading AFM files and\n  parsing page sizes.\n- Fixed incompatibility with Fortify's version of strcpy, which does not work\n  properly with variable-length arrays\n- Fixed compilation against PNG library 1.5 or later\n- Fixed documentation errors\n- Marked Zapf-Dingbats as a standard font\n- Fixed GPL license text in GUI\n- Fixed a table formatting problem when a column has multiple colspan values\n- Fixed parsing of HTML comments\n- Fixed potential out-of-bounds read in table-of-contents rendering code\n- Fixed handling of image URLs with ampersands in them\n- Fixed top/bottom margins for logo and header/footer images\n- Fixed image alignment bug\n- Fixed X11 build problem\n\n\n# Changes in HTMLDOC v1.8.27\n\n- Fixed a crash bug that appeared when more than 10 blank pages were present in\n  a document\n- Color changes were not reflected in PRE text\n- Remote URLs did not always work on older operating systems\n- Image filenames using % escapes were not decoded properly.\n- Rows using BGCOLOR that spanned across multiple pages did not render properly\n- Rows no longer start on a new page due to a cell with both HEIGHT and ROWSPAN\n  specified\n- CMYK JPEG images caused HTMLDOC to crash\n- Table cell width calculations didn't always account for the proper minimum\n  width\n- Images were not copied when generating indexed HTML output to a directory\n- Changing the bottom margin resulted in text that was formatted below the\n  bottom margin.\n- The Monospace-Oblique font was not embedded properly in PDF files.\n\n\n# Changes in HTMLDOC v1.8.26\n\n- Outline and keyword strings in PDF files are now stored as Unicode\n- The Flate compression code could get in an infinite loop if it ran out of\n  memory\n- Book files saved from the GUI did not handle filenames with spaces\n- Fixed and re-enabled the ASCII85Device filter support in PostScript Level 2/3\n  output\n- Character entities in the first word of a file were not rendered properly\n- Fixed-size table columns were incorrectly resized when a table width was also\n  specified and there was extra space to distribute\n- Text could \"walk\" up or down when in-line images were used\n- Row backgrounds incorrectly replaced cell backgrounds when the first cell in a\n  row used ROWSPAN\n- HTMLDOC did not correctly parse FONT FACE attributes\n- Images in Level 2/3 PostScript output did not work on some printers\n- The GUI did not use the first page header\n\n\n# Changes in HTMLDOC v1.8.25\n\n- Added \"--overflow\" and \"--no-overflow\" command-line options to show or hide\n  the content-too-large errors; the default is \"--no-overflow\".\n- Added \"--header1\" command-line option and \"HEADER1\" page comments to set the\n  page header for the first page of each chapter.\n- Added \"timing\" and \"remotebytes\" debug data generation.\n- Added DejaVu font collection to better support Cyrillic and Greek text; the\n  new fonts are available under the generic names \"monospace\", \"sans\", and\n  \"serif\".\n- Added \"--referer\" command-line option and corresponding CGI-mode support to\n  pass Referer: information in HTTP requests\n- On Windows, HTMLDOC now logs CGI mode errors to a file called \"htmldoc.log\" in\n  the Windows temporary directory.\n- HTMLDOC no longer uses Base-85 encoding for image data when producing Level 2\n  and 3 PostScript output. It appears that many printers and PostScript\n  interpreters cannot properly decode this data when the original image data is\n  not a multiple of 8 bits.\n- HTMLDOC now renders STRONG elements in boldface instead of bold-italic to\n  match the W3C recommendations.\n- HTMLDOC now automatically inserts a TR element before a TD or TH element as\n  needed to improve web site compatibility; this also triggers a HTML error in\n  --strict mode.\n- \"$HFIMAGEn\" didn't work in a header/footer string.\n- HTMLDOC could crash when rendering a table.\n- Book files were not used in CGI mode\n- Cookies were not sent in HTTP requests\n- Table cells were not aligned properly when the ROWSPAN attribute was set to 1\n- HTMLDOC crashed when rendering unresolved hyperlinks in aligned images\n- Documented the HTMLDOC_NOCGI environment variable\n- HTMLDOC sometimes crashed when rendering tables with background colors\n- HTMLDOC would crash when writing encrypted strings longer than 1024 bytes\n- HTMLDOC didn't set the data directory when running in CGI mode on Windows.\n- HTMLDOC could crash when loading the Symbol.afm file\n- HTMLDOC did not always honor HEIGHT attributes in table rows.\n- Tables with a mix of colspan and rowspan sometimes caused cells to be moved\n  vertically outside the cell.\n", "/*\n * Filename routines for HTMLDOC, a HTML document processing program.\n *\n * Copyright \u00a9\u00a02011-2021 by Michael R Sweet.\n * Copyright \u00a9\u00a01997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"file.h\"\n#include \"http.h\"\n#include \"progress.h\"\n#include \"debug.h\"\n\n#if defined(WIN32)\n#  include <io.h>\n#else\n#  include <unistd.h>\n#endif /* WIN32 */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <ctype.h>\n\n\n\n/*\n * Temporary file definitions...\n */\n\n#ifdef WIN32\n#  define getpid\tGetCurrentProcessId\n#  define TEMPLATE\t\"%s/%08lx.%06d.tmp\"\n#  define OPENMODE\t(_O_CREAT | _O_RDWR | _O_TRUNC | _O_BINARY)\n#  define OPENPERM\t(_S_IREAD | _S_IWRITE)\n#else\n#  define TEMPLATE\t\"%s/%06ld.%06d.tmp\"\n#  define OPENMODE\t(O_CREAT | O_RDWR | O_EXCL | O_TRUNC)\n#  define OPENPERM\t0600\n#endif /* WIN32 */\n\n\n/*\n * Cache file structure...\n */\n\ntypedef struct\t\t/* Cache for all temporary files */\n{\n  char\t*name;\t\t\t\t/* Temporary filename */\n  char\t*url;\t\t\t\t/* URL */\n} cache_t;\n\n\n/*\n * Local globals...\n */\n\nchar\tproxy_scheme[32] = \"\",\t\t/* Proxy scheme */\n\tproxy_host[HTTP_MAX_URI] = \"\";\t/* Proxy hostname */\nint\tproxy_port = 0;\t\t\t/* Proxy port */\nhttp_t\t*http = NULL;\t\t\t/* Connection to remote server */\nsize_t\tweb_files = 0,\t\t\t/* Number of temporary files */\n\tweb_alloc = 0;\t\t\t/* Number of allocated files */\ncache_t\t*web_cache = NULL;\t\t/* Cache array */\nint\tno_local = 0;\t\t\t/* Non-zero to disable local files */\nchar\tcookies[1024] = \"\";\t\t/* HTTP cookies, if any */\nchar\treferer_url[HTTP_MAX_VALUE] = \"\";\n\t\t\t\t\t/* HTTP referer, if any */\n\n\n/*\n * 'file_basename()' - Return the base filename without directory or target.\n */\n\nconst char *\t\t\t/* O - Base filename */\nfile_basename(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*basename;\t/* Pointer to directory separator */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL)\n    return (NULL);\n\n  if ((basename = strrchr(s, '/')) != NULL)\n    basename ++;\n  else if ((basename = strrchr(s, '\\\\')) != NULL)\n    basename ++;\n  else\n    basename = (char *)s;\n\n  if (basename[0] == '#')\n    return (NULL);\n\n  if (strchr(basename, '#') == NULL)\n    return (basename);\n\n  strlcpy(buf, basename, sizeof(buf));\n  *(char *)strchr(buf, '#') = '\\0';\n\n  return (buf);\n}\n\n\n/*\n * 'file_cleanup()' - Close an open HTTP connection and remove temporary files...\n */\n\nvoid\nfile_cleanup(void)\n{\n  size_t\ti;\t\t\t/* Looping var */\n  char\t\tfilename[1024];\t\t/* Temporary file */\n  struct stat\tfileinfo;\t\t/* File information */\n  size_t\tremotebytes;\t\t/* Size of remote data */\n  const char\t*tmpdir;\t\t/* Temporary directory */\n#ifdef WIN32\n  char\t\ttmppath[1024];\t\t/* Temporary directory */\n#endif /* WIN32 */\n  const char\t*debug;\t\t\t/* HTMLDOC_DEBUG env var */\n\n\n  if (http)\n  {\n    httpClose(http);\n    http = NULL;\n  }\n\n#ifdef WIN32\n  if ((tmpdir = getenv(\"TEMP\")) == NULL)\n  {\n    GetTempPath(sizeof(tmppath), tmppath);\n    tmpdir = tmppath;\n  }\n#else\n  if ((tmpdir = getenv(\"TMPDIR\")) == NULL)\n    tmpdir = \"/var/tmp\";\n#endif /* WIN32 */\n\n /*\n  * Report on the remote data bytes that were downloaded...\n  */\n\n  debug = getenv(\"HTMLDOC_DEBUG\");\n\n  if (debug &&\n      (strstr(debug, \"all\") != NULL || strstr(debug, \"remotebytes\") != NULL))\n  {\n    for (i = 0, remotebytes = 0; i < web_files; i ++)\n      if (web_cache[i].url)\n      {\n\tsnprintf(filename, sizeof(filename), TEMPLATE, tmpdir, (long)getpid(), (int)(i + 1));\n        if (!stat(filename, &fileinfo))\n\t  remotebytes += (size_t)fileinfo.st_size;\n      }\n\n    progress_error(HD_ERROR_NONE, \"REMOTEBYTES: %ld\", (long)remotebytes);\n  }\n\n /*\n  * Check to see if we want to leave the temporary files around for\n  * debugging...\n  */\n\n  if (debug &&\n      (strstr(debug, \"all\") != NULL || strstr(debug, \"tempfiles\") != NULL))\n  {\n   /*\n    * Yes, leave the files, but show the mapping from filename to URL...\n    */\n\n    progress_error(HD_ERROR_NONE, \"DEBUG: Temporary File Summary\");\n    progress_error(HD_ERROR_NONE, \"DEBUG:\");\n    progress_error(HD_ERROR_NONE, \"DEBUG: URL                             Filename\");\n    progress_error(HD_ERROR_NONE, \"DEBUG: ------------------------------- ---------------------\");\n\n    for (i = 0; i < web_files; i ++)\n    {\n      snprintf(filename, sizeof(filename), TEMPLATE, tmpdir, (long)getpid(), (int)(i + 1));\n      progress_error(HD_ERROR_NONE, \"DEBUG: %-31.31s %s\\n\", web_cache[i].url ? web_cache[i].url : \"none\", filename);\n    }\n\n    progress_error(HD_ERROR_NONE, \"DEBUG:\");\n\n    return;\n  }\n\n  while (web_files > 0)\n  {\n    snprintf(filename, sizeof(filename), TEMPLATE, tmpdir, (long)getpid(), (int)web_files);\n\n    if (unlink(filename))\n      progress_error(HD_ERROR_DELETE_ERROR,\n                     \"Unable to delete temporary file \\\"%s\\\": %s\",\n                     filename, strerror(errno));\n\n    web_files --;\n\n    if (web_cache[web_files].name)\n      free(web_cache[web_files].name);\n    if (web_cache[web_files].url)\n      free(web_cache[web_files].url);\n  }\n\n  if (web_alloc)\n  {\n    free(web_cache);\n\n    web_alloc = 0;\n    web_cache = NULL;\n  }\n}\n\n\n/*\n * 'file_cookies()' - Set the HTTP cookies for remote accesses.\n */\n\nvoid\nfile_cookies(const char *s)\t\t/* I - Cookie string or NULL */\n{\n  if (s)\n    strlcpy(cookies, s, sizeof(cookies));\n  else\n    cookies[0] = '\\0';\n}\n\n\n/*\n * 'file_directory()' - Return the directory without filename or target.\n */\n\nconst char *\t\t\t/* O - Directory for file */\nfile_directory(const char *s)\t/* I - Filename or URL */\n{\n  char\t\t*dir;\t\t/* Pointer to directory separator */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL || !strncmp(s, \"data:\", 5))\n    return (NULL);\n\n  if (strncmp(s, \"http://\", 7) == 0 || strncmp(s, \"https://\", 8) == 0)\n  {\n   /*\n    * Handle URLs...\n    */\n\n    char\tscheme[HTTP_MAX_URI],\n\t\tusername[HTTP_MAX_URI],\n\t\thostname[HTTP_MAX_URI],\n\t\tresource[HTTP_MAX_URI];\n    int\t\tport;\n\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, s, scheme, sizeof(scheme),\n                    username, sizeof(username), hostname, sizeof(hostname),\n\t\t    &port, resource, sizeof(resource));\n    if ((dir = strrchr(resource, '/')) != NULL)\n      *dir = '\\0';\n\n    httpAssembleURI(HTTP_URI_CODING_ALL, buf, sizeof(buf), scheme, username,\n                    hostname, port, resource);\n  }\n  else\n  {\n   /*\n    * Normal stuff...\n    */\n\n    strlcpy(buf, s, sizeof(buf));\n\n    if ((dir = strrchr(buf, '/')) != NULL)\n      *dir = '\\0';\n    else if ((dir = strrchr(buf, '\\\\')) != NULL)\n      *dir = '\\0';\n    else\n      return (\".\");\n\n    if (strncmp(buf, \"file:\", 5) == 0)\n      hd_strcpy(buf, buf + 5);\n\n    if (!buf[0])\n      /* Safe because buf is more than 2 chars long */\n      strlcpy(buf, \"/\", sizeof(buf));\n  }\n\n  return (buf);\n}\n\n\n/*\n * 'file_extension()' - Return the extension of a file without the target.\n */\n\nconst char *\t\t\t/* O - File extension */\nfile_extension(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*extension;\t/* Pointer to directory separator */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n    return (\"jpg\");\n  else if (!strncmp(s, \"data:image/png;\", 15))\n    return (\"png\");\n  else if ((extension = strrchr(s, '/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  *(char *)strchr(buf, '#') = '\\0';\n\n  return (buf);\n}\n\n\n/*\n * 'file_find_check()' - Check to see if the specified file or URL exists...\n */\n\nstatic const char *\t\t\t/* O - Pathname or NULL */\nfile_find_check(const char *filename)\t/* I - File or URL */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  int\t\tretry;\t\t\t/* Current retry */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method/scheme */\n\t\tusername[HTTP_MAX_URI],\t/* Username:password */\n\t\thostname[HTTP_MAX_URI],\t/* Hostname */\n\t\tresource[HTTP_MAX_URI];\t/* Resource */\n  int\t\tport;\t\t\t/* Port number */\n  const char\t*connscheme;\t\t/* Scheme for connection */\n  const char\t*connhost;\t\t/* Host to connect to */\n  int\t\tconnport;\t\t/* Port to connect to */\n  char\t\tconnpath[HTTP_MAX_URI],\t/* Path for GET */\n\t\tconnauth[HTTP_MAX_VALUE];/* Auth string */\n  http_status_t\tstatus;\t\t\t/* Status of request... */\n  FILE\t\t*fp;\t\t\t/* Web file */\n  ssize_t\tbytes,\t\t\t/* Bytes read */\n\t\tcount;\t\t\t/* Number of bytes so far */\n  off_t\t\ttotal;\t\t\t/* Total bytes in file */\n  char\t\ttempname[HTTP_MAX_URI];\t/* Temporary filename */\n\n\n  DEBUG_printf((\"file_find_check(filename=\\\"%s\\\")\\n\", filename));\n\n  if (strncmp(filename, \"http:\", 5) == 0 || strncmp(filename, \"//\", 2) == 0)\n    strlcpy(scheme, \"http\", sizeof(scheme));\n  else if (strncmp(filename, \"https:\", 6) == 0)\n    strlcpy(scheme, \"https\", sizeof(scheme));\n  else if (strncmp(filename, \"data:\", 5) == 0)\n    strlcpy(scheme, \"data\", sizeof(scheme));\n  else\n    strlcpy(scheme, \"file\", sizeof(scheme));\n\n  if (strcmp(scheme, \"file\") == 0)\n  {\n   /*\n    * Return immediately if we aren't allowing access to local files...\n    */\n\n    if (no_local)\n      return (NULL);\n\n   /*\n    * If the filename exists, return the filename...\n    */\n\n    if (!access(filename, 0))\n    {\n      DEBUG_printf((\"file_find_check: Returning \\\"%s\\\"!\\n\", filename));\n      return (filename);\n    }\n  }\n  else if (!strcmp(scheme, \"data\"))\n  {\n   /*\n    * Data URI; look it up in the web cache, then save to a temporary file...\n    */\n\n    const char\t*data;\t\t\t/* Pointer to data */\n    int\t\tlen;\t\t\t/* Number of bytes */\n    char\tbuffer[8192];\t\t/* Data buffer */\n\n    for (i = 0; i < (int)web_files; i ++)\n    {\n      if (web_cache[i].url && strcmp(web_cache[i].url, filename) == 0)\n      {\n        DEBUG_printf((\"file_find_check: Returning \\\"%s\\\" for \\\"%s\\\".\\n\", web_cache[i].name, filename));\n        return (web_cache[i].name);\n      }\n    }\n\n    if ((data = strstr(filename, \";base64,\")) != NULL)\n    {\n      len = sizeof(buffer);\n      httpDecode64_2(buffer, &len, data + 8);\n\n      if ((fp = file_temp(tempname, sizeof(tempname))) == NULL)\n      {\n\tprogress_hide();\n\tprogress_error(HD_ERROR_WRITE_ERROR, \"Unable to create temporary file \\\"%s\\\": %s\", tempname, strerror(errno));\n\treturn (NULL);\n      }\n\n      fwrite(buffer, 1, (size_t)len, fp);\n      fclose(fp);\n\n      progress_hide();\n\n      web_cache[web_files - 1].url = strdup(filename);\n\n      DEBUG_printf((\"file_find_check: Returning \\\"%s\\\" for \\\"%s\\\".\\n\", tempname, filename));\n\n      return (web_cache[web_files - 1].name);\n    }\n  }\n  else\n  {\n   /*\n    * Remote file; look it up in the web cache, and then try getting it\n    * from the remote system...\n    */\n\n    for (i = 0; i < (int)web_files; i ++)\n    {\n      if (web_cache[i].url && strcmp(web_cache[i].url, filename) == 0)\n      {\n        DEBUG_printf((\"file_find_check: Returning \\\"%s\\\" for \\\"%s\\\".\\n\", web_cache[i].name, filename));\n        return (web_cache[i].name);\n      }\n    }\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, filename, scheme, sizeof(scheme),\n                    username, sizeof(username), hostname, sizeof(hostname),\n\t\t    &port, resource, sizeof(resource));\n\n    for (status = HTTP_STATUS_ERROR, retry = 0; status != HTTP_STATUS_OK && retry < 5; retry ++)\n    {\n      if (proxy_port)\n      {\n        // Send request to proxy host...\n        connscheme = proxy_scheme;\n        connhost   = proxy_host;\n        connport   = proxy_port;\n        httpAssembleURI(HTTP_URI_CODING_ALL, connpath, sizeof(connpath), scheme, NULL, hostname, port, resource);\n      }\n      else\n      {\n        // Send request to host directly...\n        connscheme = scheme;\n        connhost   = hostname;\n        connport   = port;\n        strlcpy(connpath, resource, sizeof(connpath));\n      }\n\n      if (connport != httpAddrPort(httpGetAddress(http)) ||\n#ifdef HAVE_SSL\n\t  (!strcmp(connscheme, \"https\") && !httpIsEncrypted(http)) ||\n          (!strcmp(connscheme, \"http\") && httpIsEncrypted(http)) ||\n#endif // HAVE_SSL\n          strcasecmp(httpGetHostname(http, tempname, sizeof(tempname)), hostname))\n      {\n        httpClose(http);\n        http = NULL;\n      }\n\n      if (http == NULL)\n      {\n        progress_show(\"Connecting to %s...\", connhost);\n\n        http_encryption_t encryption = !strcmp(connscheme, \"http\") ? HTTP_ENCRYPTION_IF_REQUESTED : HTTP_ENCRYPTION_ALWAYS;\n\n        if ((http = httpConnect2(connhost, connport, NULL, AF_UNSPEC, encryption, 1, 30000, NULL)) == NULL)\n\t{\n          progress_hide();\n          progress_error(HD_ERROR_NETWORK_ERROR, \"Unable to connect to %s:%d\", connhost, connport);\n          return (NULL);\n        }\n      }\n\n      progress_show(\"Getting %s...\", connpath);\n\n      httpClearFields(http);\n      httpSetField(http, HTTP_FIELD_HOST, hostname);\n      httpSetField(http, HTTP_FIELD_CONNECTION, \"Keep-Alive\");\n      httpSetField(http, HTTP_FIELD_REFERER, referer_url);\n\n      if (username[0])\n      {\n        strlcpy(connauth, \"Basic \", sizeof(connauth));\n        httpEncode64_2(connauth + 6, sizeof(connauth) - 6, username, strlen(username));\n        httpSetField(http, HTTP_FIELD_AUTHORIZATION, connauth);\n      }\n\n      if (cookies[0])\n        httpSetCookie(http, cookies);\n\n      if (!httpGet(http, connpath))\n      {\n\twhile ((status = httpUpdate(http)) == HTTP_CONTINUE);\n      }\n      else\n\tstatus = HTTP_ERROR;\n\n      if (status >= HTTP_STATUS_MULTIPLE_CHOICES && status < HTTP_STATUS_BAD_REQUEST)\n      {\n        // Redirect status code, grab the new location...\n        const char *newurl = httpGetField(http, HTTP_FIELD_LOCATION);\n\t\t\t\t\t// New URL\n        char\tnewresource[256];\t// New resource\n\n        progress_show(\"Redirecting to %s...\", newurl);\n\thttpSeparateURI(HTTP_URI_CODING_ALL, newurl, scheme, sizeof(scheme), username, sizeof(username), hostname, sizeof(hostname), &port, newresource, sizeof(newresource));\n\n        // Don't use new resource path if it is empty...\n        if (strchr(newurl + strlen(scheme) + 3, '/'))\n          strlcpy(resource, newresource, sizeof(resource));\n\n        // ... then flush any text in the response...\n\thttpFlush(http);\n      }\n    }\n\n    if (status != HTTP_OK)\n    {\n      progress_hide();\n      progress_error((HDerror)status, \"%s (%s)\", httpStatus(status), filename);\n      httpFlush(http);\n      return (NULL);\n    }\n\n    if ((fp = file_temp(tempname, sizeof(tempname))) == NULL)\n    {\n      progress_hide();\n      progress_error(HD_ERROR_WRITE_ERROR,\n                     \"Unable to create temporary file \\\"%s\\\": %s\", tempname,\n                     strerror(errno));\n      httpFlush(http);\n      return (NULL);\n    }\n\n    if ((total = httpGetLength2(http)) == 0)\n      total = 8192;\n\n    count = 0;\n    while ((bytes = httpRead2(http, resource, sizeof(resource))) > 0)\n    {\n      count += bytes;\n      progress_update((100 * count / total) % 101);\n      fwrite(resource, 1, (size_t)bytes, fp);\n    }\n\n    progress_hide();\n\n    fclose(fp);\n\n    web_cache[web_files - 1].url = strdup(filename);\n\n    DEBUG_printf((\"file_find_check: Returning \\\"%s\\\" for \\\"%s\\\".\\n\", tempname, filename));\n\n    return (web_cache[web_files - 1].name);\n  }\n\n  return (NULL);\n}\n\n\n/*\n * 'file_find()' - Find a file in one of the path directories.\n */\n\nconst char *\t\t\t\t/* O - Pathname or NULL */\nfile_find(const char *path,\t\t/* I - Path \"dir;dir;dir\" */\n          const char *s)\t\t/* I - File to find */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  char\t\t*temp;\t\t\t/* Current position in filename */\n  const char\t*sptr;\t\t\t/* Pointer into \"s\" */\n  int\t\tch;\t\t\t/* Quoted character */\n  char\t\tbasename[HTTP_MAX_URI];\t/* Base (unquoted) filename */\n  const char\t*realname;\t\t/* Real filename */\n  static char\tfilename[HTTP_MAX_URI];\t/* Current filename */\n\n\n /*\n  * If the filename is NULL, return NULL...\n  */\n\n  if (s == NULL)\n    return (NULL);\n\n  DEBUG_printf((\"file_find(path=\\\"%s\\\", s=\\\"%s\\\")\\n\", path ? path : \"(null)\", s));\n\n /*\n  * See if this is a cached remote file...\n  */\n\n  for (i = 0; i < (int)web_files; i ++)\n  {\n    if (strcmp(s, web_cache[i].name) == 0)\n    {\n      DEBUG_printf((\"file_find: Returning cache file \\\"%s\\\"!\\n\", s));\n      return (web_cache[i].name);\n    }\n  }\n\n  DEBUG_printf((\"file_find: \\\"%s\\\" not in web cache of %d files...\\n\", s, (int)web_files));\n\n /*\n  * Make sure the filename is not quoted...\n  */\n\n  if (strchr(s, '%') == NULL)\n  {\n    strlcpy(basename, s, sizeof(basename));\n  }\n  else\n  {\n    for (sptr = s, temp = basename;\n\t *sptr && temp < (basename + sizeof(basename) - 1);)\n    {\n      if (*sptr == '%' && isxdigit(sptr[1]) && isxdigit(sptr[2]))\n      {\n       /*\n\t* Dequote %HH...\n\t*/\n\n\tif (isalpha(sptr[1]))\n\t  ch = (tolower(sptr[1]) - 'a' + 10) << 4;\n\telse\n\t  ch = (sptr[1] - '0') << 4;\n\n\tif (isalpha(sptr[2]))\n\t  ch |= tolower(sptr[2]) - 'a' + 10;\n\telse\n\t  ch |= sptr[2] - '0';\n\n\t*temp++ = (char)ch;\n\n\tsptr += 3;\n      }\n      else\n\t*temp++ = *sptr++;\n    }\n\n    *temp = '\\0';\n  }\n\n /*\n  * If we got a complete URL, we don't use the path...\n  */\n\n  if (path != NULL && !path[0])\n  {\n    DEBUG_puts(\"file_find: Resetting path to NULL since path is empty...\");\n    path = NULL;\n  }\n\n  if (strncmp(s, \"http:\", 5) == 0 ||\n      strncmp(s, \"https:\", 6) == 0 ||\n      strncmp(s, \"//\", 2) == 0)\n  {\n    DEBUG_puts(\"file_find: Resetting path to NULL since filename is a URL...\");\n    path = NULL;\n  }\n\n /*\n  * Loop through the path as needed...\n  */\n\n  if (path != NULL)\n  {\n    filename[sizeof(filename) - 1] = '\\0';\n\n    while (*path != '\\0')\n    {\n     /*\n      * Copy the path directory...\n      */\n\n      temp = filename;\n\n      while (*path != ';' && *path && temp < (filename + sizeof(filename) - 1))\n\t*temp++ = *path++;\n\n      if (*path == ';')\n\tpath ++;\n\n     /*\n      * Append a slash as needed, then the filename...\n      */\n\n      if (temp > filename && temp < (filename + sizeof(filename) - 1) &&\n          basename[0] != '/')\n\t*temp++ = '/';\n\n      strlcpy(temp, basename, sizeof(filename) - (size_t)(temp - filename));\n\n     /*\n      * See if the file or URL exists...\n      */\n\n      if ((realname = file_find_check(filename)) != NULL)\n\treturn (realname);\n    }\n  }\n\n  return (file_find_check(s));\n}\n\n\n/*\n * 'file_gets()' - Read a line from a file terminated with CR, LF, or CR LF.\n */\n\nchar *\t\t\t\t/* O - Line from file or NULL on EOF */\nfile_gets(char  *buf,\t\t/* I - Line buffer */\n\t  int   buflen,\t\t/* I - Length of buffer */\n\t  FILE  *fp)\t\t/* I - File to read from */\n{\n  int\t\tch;\t\t/* Character from file */\n  char\t\t*ptr,\t\t/* Current position in line buffer */\n\t\t*end;\t\t/* End of line buffer */\n\n\n /*\n  * Range check everything...\n  */\n\n  if (fp == NULL || buf == NULL || buflen < 2)\n    return (NULL);\n\n /*\n  * Now loop until we have a valid line...\n  */\n\n  ptr = buf;\n  end = buf + buflen - 1;\n\n  for (;;)\n  {\n    if ((ch = getc(fp)) == EOF)\n      break;\n    else if (ch == '\\r')\n    {\n     /*\n      * See if we have CR or CR LF...\n      */\n\n      int nextch = getc(fp);\n\n      if (nextch == EOF || nextch == '\\n')\n        break;\n\n     /*\n      * No LF, so save the next char for later...\n      */\n\n      ungetc(nextch, fp);\n\n      break;\n    }\n    else if (ch == '\\n')\n      break;\n    else if (ch == '\\\\')\n    {\n     /*\n      * Handle \\ escapes, to continue to multiple lines...\n      */\n\n      int nextch = getc(fp);\n\n      if (nextch == EOF)\n        break;\n      else if (nextch == '\\r')\n      {\n        nextch = getc(fp);\n\n\tif (nextch == EOF)\n\t  break;\n\telse if (nextch != '\\n')\n\t  ungetc(nextch, fp);\n      }\n      else if (nextch != '\\n' && ptr < end)\n        *ptr++ = (char)nextch;\n    }\n    else if (ptr < end)\n      *ptr++ = (char)ch;\n  }\n\n  *ptr = '\\0';\n\n  if (ch != EOF || ptr > buf)\n    return (buf);\n  else\n    return (NULL);\n}\n\n\n/*\n * 'file_localize()' - Localize a filename for the new working directory.\n */\n\nconst char *\t\t\t\t/* O - New filename */\nfile_localize(const char *filename,\t/* I - Filename */\n              const char *newcwd)\t/* I - New directory */\n{\n  const char\t*newslash;\t\t/* Directory separator */\n  char\t\t*slash;\t\t\t/* Directory separator */\n  char\t\tcwd[1024];\t\t/* Current directory */\n  char\t\ttemp[1024];\t\t/* Temporary pathname */\n  static char\tnewfilename[1024];\t/* New filename */\n\n\n  if (filename[0] == '\\0')\n    return (\"\");\n\n  if (file_method(filename))\n    return (filename);\n\n  getcwd(cwd, sizeof(cwd));\n  if (newcwd == NULL)\n    newcwd = cwd;\n\n#if defined(WIN32) || defined(__EMX__)\n  if (filename[0] != '/' &&\n      filename[0] != '\\\\' &&\n      !(isalpha(filename[0]) && filename[1] == ':'))\n#else\n  if (filename[0] != '/')\n#endif /* WIN32 || __EMX__ */\n  {\n    for (newslash = filename; strncmp(newslash, \"../\", 3) == 0; newslash += 3)\n#if defined(WIN32) || defined(__EMX__)\n    {\n      if ((slash = strrchr(cwd, '/')) == NULL)\n        slash = strrchr(cwd, '\\\\');\n      if (slash != NULL)\n        *slash = '\\0';\n    }\n#else\n      if ((slash = strrchr(cwd, '/')) != NULL)\n        *slash = '\\0';\n#endif /* WIN32 || __EMX__ */\n\n    snprintf(temp, sizeof(temp), \"%s/%s\", cwd, newslash);\n  }\n  else\n    strlcpy(temp, filename, sizeof(temp));\n\n  for (slash = temp, newslash = newcwd;\n       *slash != '\\0' && *newslash != '\\0';\n       slash ++, newslash ++)\n    if ((*slash == '/' || *slash == '\\\\') &&\n        (*newslash == '/' || *newslash == '\\\\'))\n      continue;\n    else if (*slash != *newslash)\n      break;\n\n  while (*slash != '/' && *slash != '\\\\' && slash > temp)\n    slash --;\n\n  if (*slash == '/' || *slash == '\\\\')\n    slash ++;\n\n#if defined(WIN32) || defined(__EMX__)\n  if (isalpha(slash[0]) && slash[1] == ':')\n    return ((char *)filename); /* Different drive letter... */\n#endif /* WIN32 || __EMX__ */\n\n  if (*newslash != '\\0')\n    while (*newslash != '/' && *newslash != '\\\\' && newslash > newcwd)\n      newslash --;\n\n  newfilename[0] = '\\0';\n\n  while (*newslash != '\\0')\n  {\n    if (*newslash == '/' || *newslash == '\\\\')\n      strlcat(newfilename, \"../\", sizeof(newfilename));\n    newslash ++;\n  }\n\n  strlcat(newfilename, slash, sizeof(newfilename));\n\n  return (newfilename);\n}\n\n\n/*\n * 'file_method()' - Return the method for a filename or URL.\n *\n * Returns NULL if the URL is a local file.\n */\n\nconst char *\t\t\t/* O - Method string (\"http\", \"ftp\", etc.) */\nfile_method(const char *s)\t/* I - Filename or URL */\n{\n  if (strncmp(s, \"data:\", 5) == 0)\n    return (\"data\");\n  else if (strncmp(s, \"http:\", 5) == 0)\n    return (\"http\");\n  else if (strncmp(s, \"https:\", 6) == 0)\n    return (\"https\");\n  else if (strncmp(s, \"ftp:\", 4) == 0)\n    return (\"ftp\");\n  else if (strncmp(s, \"mailto:\", 7) == 0)\n    return (\"mailto\");\n  else\n    return (NULL);\n}\n\n\n/*\n * 'file_nolocal()' - Disable access to local files.\n */\n\nvoid\nfile_nolocal(void)\n{\n  no_local = 1;\n}\n\n\n/*\n * 'file_proxy()' - Set the proxy host for all HTTP requests.\n */\n\nvoid\nfile_proxy(const char *url)\t/* I - URL of proxy server */\n{\n   char\tscheme[HTTP_MAX_URI],\t/* Method name (must be HTTP) */\n\tusername[HTTP_MAX_URI],\t/* Username:password information */\n\thostname[HTTP_MAX_URI],\t/* Hostname */\n\tresource[HTTP_MAX_URI];\t/* Resource name */\n  int\tport;\t\t\t/* Port number */\n\n\n  if (url == NULL || url[0] == '\\0')\n  {\n    proxy_host[0] = '\\0';\n    proxy_port    = 0;\n  }\n  else\n  {\n    httpSeparateURI(HTTP_URI_CODING_ALL, url, scheme, sizeof(scheme),\n                    username, sizeof(username), hostname, sizeof(hostname),\n\t\t    &port, resource, sizeof(resource));\n\n    if (strcmp(scheme, \"http\") == 0)\n    {\n      strlcpy(proxy_host, hostname, sizeof(proxy_host));\n      proxy_port = port;\n    }\n  }\n}\n\n\n/*\n * 'file_referer()' - Set the HTTP referer for remote accesses.\n */\n\nvoid\nfile_referer(const char *referer)\t/* I - Referer URL */\n{\n  if (referer)\n    strlcpy(referer_url, referer, sizeof(referer_url));\n  else\n    referer_url[0] = '\\0';\n}\n\n\n/*\n * 'file_rlookup()' - Lookup a filename to find the original URL, if applicable.\n */\n\nconst char *\t\t\t\t/* O - URL or filename */\nfile_rlookup(const char *filename)\t/* I - Filename */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  cache_t\t*wc;\t\t\t/* Current cache file */\n\n\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n    if (!strcmp(wc->name, filename))\n      return (wc->url);\n\n  return (filename);\n}\n\n\n/*\n * 'file_target()' - Return the target of a link.\n */\n\nconst char *\t\t\t/* O - Target name */\nfile_target(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*basename;\t/* Pointer to directory separator */\n  const char\t*target;\t/* Pointer to target */\n\n\n  if (s == NULL)\n    return (NULL);\n\n  if ((basename = strrchr(s, '/')) != NULL)\n    basename ++;\n  else if ((basename = strrchr(s, '\\\\')) != NULL)\n    basename ++;\n  else\n    basename = s;\n\n  if ((target = strchr(basename, '#')) != NULL)\n    return (target + 1);\n  else\n    return (NULL);\n}\n\n\n/*\n * 'file_temp()' - Create and open a temporary file.\n */\n\nFILE *\t\t\t\t\t/* O - Temporary file */\nfile_temp(char *name,\t\t\t/* O - Filename */\n          int  len)\t\t\t/* I - Length of filename buffer */\n{\n  cache_t\t*temp;\t\t\t/* Pointer to cache entry */\n  FILE\t\t*fp;\t\t\t/* File pointer */\n  int\t\tfd;\t\t\t/* File descriptor */\n  const char\t*tmpdir;\t\t/* Temporary directory */\n#ifdef WIN32\n  char\t\ttmppath[1024];\t\t/* Buffer for temp dir */\n#endif /* WIN32 */\n\n\n /*\n  * Allocate memory for the file cache as needed...\n  */\n\n  if (web_files >= web_alloc)\n  {\n    web_alloc += ALLOC_FILES;\n    if (web_files == 0)\n      temp = (cache_t *)malloc(sizeof(cache_t) * web_alloc);\n    else\n      temp = (cache_t *)realloc(web_cache, sizeof(cache_t) * web_alloc);\n\n    if (temp == NULL)\n    {\n      progress_error(HD_ERROR_OUT_OF_MEMORY,\n                     \"Unable to allocate memory for %d file entries - %s\",\n                     (int)web_alloc, strerror(errno));\n      web_alloc -= ALLOC_FILES;\n      return (NULL);\n    }\n\n    web_cache = temp;\n  }\n\n /*\n  * Clear a new file cache entry...\n  */\n\n  temp = web_cache + web_files;\n\n  temp->name = NULL;\n  temp->url  = NULL;\n  web_files ++;\n\n#ifdef WIN32\n  if ((tmpdir = getenv(\"TEMP\")) == NULL)\n  {\n    GetTempPath(sizeof(tmppath), tmppath);\n    tmpdir = tmppath;\n  }\n#else\n  if ((tmpdir = getenv(\"TMPDIR\")) == NULL)\n    tmpdir = \"/var/tmp\";\n#endif /* WIN32 */\n\n  snprintf(name, (size_t)len, TEMPLATE, tmpdir, (long)getpid(), (int)web_files);\n\n  if ((fd = open(name, OPENMODE, OPENPERM)) >= 0)\n    fp = fdopen(fd, \"w+b\");\n  else\n    fp = NULL;\n\n  if (!fp)\n    web_files --;\n\n  temp->name = strdup(name);\n\n  return (fp);\n}\n"], "fixing_code": ["# Changes in HTMLDOC v1.9.12\n\n- Fixed a crash bug with \"data:\" URIs and EPUB output (Issue #410)\n- Fixed a crash bug with malformed URIs (Issue #418)\n- Fixed some issues reported by Coverity.\n\n\n# Changes in HTMLDOC v1.9.11\n\n- Added high-resolution desktop icons for Linux.\n- Updated the internal HTTP library to fix truncation of redirection URLs\n  (Issue #396)\n- Fixed a regression in the handling of character entities for UTF-8 input\n  (Issue #401)\n- The `--numbered` option did not work when the table-of-contents was disabled\n  (Issue #405)\n\n\n# Changes in HTMLDOC v1.9.10\n\n- Updated local zlib to v1.2.11.\n- Updated local libpng to v1.6.37.\n- Fixed packaging issues on macOS and Windows (Issue #377, Issue #386)\n- Now ignore sRGB profile errors in PNG files (Issue #390)\n- The GUI would crash when saving (Issue #391)\n- Page comments are now allowed in `pre` text (Issue #394)\n\n\n# Changes in HTMLDOC v1.9.9\n\n- Fixed a redirection issue - some sites (incorrectly) provide an incomplete\n  Location: URL in the HTTP response.\n- Fixed https: support on newer versions of Windows (Issue #378)\n- Fixed a problem with remote URLs containing spaces (Issue #379)\n- Fixed a UTF-8 processing bug for Markdown files (Issue #383)\n- Added support for `<FONT FACE=\"monospace\">` (Issue #385)\n\n\n# Changes in HTMLDOC v1.9.8\n\n- Added support for a `HTMLDOC.filename` META keyword that controls the filename\n  reported in CGI mode; the default remains \"htmldoc.pdf\" (Issue #367)\n- Fixed a paragraph formatting issue with large inline images (Issue #369)\n- Fixed a buffer underflow issue (Issue #370)\n- Fixed PDF page numbers (Issue #371)\n- Added support for a new `L` header/footer format (`$LETTERHEAD`), which\n  inserts a letterhead image at its full size (Issue #372, Issue #373,\n  Issue #375)\n- Updated the build documentation (Issue #374)\n\n\n# Changes in HTMLDOC v1.9.7\n\n- Refactored the PRE rendering code to work around compiler optimization bugs\n  (Issue #349)\n- Added support for links with targets (Issue #351)\n- Fixed a table rowspan + valign bug (Issue #360)\n\n\n# Changes in HTMLDOC v1.9.6\n\n- Added support for data URIs (Issue #340)\n- HTMLDOC no longer includes a PDF table of contents when converting a single\n  web page (Issue #344)\n- Updated the markdown support with external links, additional inline markup,\n  and hard line breaks.\n- Links in markdown text no longer render with a leading space as part of the\n  link (Issue #346)\n- Fixed a buffer underflow bug discovered by AddressSanitizer.\n- Fixed a bug in UTF-8 support (Issue #348)\n- PDF output now includes the base language of the input document(s)\n  (Issue #350)\n- Optimized the loading of font widths (Issue #354)\n- Optimized PDF page resources (Issue #356)\n- Optimized the base memory used for font widths (Issue #357)\n- Added proper `&shy;` support (Issue #361)\n- Title files can now be markdown.\n\n\n# Changes in HTMLDOC v1.9.5\n\n- The GUI did not support EPUB output.\n- Empty markdown table cells were not rendered in PDF or PostScript output.\n- The automatically-generated title page now supports both \"docnumber\" and\n  \"version\" metadata.\n- Added support for dc:subject and dc:language metadata in EPUB output from the\n  HTML keywords and lang values.\n- Added support for the subject and language metadata in markdown input.\n- Fixed a buffer underflow bug (Issue #338)\n- `htmldoc --help` now reports whether HTTPS URLs are supported (Issue #339)\n- Fixed an issue with HTML title pages and EPUB output.\n\n\n# Changes in HTMLDOC v1.9.4\n\n- Inline fixed-width text is no longer reduced in size automatically\n  (Issue #309)\n- Optimized initialization of font width data (Issue #334)\n\n\n# Changes in HTMLDOC v1.9.3\n\n- Fixed formatting bugs with aligned images (Issue #322, Issue #324)\n- Fixed support for three digit \"#RGB\" color values (Issue #323)\n- Fixed character set support for markdown metadata.\n- Updated libpng to v1.6.34 (Issue #326)\n- The makefiles did not use the CPPFLAGS value (Issue #328)\n\n\n# Changes in HTMLDOC v1.9.2\n\n- Added Markdown table support.\n- Fixed parsing of TBODY, TFOOT, and THEAD elements in HTML files.\n\n\n# Changes in HTMLDOC v1.9.1\n\n- Fixed monospace font size issue (Issue #309)\n- Added support for reproducible builds (Issue #310)\n- Added limited support for the HTML 4.0 SPAN element (Issue #311)\n- Added (extremely limited) UTF-8 support for input files (Issue #314)\n- Fixed buffer underflow for (invalid) short HTML comments (Issue #316)\n- Now indent PRE text, by popular request.\n- EPUB output now makes sure that `<element property>` is written as\n  `<element property=\"property\">`.\n- Now support both NAME and ID for table-of-contents targets.\n\n\n# Changes in HTMLDOC v1.9\n\n- Added support for repeating a single header row for tables that span multiple\n  pages (Issue #16)\n- Added support for embedding the current filename/URL in the header or footer\n  (Issue #50)\n- Added EPUB support (Issue #301)\n- Added Markdown support (Issue #302)\n- Fixed a regression in header/footer image scaling (Issue #303)\n- Documentation updates (Issue #305)\n- Compiler fixes (Issue #304, Issue #306)\n- Fixed a bug when running HTMLDOC as a macOS application.\n- Updated the bundled libpng to v1.6.29.\n\n\n# Changes in HTMLDOC v1.8.30\n\n- Updated documentation to reflect new project page on Github.\n- Dropped old CDE and IRIX desktop integration files.\n- Cleaned up the GUI and adopted new default text editors for Linux and macOS.\n- PAGE BREAK comments at the end of a file in web page mode would lose the\n  first page (Issue #251)\n- Fixed the scaling of header/footer images to limit them to the height of the\n  header or footer (Issue #273)\n- Fixed an issue with the top-level makefile not exiting with an error as\n  needed (Issue #282)\n- Fixed a URL referencing bug when the same hostname but a different port was\n  used (Issue #290)\n- Fixed build issue on macOS (Issue #291)\n- Fixed handling of indexed+alpha PNG images (Issue #295)\n\n\n# Changes in HTMLDOC v1.8.29\n\n- Updated local PNG library to version 1.6.20.\n- Updated local JPEG library to version 9b.\n- Dropped support for OpenSSL.\n- Added configure script support for libjpeg-turbo.\n- Updated HTTP code to latest CUPS/ippsample sources.\n- Duplex PDF output incorrectly forced an even number of pages\n- The table of contents showed the wrong page numbers after headings containing\n  the \"_HD_OMIT_TOC\" attribute.\n- Fixed reported build issues\n- The configure script's --enable-local* options did not work.\n\n\n# Changes in HTMLDOC v1.8.28\n\n- Updated local zlib to version 1.2.8.\n- Updated local PNG library to version 1.6.8.\n- Updated local JPEG library to version 9.\n- Updated default PDF version to 1.4.\n- SECURITY: Fixed three buffer overflow issues when reading AFM files and\n  parsing page sizes.\n- Fixed incompatibility with Fortify's version of strcpy, which does not work\n  properly with variable-length arrays\n- Fixed compilation against PNG library 1.5 or later\n- Fixed documentation errors\n- Marked Zapf-Dingbats as a standard font\n- Fixed GPL license text in GUI\n- Fixed a table formatting problem when a column has multiple colspan values\n- Fixed parsing of HTML comments\n- Fixed potential out-of-bounds read in table-of-contents rendering code\n- Fixed handling of image URLs with ampersands in them\n- Fixed top/bottom margins for logo and header/footer images\n- Fixed image alignment bug\n- Fixed X11 build problem\n\n\n# Changes in HTMLDOC v1.8.27\n\n- Fixed a crash bug that appeared when more than 10 blank pages were present in\n  a document\n- Color changes were not reflected in PRE text\n- Remote URLs did not always work on older operating systems\n- Image filenames using % escapes were not decoded properly.\n- Rows using BGCOLOR that spanned across multiple pages did not render properly\n- Rows no longer start on a new page due to a cell with both HEIGHT and ROWSPAN\n  specified\n- CMYK JPEG images caused HTMLDOC to crash\n- Table cell width calculations didn't always account for the proper minimum\n  width\n- Images were not copied when generating indexed HTML output to a directory\n- Changing the bottom margin resulted in text that was formatted below the\n  bottom margin.\n- The Monospace-Oblique font was not embedded properly in PDF files.\n\n\n# Changes in HTMLDOC v1.8.26\n\n- Outline and keyword strings in PDF files are now stored as Unicode\n- The Flate compression code could get in an infinite loop if it ran out of\n  memory\n- Book files saved from the GUI did not handle filenames with spaces\n- Fixed and re-enabled the ASCII85Device filter support in PostScript Level 2/3\n  output\n- Character entities in the first word of a file were not rendered properly\n- Fixed-size table columns were incorrectly resized when a table width was also\n  specified and there was extra space to distribute\n- Text could \"walk\" up or down when in-line images were used\n- Row backgrounds incorrectly replaced cell backgrounds when the first cell in a\n  row used ROWSPAN\n- HTMLDOC did not correctly parse FONT FACE attributes\n- Images in Level 2/3 PostScript output did not work on some printers\n- The GUI did not use the first page header\n\n\n# Changes in HTMLDOC v1.8.25\n\n- Added \"--overflow\" and \"--no-overflow\" command-line options to show or hide\n  the content-too-large errors; the default is \"--no-overflow\".\n- Added \"--header1\" command-line option and \"HEADER1\" page comments to set the\n  page header for the first page of each chapter.\n- Added \"timing\" and \"remotebytes\" debug data generation.\n- Added DejaVu font collection to better support Cyrillic and Greek text; the\n  new fonts are available under the generic names \"monospace\", \"sans\", and\n  \"serif\".\n- Added \"--referer\" command-line option and corresponding CGI-mode support to\n  pass Referer: information in HTTP requests\n- On Windows, HTMLDOC now logs CGI mode errors to a file called \"htmldoc.log\" in\n  the Windows temporary directory.\n- HTMLDOC no longer uses Base-85 encoding for image data when producing Level 2\n  and 3 PostScript output. It appears that many printers and PostScript\n  interpreters cannot properly decode this data when the original image data is\n  not a multiple of 8 bits.\n- HTMLDOC now renders STRONG elements in boldface instead of bold-italic to\n  match the W3C recommendations.\n- HTMLDOC now automatically inserts a TR element before a TD or TH element as\n  needed to improve web site compatibility; this also triggers a HTML error in\n  --strict mode.\n- \"$HFIMAGEn\" didn't work in a header/footer string.\n- HTMLDOC could crash when rendering a table.\n- Book files were not used in CGI mode\n- Cookies were not sent in HTTP requests\n- Table cells were not aligned properly when the ROWSPAN attribute was set to 1\n- HTMLDOC crashed when rendering unresolved hyperlinks in aligned images\n- Documented the HTMLDOC_NOCGI environment variable\n- HTMLDOC sometimes crashed when rendering tables with background colors\n- HTMLDOC would crash when writing encrypted strings longer than 1024 bytes\n- HTMLDOC didn't set the data directory when running in CGI mode on Windows.\n- HTMLDOC could crash when loading the Symbol.afm file\n- HTMLDOC did not always honor HEIGHT attributes in table rows.\n- Tables with a mix of colspan and rowspan sometimes caused cells to be moved\n  vertically outside the cell.\n", "/*\n * Filename routines for HTMLDOC, a HTML document processing program.\n *\n * Copyright \u00a9\u00a02011-2021 by Michael R Sweet.\n * Copyright \u00a9\u00a01997-2010 by Easy Software Products.  All rights reserved.\n *\n * This program is free software.  Distribution and use rights are outlined in\n * the file \"COPYING\".\n */\n\n/*\n * Include necessary headers.\n */\n\n#include \"file.h\"\n#include \"http.h\"\n#include \"progress.h\"\n#include \"debug.h\"\n\n#if defined(WIN32)\n#  include <io.h>\n#else\n#  include <unistd.h>\n#endif /* WIN32 */\n\n#include <errno.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <ctype.h>\n\n\n\n/*\n * Temporary file definitions...\n */\n\n#ifdef WIN32\n#  define getpid\tGetCurrentProcessId\n#  define TEMPLATE\t\"%s/%08lx.%06d.tmp\"\n#  define OPENMODE\t(_O_CREAT | _O_RDWR | _O_TRUNC | _O_BINARY)\n#  define OPENPERM\t(_S_IREAD | _S_IWRITE)\n#else\n#  define TEMPLATE\t\"%s/%06ld.%06d.tmp\"\n#  define OPENMODE\t(O_CREAT | O_RDWR | O_EXCL | O_TRUNC)\n#  define OPENPERM\t0600\n#endif /* WIN32 */\n\n\n/*\n * Cache file structure...\n */\n\ntypedef struct\t\t/* Cache for all temporary files */\n{\n  char\t*name;\t\t\t\t/* Temporary filename */\n  char\t*url;\t\t\t\t/* URL */\n} cache_t;\n\n\n/*\n * Local globals...\n */\n\nchar\tproxy_scheme[32] = \"\",\t\t/* Proxy scheme */\n\tproxy_host[HTTP_MAX_URI] = \"\";\t/* Proxy hostname */\nint\tproxy_port = 0;\t\t\t/* Proxy port */\nhttp_t\t*http = NULL;\t\t\t/* Connection to remote server */\nsize_t\tweb_files = 0,\t\t\t/* Number of temporary files */\n\tweb_alloc = 0;\t\t\t/* Number of allocated files */\ncache_t\t*web_cache = NULL;\t\t/* Cache array */\nint\tno_local = 0;\t\t\t/* Non-zero to disable local files */\nchar\tcookies[1024] = \"\";\t\t/* HTTP cookies, if any */\nchar\treferer_url[HTTP_MAX_VALUE] = \"\";\n\t\t\t\t\t/* HTTP referer, if any */\n\n\n/*\n * 'file_basename()' - Return the base filename without directory or target.\n */\n\nconst char *\t\t\t/* O - Base filename */\nfile_basename(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*basename;\t/* Pointer to directory separator */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL)\n    return (NULL);\n\n  if ((basename = strrchr(s, '/')) != NULL)\n    basename ++;\n  else if ((basename = strrchr(s, '\\\\')) != NULL)\n    basename ++;\n  else\n    basename = (char *)s;\n\n  if (basename[0] == '#')\n    return (NULL);\n\n  if (strchr(basename, '#') == NULL)\n    return (basename);\n\n  strlcpy(buf, basename, sizeof(buf));\n  *(char *)strchr(buf, '#') = '\\0';\n\n  return (buf);\n}\n\n\n/*\n * 'file_cleanup()' - Close an open HTTP connection and remove temporary files...\n */\n\nvoid\nfile_cleanup(void)\n{\n  size_t\ti;\t\t\t/* Looping var */\n  char\t\tfilename[1024];\t\t/* Temporary file */\n  struct stat\tfileinfo;\t\t/* File information */\n  size_t\tremotebytes;\t\t/* Size of remote data */\n  const char\t*tmpdir;\t\t/* Temporary directory */\n#ifdef WIN32\n  char\t\ttmppath[1024];\t\t/* Temporary directory */\n#endif /* WIN32 */\n  const char\t*debug;\t\t\t/* HTMLDOC_DEBUG env var */\n\n\n  if (http)\n  {\n    httpClose(http);\n    http = NULL;\n  }\n\n#ifdef WIN32\n  if ((tmpdir = getenv(\"TEMP\")) == NULL)\n  {\n    GetTempPath(sizeof(tmppath), tmppath);\n    tmpdir = tmppath;\n  }\n#else\n  if ((tmpdir = getenv(\"TMPDIR\")) == NULL)\n    tmpdir = \"/var/tmp\";\n#endif /* WIN32 */\n\n /*\n  * Report on the remote data bytes that were downloaded...\n  */\n\n  debug = getenv(\"HTMLDOC_DEBUG\");\n\n  if (debug &&\n      (strstr(debug, \"all\") != NULL || strstr(debug, \"remotebytes\") != NULL))\n  {\n    for (i = 0, remotebytes = 0; i < web_files; i ++)\n      if (web_cache[i].url)\n      {\n\tsnprintf(filename, sizeof(filename), TEMPLATE, tmpdir, (long)getpid(), (int)(i + 1));\n        if (!stat(filename, &fileinfo))\n\t  remotebytes += (size_t)fileinfo.st_size;\n      }\n\n    progress_error(HD_ERROR_NONE, \"REMOTEBYTES: %ld\", (long)remotebytes);\n  }\n\n /*\n  * Check to see if we want to leave the temporary files around for\n  * debugging...\n  */\n\n  if (debug &&\n      (strstr(debug, \"all\") != NULL || strstr(debug, \"tempfiles\") != NULL))\n  {\n   /*\n    * Yes, leave the files, but show the mapping from filename to URL...\n    */\n\n    progress_error(HD_ERROR_NONE, \"DEBUG: Temporary File Summary\");\n    progress_error(HD_ERROR_NONE, \"DEBUG:\");\n    progress_error(HD_ERROR_NONE, \"DEBUG: URL                             Filename\");\n    progress_error(HD_ERROR_NONE, \"DEBUG: ------------------------------- ---------------------\");\n\n    for (i = 0; i < web_files; i ++)\n    {\n      snprintf(filename, sizeof(filename), TEMPLATE, tmpdir, (long)getpid(), (int)(i + 1));\n      progress_error(HD_ERROR_NONE, \"DEBUG: %-31.31s %s\\n\", web_cache[i].url ? web_cache[i].url : \"none\", filename);\n    }\n\n    progress_error(HD_ERROR_NONE, \"DEBUG:\");\n\n    return;\n  }\n\n  while (web_files > 0)\n  {\n    snprintf(filename, sizeof(filename), TEMPLATE, tmpdir, (long)getpid(), (int)web_files);\n\n    if (unlink(filename))\n      progress_error(HD_ERROR_DELETE_ERROR,\n                     \"Unable to delete temporary file \\\"%s\\\": %s\",\n                     filename, strerror(errno));\n\n    web_files --;\n\n    if (web_cache[web_files].name)\n      free(web_cache[web_files].name);\n    if (web_cache[web_files].url)\n      free(web_cache[web_files].url);\n  }\n\n  if (web_alloc)\n  {\n    free(web_cache);\n\n    web_alloc = 0;\n    web_cache = NULL;\n  }\n}\n\n\n/*\n * 'file_cookies()' - Set the HTTP cookies for remote accesses.\n */\n\nvoid\nfile_cookies(const char *s)\t\t/* I - Cookie string or NULL */\n{\n  if (s)\n    strlcpy(cookies, s, sizeof(cookies));\n  else\n    cookies[0] = '\\0';\n}\n\n\n/*\n * 'file_directory()' - Return the directory without filename or target.\n */\n\nconst char *\t\t\t/* O - Directory for file */\nfile_directory(const char *s)\t/* I - Filename or URL */\n{\n  char\t\t*dir;\t\t/* Pointer to directory separator */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL || !strncmp(s, \"data:\", 5))\n    return (NULL);\n\n  if (strncmp(s, \"http://\", 7) == 0 || strncmp(s, \"https://\", 8) == 0)\n  {\n   /*\n    * Handle URLs...\n    */\n\n    char\tscheme[HTTP_MAX_URI],\n\t\tusername[HTTP_MAX_URI],\n\t\thostname[HTTP_MAX_URI],\n\t\tresource[HTTP_MAX_URI];\n    int\t\tport;\n\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, s, scheme, sizeof(scheme),\n                    username, sizeof(username), hostname, sizeof(hostname),\n\t\t    &port, resource, sizeof(resource));\n    if ((dir = strrchr(resource, '/')) != NULL)\n      *dir = '\\0';\n\n    httpAssembleURI(HTTP_URI_CODING_ALL, buf, sizeof(buf), scheme, username,\n                    hostname, port, resource);\n  }\n  else\n  {\n   /*\n    * Normal stuff...\n    */\n\n    strlcpy(buf, s, sizeof(buf));\n\n    if ((dir = strrchr(buf, '/')) != NULL)\n      *dir = '\\0';\n    else if ((dir = strrchr(buf, '\\\\')) != NULL)\n      *dir = '\\0';\n    else\n      return (\".\");\n\n    if (strncmp(buf, \"file:\", 5) == 0)\n      hd_strcpy(buf, buf + 5);\n\n    if (!buf[0])\n      /* Safe because buf is more than 2 chars long */\n      strlcpy(buf, \"/\", sizeof(buf));\n  }\n\n  return (buf);\n}\n\n\n/*\n * 'file_extension()' - Return the extension of a file without the target.\n */\n\nconst char *\t\t\t/* O - File extension */\nfile_extension(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*extension;\t/* Pointer to directory separator */\n  char\t\t*bufptr;\t/* Pointer into buffer */\n  static char\tbuf[1024];\t/* Buffer for files with targets */\n\n\n  if (s == NULL)\n    return (NULL);\n  else if (!strncmp(s, \"data:image/bmp;\", 15))\n    return (\"bmp\");\n  else if (!strncmp(s, \"data:image/gif;\", 15))\n    return (\"gif\");\n  else if (!strncmp(s, \"data:image/jpeg;\", 16))\n    return (\"jpg\");\n  else if (!strncmp(s, \"data:image/png;\", 15))\n    return (\"png\");\n  else if ((extension = strrchr(s, '/')) != NULL)\n    extension ++;\n  else if ((extension = strrchr(s, '\\\\')) != NULL)\n    extension ++;\n  else\n    extension = s;\n\n  if ((extension = strrchr(extension, '.')) == NULL)\n    return (\"\");\n  else\n    extension ++;\n\n  if (strchr(extension, '#') == NULL)\n    return (extension);\n\n  strlcpy(buf, extension, sizeof(buf));\n\n  if ((bufptr = strchr(buf, '#')) != NULL)\n    *bufptr = '\\0';\n\n  return (buf);\n}\n\n\n/*\n * 'file_find_check()' - Check to see if the specified file or URL exists...\n */\n\nstatic const char *\t\t\t/* O - Pathname or NULL */\nfile_find_check(const char *filename)\t/* I - File or URL */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  int\t\tretry;\t\t\t/* Current retry */\n  char\t\tscheme[HTTP_MAX_URI],\t/* Method/scheme */\n\t\tusername[HTTP_MAX_URI],\t/* Username:password */\n\t\thostname[HTTP_MAX_URI],\t/* Hostname */\n\t\tresource[HTTP_MAX_URI];\t/* Resource */\n  int\t\tport;\t\t\t/* Port number */\n  const char\t*connscheme;\t\t/* Scheme for connection */\n  const char\t*connhost;\t\t/* Host to connect to */\n  int\t\tconnport;\t\t/* Port to connect to */\n  char\t\tconnpath[HTTP_MAX_URI],\t/* Path for GET */\n\t\tconnauth[HTTP_MAX_VALUE];/* Auth string */\n  http_status_t\tstatus;\t\t\t/* Status of request... */\n  FILE\t\t*fp;\t\t\t/* Web file */\n  ssize_t\tbytes,\t\t\t/* Bytes read */\n\t\tcount;\t\t\t/* Number of bytes so far */\n  off_t\t\ttotal;\t\t\t/* Total bytes in file */\n  char\t\ttempname[HTTP_MAX_URI];\t/* Temporary filename */\n\n\n  DEBUG_printf((\"file_find_check(filename=\\\"%s\\\")\\n\", filename));\n\n  if (strncmp(filename, \"http:\", 5) == 0 || strncmp(filename, \"//\", 2) == 0)\n    strlcpy(scheme, \"http\", sizeof(scheme));\n  else if (strncmp(filename, \"https:\", 6) == 0)\n    strlcpy(scheme, \"https\", sizeof(scheme));\n  else if (strncmp(filename, \"data:\", 5) == 0)\n    strlcpy(scheme, \"data\", sizeof(scheme));\n  else\n    strlcpy(scheme, \"file\", sizeof(scheme));\n\n  if (strcmp(scheme, \"file\") == 0)\n  {\n   /*\n    * Return immediately if we aren't allowing access to local files...\n    */\n\n    if (no_local)\n      return (NULL);\n\n   /*\n    * If the filename exists, return the filename...\n    */\n\n    if (!access(filename, 0))\n    {\n      DEBUG_printf((\"file_find_check: Returning \\\"%s\\\"!\\n\", filename));\n      return (filename);\n    }\n  }\n  else if (!strcmp(scheme, \"data\"))\n  {\n   /*\n    * Data URI; look it up in the web cache, then save to a temporary file...\n    */\n\n    const char\t*data;\t\t\t/* Pointer to data */\n    int\t\tlen;\t\t\t/* Number of bytes */\n    char\tbuffer[8192];\t\t/* Data buffer */\n\n    for (i = 0; i < (int)web_files; i ++)\n    {\n      if (web_cache[i].url && strcmp(web_cache[i].url, filename) == 0)\n      {\n        DEBUG_printf((\"file_find_check: Returning \\\"%s\\\" for \\\"%s\\\".\\n\", web_cache[i].name, filename));\n        return (web_cache[i].name);\n      }\n    }\n\n    if ((data = strstr(filename, \";base64,\")) != NULL)\n    {\n      len = sizeof(buffer);\n      httpDecode64_2(buffer, &len, data + 8);\n\n      if ((fp = file_temp(tempname, sizeof(tempname))) == NULL)\n      {\n\tprogress_hide();\n\tprogress_error(HD_ERROR_WRITE_ERROR, \"Unable to create temporary file \\\"%s\\\": %s\", tempname, strerror(errno));\n\treturn (NULL);\n      }\n\n      fwrite(buffer, 1, (size_t)len, fp);\n      fclose(fp);\n\n      progress_hide();\n\n      web_cache[web_files - 1].url = strdup(filename);\n\n      DEBUG_printf((\"file_find_check: Returning \\\"%s\\\" for \\\"%s\\\".\\n\", tempname, filename));\n\n      return (web_cache[web_files - 1].name);\n    }\n  }\n  else\n  {\n   /*\n    * Remote file; look it up in the web cache, and then try getting it\n    * from the remote system...\n    */\n\n    for (i = 0; i < (int)web_files; i ++)\n    {\n      if (web_cache[i].url && strcmp(web_cache[i].url, filename) == 0)\n      {\n        DEBUG_printf((\"file_find_check: Returning \\\"%s\\\" for \\\"%s\\\".\\n\", web_cache[i].name, filename));\n        return (web_cache[i].name);\n      }\n    }\n\n    httpSeparateURI(HTTP_URI_CODING_ALL, filename, scheme, sizeof(scheme),\n                    username, sizeof(username), hostname, sizeof(hostname),\n\t\t    &port, resource, sizeof(resource));\n\n    for (status = HTTP_STATUS_ERROR, retry = 0; status != HTTP_STATUS_OK && retry < 5; retry ++)\n    {\n      if (proxy_port)\n      {\n        // Send request to proxy host...\n        connscheme = proxy_scheme;\n        connhost   = proxy_host;\n        connport   = proxy_port;\n        httpAssembleURI(HTTP_URI_CODING_ALL, connpath, sizeof(connpath), scheme, NULL, hostname, port, resource);\n      }\n      else\n      {\n        // Send request to host directly...\n        connscheme = scheme;\n        connhost   = hostname;\n        connport   = port;\n        strlcpy(connpath, resource, sizeof(connpath));\n      }\n\n      if (connport != httpAddrPort(httpGetAddress(http)) ||\n#ifdef HAVE_SSL\n\t  (!strcmp(connscheme, \"https\") && !httpIsEncrypted(http)) ||\n          (!strcmp(connscheme, \"http\") && httpIsEncrypted(http)) ||\n#endif // HAVE_SSL\n          strcasecmp(httpGetHostname(http, tempname, sizeof(tempname)), hostname))\n      {\n        httpClose(http);\n        http = NULL;\n      }\n\n      if (http == NULL)\n      {\n        progress_show(\"Connecting to %s...\", connhost);\n\n        http_encryption_t encryption = !strcmp(connscheme, \"http\") ? HTTP_ENCRYPTION_IF_REQUESTED : HTTP_ENCRYPTION_ALWAYS;\n\n        if ((http = httpConnect2(connhost, connport, NULL, AF_UNSPEC, encryption, 1, 30000, NULL)) == NULL)\n\t{\n          progress_hide();\n          progress_error(HD_ERROR_NETWORK_ERROR, \"Unable to connect to %s:%d\", connhost, connport);\n          return (NULL);\n        }\n      }\n\n      progress_show(\"Getting %s...\", connpath);\n\n      httpClearFields(http);\n      httpSetField(http, HTTP_FIELD_HOST, hostname);\n      httpSetField(http, HTTP_FIELD_CONNECTION, \"Keep-Alive\");\n      httpSetField(http, HTTP_FIELD_REFERER, referer_url);\n\n      if (username[0])\n      {\n        strlcpy(connauth, \"Basic \", sizeof(connauth));\n        httpEncode64_2(connauth + 6, sizeof(connauth) - 6, username, strlen(username));\n        httpSetField(http, HTTP_FIELD_AUTHORIZATION, connauth);\n      }\n\n      if (cookies[0])\n        httpSetCookie(http, cookies);\n\n      if (!httpGet(http, connpath))\n      {\n\twhile ((status = httpUpdate(http)) == HTTP_CONTINUE);\n      }\n      else\n\tstatus = HTTP_ERROR;\n\n      if (status >= HTTP_STATUS_MULTIPLE_CHOICES && status < HTTP_STATUS_BAD_REQUEST)\n      {\n        // Redirect status code, grab the new location...\n        const char *newurl = httpGetField(http, HTTP_FIELD_LOCATION);\n\t\t\t\t\t// New URL\n        char\tnewresource[256];\t// New resource\n\n        progress_show(\"Redirecting to %s...\", newurl);\n\thttpSeparateURI(HTTP_URI_CODING_ALL, newurl, scheme, sizeof(scheme), username, sizeof(username), hostname, sizeof(hostname), &port, newresource, sizeof(newresource));\n\n        // Don't use new resource path if it is empty...\n        if (strchr(newurl + strlen(scheme) + 3, '/'))\n          strlcpy(resource, newresource, sizeof(resource));\n\n        // ... then flush any text in the response...\n\thttpFlush(http);\n      }\n    }\n\n    if (status != HTTP_OK)\n    {\n      progress_hide();\n      progress_error((HDerror)status, \"%s (%s)\", httpStatus(status), filename);\n      httpFlush(http);\n      return (NULL);\n    }\n\n    if ((fp = file_temp(tempname, sizeof(tempname))) == NULL)\n    {\n      progress_hide();\n      progress_error(HD_ERROR_WRITE_ERROR,\n                     \"Unable to create temporary file \\\"%s\\\": %s\", tempname,\n                     strerror(errno));\n      httpFlush(http);\n      return (NULL);\n    }\n\n    if ((total = httpGetLength2(http)) == 0)\n      total = 8192;\n\n    count = 0;\n    while ((bytes = httpRead2(http, resource, sizeof(resource))) > 0)\n    {\n      count += bytes;\n      progress_update((100 * count / total) % 101);\n      fwrite(resource, 1, (size_t)bytes, fp);\n    }\n\n    progress_hide();\n\n    fclose(fp);\n\n    web_cache[web_files - 1].url = strdup(filename);\n\n    DEBUG_printf((\"file_find_check: Returning \\\"%s\\\" for \\\"%s\\\".\\n\", tempname, filename));\n\n    return (web_cache[web_files - 1].name);\n  }\n\n  return (NULL);\n}\n\n\n/*\n * 'file_find()' - Find a file in one of the path directories.\n */\n\nconst char *\t\t\t\t/* O - Pathname or NULL */\nfile_find(const char *path,\t\t/* I - Path \"dir;dir;dir\" */\n          const char *s)\t\t/* I - File to find */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  char\t\t*temp;\t\t\t/* Current position in filename */\n  const char\t*sptr;\t\t\t/* Pointer into \"s\" */\n  int\t\tch;\t\t\t/* Quoted character */\n  char\t\tbasename[HTTP_MAX_URI];\t/* Base (unquoted) filename */\n  const char\t*realname;\t\t/* Real filename */\n  static char\tfilename[HTTP_MAX_URI];\t/* Current filename */\n\n\n /*\n  * If the filename is NULL, return NULL...\n  */\n\n  if (s == NULL)\n    return (NULL);\n\n  DEBUG_printf((\"file_find(path=\\\"%s\\\", s=\\\"%s\\\")\\n\", path ? path : \"(null)\", s));\n\n /*\n  * See if this is a cached remote file...\n  */\n\n  for (i = 0; i < (int)web_files; i ++)\n  {\n    if (strcmp(s, web_cache[i].name) == 0)\n    {\n      DEBUG_printf((\"file_find: Returning cache file \\\"%s\\\"!\\n\", s));\n      return (web_cache[i].name);\n    }\n  }\n\n  DEBUG_printf((\"file_find: \\\"%s\\\" not in web cache of %d files...\\n\", s, (int)web_files));\n\n /*\n  * Make sure the filename is not quoted...\n  */\n\n  if (strchr(s, '%') == NULL)\n  {\n    strlcpy(basename, s, sizeof(basename));\n  }\n  else\n  {\n    for (sptr = s, temp = basename;\n\t *sptr && temp < (basename + sizeof(basename) - 1);)\n    {\n      if (*sptr == '%' && isxdigit(sptr[1]) && isxdigit(sptr[2]))\n      {\n       /*\n\t* Dequote %HH...\n\t*/\n\n\tif (isalpha(sptr[1]))\n\t  ch = (tolower(sptr[1]) - 'a' + 10) << 4;\n\telse\n\t  ch = (sptr[1] - '0') << 4;\n\n\tif (isalpha(sptr[2]))\n\t  ch |= tolower(sptr[2]) - 'a' + 10;\n\telse\n\t  ch |= sptr[2] - '0';\n\n\t*temp++ = (char)ch;\n\n\tsptr += 3;\n      }\n      else\n\t*temp++ = *sptr++;\n    }\n\n    *temp = '\\0';\n  }\n\n /*\n  * If we got a complete URL, we don't use the path...\n  */\n\n  if (path != NULL && !path[0])\n  {\n    DEBUG_puts(\"file_find: Resetting path to NULL since path is empty...\");\n    path = NULL;\n  }\n\n  if (strncmp(s, \"http:\", 5) == 0 ||\n      strncmp(s, \"https:\", 6) == 0 ||\n      strncmp(s, \"//\", 2) == 0)\n  {\n    DEBUG_puts(\"file_find: Resetting path to NULL since filename is a URL...\");\n    path = NULL;\n  }\n\n /*\n  * Loop through the path as needed...\n  */\n\n  if (path != NULL)\n  {\n    filename[sizeof(filename) - 1] = '\\0';\n\n    while (*path != '\\0')\n    {\n     /*\n      * Copy the path directory...\n      */\n\n      temp = filename;\n\n      while (*path != ';' && *path && temp < (filename + sizeof(filename) - 1))\n\t*temp++ = *path++;\n\n      if (*path == ';')\n\tpath ++;\n\n     /*\n      * Append a slash as needed, then the filename...\n      */\n\n      if (temp > filename && temp < (filename + sizeof(filename) - 1) &&\n          basename[0] != '/')\n\t*temp++ = '/';\n\n      strlcpy(temp, basename, sizeof(filename) - (size_t)(temp - filename));\n\n     /*\n      * See if the file or URL exists...\n      */\n\n      if ((realname = file_find_check(filename)) != NULL)\n\treturn (realname);\n    }\n  }\n\n  return (file_find_check(s));\n}\n\n\n/*\n * 'file_gets()' - Read a line from a file terminated with CR, LF, or CR LF.\n */\n\nchar *\t\t\t\t/* O - Line from file or NULL on EOF */\nfile_gets(char  *buf,\t\t/* I - Line buffer */\n\t  int   buflen,\t\t/* I - Length of buffer */\n\t  FILE  *fp)\t\t/* I - File to read from */\n{\n  int\t\tch;\t\t/* Character from file */\n  char\t\t*ptr,\t\t/* Current position in line buffer */\n\t\t*end;\t\t/* End of line buffer */\n\n\n /*\n  * Range check everything...\n  */\n\n  if (fp == NULL || buf == NULL || buflen < 2)\n    return (NULL);\n\n /*\n  * Now loop until we have a valid line...\n  */\n\n  ptr = buf;\n  end = buf + buflen - 1;\n\n  for (;;)\n  {\n    if ((ch = getc(fp)) == EOF)\n      break;\n    else if (ch == '\\r')\n    {\n     /*\n      * See if we have CR or CR LF...\n      */\n\n      int nextch = getc(fp);\n\n      if (nextch == EOF || nextch == '\\n')\n        break;\n\n     /*\n      * No LF, so save the next char for later...\n      */\n\n      ungetc(nextch, fp);\n\n      break;\n    }\n    else if (ch == '\\n')\n      break;\n    else if (ch == '\\\\')\n    {\n     /*\n      * Handle \\ escapes, to continue to multiple lines...\n      */\n\n      int nextch = getc(fp);\n\n      if (nextch == EOF)\n        break;\n      else if (nextch == '\\r')\n      {\n        nextch = getc(fp);\n\n\tif (nextch == EOF)\n\t  break;\n\telse if (nextch != '\\n')\n\t  ungetc(nextch, fp);\n      }\n      else if (nextch != '\\n' && ptr < end)\n        *ptr++ = (char)nextch;\n    }\n    else if (ptr < end)\n      *ptr++ = (char)ch;\n  }\n\n  *ptr = '\\0';\n\n  if (ch != EOF || ptr > buf)\n    return (buf);\n  else\n    return (NULL);\n}\n\n\n/*\n * 'file_localize()' - Localize a filename for the new working directory.\n */\n\nconst char *\t\t\t\t/* O - New filename */\nfile_localize(const char *filename,\t/* I - Filename */\n              const char *newcwd)\t/* I - New directory */\n{\n  const char\t*newslash;\t\t/* Directory separator */\n  char\t\t*slash;\t\t\t/* Directory separator */\n  char\t\tcwd[1024];\t\t/* Current directory */\n  char\t\ttemp[1024];\t\t/* Temporary pathname */\n  static char\tnewfilename[1024];\t/* New filename */\n\n\n  if (filename[0] == '\\0')\n    return (\"\");\n\n  if (file_method(filename))\n    return (filename);\n\n  getcwd(cwd, sizeof(cwd));\n  if (newcwd == NULL)\n    newcwd = cwd;\n\n#if defined(WIN32) || defined(__EMX__)\n  if (filename[0] != '/' &&\n      filename[0] != '\\\\' &&\n      !(isalpha(filename[0]) && filename[1] == ':'))\n#else\n  if (filename[0] != '/')\n#endif /* WIN32 || __EMX__ */\n  {\n    for (newslash = filename; strncmp(newslash, \"../\", 3) == 0; newslash += 3)\n#if defined(WIN32) || defined(__EMX__)\n    {\n      if ((slash = strrchr(cwd, '/')) == NULL)\n        slash = strrchr(cwd, '\\\\');\n      if (slash != NULL)\n        *slash = '\\0';\n    }\n#else\n      if ((slash = strrchr(cwd, '/')) != NULL)\n        *slash = '\\0';\n#endif /* WIN32 || __EMX__ */\n\n    snprintf(temp, sizeof(temp), \"%s/%s\", cwd, newslash);\n  }\n  else\n    strlcpy(temp, filename, sizeof(temp));\n\n  for (slash = temp, newslash = newcwd;\n       *slash != '\\0' && *newslash != '\\0';\n       slash ++, newslash ++)\n    if ((*slash == '/' || *slash == '\\\\') &&\n        (*newslash == '/' || *newslash == '\\\\'))\n      continue;\n    else if (*slash != *newslash)\n      break;\n\n  while (*slash != '/' && *slash != '\\\\' && slash > temp)\n    slash --;\n\n  if (*slash == '/' || *slash == '\\\\')\n    slash ++;\n\n#if defined(WIN32) || defined(__EMX__)\n  if (isalpha(slash[0]) && slash[1] == ':')\n    return ((char *)filename); /* Different drive letter... */\n#endif /* WIN32 || __EMX__ */\n\n  if (*newslash != '\\0')\n    while (*newslash != '/' && *newslash != '\\\\' && newslash > newcwd)\n      newslash --;\n\n  newfilename[0] = '\\0';\n\n  while (*newslash != '\\0')\n  {\n    if (*newslash == '/' || *newslash == '\\\\')\n      strlcat(newfilename, \"../\", sizeof(newfilename));\n    newslash ++;\n  }\n\n  strlcat(newfilename, slash, sizeof(newfilename));\n\n  return (newfilename);\n}\n\n\n/*\n * 'file_method()' - Return the method for a filename or URL.\n *\n * Returns NULL if the URL is a local file.\n */\n\nconst char *\t\t\t/* O - Method string (\"http\", \"ftp\", etc.) */\nfile_method(const char *s)\t/* I - Filename or URL */\n{\n  if (strncmp(s, \"data:\", 5) == 0)\n    return (\"data\");\n  else if (strncmp(s, \"http:\", 5) == 0)\n    return (\"http\");\n  else if (strncmp(s, \"https:\", 6) == 0)\n    return (\"https\");\n  else if (strncmp(s, \"ftp:\", 4) == 0)\n    return (\"ftp\");\n  else if (strncmp(s, \"mailto:\", 7) == 0)\n    return (\"mailto\");\n  else\n    return (NULL);\n}\n\n\n/*\n * 'file_nolocal()' - Disable access to local files.\n */\n\nvoid\nfile_nolocal(void)\n{\n  no_local = 1;\n}\n\n\n/*\n * 'file_proxy()' - Set the proxy host for all HTTP requests.\n */\n\nvoid\nfile_proxy(const char *url)\t/* I - URL of proxy server */\n{\n   char\tscheme[HTTP_MAX_URI],\t/* Method name (must be HTTP) */\n\tusername[HTTP_MAX_URI],\t/* Username:password information */\n\thostname[HTTP_MAX_URI],\t/* Hostname */\n\tresource[HTTP_MAX_URI];\t/* Resource name */\n  int\tport;\t\t\t/* Port number */\n\n\n  if (url == NULL || url[0] == '\\0')\n  {\n    proxy_host[0] = '\\0';\n    proxy_port    = 0;\n  }\n  else\n  {\n    httpSeparateURI(HTTP_URI_CODING_ALL, url, scheme, sizeof(scheme),\n                    username, sizeof(username), hostname, sizeof(hostname),\n\t\t    &port, resource, sizeof(resource));\n\n    if (strcmp(scheme, \"http\") == 0)\n    {\n      strlcpy(proxy_host, hostname, sizeof(proxy_host));\n      proxy_port = port;\n    }\n  }\n}\n\n\n/*\n * 'file_referer()' - Set the HTTP referer for remote accesses.\n */\n\nvoid\nfile_referer(const char *referer)\t/* I - Referer URL */\n{\n  if (referer)\n    strlcpy(referer_url, referer, sizeof(referer_url));\n  else\n    referer_url[0] = '\\0';\n}\n\n\n/*\n * 'file_rlookup()' - Lookup a filename to find the original URL, if applicable.\n */\n\nconst char *\t\t\t\t/* O - URL or filename */\nfile_rlookup(const char *filename)\t/* I - Filename */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  cache_t\t*wc;\t\t\t/* Current cache file */\n\n\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n    if (!strcmp(wc->name, filename))\n      return (wc->url);\n\n  return (filename);\n}\n\n\n/*\n * 'file_target()' - Return the target of a link.\n */\n\nconst char *\t\t\t/* O - Target name */\nfile_target(const char *s)\t/* I - Filename or URL */\n{\n  const char\t*basename;\t/* Pointer to directory separator */\n  const char\t*target;\t/* Pointer to target */\n\n\n  if (s == NULL)\n    return (NULL);\n\n  if ((basename = strrchr(s, '/')) != NULL)\n    basename ++;\n  else if ((basename = strrchr(s, '\\\\')) != NULL)\n    basename ++;\n  else\n    basename = s;\n\n  if ((target = strchr(basename, '#')) != NULL)\n    return (target + 1);\n  else\n    return (NULL);\n}\n\n\n/*\n * 'file_temp()' - Create and open a temporary file.\n */\n\nFILE *\t\t\t\t\t/* O - Temporary file */\nfile_temp(char *name,\t\t\t/* O - Filename */\n          int  len)\t\t\t/* I - Length of filename buffer */\n{\n  cache_t\t*temp;\t\t\t/* Pointer to cache entry */\n  FILE\t\t*fp;\t\t\t/* File pointer */\n  int\t\tfd;\t\t\t/* File descriptor */\n  const char\t*tmpdir;\t\t/* Temporary directory */\n#ifdef WIN32\n  char\t\ttmppath[1024];\t\t/* Buffer for temp dir */\n#endif /* WIN32 */\n\n\n /*\n  * Allocate memory for the file cache as needed...\n  */\n\n  if (web_files >= web_alloc)\n  {\n    web_alloc += ALLOC_FILES;\n    if (web_files == 0)\n      temp = (cache_t *)malloc(sizeof(cache_t) * web_alloc);\n    else\n      temp = (cache_t *)realloc(web_cache, sizeof(cache_t) * web_alloc);\n\n    if (temp == NULL)\n    {\n      progress_error(HD_ERROR_OUT_OF_MEMORY,\n                     \"Unable to allocate memory for %d file entries - %s\",\n                     (int)web_alloc, strerror(errno));\n      web_alloc -= ALLOC_FILES;\n      return (NULL);\n    }\n\n    web_cache = temp;\n  }\n\n /*\n  * Clear a new file cache entry...\n  */\n\n  temp = web_cache + web_files;\n\n  temp->name = NULL;\n  temp->url  = NULL;\n  web_files ++;\n\n#ifdef WIN32\n  if ((tmpdir = getenv(\"TEMP\")) == NULL)\n  {\n    GetTempPath(sizeof(tmppath), tmppath);\n    tmpdir = tmppath;\n  }\n#else\n  if ((tmpdir = getenv(\"TMPDIR\")) == NULL)\n    tmpdir = \"/var/tmp\";\n#endif /* WIN32 */\n\n  snprintf(name, (size_t)len, TEMPLATE, tmpdir, (long)getpid(), (int)web_files);\n\n  if ((fd = open(name, OPENMODE, OPENPERM)) >= 0)\n    fp = fdopen(fd, \"w+b\");\n  else\n    fp = NULL;\n\n  if (!fp)\n    web_files --;\n\n  temp->name = strdup(name);\n\n  return (fp);\n}\n"], "filenames": ["CHANGES.md", "htmldoc/file.c"], "buggy_code_start_loc": [3, 306], "buggy_code_end_loc": [3, 338], "fixing_code_start_loc": [4, 307], "fixing_code_end_loc": [5, 340], "type": "CWE-476", "message": "A flaw was found in htmldoc in v1.9.12 and before. Null pointer dereference in file_extension(),in file.c may lead to execute arbitrary code and denial of service.", "other": {"cve": {"id": "CVE-2021-23180", "sourceIdentifier": "secalert@redhat.com", "published": "2022-03-02T23:15:08.283", "lastModified": "2022-03-10T19:27:16.150", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A flaw was found in htmldoc in v1.9.12 and before. Null pointer dereference in file_extension(),in file.c may lead to execute arbitrary code and denial of service."}, {"lang": "es", "value": "Se ha encontrado un fallo en htmldoc en la versiones 1.9.12 y anteriores. Se presenta una desreferencia de puntero Null en la funci\u00f3n  file_extension(),en el archivo file.c puede conllevar a una ejecuci\u00f3n de c\u00f3digo arbitrario y una denegaci\u00f3n de servicio"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}, {"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:htmldoc_project:htmldoc:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.9.12", "matchCriteriaId": "B9DD956F-44F8-4CB5-B9FD-9269C3E931F2"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1967041", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelrsweet/htmldoc/commit/19c582fb32eac74b57e155cffbb529377a9e751a", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/michaelrsweet/htmldoc/issues/418", "source": "secalert@redhat.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://ubuntu.com/security/CVE-2021-23180", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/michaelrsweet/htmldoc/commit/19c582fb32eac74b57e155cffbb529377a9e751a"}}