{"buggy_code": ["/*\n *  OpenVPN -- An application to securely tunnel IP networks\n *             over a single TCP/UDP port, with support for SSL/TLS-based\n *             session authentication and key exchange,\n *             packet encryption, packet authentication, and\n *             packet compression.\n *\n *  Copyright (C) 2002-2018 OpenVPN Inc <sales@openvpn.net>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2\n *  as published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#elif defined(_MSC_VER)\n#include \"config-msvc.h\"\n#endif\n\n#ifdef HAVE_SYS_INOTIFY_H\n#include <sys/inotify.h>\n#define INOTIFY_EVENT_BUFFER_SIZE 16384\n#endif\n\n#include \"syshead.h\"\n\n#if P2MP_SERVER\n\n#include \"forward.h\"\n#include \"multi.h\"\n#include \"push.h\"\n#include \"run_command.h\"\n#include \"otime.h\"\n#include \"pf.h\"\n#include \"gremlin.h\"\n#include \"mstats.h\"\n#include \"ssl_verify.h\"\n#include \"ssl_ncp.h\"\n#include \"vlan.h\"\n#include <inttypes.h>\n\n#include \"memdbg.h\"\n\n\n#include \"crypto_backend.h\"\n\n/*#define MULTI_DEBUG_EVENT_LOOP*/\n\n#ifdef MULTI_DEBUG_EVENT_LOOP\nstatic const char *\nid(struct multi_instance *mi)\n{\n    if (mi)\n    {\n        return tls_common_name(mi->context.c2.tls_multi, false);\n    }\n    else\n    {\n        return \"NULL\";\n    }\n}\n#endif\n\n#ifdef MANAGEMENT_DEF_AUTH\nstatic void\nset_cc_config(struct multi_instance *mi, struct buffer_list *cc_config)\n{\n    if (mi->cc_config)\n    {\n        buffer_list_free(mi->cc_config);\n    }\n    mi->cc_config = cc_config;\n}\n#endif\n\nstatic inline void\nupdate_mstat_n_clients(const int n_clients)\n{\n#ifdef ENABLE_MEMSTATS\n    if (mmap_stats)\n    {\n        mmap_stats->n_clients = n_clients;\n    }\n#endif\n}\n\nstatic bool\nlearn_address_script(const struct multi_context *m,\n                     const struct multi_instance *mi,\n                     const char *op,\n                     const struct mroute_addr *addr)\n{\n    struct gc_arena gc = gc_new();\n    struct env_set *es;\n    bool ret = true;\n    struct plugin_list *plugins;\n\n    /* get environmental variable source */\n    if (mi && mi->context.c2.es)\n    {\n        es = mi->context.c2.es;\n    }\n    else\n    {\n        es = env_set_create(&gc);\n    }\n\n    /* get plugin source */\n    if (mi)\n    {\n        plugins = mi->context.plugins;\n    }\n    else\n    {\n        plugins = m->top.plugins;\n    }\n\n    if (plugin_defined(plugins, OPENVPN_PLUGIN_LEARN_ADDRESS))\n    {\n        struct argv argv = argv_new();\n        argv_printf(&argv, \"%s %s\",\n                    op,\n                    mroute_addr_print(addr, &gc));\n        if (mi)\n        {\n            argv_printf_cat(&argv, \"%s\", tls_common_name(mi->context.c2.tls_multi, false));\n        }\n        if (plugin_call(plugins, OPENVPN_PLUGIN_LEARN_ADDRESS, &argv, NULL, es) != OPENVPN_PLUGIN_FUNC_SUCCESS)\n        {\n            msg(M_WARN, \"WARNING: learn-address plugin call failed\");\n            ret = false;\n        }\n        argv_free(&argv);\n    }\n\n    if (m->top.options.learn_address_script)\n    {\n        struct argv argv = argv_new();\n        setenv_str(es, \"script_type\", \"learn-address\");\n        argv_parse_cmd(&argv, m->top.options.learn_address_script);\n        argv_printf_cat(&argv, \"%s %s\", op, mroute_addr_print(addr, &gc));\n        if (mi)\n        {\n            argv_printf_cat(&argv, \"%s\", tls_common_name(mi->context.c2.tls_multi, false));\n        }\n        if (!openvpn_run_script(&argv, es, 0, \"--learn-address\"))\n        {\n            ret = false;\n        }\n        argv_free(&argv);\n    }\n\n    gc_free(&gc);\n    return ret;\n}\n\nvoid\nmulti_ifconfig_pool_persist(struct multi_context *m, bool force)\n{\n    /* write pool data to file */\n    if (m->ifconfig_pool\n        && m->top.c1.ifconfig_pool_persist\n        && (force || ifconfig_pool_write_trigger(m->top.c1.ifconfig_pool_persist)))\n    {\n        ifconfig_pool_write(m->top.c1.ifconfig_pool_persist, m->ifconfig_pool);\n    }\n}\n\nstatic void\nmulti_reap_range(const struct multi_context *m,\n                 int start_bucket,\n                 int end_bucket)\n{\n    struct gc_arena gc = gc_new();\n    struct hash_iterator hi;\n    struct hash_element *he;\n\n    if (start_bucket < 0)\n    {\n        start_bucket = 0;\n        end_bucket = hash_n_buckets(m->vhash);\n    }\n\n    dmsg(D_MULTI_DEBUG, \"MULTI: REAP range %d -> %d\", start_bucket, end_bucket);\n    hash_iterator_init_range(m->vhash, &hi, start_bucket, end_bucket);\n    while ((he = hash_iterator_next(&hi)) != NULL)\n    {\n        struct multi_route *r = (struct multi_route *) he->value;\n        if (!multi_route_defined(m, r))\n        {\n            dmsg(D_MULTI_DEBUG, \"MULTI: REAP DEL %s\",\n                 mroute_addr_print(&r->addr, &gc));\n            learn_address_script(m, NULL, \"delete\", &r->addr);\n            multi_route_del(r);\n            hash_iterator_delete_element(&hi);\n        }\n    }\n    hash_iterator_free(&hi);\n    gc_free(&gc);\n}\n\nstatic void\nmulti_reap_all(const struct multi_context *m)\n{\n    multi_reap_range(m, -1, 0);\n}\n\nstatic struct multi_reap *\nmulti_reap_new(int buckets_per_pass)\n{\n    struct multi_reap *mr;\n    ALLOC_OBJ(mr, struct multi_reap);\n    mr->bucket_base = 0;\n    mr->buckets_per_pass = buckets_per_pass;\n    mr->last_call = now;\n    return mr;\n}\n\nvoid\nmulti_reap_process_dowork(const struct multi_context *m)\n{\n    struct multi_reap *mr = m->reaper;\n    if (mr->bucket_base >= hash_n_buckets(m->vhash))\n    {\n        mr->bucket_base = 0;\n    }\n    multi_reap_range(m, mr->bucket_base, mr->bucket_base + mr->buckets_per_pass);\n    mr->bucket_base += mr->buckets_per_pass;\n    mr->last_call = now;\n}\n\nstatic void\nmulti_reap_free(struct multi_reap *mr)\n{\n    free(mr);\n}\n\n/*\n * How many buckets in vhash to reap per pass.\n */\nstatic int\nreap_buckets_per_pass(int n_buckets)\n{\n    return constrain_int(n_buckets / REAP_DIVISOR, REAP_MIN, REAP_MAX);\n}\n\n#ifdef MANAGEMENT_DEF_AUTH\n\nstatic uint32_t\ncid_hash_function(const void *key, uint32_t iv)\n{\n    const unsigned long *k = (const unsigned long *)key;\n    return (uint32_t) *k;\n}\n\nstatic bool\ncid_compare_function(const void *key1, const void *key2)\n{\n    const unsigned long *k1 = (const unsigned long *)key1;\n    const unsigned long *k2 = (const unsigned long *)key2;\n    return *k1 == *k2;\n}\n\n#endif\n\n#ifdef ENABLE_ASYNC_PUSH\nstatic uint32_t\n/*\n * inotify watcher descriptors are used as hash value\n */\nint_hash_function(const void *key, uint32_t iv)\n{\n    return (unsigned long)key;\n}\n\nstatic bool\nint_compare_function(const void *key1, const void *key2)\n{\n    return (unsigned long)key1 == (unsigned long)key2;\n}\n#endif\n\n/*\n * Main initialization function, init multi_context object.\n */\nvoid\nmulti_init(struct multi_context *m, struct context *t, bool tcp_mode, int thread_mode)\n{\n    int dev = DEV_TYPE_UNDEF;\n\n    msg(D_MULTI_LOW, \"MULTI: multi_init called, r=%d v=%d\",\n        t->options.real_hash_size,\n        t->options.virtual_hash_size);\n\n    /*\n     * Get tun/tap/null device type\n     */\n    dev = dev_type_enum(t->options.dev, t->options.dev_type);\n\n    /*\n     * Init our multi_context object.\n     */\n    CLEAR(*m);\n\n    m->thread_mode = thread_mode;\n\n    /*\n     * Real address hash table (source port number is\n     * considered to be part of the address).  Used\n     * to determine which client sent an incoming packet\n     * which is seen on the TCP/UDP socket.\n     */\n    m->hash = hash_init(t->options.real_hash_size,\n                        get_random(),\n                        mroute_addr_hash_function,\n                        mroute_addr_compare_function);\n\n    /*\n     * Virtual address hash table.  Used to determine\n     * which client to route a packet to.\n     */\n    m->vhash = hash_init(t->options.virtual_hash_size,\n                         get_random(),\n                         mroute_addr_hash_function,\n                         mroute_addr_compare_function);\n\n    /*\n     * This hash table is a clone of m->hash but with a\n     * bucket size of one so that it can be used\n     * for fast iteration through the list.\n     */\n    m->iter = hash_init(1,\n                        get_random(),\n                        mroute_addr_hash_function,\n                        mroute_addr_compare_function);\n\n#ifdef MANAGEMENT_DEF_AUTH\n    m->cid_hash = hash_init(t->options.real_hash_size,\n                            0,\n                            cid_hash_function,\n                            cid_compare_function);\n#endif\n\n#ifdef ENABLE_ASYNC_PUSH\n    /*\n     * Mapping between inotify watch descriptors and\n     * multi_instances.\n     */\n    m->inotify_watchers = hash_init(t->options.real_hash_size,\n                                    get_random(),\n                                    int_hash_function,\n                                    int_compare_function);\n#endif\n\n    /*\n     * This is our scheduler, for time-based wakeup\n     * events.\n     */\n    m->schedule = schedule_init();\n\n    /*\n     * Limit frequency of incoming connections to control\n     * DoS.\n     */\n    m->new_connection_limiter = frequency_limit_init(t->options.cf_max,\n                                                     t->options.cf_per);\n\n    /*\n     * Allocate broadcast/multicast buffer list\n     */\n    m->mbuf = mbuf_init(t->options.n_bcast_buf);\n\n    /*\n     * Different status file format options are available\n     */\n    m->status_file_version = t->options.status_file_version;\n\n    /*\n     * Possibly allocate an ifconfig pool, do it\n     * differently based on whether a tun or tap style\n     * tunnel.\n     */\n    if (t->options.ifconfig_pool_defined)\n    {\n        int pool_type = IFCONFIG_POOL_INDIV;\n\n        if (dev == DEV_TYPE_TUN && t->options.topology == TOP_NET30)\n        {\n            pool_type = IFCONFIG_POOL_30NET;\n        }\n\n        m->ifconfig_pool = ifconfig_pool_init(pool_type,\n                                              t->options.ifconfig_pool_start,\n                                              t->options.ifconfig_pool_end,\n                                              t->options.duplicate_cn,\n                                              t->options.ifconfig_ipv6_pool_defined,\n                                              t->options.ifconfig_ipv6_pool_base,\n                                              t->options.ifconfig_ipv6_pool_netbits );\n\n        /* reload pool data from file */\n        if (t->c1.ifconfig_pool_persist)\n        {\n            ifconfig_pool_read(t->c1.ifconfig_pool_persist, m->ifconfig_pool);\n        }\n    }\n\n    /*\n     * Help us keep track of routing table.\n     */\n    m->route_helper = mroute_helper_init(MULTI_CACHE_ROUTE_TTL);\n\n    /*\n     * Initialize route and instance reaper.\n     */\n    m->reaper = multi_reap_new(reap_buckets_per_pass(t->options.virtual_hash_size));\n\n    /*\n     * Get local ifconfig address\n     */\n    CLEAR(m->local);\n    ASSERT(t->c1.tuntap);\n    mroute_extract_in_addr_t(&m->local, t->c1.tuntap->local);\n\n    /*\n     * Per-client limits\n     */\n    m->max_clients = t->options.max_clients;\n\n    m->instances = calloc(m->max_clients, sizeof(struct multi_instance *));\n\n    /*\n     * Initialize multi-socket TCP I/O wait object\n     */\n    if (tcp_mode)\n    {\n        m->mtcp = multi_tcp_init(t->options.max_clients, &m->max_clients);\n    }\n    m->tcp_queue_limit = t->options.tcp_queue_limit;\n\n    /*\n     * Allow client <-> client communication, without going through\n     * tun/tap interface and network stack?\n     */\n    m->enable_c2c = t->options.enable_c2c;\n\n    /* initialize stale routes check timer */\n    if (t->options.stale_routes_check_interval > 0)\n    {\n        msg(M_INFO, \"Initializing stale route check timer to run every %i seconds and to removing routes with activity timeout older than %i seconds\",\n            t->options.stale_routes_check_interval, t->options.stale_routes_ageing_time);\n        event_timeout_init(&m->stale_routes_check_et, t->options.stale_routes_check_interval, 0);\n    }\n\n    m->deferred_shutdown_signal.signal_received = 0;\n}\n\nconst char *\nmulti_instance_string(const struct multi_instance *mi, bool null, struct gc_arena *gc)\n{\n    if (mi)\n    {\n        struct buffer out = alloc_buf_gc(MULTI_PREFIX_MAX_LENGTH, gc);\n        const char *cn = tls_common_name(mi->context.c2.tls_multi, true);\n\n        if (cn)\n        {\n            buf_printf(&out, \"%s/\", cn);\n        }\n        buf_printf(&out, \"%s\", mroute_addr_print(&mi->real, gc));\n        return BSTR(&out);\n    }\n    else if (null)\n    {\n        return NULL;\n    }\n    else\n    {\n        return \"UNDEF\";\n    }\n}\n\nstatic void\ngenerate_prefix(struct multi_instance *mi)\n{\n    struct gc_arena gc = gc_new();\n    const char *prefix = multi_instance_string(mi, true, &gc);\n    if (prefix)\n    {\n        strncpynt(mi->msg_prefix, prefix, sizeof(mi->msg_prefix));\n    }\n    else\n    {\n        mi->msg_prefix[0] = '\\0';\n    }\n    set_prefix(mi);\n    gc_free(&gc);\n}\n\nvoid\nungenerate_prefix(struct multi_instance *mi)\n{\n    mi->msg_prefix[0] = '\\0';\n    set_prefix(mi);\n}\n\nstatic const char *\nmi_prefix(const struct multi_instance *mi)\n{\n    if (mi && mi->msg_prefix[0])\n    {\n        return mi->msg_prefix;\n    }\n    else\n    {\n        return \"UNDEF_I\";\n    }\n}\n\n/*\n * Tell the route helper about deleted iroutes so\n * that it can update its mask of currently used\n * CIDR netlengths.\n */\nstatic void\nmulti_del_iroutes(struct multi_context *m,\n                  struct multi_instance *mi)\n{\n    const struct iroute *ir;\n    const struct iroute_ipv6 *ir6;\n    if (TUNNEL_TYPE(mi->context.c1.tuntap) == DEV_TYPE_TUN)\n    {\n        for (ir = mi->context.options.iroutes; ir != NULL; ir = ir->next)\n        {\n            mroute_helper_del_iroute46(m->route_helper, ir->netbits);\n        }\n\n        for (ir6 = mi->context.options.iroutes_ipv6; ir6 != NULL; ir6 = ir6->next)\n        {\n            mroute_helper_del_iroute46(m->route_helper, ir6->netbits);\n        }\n    }\n}\n\nstatic void\nsetenv_stats(struct context *c)\n{\n    setenv_counter(c->c2.es, \"bytes_received\", c->c2.link_read_bytes);\n    setenv_counter(c->c2.es, \"bytes_sent\", c->c2.link_write_bytes);\n}\n\nstatic void\nmulti_client_disconnect_setenv(struct multi_instance *mi)\n{\n    /* setenv client real IP address */\n    setenv_trusted(mi->context.c2.es, get_link_socket_info(&mi->context));\n\n    /* setenv stats */\n    setenv_stats(&mi->context);\n\n    /* setenv connection duration */\n    setenv_long_long(mi->context.c2.es, \"time_duration\", now - mi->created);\n}\n\nstatic void\nmulti_client_disconnect_script(struct multi_instance *mi)\n{\n    if ((mi->context.c2.context_auth == CAS_SUCCEEDED && mi->connection_established_flag)\n        || mi->context.c2.context_auth == CAS_PARTIAL)\n    {\n        multi_client_disconnect_setenv(mi);\n\n        if (plugin_defined(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_DISCONNECT))\n        {\n            if (plugin_call(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_DISCONNECT, NULL, NULL, mi->context.c2.es) != OPENVPN_PLUGIN_FUNC_SUCCESS)\n            {\n                msg(M_WARN, \"WARNING: client-disconnect plugin call failed\");\n            }\n        }\n\n        if (mi->context.options.client_disconnect_script)\n        {\n            struct argv argv = argv_new();\n            setenv_str(mi->context.c2.es, \"script_type\", \"client-disconnect\");\n            argv_parse_cmd(&argv, mi->context.options.client_disconnect_script);\n            openvpn_run_script(&argv, mi->context.c2.es, 0, \"--client-disconnect\");\n            argv_free(&argv);\n        }\n#ifdef MANAGEMENT_DEF_AUTH\n        if (management)\n        {\n            management_notify_client_close(management, &mi->context.c2.mda_context, mi->context.c2.es);\n        }\n#endif\n\n    }\n}\n\nvoid\nmulti_close_instance(struct multi_context *m,\n                     struct multi_instance *mi,\n                     bool shutdown)\n{\n    perf_push(PERF_MULTI_CLOSE_INSTANCE);\n\n    ASSERT(!mi->halt);\n    mi->halt = true;\n\n    dmsg(D_MULTI_DEBUG, \"MULTI: multi_close_instance called\");\n\n    /* adjust current client connection count */\n    m->n_clients += mi->n_clients_delta;\n    update_mstat_n_clients(m->n_clients);\n    mi->n_clients_delta = 0;\n\n    /* prevent dangling pointers */\n    if (m->pending == mi)\n    {\n        multi_set_pending(m, NULL);\n    }\n    if (m->earliest_wakeup == mi)\n    {\n        m->earliest_wakeup = NULL;\n    }\n\n    if (!shutdown)\n    {\n        if (mi->did_real_hash)\n        {\n            ASSERT(hash_remove(m->hash, &mi->real));\n        }\n        if (mi->did_iter)\n        {\n            ASSERT(hash_remove(m->iter, &mi->real));\n        }\n#ifdef MANAGEMENT_DEF_AUTH\n        if (mi->did_cid_hash)\n        {\n            ASSERT(hash_remove(m->cid_hash, &mi->context.c2.mda_context.cid));\n        }\n#endif\n\n#ifdef ENABLE_ASYNC_PUSH\n        if (mi->inotify_watch != -1)\n        {\n            hash_remove(m->inotify_watchers, (void *) (unsigned long)mi->inotify_watch);\n            mi->inotify_watch = -1;\n        }\n#endif\n\n        if (mi->context.c2.tls_multi->peer_id != MAX_PEER_ID)\n        {\n            m->instances[mi->context.c2.tls_multi->peer_id] = NULL;\n        }\n\n        schedule_remove_entry(m->schedule, (struct schedule_entry *) mi);\n\n        ifconfig_pool_release(m->ifconfig_pool, mi->vaddr_handle, false);\n\n        if (mi->did_iroutes)\n        {\n            multi_del_iroutes(m, mi);\n            mi->did_iroutes = false;\n        }\n\n        if (m->mtcp)\n        {\n            multi_tcp_dereference_instance(m->mtcp, mi);\n        }\n\n        mbuf_dereference_instance(m->mbuf, mi);\n    }\n\n#ifdef MANAGEMENT_DEF_AUTH\n    set_cc_config(mi, NULL);\n#endif\n\n    multi_client_disconnect_script(mi);\n\n    if (mi->did_open_context)\n    {\n        close_context(&mi->context, SIGTERM, CC_GC_FREE);\n    }\n\n    multi_tcp_instance_specific_free(mi);\n\n    ungenerate_prefix(mi);\n\n    /*\n     * Don't actually delete the instance memory allocation yet,\n     * because virtual routes may still point to it.  Let the\n     * vhash reaper deal with it.\n     */\n    multi_instance_dec_refcount(mi);\n\n    perf_pop();\n}\n\n/*\n * Called on shutdown or restart.\n */\nvoid\nmulti_uninit(struct multi_context *m)\n{\n    if (m->thread_mode & MC_WORK_THREAD)\n    {\n        multi_top_free(m);\n        m->thread_mode = MC_UNDEF;\n    }\n    else if (m->thread_mode)\n    {\n        if (m->hash)\n        {\n            struct hash_iterator hi;\n            struct hash_element *he;\n\n            hash_iterator_init(m->iter, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct multi_instance *mi = (struct multi_instance *) he->value;\n                mi->did_iter = false;\n                multi_close_instance(m, mi, true);\n            }\n            hash_iterator_free(&hi);\n\n            multi_reap_all(m);\n\n            hash_free(m->hash);\n            hash_free(m->vhash);\n            hash_free(m->iter);\n#ifdef MANAGEMENT_DEF_AUTH\n            hash_free(m->cid_hash);\n#endif\n            m->hash = NULL;\n\n            free(m->instances);\n\n#ifdef ENABLE_ASYNC_PUSH\n            hash_free(m->inotify_watchers);\n            m->inotify_watchers = NULL;\n#endif\n\n            schedule_free(m->schedule);\n            mbuf_free(m->mbuf);\n            ifconfig_pool_free(m->ifconfig_pool);\n            frequency_limit_free(m->new_connection_limiter);\n            multi_reap_free(m->reaper);\n            mroute_helper_free(m->route_helper);\n            multi_tcp_free(m->mtcp);\n            m->thread_mode = MC_UNDEF;\n        }\n    }\n}\n\n/*\n * Create a client instance object for a newly connected client.\n */\nstruct multi_instance *\nmulti_create_instance(struct multi_context *m, const struct mroute_addr *real)\n{\n    struct gc_arena gc = gc_new();\n    struct multi_instance *mi;\n\n    perf_push(PERF_MULTI_CREATE_INSTANCE);\n\n    msg(D_MULTI_MEDIUM, \"MULTI: multi_create_instance called\");\n\n    ALLOC_OBJ_CLEAR(mi, struct multi_instance);\n\n    mi->gc = gc_new();\n    multi_instance_inc_refcount(mi);\n    mi->vaddr_handle = -1;\n    mi->created = now;\n    mroute_addr_init(&mi->real);\n\n    if (real)\n    {\n        mi->real = *real;\n        generate_prefix(mi);\n    }\n\n    mi->did_open_context = true;\n    inherit_context_child(&mi->context, &m->top);\n    if (IS_SIG(&mi->context))\n    {\n        goto err;\n    }\n\n    mi->context.c2.context_auth = CAS_PENDING;\n\n    if (hash_n_elements(m->hash) >= m->max_clients)\n    {\n        msg(D_MULTI_ERRORS, \"MULTI: new incoming connection would exceed maximum number of clients (%d)\", m->max_clients);\n        goto err;\n    }\n\n    if (!real) /* TCP mode? */\n    {\n        if (!multi_tcp_instance_specific_init(m, mi))\n        {\n            goto err;\n        }\n        generate_prefix(mi);\n    }\n\n    if (!hash_add(m->iter, &mi->real, mi, false))\n    {\n        msg(D_MULTI_LOW, \"MULTI: unable to add real address [%s] to iterator hash table\",\n            mroute_addr_print(&mi->real, &gc));\n        goto err;\n    }\n    mi->did_iter = true;\n\n#ifdef MANAGEMENT_DEF_AUTH\n    do\n    {\n        mi->context.c2.mda_context.cid = m->cid_counter++;\n    } while (!hash_add(m->cid_hash, &mi->context.c2.mda_context.cid, mi, false));\n    mi->did_cid_hash = true;\n#endif\n\n    mi->context.c2.push_reply_deferred = true;\n\n#ifdef ENABLE_ASYNC_PUSH\n    mi->context.c2.push_request_received = false;\n    mi->inotify_watch = -1;\n#endif\n\n    if (!multi_process_post(m, mi, MPP_PRE_SELECT))\n    {\n        msg(D_MULTI_ERRORS, \"MULTI: signal occurred during client instance initialization\");\n        goto err;\n    }\n\n    perf_pop();\n    gc_free(&gc);\n    return mi;\n\nerr:\n    multi_close_instance(m, mi, false);\n    perf_pop();\n    gc_free(&gc);\n    return NULL;\n}\n\n/*\n * Dump tables -- triggered by SIGUSR2.\n * If status file is defined, write to file.\n * If status file is NULL, write to syslog.\n */\nvoid\nmulti_print_status(struct multi_context *m, struct status_output *so, const int version)\n{\n    if (m->hash)\n    {\n        struct gc_arena gc_top = gc_new();\n        struct hash_iterator hi;\n        const struct hash_element *he;\n\n        status_reset(so);\n\n        if (version == 1) /* WAS: m->status_file_version */\n        {\n            /*\n             * Status file version 1\n             */\n            status_printf(so, \"OpenVPN CLIENT LIST\");\n            status_printf(so, \"Updated,%s\", time_string(0, 0, false, &gc_top));\n            status_printf(so, \"Common Name,Real Address,Bytes Received,Bytes Sent,Connected Since\");\n            hash_iterator_init(m->hash, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct gc_arena gc = gc_new();\n                const struct multi_instance *mi = (struct multi_instance *) he->value;\n\n                if (!mi->halt)\n                {\n                    status_printf(so, \"%s,%s,\" counter_format \",\" counter_format \",%s\",\n                                  tls_common_name(mi->context.c2.tls_multi, false),\n                                  mroute_addr_print(&mi->real, &gc),\n                                  mi->context.c2.link_read_bytes,\n                                  mi->context.c2.link_write_bytes,\n                                  time_string(mi->created, 0, false, &gc));\n                }\n                gc_free(&gc);\n            }\n            hash_iterator_free(&hi);\n\n            status_printf(so, \"ROUTING TABLE\");\n            status_printf(so, \"Virtual Address,Common Name,Real Address,Last Ref\");\n            hash_iterator_init(m->vhash, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct gc_arena gc = gc_new();\n                const struct multi_route *route = (struct multi_route *) he->value;\n\n                if (multi_route_defined(m, route))\n                {\n                    const struct multi_instance *mi = route->instance;\n                    const struct mroute_addr *ma = &route->addr;\n                    char flags[2] = {0, 0};\n\n                    if (route->flags & MULTI_ROUTE_CACHE)\n                    {\n                        flags[0] = 'C';\n                    }\n                    status_printf(so, \"%s%s,%s,%s,%s\",\n                                  mroute_addr_print(ma, &gc),\n                                  flags,\n                                  tls_common_name(mi->context.c2.tls_multi, false),\n                                  mroute_addr_print(&mi->real, &gc),\n                                  time_string(route->last_reference, 0, false, &gc));\n                }\n                gc_free(&gc);\n            }\n            hash_iterator_free(&hi);\n\n            status_printf(so, \"GLOBAL STATS\");\n            if (m->mbuf)\n            {\n                status_printf(so, \"Max bcast/mcast queue length,%d\",\n                              mbuf_maximum_queued(m->mbuf));\n            }\n\n            status_printf(so, \"END\");\n        }\n        else if (version == 2 || version == 3)\n        {\n            const char sep = (version == 3) ? '\\t' : ',';\n\n            /*\n             * Status file version 2 and 3\n             */\n            status_printf(so, \"TITLE%c%s\", sep, title_string);\n            status_printf(so, \"TIME%c%s%c%u\", sep, time_string(now, 0, false, &gc_top), sep, (unsigned int)now);\n            status_printf(so, \"HEADER%cCLIENT_LIST%cCommon Name%cReal Address%cVirtual Address%cVirtual IPv6 Address%cBytes Received%cBytes Sent%cConnected Since%cConnected Since (time_t)%cUsername%cClient ID%cPeer ID%cData Channel Cipher\",\n                          sep, sep, sep, sep, sep, sep, sep, sep, sep, sep, sep, sep, sep);\n            hash_iterator_init(m->hash, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct gc_arena gc = gc_new();\n                const struct multi_instance *mi = (struct multi_instance *) he->value;\n\n                if (!mi->halt)\n                {\n                    status_printf(so, \"CLIENT_LIST%c%s%c%s%c%s%c%s%c\" counter_format \"%c\" counter_format \"%c%s%c%u%c%s%c\"\n#ifdef MANAGEMENT_DEF_AUTH\n                                  \"%lu\"\n#else\n                                  \"\"\n#endif\n                                  \"%c%\" PRIu32 \"%c%s\",\n                                  sep, tls_common_name(mi->context.c2.tls_multi, false),\n                                  sep, mroute_addr_print(&mi->real, &gc),\n                                  sep, print_in_addr_t(mi->reporting_addr, IA_EMPTY_IF_UNDEF, &gc),\n                                  sep, print_in6_addr(mi->reporting_addr_ipv6, IA_EMPTY_IF_UNDEF, &gc),\n                                  sep, mi->context.c2.link_read_bytes,\n                                  sep, mi->context.c2.link_write_bytes,\n                                  sep, time_string(mi->created, 0, false, &gc),\n                                  sep, (unsigned int)mi->created,\n                                  sep, tls_username(mi->context.c2.tls_multi, false),\n#ifdef MANAGEMENT_DEF_AUTH\n                                  sep, mi->context.c2.mda_context.cid,\n#else\n                                  sep,\n#endif\n                                  sep, mi->context.c2.tls_multi ? mi->context.c2.tls_multi->peer_id : UINT32_MAX,\n                                  sep, translate_cipher_name_to_openvpn(mi->context.options.ciphername));\n                }\n                gc_free(&gc);\n            }\n            hash_iterator_free(&hi);\n\n            status_printf(so, \"HEADER%cROUTING_TABLE%cVirtual Address%cCommon Name%cReal Address%cLast Ref%cLast Ref (time_t)\",\n                          sep, sep, sep, sep, sep, sep);\n            hash_iterator_init(m->vhash, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct gc_arena gc = gc_new();\n                const struct multi_route *route = (struct multi_route *) he->value;\n\n                if (multi_route_defined(m, route))\n                {\n                    const struct multi_instance *mi = route->instance;\n                    const struct mroute_addr *ma = &route->addr;\n                    char flags[2] = {0, 0};\n\n                    if (route->flags & MULTI_ROUTE_CACHE)\n                    {\n                        flags[0] = 'C';\n                    }\n                    status_printf(so, \"ROUTING_TABLE%c%s%s%c%s%c%s%c%s%c%u\",\n                                  sep, mroute_addr_print(ma, &gc), flags,\n                                  sep, tls_common_name(mi->context.c2.tls_multi, false),\n                                  sep, mroute_addr_print(&mi->real, &gc),\n                                  sep, time_string(route->last_reference, 0, false, &gc),\n                                  sep, (unsigned int)route->last_reference);\n                }\n                gc_free(&gc);\n            }\n            hash_iterator_free(&hi);\n\n            if (m->mbuf)\n            {\n                status_printf(so, \"GLOBAL_STATS%cMax bcast/mcast queue length%c%d\",\n                              sep, sep, mbuf_maximum_queued(m->mbuf));\n            }\n\n            status_printf(so, \"END\");\n        }\n        else\n        {\n            status_printf(so, \"ERROR: bad status format version number\");\n        }\n\n#ifdef PACKET_TRUNCATION_CHECK\n        {\n            status_printf(so, \"HEADER,ERRORS,Common Name,TUN Read Trunc,TUN Write Trunc,Pre-encrypt Trunc,Post-decrypt Trunc\");\n            hash_iterator_init(m->hash, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct gc_arena gc = gc_new();\n                const struct multi_instance *mi = (struct multi_instance *) he->value;\n\n                if (!mi->halt)\n                {\n                    status_printf(so, \"ERRORS,%s,\" counter_format \",\" counter_format \",\" counter_format \",\" counter_format,\n                                  tls_common_name(mi->context.c2.tls_multi, false),\n                                  m->top.c2.n_trunc_tun_read,\n                                  mi->context.c2.n_trunc_tun_write,\n                                  mi->context.c2.n_trunc_pre_encrypt,\n                                  mi->context.c2.n_trunc_post_decrypt);\n                }\n                gc_free(&gc);\n            }\n            hash_iterator_free(&hi);\n        }\n#endif /* ifdef PACKET_TRUNCATION_CHECK */\n\n        status_flush(so);\n        gc_free(&gc_top);\n    }\n\n#ifdef ENABLE_ASYNC_PUSH\n    if (m->inotify_watchers)\n    {\n        msg(D_MULTI_DEBUG, \"inotify watchers count: %d\\n\", hash_n_elements(m->inotify_watchers));\n    }\n#endif\n}\n\n/*\n * Learn a virtual address or route.\n * The learn will fail if the learn address\n * script/plugin fails.  In this case the\n * return value may be != mi.\n * Return the instance which owns this route,\n * or NULL if none.\n */\nstatic struct multi_instance *\nmulti_learn_addr(struct multi_context *m,\n                 struct multi_instance *mi,\n                 const struct mroute_addr *addr,\n                 const unsigned int flags)\n{\n    struct hash_element *he;\n    const uint32_t hv = hash_value(m->vhash, addr);\n    struct hash_bucket *bucket = hash_bucket(m->vhash, hv);\n    struct multi_route *oldroute = NULL;\n    struct multi_instance *owner = NULL;\n    struct gc_arena gc = gc_new();\n\n    /* if route currently exists, get the instance which owns it */\n    he = hash_lookup_fast(m->vhash, bucket, addr, hv);\n    if (he)\n    {\n        oldroute = (struct multi_route *) he->value;\n    }\n    if (oldroute && multi_route_defined(m, oldroute))\n    {\n        owner = oldroute->instance;\n    }\n\n    /* do we need to add address to hash table? */\n    if ((!owner || owner != mi) && mroute_learnable_address(addr, &gc)\n        && !mroute_addr_equal(addr, &m->local))\n    {\n        struct multi_route *newroute;\n        bool learn_succeeded = false;\n\n        ALLOC_OBJ(newroute, struct multi_route);\n        newroute->addr = *addr;\n        newroute->instance = mi;\n        newroute->flags = flags;\n        newroute->last_reference = now;\n        newroute->cache_generation = 0;\n\n        /* The cache is invalidated when cache_generation is incremented */\n        if (flags & MULTI_ROUTE_CACHE)\n        {\n            newroute->cache_generation = m->route_helper->cache_generation;\n        }\n\n        if (oldroute) /* route already exists? */\n        {\n            if (route_quota_test(mi) && learn_address_script(m, mi, \"update\", &newroute->addr))\n            {\n                learn_succeeded = true;\n                owner = mi;\n                multi_instance_inc_refcount(mi);\n                route_quota_inc(mi);\n\n                /* delete old route */\n                multi_route_del(oldroute);\n\n                /* modify hash table entry, replacing old route */\n                he->key = &newroute->addr;\n                he->value = newroute;\n            }\n        }\n        else\n        {\n            if (route_quota_test(mi) && learn_address_script(m, mi, \"add\", &newroute->addr))\n            {\n                learn_succeeded = true;\n                owner = mi;\n                multi_instance_inc_refcount(mi);\n                route_quota_inc(mi);\n\n                /* add new route */\n                hash_add_fast(m->vhash, bucket, &newroute->addr, hv, newroute);\n            }\n        }\n\n        msg(D_MULTI_LOW, \"MULTI: Learn%s: %s -> %s\",\n            learn_succeeded ? \"\" : \" FAILED\",\n            mroute_addr_print(&newroute->addr, &gc),\n            multi_instance_string(mi, false, &gc));\n\n        if (!learn_succeeded)\n        {\n            free(newroute);\n        }\n    }\n    gc_free(&gc);\n\n    return owner;\n}\n\n/*\n * Get client instance based on virtual address.\n */\nstatic struct multi_instance *\nmulti_get_instance_by_virtual_addr(struct multi_context *m,\n                                   const struct mroute_addr *addr,\n                                   bool cidr_routing)\n{\n    struct multi_route *route;\n    struct multi_instance *ret = NULL;\n\n    /* check for local address */\n    if (mroute_addr_equal(addr, &m->local))\n    {\n        return NULL;\n    }\n\n    route = (struct multi_route *) hash_lookup(m->vhash, addr);\n\n    /* does host route (possible cached) exist? */\n    if (route && multi_route_defined(m, route))\n    {\n        struct multi_instance *mi = route->instance;\n        route->last_reference = now;\n        ret = mi;\n    }\n    else if (cidr_routing) /* do we need to regenerate a host route cache entry? */\n    {\n        struct mroute_helper *rh = m->route_helper;\n        struct mroute_addr tryaddr;\n        int i;\n\n        /* cycle through each CIDR length */\n        for (i = 0; i < rh->n_net_len; ++i)\n        {\n            tryaddr = *addr;\n            tryaddr.type |= MR_WITH_NETBITS;\n            tryaddr.netbits = rh->net_len[i];\n            mroute_addr_mask_host_bits(&tryaddr);\n\n            /* look up a possible route with netbits netmask */\n            route = (struct multi_route *) hash_lookup(m->vhash, &tryaddr);\n\n            if (route && multi_route_defined(m, route))\n            {\n                /* found an applicable route, cache host route */\n                struct multi_instance *mi = route->instance;\n                multi_learn_addr(m, mi, addr, MULTI_ROUTE_CACHE|MULTI_ROUTE_AGEABLE);\n                ret = mi;\n                break;\n            }\n        }\n    }\n\n#ifdef ENABLE_DEBUG\n    if (check_debug_level(D_MULTI_DEBUG))\n    {\n        struct gc_arena gc = gc_new();\n        const char *addr_text = mroute_addr_print(addr, &gc);\n        if (ret)\n        {\n            dmsg(D_MULTI_DEBUG, \"GET INST BY VIRT: %s -> %s via %s\",\n                 addr_text,\n                 multi_instance_string(ret, false, &gc),\n                 mroute_addr_print(&route->addr, &gc));\n        }\n        else\n        {\n            dmsg(D_MULTI_DEBUG, \"GET INST BY VIRT: %s [failed]\",\n                 addr_text);\n        }\n        gc_free(&gc);\n    }\n#endif\n\n    ASSERT(!(ret && ret->halt));\n    return ret;\n}\n\n/*\n * Helper function to multi_learn_addr().\n */\nstatic struct multi_instance *\nmulti_learn_in_addr_t(struct multi_context *m,\n                      struct multi_instance *mi,\n                      in_addr_t a,\n                      int netbits,  /* -1 if host route, otherwise # of network bits in address */\n                      bool primary)\n{\n    struct openvpn_sockaddr remote_si;\n    struct mroute_addr addr;\n\n    CLEAR(remote_si);\n    remote_si.addr.in4.sin_family = AF_INET;\n    remote_si.addr.in4.sin_addr.s_addr = htonl(a);\n    ASSERT(mroute_extract_openvpn_sockaddr(&addr, &remote_si, false));\n\n    if (netbits >= 0)\n    {\n        addr.type |= MR_WITH_NETBITS;\n        addr.netbits = (uint8_t) netbits;\n    }\n\n    {\n        struct multi_instance *owner = multi_learn_addr(m, mi, &addr, 0);\n#ifdef MANAGEMENT_DEF_AUTH\n        if (management && owner)\n        {\n            management_learn_addr(management, &mi->context.c2.mda_context, &addr, primary);\n        }\n#endif\n        return owner;\n    }\n}\n\nstatic struct multi_instance *\nmulti_learn_in6_addr(struct multi_context *m,\n                     struct multi_instance *mi,\n                     struct in6_addr a6,\n                     int netbits,   /* -1 if host route, otherwise # of network bits in address */\n                     bool primary)\n{\n    struct mroute_addr addr;\n\n    addr.len = 16;\n    addr.type = MR_ADDR_IPV6;\n    addr.netbits = 0;\n    addr.v6.addr = a6;\n\n    if (netbits >= 0)\n    {\n        addr.type |= MR_WITH_NETBITS;\n        addr.netbits = (uint8_t) netbits;\n        mroute_addr_mask_host_bits( &addr );\n    }\n\n    {\n        struct multi_instance *owner = multi_learn_addr(m, mi, &addr, 0);\n#ifdef MANAGEMENT_DEF_AUTH\n        if (management && owner)\n        {\n            management_learn_addr(management, &mi->context.c2.mda_context, &addr, primary);\n        }\n#endif\n        return owner;\n    }\n}\n\n/*\n * A new client has connected, add routes (server -> client)\n * to internal routing table.\n */\nstatic void\nmulti_add_iroutes(struct multi_context *m,\n                  struct multi_instance *mi)\n{\n    struct gc_arena gc = gc_new();\n    const struct iroute *ir;\n    const struct iroute_ipv6 *ir6;\n    if (TUNNEL_TYPE(mi->context.c1.tuntap) == DEV_TYPE_TUN)\n    {\n        mi->did_iroutes = true;\n        for (ir = mi->context.options.iroutes; ir != NULL; ir = ir->next)\n        {\n            if (ir->netbits >= 0)\n            {\n                msg(D_MULTI_LOW, \"MULTI: internal route %s/%d -> %s\",\n                    print_in_addr_t(ir->network, 0, &gc),\n                    ir->netbits,\n                    multi_instance_string(mi, false, &gc));\n            }\n            else\n            {\n                msg(D_MULTI_LOW, \"MULTI: internal route %s -> %s\",\n                    print_in_addr_t(ir->network, 0, &gc),\n                    multi_instance_string(mi, false, &gc));\n            }\n\n            mroute_helper_add_iroute46(m->route_helper, ir->netbits);\n\n            multi_learn_in_addr_t(m, mi, ir->network, ir->netbits, false);\n        }\n        for (ir6 = mi->context.options.iroutes_ipv6; ir6 != NULL; ir6 = ir6->next)\n        {\n            msg(D_MULTI_LOW, \"MULTI: internal route %s/%d -> %s\",\n                print_in6_addr(ir6->network, 0, &gc),\n                ir6->netbits,\n                multi_instance_string(mi, false, &gc));\n\n            mroute_helper_add_iroute46(m->route_helper, ir6->netbits);\n\n            multi_learn_in6_addr(m, mi, ir6->network, ir6->netbits, false);\n        }\n    }\n    gc_free(&gc);\n}\n\n/*\n * Given an instance (new_mi), delete all other instances which use the\n * same common name.\n */\nstatic void\nmulti_delete_dup(struct multi_context *m, struct multi_instance *new_mi)\n{\n    if (new_mi)\n    {\n        const char *new_cn = tls_common_name(new_mi->context.c2.tls_multi, true);\n        if (new_cn)\n        {\n            struct hash_iterator hi;\n            struct hash_element *he;\n            int count = 0;\n\n            hash_iterator_init(m->iter, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct multi_instance *mi = (struct multi_instance *) he->value;\n                if (mi != new_mi && !mi->halt)\n                {\n                    const char *cn = tls_common_name(mi->context.c2.tls_multi, true);\n                    if (cn && !strcmp(cn, new_cn))\n                    {\n                        mi->did_iter = false;\n                        multi_close_instance(m, mi, false);\n                        hash_iterator_delete_element(&hi);\n                        ++count;\n                    }\n                }\n            }\n            hash_iterator_free(&hi);\n\n            if (count)\n            {\n                msg(D_MULTI_LOW, \"MULTI: new connection by client '%s' will cause previous active sessions by this client to be dropped.  Remember to use the --duplicate-cn option if you want multiple clients using the same certificate or username to concurrently connect.\", new_cn);\n            }\n        }\n    }\n}\n\nstatic void\ncheck_stale_routes(struct multi_context *m)\n{\n\n    struct gc_arena gc = gc_new();\n    struct hash_iterator hi;\n    struct hash_element *he;\n\n    dmsg(D_MULTI_DEBUG, \"MULTI: Checking stale routes\");\n    hash_iterator_init_range(m->vhash, &hi, 0, hash_n_buckets(m->vhash));\n    while ((he = hash_iterator_next(&hi)) != NULL)\n    {\n        struct multi_route *r = (struct multi_route *) he->value;\n        if (multi_route_defined(m, r) && difftime(now, r->last_reference) >= m->top.options.stale_routes_ageing_time)\n        {\n            dmsg(D_MULTI_DEBUG, \"MULTI: Deleting stale route for address '%s'\",\n                 mroute_addr_print(&r->addr, &gc));\n            learn_address_script(m, NULL, \"delete\", &r->addr);\n            multi_route_del(r);\n            hash_iterator_delete_element(&hi);\n        }\n    }\n    hash_iterator_free(&hi);\n    gc_free(&gc);\n}\n\n/*\n * Ensure that endpoint to be pushed to client\n * complies with --ifconfig-push-constraint directive.\n */\nstatic bool\nifconfig_push_constraint_satisfied(const struct context *c)\n{\n    const struct options *o = &c->options;\n    if (o->push_ifconfig_constraint_defined && c->c2.push_ifconfig_defined)\n    {\n        return (o->push_ifconfig_constraint_netmask & c->c2.push_ifconfig_local) == o->push_ifconfig_constraint_network;\n    }\n    else\n    {\n        return true;\n    }\n}\n\n/*\n * Select a virtual address for a new client instance.\n * Use an --ifconfig-push directive, if given (static IP).\n * Otherwise use an --ifconfig-pool address (dynamic IP).\n */\nstatic void\nmulti_select_virtual_addr(struct multi_context *m, struct multi_instance *mi)\n{\n    struct gc_arena gc = gc_new();\n\n    /*\n     * If ifconfig addresses were set by dynamic config file,\n     * release pool addresses, otherwise keep them.\n     */\n    if (mi->context.options.push_ifconfig_defined)\n    {\n        /* ifconfig addresses were set statically,\n         * release dynamic allocation */\n        if (mi->vaddr_handle >= 0)\n        {\n            ifconfig_pool_release(m->ifconfig_pool, mi->vaddr_handle, true);\n            mi->vaddr_handle = -1;\n        }\n\n        mi->context.c2.push_ifconfig_defined = true;\n        mi->context.c2.push_ifconfig_local = mi->context.options.push_ifconfig_local;\n        mi->context.c2.push_ifconfig_remote_netmask = mi->context.options.push_ifconfig_remote_netmask;\n        mi->context.c2.push_ifconfig_local_alias = mi->context.options.push_ifconfig_local_alias;\n\n        /* the current implementation does not allow \"static IPv4, pool IPv6\",\n         * (see below) so issue a warning if that happens - don't break the\n         * session, though, as we don't even know if this client WANTS IPv6\n         */\n        if (mi->context.options.ifconfig_ipv6_pool_defined\n            && !mi->context.options.push_ifconfig_ipv6_defined)\n        {\n            msg( M_INFO, \"MULTI_sva: WARNING: if --ifconfig-push is used for IPv4, automatic IPv6 assignment from --ifconfig-ipv6-pool does not work.  Use --ifconfig-ipv6-push for IPv6 then.\" );\n        }\n    }\n    else if (m->ifconfig_pool && mi->vaddr_handle < 0) /* otherwise, choose a pool address */\n    {\n        in_addr_t local = 0, remote = 0;\n        struct in6_addr remote_ipv6;\n        const char *cn = NULL;\n\n        if (!mi->context.options.duplicate_cn)\n        {\n            cn = tls_common_name(mi->context.c2.tls_multi, true);\n        }\n\n        CLEAR(remote_ipv6);\n        mi->vaddr_handle = ifconfig_pool_acquire(m->ifconfig_pool, &local, &remote, &remote_ipv6, cn);\n        if (mi->vaddr_handle >= 0)\n        {\n            const int tunnel_type = TUNNEL_TYPE(mi->context.c1.tuntap);\n            const int tunnel_topology = TUNNEL_TOPOLOGY(mi->context.c1.tuntap);\n\n            msg( M_INFO, \"MULTI_sva: pool returned IPv4=%s, IPv6=%s\",\n                 print_in_addr_t( remote, 0, &gc ),\n                 (mi->context.options.ifconfig_ipv6_pool_defined\n                  ? print_in6_addr( remote_ipv6, 0, &gc )\n                  : \"(Not enabled)\") );\n\n            /* set push_ifconfig_remote_netmask from pool ifconfig address(es) */\n            mi->context.c2.push_ifconfig_local = remote;\n            if (tunnel_type == DEV_TYPE_TAP || (tunnel_type == DEV_TYPE_TUN && tunnel_topology == TOP_SUBNET))\n            {\n                mi->context.c2.push_ifconfig_remote_netmask = mi->context.options.ifconfig_pool_netmask;\n                if (!mi->context.c2.push_ifconfig_remote_netmask)\n                {\n                    mi->context.c2.push_ifconfig_remote_netmask = mi->context.c1.tuntap->remote_netmask;\n                }\n            }\n            else if (tunnel_type == DEV_TYPE_TUN)\n            {\n                if (tunnel_topology == TOP_P2P)\n                {\n                    mi->context.c2.push_ifconfig_remote_netmask = mi->context.c1.tuntap->local;\n                }\n                else if (tunnel_topology == TOP_NET30)\n                {\n                    mi->context.c2.push_ifconfig_remote_netmask = local;\n                }\n            }\n\n            if (mi->context.c2.push_ifconfig_remote_netmask)\n            {\n                mi->context.c2.push_ifconfig_defined = true;\n            }\n            else\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: no --ifconfig-pool netmask parameter is available to push to %s\",\n                    multi_instance_string(mi, false, &gc));\n            }\n\n            if (mi->context.options.ifconfig_ipv6_pool_defined)\n            {\n                mi->context.c2.push_ifconfig_ipv6_local = remote_ipv6;\n                mi->context.c2.push_ifconfig_ipv6_remote =\n                    mi->context.c1.tuntap->local_ipv6;\n                mi->context.c2.push_ifconfig_ipv6_netbits =\n                    mi->context.options.ifconfig_ipv6_netbits;\n                mi->context.c2.push_ifconfig_ipv6_defined = true;\n            }\n        }\n        else\n        {\n            msg(D_MULTI_ERRORS, \"MULTI: no free --ifconfig-pool addresses are available\");\n        }\n    }\n\n    /* IPv6 push_ifconfig is a bit problematic - since IPv6 shares the\n     * pool handling with IPv4, the combination \"static IPv4, dynamic IPv6\"\n     * will fail (because no pool will be allocated in this case).\n     * OTOH, this doesn't make too much sense in reality - and the other\n     * way round (\"dynamic IPv4, static IPv6\") or \"both static\" makes sense\n     * -> and so it's implemented right now\n     */\n    if (mi->context.options.push_ifconfig_ipv6_defined)\n    {\n        mi->context.c2.push_ifconfig_ipv6_local =\n            mi->context.options.push_ifconfig_ipv6_local;\n        mi->context.c2.push_ifconfig_ipv6_remote =\n            mi->context.options.push_ifconfig_ipv6_remote;\n        mi->context.c2.push_ifconfig_ipv6_netbits =\n            mi->context.options.push_ifconfig_ipv6_netbits;\n        mi->context.c2.push_ifconfig_ipv6_defined = true;\n\n        msg( M_INFO, \"MULTI_sva: push_ifconfig_ipv6 %s/%d\",\n             print_in6_addr( mi->context.c2.push_ifconfig_ipv6_local, 0, &gc ),\n             mi->context.c2.push_ifconfig_ipv6_netbits );\n    }\n\n    gc_free(&gc);\n}\n\n/*\n * Set virtual address environmental variables.\n */\nstatic void\nmulti_set_virtual_addr_env(struct multi_instance *mi)\n{\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_local_ip\");\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_remote_ip\");\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_netmask\");\n\n    if (mi->context.c2.push_ifconfig_defined)\n    {\n        const int tunnel_type = TUNNEL_TYPE(mi->context.c1.tuntap);\n        const int tunnel_topology = TUNNEL_TOPOLOGY(mi->context.c1.tuntap);\n\n        setenv_in_addr_t(mi->context.c2.es,\n                         \"ifconfig_pool_remote_ip\",\n                         mi->context.c2.push_ifconfig_local,\n                         SA_SET_IF_NONZERO);\n\n        if (tunnel_type == DEV_TYPE_TAP || (tunnel_type == DEV_TYPE_TUN && tunnel_topology == TOP_SUBNET))\n        {\n            setenv_in_addr_t(mi->context.c2.es,\n                             \"ifconfig_pool_netmask\",\n                             mi->context.c2.push_ifconfig_remote_netmask,\n                             SA_SET_IF_NONZERO);\n        }\n        else if (tunnel_type == DEV_TYPE_TUN)\n        {\n            setenv_in_addr_t(mi->context.c2.es,\n                             \"ifconfig_pool_local_ip\",\n                             mi->context.c2.push_ifconfig_remote_netmask,\n                             SA_SET_IF_NONZERO);\n        }\n    }\n\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_local_ip6\");\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_remote_ip6\");\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_ip6_netbits\");\n\n    if (mi->context.c2.push_ifconfig_ipv6_defined)\n    {\n        setenv_in6_addr(mi->context.c2.es,\n                        \"ifconfig_pool_remote\",\n                        &mi->context.c2.push_ifconfig_ipv6_local,\n                        SA_SET_IF_NONZERO);\n        setenv_in6_addr(mi->context.c2.es,\n                        \"ifconfig_pool_local\",\n                        &mi->context.c2.push_ifconfig_ipv6_remote,\n                        SA_SET_IF_NONZERO);\n        setenv_int(mi->context.c2.es,\n                   \"ifconfig_pool_ip6_netbits\",\n                   mi->context.c2.push_ifconfig_ipv6_netbits);\n    }\n}\n\n/*\n * Called after client-connect script is called\n */\nstatic void\nmulti_client_connect_post(struct multi_context *m,\n                          struct multi_instance *mi,\n                          const char *dc_file,\n                          unsigned int option_permissions_mask,\n                          unsigned int *option_types_found)\n{\n    /* Did script generate a dynamic config file? */\n    if (platform_test_file(dc_file))\n    {\n        options_server_import(&mi->context.options,\n                              dc_file,\n                              D_IMPORT_ERRORS|M_OPTERR,\n                              option_permissions_mask,\n                              option_types_found,\n                              mi->context.c2.es);\n\n        /*\n         * If the --client-connect script generates a config file\n         * with an --ifconfig-push directive, it will override any\n         * --ifconfig-push directive from the --client-config-dir\n         * directory or any --ifconfig-pool dynamic address.\n         */\n        multi_select_virtual_addr(m, mi);\n        multi_set_virtual_addr_env(mi);\n    }\n}\n\n#ifdef ENABLE_PLUGIN\n\n/*\n * Called after client-connect plug-in is called\n */\nstatic void\nmulti_client_connect_post_plugin(struct multi_context *m,\n                                 struct multi_instance *mi,\n                                 const struct plugin_return *pr,\n                                 unsigned int option_permissions_mask,\n                                 unsigned int *option_types_found)\n{\n    struct plugin_return config;\n\n    plugin_return_get_column(pr, &config, \"config\");\n\n    /* Did script generate a dynamic config file? */\n    if (plugin_return_defined(&config))\n    {\n        int i;\n        for (i = 0; i < config.n; ++i)\n        {\n            if (config.list[i] && config.list[i]->value)\n            {\n                options_string_import(&mi->context.options,\n                                      config.list[i]->value,\n                                      D_IMPORT_ERRORS|M_OPTERR,\n                                      option_permissions_mask,\n                                      option_types_found,\n                                      mi->context.c2.es);\n            }\n        }\n\n        /*\n         * If the --client-connect script generates a config file\n         * with an --ifconfig-push directive, it will override any\n         * --ifconfig-push directive from the --client-config-dir\n         * directory or any --ifconfig-pool dynamic address.\n         */\n        multi_select_virtual_addr(m, mi);\n        multi_set_virtual_addr_env(mi);\n    }\n}\n\n#endif /* ifdef ENABLE_PLUGIN */\n\n#ifdef MANAGEMENT_DEF_AUTH\n\n/*\n * Called to load management-derived client-connect config\n */\nstatic void\nmulti_client_connect_mda(struct multi_context *m,\n                         struct multi_instance *mi,\n                         const struct buffer_list *config,\n                         unsigned int option_permissions_mask,\n                         unsigned int *option_types_found)\n{\n    if (config)\n    {\n        struct buffer_entry *be;\n\n        for (be = config->head; be != NULL; be = be->next)\n        {\n            const char *opt = BSTR(&be->buf);\n            options_string_import(&mi->context.options,\n                                  opt,\n                                  D_IMPORT_ERRORS|M_OPTERR,\n                                  option_permissions_mask,\n                                  option_types_found,\n                                  mi->context.c2.es);\n        }\n\n        /*\n         * If the --client-connect script generates a config file\n         * with an --ifconfig-push directive, it will override any\n         * --ifconfig-push directive from the --client-config-dir\n         * directory or any --ifconfig-pool dynamic address.\n         */\n        multi_select_virtual_addr(m, mi);\n        multi_set_virtual_addr_env(mi);\n    }\n}\n\n#endif /* ifdef MANAGEMENT_DEF_AUTH */\n\nstatic void\nmulti_client_connect_setenv(struct multi_context *m,\n                            struct multi_instance *mi)\n{\n    struct gc_arena gc = gc_new();\n\n    /* setenv incoming cert common name for script */\n    setenv_str(mi->context.c2.es, \"common_name\", tls_common_name(mi->context.c2.tls_multi, true));\n\n    /* setenv client real IP address */\n    setenv_trusted(mi->context.c2.es, get_link_socket_info(&mi->context));\n\n    /* setenv client virtual IP address */\n    multi_set_virtual_addr_env(mi);\n\n    /* setenv connection time */\n    {\n        const char *created_ascii = time_string(mi->created, 0, false, &gc);\n        setenv_str(mi->context.c2.es, \"time_ascii\", created_ascii);\n        setenv_long_long(mi->context.c2.es, \"time_unix\", mi->created);\n    }\n\n    gc_free(&gc);\n}\n\n/*\n * Called as soon as the SSL/TLS connection authenticates.\n *\n * Instance-specific directives to be processed:\n *\n *   iroute start-ip end-ip\n *   ifconfig-push local remote-netmask\n *   push\n */\nstatic void\nmulti_connection_established(struct multi_context *m, struct multi_instance *mi)\n{\n    if (tls_authentication_status(mi->context.c2.tls_multi, 0) == TLS_AUTHENTICATION_SUCCEEDED)\n    {\n        struct gc_arena gc = gc_new();\n        unsigned int option_types_found = 0;\n\n        const unsigned int option_permissions_mask =\n            OPT_P_INSTANCE\n            | OPT_P_INHERIT\n            | OPT_P_PUSH\n            | OPT_P_TIMER\n            | OPT_P_CONFIG\n            | OPT_P_ECHO\n            | OPT_P_COMP\n            | OPT_P_SOCKFLAGS;\n\n        int cc_succeeded = true; /* client connect script status */\n        int cc_succeeded_count = 0;\n\n        ASSERT(mi->context.c1.tuntap);\n\n        /* lock down the common name and cert hashes so they can't change during future TLS renegotiations */\n        tls_lock_common_name(mi->context.c2.tls_multi);\n        tls_lock_cert_hash_set(mi->context.c2.tls_multi);\n\n        /* generate a msg() prefix for this client instance */\n        generate_prefix(mi);\n\n        /* delete instances of previous clients with same common-name */\n        if (!mi->context.options.duplicate_cn)\n        {\n            multi_delete_dup(m, mi);\n        }\n\n        /* reset pool handle to null */\n        mi->vaddr_handle = -1;\n\n        /*\n         * Try to source a dynamic config file from the\n         * --client-config-dir directory.\n         */\n        if (mi->context.options.client_config_dir)\n        {\n            const char *ccd_file;\n\n            ccd_file = platform_gen_path(mi->context.options.client_config_dir,\n                                         tls_common_name(mi->context.c2.tls_multi,\n                                                         false),\n                                         &gc);\n\n            /* try common-name file */\n            if (platform_test_file(ccd_file))\n            {\n                options_server_import(&mi->context.options,\n                                      ccd_file,\n                                      D_IMPORT_ERRORS|M_OPTERR,\n                                      option_permissions_mask,\n                                      &option_types_found,\n                                      mi->context.c2.es);\n            }\n            else /* try default file */\n            {\n                ccd_file = platform_gen_path(mi->context.options.client_config_dir,\n                                             CCD_DEFAULT,\n                                             &gc);\n\n                if (platform_test_file(ccd_file))\n                {\n                    options_server_import(&mi->context.options,\n                                          ccd_file,\n                                          D_IMPORT_ERRORS|M_OPTERR,\n                                          option_permissions_mask,\n                                          &option_types_found,\n                                          mi->context.c2.es);\n                }\n            }\n        }\n\n        /*\n         * Select a virtual address from either --ifconfig-push in --client-config-dir file\n         * or --ifconfig-pool.\n         */\n        multi_select_virtual_addr(m, mi);\n\n        /* do --client-connect setenvs */\n        multi_client_connect_setenv(m, mi);\n\n#ifdef ENABLE_PLUGIN\n        /*\n         * Call client-connect plug-in.\n         */\n\n        /* deprecated callback, use a file for passing back return info */\n        if (plugin_defined(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT))\n        {\n            struct argv argv = argv_new();\n            const char *dc_file = platform_create_temp_file(mi->context.options.tmp_dir,\n                                                            \"cc\", &gc);\n\n            if (!dc_file)\n            {\n                cc_succeeded = false;\n                goto script_depr_failed;\n            }\n\n            argv_printf(&argv, \"%s\", dc_file);\n            if (plugin_call(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT, &argv, NULL, mi->context.c2.es) != OPENVPN_PLUGIN_FUNC_SUCCESS)\n            {\n                msg(M_WARN, \"WARNING: client-connect plugin call failed\");\n                cc_succeeded = false;\n            }\n            else\n            {\n                multi_client_connect_post(m, mi, dc_file, option_permissions_mask, &option_types_found);\n                ++cc_succeeded_count;\n            }\n\n            if (!platform_unlink(dc_file))\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: problem deleting temporary file: %s\",\n                    dc_file);\n            }\n\nscript_depr_failed:\n            argv_free(&argv);\n        }\n\n        /* V2 callback, use a plugin_return struct for passing back return info */\n        if (plugin_defined(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT_V2))\n        {\n            struct plugin_return pr;\n\n            plugin_return_init(&pr);\n\n            if (plugin_call(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT_V2, NULL, &pr, mi->context.c2.es) != OPENVPN_PLUGIN_FUNC_SUCCESS)\n            {\n                msg(M_WARN, \"WARNING: client-connect-v2 plugin call failed\");\n                cc_succeeded = false;\n            }\n            else\n            {\n                multi_client_connect_post_plugin(m, mi, &pr, option_permissions_mask, &option_types_found);\n                ++cc_succeeded_count;\n            }\n\n            plugin_return_free(&pr);\n        }\n#endif /* ifdef ENABLE_PLUGIN */\n\n        /*\n         * Run --client-connect script.\n         */\n        if (mi->context.options.client_connect_script && cc_succeeded)\n        {\n            struct argv argv = argv_new();\n            const char *dc_file = NULL;\n\n            setenv_str(mi->context.c2.es, \"script_type\", \"client-connect\");\n\n            dc_file = platform_create_temp_file(mi->context.options.tmp_dir,\n                                                \"cc\", &gc);\n            if (!dc_file)\n            {\n                cc_succeeded = false;\n                goto script_failed;\n            }\n\n            argv_parse_cmd(&argv, mi->context.options.client_connect_script);\n            argv_printf_cat(&argv, \"%s\", dc_file);\n\n            if (openvpn_run_script(&argv, mi->context.c2.es, 0, \"--client-connect\"))\n            {\n                multi_client_connect_post(m, mi, dc_file, option_permissions_mask, &option_types_found);\n                ++cc_succeeded_count;\n            }\n            else\n            {\n                cc_succeeded = false;\n            }\n\n            if (!platform_unlink(dc_file))\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: problem deleting temporary file: %s\",\n                    dc_file);\n            }\n\nscript_failed:\n            argv_free(&argv);\n        }\n\n        /*\n         * Check for client-connect script left by management interface client\n         */\n#ifdef MANAGEMENT_DEF_AUTH\n        if (cc_succeeded && mi->cc_config)\n        {\n            multi_client_connect_mda(m, mi, mi->cc_config, option_permissions_mask, &option_types_found);\n            ++cc_succeeded_count;\n        }\n#endif\n\n        /*\n         * Check for \"disable\" directive in client-config-dir file\n         * or config file generated by --client-connect script.\n         */\n        if (mi->context.options.disable)\n        {\n            msg(D_MULTI_ERRORS, \"MULTI: client has been rejected due to 'disable' directive\");\n            cc_succeeded = false;\n            cc_succeeded_count = 0;\n        }\n\n        if (cc_succeeded)\n        {\n            /*\n             * Process sourced options.\n             */\n            do_deferred_options(&mi->context, option_types_found);\n\n            /*\n             * make sure we got ifconfig settings from somewhere\n             */\n            if (!mi->context.c2.push_ifconfig_defined)\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: no dynamic or static remote --ifconfig address is available for %s\",\n                    multi_instance_string(mi, false, &gc));\n            }\n\n            /*\n             * make sure that ifconfig settings comply with constraints\n             */\n            if (!ifconfig_push_constraint_satisfied(&mi->context))\n            {\n                /* JYFIXME -- this should cause the connection to fail */\n                msg(D_MULTI_ERRORS, \"MULTI ERROR: primary virtual IP for %s (%s) violates tunnel network/netmask constraint (%s/%s)\",\n                    multi_instance_string(mi, false, &gc),\n                    print_in_addr_t(mi->context.c2.push_ifconfig_local, 0, &gc),\n                    print_in_addr_t(mi->context.options.push_ifconfig_constraint_network, 0, &gc),\n                    print_in_addr_t(mi->context.options.push_ifconfig_constraint_netmask, 0, &gc));\n            }\n\n            /*\n             * For routed tunnels, set up internal route to endpoint\n             * plus add all iroute routes.\n             */\n            if (TUNNEL_TYPE(mi->context.c1.tuntap) == DEV_TYPE_TUN)\n            {\n                if (mi->context.c2.push_ifconfig_defined)\n                {\n                    multi_learn_in_addr_t(m, mi, mi->context.c2.push_ifconfig_local, -1, true);\n                    msg(D_MULTI_LOW, \"MULTI: primary virtual IP for %s: %s\",\n                        multi_instance_string(mi, false, &gc),\n                        print_in_addr_t(mi->context.c2.push_ifconfig_local, 0, &gc));\n                }\n\n                if (mi->context.c2.push_ifconfig_ipv6_defined)\n                {\n                    multi_learn_in6_addr(m, mi, mi->context.c2.push_ifconfig_ipv6_local, -1, true);\n                    /* TODO: find out where addresses are \"unlearned\"!! */\n                    msg(D_MULTI_LOW, \"MULTI: primary virtual IPv6 for %s: %s\",\n                        multi_instance_string(mi, false, &gc),\n                        print_in6_addr(mi->context.c2.push_ifconfig_ipv6_local, 0, &gc));\n                }\n\n                /* add routes locally, pointing to new client, if\n                 * --iroute options have been specified */\n                multi_add_iroutes(m, mi);\n\n                /*\n                 * iroutes represent subnets which are \"owned\" by a particular\n                 * client.  Therefore, do not actually push a route to a client\n                 * if it matches one of the client's iroutes.\n                 */\n                remove_iroutes_from_push_route_list(&mi->context.options);\n            }\n            else if (mi->context.options.iroutes)\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: --iroute options rejected for %s -- iroute only works with tun-style tunnels\",\n                    multi_instance_string(mi, false, &gc));\n            }\n\n            /* set our client's VPN endpoint for status reporting purposes */\n            mi->reporting_addr = mi->context.c2.push_ifconfig_local;\n            mi->reporting_addr_ipv6 = mi->context.c2.push_ifconfig_ipv6_local;\n\n            /* set context-level authentication flag */\n            mi->context.c2.context_auth = CAS_SUCCEEDED;\n\n#ifdef ENABLE_ASYNC_PUSH\n            /* authentication complete, send push reply */\n            if (mi->context.c2.push_request_received)\n            {\n                process_incoming_push_request(&mi->context);\n            }\n#endif\n        }\n        else\n        {\n            /* set context-level authentication flag */\n            mi->context.c2.context_auth = cc_succeeded_count ? CAS_PARTIAL : CAS_FAILED;\n        }\n\n        /* set flag so we don't get called again */\n        mi->connection_established_flag = true;\n\n        /* increment number of current authenticated clients */\n        ++m->n_clients;\n        update_mstat_n_clients(m->n_clients);\n        --mi->n_clients_delta;\n\n#ifdef MANAGEMENT_DEF_AUTH\n        if (management)\n        {\n            management_connection_established(management, &mi->context.c2.mda_context, mi->context.c2.es);\n        }\n#endif\n\n        gc_free(&gc);\n    }\n\n    /*\n     * Reply now to client's PUSH_REQUEST query\n     */\n    mi->context.c2.push_reply_deferred = false;\n}\n\n#ifdef ENABLE_ASYNC_PUSH\n/*\n * Called when inotify event is fired, which happens when acf file is closed or deleted.\n * Continues authentication and sends push_reply.\n */\nvoid\nmulti_process_file_closed(struct multi_context *m, const unsigned int mpp_flags)\n{\n    char buffer[INOTIFY_EVENT_BUFFER_SIZE];\n    size_t buffer_i = 0;\n    int r = read(m->top.c2.inotify_fd, buffer, INOTIFY_EVENT_BUFFER_SIZE);\n\n    while (buffer_i < r)\n    {\n        /* parse inotify events */\n        struct inotify_event *pevent = (struct inotify_event *) &buffer[buffer_i];\n        size_t event_size = sizeof(struct inotify_event) + pevent->len;\n        buffer_i += event_size;\n\n        msg(D_MULTI_DEBUG, \"MULTI: modified fd %d, mask %d\", pevent->wd, pevent->mask);\n\n        struct multi_instance *mi = hash_lookup(m->inotify_watchers, (void *) (unsigned long) pevent->wd);\n\n        if (pevent->mask & IN_CLOSE_WRITE)\n        {\n            if (mi)\n            {\n                /* continue authentication, perform NCP negotiation and send push_reply */\n                multi_process_post(m, mi, mpp_flags);\n\n                /* With NCP and deferred authentication, we perform cipher negotiation and\n                 * data channel keys generation on incoming push request, assuming that auth\n                 * succeeded. When auth succeeds in between push requests and async push is used,\n                 * we send push reply immediately. Above multi_process_post() call performs\n                 * NCP negotiation and here we do keys generation. */\n\n                struct context *c = &mi->context;\n                struct frame *frame_fragment = NULL;\n#ifdef ENABLE_FRAGMENT\n                if (c->options.ce.fragment)\n                {\n                    frame_fragment = &c->c2.frame_fragment;\n                }\n#endif\n                struct tls_session *session = &c->c2.tls_multi->session[TM_ACTIVE];\n                if (!tls_session_update_crypto_params(session, &c->options,\n                                                      &c->c2.frame, frame_fragment))\n                {\n                    msg(D_TLS_ERRORS, \"TLS Error: initializing data channel failed\");\n                    register_signal(c, SIGUSR1, \"init-data-channel-failed\");\n                }\n            }\n            else\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: multi_instance not found!\");\n            }\n        }\n        else if (pevent->mask & IN_IGNORED)\n        {\n            /* this event is _always_ fired when watch is removed or file is deleted */\n            if (mi)\n            {\n                hash_remove(m->inotify_watchers, (void *) (unsigned long) pevent->wd);\n                mi->inotify_watch = -1;\n            }\n        }\n        else\n        {\n            msg(D_MULTI_ERRORS, \"MULTI: unknown mask %d\", pevent->mask);\n        }\n    }\n}\n#endif /* ifdef ENABLE_ASYNC_PUSH */\n\n/*\n * Add a mbuf buffer to a particular\n * instance.\n */\nvoid\nmulti_add_mbuf(struct multi_context *m,\n               struct multi_instance *mi,\n               struct mbuf_buffer *mb)\n{\n    if (multi_output_queue_ready(m, mi))\n    {\n        struct mbuf_item item;\n        item.buffer = mb;\n        item.instance = mi;\n        mbuf_add_item(m->mbuf, &item);\n    }\n    else\n    {\n        msg(D_MULTI_DROPPED, \"MULTI: packet dropped due to output saturation (multi_add_mbuf)\");\n    }\n}\n\n/*\n * Add a packet to a client instance output queue.\n */\nstatic inline void\nmulti_unicast(struct multi_context *m,\n              const struct buffer *buf,\n              struct multi_instance *mi)\n{\n    struct mbuf_buffer *mb;\n\n    if (BLEN(buf) > 0)\n    {\n        mb = mbuf_alloc_buf(buf);\n        mb->flags = MF_UNICAST;\n        multi_add_mbuf(m, mi, mb);\n        mbuf_free_buf(mb);\n    }\n}\n\n/*\n * Broadcast a packet to all clients.\n */\nstatic void\nmulti_bcast(struct multi_context *m,\n            const struct buffer *buf,\n            const struct multi_instance *sender_instance,\n            const struct mroute_addr *sender_addr,\n            uint16_t vid)\n{\n    struct hash_iterator hi;\n    struct hash_element *he;\n    struct multi_instance *mi;\n    struct mbuf_buffer *mb;\n\n    if (BLEN(buf) > 0)\n    {\n        perf_push(PERF_MULTI_BCAST);\n#ifdef MULTI_DEBUG_EVENT_LOOP\n        printf(\"BCAST len=%d\\n\", BLEN(buf));\n#endif\n        mb = mbuf_alloc_buf(buf);\n        hash_iterator_init(m->iter, &hi);\n\n        while ((he = hash_iterator_next(&hi)))\n        {\n            mi = (struct multi_instance *) he->value;\n            if (mi != sender_instance && !mi->halt)\n            {\n#ifdef ENABLE_PF\n                if (sender_instance)\n                {\n                    if (!pf_c2c_test(&sender_instance->context.c2.pf,\n                                     sender_instance->context.c2.tls_multi,\n                                     &mi->context.c2.pf,\n                                     mi->context.c2.tls_multi,\n                                     \"bcast_c2c\"))\n                    {\n                        msg(D_PF_DROPPED_BCAST, \"PF: client[%s] -> client[%s] packet dropped by BCAST packet filter\",\n                            mi_prefix(sender_instance),\n                            mi_prefix(mi));\n                        continue;\n                    }\n                }\n                if (sender_addr)\n                {\n                    if (!pf_addr_test(&mi->context.c2.pf, &mi->context,\n                                      sender_addr, \"bcast_src_addr\"))\n                    {\n                        struct gc_arena gc = gc_new();\n                        msg(D_PF_DROPPED_BCAST, \"PF: addr[%s] -> client[%s] packet dropped by BCAST packet filter\",\n                            mroute_addr_print_ex(sender_addr, MAPF_SHOW_ARP, &gc),\n                            mi_prefix(mi));\n                        gc_free(&gc);\n                        continue;\n                    }\n                }\n#endif /* ifdef ENABLE_PF */\n                if (vid != 0 && vid != mi->context.options.vlan_pvid)\n                {\n                    continue;\n                }\n                multi_add_mbuf(m, mi, mb);\n            }\n        }\n\n        hash_iterator_free(&hi);\n        mbuf_free_buf(mb);\n        perf_pop();\n    }\n}\n\n/*\n * Given a time delta, indicating that we wish to be\n * awoken by the scheduler at time now + delta, figure\n * a sigma parameter (in microseconds) that represents\n * a sort of fuzz factor around delta, so that we're\n * really telling the scheduler to wake us up any time\n * between now + delta - sigma and now + delta + sigma.\n *\n * The sigma parameter helps the scheduler to run more efficiently.\n * Sigma should be no larger than TV_WITHIN_SIGMA_MAX_USEC\n */\nstatic inline unsigned int\ncompute_wakeup_sigma(const struct timeval *delta)\n{\n    if (delta->tv_sec < 1)\n    {\n        /* if < 1 sec, fuzz = # of microseconds / 8 */\n        return delta->tv_usec >> 3;\n    }\n    else\n    {\n        /* if < 10 minutes, fuzz = 13.1% of timeout */\n        if (delta->tv_sec < 600)\n        {\n            return delta->tv_sec << 17;\n        }\n        else\n        {\n            return 120000000; /* if >= 10 minutes, fuzz = 2 minutes */\n        }\n    }\n}\n\nstatic void\nmulti_schedule_context_wakeup(struct multi_context *m, struct multi_instance *mi)\n{\n    /* calculate an absolute wakeup time */\n    ASSERT(!openvpn_gettimeofday(&mi->wakeup, NULL));\n    tv_add(&mi->wakeup, &mi->context.c2.timeval);\n\n    /* tell scheduler to wake us up at some point in the future */\n    schedule_add_entry(m->schedule,\n                       (struct schedule_entry *) mi,\n                       &mi->wakeup,\n                       compute_wakeup_sigma(&mi->context.c2.timeval));\n}\n\n/*\n * Figure instance-specific timers, convert\n * earliest to absolute time in mi->wakeup,\n * call scheduler with our future wakeup time.\n *\n * Also close context on signal.\n */\nbool\nmulti_process_post(struct multi_context *m, struct multi_instance *mi, const unsigned int flags)\n{\n    bool ret = true;\n\n    if (!IS_SIG(&mi->context) && ((flags & MPP_PRE_SELECT) || ((flags & MPP_CONDITIONAL_PRE_SELECT) && !ANY_OUT(&mi->context))))\n    {\n#if defined(ENABLE_ASYNC_PUSH) && defined(ENABLE_DEF_AUTH)\n        bool was_authenticated = false;\n        struct key_state *ks = NULL;\n        if (mi->context.c2.tls_multi)\n        {\n            ks = &mi->context.c2.tls_multi->session[TM_ACTIVE].key[KS_PRIMARY];\n            was_authenticated = ks->authenticated;\n        }\n#endif\n\n        /* figure timeouts and fetch possible outgoing\n         * to_link packets (such as ping or TLS control) */\n        pre_select(&mi->context);\n\n#if defined(ENABLE_ASYNC_PUSH) && defined(ENABLE_DEF_AUTH)\n        if (ks && ks->auth_control_file && ks->auth_deferred && !was_authenticated)\n        {\n            /* watch acf file */\n            long watch_descriptor = inotify_add_watch(m->top.c2.inotify_fd, ks->auth_control_file, IN_CLOSE_WRITE | IN_ONESHOT);\n            if (watch_descriptor >= 0)\n            {\n                if (mi->inotify_watch != -1)\n                {\n                    hash_remove(m->inotify_watchers, (void *) (unsigned long)mi->inotify_watch);\n                }\n                hash_add(m->inotify_watchers, (const uintptr_t *)watch_descriptor, mi, true);\n                mi->inotify_watch = watch_descriptor;\n            }\n            else\n            {\n                msg(M_NONFATAL | M_ERRNO, \"MULTI: inotify_add_watch error\");\n            }\n        }\n#endif\n\n        if (!IS_SIG(&mi->context))\n        {\n            /* connection is \"established\" when SSL/TLS key negotiation succeeds\n             * and (if specified) auth user/pass succeeds */\n            if (!mi->connection_established_flag && CONNECTION_ESTABLISHED(&mi->context))\n            {\n                multi_connection_established(m, mi);\n            }\n\n            /* tell scheduler to wake us up at some point in the future */\n            multi_schedule_context_wakeup(m, mi);\n        }\n    }\n\n    if (IS_SIG(&mi->context))\n    {\n        if (flags & MPP_CLOSE_ON_SIGNAL)\n        {\n            multi_close_instance_on_signal(m, mi);\n            ret = false;\n        }\n    }\n    else\n    {\n        /* continue to pend on output? */\n        multi_set_pending(m, ANY_OUT(&mi->context) ? mi : NULL);\n\n#ifdef MULTI_DEBUG_EVENT_LOOP\n        printf(\"POST %s[%d] to=%d lo=%d/%d w=%\" PRIi64 \"/%ld\\n\",\n               id(mi),\n               (int) (mi == m->pending),\n               mi ? mi->context.c2.to_tun.len : -1,\n               mi ? mi->context.c2.to_link.len : -1,\n               (mi && mi->context.c2.fragment) ? mi->context.c2.fragment->outgoing.len : -1,\n               (int64_t)mi->context.c2.timeval.tv_sec,\n               (long)mi->context.c2.timeval.tv_usec);\n#endif\n    }\n\n    if ((flags & MPP_RECORD_TOUCH) && m->mpp_touched)\n    {\n        *m->mpp_touched = mi;\n    }\n\n    return ret;\n}\n\nvoid\nmulti_process_float(struct multi_context *m, struct multi_instance *mi)\n{\n    struct mroute_addr real;\n    struct hash *hash = m->hash;\n    struct gc_arena gc = gc_new();\n\n    if (!mroute_extract_openvpn_sockaddr(&real, &m->top.c2.from.dest, true))\n    {\n        goto done;\n    }\n\n    const uint32_t hv = hash_value(hash, &real);\n    struct hash_bucket *bucket = hash_bucket(hash, hv);\n\n    /* make sure that we don't float to an address taken by another client */\n    struct hash_element *he = hash_lookup_fast(hash, bucket, &real, hv);\n    if (he)\n    {\n        struct multi_instance *ex_mi = (struct multi_instance *) he->value;\n\n        struct tls_multi *m1 = mi->context.c2.tls_multi;\n        struct tls_multi *m2 = ex_mi->context.c2.tls_multi;\n\n        /* do not float if target address is taken by client with another cert */\n        if (!cert_hash_compare(m1->locked_cert_hash_set, m2->locked_cert_hash_set))\n        {\n            msg(D_MULTI_LOW, \"Disallow float to an address taken by another client %s\",\n                multi_instance_string(ex_mi, false, &gc));\n\n            mi->context.c2.buf.len = 0;\n\n            goto done;\n        }\n\n        msg(D_MULTI_MEDIUM, \"closing instance %s\", multi_instance_string(ex_mi, false, &gc));\n        multi_close_instance(m, ex_mi, false);\n    }\n\n    msg(D_MULTI_MEDIUM, \"peer %\" PRIu32 \" (%s) floated from %s to %s\",\n        mi->context.c2.tls_multi->peer_id,\n        tls_common_name(mi->context.c2.tls_multi, false),\n        mroute_addr_print(&mi->real, &gc),\n        print_link_socket_actual(&m->top.c2.from, &gc));\n\n    /* remove old address from hash table before changing address */\n    ASSERT(hash_remove(m->hash, &mi->real));\n    ASSERT(hash_remove(m->iter, &mi->real));\n\n    /* change external network address of the remote peer */\n    mi->real = real;\n    generate_prefix(mi);\n\n    mi->context.c2.from = m->top.c2.from;\n    mi->context.c2.to_link_addr = &mi->context.c2.from;\n\n    /* inherit parent link_socket and link_socket_info */\n    mi->context.c2.link_socket = m->top.c2.link_socket;\n    mi->context.c2.link_socket_info->lsa->actual = m->top.c2.from;\n\n    tls_update_remote_addr(mi->context.c2.tls_multi, &mi->context.c2.from);\n\n    ASSERT(hash_add(m->hash, &mi->real, mi, false));\n    ASSERT(hash_add(m->iter, &mi->real, mi, false));\n\n#ifdef MANAGEMENT_DEF_AUTH\n    ASSERT(hash_add(m->cid_hash, &mi->context.c2.mda_context.cid, mi, true));\n#endif\n\ndone:\n    gc_free(&gc);\n}\n\n/*\n * Process packets in the TCP/UDP socket -> TUN/TAP interface direction,\n * i.e. client -> server direction.\n */\nbool\nmulti_process_incoming_link(struct multi_context *m, struct multi_instance *instance, const unsigned int mpp_flags)\n{\n    struct gc_arena gc = gc_new();\n\n    struct context *c;\n    struct mroute_addr src, dest;\n    unsigned int mroute_flags;\n    struct multi_instance *mi;\n    bool ret = true;\n    bool floated = false;\n\n    if (m->pending)\n    {\n        return true;\n    }\n\n    if (!instance)\n    {\n#ifdef MULTI_DEBUG_EVENT_LOOP\n        printf(\"TCP/UDP -> TUN [%d]\\n\", BLEN(&m->top.c2.buf));\n#endif\n        multi_set_pending(m, multi_get_create_instance_udp(m, &floated));\n    }\n    else\n    {\n        multi_set_pending(m, instance);\n    }\n\n    if (m->pending)\n    {\n        set_prefix(m->pending);\n\n        /* get instance context */\n        c = &m->pending->context;\n\n        if (!instance)\n        {\n            /* transfer packet pointer from top-level context buffer to instance */\n            c->c2.buf = m->top.c2.buf;\n\n            /* transfer from-addr from top-level context buffer to instance */\n            if (!floated)\n            {\n                c->c2.from = m->top.c2.from;\n            }\n        }\n\n        if (BLEN(&c->c2.buf) > 0)\n        {\n            struct link_socket_info *lsi;\n            const uint8_t *orig_buf;\n\n            /* decrypt in instance context */\n\n            perf_push(PERF_PROC_IN_LINK);\n            lsi = get_link_socket_info(c);\n            orig_buf = c->c2.buf.data;\n            if (process_incoming_link_part1(c, lsi, floated))\n            {\n                if (floated)\n                {\n                    multi_process_float(m, m->pending);\n                }\n\n                process_incoming_link_part2(c, lsi, orig_buf);\n            }\n            perf_pop();\n\n            if (TUNNEL_TYPE(m->top.c1.tuntap) == DEV_TYPE_TUN)\n            {\n                /* extract packet source and dest addresses */\n                mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                               &dest,\n                                                               NULL,\n                                                               NULL,\n                                                               0,\n                                                               &c->c2.to_tun,\n                                                               DEV_TYPE_TUN);\n\n                /* drop packet if extract failed */\n                if (!(mroute_flags & MROUTE_EXTRACT_SUCCEEDED))\n                {\n                    c->c2.to_tun.len = 0;\n                }\n                /* make sure that source address is associated with this client */\n                else if (multi_get_instance_by_virtual_addr(m, &src, true) != m->pending)\n                {\n                    /* IPv6 link-local address (fe80::xxx)? */\n                    if ( (src.type & MR_ADDR_MASK) == MR_ADDR_IPV6\n                         && IN6_IS_ADDR_LINKLOCAL(&src.v6.addr) )\n                    {\n                        /* do nothing, for now.  TODO: add address learning */\n                    }\n                    else\n                    {\n                        msg(D_MULTI_DROPPED, \"MULTI: bad source address from client [%s], packet dropped\",\n                            mroute_addr_print(&src, &gc));\n                    }\n                    c->c2.to_tun.len = 0;\n                }\n                /* client-to-client communication enabled? */\n                else if (m->enable_c2c)\n                {\n                    /* multicast? */\n                    if (mroute_flags & MROUTE_EXTRACT_MCAST)\n                    {\n                        /* for now, treat multicast as broadcast */\n                        multi_bcast(m, &c->c2.to_tun, m->pending, NULL, 0);\n                    }\n                    else /* possible client to client routing */\n                    {\n                        ASSERT(!(mroute_flags & MROUTE_EXTRACT_BCAST));\n                        mi = multi_get_instance_by_virtual_addr(m, &dest, true);\n\n                        /* if dest addr is a known client, route to it */\n                        if (mi)\n                        {\n#ifdef ENABLE_PF\n                            if (!pf_c2c_test(&c->c2.pf, c->c2.tls_multi,\n                                             &mi->context.c2.pf,\n                                             mi->context.c2.tls_multi,\n                                             \"tun_c2c\"))\n                            {\n                                msg(D_PF_DROPPED, \"PF: client -> client[%s] packet dropped by TUN packet filter\",\n                                    mi_prefix(mi));\n                            }\n                            else\n#endif\n                            {\n                                multi_unicast(m, &c->c2.to_tun, mi);\n                                register_activity(c, BLEN(&c->c2.to_tun));\n                            }\n                            c->c2.to_tun.len = 0;\n                        }\n                    }\n                }\n#ifdef ENABLE_PF\n                if (c->c2.to_tun.len && !pf_addr_test(&c->c2.pf, c, &dest,\n                                                      \"tun_dest_addr\"))\n                {\n                    msg(D_PF_DROPPED, \"PF: client -> addr[%s] packet dropped by TUN packet filter\",\n                        mroute_addr_print_ex(&dest, MAPF_SHOW_ARP, &gc));\n                    c->c2.to_tun.len = 0;\n                }\n#endif\n            }\n            else if (TUNNEL_TYPE(m->top.c1.tuntap) == DEV_TYPE_TAP)\n            {\n                uint16_t vid = 0;\n#ifdef ENABLE_PF\n                struct mroute_addr edest;\n                mroute_addr_reset(&edest);\n#endif\n\n                if (m->top.options.vlan_tagging)\n                {\n                    if (vlan_is_tagged(&c->c2.to_tun))\n                    {\n                        /* Drop VLAN-tagged frame. */\n                        msg(D_VLAN_DEBUG, \"dropping incoming VLAN-tagged frame\");\n                        c->c2.to_tun.len = 0;\n                    }\n                    else\n                    {\n                        vid = c->options.vlan_pvid;\n                    }\n                }\n                /* extract packet source and dest addresses */\n                mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                               &dest,\n                                                               NULL,\n#ifdef ENABLE_PF\n                                                               &edest,\n#else\n                                                               NULL,\n#endif\n                                                               vid,\n                                                               &c->c2.to_tun,\n                                                               DEV_TYPE_TAP);\n\n                if (mroute_flags & MROUTE_EXTRACT_SUCCEEDED)\n                {\n                    if (multi_learn_addr(m, m->pending, &src, 0) == m->pending)\n                    {\n                        /* check for broadcast */\n                        if (m->enable_c2c)\n                        {\n                            if (mroute_flags & (MROUTE_EXTRACT_BCAST|MROUTE_EXTRACT_MCAST))\n                            {\n                                multi_bcast(m, &c->c2.to_tun, m->pending, NULL,\n                                            vid);\n                            }\n                            else /* try client-to-client routing */\n                            {\n                                mi = multi_get_instance_by_virtual_addr(m, &dest, false);\n\n                                /* if dest addr is a known client, route to it */\n                                if (mi)\n                                {\n#ifdef ENABLE_PF\n                                    if (!pf_c2c_test(&c->c2.pf, c->c2.tls_multi,\n                                                     &mi->context.c2.pf,\n                                                     mi->context.c2.tls_multi,\n                                                     \"tap_c2c\"))\n                                    {\n                                        msg(D_PF_DROPPED, \"PF: client -> client[%s] packet dropped by TAP packet filter\",\n                                            mi_prefix(mi));\n                                    }\n                                    else\n#endif\n                                    {\n                                        multi_unicast(m, &c->c2.to_tun, mi);\n                                        register_activity(c, BLEN(&c->c2.to_tun));\n                                    }\n                                    c->c2.to_tun.len = 0;\n                                }\n                            }\n                        }\n#ifdef ENABLE_PF\n                        if (c->c2.to_tun.len && !pf_addr_test(&c->c2.pf, c,\n                                                              &edest,\n                                                              \"tap_dest_addr\"))\n                        {\n                            msg(D_PF_DROPPED, \"PF: client -> addr[%s] packet dropped by TAP packet filter\",\n                                mroute_addr_print_ex(&edest, MAPF_SHOW_ARP, &gc));\n                            c->c2.to_tun.len = 0;\n                        }\n#endif\n                    }\n                    else\n                    {\n                        msg(D_MULTI_DROPPED, \"MULTI: bad source address from client [%s], packet dropped\",\n                            mroute_addr_print(&src, &gc));\n                        c->c2.to_tun.len = 0;\n                    }\n                }\n                else\n                {\n                    c->c2.to_tun.len = 0;\n                }\n            }\n        }\n\n        /* postprocess and set wakeup */\n        ret = multi_process_post(m, m->pending, mpp_flags);\n\n        clear_prefix();\n    }\n\n    gc_free(&gc);\n    return ret;\n}\n\n/*\n * Process packets in the TUN/TAP interface -> TCP/UDP socket direction,\n * i.e. server -> client direction.\n */\nbool\nmulti_process_incoming_tun(struct multi_context *m, const unsigned int mpp_flags)\n{\n    struct gc_arena gc = gc_new();\n    bool ret = true;\n\n    if (BLEN(&m->top.c2.buf) > 0)\n    {\n        unsigned int mroute_flags;\n        struct mroute_addr src, dest;\n        const int dev_type = TUNNEL_TYPE(m->top.c1.tuntap);\n        int16_t vid = 0;\n\n#ifdef ENABLE_PF\n        struct mroute_addr esrc, *e1, *e2;\n        if (dev_type == DEV_TYPE_TUN)\n        {\n            e1 = NULL;\n            e2 = &src;\n        }\n        else\n        {\n            e1 = e2 = &esrc;\n            mroute_addr_reset(&esrc);\n        }\n#endif\n\n#ifdef MULTI_DEBUG_EVENT_LOOP\n        printf(\"TUN -> TCP/UDP [%d]\\n\", BLEN(&m->top.c2.buf));\n#endif\n\n        if (m->pending)\n        {\n            return true;\n        }\n\n        if (dev_type == DEV_TYPE_TAP && m->top.options.vlan_tagging)\n        {\n            vid = vlan_decapsulate(&m->top, &m->top.c2.buf);\n            if (vid < 0)\n            {\n                return false;\n            }\n        }\n\n        /*\n         * Route an incoming tun/tap packet to\n         * the appropriate multi_instance object.\n         */\n\n        mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                       &dest,\n#ifdef ENABLE_PF\n                                                       e1,\n#else\n                                                       NULL,\n#endif\n                                                       NULL,\n                                                       vid,\n                                                       &m->top.c2.buf,\n                                                       dev_type);\n\n        if (mroute_flags & MROUTE_EXTRACT_SUCCEEDED)\n        {\n            struct context *c;\n\n            /* broadcast or multicast dest addr? */\n            if (mroute_flags & (MROUTE_EXTRACT_BCAST|MROUTE_EXTRACT_MCAST))\n            {\n                /* for now, treat multicast as broadcast */\n#ifdef ENABLE_PF\n                multi_bcast(m, &m->top.c2.buf, NULL, e2, vid);\n#else\n                multi_bcast(m, &m->top.c2.buf, NULL, NULL, vid);\n#endif\n            }\n            else\n            {\n                multi_set_pending(m, multi_get_instance_by_virtual_addr(m, &dest, dev_type == DEV_TYPE_TUN));\n\n                if (m->pending)\n                {\n                    /* get instance context */\n                    c = &m->pending->context;\n\n                    set_prefix(m->pending);\n\n#ifdef ENABLE_PF\n                    if (!pf_addr_test(&c->c2.pf, c, e2, \"tun_tap_src_addr\"))\n                    {\n                        msg(D_PF_DROPPED, \"PF: addr[%s] -> client packet dropped by packet filter\",\n                            mroute_addr_print_ex(&src, MAPF_SHOW_ARP, &gc));\n                        buf_reset_len(&c->c2.buf);\n                    }\n                    else\n#endif\n                    {\n                        if (multi_output_queue_ready(m, m->pending))\n                        {\n                            /* transfer packet pointer from top-level context buffer to instance */\n                            c->c2.buf = m->top.c2.buf;\n                        }\n                        else\n                        {\n                            /* drop packet */\n                            msg(D_MULTI_DROPPED, \"MULTI: packet dropped due to output saturation (multi_process_incoming_tun)\");\n                            buf_reset_len(&c->c2.buf);\n                        }\n                    }\n\n                    /* encrypt in instance context */\n                    process_incoming_tun(c);\n\n                    /* postprocess and set wakeup */\n                    ret = multi_process_post(m, m->pending, mpp_flags);\n\n                    clear_prefix();\n                }\n            }\n        }\n    }\n    gc_free(&gc);\n    return ret;\n}\n\n/*\n * Process a possible client-to-client/bcast/mcast message in the\n * queue.\n */\nstruct multi_instance *\nmulti_get_queue(struct mbuf_set *ms)\n{\n    struct mbuf_item item;\n\n    if (mbuf_extract_item(ms, &item)) /* cleartext IP packet */\n    {\n        unsigned int pip_flags = PIPV4_PASSTOS | PIPV6_IMCP_NOHOST_SERVER;\n\n        set_prefix(item.instance);\n        item.instance->context.c2.buf = item.buffer->buf;\n        if (item.buffer->flags & MF_UNICAST) /* --mssfix doesn't make sense for broadcast or multicast */\n        {\n            pip_flags |= PIP_MSSFIX;\n        }\n        process_ip_header(&item.instance->context, pip_flags, &item.instance->context.c2.buf);\n        encrypt_sign(&item.instance->context, true);\n        mbuf_free_buf(item.buffer);\n\n        dmsg(D_MULTI_DEBUG, \"MULTI: C2C/MCAST/BCAST\");\n\n        clear_prefix();\n        return item.instance;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\n/*\n * Called when an I/O wait times out.  Usually means that a particular\n * client instance object needs timer-based service.\n */\nbool\nmulti_process_timeout(struct multi_context *m, const unsigned int mpp_flags)\n{\n    bool ret = true;\n\n#ifdef MULTI_DEBUG_EVENT_LOOP\n    printf(\"%s -> TIMEOUT\\n\", id(m->earliest_wakeup));\n#endif\n\n    /* instance marked for wakeup? */\n    if (m->earliest_wakeup)\n    {\n        if (m->earliest_wakeup == (struct multi_instance *)&m->deferred_shutdown_signal)\n        {\n            schedule_remove_entry(m->schedule, (struct schedule_entry *) &m->deferred_shutdown_signal);\n            throw_signal(m->deferred_shutdown_signal.signal_received);\n        }\n        else\n        {\n            set_prefix(m->earliest_wakeup);\n            ret = multi_process_post(m, m->earliest_wakeup, mpp_flags);\n            clear_prefix();\n        }\n        m->earliest_wakeup = NULL;\n    }\n    return ret;\n}\n\n/*\n * Drop a TUN/TAP outgoing packet..\n */\nvoid\nmulti_process_drop_outgoing_tun(struct multi_context *m, const unsigned int mpp_flags)\n{\n    struct multi_instance *mi = m->pending;\n\n    ASSERT(mi);\n\n    set_prefix(mi);\n\n    msg(D_MULTI_ERRORS, \"MULTI: Outgoing TUN queue full, dropped packet len=%d\",\n        mi->context.c2.to_tun.len);\n\n    buf_reset(&mi->context.c2.to_tun);\n\n    multi_process_post(m, mi, mpp_flags);\n    clear_prefix();\n}\n\n/*\n * Per-client route quota management\n */\n\nvoid\nroute_quota_exceeded(const struct multi_instance *mi)\n{\n    struct gc_arena gc = gc_new();\n    msg(D_ROUTE_QUOTA, \"MULTI ROUTE: route quota (%d) exceeded for %s (see --max-routes-per-client option)\",\n        mi->context.options.max_routes_per_client,\n        multi_instance_string(mi, false, &gc));\n    gc_free(&gc);\n}\n\n#ifdef ENABLE_DEBUG\n/*\n * Flood clients with random packets\n */\nstatic void\ngremlin_flood_clients(struct multi_context *m)\n{\n    const int level = GREMLIN_PACKET_FLOOD_LEVEL(m->top.options.gremlin);\n    if (level)\n    {\n        struct gc_arena gc = gc_new();\n        struct buffer buf = alloc_buf_gc(BUF_SIZE(&m->top.c2.frame), &gc);\n        struct packet_flood_parms parm = get_packet_flood_parms(level);\n        int i;\n\n        ASSERT(buf_init(&buf, FRAME_HEADROOM(&m->top.c2.frame)));\n        parm.packet_size = min_int(parm.packet_size, MAX_RW_SIZE_TUN(&m->top.c2.frame));\n\n        msg(D_GREMLIN, \"GREMLIN_FLOOD_CLIENTS: flooding clients with %d packets of size %d\",\n            parm.n_packets,\n            parm.packet_size);\n\n        for (i = 0; i < parm.packet_size; ++i)\n        {\n            ASSERT(buf_write_u8(&buf, get_random() & 0xFF));\n        }\n\n        for (i = 0; i < parm.n_packets; ++i)\n        {\n            multi_bcast(m, &buf, NULL, NULL, 0);\n        }\n\n        gc_free(&gc);\n    }\n}\n#endif /* ifdef ENABLE_DEBUG */\n\nstatic bool\nstale_route_check_trigger(struct multi_context *m)\n{\n    struct timeval null;\n    CLEAR(null);\n    return event_timeout_trigger(&m->stale_routes_check_et, &null, ETT_DEFAULT);\n}\n\n/*\n * Process timers in the top-level context\n */\nvoid\nmulti_process_per_second_timers_dowork(struct multi_context *m)\n{\n    /* possibly reap instances/routes in vhash */\n    multi_reap_process(m);\n\n    /* possibly print to status log */\n    if (m->top.c1.status_output)\n    {\n        if (status_trigger(m->top.c1.status_output))\n        {\n            multi_print_status(m, m->top.c1.status_output, m->status_file_version);\n        }\n    }\n\n    /* possibly flush ifconfig-pool file */\n    multi_ifconfig_pool_persist(m, false);\n\n#ifdef ENABLE_DEBUG\n    gremlin_flood_clients(m);\n#endif\n\n    /* Should we check for stale routes? */\n    if (m->top.options.stale_routes_check_interval && stale_route_check_trigger(m))\n    {\n        check_stale_routes(m);\n    }\n}\n\nvoid\nmulti_top_init(struct multi_context *m, const struct context *top)\n{\n    inherit_context_top(&m->top, top);\n    m->top.c2.buffers = init_context_buffers(&top->c2.frame);\n}\n\nvoid\nmulti_top_free(struct multi_context *m)\n{\n    close_context(&m->top, -1, CC_GC_FREE);\n    free_context_buffers(m->top.c2.buffers);\n}\n\nstatic bool\nis_exit_restart(int sig)\n{\n    return (sig == SIGUSR1 || sig == SIGTERM || sig == SIGHUP || sig == SIGINT);\n}\n\nstatic void\nmulti_push_restart_schedule_exit(struct multi_context *m, bool next_server)\n{\n    struct hash_iterator hi;\n    struct hash_element *he;\n    struct timeval tv;\n\n    /* tell all clients to restart */\n    hash_iterator_init(m->iter, &hi);\n    while ((he = hash_iterator_next(&hi)))\n    {\n        struct multi_instance *mi = (struct multi_instance *) he->value;\n        if (!mi->halt)\n        {\n            send_control_channel_string(&mi->context, next_server ? \"RESTART,[N]\" : \"RESTART\", D_PUSH);\n            multi_schedule_context_wakeup(m, mi);\n        }\n    }\n    hash_iterator_free(&hi);\n\n    /* reschedule signal */\n    ASSERT(!openvpn_gettimeofday(&m->deferred_shutdown_signal.wakeup, NULL));\n    tv.tv_sec = 2;\n    tv.tv_usec = 0;\n    tv_add(&m->deferred_shutdown_signal.wakeup, &tv);\n\n    m->deferred_shutdown_signal.signal_received = m->top.sig->signal_received;\n\n    schedule_add_entry(m->schedule,\n                       (struct schedule_entry *) &m->deferred_shutdown_signal,\n                       &m->deferred_shutdown_signal.wakeup,\n                       compute_wakeup_sigma(&m->deferred_shutdown_signal.wakeup));\n\n    m->top.sig->signal_received = 0;\n}\n\n/*\n * Return true if event loop should break,\n * false if it should continue.\n */\nbool\nmulti_process_signal(struct multi_context *m)\n{\n    if (m->top.sig->signal_received == SIGUSR2)\n    {\n        struct status_output *so = status_open(NULL, 0, M_INFO, NULL, 0);\n        multi_print_status(m, so, m->status_file_version);\n        status_close(so);\n        m->top.sig->signal_received = 0;\n        return false;\n    }\n    else if (proto_is_dgram(m->top.options.ce.proto)\n             && is_exit_restart(m->top.sig->signal_received)\n             && (m->deferred_shutdown_signal.signal_received == 0)\n             && m->top.options.ce.explicit_exit_notification != 0)\n    {\n        multi_push_restart_schedule_exit(m, m->top.options.ce.explicit_exit_notification == 2);\n        return false;\n    }\n    return true;\n}\n\n/*\n * Called when an instance should be closed due to the\n * reception of a soft signal.\n */\nvoid\nmulti_close_instance_on_signal(struct multi_context *m, struct multi_instance *mi)\n{\n    remap_signal(&mi->context);\n    set_prefix(mi);\n    print_signal(mi->context.sig, \"client-instance\", D_MULTI_LOW);\n    clear_prefix();\n    multi_close_instance(m, mi, false);\n}\n\nstatic void\nmulti_signal_instance(struct multi_context *m, struct multi_instance *mi, const int sig)\n{\n    mi->context.sig->signal_received = sig;\n    multi_close_instance_on_signal(m, mi);\n}\n\n/*\n * Management subsystem callbacks\n */\n\n#ifdef ENABLE_MANAGEMENT\n\nstatic void\nmanagement_callback_status(void *arg, const int version, struct status_output *so)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n\n    if (!version)\n    {\n        multi_print_status(m, so, m->status_file_version);\n    }\n    else\n    {\n        multi_print_status(m, so, version);\n    }\n}\n\nstatic int\nmanagement_callback_n_clients(void *arg)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    return m->n_clients;\n}\n\nstatic int\nmanagement_callback_kill_by_cn(void *arg, const char *del_cn)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct hash_iterator hi;\n    struct hash_element *he;\n    int count = 0;\n\n    hash_iterator_init(m->iter, &hi);\n    while ((he = hash_iterator_next(&hi)))\n    {\n        struct multi_instance *mi = (struct multi_instance *) he->value;\n        if (!mi->halt)\n        {\n            const char *cn = tls_common_name(mi->context.c2.tls_multi, false);\n            if (cn && !strcmp(cn, del_cn))\n            {\n                multi_signal_instance(m, mi, SIGTERM);\n                ++count;\n            }\n        }\n    }\n    hash_iterator_free(&hi);\n    return count;\n}\n\nstatic int\nmanagement_callback_kill_by_addr(void *arg, const in_addr_t addr, const int port)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct hash_iterator hi;\n    struct hash_element *he;\n    struct openvpn_sockaddr saddr;\n    struct mroute_addr maddr;\n    int count = 0;\n\n    CLEAR(saddr);\n    saddr.addr.in4.sin_family = AF_INET;\n    saddr.addr.in4.sin_addr.s_addr = htonl(addr);\n    saddr.addr.in4.sin_port = htons(port);\n    if (mroute_extract_openvpn_sockaddr(&maddr, &saddr, true))\n    {\n        hash_iterator_init(m->iter, &hi);\n        while ((he = hash_iterator_next(&hi)))\n        {\n            struct multi_instance *mi = (struct multi_instance *) he->value;\n            if (!mi->halt && mroute_addr_equal(&maddr, &mi->real))\n            {\n                multi_signal_instance(m, mi, SIGTERM);\n                ++count;\n            }\n        }\n        hash_iterator_free(&hi);\n    }\n    return count;\n}\n\nstatic void\nmanagement_delete_event(void *arg, event_t event)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    if (m->mtcp)\n    {\n        multi_tcp_delete_event(m->mtcp, event);\n    }\n}\n\n#endif /* ifdef ENABLE_MANAGEMENT */\n\n#ifdef MANAGEMENT_DEF_AUTH\n\nstatic struct multi_instance *\nlookup_by_cid(struct multi_context *m, const unsigned long cid)\n{\n    if (m)\n    {\n        struct multi_instance *mi = (struct multi_instance *) hash_lookup(m->cid_hash, &cid);\n        if (mi && !mi->halt)\n        {\n            return mi;\n        }\n    }\n    return NULL;\n}\n\nstatic bool\nmanagement_kill_by_cid(void *arg, const unsigned long cid, const char *kill_msg)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct multi_instance *mi = lookup_by_cid(m, cid);\n    if (mi)\n    {\n        send_restart(&mi->context, kill_msg); /* was: multi_signal_instance (m, mi, SIGTERM); */\n        multi_schedule_context_wakeup(m, mi);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nstatic bool\nmanagement_client_auth(void *arg,\n                       const unsigned long cid,\n                       const unsigned int mda_key_id,\n                       const bool auth,\n                       const char *reason,\n                       const char *client_reason,\n                       struct buffer_list *cc_config)  /* ownership transferred */\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct multi_instance *mi = lookup_by_cid(m, cid);\n    bool cc_config_owned = true;\n    bool ret = false;\n\n    if (mi)\n    {\n        ret = tls_authenticate_key(mi->context.c2.tls_multi, mda_key_id, auth, client_reason);\n        if (ret)\n        {\n            if (auth)\n            {\n                if (!mi->connection_established_flag)\n                {\n                    set_cc_config(mi, cc_config);\n                    cc_config_owned = false;\n                }\n            }\n            else\n            {\n                if (reason)\n                {\n                    msg(D_MULTI_LOW, \"MULTI: connection rejected: %s, CLI:%s\", reason, np(client_reason));\n                }\n                if (mi->connection_established_flag)\n                {\n                    send_auth_failed(&mi->context, client_reason); /* mid-session reauth failed */\n                    multi_schedule_context_wakeup(m, mi);\n                }\n            }\n        }\n    }\n    if (cc_config_owned && cc_config)\n    {\n        buffer_list_free(cc_config);\n    }\n    return ret;\n}\n\nstatic char *\nmanagement_get_peer_info(void *arg, const unsigned long cid)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct multi_instance *mi = lookup_by_cid(m, cid);\n    char *ret = NULL;\n\n    if (mi)\n    {\n        ret = tls_get_peer_info(mi->context.c2.tls_multi);\n    }\n\n    return ret;\n}\n\n#endif /* ifdef MANAGEMENT_DEF_AUTH */\n\n#ifdef MANAGEMENT_PF\nstatic bool\nmanagement_client_pf(void *arg,\n                     const unsigned long cid,\n                     struct buffer_list *pf_config)  /* ownership transferred */\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct multi_instance *mi = lookup_by_cid(m, cid);\n    bool ret = false;\n\n    if (mi && pf_config)\n    {\n        ret = pf_load_from_buffer_list(&mi->context, pf_config);\n    }\n\n    if (pf_config)\n    {\n        buffer_list_free(pf_config);\n    }\n    return ret;\n}\n#endif /* ifdef MANAGEMENT_PF */\n\nvoid\ninit_management_callback_multi(struct multi_context *m)\n{\n#ifdef ENABLE_MANAGEMENT\n    if (management)\n    {\n        struct management_callback cb;\n        CLEAR(cb);\n        cb.arg = m;\n        cb.flags = MCF_SERVER;\n        cb.status = management_callback_status;\n        cb.show_net = management_show_net_callback;\n        cb.kill_by_cn = management_callback_kill_by_cn;\n        cb.kill_by_addr = management_callback_kill_by_addr;\n        cb.delete_event = management_delete_event;\n        cb.n_clients = management_callback_n_clients;\n#ifdef MANAGEMENT_DEF_AUTH\n        cb.kill_by_cid = management_kill_by_cid;\n        cb.client_auth = management_client_auth;\n        cb.get_peer_info = management_get_peer_info;\n#endif\n#ifdef MANAGEMENT_PF\n        cb.client_pf = management_client_pf;\n#endif\n        management_set_callback(management, &cb);\n    }\n#endif /* ifdef ENABLE_MANAGEMENT */\n}\n\n/*\n * Top level event loop.\n */\nvoid\ntunnel_server(struct context *top)\n{\n    ASSERT(top->options.mode == MODE_SERVER);\n\n    if (proto_is_dgram(top->options.ce.proto))\n    {\n        tunnel_server_udp(top);\n    }\n    else\n    {\n        tunnel_server_tcp(top);\n    }\n}\n\n#else  /* if P2MP_SERVER */\nstatic void\ndummy(void)\n{\n}\n#endif /* P2MP_SERVER */\n"], "fixing_code": ["/*\n *  OpenVPN -- An application to securely tunnel IP networks\n *             over a single TCP/UDP port, with support for SSL/TLS-based\n *             session authentication and key exchange,\n *             packet encryption, packet authentication, and\n *             packet compression.\n *\n *  Copyright (C) 2002-2018 OpenVPN Inc <sales@openvpn.net>\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2\n *  as published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License along\n *  with this program; if not, write to the Free Software Foundation, Inc.,\n *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#elif defined(_MSC_VER)\n#include \"config-msvc.h\"\n#endif\n\n#ifdef HAVE_SYS_INOTIFY_H\n#include <sys/inotify.h>\n#define INOTIFY_EVENT_BUFFER_SIZE 16384\n#endif\n\n#include \"syshead.h\"\n\n#if P2MP_SERVER\n\n#include \"forward.h\"\n#include \"multi.h\"\n#include \"push.h\"\n#include \"run_command.h\"\n#include \"otime.h\"\n#include \"pf.h\"\n#include \"gremlin.h\"\n#include \"mstats.h\"\n#include \"ssl_verify.h\"\n#include \"ssl_ncp.h\"\n#include \"vlan.h\"\n#include <inttypes.h>\n\n#include \"memdbg.h\"\n\n\n#include \"crypto_backend.h\"\n\n/*#define MULTI_DEBUG_EVENT_LOOP*/\n\n#ifdef MULTI_DEBUG_EVENT_LOOP\nstatic const char *\nid(struct multi_instance *mi)\n{\n    if (mi)\n    {\n        return tls_common_name(mi->context.c2.tls_multi, false);\n    }\n    else\n    {\n        return \"NULL\";\n    }\n}\n#endif\n\n#ifdef MANAGEMENT_DEF_AUTH\nstatic void\nset_cc_config(struct multi_instance *mi, struct buffer_list *cc_config)\n{\n    if (mi->cc_config)\n    {\n        buffer_list_free(mi->cc_config);\n    }\n    mi->cc_config = cc_config;\n}\n#endif\n\nstatic inline void\nupdate_mstat_n_clients(const int n_clients)\n{\n#ifdef ENABLE_MEMSTATS\n    if (mmap_stats)\n    {\n        mmap_stats->n_clients = n_clients;\n    }\n#endif\n}\n\nstatic bool\nlearn_address_script(const struct multi_context *m,\n                     const struct multi_instance *mi,\n                     const char *op,\n                     const struct mroute_addr *addr)\n{\n    struct gc_arena gc = gc_new();\n    struct env_set *es;\n    bool ret = true;\n    struct plugin_list *plugins;\n\n    /* get environmental variable source */\n    if (mi && mi->context.c2.es)\n    {\n        es = mi->context.c2.es;\n    }\n    else\n    {\n        es = env_set_create(&gc);\n    }\n\n    /* get plugin source */\n    if (mi)\n    {\n        plugins = mi->context.plugins;\n    }\n    else\n    {\n        plugins = m->top.plugins;\n    }\n\n    if (plugin_defined(plugins, OPENVPN_PLUGIN_LEARN_ADDRESS))\n    {\n        struct argv argv = argv_new();\n        argv_printf(&argv, \"%s %s\",\n                    op,\n                    mroute_addr_print(addr, &gc));\n        if (mi)\n        {\n            argv_printf_cat(&argv, \"%s\", tls_common_name(mi->context.c2.tls_multi, false));\n        }\n        if (plugin_call(plugins, OPENVPN_PLUGIN_LEARN_ADDRESS, &argv, NULL, es) != OPENVPN_PLUGIN_FUNC_SUCCESS)\n        {\n            msg(M_WARN, \"WARNING: learn-address plugin call failed\");\n            ret = false;\n        }\n        argv_free(&argv);\n    }\n\n    if (m->top.options.learn_address_script)\n    {\n        struct argv argv = argv_new();\n        setenv_str(es, \"script_type\", \"learn-address\");\n        argv_parse_cmd(&argv, m->top.options.learn_address_script);\n        argv_printf_cat(&argv, \"%s %s\", op, mroute_addr_print(addr, &gc));\n        if (mi)\n        {\n            argv_printf_cat(&argv, \"%s\", tls_common_name(mi->context.c2.tls_multi, false));\n        }\n        if (!openvpn_run_script(&argv, es, 0, \"--learn-address\"))\n        {\n            ret = false;\n        }\n        argv_free(&argv);\n    }\n\n    gc_free(&gc);\n    return ret;\n}\n\nvoid\nmulti_ifconfig_pool_persist(struct multi_context *m, bool force)\n{\n    /* write pool data to file */\n    if (m->ifconfig_pool\n        && m->top.c1.ifconfig_pool_persist\n        && (force || ifconfig_pool_write_trigger(m->top.c1.ifconfig_pool_persist)))\n    {\n        ifconfig_pool_write(m->top.c1.ifconfig_pool_persist, m->ifconfig_pool);\n    }\n}\n\nstatic void\nmulti_reap_range(const struct multi_context *m,\n                 int start_bucket,\n                 int end_bucket)\n{\n    struct gc_arena gc = gc_new();\n    struct hash_iterator hi;\n    struct hash_element *he;\n\n    if (start_bucket < 0)\n    {\n        start_bucket = 0;\n        end_bucket = hash_n_buckets(m->vhash);\n    }\n\n    dmsg(D_MULTI_DEBUG, \"MULTI: REAP range %d -> %d\", start_bucket, end_bucket);\n    hash_iterator_init_range(m->vhash, &hi, start_bucket, end_bucket);\n    while ((he = hash_iterator_next(&hi)) != NULL)\n    {\n        struct multi_route *r = (struct multi_route *) he->value;\n        if (!multi_route_defined(m, r))\n        {\n            dmsg(D_MULTI_DEBUG, \"MULTI: REAP DEL %s\",\n                 mroute_addr_print(&r->addr, &gc));\n            learn_address_script(m, NULL, \"delete\", &r->addr);\n            multi_route_del(r);\n            hash_iterator_delete_element(&hi);\n        }\n    }\n    hash_iterator_free(&hi);\n    gc_free(&gc);\n}\n\nstatic void\nmulti_reap_all(const struct multi_context *m)\n{\n    multi_reap_range(m, -1, 0);\n}\n\nstatic struct multi_reap *\nmulti_reap_new(int buckets_per_pass)\n{\n    struct multi_reap *mr;\n    ALLOC_OBJ(mr, struct multi_reap);\n    mr->bucket_base = 0;\n    mr->buckets_per_pass = buckets_per_pass;\n    mr->last_call = now;\n    return mr;\n}\n\nvoid\nmulti_reap_process_dowork(const struct multi_context *m)\n{\n    struct multi_reap *mr = m->reaper;\n    if (mr->bucket_base >= hash_n_buckets(m->vhash))\n    {\n        mr->bucket_base = 0;\n    }\n    multi_reap_range(m, mr->bucket_base, mr->bucket_base + mr->buckets_per_pass);\n    mr->bucket_base += mr->buckets_per_pass;\n    mr->last_call = now;\n}\n\nstatic void\nmulti_reap_free(struct multi_reap *mr)\n{\n    free(mr);\n}\n\n/*\n * How many buckets in vhash to reap per pass.\n */\nstatic int\nreap_buckets_per_pass(int n_buckets)\n{\n    return constrain_int(n_buckets / REAP_DIVISOR, REAP_MIN, REAP_MAX);\n}\n\n#ifdef MANAGEMENT_DEF_AUTH\n\nstatic uint32_t\ncid_hash_function(const void *key, uint32_t iv)\n{\n    const unsigned long *k = (const unsigned long *)key;\n    return (uint32_t) *k;\n}\n\nstatic bool\ncid_compare_function(const void *key1, const void *key2)\n{\n    const unsigned long *k1 = (const unsigned long *)key1;\n    const unsigned long *k2 = (const unsigned long *)key2;\n    return *k1 == *k2;\n}\n\n#endif\n\n#ifdef ENABLE_ASYNC_PUSH\nstatic uint32_t\n/*\n * inotify watcher descriptors are used as hash value\n */\nint_hash_function(const void *key, uint32_t iv)\n{\n    return (unsigned long)key;\n}\n\nstatic bool\nint_compare_function(const void *key1, const void *key2)\n{\n    return (unsigned long)key1 == (unsigned long)key2;\n}\n#endif\n\n/*\n * Main initialization function, init multi_context object.\n */\nvoid\nmulti_init(struct multi_context *m, struct context *t, bool tcp_mode, int thread_mode)\n{\n    int dev = DEV_TYPE_UNDEF;\n\n    msg(D_MULTI_LOW, \"MULTI: multi_init called, r=%d v=%d\",\n        t->options.real_hash_size,\n        t->options.virtual_hash_size);\n\n    /*\n     * Get tun/tap/null device type\n     */\n    dev = dev_type_enum(t->options.dev, t->options.dev_type);\n\n    /*\n     * Init our multi_context object.\n     */\n    CLEAR(*m);\n\n    m->thread_mode = thread_mode;\n\n    /*\n     * Real address hash table (source port number is\n     * considered to be part of the address).  Used\n     * to determine which client sent an incoming packet\n     * which is seen on the TCP/UDP socket.\n     */\n    m->hash = hash_init(t->options.real_hash_size,\n                        get_random(),\n                        mroute_addr_hash_function,\n                        mroute_addr_compare_function);\n\n    /*\n     * Virtual address hash table.  Used to determine\n     * which client to route a packet to.\n     */\n    m->vhash = hash_init(t->options.virtual_hash_size,\n                         get_random(),\n                         mroute_addr_hash_function,\n                         mroute_addr_compare_function);\n\n    /*\n     * This hash table is a clone of m->hash but with a\n     * bucket size of one so that it can be used\n     * for fast iteration through the list.\n     */\n    m->iter = hash_init(1,\n                        get_random(),\n                        mroute_addr_hash_function,\n                        mroute_addr_compare_function);\n\n#ifdef MANAGEMENT_DEF_AUTH\n    m->cid_hash = hash_init(t->options.real_hash_size,\n                            0,\n                            cid_hash_function,\n                            cid_compare_function);\n#endif\n\n#ifdef ENABLE_ASYNC_PUSH\n    /*\n     * Mapping between inotify watch descriptors and\n     * multi_instances.\n     */\n    m->inotify_watchers = hash_init(t->options.real_hash_size,\n                                    get_random(),\n                                    int_hash_function,\n                                    int_compare_function);\n#endif\n\n    /*\n     * This is our scheduler, for time-based wakeup\n     * events.\n     */\n    m->schedule = schedule_init();\n\n    /*\n     * Limit frequency of incoming connections to control\n     * DoS.\n     */\n    m->new_connection_limiter = frequency_limit_init(t->options.cf_max,\n                                                     t->options.cf_per);\n\n    /*\n     * Allocate broadcast/multicast buffer list\n     */\n    m->mbuf = mbuf_init(t->options.n_bcast_buf);\n\n    /*\n     * Different status file format options are available\n     */\n    m->status_file_version = t->options.status_file_version;\n\n    /*\n     * Possibly allocate an ifconfig pool, do it\n     * differently based on whether a tun or tap style\n     * tunnel.\n     */\n    if (t->options.ifconfig_pool_defined)\n    {\n        int pool_type = IFCONFIG_POOL_INDIV;\n\n        if (dev == DEV_TYPE_TUN && t->options.topology == TOP_NET30)\n        {\n            pool_type = IFCONFIG_POOL_30NET;\n        }\n\n        m->ifconfig_pool = ifconfig_pool_init(pool_type,\n                                              t->options.ifconfig_pool_start,\n                                              t->options.ifconfig_pool_end,\n                                              t->options.duplicate_cn,\n                                              t->options.ifconfig_ipv6_pool_defined,\n                                              t->options.ifconfig_ipv6_pool_base,\n                                              t->options.ifconfig_ipv6_pool_netbits );\n\n        /* reload pool data from file */\n        if (t->c1.ifconfig_pool_persist)\n        {\n            ifconfig_pool_read(t->c1.ifconfig_pool_persist, m->ifconfig_pool);\n        }\n    }\n\n    /*\n     * Help us keep track of routing table.\n     */\n    m->route_helper = mroute_helper_init(MULTI_CACHE_ROUTE_TTL);\n\n    /*\n     * Initialize route and instance reaper.\n     */\n    m->reaper = multi_reap_new(reap_buckets_per_pass(t->options.virtual_hash_size));\n\n    /*\n     * Get local ifconfig address\n     */\n    CLEAR(m->local);\n    ASSERT(t->c1.tuntap);\n    mroute_extract_in_addr_t(&m->local, t->c1.tuntap->local);\n\n    /*\n     * Per-client limits\n     */\n    m->max_clients = t->options.max_clients;\n\n    m->instances = calloc(m->max_clients, sizeof(struct multi_instance *));\n\n    /*\n     * Initialize multi-socket TCP I/O wait object\n     */\n    if (tcp_mode)\n    {\n        m->mtcp = multi_tcp_init(t->options.max_clients, &m->max_clients);\n    }\n    m->tcp_queue_limit = t->options.tcp_queue_limit;\n\n    /*\n     * Allow client <-> client communication, without going through\n     * tun/tap interface and network stack?\n     */\n    m->enable_c2c = t->options.enable_c2c;\n\n    /* initialize stale routes check timer */\n    if (t->options.stale_routes_check_interval > 0)\n    {\n        msg(M_INFO, \"Initializing stale route check timer to run every %i seconds and to removing routes with activity timeout older than %i seconds\",\n            t->options.stale_routes_check_interval, t->options.stale_routes_ageing_time);\n        event_timeout_init(&m->stale_routes_check_et, t->options.stale_routes_check_interval, 0);\n    }\n\n    m->deferred_shutdown_signal.signal_received = 0;\n}\n\nconst char *\nmulti_instance_string(const struct multi_instance *mi, bool null, struct gc_arena *gc)\n{\n    if (mi)\n    {\n        struct buffer out = alloc_buf_gc(MULTI_PREFIX_MAX_LENGTH, gc);\n        const char *cn = tls_common_name(mi->context.c2.tls_multi, true);\n\n        if (cn)\n        {\n            buf_printf(&out, \"%s/\", cn);\n        }\n        buf_printf(&out, \"%s\", mroute_addr_print(&mi->real, gc));\n        return BSTR(&out);\n    }\n    else if (null)\n    {\n        return NULL;\n    }\n    else\n    {\n        return \"UNDEF\";\n    }\n}\n\nstatic void\ngenerate_prefix(struct multi_instance *mi)\n{\n    struct gc_arena gc = gc_new();\n    const char *prefix = multi_instance_string(mi, true, &gc);\n    if (prefix)\n    {\n        strncpynt(mi->msg_prefix, prefix, sizeof(mi->msg_prefix));\n    }\n    else\n    {\n        mi->msg_prefix[0] = '\\0';\n    }\n    set_prefix(mi);\n    gc_free(&gc);\n}\n\nvoid\nungenerate_prefix(struct multi_instance *mi)\n{\n    mi->msg_prefix[0] = '\\0';\n    set_prefix(mi);\n}\n\nstatic const char *\nmi_prefix(const struct multi_instance *mi)\n{\n    if (mi && mi->msg_prefix[0])\n    {\n        return mi->msg_prefix;\n    }\n    else\n    {\n        return \"UNDEF_I\";\n    }\n}\n\n/*\n * Tell the route helper about deleted iroutes so\n * that it can update its mask of currently used\n * CIDR netlengths.\n */\nstatic void\nmulti_del_iroutes(struct multi_context *m,\n                  struct multi_instance *mi)\n{\n    const struct iroute *ir;\n    const struct iroute_ipv6 *ir6;\n    if (TUNNEL_TYPE(mi->context.c1.tuntap) == DEV_TYPE_TUN)\n    {\n        for (ir = mi->context.options.iroutes; ir != NULL; ir = ir->next)\n        {\n            mroute_helper_del_iroute46(m->route_helper, ir->netbits);\n        }\n\n        for (ir6 = mi->context.options.iroutes_ipv6; ir6 != NULL; ir6 = ir6->next)\n        {\n            mroute_helper_del_iroute46(m->route_helper, ir6->netbits);\n        }\n    }\n}\n\nstatic void\nsetenv_stats(struct context *c)\n{\n    setenv_counter(c->c2.es, \"bytes_received\", c->c2.link_read_bytes);\n    setenv_counter(c->c2.es, \"bytes_sent\", c->c2.link_write_bytes);\n}\n\nstatic void\nmulti_client_disconnect_setenv(struct multi_instance *mi)\n{\n    /* setenv client real IP address */\n    setenv_trusted(mi->context.c2.es, get_link_socket_info(&mi->context));\n\n    /* setenv stats */\n    setenv_stats(&mi->context);\n\n    /* setenv connection duration */\n    setenv_long_long(mi->context.c2.es, \"time_duration\", now - mi->created);\n}\n\nstatic void\nmulti_client_disconnect_script(struct multi_instance *mi)\n{\n    if ((mi->context.c2.context_auth == CAS_SUCCEEDED && mi->connection_established_flag)\n        || mi->context.c2.context_auth == CAS_PARTIAL)\n    {\n        multi_client_disconnect_setenv(mi);\n\n        if (plugin_defined(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_DISCONNECT))\n        {\n            if (plugin_call(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_DISCONNECT, NULL, NULL, mi->context.c2.es) != OPENVPN_PLUGIN_FUNC_SUCCESS)\n            {\n                msg(M_WARN, \"WARNING: client-disconnect plugin call failed\");\n            }\n        }\n\n        if (mi->context.options.client_disconnect_script)\n        {\n            struct argv argv = argv_new();\n            setenv_str(mi->context.c2.es, \"script_type\", \"client-disconnect\");\n            argv_parse_cmd(&argv, mi->context.options.client_disconnect_script);\n            openvpn_run_script(&argv, mi->context.c2.es, 0, \"--client-disconnect\");\n            argv_free(&argv);\n        }\n#ifdef MANAGEMENT_DEF_AUTH\n        if (management)\n        {\n            management_notify_client_close(management, &mi->context.c2.mda_context, mi->context.c2.es);\n        }\n#endif\n\n    }\n}\n\nvoid\nmulti_close_instance(struct multi_context *m,\n                     struct multi_instance *mi,\n                     bool shutdown)\n{\n    perf_push(PERF_MULTI_CLOSE_INSTANCE);\n\n    ASSERT(!mi->halt);\n    mi->halt = true;\n\n    dmsg(D_MULTI_DEBUG, \"MULTI: multi_close_instance called\");\n\n    /* adjust current client connection count */\n    m->n_clients += mi->n_clients_delta;\n    update_mstat_n_clients(m->n_clients);\n    mi->n_clients_delta = 0;\n\n    /* prevent dangling pointers */\n    if (m->pending == mi)\n    {\n        multi_set_pending(m, NULL);\n    }\n    if (m->earliest_wakeup == mi)\n    {\n        m->earliest_wakeup = NULL;\n    }\n\n    if (!shutdown)\n    {\n        if (mi->did_real_hash)\n        {\n            ASSERT(hash_remove(m->hash, &mi->real));\n        }\n        if (mi->did_iter)\n        {\n            ASSERT(hash_remove(m->iter, &mi->real));\n        }\n#ifdef MANAGEMENT_DEF_AUTH\n        if (mi->did_cid_hash)\n        {\n            ASSERT(hash_remove(m->cid_hash, &mi->context.c2.mda_context.cid));\n        }\n#endif\n\n#ifdef ENABLE_ASYNC_PUSH\n        if (mi->inotify_watch != -1)\n        {\n            hash_remove(m->inotify_watchers, (void *) (unsigned long)mi->inotify_watch);\n            mi->inotify_watch = -1;\n        }\n#endif\n\n        if (mi->context.c2.tls_multi->peer_id != MAX_PEER_ID)\n        {\n            m->instances[mi->context.c2.tls_multi->peer_id] = NULL;\n        }\n\n        schedule_remove_entry(m->schedule, (struct schedule_entry *) mi);\n\n        ifconfig_pool_release(m->ifconfig_pool, mi->vaddr_handle, false);\n\n        if (mi->did_iroutes)\n        {\n            multi_del_iroutes(m, mi);\n            mi->did_iroutes = false;\n        }\n\n        if (m->mtcp)\n        {\n            multi_tcp_dereference_instance(m->mtcp, mi);\n        }\n\n        mbuf_dereference_instance(m->mbuf, mi);\n    }\n\n#ifdef MANAGEMENT_DEF_AUTH\n    set_cc_config(mi, NULL);\n#endif\n\n    multi_client_disconnect_script(mi);\n\n    if (mi->did_open_context)\n    {\n        close_context(&mi->context, SIGTERM, CC_GC_FREE);\n    }\n\n    multi_tcp_instance_specific_free(mi);\n\n    ungenerate_prefix(mi);\n\n    /*\n     * Don't actually delete the instance memory allocation yet,\n     * because virtual routes may still point to it.  Let the\n     * vhash reaper deal with it.\n     */\n    multi_instance_dec_refcount(mi);\n\n    perf_pop();\n}\n\n/*\n * Called on shutdown or restart.\n */\nvoid\nmulti_uninit(struct multi_context *m)\n{\n    if (m->thread_mode & MC_WORK_THREAD)\n    {\n        multi_top_free(m);\n        m->thread_mode = MC_UNDEF;\n    }\n    else if (m->thread_mode)\n    {\n        if (m->hash)\n        {\n            struct hash_iterator hi;\n            struct hash_element *he;\n\n            hash_iterator_init(m->iter, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct multi_instance *mi = (struct multi_instance *) he->value;\n                mi->did_iter = false;\n                multi_close_instance(m, mi, true);\n            }\n            hash_iterator_free(&hi);\n\n            multi_reap_all(m);\n\n            hash_free(m->hash);\n            hash_free(m->vhash);\n            hash_free(m->iter);\n#ifdef MANAGEMENT_DEF_AUTH\n            hash_free(m->cid_hash);\n#endif\n            m->hash = NULL;\n\n            free(m->instances);\n\n#ifdef ENABLE_ASYNC_PUSH\n            hash_free(m->inotify_watchers);\n            m->inotify_watchers = NULL;\n#endif\n\n            schedule_free(m->schedule);\n            mbuf_free(m->mbuf);\n            ifconfig_pool_free(m->ifconfig_pool);\n            frequency_limit_free(m->new_connection_limiter);\n            multi_reap_free(m->reaper);\n            mroute_helper_free(m->route_helper);\n            multi_tcp_free(m->mtcp);\n            m->thread_mode = MC_UNDEF;\n        }\n    }\n}\n\n/*\n * Create a client instance object for a newly connected client.\n */\nstruct multi_instance *\nmulti_create_instance(struct multi_context *m, const struct mroute_addr *real)\n{\n    struct gc_arena gc = gc_new();\n    struct multi_instance *mi;\n\n    perf_push(PERF_MULTI_CREATE_INSTANCE);\n\n    msg(D_MULTI_MEDIUM, \"MULTI: multi_create_instance called\");\n\n    ALLOC_OBJ_CLEAR(mi, struct multi_instance);\n\n    mi->gc = gc_new();\n    multi_instance_inc_refcount(mi);\n    mi->vaddr_handle = -1;\n    mi->created = now;\n    mroute_addr_init(&mi->real);\n\n    if (real)\n    {\n        mi->real = *real;\n        generate_prefix(mi);\n    }\n\n    mi->did_open_context = true;\n    inherit_context_child(&mi->context, &m->top);\n    if (IS_SIG(&mi->context))\n    {\n        goto err;\n    }\n\n    mi->context.c2.context_auth = CAS_PENDING;\n\n    if (hash_n_elements(m->hash) >= m->max_clients)\n    {\n        msg(D_MULTI_ERRORS, \"MULTI: new incoming connection would exceed maximum number of clients (%d)\", m->max_clients);\n        goto err;\n    }\n\n    if (!real) /* TCP mode? */\n    {\n        if (!multi_tcp_instance_specific_init(m, mi))\n        {\n            goto err;\n        }\n        generate_prefix(mi);\n    }\n\n    if (!hash_add(m->iter, &mi->real, mi, false))\n    {\n        msg(D_MULTI_LOW, \"MULTI: unable to add real address [%s] to iterator hash table\",\n            mroute_addr_print(&mi->real, &gc));\n        goto err;\n    }\n    mi->did_iter = true;\n\n#ifdef MANAGEMENT_DEF_AUTH\n    do\n    {\n        mi->context.c2.mda_context.cid = m->cid_counter++;\n    } while (!hash_add(m->cid_hash, &mi->context.c2.mda_context.cid, mi, false));\n    mi->did_cid_hash = true;\n#endif\n\n    mi->context.c2.push_reply_deferred = true;\n\n#ifdef ENABLE_ASYNC_PUSH\n    mi->context.c2.push_request_received = false;\n    mi->inotify_watch = -1;\n#endif\n\n    if (!multi_process_post(m, mi, MPP_PRE_SELECT))\n    {\n        msg(D_MULTI_ERRORS, \"MULTI: signal occurred during client instance initialization\");\n        goto err;\n    }\n\n    perf_pop();\n    gc_free(&gc);\n    return mi;\n\nerr:\n    multi_close_instance(m, mi, false);\n    perf_pop();\n    gc_free(&gc);\n    return NULL;\n}\n\n/*\n * Dump tables -- triggered by SIGUSR2.\n * If status file is defined, write to file.\n * If status file is NULL, write to syslog.\n */\nvoid\nmulti_print_status(struct multi_context *m, struct status_output *so, const int version)\n{\n    if (m->hash)\n    {\n        struct gc_arena gc_top = gc_new();\n        struct hash_iterator hi;\n        const struct hash_element *he;\n\n        status_reset(so);\n\n        if (version == 1) /* WAS: m->status_file_version */\n        {\n            /*\n             * Status file version 1\n             */\n            status_printf(so, \"OpenVPN CLIENT LIST\");\n            status_printf(so, \"Updated,%s\", time_string(0, 0, false, &gc_top));\n            status_printf(so, \"Common Name,Real Address,Bytes Received,Bytes Sent,Connected Since\");\n            hash_iterator_init(m->hash, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct gc_arena gc = gc_new();\n                const struct multi_instance *mi = (struct multi_instance *) he->value;\n\n                if (!mi->halt)\n                {\n                    status_printf(so, \"%s,%s,\" counter_format \",\" counter_format \",%s\",\n                                  tls_common_name(mi->context.c2.tls_multi, false),\n                                  mroute_addr_print(&mi->real, &gc),\n                                  mi->context.c2.link_read_bytes,\n                                  mi->context.c2.link_write_bytes,\n                                  time_string(mi->created, 0, false, &gc));\n                }\n                gc_free(&gc);\n            }\n            hash_iterator_free(&hi);\n\n            status_printf(so, \"ROUTING TABLE\");\n            status_printf(so, \"Virtual Address,Common Name,Real Address,Last Ref\");\n            hash_iterator_init(m->vhash, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct gc_arena gc = gc_new();\n                const struct multi_route *route = (struct multi_route *) he->value;\n\n                if (multi_route_defined(m, route))\n                {\n                    const struct multi_instance *mi = route->instance;\n                    const struct mroute_addr *ma = &route->addr;\n                    char flags[2] = {0, 0};\n\n                    if (route->flags & MULTI_ROUTE_CACHE)\n                    {\n                        flags[0] = 'C';\n                    }\n                    status_printf(so, \"%s%s,%s,%s,%s\",\n                                  mroute_addr_print(ma, &gc),\n                                  flags,\n                                  tls_common_name(mi->context.c2.tls_multi, false),\n                                  mroute_addr_print(&mi->real, &gc),\n                                  time_string(route->last_reference, 0, false, &gc));\n                }\n                gc_free(&gc);\n            }\n            hash_iterator_free(&hi);\n\n            status_printf(so, \"GLOBAL STATS\");\n            if (m->mbuf)\n            {\n                status_printf(so, \"Max bcast/mcast queue length,%d\",\n                              mbuf_maximum_queued(m->mbuf));\n            }\n\n            status_printf(so, \"END\");\n        }\n        else if (version == 2 || version == 3)\n        {\n            const char sep = (version == 3) ? '\\t' : ',';\n\n            /*\n             * Status file version 2 and 3\n             */\n            status_printf(so, \"TITLE%c%s\", sep, title_string);\n            status_printf(so, \"TIME%c%s%c%u\", sep, time_string(now, 0, false, &gc_top), sep, (unsigned int)now);\n            status_printf(so, \"HEADER%cCLIENT_LIST%cCommon Name%cReal Address%cVirtual Address%cVirtual IPv6 Address%cBytes Received%cBytes Sent%cConnected Since%cConnected Since (time_t)%cUsername%cClient ID%cPeer ID%cData Channel Cipher\",\n                          sep, sep, sep, sep, sep, sep, sep, sep, sep, sep, sep, sep, sep);\n            hash_iterator_init(m->hash, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct gc_arena gc = gc_new();\n                const struct multi_instance *mi = (struct multi_instance *) he->value;\n\n                if (!mi->halt)\n                {\n                    status_printf(so, \"CLIENT_LIST%c%s%c%s%c%s%c%s%c\" counter_format \"%c\" counter_format \"%c%s%c%u%c%s%c\"\n#ifdef MANAGEMENT_DEF_AUTH\n                                  \"%lu\"\n#else\n                                  \"\"\n#endif\n                                  \"%c%\" PRIu32 \"%c%s\",\n                                  sep, tls_common_name(mi->context.c2.tls_multi, false),\n                                  sep, mroute_addr_print(&mi->real, &gc),\n                                  sep, print_in_addr_t(mi->reporting_addr, IA_EMPTY_IF_UNDEF, &gc),\n                                  sep, print_in6_addr(mi->reporting_addr_ipv6, IA_EMPTY_IF_UNDEF, &gc),\n                                  sep, mi->context.c2.link_read_bytes,\n                                  sep, mi->context.c2.link_write_bytes,\n                                  sep, time_string(mi->created, 0, false, &gc),\n                                  sep, (unsigned int)mi->created,\n                                  sep, tls_username(mi->context.c2.tls_multi, false),\n#ifdef MANAGEMENT_DEF_AUTH\n                                  sep, mi->context.c2.mda_context.cid,\n#else\n                                  sep,\n#endif\n                                  sep, mi->context.c2.tls_multi ? mi->context.c2.tls_multi->peer_id : UINT32_MAX,\n                                  sep, translate_cipher_name_to_openvpn(mi->context.options.ciphername));\n                }\n                gc_free(&gc);\n            }\n            hash_iterator_free(&hi);\n\n            status_printf(so, \"HEADER%cROUTING_TABLE%cVirtual Address%cCommon Name%cReal Address%cLast Ref%cLast Ref (time_t)\",\n                          sep, sep, sep, sep, sep, sep);\n            hash_iterator_init(m->vhash, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct gc_arena gc = gc_new();\n                const struct multi_route *route = (struct multi_route *) he->value;\n\n                if (multi_route_defined(m, route))\n                {\n                    const struct multi_instance *mi = route->instance;\n                    const struct mroute_addr *ma = &route->addr;\n                    char flags[2] = {0, 0};\n\n                    if (route->flags & MULTI_ROUTE_CACHE)\n                    {\n                        flags[0] = 'C';\n                    }\n                    status_printf(so, \"ROUTING_TABLE%c%s%s%c%s%c%s%c%s%c%u\",\n                                  sep, mroute_addr_print(ma, &gc), flags,\n                                  sep, tls_common_name(mi->context.c2.tls_multi, false),\n                                  sep, mroute_addr_print(&mi->real, &gc),\n                                  sep, time_string(route->last_reference, 0, false, &gc),\n                                  sep, (unsigned int)route->last_reference);\n                }\n                gc_free(&gc);\n            }\n            hash_iterator_free(&hi);\n\n            if (m->mbuf)\n            {\n                status_printf(so, \"GLOBAL_STATS%cMax bcast/mcast queue length%c%d\",\n                              sep, sep, mbuf_maximum_queued(m->mbuf));\n            }\n\n            status_printf(so, \"END\");\n        }\n        else\n        {\n            status_printf(so, \"ERROR: bad status format version number\");\n        }\n\n#ifdef PACKET_TRUNCATION_CHECK\n        {\n            status_printf(so, \"HEADER,ERRORS,Common Name,TUN Read Trunc,TUN Write Trunc,Pre-encrypt Trunc,Post-decrypt Trunc\");\n            hash_iterator_init(m->hash, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct gc_arena gc = gc_new();\n                const struct multi_instance *mi = (struct multi_instance *) he->value;\n\n                if (!mi->halt)\n                {\n                    status_printf(so, \"ERRORS,%s,\" counter_format \",\" counter_format \",\" counter_format \",\" counter_format,\n                                  tls_common_name(mi->context.c2.tls_multi, false),\n                                  m->top.c2.n_trunc_tun_read,\n                                  mi->context.c2.n_trunc_tun_write,\n                                  mi->context.c2.n_trunc_pre_encrypt,\n                                  mi->context.c2.n_trunc_post_decrypt);\n                }\n                gc_free(&gc);\n            }\n            hash_iterator_free(&hi);\n        }\n#endif /* ifdef PACKET_TRUNCATION_CHECK */\n\n        status_flush(so);\n        gc_free(&gc_top);\n    }\n\n#ifdef ENABLE_ASYNC_PUSH\n    if (m->inotify_watchers)\n    {\n        msg(D_MULTI_DEBUG, \"inotify watchers count: %d\\n\", hash_n_elements(m->inotify_watchers));\n    }\n#endif\n}\n\n/*\n * Learn a virtual address or route.\n * The learn will fail if the learn address\n * script/plugin fails.  In this case the\n * return value may be != mi.\n * Return the instance which owns this route,\n * or NULL if none.\n */\nstatic struct multi_instance *\nmulti_learn_addr(struct multi_context *m,\n                 struct multi_instance *mi,\n                 const struct mroute_addr *addr,\n                 const unsigned int flags)\n{\n    struct hash_element *he;\n    const uint32_t hv = hash_value(m->vhash, addr);\n    struct hash_bucket *bucket = hash_bucket(m->vhash, hv);\n    struct multi_route *oldroute = NULL;\n    struct multi_instance *owner = NULL;\n    struct gc_arena gc = gc_new();\n\n    /* if route currently exists, get the instance which owns it */\n    he = hash_lookup_fast(m->vhash, bucket, addr, hv);\n    if (he)\n    {\n        oldroute = (struct multi_route *) he->value;\n    }\n    if (oldroute && multi_route_defined(m, oldroute))\n    {\n        owner = oldroute->instance;\n    }\n\n    /* do we need to add address to hash table? */\n    if ((!owner || owner != mi) && mroute_learnable_address(addr, &gc)\n        && !mroute_addr_equal(addr, &m->local))\n    {\n        struct multi_route *newroute;\n        bool learn_succeeded = false;\n\n        ALLOC_OBJ(newroute, struct multi_route);\n        newroute->addr = *addr;\n        newroute->instance = mi;\n        newroute->flags = flags;\n        newroute->last_reference = now;\n        newroute->cache_generation = 0;\n\n        /* The cache is invalidated when cache_generation is incremented */\n        if (flags & MULTI_ROUTE_CACHE)\n        {\n            newroute->cache_generation = m->route_helper->cache_generation;\n        }\n\n        if (oldroute) /* route already exists? */\n        {\n            if (route_quota_test(mi) && learn_address_script(m, mi, \"update\", &newroute->addr))\n            {\n                learn_succeeded = true;\n                owner = mi;\n                multi_instance_inc_refcount(mi);\n                route_quota_inc(mi);\n\n                /* delete old route */\n                multi_route_del(oldroute);\n\n                /* modify hash table entry, replacing old route */\n                he->key = &newroute->addr;\n                he->value = newroute;\n            }\n        }\n        else\n        {\n            if (route_quota_test(mi) && learn_address_script(m, mi, \"add\", &newroute->addr))\n            {\n                learn_succeeded = true;\n                owner = mi;\n                multi_instance_inc_refcount(mi);\n                route_quota_inc(mi);\n\n                /* add new route */\n                hash_add_fast(m->vhash, bucket, &newroute->addr, hv, newroute);\n            }\n        }\n\n        msg(D_MULTI_LOW, \"MULTI: Learn%s: %s -> %s\",\n            learn_succeeded ? \"\" : \" FAILED\",\n            mroute_addr_print(&newroute->addr, &gc),\n            multi_instance_string(mi, false, &gc));\n\n        if (!learn_succeeded)\n        {\n            free(newroute);\n        }\n    }\n    gc_free(&gc);\n\n    return owner;\n}\n\n/*\n * Get client instance based on virtual address.\n */\nstatic struct multi_instance *\nmulti_get_instance_by_virtual_addr(struct multi_context *m,\n                                   const struct mroute_addr *addr,\n                                   bool cidr_routing)\n{\n    struct multi_route *route;\n    struct multi_instance *ret = NULL;\n\n    /* check for local address */\n    if (mroute_addr_equal(addr, &m->local))\n    {\n        return NULL;\n    }\n\n    route = (struct multi_route *) hash_lookup(m->vhash, addr);\n\n    /* does host route (possible cached) exist? */\n    if (route && multi_route_defined(m, route))\n    {\n        struct multi_instance *mi = route->instance;\n        route->last_reference = now;\n        ret = mi;\n    }\n    else if (cidr_routing) /* do we need to regenerate a host route cache entry? */\n    {\n        struct mroute_helper *rh = m->route_helper;\n        struct mroute_addr tryaddr;\n        int i;\n\n        /* cycle through each CIDR length */\n        for (i = 0; i < rh->n_net_len; ++i)\n        {\n            tryaddr = *addr;\n            tryaddr.type |= MR_WITH_NETBITS;\n            tryaddr.netbits = rh->net_len[i];\n            mroute_addr_mask_host_bits(&tryaddr);\n\n            /* look up a possible route with netbits netmask */\n            route = (struct multi_route *) hash_lookup(m->vhash, &tryaddr);\n\n            if (route && multi_route_defined(m, route))\n            {\n                /* found an applicable route, cache host route */\n                struct multi_instance *mi = route->instance;\n                multi_learn_addr(m, mi, addr, MULTI_ROUTE_CACHE|MULTI_ROUTE_AGEABLE);\n                ret = mi;\n                break;\n            }\n        }\n    }\n\n#ifdef ENABLE_DEBUG\n    if (check_debug_level(D_MULTI_DEBUG))\n    {\n        struct gc_arena gc = gc_new();\n        const char *addr_text = mroute_addr_print(addr, &gc);\n        if (ret)\n        {\n            dmsg(D_MULTI_DEBUG, \"GET INST BY VIRT: %s -> %s via %s\",\n                 addr_text,\n                 multi_instance_string(ret, false, &gc),\n                 mroute_addr_print(&route->addr, &gc));\n        }\n        else\n        {\n            dmsg(D_MULTI_DEBUG, \"GET INST BY VIRT: %s [failed]\",\n                 addr_text);\n        }\n        gc_free(&gc);\n    }\n#endif\n\n    ASSERT(!(ret && ret->halt));\n    return ret;\n}\n\n/*\n * Helper function to multi_learn_addr().\n */\nstatic struct multi_instance *\nmulti_learn_in_addr_t(struct multi_context *m,\n                      struct multi_instance *mi,\n                      in_addr_t a,\n                      int netbits,  /* -1 if host route, otherwise # of network bits in address */\n                      bool primary)\n{\n    struct openvpn_sockaddr remote_si;\n    struct mroute_addr addr;\n\n    CLEAR(remote_si);\n    remote_si.addr.in4.sin_family = AF_INET;\n    remote_si.addr.in4.sin_addr.s_addr = htonl(a);\n    ASSERT(mroute_extract_openvpn_sockaddr(&addr, &remote_si, false));\n\n    if (netbits >= 0)\n    {\n        addr.type |= MR_WITH_NETBITS;\n        addr.netbits = (uint8_t) netbits;\n    }\n\n    {\n        struct multi_instance *owner = multi_learn_addr(m, mi, &addr, 0);\n#ifdef MANAGEMENT_DEF_AUTH\n        if (management && owner)\n        {\n            management_learn_addr(management, &mi->context.c2.mda_context, &addr, primary);\n        }\n#endif\n        return owner;\n    }\n}\n\nstatic struct multi_instance *\nmulti_learn_in6_addr(struct multi_context *m,\n                     struct multi_instance *mi,\n                     struct in6_addr a6,\n                     int netbits,   /* -1 if host route, otherwise # of network bits in address */\n                     bool primary)\n{\n    struct mroute_addr addr;\n\n    addr.len = 16;\n    addr.type = MR_ADDR_IPV6;\n    addr.netbits = 0;\n    addr.v6.addr = a6;\n\n    if (netbits >= 0)\n    {\n        addr.type |= MR_WITH_NETBITS;\n        addr.netbits = (uint8_t) netbits;\n        mroute_addr_mask_host_bits( &addr );\n    }\n\n    {\n        struct multi_instance *owner = multi_learn_addr(m, mi, &addr, 0);\n#ifdef MANAGEMENT_DEF_AUTH\n        if (management && owner)\n        {\n            management_learn_addr(management, &mi->context.c2.mda_context, &addr, primary);\n        }\n#endif\n        return owner;\n    }\n}\n\n/*\n * A new client has connected, add routes (server -> client)\n * to internal routing table.\n */\nstatic void\nmulti_add_iroutes(struct multi_context *m,\n                  struct multi_instance *mi)\n{\n    struct gc_arena gc = gc_new();\n    const struct iroute *ir;\n    const struct iroute_ipv6 *ir6;\n    if (TUNNEL_TYPE(mi->context.c1.tuntap) == DEV_TYPE_TUN)\n    {\n        mi->did_iroutes = true;\n        for (ir = mi->context.options.iroutes; ir != NULL; ir = ir->next)\n        {\n            if (ir->netbits >= 0)\n            {\n                msg(D_MULTI_LOW, \"MULTI: internal route %s/%d -> %s\",\n                    print_in_addr_t(ir->network, 0, &gc),\n                    ir->netbits,\n                    multi_instance_string(mi, false, &gc));\n            }\n            else\n            {\n                msg(D_MULTI_LOW, \"MULTI: internal route %s -> %s\",\n                    print_in_addr_t(ir->network, 0, &gc),\n                    multi_instance_string(mi, false, &gc));\n            }\n\n            mroute_helper_add_iroute46(m->route_helper, ir->netbits);\n\n            multi_learn_in_addr_t(m, mi, ir->network, ir->netbits, false);\n        }\n        for (ir6 = mi->context.options.iroutes_ipv6; ir6 != NULL; ir6 = ir6->next)\n        {\n            msg(D_MULTI_LOW, \"MULTI: internal route %s/%d -> %s\",\n                print_in6_addr(ir6->network, 0, &gc),\n                ir6->netbits,\n                multi_instance_string(mi, false, &gc));\n\n            mroute_helper_add_iroute46(m->route_helper, ir6->netbits);\n\n            multi_learn_in6_addr(m, mi, ir6->network, ir6->netbits, false);\n        }\n    }\n    gc_free(&gc);\n}\n\n/*\n * Given an instance (new_mi), delete all other instances which use the\n * same common name.\n */\nstatic void\nmulti_delete_dup(struct multi_context *m, struct multi_instance *new_mi)\n{\n    if (new_mi)\n    {\n        const char *new_cn = tls_common_name(new_mi->context.c2.tls_multi, true);\n        if (new_cn)\n        {\n            struct hash_iterator hi;\n            struct hash_element *he;\n            int count = 0;\n\n            hash_iterator_init(m->iter, &hi);\n            while ((he = hash_iterator_next(&hi)))\n            {\n                struct multi_instance *mi = (struct multi_instance *) he->value;\n                if (mi != new_mi && !mi->halt)\n                {\n                    const char *cn = tls_common_name(mi->context.c2.tls_multi, true);\n                    if (cn && !strcmp(cn, new_cn))\n                    {\n                        mi->did_iter = false;\n                        multi_close_instance(m, mi, false);\n                        hash_iterator_delete_element(&hi);\n                        ++count;\n                    }\n                }\n            }\n            hash_iterator_free(&hi);\n\n            if (count)\n            {\n                msg(D_MULTI_LOW, \"MULTI: new connection by client '%s' will cause previous active sessions by this client to be dropped.  Remember to use the --duplicate-cn option if you want multiple clients using the same certificate or username to concurrently connect.\", new_cn);\n            }\n        }\n    }\n}\n\nstatic void\ncheck_stale_routes(struct multi_context *m)\n{\n\n    struct gc_arena gc = gc_new();\n    struct hash_iterator hi;\n    struct hash_element *he;\n\n    dmsg(D_MULTI_DEBUG, \"MULTI: Checking stale routes\");\n    hash_iterator_init_range(m->vhash, &hi, 0, hash_n_buckets(m->vhash));\n    while ((he = hash_iterator_next(&hi)) != NULL)\n    {\n        struct multi_route *r = (struct multi_route *) he->value;\n        if (multi_route_defined(m, r) && difftime(now, r->last_reference) >= m->top.options.stale_routes_ageing_time)\n        {\n            dmsg(D_MULTI_DEBUG, \"MULTI: Deleting stale route for address '%s'\",\n                 mroute_addr_print(&r->addr, &gc));\n            learn_address_script(m, NULL, \"delete\", &r->addr);\n            multi_route_del(r);\n            hash_iterator_delete_element(&hi);\n        }\n    }\n    hash_iterator_free(&hi);\n    gc_free(&gc);\n}\n\n/*\n * Ensure that endpoint to be pushed to client\n * complies with --ifconfig-push-constraint directive.\n */\nstatic bool\nifconfig_push_constraint_satisfied(const struct context *c)\n{\n    const struct options *o = &c->options;\n    if (o->push_ifconfig_constraint_defined && c->c2.push_ifconfig_defined)\n    {\n        return (o->push_ifconfig_constraint_netmask & c->c2.push_ifconfig_local) == o->push_ifconfig_constraint_network;\n    }\n    else\n    {\n        return true;\n    }\n}\n\n/*\n * Select a virtual address for a new client instance.\n * Use an --ifconfig-push directive, if given (static IP).\n * Otherwise use an --ifconfig-pool address (dynamic IP).\n */\nstatic void\nmulti_select_virtual_addr(struct multi_context *m, struct multi_instance *mi)\n{\n    struct gc_arena gc = gc_new();\n\n    /*\n     * If ifconfig addresses were set by dynamic config file,\n     * release pool addresses, otherwise keep them.\n     */\n    if (mi->context.options.push_ifconfig_defined)\n    {\n        /* ifconfig addresses were set statically,\n         * release dynamic allocation */\n        if (mi->vaddr_handle >= 0)\n        {\n            ifconfig_pool_release(m->ifconfig_pool, mi->vaddr_handle, true);\n            mi->vaddr_handle = -1;\n        }\n\n        mi->context.c2.push_ifconfig_defined = true;\n        mi->context.c2.push_ifconfig_local = mi->context.options.push_ifconfig_local;\n        mi->context.c2.push_ifconfig_remote_netmask = mi->context.options.push_ifconfig_remote_netmask;\n        mi->context.c2.push_ifconfig_local_alias = mi->context.options.push_ifconfig_local_alias;\n\n        /* the current implementation does not allow \"static IPv4, pool IPv6\",\n         * (see below) so issue a warning if that happens - don't break the\n         * session, though, as we don't even know if this client WANTS IPv6\n         */\n        if (mi->context.options.ifconfig_ipv6_pool_defined\n            && !mi->context.options.push_ifconfig_ipv6_defined)\n        {\n            msg( M_INFO, \"MULTI_sva: WARNING: if --ifconfig-push is used for IPv4, automatic IPv6 assignment from --ifconfig-ipv6-pool does not work.  Use --ifconfig-ipv6-push for IPv6 then.\" );\n        }\n    }\n    else if (m->ifconfig_pool && mi->vaddr_handle < 0) /* otherwise, choose a pool address */\n    {\n        in_addr_t local = 0, remote = 0;\n        struct in6_addr remote_ipv6;\n        const char *cn = NULL;\n\n        if (!mi->context.options.duplicate_cn)\n        {\n            cn = tls_common_name(mi->context.c2.tls_multi, true);\n        }\n\n        CLEAR(remote_ipv6);\n        mi->vaddr_handle = ifconfig_pool_acquire(m->ifconfig_pool, &local, &remote, &remote_ipv6, cn);\n        if (mi->vaddr_handle >= 0)\n        {\n            const int tunnel_type = TUNNEL_TYPE(mi->context.c1.tuntap);\n            const int tunnel_topology = TUNNEL_TOPOLOGY(mi->context.c1.tuntap);\n\n            msg( M_INFO, \"MULTI_sva: pool returned IPv4=%s, IPv6=%s\",\n                 print_in_addr_t( remote, 0, &gc ),\n                 (mi->context.options.ifconfig_ipv6_pool_defined\n                  ? print_in6_addr( remote_ipv6, 0, &gc )\n                  : \"(Not enabled)\") );\n\n            /* set push_ifconfig_remote_netmask from pool ifconfig address(es) */\n            mi->context.c2.push_ifconfig_local = remote;\n            if (tunnel_type == DEV_TYPE_TAP || (tunnel_type == DEV_TYPE_TUN && tunnel_topology == TOP_SUBNET))\n            {\n                mi->context.c2.push_ifconfig_remote_netmask = mi->context.options.ifconfig_pool_netmask;\n                if (!mi->context.c2.push_ifconfig_remote_netmask)\n                {\n                    mi->context.c2.push_ifconfig_remote_netmask = mi->context.c1.tuntap->remote_netmask;\n                }\n            }\n            else if (tunnel_type == DEV_TYPE_TUN)\n            {\n                if (tunnel_topology == TOP_P2P)\n                {\n                    mi->context.c2.push_ifconfig_remote_netmask = mi->context.c1.tuntap->local;\n                }\n                else if (tunnel_topology == TOP_NET30)\n                {\n                    mi->context.c2.push_ifconfig_remote_netmask = local;\n                }\n            }\n\n            if (mi->context.c2.push_ifconfig_remote_netmask)\n            {\n                mi->context.c2.push_ifconfig_defined = true;\n            }\n            else\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: no --ifconfig-pool netmask parameter is available to push to %s\",\n                    multi_instance_string(mi, false, &gc));\n            }\n\n            if (mi->context.options.ifconfig_ipv6_pool_defined)\n            {\n                mi->context.c2.push_ifconfig_ipv6_local = remote_ipv6;\n                mi->context.c2.push_ifconfig_ipv6_remote =\n                    mi->context.c1.tuntap->local_ipv6;\n                mi->context.c2.push_ifconfig_ipv6_netbits =\n                    mi->context.options.ifconfig_ipv6_netbits;\n                mi->context.c2.push_ifconfig_ipv6_defined = true;\n            }\n        }\n        else\n        {\n            msg(D_MULTI_ERRORS, \"MULTI: no free --ifconfig-pool addresses are available\");\n        }\n    }\n\n    /* IPv6 push_ifconfig is a bit problematic - since IPv6 shares the\n     * pool handling with IPv4, the combination \"static IPv4, dynamic IPv6\"\n     * will fail (because no pool will be allocated in this case).\n     * OTOH, this doesn't make too much sense in reality - and the other\n     * way round (\"dynamic IPv4, static IPv6\") or \"both static\" makes sense\n     * -> and so it's implemented right now\n     */\n    if (mi->context.options.push_ifconfig_ipv6_defined)\n    {\n        mi->context.c2.push_ifconfig_ipv6_local =\n            mi->context.options.push_ifconfig_ipv6_local;\n        mi->context.c2.push_ifconfig_ipv6_remote =\n            mi->context.options.push_ifconfig_ipv6_remote;\n        mi->context.c2.push_ifconfig_ipv6_netbits =\n            mi->context.options.push_ifconfig_ipv6_netbits;\n        mi->context.c2.push_ifconfig_ipv6_defined = true;\n\n        msg( M_INFO, \"MULTI_sva: push_ifconfig_ipv6 %s/%d\",\n             print_in6_addr( mi->context.c2.push_ifconfig_ipv6_local, 0, &gc ),\n             mi->context.c2.push_ifconfig_ipv6_netbits );\n    }\n\n    gc_free(&gc);\n}\n\n/*\n * Set virtual address environmental variables.\n */\nstatic void\nmulti_set_virtual_addr_env(struct multi_instance *mi)\n{\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_local_ip\");\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_remote_ip\");\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_netmask\");\n\n    if (mi->context.c2.push_ifconfig_defined)\n    {\n        const int tunnel_type = TUNNEL_TYPE(mi->context.c1.tuntap);\n        const int tunnel_topology = TUNNEL_TOPOLOGY(mi->context.c1.tuntap);\n\n        setenv_in_addr_t(mi->context.c2.es,\n                         \"ifconfig_pool_remote_ip\",\n                         mi->context.c2.push_ifconfig_local,\n                         SA_SET_IF_NONZERO);\n\n        if (tunnel_type == DEV_TYPE_TAP || (tunnel_type == DEV_TYPE_TUN && tunnel_topology == TOP_SUBNET))\n        {\n            setenv_in_addr_t(mi->context.c2.es,\n                             \"ifconfig_pool_netmask\",\n                             mi->context.c2.push_ifconfig_remote_netmask,\n                             SA_SET_IF_NONZERO);\n        }\n        else if (tunnel_type == DEV_TYPE_TUN)\n        {\n            setenv_in_addr_t(mi->context.c2.es,\n                             \"ifconfig_pool_local_ip\",\n                             mi->context.c2.push_ifconfig_remote_netmask,\n                             SA_SET_IF_NONZERO);\n        }\n    }\n\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_local_ip6\");\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_remote_ip6\");\n    setenv_del(mi->context.c2.es, \"ifconfig_pool_ip6_netbits\");\n\n    if (mi->context.c2.push_ifconfig_ipv6_defined)\n    {\n        setenv_in6_addr(mi->context.c2.es,\n                        \"ifconfig_pool_remote\",\n                        &mi->context.c2.push_ifconfig_ipv6_local,\n                        SA_SET_IF_NONZERO);\n        setenv_in6_addr(mi->context.c2.es,\n                        \"ifconfig_pool_local\",\n                        &mi->context.c2.push_ifconfig_ipv6_remote,\n                        SA_SET_IF_NONZERO);\n        setenv_int(mi->context.c2.es,\n                   \"ifconfig_pool_ip6_netbits\",\n                   mi->context.c2.push_ifconfig_ipv6_netbits);\n    }\n}\n\n/*\n * Called after client-connect script is called\n */\nstatic void\nmulti_client_connect_post(struct multi_context *m,\n                          struct multi_instance *mi,\n                          const char *dc_file,\n                          unsigned int option_permissions_mask,\n                          unsigned int *option_types_found)\n{\n    /* Did script generate a dynamic config file? */\n    if (platform_test_file(dc_file))\n    {\n        options_server_import(&mi->context.options,\n                              dc_file,\n                              D_IMPORT_ERRORS|M_OPTERR,\n                              option_permissions_mask,\n                              option_types_found,\n                              mi->context.c2.es);\n\n        /*\n         * If the --client-connect script generates a config file\n         * with an --ifconfig-push directive, it will override any\n         * --ifconfig-push directive from the --client-config-dir\n         * directory or any --ifconfig-pool dynamic address.\n         */\n        multi_select_virtual_addr(m, mi);\n        multi_set_virtual_addr_env(mi);\n    }\n}\n\n#ifdef ENABLE_PLUGIN\n\n/*\n * Called after client-connect plug-in is called\n */\nstatic void\nmulti_client_connect_post_plugin(struct multi_context *m,\n                                 struct multi_instance *mi,\n                                 const struct plugin_return *pr,\n                                 unsigned int option_permissions_mask,\n                                 unsigned int *option_types_found)\n{\n    struct plugin_return config;\n\n    plugin_return_get_column(pr, &config, \"config\");\n\n    /* Did script generate a dynamic config file? */\n    if (plugin_return_defined(&config))\n    {\n        int i;\n        for (i = 0; i < config.n; ++i)\n        {\n            if (config.list[i] && config.list[i]->value)\n            {\n                options_string_import(&mi->context.options,\n                                      config.list[i]->value,\n                                      D_IMPORT_ERRORS|M_OPTERR,\n                                      option_permissions_mask,\n                                      option_types_found,\n                                      mi->context.c2.es);\n            }\n        }\n\n        /*\n         * If the --client-connect script generates a config file\n         * with an --ifconfig-push directive, it will override any\n         * --ifconfig-push directive from the --client-config-dir\n         * directory or any --ifconfig-pool dynamic address.\n         */\n        multi_select_virtual_addr(m, mi);\n        multi_set_virtual_addr_env(mi);\n    }\n}\n\n#endif /* ifdef ENABLE_PLUGIN */\n\n#ifdef MANAGEMENT_DEF_AUTH\n\n/*\n * Called to load management-derived client-connect config\n */\nstatic void\nmulti_client_connect_mda(struct multi_context *m,\n                         struct multi_instance *mi,\n                         const struct buffer_list *config,\n                         unsigned int option_permissions_mask,\n                         unsigned int *option_types_found)\n{\n    if (config)\n    {\n        struct buffer_entry *be;\n\n        for (be = config->head; be != NULL; be = be->next)\n        {\n            const char *opt = BSTR(&be->buf);\n            options_string_import(&mi->context.options,\n                                  opt,\n                                  D_IMPORT_ERRORS|M_OPTERR,\n                                  option_permissions_mask,\n                                  option_types_found,\n                                  mi->context.c2.es);\n        }\n\n        /*\n         * If the --client-connect script generates a config file\n         * with an --ifconfig-push directive, it will override any\n         * --ifconfig-push directive from the --client-config-dir\n         * directory or any --ifconfig-pool dynamic address.\n         */\n        multi_select_virtual_addr(m, mi);\n        multi_set_virtual_addr_env(mi);\n    }\n}\n\n#endif /* ifdef MANAGEMENT_DEF_AUTH */\n\nstatic void\nmulti_client_connect_setenv(struct multi_context *m,\n                            struct multi_instance *mi)\n{\n    struct gc_arena gc = gc_new();\n\n    /* setenv incoming cert common name for script */\n    setenv_str(mi->context.c2.es, \"common_name\", tls_common_name(mi->context.c2.tls_multi, true));\n\n    /* setenv client real IP address */\n    setenv_trusted(mi->context.c2.es, get_link_socket_info(&mi->context));\n\n    /* setenv client virtual IP address */\n    multi_set_virtual_addr_env(mi);\n\n    /* setenv connection time */\n    {\n        const char *created_ascii = time_string(mi->created, 0, false, &gc);\n        setenv_str(mi->context.c2.es, \"time_ascii\", created_ascii);\n        setenv_long_long(mi->context.c2.es, \"time_unix\", mi->created);\n    }\n\n    gc_free(&gc);\n}\n\n/*\n * Called as soon as the SSL/TLS connection authenticates.\n *\n * Instance-specific directives to be processed:\n *\n *   iroute start-ip end-ip\n *   ifconfig-push local remote-netmask\n *   push\n */\nstatic void\nmulti_connection_established(struct multi_context *m, struct multi_instance *mi)\n{\n    if (tls_authentication_status(mi->context.c2.tls_multi, 0) == TLS_AUTHENTICATION_SUCCEEDED)\n    {\n        struct gc_arena gc = gc_new();\n        unsigned int option_types_found = 0;\n\n        const unsigned int option_permissions_mask =\n            OPT_P_INSTANCE\n            | OPT_P_INHERIT\n            | OPT_P_PUSH\n            | OPT_P_TIMER\n            | OPT_P_CONFIG\n            | OPT_P_ECHO\n            | OPT_P_COMP\n            | OPT_P_SOCKFLAGS;\n\n        int cc_succeeded = true; /* client connect script status */\n        int cc_succeeded_count = 0;\n\n        ASSERT(mi->context.c1.tuntap);\n\n        /* lock down the common name and cert hashes so they can't change during future TLS renegotiations */\n        tls_lock_common_name(mi->context.c2.tls_multi);\n        tls_lock_cert_hash_set(mi->context.c2.tls_multi);\n\n        /* generate a msg() prefix for this client instance */\n        generate_prefix(mi);\n\n        /* delete instances of previous clients with same common-name */\n        if (!mi->context.options.duplicate_cn)\n        {\n            multi_delete_dup(m, mi);\n        }\n\n        /* reset pool handle to null */\n        mi->vaddr_handle = -1;\n\n        /*\n         * Try to source a dynamic config file from the\n         * --client-config-dir directory.\n         */\n        if (mi->context.options.client_config_dir)\n        {\n            const char *ccd_file;\n\n            ccd_file = platform_gen_path(mi->context.options.client_config_dir,\n                                         tls_common_name(mi->context.c2.tls_multi,\n                                                         false),\n                                         &gc);\n\n            /* try common-name file */\n            if (platform_test_file(ccd_file))\n            {\n                options_server_import(&mi->context.options,\n                                      ccd_file,\n                                      D_IMPORT_ERRORS|M_OPTERR,\n                                      option_permissions_mask,\n                                      &option_types_found,\n                                      mi->context.c2.es);\n            }\n            else /* try default file */\n            {\n                ccd_file = platform_gen_path(mi->context.options.client_config_dir,\n                                             CCD_DEFAULT,\n                                             &gc);\n\n                if (platform_test_file(ccd_file))\n                {\n                    options_server_import(&mi->context.options,\n                                          ccd_file,\n                                          D_IMPORT_ERRORS|M_OPTERR,\n                                          option_permissions_mask,\n                                          &option_types_found,\n                                          mi->context.c2.es);\n                }\n            }\n        }\n\n        /*\n         * Select a virtual address from either --ifconfig-push in --client-config-dir file\n         * or --ifconfig-pool.\n         */\n        multi_select_virtual_addr(m, mi);\n\n        /* do --client-connect setenvs */\n        multi_client_connect_setenv(m, mi);\n\n#ifdef ENABLE_PLUGIN\n        /*\n         * Call client-connect plug-in.\n         */\n\n        /* deprecated callback, use a file for passing back return info */\n        if (plugin_defined(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT))\n        {\n            struct argv argv = argv_new();\n            const char *dc_file = platform_create_temp_file(mi->context.options.tmp_dir,\n                                                            \"cc\", &gc);\n\n            if (!dc_file)\n            {\n                cc_succeeded = false;\n                goto script_depr_failed;\n            }\n\n            argv_printf(&argv, \"%s\", dc_file);\n            if (plugin_call(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT, &argv, NULL, mi->context.c2.es) != OPENVPN_PLUGIN_FUNC_SUCCESS)\n            {\n                msg(M_WARN, \"WARNING: client-connect plugin call failed\");\n                cc_succeeded = false;\n            }\n            else\n            {\n                multi_client_connect_post(m, mi, dc_file, option_permissions_mask, &option_types_found);\n                ++cc_succeeded_count;\n            }\n\n            if (!platform_unlink(dc_file))\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: problem deleting temporary file: %s\",\n                    dc_file);\n            }\n\nscript_depr_failed:\n            argv_free(&argv);\n        }\n\n        /* V2 callback, use a plugin_return struct for passing back return info */\n        if (plugin_defined(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT_V2))\n        {\n            struct plugin_return pr;\n\n            plugin_return_init(&pr);\n\n            if (plugin_call(mi->context.plugins, OPENVPN_PLUGIN_CLIENT_CONNECT_V2, NULL, &pr, mi->context.c2.es) != OPENVPN_PLUGIN_FUNC_SUCCESS)\n            {\n                msg(M_WARN, \"WARNING: client-connect-v2 plugin call failed\");\n                cc_succeeded = false;\n            }\n            else\n            {\n                multi_client_connect_post_plugin(m, mi, &pr, option_permissions_mask, &option_types_found);\n                ++cc_succeeded_count;\n            }\n\n            plugin_return_free(&pr);\n        }\n#endif /* ifdef ENABLE_PLUGIN */\n\n        /*\n         * Run --client-connect script.\n         */\n        if (mi->context.options.client_connect_script && cc_succeeded)\n        {\n            struct argv argv = argv_new();\n            const char *dc_file = NULL;\n\n            setenv_str(mi->context.c2.es, \"script_type\", \"client-connect\");\n\n            dc_file = platform_create_temp_file(mi->context.options.tmp_dir,\n                                                \"cc\", &gc);\n            if (!dc_file)\n            {\n                cc_succeeded = false;\n                goto script_failed;\n            }\n\n            argv_parse_cmd(&argv, mi->context.options.client_connect_script);\n            argv_printf_cat(&argv, \"%s\", dc_file);\n\n            if (openvpn_run_script(&argv, mi->context.c2.es, 0, \"--client-connect\"))\n            {\n                multi_client_connect_post(m, mi, dc_file, option_permissions_mask, &option_types_found);\n                ++cc_succeeded_count;\n            }\n            else\n            {\n                cc_succeeded = false;\n            }\n\n            if (!platform_unlink(dc_file))\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: problem deleting temporary file: %s\",\n                    dc_file);\n            }\n\nscript_failed:\n            argv_free(&argv);\n        }\n\n        /*\n         * Check for client-connect script left by management interface client\n         */\n#ifdef MANAGEMENT_DEF_AUTH\n        if (cc_succeeded && mi->cc_config)\n        {\n            multi_client_connect_mda(m, mi, mi->cc_config, option_permissions_mask, &option_types_found);\n            ++cc_succeeded_count;\n        }\n#endif\n\n        /*\n         * Check for \"disable\" directive in client-config-dir file\n         * or config file generated by --client-connect script.\n         */\n        if (mi->context.options.disable)\n        {\n            msg(D_MULTI_ERRORS, \"MULTI: client has been rejected due to 'disable' directive\");\n            cc_succeeded = false;\n            cc_succeeded_count = 0;\n        }\n\n        if (cc_succeeded)\n        {\n            /*\n             * Process sourced options.\n             */\n            do_deferred_options(&mi->context, option_types_found);\n\n            /*\n             * make sure we got ifconfig settings from somewhere\n             */\n            if (!mi->context.c2.push_ifconfig_defined)\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: no dynamic or static remote --ifconfig address is available for %s\",\n                    multi_instance_string(mi, false, &gc));\n            }\n\n            /*\n             * make sure that ifconfig settings comply with constraints\n             */\n            if (!ifconfig_push_constraint_satisfied(&mi->context))\n            {\n                /* JYFIXME -- this should cause the connection to fail */\n                msg(D_MULTI_ERRORS, \"MULTI ERROR: primary virtual IP for %s (%s) violates tunnel network/netmask constraint (%s/%s)\",\n                    multi_instance_string(mi, false, &gc),\n                    print_in_addr_t(mi->context.c2.push_ifconfig_local, 0, &gc),\n                    print_in_addr_t(mi->context.options.push_ifconfig_constraint_network, 0, &gc),\n                    print_in_addr_t(mi->context.options.push_ifconfig_constraint_netmask, 0, &gc));\n            }\n\n            /*\n             * For routed tunnels, set up internal route to endpoint\n             * plus add all iroute routes.\n             */\n            if (TUNNEL_TYPE(mi->context.c1.tuntap) == DEV_TYPE_TUN)\n            {\n                if (mi->context.c2.push_ifconfig_defined)\n                {\n                    multi_learn_in_addr_t(m, mi, mi->context.c2.push_ifconfig_local, -1, true);\n                    msg(D_MULTI_LOW, \"MULTI: primary virtual IP for %s: %s\",\n                        multi_instance_string(mi, false, &gc),\n                        print_in_addr_t(mi->context.c2.push_ifconfig_local, 0, &gc));\n                }\n\n                if (mi->context.c2.push_ifconfig_ipv6_defined)\n                {\n                    multi_learn_in6_addr(m, mi, mi->context.c2.push_ifconfig_ipv6_local, -1, true);\n                    /* TODO: find out where addresses are \"unlearned\"!! */\n                    msg(D_MULTI_LOW, \"MULTI: primary virtual IPv6 for %s: %s\",\n                        multi_instance_string(mi, false, &gc),\n                        print_in6_addr(mi->context.c2.push_ifconfig_ipv6_local, 0, &gc));\n                }\n\n                /* add routes locally, pointing to new client, if\n                 * --iroute options have been specified */\n                multi_add_iroutes(m, mi);\n\n                /*\n                 * iroutes represent subnets which are \"owned\" by a particular\n                 * client.  Therefore, do not actually push a route to a client\n                 * if it matches one of the client's iroutes.\n                 */\n                remove_iroutes_from_push_route_list(&mi->context.options);\n            }\n            else if (mi->context.options.iroutes)\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: --iroute options rejected for %s -- iroute only works with tun-style tunnels\",\n                    multi_instance_string(mi, false, &gc));\n            }\n\n            /* set our client's VPN endpoint for status reporting purposes */\n            mi->reporting_addr = mi->context.c2.push_ifconfig_local;\n            mi->reporting_addr_ipv6 = mi->context.c2.push_ifconfig_ipv6_local;\n\n            /* set context-level authentication flag */\n            mi->context.c2.context_auth = CAS_SUCCEEDED;\n\n#ifdef ENABLE_ASYNC_PUSH\n            /* authentication complete, send push reply */\n            if (mi->context.c2.push_request_received)\n            {\n                process_incoming_push_request(&mi->context);\n            }\n#endif\n        }\n        else\n        {\n            /* set context-level authentication flag */\n            mi->context.c2.context_auth = cc_succeeded_count ? CAS_PARTIAL : CAS_FAILED;\n        }\n\n        /* set flag so we don't get called again */\n        mi->connection_established_flag = true;\n\n        /* increment number of current authenticated clients */\n        ++m->n_clients;\n        update_mstat_n_clients(m->n_clients);\n        --mi->n_clients_delta;\n\n#ifdef MANAGEMENT_DEF_AUTH\n        if (management)\n        {\n            management_connection_established(management, &mi->context.c2.mda_context, mi->context.c2.es);\n        }\n#endif\n\n        gc_free(&gc);\n    }\n\n    /*\n     * Reply now to client's PUSH_REQUEST query\n     */\n    mi->context.c2.push_reply_deferred = false;\n}\n\n#ifdef ENABLE_ASYNC_PUSH\n/*\n * Called when inotify event is fired, which happens when acf file is closed or deleted.\n * Continues authentication and sends push_reply.\n */\nvoid\nmulti_process_file_closed(struct multi_context *m, const unsigned int mpp_flags)\n{\n    char buffer[INOTIFY_EVENT_BUFFER_SIZE];\n    size_t buffer_i = 0;\n    int r = read(m->top.c2.inotify_fd, buffer, INOTIFY_EVENT_BUFFER_SIZE);\n\n    while (buffer_i < r)\n    {\n        /* parse inotify events */\n        struct inotify_event *pevent = (struct inotify_event *) &buffer[buffer_i];\n        size_t event_size = sizeof(struct inotify_event) + pevent->len;\n        buffer_i += event_size;\n\n        msg(D_MULTI_DEBUG, \"MULTI: modified fd %d, mask %d\", pevent->wd, pevent->mask);\n\n        struct multi_instance *mi = hash_lookup(m->inotify_watchers, (void *) (unsigned long) pevent->wd);\n\n        if (pevent->mask & IN_CLOSE_WRITE)\n        {\n            if (mi)\n            {\n                /* continue authentication, perform NCP negotiation and send push_reply */\n                multi_process_post(m, mi, mpp_flags);\n\n                /* With NCP and deferred authentication, we perform cipher negotiation and\n                 * data channel keys generation on incoming push request, assuming that auth\n                 * succeeded. When auth succeeds in between push requests and async push is used,\n                 * we send push reply immediately. Above multi_process_post() call performs\n                 * NCP negotiation and here we do keys generation. */\n\n                struct context *c = &mi->context;\n                struct frame *frame_fragment = NULL;\n#ifdef ENABLE_FRAGMENT\n                if (c->options.ce.fragment)\n                {\n                    frame_fragment = &c->c2.frame_fragment;\n                }\n#endif\n                struct tls_session *session = &c->c2.tls_multi->session[TM_ACTIVE];\n                if (!tls_session_update_crypto_params(session, &c->options,\n                                                      &c->c2.frame, frame_fragment))\n                {\n                    msg(D_TLS_ERRORS, \"TLS Error: initializing data channel failed\");\n                    register_signal(c, SIGUSR1, \"init-data-channel-failed\");\n                }\n            }\n            else\n            {\n                msg(D_MULTI_ERRORS, \"MULTI: multi_instance not found!\");\n            }\n        }\n        else if (pevent->mask & IN_IGNORED)\n        {\n            /* this event is _always_ fired when watch is removed or file is deleted */\n            if (mi)\n            {\n                hash_remove(m->inotify_watchers, (void *) (unsigned long) pevent->wd);\n                mi->inotify_watch = -1;\n            }\n        }\n        else\n        {\n            msg(D_MULTI_ERRORS, \"MULTI: unknown mask %d\", pevent->mask);\n        }\n    }\n}\n#endif /* ifdef ENABLE_ASYNC_PUSH */\n\n/*\n * Add a mbuf buffer to a particular\n * instance.\n */\nvoid\nmulti_add_mbuf(struct multi_context *m,\n               struct multi_instance *mi,\n               struct mbuf_buffer *mb)\n{\n    if (multi_output_queue_ready(m, mi))\n    {\n        struct mbuf_item item;\n        item.buffer = mb;\n        item.instance = mi;\n        mbuf_add_item(m->mbuf, &item);\n    }\n    else\n    {\n        msg(D_MULTI_DROPPED, \"MULTI: packet dropped due to output saturation (multi_add_mbuf)\");\n    }\n}\n\n/*\n * Add a packet to a client instance output queue.\n */\nstatic inline void\nmulti_unicast(struct multi_context *m,\n              const struct buffer *buf,\n              struct multi_instance *mi)\n{\n    struct mbuf_buffer *mb;\n\n    if (BLEN(buf) > 0)\n    {\n        mb = mbuf_alloc_buf(buf);\n        mb->flags = MF_UNICAST;\n        multi_add_mbuf(m, mi, mb);\n        mbuf_free_buf(mb);\n    }\n}\n\n/*\n * Broadcast a packet to all clients.\n */\nstatic void\nmulti_bcast(struct multi_context *m,\n            const struct buffer *buf,\n            const struct multi_instance *sender_instance,\n            const struct mroute_addr *sender_addr,\n            uint16_t vid)\n{\n    struct hash_iterator hi;\n    struct hash_element *he;\n    struct multi_instance *mi;\n    struct mbuf_buffer *mb;\n\n    if (BLEN(buf) > 0)\n    {\n        perf_push(PERF_MULTI_BCAST);\n#ifdef MULTI_DEBUG_EVENT_LOOP\n        printf(\"BCAST len=%d\\n\", BLEN(buf));\n#endif\n        mb = mbuf_alloc_buf(buf);\n        hash_iterator_init(m->iter, &hi);\n\n        while ((he = hash_iterator_next(&hi)))\n        {\n            mi = (struct multi_instance *) he->value;\n            if (mi != sender_instance && !mi->halt)\n            {\n#ifdef ENABLE_PF\n                if (sender_instance)\n                {\n                    if (!pf_c2c_test(&sender_instance->context.c2.pf,\n                                     sender_instance->context.c2.tls_multi,\n                                     &mi->context.c2.pf,\n                                     mi->context.c2.tls_multi,\n                                     \"bcast_c2c\"))\n                    {\n                        msg(D_PF_DROPPED_BCAST, \"PF: client[%s] -> client[%s] packet dropped by BCAST packet filter\",\n                            mi_prefix(sender_instance),\n                            mi_prefix(mi));\n                        continue;\n                    }\n                }\n                if (sender_addr)\n                {\n                    if (!pf_addr_test(&mi->context.c2.pf, &mi->context,\n                                      sender_addr, \"bcast_src_addr\"))\n                    {\n                        struct gc_arena gc = gc_new();\n                        msg(D_PF_DROPPED_BCAST, \"PF: addr[%s] -> client[%s] packet dropped by BCAST packet filter\",\n                            mroute_addr_print_ex(sender_addr, MAPF_SHOW_ARP, &gc),\n                            mi_prefix(mi));\n                        gc_free(&gc);\n                        continue;\n                    }\n                }\n#endif /* ifdef ENABLE_PF */\n                if (vid != 0 && vid != mi->context.options.vlan_pvid)\n                {\n                    continue;\n                }\n                multi_add_mbuf(m, mi, mb);\n            }\n        }\n\n        hash_iterator_free(&hi);\n        mbuf_free_buf(mb);\n        perf_pop();\n    }\n}\n\n/*\n * Given a time delta, indicating that we wish to be\n * awoken by the scheduler at time now + delta, figure\n * a sigma parameter (in microseconds) that represents\n * a sort of fuzz factor around delta, so that we're\n * really telling the scheduler to wake us up any time\n * between now + delta - sigma and now + delta + sigma.\n *\n * The sigma parameter helps the scheduler to run more efficiently.\n * Sigma should be no larger than TV_WITHIN_SIGMA_MAX_USEC\n */\nstatic inline unsigned int\ncompute_wakeup_sigma(const struct timeval *delta)\n{\n    if (delta->tv_sec < 1)\n    {\n        /* if < 1 sec, fuzz = # of microseconds / 8 */\n        return delta->tv_usec >> 3;\n    }\n    else\n    {\n        /* if < 10 minutes, fuzz = 13.1% of timeout */\n        if (delta->tv_sec < 600)\n        {\n            return delta->tv_sec << 17;\n        }\n        else\n        {\n            return 120000000; /* if >= 10 minutes, fuzz = 2 minutes */\n        }\n    }\n}\n\nstatic void\nmulti_schedule_context_wakeup(struct multi_context *m, struct multi_instance *mi)\n{\n    /* calculate an absolute wakeup time */\n    ASSERT(!openvpn_gettimeofday(&mi->wakeup, NULL));\n    tv_add(&mi->wakeup, &mi->context.c2.timeval);\n\n    /* tell scheduler to wake us up at some point in the future */\n    schedule_add_entry(m->schedule,\n                       (struct schedule_entry *) mi,\n                       &mi->wakeup,\n                       compute_wakeup_sigma(&mi->context.c2.timeval));\n}\n\n/*\n * Figure instance-specific timers, convert\n * earliest to absolute time in mi->wakeup,\n * call scheduler with our future wakeup time.\n *\n * Also close context on signal.\n */\nbool\nmulti_process_post(struct multi_context *m, struct multi_instance *mi, const unsigned int flags)\n{\n    bool ret = true;\n\n    if (!IS_SIG(&mi->context) && ((flags & MPP_PRE_SELECT) || ((flags & MPP_CONDITIONAL_PRE_SELECT) && !ANY_OUT(&mi->context))))\n    {\n#if defined(ENABLE_ASYNC_PUSH) && defined(ENABLE_DEF_AUTH)\n        bool was_authenticated = false;\n        struct key_state *ks = NULL;\n        if (mi->context.c2.tls_multi)\n        {\n            ks = &mi->context.c2.tls_multi->session[TM_ACTIVE].key[KS_PRIMARY];\n            was_authenticated = ks->authenticated;\n        }\n#endif\n\n        /* figure timeouts and fetch possible outgoing\n         * to_link packets (such as ping or TLS control) */\n        pre_select(&mi->context);\n\n#if defined(ENABLE_ASYNC_PUSH) && defined(ENABLE_DEF_AUTH)\n        if (ks && ks->auth_control_file && ks->auth_deferred && !was_authenticated)\n        {\n            /* watch acf file */\n            long watch_descriptor = inotify_add_watch(m->top.c2.inotify_fd, ks->auth_control_file, IN_CLOSE_WRITE | IN_ONESHOT);\n            if (watch_descriptor >= 0)\n            {\n                if (mi->inotify_watch != -1)\n                {\n                    hash_remove(m->inotify_watchers, (void *) (unsigned long)mi->inotify_watch);\n                }\n                hash_add(m->inotify_watchers, (const uintptr_t *)watch_descriptor, mi, true);\n                mi->inotify_watch = watch_descriptor;\n            }\n            else\n            {\n                msg(M_NONFATAL | M_ERRNO, \"MULTI: inotify_add_watch error\");\n            }\n        }\n#endif\n\n        if (!IS_SIG(&mi->context))\n        {\n            /* connection is \"established\" when SSL/TLS key negotiation succeeds\n             * and (if specified) auth user/pass succeeds */\n            if (!mi->connection_established_flag && CONNECTION_ESTABLISHED(&mi->context))\n            {\n                multi_connection_established(m, mi);\n            }\n\n            /* tell scheduler to wake us up at some point in the future */\n            multi_schedule_context_wakeup(m, mi);\n        }\n    }\n\n    if (IS_SIG(&mi->context))\n    {\n        if (flags & MPP_CLOSE_ON_SIGNAL)\n        {\n            multi_close_instance_on_signal(m, mi);\n            ret = false;\n        }\n    }\n    else\n    {\n        /* continue to pend on output? */\n        multi_set_pending(m, ANY_OUT(&mi->context) ? mi : NULL);\n\n#ifdef MULTI_DEBUG_EVENT_LOOP\n        printf(\"POST %s[%d] to=%d lo=%d/%d w=%\" PRIi64 \"/%ld\\n\",\n               id(mi),\n               (int) (mi == m->pending),\n               mi ? mi->context.c2.to_tun.len : -1,\n               mi ? mi->context.c2.to_link.len : -1,\n               (mi && mi->context.c2.fragment) ? mi->context.c2.fragment->outgoing.len : -1,\n               (int64_t)mi->context.c2.timeval.tv_sec,\n               (long)mi->context.c2.timeval.tv_usec);\n#endif\n    }\n\n    if ((flags & MPP_RECORD_TOUCH) && m->mpp_touched)\n    {\n        *m->mpp_touched = mi;\n    }\n\n    return ret;\n}\n\nvoid\nmulti_process_float(struct multi_context *m, struct multi_instance *mi)\n{\n    struct mroute_addr real;\n    struct hash *hash = m->hash;\n    struct gc_arena gc = gc_new();\n\n    if (!mroute_extract_openvpn_sockaddr(&real, &m->top.c2.from.dest, true))\n    {\n        goto done;\n    }\n\n    const uint32_t hv = hash_value(hash, &real);\n    struct hash_bucket *bucket = hash_bucket(hash, hv);\n\n    /* make sure that we don't float to an address taken by another client */\n    struct hash_element *he = hash_lookup_fast(hash, bucket, &real, hv);\n    if (he)\n    {\n        struct multi_instance *ex_mi = (struct multi_instance *) he->value;\n\n        struct tls_multi *m1 = mi->context.c2.tls_multi;\n        struct tls_multi *m2 = ex_mi->context.c2.tls_multi;\n\n        /* do not float if target address is taken by client with another cert */\n        if (!cert_hash_compare(m1->locked_cert_hash_set, m2->locked_cert_hash_set))\n        {\n            msg(D_MULTI_LOW, \"Disallow float to an address taken by another client %s\",\n                multi_instance_string(ex_mi, false, &gc));\n\n            mi->context.c2.buf.len = 0;\n\n            goto done;\n        }\n\n        msg(D_MULTI_MEDIUM, \"closing instance %s\", multi_instance_string(ex_mi, false, &gc));\n        multi_close_instance(m, ex_mi, false);\n    }\n\n    msg(D_MULTI_MEDIUM, \"peer %\" PRIu32 \" (%s) floated from %s to %s\",\n        mi->context.c2.tls_multi->peer_id,\n        tls_common_name(mi->context.c2.tls_multi, false),\n        mroute_addr_print(&mi->real, &gc),\n        print_link_socket_actual(&m->top.c2.from, &gc));\n\n    /* remove old address from hash table before changing address */\n    ASSERT(hash_remove(m->hash, &mi->real));\n    ASSERT(hash_remove(m->iter, &mi->real));\n\n    /* change external network address of the remote peer */\n    mi->real = real;\n    generate_prefix(mi);\n\n    mi->context.c2.from = m->top.c2.from;\n    mi->context.c2.to_link_addr = &mi->context.c2.from;\n\n    /* inherit parent link_socket and link_socket_info */\n    mi->context.c2.link_socket = m->top.c2.link_socket;\n    mi->context.c2.link_socket_info->lsa->actual = m->top.c2.from;\n\n    tls_update_remote_addr(mi->context.c2.tls_multi, &mi->context.c2.from);\n\n    ASSERT(hash_add(m->hash, &mi->real, mi, false));\n    ASSERT(hash_add(m->iter, &mi->real, mi, false));\n\n#ifdef MANAGEMENT_DEF_AUTH\n    ASSERT(hash_add(m->cid_hash, &mi->context.c2.mda_context.cid, mi, true));\n#endif\n\ndone:\n    gc_free(&gc);\n}\n\n/*\n * Process packets in the TCP/UDP socket -> TUN/TAP interface direction,\n * i.e. client -> server direction.\n */\nbool\nmulti_process_incoming_link(struct multi_context *m, struct multi_instance *instance, const unsigned int mpp_flags)\n{\n    struct gc_arena gc = gc_new();\n\n    struct context *c;\n    struct mroute_addr src, dest;\n    unsigned int mroute_flags;\n    struct multi_instance *mi;\n    bool ret = true;\n    bool floated = false;\n\n    if (m->pending)\n    {\n        return true;\n    }\n\n    if (!instance)\n    {\n#ifdef MULTI_DEBUG_EVENT_LOOP\n        printf(\"TCP/UDP -> TUN [%d]\\n\", BLEN(&m->top.c2.buf));\n#endif\n        multi_set_pending(m, multi_get_create_instance_udp(m, &floated));\n    }\n    else\n    {\n        multi_set_pending(m, instance);\n    }\n\n    if (m->pending)\n    {\n        set_prefix(m->pending);\n\n        /* get instance context */\n        c = &m->pending->context;\n\n        if (!instance)\n        {\n            /* transfer packet pointer from top-level context buffer to instance */\n            c->c2.buf = m->top.c2.buf;\n\n            /* transfer from-addr from top-level context buffer to instance */\n            if (!floated)\n            {\n                c->c2.from = m->top.c2.from;\n            }\n        }\n\n        if (BLEN(&c->c2.buf) > 0)\n        {\n            struct link_socket_info *lsi;\n            const uint8_t *orig_buf;\n\n            /* decrypt in instance context */\n\n            perf_push(PERF_PROC_IN_LINK);\n            lsi = get_link_socket_info(c);\n            orig_buf = c->c2.buf.data;\n            if (process_incoming_link_part1(c, lsi, floated))\n            {\n                /* nonzero length means that we have a valid, decrypted packed */\n                if (floated && c->c2.buf.len > 0)\n                {\n                    multi_process_float(m, m->pending);\n                }\n\n                process_incoming_link_part2(c, lsi, orig_buf);\n            }\n            perf_pop();\n\n            if (TUNNEL_TYPE(m->top.c1.tuntap) == DEV_TYPE_TUN)\n            {\n                /* extract packet source and dest addresses */\n                mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                               &dest,\n                                                               NULL,\n                                                               NULL,\n                                                               0,\n                                                               &c->c2.to_tun,\n                                                               DEV_TYPE_TUN);\n\n                /* drop packet if extract failed */\n                if (!(mroute_flags & MROUTE_EXTRACT_SUCCEEDED))\n                {\n                    c->c2.to_tun.len = 0;\n                }\n                /* make sure that source address is associated with this client */\n                else if (multi_get_instance_by_virtual_addr(m, &src, true) != m->pending)\n                {\n                    /* IPv6 link-local address (fe80::xxx)? */\n                    if ( (src.type & MR_ADDR_MASK) == MR_ADDR_IPV6\n                         && IN6_IS_ADDR_LINKLOCAL(&src.v6.addr) )\n                    {\n                        /* do nothing, for now.  TODO: add address learning */\n                    }\n                    else\n                    {\n                        msg(D_MULTI_DROPPED, \"MULTI: bad source address from client [%s], packet dropped\",\n                            mroute_addr_print(&src, &gc));\n                    }\n                    c->c2.to_tun.len = 0;\n                }\n                /* client-to-client communication enabled? */\n                else if (m->enable_c2c)\n                {\n                    /* multicast? */\n                    if (mroute_flags & MROUTE_EXTRACT_MCAST)\n                    {\n                        /* for now, treat multicast as broadcast */\n                        multi_bcast(m, &c->c2.to_tun, m->pending, NULL, 0);\n                    }\n                    else /* possible client to client routing */\n                    {\n                        ASSERT(!(mroute_flags & MROUTE_EXTRACT_BCAST));\n                        mi = multi_get_instance_by_virtual_addr(m, &dest, true);\n\n                        /* if dest addr is a known client, route to it */\n                        if (mi)\n                        {\n#ifdef ENABLE_PF\n                            if (!pf_c2c_test(&c->c2.pf, c->c2.tls_multi,\n                                             &mi->context.c2.pf,\n                                             mi->context.c2.tls_multi,\n                                             \"tun_c2c\"))\n                            {\n                                msg(D_PF_DROPPED, \"PF: client -> client[%s] packet dropped by TUN packet filter\",\n                                    mi_prefix(mi));\n                            }\n                            else\n#endif\n                            {\n                                multi_unicast(m, &c->c2.to_tun, mi);\n                                register_activity(c, BLEN(&c->c2.to_tun));\n                            }\n                            c->c2.to_tun.len = 0;\n                        }\n                    }\n                }\n#ifdef ENABLE_PF\n                if (c->c2.to_tun.len && !pf_addr_test(&c->c2.pf, c, &dest,\n                                                      \"tun_dest_addr\"))\n                {\n                    msg(D_PF_DROPPED, \"PF: client -> addr[%s] packet dropped by TUN packet filter\",\n                        mroute_addr_print_ex(&dest, MAPF_SHOW_ARP, &gc));\n                    c->c2.to_tun.len = 0;\n                }\n#endif\n            }\n            else if (TUNNEL_TYPE(m->top.c1.tuntap) == DEV_TYPE_TAP)\n            {\n                uint16_t vid = 0;\n#ifdef ENABLE_PF\n                struct mroute_addr edest;\n                mroute_addr_reset(&edest);\n#endif\n\n                if (m->top.options.vlan_tagging)\n                {\n                    if (vlan_is_tagged(&c->c2.to_tun))\n                    {\n                        /* Drop VLAN-tagged frame. */\n                        msg(D_VLAN_DEBUG, \"dropping incoming VLAN-tagged frame\");\n                        c->c2.to_tun.len = 0;\n                    }\n                    else\n                    {\n                        vid = c->options.vlan_pvid;\n                    }\n                }\n                /* extract packet source and dest addresses */\n                mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                               &dest,\n                                                               NULL,\n#ifdef ENABLE_PF\n                                                               &edest,\n#else\n                                                               NULL,\n#endif\n                                                               vid,\n                                                               &c->c2.to_tun,\n                                                               DEV_TYPE_TAP);\n\n                if (mroute_flags & MROUTE_EXTRACT_SUCCEEDED)\n                {\n                    if (multi_learn_addr(m, m->pending, &src, 0) == m->pending)\n                    {\n                        /* check for broadcast */\n                        if (m->enable_c2c)\n                        {\n                            if (mroute_flags & (MROUTE_EXTRACT_BCAST|MROUTE_EXTRACT_MCAST))\n                            {\n                                multi_bcast(m, &c->c2.to_tun, m->pending, NULL,\n                                            vid);\n                            }\n                            else /* try client-to-client routing */\n                            {\n                                mi = multi_get_instance_by_virtual_addr(m, &dest, false);\n\n                                /* if dest addr is a known client, route to it */\n                                if (mi)\n                                {\n#ifdef ENABLE_PF\n                                    if (!pf_c2c_test(&c->c2.pf, c->c2.tls_multi,\n                                                     &mi->context.c2.pf,\n                                                     mi->context.c2.tls_multi,\n                                                     \"tap_c2c\"))\n                                    {\n                                        msg(D_PF_DROPPED, \"PF: client -> client[%s] packet dropped by TAP packet filter\",\n                                            mi_prefix(mi));\n                                    }\n                                    else\n#endif\n                                    {\n                                        multi_unicast(m, &c->c2.to_tun, mi);\n                                        register_activity(c, BLEN(&c->c2.to_tun));\n                                    }\n                                    c->c2.to_tun.len = 0;\n                                }\n                            }\n                        }\n#ifdef ENABLE_PF\n                        if (c->c2.to_tun.len && !pf_addr_test(&c->c2.pf, c,\n                                                              &edest,\n                                                              \"tap_dest_addr\"))\n                        {\n                            msg(D_PF_DROPPED, \"PF: client -> addr[%s] packet dropped by TAP packet filter\",\n                                mroute_addr_print_ex(&edest, MAPF_SHOW_ARP, &gc));\n                            c->c2.to_tun.len = 0;\n                        }\n#endif\n                    }\n                    else\n                    {\n                        msg(D_MULTI_DROPPED, \"MULTI: bad source address from client [%s], packet dropped\",\n                            mroute_addr_print(&src, &gc));\n                        c->c2.to_tun.len = 0;\n                    }\n                }\n                else\n                {\n                    c->c2.to_tun.len = 0;\n                }\n            }\n        }\n\n        /* postprocess and set wakeup */\n        ret = multi_process_post(m, m->pending, mpp_flags);\n\n        clear_prefix();\n    }\n\n    gc_free(&gc);\n    return ret;\n}\n\n/*\n * Process packets in the TUN/TAP interface -> TCP/UDP socket direction,\n * i.e. server -> client direction.\n */\nbool\nmulti_process_incoming_tun(struct multi_context *m, const unsigned int mpp_flags)\n{\n    struct gc_arena gc = gc_new();\n    bool ret = true;\n\n    if (BLEN(&m->top.c2.buf) > 0)\n    {\n        unsigned int mroute_flags;\n        struct mroute_addr src, dest;\n        const int dev_type = TUNNEL_TYPE(m->top.c1.tuntap);\n        int16_t vid = 0;\n\n#ifdef ENABLE_PF\n        struct mroute_addr esrc, *e1, *e2;\n        if (dev_type == DEV_TYPE_TUN)\n        {\n            e1 = NULL;\n            e2 = &src;\n        }\n        else\n        {\n            e1 = e2 = &esrc;\n            mroute_addr_reset(&esrc);\n        }\n#endif\n\n#ifdef MULTI_DEBUG_EVENT_LOOP\n        printf(\"TUN -> TCP/UDP [%d]\\n\", BLEN(&m->top.c2.buf));\n#endif\n\n        if (m->pending)\n        {\n            return true;\n        }\n\n        if (dev_type == DEV_TYPE_TAP && m->top.options.vlan_tagging)\n        {\n            vid = vlan_decapsulate(&m->top, &m->top.c2.buf);\n            if (vid < 0)\n            {\n                return false;\n            }\n        }\n\n        /*\n         * Route an incoming tun/tap packet to\n         * the appropriate multi_instance object.\n         */\n\n        mroute_flags = mroute_extract_addr_from_packet(&src,\n                                                       &dest,\n#ifdef ENABLE_PF\n                                                       e1,\n#else\n                                                       NULL,\n#endif\n                                                       NULL,\n                                                       vid,\n                                                       &m->top.c2.buf,\n                                                       dev_type);\n\n        if (mroute_flags & MROUTE_EXTRACT_SUCCEEDED)\n        {\n            struct context *c;\n\n            /* broadcast or multicast dest addr? */\n            if (mroute_flags & (MROUTE_EXTRACT_BCAST|MROUTE_EXTRACT_MCAST))\n            {\n                /* for now, treat multicast as broadcast */\n#ifdef ENABLE_PF\n                multi_bcast(m, &m->top.c2.buf, NULL, e2, vid);\n#else\n                multi_bcast(m, &m->top.c2.buf, NULL, NULL, vid);\n#endif\n            }\n            else\n            {\n                multi_set_pending(m, multi_get_instance_by_virtual_addr(m, &dest, dev_type == DEV_TYPE_TUN));\n\n                if (m->pending)\n                {\n                    /* get instance context */\n                    c = &m->pending->context;\n\n                    set_prefix(m->pending);\n\n#ifdef ENABLE_PF\n                    if (!pf_addr_test(&c->c2.pf, c, e2, \"tun_tap_src_addr\"))\n                    {\n                        msg(D_PF_DROPPED, \"PF: addr[%s] -> client packet dropped by packet filter\",\n                            mroute_addr_print_ex(&src, MAPF_SHOW_ARP, &gc));\n                        buf_reset_len(&c->c2.buf);\n                    }\n                    else\n#endif\n                    {\n                        if (multi_output_queue_ready(m, m->pending))\n                        {\n                            /* transfer packet pointer from top-level context buffer to instance */\n                            c->c2.buf = m->top.c2.buf;\n                        }\n                        else\n                        {\n                            /* drop packet */\n                            msg(D_MULTI_DROPPED, \"MULTI: packet dropped due to output saturation (multi_process_incoming_tun)\");\n                            buf_reset_len(&c->c2.buf);\n                        }\n                    }\n\n                    /* encrypt in instance context */\n                    process_incoming_tun(c);\n\n                    /* postprocess and set wakeup */\n                    ret = multi_process_post(m, m->pending, mpp_flags);\n\n                    clear_prefix();\n                }\n            }\n        }\n    }\n    gc_free(&gc);\n    return ret;\n}\n\n/*\n * Process a possible client-to-client/bcast/mcast message in the\n * queue.\n */\nstruct multi_instance *\nmulti_get_queue(struct mbuf_set *ms)\n{\n    struct mbuf_item item;\n\n    if (mbuf_extract_item(ms, &item)) /* cleartext IP packet */\n    {\n        unsigned int pip_flags = PIPV4_PASSTOS | PIPV6_IMCP_NOHOST_SERVER;\n\n        set_prefix(item.instance);\n        item.instance->context.c2.buf = item.buffer->buf;\n        if (item.buffer->flags & MF_UNICAST) /* --mssfix doesn't make sense for broadcast or multicast */\n        {\n            pip_flags |= PIP_MSSFIX;\n        }\n        process_ip_header(&item.instance->context, pip_flags, &item.instance->context.c2.buf);\n        encrypt_sign(&item.instance->context, true);\n        mbuf_free_buf(item.buffer);\n\n        dmsg(D_MULTI_DEBUG, \"MULTI: C2C/MCAST/BCAST\");\n\n        clear_prefix();\n        return item.instance;\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\n/*\n * Called when an I/O wait times out.  Usually means that a particular\n * client instance object needs timer-based service.\n */\nbool\nmulti_process_timeout(struct multi_context *m, const unsigned int mpp_flags)\n{\n    bool ret = true;\n\n#ifdef MULTI_DEBUG_EVENT_LOOP\n    printf(\"%s -> TIMEOUT\\n\", id(m->earliest_wakeup));\n#endif\n\n    /* instance marked for wakeup? */\n    if (m->earliest_wakeup)\n    {\n        if (m->earliest_wakeup == (struct multi_instance *)&m->deferred_shutdown_signal)\n        {\n            schedule_remove_entry(m->schedule, (struct schedule_entry *) &m->deferred_shutdown_signal);\n            throw_signal(m->deferred_shutdown_signal.signal_received);\n        }\n        else\n        {\n            set_prefix(m->earliest_wakeup);\n            ret = multi_process_post(m, m->earliest_wakeup, mpp_flags);\n            clear_prefix();\n        }\n        m->earliest_wakeup = NULL;\n    }\n    return ret;\n}\n\n/*\n * Drop a TUN/TAP outgoing packet..\n */\nvoid\nmulti_process_drop_outgoing_tun(struct multi_context *m, const unsigned int mpp_flags)\n{\n    struct multi_instance *mi = m->pending;\n\n    ASSERT(mi);\n\n    set_prefix(mi);\n\n    msg(D_MULTI_ERRORS, \"MULTI: Outgoing TUN queue full, dropped packet len=%d\",\n        mi->context.c2.to_tun.len);\n\n    buf_reset(&mi->context.c2.to_tun);\n\n    multi_process_post(m, mi, mpp_flags);\n    clear_prefix();\n}\n\n/*\n * Per-client route quota management\n */\n\nvoid\nroute_quota_exceeded(const struct multi_instance *mi)\n{\n    struct gc_arena gc = gc_new();\n    msg(D_ROUTE_QUOTA, \"MULTI ROUTE: route quota (%d) exceeded for %s (see --max-routes-per-client option)\",\n        mi->context.options.max_routes_per_client,\n        multi_instance_string(mi, false, &gc));\n    gc_free(&gc);\n}\n\n#ifdef ENABLE_DEBUG\n/*\n * Flood clients with random packets\n */\nstatic void\ngremlin_flood_clients(struct multi_context *m)\n{\n    const int level = GREMLIN_PACKET_FLOOD_LEVEL(m->top.options.gremlin);\n    if (level)\n    {\n        struct gc_arena gc = gc_new();\n        struct buffer buf = alloc_buf_gc(BUF_SIZE(&m->top.c2.frame), &gc);\n        struct packet_flood_parms parm = get_packet_flood_parms(level);\n        int i;\n\n        ASSERT(buf_init(&buf, FRAME_HEADROOM(&m->top.c2.frame)));\n        parm.packet_size = min_int(parm.packet_size, MAX_RW_SIZE_TUN(&m->top.c2.frame));\n\n        msg(D_GREMLIN, \"GREMLIN_FLOOD_CLIENTS: flooding clients with %d packets of size %d\",\n            parm.n_packets,\n            parm.packet_size);\n\n        for (i = 0; i < parm.packet_size; ++i)\n        {\n            ASSERT(buf_write_u8(&buf, get_random() & 0xFF));\n        }\n\n        for (i = 0; i < parm.n_packets; ++i)\n        {\n            multi_bcast(m, &buf, NULL, NULL, 0);\n        }\n\n        gc_free(&gc);\n    }\n}\n#endif /* ifdef ENABLE_DEBUG */\n\nstatic bool\nstale_route_check_trigger(struct multi_context *m)\n{\n    struct timeval null;\n    CLEAR(null);\n    return event_timeout_trigger(&m->stale_routes_check_et, &null, ETT_DEFAULT);\n}\n\n/*\n * Process timers in the top-level context\n */\nvoid\nmulti_process_per_second_timers_dowork(struct multi_context *m)\n{\n    /* possibly reap instances/routes in vhash */\n    multi_reap_process(m);\n\n    /* possibly print to status log */\n    if (m->top.c1.status_output)\n    {\n        if (status_trigger(m->top.c1.status_output))\n        {\n            multi_print_status(m, m->top.c1.status_output, m->status_file_version);\n        }\n    }\n\n    /* possibly flush ifconfig-pool file */\n    multi_ifconfig_pool_persist(m, false);\n\n#ifdef ENABLE_DEBUG\n    gremlin_flood_clients(m);\n#endif\n\n    /* Should we check for stale routes? */\n    if (m->top.options.stale_routes_check_interval && stale_route_check_trigger(m))\n    {\n        check_stale_routes(m);\n    }\n}\n\nvoid\nmulti_top_init(struct multi_context *m, const struct context *top)\n{\n    inherit_context_top(&m->top, top);\n    m->top.c2.buffers = init_context_buffers(&top->c2.frame);\n}\n\nvoid\nmulti_top_free(struct multi_context *m)\n{\n    close_context(&m->top, -1, CC_GC_FREE);\n    free_context_buffers(m->top.c2.buffers);\n}\n\nstatic bool\nis_exit_restart(int sig)\n{\n    return (sig == SIGUSR1 || sig == SIGTERM || sig == SIGHUP || sig == SIGINT);\n}\n\nstatic void\nmulti_push_restart_schedule_exit(struct multi_context *m, bool next_server)\n{\n    struct hash_iterator hi;\n    struct hash_element *he;\n    struct timeval tv;\n\n    /* tell all clients to restart */\n    hash_iterator_init(m->iter, &hi);\n    while ((he = hash_iterator_next(&hi)))\n    {\n        struct multi_instance *mi = (struct multi_instance *) he->value;\n        if (!mi->halt)\n        {\n            send_control_channel_string(&mi->context, next_server ? \"RESTART,[N]\" : \"RESTART\", D_PUSH);\n            multi_schedule_context_wakeup(m, mi);\n        }\n    }\n    hash_iterator_free(&hi);\n\n    /* reschedule signal */\n    ASSERT(!openvpn_gettimeofday(&m->deferred_shutdown_signal.wakeup, NULL));\n    tv.tv_sec = 2;\n    tv.tv_usec = 0;\n    tv_add(&m->deferred_shutdown_signal.wakeup, &tv);\n\n    m->deferred_shutdown_signal.signal_received = m->top.sig->signal_received;\n\n    schedule_add_entry(m->schedule,\n                       (struct schedule_entry *) &m->deferred_shutdown_signal,\n                       &m->deferred_shutdown_signal.wakeup,\n                       compute_wakeup_sigma(&m->deferred_shutdown_signal.wakeup));\n\n    m->top.sig->signal_received = 0;\n}\n\n/*\n * Return true if event loop should break,\n * false if it should continue.\n */\nbool\nmulti_process_signal(struct multi_context *m)\n{\n    if (m->top.sig->signal_received == SIGUSR2)\n    {\n        struct status_output *so = status_open(NULL, 0, M_INFO, NULL, 0);\n        multi_print_status(m, so, m->status_file_version);\n        status_close(so);\n        m->top.sig->signal_received = 0;\n        return false;\n    }\n    else if (proto_is_dgram(m->top.options.ce.proto)\n             && is_exit_restart(m->top.sig->signal_received)\n             && (m->deferred_shutdown_signal.signal_received == 0)\n             && m->top.options.ce.explicit_exit_notification != 0)\n    {\n        multi_push_restart_schedule_exit(m, m->top.options.ce.explicit_exit_notification == 2);\n        return false;\n    }\n    return true;\n}\n\n/*\n * Called when an instance should be closed due to the\n * reception of a soft signal.\n */\nvoid\nmulti_close_instance_on_signal(struct multi_context *m, struct multi_instance *mi)\n{\n    remap_signal(&mi->context);\n    set_prefix(mi);\n    print_signal(mi->context.sig, \"client-instance\", D_MULTI_LOW);\n    clear_prefix();\n    multi_close_instance(m, mi, false);\n}\n\nstatic void\nmulti_signal_instance(struct multi_context *m, struct multi_instance *mi, const int sig)\n{\n    mi->context.sig->signal_received = sig;\n    multi_close_instance_on_signal(m, mi);\n}\n\n/*\n * Management subsystem callbacks\n */\n\n#ifdef ENABLE_MANAGEMENT\n\nstatic void\nmanagement_callback_status(void *arg, const int version, struct status_output *so)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n\n    if (!version)\n    {\n        multi_print_status(m, so, m->status_file_version);\n    }\n    else\n    {\n        multi_print_status(m, so, version);\n    }\n}\n\nstatic int\nmanagement_callback_n_clients(void *arg)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    return m->n_clients;\n}\n\nstatic int\nmanagement_callback_kill_by_cn(void *arg, const char *del_cn)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct hash_iterator hi;\n    struct hash_element *he;\n    int count = 0;\n\n    hash_iterator_init(m->iter, &hi);\n    while ((he = hash_iterator_next(&hi)))\n    {\n        struct multi_instance *mi = (struct multi_instance *) he->value;\n        if (!mi->halt)\n        {\n            const char *cn = tls_common_name(mi->context.c2.tls_multi, false);\n            if (cn && !strcmp(cn, del_cn))\n            {\n                multi_signal_instance(m, mi, SIGTERM);\n                ++count;\n            }\n        }\n    }\n    hash_iterator_free(&hi);\n    return count;\n}\n\nstatic int\nmanagement_callback_kill_by_addr(void *arg, const in_addr_t addr, const int port)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct hash_iterator hi;\n    struct hash_element *he;\n    struct openvpn_sockaddr saddr;\n    struct mroute_addr maddr;\n    int count = 0;\n\n    CLEAR(saddr);\n    saddr.addr.in4.sin_family = AF_INET;\n    saddr.addr.in4.sin_addr.s_addr = htonl(addr);\n    saddr.addr.in4.sin_port = htons(port);\n    if (mroute_extract_openvpn_sockaddr(&maddr, &saddr, true))\n    {\n        hash_iterator_init(m->iter, &hi);\n        while ((he = hash_iterator_next(&hi)))\n        {\n            struct multi_instance *mi = (struct multi_instance *) he->value;\n            if (!mi->halt && mroute_addr_equal(&maddr, &mi->real))\n            {\n                multi_signal_instance(m, mi, SIGTERM);\n                ++count;\n            }\n        }\n        hash_iterator_free(&hi);\n    }\n    return count;\n}\n\nstatic void\nmanagement_delete_event(void *arg, event_t event)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    if (m->mtcp)\n    {\n        multi_tcp_delete_event(m->mtcp, event);\n    }\n}\n\n#endif /* ifdef ENABLE_MANAGEMENT */\n\n#ifdef MANAGEMENT_DEF_AUTH\n\nstatic struct multi_instance *\nlookup_by_cid(struct multi_context *m, const unsigned long cid)\n{\n    if (m)\n    {\n        struct multi_instance *mi = (struct multi_instance *) hash_lookup(m->cid_hash, &cid);\n        if (mi && !mi->halt)\n        {\n            return mi;\n        }\n    }\n    return NULL;\n}\n\nstatic bool\nmanagement_kill_by_cid(void *arg, const unsigned long cid, const char *kill_msg)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct multi_instance *mi = lookup_by_cid(m, cid);\n    if (mi)\n    {\n        send_restart(&mi->context, kill_msg); /* was: multi_signal_instance (m, mi, SIGTERM); */\n        multi_schedule_context_wakeup(m, mi);\n        return true;\n    }\n    else\n    {\n        return false;\n    }\n}\n\nstatic bool\nmanagement_client_auth(void *arg,\n                       const unsigned long cid,\n                       const unsigned int mda_key_id,\n                       const bool auth,\n                       const char *reason,\n                       const char *client_reason,\n                       struct buffer_list *cc_config)  /* ownership transferred */\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct multi_instance *mi = lookup_by_cid(m, cid);\n    bool cc_config_owned = true;\n    bool ret = false;\n\n    if (mi)\n    {\n        ret = tls_authenticate_key(mi->context.c2.tls_multi, mda_key_id, auth, client_reason);\n        if (ret)\n        {\n            if (auth)\n            {\n                if (!mi->connection_established_flag)\n                {\n                    set_cc_config(mi, cc_config);\n                    cc_config_owned = false;\n                }\n            }\n            else\n            {\n                if (reason)\n                {\n                    msg(D_MULTI_LOW, \"MULTI: connection rejected: %s, CLI:%s\", reason, np(client_reason));\n                }\n                if (mi->connection_established_flag)\n                {\n                    send_auth_failed(&mi->context, client_reason); /* mid-session reauth failed */\n                    multi_schedule_context_wakeup(m, mi);\n                }\n            }\n        }\n    }\n    if (cc_config_owned && cc_config)\n    {\n        buffer_list_free(cc_config);\n    }\n    return ret;\n}\n\nstatic char *\nmanagement_get_peer_info(void *arg, const unsigned long cid)\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct multi_instance *mi = lookup_by_cid(m, cid);\n    char *ret = NULL;\n\n    if (mi)\n    {\n        ret = tls_get_peer_info(mi->context.c2.tls_multi);\n    }\n\n    return ret;\n}\n\n#endif /* ifdef MANAGEMENT_DEF_AUTH */\n\n#ifdef MANAGEMENT_PF\nstatic bool\nmanagement_client_pf(void *arg,\n                     const unsigned long cid,\n                     struct buffer_list *pf_config)  /* ownership transferred */\n{\n    struct multi_context *m = (struct multi_context *) arg;\n    struct multi_instance *mi = lookup_by_cid(m, cid);\n    bool ret = false;\n\n    if (mi && pf_config)\n    {\n        ret = pf_load_from_buffer_list(&mi->context, pf_config);\n    }\n\n    if (pf_config)\n    {\n        buffer_list_free(pf_config);\n    }\n    return ret;\n}\n#endif /* ifdef MANAGEMENT_PF */\n\nvoid\ninit_management_callback_multi(struct multi_context *m)\n{\n#ifdef ENABLE_MANAGEMENT\n    if (management)\n    {\n        struct management_callback cb;\n        CLEAR(cb);\n        cb.arg = m;\n        cb.flags = MCF_SERVER;\n        cb.status = management_callback_status;\n        cb.show_net = management_show_net_callback;\n        cb.kill_by_cn = management_callback_kill_by_cn;\n        cb.kill_by_addr = management_callback_kill_by_addr;\n        cb.delete_event = management_delete_event;\n        cb.n_clients = management_callback_n_clients;\n#ifdef MANAGEMENT_DEF_AUTH\n        cb.kill_by_cid = management_kill_by_cid;\n        cb.client_auth = management_client_auth;\n        cb.get_peer_info = management_get_peer_info;\n#endif\n#ifdef MANAGEMENT_PF\n        cb.client_pf = management_client_pf;\n#endif\n        management_set_callback(management, &cb);\n    }\n#endif /* ifdef ENABLE_MANAGEMENT */\n}\n\n/*\n * Top level event loop.\n */\nvoid\ntunnel_server(struct context *top)\n{\n    ASSERT(top->options.mode == MODE_SERVER);\n\n    if (proto_is_dgram(top->options.ce.proto))\n    {\n        tunnel_server_udp(top);\n    }\n    else\n    {\n        tunnel_server_tcp(top);\n    }\n}\n\n#else  /* if P2MP_SERVER */\nstatic void\ndummy(void)\n{\n}\n#endif /* P2MP_SERVER */\n"], "filenames": ["src/openvpn/multi.c"], "buggy_code_start_loc": [2580], "buggy_code_end_loc": [2581], "fixing_code_start_loc": [2580], "fixing_code_end_loc": [2582], "type": "CWE-362", "message": "An issue was discovered in OpenVPN 2.4.x before 2.4.9. An attacker can inject a data channel v2 (P_DATA_V2) packet using a victim's peer-id. Normally such packets are dropped, but if this packet arrives before the data channel crypto parameters have been initialized, the victim's connection will be dropped. This requires careful timing due to the small time window (usually within a few seconds) between the victim client connection starting and the server PUSH_REPLY response back to the client. This attack will only work if Negotiable Cipher Parameters (NCP) is in use.", "other": {"cve": {"id": "CVE-2020-11810", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-27T15:15:12.407", "lastModified": "2022-05-12T20:14:32.207", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in OpenVPN 2.4.x before 2.4.9. An attacker can inject a data channel v2 (P_DATA_V2) packet using a victim's peer-id. Normally such packets are dropped, but if this packet arrives before the data channel crypto parameters have been initialized, the victim's connection will be dropped. This requires careful timing due to the small time window (usually within a few seconds) between the victim client connection starting and the server PUSH_REPLY response back to the client. This attack will only work if Negotiable Cipher Parameters (NCP) is in use."}, {"lang": "es", "value": "Se detect\u00f3 un problema en OpenVPN versiones 2.4.x versiones anteriores a 2.4.9. Un atacante puede inyectar un paquete de canal de datos v2 (P_DATA_V2) usando el peer-id de la v\u00edctima. Normalmente, estos paquetes son eliminados, pero si este paquete llega antes de que se hayan inicializado los par\u00e1metros de cifrado del canal de datos, se eliminar\u00e1 la conexi\u00f3n de la v\u00edctima. Esto requiere una sincronizaci\u00f3n cuidadosa debido a una peque\u00f1a ventana de tiempo (normalmente unos pocos segundos) entre el inicio de la conexi\u00f3n del cliente v\u00edctima y la respuesta PUSH_REPLY del servidor al cliente. Este ataque s\u00f3lo funcionar\u00e1 si Negotiable Cipher Parameters (NCP) est\u00e1 en uso."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openvpn:openvpn:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.9", "matchCriteriaId": "3D4C2FC1-8BC0-4588-85C3-FC6D3B84D3F6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}], "references": [{"url": "https://bugzilla.suse.com/show_bug.cgi?id=1169925", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://community.openvpn.net/openvpn/ticket/1272", "source": "cve@mitre.org", "tags": ["Exploit", "Vendor Advisory"]}, {"url": "https://github.com/OpenVPN/openvpn/commit/37bc691e7d26ea4eb61a8a434ebd7a9ae76225ab", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00002.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FGHHV4YZANZW45KZTJJGVGPFMSXYRCKZ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/JII7RYYYRBPQNEGGVSOXCM7JUZ43T3VH/", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://patchwork.openvpn.net/patch/1079/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2020-11810", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/OpenVPN/openvpn/commit/37bc691e7d26ea4eb61a8a434ebd7a9ae76225ab"}}