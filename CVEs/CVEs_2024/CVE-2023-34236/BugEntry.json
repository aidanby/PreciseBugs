{"buggy_code": ["package runner\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"reflect\"\n\n\tinfrav1 \"github.com/weaveworks/tf-controller/api/v1alpha2\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\tctrl \"sigs.k8s.io/controller-runtime\"\n)\n\nfunc (r *TerraformRunnerServer) Output(ctx context.Context, req *OutputRequest) (*OutputReply, error) {\n\tlog := ctrl.LoggerFrom(ctx, \"instance-id\", r.InstanceID).WithName(loggerName)\n\tlog.Info(\"creating outputs\")\n\tif req.TfInstance != r.InstanceID {\n\t\terr := fmt.Errorf(\"no TF instance found\")\n\t\tlog.Error(err, \"no terraform\")\n\t\treturn nil, err\n\t}\n\n\toutputs, err := r.tf.Output(ctx)\n\tif err != nil {\n\t\tlog.Error(err, \"unable to get outputs\")\n\t\treturn nil, err\n\t}\n\n\toutputReply := &OutputReply{Outputs: map[string]*OutputMeta{}}\n\tfor k, v := range outputs {\n\t\toutputReply.Outputs[k] = &OutputMeta{\n\t\t\tSensitive: v.Sensitive,\n\t\t\tType:      v.Type,\n\t\t\tValue:     v.Value,\n\t\t}\n\t}\n\treturn outputReply, nil\n}\n\nfunc (r *TerraformRunnerServer) WriteOutputs(ctx context.Context, req *WriteOutputsRequest) (*WriteOutputsReply, error) {\n\tlog := ctrl.LoggerFrom(ctx, \"instance-id\", r.InstanceID).WithName(loggerName)\n\tlog.Info(\"write outputs to secret\")\n\n\tobjectKey := types.NamespacedName{Namespace: req.Namespace, Name: req.SecretName}\n\tvar outputSecret corev1.Secret\n\n\tdrift := true\n\tcreate := true\n\tif err := r.Client.Get(ctx, objectKey, &outputSecret); err == nil {\n\t\t// if everything is there, we don't write anything\n\t\tif reflect.DeepEqual(outputSecret.Data, req.Data) {\n\t\t\tdrift = false\n\t\t} else {\n\t\t\t// found, but need update\n\t\t\tcreate = false\n\t\t}\n\t} else if apierrors.IsNotFound(err) == false {\n\t\tlog.Error(err, \"unable to get output secret\")\n\t\treturn nil, err\n\t}\n\n\tif drift {\n\t\tif create {\n\t\t\tvTrue := true\n\t\t\toutputSecret = corev1.Secret{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:        req.SecretName,\n\t\t\t\t\tNamespace:   req.Namespace,\n\t\t\t\t\tLabels:      req.Labels,\n\t\t\t\t\tAnnotations: req.Annotations,\n\t\t\t\t\tOwnerReferences: []metav1.OwnerReference{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAPIVersion: infrav1.GroupVersion.Group + \"/\" + infrav1.GroupVersion.Version,\n\t\t\t\t\t\t\tKind:       infrav1.TerraformKind,\n\t\t\t\t\t\t\tName:       req.Name,\n\t\t\t\t\t\t\tUID:        types.UID(req.Uuid),\n\t\t\t\t\t\t\tController: &vTrue,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tType: corev1.SecretTypeOpaque,\n\t\t\t\tData: req.Data,\n\t\t\t}\n\n\t\t\terr := r.Client.Create(ctx, &outputSecret)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(err, \"unable to create secret\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\toutputSecret.Data = req.Data\n\t\t\terr := r.Client.Update(ctx, &outputSecret)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(err, \"unable to update secret\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\treturn &WriteOutputsReply{Message: \"ok\", Changed: true}, nil\n\t}\n\n\treturn &WriteOutputsReply{Message: \"ok\", Changed: false}, nil\n}\n\nfunc (r *TerraformRunnerServer) GetOutputs(ctx context.Context, req *GetOutputsRequest) (*GetOutputsReply, error) {\n\tlog := ctrl.LoggerFrom(ctx, \"instance-id\", r.InstanceID).WithName(loggerName)\n\tlog.Info(\"get outputs\")\n\toutputKey := types.NamespacedName{Namespace: req.Namespace, Name: req.SecretName}\n\toutputSecret := corev1.Secret{}\n\terr := r.Client.Get(ctx, outputKey, &outputSecret)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"error getting terraform output for health checks: %s\", err)\n\t\tlog.Error(err, \"unable to check terraform health\")\n\t\treturn nil, err\n\t}\n\n\toutputs := map[string]string{}\n\t// parse map[string][]byte to map[string]string for go template parsing\n\tif len(outputSecret.Data) > 0 {\n\t\tfor k, v := range outputSecret.Data {\n\t\t\toutputs[k] = string(v)\n\t\t}\n\t}\n\n\treturn &GetOutputsReply{Outputs: outputs}, nil\n}\n"], "fixing_code": ["package runner\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\n\t\"github.com/hashicorp/terraform-exec/tfexec\"\n\tinfrav1 \"github.com/weaveworks/tf-controller/api/v1alpha2\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tapierrors \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\tctrl \"sigs.k8s.io/controller-runtime\"\n)\n\nfunc (r *TerraformRunnerServer) tfOutput(ctx context.Context, opts ...tfexec.OutputOption) (map[string]tfexec.OutputMeta, error) {\n\tlog := ctrl.LoggerFrom(ctx, \"instance-id\", r.InstanceID).WithName(loggerName)\n\n\t// This is the only place where we disable the logger\n\tr.tf.SetStdout(io.Discard)\n\tr.tf.SetStderr(io.Discard)\n\n\tdefer r.initLogger(log)\n\n\treturn r.tf.Output(ctx, opts...)\n}\n\nfunc (r *TerraformRunnerServer) Output(ctx context.Context, req *OutputRequest) (*OutputReply, error) {\n\tlog := ctrl.LoggerFrom(ctx, \"instance-id\", r.InstanceID).WithName(loggerName)\n\tlog.Info(\"creating outputs\")\n\tif req.TfInstance != r.InstanceID {\n\t\terr := fmt.Errorf(\"no TF instance found\")\n\t\tlog.Error(err, \"no terraform\")\n\t\treturn nil, err\n\t}\n\n\toutputs, err := r.tfOutput(ctx)\n\tif err != nil {\n\t\tlog.Error(err, \"unable to get outputs\")\n\t\treturn nil, err\n\t}\n\n\toutputReply := &OutputReply{Outputs: map[string]*OutputMeta{}}\n\tfor k, v := range outputs {\n\t\toutputReply.Outputs[k] = &OutputMeta{\n\t\t\tSensitive: v.Sensitive,\n\t\t\tType:      v.Type,\n\t\t\tValue:     v.Value,\n\t\t}\n\t}\n\treturn outputReply, nil\n}\n\nfunc (r *TerraformRunnerServer) WriteOutputs(ctx context.Context, req *WriteOutputsRequest) (*WriteOutputsReply, error) {\n\tlog := ctrl.LoggerFrom(ctx, \"instance-id\", r.InstanceID).WithName(loggerName)\n\tlog.Info(\"write outputs to secret\")\n\n\tobjectKey := types.NamespacedName{Namespace: req.Namespace, Name: req.SecretName}\n\tvar outputSecret corev1.Secret\n\n\tdrift := true\n\tcreate := true\n\tif err := r.Client.Get(ctx, objectKey, &outputSecret); err == nil {\n\t\t// if everything is there, we don't write anything\n\t\tif reflect.DeepEqual(outputSecret.Data, req.Data) {\n\t\t\tdrift = false\n\t\t} else {\n\t\t\t// found, but need update\n\t\t\tcreate = false\n\t\t}\n\t} else if apierrors.IsNotFound(err) == false {\n\t\tlog.Error(err, \"unable to get output secret\")\n\t\treturn nil, err\n\t}\n\n\tif drift {\n\t\tif create {\n\t\t\tvTrue := true\n\t\t\toutputSecret = corev1.Secret{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName:        req.SecretName,\n\t\t\t\t\tNamespace:   req.Namespace,\n\t\t\t\t\tLabels:      req.Labels,\n\t\t\t\t\tAnnotations: req.Annotations,\n\t\t\t\t\tOwnerReferences: []metav1.OwnerReference{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAPIVersion: infrav1.GroupVersion.Group + \"/\" + infrav1.GroupVersion.Version,\n\t\t\t\t\t\t\tKind:       infrav1.TerraformKind,\n\t\t\t\t\t\t\tName:       req.Name,\n\t\t\t\t\t\t\tUID:        types.UID(req.Uuid),\n\t\t\t\t\t\t\tController: &vTrue,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tType: corev1.SecretTypeOpaque,\n\t\t\t\tData: req.Data,\n\t\t\t}\n\n\t\t\terr := r.Client.Create(ctx, &outputSecret)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(err, \"unable to create secret\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\toutputSecret.Data = req.Data\n\t\t\terr := r.Client.Update(ctx, &outputSecret)\n\t\t\tif err != nil {\n\t\t\t\tlog.Error(err, \"unable to update secret\")\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\n\t\treturn &WriteOutputsReply{Message: \"ok\", Changed: true}, nil\n\t}\n\n\treturn &WriteOutputsReply{Message: \"ok\", Changed: false}, nil\n}\n\nfunc (r *TerraformRunnerServer) GetOutputs(ctx context.Context, req *GetOutputsRequest) (*GetOutputsReply, error) {\n\tlog := ctrl.LoggerFrom(ctx, \"instance-id\", r.InstanceID).WithName(loggerName)\n\tlog.Info(\"get outputs\")\n\toutputKey := types.NamespacedName{Namespace: req.Namespace, Name: req.SecretName}\n\toutputSecret := corev1.Secret{}\n\terr := r.Client.Get(ctx, outputKey, &outputSecret)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"error getting terraform output for health checks: %s\", err)\n\t\tlog.Error(err, \"unable to check terraform health\")\n\t\treturn nil, err\n\t}\n\n\toutputs := map[string]string{}\n\t// parse map[string][]byte to map[string]string for go template parsing\n\tif len(outputSecret.Data) > 0 {\n\t\tfor k, v := range outputSecret.Data {\n\t\t\toutputs[k] = string(v)\n\t\t}\n\t}\n\n\treturn &GetOutputsReply{Outputs: outputs}, nil\n}\n"], "filenames": ["runner/server_outputs.go"], "buggy_code_start_loc": [5], "buggy_code_end_loc": [26], "fixing_code_start_loc": [6], "fixing_code_end_loc": [40], "type": "CWE-200", "message": "Weave GitOps Terraform Controller (aka Weave TF-controller) is a controller for Flux to reconcile Terraform resources in a GitOps way. A vulnerability has been identified in Weave GitOps Terraform Controller which could allow an authenticated remote attacker to view sensitive information. This vulnerability stems from Weave GitOps Terraform Runners (`tf-runner`), where sensitive data is inadvertently printed - potentially revealing sensitive user data in their pod logs. In particular, functions `tfexec.ShowPlan`, `tfexec.ShowPlanRaw`, and `tfexec.Output` are implicated when the `tfexec` object set its `Stdout` and `Stderr` to be `os.Stdout` and `os.Stderr`. An unauthorized remote attacker could exploit this vulnerability by accessing these prints of sensitive information, which may contain configurations or tokens that could be used to gain unauthorized control or access to resources managed by the Terraform controller. A successful exploit could allow the attacker to utilize this sensitive data, potentially leading to unauthorized access or control of the system. This vulnerability has been addressed in Weave GitOps Terraform Controller versions `v0.14.4` and `v0.15.0-rc.5`. Users are urged to upgrade to one of these versions to mitigate the vulnerability. As a temporary measure until the patch can be applied, users can add the environment variable `DISABLE_TF_LOGS` to the tf-runners via the runner pod template of the Terraform Custom Resource. This will prevent the logging of sensitive information and mitigate the risk of this vulnerability.", "other": {"cve": {"id": "CVE-2023-34236", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-14T22:15:09.083", "lastModified": "2023-07-31T17:07:37.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Weave GitOps Terraform Controller (aka Weave TF-controller) is a controller for Flux to reconcile Terraform resources in a GitOps way. A vulnerability has been identified in Weave GitOps Terraform Controller which could allow an authenticated remote attacker to view sensitive information. This vulnerability stems from Weave GitOps Terraform Runners (`tf-runner`), where sensitive data is inadvertently printed - potentially revealing sensitive user data in their pod logs. In particular, functions `tfexec.ShowPlan`, `tfexec.ShowPlanRaw`, and `tfexec.Output` are implicated when the `tfexec` object set its `Stdout` and `Stderr` to be `os.Stdout` and `os.Stderr`. An unauthorized remote attacker could exploit this vulnerability by accessing these prints of sensitive information, which may contain configurations or tokens that could be used to gain unauthorized control or access to resources managed by the Terraform controller. A successful exploit could allow the attacker to utilize this sensitive data, potentially leading to unauthorized access or control of the system. This vulnerability has been addressed in Weave GitOps Terraform Controller versions `v0.14.4` and `v0.15.0-rc.5`. Users are urged to upgrade to one of these versions to mitigate the vulnerability. As a temporary measure until the patch can be applied, users can add the environment variable `DISABLE_TF_LOGS` to the tf-runners via the runner pod template of the Terraform Custom Resource. This will prevent the logging of sensitive information and mitigate the risk of this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 8.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:weave:gitops_terraform_controller:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.14.4", "matchCriteriaId": "5015875D-5A93-4B98-B98C-4D68ADFFFFBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:weave:gitops_terraform_controller:0.15.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "47372AC4-D67E-47DA-8785-92867A513798"}, {"vulnerable": true, "criteria": "cpe:2.3:a:weave:gitops_terraform_controller:0.15.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "2860AB73-484B-4BC4-831D-5D1F47A4CD88"}, {"vulnerable": true, "criteria": "cpe:2.3:a:weave:gitops_terraform_controller:0.15.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "D02C71DF-5978-4E0B-B16B-40E9D41A43BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:weave:gitops_terraform_controller:0.15.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "95E8F1FB-185A-4351-A382-2815B90215EF"}]}]}], "references": [{"url": "https://github.com/weaveworks/tf-controller/commit/28282bc644054e157c3b9a3d38f1f9551ce09074", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/weaveworks/tf-controller/commit/6323b355bd7f5d2ce85d0244fe0883af3881df4e", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/weaveworks/tf-controller/commit/9708fda28ccd0466cb0a8fd409854ab4d92f7dca", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/weaveworks/tf-controller/commit/98a0688036e9dbcf43fa84960d9a1ef3e09a69cf", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/weaveworks/tf-controller/issues/637", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking"]}, {"url": "https://github.com/weaveworks/tf-controller/issues/649", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Patch"]}, {"url": "https://github.com/weaveworks/tf-controller/security/advisories/GHSA-6hvv-j432-23cv", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/weaveworks/tf-controller/commit/28282bc644054e157c3b9a3d38f1f9551ce09074"}}