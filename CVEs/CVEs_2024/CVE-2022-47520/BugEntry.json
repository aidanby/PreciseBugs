{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.\n * All rights reserved.\n */\n\n#include \"netdev.h\"\n\n#define WILC_HIF_SCAN_TIMEOUT_MS                5000\n#define WILC_HIF_CONNECT_TIMEOUT_MS             9500\n\n#define WILC_FALSE_FRMWR_CHANNEL\t\t100\n\n#define WILC_SCAN_WID_LIST_SIZE\t\t6\n\nstruct wilc_rcvd_mac_info {\n\tu8 status;\n};\n\nstruct wilc_set_multicast {\n\tu32 enabled;\n\tu32 cnt;\n\tu8 *mc_list;\n};\n\nstruct host_if_wowlan_trigger {\n\tu8 wowlan_trigger;\n};\n\nstruct wilc_del_all_sta {\n\tu8 assoc_sta;\n\tu8 mac[WILC_MAX_NUM_STA][ETH_ALEN];\n};\n\nunion wilc_message_body {\n\tstruct wilc_rcvd_net_info net_info;\n\tstruct wilc_rcvd_mac_info mac_info;\n\tstruct wilc_set_multicast mc_info;\n\tstruct wilc_remain_ch remain_on_ch;\n\tchar *data;\n\tstruct host_if_wowlan_trigger wow_trigger;\n};\n\nstruct host_if_msg {\n\tunion wilc_message_body body;\n\tstruct wilc_vif *vif;\n\tstruct work_struct work;\n\tvoid (*fn)(struct work_struct *ws);\n\tstruct completion work_comp;\n\tbool is_sync;\n};\n\n/* 'msg' should be free by the caller for syc */\nstatic struct host_if_msg*\nwilc_alloc_work(struct wilc_vif *vif, void (*work_fun)(struct work_struct *),\n\t\tbool is_sync)\n{\n\tstruct host_if_msg *msg;\n\n\tif (!work_fun)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmsg = kzalloc(sizeof(*msg), GFP_ATOMIC);\n\tif (!msg)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmsg->fn = work_fun;\n\tmsg->vif = vif;\n\tmsg->is_sync = is_sync;\n\tif (is_sync)\n\t\tinit_completion(&msg->work_comp);\n\n\treturn msg;\n}\n\nstatic int wilc_enqueue_work(struct host_if_msg *msg)\n{\n\tINIT_WORK(&msg->work, msg->fn);\n\n\tif (!msg->vif || !msg->vif->wilc || !msg->vif->wilc->hif_workqueue)\n\t\treturn -EINVAL;\n\n\tif (!queue_work(msg->vif->wilc->hif_workqueue, &msg->work))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* The idx starts from 0 to (NUM_CONCURRENT_IFC - 1), but 0 index used as\n * special purpose in wilc device, so we add 1 to the index to starts from 1.\n * As a result, the returned index will be 1 to NUM_CONCURRENT_IFC.\n */\nint wilc_get_vif_idx(struct wilc_vif *vif)\n{\n\treturn vif->idx + 1;\n}\n\n/* We need to minus 1 from idx which is from wilc device to get real index\n * of wilc->vif[], because we add 1 when pass to wilc device in the function\n * wilc_get_vif_idx.\n * As a result, the index should be between 0 and (NUM_CONCURRENT_IFC - 1).\n */\nstatic struct wilc_vif *wilc_get_vif_from_idx(struct wilc *wilc, int idx)\n{\n\tint index = idx - 1;\n\tstruct wilc_vif *vif;\n\n\tif (index < 0 || index >= WILC_NUM_CONCURRENT_IFC)\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(vif, &wilc->vif_list, list) {\n\t\tif (vif->idx == index)\n\t\t\treturn vif;\n\t}\n\n\treturn NULL;\n}\n\nstatic int handle_scan_done(struct wilc_vif *vif, enum scan_event evt)\n{\n\tint result = 0;\n\tu8 abort_running_scan;\n\tstruct wid wid;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\tstruct wilc_user_scan_req *scan_req;\n\n\tif (evt == SCAN_EVENT_ABORTED) {\n\t\tabort_running_scan = 1;\n\t\twid.id = WID_ABORT_RUNNING_SCAN;\n\t\twid.type = WID_CHAR;\n\t\twid.val = (s8 *)&abort_running_scan;\n\t\twid.size = sizeof(char);\n\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\t\tif (result) {\n\t\t\tnetdev_err(vif->ndev, \"Failed to set abort running\\n\");\n\t\t\tresult = -EFAULT;\n\t\t}\n\t}\n\n\tif (!hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\\n\", __func__);\n\t\treturn result;\n\t}\n\n\tscan_req = &hif_drv->usr_scan_req;\n\tif (scan_req->scan_result) {\n\t\tscan_req->scan_result(evt, NULL, scan_req->arg);\n\t\tscan_req->scan_result = NULL;\n\t}\n\n\treturn result;\n}\n\nint wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,\n\t      u8 *ch_freq_list, u8 ch_list_len,\n\t      void (*scan_result_fn)(enum scan_event,\n\t\t\t\t     struct wilc_rcvd_net_info *, void *),\n\t      void *user_arg, struct cfg80211_scan_request *request)\n{\n\tint result = 0;\n\tstruct wid wid_list[WILC_SCAN_WID_LIST_SIZE];\n\tu32 index = 0;\n\tu32 i, scan_timeout;\n\tu8 *buffer;\n\tu8 valuesize = 0;\n\tu8 *search_ssid_vals = NULL;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (hif_drv->hif_state >= HOST_IF_SCANNING &&\n\t    hif_drv->hif_state < HOST_IF_CONNECTED) {\n\t\tnetdev_err(vif->ndev, \"Already scan\\n\");\n\t\tresult = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (vif->connecting) {\n\t\tnetdev_err(vif->ndev, \"Don't do obss scan\\n\");\n\t\tresult = -EBUSY;\n\t\tgoto error;\n\t}\n\n\thif_drv->usr_scan_req.ch_cnt = 0;\n\n\tif (request->n_ssids) {\n\t\tfor (i = 0; i < request->n_ssids; i++)\n\t\t\tvaluesize += ((request->ssids[i].ssid_len) + 1);\n\t\tsearch_ssid_vals = kmalloc(valuesize + 1, GFP_KERNEL);\n\t\tif (search_ssid_vals) {\n\t\t\twid_list[index].id = WID_SSID_PROBE_REQ;\n\t\t\twid_list[index].type = WID_STR;\n\t\t\twid_list[index].val = search_ssid_vals;\n\t\t\tbuffer = wid_list[index].val;\n\n\t\t\t*buffer++ = request->n_ssids;\n\n\t\t\tfor (i = 0; i < request->n_ssids; i++) {\n\t\t\t\t*buffer++ = request->ssids[i].ssid_len;\n\t\t\t\tmemcpy(buffer, request->ssids[i].ssid,\n\t\t\t\t       request->ssids[i].ssid_len);\n\t\t\t\tbuffer += request->ssids[i].ssid_len;\n\t\t\t}\n\t\t\twid_list[index].size = (s32)(valuesize + 1);\n\t\t\tindex++;\n\t\t}\n\t}\n\n\twid_list[index].id = WID_INFO_ELEMENT_PROBE;\n\twid_list[index].type = WID_BIN_DATA;\n\twid_list[index].val = (s8 *)request->ie;\n\twid_list[index].size = request->ie_len;\n\tindex++;\n\n\twid_list[index].id = WID_SCAN_TYPE;\n\twid_list[index].type = WID_CHAR;\n\twid_list[index].size = sizeof(char);\n\twid_list[index].val = (s8 *)&scan_type;\n\tindex++;\n\n\tif (scan_type == WILC_FW_PASSIVE_SCAN && request->duration) {\n\t\twid_list[index].id = WID_PASSIVE_SCAN_TIME;\n\t\twid_list[index].type = WID_SHORT;\n\t\twid_list[index].size = sizeof(u16);\n\t\twid_list[index].val = (s8 *)&request->duration;\n\t\tindex++;\n\n\t\tscan_timeout = (request->duration * ch_list_len) + 500;\n\t} else {\n\t\tscan_timeout = WILC_HIF_SCAN_TIMEOUT_MS;\n\t}\n\n\twid_list[index].id = WID_SCAN_CHANNEL_LIST;\n\twid_list[index].type = WID_BIN_DATA;\n\n\tif (ch_freq_list && ch_list_len > 0) {\n\t\tfor (i = 0; i < ch_list_len; i++) {\n\t\t\tif (ch_freq_list[i] > 0)\n\t\t\t\tch_freq_list[i] -= 1;\n\t\t}\n\t}\n\n\twid_list[index].val = ch_freq_list;\n\twid_list[index].size = ch_list_len;\n\tindex++;\n\n\twid_list[index].id = WID_START_SCAN_REQ;\n\twid_list[index].type = WID_CHAR;\n\twid_list[index].size = sizeof(char);\n\twid_list[index].val = (s8 *)&scan_source;\n\tindex++;\n\n\thif_drv->usr_scan_req.scan_result = scan_result_fn;\n\thif_drv->usr_scan_req.arg = user_arg;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, index);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"Failed to send scan parameters\\n\");\n\t\tgoto error;\n\t}\n\n\thif_drv->scan_timer_vif = vif;\n\tmod_timer(&hif_drv->scan_timer,\n\t\t  jiffies + msecs_to_jiffies(scan_timeout));\n\nerror:\n\n\tkfree(search_ssid_vals);\n\n\treturn result;\n}\n\nstatic int wilc_send_connect_wid(struct wilc_vif *vif)\n{\n\tint result = 0;\n\tstruct wid wid_list[5];\n\tu32 wid_cnt = 0;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\tstruct wilc_conn_info *conn_attr = &hif_drv->conn_info;\n\tstruct wilc_join_bss_param *bss_param = conn_attr->param;\n\n\n        wid_list[wid_cnt].id = WID_SET_MFP;\n        wid_list[wid_cnt].type = WID_CHAR;\n        wid_list[wid_cnt].size = sizeof(char);\n        wid_list[wid_cnt].val = (s8 *)&conn_attr->mfp_type;\n        wid_cnt++;\n\n\twid_list[wid_cnt].id = WID_INFO_ELEMENT_ASSOCIATE;\n\twid_list[wid_cnt].type = WID_BIN_DATA;\n\twid_list[wid_cnt].val = conn_attr->req_ies;\n\twid_list[wid_cnt].size = conn_attr->req_ies_len;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_11I_MODE;\n\twid_list[wid_cnt].type = WID_CHAR;\n\twid_list[wid_cnt].size = sizeof(char);\n\twid_list[wid_cnt].val = (s8 *)&conn_attr->security;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_AUTH_TYPE;\n\twid_list[wid_cnt].type = WID_CHAR;\n\twid_list[wid_cnt].size = sizeof(char);\n\twid_list[wid_cnt].val = (s8 *)&conn_attr->auth_type;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_JOIN_REQ_EXTENDED;\n\twid_list[wid_cnt].type = WID_STR;\n\twid_list[wid_cnt].size = sizeof(*bss_param);\n\twid_list[wid_cnt].val = (u8 *)bss_param;\n\twid_cnt++;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, wid_cnt);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"failed to send config packet\\n\");\n\t\tgoto error;\n\t} else {\n                if (conn_attr->auth_type == WILC_FW_AUTH_SAE)\n                        hif_drv->hif_state = HOST_IF_EXTERNAL_AUTH;\n                else\n                        hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;\n\t}\n\n\treturn 0;\n\nerror:\n\n\tkfree(conn_attr->req_ies);\n\tconn_attr->req_ies = NULL;\n\n\treturn result;\n}\n\nstatic void handle_connect_timeout(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\tstruct wilc_vif *vif = msg->vif;\n\tint result;\n\tstruct wid wid;\n\tu16 dummy_reason_code = 0;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (!hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\thif_drv->hif_state = HOST_IF_IDLE;\n\n\tif (hif_drv->conn_info.conn_result) {\n\t\thif_drv->conn_info.conn_result(CONN_DISCONN_EVENT_CONN_RESP,\n\t\t\t\t\t       WILC_MAC_STATUS_DISCONNECTED,\n\t\t\t\t\t       hif_drv->conn_info.arg);\n\n\t} else {\n\t\tnetdev_err(vif->ndev, \"%s: conn_result is NULL\\n\", __func__);\n\t}\n\n\twid.id = WID_DISCONNECT;\n\twid.type = WID_CHAR;\n\twid.val = (s8 *)&dummy_reason_code;\n\twid.size = sizeof(char);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send disconnect\\n\");\n\n\thif_drv->conn_info.req_ies_len = 0;\n\tkfree(hif_drv->conn_info.req_ies);\n\thif_drv->conn_info.req_ies = NULL;\n\nout:\n\tkfree(msg);\n}\n\nvoid *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\t\t\t\tstruct cfg80211_crypto_settings *crypto)\n{\n\tstruct wilc_join_bss_param *param;\n\tstruct ieee80211_p2p_noa_attr noa_attr;\n\tu8 rates_len = 0;\n\tconst u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;\n\tconst u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;\n\tint ret;\n\tconst struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn NULL;\n\n\tparam->beacon_period = cpu_to_le16(bss->beacon_interval);\n\tparam->cap_info = cpu_to_le16(bss->capability);\n\tparam->bss_type = WILC_FW_BSS_TYPE_INFRA;\n\tparam->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tether_addr_copy(param->bssid, bss->bssid);\n\n\tssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (ssid_elm) {\n\t\tif (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)\n\t\t\tmemcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);\n\t}\n\n\ttim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tif (tim_elm && tim_elm[1] >= 2)\n\t\tparam->dtim_period = tim_elm[3];\n\n\tmemset(param->p_suites, 0xFF, 3);\n\tmemset(param->akm_suites, 0xFF, 3);\n\n\trates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);\n\tif (rates_ie) {\n\t\trates_len = rates_ie[1];\n\t\tif (rates_len > WILC_MAX_RATES_SUPPORTED)\n\t\t\trates_len = WILC_MAX_RATES_SUPPORTED;\n\t\tparam->supp_rates[0] = rates_len;\n\t\tmemcpy(&param->supp_rates[1], rates_ie + 2, rates_len);\n\t}\n\n\tif (rates_len < WILC_MAX_RATES_SUPPORTED) {\n\t\tsupp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t\t ies->data, ies->len);\n\t\tif (supp_rates_ie) {\n\t\t\tu8 ext_rates = supp_rates_ie[1];\n\n\t\t\tif (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))\n\t\t\t\tparam->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;\n\t\t\telse\n\t\t\t\tparam->supp_rates[0] += ext_rates;\n\n\t\t\tmemcpy(&param->supp_rates[rates_len + 1],\n\t\t\t       supp_rates_ie + 2,\n\t\t\t       (param->supp_rates[0] - rates_len));\n\t\t}\n\t}\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);\n\tif (ht_ie)\n\t\tparam->ht_capable = true;\n\n\tret = cfg80211_get_p2p_attr(ies->data, ies->len,\n\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t    (u8 *)&noa_attr, sizeof(noa_attr));\n\tif (ret > 0) {\n\t\tparam->tsf_lo = cpu_to_le32(ies->tsf);\n\t\tparam->noa_enabled = 1;\n\t\tparam->idx = noa_attr.index;\n\t\tif (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {\n\t\t\tparam->opp_enabled = 1;\n\t\t\tparam->opp_en.ct_window = noa_attr.oppps_ctwindow;\n\t\t\tparam->opp_en.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_en.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_en.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_en.start_time = noa_attr.desc[0].start_time;\n\t\t} else {\n\t\t\tparam->opp_enabled = 0;\n\t\t\tparam->opp_dis.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_dis.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_dis.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_dis.start_time = noa_attr.desc[0].start_time;\n\t\t}\n\t}\n\twmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wmm_ie) {\n\t\tstruct ieee80211_wmm_param_ie *ie;\n\n\t\tie = (struct ieee80211_wmm_param_ie *)wmm_ie;\n\t\tif ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&\n\t\t    ie->version == 1) {\n\t\t\tparam->wmm_cap = true;\n\t\t\tif (ie->qos_info & BIT(7))\n\t\t\t\tparam->uapsd_cap = true;\n\t\t}\n\t}\n\n\twpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wpa_ie) {\n\t\tparam->mode_802_11i = 1;\n\t\tparam->rsn_found = true;\n\t}\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n\tif (rsn_ie) {\n\t\tint offset = 8;\n\n\t\tparam->mode_802_11i = 2;\n\t\tparam->rsn_found = true;\n\t\t/* extract RSN capabilities */\n\t\toffset += (rsn_ie[offset] * 4) + 2;\n\t\toffset += (rsn_ie[offset] * 4) + 2;\n\t\tmemcpy(param->rsn_cap, &rsn_ie[offset], 2);\n\t}\n\n\tif (param->rsn_found) {\n\t\tint i;\n\n\t\tparam->rsn_grp_policy = crypto->cipher_group & 0xFF;\n\t\tfor (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)\n\t\t\tparam->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;\n\n\t\tfor (i = 0; i < crypto->n_akm_suites && i < 3; i++)\n\t\t\tparam->akm_suites[i] = crypto->akm_suites[i] & 0xFF;\n\t}\n\n\treturn (void *)param;\n}\n\nstatic void handle_rcvd_ntwrk_info(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\tstruct wilc_rcvd_net_info *rcvd_info = &msg->body.net_info;\n\tstruct wilc_user_scan_req *scan_req = &msg->vif->hif_drv->usr_scan_req;\n\tconst u8 *ch_elm;\n\tu8 *ies;\n\tint ies_len;\n\tsize_t offset;\n\n\tif (ieee80211_is_probe_resp(rcvd_info->mgmt->frame_control))\n\t\toffset = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);\n\telse if (ieee80211_is_beacon(rcvd_info->mgmt->frame_control))\n\t\toffset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\telse\n\t\tgoto done;\n\n\ties = rcvd_info->mgmt->u.beacon.variable;\n\ties_len = rcvd_info->frame_len - offset;\n\tif (ies_len <= 0)\n\t\tgoto done;\n\n\tch_elm = cfg80211_find_ie(WLAN_EID_DS_PARAMS, ies, ies_len);\n\tif (ch_elm && ch_elm[1] > 0)\n\t\trcvd_info->ch = ch_elm[2];\n\n\tif (scan_req->scan_result)\n\t\tscan_req->scan_result(SCAN_EVENT_NETWORK_FOUND, rcvd_info,\n\t\t\t\t      scan_req->arg);\n\ndone:\n\tkfree(rcvd_info->mgmt);\n\tkfree(msg);\n}\n\nstatic void host_int_get_assoc_res_info(struct wilc_vif *vif,\n\t\t\t\t\tu8 *assoc_resp_info,\n\t\t\t\t\tu32 max_assoc_resp_info_len,\n\t\t\t\t\tu32 *rcvd_assoc_resp_info_len)\n{\n\tint result;\n\tstruct wid wid;\n\n\twid.id = WID_ASSOC_RES_INFO;\n\twid.type = WID_STR;\n\twid.val = assoc_resp_info;\n\twid.size = max_assoc_resp_info_len;\n\n\tresult = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);\n\tif (result) {\n\t\t*rcvd_assoc_resp_info_len = 0;\n\t\tnetdev_err(vif->ndev, \"Failed to send association response\\n\");\n\t\treturn;\n\t}\n\n\t*rcvd_assoc_resp_info_len = wid.size;\n}\n\nstatic s32 wilc_parse_assoc_resp_info(u8 *buffer, u32 buffer_len,\n\t\t\t\t      struct wilc_conn_info *ret_conn_info)\n{\n\tu8 *ies;\n\tu16 ies_len;\n\tstruct wilc_assoc_resp *res = (struct wilc_assoc_resp *)buffer;\n\n\tret_conn_info->status = le16_to_cpu(res->status_code);\n\tif (ret_conn_info->status == WLAN_STATUS_SUCCESS) {\n\t\ties = &buffer[sizeof(*res)];\n\t\ties_len = buffer_len - sizeof(*res);\n\n\t\tret_conn_info->resp_ies = kmemdup(ies, ies_len, GFP_KERNEL);\n\t\tif (!ret_conn_info->resp_ies)\n\t\t\treturn -ENOMEM;\n\n\t\tret_conn_info->resp_ies_len = ies_len;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void host_int_parse_assoc_resp_info(struct wilc_vif *vif,\n\t\t\t\t\t\t  u8 mac_status)\n{\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\tstruct wilc_conn_info *conn_info = &hif_drv->conn_info;\n\n\tif (mac_status == WILC_MAC_STATUS_CONNECTED) {\n\t\tu32 assoc_resp_info_len;\n\n\t\tmemset(hif_drv->assoc_resp, 0, WILC_MAX_ASSOC_RESP_FRAME_SIZE);\n\n\t\thost_int_get_assoc_res_info(vif, hif_drv->assoc_resp,\n\t\t\t\t\t    WILC_MAX_ASSOC_RESP_FRAME_SIZE,\n\t\t\t\t\t    &assoc_resp_info_len);\n\n\t\tif (assoc_resp_info_len != 0) {\n\t\t\ts32 err = 0;\n\n\t\t\terr = wilc_parse_assoc_resp_info(hif_drv->assoc_resp,\n\t\t\t\t\t\t\t assoc_resp_info_len,\n\t\t\t\t\t\t\t conn_info);\n\t\t\tif (err)\n\t\t\t\tnetdev_err(vif->ndev,\n\t\t\t\t\t   \"wilc_parse_assoc_resp_info() returned error %d\\n\",\n\t\t\t\t\t   err);\n\t\t}\n\t}\n\n\tdel_timer(&hif_drv->connect_timer);\n\tconn_info->conn_result(CONN_DISCONN_EVENT_CONN_RESP, mac_status,\n\t\t\t       hif_drv->conn_info.arg);\n\n\tif (mac_status == WILC_MAC_STATUS_CONNECTED &&\n\t    conn_info->status == WLAN_STATUS_SUCCESS) {\n\t\tether_addr_copy(hif_drv->assoc_bssid, conn_info->bssid);\n\t\thif_drv->hif_state = HOST_IF_CONNECTED;\n\t} else {\n\t\thif_drv->hif_state = HOST_IF_IDLE;\n\t}\n\n\tkfree(conn_info->resp_ies);\n\tconn_info->resp_ies = NULL;\n\tconn_info->resp_ies_len = 0;\n\n\tkfree(conn_info->req_ies);\n\tconn_info->req_ies = NULL;\n\tconn_info->req_ies_len = 0;\n}\n\nvoid wilc_handle_disconnect(struct wilc_vif *vif)\n{\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (hif_drv->usr_scan_req.scan_result) {\n\t\tdel_timer(&hif_drv->scan_timer);\n\t\thandle_scan_done(vif, SCAN_EVENT_ABORTED);\n\t}\n\n\tif (hif_drv->conn_info.conn_result)\n\t\thif_drv->conn_info.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,\n\t\t\t\t\t       0, hif_drv->conn_info.arg);\n\n\teth_zero_addr(hif_drv->assoc_bssid);\n\n\thif_drv->conn_info.req_ies_len = 0;\n\tkfree(hif_drv->conn_info.req_ies);\n\thif_drv->conn_info.req_ies = NULL;\n\thif_drv->hif_state = HOST_IF_IDLE;\n}\n\nstatic void handle_rcvd_gnrl_async_info(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\tstruct wilc_vif *vif = msg->vif;\n\tstruct wilc_rcvd_mac_info *mac_info = &msg->body.mac_info;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (!hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\\n\", __func__);\n\t\tgoto free_msg;\n\t}\n\n\tif (!hif_drv->conn_info.conn_result) {\n\t\tnetdev_err(vif->ndev, \"%s: conn_result is NULL\\n\", __func__);\n\t\tgoto free_msg;\n\t}\n\n\n        if (hif_drv->hif_state == HOST_IF_EXTERNAL_AUTH) {\n                cfg80211_external_auth_request(vif->ndev, &vif->auth,\n\t\t\t\t\t       GFP_KERNEL);\n                hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;\n        } else if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {\n\t\thost_int_parse_assoc_resp_info(vif, mac_info->status);\n\t} else if (mac_info->status == WILC_MAC_STATUS_DISCONNECTED) {\n\t\tif (hif_drv->hif_state == HOST_IF_CONNECTED) {\n\t\t\twilc_handle_disconnect(vif);\n\t\t} else if (hif_drv->usr_scan_req.scan_result) {\n\t\t\tdel_timer(&hif_drv->scan_timer);\n\t\t\thandle_scan_done(vif, SCAN_EVENT_ABORTED);\n\t\t}\n\t}\n\nfree_msg:\n\tkfree(msg);\n}\n\nint wilc_disconnect(struct wilc_vif *vif)\n{\n\tstruct wid wid;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\tstruct wilc_user_scan_req *scan_req;\n\tstruct wilc_conn_info *conn_info;\n\tint result;\n\tu16 dummy_reason_code = 0;\n\n\twid.id = WID_DISCONNECT;\n\twid.type = WID_CHAR;\n\twid.val = (s8 *)&dummy_reason_code;\n\twid.size = sizeof(char);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"Failed to send disconnect\\n\");\n\t\treturn result;\n\t}\n\n\tscan_req = &hif_drv->usr_scan_req;\n\tconn_info = &hif_drv->conn_info;\n\n\tif (scan_req->scan_result) {\n\t\tdel_timer(&hif_drv->scan_timer);\n\t\tscan_req->scan_result(SCAN_EVENT_ABORTED, NULL, scan_req->arg);\n\t\tscan_req->scan_result = NULL;\n\t}\n\n\tif (conn_info->conn_result) {\n\t\tif (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP ||\n\t\t    hif_drv->hif_state == HOST_IF_EXTERNAL_AUTH)\n\t\t\tdel_timer(&hif_drv->connect_timer);\n\n\t\tconn_info->conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF, 0,\n\t\t\t\t       conn_info->arg);\n\t} else {\n\t\tnetdev_err(vif->ndev, \"%s: conn_result is NULL\\n\", __func__);\n\t}\n\n\thif_drv->hif_state = HOST_IF_IDLE;\n\n\teth_zero_addr(hif_drv->assoc_bssid);\n\n\tconn_info->req_ies_len = 0;\n\tkfree(conn_info->req_ies);\n\tconn_info->req_ies = NULL;\n\n\treturn 0;\n}\n\nint wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats)\n{\n\tstruct wid wid_list[5];\n\tu32 wid_cnt = 0, result;\n\n\twid_list[wid_cnt].id = WID_LINKSPEED;\n\twid_list[wid_cnt].type = WID_CHAR;\n\twid_list[wid_cnt].size = sizeof(char);\n\twid_list[wid_cnt].val = (s8 *)&stats->link_speed;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_RSSI;\n\twid_list[wid_cnt].type = WID_CHAR;\n\twid_list[wid_cnt].size = sizeof(char);\n\twid_list[wid_cnt].val = (s8 *)&stats->rssi;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_SUCCESS_FRAME_COUNT;\n\twid_list[wid_cnt].type = WID_INT;\n\twid_list[wid_cnt].size = sizeof(u32);\n\twid_list[wid_cnt].val = (s8 *)&stats->tx_cnt;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_RECEIVED_FRAGMENT_COUNT;\n\twid_list[wid_cnt].type = WID_INT;\n\twid_list[wid_cnt].size = sizeof(u32);\n\twid_list[wid_cnt].val = (s8 *)&stats->rx_cnt;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_FAILED_COUNT;\n\twid_list[wid_cnt].type = WID_INT;\n\twid_list[wid_cnt].size = sizeof(u32);\n\twid_list[wid_cnt].val = (s8 *)&stats->tx_fail_cnt;\n\twid_cnt++;\n\n\tresult = wilc_send_config_pkt(vif, WILC_GET_CFG, wid_list, wid_cnt);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"Failed to send scan parameters\\n\");\n\t\treturn result;\n\t}\n\n\tif (stats->link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&\n\t    stats->link_speed != DEFAULT_LINK_SPEED)\n\t\twilc_enable_tcp_ack_filter(vif, true);\n\telse if (stats->link_speed != DEFAULT_LINK_SPEED)\n\t\twilc_enable_tcp_ack_filter(vif, false);\n\n\treturn result;\n}\n\nstatic void handle_get_statistics(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\tstruct wilc_vif *vif = msg->vif;\n\tstruct rf_info *stats = (struct rf_info *)msg->body.data;\n\n\twilc_get_statistics(vif, stats);\n\n\tkfree(msg);\n}\n\nstatic void wilc_hif_pack_sta_param(u8 *cur_byte, const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tether_addr_copy(cur_byte, mac);\n\tcur_byte += ETH_ALEN;\n\n\tput_unaligned_le16(params->aid, cur_byte);\n\tcur_byte += 2;\n\n\t*cur_byte++ = params->link_sta_params.supported_rates_len;\n\tif (params->link_sta_params.supported_rates_len > 0)\n\t\tmemcpy(cur_byte, params->link_sta_params.supported_rates,\n\t\t       params->link_sta_params.supported_rates_len);\n\tcur_byte += params->link_sta_params.supported_rates_len;\n\n\tif (params->link_sta_params.ht_capa) {\n\t\t*cur_byte++ = true;\n\t\tmemcpy(cur_byte, params->link_sta_params.ht_capa,\n\t\t       sizeof(struct ieee80211_ht_cap));\n\t} else {\n\t\t*cur_byte++ = false;\n\t}\n\tcur_byte += sizeof(struct ieee80211_ht_cap);\n\n\tput_unaligned_le16(params->sta_flags_mask, cur_byte);\n\tcur_byte += 2;\n\tput_unaligned_le16(params->sta_flags_set, cur_byte);\n}\n\nstatic int handle_remain_on_chan(struct wilc_vif *vif,\n\t\t\t\t struct wilc_remain_ch *hif_remain_ch)\n{\n\tint result;\n\tu8 remain_on_chan_flag;\n\tstruct wid wid;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (hif_drv->usr_scan_req.scan_result)\n\t\treturn -EBUSY;\n\n\tif (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP)\n\t\treturn -EBUSY;\n\n\tif (vif->connecting)\n\t\treturn -EBUSY;\n\n\tremain_on_chan_flag = true;\n\twid.id = WID_REMAIN_ON_CHAN;\n\twid.type = WID_STR;\n\twid.size = 2;\n\twid.val = kmalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\twid.val[0] = remain_on_chan_flag;\n\twid.val[1] = (s8)hif_remain_ch->ch;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tkfree(wid.val);\n\tif (result)\n\t\treturn -EBUSY;\n\n\thif_drv->remain_on_ch.arg = hif_remain_ch->arg;\n\thif_drv->remain_on_ch.expired = hif_remain_ch->expired;\n\thif_drv->remain_on_ch.ch = hif_remain_ch->ch;\n\thif_drv->remain_on_ch.cookie = hif_remain_ch->cookie;\n\thif_drv->remain_on_ch_timer_vif = vif;\n\n\treturn 0;\n}\n\nstatic int wilc_handle_roc_expired(struct wilc_vif *vif, u64 cookie)\n{\n\tu8 remain_on_chan_flag;\n\tstruct wid wid;\n\tint result;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (vif->priv.p2p_listen_state) {\n\t\tremain_on_chan_flag = false;\n\t\twid.id = WID_REMAIN_ON_CHAN;\n\t\twid.type = WID_STR;\n\t\twid.size = 2;\n\n\t\twid.val = kmalloc(wid.size, GFP_KERNEL);\n\t\tif (!wid.val)\n\t\t\treturn -ENOMEM;\n\n\t\twid.val[0] = remain_on_chan_flag;\n\t\twid.val[1] = WILC_FALSE_FRMWR_CHANNEL;\n\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\t\tkfree(wid.val);\n\t\tif (result != 0) {\n\t\t\tnetdev_err(vif->ndev, \"Failed to set remain channel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (hif_drv->remain_on_ch.expired) {\n\t\t\thif_drv->remain_on_ch.expired(hif_drv->remain_on_ch.arg,\n\t\t\t\t\t\t      cookie);\n\t\t}\n\t} else {\n\t\tnetdev_dbg(vif->ndev, \"Not in listen state\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void wilc_handle_listen_state_expired(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\n\twilc_handle_roc_expired(msg->vif, msg->body.remain_on_ch.cookie);\n\tkfree(msg);\n}\n\nstatic void listen_timer_cb(struct timer_list *t)\n{\n\tstruct host_if_drv *hif_drv = from_timer(hif_drv, t,\n\t\t\t\t\t\t      remain_on_ch_timer);\n\tstruct wilc_vif *vif = hif_drv->remain_on_ch_timer_vif;\n\tint result;\n\tstruct host_if_msg *msg;\n\n\tdel_timer(&vif->hif_drv->remain_on_ch_timer);\n\n\tmsg = wilc_alloc_work(vif, wilc_handle_listen_state_expired, false);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\tmsg->body.remain_on_ch.cookie = vif->hif_drv->remain_on_ch.cookie;\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\", __func__);\n\t\tkfree(msg);\n\t}\n}\n\nstatic void handle_set_mcast_filter(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\tstruct wilc_vif *vif = msg->vif;\n\tstruct wilc_set_multicast *set_mc = &msg->body.mc_info;\n\tint result;\n\tstruct wid wid;\n\tu8 *cur_byte;\n\n\twid.id = WID_SETUP_MULTICAST_FILTER;\n\twid.type = WID_BIN;\n\twid.size = sizeof(struct wilc_set_multicast) + (set_mc->cnt * ETH_ALEN);\n\twid.val = kmalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\tgoto error;\n\n\tcur_byte = wid.val;\n\tput_unaligned_le32(set_mc->enabled, cur_byte);\n\tcur_byte += 4;\n\n\tput_unaligned_le32(set_mc->cnt, cur_byte);\n\tcur_byte += 4;\n\n\tif (set_mc->cnt > 0 && set_mc->mc_list)\n\t\tmemcpy(cur_byte, set_mc->mc_list, set_mc->cnt * ETH_ALEN);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send setup multicast\\n\");\n\nerror:\n\tkfree(set_mc->mc_list);\n\tkfree(wid.val);\n\tkfree(msg);\n}\n\nvoid wilc_set_wowlan_trigger(struct wilc_vif *vif, bool enabled)\n{\n\tint ret;\n\tstruct wid wid;\n\tu8 wowlan_trigger = 0;\n\n\tif (enabled)\n\t\twowlan_trigger = 1;\n\n\twid.id = WID_WOWLAN_TRIGGER;\n\twid.type = WID_CHAR;\n\twid.val = &wowlan_trigger;\n\twid.size = sizeof(char);\n\n\tret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (ret)\n\t\tpr_err(\"Failed to send wowlan trigger config packet\\n\");\n}\n\nint wilc_set_external_auth_param(struct wilc_vif *vif,\n\t\t\t\t struct cfg80211_external_auth_params *auth)\n{\n\tint ret;\n\tstruct wid wid;\n\tstruct wilc_external_auth_param *param;\n\n\twid.id = WID_EXTERNAL_AUTH_PARAM;\n\twid.type = WID_BIN_DATA;\n\twid.size = sizeof(*param);\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn -EINVAL;\n\n\twid.val = (u8 *)param;\n\tparam->action = auth->action;\n\tether_addr_copy(param->bssid, auth->bssid);\n\tmemcpy(param->ssid, auth->ssid.ssid, auth->ssid.ssid_len);\n\tparam->ssid_len = auth->ssid.ssid_len;\n\tret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\n\tkfree(param);\n\treturn ret;\n}\n\nstatic void handle_scan_timer(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\n\thandle_scan_done(msg->vif, SCAN_EVENT_ABORTED);\n\tkfree(msg);\n}\n\nstatic void handle_scan_complete(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\n\tdel_timer(&msg->vif->hif_drv->scan_timer);\n\n\thandle_scan_done(msg->vif, SCAN_EVENT_DONE);\n\n\tkfree(msg);\n}\n\nstatic void timer_scan_cb(struct timer_list *t)\n{\n\tstruct host_if_drv *hif_drv = from_timer(hif_drv, t, scan_timer);\n\tstruct wilc_vif *vif = hif_drv->scan_timer_vif;\n\tstruct host_if_msg *msg;\n\tint result;\n\n\tmsg = wilc_alloc_work(vif, handle_scan_timer, false);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result)\n\t\tkfree(msg);\n}\n\nstatic void timer_connect_cb(struct timer_list *t)\n{\n\tstruct host_if_drv *hif_drv = from_timer(hif_drv, t,\n\t\t\t\t\t\t      connect_timer);\n\tstruct wilc_vif *vif = hif_drv->connect_timer_vif;\n\tstruct host_if_msg *msg;\n\tint result;\n\n\tmsg = wilc_alloc_work(vif, handle_connect_timeout, false);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result)\n\t\tkfree(msg);\n}\n\nint wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,\n\t\t const u8 *mac_addr, const u8 *rx_mic, const u8 *tx_mic,\n\t\t u8 mode, u8 cipher_mode, u8 index)\n{\n\tint result = 0;\n\tu8 t_key_len  = ptk_key_len + WILC_RX_MIC_KEY_LEN + WILC_TX_MIC_KEY_LEN;\n\n\tif (mode == WILC_AP_MODE) {\n\t\tstruct wid wid_list[2];\n\t\tstruct wilc_ap_wpa_ptk *key_buf;\n\n\t\twid_list[0].id = WID_11I_MODE;\n\t\twid_list[0].type = WID_CHAR;\n\t\twid_list[0].size = sizeof(char);\n\t\twid_list[0].val = (s8 *)&cipher_mode;\n\n\t\tkey_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);\n\t\tif (!key_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tether_addr_copy(key_buf->mac_addr, mac_addr);\n\t\tkey_buf->index = index;\n\t\tkey_buf->key_len = t_key_len;\n\t\tmemcpy(&key_buf->key[0], ptk, ptk_key_len);\n\n\t\tif (rx_mic)\n\t\t\tmemcpy(&key_buf->key[ptk_key_len], rx_mic,\n\t\t\t       WILC_RX_MIC_KEY_LEN);\n\n\t\tif (tx_mic)\n\t\t\tmemcpy(&key_buf->key[ptk_key_len + WILC_RX_MIC_KEY_LEN],\n\t\t\t       tx_mic, WILC_TX_MIC_KEY_LEN);\n\n\t\twid_list[1].id = WID_ADD_PTK;\n\t\twid_list[1].type = WID_STR;\n\t\twid_list[1].size = sizeof(*key_buf) + t_key_len;\n\t\twid_list[1].val = (u8 *)key_buf;\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list,\n\t\t\t\t\t      ARRAY_SIZE(wid_list));\n\t\tkfree(key_buf);\n\t} else if (mode == WILC_STATION_MODE) {\n\t\tstruct wid wid;\n\t\tstruct wilc_sta_wpa_ptk *key_buf;\n\n\t\tkey_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);\n\t\tif (!key_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tether_addr_copy(key_buf->mac_addr, mac_addr);\n\t\tkey_buf->key_len = t_key_len;\n\t\tmemcpy(&key_buf->key[0], ptk, ptk_key_len);\n\n\t\tif (rx_mic)\n\t\t\tmemcpy(&key_buf->key[ptk_key_len], rx_mic,\n\t\t\t       WILC_RX_MIC_KEY_LEN);\n\n\t\tif (tx_mic)\n\t\t\tmemcpy(&key_buf->key[ptk_key_len + WILC_RX_MIC_KEY_LEN],\n\t\t\t       tx_mic, WILC_TX_MIC_KEY_LEN);\n\n\t\twid.id = WID_ADD_PTK;\n\t\twid.type = WID_STR;\n\t\twid.size = sizeof(*key_buf) + t_key_len;\n\t\twid.val = (s8 *)key_buf;\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\t\tkfree(key_buf);\n\t}\n\n\treturn result;\n}\n\nint wilc_add_igtk(struct wilc_vif *vif, const u8 *igtk, u8 igtk_key_len,\n\t\t  const u8 *pn, u8 pn_len, const u8 *mac_addr, u8 mode, u8 index)\n{\n\tint result = 0;\n\tu8 t_key_len = igtk_key_len;\n\tstruct wid wid;\n\tstruct wilc_wpa_igtk *key_buf;\n\n\tkey_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);\n\tif (!key_buf)\n\t\treturn -ENOMEM;\n\n\tkey_buf->index = index;\n\n\tmemcpy(&key_buf->pn[0], pn, pn_len);\n\tkey_buf->pn_len = pn_len;\n\n\tmemcpy(&key_buf->key[0], igtk, igtk_key_len);\n\tkey_buf->key_len = t_key_len;\n\n\twid.id = WID_ADD_IGTK;\n\twid.type = WID_STR;\n\twid.size = sizeof(*key_buf) + t_key_len;\n\twid.val = (s8 *)key_buf;\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tkfree(key_buf);\n\n\treturn result;\n}\n\nint wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,\n\t\t    u8 index, u32 key_rsc_len, const u8 *key_rsc,\n\t\t    const u8 *rx_mic, const u8 *tx_mic, u8 mode,\n\t\t    u8 cipher_mode)\n{\n\tint result = 0;\n\tstruct wilc_gtk_key *gtk_key;\n\tint t_key_len = gtk_key_len + WILC_RX_MIC_KEY_LEN + WILC_TX_MIC_KEY_LEN;\n\n\tgtk_key = kzalloc(sizeof(*gtk_key) + t_key_len, GFP_KERNEL);\n\tif (!gtk_key)\n\t\treturn -ENOMEM;\n\n\t/* fill bssid value only in station mode */\n\tif (mode == WILC_STATION_MODE &&\n\t    vif->hif_drv->hif_state == HOST_IF_CONNECTED)\n\t\tmemcpy(gtk_key->mac_addr, vif->hif_drv->assoc_bssid, ETH_ALEN);\n\n\tif (key_rsc)\n\t\tmemcpy(gtk_key->rsc, key_rsc, 8);\n\tgtk_key->index = index;\n\tgtk_key->key_len = t_key_len;\n\tmemcpy(&gtk_key->key[0], rx_gtk, gtk_key_len);\n\n\tif (rx_mic)\n\t\tmemcpy(&gtk_key->key[gtk_key_len], rx_mic, WILC_RX_MIC_KEY_LEN);\n\n\tif (tx_mic)\n\t\tmemcpy(&gtk_key->key[gtk_key_len + WILC_RX_MIC_KEY_LEN],\n\t\t       tx_mic, WILC_TX_MIC_KEY_LEN);\n\n\tif (mode == WILC_AP_MODE) {\n\t\tstruct wid wid_list[2];\n\n\t\twid_list[0].id = WID_11I_MODE;\n\t\twid_list[0].type = WID_CHAR;\n\t\twid_list[0].size = sizeof(char);\n\t\twid_list[0].val = (s8 *)&cipher_mode;\n\n\t\twid_list[1].id = WID_ADD_RX_GTK;\n\t\twid_list[1].type = WID_STR;\n\t\twid_list[1].size = sizeof(*gtk_key) + t_key_len;\n\t\twid_list[1].val = (u8 *)gtk_key;\n\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list,\n\t\t\t\t\t      ARRAY_SIZE(wid_list));\n\t} else if (mode == WILC_STATION_MODE) {\n\t\tstruct wid wid;\n\n\t\twid.id = WID_ADD_RX_GTK;\n\t\twid.type = WID_STR;\n\t\twid.size = sizeof(*gtk_key) + t_key_len;\n\t\twid.val = (u8 *)gtk_key;\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\t}\n\n\tkfree(gtk_key);\n\treturn result;\n}\n\nint wilc_set_pmkid_info(struct wilc_vif *vif, struct wilc_pmkid_attr *pmkid)\n{\n\tstruct wid wid;\n\n\twid.id = WID_PMKID_INFO;\n\twid.type = WID_STR;\n\twid.size = (pmkid->numpmkid * sizeof(struct wilc_pmkid)) + 1;\n\twid.val = (u8 *)pmkid;\n\n\treturn wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n}\n\nint wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr)\n{\n\tint result;\n\tstruct wid wid;\n\n\twid.id = WID_MAC_ADDR;\n\twid.type = WID_STR;\n\twid.size = ETH_ALEN;\n\twid.val = mac_addr;\n\n\tresult = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to get mac address\\n\");\n\n\treturn result;\n}\n\nint wilc_set_mac_address(struct wilc_vif *vif, u8 *mac_addr)\n{\n\tstruct wid wid;\n\tint result;\n\n\twid.id = WID_MAC_ADDR;\n\twid.type = WID_STR;\n\twid.size = ETH_ALEN;\n\twid.val = mac_addr;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to set mac address\\n\");\n\n\treturn result;\n}\n\nint wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ies,\n\t\t      size_t ies_len)\n{\n\tint result;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\tstruct wilc_conn_info *conn_info = &hif_drv->conn_info;\n\n\tif (bssid)\n\t\tether_addr_copy(conn_info->bssid, bssid);\n\n\tif (ies) {\n\t\tconn_info->req_ies_len = ies_len;\n\t\tconn_info->req_ies = kmemdup(ies, ies_len, GFP_KERNEL);\n\t\tif (!conn_info->req_ies)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tresult = wilc_send_connect_wid(vif);\n\tif (result)\n\t\tgoto free_ies;\n\n\thif_drv->connect_timer_vif = vif;\n\tmod_timer(&hif_drv->connect_timer,\n\t\t  jiffies + msecs_to_jiffies(WILC_HIF_CONNECT_TIMEOUT_MS));\n\n\treturn 0;\n\nfree_ies:\n\tkfree(conn_info->req_ies);\n\n\treturn result;\n}\n\nint wilc_set_mac_chnl_num(struct wilc_vif *vif, u8 channel)\n{\n\tstruct wid wid;\n\tint result;\n\n\twid.id = WID_CURRENT_CHANNEL;\n\twid.type = WID_CHAR;\n\twid.size = sizeof(char);\n\twid.val = &channel;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to set channel\\n\");\n\n\treturn result;\n}\n\nint wilc_set_operation_mode(struct wilc_vif *vif, int index, u8 mode,\n\t\t\t    u8 ifc_id)\n{\n\tstruct wid wid;\n\tint result;\n\tstruct wilc_drv_handler drv;\n\n\twid.id = WID_SET_OPERATION_MODE;\n\twid.type = WID_STR;\n\twid.size = sizeof(drv);\n\twid.val = (u8 *)&drv;\n\n\tdrv.handler = cpu_to_le32(index);\n\tdrv.mode = (ifc_id | (mode << 1));\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to set driver handler\\n\");\n\n\treturn result;\n}\n\ns32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac, u32 *out_val)\n{\n\tstruct wid wid;\n\ts32 result;\n\n\twid.id = WID_SET_STA_MAC_INACTIVE_TIME;\n\twid.type = WID_STR;\n\twid.size = ETH_ALEN;\n\twid.val = kzalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\tether_addr_copy(wid.val, mac);\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tkfree(wid.val);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"Failed to set inactive mac\\n\");\n\t\treturn result;\n\t}\n\n\twid.id = WID_GET_INACTIVE_TIME;\n\twid.type = WID_INT;\n\twid.val = (s8 *)out_val;\n\twid.size = sizeof(u32);\n\tresult = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to get inactive time\\n\");\n\n\treturn result;\n}\n\nint wilc_get_rssi(struct wilc_vif *vif, s8 *rssi_level)\n{\n\tstruct wid wid;\n\tint result;\n\n\tif (!rssi_level) {\n\t\tnetdev_err(vif->ndev, \"%s: RSSI level is NULL\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\twid.id = WID_RSSI;\n\twid.type = WID_CHAR;\n\twid.size = sizeof(char);\n\twid.val = rssi_level;\n\tresult = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to get RSSI value\\n\");\n\n\treturn result;\n}\n\nstatic int wilc_get_stats_async(struct wilc_vif *vif, struct rf_info *stats)\n{\n\tint result;\n\tstruct host_if_msg *msg;\n\n\tmsg = wilc_alloc_work(vif, handle_get_statistics, false);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tmsg->body.data = (char *)stats;\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\", __func__);\n\t\tkfree(msg);\n\t\treturn result;\n\t}\n\n\treturn result;\n}\n\nint wilc_hif_set_cfg(struct wilc_vif *vif, struct cfg_param_attr *param)\n{\n\tstruct wid wid_list[4];\n\tint i = 0;\n\n\tif (param->flag & WILC_CFG_PARAM_RETRY_SHORT) {\n\t\twid_list[i].id = WID_SHORT_RETRY_LIMIT;\n\t\twid_list[i].val = (s8 *)&param->short_retry_limit;\n\t\twid_list[i].type = WID_SHORT;\n\t\twid_list[i].size = sizeof(u16);\n\t\ti++;\n\t}\n\tif (param->flag & WILC_CFG_PARAM_RETRY_LONG) {\n\t\twid_list[i].id = WID_LONG_RETRY_LIMIT;\n\t\twid_list[i].val = (s8 *)&param->long_retry_limit;\n\t\twid_list[i].type = WID_SHORT;\n\t\twid_list[i].size = sizeof(u16);\n\t\ti++;\n\t}\n\tif (param->flag & WILC_CFG_PARAM_FRAG_THRESHOLD) {\n\t\twid_list[i].id = WID_FRAG_THRESHOLD;\n\t\twid_list[i].val = (s8 *)&param->frag_threshold;\n\t\twid_list[i].type = WID_SHORT;\n\t\twid_list[i].size = sizeof(u16);\n\t\ti++;\n\t}\n\tif (param->flag & WILC_CFG_PARAM_RTS_THRESHOLD) {\n\t\twid_list[i].id = WID_RTS_THRESHOLD;\n\t\twid_list[i].val = (s8 *)&param->rts_threshold;\n\t\twid_list[i].type = WID_SHORT;\n\t\twid_list[i].size = sizeof(u16);\n\t\ti++;\n\t}\n\n\treturn wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, i);\n}\n\nstatic void get_periodic_rssi(struct timer_list *t)\n{\n\tstruct wilc_vif *vif = from_timer(vif, t, periodic_rssi);\n\n\tif (!vif->hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\", __func__);\n\t\treturn;\n\t}\n\n\tif (vif->hif_drv->hif_state == HOST_IF_CONNECTED)\n\t\twilc_get_stats_async(vif, &vif->periodic_stat);\n\n\tmod_timer(&vif->periodic_rssi, jiffies + msecs_to_jiffies(5000));\n}\n\nint wilc_init(struct net_device *dev, struct host_if_drv **hif_drv_handler)\n{\n\tstruct host_if_drv *hif_drv;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\thif_drv  = kzalloc(sizeof(*hif_drv), GFP_KERNEL);\n\tif (!hif_drv)\n\t\treturn -ENOMEM;\n\n\t*hif_drv_handler = hif_drv;\n\n\tvif->hif_drv = hif_drv;\n\n\ttimer_setup(&vif->periodic_rssi, get_periodic_rssi, 0);\n\tmod_timer(&vif->periodic_rssi, jiffies + msecs_to_jiffies(5000));\n\n\ttimer_setup(&hif_drv->scan_timer, timer_scan_cb, 0);\n\ttimer_setup(&hif_drv->connect_timer, timer_connect_cb, 0);\n\ttimer_setup(&hif_drv->remain_on_ch_timer, listen_timer_cb, 0);\n\n\thif_drv->hif_state = HOST_IF_IDLE;\n\n\thif_drv->p2p_timeout = 0;\n\n\treturn 0;\n}\n\nint wilc_deinit(struct wilc_vif *vif)\n{\n\tint result = 0;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (!hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tmutex_lock(&vif->wilc->deinit_lock);\n\n\tdel_timer_sync(&hif_drv->scan_timer);\n\tdel_timer_sync(&hif_drv->connect_timer);\n\tdel_timer_sync(&vif->periodic_rssi);\n\tdel_timer_sync(&hif_drv->remain_on_ch_timer);\n\n\tif (hif_drv->usr_scan_req.scan_result) {\n\t\thif_drv->usr_scan_req.scan_result(SCAN_EVENT_ABORTED, NULL,\n\t\t\t\t\t\t  hif_drv->usr_scan_req.arg);\n\t\thif_drv->usr_scan_req.scan_result = NULL;\n\t}\n\n\thif_drv->hif_state = HOST_IF_IDLE;\n\n\tkfree(hif_drv);\n\tvif->hif_drv = NULL;\n\tmutex_unlock(&vif->wilc->deinit_lock);\n\treturn result;\n}\n\nvoid wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length)\n{\n\tint result;\n\tstruct host_if_msg *msg;\n\tint id;\n\tstruct host_if_drv *hif_drv;\n\tstruct wilc_vif *vif;\n\n\tid = get_unaligned_le32(&buffer[length - 4]);\n\tvif = wilc_get_vif_from_idx(wilc, id);\n\tif (!vif)\n\t\treturn;\n\thif_drv = vif->hif_drv;\n\n\tif (!hif_drv) {\n\t\tnetdev_err(vif->ndev, \"driver not init[%p]\\n\", hif_drv);\n\t\treturn;\n\t}\n\n\tmsg = wilc_alloc_work(vif, handle_rcvd_ntwrk_info, false);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\tmsg->body.net_info.frame_len = get_unaligned_le16(&buffer[6]) - 1;\n\tmsg->body.net_info.rssi = buffer[8];\n\tmsg->body.net_info.mgmt = kmemdup(&buffer[9],\n\t\t\t\t\t  msg->body.net_info.frame_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!msg->body.net_info.mgmt) {\n\t\tkfree(msg);\n\t\treturn;\n\t}\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\", __func__);\n\t\tkfree(msg->body.net_info.mgmt);\n\t\tkfree(msg);\n\t}\n}\n\nvoid wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length)\n{\n\tint result;\n\tstruct host_if_msg *msg;\n\tint id;\n\tstruct host_if_drv *hif_drv;\n\tstruct wilc_vif *vif;\n\n\tmutex_lock(&wilc->deinit_lock);\n\n\tid = get_unaligned_le32(&buffer[length - 4]);\n\tvif = wilc_get_vif_from_idx(wilc, id);\n\tif (!vif) {\n\t\tmutex_unlock(&wilc->deinit_lock);\n\t\treturn;\n\t}\n\n\thif_drv = vif->hif_drv;\n\n\tif (!hif_drv) {\n\t\tmutex_unlock(&wilc->deinit_lock);\n\t\treturn;\n\t}\n\n\tif (!hif_drv->conn_info.conn_result) {\n\t\tnetdev_err(vif->ndev, \"%s: conn_result is NULL\\n\", __func__);\n\t\tmutex_unlock(&wilc->deinit_lock);\n\t\treturn;\n\t}\n\n\tmsg = wilc_alloc_work(vif, handle_rcvd_gnrl_async_info, false);\n\tif (IS_ERR(msg)) {\n\t\tmutex_unlock(&wilc->deinit_lock);\n\t\treturn;\n\t}\n\n\tmsg->body.mac_info.status = buffer[7];\n\tresult = wilc_enqueue_work(msg);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\", __func__);\n\t\tkfree(msg);\n\t}\n\n\tmutex_unlock(&wilc->deinit_lock);\n}\n\nvoid wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length)\n{\n\tint result;\n\tint id;\n\tstruct host_if_drv *hif_drv;\n\tstruct wilc_vif *vif;\n\n\tid = get_unaligned_le32(&buffer[length - 4]);\n\tvif = wilc_get_vif_from_idx(wilc, id);\n\tif (!vif)\n\t\treturn;\n\thif_drv = vif->hif_drv;\n\n\tif (!hif_drv)\n\t\treturn;\n\n\tif (hif_drv->usr_scan_req.scan_result) {\n\t\tstruct host_if_msg *msg;\n\n\t\tmsg = wilc_alloc_work(vif, handle_scan_complete, false);\n\t\tif (IS_ERR(msg))\n\t\t\treturn;\n\n\t\tresult = wilc_enqueue_work(msg);\n\t\tif (result) {\n\t\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree(msg);\n\t\t}\n\t}\n}\n\nint wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie,\n\t\t\t   u32 duration, u16 chan,\n\t\t\t   void (*expired)(void *, u64),\n\t\t\t   void *user_arg)\n{\n\tstruct wilc_remain_ch roc;\n\tint result;\n\n\troc.ch = chan;\n\troc.expired = expired;\n\troc.arg = user_arg;\n\troc.duration = duration;\n\troc.cookie = cookie;\n\tresult = handle_remain_on_chan(vif, &roc);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"%s: failed to set remain on channel\\n\",\n\t\t\t   __func__);\n\n\treturn result;\n}\n\nint wilc_listen_state_expired(struct wilc_vif *vif, u64 cookie)\n{\n\tif (!vif->hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdel_timer(&vif->hif_drv->remain_on_ch_timer);\n\n\treturn wilc_handle_roc_expired(vif, cookie);\n}\n\nvoid wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg)\n{\n\tstruct wid wid;\n\tint result;\n\tstruct wilc_reg_frame reg_frame;\n\n\twid.id = WID_REGISTER_FRAME;\n\twid.type = WID_STR;\n\twid.size = sizeof(reg_frame);\n\twid.val = (u8 *)&reg_frame;\n\n\tmemset(&reg_frame, 0x0, sizeof(reg_frame));\n\n\tif (reg)\n\t\treg_frame.reg = 1;\n\n\tswitch (frame_type) {\n\tcase IEEE80211_STYPE_ACTION:\n\t\treg_frame.reg_id = WILC_FW_ACTION_FRM_IDX;\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_PROBE_REQ:\n\t\treg_frame.reg_id = WILC_FW_PROBE_REQ_IDX;\n\t\tbreak;\n\n        case IEEE80211_STYPE_AUTH:\n                reg_frame.reg_id = WILC_FW_AUTH_REQ_IDX;\n                break;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treg_frame.frame_type = cpu_to_le16(frame_type);\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to frame register\\n\");\n}\n\nint wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,\n\t\t    struct cfg80211_beacon_data *params)\n{\n\tstruct wid wid;\n\tint result;\n\tu8 *cur_byte;\n\n\twid.id = WID_ADD_BEACON;\n\twid.type = WID_BIN;\n\twid.size = params->head_len + params->tail_len + 16;\n\twid.val = kzalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\tcur_byte = wid.val;\n\tput_unaligned_le32(interval, cur_byte);\n\tcur_byte += 4;\n\tput_unaligned_le32(dtim_period, cur_byte);\n\tcur_byte += 4;\n\tput_unaligned_le32(params->head_len, cur_byte);\n\tcur_byte += 4;\n\n\tif (params->head_len > 0)\n\t\tmemcpy(cur_byte, params->head, params->head_len);\n\tcur_byte += params->head_len;\n\n\tput_unaligned_le32(params->tail_len, cur_byte);\n\tcur_byte += 4;\n\n\tif (params->tail_len > 0)\n\t\tmemcpy(cur_byte, params->tail, params->tail_len);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send add beacon\\n\");\n\n\tkfree(wid.val);\n\n\treturn result;\n}\n\nint wilc_del_beacon(struct wilc_vif *vif)\n{\n\tint result;\n\tstruct wid wid;\n\tu8 del_beacon = 0;\n\n\twid.id = WID_DEL_BEACON;\n\twid.type = WID_CHAR;\n\twid.size = sizeof(char);\n\twid.val = &del_beacon;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send delete beacon\\n\");\n\n\treturn result;\n}\n\nint wilc_add_station(struct wilc_vif *vif, const u8 *mac,\n\t\t     struct station_parameters *params)\n{\n\tstruct wid wid;\n\tint result;\n\tu8 *cur_byte;\n\n\twid.id = WID_ADD_STA;\n\twid.type = WID_BIN;\n\twid.size = WILC_ADD_STA_LENGTH +\n\t\t   params->link_sta_params.supported_rates_len;\n\twid.val = kmalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\tcur_byte = wid.val;\n\twilc_hif_pack_sta_param(cur_byte, mac, params);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result != 0)\n\t\tnetdev_err(vif->ndev, \"Failed to send add station\\n\");\n\n\tkfree(wid.val);\n\n\treturn result;\n}\n\nint wilc_del_station(struct wilc_vif *vif, const u8 *mac_addr)\n{\n\tstruct wid wid;\n\tint result;\n\n\twid.id = WID_REMOVE_STA;\n\twid.type = WID_BIN;\n\twid.size = ETH_ALEN;\n\twid.val = kzalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\tif (!mac_addr)\n\t\teth_broadcast_addr(wid.val);\n\telse\n\t\tether_addr_copy(wid.val, mac_addr);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to del station\\n\");\n\n\tkfree(wid.val);\n\n\treturn result;\n}\n\nint wilc_del_allstation(struct wilc_vif *vif, u8 mac_addr[][ETH_ALEN])\n{\n\tstruct wid wid;\n\tint result;\n\tint i;\n\tu8 assoc_sta = 0;\n\tstruct wilc_del_all_sta del_sta;\n\n\tmemset(&del_sta, 0x0, sizeof(del_sta));\n\tfor (i = 0; i < WILC_MAX_NUM_STA; i++) {\n\t\tif (!is_zero_ether_addr(mac_addr[i])) {\n\t\t\tassoc_sta++;\n\t\t\tether_addr_copy(del_sta.mac[i], mac_addr[i]);\n\t\t}\n\t}\n\n\tif (!assoc_sta)\n\t\treturn 0;\n\n\tdel_sta.assoc_sta = assoc_sta;\n\n\twid.id = WID_DEL_ALL_STA;\n\twid.type = WID_STR;\n\twid.size = (assoc_sta * ETH_ALEN) + 1;\n\twid.val = (u8 *)&del_sta;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send delete all station\\n\");\n\n\treturn result;\n}\n\nint wilc_edit_station(struct wilc_vif *vif, const u8 *mac,\n\t\t      struct station_parameters *params)\n{\n\tstruct wid wid;\n\tint result;\n\tu8 *cur_byte;\n\n\twid.id = WID_EDIT_STA;\n\twid.type = WID_BIN;\n\twid.size = WILC_ADD_STA_LENGTH +\n\t\t   params->link_sta_params.supported_rates_len;\n\twid.val = kmalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\tcur_byte = wid.val;\n\twilc_hif_pack_sta_param(cur_byte, mac, params);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send edit station\\n\");\n\n\tkfree(wid.val);\n\treturn result;\n}\n\nint wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)\n{\n\tstruct wilc *wilc = vif->wilc;\n\tstruct wid wid;\n\tint result;\n\ts8 power_mode;\n\n\tif (enabled)\n\t\tpower_mode = WILC_FW_MIN_FAST_PS;\n\telse\n\t\tpower_mode = WILC_FW_NO_POWERSAVE;\n\n\twid.id = WID_POWER_MANAGEMENT;\n\twid.val = &power_mode;\n\twid.size = sizeof(char);\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send power management\\n\");\n\telse\n\t\twilc->power_save_mode = enabled;\n\n\treturn result;\n}\n\nint wilc_setup_multicast_filter(struct wilc_vif *vif, u32 enabled, u32 count,\n\t\t\t\tu8 *mc_list)\n{\n\tint result;\n\tstruct host_if_msg *msg;\n\n\tmsg = wilc_alloc_work(vif, handle_set_mcast_filter, false);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tmsg->body.mc_info.enabled = enabled;\n\tmsg->body.mc_info.cnt = count;\n\tmsg->body.mc_info.mc_list = mc_list;\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\", __func__);\n\t\tkfree(msg);\n\t}\n\treturn result;\n}\n\nint wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power)\n{\n\tstruct wid wid;\n\n\twid.id = WID_TX_POWER;\n\twid.type = WID_CHAR;\n\twid.val = &tx_power;\n\twid.size = sizeof(char);\n\n\treturn wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n}\n\nint wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)\n{\n\tstruct wid wid;\n\n\twid.id = WID_TX_POWER;\n\twid.type = WID_CHAR;\n\twid.val = tx_power;\n\twid.size = sizeof(char);\n\n\treturn wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);\n}\n\nint wilc_set_default_mgmt_key_index(struct wilc_vif *vif, u8 index)\n{\n        struct wid wid;\n        int result;\n\n        wid.id = WID_DEFAULT_MGMT_KEY_ID;\n        wid.type = WID_CHAR;\n        wid.size = sizeof(char);\n        wid.val = &index;\n        result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n        if (result)\n                netdev_err(vif->ndev,\n                           \"Failed to send default mgmt key index\\n\");\n\n        return result;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n/*\n * Copyright (c) 2012 - 2018 Microchip Technology Inc., and its subsidiaries.\n * All rights reserved.\n */\n\n#include \"netdev.h\"\n\n#define WILC_HIF_SCAN_TIMEOUT_MS                5000\n#define WILC_HIF_CONNECT_TIMEOUT_MS             9500\n\n#define WILC_FALSE_FRMWR_CHANNEL\t\t100\n\n#define WILC_SCAN_WID_LIST_SIZE\t\t6\n\nstruct wilc_rcvd_mac_info {\n\tu8 status;\n};\n\nstruct wilc_set_multicast {\n\tu32 enabled;\n\tu32 cnt;\n\tu8 *mc_list;\n};\n\nstruct host_if_wowlan_trigger {\n\tu8 wowlan_trigger;\n};\n\nstruct wilc_del_all_sta {\n\tu8 assoc_sta;\n\tu8 mac[WILC_MAX_NUM_STA][ETH_ALEN];\n};\n\nunion wilc_message_body {\n\tstruct wilc_rcvd_net_info net_info;\n\tstruct wilc_rcvd_mac_info mac_info;\n\tstruct wilc_set_multicast mc_info;\n\tstruct wilc_remain_ch remain_on_ch;\n\tchar *data;\n\tstruct host_if_wowlan_trigger wow_trigger;\n};\n\nstruct host_if_msg {\n\tunion wilc_message_body body;\n\tstruct wilc_vif *vif;\n\tstruct work_struct work;\n\tvoid (*fn)(struct work_struct *ws);\n\tstruct completion work_comp;\n\tbool is_sync;\n};\n\n/* 'msg' should be free by the caller for syc */\nstatic struct host_if_msg*\nwilc_alloc_work(struct wilc_vif *vif, void (*work_fun)(struct work_struct *),\n\t\tbool is_sync)\n{\n\tstruct host_if_msg *msg;\n\n\tif (!work_fun)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmsg = kzalloc(sizeof(*msg), GFP_ATOMIC);\n\tif (!msg)\n\t\treturn ERR_PTR(-ENOMEM);\n\tmsg->fn = work_fun;\n\tmsg->vif = vif;\n\tmsg->is_sync = is_sync;\n\tif (is_sync)\n\t\tinit_completion(&msg->work_comp);\n\n\treturn msg;\n}\n\nstatic int wilc_enqueue_work(struct host_if_msg *msg)\n{\n\tINIT_WORK(&msg->work, msg->fn);\n\n\tif (!msg->vif || !msg->vif->wilc || !msg->vif->wilc->hif_workqueue)\n\t\treturn -EINVAL;\n\n\tif (!queue_work(msg->vif->wilc->hif_workqueue, &msg->work))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/* The idx starts from 0 to (NUM_CONCURRENT_IFC - 1), but 0 index used as\n * special purpose in wilc device, so we add 1 to the index to starts from 1.\n * As a result, the returned index will be 1 to NUM_CONCURRENT_IFC.\n */\nint wilc_get_vif_idx(struct wilc_vif *vif)\n{\n\treturn vif->idx + 1;\n}\n\n/* We need to minus 1 from idx which is from wilc device to get real index\n * of wilc->vif[], because we add 1 when pass to wilc device in the function\n * wilc_get_vif_idx.\n * As a result, the index should be between 0 and (NUM_CONCURRENT_IFC - 1).\n */\nstatic struct wilc_vif *wilc_get_vif_from_idx(struct wilc *wilc, int idx)\n{\n\tint index = idx - 1;\n\tstruct wilc_vif *vif;\n\n\tif (index < 0 || index >= WILC_NUM_CONCURRENT_IFC)\n\t\treturn NULL;\n\n\tlist_for_each_entry_rcu(vif, &wilc->vif_list, list) {\n\t\tif (vif->idx == index)\n\t\t\treturn vif;\n\t}\n\n\treturn NULL;\n}\n\nstatic int handle_scan_done(struct wilc_vif *vif, enum scan_event evt)\n{\n\tint result = 0;\n\tu8 abort_running_scan;\n\tstruct wid wid;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\tstruct wilc_user_scan_req *scan_req;\n\n\tif (evt == SCAN_EVENT_ABORTED) {\n\t\tabort_running_scan = 1;\n\t\twid.id = WID_ABORT_RUNNING_SCAN;\n\t\twid.type = WID_CHAR;\n\t\twid.val = (s8 *)&abort_running_scan;\n\t\twid.size = sizeof(char);\n\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\t\tif (result) {\n\t\t\tnetdev_err(vif->ndev, \"Failed to set abort running\\n\");\n\t\t\tresult = -EFAULT;\n\t\t}\n\t}\n\n\tif (!hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\\n\", __func__);\n\t\treturn result;\n\t}\n\n\tscan_req = &hif_drv->usr_scan_req;\n\tif (scan_req->scan_result) {\n\t\tscan_req->scan_result(evt, NULL, scan_req->arg);\n\t\tscan_req->scan_result = NULL;\n\t}\n\n\treturn result;\n}\n\nint wilc_scan(struct wilc_vif *vif, u8 scan_source, u8 scan_type,\n\t      u8 *ch_freq_list, u8 ch_list_len,\n\t      void (*scan_result_fn)(enum scan_event,\n\t\t\t\t     struct wilc_rcvd_net_info *, void *),\n\t      void *user_arg, struct cfg80211_scan_request *request)\n{\n\tint result = 0;\n\tstruct wid wid_list[WILC_SCAN_WID_LIST_SIZE];\n\tu32 index = 0;\n\tu32 i, scan_timeout;\n\tu8 *buffer;\n\tu8 valuesize = 0;\n\tu8 *search_ssid_vals = NULL;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (hif_drv->hif_state >= HOST_IF_SCANNING &&\n\t    hif_drv->hif_state < HOST_IF_CONNECTED) {\n\t\tnetdev_err(vif->ndev, \"Already scan\\n\");\n\t\tresult = -EBUSY;\n\t\tgoto error;\n\t}\n\n\tif (vif->connecting) {\n\t\tnetdev_err(vif->ndev, \"Don't do obss scan\\n\");\n\t\tresult = -EBUSY;\n\t\tgoto error;\n\t}\n\n\thif_drv->usr_scan_req.ch_cnt = 0;\n\n\tif (request->n_ssids) {\n\t\tfor (i = 0; i < request->n_ssids; i++)\n\t\t\tvaluesize += ((request->ssids[i].ssid_len) + 1);\n\t\tsearch_ssid_vals = kmalloc(valuesize + 1, GFP_KERNEL);\n\t\tif (search_ssid_vals) {\n\t\t\twid_list[index].id = WID_SSID_PROBE_REQ;\n\t\t\twid_list[index].type = WID_STR;\n\t\t\twid_list[index].val = search_ssid_vals;\n\t\t\tbuffer = wid_list[index].val;\n\n\t\t\t*buffer++ = request->n_ssids;\n\n\t\t\tfor (i = 0; i < request->n_ssids; i++) {\n\t\t\t\t*buffer++ = request->ssids[i].ssid_len;\n\t\t\t\tmemcpy(buffer, request->ssids[i].ssid,\n\t\t\t\t       request->ssids[i].ssid_len);\n\t\t\t\tbuffer += request->ssids[i].ssid_len;\n\t\t\t}\n\t\t\twid_list[index].size = (s32)(valuesize + 1);\n\t\t\tindex++;\n\t\t}\n\t}\n\n\twid_list[index].id = WID_INFO_ELEMENT_PROBE;\n\twid_list[index].type = WID_BIN_DATA;\n\twid_list[index].val = (s8 *)request->ie;\n\twid_list[index].size = request->ie_len;\n\tindex++;\n\n\twid_list[index].id = WID_SCAN_TYPE;\n\twid_list[index].type = WID_CHAR;\n\twid_list[index].size = sizeof(char);\n\twid_list[index].val = (s8 *)&scan_type;\n\tindex++;\n\n\tif (scan_type == WILC_FW_PASSIVE_SCAN && request->duration) {\n\t\twid_list[index].id = WID_PASSIVE_SCAN_TIME;\n\t\twid_list[index].type = WID_SHORT;\n\t\twid_list[index].size = sizeof(u16);\n\t\twid_list[index].val = (s8 *)&request->duration;\n\t\tindex++;\n\n\t\tscan_timeout = (request->duration * ch_list_len) + 500;\n\t} else {\n\t\tscan_timeout = WILC_HIF_SCAN_TIMEOUT_MS;\n\t}\n\n\twid_list[index].id = WID_SCAN_CHANNEL_LIST;\n\twid_list[index].type = WID_BIN_DATA;\n\n\tif (ch_freq_list && ch_list_len > 0) {\n\t\tfor (i = 0; i < ch_list_len; i++) {\n\t\t\tif (ch_freq_list[i] > 0)\n\t\t\t\tch_freq_list[i] -= 1;\n\t\t}\n\t}\n\n\twid_list[index].val = ch_freq_list;\n\twid_list[index].size = ch_list_len;\n\tindex++;\n\n\twid_list[index].id = WID_START_SCAN_REQ;\n\twid_list[index].type = WID_CHAR;\n\twid_list[index].size = sizeof(char);\n\twid_list[index].val = (s8 *)&scan_source;\n\tindex++;\n\n\thif_drv->usr_scan_req.scan_result = scan_result_fn;\n\thif_drv->usr_scan_req.arg = user_arg;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, index);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"Failed to send scan parameters\\n\");\n\t\tgoto error;\n\t}\n\n\thif_drv->scan_timer_vif = vif;\n\tmod_timer(&hif_drv->scan_timer,\n\t\t  jiffies + msecs_to_jiffies(scan_timeout));\n\nerror:\n\n\tkfree(search_ssid_vals);\n\n\treturn result;\n}\n\nstatic int wilc_send_connect_wid(struct wilc_vif *vif)\n{\n\tint result = 0;\n\tstruct wid wid_list[5];\n\tu32 wid_cnt = 0;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\tstruct wilc_conn_info *conn_attr = &hif_drv->conn_info;\n\tstruct wilc_join_bss_param *bss_param = conn_attr->param;\n\n\n        wid_list[wid_cnt].id = WID_SET_MFP;\n        wid_list[wid_cnt].type = WID_CHAR;\n        wid_list[wid_cnt].size = sizeof(char);\n        wid_list[wid_cnt].val = (s8 *)&conn_attr->mfp_type;\n        wid_cnt++;\n\n\twid_list[wid_cnt].id = WID_INFO_ELEMENT_ASSOCIATE;\n\twid_list[wid_cnt].type = WID_BIN_DATA;\n\twid_list[wid_cnt].val = conn_attr->req_ies;\n\twid_list[wid_cnt].size = conn_attr->req_ies_len;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_11I_MODE;\n\twid_list[wid_cnt].type = WID_CHAR;\n\twid_list[wid_cnt].size = sizeof(char);\n\twid_list[wid_cnt].val = (s8 *)&conn_attr->security;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_AUTH_TYPE;\n\twid_list[wid_cnt].type = WID_CHAR;\n\twid_list[wid_cnt].size = sizeof(char);\n\twid_list[wid_cnt].val = (s8 *)&conn_attr->auth_type;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_JOIN_REQ_EXTENDED;\n\twid_list[wid_cnt].type = WID_STR;\n\twid_list[wid_cnt].size = sizeof(*bss_param);\n\twid_list[wid_cnt].val = (u8 *)bss_param;\n\twid_cnt++;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, wid_cnt);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"failed to send config packet\\n\");\n\t\tgoto error;\n\t} else {\n                if (conn_attr->auth_type == WILC_FW_AUTH_SAE)\n                        hif_drv->hif_state = HOST_IF_EXTERNAL_AUTH;\n                else\n                        hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;\n\t}\n\n\treturn 0;\n\nerror:\n\n\tkfree(conn_attr->req_ies);\n\tconn_attr->req_ies = NULL;\n\n\treturn result;\n}\n\nstatic void handle_connect_timeout(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\tstruct wilc_vif *vif = msg->vif;\n\tint result;\n\tstruct wid wid;\n\tu16 dummy_reason_code = 0;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (!hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\\n\", __func__);\n\t\tgoto out;\n\t}\n\n\thif_drv->hif_state = HOST_IF_IDLE;\n\n\tif (hif_drv->conn_info.conn_result) {\n\t\thif_drv->conn_info.conn_result(CONN_DISCONN_EVENT_CONN_RESP,\n\t\t\t\t\t       WILC_MAC_STATUS_DISCONNECTED,\n\t\t\t\t\t       hif_drv->conn_info.arg);\n\n\t} else {\n\t\tnetdev_err(vif->ndev, \"%s: conn_result is NULL\\n\", __func__);\n\t}\n\n\twid.id = WID_DISCONNECT;\n\twid.type = WID_CHAR;\n\twid.val = (s8 *)&dummy_reason_code;\n\twid.size = sizeof(char);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send disconnect\\n\");\n\n\thif_drv->conn_info.req_ies_len = 0;\n\tkfree(hif_drv->conn_info.req_ies);\n\thif_drv->conn_info.req_ies = NULL;\n\nout:\n\tkfree(msg);\n}\n\nvoid *wilc_parse_join_bss_param(struct cfg80211_bss *bss,\n\t\t\t\tstruct cfg80211_crypto_settings *crypto)\n{\n\tstruct wilc_join_bss_param *param;\n\tstruct ieee80211_p2p_noa_attr noa_attr;\n\tu8 rates_len = 0;\n\tconst u8 *tim_elm, *ssid_elm, *rates_ie, *supp_rates_ie;\n\tconst u8 *ht_ie, *wpa_ie, *wmm_ie, *rsn_ie;\n\tint ret;\n\tconst struct cfg80211_bss_ies *ies = rcu_dereference(bss->ies);\n\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn NULL;\n\n\tparam->beacon_period = cpu_to_le16(bss->beacon_interval);\n\tparam->cap_info = cpu_to_le16(bss->capability);\n\tparam->bss_type = WILC_FW_BSS_TYPE_INFRA;\n\tparam->ch = ieee80211_frequency_to_channel(bss->channel->center_freq);\n\tether_addr_copy(param->bssid, bss->bssid);\n\n\tssid_elm = cfg80211_find_ie(WLAN_EID_SSID, ies->data, ies->len);\n\tif (ssid_elm) {\n\t\tif (ssid_elm[1] <= IEEE80211_MAX_SSID_LEN)\n\t\t\tmemcpy(param->ssid, ssid_elm + 2, ssid_elm[1]);\n\t}\n\n\ttim_elm = cfg80211_find_ie(WLAN_EID_TIM, ies->data, ies->len);\n\tif (tim_elm && tim_elm[1] >= 2)\n\t\tparam->dtim_period = tim_elm[3];\n\n\tmemset(param->p_suites, 0xFF, 3);\n\tmemset(param->akm_suites, 0xFF, 3);\n\n\trates_ie = cfg80211_find_ie(WLAN_EID_SUPP_RATES, ies->data, ies->len);\n\tif (rates_ie) {\n\t\trates_len = rates_ie[1];\n\t\tif (rates_len > WILC_MAX_RATES_SUPPORTED)\n\t\t\trates_len = WILC_MAX_RATES_SUPPORTED;\n\t\tparam->supp_rates[0] = rates_len;\n\t\tmemcpy(&param->supp_rates[1], rates_ie + 2, rates_len);\n\t}\n\n\tif (rates_len < WILC_MAX_RATES_SUPPORTED) {\n\t\tsupp_rates_ie = cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t\t ies->data, ies->len);\n\t\tif (supp_rates_ie) {\n\t\t\tu8 ext_rates = supp_rates_ie[1];\n\n\t\t\tif (ext_rates > (WILC_MAX_RATES_SUPPORTED - rates_len))\n\t\t\t\tparam->supp_rates[0] = WILC_MAX_RATES_SUPPORTED;\n\t\t\telse\n\t\t\t\tparam->supp_rates[0] += ext_rates;\n\n\t\t\tmemcpy(&param->supp_rates[rates_len + 1],\n\t\t\t       supp_rates_ie + 2,\n\t\t\t       (param->supp_rates[0] - rates_len));\n\t\t}\n\t}\n\n\tht_ie = cfg80211_find_ie(WLAN_EID_HT_CAPABILITY, ies->data, ies->len);\n\tif (ht_ie)\n\t\tparam->ht_capable = true;\n\n\tret = cfg80211_get_p2p_attr(ies->data, ies->len,\n\t\t\t\t    IEEE80211_P2P_ATTR_ABSENCE_NOTICE,\n\t\t\t\t    (u8 *)&noa_attr, sizeof(noa_attr));\n\tif (ret > 0) {\n\t\tparam->tsf_lo = cpu_to_le32(ies->tsf);\n\t\tparam->noa_enabled = 1;\n\t\tparam->idx = noa_attr.index;\n\t\tif (noa_attr.oppps_ctwindow & IEEE80211_P2P_OPPPS_ENABLE_BIT) {\n\t\t\tparam->opp_enabled = 1;\n\t\t\tparam->opp_en.ct_window = noa_attr.oppps_ctwindow;\n\t\t\tparam->opp_en.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_en.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_en.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_en.start_time = noa_attr.desc[0].start_time;\n\t\t} else {\n\t\t\tparam->opp_enabled = 0;\n\t\t\tparam->opp_dis.cnt = noa_attr.desc[0].count;\n\t\t\tparam->opp_dis.duration = noa_attr.desc[0].duration;\n\t\t\tparam->opp_dis.interval = noa_attr.desc[0].interval;\n\t\t\tparam->opp_dis.start_time = noa_attr.desc[0].start_time;\n\t\t}\n\t}\n\twmm_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wmm_ie) {\n\t\tstruct ieee80211_wmm_param_ie *ie;\n\n\t\tie = (struct ieee80211_wmm_param_ie *)wmm_ie;\n\t\tif ((ie->oui_subtype == 0 || ie->oui_subtype == 1) &&\n\t\t    ie->version == 1) {\n\t\t\tparam->wmm_cap = true;\n\t\t\tif (ie->qos_info & BIT(7))\n\t\t\t\tparam->uapsd_cap = true;\n\t\t}\n\t}\n\n\twpa_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t ies->data, ies->len);\n\tif (wpa_ie) {\n\t\tparam->mode_802_11i = 1;\n\t\tparam->rsn_found = true;\n\t}\n\n\trsn_ie = cfg80211_find_ie(WLAN_EID_RSN, ies->data, ies->len);\n\tif (rsn_ie) {\n\t\tint rsn_ie_len = sizeof(struct element) + rsn_ie[1];\n\t\tint offset = 8;\n\n\t\t/* extract RSN capabilities */\n\t\tif (offset < rsn_ie_len) {\n\t\t\t/* skip over pairwise suites */\n\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n\n\t\t\tif (offset < rsn_ie_len) {\n\t\t\t\t/* skip over authentication suites */\n\t\t\t\toffset += (rsn_ie[offset] * 4) + 2;\n\n\t\t\t\tif (offset + 1 < rsn_ie_len) {\n\t\t\t\t\tparam->mode_802_11i = 2;\n\t\t\t\t\tparam->rsn_found = true;\n\t\t\t\t\tmemcpy(param->rsn_cap, &rsn_ie[offset], 2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (param->rsn_found) {\n\t\tint i;\n\n\t\tparam->rsn_grp_policy = crypto->cipher_group & 0xFF;\n\t\tfor (i = 0; i < crypto->n_ciphers_pairwise && i < 3; i++)\n\t\t\tparam->p_suites[i] = crypto->ciphers_pairwise[i] & 0xFF;\n\n\t\tfor (i = 0; i < crypto->n_akm_suites && i < 3; i++)\n\t\t\tparam->akm_suites[i] = crypto->akm_suites[i] & 0xFF;\n\t}\n\n\treturn (void *)param;\n}\n\nstatic void handle_rcvd_ntwrk_info(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\tstruct wilc_rcvd_net_info *rcvd_info = &msg->body.net_info;\n\tstruct wilc_user_scan_req *scan_req = &msg->vif->hif_drv->usr_scan_req;\n\tconst u8 *ch_elm;\n\tu8 *ies;\n\tint ies_len;\n\tsize_t offset;\n\n\tif (ieee80211_is_probe_resp(rcvd_info->mgmt->frame_control))\n\t\toffset = offsetof(struct ieee80211_mgmt, u.probe_resp.variable);\n\telse if (ieee80211_is_beacon(rcvd_info->mgmt->frame_control))\n\t\toffset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\telse\n\t\tgoto done;\n\n\ties = rcvd_info->mgmt->u.beacon.variable;\n\ties_len = rcvd_info->frame_len - offset;\n\tif (ies_len <= 0)\n\t\tgoto done;\n\n\tch_elm = cfg80211_find_ie(WLAN_EID_DS_PARAMS, ies, ies_len);\n\tif (ch_elm && ch_elm[1] > 0)\n\t\trcvd_info->ch = ch_elm[2];\n\n\tif (scan_req->scan_result)\n\t\tscan_req->scan_result(SCAN_EVENT_NETWORK_FOUND, rcvd_info,\n\t\t\t\t      scan_req->arg);\n\ndone:\n\tkfree(rcvd_info->mgmt);\n\tkfree(msg);\n}\n\nstatic void host_int_get_assoc_res_info(struct wilc_vif *vif,\n\t\t\t\t\tu8 *assoc_resp_info,\n\t\t\t\t\tu32 max_assoc_resp_info_len,\n\t\t\t\t\tu32 *rcvd_assoc_resp_info_len)\n{\n\tint result;\n\tstruct wid wid;\n\n\twid.id = WID_ASSOC_RES_INFO;\n\twid.type = WID_STR;\n\twid.val = assoc_resp_info;\n\twid.size = max_assoc_resp_info_len;\n\n\tresult = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);\n\tif (result) {\n\t\t*rcvd_assoc_resp_info_len = 0;\n\t\tnetdev_err(vif->ndev, \"Failed to send association response\\n\");\n\t\treturn;\n\t}\n\n\t*rcvd_assoc_resp_info_len = wid.size;\n}\n\nstatic s32 wilc_parse_assoc_resp_info(u8 *buffer, u32 buffer_len,\n\t\t\t\t      struct wilc_conn_info *ret_conn_info)\n{\n\tu8 *ies;\n\tu16 ies_len;\n\tstruct wilc_assoc_resp *res = (struct wilc_assoc_resp *)buffer;\n\n\tret_conn_info->status = le16_to_cpu(res->status_code);\n\tif (ret_conn_info->status == WLAN_STATUS_SUCCESS) {\n\t\ties = &buffer[sizeof(*res)];\n\t\ties_len = buffer_len - sizeof(*res);\n\n\t\tret_conn_info->resp_ies = kmemdup(ies, ies_len, GFP_KERNEL);\n\t\tif (!ret_conn_info->resp_ies)\n\t\t\treturn -ENOMEM;\n\n\t\tret_conn_info->resp_ies_len = ies_len;\n\t}\n\n\treturn 0;\n}\n\nstatic inline void host_int_parse_assoc_resp_info(struct wilc_vif *vif,\n\t\t\t\t\t\t  u8 mac_status)\n{\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\tstruct wilc_conn_info *conn_info = &hif_drv->conn_info;\n\n\tif (mac_status == WILC_MAC_STATUS_CONNECTED) {\n\t\tu32 assoc_resp_info_len;\n\n\t\tmemset(hif_drv->assoc_resp, 0, WILC_MAX_ASSOC_RESP_FRAME_SIZE);\n\n\t\thost_int_get_assoc_res_info(vif, hif_drv->assoc_resp,\n\t\t\t\t\t    WILC_MAX_ASSOC_RESP_FRAME_SIZE,\n\t\t\t\t\t    &assoc_resp_info_len);\n\n\t\tif (assoc_resp_info_len != 0) {\n\t\t\ts32 err = 0;\n\n\t\t\terr = wilc_parse_assoc_resp_info(hif_drv->assoc_resp,\n\t\t\t\t\t\t\t assoc_resp_info_len,\n\t\t\t\t\t\t\t conn_info);\n\t\t\tif (err)\n\t\t\t\tnetdev_err(vif->ndev,\n\t\t\t\t\t   \"wilc_parse_assoc_resp_info() returned error %d\\n\",\n\t\t\t\t\t   err);\n\t\t}\n\t}\n\n\tdel_timer(&hif_drv->connect_timer);\n\tconn_info->conn_result(CONN_DISCONN_EVENT_CONN_RESP, mac_status,\n\t\t\t       hif_drv->conn_info.arg);\n\n\tif (mac_status == WILC_MAC_STATUS_CONNECTED &&\n\t    conn_info->status == WLAN_STATUS_SUCCESS) {\n\t\tether_addr_copy(hif_drv->assoc_bssid, conn_info->bssid);\n\t\thif_drv->hif_state = HOST_IF_CONNECTED;\n\t} else {\n\t\thif_drv->hif_state = HOST_IF_IDLE;\n\t}\n\n\tkfree(conn_info->resp_ies);\n\tconn_info->resp_ies = NULL;\n\tconn_info->resp_ies_len = 0;\n\n\tkfree(conn_info->req_ies);\n\tconn_info->req_ies = NULL;\n\tconn_info->req_ies_len = 0;\n}\n\nvoid wilc_handle_disconnect(struct wilc_vif *vif)\n{\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (hif_drv->usr_scan_req.scan_result) {\n\t\tdel_timer(&hif_drv->scan_timer);\n\t\thandle_scan_done(vif, SCAN_EVENT_ABORTED);\n\t}\n\n\tif (hif_drv->conn_info.conn_result)\n\t\thif_drv->conn_info.conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF,\n\t\t\t\t\t       0, hif_drv->conn_info.arg);\n\n\teth_zero_addr(hif_drv->assoc_bssid);\n\n\thif_drv->conn_info.req_ies_len = 0;\n\tkfree(hif_drv->conn_info.req_ies);\n\thif_drv->conn_info.req_ies = NULL;\n\thif_drv->hif_state = HOST_IF_IDLE;\n}\n\nstatic void handle_rcvd_gnrl_async_info(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\tstruct wilc_vif *vif = msg->vif;\n\tstruct wilc_rcvd_mac_info *mac_info = &msg->body.mac_info;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (!hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\\n\", __func__);\n\t\tgoto free_msg;\n\t}\n\n\tif (!hif_drv->conn_info.conn_result) {\n\t\tnetdev_err(vif->ndev, \"%s: conn_result is NULL\\n\", __func__);\n\t\tgoto free_msg;\n\t}\n\n\n        if (hif_drv->hif_state == HOST_IF_EXTERNAL_AUTH) {\n                cfg80211_external_auth_request(vif->ndev, &vif->auth,\n\t\t\t\t\t       GFP_KERNEL);\n                hif_drv->hif_state = HOST_IF_WAITING_CONN_RESP;\n        } else if (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP) {\n\t\thost_int_parse_assoc_resp_info(vif, mac_info->status);\n\t} else if (mac_info->status == WILC_MAC_STATUS_DISCONNECTED) {\n\t\tif (hif_drv->hif_state == HOST_IF_CONNECTED) {\n\t\t\twilc_handle_disconnect(vif);\n\t\t} else if (hif_drv->usr_scan_req.scan_result) {\n\t\t\tdel_timer(&hif_drv->scan_timer);\n\t\t\thandle_scan_done(vif, SCAN_EVENT_ABORTED);\n\t\t}\n\t}\n\nfree_msg:\n\tkfree(msg);\n}\n\nint wilc_disconnect(struct wilc_vif *vif)\n{\n\tstruct wid wid;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\tstruct wilc_user_scan_req *scan_req;\n\tstruct wilc_conn_info *conn_info;\n\tint result;\n\tu16 dummy_reason_code = 0;\n\n\twid.id = WID_DISCONNECT;\n\twid.type = WID_CHAR;\n\twid.val = (s8 *)&dummy_reason_code;\n\twid.size = sizeof(char);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"Failed to send disconnect\\n\");\n\t\treturn result;\n\t}\n\n\tscan_req = &hif_drv->usr_scan_req;\n\tconn_info = &hif_drv->conn_info;\n\n\tif (scan_req->scan_result) {\n\t\tdel_timer(&hif_drv->scan_timer);\n\t\tscan_req->scan_result(SCAN_EVENT_ABORTED, NULL, scan_req->arg);\n\t\tscan_req->scan_result = NULL;\n\t}\n\n\tif (conn_info->conn_result) {\n\t\tif (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP ||\n\t\t    hif_drv->hif_state == HOST_IF_EXTERNAL_AUTH)\n\t\t\tdel_timer(&hif_drv->connect_timer);\n\n\t\tconn_info->conn_result(CONN_DISCONN_EVENT_DISCONN_NOTIF, 0,\n\t\t\t\t       conn_info->arg);\n\t} else {\n\t\tnetdev_err(vif->ndev, \"%s: conn_result is NULL\\n\", __func__);\n\t}\n\n\thif_drv->hif_state = HOST_IF_IDLE;\n\n\teth_zero_addr(hif_drv->assoc_bssid);\n\n\tconn_info->req_ies_len = 0;\n\tkfree(conn_info->req_ies);\n\tconn_info->req_ies = NULL;\n\n\treturn 0;\n}\n\nint wilc_get_statistics(struct wilc_vif *vif, struct rf_info *stats)\n{\n\tstruct wid wid_list[5];\n\tu32 wid_cnt = 0, result;\n\n\twid_list[wid_cnt].id = WID_LINKSPEED;\n\twid_list[wid_cnt].type = WID_CHAR;\n\twid_list[wid_cnt].size = sizeof(char);\n\twid_list[wid_cnt].val = (s8 *)&stats->link_speed;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_RSSI;\n\twid_list[wid_cnt].type = WID_CHAR;\n\twid_list[wid_cnt].size = sizeof(char);\n\twid_list[wid_cnt].val = (s8 *)&stats->rssi;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_SUCCESS_FRAME_COUNT;\n\twid_list[wid_cnt].type = WID_INT;\n\twid_list[wid_cnt].size = sizeof(u32);\n\twid_list[wid_cnt].val = (s8 *)&stats->tx_cnt;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_RECEIVED_FRAGMENT_COUNT;\n\twid_list[wid_cnt].type = WID_INT;\n\twid_list[wid_cnt].size = sizeof(u32);\n\twid_list[wid_cnt].val = (s8 *)&stats->rx_cnt;\n\twid_cnt++;\n\n\twid_list[wid_cnt].id = WID_FAILED_COUNT;\n\twid_list[wid_cnt].type = WID_INT;\n\twid_list[wid_cnt].size = sizeof(u32);\n\twid_list[wid_cnt].val = (s8 *)&stats->tx_fail_cnt;\n\twid_cnt++;\n\n\tresult = wilc_send_config_pkt(vif, WILC_GET_CFG, wid_list, wid_cnt);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"Failed to send scan parameters\\n\");\n\t\treturn result;\n\t}\n\n\tif (stats->link_speed > TCP_ACK_FILTER_LINK_SPEED_THRESH &&\n\t    stats->link_speed != DEFAULT_LINK_SPEED)\n\t\twilc_enable_tcp_ack_filter(vif, true);\n\telse if (stats->link_speed != DEFAULT_LINK_SPEED)\n\t\twilc_enable_tcp_ack_filter(vif, false);\n\n\treturn result;\n}\n\nstatic void handle_get_statistics(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\tstruct wilc_vif *vif = msg->vif;\n\tstruct rf_info *stats = (struct rf_info *)msg->body.data;\n\n\twilc_get_statistics(vif, stats);\n\n\tkfree(msg);\n}\n\nstatic void wilc_hif_pack_sta_param(u8 *cur_byte, const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tether_addr_copy(cur_byte, mac);\n\tcur_byte += ETH_ALEN;\n\n\tput_unaligned_le16(params->aid, cur_byte);\n\tcur_byte += 2;\n\n\t*cur_byte++ = params->link_sta_params.supported_rates_len;\n\tif (params->link_sta_params.supported_rates_len > 0)\n\t\tmemcpy(cur_byte, params->link_sta_params.supported_rates,\n\t\t       params->link_sta_params.supported_rates_len);\n\tcur_byte += params->link_sta_params.supported_rates_len;\n\n\tif (params->link_sta_params.ht_capa) {\n\t\t*cur_byte++ = true;\n\t\tmemcpy(cur_byte, params->link_sta_params.ht_capa,\n\t\t       sizeof(struct ieee80211_ht_cap));\n\t} else {\n\t\t*cur_byte++ = false;\n\t}\n\tcur_byte += sizeof(struct ieee80211_ht_cap);\n\n\tput_unaligned_le16(params->sta_flags_mask, cur_byte);\n\tcur_byte += 2;\n\tput_unaligned_le16(params->sta_flags_set, cur_byte);\n}\n\nstatic int handle_remain_on_chan(struct wilc_vif *vif,\n\t\t\t\t struct wilc_remain_ch *hif_remain_ch)\n{\n\tint result;\n\tu8 remain_on_chan_flag;\n\tstruct wid wid;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (hif_drv->usr_scan_req.scan_result)\n\t\treturn -EBUSY;\n\n\tif (hif_drv->hif_state == HOST_IF_WAITING_CONN_RESP)\n\t\treturn -EBUSY;\n\n\tif (vif->connecting)\n\t\treturn -EBUSY;\n\n\tremain_on_chan_flag = true;\n\twid.id = WID_REMAIN_ON_CHAN;\n\twid.type = WID_STR;\n\twid.size = 2;\n\twid.val = kmalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\twid.val[0] = remain_on_chan_flag;\n\twid.val[1] = (s8)hif_remain_ch->ch;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tkfree(wid.val);\n\tif (result)\n\t\treturn -EBUSY;\n\n\thif_drv->remain_on_ch.arg = hif_remain_ch->arg;\n\thif_drv->remain_on_ch.expired = hif_remain_ch->expired;\n\thif_drv->remain_on_ch.ch = hif_remain_ch->ch;\n\thif_drv->remain_on_ch.cookie = hif_remain_ch->cookie;\n\thif_drv->remain_on_ch_timer_vif = vif;\n\n\treturn 0;\n}\n\nstatic int wilc_handle_roc_expired(struct wilc_vif *vif, u64 cookie)\n{\n\tu8 remain_on_chan_flag;\n\tstruct wid wid;\n\tint result;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (vif->priv.p2p_listen_state) {\n\t\tremain_on_chan_flag = false;\n\t\twid.id = WID_REMAIN_ON_CHAN;\n\t\twid.type = WID_STR;\n\t\twid.size = 2;\n\n\t\twid.val = kmalloc(wid.size, GFP_KERNEL);\n\t\tif (!wid.val)\n\t\t\treturn -ENOMEM;\n\n\t\twid.val[0] = remain_on_chan_flag;\n\t\twid.val[1] = WILC_FALSE_FRMWR_CHANNEL;\n\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\t\tkfree(wid.val);\n\t\tif (result != 0) {\n\t\t\tnetdev_err(vif->ndev, \"Failed to set remain channel\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tif (hif_drv->remain_on_ch.expired) {\n\t\t\thif_drv->remain_on_ch.expired(hif_drv->remain_on_ch.arg,\n\t\t\t\t\t\t      cookie);\n\t\t}\n\t} else {\n\t\tnetdev_dbg(vif->ndev, \"Not in listen state\\n\");\n\t}\n\n\treturn 0;\n}\n\nstatic void wilc_handle_listen_state_expired(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\n\twilc_handle_roc_expired(msg->vif, msg->body.remain_on_ch.cookie);\n\tkfree(msg);\n}\n\nstatic void listen_timer_cb(struct timer_list *t)\n{\n\tstruct host_if_drv *hif_drv = from_timer(hif_drv, t,\n\t\t\t\t\t\t      remain_on_ch_timer);\n\tstruct wilc_vif *vif = hif_drv->remain_on_ch_timer_vif;\n\tint result;\n\tstruct host_if_msg *msg;\n\n\tdel_timer(&vif->hif_drv->remain_on_ch_timer);\n\n\tmsg = wilc_alloc_work(vif, wilc_handle_listen_state_expired, false);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\tmsg->body.remain_on_ch.cookie = vif->hif_drv->remain_on_ch.cookie;\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\", __func__);\n\t\tkfree(msg);\n\t}\n}\n\nstatic void handle_set_mcast_filter(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\tstruct wilc_vif *vif = msg->vif;\n\tstruct wilc_set_multicast *set_mc = &msg->body.mc_info;\n\tint result;\n\tstruct wid wid;\n\tu8 *cur_byte;\n\n\twid.id = WID_SETUP_MULTICAST_FILTER;\n\twid.type = WID_BIN;\n\twid.size = sizeof(struct wilc_set_multicast) + (set_mc->cnt * ETH_ALEN);\n\twid.val = kmalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\tgoto error;\n\n\tcur_byte = wid.val;\n\tput_unaligned_le32(set_mc->enabled, cur_byte);\n\tcur_byte += 4;\n\n\tput_unaligned_le32(set_mc->cnt, cur_byte);\n\tcur_byte += 4;\n\n\tif (set_mc->cnt > 0 && set_mc->mc_list)\n\t\tmemcpy(cur_byte, set_mc->mc_list, set_mc->cnt * ETH_ALEN);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send setup multicast\\n\");\n\nerror:\n\tkfree(set_mc->mc_list);\n\tkfree(wid.val);\n\tkfree(msg);\n}\n\nvoid wilc_set_wowlan_trigger(struct wilc_vif *vif, bool enabled)\n{\n\tint ret;\n\tstruct wid wid;\n\tu8 wowlan_trigger = 0;\n\n\tif (enabled)\n\t\twowlan_trigger = 1;\n\n\twid.id = WID_WOWLAN_TRIGGER;\n\twid.type = WID_CHAR;\n\twid.val = &wowlan_trigger;\n\twid.size = sizeof(char);\n\n\tret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (ret)\n\t\tpr_err(\"Failed to send wowlan trigger config packet\\n\");\n}\n\nint wilc_set_external_auth_param(struct wilc_vif *vif,\n\t\t\t\t struct cfg80211_external_auth_params *auth)\n{\n\tint ret;\n\tstruct wid wid;\n\tstruct wilc_external_auth_param *param;\n\n\twid.id = WID_EXTERNAL_AUTH_PARAM;\n\twid.type = WID_BIN_DATA;\n\twid.size = sizeof(*param);\n\tparam = kzalloc(sizeof(*param), GFP_KERNEL);\n\tif (!param)\n\t\treturn -EINVAL;\n\n\twid.val = (u8 *)param;\n\tparam->action = auth->action;\n\tether_addr_copy(param->bssid, auth->bssid);\n\tmemcpy(param->ssid, auth->ssid.ssid, auth->ssid.ssid_len);\n\tparam->ssid_len = auth->ssid.ssid_len;\n\tret = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\n\tkfree(param);\n\treturn ret;\n}\n\nstatic void handle_scan_timer(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\n\thandle_scan_done(msg->vif, SCAN_EVENT_ABORTED);\n\tkfree(msg);\n}\n\nstatic void handle_scan_complete(struct work_struct *work)\n{\n\tstruct host_if_msg *msg = container_of(work, struct host_if_msg, work);\n\n\tdel_timer(&msg->vif->hif_drv->scan_timer);\n\n\thandle_scan_done(msg->vif, SCAN_EVENT_DONE);\n\n\tkfree(msg);\n}\n\nstatic void timer_scan_cb(struct timer_list *t)\n{\n\tstruct host_if_drv *hif_drv = from_timer(hif_drv, t, scan_timer);\n\tstruct wilc_vif *vif = hif_drv->scan_timer_vif;\n\tstruct host_if_msg *msg;\n\tint result;\n\n\tmsg = wilc_alloc_work(vif, handle_scan_timer, false);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result)\n\t\tkfree(msg);\n}\n\nstatic void timer_connect_cb(struct timer_list *t)\n{\n\tstruct host_if_drv *hif_drv = from_timer(hif_drv, t,\n\t\t\t\t\t\t      connect_timer);\n\tstruct wilc_vif *vif = hif_drv->connect_timer_vif;\n\tstruct host_if_msg *msg;\n\tint result;\n\n\tmsg = wilc_alloc_work(vif, handle_connect_timeout, false);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result)\n\t\tkfree(msg);\n}\n\nint wilc_add_ptk(struct wilc_vif *vif, const u8 *ptk, u8 ptk_key_len,\n\t\t const u8 *mac_addr, const u8 *rx_mic, const u8 *tx_mic,\n\t\t u8 mode, u8 cipher_mode, u8 index)\n{\n\tint result = 0;\n\tu8 t_key_len  = ptk_key_len + WILC_RX_MIC_KEY_LEN + WILC_TX_MIC_KEY_LEN;\n\n\tif (mode == WILC_AP_MODE) {\n\t\tstruct wid wid_list[2];\n\t\tstruct wilc_ap_wpa_ptk *key_buf;\n\n\t\twid_list[0].id = WID_11I_MODE;\n\t\twid_list[0].type = WID_CHAR;\n\t\twid_list[0].size = sizeof(char);\n\t\twid_list[0].val = (s8 *)&cipher_mode;\n\n\t\tkey_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);\n\t\tif (!key_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tether_addr_copy(key_buf->mac_addr, mac_addr);\n\t\tkey_buf->index = index;\n\t\tkey_buf->key_len = t_key_len;\n\t\tmemcpy(&key_buf->key[0], ptk, ptk_key_len);\n\n\t\tif (rx_mic)\n\t\t\tmemcpy(&key_buf->key[ptk_key_len], rx_mic,\n\t\t\t       WILC_RX_MIC_KEY_LEN);\n\n\t\tif (tx_mic)\n\t\t\tmemcpy(&key_buf->key[ptk_key_len + WILC_RX_MIC_KEY_LEN],\n\t\t\t       tx_mic, WILC_TX_MIC_KEY_LEN);\n\n\t\twid_list[1].id = WID_ADD_PTK;\n\t\twid_list[1].type = WID_STR;\n\t\twid_list[1].size = sizeof(*key_buf) + t_key_len;\n\t\twid_list[1].val = (u8 *)key_buf;\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list,\n\t\t\t\t\t      ARRAY_SIZE(wid_list));\n\t\tkfree(key_buf);\n\t} else if (mode == WILC_STATION_MODE) {\n\t\tstruct wid wid;\n\t\tstruct wilc_sta_wpa_ptk *key_buf;\n\n\t\tkey_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);\n\t\tif (!key_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tether_addr_copy(key_buf->mac_addr, mac_addr);\n\t\tkey_buf->key_len = t_key_len;\n\t\tmemcpy(&key_buf->key[0], ptk, ptk_key_len);\n\n\t\tif (rx_mic)\n\t\t\tmemcpy(&key_buf->key[ptk_key_len], rx_mic,\n\t\t\t       WILC_RX_MIC_KEY_LEN);\n\n\t\tif (tx_mic)\n\t\t\tmemcpy(&key_buf->key[ptk_key_len + WILC_RX_MIC_KEY_LEN],\n\t\t\t       tx_mic, WILC_TX_MIC_KEY_LEN);\n\n\t\twid.id = WID_ADD_PTK;\n\t\twid.type = WID_STR;\n\t\twid.size = sizeof(*key_buf) + t_key_len;\n\t\twid.val = (s8 *)key_buf;\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\t\tkfree(key_buf);\n\t}\n\n\treturn result;\n}\n\nint wilc_add_igtk(struct wilc_vif *vif, const u8 *igtk, u8 igtk_key_len,\n\t\t  const u8 *pn, u8 pn_len, const u8 *mac_addr, u8 mode, u8 index)\n{\n\tint result = 0;\n\tu8 t_key_len = igtk_key_len;\n\tstruct wid wid;\n\tstruct wilc_wpa_igtk *key_buf;\n\n\tkey_buf = kzalloc(sizeof(*key_buf) + t_key_len, GFP_KERNEL);\n\tif (!key_buf)\n\t\treturn -ENOMEM;\n\n\tkey_buf->index = index;\n\n\tmemcpy(&key_buf->pn[0], pn, pn_len);\n\tkey_buf->pn_len = pn_len;\n\n\tmemcpy(&key_buf->key[0], igtk, igtk_key_len);\n\tkey_buf->key_len = t_key_len;\n\n\twid.id = WID_ADD_IGTK;\n\twid.type = WID_STR;\n\twid.size = sizeof(*key_buf) + t_key_len;\n\twid.val = (s8 *)key_buf;\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tkfree(key_buf);\n\n\treturn result;\n}\n\nint wilc_add_rx_gtk(struct wilc_vif *vif, const u8 *rx_gtk, u8 gtk_key_len,\n\t\t    u8 index, u32 key_rsc_len, const u8 *key_rsc,\n\t\t    const u8 *rx_mic, const u8 *tx_mic, u8 mode,\n\t\t    u8 cipher_mode)\n{\n\tint result = 0;\n\tstruct wilc_gtk_key *gtk_key;\n\tint t_key_len = gtk_key_len + WILC_RX_MIC_KEY_LEN + WILC_TX_MIC_KEY_LEN;\n\n\tgtk_key = kzalloc(sizeof(*gtk_key) + t_key_len, GFP_KERNEL);\n\tif (!gtk_key)\n\t\treturn -ENOMEM;\n\n\t/* fill bssid value only in station mode */\n\tif (mode == WILC_STATION_MODE &&\n\t    vif->hif_drv->hif_state == HOST_IF_CONNECTED)\n\t\tmemcpy(gtk_key->mac_addr, vif->hif_drv->assoc_bssid, ETH_ALEN);\n\n\tif (key_rsc)\n\t\tmemcpy(gtk_key->rsc, key_rsc, 8);\n\tgtk_key->index = index;\n\tgtk_key->key_len = t_key_len;\n\tmemcpy(&gtk_key->key[0], rx_gtk, gtk_key_len);\n\n\tif (rx_mic)\n\t\tmemcpy(&gtk_key->key[gtk_key_len], rx_mic, WILC_RX_MIC_KEY_LEN);\n\n\tif (tx_mic)\n\t\tmemcpy(&gtk_key->key[gtk_key_len + WILC_RX_MIC_KEY_LEN],\n\t\t       tx_mic, WILC_TX_MIC_KEY_LEN);\n\n\tif (mode == WILC_AP_MODE) {\n\t\tstruct wid wid_list[2];\n\n\t\twid_list[0].id = WID_11I_MODE;\n\t\twid_list[0].type = WID_CHAR;\n\t\twid_list[0].size = sizeof(char);\n\t\twid_list[0].val = (s8 *)&cipher_mode;\n\n\t\twid_list[1].id = WID_ADD_RX_GTK;\n\t\twid_list[1].type = WID_STR;\n\t\twid_list[1].size = sizeof(*gtk_key) + t_key_len;\n\t\twid_list[1].val = (u8 *)gtk_key;\n\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list,\n\t\t\t\t\t      ARRAY_SIZE(wid_list));\n\t} else if (mode == WILC_STATION_MODE) {\n\t\tstruct wid wid;\n\n\t\twid.id = WID_ADD_RX_GTK;\n\t\twid.type = WID_STR;\n\t\twid.size = sizeof(*gtk_key) + t_key_len;\n\t\twid.val = (u8 *)gtk_key;\n\t\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\t}\n\n\tkfree(gtk_key);\n\treturn result;\n}\n\nint wilc_set_pmkid_info(struct wilc_vif *vif, struct wilc_pmkid_attr *pmkid)\n{\n\tstruct wid wid;\n\n\twid.id = WID_PMKID_INFO;\n\twid.type = WID_STR;\n\twid.size = (pmkid->numpmkid * sizeof(struct wilc_pmkid)) + 1;\n\twid.val = (u8 *)pmkid;\n\n\treturn wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n}\n\nint wilc_get_mac_address(struct wilc_vif *vif, u8 *mac_addr)\n{\n\tint result;\n\tstruct wid wid;\n\n\twid.id = WID_MAC_ADDR;\n\twid.type = WID_STR;\n\twid.size = ETH_ALEN;\n\twid.val = mac_addr;\n\n\tresult = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to get mac address\\n\");\n\n\treturn result;\n}\n\nint wilc_set_mac_address(struct wilc_vif *vif, u8 *mac_addr)\n{\n\tstruct wid wid;\n\tint result;\n\n\twid.id = WID_MAC_ADDR;\n\twid.type = WID_STR;\n\twid.size = ETH_ALEN;\n\twid.val = mac_addr;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to set mac address\\n\");\n\n\treturn result;\n}\n\nint wilc_set_join_req(struct wilc_vif *vif, u8 *bssid, const u8 *ies,\n\t\t      size_t ies_len)\n{\n\tint result;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\tstruct wilc_conn_info *conn_info = &hif_drv->conn_info;\n\n\tif (bssid)\n\t\tether_addr_copy(conn_info->bssid, bssid);\n\n\tif (ies) {\n\t\tconn_info->req_ies_len = ies_len;\n\t\tconn_info->req_ies = kmemdup(ies, ies_len, GFP_KERNEL);\n\t\tif (!conn_info->req_ies)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tresult = wilc_send_connect_wid(vif);\n\tif (result)\n\t\tgoto free_ies;\n\n\thif_drv->connect_timer_vif = vif;\n\tmod_timer(&hif_drv->connect_timer,\n\t\t  jiffies + msecs_to_jiffies(WILC_HIF_CONNECT_TIMEOUT_MS));\n\n\treturn 0;\n\nfree_ies:\n\tkfree(conn_info->req_ies);\n\n\treturn result;\n}\n\nint wilc_set_mac_chnl_num(struct wilc_vif *vif, u8 channel)\n{\n\tstruct wid wid;\n\tint result;\n\n\twid.id = WID_CURRENT_CHANNEL;\n\twid.type = WID_CHAR;\n\twid.size = sizeof(char);\n\twid.val = &channel;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to set channel\\n\");\n\n\treturn result;\n}\n\nint wilc_set_operation_mode(struct wilc_vif *vif, int index, u8 mode,\n\t\t\t    u8 ifc_id)\n{\n\tstruct wid wid;\n\tint result;\n\tstruct wilc_drv_handler drv;\n\n\twid.id = WID_SET_OPERATION_MODE;\n\twid.type = WID_STR;\n\twid.size = sizeof(drv);\n\twid.val = (u8 *)&drv;\n\n\tdrv.handler = cpu_to_le32(index);\n\tdrv.mode = (ifc_id | (mode << 1));\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to set driver handler\\n\");\n\n\treturn result;\n}\n\ns32 wilc_get_inactive_time(struct wilc_vif *vif, const u8 *mac, u32 *out_val)\n{\n\tstruct wid wid;\n\ts32 result;\n\n\twid.id = WID_SET_STA_MAC_INACTIVE_TIME;\n\twid.type = WID_STR;\n\twid.size = ETH_ALEN;\n\twid.val = kzalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\tether_addr_copy(wid.val, mac);\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tkfree(wid.val);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"Failed to set inactive mac\\n\");\n\t\treturn result;\n\t}\n\n\twid.id = WID_GET_INACTIVE_TIME;\n\twid.type = WID_INT;\n\twid.val = (s8 *)out_val;\n\twid.size = sizeof(u32);\n\tresult = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to get inactive time\\n\");\n\n\treturn result;\n}\n\nint wilc_get_rssi(struct wilc_vif *vif, s8 *rssi_level)\n{\n\tstruct wid wid;\n\tint result;\n\n\tif (!rssi_level) {\n\t\tnetdev_err(vif->ndev, \"%s: RSSI level is NULL\\n\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\twid.id = WID_RSSI;\n\twid.type = WID_CHAR;\n\twid.size = sizeof(char);\n\twid.val = rssi_level;\n\tresult = wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to get RSSI value\\n\");\n\n\treturn result;\n}\n\nstatic int wilc_get_stats_async(struct wilc_vif *vif, struct rf_info *stats)\n{\n\tint result;\n\tstruct host_if_msg *msg;\n\n\tmsg = wilc_alloc_work(vif, handle_get_statistics, false);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tmsg->body.data = (char *)stats;\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\", __func__);\n\t\tkfree(msg);\n\t\treturn result;\n\t}\n\n\treturn result;\n}\n\nint wilc_hif_set_cfg(struct wilc_vif *vif, struct cfg_param_attr *param)\n{\n\tstruct wid wid_list[4];\n\tint i = 0;\n\n\tif (param->flag & WILC_CFG_PARAM_RETRY_SHORT) {\n\t\twid_list[i].id = WID_SHORT_RETRY_LIMIT;\n\t\twid_list[i].val = (s8 *)&param->short_retry_limit;\n\t\twid_list[i].type = WID_SHORT;\n\t\twid_list[i].size = sizeof(u16);\n\t\ti++;\n\t}\n\tif (param->flag & WILC_CFG_PARAM_RETRY_LONG) {\n\t\twid_list[i].id = WID_LONG_RETRY_LIMIT;\n\t\twid_list[i].val = (s8 *)&param->long_retry_limit;\n\t\twid_list[i].type = WID_SHORT;\n\t\twid_list[i].size = sizeof(u16);\n\t\ti++;\n\t}\n\tif (param->flag & WILC_CFG_PARAM_FRAG_THRESHOLD) {\n\t\twid_list[i].id = WID_FRAG_THRESHOLD;\n\t\twid_list[i].val = (s8 *)&param->frag_threshold;\n\t\twid_list[i].type = WID_SHORT;\n\t\twid_list[i].size = sizeof(u16);\n\t\ti++;\n\t}\n\tif (param->flag & WILC_CFG_PARAM_RTS_THRESHOLD) {\n\t\twid_list[i].id = WID_RTS_THRESHOLD;\n\t\twid_list[i].val = (s8 *)&param->rts_threshold;\n\t\twid_list[i].type = WID_SHORT;\n\t\twid_list[i].size = sizeof(u16);\n\t\ti++;\n\t}\n\n\treturn wilc_send_config_pkt(vif, WILC_SET_CFG, wid_list, i);\n}\n\nstatic void get_periodic_rssi(struct timer_list *t)\n{\n\tstruct wilc_vif *vif = from_timer(vif, t, periodic_rssi);\n\n\tif (!vif->hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\", __func__);\n\t\treturn;\n\t}\n\n\tif (vif->hif_drv->hif_state == HOST_IF_CONNECTED)\n\t\twilc_get_stats_async(vif, &vif->periodic_stat);\n\n\tmod_timer(&vif->periodic_rssi, jiffies + msecs_to_jiffies(5000));\n}\n\nint wilc_init(struct net_device *dev, struct host_if_drv **hif_drv_handler)\n{\n\tstruct host_if_drv *hif_drv;\n\tstruct wilc_vif *vif = netdev_priv(dev);\n\n\thif_drv  = kzalloc(sizeof(*hif_drv), GFP_KERNEL);\n\tif (!hif_drv)\n\t\treturn -ENOMEM;\n\n\t*hif_drv_handler = hif_drv;\n\n\tvif->hif_drv = hif_drv;\n\n\ttimer_setup(&vif->periodic_rssi, get_periodic_rssi, 0);\n\tmod_timer(&vif->periodic_rssi, jiffies + msecs_to_jiffies(5000));\n\n\ttimer_setup(&hif_drv->scan_timer, timer_scan_cb, 0);\n\ttimer_setup(&hif_drv->connect_timer, timer_connect_cb, 0);\n\ttimer_setup(&hif_drv->remain_on_ch_timer, listen_timer_cb, 0);\n\n\thif_drv->hif_state = HOST_IF_IDLE;\n\n\thif_drv->p2p_timeout = 0;\n\n\treturn 0;\n}\n\nint wilc_deinit(struct wilc_vif *vif)\n{\n\tint result = 0;\n\tstruct host_if_drv *hif_drv = vif->hif_drv;\n\n\tif (!hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tmutex_lock(&vif->wilc->deinit_lock);\n\n\tdel_timer_sync(&hif_drv->scan_timer);\n\tdel_timer_sync(&hif_drv->connect_timer);\n\tdel_timer_sync(&vif->periodic_rssi);\n\tdel_timer_sync(&hif_drv->remain_on_ch_timer);\n\n\tif (hif_drv->usr_scan_req.scan_result) {\n\t\thif_drv->usr_scan_req.scan_result(SCAN_EVENT_ABORTED, NULL,\n\t\t\t\t\t\t  hif_drv->usr_scan_req.arg);\n\t\thif_drv->usr_scan_req.scan_result = NULL;\n\t}\n\n\thif_drv->hif_state = HOST_IF_IDLE;\n\n\tkfree(hif_drv);\n\tvif->hif_drv = NULL;\n\tmutex_unlock(&vif->wilc->deinit_lock);\n\treturn result;\n}\n\nvoid wilc_network_info_received(struct wilc *wilc, u8 *buffer, u32 length)\n{\n\tint result;\n\tstruct host_if_msg *msg;\n\tint id;\n\tstruct host_if_drv *hif_drv;\n\tstruct wilc_vif *vif;\n\n\tid = get_unaligned_le32(&buffer[length - 4]);\n\tvif = wilc_get_vif_from_idx(wilc, id);\n\tif (!vif)\n\t\treturn;\n\thif_drv = vif->hif_drv;\n\n\tif (!hif_drv) {\n\t\tnetdev_err(vif->ndev, \"driver not init[%p]\\n\", hif_drv);\n\t\treturn;\n\t}\n\n\tmsg = wilc_alloc_work(vif, handle_rcvd_ntwrk_info, false);\n\tif (IS_ERR(msg))\n\t\treturn;\n\n\tmsg->body.net_info.frame_len = get_unaligned_le16(&buffer[6]) - 1;\n\tmsg->body.net_info.rssi = buffer[8];\n\tmsg->body.net_info.mgmt = kmemdup(&buffer[9],\n\t\t\t\t\t  msg->body.net_info.frame_len,\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!msg->body.net_info.mgmt) {\n\t\tkfree(msg);\n\t\treturn;\n\t}\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\", __func__);\n\t\tkfree(msg->body.net_info.mgmt);\n\t\tkfree(msg);\n\t}\n}\n\nvoid wilc_gnrl_async_info_received(struct wilc *wilc, u8 *buffer, u32 length)\n{\n\tint result;\n\tstruct host_if_msg *msg;\n\tint id;\n\tstruct host_if_drv *hif_drv;\n\tstruct wilc_vif *vif;\n\n\tmutex_lock(&wilc->deinit_lock);\n\n\tid = get_unaligned_le32(&buffer[length - 4]);\n\tvif = wilc_get_vif_from_idx(wilc, id);\n\tif (!vif) {\n\t\tmutex_unlock(&wilc->deinit_lock);\n\t\treturn;\n\t}\n\n\thif_drv = vif->hif_drv;\n\n\tif (!hif_drv) {\n\t\tmutex_unlock(&wilc->deinit_lock);\n\t\treturn;\n\t}\n\n\tif (!hif_drv->conn_info.conn_result) {\n\t\tnetdev_err(vif->ndev, \"%s: conn_result is NULL\\n\", __func__);\n\t\tmutex_unlock(&wilc->deinit_lock);\n\t\treturn;\n\t}\n\n\tmsg = wilc_alloc_work(vif, handle_rcvd_gnrl_async_info, false);\n\tif (IS_ERR(msg)) {\n\t\tmutex_unlock(&wilc->deinit_lock);\n\t\treturn;\n\t}\n\n\tmsg->body.mac_info.status = buffer[7];\n\tresult = wilc_enqueue_work(msg);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\", __func__);\n\t\tkfree(msg);\n\t}\n\n\tmutex_unlock(&wilc->deinit_lock);\n}\n\nvoid wilc_scan_complete_received(struct wilc *wilc, u8 *buffer, u32 length)\n{\n\tint result;\n\tint id;\n\tstruct host_if_drv *hif_drv;\n\tstruct wilc_vif *vif;\n\n\tid = get_unaligned_le32(&buffer[length - 4]);\n\tvif = wilc_get_vif_from_idx(wilc, id);\n\tif (!vif)\n\t\treturn;\n\thif_drv = vif->hif_drv;\n\n\tif (!hif_drv)\n\t\treturn;\n\n\tif (hif_drv->usr_scan_req.scan_result) {\n\t\tstruct host_if_msg *msg;\n\n\t\tmsg = wilc_alloc_work(vif, handle_scan_complete, false);\n\t\tif (IS_ERR(msg))\n\t\t\treturn;\n\n\t\tresult = wilc_enqueue_work(msg);\n\t\tif (result) {\n\t\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\",\n\t\t\t\t   __func__);\n\t\t\tkfree(msg);\n\t\t}\n\t}\n}\n\nint wilc_remain_on_channel(struct wilc_vif *vif, u64 cookie,\n\t\t\t   u32 duration, u16 chan,\n\t\t\t   void (*expired)(void *, u64),\n\t\t\t   void *user_arg)\n{\n\tstruct wilc_remain_ch roc;\n\tint result;\n\n\troc.ch = chan;\n\troc.expired = expired;\n\troc.arg = user_arg;\n\troc.duration = duration;\n\troc.cookie = cookie;\n\tresult = handle_remain_on_chan(vif, &roc);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"%s: failed to set remain on channel\\n\",\n\t\t\t   __func__);\n\n\treturn result;\n}\n\nint wilc_listen_state_expired(struct wilc_vif *vif, u64 cookie)\n{\n\tif (!vif->hif_drv) {\n\t\tnetdev_err(vif->ndev, \"%s: hif driver is NULL\", __func__);\n\t\treturn -EFAULT;\n\t}\n\n\tdel_timer(&vif->hif_drv->remain_on_ch_timer);\n\n\treturn wilc_handle_roc_expired(vif, cookie);\n}\n\nvoid wilc_frame_register(struct wilc_vif *vif, u16 frame_type, bool reg)\n{\n\tstruct wid wid;\n\tint result;\n\tstruct wilc_reg_frame reg_frame;\n\n\twid.id = WID_REGISTER_FRAME;\n\twid.type = WID_STR;\n\twid.size = sizeof(reg_frame);\n\twid.val = (u8 *)&reg_frame;\n\n\tmemset(&reg_frame, 0x0, sizeof(reg_frame));\n\n\tif (reg)\n\t\treg_frame.reg = 1;\n\n\tswitch (frame_type) {\n\tcase IEEE80211_STYPE_ACTION:\n\t\treg_frame.reg_id = WILC_FW_ACTION_FRM_IDX;\n\t\tbreak;\n\n\tcase IEEE80211_STYPE_PROBE_REQ:\n\t\treg_frame.reg_id = WILC_FW_PROBE_REQ_IDX;\n\t\tbreak;\n\n        case IEEE80211_STYPE_AUTH:\n                reg_frame.reg_id = WILC_FW_AUTH_REQ_IDX;\n                break;\n\n\tdefault:\n\t\tbreak;\n\t}\n\treg_frame.frame_type = cpu_to_le16(frame_type);\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to frame register\\n\");\n}\n\nint wilc_add_beacon(struct wilc_vif *vif, u32 interval, u32 dtim_period,\n\t\t    struct cfg80211_beacon_data *params)\n{\n\tstruct wid wid;\n\tint result;\n\tu8 *cur_byte;\n\n\twid.id = WID_ADD_BEACON;\n\twid.type = WID_BIN;\n\twid.size = params->head_len + params->tail_len + 16;\n\twid.val = kzalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\tcur_byte = wid.val;\n\tput_unaligned_le32(interval, cur_byte);\n\tcur_byte += 4;\n\tput_unaligned_le32(dtim_period, cur_byte);\n\tcur_byte += 4;\n\tput_unaligned_le32(params->head_len, cur_byte);\n\tcur_byte += 4;\n\n\tif (params->head_len > 0)\n\t\tmemcpy(cur_byte, params->head, params->head_len);\n\tcur_byte += params->head_len;\n\n\tput_unaligned_le32(params->tail_len, cur_byte);\n\tcur_byte += 4;\n\n\tif (params->tail_len > 0)\n\t\tmemcpy(cur_byte, params->tail, params->tail_len);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send add beacon\\n\");\n\n\tkfree(wid.val);\n\n\treturn result;\n}\n\nint wilc_del_beacon(struct wilc_vif *vif)\n{\n\tint result;\n\tstruct wid wid;\n\tu8 del_beacon = 0;\n\n\twid.id = WID_DEL_BEACON;\n\twid.type = WID_CHAR;\n\twid.size = sizeof(char);\n\twid.val = &del_beacon;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send delete beacon\\n\");\n\n\treturn result;\n}\n\nint wilc_add_station(struct wilc_vif *vif, const u8 *mac,\n\t\t     struct station_parameters *params)\n{\n\tstruct wid wid;\n\tint result;\n\tu8 *cur_byte;\n\n\twid.id = WID_ADD_STA;\n\twid.type = WID_BIN;\n\twid.size = WILC_ADD_STA_LENGTH +\n\t\t   params->link_sta_params.supported_rates_len;\n\twid.val = kmalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\tcur_byte = wid.val;\n\twilc_hif_pack_sta_param(cur_byte, mac, params);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result != 0)\n\t\tnetdev_err(vif->ndev, \"Failed to send add station\\n\");\n\n\tkfree(wid.val);\n\n\treturn result;\n}\n\nint wilc_del_station(struct wilc_vif *vif, const u8 *mac_addr)\n{\n\tstruct wid wid;\n\tint result;\n\n\twid.id = WID_REMOVE_STA;\n\twid.type = WID_BIN;\n\twid.size = ETH_ALEN;\n\twid.val = kzalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\tif (!mac_addr)\n\t\teth_broadcast_addr(wid.val);\n\telse\n\t\tether_addr_copy(wid.val, mac_addr);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to del station\\n\");\n\n\tkfree(wid.val);\n\n\treturn result;\n}\n\nint wilc_del_allstation(struct wilc_vif *vif, u8 mac_addr[][ETH_ALEN])\n{\n\tstruct wid wid;\n\tint result;\n\tint i;\n\tu8 assoc_sta = 0;\n\tstruct wilc_del_all_sta del_sta;\n\n\tmemset(&del_sta, 0x0, sizeof(del_sta));\n\tfor (i = 0; i < WILC_MAX_NUM_STA; i++) {\n\t\tif (!is_zero_ether_addr(mac_addr[i])) {\n\t\t\tassoc_sta++;\n\t\t\tether_addr_copy(del_sta.mac[i], mac_addr[i]);\n\t\t}\n\t}\n\n\tif (!assoc_sta)\n\t\treturn 0;\n\n\tdel_sta.assoc_sta = assoc_sta;\n\n\twid.id = WID_DEL_ALL_STA;\n\twid.type = WID_STR;\n\twid.size = (assoc_sta * ETH_ALEN) + 1;\n\twid.val = (u8 *)&del_sta;\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send delete all station\\n\");\n\n\treturn result;\n}\n\nint wilc_edit_station(struct wilc_vif *vif, const u8 *mac,\n\t\t      struct station_parameters *params)\n{\n\tstruct wid wid;\n\tint result;\n\tu8 *cur_byte;\n\n\twid.id = WID_EDIT_STA;\n\twid.type = WID_BIN;\n\twid.size = WILC_ADD_STA_LENGTH +\n\t\t   params->link_sta_params.supported_rates_len;\n\twid.val = kmalloc(wid.size, GFP_KERNEL);\n\tif (!wid.val)\n\t\treturn -ENOMEM;\n\n\tcur_byte = wid.val;\n\twilc_hif_pack_sta_param(cur_byte, mac, params);\n\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send edit station\\n\");\n\n\tkfree(wid.val);\n\treturn result;\n}\n\nint wilc_set_power_mgmt(struct wilc_vif *vif, bool enabled, u32 timeout)\n{\n\tstruct wilc *wilc = vif->wilc;\n\tstruct wid wid;\n\tint result;\n\ts8 power_mode;\n\n\tif (enabled)\n\t\tpower_mode = WILC_FW_MIN_FAST_PS;\n\telse\n\t\tpower_mode = WILC_FW_NO_POWERSAVE;\n\n\twid.id = WID_POWER_MANAGEMENT;\n\twid.val = &power_mode;\n\twid.size = sizeof(char);\n\tresult = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n\tif (result)\n\t\tnetdev_err(vif->ndev, \"Failed to send power management\\n\");\n\telse\n\t\twilc->power_save_mode = enabled;\n\n\treturn result;\n}\n\nint wilc_setup_multicast_filter(struct wilc_vif *vif, u32 enabled, u32 count,\n\t\t\t\tu8 *mc_list)\n{\n\tint result;\n\tstruct host_if_msg *msg;\n\n\tmsg = wilc_alloc_work(vif, handle_set_mcast_filter, false);\n\tif (IS_ERR(msg))\n\t\treturn PTR_ERR(msg);\n\n\tmsg->body.mc_info.enabled = enabled;\n\tmsg->body.mc_info.cnt = count;\n\tmsg->body.mc_info.mc_list = mc_list;\n\n\tresult = wilc_enqueue_work(msg);\n\tif (result) {\n\t\tnetdev_err(vif->ndev, \"%s: enqueue work failed\\n\", __func__);\n\t\tkfree(msg);\n\t}\n\treturn result;\n}\n\nint wilc_set_tx_power(struct wilc_vif *vif, u8 tx_power)\n{\n\tstruct wid wid;\n\n\twid.id = WID_TX_POWER;\n\twid.type = WID_CHAR;\n\twid.val = &tx_power;\n\twid.size = sizeof(char);\n\n\treturn wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n}\n\nint wilc_get_tx_power(struct wilc_vif *vif, u8 *tx_power)\n{\n\tstruct wid wid;\n\n\twid.id = WID_TX_POWER;\n\twid.type = WID_CHAR;\n\twid.val = tx_power;\n\twid.size = sizeof(char);\n\n\treturn wilc_send_config_pkt(vif, WILC_GET_CFG, &wid, 1);\n}\n\nint wilc_set_default_mgmt_key_index(struct wilc_vif *vif, u8 index)\n{\n        struct wid wid;\n        int result;\n\n        wid.id = WID_DEFAULT_MGMT_KEY_ID;\n        wid.type = WID_CHAR;\n        wid.size = sizeof(char);\n        wid.val = &index;\n        result = wilc_send_config_pkt(vif, WILC_SET_CFG, &wid, 1);\n        if (result)\n                netdev_err(vif->ndev,\n                           \"Failed to send default mgmt key index\\n\");\n\n        return result;\n}\n"], "filenames": ["drivers/net/wireless/microchip/wilc1000/hif.c"], "buggy_code_start_loc": [484], "buggy_code_end_loc": [493], "fixing_code_start_loc": [485], "fixing_code_end_loc": [504], "type": "CWE-125", "message": "An issue was discovered in the Linux kernel before 6.0.11. Missing offset validation in drivers/net/wireless/microchip/wilc1000/hif.c in the WILC1000 wireless driver can trigger an out-of-bounds read when parsing a Robust Security Network (RSN) information element from a Netlink packet.", "other": {"cve": {"id": "CVE-2022-47520", "sourceIdentifier": "cve@mitre.org", "published": "2022-12-18T06:15:09.473", "lastModified": "2023-01-30T15:23:18.743", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 6.0.11. Missing offset validation in drivers/net/wireless/microchip/wilc1000/hif.c in the WILC1000 wireless driver can trigger an out-of-bounds read when parsing a Robust Security Network (RSN) information element from a Netlink packet."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.0.11", "matchCriteriaId": "250F7A1B-7491-4CCA-BD47-B4E4FD26603E"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410c_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "234DEFE0-5CE5-4B0A-96B8-5D227CB8ED31"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410c:-:*:*:*:*:*:*:*", "matchCriteriaId": "CDDF61B7-EC5C-467C-B710-B89F502CD04F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h300s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "6770B6C3-732E-4E22-BF1C-2D2FD610061C"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h300s:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F9C8C20-42EB-4AB5-BD97-212DEB070C43"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h500s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "7FFF7106-ED78-49BA-9EC5-B889E3685D53"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h500s:-:*:*:*:*:*:*:*", "matchCriteriaId": "E63D8B0F-006E-4801-BF9D-1C001BBFB4F9"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h700s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "56409CEC-5A1E-4450-AA42-641E459CC2AF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h700s:-:*:*:*:*:*:*:*", "matchCriteriaId": "B06F4839-D16A-4A61-9BB5-55B13F41E47F"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:netapp:h410s_firmware:-:*:*:*:*:*:*:*", "matchCriteriaId": "D0B4AD8A-F172-4558-AEC6-FF424BA2D912"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:netapp:h410s:-:*:*:*:*:*:*:*", "matchCriteriaId": "8497A4C9-8474-4A62-8331-3FE862ED4098"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/cd21d99e595ec1d8721e1058dcdd4f1f7de1d793", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/12/msg00031.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lore.kernel.org/r/20221123153543.8568-2-philipturnbull@github.com", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20230113-0007/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/cd21d99e595ec1d8721e1058dcdd4f1f7de1d793"}}