{"buggy_code": ["/*\n *  Copyright (c) 2016, The OpenThread Authors.\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the copyright holder nor the\n *     names of its contributors may be used to endorse or promote products\n *     derived from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file\n *   This file implements a Commissioner role.\n */\n\n#include \"commissioner.hpp\"\n\n#include <stdio.h>\n#include \"utils/wrap_string.h\"\n\n#include \"coap/coap_message.hpp\"\n#include \"common/encoding.hpp\"\n#include \"common/instance.hpp\"\n#include \"common/locator-getters.hpp\"\n#include \"common/logging.hpp\"\n#include \"crypto/pbkdf2_cmac.h\"\n#include \"meshcop/joiner_router.hpp\"\n#include \"meshcop/meshcop.hpp\"\n#include \"meshcop/meshcop_tlvs.hpp\"\n#include \"thread/thread_netif.hpp\"\n#include \"thread/thread_tlvs.hpp\"\n#include \"thread/thread_uri_paths.hpp\"\n\n#if OPENTHREAD_FTD && OPENTHREAD_CONFIG_COMMISSIONER_ENABLE\n\nnamespace ot {\nnamespace MeshCoP {\n\nCommissioner::Commissioner(Instance &aInstance)\n    : InstanceLocator(aInstance)\n    , mJoinerPort(0)\n    , mJoinerRloc(0)\n    , mSessionId(0)\n    , mJoinerIndex(0)\n    , mTransmitAttempts(0)\n    , mJoinerExpirationTimer(aInstance, HandleJoinerExpirationTimer, this)\n    , mTimer(aInstance, HandleTimer, this)\n    , mRelayReceive(OT_URI_PATH_RELAY_RX, &Commissioner::HandleRelayReceive, this)\n    , mDatasetChanged(OT_URI_PATH_DATASET_CHANGED, &Commissioner::HandleDatasetChanged, this)\n    , mJoinerFinalize(OT_URI_PATH_JOINER_FINALIZE, &Commissioner::HandleJoinerFinalize, this)\n    , mAnnounceBegin(aInstance)\n    , mEnergyScan(aInstance)\n    , mPanIdQuery(aInstance)\n    , mStateCallback(NULL)\n    , mJoinerCallback(NULL)\n    , mCallbackContext(NULL)\n    , mState(OT_COMMISSIONER_STATE_DISABLED)\n{\n    memset(mJoiners, 0, sizeof(mJoiners));\n\n    mCommissionerAloc.Clear();\n    mCommissionerAloc.mPrefixLength       = 64;\n    mCommissionerAloc.mPreferred          = true;\n    mCommissionerAloc.mValid              = true;\n    mCommissionerAloc.mScopeOverride      = Ip6::Address::kRealmLocalScope;\n    mCommissionerAloc.mScopeOverrideValid = true;\n\n    mProvisioningUrl[0] = '\\0';\n}\n\nvoid Commissioner::SetState(otCommissionerState aState)\n{\n    VerifyOrExit(mState != aState);\n\n    otLogInfoMeshCoP(\"Commissioner State: %s -> %s\", StateToString(mState), StateToString(aState));\n\n    mState = aState;\n\n    if (mStateCallback)\n    {\n        mStateCallback(mState, mCallbackContext);\n    }\n\nexit:\n    return;\n}\n\nvoid Commissioner::SignalJoinerEvent(otCommissionerJoinerEvent aEvent, const Mac::ExtAddress &aJoinerId)\n{\n    if (mJoinerCallback)\n    {\n        mJoinerCallback(aEvent, &aJoinerId, mCallbackContext);\n    }\n}\n\nvoid Commissioner::AddCoapResources(void)\n{\n    Get<Coap::Coap>().AddResource(mRelayReceive);\n    Get<Coap::Coap>().AddResource(mDatasetChanged);\n    Get<Coap::CoapSecure>().AddResource(mJoinerFinalize);\n}\n\nvoid Commissioner::RemoveCoapResources(void)\n{\n    Get<Coap::Coap>().RemoveResource(mRelayReceive);\n    Get<Coap::Coap>().RemoveResource(mDatasetChanged);\n    Get<Coap::CoapSecure>().RemoveResource(mJoinerFinalize);\n}\n\nvoid Commissioner::HandleCoapsConnected(bool aConnected, void *aContext)\n{\n    static_cast<Commissioner *>(aContext)->HandleCoapsConnected(aConnected);\n}\n\nvoid Commissioner::HandleCoapsConnected(bool aConnected)\n{\n    otCommissionerJoinerEvent event;\n    Mac::ExtAddress           joinerId;\n\n    event = aConnected ? OT_COMMISSIONER_JOINER_CONNECTED : OT_COMMISSIONER_JOINER_END;\n\n    joinerId.Set(mJoinerIid);\n    joinerId.ToggleLocal();\n\n    SignalJoinerEvent(event, joinerId);\n}\n\notError Commissioner::Start(otCommissionerStateCallback  aStateCallback,\n                            otCommissionerJoinerCallback aJoinerCallback,\n                            void *                       aCallbackContext)\n{\n    otError error = OT_ERROR_NONE;\n\n    VerifyOrExit(Get<Mle::MleRouter>().IsAttached(), error = OT_ERROR_INVALID_STATE);\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_DISABLED, error = OT_ERROR_INVALID_STATE);\n\n    SuccessOrExit(error = Get<Coap::CoapSecure>().Start(SendRelayTransmit, this));\n    Get<Coap::CoapSecure>().SetConnectedCallback(&Commissioner::HandleCoapsConnected, this);\n\n    mStateCallback    = aStateCallback;\n    mJoinerCallback   = aJoinerCallback;\n    mCallbackContext  = aCallbackContext;\n    mTransmitAttempts = 0;\n\n    SuccessOrExit(error = SendPetition());\n    SetState(OT_COMMISSIONER_STATE_PETITION);\n\nexit:\n    return error;\n}\n\notError Commissioner::Stop(void)\n{\n    otError error = OT_ERROR_NONE;\n\n    VerifyOrExit(mState != OT_COMMISSIONER_STATE_DISABLED, error = OT_ERROR_INVALID_STATE);\n\n    Get<Coap::CoapSecure>().Stop();\n\n    Get<ThreadNetif>().RemoveUnicastAddress(mCommissionerAloc);\n    RemoveCoapResources();\n    ClearJoiners();\n    mTransmitAttempts = 0;\n\n    mTimer.Stop();\n    Get<Coap::CoapSecure>().Stop();\n\n    SetState(OT_COMMISSIONER_STATE_DISABLED);\n\n    SendKeepAlive();\n\nexit:\n    return error;\n}\n\notError Commissioner::SendCommissionerSet(void)\n{\n    otError                error;\n    otCommissioningDataset dataset;\n    SteeringDataTlv        steeringData;\n    Mac::ExtAddress        joinerId;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n\n    memset(&dataset, 0, sizeof(dataset));\n\n    // session id\n    dataset.mSessionId      = mSessionId;\n    dataset.mIsSessionIdSet = true;\n\n    // compute bloom filter\n    steeringData.Init();\n    steeringData.Clear();\n\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (!joiner->mValid)\n        {\n            continue;\n        }\n\n        if (joiner->mAny)\n        {\n            steeringData.SetLength(1);\n            steeringData.Set();\n            break;\n        }\n\n        ComputeJoinerId(joiner->mEui64, joinerId);\n        steeringData.ComputeBloomFilter(joinerId);\n    }\n\n    // set bloom filter\n    dataset.mSteeringData.mLength = steeringData.GetSteeringDataLength();\n    memcpy(dataset.mSteeringData.m8, steeringData.GetValue(), dataset.mSteeringData.mLength);\n    dataset.mIsSteeringDataSet = true;\n\n    SuccessOrExit(error = SendMgmtCommissionerSetRequest(dataset, NULL, 0));\n\nexit:\n    return error;\n}\n\nvoid Commissioner::ClearJoiners(void)\n{\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        joiner->mValid = false;\n    }\n\n    SendCommissionerSet();\n}\n\notError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)\n{\n    otError error = OT_ERROR_NO_BUFS;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n\n    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);\n    RemoveJoiner(aEui64, 0); // remove immediately\n\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (joiner->mValid)\n        {\n            continue;\n        }\n\n        if (aEui64 != NULL)\n        {\n            joiner->mEui64 = *aEui64;\n            joiner->mAny   = false;\n        }\n        else\n        {\n            joiner->mAny = true;\n        }\n\n        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));\n        joiner->mValid          = true;\n        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);\n\n        UpdateJoinerExpirationTimer();\n\n        SendCommissionerSet();\n\n        otLogInfoMeshCoP(\"Added Joiner (%s, %s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\", aPskd);\n\n        ExitNow(error = OT_ERROR_NONE);\n    }\n\nexit:\n    return error;\n}\n\notError Commissioner::GetNextJoinerInfo(uint16_t &aIterator, otJoinerInfo &aJoiner) const\n{\n    otError error = OT_ERROR_NONE;\n    size_t  index;\n\n    for (index = aIterator; index < OT_ARRAY_LENGTH(mJoiners); index++)\n    {\n        if (!mJoiners[index].mValid)\n        {\n            continue;\n        }\n\n        memset(&aJoiner, 0, sizeof(aJoiner));\n\n        aJoiner.mAny   = mJoiners[index].mAny;\n        aJoiner.mEui64 = mJoiners[index].mEui64;\n        strlcpy(aJoiner.mPsk, mJoiners[index].mPsk, sizeof(aJoiner.mPsk));\n        aJoiner.mExpirationTime = mJoiners[index].mExpirationTime - TimerMilli::GetNow();\n        aIterator               = static_cast<uint16_t>(index) + 1;\n        ExitNow();\n    }\n\n    error = OT_ERROR_NOT_FOUND;\n\nexit:\n    return error;\n}\n\notError Commissioner::RemoveJoiner(const Mac::ExtAddress *aEui64, uint32_t aDelay)\n{\n    otError error = OT_ERROR_NOT_FOUND;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (!joiner->mValid)\n        {\n            continue;\n        }\n\n        if (aEui64 != NULL)\n        {\n            if (joiner->mEui64 != *aEui64)\n            {\n                continue;\n            }\n        }\n        else if (!joiner->mAny)\n        {\n            continue;\n        }\n\n        if (aDelay > 0)\n        {\n            TimeMilli now = TimerMilli::GetNow();\n\n            if ((joiner->mExpirationTime > now) && (joiner->mExpirationTime - now > Time::SecToMsec(aDelay)))\n            {\n                joiner->mExpirationTime = now + Time::SecToMsec(aDelay);\n                UpdateJoinerExpirationTimer();\n            }\n        }\n        else\n        {\n            Mac::ExtAddress joinerId;\n\n            joiner->mValid = false;\n            UpdateJoinerExpirationTimer();\n            SendCommissionerSet();\n\n            otLogInfoMeshCoP(\"Removed Joiner (%s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\");\n\n            ComputeJoinerId(joiner->mEui64, joinerId);\n            SignalJoinerEvent(OT_COMMISSIONER_JOINER_REMOVED, joinerId);\n        }\n\n        ExitNow(error = OT_ERROR_NONE);\n    }\n\nexit:\n    return error;\n}\n\notError Commissioner::SetProvisioningUrl(const char *aProvisioningUrl)\n{\n    otError error = OT_ERROR_NONE;\n    uint8_t len;\n\n    if (aProvisioningUrl == NULL)\n    {\n        mProvisioningUrl[0] = '\\0';\n        ExitNow();\n    }\n\n    len = static_cast<uint8_t>(strnlen(aProvisioningUrl, sizeof(mProvisioningUrl)));\n\n    VerifyOrExit(len < sizeof(mProvisioningUrl), error = OT_ERROR_INVALID_ARGS);\n\n    memcpy(mProvisioningUrl, aProvisioningUrl, len);\n    mProvisioningUrl[len] = '\\0';\n\nexit:\n    return error;\n}\n\nvoid Commissioner::HandleTimer(Timer &aTimer)\n{\n    aTimer.GetOwner<Commissioner>().HandleTimer();\n}\n\nvoid Commissioner::HandleTimer(void)\n{\n    switch (mState)\n    {\n    case OT_COMMISSIONER_STATE_DISABLED:\n        break;\n\n    case OT_COMMISSIONER_STATE_PETITION:\n        SendPetition();\n        break;\n\n    case OT_COMMISSIONER_STATE_ACTIVE:\n        SendKeepAlive();\n        break;\n    }\n}\n\nvoid Commissioner::HandleJoinerExpirationTimer(Timer &aTimer)\n{\n    aTimer.GetOwner<Commissioner>().HandleJoinerExpirationTimer();\n}\n\nvoid Commissioner::HandleJoinerExpirationTimer(void)\n{\n    TimeMilli now = TimerMilli::GetNow();\n\n    // Remove Joiners.\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (!joiner->mValid)\n        {\n            continue;\n        }\n\n        if (now >= joiner->mExpirationTime)\n        {\n            otLogDebgMeshCoP(\"removing joiner due to timeout or successfully joined\");\n            RemoveJoiner(&joiner->mEui64, 0); // remove immediately\n        }\n    }\n\n    UpdateJoinerExpirationTimer();\n}\n\nvoid Commissioner::UpdateJoinerExpirationTimer(void)\n{\n    TimeMilli now         = TimerMilli::GetNow();\n    uint32_t  nextTimeout = TimeMilli::kMaxDuration;\n\n    // Check if timer should be set for next Joiner.\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        uint32_t diff;\n\n        if (!joiner->mValid)\n        {\n            continue;\n        }\n\n        if (now >= joiner->mExpirationTime)\n        {\n            nextTimeout = 0;\n            break;\n        }\n\n        diff = joiner->mExpirationTime - now;\n\n        if (diff < nextTimeout)\n        {\n            nextTimeout = diff;\n        }\n    }\n\n    if (nextTimeout != TimeMilli::kMaxDuration)\n    {\n        // Update the timer to the timeout of the next Joiner.\n        mJoinerExpirationTimer.Start(nextTimeout);\n    }\n    else\n    {\n        // No Joiners, stop the timer.\n        mJoinerExpirationTimer.Stop();\n    }\n}\n\notError Commissioner::SendMgmtCommissionerGetRequest(const uint8_t *aTlvs, uint8_t aLength)\n{\n    otError          error = OT_ERROR_NONE;\n    Coap::Message *  message;\n    Ip6::MessageInfo messageInfo;\n    MeshCoP::Tlv     tlv;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->Init(OT_COAP_TYPE_CONFIRMABLE, OT_COAP_CODE_POST, OT_URI_PATH_COMMISSIONER_GET));\n\n    if (aLength > 0)\n    {\n        SuccessOrExit(error = message->SetPayloadMarker());\n    }\n\n    if (aLength > 0)\n    {\n        tlv.SetType(MeshCoP::Tlv::kGet);\n        tlv.SetLength(aLength);\n        SuccessOrExit(error = message->Append(&tlv, sizeof(tlv)));\n        SuccessOrExit(error = message->Append(aTlvs, aLength));\n    }\n\n    messageInfo.SetSockAddr(Get<Mle::MleRouter>().GetMeshLocal16());\n    SuccessOrExit(error = Get<Mle::MleRouter>().GetLeaderAloc(messageInfo.GetPeerAddr()));\n    messageInfo.SetPeerPort(kCoapUdpPort);\n    SuccessOrExit(error = Get<Coap::Coap>().SendMessage(*message, messageInfo,\n                                                        Commissioner::HandleMgmtCommissionerGetResponse, this));\n\n    otLogInfoMeshCoP(\"sent MGMT_COMMISSIONER_GET.req to leader\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n\n    return error;\n}\n\nvoid Commissioner::HandleMgmtCommissionerGetResponse(void *               aContext,\n                                                     otMessage *          aMessage,\n                                                     const otMessageInfo *aMessageInfo,\n                                                     otError              aResult)\n{\n    static_cast<Commissioner *>(aContext)->HandleMgmtCommissionerGetResponse(\n        static_cast<Coap::Message *>(aMessage), static_cast<const Ip6::MessageInfo *>(aMessageInfo), aResult);\n}\n\nvoid Commissioner::HandleMgmtCommissionerGetResponse(Coap::Message *         aMessage,\n                                                     const Ip6::MessageInfo *aMessageInfo,\n                                                     otError                 aResult)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    VerifyOrExit(aResult == OT_ERROR_NONE && aMessage->GetCode() == OT_COAP_CODE_CHANGED);\n    otLogInfoMeshCoP(\"received MGMT_COMMISSIONER_GET response\");\n\nexit:\n    return;\n}\n\notError Commissioner::SendMgmtCommissionerSetRequest(const otCommissioningDataset &aDataset,\n                                                     const uint8_t *               aTlvs,\n                                                     uint8_t                       aLength)\n{\n    otError          error = OT_ERROR_NONE;\n    Coap::Message *  message;\n    Ip6::MessageInfo messageInfo;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->Init(OT_COAP_TYPE_CONFIRMABLE, OT_COAP_CODE_POST, OT_URI_PATH_COMMISSIONER_SET));\n    SuccessOrExit(error = message->SetPayloadMarker());\n\n    if (aDataset.mIsLocatorSet)\n    {\n        MeshCoP::BorderAgentLocatorTlv locator;\n        locator.Init();\n        locator.SetBorderAgentLocator(aDataset.mLocator);\n        SuccessOrExit(error = message->AppendTlv(locator));\n    }\n\n    if (aDataset.mIsSessionIdSet)\n    {\n        MeshCoP::CommissionerSessionIdTlv sessionId;\n        sessionId.Init();\n        sessionId.SetCommissionerSessionId(aDataset.mSessionId);\n        SuccessOrExit(error = message->AppendTlv(sessionId));\n    }\n\n    if (aDataset.mIsSteeringDataSet)\n    {\n        MeshCoP::SteeringDataTlv steeringData;\n        steeringData.Init();\n        steeringData.SetLength(aDataset.mSteeringData.mLength);\n        SuccessOrExit(error = message->Append(&steeringData, sizeof(MeshCoP::Tlv)));\n        SuccessOrExit(error = message->Append(&aDataset.mSteeringData.m8, aDataset.mSteeringData.mLength));\n    }\n\n    if (aDataset.mIsJoinerUdpPortSet)\n    {\n        MeshCoP::JoinerUdpPortTlv joinerUdpPort;\n        joinerUdpPort.Init();\n        joinerUdpPort.SetUdpPort(aDataset.mJoinerUdpPort);\n        SuccessOrExit(error = message->AppendTlv(joinerUdpPort));\n    }\n\n    if (aLength > 0)\n    {\n        SuccessOrExit(error = message->Append(aTlvs, aLength));\n    }\n\n    if (message->GetLength() == message->GetOffset())\n    {\n        // no payload, remove coap payload marker\n        message->SetLength(message->GetLength() - 1);\n    }\n\n    messageInfo.SetSockAddr(Get<Mle::MleRouter>().GetMeshLocal16());\n    SuccessOrExit(error = Get<Mle::MleRouter>().GetLeaderAloc(messageInfo.GetPeerAddr()));\n    messageInfo.SetPeerPort(kCoapUdpPort);\n    SuccessOrExit(error = Get<Coap::Coap>().SendMessage(*message, messageInfo,\n                                                        Commissioner::HandleMgmtCommissionerSetResponse, this));\n\n    otLogInfoMeshCoP(\"sent MGMT_COMMISSIONER_SET.req to leader\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n\n    return error;\n}\n\nvoid Commissioner::HandleMgmtCommissionerSetResponse(void *               aContext,\n                                                     otMessage *          aMessage,\n                                                     const otMessageInfo *aMessageInfo,\n                                                     otError              aResult)\n{\n    static_cast<Commissioner *>(aContext)->HandleMgmtCommissionerSetResponse(\n        static_cast<Coap::Message *>(aMessage), static_cast<const Ip6::MessageInfo *>(aMessageInfo), aResult);\n}\n\nvoid Commissioner::HandleMgmtCommissionerSetResponse(Coap::Message *         aMessage,\n                                                     const Ip6::MessageInfo *aMessageInfo,\n                                                     otError                 aResult)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    VerifyOrExit(aResult == OT_ERROR_NONE && aMessage->GetCode() == OT_COAP_CODE_CHANGED);\n    otLogInfoMeshCoP(\"received MGMT_COMMISSIONER_SET response\");\n\nexit:\n    return;\n}\n\notError Commissioner::SendPetition(void)\n{\n    otError           error   = OT_ERROR_NONE;\n    Coap::Message *   message = NULL;\n    Ip6::MessageInfo  messageInfo;\n    CommissionerIdTlv commissionerId;\n\n    mTransmitAttempts++;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->Init(OT_COAP_TYPE_CONFIRMABLE, OT_COAP_CODE_POST, OT_URI_PATH_LEADER_PETITION));\n    SuccessOrExit(error = message->SetPayloadMarker());\n\n    commissionerId.Init();\n    commissionerId.SetCommissionerId(\"OpenThread Commissioner\");\n\n    SuccessOrExit(error = message->AppendTlv(commissionerId));\n\n    SuccessOrExit(error = Get<Mle::MleRouter>().GetLeaderAloc(messageInfo.GetPeerAddr()));\n    messageInfo.SetPeerPort(kCoapUdpPort);\n    messageInfo.SetSockAddr(Get<Mle::MleRouter>().GetMeshLocal16());\n    SuccessOrExit(\n        error = Get<Coap::Coap>().SendMessage(*message, messageInfo, Commissioner::HandleLeaderPetitionResponse, this));\n\n    otLogInfoMeshCoP(\"sent petition\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n\n    return error;\n}\n\nvoid Commissioner::HandleLeaderPetitionResponse(void *               aContext,\n                                                otMessage *          aMessage,\n                                                const otMessageInfo *aMessageInfo,\n                                                otError              aResult)\n{\n    static_cast<Commissioner *>(aContext)->HandleLeaderPetitionResponse(\n        static_cast<Coap::Message *>(aMessage), static_cast<const Ip6::MessageInfo *>(aMessageInfo), aResult);\n}\n\nvoid Commissioner::HandleLeaderPetitionResponse(Coap::Message *         aMessage,\n                                                const Ip6::MessageInfo *aMessageInfo,\n                                                otError                 aResult)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    StateTlv                 state;\n    CommissionerSessionIdTlv sessionId;\n    bool                     retransmit = false;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_PETITION, SetState(OT_COMMISSIONER_STATE_DISABLED));\n    VerifyOrExit(aResult == OT_ERROR_NONE && aMessage->GetCode() == OT_COAP_CODE_CHANGED, retransmit = true);\n\n    otLogInfoMeshCoP(\"received Leader Petition response\");\n\n    SuccessOrExit(Tlv::GetTlv(*aMessage, Tlv::kState, sizeof(state), state));\n    VerifyOrExit(state.IsValid());\n\n    VerifyOrExit(state.GetState() == StateTlv::kAccept, SetState(OT_COMMISSIONER_STATE_DISABLED));\n\n    SuccessOrExit(Tlv::GetTlv(*aMessage, Tlv::kCommissionerSessionId, sizeof(sessionId), sessionId));\n    VerifyOrExit(sessionId.IsValid());\n    mSessionId = sessionId.GetCommissionerSessionId();\n\n    Get<Mle::MleRouter>().GetCommissionerAloc(mCommissionerAloc.GetAddress(), mSessionId);\n    Get<ThreadNetif>().AddUnicastAddress(mCommissionerAloc);\n\n    AddCoapResources();\n    SetState(OT_COMMISSIONER_STATE_ACTIVE);\n\n    mTransmitAttempts = 0;\n    mTimer.Start(Time::SecToMsec(kKeepAliveTimeout) / 2);\n\nexit:\n\n    if (retransmit)\n    {\n        if (mTransmitAttempts >= kPetitionRetryCount)\n        {\n            SetState(OT_COMMISSIONER_STATE_DISABLED);\n        }\n        else\n        {\n            mTimer.Start(Time::SecToMsec(kPetitionRetryDelay));\n        }\n    }\n}\n\notError Commissioner::SendKeepAlive(void)\n{\n    otError                  error   = OT_ERROR_NONE;\n    Coap::Message *          message = NULL;\n    Ip6::MessageInfo         messageInfo;\n    StateTlv                 state;\n    CommissionerSessionIdTlv sessionId;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->Init(OT_COAP_TYPE_CONFIRMABLE, OT_COAP_CODE_POST, OT_URI_PATH_LEADER_KEEP_ALIVE));\n    SuccessOrExit(error = message->SetPayloadMarker());\n\n    state.Init();\n    state.SetState(mState == OT_COMMISSIONER_STATE_ACTIVE ? StateTlv::kAccept : StateTlv::kReject);\n    SuccessOrExit(error = message->AppendTlv(state));\n\n    sessionId.Init();\n    sessionId.SetCommissionerSessionId(mSessionId);\n    SuccessOrExit(error = message->AppendTlv(sessionId));\n\n    messageInfo.SetSockAddr(Get<Mle::MleRouter>().GetMeshLocal16());\n    SuccessOrExit(error = Get<Mle::MleRouter>().GetLeaderAloc(messageInfo.GetPeerAddr()));\n    messageInfo.SetPeerPort(kCoapUdpPort);\n    SuccessOrExit(error = Get<Coap::Coap>().SendMessage(*message, messageInfo,\n                                                        Commissioner::HandleLeaderKeepAliveResponse, this));\n\n    otLogInfoMeshCoP(\"sent keep alive\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n\n    return error;\n}\n\nvoid Commissioner::HandleLeaderKeepAliveResponse(void *               aContext,\n                                                 otMessage *          aMessage,\n                                                 const otMessageInfo *aMessageInfo,\n                                                 otError              aResult)\n{\n    static_cast<Commissioner *>(aContext)->HandleLeaderKeepAliveResponse(\n        static_cast<Coap::Message *>(aMessage), static_cast<const Ip6::MessageInfo *>(aMessageInfo), aResult);\n}\n\nvoid Commissioner::HandleLeaderKeepAliveResponse(Coap::Message *         aMessage,\n                                                 const Ip6::MessageInfo *aMessageInfo,\n                                                 otError                 aResult)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    StateTlv state;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, SetState(OT_COMMISSIONER_STATE_DISABLED));\n    VerifyOrExit(aResult == OT_ERROR_NONE && aMessage->GetCode() == OT_COAP_CODE_CHANGED,\n                 SetState(OT_COMMISSIONER_STATE_DISABLED));\n\n    otLogInfoMeshCoP(\"received Leader keep-alive response\");\n\n    SuccessOrExit(Tlv::GetTlv(*aMessage, Tlv::kState, sizeof(state), state));\n    VerifyOrExit(state.IsValid());\n\n    VerifyOrExit(state.GetState() == StateTlv::kAccept, SetState(OT_COMMISSIONER_STATE_DISABLED));\n\n    mTimer.Start(Time::SecToMsec(kKeepAliveTimeout) / 2);\n\nexit:\n\n    if (mState != OT_COMMISSIONER_STATE_ACTIVE)\n    {\n        Get<ThreadNetif>().RemoveUnicastAddress(mCommissionerAloc);\n        RemoveCoapResources();\n    }\n}\n\nvoid Commissioner::HandleRelayReceive(void *aContext, otMessage *aMessage, const otMessageInfo *aMessageInfo)\n{\n    static_cast<Commissioner *>(aContext)->HandleRelayReceive(*static_cast<Coap::Message *>(aMessage),\n                                                              *static_cast<const Ip6::MessageInfo *>(aMessageInfo));\n}\n\nvoid Commissioner::HandleRelayReceive(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    otError                error;\n    JoinerUdpPortTlv       joinerPort;\n    JoinerIidTlv           joinerIid;\n    JoinerRouterLocatorTlv joinerRloc;\n    Ip6::MessageInfo       joinerMessageInfo;\n    uint16_t               offset;\n    uint16_t               length;\n    bool                   enableJoiner = false;\n    Mac::ExtAddress        receivedId;\n    Mac::ExtAddress        joinerId;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n\n    VerifyOrExit(aMessage.GetType() == OT_COAP_TYPE_NON_CONFIRMABLE && aMessage.GetCode() == OT_COAP_CODE_POST);\n\n    SuccessOrExit(error = Tlv::GetTlv(aMessage, Tlv::kJoinerUdpPort, sizeof(joinerPort), joinerPort));\n    VerifyOrExit(joinerPort.IsValid(), error = OT_ERROR_PARSE);\n\n    SuccessOrExit(error = Tlv::GetTlv(aMessage, Tlv::kJoinerIid, sizeof(joinerIid), joinerIid));\n    VerifyOrExit(joinerIid.IsValid(), error = OT_ERROR_PARSE);\n\n    SuccessOrExit(error = Tlv::GetTlv(aMessage, Tlv::kJoinerRouterLocator, sizeof(joinerRloc), joinerRloc));\n    VerifyOrExit(joinerRloc.IsValid(), error = OT_ERROR_PARSE);\n\n    SuccessOrExit(error = Tlv::GetValueOffset(aMessage, Tlv::kJoinerDtlsEncapsulation, offset, length));\n    VerifyOrExit(length <= aMessage.GetLength() - offset, error = OT_ERROR_PARSE);\n\n    if (!Get<Coap::CoapSecure>().IsConnectionActive())\n    {\n        memcpy(mJoinerIid, joinerIid.GetIid(), sizeof(mJoinerIid));\n\n        receivedId.Set(mJoinerIid);\n        receivedId.ToggleLocal();\n\n        for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n        {\n            if (!joiner->mValid)\n            {\n                continue;\n            }\n\n            ComputeJoinerId(joiner->mEui64, joinerId);\n\n            if (joiner->mAny || (joinerId == receivedId))\n            {\n                error = Get<Coap::CoapSecure>().SetPsk(reinterpret_cast<const uint8_t *>(joiner->mPsk),\n                                                       static_cast<uint8_t>(strlen(joiner->mPsk)));\n                SuccessOrExit(error);\n                mJoinerIndex = static_cast<uint8_t>(joiner - mJoiners);\n                enableJoiner = true;\n\n                otLogInfoMeshCoP(\"found joiner, starting new session\");\n                SignalJoinerEvent(OT_COMMISSIONER_JOINER_START, joinerId);\n\n                break;\n            }\n        }\n    }\n    else\n    {\n        enableJoiner = (memcmp(mJoinerIid, joinerIid.GetIid(), sizeof(mJoinerIid)) == 0);\n    }\n\n    VerifyOrExit(enableJoiner);\n\n    mJoinerPort = joinerPort.GetUdpPort();\n    mJoinerRloc = joinerRloc.GetJoinerRouterLocator();\n\n    otLogInfoMeshCoP(\"Remove Relay Receive (%02x%02x%02x%02x%02x%02x%02x%02x, 0x%04x)\", mJoinerIid[0], mJoinerIid[1],\n                     mJoinerIid[2], mJoinerIid[3], mJoinerIid[4], mJoinerIid[5], mJoinerIid[6], mJoinerIid[7],\n                     mJoinerRloc);\n\n    aMessage.SetOffset(offset);\n    SuccessOrExit(error = aMessage.SetLength(offset + length));\n\n    joinerMessageInfo.SetPeerAddr(Get<Mle::MleRouter>().GetMeshLocal64());\n    joinerMessageInfo.GetPeerAddr().SetIid(mJoinerIid);\n    joinerMessageInfo.SetPeerPort(mJoinerPort);\n\n    Get<Coap::CoapSecure>().HandleUdpReceive(aMessage, joinerMessageInfo);\n\nexit:\n    return;\n}\n\nvoid Commissioner::HandleDatasetChanged(void *aContext, otMessage *aMessage, const otMessageInfo *aMessageInfo)\n{\n    static_cast<Commissioner *>(aContext)->HandleDatasetChanged(*static_cast<Coap::Message *>(aMessage),\n                                                                *static_cast<const Ip6::MessageInfo *>(aMessageInfo));\n}\n\nvoid Commissioner::HandleDatasetChanged(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    VerifyOrExit(aMessage.GetType() == OT_COAP_TYPE_CONFIRMABLE && aMessage.GetCode() == OT_COAP_CODE_POST);\n\n    otLogInfoMeshCoP(\"received dataset changed\");\n\n    SuccessOrExit(Get<Coap::Coap>().SendEmptyAck(aMessage, aMessageInfo));\n\n    otLogInfoMeshCoP(\"sent dataset changed acknowledgment\");\n\nexit:\n    return;\n}\n\nvoid Commissioner::HandleJoinerFinalize(void *aContext, otMessage *aMessage, const otMessageInfo *aMessageInfo)\n{\n    static_cast<Commissioner *>(aContext)->HandleJoinerFinalize(*static_cast<Coap::Message *>(aMessage),\n                                                                *static_cast<const Ip6::MessageInfo *>(aMessageInfo));\n}\n\nvoid Commissioner::HandleJoinerFinalize(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    StateTlv::State    state = StateTlv::kAccept;\n    ProvisioningUrlTlv provisioningUrl;\n\n    otLogInfoMeshCoP(\"received joiner finalize\");\n\n    if (Tlv::GetTlv(aMessage, Tlv::kProvisioningUrl, sizeof(provisioningUrl), provisioningUrl) == OT_ERROR_NONE)\n    {\n        uint8_t len = static_cast<uint8_t>(strnlen(mProvisioningUrl, sizeof(mProvisioningUrl)));\n\n        if ((provisioningUrl.GetProvisioningUrlLength() != len) ||\n            !memcmp(provisioningUrl.GetProvisioningUrl(), mProvisioningUrl, len))\n        {\n            state = StateTlv::kReject;\n        }\n    }\n\n#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE\n    if (aMessage.GetLength() <= OPENTHREAD_CONFIG_MESSAGE_BUFFER_SIZE)\n    {\n        uint8_t buf[OPENTHREAD_CONFIG_MESSAGE_BUFFER_SIZE];\n\n        aMessage.Read(aMessage.GetOffset(), aMessage.GetLength() - aMessage.GetOffset(), buf);\n        otDumpCertMeshCoP(\"[THCI] direction=recv | type=JOIN_FIN.req |\", buf,\n                          aMessage.GetLength() - aMessage.GetOffset());\n    }\n#endif\n\n    SendJoinFinalizeResponse(aMessage, state);\n}\n\nvoid Commissioner::SendJoinFinalizeResponse(const Coap::Message &aRequest, StateTlv::State aState)\n{\n    otError           error = OT_ERROR_NONE;\n    Ip6::MessageInfo  joinerMessageInfo;\n    MeshCoP::StateTlv stateTlv;\n    Coap::Message *   message;\n    Mac::ExtAddress   joinerId;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::CoapSecure>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->SetDefaultResponseHeader(aRequest));\n    SuccessOrExit(error = message->SetPayloadMarker());\n    message->SetOffset(message->GetLength());\n    message->SetSubType(Message::kSubTypeJoinerFinalizeResponse);\n\n    stateTlv.Init();\n    stateTlv.SetState(aState);\n    SuccessOrExit(error = message->AppendTlv(stateTlv));\n\n    joinerMessageInfo.SetPeerAddr(Get<Mle::MleRouter>().GetMeshLocal64());\n    joinerMessageInfo.GetPeerAddr().SetIid(mJoinerIid);\n    joinerMessageInfo.SetPeerPort(mJoinerPort);\n\n#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE\n    uint8_t buf[OPENTHREAD_CONFIG_MESSAGE_BUFFER_SIZE];\n\n    VerifyOrExit(message->GetLength() <= sizeof(buf));\n    message->Read(message->GetOffset(), message->GetLength() - message->GetOffset(), buf);\n    otDumpCertMeshCoP(\"[THCI] direction=send | type=JOIN_FIN.rsp |\", buf, message->GetLength() - message->GetOffset());\n#endif\n\n    SuccessOrExit(error = Get<Coap::CoapSecure>().SendMessage(*message, joinerMessageInfo));\n\n    joinerId.Set(mJoinerIid);\n    joinerId.ToggleLocal();\n    SignalJoinerEvent(OT_COMMISSIONER_JOINER_FINALIZE, joinerId);\n\n    if (!mJoiners[mJoinerIndex].mAny)\n    {\n        // remove after kRemoveJoinerDelay (seconds)\n        RemoveJoiner(&mJoiners[mJoinerIndex].mEui64, kRemoveJoinerDelay);\n    }\n\n    otLogInfoMeshCoP(\"sent joiner finalize response\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n}\n\notError Commissioner::SendRelayTransmit(void *aContext, Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    return static_cast<Commissioner *>(aContext)->SendRelayTransmit(aMessage, aMessageInfo);\n}\n\notError Commissioner::SendRelayTransmit(Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    otError                error = OT_ERROR_NONE;\n    JoinerUdpPortTlv       udpPort;\n    JoinerIidTlv           iid;\n    JoinerRouterLocatorTlv rloc;\n    ExtendedTlv            tlv;\n    Coap::Message *        message;\n    uint16_t               offset;\n    Ip6::MessageInfo       messageInfo;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    message->Init(OT_COAP_TYPE_NON_CONFIRMABLE, OT_COAP_CODE_POST);\n    SuccessOrExit(error = message->AppendUriPathOptions(OT_URI_PATH_RELAY_TX));\n    SuccessOrExit(error = message->SetPayloadMarker());\n\n    udpPort.Init();\n    udpPort.SetUdpPort(mJoinerPort);\n    SuccessOrExit(error = message->AppendTlv(udpPort));\n\n    iid.Init();\n    iid.SetIid(mJoinerIid);\n    SuccessOrExit(error = message->AppendTlv(iid));\n\n    rloc.Init();\n    rloc.SetJoinerRouterLocator(mJoinerRloc);\n    SuccessOrExit(error = message->AppendTlv(rloc));\n\n    if (aMessage.GetSubType() == Message::kSubTypeJoinerFinalizeResponse)\n    {\n        JoinerRouterKekTlv kek;\n        kek.Init();\n        kek.SetKek(Get<KeyManager>().GetKek());\n        SuccessOrExit(error = message->AppendTlv(kek));\n    }\n\n    tlv.SetType(Tlv::kJoinerDtlsEncapsulation);\n    tlv.SetLength(aMessage.GetLength());\n    SuccessOrExit(error = message->Append(&tlv, sizeof(tlv)));\n    offset = message->GetLength();\n    SuccessOrExit(error = message->SetLength(offset + aMessage.GetLength()));\n    aMessage.CopyTo(0, offset, aMessage.GetLength(), *message);\n\n    messageInfo.SetPeerAddr(Get<Mle::MleRouter>().GetMeshLocal16());\n    messageInfo.GetPeerAddr().mFields.m16[7] = HostSwap16(mJoinerRloc);\n    messageInfo.SetPeerPort(kCoapUdpPort);\n\n    SuccessOrExit(error = Get<Coap::Coap>().SendMessage(*message, messageInfo));\n\n    aMessage.Free();\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n\n    return error;\n}\n\notError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}\n\n// LCOV_EXCL_START\n\n#if (OPENTHREAD_CONFIG_LOG_LEVEL >= OT_LOG_LEVEL_INFO) && (OPENTHREAD_CONFIG_LOG_MLE == 1)\n\nconst char *Commissioner::StateToString(otCommissionerState aState)\n{\n    const char *str = \"Unknown\";\n\n    switch (aState)\n    {\n    case OT_COMMISSIONER_STATE_DISABLED:\n        str = \"disabled\";\n        break;\n    case OT_COMMISSIONER_STATE_PETITION:\n        str = \"petition\";\n        break;\n    case OT_COMMISSIONER_STATE_ACTIVE:\n        str = \"active\";\n        break;\n    default:\n        break;\n    }\n\n    return str;\n}\n\n#endif // (OPENTHREAD_CONFIG_LOG_LEVEL >= OT_LOG_LEVEL_INFO) && (OPENTHREAD_CONFIG_LOG_MLE == 1)\n\n// LCOV_EXCL_STOP\n\n} // namespace MeshCoP\n} // namespace ot\n\n#endif // OPENTHREAD_FTD && OPENTHREAD_CONFIG_COMMISSIONER_ENABLE\n"], "fixing_code": ["/*\n *  Copyright (c) 2016, The OpenThread Authors.\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright\n *     notice, this list of conditions and the following disclaimer.\n *  2. Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *  3. Neither the name of the copyright holder nor the\n *     names of its contributors may be used to endorse or promote products\n *     derived from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @file\n *   This file implements a Commissioner role.\n */\n\n#include \"commissioner.hpp\"\n\n#include <stdio.h>\n#include \"utils/wrap_string.h\"\n\n#include \"coap/coap_message.hpp\"\n#include \"common/encoding.hpp\"\n#include \"common/instance.hpp\"\n#include \"common/locator-getters.hpp\"\n#include \"common/logging.hpp\"\n#include \"crypto/pbkdf2_cmac.h\"\n#include \"meshcop/joiner_router.hpp\"\n#include \"meshcop/meshcop.hpp\"\n#include \"meshcop/meshcop_tlvs.hpp\"\n#include \"thread/thread_netif.hpp\"\n#include \"thread/thread_tlvs.hpp\"\n#include \"thread/thread_uri_paths.hpp\"\n\n#if OPENTHREAD_FTD && OPENTHREAD_CONFIG_COMMISSIONER_ENABLE\n\nnamespace ot {\nnamespace MeshCoP {\n\nCommissioner::Commissioner(Instance &aInstance)\n    : InstanceLocator(aInstance)\n    , mJoinerPort(0)\n    , mJoinerRloc(0)\n    , mSessionId(0)\n    , mJoinerIndex(0)\n    , mTransmitAttempts(0)\n    , mJoinerExpirationTimer(aInstance, HandleJoinerExpirationTimer, this)\n    , mTimer(aInstance, HandleTimer, this)\n    , mRelayReceive(OT_URI_PATH_RELAY_RX, &Commissioner::HandleRelayReceive, this)\n    , mDatasetChanged(OT_URI_PATH_DATASET_CHANGED, &Commissioner::HandleDatasetChanged, this)\n    , mJoinerFinalize(OT_URI_PATH_JOINER_FINALIZE, &Commissioner::HandleJoinerFinalize, this)\n    , mAnnounceBegin(aInstance)\n    , mEnergyScan(aInstance)\n    , mPanIdQuery(aInstance)\n    , mStateCallback(NULL)\n    , mJoinerCallback(NULL)\n    , mCallbackContext(NULL)\n    , mState(OT_COMMISSIONER_STATE_DISABLED)\n{\n    memset(mJoiners, 0, sizeof(mJoiners));\n\n    mCommissionerAloc.Clear();\n    mCommissionerAloc.mPrefixLength       = 64;\n    mCommissionerAloc.mPreferred          = true;\n    mCommissionerAloc.mValid              = true;\n    mCommissionerAloc.mScopeOverride      = Ip6::Address::kRealmLocalScope;\n    mCommissionerAloc.mScopeOverrideValid = true;\n\n    mProvisioningUrl[0] = '\\0';\n}\n\nvoid Commissioner::SetState(otCommissionerState aState)\n{\n    VerifyOrExit(mState != aState);\n\n    otLogInfoMeshCoP(\"Commissioner State: %s -> %s\", StateToString(mState), StateToString(aState));\n\n    mState = aState;\n\n    if (mStateCallback)\n    {\n        mStateCallback(mState, mCallbackContext);\n    }\n\nexit:\n    return;\n}\n\nvoid Commissioner::SignalJoinerEvent(otCommissionerJoinerEvent aEvent, const Mac::ExtAddress &aJoinerId)\n{\n    if (mJoinerCallback)\n    {\n        mJoinerCallback(aEvent, &aJoinerId, mCallbackContext);\n    }\n}\n\nvoid Commissioner::AddCoapResources(void)\n{\n    Get<Coap::Coap>().AddResource(mRelayReceive);\n    Get<Coap::Coap>().AddResource(mDatasetChanged);\n    Get<Coap::CoapSecure>().AddResource(mJoinerFinalize);\n}\n\nvoid Commissioner::RemoveCoapResources(void)\n{\n    Get<Coap::Coap>().RemoveResource(mRelayReceive);\n    Get<Coap::Coap>().RemoveResource(mDatasetChanged);\n    Get<Coap::CoapSecure>().RemoveResource(mJoinerFinalize);\n}\n\nvoid Commissioner::HandleCoapsConnected(bool aConnected, void *aContext)\n{\n    static_cast<Commissioner *>(aContext)->HandleCoapsConnected(aConnected);\n}\n\nvoid Commissioner::HandleCoapsConnected(bool aConnected)\n{\n    otCommissionerJoinerEvent event;\n    Mac::ExtAddress           joinerId;\n\n    event = aConnected ? OT_COMMISSIONER_JOINER_CONNECTED : OT_COMMISSIONER_JOINER_END;\n\n    joinerId.Set(mJoinerIid);\n    joinerId.ToggleLocal();\n\n    SignalJoinerEvent(event, joinerId);\n}\n\notError Commissioner::Start(otCommissionerStateCallback  aStateCallback,\n                            otCommissionerJoinerCallback aJoinerCallback,\n                            void *                       aCallbackContext)\n{\n    otError error = OT_ERROR_NONE;\n\n    VerifyOrExit(Get<Mle::MleRouter>().IsAttached(), error = OT_ERROR_INVALID_STATE);\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_DISABLED, error = OT_ERROR_INVALID_STATE);\n\n    SuccessOrExit(error = Get<Coap::CoapSecure>().Start(SendRelayTransmit, this));\n    Get<Coap::CoapSecure>().SetConnectedCallback(&Commissioner::HandleCoapsConnected, this);\n\n    mStateCallback    = aStateCallback;\n    mJoinerCallback   = aJoinerCallback;\n    mCallbackContext  = aCallbackContext;\n    mTransmitAttempts = 0;\n\n    SuccessOrExit(error = SendPetition());\n    SetState(OT_COMMISSIONER_STATE_PETITION);\n\nexit:\n    return error;\n}\n\notError Commissioner::Stop(void)\n{\n    otError error = OT_ERROR_NONE;\n\n    VerifyOrExit(mState != OT_COMMISSIONER_STATE_DISABLED, error = OT_ERROR_INVALID_STATE);\n\n    Get<Coap::CoapSecure>().Stop();\n\n    Get<ThreadNetif>().RemoveUnicastAddress(mCommissionerAloc);\n    RemoveCoapResources();\n    ClearJoiners();\n    mTransmitAttempts = 0;\n\n    mTimer.Stop();\n    Get<Coap::CoapSecure>().Stop();\n\n    SetState(OT_COMMISSIONER_STATE_DISABLED);\n\n    SendKeepAlive();\n\nexit:\n    return error;\n}\n\notError Commissioner::SendCommissionerSet(void)\n{\n    otError                error;\n    otCommissioningDataset dataset;\n    SteeringDataTlv        steeringData;\n    Mac::ExtAddress        joinerId;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n\n    memset(&dataset, 0, sizeof(dataset));\n\n    // session id\n    dataset.mSessionId      = mSessionId;\n    dataset.mIsSessionIdSet = true;\n\n    // compute bloom filter\n    steeringData.Init();\n    steeringData.Clear();\n\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (!joiner->mValid)\n        {\n            continue;\n        }\n\n        if (joiner->mAny)\n        {\n            steeringData.SetLength(1);\n            steeringData.Set();\n            break;\n        }\n\n        ComputeJoinerId(joiner->mEui64, joinerId);\n        steeringData.ComputeBloomFilter(joinerId);\n    }\n\n    // set bloom filter\n    dataset.mSteeringData.mLength = steeringData.GetSteeringDataLength();\n    memcpy(dataset.mSteeringData.m8, steeringData.GetValue(), dataset.mSteeringData.mLength);\n    dataset.mIsSteeringDataSet = true;\n\n    SuccessOrExit(error = SendMgmtCommissionerSetRequest(dataset, NULL, 0));\n\nexit:\n    return error;\n}\n\nvoid Commissioner::ClearJoiners(void)\n{\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        joiner->mValid = false;\n    }\n\n    SendCommissionerSet();\n}\n\notError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)\n{\n    otError error = OT_ERROR_NO_BUFS;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n\n    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);\n    RemoveJoiner(aEui64, 0); // remove immediately\n\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (joiner->mValid)\n        {\n            continue;\n        }\n\n        if (aEui64 != NULL)\n        {\n            joiner->mEui64 = *aEui64;\n            joiner->mAny   = false;\n        }\n        else\n        {\n            joiner->mAny = true;\n        }\n\n        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));\n        joiner->mValid          = true;\n        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);\n\n        UpdateJoinerExpirationTimer();\n\n        SendCommissionerSet();\n\n        otLogInfoMeshCoP(\"Added Joiner (%s, %s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\", aPskd);\n\n        ExitNow(error = OT_ERROR_NONE);\n    }\n\nexit:\n    return error;\n}\n\notError Commissioner::GetNextJoinerInfo(uint16_t &aIterator, otJoinerInfo &aJoiner) const\n{\n    otError error = OT_ERROR_NONE;\n    size_t  index;\n\n    for (index = aIterator; index < OT_ARRAY_LENGTH(mJoiners); index++)\n    {\n        if (!mJoiners[index].mValid)\n        {\n            continue;\n        }\n\n        memset(&aJoiner, 0, sizeof(aJoiner));\n\n        aJoiner.mAny   = mJoiners[index].mAny;\n        aJoiner.mEui64 = mJoiners[index].mEui64;\n        strlcpy(aJoiner.mPsk, mJoiners[index].mPsk, sizeof(aJoiner.mPsk));\n        aJoiner.mExpirationTime = mJoiners[index].mExpirationTime - TimerMilli::GetNow();\n        aIterator               = static_cast<uint16_t>(index) + 1;\n        ExitNow();\n    }\n\n    error = OT_ERROR_NOT_FOUND;\n\nexit:\n    return error;\n}\n\notError Commissioner::RemoveJoiner(const Mac::ExtAddress *aEui64, uint32_t aDelay)\n{\n    otError error = OT_ERROR_NOT_FOUND;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (!joiner->mValid)\n        {\n            continue;\n        }\n\n        if (aEui64 != NULL)\n        {\n            if (joiner->mEui64 != *aEui64)\n            {\n                continue;\n            }\n        }\n        else if (!joiner->mAny)\n        {\n            continue;\n        }\n\n        if (aDelay > 0)\n        {\n            TimeMilli now = TimerMilli::GetNow();\n\n            if ((joiner->mExpirationTime > now) && (joiner->mExpirationTime - now > Time::SecToMsec(aDelay)))\n            {\n                joiner->mExpirationTime = now + Time::SecToMsec(aDelay);\n                UpdateJoinerExpirationTimer();\n            }\n        }\n        else\n        {\n            Mac::ExtAddress joinerId;\n\n            joiner->mValid = false;\n            UpdateJoinerExpirationTimer();\n            SendCommissionerSet();\n\n            otLogInfoMeshCoP(\"Removed Joiner (%s)\", (aEui64 != NULL) ? aEui64->ToString().AsCString() : \"*\");\n\n            ComputeJoinerId(joiner->mEui64, joinerId);\n            SignalJoinerEvent(OT_COMMISSIONER_JOINER_REMOVED, joinerId);\n        }\n\n        ExitNow(error = OT_ERROR_NONE);\n    }\n\nexit:\n    return error;\n}\n\notError Commissioner::SetProvisioningUrl(const char *aProvisioningUrl)\n{\n    otError error = OT_ERROR_NONE;\n    uint8_t len;\n\n    if (aProvisioningUrl == NULL)\n    {\n        mProvisioningUrl[0] = '\\0';\n        ExitNow();\n    }\n\n    len = static_cast<uint8_t>(strnlen(aProvisioningUrl, sizeof(mProvisioningUrl)));\n\n    VerifyOrExit(len < sizeof(mProvisioningUrl), error = OT_ERROR_INVALID_ARGS);\n\n    memcpy(mProvisioningUrl, aProvisioningUrl, len);\n    mProvisioningUrl[len] = '\\0';\n\nexit:\n    return error;\n}\n\nvoid Commissioner::HandleTimer(Timer &aTimer)\n{\n    aTimer.GetOwner<Commissioner>().HandleTimer();\n}\n\nvoid Commissioner::HandleTimer(void)\n{\n    switch (mState)\n    {\n    case OT_COMMISSIONER_STATE_DISABLED:\n        break;\n\n    case OT_COMMISSIONER_STATE_PETITION:\n        SendPetition();\n        break;\n\n    case OT_COMMISSIONER_STATE_ACTIVE:\n        SendKeepAlive();\n        break;\n    }\n}\n\nvoid Commissioner::HandleJoinerExpirationTimer(Timer &aTimer)\n{\n    aTimer.GetOwner<Commissioner>().HandleJoinerExpirationTimer();\n}\n\nvoid Commissioner::HandleJoinerExpirationTimer(void)\n{\n    TimeMilli now = TimerMilli::GetNow();\n\n    // Remove Joiners.\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        if (!joiner->mValid)\n        {\n            continue;\n        }\n\n        if (now >= joiner->mExpirationTime)\n        {\n            otLogDebgMeshCoP(\"removing joiner due to timeout or successfully joined\");\n            RemoveJoiner(&joiner->mEui64, 0); // remove immediately\n        }\n    }\n\n    UpdateJoinerExpirationTimer();\n}\n\nvoid Commissioner::UpdateJoinerExpirationTimer(void)\n{\n    TimeMilli now         = TimerMilli::GetNow();\n    uint32_t  nextTimeout = TimeMilli::kMaxDuration;\n\n    // Check if timer should be set for next Joiner.\n    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n    {\n        uint32_t diff;\n\n        if (!joiner->mValid)\n        {\n            continue;\n        }\n\n        if (now >= joiner->mExpirationTime)\n        {\n            nextTimeout = 0;\n            break;\n        }\n\n        diff = joiner->mExpirationTime - now;\n\n        if (diff < nextTimeout)\n        {\n            nextTimeout = diff;\n        }\n    }\n\n    if (nextTimeout != TimeMilli::kMaxDuration)\n    {\n        // Update the timer to the timeout of the next Joiner.\n        mJoinerExpirationTimer.Start(nextTimeout);\n    }\n    else\n    {\n        // No Joiners, stop the timer.\n        mJoinerExpirationTimer.Stop();\n    }\n}\n\notError Commissioner::SendMgmtCommissionerGetRequest(const uint8_t *aTlvs, uint8_t aLength)\n{\n    otError          error = OT_ERROR_NONE;\n    Coap::Message *  message;\n    Ip6::MessageInfo messageInfo;\n    MeshCoP::Tlv     tlv;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->Init(OT_COAP_TYPE_CONFIRMABLE, OT_COAP_CODE_POST, OT_URI_PATH_COMMISSIONER_GET));\n\n    if (aLength > 0)\n    {\n        SuccessOrExit(error = message->SetPayloadMarker());\n    }\n\n    if (aLength > 0)\n    {\n        tlv.SetType(MeshCoP::Tlv::kGet);\n        tlv.SetLength(aLength);\n        SuccessOrExit(error = message->Append(&tlv, sizeof(tlv)));\n        SuccessOrExit(error = message->Append(aTlvs, aLength));\n    }\n\n    messageInfo.SetSockAddr(Get<Mle::MleRouter>().GetMeshLocal16());\n    SuccessOrExit(error = Get<Mle::MleRouter>().GetLeaderAloc(messageInfo.GetPeerAddr()));\n    messageInfo.SetPeerPort(kCoapUdpPort);\n    SuccessOrExit(error = Get<Coap::Coap>().SendMessage(*message, messageInfo,\n                                                        Commissioner::HandleMgmtCommissionerGetResponse, this));\n\n    otLogInfoMeshCoP(\"sent MGMT_COMMISSIONER_GET.req to leader\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n\n    return error;\n}\n\nvoid Commissioner::HandleMgmtCommissionerGetResponse(void *               aContext,\n                                                     otMessage *          aMessage,\n                                                     const otMessageInfo *aMessageInfo,\n                                                     otError              aResult)\n{\n    static_cast<Commissioner *>(aContext)->HandleMgmtCommissionerGetResponse(\n        static_cast<Coap::Message *>(aMessage), static_cast<const Ip6::MessageInfo *>(aMessageInfo), aResult);\n}\n\nvoid Commissioner::HandleMgmtCommissionerGetResponse(Coap::Message *         aMessage,\n                                                     const Ip6::MessageInfo *aMessageInfo,\n                                                     otError                 aResult)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    VerifyOrExit(aResult == OT_ERROR_NONE && aMessage->GetCode() == OT_COAP_CODE_CHANGED);\n    otLogInfoMeshCoP(\"received MGMT_COMMISSIONER_GET response\");\n\nexit:\n    return;\n}\n\notError Commissioner::SendMgmtCommissionerSetRequest(const otCommissioningDataset &aDataset,\n                                                     const uint8_t *               aTlvs,\n                                                     uint8_t                       aLength)\n{\n    otError          error = OT_ERROR_NONE;\n    Coap::Message *  message;\n    Ip6::MessageInfo messageInfo;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->Init(OT_COAP_TYPE_CONFIRMABLE, OT_COAP_CODE_POST, OT_URI_PATH_COMMISSIONER_SET));\n    SuccessOrExit(error = message->SetPayloadMarker());\n\n    if (aDataset.mIsLocatorSet)\n    {\n        MeshCoP::BorderAgentLocatorTlv locator;\n        locator.Init();\n        locator.SetBorderAgentLocator(aDataset.mLocator);\n        SuccessOrExit(error = message->AppendTlv(locator));\n    }\n\n    if (aDataset.mIsSessionIdSet)\n    {\n        MeshCoP::CommissionerSessionIdTlv sessionId;\n        sessionId.Init();\n        sessionId.SetCommissionerSessionId(aDataset.mSessionId);\n        SuccessOrExit(error = message->AppendTlv(sessionId));\n    }\n\n    if (aDataset.mIsSteeringDataSet)\n    {\n        MeshCoP::SteeringDataTlv steeringData;\n        steeringData.Init();\n        steeringData.SetLength(aDataset.mSteeringData.mLength);\n        SuccessOrExit(error = message->Append(&steeringData, sizeof(MeshCoP::Tlv)));\n        SuccessOrExit(error = message->Append(&aDataset.mSteeringData.m8, aDataset.mSteeringData.mLength));\n    }\n\n    if (aDataset.mIsJoinerUdpPortSet)\n    {\n        MeshCoP::JoinerUdpPortTlv joinerUdpPort;\n        joinerUdpPort.Init();\n        joinerUdpPort.SetUdpPort(aDataset.mJoinerUdpPort);\n        SuccessOrExit(error = message->AppendTlv(joinerUdpPort));\n    }\n\n    if (aLength > 0)\n    {\n        SuccessOrExit(error = message->Append(aTlvs, aLength));\n    }\n\n    if (message->GetLength() == message->GetOffset())\n    {\n        // no payload, remove coap payload marker\n        message->SetLength(message->GetLength() - 1);\n    }\n\n    messageInfo.SetSockAddr(Get<Mle::MleRouter>().GetMeshLocal16());\n    SuccessOrExit(error = Get<Mle::MleRouter>().GetLeaderAloc(messageInfo.GetPeerAddr()));\n    messageInfo.SetPeerPort(kCoapUdpPort);\n    SuccessOrExit(error = Get<Coap::Coap>().SendMessage(*message, messageInfo,\n                                                        Commissioner::HandleMgmtCommissionerSetResponse, this));\n\n    otLogInfoMeshCoP(\"sent MGMT_COMMISSIONER_SET.req to leader\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n\n    return error;\n}\n\nvoid Commissioner::HandleMgmtCommissionerSetResponse(void *               aContext,\n                                                     otMessage *          aMessage,\n                                                     const otMessageInfo *aMessageInfo,\n                                                     otError              aResult)\n{\n    static_cast<Commissioner *>(aContext)->HandleMgmtCommissionerSetResponse(\n        static_cast<Coap::Message *>(aMessage), static_cast<const Ip6::MessageInfo *>(aMessageInfo), aResult);\n}\n\nvoid Commissioner::HandleMgmtCommissionerSetResponse(Coap::Message *         aMessage,\n                                                     const Ip6::MessageInfo *aMessageInfo,\n                                                     otError                 aResult)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    VerifyOrExit(aResult == OT_ERROR_NONE && aMessage->GetCode() == OT_COAP_CODE_CHANGED);\n    otLogInfoMeshCoP(\"received MGMT_COMMISSIONER_SET response\");\n\nexit:\n    return;\n}\n\notError Commissioner::SendPetition(void)\n{\n    otError           error   = OT_ERROR_NONE;\n    Coap::Message *   message = NULL;\n    Ip6::MessageInfo  messageInfo;\n    CommissionerIdTlv commissionerId;\n\n    mTransmitAttempts++;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->Init(OT_COAP_TYPE_CONFIRMABLE, OT_COAP_CODE_POST, OT_URI_PATH_LEADER_PETITION));\n    SuccessOrExit(error = message->SetPayloadMarker());\n\n    commissionerId.Init();\n    commissionerId.SetCommissionerId(\"OpenThread Commissioner\");\n\n    SuccessOrExit(error = message->AppendTlv(commissionerId));\n\n    SuccessOrExit(error = Get<Mle::MleRouter>().GetLeaderAloc(messageInfo.GetPeerAddr()));\n    messageInfo.SetPeerPort(kCoapUdpPort);\n    messageInfo.SetSockAddr(Get<Mle::MleRouter>().GetMeshLocal16());\n    SuccessOrExit(\n        error = Get<Coap::Coap>().SendMessage(*message, messageInfo, Commissioner::HandleLeaderPetitionResponse, this));\n\n    otLogInfoMeshCoP(\"sent petition\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n\n    return error;\n}\n\nvoid Commissioner::HandleLeaderPetitionResponse(void *               aContext,\n                                                otMessage *          aMessage,\n                                                const otMessageInfo *aMessageInfo,\n                                                otError              aResult)\n{\n    static_cast<Commissioner *>(aContext)->HandleLeaderPetitionResponse(\n        static_cast<Coap::Message *>(aMessage), static_cast<const Ip6::MessageInfo *>(aMessageInfo), aResult);\n}\n\nvoid Commissioner::HandleLeaderPetitionResponse(Coap::Message *         aMessage,\n                                                const Ip6::MessageInfo *aMessageInfo,\n                                                otError                 aResult)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    StateTlv                 state;\n    CommissionerSessionIdTlv sessionId;\n    bool                     retransmit = false;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_PETITION, SetState(OT_COMMISSIONER_STATE_DISABLED));\n    VerifyOrExit(aResult == OT_ERROR_NONE && aMessage->GetCode() == OT_COAP_CODE_CHANGED, retransmit = true);\n\n    otLogInfoMeshCoP(\"received Leader Petition response\");\n\n    SuccessOrExit(Tlv::GetTlv(*aMessage, Tlv::kState, sizeof(state), state));\n    VerifyOrExit(state.IsValid());\n\n    VerifyOrExit(state.GetState() == StateTlv::kAccept, SetState(OT_COMMISSIONER_STATE_DISABLED));\n\n    SuccessOrExit(Tlv::GetTlv(*aMessage, Tlv::kCommissionerSessionId, sizeof(sessionId), sessionId));\n    VerifyOrExit(sessionId.IsValid());\n    mSessionId = sessionId.GetCommissionerSessionId();\n\n    Get<Mle::MleRouter>().GetCommissionerAloc(mCommissionerAloc.GetAddress(), mSessionId);\n    Get<ThreadNetif>().AddUnicastAddress(mCommissionerAloc);\n\n    AddCoapResources();\n    SetState(OT_COMMISSIONER_STATE_ACTIVE);\n\n    mTransmitAttempts = 0;\n    mTimer.Start(Time::SecToMsec(kKeepAliveTimeout) / 2);\n\nexit:\n\n    if (retransmit)\n    {\n        if (mTransmitAttempts >= kPetitionRetryCount)\n        {\n            SetState(OT_COMMISSIONER_STATE_DISABLED);\n        }\n        else\n        {\n            mTimer.Start(Time::SecToMsec(kPetitionRetryDelay));\n        }\n    }\n}\n\notError Commissioner::SendKeepAlive(void)\n{\n    otError                  error   = OT_ERROR_NONE;\n    Coap::Message *          message = NULL;\n    Ip6::MessageInfo         messageInfo;\n    StateTlv                 state;\n    CommissionerSessionIdTlv sessionId;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->Init(OT_COAP_TYPE_CONFIRMABLE, OT_COAP_CODE_POST, OT_URI_PATH_LEADER_KEEP_ALIVE));\n    SuccessOrExit(error = message->SetPayloadMarker());\n\n    state.Init();\n    state.SetState(mState == OT_COMMISSIONER_STATE_ACTIVE ? StateTlv::kAccept : StateTlv::kReject);\n    SuccessOrExit(error = message->AppendTlv(state));\n\n    sessionId.Init();\n    sessionId.SetCommissionerSessionId(mSessionId);\n    SuccessOrExit(error = message->AppendTlv(sessionId));\n\n    messageInfo.SetSockAddr(Get<Mle::MleRouter>().GetMeshLocal16());\n    SuccessOrExit(error = Get<Mle::MleRouter>().GetLeaderAloc(messageInfo.GetPeerAddr()));\n    messageInfo.SetPeerPort(kCoapUdpPort);\n    SuccessOrExit(error = Get<Coap::Coap>().SendMessage(*message, messageInfo,\n                                                        Commissioner::HandleLeaderKeepAliveResponse, this));\n\n    otLogInfoMeshCoP(\"sent keep alive\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n\n    return error;\n}\n\nvoid Commissioner::HandleLeaderKeepAliveResponse(void *               aContext,\n                                                 otMessage *          aMessage,\n                                                 const otMessageInfo *aMessageInfo,\n                                                 otError              aResult)\n{\n    static_cast<Commissioner *>(aContext)->HandleLeaderKeepAliveResponse(\n        static_cast<Coap::Message *>(aMessage), static_cast<const Ip6::MessageInfo *>(aMessageInfo), aResult);\n}\n\nvoid Commissioner::HandleLeaderKeepAliveResponse(Coap::Message *         aMessage,\n                                                 const Ip6::MessageInfo *aMessageInfo,\n                                                 otError                 aResult)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    StateTlv state;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, SetState(OT_COMMISSIONER_STATE_DISABLED));\n    VerifyOrExit(aResult == OT_ERROR_NONE && aMessage->GetCode() == OT_COAP_CODE_CHANGED,\n                 SetState(OT_COMMISSIONER_STATE_DISABLED));\n\n    otLogInfoMeshCoP(\"received Leader keep-alive response\");\n\n    SuccessOrExit(Tlv::GetTlv(*aMessage, Tlv::kState, sizeof(state), state));\n    VerifyOrExit(state.IsValid());\n\n    VerifyOrExit(state.GetState() == StateTlv::kAccept, SetState(OT_COMMISSIONER_STATE_DISABLED));\n\n    mTimer.Start(Time::SecToMsec(kKeepAliveTimeout) / 2);\n\nexit:\n\n    if (mState != OT_COMMISSIONER_STATE_ACTIVE)\n    {\n        Get<ThreadNetif>().RemoveUnicastAddress(mCommissionerAloc);\n        RemoveCoapResources();\n    }\n}\n\nvoid Commissioner::HandleRelayReceive(void *aContext, otMessage *aMessage, const otMessageInfo *aMessageInfo)\n{\n    static_cast<Commissioner *>(aContext)->HandleRelayReceive(*static_cast<Coap::Message *>(aMessage),\n                                                              *static_cast<const Ip6::MessageInfo *>(aMessageInfo));\n}\n\nvoid Commissioner::HandleRelayReceive(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    otError                error;\n    JoinerUdpPortTlv       joinerPort;\n    JoinerIidTlv           joinerIid;\n    JoinerRouterLocatorTlv joinerRloc;\n    Ip6::MessageInfo       joinerMessageInfo;\n    uint16_t               offset;\n    uint16_t               length;\n    bool                   enableJoiner = false;\n    Mac::ExtAddress        receivedId;\n    Mac::ExtAddress        joinerId;\n\n    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);\n\n    VerifyOrExit(aMessage.GetType() == OT_COAP_TYPE_NON_CONFIRMABLE && aMessage.GetCode() == OT_COAP_CODE_POST);\n\n    SuccessOrExit(error = Tlv::GetTlv(aMessage, Tlv::kJoinerUdpPort, sizeof(joinerPort), joinerPort));\n    VerifyOrExit(joinerPort.IsValid(), error = OT_ERROR_PARSE);\n\n    SuccessOrExit(error = Tlv::GetTlv(aMessage, Tlv::kJoinerIid, sizeof(joinerIid), joinerIid));\n    VerifyOrExit(joinerIid.IsValid(), error = OT_ERROR_PARSE);\n\n    SuccessOrExit(error = Tlv::GetTlv(aMessage, Tlv::kJoinerRouterLocator, sizeof(joinerRloc), joinerRloc));\n    VerifyOrExit(joinerRloc.IsValid(), error = OT_ERROR_PARSE);\n\n    SuccessOrExit(error = Tlv::GetValueOffset(aMessage, Tlv::kJoinerDtlsEncapsulation, offset, length));\n    VerifyOrExit(length <= aMessage.GetLength() - offset, error = OT_ERROR_PARSE);\n\n    if (!Get<Coap::CoapSecure>().IsConnectionActive())\n    {\n        memcpy(mJoinerIid, joinerIid.GetIid(), sizeof(mJoinerIid));\n\n        receivedId.Set(mJoinerIid);\n        receivedId.ToggleLocal();\n\n        for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)\n        {\n            if (!joiner->mValid)\n            {\n                continue;\n            }\n\n            ComputeJoinerId(joiner->mEui64, joinerId);\n\n            if (joiner->mAny || (joinerId == receivedId))\n            {\n                error = Get<Coap::CoapSecure>().SetPsk(reinterpret_cast<const uint8_t *>(joiner->mPsk),\n                                                       static_cast<uint8_t>(strlen(joiner->mPsk)));\n                SuccessOrExit(error);\n                mJoinerIndex = static_cast<uint8_t>(joiner - mJoiners);\n                enableJoiner = true;\n\n                otLogInfoMeshCoP(\"found joiner, starting new session\");\n                SignalJoinerEvent(OT_COMMISSIONER_JOINER_START, joinerId);\n\n                break;\n            }\n        }\n    }\n    else\n    {\n        enableJoiner = (memcmp(mJoinerIid, joinerIid.GetIid(), sizeof(mJoinerIid)) == 0);\n    }\n\n    VerifyOrExit(enableJoiner);\n\n    mJoinerPort = joinerPort.GetUdpPort();\n    mJoinerRloc = joinerRloc.GetJoinerRouterLocator();\n\n    otLogInfoMeshCoP(\"Remove Relay Receive (%02x%02x%02x%02x%02x%02x%02x%02x, 0x%04x)\", mJoinerIid[0], mJoinerIid[1],\n                     mJoinerIid[2], mJoinerIid[3], mJoinerIid[4], mJoinerIid[5], mJoinerIid[6], mJoinerIid[7],\n                     mJoinerRloc);\n\n    aMessage.SetOffset(offset);\n    SuccessOrExit(error = aMessage.SetLength(offset + length));\n\n    joinerMessageInfo.SetPeerAddr(Get<Mle::MleRouter>().GetMeshLocal64());\n    joinerMessageInfo.GetPeerAddr().SetIid(mJoinerIid);\n    joinerMessageInfo.SetPeerPort(mJoinerPort);\n\n    Get<Coap::CoapSecure>().HandleUdpReceive(aMessage, joinerMessageInfo);\n\nexit:\n    return;\n}\n\nvoid Commissioner::HandleDatasetChanged(void *aContext, otMessage *aMessage, const otMessageInfo *aMessageInfo)\n{\n    static_cast<Commissioner *>(aContext)->HandleDatasetChanged(*static_cast<Coap::Message *>(aMessage),\n                                                                *static_cast<const Ip6::MessageInfo *>(aMessageInfo));\n}\n\nvoid Commissioner::HandleDatasetChanged(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    VerifyOrExit(aMessage.GetType() == OT_COAP_TYPE_CONFIRMABLE && aMessage.GetCode() == OT_COAP_CODE_POST);\n\n    otLogInfoMeshCoP(\"received dataset changed\");\n\n    SuccessOrExit(Get<Coap::Coap>().SendEmptyAck(aMessage, aMessageInfo));\n\n    otLogInfoMeshCoP(\"sent dataset changed acknowledgment\");\n\nexit:\n    return;\n}\n\nvoid Commissioner::HandleJoinerFinalize(void *aContext, otMessage *aMessage, const otMessageInfo *aMessageInfo)\n{\n    static_cast<Commissioner *>(aContext)->HandleJoinerFinalize(*static_cast<Coap::Message *>(aMessage),\n                                                                *static_cast<const Ip6::MessageInfo *>(aMessageInfo));\n}\n\nvoid Commissioner::HandleJoinerFinalize(Coap::Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    StateTlv::State    state = StateTlv::kAccept;\n    ProvisioningUrlTlv provisioningUrl;\n\n    otLogInfoMeshCoP(\"received joiner finalize\");\n\n    if (Tlv::GetTlv(aMessage, Tlv::kProvisioningUrl, sizeof(provisioningUrl), provisioningUrl) == OT_ERROR_NONE)\n    {\n        uint8_t len = static_cast<uint8_t>(strnlen(mProvisioningUrl, sizeof(mProvisioningUrl)));\n\n        if ((provisioningUrl.GetProvisioningUrlLength() != len) ||\n            !memcmp(provisioningUrl.GetProvisioningUrl(), mProvisioningUrl, len))\n        {\n            state = StateTlv::kReject;\n        }\n    }\n\n#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE\n    if (aMessage.GetLength() <= OPENTHREAD_CONFIG_MESSAGE_BUFFER_SIZE)\n    {\n        uint8_t buf[OPENTHREAD_CONFIG_MESSAGE_BUFFER_SIZE];\n\n        aMessage.Read(aMessage.GetOffset(), aMessage.GetLength() - aMessage.GetOffset(), buf);\n        otDumpCertMeshCoP(\"[THCI] direction=recv | type=JOIN_FIN.req |\", buf,\n                          aMessage.GetLength() - aMessage.GetOffset());\n    }\n#endif\n\n    SendJoinFinalizeResponse(aMessage, state);\n}\n\nvoid Commissioner::SendJoinFinalizeResponse(const Coap::Message &aRequest, StateTlv::State aState)\n{\n    otError           error = OT_ERROR_NONE;\n    Ip6::MessageInfo  joinerMessageInfo;\n    MeshCoP::StateTlv stateTlv;\n    Coap::Message *   message;\n    Mac::ExtAddress   joinerId;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::CoapSecure>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    SuccessOrExit(error = message->SetDefaultResponseHeader(aRequest));\n    SuccessOrExit(error = message->SetPayloadMarker());\n    message->SetOffset(message->GetLength());\n    message->SetSubType(Message::kSubTypeJoinerFinalizeResponse);\n\n    stateTlv.Init();\n    stateTlv.SetState(aState);\n    SuccessOrExit(error = message->AppendTlv(stateTlv));\n\n    joinerMessageInfo.SetPeerAddr(Get<Mle::MleRouter>().GetMeshLocal64());\n    joinerMessageInfo.GetPeerAddr().SetIid(mJoinerIid);\n    joinerMessageInfo.SetPeerPort(mJoinerPort);\n\n#if OPENTHREAD_CONFIG_REFERENCE_DEVICE_ENABLE\n    uint8_t buf[OPENTHREAD_CONFIG_MESSAGE_BUFFER_SIZE];\n\n    VerifyOrExit(message->GetLength() <= sizeof(buf));\n    message->Read(message->GetOffset(), message->GetLength() - message->GetOffset(), buf);\n    otDumpCertMeshCoP(\"[THCI] direction=send | type=JOIN_FIN.rsp |\", buf, message->GetLength() - message->GetOffset());\n#endif\n\n    SuccessOrExit(error = Get<Coap::CoapSecure>().SendMessage(*message, joinerMessageInfo));\n\n    joinerId.Set(mJoinerIid);\n    joinerId.ToggleLocal();\n    SignalJoinerEvent(OT_COMMISSIONER_JOINER_FINALIZE, joinerId);\n\n    if (!mJoiners[mJoinerIndex].mAny)\n    {\n        // remove after kRemoveJoinerDelay (seconds)\n        RemoveJoiner(&mJoiners[mJoinerIndex].mEui64, kRemoveJoinerDelay);\n    }\n\n    otLogInfoMeshCoP(\"sent joiner finalize response\");\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n}\n\notError Commissioner::SendRelayTransmit(void *aContext, Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    return static_cast<Commissioner *>(aContext)->SendRelayTransmit(aMessage, aMessageInfo);\n}\n\notError Commissioner::SendRelayTransmit(Message &aMessage, const Ip6::MessageInfo &aMessageInfo)\n{\n    OT_UNUSED_VARIABLE(aMessageInfo);\n\n    otError                error = OT_ERROR_NONE;\n    JoinerUdpPortTlv       udpPort;\n    JoinerIidTlv           iid;\n    JoinerRouterLocatorTlv rloc;\n    ExtendedTlv            tlv;\n    Coap::Message *        message;\n    uint16_t               offset;\n    Ip6::MessageInfo       messageInfo;\n\n    VerifyOrExit((message = NewMeshCoPMessage(Get<Coap::Coap>())) != NULL, error = OT_ERROR_NO_BUFS);\n\n    message->Init(OT_COAP_TYPE_NON_CONFIRMABLE, OT_COAP_CODE_POST);\n    SuccessOrExit(error = message->AppendUriPathOptions(OT_URI_PATH_RELAY_TX));\n    SuccessOrExit(error = message->SetPayloadMarker());\n\n    udpPort.Init();\n    udpPort.SetUdpPort(mJoinerPort);\n    SuccessOrExit(error = message->AppendTlv(udpPort));\n\n    iid.Init();\n    iid.SetIid(mJoinerIid);\n    SuccessOrExit(error = message->AppendTlv(iid));\n\n    rloc.Init();\n    rloc.SetJoinerRouterLocator(mJoinerRloc);\n    SuccessOrExit(error = message->AppendTlv(rloc));\n\n    if (aMessage.GetSubType() == Message::kSubTypeJoinerFinalizeResponse)\n    {\n        JoinerRouterKekTlv kek;\n        kek.Init();\n        kek.SetKek(Get<KeyManager>().GetKek());\n        SuccessOrExit(error = message->AppendTlv(kek));\n    }\n\n    tlv.SetType(Tlv::kJoinerDtlsEncapsulation);\n    tlv.SetLength(aMessage.GetLength());\n    SuccessOrExit(error = message->Append(&tlv, sizeof(tlv)));\n    offset = message->GetLength();\n    SuccessOrExit(error = message->SetLength(offset + aMessage.GetLength()));\n    aMessage.CopyTo(0, offset, aMessage.GetLength(), *message);\n\n    messageInfo.SetPeerAddr(Get<Mle::MleRouter>().GetMeshLocal16());\n    messageInfo.GetPeerAddr().mFields.m16[7] = HostSwap16(mJoinerRloc);\n    messageInfo.SetPeerPort(kCoapUdpPort);\n\n    SuccessOrExit(error = Get<Coap::Coap>().SendMessage(*message, messageInfo));\n\n    aMessage.Free();\n\nexit:\n\n    if (error != OT_ERROR_NONE && message != NULL)\n    {\n        message->Free();\n    }\n\n    return error;\n}\n\notError Commissioner::GeneratePskc(const char *              aPassPhrase,\n                                   const char *              aNetworkName,\n                                   const Mac::ExtendedPanId &aExtPanId,\n                                   Pskc &                    aPskc)\n{\n    otError     error      = OT_ERROR_NONE;\n    const char *saltPrefix = \"Thread\";\n    uint8_t     salt[OT_PBKDF2_SALT_MAX_LEN];\n    uint16_t    saltLen = 0;\n\n    VerifyOrExit((strlen(aPassPhrase) >= OT_COMMISSIONING_PASSPHRASE_MIN_SIZE) &&\n                     (strlen(aPassPhrase) <= OT_COMMISSIONING_PASSPHRASE_MAX_SIZE) &&\n                     (strlen(aNetworkName) <= OT_NETWORK_NAME_MAX_SIZE),\n                 error = OT_ERROR_INVALID_ARGS);\n\n    memset(salt, 0, sizeof(salt));\n    memcpy(salt, saltPrefix, strlen(saltPrefix));\n    saltLen += static_cast<uint16_t>(strlen(saltPrefix));\n\n    memcpy(salt + saltLen, aExtPanId.m8, sizeof(aExtPanId));\n    saltLen += OT_EXT_PAN_ID_SIZE;\n\n    memcpy(salt + saltLen, aNetworkName, strlen(aNetworkName));\n    saltLen += static_cast<uint16_t>(strlen(aNetworkName));\n\n    otPbkdf2Cmac(reinterpret_cast<const uint8_t *>(aPassPhrase), static_cast<uint16_t>(strlen(aPassPhrase)),\n                 reinterpret_cast<const uint8_t *>(salt), saltLen, 16384, OT_PSKC_MAX_SIZE, aPskc.m8);\n\nexit:\n    return error;\n}\n\n// LCOV_EXCL_START\n\n#if (OPENTHREAD_CONFIG_LOG_LEVEL >= OT_LOG_LEVEL_INFO) && (OPENTHREAD_CONFIG_LOG_MLE == 1)\n\nconst char *Commissioner::StateToString(otCommissionerState aState)\n{\n    const char *str = \"Unknown\";\n\n    switch (aState)\n    {\n    case OT_COMMISSIONER_STATE_DISABLED:\n        str = \"disabled\";\n        break;\n    case OT_COMMISSIONER_STATE_PETITION:\n        str = \"petition\";\n        break;\n    case OT_COMMISSIONER_STATE_ACTIVE:\n        str = \"active\";\n        break;\n    default:\n        break;\n    }\n\n    return str;\n}\n\n#endif // (OPENTHREAD_CONFIG_LOG_LEVEL >= OT_LOG_LEVEL_INFO) && (OPENTHREAD_CONFIG_LOG_MLE == 1)\n\n// LCOV_EXCL_STOP\n\n} // namespace MeshCoP\n} // namespace ot\n\n#endif // OPENTHREAD_FTD && OPENTHREAD_CONFIG_COMMISSIONER_ENABLE\n"], "filenames": ["src/core/meshcop/commissioner.cpp"], "buggy_code_start_loc": [1112], "buggy_code_end_loc": [1113], "fixing_code_start_loc": [1112], "fixing_code_end_loc": [1114], "type": "CWE-787", "message": "OpenThread before 2019-12-13 has a stack-based buffer overflow in MeshCoP::Commissioner::GeneratePskc.", "other": {"cve": {"id": "CVE-2019-20791", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-28T18:15:12.660", "lastModified": "2020-05-01T20:22:05.760", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "OpenThread before 2019-12-13 has a stack-based buffer overflow in MeshCoP::Commissioner::GeneratePskc."}, {"lang": "es", "value": "OpenThread antes del 13-12-2019, tiene un desbordamiento del b\u00fafer en la regi\u00f3n stack de la memoria en la funci\u00f3n MeshCoP::Commissioner::GeneratePskc."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:google:openthread:*:*:*:*:*:*:*:*", "versionEndExcluding": "2019-12-13", "matchCriteriaId": "1D13263C-145E-4418-A0F8-9C8839359C5D"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=19386", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/openthread/openthread/commit/b8c3161281f8e15873f8decabd8eac461717aefe", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/openthread/openthread/commit/c3a3a0c424322009fec3ab735fb20ce8f6e19e70", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/openthread/openthread/commit/b8c3161281f8e15873f8decabd8eac461717aefe"}}