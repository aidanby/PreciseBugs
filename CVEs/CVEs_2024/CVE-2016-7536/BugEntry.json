{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               PPPP   RRRR    OOO   FFFFF  IIIII  L      EEEEE               %\n%               P   P  R   R  O   O  F        I    L      E                   %\n%               PPPP   RRRR   O   O  FFF      I    L      EEE                 %\n%               P      R R    O   O  F        I    L      E                   %\n%               P      R  R    OOO   F      IIIII  LLLLL  EEEEE               %\n%                                                                             %\n%                                                                             %\n%                       MagickCore Image Profile Methods                      %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/profile-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(MAGICKCORE_HAVE_LCMS_LCMS2_H)\n#include <wchar.h>\n#include <lcms/lcms2.h>\n#else\n#include <wchar.h>\n#include \"lcms2.h\"\n#endif\n#endif\n\f\n/*\n  Forward declarations\n*/\nstatic MagickBooleanType\n  SetImageProfileInternal(Image *,const char *,const StringInfo *,\n    const MagickBooleanType,ExceptionInfo *);\n\nstatic void\n  WriteTo8BimProfile(Image *,const char*,const StringInfo *);\n\f\n/*\n  Typedef declarations\n*/\nstruct _ProfileInfo\n{\n  char\n    *name;\n\n  size_t\n    length;\n\n  unsigned char\n    *info;\n\n  size_t\n    signature;\n};\n\ntypedef struct _CMSExceptionInfo\n{\n  Image\n    *image;\n\n  ExceptionInfo\n    *exception;\n} CMSExceptionInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o f i l e s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProfiles() clones one or more image profiles.\n%\n%  The format of the CloneImageProfiles method is:\n%\n%      MagickBooleanType CloneImageProfiles(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProfiles(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (clone_image->profiles != (void *) NULL)\n    {\n      if (image->profiles != (void *) NULL)\n        DestroyImageProfiles(image);\n      image->profiles=CloneSplayTree((SplayTreeInfo *) clone_image->profiles,\n        (void *(*)(void *)) ConstantString,(void *(*)(void *)) CloneStringInfo);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProfile() deletes a profile from the image by its name.\n%\n%  The format of the DeleteImageProfile method is:\n%\n%      MagickBooleanTyupe DeleteImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProfile(Image *image,const char *name)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return(MagickFalse);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->profiles,name));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o f i l e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProfiles() releases memory associated with an image profile map.\n%\n%  The format of the DestroyProfiles method is:\n%\n%      void DestroyImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProfiles(Image *image)\n{\n  if (image->profiles != (SplayTreeInfo *) NULL)\n    image->profiles=DestroySplayTree((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProfile() gets a profile associated with an image by name.\n%\n%  The format of the GetImageProfile method is:\n%\n%      const StringInfo *GetImageProfile(const Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport const StringInfo *GetImageProfile(const Image *image,\n  const char *name)\n{\n  const StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  profile=(const StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o f i l e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProfile() gets the next profile name for an image.\n%\n%  The format of the GetNextImageProfile method is:\n%\n%      char *GetNextImageProfile(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o hash_info: the hash info.\n%\n*/\nMagickExport char *GetNextImageProfile(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((char *) NULL);\n  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P r o f i l e I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ProfileImage() associates, applies, or removes an ICM, IPTC, or generic\n%  profile with / to / from an image.  If the profile is NULL, it is removed\n%  from the image otherwise added or applied.  Use a name of '*' and a profile\n%  of NULL to remove all profiles from the image.\n%\n%  ICC and ICM profiles are handled as follows: If the image does not have\n%  an associated color profile, the one you provide is associated with the\n%  image and the image pixels are not transformed.  Otherwise, the colorspace\n%  transform defined by the existing and new profile are applied to the image\n%  pixels and the new profile is associated with the image.\n%\n%  The format of the ProfileImage method is:\n%\n%      MagickBooleanType ProfileImage(Image *image,const char *name,\n%        const void *datum,const size_t length,const MagickBooleanType clone)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: Name of profile to add or remove: ICC, IPTC, or generic profile.\n%\n%    o datum: the profile data.\n%\n%    o length: the length of the profile.\n%\n%    o clone: should be MagickFalse.\n%\n*/\n\n#if defined(MAGICKCORE_LCMS_DELEGATE)\nstatic unsigned short **DestroyPixelThreadSet(unsigned short **pixels)\n{\n  register ssize_t\n    i;\n\n  assert(pixels != (unsigned short **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixels[i] != (unsigned short *) NULL)\n      pixels[i]=(unsigned short *) RelinquishMagickMemory(pixels[i]);\n  pixels=(unsigned short **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic unsigned short **AcquirePixelThreadSet(const size_t columns,\n  const size_t channels)\n{\n  register ssize_t\n    i;\n\n  unsigned short\n    **pixels;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(unsigned short **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n  if (pixels == (unsigned short **) NULL)\n    return((unsigned short **) NULL);\n  (void) ResetMagickMemory(pixels,0,number_threads*sizeof(*pixels));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixels[i]=(unsigned short *) AcquireQuantumMemory(columns,channels*\n      sizeof(**pixels));\n    if (pixels[i] == (unsigned short *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n  }\n  return(pixels);\n}\n\nstatic cmsHTRANSFORM *DestroyTransformThreadSet(cmsHTRANSFORM *transform)\n{\n  register ssize_t\n    i;\n\n  assert(transform != (cmsHTRANSFORM *) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (transform[i] != (cmsHTRANSFORM) NULL)\n      cmsDeleteTransform(transform[i]);\n  transform=(cmsHTRANSFORM *) RelinquishMagickMemory(transform);\n  return(transform);\n}\n\nstatic cmsHTRANSFORM *AcquireTransformThreadSet(Image *image,\n  const cmsHPROFILE source_profile,const cmsUInt32Number source_type,\n  const cmsHPROFILE target_profile,const cmsUInt32Number target_type,\n  const int intent,const cmsUInt32Number flags)\n{\n  cmsHTRANSFORM\n    *transform;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  transform=(cmsHTRANSFORM *) AcquireQuantumMemory(number_threads,\n    sizeof(*transform));\n  if (transform == (cmsHTRANSFORM *) NULL)\n    return((cmsHTRANSFORM *) NULL);\n  (void) ResetMagickMemory(transform,0,number_threads*sizeof(*transform));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    transform[i]=cmsCreateTransformTHR((cmsContext) image,source_profile,\n      source_type,target_profile,target_type,intent,flags);\n    if (transform[i] == (cmsHTRANSFORM) NULL)\n      return(DestroyTransformThreadSet(transform));\n  }\n  return(transform);\n}\n#endif\n\n#if defined(MAGICKCORE_LCMS_DELEGATE)\nstatic void CMSExceptionHandler(cmsContext context,cmsUInt32Number severity,\n  const char *message)\n{\n  CMSExceptionInfo\n    *cms_exception;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  cms_exception=(CMSExceptionInfo *) context;\n  image=cms_exception->image;\n  exception=cms_exception->exception;\n  if (image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n        \"UnableToTransformColorspace\",\"`%s'\",\"unknown context\");\n      return;\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"lcms: #%u, %s\",\n      severity,message != (char *) NULL ? message : \"no message\");\n  (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n    \"UnableToTransformColorspace\",\"`%s'\",image->filename);\n}\n#endif\n\nstatic MagickBooleanType SetsRGBImageProfile(Image *image,\n  ExceptionInfo *exception)\n{\n  static unsigned char\n    sRGBProfile[] =\n    {\n      0x00, 0x00, 0x0c, 0x8c, 0x61, 0x72, 0x67, 0x6c, 0x02, 0x20, 0x00, 0x00,\n      0x6d, 0x6e, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5a, 0x20,\n      0x07, 0xde, 0x00, 0x01, 0x00, 0x06, 0x00, 0x16, 0x00, 0x0f, 0x00, 0x3a,\n      0x61, 0x63, 0x73, 0x70, 0x4d, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00,\n      0x49, 0x45, 0x43, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0xd6,\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d, 0x61, 0x72, 0x67, 0x6c,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x00, 0x99,\n      0x63, 0x70, 0x72, 0x74, 0x00, 0x00, 0x01, 0xec, 0x00, 0x00, 0x00, 0x67,\n      0x64, 0x6d, 0x6e, 0x64, 0x00, 0x00, 0x02, 0x54, 0x00, 0x00, 0x00, 0x70,\n      0x64, 0x6d, 0x64, 0x64, 0x00, 0x00, 0x02, 0xc4, 0x00, 0x00, 0x00, 0x88,\n      0x74, 0x65, 0x63, 0x68, 0x00, 0x00, 0x03, 0x4c, 0x00, 0x00, 0x00, 0x0c,\n      0x76, 0x75, 0x65, 0x64, 0x00, 0x00, 0x03, 0x58, 0x00, 0x00, 0x00, 0x67,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x24,\n      0x6c, 0x75, 0x6d, 0x69, 0x00, 0x00, 0x03, 0xe4, 0x00, 0x00, 0x00, 0x14,\n      0x6d, 0x65, 0x61, 0x73, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x24,\n      0x77, 0x74, 0x70, 0x74, 0x00, 0x00, 0x04, 0x1c, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x6b, 0x70, 0x74, 0x00, 0x00, 0x04, 0x30, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x44, 0x00, 0x00, 0x00, 0x14,\n      0x67, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x58, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x6c, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x62, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,\n      0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36,\n      0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75, 0x69, 0x76,\n      0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77, 0x77, 0x77,\n      0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20, 0x31, 0x39,\n      0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c,\n      0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x3f, 0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31,\n      0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75,\n      0x69, 0x76, 0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77,\n      0x77, 0x77, 0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20,\n      0x31, 0x39, 0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66,\n      0x69, 0x6c, 0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x43, 0x72, 0x65, 0x61,\n      0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x47, 0x72, 0x61, 0x65, 0x6d,\n      0x65, 0x20, 0x57, 0x2e, 0x20, 0x47, 0x69, 0x6c, 0x6c, 0x2e, 0x20, 0x52,\n      0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x6f,\n      0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20,\n      0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x20, 0x4e, 0x6f, 0x20, 0x57,\n      0x61, 0x72, 0x72, 0x61, 0x6e, 0x74, 0x79, 0x2c, 0x20, 0x55, 0x73, 0x65,\n      0x20, 0x61, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x6f, 0x77, 0x6e,\n      0x20, 0x72, 0x69, 0x73, 0x6b, 0x2e, 0x00, 0x00, 0x64, 0x65, 0x73, 0x63,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20,\n      0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69,\n      0x65, 0x63, 0x2e, 0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20, 0x68, 0x74, 0x74,\n      0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69, 0x65, 0x63, 0x2e,\n      0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e,\n      0x49, 0x45, 0x43, 0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e,\n      0x31, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47,\n      0x42, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61,\n      0x63, 0x65, 0x20, 0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x49, 0x45, 0x43,\n      0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x44,\n      0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47, 0x42, 0x20, 0x63,\n      0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,\n      0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x73, 0x69, 0x67, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x43, 0x52, 0x54, 0x20, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xa4, 0x7c,\n      0x00, 0x14, 0x5f, 0x30, 0x00, 0x10, 0xce, 0x02, 0x00, 0x03, 0xed, 0xb2,\n      0x00, 0x04, 0x13, 0x0a, 0x00, 0x03, 0x5c, 0x67, 0x00, 0x00, 0x00, 0x01,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x0a, 0x3d,\n      0x00, 0x50, 0x00, 0x00, 0x00, 0x57, 0x1e, 0xb8, 0x6d, 0x65, 0x61, 0x73,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x02, 0x8f, 0x00, 0x00, 0x00, 0x02, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x51, 0x00, 0x01, 0x00, 0x00,\n      0x00, 0x01, 0x16, 0xcc, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xa0,\n      0x00, 0x00, 0x38, 0xf5, 0x00, 0x00, 0x03, 0x90, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x97, 0x00, 0x00, 0xb7, 0x87,\n      0x00, 0x00, 0x18, 0xd9, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x24, 0x9f, 0x00, 0x00, 0x0f, 0x84, 0x00, 0x00, 0xb6, 0xc4,\n      0x63, 0x75, 0x72, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n      0x00, 0x00, 0x00, 0x05, 0x00, 0x0a, 0x00, 0x0f, 0x00, 0x14, 0x00, 0x19,\n      0x00, 0x1e, 0x00, 0x23, 0x00, 0x28, 0x00, 0x2d, 0x00, 0x32, 0x00, 0x37,\n      0x00, 0x3b, 0x00, 0x40, 0x00, 0x45, 0x00, 0x4a, 0x00, 0x4f, 0x00, 0x54,\n      0x00, 0x59, 0x00, 0x5e, 0x00, 0x63, 0x00, 0x68, 0x00, 0x6d, 0x00, 0x72,\n      0x00, 0x77, 0x00, 0x7c, 0x00, 0x81, 0x00, 0x86, 0x00, 0x8b, 0x00, 0x90,\n      0x00, 0x95, 0x00, 0x9a, 0x00, 0x9f, 0x00, 0xa4, 0x00, 0xa9, 0x00, 0xae,\n      0x00, 0xb2, 0x00, 0xb7, 0x00, 0xbc, 0x00, 0xc1, 0x00, 0xc6, 0x00, 0xcb,\n      0x00, 0xd0, 0x00, 0xd5, 0x00, 0xdb, 0x00, 0xe0, 0x00, 0xe5, 0x00, 0xeb,\n      0x00, 0xf0, 0x00, 0xf6, 0x00, 0xfb, 0x01, 0x01, 0x01, 0x07, 0x01, 0x0d,\n      0x01, 0x13, 0x01, 0x19, 0x01, 0x1f, 0x01, 0x25, 0x01, 0x2b, 0x01, 0x32,\n      0x01, 0x38, 0x01, 0x3e, 0x01, 0x45, 0x01, 0x4c, 0x01, 0x52, 0x01, 0x59,\n      0x01, 0x60, 0x01, 0x67, 0x01, 0x6e, 0x01, 0x75, 0x01, 0x7c, 0x01, 0x83,\n      0x01, 0x8b, 0x01, 0x92, 0x01, 0x9a, 0x01, 0xa1, 0x01, 0xa9, 0x01, 0xb1,\n      0x01, 0xb9, 0x01, 0xc1, 0x01, 0xc9, 0x01, 0xd1, 0x01, 0xd9, 0x01, 0xe1,\n      0x01, 0xe9, 0x01, 0xf2, 0x01, 0xfa, 0x02, 0x03, 0x02, 0x0c, 0x02, 0x14,\n      0x02, 0x1d, 0x02, 0x26, 0x02, 0x2f, 0x02, 0x38, 0x02, 0x41, 0x02, 0x4b,\n      0x02, 0x54, 0x02, 0x5d, 0x02, 0x67, 0x02, 0x71, 0x02, 0x7a, 0x02, 0x84,\n      0x02, 0x8e, 0x02, 0x98, 0x02, 0xa2, 0x02, 0xac, 0x02, 0xb6, 0x02, 0xc1,\n      0x02, 0xcb, 0x02, 0xd5, 0x02, 0xe0, 0x02, 0xeb, 0x02, 0xf5, 0x03, 0x00,\n      0x03, 0x0b, 0x03, 0x16, 0x03, 0x21, 0x03, 0x2d, 0x03, 0x38, 0x03, 0x43,\n      0x03, 0x4f, 0x03, 0x5a, 0x03, 0x66, 0x03, 0x72, 0x03, 0x7e, 0x03, 0x8a,\n      0x03, 0x96, 0x03, 0xa2, 0x03, 0xae, 0x03, 0xba, 0x03, 0xc7, 0x03, 0xd3,\n      0x03, 0xe0, 0x03, 0xec, 0x03, 0xf9, 0x04, 0x06, 0x04, 0x13, 0x04, 0x20,\n      0x04, 0x2d, 0x04, 0x3b, 0x04, 0x48, 0x04, 0x55, 0x04, 0x63, 0x04, 0x71,\n      0x04, 0x7e, 0x04, 0x8c, 0x04, 0x9a, 0x04, 0xa8, 0x04, 0xb6, 0x04, 0xc4,\n      0x04, 0xd3, 0x04, 0xe1, 0x04, 0xf0, 0x04, 0xfe, 0x05, 0x0d, 0x05, 0x1c,\n      0x05, 0x2b, 0x05, 0x3a, 0x05, 0x49, 0x05, 0x58, 0x05, 0x67, 0x05, 0x77,\n      0x05, 0x86, 0x05, 0x96, 0x05, 0xa6, 0x05, 0xb5, 0x05, 0xc5, 0x05, 0xd5,\n      0x05, 0xe5, 0x05, 0xf6, 0x06, 0x06, 0x06, 0x16, 0x06, 0x27, 0x06, 0x37,\n      0x06, 0x48, 0x06, 0x59, 0x06, 0x6a, 0x06, 0x7b, 0x06, 0x8c, 0x06, 0x9d,\n      0x06, 0xaf, 0x06, 0xc0, 0x06, 0xd1, 0x06, 0xe3, 0x06, 0xf5, 0x07, 0x07,\n      0x07, 0x19, 0x07, 0x2b, 0x07, 0x3d, 0x07, 0x4f, 0x07, 0x61, 0x07, 0x74,\n      0x07, 0x86, 0x07, 0x99, 0x07, 0xac, 0x07, 0xbf, 0x07, 0xd2, 0x07, 0xe5,\n      0x07, 0xf8, 0x08, 0x0b, 0x08, 0x1f, 0x08, 0x32, 0x08, 0x46, 0x08, 0x5a,\n      0x08, 0x6e, 0x08, 0x82, 0x08, 0x96, 0x08, 0xaa, 0x08, 0xbe, 0x08, 0xd2,\n      0x08, 0xe7, 0x08, 0xfb, 0x09, 0x10, 0x09, 0x25, 0x09, 0x3a, 0x09, 0x4f,\n      0x09, 0x64, 0x09, 0x79, 0x09, 0x8f, 0x09, 0xa4, 0x09, 0xba, 0x09, 0xcf,\n      0x09, 0xe5, 0x09, 0xfb, 0x0a, 0x11, 0x0a, 0x27, 0x0a, 0x3d, 0x0a, 0x54,\n      0x0a, 0x6a, 0x0a, 0x81, 0x0a, 0x98, 0x0a, 0xae, 0x0a, 0xc5, 0x0a, 0xdc,\n      0x0a, 0xf3, 0x0b, 0x0b, 0x0b, 0x22, 0x0b, 0x39, 0x0b, 0x51, 0x0b, 0x69,\n      0x0b, 0x80, 0x0b, 0x98, 0x0b, 0xb0, 0x0b, 0xc8, 0x0b, 0xe1, 0x0b, 0xf9,\n      0x0c, 0x12, 0x0c, 0x2a, 0x0c, 0x43, 0x0c, 0x5c, 0x0c, 0x75, 0x0c, 0x8e,\n      0x0c, 0xa7, 0x0c, 0xc0, 0x0c, 0xd9, 0x0c, 0xf3, 0x0d, 0x0d, 0x0d, 0x26,\n      0x0d, 0x40, 0x0d, 0x5a, 0x0d, 0x74, 0x0d, 0x8e, 0x0d, 0xa9, 0x0d, 0xc3,\n      0x0d, 0xde, 0x0d, 0xf8, 0x0e, 0x13, 0x0e, 0x2e, 0x0e, 0x49, 0x0e, 0x64,\n      0x0e, 0x7f, 0x0e, 0x9b, 0x0e, 0xb6, 0x0e, 0xd2, 0x0e, 0xee, 0x0f, 0x09,\n      0x0f, 0x25, 0x0f, 0x41, 0x0f, 0x5e, 0x0f, 0x7a, 0x0f, 0x96, 0x0f, 0xb3,\n      0x0f, 0xcf, 0x0f, 0xec, 0x10, 0x09, 0x10, 0x26, 0x10, 0x43, 0x10, 0x61,\n      0x10, 0x7e, 0x10, 0x9b, 0x10, 0xb9, 0x10, 0xd7, 0x10, 0xf5, 0x11, 0x13,\n      0x11, 0x31, 0x11, 0x4f, 0x11, 0x6d, 0x11, 0x8c, 0x11, 0xaa, 0x11, 0xc9,\n      0x11, 0xe8, 0x12, 0x07, 0x12, 0x26, 0x12, 0x45, 0x12, 0x64, 0x12, 0x84,\n      0x12, 0xa3, 0x12, 0xc3, 0x12, 0xe3, 0x13, 0x03, 0x13, 0x23, 0x13, 0x43,\n      0x13, 0x63, 0x13, 0x83, 0x13, 0xa4, 0x13, 0xc5, 0x13, 0xe5, 0x14, 0x06,\n      0x14, 0x27, 0x14, 0x49, 0x14, 0x6a, 0x14, 0x8b, 0x14, 0xad, 0x14, 0xce,\n      0x14, 0xf0, 0x15, 0x12, 0x15, 0x34, 0x15, 0x56, 0x15, 0x78, 0x15, 0x9b,\n      0x15, 0xbd, 0x15, 0xe0, 0x16, 0x03, 0x16, 0x26, 0x16, 0x49, 0x16, 0x6c,\n      0x16, 0x8f, 0x16, 0xb2, 0x16, 0xd6, 0x16, 0xfa, 0x17, 0x1d, 0x17, 0x41,\n      0x17, 0x65, 0x17, 0x89, 0x17, 0xae, 0x17, 0xd2, 0x17, 0xf7, 0x18, 0x1b,\n      0x18, 0x40, 0x18, 0x65, 0x18, 0x8a, 0x18, 0xaf, 0x18, 0xd5, 0x18, 0xfa,\n      0x19, 0x20, 0x19, 0x45, 0x19, 0x6b, 0x19, 0x91, 0x19, 0xb7, 0x19, 0xdd,\n      0x1a, 0x04, 0x1a, 0x2a, 0x1a, 0x51, 0x1a, 0x77, 0x1a, 0x9e, 0x1a, 0xc5,\n      0x1a, 0xec, 0x1b, 0x14, 0x1b, 0x3b, 0x1b, 0x63, 0x1b, 0x8a, 0x1b, 0xb2,\n      0x1b, 0xda, 0x1c, 0x02, 0x1c, 0x2a, 0x1c, 0x52, 0x1c, 0x7b, 0x1c, 0xa3,\n      0x1c, 0xcc, 0x1c, 0xf5, 0x1d, 0x1e, 0x1d, 0x47, 0x1d, 0x70, 0x1d, 0x99,\n      0x1d, 0xc3, 0x1d, 0xec, 0x1e, 0x16, 0x1e, 0x40, 0x1e, 0x6a, 0x1e, 0x94,\n      0x1e, 0xbe, 0x1e, 0xe9, 0x1f, 0x13, 0x1f, 0x3e, 0x1f, 0x69, 0x1f, 0x94,\n      0x1f, 0xbf, 0x1f, 0xea, 0x20, 0x15, 0x20, 0x41, 0x20, 0x6c, 0x20, 0x98,\n      0x20, 0xc4, 0x20, 0xf0, 0x21, 0x1c, 0x21, 0x48, 0x21, 0x75, 0x21, 0xa1,\n      0x21, 0xce, 0x21, 0xfb, 0x22, 0x27, 0x22, 0x55, 0x22, 0x82, 0x22, 0xaf,\n      0x22, 0xdd, 0x23, 0x0a, 0x23, 0x38, 0x23, 0x66, 0x23, 0x94, 0x23, 0xc2,\n      0x23, 0xf0, 0x24, 0x1f, 0x24, 0x4d, 0x24, 0x7c, 0x24, 0xab, 0x24, 0xda,\n      0x25, 0x09, 0x25, 0x38, 0x25, 0x68, 0x25, 0x97, 0x25, 0xc7, 0x25, 0xf7,\n      0x26, 0x27, 0x26, 0x57, 0x26, 0x87, 0x26, 0xb7, 0x26, 0xe8, 0x27, 0x18,\n      0x27, 0x49, 0x27, 0x7a, 0x27, 0xab, 0x27, 0xdc, 0x28, 0x0d, 0x28, 0x3f,\n      0x28, 0x71, 0x28, 0xa2, 0x28, 0xd4, 0x29, 0x06, 0x29, 0x38, 0x29, 0x6b,\n      0x29, 0x9d, 0x29, 0xd0, 0x2a, 0x02, 0x2a, 0x35, 0x2a, 0x68, 0x2a, 0x9b,\n      0x2a, 0xcf, 0x2b, 0x02, 0x2b, 0x36, 0x2b, 0x69, 0x2b, 0x9d, 0x2b, 0xd1,\n      0x2c, 0x05, 0x2c, 0x39, 0x2c, 0x6e, 0x2c, 0xa2, 0x2c, 0xd7, 0x2d, 0x0c,\n      0x2d, 0x41, 0x2d, 0x76, 0x2d, 0xab, 0x2d, 0xe1, 0x2e, 0x16, 0x2e, 0x4c,\n      0x2e, 0x82, 0x2e, 0xb7, 0x2e, 0xee, 0x2f, 0x24, 0x2f, 0x5a, 0x2f, 0x91,\n      0x2f, 0xc7, 0x2f, 0xfe, 0x30, 0x35, 0x30, 0x6c, 0x30, 0xa4, 0x30, 0xdb,\n      0x31, 0x12, 0x31, 0x4a, 0x31, 0x82, 0x31, 0xba, 0x31, 0xf2, 0x32, 0x2a,\n      0x32, 0x63, 0x32, 0x9b, 0x32, 0xd4, 0x33, 0x0d, 0x33, 0x46, 0x33, 0x7f,\n      0x33, 0xb8, 0x33, 0xf1, 0x34, 0x2b, 0x34, 0x65, 0x34, 0x9e, 0x34, 0xd8,\n      0x35, 0x13, 0x35, 0x4d, 0x35, 0x87, 0x35, 0xc2, 0x35, 0xfd, 0x36, 0x37,\n      0x36, 0x72, 0x36, 0xae, 0x36, 0xe9, 0x37, 0x24, 0x37, 0x60, 0x37, 0x9c,\n      0x37, 0xd7, 0x38, 0x14, 0x38, 0x50, 0x38, 0x8c, 0x38, 0xc8, 0x39, 0x05,\n      0x39, 0x42, 0x39, 0x7f, 0x39, 0xbc, 0x39, 0xf9, 0x3a, 0x36, 0x3a, 0x74,\n      0x3a, 0xb2, 0x3a, 0xef, 0x3b, 0x2d, 0x3b, 0x6b, 0x3b, 0xaa, 0x3b, 0xe8,\n      0x3c, 0x27, 0x3c, 0x65, 0x3c, 0xa4, 0x3c, 0xe3, 0x3d, 0x22, 0x3d, 0x61,\n      0x3d, 0xa1, 0x3d, 0xe0, 0x3e, 0x20, 0x3e, 0x60, 0x3e, 0xa0, 0x3e, 0xe0,\n      0x3f, 0x21, 0x3f, 0x61, 0x3f, 0xa2, 0x3f, 0xe2, 0x40, 0x23, 0x40, 0x64,\n      0x40, 0xa6, 0x40, 0xe7, 0x41, 0x29, 0x41, 0x6a, 0x41, 0xac, 0x41, 0xee,\n      0x42, 0x30, 0x42, 0x72, 0x42, 0xb5, 0x42, 0xf7, 0x43, 0x3a, 0x43, 0x7d,\n      0x43, 0xc0, 0x44, 0x03, 0x44, 0x47, 0x44, 0x8a, 0x44, 0xce, 0x45, 0x12,\n      0x45, 0x55, 0x45, 0x9a, 0x45, 0xde, 0x46, 0x22, 0x46, 0x67, 0x46, 0xab,\n      0x46, 0xf0, 0x47, 0x35, 0x47, 0x7b, 0x47, 0xc0, 0x48, 0x05, 0x48, 0x4b,\n      0x48, 0x91, 0x48, 0xd7, 0x49, 0x1d, 0x49, 0x63, 0x49, 0xa9, 0x49, 0xf0,\n      0x4a, 0x37, 0x4a, 0x7d, 0x4a, 0xc4, 0x4b, 0x0c, 0x4b, 0x53, 0x4b, 0x9a,\n      0x4b, 0xe2, 0x4c, 0x2a, 0x4c, 0x72, 0x4c, 0xba, 0x4d, 0x02, 0x4d, 0x4a,\n      0x4d, 0x93, 0x4d, 0xdc, 0x4e, 0x25, 0x4e, 0x6e, 0x4e, 0xb7, 0x4f, 0x00,\n      0x4f, 0x49, 0x4f, 0x93, 0x4f, 0xdd, 0x50, 0x27, 0x50, 0x71, 0x50, 0xbb,\n      0x51, 0x06, 0x51, 0x50, 0x51, 0x9b, 0x51, 0xe6, 0x52, 0x31, 0x52, 0x7c,\n      0x52, 0xc7, 0x53, 0x13, 0x53, 0x5f, 0x53, 0xaa, 0x53, 0xf6, 0x54, 0x42,\n      0x54, 0x8f, 0x54, 0xdb, 0x55, 0x28, 0x55, 0x75, 0x55, 0xc2, 0x56, 0x0f,\n      0x56, 0x5c, 0x56, 0xa9, 0x56, 0xf7, 0x57, 0x44, 0x57, 0x92, 0x57, 0xe0,\n      0x58, 0x2f, 0x58, 0x7d, 0x58, 0xcb, 0x59, 0x1a, 0x59, 0x69, 0x59, 0xb8,\n      0x5a, 0x07, 0x5a, 0x56, 0x5a, 0xa6, 0x5a, 0xf5, 0x5b, 0x45, 0x5b, 0x95,\n      0x5b, 0xe5, 0x5c, 0x35, 0x5c, 0x86, 0x5c, 0xd6, 0x5d, 0x27, 0x5d, 0x78,\n      0x5d, 0xc9, 0x5e, 0x1a, 0x5e, 0x6c, 0x5e, 0xbd, 0x5f, 0x0f, 0x5f, 0x61,\n      0x5f, 0xb3, 0x60, 0x05, 0x60, 0x57, 0x60, 0xaa, 0x60, 0xfc, 0x61, 0x4f,\n      0x61, 0xa2, 0x61, 0xf5, 0x62, 0x49, 0x62, 0x9c, 0x62, 0xf0, 0x63, 0x43,\n      0x63, 0x97, 0x63, 0xeb, 0x64, 0x40, 0x64, 0x94, 0x64, 0xe9, 0x65, 0x3d,\n      0x65, 0x92, 0x65, 0xe7, 0x66, 0x3d, 0x66, 0x92, 0x66, 0xe8, 0x67, 0x3d,\n      0x67, 0x93, 0x67, 0xe9, 0x68, 0x3f, 0x68, 0x96, 0x68, 0xec, 0x69, 0x43,\n      0x69, 0x9a, 0x69, 0xf1, 0x6a, 0x48, 0x6a, 0x9f, 0x6a, 0xf7, 0x6b, 0x4f,\n      0x6b, 0xa7, 0x6b, 0xff, 0x6c, 0x57, 0x6c, 0xaf, 0x6d, 0x08, 0x6d, 0x60,\n      0x6d, 0xb9, 0x6e, 0x12, 0x6e, 0x6b, 0x6e, 0xc4, 0x6f, 0x1e, 0x6f, 0x78,\n      0x6f, 0xd1, 0x70, 0x2b, 0x70, 0x86, 0x70, 0xe0, 0x71, 0x3a, 0x71, 0x95,\n      0x71, 0xf0, 0x72, 0x4b, 0x72, 0xa6, 0x73, 0x01, 0x73, 0x5d, 0x73, 0xb8,\n      0x74, 0x14, 0x74, 0x70, 0x74, 0xcc, 0x75, 0x28, 0x75, 0x85, 0x75, 0xe1,\n      0x76, 0x3e, 0x76, 0x9b, 0x76, 0xf8, 0x77, 0x56, 0x77, 0xb3, 0x78, 0x11,\n      0x78, 0x6e, 0x78, 0xcc, 0x79, 0x2a, 0x79, 0x89, 0x79, 0xe7, 0x7a, 0x46,\n      0x7a, 0xa5, 0x7b, 0x04, 0x7b, 0x63, 0x7b, 0xc2, 0x7c, 0x21, 0x7c, 0x81,\n      0x7c, 0xe1, 0x7d, 0x41, 0x7d, 0xa1, 0x7e, 0x01, 0x7e, 0x62, 0x7e, 0xc2,\n      0x7f, 0x23, 0x7f, 0x84, 0x7f, 0xe5, 0x80, 0x47, 0x80, 0xa8, 0x81, 0x0a,\n      0x81, 0x6b, 0x81, 0xcd, 0x82, 0x30, 0x82, 0x92, 0x82, 0xf4, 0x83, 0x57,\n      0x83, 0xba, 0x84, 0x1d, 0x84, 0x80, 0x84, 0xe3, 0x85, 0x47, 0x85, 0xab,\n      0x86, 0x0e, 0x86, 0x72, 0x86, 0xd7, 0x87, 0x3b, 0x87, 0x9f, 0x88, 0x04,\n      0x88, 0x69, 0x88, 0xce, 0x89, 0x33, 0x89, 0x99, 0x89, 0xfe, 0x8a, 0x64,\n      0x8a, 0xca, 0x8b, 0x30, 0x8b, 0x96, 0x8b, 0xfc, 0x8c, 0x63, 0x8c, 0xca,\n      0x8d, 0x31, 0x8d, 0x98, 0x8d, 0xff, 0x8e, 0x66, 0x8e, 0xce, 0x8f, 0x36,\n      0x8f, 0x9e, 0x90, 0x06, 0x90, 0x6e, 0x90, 0xd6, 0x91, 0x3f, 0x91, 0xa8,\n      0x92, 0x11, 0x92, 0x7a, 0x92, 0xe3, 0x93, 0x4d, 0x93, 0xb6, 0x94, 0x20,\n      0x94, 0x8a, 0x94, 0xf4, 0x95, 0x5f, 0x95, 0xc9, 0x96, 0x34, 0x96, 0x9f,\n      0x97, 0x0a, 0x97, 0x75, 0x97, 0xe0, 0x98, 0x4c, 0x98, 0xb8, 0x99, 0x24,\n      0x99, 0x90, 0x99, 0xfc, 0x9a, 0x68, 0x9a, 0xd5, 0x9b, 0x42, 0x9b, 0xaf,\n      0x9c, 0x1c, 0x9c, 0x89, 0x9c, 0xf7, 0x9d, 0x64, 0x9d, 0xd2, 0x9e, 0x40,\n      0x9e, 0xae, 0x9f, 0x1d, 0x9f, 0x8b, 0x9f, 0xfa, 0xa0, 0x69, 0xa0, 0xd8,\n      0xa1, 0x47, 0xa1, 0xb6, 0xa2, 0x26, 0xa2, 0x96, 0xa3, 0x06, 0xa3, 0x76,\n      0xa3, 0xe6, 0xa4, 0x56, 0xa4, 0xc7, 0xa5, 0x38, 0xa5, 0xa9, 0xa6, 0x1a,\n      0xa6, 0x8b, 0xa6, 0xfd, 0xa7, 0x6e, 0xa7, 0xe0, 0xa8, 0x52, 0xa8, 0xc4,\n      0xa9, 0x37, 0xa9, 0xa9, 0xaa, 0x1c, 0xaa, 0x8f, 0xab, 0x02, 0xab, 0x75,\n      0xab, 0xe9, 0xac, 0x5c, 0xac, 0xd0, 0xad, 0x44, 0xad, 0xb8, 0xae, 0x2d,\n      0xae, 0xa1, 0xaf, 0x16, 0xaf, 0x8b, 0xb0, 0x00, 0xb0, 0x75, 0xb0, 0xea,\n      0xb1, 0x60, 0xb1, 0xd6, 0xb2, 0x4b, 0xb2, 0xc2, 0xb3, 0x38, 0xb3, 0xae,\n      0xb4, 0x25, 0xb4, 0x9c, 0xb5, 0x13, 0xb5, 0x8a, 0xb6, 0x01, 0xb6, 0x79,\n      0xb6, 0xf0, 0xb7, 0x68, 0xb7, 0xe0, 0xb8, 0x59, 0xb8, 0xd1, 0xb9, 0x4a,\n      0xb9, 0xc2, 0xba, 0x3b, 0xba, 0xb5, 0xbb, 0x2e, 0xbb, 0xa7, 0xbc, 0x21,\n      0xbc, 0x9b, 0xbd, 0x15, 0xbd, 0x8f, 0xbe, 0x0a, 0xbe, 0x84, 0xbe, 0xff,\n      0xbf, 0x7a, 0xbf, 0xf5, 0xc0, 0x70, 0xc0, 0xec, 0xc1, 0x67, 0xc1, 0xe3,\n      0xc2, 0x5f, 0xc2, 0xdb, 0xc3, 0x58, 0xc3, 0xd4, 0xc4, 0x51, 0xc4, 0xce,\n      0xc5, 0x4b, 0xc5, 0xc8, 0xc6, 0x46, 0xc6, 0xc3, 0xc7, 0x41, 0xc7, 0xbf,\n      0xc8, 0x3d, 0xc8, 0xbc, 0xc9, 0x3a, 0xc9, 0xb9, 0xca, 0x38, 0xca, 0xb7,\n      0xcb, 0x36, 0xcb, 0xb6, 0xcc, 0x35, 0xcc, 0xb5, 0xcd, 0x35, 0xcd, 0xb5,\n      0xce, 0x36, 0xce, 0xb6, 0xcf, 0x37, 0xcf, 0xb8, 0xd0, 0x39, 0xd0, 0xba,\n      0xd1, 0x3c, 0xd1, 0xbe, 0xd2, 0x3f, 0xd2, 0xc1, 0xd3, 0x44, 0xd3, 0xc6,\n      0xd4, 0x49, 0xd4, 0xcb, 0xd5, 0x4e, 0xd5, 0xd1, 0xd6, 0x55, 0xd6, 0xd8,\n      0xd7, 0x5c, 0xd7, 0xe0, 0xd8, 0x64, 0xd8, 0xe8, 0xd9, 0x6c, 0xd9, 0xf1,\n      0xda, 0x76, 0xda, 0xfb, 0xdb, 0x80, 0xdc, 0x05, 0xdc, 0x8a, 0xdd, 0x10,\n      0xdd, 0x96, 0xde, 0x1c, 0xde, 0xa2, 0xdf, 0x29, 0xdf, 0xaf, 0xe0, 0x36,\n      0xe0, 0xbd, 0xe1, 0x44, 0xe1, 0xcc, 0xe2, 0x53, 0xe2, 0xdb, 0xe3, 0x63,\n      0xe3, 0xeb, 0xe4, 0x73, 0xe4, 0xfc, 0xe5, 0x84, 0xe6, 0x0d, 0xe6, 0x96,\n      0xe7, 0x1f, 0xe7, 0xa9, 0xe8, 0x32, 0xe8, 0xbc, 0xe9, 0x46, 0xe9, 0xd0,\n      0xea, 0x5b, 0xea, 0xe5, 0xeb, 0x70, 0xeb, 0xfb, 0xec, 0x86, 0xed, 0x11,\n      0xed, 0x9c, 0xee, 0x28, 0xee, 0xb4, 0xef, 0x40, 0xef, 0xcc, 0xf0, 0x58,\n      0xf0, 0xe5, 0xf1, 0x72, 0xf1, 0xff, 0xf2, 0x8c, 0xf3, 0x19, 0xf3, 0xa7,\n      0xf4, 0x34, 0xf4, 0xc2, 0xf5, 0x50, 0xf5, 0xde, 0xf6, 0x6d, 0xf6, 0xfb,\n      0xf7, 0x8a, 0xf8, 0x19, 0xf8, 0xa8, 0xf9, 0x38, 0xf9, 0xc7, 0xfa, 0x57,\n      0xfa, 0xe7, 0xfb, 0x77, 0xfc, 0x07, 0xfc, 0x98, 0xfd, 0x29, 0xfd, 0xba,\n      0xfe, 0x4b, 0xfe, 0xdc, 0xff, 0x6d, 0xff, 0xff\n    };\n\n  StringInfo\n    *profile;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (GetImageProfile(image,\"icc\") != (const StringInfo *) NULL)\n    return(MagickFalse);\n  profile=AcquireStringInfo(sizeof(sRGBProfile));\n  SetStringInfoDatum(profile,sRGBProfile);\n  status=SetImageProfile(image,\"icc\",profile,exception);\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\nMagickExport MagickBooleanType ProfileImage(Image *image,const char *name,\n  const void *datum,const size_t length,ExceptionInfo *exception)\n{\n#define ProfileImageTag  \"Profile/Image\"\n#define ThrowProfileException(severity,tag,context) \\\n{ \\\n  if (source_profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(source_profile); \\\n  if (target_profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(target_profile); \\\n  ThrowBinaryException(severity,tag,context); \\\n}\n\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(name != (const char *) NULL);\n  if ((datum == (const void *) NULL) || (length == 0))\n    {\n      char\n        *next;\n\n      /*\n        Delete image profile(s).\n      */\n      ResetImageProfileIterator(image);\n      for (next=GetNextImageProfile(image); next != (const char *) NULL; )\n      {\n        if (IsOptionMember(next,name) != MagickFalse)\n          {\n            (void) DeleteImageProfile(image,next);\n            ResetImageProfileIterator(image);\n          }\n        next=GetNextImageProfile(image);\n      }\n      return(MagickTrue);\n    }\n  /*\n    Add a ICC, IPTC, or generic profile to the image.\n  */\n  status=MagickTrue;\n  profile=AcquireStringInfo((size_t) length);\n  SetStringInfoDatum(profile,(unsigned char *) datum);\n  if ((LocaleCompare(name,\"icc\") != 0) && (LocaleCompare(name,\"icm\") != 0))\n    status=SetImageProfile(image,name,profile,exception);\n  else\n    {\n      const StringInfo\n        *icc_profile;\n\n      icc_profile=GetImageProfile(image,\"icc\");\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          const char\n            *value;\n\n          value=GetImageProperty(image,\"exif:ColorSpace\",exception);\n          (void) value;\n          if (LocaleCompare(value,\"1\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          value=GetImageProperty(image,\"exif:InteroperabilityIndex\",exception);\n          if (LocaleCompare(value,\"R98.\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          /* Future.\n          value=GetImageProperty(image,\"exif:InteroperabilityIndex\",exception);\n          if (LocaleCompare(value,\"R03.\") != 0)\n            (void) SetAdobeRGB1998ImageProfile(image,exception);\n          */\n          icc_profile=GetImageProfile(image,\"icc\");\n        }\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          profile=DestroyStringInfo(profile);\n          return(MagickTrue);\n        }\n#if !defined(MAGICKCORE_LCMS_DELEGATE)\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n        \"'%s' (LCMS)\",image->filename);\n#else\n      {\n        cmsHPROFILE\n          source_profile;\n\n        CMSExceptionInfo\n          cms_exception;\n\n        /*\n          Transform pixel colors as defined by the color profiles.\n        */\n        cmsSetLogErrorHandler(CMSExceptionHandler);\n        cms_exception.image=image;\n        cms_exception.exception=exception;\n        (void) cms_exception;\n        source_profile=cmsOpenProfileFromMemTHR((cmsContext) &cms_exception,\n          GetStringInfoDatum(profile),(cmsUInt32Number)\n          GetStringInfoLength(profile));\n        if (source_profile == (cmsHPROFILE) NULL)\n          ThrowBinaryException(ResourceLimitError,\n            \"ColorspaceColorProfileMismatch\",name);\n        if ((cmsGetDeviceClass(source_profile) != cmsSigLinkClass) &&\n            (icc_profile == (StringInfo *) NULL))\n          status=SetImageProfile(image,name,profile,exception);\n        else\n          {\n            CacheView\n              *image_view;\n\n            ColorspaceType\n              source_colorspace,\n              target_colorspace;\n\n            cmsColorSpaceSignature\n              signature;\n\n            cmsHPROFILE\n              target_profile;\n\n            cmsHTRANSFORM\n              *magick_restrict transform;\n\n            cmsUInt32Number\n              flags,\n              source_type,\n              target_type;\n\n            int\n              intent;\n\n            MagickBooleanType\n              status;\n\n            MagickOffsetType\n              progress;\n\n            size_t\n              source_channels,\n              target_channels;\n\n            ssize_t\n              y;\n\n            unsigned short\n              **magick_restrict source_pixels,\n              **magick_restrict target_pixels;\n\n            target_profile=(cmsHPROFILE) NULL;\n            if (icc_profile != (StringInfo *) NULL)\n              {\n                target_profile=source_profile;\n                source_profile=cmsOpenProfileFromMemTHR((cmsContext)\n                  &cms_exception,GetStringInfoDatum(icc_profile),\n                  (cmsUInt32Number) GetStringInfoLength(icc_profile));\n                if (source_profile == (cmsHPROFILE) NULL)\n                  ThrowProfileException(ResourceLimitError,\n                    \"ColorspaceColorProfileMismatch\",name);\n              }\n            switch (cmsGetColorSpace(source_profile))\n            {\n              case cmsSigCmykData:\n              {\n                source_colorspace=CMYKColorspace;\n                source_type=(cmsUInt32Number) TYPE_CMYK_16;\n                source_channels=4;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                source_colorspace=GRAYColorspace;\n                source_type=(cmsUInt32Number) TYPE_GRAY_16;\n                source_channels=1;\n                break;\n              }\n              case cmsSigLabData:\n              {\n                source_colorspace=LabColorspace;\n                source_type=(cmsUInt32Number) TYPE_Lab_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigLuvData:\n              {\n                source_colorspace=YUVColorspace;\n                source_type=(cmsUInt32Number) TYPE_YUV_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                source_colorspace=sRGBColorspace;\n                source_type=(cmsUInt32Number) TYPE_RGB_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                source_colorspace=XYZColorspace;\n                source_type=(cmsUInt32Number) TYPE_XYZ_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigYCbCrData:\n              {\n                source_colorspace=YCbCrColorspace;\n                source_type=(cmsUInt32Number) TYPE_YCbCr_16;\n                source_channels=3;\n                break;\n              }\n              default:\n              {\n                source_colorspace=UndefinedColorspace;\n                source_type=(cmsUInt32Number) TYPE_RGB_16;\n                source_channels=3;\n                break;\n              }\n            }\n            signature=cmsGetPCS(source_profile);\n            if (target_profile != (cmsHPROFILE) NULL)\n              signature=cmsGetColorSpace(target_profile);\n            switch (signature)\n            {\n              case cmsSigCmykData:\n              {\n                target_colorspace=CMYKColorspace;\n                target_type=(cmsUInt32Number) TYPE_CMYK_16;\n                target_channels=4;\n                break;\n              }\n              case cmsSigLabData:\n              {\n                target_colorspace=LabColorspace;\n                target_type=(cmsUInt32Number) TYPE_Lab_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                target_colorspace=GRAYColorspace;\n                target_type=(cmsUInt32Number) TYPE_GRAY_16;\n                target_channels=1;\n                break;\n              }\n              case cmsSigLuvData:\n              {\n                target_colorspace=YUVColorspace;\n                target_type=(cmsUInt32Number) TYPE_YUV_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                target_colorspace=sRGBColorspace;\n                target_type=(cmsUInt32Number) TYPE_RGB_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                target_colorspace=XYZColorspace;\n                target_type=(cmsUInt32Number) TYPE_XYZ_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigYCbCrData:\n              {\n                target_colorspace=YCbCrColorspace;\n                target_type=(cmsUInt32Number) TYPE_YCbCr_16;\n                target_channels=3;\n                break;\n              }\n              default:\n              {\n                target_colorspace=UndefinedColorspace;\n                target_type=(cmsUInt32Number) TYPE_RGB_16;\n                target_channels=3;\n                break;\n              }\n            }\n            if ((source_colorspace == UndefinedColorspace) ||\n                (target_colorspace == UndefinedColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == GRAYColorspace) &&\n                 (SetImageGray(image,exception) == MagickFalse))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == CMYKColorspace) &&\n                 (image->colorspace != CMYKColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == XYZColorspace) &&\n                 (image->colorspace != XYZColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == YCbCrColorspace) &&\n                 (image->colorspace != YCbCrColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace != CMYKColorspace) &&\n                 (source_colorspace != LabColorspace) &&\n                 (source_colorspace != XYZColorspace) &&\n                 (source_colorspace != YCbCrColorspace) &&\n                 (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n            switch (image->rendering_intent)\n            {\n              case AbsoluteIntent: intent=INTENT_ABSOLUTE_COLORIMETRIC; break;\n              case PerceptualIntent: intent=INTENT_PERCEPTUAL; break;\n              case RelativeIntent: intent=INTENT_RELATIVE_COLORIMETRIC; break;\n              case SaturationIntent: intent=INTENT_SATURATION; break;\n              default: intent=INTENT_PERCEPTUAL; break;\n            }\n            flags=cmsFLAGS_HIGHRESPRECALC;\n#if defined(cmsFLAGS_BLACKPOINTCOMPENSATION)\n            if (image->black_point_compensation != MagickFalse)\n              flags|=cmsFLAGS_BLACKPOINTCOMPENSATION;\n#endif\n            transform=AcquireTransformThreadSet(image,source_profile,\n              source_type,target_profile,target_type,intent,flags);\n            if (transform == (cmsHTRANSFORM *) NULL)\n              ThrowProfileException(ImageError,\"UnableToCreateColorTransform\",\n                name);\n            /*\n              Transform image as dictated by the source & target image profiles.\n            */\n            source_pixels=AcquirePixelThreadSet(image->columns,source_channels);\n            target_pixels=AcquirePixelThreadSet(image->columns,target_channels);\n            if ((source_pixels == (unsigned short **) NULL) ||\n                (target_pixels == (unsigned short **) NULL))\n              {\n                transform=DestroyTransformThreadSet(transform);\n                ThrowProfileException(ResourceLimitError,\n                  \"MemoryAllocationFailed\",image->filename);\n              }\n            if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n              {\n                target_pixels=DestroyPixelThreadSet(target_pixels);\n                source_pixels=DestroyPixelThreadSet(source_pixels);\n                transform=DestroyTransformThreadSet(transform);\n                if (source_profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(source_profile);\n                if (target_profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(target_profile);\n                return(MagickFalse);\n              }\n            if (target_colorspace == CMYKColorspace)\n              (void) SetImageColorspace(image,target_colorspace,exception);\n            status=MagickTrue;\n            progress=0;\n            image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel for schedule(static,4) shared(status) \\\n              magick_threads(image,image,image->rows,1)\n#endif\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const int\n                id = GetOpenMPThreadId();\n\n              MagickBooleanType\n                sync;\n\n              register ssize_t\n                x;\n\n              register Quantum\n                *magick_restrict q;\n\n              register unsigned short\n                *p;\n\n              if (status == MagickFalse)\n                continue;\n              q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                {\n                  status=MagickFalse;\n                  continue;\n                }\n              p=source_pixels[id];\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *p++=ScaleQuantumToShort(GetPixelRed(image,q));\n                if (source_channels > 1)\n                  {\n                    *p++=ScaleQuantumToShort(GetPixelGreen(image,q));\n                    *p++=ScaleQuantumToShort(GetPixelBlue(image,q));\n                  }\n                if (source_channels > 3)\n                  *p++=ScaleQuantumToShort(GetPixelBlack(image,q));\n                q+=GetPixelChannels(image);\n              }\n              cmsDoTransform(transform[id],source_pixels[id],target_pixels[id],\n                (unsigned int) image->columns);\n              p=target_pixels[id];\n              q-=GetPixelChannels(image)*image->columns;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (target_channels == 1)\n                  SetPixelGray(image,ScaleShortToQuantum(*p),q);\n                else\n                  SetPixelRed(image,ScaleShortToQuantum(*p),q);\n                p++;\n                if (target_channels > 1)\n                  {\n                    SetPixelGreen(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                    SetPixelBlue(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                  }\n                if (target_channels > 3)\n                  {\n                    SetPixelBlack(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                  }\n                q+=GetPixelChannels(image);\n              }\n              sync=SyncCacheViewAuthenticPixels(image_view,exception);\n              if (sync == MagickFalse)\n                status=MagickFalse;\n              if (image->progress_monitor != (MagickProgressMonitor) NULL)\n                {\n                  MagickBooleanType\n                    proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n                  #pragma omp critical (MagickCore_ProfileImage)\n#endif\n                  proceed=SetImageProgress(image,ProfileImageTag,progress++,\n                    image->rows);\n                  if (proceed == MagickFalse)\n                    status=MagickFalse;\n                }\n            }\n            image_view=DestroyCacheView(image_view);\n            (void) SetImageColorspace(image,target_colorspace,exception);\n            switch (signature)\n            {\n              case cmsSigRgbData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  TrueColorType : TrueColorAlphaType;\n                break;\n              }\n              case cmsSigCmykData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  ColorSeparationType : ColorSeparationAlphaType;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  GrayscaleType : GrayscaleAlphaType;\n                break;\n              }\n              default:\n                break;\n            }\n            target_pixels=DestroyPixelThreadSet(target_pixels);\n            source_pixels=DestroyPixelThreadSet(source_pixels);\n            transform=DestroyTransformThreadSet(transform);\n            if (cmsGetDeviceClass(source_profile) != cmsSigLinkClass)\n              status=SetImageProfile(image,name,profile,exception);\n            if (target_profile != (cmsHPROFILE) NULL)\n              (void) cmsCloseProfile(target_profile);\n          }\n        (void) cmsCloseProfile(source_profile);\n      }\n#endif\n    }\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProfile() removes a named profile from the image and returns its\n%  value.\n%\n%  The format of the RemoveImageProfile method is:\n%\n%      void *RemoveImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport StringInfo *RemoveImageProfile(Image *image,const char *name)\n{\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  profile=(StringInfo *) RemoveNodeFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t P r o f i l e I t e r a t o r                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImageProfileIterator() resets the image profile iterator.  Use it in\n%  conjunction with GetNextImageProfile() to iterate over all the profiles\n%  associated with an image.\n%\n%  The format of the ResetImageProfileIterator method is:\n%\n%      ResetImageProfileIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImageProfileIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProfile() adds a named profile to the image.  If a profile with the\n%  same name already exists, it is replaced.  This method differs from the\n%  ProfileImage() method in that it does not apply CMS color profiles.\n%\n%  The format of the SetImageProfile method is:\n%\n%      MagickBooleanType SetImageProfile(Image *image,const char *name,\n%        const StringInfo *profile)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name, for example icc, exif, and 8bim (8bim is the\n%      Photoshop wrapper for iptc profiles).\n%\n%    o profile: A StringInfo structure that contains the named profile.\n%\n*/\n\nstatic void *DestroyProfile(void *profile)\n{\n  return((void *) DestroyStringInfo((StringInfo *) profile));\n}\n\nstatic inline const unsigned char *ReadResourceByte(const unsigned char *p,\n  unsigned char *quantum)\n{\n  *quantum=(*p++);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceLong(const unsigned char *p,\n  unsigned int *quantum)\n{\n  *quantum=(size_t) (*p++ << 24);\n  *quantum|=(size_t) (*p++ << 16);\n  *quantum|=(size_t) (*p++ << 8);\n  *quantum|=(size_t) (*p++ << 0);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceShort(const unsigned char *p,\n  unsigned short *quantum)\n{\n  *quantum=(unsigned short) (*p++ << 8);\n  *quantum|=(unsigned short) (*p++ << 0);\n  return(p);\n}static inline void WriteResourceLong(unsigned char *p,\n  const unsigned int quantum)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) (quantum >> 24);\n  buffer[1]=(unsigned char) (quantum >> 16);\n  buffer[2]=(unsigned char) (quantum >> 8);\n  buffer[3]=(unsigned char) quantum;\n  (void) CopyMagickMemory(p,buffer,4);\n}\n\nstatic void WriteTo8BimProfile(Image *image,const char *name,\n  const StringInfo *profile)\n{\n  const unsigned char\n    *datum,\n    *q;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile_8bim;\n\n  ssize_t\n    count;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id,\n    profile_id;\n\n  if (LocaleCompare(name,\"icc\") == 0)\n    profile_id=0x040f;\n  else\n    if (LocaleCompare(name,\"iptc\") == 0)\n      profile_id=0x0404;\n    else\n      if (LocaleCompare(name,\"xmp\") == 0)\n        profile_id=0x0424;\n      else\n        return;\n  profile_8bim=(StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,\"8bim\");\n  if (profile_8bim == (StringInfo *) NULL)\n    return;\n  datum=GetStringInfoDatum(profile_8bim);\n  length=GetStringInfoLength(profile_8bim);\n  for (p=datum; p < (datum+length-16); )\n  {\n    q=p;\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((count & 0x01) != 0)\n      count++;\n    if ((p > (datum+length-count)) || (count > (ssize_t) length))\n      break;\n    if (id != profile_id)\n      p+=count;\n    else\n      {\n        size_t\n          extent,\n          offset;\n\n        ssize_t\n          extract_count;\n\n        StringInfo\n          *extract_profile;\n\n        extract_count=0;\n        extent=(datum+length)-(p+count);\n        if (profile == (StringInfo *) NULL)\n          {\n            offset=(q-datum);\n            extract_profile=AcquireStringInfo(offset+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset);\n          }\n        else\n          {\n            offset=(p-datum);\n            extract_count=profile->length;\n            if ((extract_count & 0x01) != 0)\n              extract_count++;\n            extract_profile=AcquireStringInfo(offset+extract_count+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset-4);\n            WriteResourceLong(extract_profile->datum+offset-4,\n              (unsigned int)profile->length);\n            (void) CopyMagickMemory(extract_profile->datum+offset,\n              profile->datum,profile->length);\n          }\n        (void) CopyMagickMemory(extract_profile->datum+offset+extract_count,\n          p+count,extent);\n        (void) AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n          ConstantString(\"8bim\"),CloneStringInfo(extract_profile));\n        extract_profile=DestroyStringInfo(extract_profile);\n        break;\n      }\n  }\n}\n\nstatic void GetProfilesFromResourceBlock(Image *image,\n  const StringInfo *resource_block,ExceptionInfo *exception)\n{\n  const unsigned char\n    *datum;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    length_byte;\n\n   unsigned int\n     value;\n\n  unsigned short\n    id;\n\n  datum=GetStringInfoDatum(resource_block);\n  length=GetStringInfoLength(resource_block);\n  for (p=datum; p < (datum+length-16); )\n  {\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((p > (datum+length-count)) || (count > (ssize_t) length) ||\n        (count < 0))\n      break;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        unsigned int\n          resolution;\n\n        unsigned short\n          units;\n\n        /*\n          Resolution.\n        */\n        p=ReadResourceLong(p,&resolution);\n        image->resolution.x=((double) resolution)/65536.0;\n        p=ReadResourceShort(p,&units)+2;\n        p=ReadResourceLong(p,&resolution)+4;\n        image->resolution.y=((double) resolution)/65536.0;\n        /*\n          Values are always stored as pixels per inch.\n        */\n        if ((ResolutionType) units != PixelsPerCentimeterResolution)\n          image->units=PixelsPerInchResolution;\n        else\n          {\n            image->units=PixelsPerCentimeterResolution;\n            image->resolution.x/=2.54;\n            image->resolution.y/=2.54;\n          }\n        break;\n      }\n      case 0x0404:\n      {\n        /*\n          IPTC Profile\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"iptc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x040c:\n      {\n        /*\n          Thumbnail.\n        */\n        p+=count;\n        break;\n      }\n      case 0x040f:\n      {\n        /*\n          ICC Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"icc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0422:\n      {\n        /*\n          EXIF Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"exif\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0424:\n      {\n        /*\n          XMP Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"xmp\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      default:\n      {\n        p+=count;\n        break;\n      }\n    }\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic MagickBooleanType SetImageProfileInternal(Image *image,const char *name,\n  const StringInfo *profile,const MagickBooleanType recursive,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    property[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MagickPathExtent);\n  LocaleLower(key);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),CloneStringInfo(profile));\n  if (status != MagickFalse)\n    {\n      if (LocaleCompare(name,\"8bim\") == 0)\n        GetProfilesFromResourceBlock(image,profile,exception);\n      else if (recursive == MagickFalse)\n        WriteTo8BimProfile(image,name,profile);\n    }\n  /*\n    Inject profile into image properties.\n  */\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s:*\",name);\n  (void) GetImageProperty(image,property,exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  return(SetImageProfileInternal(image,name,profile,MagickFalse,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c I m a g e P r o f i l e s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImageProfiles() synchronizes image properties with the image profiles.\n%  Currently we only support updating the EXIF resolution and orientation.\n%\n%  The format of the SyncImageProfiles method is:\n%\n%      MagickBooleanType SyncImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nstatic inline int ReadProfileByte(unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline unsigned short ReadProfileShort(const EndianType endian,\n  unsigned char *buffer)\n{\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) ((buffer[1] << 8) | buffer[0]);\n      return((unsigned short) (value & 0xffff));\n    }\n  value=(unsigned short) ((((unsigned char *) buffer)[0] << 8) |\n    ((unsigned char *) buffer)[1]);\n  return((unsigned short) (value & 0xffff));\n}\n\nstatic inline unsigned int ReadProfileLong(const EndianType endian,\n  unsigned char *buffer)\n{\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) ((buffer[3] << 24) | (buffer[2] << 16) |\n        (buffer[1] << 8 ) | (buffer[0]));\n      return((unsigned int) (value & 0xffffffff));\n    }\n  value=(unsigned int) ((buffer[0] << 24) | (buffer[1] << 16) |\n    (buffer[2] << 8) | buffer[3]);\n  return((unsigned int) (value & 0xffffffff));\n}\n\nstatic inline unsigned int ReadProfileMSBLong(unsigned char **p,size_t *length)\n{\n  unsigned int\n    value;\n\n  if (*length < 4)\n    return(0);\n  value=ReadProfileLong(MSBEndian,*p);\n  (*length)-=4;\n  *p+=4;\n  return(value);\n}\n\nstatic inline unsigned short ReadProfileMSBShort(unsigned char **p,\n  size_t *length)\n{\n  unsigned short\n    value;\n\n  if (*length < 2)\n    return(0);\n  value=ReadProfileShort(MSBEndian,*p);\n  (*length)-=2;\n  *p+=2;\n  return(value);\n}\n\nstatic inline void WriteProfileLong(const EndianType endian,\n  const size_t value,unsigned char *p)\n{\n  unsigned char\n    buffer[4];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      buffer[2]=(unsigned char) (value >> 16);\n      buffer[3]=(unsigned char) (value >> 24);\n      (void) CopyMagickMemory(p,buffer,4);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  (void) CopyMagickMemory(p,buffer,4);\n}\n\nstatic void WriteProfileShort(const EndianType endian,\n  const unsigned short value,unsigned char *p)\n{\n  unsigned char\n    buffer[2];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      (void) CopyMagickMemory(p,buffer,2);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 8);\n  buffer[1]=(unsigned char) value;\n  (void) CopyMagickMemory(p,buffer,2);\n}\n\nstatic MagickBooleanType Sync8BimProfile(Image *image,StringInfo *profile)\n{\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *p;\n\n  unsigned short\n    id;\n\n  length=GetStringInfoLength(profile);\n  p=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadProfileByte(&p,&length) != 0x38)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x42)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x49)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x4D)\n      continue;\n    if (length < 7)\n      return(MagickFalse);\n    id=ReadProfileMSBShort(&p,&length);\n    count=(ssize_t) ReadProfileByte(&p,&length);\n    if ((count > (ssize_t) length) || (count < 0))\n      return(MagickFalse);\n    p+=count;\n    if ((*p & 0x01) == 0)\n      (void) ReadProfileByte(&p,&length);\n    count=(ssize_t) ReadProfileMSBLong(&p,&length);\n    if ((count > (ssize_t) length) || (count < 0))\n      return(MagickFalse);\n    if ((id == 0x3ED) && (count == 16))\n      {\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.x*2.54*\n            65536.0),p);\n        else\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.x*\n            65536.0),p);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+4);\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.y*2.54*\n            65536.0),p+8);\n        else\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.y*\n            65536.0),p+8);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+12);\n      }\n    p+=count;\n    length-=count;\n  }\n  return(MagickTrue);\n}\n\nMagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ((int) ReadProfileLong(endian,exif+4));\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format-1) >= EXIF_NUM_FORMATS)\n        break;\n      components=(ssize_t) ((int) ReadProfileLong(endian,q+4));\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          ssize_t\n            offset;\n\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t) ((int) ReadProfileLong(endian,q+8));\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          ssize_t\n            offset;\n\n          offset=(ssize_t) ((int) ReadProfileLong(endian,p));\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t) ((int) ReadProfileLong(endian,directory+2+(12*\n                number_entries)));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}\n\nMagickPrivate MagickBooleanType SyncImageProfiles(Image *image)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  status=MagickTrue;\n  profile=(StringInfo *) GetImageProfile(image,\"8BIM\");\n  if (profile != (StringInfo *) NULL)\n    if (Sync8BimProfile(image,profile) == MagickFalse)\n      status=MagickFalse;\n  profile=(StringInfo *) GetImageProfile(image,\"EXIF\");\n  if (profile != (StringInfo *) NULL)\n    if (SyncExifProfile(image,profile) == MagickFalse)\n      status=MagickFalse;\n  return(status);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               PPPP   RRRR    OOO   FFFFF  IIIII  L      EEEEE               %\n%               P   P  R   R  O   O  F        I    L      E                   %\n%               PPPP   RRRR   O   O  FFF      I    L      EEE                 %\n%               P      R R    O   O  F        I    L      E                   %\n%               P      R  R    OOO   F      IIIII  LLLLL  EEEEE               %\n%                                                                             %\n%                                                                             %\n%                       MagickCore Image Profile Methods                      %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/configure.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/linked-list.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/option-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/profile-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/splay-tree.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/token.h\"\n#include \"MagickCore/utility.h\"\n#if defined(MAGICKCORE_LCMS_DELEGATE)\n#if defined(MAGICKCORE_HAVE_LCMS_LCMS2_H)\n#include <wchar.h>\n#include <lcms/lcms2.h>\n#else\n#include <wchar.h>\n#include \"lcms2.h\"\n#endif\n#endif\n\f\n/*\n  Forward declarations\n*/\nstatic MagickBooleanType\n  SetImageProfileInternal(Image *,const char *,const StringInfo *,\n    const MagickBooleanType,ExceptionInfo *);\n\nstatic void\n  WriteTo8BimProfile(Image *,const char*,const StringInfo *);\n\f\n/*\n  Typedef declarations\n*/\nstruct _ProfileInfo\n{\n  char\n    *name;\n\n  size_t\n    length;\n\n  unsigned char\n    *info;\n\n  size_t\n    signature;\n};\n\ntypedef struct _CMSExceptionInfo\n{\n  Image\n    *image;\n\n  ExceptionInfo\n    *exception;\n} CMSExceptionInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   C l o n e I m a g e P r o f i l e s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CloneImageProfiles() clones one or more image profiles.\n%\n%  The format of the CloneImageProfiles method is:\n%\n%      MagickBooleanType CloneImageProfiles(Image *image,\n%        const Image *clone_image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone_image: the clone image.\n%\n*/\nMagickExport MagickBooleanType CloneImageProfiles(Image *image,\n  const Image *clone_image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(clone_image != (const Image *) NULL);\n  assert(clone_image->signature == MagickCoreSignature);\n  if (clone_image->profiles != (void *) NULL)\n    {\n      if (image->profiles != (void *) NULL)\n        DestroyImageProfiles(image);\n      image->profiles=CloneSplayTree((SplayTreeInfo *) clone_image->profiles,\n        (void *(*)(void *)) ConstantString,(void *(*)(void *)) CloneStringInfo);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e l e t e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DeleteImageProfile() deletes a profile from the image by its name.\n%\n%  The format of the DeleteImageProfile method is:\n%\n%      MagickBooleanTyupe DeleteImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport MagickBooleanType DeleteImageProfile(Image *image,const char *name)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return(MagickFalse);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  return(DeleteNodeFromSplayTree((SplayTreeInfo *) image->profiles,name));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   D e s t r o y I m a g e P r o f i l e s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImageProfiles() releases memory associated with an image profile map.\n%\n%  The format of the DestroyProfiles method is:\n%\n%      void DestroyImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImageProfiles(Image *image)\n{\n  if (image->profiles != (SplayTreeInfo *) NULL)\n    image->profiles=DestroySplayTree((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageProfile() gets a profile associated with an image by name.\n%\n%  The format of the GetImageProfile method is:\n%\n%      const StringInfo *GetImageProfile(const Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport const StringInfo *GetImageProfile(const Image *image,\n  const char *name)\n{\n  const StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  profile=(const StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t N e x t I m a g e P r o f i l e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetNextImageProfile() gets the next profile name for an image.\n%\n%  The format of the GetNextImageProfile method is:\n%\n%      char *GetNextImageProfile(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o hash_info: the hash info.\n%\n*/\nMagickExport char *GetNextImageProfile(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((char *) NULL);\n  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   P r o f i l e I m a g e                                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ProfileImage() associates, applies, or removes an ICM, IPTC, or generic\n%  profile with / to / from an image.  If the profile is NULL, it is removed\n%  from the image otherwise added or applied.  Use a name of '*' and a profile\n%  of NULL to remove all profiles from the image.\n%\n%  ICC and ICM profiles are handled as follows: If the image does not have\n%  an associated color profile, the one you provide is associated with the\n%  image and the image pixels are not transformed.  Otherwise, the colorspace\n%  transform defined by the existing and new profile are applied to the image\n%  pixels and the new profile is associated with the image.\n%\n%  The format of the ProfileImage method is:\n%\n%      MagickBooleanType ProfileImage(Image *image,const char *name,\n%        const void *datum,const size_t length,const MagickBooleanType clone)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: Name of profile to add or remove: ICC, IPTC, or generic profile.\n%\n%    o datum: the profile data.\n%\n%    o length: the length of the profile.\n%\n%    o clone: should be MagickFalse.\n%\n*/\n\n#if defined(MAGICKCORE_LCMS_DELEGATE)\nstatic unsigned short **DestroyPixelThreadSet(unsigned short **pixels)\n{\n  register ssize_t\n    i;\n\n  assert(pixels != (unsigned short **) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (pixels[i] != (unsigned short *) NULL)\n      pixels[i]=(unsigned short *) RelinquishMagickMemory(pixels[i]);\n  pixels=(unsigned short **) RelinquishMagickMemory(pixels);\n  return(pixels);\n}\n\nstatic unsigned short **AcquirePixelThreadSet(const size_t columns,\n  const size_t channels)\n{\n  register ssize_t\n    i;\n\n  unsigned short\n    **pixels;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  pixels=(unsigned short **) AcquireQuantumMemory(number_threads,\n    sizeof(*pixels));\n  if (pixels == (unsigned short **) NULL)\n    return((unsigned short **) NULL);\n  (void) ResetMagickMemory(pixels,0,number_threads*sizeof(*pixels));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    pixels[i]=(unsigned short *) AcquireQuantumMemory(columns,channels*\n      sizeof(**pixels));\n    if (pixels[i] == (unsigned short *) NULL)\n      return(DestroyPixelThreadSet(pixels));\n  }\n  return(pixels);\n}\n\nstatic cmsHTRANSFORM *DestroyTransformThreadSet(cmsHTRANSFORM *transform)\n{\n  register ssize_t\n    i;\n\n  assert(transform != (cmsHTRANSFORM *) NULL);\n  for (i=0; i < (ssize_t) GetMagickResourceLimit(ThreadResource); i++)\n    if (transform[i] != (cmsHTRANSFORM) NULL)\n      cmsDeleteTransform(transform[i]);\n  transform=(cmsHTRANSFORM *) RelinquishMagickMemory(transform);\n  return(transform);\n}\n\nstatic cmsHTRANSFORM *AcquireTransformThreadSet(Image *image,\n  const cmsHPROFILE source_profile,const cmsUInt32Number source_type,\n  const cmsHPROFILE target_profile,const cmsUInt32Number target_type,\n  const int intent,const cmsUInt32Number flags)\n{\n  cmsHTRANSFORM\n    *transform;\n\n  register ssize_t\n    i;\n\n  size_t\n    number_threads;\n\n  number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  transform=(cmsHTRANSFORM *) AcquireQuantumMemory(number_threads,\n    sizeof(*transform));\n  if (transform == (cmsHTRANSFORM *) NULL)\n    return((cmsHTRANSFORM *) NULL);\n  (void) ResetMagickMemory(transform,0,number_threads*sizeof(*transform));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    transform[i]=cmsCreateTransformTHR((cmsContext) image,source_profile,\n      source_type,target_profile,target_type,intent,flags);\n    if (transform[i] == (cmsHTRANSFORM) NULL)\n      return(DestroyTransformThreadSet(transform));\n  }\n  return(transform);\n}\n#endif\n\n#if defined(MAGICKCORE_LCMS_DELEGATE)\nstatic void CMSExceptionHandler(cmsContext context,cmsUInt32Number severity,\n  const char *message)\n{\n  CMSExceptionInfo\n    *cms_exception;\n\n  ExceptionInfo\n    *exception;\n\n  Image\n    *image;\n\n  cms_exception=(CMSExceptionInfo *) context;\n  image=cms_exception->image;\n  exception=cms_exception->exception;\n  if (image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n        \"UnableToTransformColorspace\",\"`%s'\",\"unknown context\");\n      return;\n    }\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TransformEvent,GetMagickModule(),\"lcms: #%u, %s\",\n      severity,message != (char *) NULL ? message : \"no message\");\n  (void) ThrowMagickException(exception,GetMagickModule(),ImageWarning,\n    \"UnableToTransformColorspace\",\"`%s'\",image->filename);\n}\n#endif\n\nstatic MagickBooleanType SetsRGBImageProfile(Image *image,\n  ExceptionInfo *exception)\n{\n  static unsigned char\n    sRGBProfile[] =\n    {\n      0x00, 0x00, 0x0c, 0x8c, 0x61, 0x72, 0x67, 0x6c, 0x02, 0x20, 0x00, 0x00,\n      0x6d, 0x6e, 0x74, 0x72, 0x52, 0x47, 0x42, 0x20, 0x58, 0x59, 0x5a, 0x20,\n      0x07, 0xde, 0x00, 0x01, 0x00, 0x06, 0x00, 0x16, 0x00, 0x0f, 0x00, 0x3a,\n      0x61, 0x63, 0x73, 0x70, 0x4d, 0x53, 0x46, 0x54, 0x00, 0x00, 0x00, 0x00,\n      0x49, 0x45, 0x43, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf6, 0xd6,\n      0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d, 0x61, 0x72, 0x67, 0x6c,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x01, 0x50, 0x00, 0x00, 0x00, 0x99,\n      0x63, 0x70, 0x72, 0x74, 0x00, 0x00, 0x01, 0xec, 0x00, 0x00, 0x00, 0x67,\n      0x64, 0x6d, 0x6e, 0x64, 0x00, 0x00, 0x02, 0x54, 0x00, 0x00, 0x00, 0x70,\n      0x64, 0x6d, 0x64, 0x64, 0x00, 0x00, 0x02, 0xc4, 0x00, 0x00, 0x00, 0x88,\n      0x74, 0x65, 0x63, 0x68, 0x00, 0x00, 0x03, 0x4c, 0x00, 0x00, 0x00, 0x0c,\n      0x76, 0x75, 0x65, 0x64, 0x00, 0x00, 0x03, 0x58, 0x00, 0x00, 0x00, 0x67,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x03, 0xc0, 0x00, 0x00, 0x00, 0x24,\n      0x6c, 0x75, 0x6d, 0x69, 0x00, 0x00, 0x03, 0xe4, 0x00, 0x00, 0x00, 0x14,\n      0x6d, 0x65, 0x61, 0x73, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00, 0x24,\n      0x77, 0x74, 0x70, 0x74, 0x00, 0x00, 0x04, 0x1c, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x6b, 0x70, 0x74, 0x00, 0x00, 0x04, 0x30, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x44, 0x00, 0x00, 0x00, 0x14,\n      0x67, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x58, 0x00, 0x00, 0x00, 0x14,\n      0x62, 0x58, 0x59, 0x5a, 0x00, 0x00, 0x04, 0x6c, 0x00, 0x00, 0x00, 0x14,\n      0x72, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x67, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x62, 0x54, 0x52, 0x43, 0x00, 0x00, 0x04, 0x80, 0x00, 0x00, 0x08, 0x0c,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f,\n      0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36,\n      0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75, 0x69, 0x76,\n      0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77, 0x77, 0x77,\n      0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20, 0x31, 0x39,\n      0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c,\n      0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x3f, 0x73, 0x52, 0x47, 0x42, 0x20, 0x49, 0x45, 0x43, 0x36, 0x31,\n      0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x28, 0x45, 0x71, 0x75,\n      0x69, 0x76, 0x61, 0x6c, 0x65, 0x6e, 0x74, 0x20, 0x74, 0x6f, 0x20, 0x77,\n      0x77, 0x77, 0x2e, 0x73, 0x72, 0x67, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x20,\n      0x31, 0x39, 0x39, 0x38, 0x20, 0x48, 0x50, 0x20, 0x70, 0x72, 0x6f, 0x66,\n      0x69, 0x6c, 0x65, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00, 0x00, 0x43, 0x72, 0x65, 0x61,\n      0x74, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20, 0x47, 0x72, 0x61, 0x65, 0x6d,\n      0x65, 0x20, 0x57, 0x2e, 0x20, 0x47, 0x69, 0x6c, 0x6c, 0x2e, 0x20, 0x52,\n      0x65, 0x6c, 0x65, 0x61, 0x73, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x74, 0x6f,\n      0x20, 0x74, 0x68, 0x65, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63, 0x20,\n      0x64, 0x6f, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x20, 0x4e, 0x6f, 0x20, 0x57,\n      0x61, 0x72, 0x72, 0x61, 0x6e, 0x74, 0x79, 0x2c, 0x20, 0x55, 0x73, 0x65,\n      0x20, 0x61, 0x74, 0x20, 0x79, 0x6f, 0x75, 0x72, 0x20, 0x6f, 0x77, 0x6e,\n      0x20, 0x72, 0x69, 0x73, 0x6b, 0x2e, 0x00, 0x00, 0x64, 0x65, 0x73, 0x63,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20,\n      0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69,\n      0x65, 0x63, 0x2e, 0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x16, 0x49, 0x45, 0x43, 0x20, 0x68, 0x74, 0x74,\n      0x70, 0x3a, 0x2f, 0x2f, 0x77, 0x77, 0x77, 0x2e, 0x69, 0x65, 0x63, 0x2e,\n      0x63, 0x68, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e,\n      0x49, 0x45, 0x43, 0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e,\n      0x31, 0x20, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47,\n      0x42, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61,\n      0x63, 0x65, 0x20, 0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x49, 0x45, 0x43,\n      0x20, 0x36, 0x31, 0x39, 0x36, 0x36, 0x2d, 0x32, 0x2e, 0x31, 0x20, 0x44,\n      0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x20, 0x52, 0x47, 0x42, 0x20, 0x63,\n      0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x20, 0x73, 0x70, 0x61, 0x63, 0x65, 0x20,\n      0x2d, 0x20, 0x73, 0x52, 0x47, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x73, 0x69, 0x67, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x43, 0x52, 0x54, 0x20, 0x64, 0x65, 0x73, 0x63, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x0d, 0x49, 0x45, 0x43, 0x36, 0x31, 0x39, 0x36, 0x36,\n      0x2d, 0x32, 0x2e, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x76, 0x69, 0x65, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xa4, 0x7c,\n      0x00, 0x14, 0x5f, 0x30, 0x00, 0x10, 0xce, 0x02, 0x00, 0x03, 0xed, 0xb2,\n      0x00, 0x04, 0x13, 0x0a, 0x00, 0x03, 0x5c, 0x67, 0x00, 0x00, 0x00, 0x01,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4c, 0x0a, 0x3d,\n      0x00, 0x50, 0x00, 0x00, 0x00, 0x57, 0x1e, 0xb8, 0x6d, 0x65, 0x61, 0x73,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x02, 0x8f, 0x00, 0x00, 0x00, 0x02, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x51, 0x00, 0x01, 0x00, 0x00,\n      0x00, 0x01, 0x16, 0xcc, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n      0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6f, 0xa0,\n      0x00, 0x00, 0x38, 0xf5, 0x00, 0x00, 0x03, 0x90, 0x58, 0x59, 0x5a, 0x20,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0x97, 0x00, 0x00, 0xb7, 0x87,\n      0x00, 0x00, 0x18, 0xd9, 0x58, 0x59, 0x5a, 0x20, 0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x24, 0x9f, 0x00, 0x00, 0x0f, 0x84, 0x00, 0x00, 0xb6, 0xc4,\n      0x63, 0x75, 0x72, 0x76, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00,\n      0x00, 0x00, 0x00, 0x05, 0x00, 0x0a, 0x00, 0x0f, 0x00, 0x14, 0x00, 0x19,\n      0x00, 0x1e, 0x00, 0x23, 0x00, 0x28, 0x00, 0x2d, 0x00, 0x32, 0x00, 0x37,\n      0x00, 0x3b, 0x00, 0x40, 0x00, 0x45, 0x00, 0x4a, 0x00, 0x4f, 0x00, 0x54,\n      0x00, 0x59, 0x00, 0x5e, 0x00, 0x63, 0x00, 0x68, 0x00, 0x6d, 0x00, 0x72,\n      0x00, 0x77, 0x00, 0x7c, 0x00, 0x81, 0x00, 0x86, 0x00, 0x8b, 0x00, 0x90,\n      0x00, 0x95, 0x00, 0x9a, 0x00, 0x9f, 0x00, 0xa4, 0x00, 0xa9, 0x00, 0xae,\n      0x00, 0xb2, 0x00, 0xb7, 0x00, 0xbc, 0x00, 0xc1, 0x00, 0xc6, 0x00, 0xcb,\n      0x00, 0xd0, 0x00, 0xd5, 0x00, 0xdb, 0x00, 0xe0, 0x00, 0xe5, 0x00, 0xeb,\n      0x00, 0xf0, 0x00, 0xf6, 0x00, 0xfb, 0x01, 0x01, 0x01, 0x07, 0x01, 0x0d,\n      0x01, 0x13, 0x01, 0x19, 0x01, 0x1f, 0x01, 0x25, 0x01, 0x2b, 0x01, 0x32,\n      0x01, 0x38, 0x01, 0x3e, 0x01, 0x45, 0x01, 0x4c, 0x01, 0x52, 0x01, 0x59,\n      0x01, 0x60, 0x01, 0x67, 0x01, 0x6e, 0x01, 0x75, 0x01, 0x7c, 0x01, 0x83,\n      0x01, 0x8b, 0x01, 0x92, 0x01, 0x9a, 0x01, 0xa1, 0x01, 0xa9, 0x01, 0xb1,\n      0x01, 0xb9, 0x01, 0xc1, 0x01, 0xc9, 0x01, 0xd1, 0x01, 0xd9, 0x01, 0xe1,\n      0x01, 0xe9, 0x01, 0xf2, 0x01, 0xfa, 0x02, 0x03, 0x02, 0x0c, 0x02, 0x14,\n      0x02, 0x1d, 0x02, 0x26, 0x02, 0x2f, 0x02, 0x38, 0x02, 0x41, 0x02, 0x4b,\n      0x02, 0x54, 0x02, 0x5d, 0x02, 0x67, 0x02, 0x71, 0x02, 0x7a, 0x02, 0x84,\n      0x02, 0x8e, 0x02, 0x98, 0x02, 0xa2, 0x02, 0xac, 0x02, 0xb6, 0x02, 0xc1,\n      0x02, 0xcb, 0x02, 0xd5, 0x02, 0xe0, 0x02, 0xeb, 0x02, 0xf5, 0x03, 0x00,\n      0x03, 0x0b, 0x03, 0x16, 0x03, 0x21, 0x03, 0x2d, 0x03, 0x38, 0x03, 0x43,\n      0x03, 0x4f, 0x03, 0x5a, 0x03, 0x66, 0x03, 0x72, 0x03, 0x7e, 0x03, 0x8a,\n      0x03, 0x96, 0x03, 0xa2, 0x03, 0xae, 0x03, 0xba, 0x03, 0xc7, 0x03, 0xd3,\n      0x03, 0xe0, 0x03, 0xec, 0x03, 0xf9, 0x04, 0x06, 0x04, 0x13, 0x04, 0x20,\n      0x04, 0x2d, 0x04, 0x3b, 0x04, 0x48, 0x04, 0x55, 0x04, 0x63, 0x04, 0x71,\n      0x04, 0x7e, 0x04, 0x8c, 0x04, 0x9a, 0x04, 0xa8, 0x04, 0xb6, 0x04, 0xc4,\n      0x04, 0xd3, 0x04, 0xe1, 0x04, 0xf0, 0x04, 0xfe, 0x05, 0x0d, 0x05, 0x1c,\n      0x05, 0x2b, 0x05, 0x3a, 0x05, 0x49, 0x05, 0x58, 0x05, 0x67, 0x05, 0x77,\n      0x05, 0x86, 0x05, 0x96, 0x05, 0xa6, 0x05, 0xb5, 0x05, 0xc5, 0x05, 0xd5,\n      0x05, 0xe5, 0x05, 0xf6, 0x06, 0x06, 0x06, 0x16, 0x06, 0x27, 0x06, 0x37,\n      0x06, 0x48, 0x06, 0x59, 0x06, 0x6a, 0x06, 0x7b, 0x06, 0x8c, 0x06, 0x9d,\n      0x06, 0xaf, 0x06, 0xc0, 0x06, 0xd1, 0x06, 0xe3, 0x06, 0xf5, 0x07, 0x07,\n      0x07, 0x19, 0x07, 0x2b, 0x07, 0x3d, 0x07, 0x4f, 0x07, 0x61, 0x07, 0x74,\n      0x07, 0x86, 0x07, 0x99, 0x07, 0xac, 0x07, 0xbf, 0x07, 0xd2, 0x07, 0xe5,\n      0x07, 0xf8, 0x08, 0x0b, 0x08, 0x1f, 0x08, 0x32, 0x08, 0x46, 0x08, 0x5a,\n      0x08, 0x6e, 0x08, 0x82, 0x08, 0x96, 0x08, 0xaa, 0x08, 0xbe, 0x08, 0xd2,\n      0x08, 0xe7, 0x08, 0xfb, 0x09, 0x10, 0x09, 0x25, 0x09, 0x3a, 0x09, 0x4f,\n      0x09, 0x64, 0x09, 0x79, 0x09, 0x8f, 0x09, 0xa4, 0x09, 0xba, 0x09, 0xcf,\n      0x09, 0xe5, 0x09, 0xfb, 0x0a, 0x11, 0x0a, 0x27, 0x0a, 0x3d, 0x0a, 0x54,\n      0x0a, 0x6a, 0x0a, 0x81, 0x0a, 0x98, 0x0a, 0xae, 0x0a, 0xc5, 0x0a, 0xdc,\n      0x0a, 0xf3, 0x0b, 0x0b, 0x0b, 0x22, 0x0b, 0x39, 0x0b, 0x51, 0x0b, 0x69,\n      0x0b, 0x80, 0x0b, 0x98, 0x0b, 0xb0, 0x0b, 0xc8, 0x0b, 0xe1, 0x0b, 0xf9,\n      0x0c, 0x12, 0x0c, 0x2a, 0x0c, 0x43, 0x0c, 0x5c, 0x0c, 0x75, 0x0c, 0x8e,\n      0x0c, 0xa7, 0x0c, 0xc0, 0x0c, 0xd9, 0x0c, 0xf3, 0x0d, 0x0d, 0x0d, 0x26,\n      0x0d, 0x40, 0x0d, 0x5a, 0x0d, 0x74, 0x0d, 0x8e, 0x0d, 0xa9, 0x0d, 0xc3,\n      0x0d, 0xde, 0x0d, 0xf8, 0x0e, 0x13, 0x0e, 0x2e, 0x0e, 0x49, 0x0e, 0x64,\n      0x0e, 0x7f, 0x0e, 0x9b, 0x0e, 0xb6, 0x0e, 0xd2, 0x0e, 0xee, 0x0f, 0x09,\n      0x0f, 0x25, 0x0f, 0x41, 0x0f, 0x5e, 0x0f, 0x7a, 0x0f, 0x96, 0x0f, 0xb3,\n      0x0f, 0xcf, 0x0f, 0xec, 0x10, 0x09, 0x10, 0x26, 0x10, 0x43, 0x10, 0x61,\n      0x10, 0x7e, 0x10, 0x9b, 0x10, 0xb9, 0x10, 0xd7, 0x10, 0xf5, 0x11, 0x13,\n      0x11, 0x31, 0x11, 0x4f, 0x11, 0x6d, 0x11, 0x8c, 0x11, 0xaa, 0x11, 0xc9,\n      0x11, 0xe8, 0x12, 0x07, 0x12, 0x26, 0x12, 0x45, 0x12, 0x64, 0x12, 0x84,\n      0x12, 0xa3, 0x12, 0xc3, 0x12, 0xe3, 0x13, 0x03, 0x13, 0x23, 0x13, 0x43,\n      0x13, 0x63, 0x13, 0x83, 0x13, 0xa4, 0x13, 0xc5, 0x13, 0xe5, 0x14, 0x06,\n      0x14, 0x27, 0x14, 0x49, 0x14, 0x6a, 0x14, 0x8b, 0x14, 0xad, 0x14, 0xce,\n      0x14, 0xf0, 0x15, 0x12, 0x15, 0x34, 0x15, 0x56, 0x15, 0x78, 0x15, 0x9b,\n      0x15, 0xbd, 0x15, 0xe0, 0x16, 0x03, 0x16, 0x26, 0x16, 0x49, 0x16, 0x6c,\n      0x16, 0x8f, 0x16, 0xb2, 0x16, 0xd6, 0x16, 0xfa, 0x17, 0x1d, 0x17, 0x41,\n      0x17, 0x65, 0x17, 0x89, 0x17, 0xae, 0x17, 0xd2, 0x17, 0xf7, 0x18, 0x1b,\n      0x18, 0x40, 0x18, 0x65, 0x18, 0x8a, 0x18, 0xaf, 0x18, 0xd5, 0x18, 0xfa,\n      0x19, 0x20, 0x19, 0x45, 0x19, 0x6b, 0x19, 0x91, 0x19, 0xb7, 0x19, 0xdd,\n      0x1a, 0x04, 0x1a, 0x2a, 0x1a, 0x51, 0x1a, 0x77, 0x1a, 0x9e, 0x1a, 0xc5,\n      0x1a, 0xec, 0x1b, 0x14, 0x1b, 0x3b, 0x1b, 0x63, 0x1b, 0x8a, 0x1b, 0xb2,\n      0x1b, 0xda, 0x1c, 0x02, 0x1c, 0x2a, 0x1c, 0x52, 0x1c, 0x7b, 0x1c, 0xa3,\n      0x1c, 0xcc, 0x1c, 0xf5, 0x1d, 0x1e, 0x1d, 0x47, 0x1d, 0x70, 0x1d, 0x99,\n      0x1d, 0xc3, 0x1d, 0xec, 0x1e, 0x16, 0x1e, 0x40, 0x1e, 0x6a, 0x1e, 0x94,\n      0x1e, 0xbe, 0x1e, 0xe9, 0x1f, 0x13, 0x1f, 0x3e, 0x1f, 0x69, 0x1f, 0x94,\n      0x1f, 0xbf, 0x1f, 0xea, 0x20, 0x15, 0x20, 0x41, 0x20, 0x6c, 0x20, 0x98,\n      0x20, 0xc4, 0x20, 0xf0, 0x21, 0x1c, 0x21, 0x48, 0x21, 0x75, 0x21, 0xa1,\n      0x21, 0xce, 0x21, 0xfb, 0x22, 0x27, 0x22, 0x55, 0x22, 0x82, 0x22, 0xaf,\n      0x22, 0xdd, 0x23, 0x0a, 0x23, 0x38, 0x23, 0x66, 0x23, 0x94, 0x23, 0xc2,\n      0x23, 0xf0, 0x24, 0x1f, 0x24, 0x4d, 0x24, 0x7c, 0x24, 0xab, 0x24, 0xda,\n      0x25, 0x09, 0x25, 0x38, 0x25, 0x68, 0x25, 0x97, 0x25, 0xc7, 0x25, 0xf7,\n      0x26, 0x27, 0x26, 0x57, 0x26, 0x87, 0x26, 0xb7, 0x26, 0xe8, 0x27, 0x18,\n      0x27, 0x49, 0x27, 0x7a, 0x27, 0xab, 0x27, 0xdc, 0x28, 0x0d, 0x28, 0x3f,\n      0x28, 0x71, 0x28, 0xa2, 0x28, 0xd4, 0x29, 0x06, 0x29, 0x38, 0x29, 0x6b,\n      0x29, 0x9d, 0x29, 0xd0, 0x2a, 0x02, 0x2a, 0x35, 0x2a, 0x68, 0x2a, 0x9b,\n      0x2a, 0xcf, 0x2b, 0x02, 0x2b, 0x36, 0x2b, 0x69, 0x2b, 0x9d, 0x2b, 0xd1,\n      0x2c, 0x05, 0x2c, 0x39, 0x2c, 0x6e, 0x2c, 0xa2, 0x2c, 0xd7, 0x2d, 0x0c,\n      0x2d, 0x41, 0x2d, 0x76, 0x2d, 0xab, 0x2d, 0xe1, 0x2e, 0x16, 0x2e, 0x4c,\n      0x2e, 0x82, 0x2e, 0xb7, 0x2e, 0xee, 0x2f, 0x24, 0x2f, 0x5a, 0x2f, 0x91,\n      0x2f, 0xc7, 0x2f, 0xfe, 0x30, 0x35, 0x30, 0x6c, 0x30, 0xa4, 0x30, 0xdb,\n      0x31, 0x12, 0x31, 0x4a, 0x31, 0x82, 0x31, 0xba, 0x31, 0xf2, 0x32, 0x2a,\n      0x32, 0x63, 0x32, 0x9b, 0x32, 0xd4, 0x33, 0x0d, 0x33, 0x46, 0x33, 0x7f,\n      0x33, 0xb8, 0x33, 0xf1, 0x34, 0x2b, 0x34, 0x65, 0x34, 0x9e, 0x34, 0xd8,\n      0x35, 0x13, 0x35, 0x4d, 0x35, 0x87, 0x35, 0xc2, 0x35, 0xfd, 0x36, 0x37,\n      0x36, 0x72, 0x36, 0xae, 0x36, 0xe9, 0x37, 0x24, 0x37, 0x60, 0x37, 0x9c,\n      0x37, 0xd7, 0x38, 0x14, 0x38, 0x50, 0x38, 0x8c, 0x38, 0xc8, 0x39, 0x05,\n      0x39, 0x42, 0x39, 0x7f, 0x39, 0xbc, 0x39, 0xf9, 0x3a, 0x36, 0x3a, 0x74,\n      0x3a, 0xb2, 0x3a, 0xef, 0x3b, 0x2d, 0x3b, 0x6b, 0x3b, 0xaa, 0x3b, 0xe8,\n      0x3c, 0x27, 0x3c, 0x65, 0x3c, 0xa4, 0x3c, 0xe3, 0x3d, 0x22, 0x3d, 0x61,\n      0x3d, 0xa1, 0x3d, 0xe0, 0x3e, 0x20, 0x3e, 0x60, 0x3e, 0xa0, 0x3e, 0xe0,\n      0x3f, 0x21, 0x3f, 0x61, 0x3f, 0xa2, 0x3f, 0xe2, 0x40, 0x23, 0x40, 0x64,\n      0x40, 0xa6, 0x40, 0xe7, 0x41, 0x29, 0x41, 0x6a, 0x41, 0xac, 0x41, 0xee,\n      0x42, 0x30, 0x42, 0x72, 0x42, 0xb5, 0x42, 0xf7, 0x43, 0x3a, 0x43, 0x7d,\n      0x43, 0xc0, 0x44, 0x03, 0x44, 0x47, 0x44, 0x8a, 0x44, 0xce, 0x45, 0x12,\n      0x45, 0x55, 0x45, 0x9a, 0x45, 0xde, 0x46, 0x22, 0x46, 0x67, 0x46, 0xab,\n      0x46, 0xf0, 0x47, 0x35, 0x47, 0x7b, 0x47, 0xc0, 0x48, 0x05, 0x48, 0x4b,\n      0x48, 0x91, 0x48, 0xd7, 0x49, 0x1d, 0x49, 0x63, 0x49, 0xa9, 0x49, 0xf0,\n      0x4a, 0x37, 0x4a, 0x7d, 0x4a, 0xc4, 0x4b, 0x0c, 0x4b, 0x53, 0x4b, 0x9a,\n      0x4b, 0xe2, 0x4c, 0x2a, 0x4c, 0x72, 0x4c, 0xba, 0x4d, 0x02, 0x4d, 0x4a,\n      0x4d, 0x93, 0x4d, 0xdc, 0x4e, 0x25, 0x4e, 0x6e, 0x4e, 0xb7, 0x4f, 0x00,\n      0x4f, 0x49, 0x4f, 0x93, 0x4f, 0xdd, 0x50, 0x27, 0x50, 0x71, 0x50, 0xbb,\n      0x51, 0x06, 0x51, 0x50, 0x51, 0x9b, 0x51, 0xe6, 0x52, 0x31, 0x52, 0x7c,\n      0x52, 0xc7, 0x53, 0x13, 0x53, 0x5f, 0x53, 0xaa, 0x53, 0xf6, 0x54, 0x42,\n      0x54, 0x8f, 0x54, 0xdb, 0x55, 0x28, 0x55, 0x75, 0x55, 0xc2, 0x56, 0x0f,\n      0x56, 0x5c, 0x56, 0xa9, 0x56, 0xf7, 0x57, 0x44, 0x57, 0x92, 0x57, 0xe0,\n      0x58, 0x2f, 0x58, 0x7d, 0x58, 0xcb, 0x59, 0x1a, 0x59, 0x69, 0x59, 0xb8,\n      0x5a, 0x07, 0x5a, 0x56, 0x5a, 0xa6, 0x5a, 0xf5, 0x5b, 0x45, 0x5b, 0x95,\n      0x5b, 0xe5, 0x5c, 0x35, 0x5c, 0x86, 0x5c, 0xd6, 0x5d, 0x27, 0x5d, 0x78,\n      0x5d, 0xc9, 0x5e, 0x1a, 0x5e, 0x6c, 0x5e, 0xbd, 0x5f, 0x0f, 0x5f, 0x61,\n      0x5f, 0xb3, 0x60, 0x05, 0x60, 0x57, 0x60, 0xaa, 0x60, 0xfc, 0x61, 0x4f,\n      0x61, 0xa2, 0x61, 0xf5, 0x62, 0x49, 0x62, 0x9c, 0x62, 0xf0, 0x63, 0x43,\n      0x63, 0x97, 0x63, 0xeb, 0x64, 0x40, 0x64, 0x94, 0x64, 0xe9, 0x65, 0x3d,\n      0x65, 0x92, 0x65, 0xe7, 0x66, 0x3d, 0x66, 0x92, 0x66, 0xe8, 0x67, 0x3d,\n      0x67, 0x93, 0x67, 0xe9, 0x68, 0x3f, 0x68, 0x96, 0x68, 0xec, 0x69, 0x43,\n      0x69, 0x9a, 0x69, 0xf1, 0x6a, 0x48, 0x6a, 0x9f, 0x6a, 0xf7, 0x6b, 0x4f,\n      0x6b, 0xa7, 0x6b, 0xff, 0x6c, 0x57, 0x6c, 0xaf, 0x6d, 0x08, 0x6d, 0x60,\n      0x6d, 0xb9, 0x6e, 0x12, 0x6e, 0x6b, 0x6e, 0xc4, 0x6f, 0x1e, 0x6f, 0x78,\n      0x6f, 0xd1, 0x70, 0x2b, 0x70, 0x86, 0x70, 0xe0, 0x71, 0x3a, 0x71, 0x95,\n      0x71, 0xf0, 0x72, 0x4b, 0x72, 0xa6, 0x73, 0x01, 0x73, 0x5d, 0x73, 0xb8,\n      0x74, 0x14, 0x74, 0x70, 0x74, 0xcc, 0x75, 0x28, 0x75, 0x85, 0x75, 0xe1,\n      0x76, 0x3e, 0x76, 0x9b, 0x76, 0xf8, 0x77, 0x56, 0x77, 0xb3, 0x78, 0x11,\n      0x78, 0x6e, 0x78, 0xcc, 0x79, 0x2a, 0x79, 0x89, 0x79, 0xe7, 0x7a, 0x46,\n      0x7a, 0xa5, 0x7b, 0x04, 0x7b, 0x63, 0x7b, 0xc2, 0x7c, 0x21, 0x7c, 0x81,\n      0x7c, 0xe1, 0x7d, 0x41, 0x7d, 0xa1, 0x7e, 0x01, 0x7e, 0x62, 0x7e, 0xc2,\n      0x7f, 0x23, 0x7f, 0x84, 0x7f, 0xe5, 0x80, 0x47, 0x80, 0xa8, 0x81, 0x0a,\n      0x81, 0x6b, 0x81, 0xcd, 0x82, 0x30, 0x82, 0x92, 0x82, 0xf4, 0x83, 0x57,\n      0x83, 0xba, 0x84, 0x1d, 0x84, 0x80, 0x84, 0xe3, 0x85, 0x47, 0x85, 0xab,\n      0x86, 0x0e, 0x86, 0x72, 0x86, 0xd7, 0x87, 0x3b, 0x87, 0x9f, 0x88, 0x04,\n      0x88, 0x69, 0x88, 0xce, 0x89, 0x33, 0x89, 0x99, 0x89, 0xfe, 0x8a, 0x64,\n      0x8a, 0xca, 0x8b, 0x30, 0x8b, 0x96, 0x8b, 0xfc, 0x8c, 0x63, 0x8c, 0xca,\n      0x8d, 0x31, 0x8d, 0x98, 0x8d, 0xff, 0x8e, 0x66, 0x8e, 0xce, 0x8f, 0x36,\n      0x8f, 0x9e, 0x90, 0x06, 0x90, 0x6e, 0x90, 0xd6, 0x91, 0x3f, 0x91, 0xa8,\n      0x92, 0x11, 0x92, 0x7a, 0x92, 0xe3, 0x93, 0x4d, 0x93, 0xb6, 0x94, 0x20,\n      0x94, 0x8a, 0x94, 0xf4, 0x95, 0x5f, 0x95, 0xc9, 0x96, 0x34, 0x96, 0x9f,\n      0x97, 0x0a, 0x97, 0x75, 0x97, 0xe0, 0x98, 0x4c, 0x98, 0xb8, 0x99, 0x24,\n      0x99, 0x90, 0x99, 0xfc, 0x9a, 0x68, 0x9a, 0xd5, 0x9b, 0x42, 0x9b, 0xaf,\n      0x9c, 0x1c, 0x9c, 0x89, 0x9c, 0xf7, 0x9d, 0x64, 0x9d, 0xd2, 0x9e, 0x40,\n      0x9e, 0xae, 0x9f, 0x1d, 0x9f, 0x8b, 0x9f, 0xfa, 0xa0, 0x69, 0xa0, 0xd8,\n      0xa1, 0x47, 0xa1, 0xb6, 0xa2, 0x26, 0xa2, 0x96, 0xa3, 0x06, 0xa3, 0x76,\n      0xa3, 0xe6, 0xa4, 0x56, 0xa4, 0xc7, 0xa5, 0x38, 0xa5, 0xa9, 0xa6, 0x1a,\n      0xa6, 0x8b, 0xa6, 0xfd, 0xa7, 0x6e, 0xa7, 0xe0, 0xa8, 0x52, 0xa8, 0xc4,\n      0xa9, 0x37, 0xa9, 0xa9, 0xaa, 0x1c, 0xaa, 0x8f, 0xab, 0x02, 0xab, 0x75,\n      0xab, 0xe9, 0xac, 0x5c, 0xac, 0xd0, 0xad, 0x44, 0xad, 0xb8, 0xae, 0x2d,\n      0xae, 0xa1, 0xaf, 0x16, 0xaf, 0x8b, 0xb0, 0x00, 0xb0, 0x75, 0xb0, 0xea,\n      0xb1, 0x60, 0xb1, 0xd6, 0xb2, 0x4b, 0xb2, 0xc2, 0xb3, 0x38, 0xb3, 0xae,\n      0xb4, 0x25, 0xb4, 0x9c, 0xb5, 0x13, 0xb5, 0x8a, 0xb6, 0x01, 0xb6, 0x79,\n      0xb6, 0xf0, 0xb7, 0x68, 0xb7, 0xe0, 0xb8, 0x59, 0xb8, 0xd1, 0xb9, 0x4a,\n      0xb9, 0xc2, 0xba, 0x3b, 0xba, 0xb5, 0xbb, 0x2e, 0xbb, 0xa7, 0xbc, 0x21,\n      0xbc, 0x9b, 0xbd, 0x15, 0xbd, 0x8f, 0xbe, 0x0a, 0xbe, 0x84, 0xbe, 0xff,\n      0xbf, 0x7a, 0xbf, 0xf5, 0xc0, 0x70, 0xc0, 0xec, 0xc1, 0x67, 0xc1, 0xe3,\n      0xc2, 0x5f, 0xc2, 0xdb, 0xc3, 0x58, 0xc3, 0xd4, 0xc4, 0x51, 0xc4, 0xce,\n      0xc5, 0x4b, 0xc5, 0xc8, 0xc6, 0x46, 0xc6, 0xc3, 0xc7, 0x41, 0xc7, 0xbf,\n      0xc8, 0x3d, 0xc8, 0xbc, 0xc9, 0x3a, 0xc9, 0xb9, 0xca, 0x38, 0xca, 0xb7,\n      0xcb, 0x36, 0xcb, 0xb6, 0xcc, 0x35, 0xcc, 0xb5, 0xcd, 0x35, 0xcd, 0xb5,\n      0xce, 0x36, 0xce, 0xb6, 0xcf, 0x37, 0xcf, 0xb8, 0xd0, 0x39, 0xd0, 0xba,\n      0xd1, 0x3c, 0xd1, 0xbe, 0xd2, 0x3f, 0xd2, 0xc1, 0xd3, 0x44, 0xd3, 0xc6,\n      0xd4, 0x49, 0xd4, 0xcb, 0xd5, 0x4e, 0xd5, 0xd1, 0xd6, 0x55, 0xd6, 0xd8,\n      0xd7, 0x5c, 0xd7, 0xe0, 0xd8, 0x64, 0xd8, 0xe8, 0xd9, 0x6c, 0xd9, 0xf1,\n      0xda, 0x76, 0xda, 0xfb, 0xdb, 0x80, 0xdc, 0x05, 0xdc, 0x8a, 0xdd, 0x10,\n      0xdd, 0x96, 0xde, 0x1c, 0xde, 0xa2, 0xdf, 0x29, 0xdf, 0xaf, 0xe0, 0x36,\n      0xe0, 0xbd, 0xe1, 0x44, 0xe1, 0xcc, 0xe2, 0x53, 0xe2, 0xdb, 0xe3, 0x63,\n      0xe3, 0xeb, 0xe4, 0x73, 0xe4, 0xfc, 0xe5, 0x84, 0xe6, 0x0d, 0xe6, 0x96,\n      0xe7, 0x1f, 0xe7, 0xa9, 0xe8, 0x32, 0xe8, 0xbc, 0xe9, 0x46, 0xe9, 0xd0,\n      0xea, 0x5b, 0xea, 0xe5, 0xeb, 0x70, 0xeb, 0xfb, 0xec, 0x86, 0xed, 0x11,\n      0xed, 0x9c, 0xee, 0x28, 0xee, 0xb4, 0xef, 0x40, 0xef, 0xcc, 0xf0, 0x58,\n      0xf0, 0xe5, 0xf1, 0x72, 0xf1, 0xff, 0xf2, 0x8c, 0xf3, 0x19, 0xf3, 0xa7,\n      0xf4, 0x34, 0xf4, 0xc2, 0xf5, 0x50, 0xf5, 0xde, 0xf6, 0x6d, 0xf6, 0xfb,\n      0xf7, 0x8a, 0xf8, 0x19, 0xf8, 0xa8, 0xf9, 0x38, 0xf9, 0xc7, 0xfa, 0x57,\n      0xfa, 0xe7, 0xfb, 0x77, 0xfc, 0x07, 0xfc, 0x98, 0xfd, 0x29, 0xfd, 0xba,\n      0xfe, 0x4b, 0xfe, 0xdc, 0xff, 0x6d, 0xff, 0xff\n    };\n\n  StringInfo\n    *profile;\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (GetImageProfile(image,\"icc\") != (const StringInfo *) NULL)\n    return(MagickFalse);\n  profile=AcquireStringInfo(sizeof(sRGBProfile));\n  SetStringInfoDatum(profile,sRGBProfile);\n  status=SetImageProfile(image,\"icc\",profile,exception);\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\nMagickExport MagickBooleanType ProfileImage(Image *image,const char *name,\n  const void *datum,const size_t length,ExceptionInfo *exception)\n{\n#define ProfileImageTag  \"Profile/Image\"\n#define ThrowProfileException(severity,tag,context) \\\n{ \\\n  if (source_profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(source_profile); \\\n  if (target_profile != (cmsHPROFILE) NULL) \\\n    (void) cmsCloseProfile(target_profile); \\\n  ThrowBinaryException(severity,tag,context); \\\n}\n\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(name != (const char *) NULL);\n  if ((datum == (const void *) NULL) || (length == 0))\n    {\n      char\n        *next;\n\n      /*\n        Delete image profile(s).\n      */\n      ResetImageProfileIterator(image);\n      for (next=GetNextImageProfile(image); next != (const char *) NULL; )\n      {\n        if (IsOptionMember(next,name) != MagickFalse)\n          {\n            (void) DeleteImageProfile(image,next);\n            ResetImageProfileIterator(image);\n          }\n        next=GetNextImageProfile(image);\n      }\n      return(MagickTrue);\n    }\n  /*\n    Add a ICC, IPTC, or generic profile to the image.\n  */\n  status=MagickTrue;\n  profile=AcquireStringInfo((size_t) length);\n  SetStringInfoDatum(profile,(unsigned char *) datum);\n  if ((LocaleCompare(name,\"icc\") != 0) && (LocaleCompare(name,\"icm\") != 0))\n    status=SetImageProfile(image,name,profile,exception);\n  else\n    {\n      const StringInfo\n        *icc_profile;\n\n      icc_profile=GetImageProfile(image,\"icc\");\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          const char\n            *value;\n\n          value=GetImageProperty(image,\"exif:ColorSpace\",exception);\n          (void) value;\n          if (LocaleCompare(value,\"1\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          value=GetImageProperty(image,\"exif:InteroperabilityIndex\",exception);\n          if (LocaleCompare(value,\"R98.\") != 0)\n            (void) SetsRGBImageProfile(image,exception);\n          /* Future.\n          value=GetImageProperty(image,\"exif:InteroperabilityIndex\",exception);\n          if (LocaleCompare(value,\"R03.\") != 0)\n            (void) SetAdobeRGB1998ImageProfile(image,exception);\n          */\n          icc_profile=GetImageProfile(image,\"icc\");\n        }\n      if ((icc_profile != (const StringInfo *) NULL) &&\n          (CompareStringInfo(icc_profile,profile) == 0))\n        {\n          profile=DestroyStringInfo(profile);\n          return(MagickTrue);\n        }\n#if !defined(MAGICKCORE_LCMS_DELEGATE)\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\n        \"'%s' (LCMS)\",image->filename);\n#else\n      {\n        cmsHPROFILE\n          source_profile;\n\n        CMSExceptionInfo\n          cms_exception;\n\n        /*\n          Transform pixel colors as defined by the color profiles.\n        */\n        cmsSetLogErrorHandler(CMSExceptionHandler);\n        cms_exception.image=image;\n        cms_exception.exception=exception;\n        (void) cms_exception;\n        source_profile=cmsOpenProfileFromMemTHR((cmsContext) &cms_exception,\n          GetStringInfoDatum(profile),(cmsUInt32Number)\n          GetStringInfoLength(profile));\n        if (source_profile == (cmsHPROFILE) NULL)\n          ThrowBinaryException(ResourceLimitError,\n            \"ColorspaceColorProfileMismatch\",name);\n        if ((cmsGetDeviceClass(source_profile) != cmsSigLinkClass) &&\n            (icc_profile == (StringInfo *) NULL))\n          status=SetImageProfile(image,name,profile,exception);\n        else\n          {\n            CacheView\n              *image_view;\n\n            ColorspaceType\n              source_colorspace,\n              target_colorspace;\n\n            cmsColorSpaceSignature\n              signature;\n\n            cmsHPROFILE\n              target_profile;\n\n            cmsHTRANSFORM\n              *magick_restrict transform;\n\n            cmsUInt32Number\n              flags,\n              source_type,\n              target_type;\n\n            int\n              intent;\n\n            MagickBooleanType\n              status;\n\n            MagickOffsetType\n              progress;\n\n            size_t\n              source_channels,\n              target_channels;\n\n            ssize_t\n              y;\n\n            unsigned short\n              **magick_restrict source_pixels,\n              **magick_restrict target_pixels;\n\n            target_profile=(cmsHPROFILE) NULL;\n            if (icc_profile != (StringInfo *) NULL)\n              {\n                target_profile=source_profile;\n                source_profile=cmsOpenProfileFromMemTHR((cmsContext)\n                  &cms_exception,GetStringInfoDatum(icc_profile),\n                  (cmsUInt32Number) GetStringInfoLength(icc_profile));\n                if (source_profile == (cmsHPROFILE) NULL)\n                  ThrowProfileException(ResourceLimitError,\n                    \"ColorspaceColorProfileMismatch\",name);\n              }\n            switch (cmsGetColorSpace(source_profile))\n            {\n              case cmsSigCmykData:\n              {\n                source_colorspace=CMYKColorspace;\n                source_type=(cmsUInt32Number) TYPE_CMYK_16;\n                source_channels=4;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                source_colorspace=GRAYColorspace;\n                source_type=(cmsUInt32Number) TYPE_GRAY_16;\n                source_channels=1;\n                break;\n              }\n              case cmsSigLabData:\n              {\n                source_colorspace=LabColorspace;\n                source_type=(cmsUInt32Number) TYPE_Lab_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigLuvData:\n              {\n                source_colorspace=YUVColorspace;\n                source_type=(cmsUInt32Number) TYPE_YUV_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                source_colorspace=sRGBColorspace;\n                source_type=(cmsUInt32Number) TYPE_RGB_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                source_colorspace=XYZColorspace;\n                source_type=(cmsUInt32Number) TYPE_XYZ_16;\n                source_channels=3;\n                break;\n              }\n              case cmsSigYCbCrData:\n              {\n                source_colorspace=YCbCrColorspace;\n                source_type=(cmsUInt32Number) TYPE_YCbCr_16;\n                source_channels=3;\n                break;\n              }\n              default:\n              {\n                source_colorspace=UndefinedColorspace;\n                source_type=(cmsUInt32Number) TYPE_RGB_16;\n                source_channels=3;\n                break;\n              }\n            }\n            signature=cmsGetPCS(source_profile);\n            if (target_profile != (cmsHPROFILE) NULL)\n              signature=cmsGetColorSpace(target_profile);\n            switch (signature)\n            {\n              case cmsSigCmykData:\n              {\n                target_colorspace=CMYKColorspace;\n                target_type=(cmsUInt32Number) TYPE_CMYK_16;\n                target_channels=4;\n                break;\n              }\n              case cmsSigLabData:\n              {\n                target_colorspace=LabColorspace;\n                target_type=(cmsUInt32Number) TYPE_Lab_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                target_colorspace=GRAYColorspace;\n                target_type=(cmsUInt32Number) TYPE_GRAY_16;\n                target_channels=1;\n                break;\n              }\n              case cmsSigLuvData:\n              {\n                target_colorspace=YUVColorspace;\n                target_type=(cmsUInt32Number) TYPE_YUV_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigRgbData:\n              {\n                target_colorspace=sRGBColorspace;\n                target_type=(cmsUInt32Number) TYPE_RGB_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigXYZData:\n              {\n                target_colorspace=XYZColorspace;\n                target_type=(cmsUInt32Number) TYPE_XYZ_16;\n                target_channels=3;\n                break;\n              }\n              case cmsSigYCbCrData:\n              {\n                target_colorspace=YCbCrColorspace;\n                target_type=(cmsUInt32Number) TYPE_YCbCr_16;\n                target_channels=3;\n                break;\n              }\n              default:\n              {\n                target_colorspace=UndefinedColorspace;\n                target_type=(cmsUInt32Number) TYPE_RGB_16;\n                target_channels=3;\n                break;\n              }\n            }\n            if ((source_colorspace == UndefinedColorspace) ||\n                (target_colorspace == UndefinedColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == GRAYColorspace) &&\n                 (SetImageGray(image,exception) == MagickFalse))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == CMYKColorspace) &&\n                 (image->colorspace != CMYKColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == XYZColorspace) &&\n                 (image->colorspace != XYZColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace == YCbCrColorspace) &&\n                 (image->colorspace != YCbCrColorspace))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n             if ((source_colorspace != CMYKColorspace) &&\n                 (source_colorspace != LabColorspace) &&\n                 (source_colorspace != XYZColorspace) &&\n                 (source_colorspace != YCbCrColorspace) &&\n                 (IssRGBCompatibleColorspace(image->colorspace) == MagickFalse))\n              ThrowProfileException(ImageError,\"ColorspaceColorProfileMismatch\",\n                name);\n            switch (image->rendering_intent)\n            {\n              case AbsoluteIntent: intent=INTENT_ABSOLUTE_COLORIMETRIC; break;\n              case PerceptualIntent: intent=INTENT_PERCEPTUAL; break;\n              case RelativeIntent: intent=INTENT_RELATIVE_COLORIMETRIC; break;\n              case SaturationIntent: intent=INTENT_SATURATION; break;\n              default: intent=INTENT_PERCEPTUAL; break;\n            }\n            flags=cmsFLAGS_HIGHRESPRECALC;\n#if defined(cmsFLAGS_BLACKPOINTCOMPENSATION)\n            if (image->black_point_compensation != MagickFalse)\n              flags|=cmsFLAGS_BLACKPOINTCOMPENSATION;\n#endif\n            transform=AcquireTransformThreadSet(image,source_profile,\n              source_type,target_profile,target_type,intent,flags);\n            if (transform == (cmsHTRANSFORM *) NULL)\n              ThrowProfileException(ImageError,\"UnableToCreateColorTransform\",\n                name);\n            /*\n              Transform image as dictated by the source & target image profiles.\n            */\n            source_pixels=AcquirePixelThreadSet(image->columns,source_channels);\n            target_pixels=AcquirePixelThreadSet(image->columns,target_channels);\n            if ((source_pixels == (unsigned short **) NULL) ||\n                (target_pixels == (unsigned short **) NULL))\n              {\n                transform=DestroyTransformThreadSet(transform);\n                ThrowProfileException(ResourceLimitError,\n                  \"MemoryAllocationFailed\",image->filename);\n              }\n            if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n              {\n                target_pixels=DestroyPixelThreadSet(target_pixels);\n                source_pixels=DestroyPixelThreadSet(source_pixels);\n                transform=DestroyTransformThreadSet(transform);\n                if (source_profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(source_profile);\n                if (target_profile != (cmsHPROFILE) NULL)\n                  (void) cmsCloseProfile(target_profile);\n                return(MagickFalse);\n              }\n            if (target_colorspace == CMYKColorspace)\n              (void) SetImageColorspace(image,target_colorspace,exception);\n            status=MagickTrue;\n            progress=0;\n            image_view=AcquireAuthenticCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel for schedule(static,4) shared(status) \\\n              magick_threads(image,image,image->rows,1)\n#endif\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              const int\n                id = GetOpenMPThreadId();\n\n              MagickBooleanType\n                sync;\n\n              register ssize_t\n                x;\n\n              register Quantum\n                *magick_restrict q;\n\n              register unsigned short\n                *p;\n\n              if (status == MagickFalse)\n                continue;\n              q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                {\n                  status=MagickFalse;\n                  continue;\n                }\n              p=source_pixels[id];\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *p++=ScaleQuantumToShort(GetPixelRed(image,q));\n                if (source_channels > 1)\n                  {\n                    *p++=ScaleQuantumToShort(GetPixelGreen(image,q));\n                    *p++=ScaleQuantumToShort(GetPixelBlue(image,q));\n                  }\n                if (source_channels > 3)\n                  *p++=ScaleQuantumToShort(GetPixelBlack(image,q));\n                q+=GetPixelChannels(image);\n              }\n              cmsDoTransform(transform[id],source_pixels[id],target_pixels[id],\n                (unsigned int) image->columns);\n              p=target_pixels[id];\n              q-=GetPixelChannels(image)*image->columns;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                if (target_channels == 1)\n                  SetPixelGray(image,ScaleShortToQuantum(*p),q);\n                else\n                  SetPixelRed(image,ScaleShortToQuantum(*p),q);\n                p++;\n                if (target_channels > 1)\n                  {\n                    SetPixelGreen(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                    SetPixelBlue(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                  }\n                if (target_channels > 3)\n                  {\n                    SetPixelBlack(image,ScaleShortToQuantum(*p),q);\n                    p++;\n                  }\n                q+=GetPixelChannels(image);\n              }\n              sync=SyncCacheViewAuthenticPixels(image_view,exception);\n              if (sync == MagickFalse)\n                status=MagickFalse;\n              if (image->progress_monitor != (MagickProgressMonitor) NULL)\n                {\n                  MagickBooleanType\n                    proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n                  #pragma omp critical (MagickCore_ProfileImage)\n#endif\n                  proceed=SetImageProgress(image,ProfileImageTag,progress++,\n                    image->rows);\n                  if (proceed == MagickFalse)\n                    status=MagickFalse;\n                }\n            }\n            image_view=DestroyCacheView(image_view);\n            (void) SetImageColorspace(image,target_colorspace,exception);\n            switch (signature)\n            {\n              case cmsSigRgbData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  TrueColorType : TrueColorAlphaType;\n                break;\n              }\n              case cmsSigCmykData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  ColorSeparationType : ColorSeparationAlphaType;\n                break;\n              }\n              case cmsSigGrayData:\n              {\n                image->type=image->alpha_trait == UndefinedPixelTrait ?\n                  GrayscaleType : GrayscaleAlphaType;\n                break;\n              }\n              default:\n                break;\n            }\n            target_pixels=DestroyPixelThreadSet(target_pixels);\n            source_pixels=DestroyPixelThreadSet(source_pixels);\n            transform=DestroyTransformThreadSet(transform);\n            if (cmsGetDeviceClass(source_profile) != cmsSigLinkClass)\n              status=SetImageProfile(image,name,profile,exception);\n            if (target_profile != (cmsHPROFILE) NULL)\n              (void) cmsCloseProfile(target_profile);\n          }\n        (void) cmsCloseProfile(source_profile);\n      }\n#endif\n    }\n  profile=DestroyStringInfo(profile);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e m o v e I m a g e P r o f i l e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  RemoveImageProfile() removes a named profile from the image and returns its\n%  value.\n%\n%  The format of the RemoveImageProfile method is:\n%\n%      void *RemoveImageProfile(Image *image,const char *name)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name.\n%\n*/\nMagickExport StringInfo *RemoveImageProfile(Image *image,const char *name)\n{\n  StringInfo\n    *profile;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return((StringInfo *) NULL);\n  WriteTo8BimProfile(image,name,(StringInfo *) NULL);\n  profile=(StringInfo *) RemoveNodeFromSplayTree((SplayTreeInfo *)\n    image->profiles,name);\n  return(profile);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   R e s e t P r o f i l e I t e r a t o r                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ResetImageProfileIterator() resets the image profile iterator.  Use it in\n%  conjunction with GetNextImageProfile() to iterate over all the profiles\n%  associated with an image.\n%\n%  The format of the ResetImageProfileIterator method is:\n%\n%      ResetImageProfileIterator(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void ResetImageProfileIterator(const Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    return;\n  ResetSplayTreeIterator((SplayTreeInfo *) image->profiles);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t I m a g e P r o f i l e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetImageProfile() adds a named profile to the image.  If a profile with the\n%  same name already exists, it is replaced.  This method differs from the\n%  ProfileImage() method in that it does not apply CMS color profiles.\n%\n%  The format of the SetImageProfile method is:\n%\n%      MagickBooleanType SetImageProfile(Image *image,const char *name,\n%        const StringInfo *profile)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o name: the profile name, for example icc, exif, and 8bim (8bim is the\n%      Photoshop wrapper for iptc profiles).\n%\n%    o profile: A StringInfo structure that contains the named profile.\n%\n*/\n\nstatic void *DestroyProfile(void *profile)\n{\n  return((void *) DestroyStringInfo((StringInfo *) profile));\n}\n\nstatic inline const unsigned char *ReadResourceByte(const unsigned char *p,\n  unsigned char *quantum)\n{\n  *quantum=(*p++);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceLong(const unsigned char *p,\n  unsigned int *quantum)\n{\n  *quantum=(size_t) (*p++ << 24);\n  *quantum|=(size_t) (*p++ << 16);\n  *quantum|=(size_t) (*p++ << 8);\n  *quantum|=(size_t) (*p++ << 0);\n  return(p);\n}\n\nstatic inline const unsigned char *ReadResourceShort(const unsigned char *p,\n  unsigned short *quantum)\n{\n  *quantum=(unsigned short) (*p++ << 8);\n  *quantum|=(unsigned short) (*p++ << 0);\n  return(p);\n}static inline void WriteResourceLong(unsigned char *p,\n  const unsigned int quantum)\n{\n  unsigned char\n    buffer[4];\n\n  buffer[0]=(unsigned char) (quantum >> 24);\n  buffer[1]=(unsigned char) (quantum >> 16);\n  buffer[2]=(unsigned char) (quantum >> 8);\n  buffer[3]=(unsigned char) quantum;\n  (void) CopyMagickMemory(p,buffer,4);\n}\n\nstatic void WriteTo8BimProfile(Image *image,const char *name,\n  const StringInfo *profile)\n{\n  const unsigned char\n    *datum,\n    *q;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  StringInfo\n    *profile_8bim;\n\n  ssize_t\n    count;\n\n  unsigned char\n    length_byte;\n\n  unsigned int\n    value;\n\n  unsigned short\n    id,\n    profile_id;\n\n  if (LocaleCompare(name,\"icc\") == 0)\n    profile_id=0x040f;\n  else\n    if (LocaleCompare(name,\"iptc\") == 0)\n      profile_id=0x0404;\n    else\n      if (LocaleCompare(name,\"xmp\") == 0)\n        profile_id=0x0424;\n      else\n        return;\n  profile_8bim=(StringInfo *) GetValueFromSplayTree((SplayTreeInfo *)\n    image->profiles,\"8bim\");\n  if (profile_8bim == (StringInfo *) NULL)\n    return;\n  datum=GetStringInfoDatum(profile_8bim);\n  length=GetStringInfoLength(profile_8bim);\n  for (p=datum; p < (datum+length-16); )\n  {\n    q=p;\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((count & 0x01) != 0)\n      count++;\n    if ((count < 0) || (p > (datum+length-count)) ||\n        (count > (ssize_t) length))\n      break;\n    if (id != profile_id)\n      p+=count;\n    else\n      {\n        size_t\n          extent,\n          offset;\n\n        ssize_t\n          extract_count;\n\n        StringInfo\n          *extract_profile;\n\n        extract_count=0;\n        extent=(datum+length)-(p+count);\n        if (profile == (StringInfo *) NULL)\n          {\n            offset=(q-datum);\n            extract_profile=AcquireStringInfo(offset+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset);\n          }\n        else\n          {\n            offset=(p-datum);\n            extract_count=profile->length;\n            if ((extract_count & 0x01) != 0)\n              extract_count++;\n            extract_profile=AcquireStringInfo(offset+extract_count+extent);\n            (void) CopyMagickMemory(extract_profile->datum,datum,offset-4);\n            WriteResourceLong(extract_profile->datum+offset-4,\n              (unsigned int)profile->length);\n            (void) CopyMagickMemory(extract_profile->datum+offset,\n              profile->datum,profile->length);\n          }\n        (void) CopyMagickMemory(extract_profile->datum+offset+extract_count,\n          p+count,extent);\n        (void) AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n          ConstantString(\"8bim\"),CloneStringInfo(extract_profile));\n        extract_profile=DestroyStringInfo(extract_profile);\n        break;\n      }\n  }\n}\n\nstatic void GetProfilesFromResourceBlock(Image *image,\n  const StringInfo *resource_block,ExceptionInfo *exception)\n{\n  const unsigned char\n    *datum;\n\n  register const unsigned char\n    *p;\n\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  StringInfo\n    *profile;\n\n  unsigned char\n    length_byte;\n\n   unsigned int\n     value;\n\n  unsigned short\n    id;\n\n  datum=GetStringInfoDatum(resource_block);\n  length=GetStringInfoLength(resource_block);\n  for (p=datum; p < (datum+length-16); )\n  {\n    if (LocaleNCompare((char *) p,\"8BIM\",4) != 0)\n      break;\n    p+=4;\n    p=ReadResourceShort(p,&id);\n    p=ReadResourceByte(p,&length_byte);\n    p+=length_byte;\n    if (((length_byte+1) & 0x01) != 0)\n      p++;\n    if (p > (datum+length-4))\n      break;\n    p=ReadResourceLong(p,&value);\n    count=(ssize_t) value;\n    if ((p > (datum+length-count)) || (count > (ssize_t) length) ||\n        (count < 0))\n      break;\n    switch (id)\n    {\n      case 0x03ed:\n      {\n        unsigned int\n          resolution;\n\n        unsigned short\n          units;\n\n        /*\n          Resolution.\n        */\n        p=ReadResourceLong(p,&resolution);\n        image->resolution.x=((double) resolution)/65536.0;\n        p=ReadResourceShort(p,&units)+2;\n        p=ReadResourceLong(p,&resolution)+4;\n        image->resolution.y=((double) resolution)/65536.0;\n        /*\n          Values are always stored as pixels per inch.\n        */\n        if ((ResolutionType) units != PixelsPerCentimeterResolution)\n          image->units=PixelsPerInchResolution;\n        else\n          {\n            image->units=PixelsPerCentimeterResolution;\n            image->resolution.x/=2.54;\n            image->resolution.y/=2.54;\n          }\n        break;\n      }\n      case 0x0404:\n      {\n        /*\n          IPTC Profile\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"iptc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x040c:\n      {\n        /*\n          Thumbnail.\n        */\n        p+=count;\n        break;\n      }\n      case 0x040f:\n      {\n        /*\n          ICC Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"icc\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0422:\n      {\n        /*\n          EXIF Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"exif\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      case 0x0424:\n      {\n        /*\n          XMP Profile.\n        */\n        profile=AcquireStringInfo(count);\n        SetStringInfoDatum(profile,p);\n        (void) SetImageProfileInternal(image,\"xmp\",profile,MagickTrue,\n          exception);\n        profile=DestroyStringInfo(profile);\n        p+=count;\n        break;\n      }\n      default:\n      {\n        p+=count;\n        break;\n      }\n    }\n    if ((count & 0x01) != 0)\n      p++;\n  }\n}\n\nstatic MagickBooleanType SetImageProfileInternal(Image *image,const char *name,\n  const StringInfo *profile,const MagickBooleanType recursive,\n  ExceptionInfo *exception)\n{\n  char\n    key[MagickPathExtent],\n    property[MagickPathExtent];\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->profiles == (SplayTreeInfo *) NULL)\n    image->profiles=NewSplayTree(CompareSplayTreeString,RelinquishMagickMemory,\n      DestroyProfile);\n  (void) CopyMagickString(key,name,MagickPathExtent);\n  LocaleLower(key);\n  status=AddValueToSplayTree((SplayTreeInfo *) image->profiles,\n    ConstantString(key),CloneStringInfo(profile));\n  if (status != MagickFalse)\n    {\n      if (LocaleCompare(name,\"8bim\") == 0)\n        GetProfilesFromResourceBlock(image,profile,exception);\n      else if (recursive == MagickFalse)\n        WriteTo8BimProfile(image,name,profile);\n    }\n  /*\n    Inject profile into image properties.\n  */\n  (void) FormatLocaleString(property,MagickPathExtent,\"%s:*\",name);\n  (void) GetImageProperty(image,property,exception);\n  return(status);\n}\n\nMagickExport MagickBooleanType SetImageProfile(Image *image,const char *name,\n  const StringInfo *profile,ExceptionInfo *exception)\n{\n  return(SetImageProfileInternal(image,name,profile,MagickFalse,exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c I m a g e P r o f i l e s                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImageProfiles() synchronizes image properties with the image profiles.\n%  Currently we only support updating the EXIF resolution and orientation.\n%\n%  The format of the SyncImageProfiles method is:\n%\n%      MagickBooleanType SyncImageProfiles(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nstatic inline int ReadProfileByte(unsigned char **p,size_t *length)\n{\n  int\n    c;\n\n  if (*length < 1)\n    return(EOF);\n  c=(int) (*(*p)++);\n  (*length)--;\n  return(c);\n}\n\nstatic inline unsigned short ReadProfileShort(const EndianType endian,\n  unsigned char *buffer)\n{\n  unsigned short\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned short) ((buffer[1] << 8) | buffer[0]);\n      return((unsigned short) (value & 0xffff));\n    }\n  value=(unsigned short) ((((unsigned char *) buffer)[0] << 8) |\n    ((unsigned char *) buffer)[1]);\n  return((unsigned short) (value & 0xffff));\n}\n\nstatic inline unsigned int ReadProfileLong(const EndianType endian,\n  unsigned char *buffer)\n{\n  unsigned int\n    value;\n\n  if (endian == LSBEndian)\n    {\n      value=(unsigned int) ((buffer[3] << 24) | (buffer[2] << 16) |\n        (buffer[1] << 8 ) | (buffer[0]));\n      return((unsigned int) (value & 0xffffffff));\n    }\n  value=(unsigned int) ((buffer[0] << 24) | (buffer[1] << 16) |\n    (buffer[2] << 8) | buffer[3]);\n  return((unsigned int) (value & 0xffffffff));\n}\n\nstatic inline unsigned int ReadProfileMSBLong(unsigned char **p,size_t *length)\n{\n  unsigned int\n    value;\n\n  if (*length < 4)\n    return(0);\n  value=ReadProfileLong(MSBEndian,*p);\n  (*length)-=4;\n  *p+=4;\n  return(value);\n}\n\nstatic inline unsigned short ReadProfileMSBShort(unsigned char **p,\n  size_t *length)\n{\n  unsigned short\n    value;\n\n  if (*length < 2)\n    return(0);\n  value=ReadProfileShort(MSBEndian,*p);\n  (*length)-=2;\n  *p+=2;\n  return(value);\n}\n\nstatic inline void WriteProfileLong(const EndianType endian,\n  const size_t value,unsigned char *p)\n{\n  unsigned char\n    buffer[4];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      buffer[2]=(unsigned char) (value >> 16);\n      buffer[3]=(unsigned char) (value >> 24);\n      (void) CopyMagickMemory(p,buffer,4);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 24);\n  buffer[1]=(unsigned char) (value >> 16);\n  buffer[2]=(unsigned char) (value >> 8);\n  buffer[3]=(unsigned char) value;\n  (void) CopyMagickMemory(p,buffer,4);\n}\n\nstatic void WriteProfileShort(const EndianType endian,\n  const unsigned short value,unsigned char *p)\n{\n  unsigned char\n    buffer[2];\n\n  if (endian == LSBEndian)\n    {\n      buffer[0]=(unsigned char) value;\n      buffer[1]=(unsigned char) (value >> 8);\n      (void) CopyMagickMemory(p,buffer,2);\n      return;\n    }\n  buffer[0]=(unsigned char) (value >> 8);\n  buffer[1]=(unsigned char) value;\n  (void) CopyMagickMemory(p,buffer,2);\n}\n\nstatic MagickBooleanType Sync8BimProfile(Image *image,StringInfo *profile)\n{\n  size_t\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    *p;\n\n  unsigned short\n    id;\n\n  length=GetStringInfoLength(profile);\n  p=GetStringInfoDatum(profile);\n  while (length != 0)\n  {\n    if (ReadProfileByte(&p,&length) != 0x38)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x42)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x49)\n      continue;\n    if (ReadProfileByte(&p,&length) != 0x4D)\n      continue;\n    if (length < 7)\n      return(MagickFalse);\n    id=ReadProfileMSBShort(&p,&length);\n    count=(ssize_t) ReadProfileByte(&p,&length);\n    if ((count > (ssize_t) length) || (count < 0))\n      return(MagickFalse);\n    p+=count;\n    if ((*p & 0x01) == 0)\n      (void) ReadProfileByte(&p,&length);\n    count=(ssize_t) ReadProfileMSBLong(&p,&length);\n    if ((count > (ssize_t) length) || (count < 0))\n      return(MagickFalse);\n    if ((id == 0x3ED) && (count == 16))\n      {\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.x*2.54*\n            65536.0),p);\n        else\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.x*\n            65536.0),p);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+4);\n        if (image->units == PixelsPerCentimeterResolution)\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.y*2.54*\n            65536.0),p+8);\n        else\n          WriteProfileLong(MSBEndian, (unsigned int) (image->resolution.y*\n            65536.0),p+8);\n        WriteProfileShort(MSBEndian,(unsigned short) image->units,p+12);\n      }\n    p+=count;\n    length-=count;\n  }\n  return(MagickTrue);\n}\n\nMagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ((int) ReadProfileLong(endian,exif+4));\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format-1) >= EXIF_NUM_FORMATS)\n        break;\n      components=(ssize_t) ((int) ReadProfileLong(endian,q+4));\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          ssize_t\n            offset;\n\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t) ((int) ReadProfileLong(endian,q+8));\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          ssize_t\n            offset;\n\n          offset=(ssize_t) ((int) ReadProfileLong(endian,p));\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t) ((int) ReadProfileLong(endian,directory+2+(12*\n                number_entries)));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}\n\nMagickPrivate MagickBooleanType SyncImageProfiles(Image *image)\n{\n  MagickBooleanType\n    status;\n\n  StringInfo\n    *profile;\n\n  status=MagickTrue;\n  profile=(StringInfo *) GetImageProfile(image,\"8BIM\");\n  if (profile != (StringInfo *) NULL)\n    if (Sync8BimProfile(image,profile) == MagickFalse)\n      status=MagickFalse;\n  profile=(StringInfo *) GetImageProfile(image,\"EXIF\");\n  if (profile != (StringInfo *) NULL)\n    if (SyncExifProfile(image,profile) == MagickFalse)\n      status=MagickFalse;\n  return(status);\n}\n"], "filenames": ["MagickCore/profile.c"], "buggy_code_start_loc": [1457], "buggy_code_end_loc": [1458], "fixing_code_start_loc": [1457], "fixing_code_end_loc": [1459], "type": "CWE-20", "message": "magick/profile.c in ImageMagick allows remote attackers to cause a denial of service (segmentation fault) via a crafted profile.", "other": {"cve": {"id": "CVE-2016-7536", "sourceIdentifier": "security@debian.org", "published": "2017-04-20T18:59:01.437", "lastModified": "2020-11-16T19:34:51.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "magick/profile.c in ImageMagick allows remote attackers to cause a denial of service (segmentation fault) via a crafted profile."}, {"lang": "es", "value": "magick/profile.c en ImageMagick permite a atacantes remotos provocar una denegaci\u00f3n de servicio (error de segmentaci\u00f3n) a trav\u00e9s de un perfil manipulado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:-:*:*:*:*:*:*:*", "matchCriteriaId": "6E6BE7A5-6FF7-4916-B671-9EE11CA54F65"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/09/22/2", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93225", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.launchpad.net/ubuntu/+source/imagemagick/+bug/1545367", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1378772", "source": "security@debian.org", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/02dadf116124cfba35d7ebd9ced3e5ad0be0f176", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/478cce544fdf1de882d78381768458f397964453", "source": "security@debian.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/130", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/02dadf116124cfba35d7ebd9ced3e5ad0be0f176"}}