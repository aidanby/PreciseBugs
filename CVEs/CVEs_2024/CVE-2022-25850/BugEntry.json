{"buggy_code": ["package libproxy\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype statusChangeFunction func(status string, isListening bool)\n\nvar (\n\taccessToken        string\n\tsessionFingerprint string\n\tallowedOrigins     []string\n\tbannedOutputs      []string\n)\n\ntype Request struct {\n\tAccessToken string\n\tWantsBinary bool\n\tMethod      string\n\tUrl         string\n\tAuth        struct {\n\t\tUsername string\n\t\tPassword string\n\t}\n\tHeaders map[string]string\n\tData    string\n\tParams  map[string]string\n}\n\ntype Response struct {\n\tSuccess    bool              `json:\"success\"`\n\tIsBinary   bool              `json:\"isBinary\"`\n\tStatus     int               `json:\"status\"`\n\tData       string            `json:\"data\"`\n\tStatusText string            `json:\"statusText\"`\n\tHeaders    map[string]string `json:\"headers\"`\n}\n\nfunc isAllowedOrigin(origin string) bool {\n\tif allowedOrigins[0] == \"*\" {\n\t\treturn true\n\t}\n\n\tfor _, b := range allowedOrigins {\n\t\tif b == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc Initialize(\n\tinitialAccessToken string,\n\tproxyURL string,\n\tinitialAllowedOrigins string,\n\tinitialBannedOutputs string,\n\tonStatusChange statusChangeFunction,\n\twithSSL bool,\n\tfinished chan bool,\n) {\n\tif initialBannedOutputs != \"\" {\n\t\tbannedOutputs = strings.Split(initialBannedOutputs, \",\")\n\t}\n\tallowedOrigins = strings.Split(initialAllowedOrigins, \",\")\n\taccessToken = initialAccessToken\n\tsessionFingerprint = uuid.New().String()\n\tlog.Println(\"Starting proxy server...\")\n\n\thttp.HandleFunc(\"/\", proxyHandler)\n\n\tif !withSSL {\n\t\tgo func() {\n\t\t\thttpServerError := http.ListenAndServe(proxyURL, nil)\n\n\t\t\tif httpServerError != nil {\n\t\t\t\tonStatusChange(\"An error occurred: \"+httpServerError.Error(), false)\n\t\t\t}\n\n\t\t\tfinished <- true\n\t\t}()\n\n\t\tonStatusChange(\"Listening on http://\"+proxyURL+\"/\", true)\n\t} else {\n\t\tonStatusChange(\"Checking SSL certificate...\", false)\n\n\t\terr := EnsurePrivateKeyInstalled()\n\t\tif err != nil {\n\t\t\tlog.Println(err.Error())\n\t\t\tonStatusChange(\"An error occurred.\", false)\n\t\t}\n\n\t\tgo func() {\n\t\t\thttpServerError := http.ListenAndServeTLS(proxyURL, GetOrCreateDataPath()+\"/cert.pem\", GetOrCreateDataPath()+\"/key.pem\", nil)\n\n\t\t\tif httpServerError != nil {\n\t\t\t\tonStatusChange(\"An error occurred.\", false)\n\t\t\t}\n\t\t}()\n\n\t\tonStatusChange(\"Listening on https://\"+proxyURL+\"/\", true)\n\t\tlog.Println(\"Proxy server listening on https://\" + proxyURL + \"/\")\n\t}\n}\n\nfunc GetAccessToken() string {\n\treturn accessToken\n}\n\nfunc SetAccessToken(newAccessToken string) {\n\taccessToken = newAccessToken\n}\n\nconst ErrorBodyInvalidRequest = \"{\\\"success\\\": false, \\\"data\\\":{\\\"message\\\":\\\"(Proxy Error) Invalid request.\\\"}}\"\nconst ErrorBodyProxyRequestFailed = \"{\\\"success\\\": false, \\\"data\\\":{\\\"message\\\":\\\"(Proxy Error) Request failed.\\\"}}\"\nconst maxMemory = int64(32 << 20) // multipartRequestDataKey currently its 32 MB\n\nfunc proxyHandler(response http.ResponseWriter, request *http.Request) {\n\t// We want to allow all types of requests to the proxy, though we only want to allow certain\n\t// origins.\n\tresponse.Header().Add(\"Access-Control-Allow-Headers\", \"*\")\n\tif request.Method == \"OPTIONS\" {\n\t\tresponse.Header().Add(\"Access-Control-Allow-Origin\", \"*\")\n\t\tresponse.WriteHeader(200)\n\t\treturn\n\t}\n\n\tif request.Header.Get(\"Origin\") == \"\" || !isAllowedOrigin(request.Header.Get(\"Origin\")) {\n\t\tif strings.HasPrefix(request.Header.Get(\"Content-Type\"), \"application/json\") {\n\t\t\tresponse.Header().Add(\"Access-Control-Allow-Headers\", \"*\")\n\t\t\tresponse.Header().Add(\"Access-Control-Allow-Origin\", \"*\")\n\t\t\tresponse.WriteHeader(200)\n\t\t\t_, _ = fmt.Fprintln(response, ErrorBodyProxyRequestFailed)\n\t\t\treturn\n\t\t}\n\n\t\t// If it is not an allowed origin, redirect back to hoppscotch.io.\n\t\tresponse.Header().Add(\"Location\", \"https://hoppscotch.io/\")\n\t\tresponse.WriteHeader(301)\n\t\treturn\n\t} else {\n\t\t// Otherwise set the appropriate CORS polciy and continue.\n\t\tresponse.Header().Add(\"Access-Control-Allow-Origin\", request.Header.Get(\"Origin\"))\n\t}\n\n\t// For anything other than an POST request, we'll return an empty JSON object.\n\tresponse.Header().Add(\"Content-Type\", \"application/json; charset=utf-8\")\n\tif request.Method != \"POST\" {\n\t\t_, _ = fmt.Fprintln(response, \"{\\\"success\\\": true, \\\"data\\\":{\\\"sessionFingerprint\\\":\\\"\"+sessionFingerprint+\"\\\", \\\"isProtected\\\":\"+strconv.FormatBool(len(accessToken) > 0)+\"}}\")\n\t\treturn\n\t}\n\n\t// Attempt to parse request body.\n\tvar requestData Request\n\tisMultipart := strings.HasPrefix(request.Header.Get(\"content-type\"), \"multipart/form-data\")\n\tvar multipartRequestDataKey = request.Header.Get(\"multipart-part-key\")\n\tif multipartRequestDataKey == \"\" {\n\t\tmultipartRequestDataKey = \"proxyRequestData\"\n\t}\n\tif isMultipart {\n\t\tvar err = request.ParseMultipartForm(maxMemory)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to parse request body: %v\", err)\n\t\t\t_, _ = fmt.Fprintln(response, ErrorBodyInvalidRequest)\n\t\t\treturn\n\t\t}\n\t\tr := request.MultipartForm.Value[multipartRequestDataKey]\n\t\terr = json.Unmarshal([]byte(r[0]), &requestData)\n\t\tif err != nil || len(requestData.Url) == 0 || len(requestData.Method) == 0 {\n\t\t\t// If the logged err is nil here, it means either the URL or method were not supplied\n\t\t\t// in the request data.\n\t\t\tlog.Printf(\"Failed to parse request body: %v\", err)\n\t\t\t_, _ = fmt.Fprintln(response, ErrorBodyInvalidRequest)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tvar err = json.NewDecoder(request.Body).Decode(&requestData)\n\t\tif err != nil || len(requestData.Url) == 0 || len(requestData.Method) == 0 {\n\t\t\t// If the logged err is nil here, it means either the URL or method were not supplied\n\t\t\t// in the request data.\n\t\t\tlog.Printf(\"Failed to parse request body: %v\", err)\n\t\t\t_, _ = fmt.Fprintln(response, ErrorBodyInvalidRequest)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif len(accessToken) > 0 && requestData.AccessToken != accessToken {\n\t\tlog.Print(\"An unauthorized request was made.\")\n\t\t_, _ = fmt.Fprintln(response, \"{\\\"success\\\": false, \\\"data\\\":{\\\"message\\\":\\\"(Proxy Error) Unauthorized request; you may need to set your access token in Settings.\\\"}}\")\n\t\treturn\n\t}\n\n\t// Make the request\n\tvar proxyRequest http.Request\n\tproxyRequest.Header = make(http.Header)\n\tproxyRequest.Method = requestData.Method\n\tproxyRequest.URL, _ = url.Parse(requestData.Url)\n\n\tvar params = proxyRequest.URL.Query()\n\n\tfor k, v := range requestData.Params {\n\t\tparams.Set(k, v)\n\t}\n\tproxyRequest.URL.RawQuery = params.Encode()\n\n\tif len(requestData.Auth.Username) > 0 && len(requestData.Auth.Password) > 0 {\n\t\tproxyRequest.SetBasicAuth(requestData.Auth.Username, requestData.Auth.Password)\n\t}\n\tfor k, v := range requestData.Headers {\n\t\tproxyRequest.Header.Set(k, v)\n\t}\n\n\tproxyRequest.Header.Set(\"User-Agent\", \"Proxyscotch/1.1\")\n\n\tif isMultipart {\n\t\tbody := &bytes.Buffer{}\n\t\twriter := multipart.NewWriter(body)\n\t\tfor key := range request.MultipartForm.Value {\n\t\t\tif key == multipartRequestDataKey {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, val := range request.MultipartForm.Value[key] {\n\t\t\t\t// This usually never happens, mostly memory issue\n\t\t\t\terr := writer.WriteField(key, val)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to write multipart field key: %s error: %v\", key, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor fileKey := range request.MultipartForm.File {\n\t\t\tfor _, val := range request.MultipartForm.File[fileKey] {\n\t\t\t\tf, err := val.Open()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to write multipart field: %s err: %v\", fileKey, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfield, _ := writer.CreatePart(val.Header)\n\t\t\t\t_, err = io.Copy(field, f)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to write multipart field: %s err: %v\", fileKey, err)\n\t\t\t\t}\n\t\t\t\t// Close need not be handled, as go will clear temp file\n\t\t\t\tdefer func(f multipart.File) {\n\t\t\t\t\terr := f.Close()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Printf(\"Failed to close file\")\n\t\t\t\t\t}\n\t\t\t\t}(f)\n\t\t\t}\n\t\t}\n\t\terr := writer.Close()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to write multipart content: %v\", err)\n\t\t\t_, _ = fmt.Fprintf(response, ErrorBodyProxyRequestFailed)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tcontentType := fmt.Sprintf(\"multipart/form-data; boundary=%v\", writer.Boundary())\n\t\tproxyRequest.Header.Set(\"content-type\", contentType)\n\t\tproxyRequest.Body = ioutil.NopCloser(bytes.NewReader(body.Bytes()))\n\t\tproxyRequest.Body.Close()\n\t} else if len(requestData.Data) > 0 {\n\t\tproxyRequest.Body = ioutil.NopCloser(strings.NewReader(requestData.Data))\n\t\tproxyRequest.Body.Close()\n\t}\n\n\tvar client http.Client\n\tvar proxyResponse *http.Response\n\tproxyResponse, err := client.Do(&proxyRequest)\n\n\tif err != nil {\n\t\tlog.Print(\"Failed to write response body: \", err.Error())\n\t\t_, _ = fmt.Fprintln(response, ErrorBodyProxyRequestFailed)\n\t\treturn\n\t}\n\n\tvar responseData Response\n\tresponseData.Success = true\n\tresponseData.Status = proxyResponse.StatusCode\n\tresponseData.StatusText = strings.Join(strings.Split(proxyResponse.Status, \" \")[1:], \" \")\n\tresponseBytes, err := ioutil.ReadAll(proxyResponse.Body)\n\tresponseData.Headers = headerToArray(proxyResponse.Header)\n\n\tif requestData.WantsBinary {\n\t\tfor _, bannedOutput := range bannedOutputs {\n\t\t\tresponseBytes = bytes.ReplaceAll(responseBytes, []byte(bannedOutput), []byte(\"[redacted]\"))\n\t\t}\n\n\t\t// If using the new binary format, encode the response body.\n\t\tresponseData.Data = base64.RawStdEncoding.EncodeToString(responseBytes)\n\t\tresponseData.IsBinary = true\n\t} else {\n\t\t// Otherwise, simply return the old format.\n\t\tresponseData.Data = string(responseBytes)\n\n\t\tfor _, bannedOutput := range bannedOutputs {\n\t\t\tresponseData.Data = strings.Replace(responseData.Data, bannedOutput, \"[redacted]\", -1)\n\t\t}\n\t}\n\n\t// Write the request body to the response.\n\terr = json.NewEncoder(response).Encode(responseData)\n\n\t// Return the response.\n\tif err != nil {\n\t\tlog.Print(\"Failed to write response body: \", err.Error())\n\t\t_, _ = fmt.Fprintln(response, ErrorBodyProxyRequestFailed)\n\t\treturn\n\t}\n}\n\n/// Converts http.Header to a map.\n/// Original Source: https://stackoverflow.com/a/37030039/2872279 (modified).\nfunc headerToArray(header http.Header) (res map[string]string) {\n\tres = make(map[string]string)\n\n\tfor name, values := range header {\n\t\tfor _, value := range values {\n\t\t\tres[strings.ToLower(name)] = value\n\t\t}\n\t}\n\n\treturn res\n}\n", "package main\n\nimport (\n\t\"flag\"\n\t\"log\"\n\n\t\"github.com/hoppscotch/proxyscotch/libproxy\"\n)\n\nfunc main() {\n\thostPtr := flag.String(\"host\", \"localhost:9159\", \"the hostname that the server should listen on.\")\n\ttokenPtr := flag.String(\"token\", \"\", \"the Proxy Access Token used to restrict access to the server.\")\n\tallowedOriginsPtr := flag.String(\"allowed-origins\", \"*\", \"a comma separated list of allowed origins.\")\n\tbannedOutputsPtr := flag.String(\"banned-outputs\", \"\", \"a comma separated list of banned outputs.\")\n\tflag.Parse()\n\n\tfinished := make(chan bool)\n\tlibproxy.Initialize(*tokenPtr, *hostPtr, *allowedOriginsPtr, *bannedOutputsPtr, onProxyStateChangeServer, false, finished)\n\n\t<-finished\n}\n\nfunc onProxyStateChangeServer(status string, isListening bool) {\n\tlog.Printf(\"[ready=%v] %s\", isListening, status)\n}\n"], "fixing_code": ["package libproxy\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/google/uuid\"\n)\n\ntype statusChangeFunction func(status string, isListening bool)\n\nvar (\n\taccessToken        string\n\tsessionFingerprint string\n\tallowedOrigins     []string\n\tbannedOutputs      []string\n\tbannedDests        []string\n)\n\ntype Request struct {\n\tAccessToken string\n\tWantsBinary bool\n\tMethod      string\n\tUrl         string\n\tAuth        struct {\n\t\tUsername string\n\t\tPassword string\n\t}\n\tHeaders map[string]string\n\tData    string\n\tParams  map[string]string\n}\n\ntype Response struct {\n\tSuccess    bool              `json:\"success\"`\n\tIsBinary   bool              `json:\"isBinary\"`\n\tStatus     int               `json:\"status\"`\n\tData       string            `json:\"data\"`\n\tStatusText string            `json:\"statusText\"`\n\tHeaders    map[string]string `json:\"headers\"`\n}\n\nfunc isAllowedDest(dest string) bool {\n\tfor _, b := range bannedDests {\n\t\tif b == dest {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc isAllowedOrigin(origin string) bool {\n\tif allowedOrigins[0] == \"*\" {\n\t\treturn true\n\t}\n\n\tfor _, b := range allowedOrigins {\n\t\tif b == origin {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\nfunc Initialize(\n\tinitialAccessToken string,\n\tproxyURL string,\n\tinitialAllowedOrigins string,\n\tinitialBannedOutputs string,\n\tinitialBannedDests string,\n\tonStatusChange statusChangeFunction,\n\twithSSL bool,\n\tfinished chan bool,\n) {\n\tif initialBannedOutputs != \"\" {\n\t\tbannedOutputs = strings.Split(initialBannedOutputs, \",\")\n\t}\n\tif initialBannedDests != \"\" {\n\t\tbannedDests = strings.Split(initialBannedDests, \",\")\n\t} else {\n\t\tbannedDests = []string{}\n\t}\n\tallowedOrigins = strings.Split(initialAllowedOrigins, \",\")\n\taccessToken = initialAccessToken\n\tsessionFingerprint = uuid.New().String()\n\tlog.Println(\"Starting proxy server...\")\n\n\thttp.HandleFunc(\"/\", proxyHandler)\n\n\tif !withSSL {\n\t\tgo func() {\n\t\t\thttpServerError := http.ListenAndServe(proxyURL, nil)\n\n\t\t\tif httpServerError != nil {\n\t\t\t\tonStatusChange(\"An error occurred: \"+httpServerError.Error(), false)\n\t\t\t}\n\n\t\t\tfinished <- true\n\t\t}()\n\n\t\tonStatusChange(\"Listening on http://\"+proxyURL+\"/\", true)\n\t} else {\n\t\tonStatusChange(\"Checking SSL certificate...\", false)\n\n\t\terr := EnsurePrivateKeyInstalled()\n\t\tif err != nil {\n\t\t\tlog.Println(err.Error())\n\t\t\tonStatusChange(\"An error occurred.\", false)\n\t\t}\n\n\t\tgo func() {\n\t\t\thttpServerError := http.ListenAndServeTLS(proxyURL, GetOrCreateDataPath()+\"/cert.pem\", GetOrCreateDataPath()+\"/key.pem\", nil)\n\n\t\t\tif httpServerError != nil {\n\t\t\t\tonStatusChange(\"An error occurred.\", false)\n\t\t\t}\n\t\t}()\n\n\t\tonStatusChange(\"Listening on https://\"+proxyURL+\"/\", true)\n\t\tlog.Println(\"Proxy server listening on https://\" + proxyURL + \"/\")\n\t}\n}\n\nfunc GetAccessToken() string {\n\treturn accessToken\n}\n\nfunc SetAccessToken(newAccessToken string) {\n\taccessToken = newAccessToken\n}\n\nconst ErrorBodyInvalidRequest = \"{\\\"success\\\": false, \\\"data\\\":{\\\"message\\\":\\\"(Proxy Error) Invalid request.\\\"}}\"\nconst ErrorBodyProxyRequestFailed = \"{\\\"success\\\": false, \\\"data\\\":{\\\"message\\\":\\\"(Proxy Error) Request failed.\\\"}}\"\nconst maxMemory = int64(32 << 20) // multipartRequestDataKey currently its 32 MB\n\nfunc proxyHandler(response http.ResponseWriter, request *http.Request) {\n\t// We want to allow all types of requests to the proxy, though we only want to allow certain\n\t// origins.\n\tresponse.Header().Add(\"Access-Control-Allow-Headers\", \"*\")\n\tif request.Method == \"OPTIONS\" {\n\t\tresponse.Header().Add(\"Access-Control-Allow-Origin\", \"*\")\n\t\tresponse.WriteHeader(200)\n\t\treturn\n\t}\n\n\tif request.Header.Get(\"Origin\") == \"\" || !isAllowedOrigin(request.Header.Get(\"Origin\")) {\n\t\tif strings.HasPrefix(request.Header.Get(\"Content-Type\"), \"application/json\") {\n\t\t\tresponse.Header().Add(\"Access-Control-Allow-Headers\", \"*\")\n\t\t\tresponse.Header().Add(\"Access-Control-Allow-Origin\", \"*\")\n\t\t\tresponse.WriteHeader(200)\n\t\t\t_, _ = fmt.Fprintln(response, ErrorBodyProxyRequestFailed)\n\t\t\treturn\n\t\t}\n\n\t\t// If it is not an allowed origin, redirect back to hoppscotch.io.\n\t\tresponse.Header().Add(\"Location\", \"https://hoppscotch.io/\")\n\t\tresponse.WriteHeader(301)\n\t\treturn\n\t} else {\n\t\t// Otherwise set the appropriate CORS polciy and continue.\n\t\tresponse.Header().Add(\"Access-Control-Allow-Origin\", request.Header.Get(\"Origin\"))\n\t}\n\n\t// For anything other than an POST request, we'll return an empty JSON object.\n\tresponse.Header().Add(\"Content-Type\", \"application/json; charset=utf-8\")\n\tif request.Method != \"POST\" {\n\t\t_, _ = fmt.Fprintln(response, \"{\\\"success\\\": true, \\\"data\\\":{\\\"sessionFingerprint\\\":\\\"\"+sessionFingerprint+\"\\\", \\\"isProtected\\\":\"+strconv.FormatBool(len(accessToken) > 0)+\"}}\")\n\t\treturn\n\t}\n\n\t// Attempt to parse request body.\n\tvar requestData Request\n\tisMultipart := strings.HasPrefix(request.Header.Get(\"content-type\"), \"multipart/form-data\")\n\tvar multipartRequestDataKey = request.Header.Get(\"multipart-part-key\")\n\tif multipartRequestDataKey == \"\" {\n\t\tmultipartRequestDataKey = \"proxyRequestData\"\n\t}\n\tif isMultipart {\n\t\tvar err = request.ParseMultipartForm(maxMemory)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to parse request body: %v\", err)\n\t\t\t_, _ = fmt.Fprintln(response, ErrorBodyInvalidRequest)\n\t\t\treturn\n\t\t}\n\t\tr := request.MultipartForm.Value[multipartRequestDataKey]\n\t\terr = json.Unmarshal([]byte(r[0]), &requestData)\n\t\tif err != nil || len(requestData.Url) == 0 || len(requestData.Method) == 0 {\n\t\t\t// If the logged err is nil here, it means either the URL or method were not supplied\n\t\t\t// in the request data.\n\t\t\tlog.Printf(\"Failed to parse request body: %v\", err)\n\t\t\t_, _ = fmt.Fprintln(response, ErrorBodyInvalidRequest)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\tvar err = json.NewDecoder(request.Body).Decode(&requestData)\n\t\tif err != nil || len(requestData.Url) == 0 || len(requestData.Method) == 0 {\n\t\t\t// If the logged err is nil here, it means either the URL or method were not supplied\n\t\t\t// in the request data.\n\t\t\tlog.Printf(\"Failed to parse request body: %v\", err)\n\t\t\t_, _ = fmt.Fprintln(response, ErrorBodyInvalidRequest)\n\t\t\treturn\n\t\t}\n\t}\n\n\tif len(accessToken) > 0 && requestData.AccessToken != accessToken {\n\t\tlog.Print(\"An unauthorized request was made.\")\n\t\t_, _ = fmt.Fprintln(response, \"{\\\"success\\\": false, \\\"data\\\":{\\\"message\\\":\\\"(Proxy Error) Unauthorized request; you may need to set your access token in Settings.\\\"}}\")\n\t\treturn\n\t}\n\n\t// Make the request\n\tvar proxyRequest http.Request\n\tproxyRequest.Header = make(http.Header)\n\tproxyRequest.Method = requestData.Method\n\tproxyRequest.URL, _ = url.Parse(requestData.Url)\n\n\t// Block requests to illegal destinations\n\tif !isAllowedDest(proxyRequest.URL.Hostname()) {\n\t\tlog.Print(\"A request to a banned destination was made.\")\n\t\t_, _ = fmt.Fprintln(response, \"{\\\"success\\\": false, \\\"data\\\":{\\\"message\\\":\\\"(Proxy Error) Request cannot be to this destination.\\\"}}\")\n\t\treturn\n\t}\n\n\tvar params = proxyRequest.URL.Query()\n\n\tfor k, v := range requestData.Params {\n\t\tparams.Set(k, v)\n\t}\n\tproxyRequest.URL.RawQuery = params.Encode()\n\n\tif len(requestData.Auth.Username) > 0 && len(requestData.Auth.Password) > 0 {\n\t\tproxyRequest.SetBasicAuth(requestData.Auth.Username, requestData.Auth.Password)\n\t}\n\tfor k, v := range requestData.Headers {\n\t\tproxyRequest.Header.Set(k, v)\n\t}\n\n\tproxyRequest.Header.Set(\"User-Agent\", \"Proxyscotch/1.1\")\n\n\tif isMultipart {\n\t\tbody := &bytes.Buffer{}\n\t\twriter := multipart.NewWriter(body)\n\t\tfor key := range request.MultipartForm.Value {\n\t\t\tif key == multipartRequestDataKey {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfor _, val := range request.MultipartForm.Value[key] {\n\t\t\t\t// This usually never happens, mostly memory issue\n\t\t\t\terr := writer.WriteField(key, val)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to write multipart field key: %s error: %v\", key, err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor fileKey := range request.MultipartForm.File {\n\t\t\tfor _, val := range request.MultipartForm.File[fileKey] {\n\t\t\t\tf, err := val.Open()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to write multipart field: %s err: %v\", fileKey, err)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfield, _ := writer.CreatePart(val.Header)\n\t\t\t\t_, err = io.Copy(field, f)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Failed to write multipart field: %s err: %v\", fileKey, err)\n\t\t\t\t}\n\t\t\t\t// Close need not be handled, as go will clear temp file\n\t\t\t\tdefer func(f multipart.File) {\n\t\t\t\t\terr := f.Close()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tlog.Printf(\"Failed to close file\")\n\t\t\t\t\t}\n\t\t\t\t}(f)\n\t\t\t}\n\t\t}\n\t\terr := writer.Close()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to write multipart content: %v\", err)\n\t\t\t_, _ = fmt.Fprintf(response, ErrorBodyProxyRequestFailed)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tcontentType := fmt.Sprintf(\"multipart/form-data; boundary=%v\", writer.Boundary())\n\t\tproxyRequest.Header.Set(\"content-type\", contentType)\n\t\tproxyRequest.Body = ioutil.NopCloser(bytes.NewReader(body.Bytes()))\n\t\tproxyRequest.Body.Close()\n\t} else if len(requestData.Data) > 0 {\n\t\tproxyRequest.Body = ioutil.NopCloser(strings.NewReader(requestData.Data))\n\t\tproxyRequest.Body.Close()\n\t}\n\n\tvar client http.Client\n\tvar proxyResponse *http.Response\n\tproxyResponse, err := client.Do(&proxyRequest)\n\n\tif err != nil {\n\t\tlog.Print(\"Failed to write response body: \", err.Error())\n\t\t_, _ = fmt.Fprintln(response, ErrorBodyProxyRequestFailed)\n\t\treturn\n\t}\n\n\tvar responseData Response\n\tresponseData.Success = true\n\tresponseData.Status = proxyResponse.StatusCode\n\tresponseData.StatusText = strings.Join(strings.Split(proxyResponse.Status, \" \")[1:], \" \")\n\tresponseBytes, err := ioutil.ReadAll(proxyResponse.Body)\n\tresponseData.Headers = headerToArray(proxyResponse.Header)\n\n\tif requestData.WantsBinary {\n\t\tfor _, bannedOutput := range bannedOutputs {\n\t\t\tresponseBytes = bytes.ReplaceAll(responseBytes, []byte(bannedOutput), []byte(\"[redacted]\"))\n\t\t}\n\n\t\t// If using the new binary format, encode the response body.\n\t\tresponseData.Data = base64.RawStdEncoding.EncodeToString(responseBytes)\n\t\tresponseData.IsBinary = true\n\t} else {\n\t\t// Otherwise, simply return the old format.\n\t\tresponseData.Data = string(responseBytes)\n\n\t\tfor _, bannedOutput := range bannedOutputs {\n\t\t\tresponseData.Data = strings.Replace(responseData.Data, bannedOutput, \"[redacted]\", -1)\n\t\t}\n\t}\n\n\t// Write the request body to the response.\n\terr = json.NewEncoder(response).Encode(responseData)\n\n\t// Return the response.\n\tif err != nil {\n\t\tlog.Print(\"Failed to write response body: \", err.Error())\n\t\t_, _ = fmt.Fprintln(response, ErrorBodyProxyRequestFailed)\n\t\treturn\n\t}\n}\n\n/// Converts http.Header to a map.\n/// Original Source: https://stackoverflow.com/a/37030039/2872279 (modified).\nfunc headerToArray(header http.Header) (res map[string]string) {\n\tres = make(map[string]string)\n\n\tfor name, values := range header {\n\t\tfor _, value := range values {\n\t\t\tres[strings.ToLower(name)] = value\n\t\t}\n\t}\n\n\treturn res\n}\n", "package main\n\nimport (\n\t\"flag\"\n\t\"log\"\n\n\t\"github.com/hoppscotch/proxyscotch/libproxy\"\n)\n\nfunc main() {\n\thostPtr := flag.String(\"host\", \"localhost:9159\", \"the hostname that the server should listen on.\")\n\ttokenPtr := flag.String(\"token\", \"\", \"the Proxy Access Token used to restrict access to the server.\")\n\tallowedOriginsPtr := flag.String(\"allowed-origins\", \"*\", \"a comma separated list of allowed origins.\")\n\tbannedOutputsPtr := flag.String(\"banned-outputs\", \"\", \"a comma separated list of banned outputs.\")\n\tbannedDestsPtr := flag.String(\"banned-dests\", \"\", \"a comma separated list of banned proxy destinations.\")\n\n\tflag.Parse()\n\n\tfinished := make(chan bool)\n\tlibproxy.Initialize(*tokenPtr, *hostPtr, *allowedOriginsPtr, *bannedOutputsPtr, *bannedDestsPtr, onProxyStateChangeServer, false, finished)\n\n\t<-finished\n}\n\nfunc onProxyStateChangeServer(status string, isListening bool) {\n\tlog.Printf(\"[ready=%v] %s\", isListening, status)\n}\n"], "filenames": ["libproxy/proxy.go", "server/server.go"], "buggy_code_start_loc": [26, 14], "buggy_code_end_loc": [210, 19], "fixing_code_start_loc": [27, 15], "fixing_code_end_loc": [235, 21], "type": "CWE-918", "message": "The package github.com/hoppscotch/proxyscotch before 1.0.0 are vulnerable to Server-side Request Forgery (SSRF) when interceptor mode is set to proxy. It occurs when an HTTP request is made by a backend server to an untrusted URL submitted by a user. It leads to a leakage of sensitive information from the server.", "other": {"cve": {"id": "CVE-2022-25850", "sourceIdentifier": "report@snyk.io", "published": "2022-05-01T16:15:08.823", "lastModified": "2022-05-11T17:41:01.270", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package github.com/hoppscotch/proxyscotch before 1.0.0 are vulnerable to Server-side Request Forgery (SSRF) when interceptor mode is set to proxy. It occurs when an HTTP request is made by a backend server to an untrusted URL submitted by a user. It leads to a leakage of sensitive information from the server."}, {"lang": "es", "value": "El paquete github.com/hoppscotch/proxyscotch versiones anteriores a 1.0.0, es vulnerable a un ataque de tipo Server-side Request Forgery (SSRF) cuando el modo de intercepci\u00f3n es establecido como proxy. Es  producido cuando un servidor backend realiza una petici\u00f3n HTTP a una URL no confiable enviada por un usuario. Conlleva a un filtrado de informaci\u00f3n confidencial del servidor"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:proxyscotch_project:proxyscotch:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.0", "matchCriteriaId": "61062286-F52E-4251-8E69-95E8083C3B63"}]}]}], "references": [{"url": "https://github.com/hoppscotch/proxyscotch/commit/de67380f62f907f201d75854b76024ba4885fab7", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-GOLANG-GITHUBCOMHOPPSCOTCHPROXYSCOTCH-2435228", "source": "report@snyk.io", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/hoppscotch/proxyscotch/commit/de67380f62f907f201d75854b76024ba4885fab7"}}