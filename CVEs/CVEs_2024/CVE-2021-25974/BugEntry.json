{"buggy_code": ["# frozen_string_literal: true\n\n# Methods added to this helper will be available to all templates in the application.\nrequire \"digest/sha1\"\n\nmodule BaseHelper\n  include BlogHelper\n\n  # Need to rewrite this one, quick hack to test my changes.\n  attr_reader :page_title\n\n  def render_sidebars\n    rendered_sidebars = Sidebar.order(:active_position).map do |sb|\n      @sidebar = sb\n      sb.parse_request(content_array, params)\n      render_sidebar(sb)\n    end\n    safe_join rendered_sidebars\n  rescue => e\n    logger.error e\n    logger.error e.backtrace.join(\"\\n\")\n    I18n.t(\"errors.render_sidebar\")\n  end\n\n  def render_sidebar(sidebar)\n    render_to_string(partial: sidebar.content_partial, locals: sidebar.to_locals_hash,\n                     layout: false)\n  end\n\n  def themeable_stylesheet_link_tag(name)\n    src = this_blog.current_theme.path + \"/stylesheets/#{name}.css\"\n    stylesheet_link_tag \"/stylesheets/theme/#{name}.css\" if File.exist? src\n  end\n\n  def themeable_javascript_include_tag(name)\n    src = this_blog.current_theme.path + \"/javascripts/#{name}.js\"\n    javascript_include_tag \"/javascripts/theme/#{name}.js\" if File.exist? src\n  end\n\n  def render_to_string(*args, &block)\n    controller.send(:render_to_string, *args, &block)\n  end\n\n  def link_to_permalink(item, title, anchor = nil, style = nil, nofollow = nil,\n                        only_path = false)\n    options = {}\n    options[:class] = style if style\n    options[:rel] = \"nofollow\" if nofollow\n    url = item.permalink_url(anchor, only_path)\n    if url\n      link_to title, url, options\n    else\n      title\n    end\n  end\n\n  def avatar_tag(options = {})\n    begin\n      avatar_class = this_blog.plugin_avatar.constantize\n    rescue NameError\n      return \"\"\n    end\n    return \"\" unless avatar_class.respond_to?(:get_avatar)\n\n    avatar_class.get_avatar(options)\n  end\n\n  def meta_tag(name, value)\n    tag :meta, name: name, content: value if value.present?\n  end\n\n  def markup_help_popup(markup, text)\n    if markup && markup.commenthelp.size > 1\n      link_to(text,\n              url_for(controller: \"articles\", action: \"markup_help\", id: markup.name),\n              onclick: \"return popup(this, 'Publify Markup Help')\")\n    else\n      \"\"\n    end\n  end\n\n  def onhover_show_admin_tools(type, id = nil)\n    admin_id = \"#admin_#{[type, id].compact.join(\"_\")}\"\n    tag = []\n    tag << %{ onmouseover=\"if (getCookie('publify_user_profile') == 'admin')\\\n             { $('#{admin_id}').show(); }\" }\n    tag << %{ onmouseout=\"$('#{admin_id}').hide();\" }\n    safe_join(tag, \" \")\n  end\n\n  def feed_title\n    if @feed_title.present?\n      @feed_title\n    elsif @page_title.present?\n      @page_title\n    else\n      this_blog.blog_name\n    end\n  end\n\n  def html(content, what = :all, _deprecated = false)\n    content.html(what)\n  end\n\n  def display_user_avatar(user, size = \"avatar\", klass = \"alignleft\")\n    if user.resource.present?\n      avatar_path = case size\n                    when \"thumb\"\n                      user.resource.upload.thumb.url\n                    when \"medium\"\n                      user.resource.upload.medium.url\n                    when \"large\"\n                      user.resource.upload.large.url\n                    else\n                      user.resource.upload.avatar.url\n                    end\n      return if avatar_path.nil?\n\n      avatar_url = this_blog.file_url(avatar_path)\n    elsif user.twitter_profile_image.present?\n      avatar_url = user.twitter_profile_image\n    end\n    return unless avatar_url\n\n    image_tag(avatar_url, alt: user.nickname, class: klass)\n  end\n\n  def author_picture(status)\n    return if status.user.twitter_profile_image.blank?\n\n    image_tag(status.user.twitter_profile_image, class: \"alignleft\",\n                                                 alt: status.user.nickname)\n  end\n\n  def page_header_includes\n    content_array.map(&:whiteboard).map do |w|\n      w.select { |k, _v| k.start_with?(\"page_header_\") }.map do |_, v|\n        v = v.chomp\n        # trim the same number of spaces from the beginning of each line\n        # this way plugins can indent nicely without making ugly source output\n        spaces = /\\A[ \\t]*/.match(v)[0].gsub(/\\t/, \"  \")\n        # add 2 spaces to line up with the assumed position of the surrounding tags\n        v.gsub!(/^#{spaces}/, \"  \")\n      end\n    end.flatten.uniq.join(\"\\n\")\n  end\n\n  def feed_atom\n    feed_for(\"atom\")\n  end\n\n  def feed_rss\n    feed_for(\"rss\")\n  end\n\n  def content_array\n    if @articles\n      @articles\n    elsif @article\n      [@article]\n    elsif @page\n      [@page]\n    else\n      []\n    end\n  end\n\n  def display_date(date)\n    l(date, format: this_blog.date_format)\n  end\n\n  def display_time(time)\n    time.strftime(this_blog.time_format)\n  end\n\n  def display_date_and_time(timestamp)\n    return if timestamp.blank?\n\n    if this_blog.date_format == \"setting_date_format_distance_of_time_in_words\"\n      timeago_tag timestamp, date_only: false\n    else\n      \"#{display_date(timestamp)} #{t(\"helper.at\")} #{display_time(timestamp)}\"\n    end\n  end\n\n  def show_meta_keyword\n    return unless this_blog.use_meta_keyword\n\n    meta_tag \"keywords\", @keywords if @keywords.present?\n  end\n\n  def stop_index_robots?(blog)\n    stop = (params[:year].present? || params[:page].present?)\n    stop = blog.unindex_tags if controller_name == \"tags\"\n    stop = blog.unindex_categories if controller_name == \"categories\"\n    stop\n  end\n\n  def get_reply_context_url(reply)\n    link_to(reply[\"user\"][\"name\"],\n            reply[\"user\"][\"entities\"][\"url\"][\"urls\"][0][\"expanded_url\"])\n  rescue\n    link_to(reply[\"user\"][\"name\"], \"https://twitter.com/#{reply[\"user\"][\"name\"]}\")\n  end\n\n  def get_reply_context_twitter_link(reply)\n    link_to(display_date_and_time(reply[\"created_at\"].to_time.in_time_zone),\n            \"https://twitter.com/#{reply[\"user\"][\"screen_name\"]}/status/#{reply[\"id_str\"]}\")\n  end\n\n  private\n\n  def feed_for(type)\n    if params[:action] == \"search\"\n      url_for(only_path: false, format: type, q: params[:q])\n    elsif !@article.nil?\n      @article.feed_url(type)\n    elsif !@auto_discovery_url_atom.nil?\n      instance_variable_get(\"@auto_discovery_url_#{type}\")\n    end\n  end\n\n  # fetches appropriate html content for RSS and ATOM feeds. Checks for:\n  # - article being password protected\n  # - hiding extended content on RSS. In this case if there is an excerpt we\n  #   show the excerpt, or else we show the body\n  def fetch_html_content_for_feeds(item, this_blog)\n    if item.password_protected?\n      \"<p>This article is password protected. Please \" \\\n        \"<a href='#{item.permalink_url}'>fill in your password</a> to read it</p>\"\n    elsif this_blog.hide_extended_on_rss\n      if item.excerpt? && !item.excerpt.empty?\n        item.excerpt\n      else\n        html(item, :body)\n      end\n    else\n      html(item, :all)\n    end\n  end\n\n  def nofollowify_links(string)\n    if this_blog.dofollowify\n      string\n    else\n      string.gsub(/<a(.*?)>/i, '<a\\1 rel=\"nofollow\">')\n    end\n  end\n\n  def nofollowified_link_to(text, url)\n    if this_blog.dofollowify\n      link_to(text, url)\n    else\n      link_to(text, url, rel: \"nofollow\")\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule ContentBase\n  def self.included(base)\n    base.extend ClassMethods\n  end\n\n  attr_accessor :just_changed_published_status\n  alias just_changed_published_status? just_changed_published_status\n\n  def really_send_notifications\n    interested_users.each do |value|\n      send_notification_to_user(value)\n    end\n    true\n  end\n\n  def send_notification_to_user(user)\n    notify_user_via_email(user)\n  end\n\n  # Return HTML for some part of this object.\n  def html(field = :all)\n    if field == :all\n      generate_html(:all, content_fields.map { |f| self[f].to_s }.join(\"\\n\\n\"))\n    elsif html_map(field)\n      generate_html(field)\n    else\n      raise ArgumentError, \"Field #{field.inspect} is not valid for #{self.class}\"\n    end\n  end\n\n  # Generate HTML for a specific field using the text_filter in use for this\n  # object.\n  def generate_html(field, text = nil)\n    text ||= self[field].to_s\n    prehtml = html_preprocess(field, text).to_s\n    html = (text_filter || default_text_filter).filter_text(prehtml) || prehtml\n    html_postprocess(field, html).to_s\n  end\n\n  # Post-process the HTML.  This is a noop by default, but Comment overrides it\n  # to enforce HTML sanity.\n  def html_postprocess(_field, html)\n    html\n  end\n\n  def html_preprocess(_field, html)\n    html\n  end\n\n  def html_map(field)\n    content_fields.include? field\n  end\n\n  def excerpt_text(length = 160)\n    text = if respond_to?(:excerpt) && (excerpt || \"\") != \"\"\n             generate_html(:excerpt, excerpt)\n           else\n             html(:all)\n           end\n\n    text = text.strip_html\n\n    text.slice(0, length) +\n      (text.length > length ? \"...\" : \"\")\n  end\n\n  def text_filter\n    TextFilter.make_filter(text_filter_name)\n  end\n\n  # The default text filter.  Generally, this is the filter specified by blog.text_filter,\n  # but comments may use a different default.\n  def default_text_filter\n    blog.text_filter_object\n  end\n\n  module ClassMethods\n    def content_fields(*attribs)\n      class_eval \"def content_fields; #{attribs.inspect}; end\"\n    end\n\n    def default_order\n      \"published_at DESC\"\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"aasm\"\nrequire \"akismet\"\n\nclass Feedback < ApplicationRecord\n  self.table_name = \"feedback\"\n\n  belongs_to :article, touch: true\n\n  include PublifyGuid\n  include ContentBase\n\n  class ContentTextHelpers\n    include ActionView::Helpers::UrlHelper\n    include ActionView::Helpers::TextHelper\n    include ActionView::Helpers::SanitizeHelper\n  end\n\n  validate :feedback_not_closed, on: :create\n  validates :article, presence: true\n\n  before_save :correct_url, :classify_content\n  before_create :create_guid, :article_allows_this_feedback\n\n  # TODO: Rename so it doesn't sound like only approved ham\n  scope :ham, -> { where(state: %w(presumed_ham ham)) }\n\n  scope :spam, -> { where(state: \"spam\") }\n  scope :created_since, ->(time) { ham.where(\"created_at > ?\", time) }\n  scope :presumed_ham, -> { where(state: \"presumed_ham\") }\n  scope :presumed_spam, -> { where(state: \"presumed_spam\") }\n  scope :unapproved, -> { where(state: [\"presumed_spam\", \"presumed_ham\"]) }\n\n  scope :published, -> { ham }\n  scope :oldest_first, -> { order(:created_at) }\n  scope :newest_first, -> { order(created_at: :desc) }\n\n  include AASM\n\n  aasm column: :state do\n    state :unclassified, initial: true\n    state :presumed_ham\n    state :presumed_spam\n    state :spam, after_enter: [:send_notifications, :report_as_spam]\n    state :ham, after_enter: [:send_notifications, :report_as_ham]\n\n    event :presume_ham do\n      transitions from: :unclassified, to: :ham, if: ->() { user_id.present? }\n      transitions from: :unclassified, to: :presumed_ham\n    end\n\n    event :presume_spam do\n      transitions from: :unclassified, to: :presumed_spam\n    end\n\n    event :mark_as_ham do\n      transitions to: :ham\n    end\n\n    event :mark_as_spam do\n      transitions to: :spam\n    end\n\n    event :withdraw do\n      transitions from: [:presumed_ham, :ham], to: :spam\n    end\n  end\n\n  # FIXME: Inline this method\n  def self.paginated(page, per_page)\n    page(page).per(per_page)\n  end\n\n  def parent\n    article\n  end\n\n  def classify_content\n    return unless unclassified?\n\n    case classify\n    when :ham then presume_ham\n    else presume_spam\n    end\n  end\n\n  def permalink_url(_anchor = :ignored, only_path = false)\n    article.permalink_url(\"#{self.class.to_s.downcase}-#{id}\", only_path)\n  end\n\n  def html_postprocess(_field, html)\n    helper = ContentTextHelpers.new\n    helper.sanitize(helper.auto_link(html))\n  end\n\n  def correct_url\n    return if url.blank?\n\n    self.url = \"http://#{url}\" unless %r{^https?://}.match?(url)\n  end\n\n  def article_allows_this_feedback\n    article && blog_allows_feedback? && article_allows_feedback?\n  end\n\n  def blog_allows_feedback?\n    true\n  end\n\n  def akismet_options\n    { type: self.class.to_s.downcase,\n      author: originator,\n      author_email: email,\n      author_url: url,\n      text: body }\n  end\n\n  def spam_fields\n    [:title, :body, :ip, :url]\n  end\n\n  def classify\n    return :ham if user_id\n    return :spam if blog.default_moderate_comments\n    return :ham unless blog.sp_global\n\n    # Yeah, three state logic is evil...\n    case sp_is_spam? || akismet_is_spam?\n    when nil then :spam\n    when true then :spam\n    when false then :ham\n    end\n  end\n\n  def sp_is_spam?(_options = {})\n    sp = SpamProtection.new(blog)\n    Timeout.timeout(30) do\n      spam_fields.any? do |field|\n        sp.is_spam?(send(field))\n      end\n    end\n  rescue Timeout::Error\n    nil\n  end\n\n  def akismet_is_spam?(_options = {})\n    return false if akismet.nil?\n\n    begin\n      Timeout.timeout(60) do\n        akismet.comment_check(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def change_state!\n    result = \"\"\n    if spam? || presumed_spam?\n      mark_as_ham!\n      result = \"ham\"\n    else\n      mark_as_spam!\n      result = \"spam\"\n    end\n    result\n  end\n\n  def confirm_classification!\n    confirm_classification\n    save!\n  end\n\n  def confirm_classification\n    if presumed_spam?\n      mark_as_spam\n    elsif presumed_ham?\n      mark_as_ham\n    end\n  end\n\n  def report_as_spam\n    return if akismet.nil?\n\n    begin\n      Timeout.timeout(5) do\n        akismet.submit_spam(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def report_as_ham\n    return if akismet.nil?\n\n    begin\n      Timeout.timeout(5) do\n        akismet.ham(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def feedback_not_closed\n    errors.add(:article_id, \"Comment are closed\") if article.comments_closed?\n  end\n\n  def send_notifications\n    nil\n  end\n\n  def published?\n    ham? || presumed_ham?\n  end\n\n  def status_confirmed?\n    ham? || spam?\n  end\n\n  def spammy?\n    spam? || presumed_spam?\n  end\n\n  delegate :blog, to: :article\n\n  private\n\n  def akismet\n    @akismet ||= akismet_client\n  end\n\n  def akismet_client\n    return nil if blog.sp_akismet_key.blank?\n\n    client = Akismet::Client.new(blog.sp_akismet_key, blog.base_url)\n    begin\n      client.verify_key ? client : nil\n    rescue SocketError\n      nil\n    end\n  end\n\n  def blog_id\n    article.blog_id if article.present?\n  end\nend\n", "<% cache article do %>\n  <% if article.excerpt? %>\n    <%= article.excerpt %>\n    <div class=\"extended\">\n      <p><%= link_to_permalink article, t('.continue_reading') %></p>\n    </div>\n  <% else %>\n    <%= raw article.html(:body) %>\n    <% if article.extended? %>\n      <div class=\"extended\">\n        <p><%= link_to_permalink article, t('.continue_reading') %></p>\n      </div>\n    <% end %>\n  <% end %>\n<% end %>\n", "<% cache article do %>\n  <%= raw article.html(:body) %>\n  <%= raw article.html(:extended) %>\n<% end %>\n", "<div id=\"viewpage\">\n  <%= raw html @page %>\n</div>\n", "<% cache comment do %>\n  <li id=\"comment-<%= comment.id %>\" <%= 'class=\"author_comment\"' if comment.user %> <%= onhover_show_admin_tools(:comment, comment.id) %>>\n    <p class=\"author\">\n    <%= avatar_tag(email: comment.email, url: comment.url) %>\n    <cite><strong><%= link_to_unless(comment.url.blank?, h(comment.author), comment.url) %></strong></cite>\n    <%= t('.said') %> <%= display_date_and_time comment.created_at %>:\n    </p>\n    <div class=\"content\">\n      <%= raw nofollowify_links comment.generate_html(:body) %>\n      <% unless comment.published? %>\n        <div class=\"spamwarning\">\n          <%= t('.this_comment_has_been_flagged_for_moderator_approval') %>\n        </div>\n      <% end %>\n    </div>\n  </li>\n<% end %>\n", "<% cache [note, note.user] do %>\n  <article class='status'>\n    <%= author_picture note %>\n    <div class='p-name entry-title e-content entry-content article'><%= raw note.html(:body) %></div>\n    <footer>\n      <small>\n        <%= link_to_permalink(note, display_date_and_time(note.published_at)) %> |\n        <%= link_to note.redirect.from_url, note.redirect.from_url %> |\n        <%= author_link note %>\n        <% unless note.twitter_id.blank? %>\n          <%= \" | #{link_to(t('.view_on_twitter'), note.twitter_url, class: 'u-syndication', rel: 'syndication')}\" %>\n        <% end %>\n      </small>\n    </footer>\n  </article>\n<% end %>\n", "<div class=\"hfeed\">\n  <% for note in @notes %>\n  <div class='h-entry hentry h-as-note'>\n    <article>\n      <p class='p-name entry-title e-content entry-content article'><%= raw note.html(:body) %></p>\n      <footer>\n        <small><%= link_to_permalink(note, display_date_and_time(note.published_at)) %></small>\n      </footer>\n    </article>\n        <hr />\n  </div>\n  <% end %>\n</div>\n\n<%= paginate @notes %>\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nclass TestBrokenSidebar < Sidebar\n  description \"Invalid test sidebar\"\n  def parse_request(_contents, _request_params)\n    raise \"I'm b0rked!\"\n  end\nend\n\ndescribe BaseHelper, type: :helper do\n  describe \"#link_to_permalink\" do\n    describe \"for a simple ascii-only permalink\" do\n      let(:article) do\n        build(:article, published_at: Date.new(2004, 6, 1).to_datetime,\n                        title: \"An Article sample\")\n      end\n\n      it {\n        expect(link_to_permalink(article, \"title\")).\n          to eq(\"<a href=\\\"#{article.permalink_url}\\\">title</a>\")\n      }\n    end\n\n    describe \"for a multibyte permalink\" do\n      let(:article) { build(:article, permalink: \"\u30eb\u30d3\u30fc\") }\n\n      it {\n        expect(link_to_permalink(article, \"title\")).\n          to include(\"%E3%83%AB%E3%83%93%E3%83%BC\")\n      }\n    end\n\n    it \"returns just the title for unpublished articles\" do\n      article = build :unpublished_article\n      expect(link_to_permalink(article, \"the-title\")).to eq \"the-title\"\n    end\n  end\n\n  describe \"#stop_index_robots?\" do\n    subject { helper.stop_index_robots?(blog) }\n\n    let(:blog) { build :blog }\n\n    context \"default\" do\n      it { expect(subject).to be_falsey }\n    end\n\n    context \"with year:2010\" do\n      before { params[:year] = 2010 }\n\n      it { expect(subject).to be_truthy }\n    end\n\n    context \"with page:2\" do\n      before { params[:page] = 2 }\n\n      it { expect(subject).to be_truthy }\n    end\n\n    context \"for the tags controller\" do\n      before { allow(helper).to receive(:controller_name).and_return(\"tags\") }\n\n      context \"with unindex_tags set to true in blog\" do\n        before { expect(blog).to receive(:unindex_tags).and_return(true) }\n\n        it { expect(subject).to be_truthy }\n      end\n\n      context \"with unindex_tags set to false in blog\" do\n        before { expect(blog).to receive(:unindex_tags).and_return(false) }\n\n        it { expect(subject).to be_falsey }\n      end\n    end\n\n    context \"for the categories controller\" do\n      before { allow(helper).to receive(:controller_name).and_return(\"categories\") }\n\n      context \"with unindex_tags to true set in blog\" do\n        before { expect(blog).to receive(:unindex_categories).and_return(true) }\n\n        it { expect(subject).to be_truthy }\n      end\n\n      context \"with unindex_tags set to false in blog\" do\n        before { expect(blog).to receive(:unindex_categories).and_return(false) }\n\n        it { expect(subject).to be_falsey }\n      end\n    end\n  end\n\n  describe \"#get_reply_context_url\" do\n    it \"returns a link to the reply's URL if given\" do\n      reply = {\n        \"user\" => {\n          \"name\" => \"truc\",\n          \"entities\" => { \"url\" => { \"urls\" => [{ \"expanded_url\" => \"an url\" }] } },\n        },\n      }\n      expect(get_reply_context_url(reply)).to eq '<a href=\"an url\">truc</a>'\n    end\n\n    it \"returns a link to the reply's user if no URL is given\" do\n      reply = { \"user\" => { \"name\" => \"truc\", \"entities\" => {} } }\n      expect(get_reply_context_url(reply)).\n        to eq '<a href=\"https://twitter.com/truc\">truc</a>'\n    end\n  end\n\n  describe \"#get_reply_context_twitter_link\" do\n    let(:reply) do\n      { \"id_str\" => \"123456789\",\n        \"created_at\" => \"Thu Jan 23 13:47:00 +0000 2014\",\n        \"user\" => {\n          \"screen_name\" => \"a_screen_name\",\n          \"entities\" => { \"url\" => { \"urls\" => [{ \"expanded_url\" => \"an url\" }] } },\n        } }\n    end\n\n    it \"returns a link with the creation date and time\" do\n      timezone = Time.zone\n      Time.zone = \"UTC\"\n\n      expect(get_reply_context_twitter_link(reply)).\n        to eq '<a href=\"https://twitter.com/a_screen_name/status/123456789\">' \\\n        \"23/01/2014 at 13h47</a>\"\n    ensure\n      Time.zone = timezone\n    end\n\n    it \"displays creation date and time in the current time zone\" do\n      timezone = Time.zone\n      Time.zone = \"Tokyo\"\n\n      expect(get_reply_context_twitter_link(reply)).\n        to eq '<a href=\"https://twitter.com/a_screen_name/status/123456789\">' \\\n        \"23/01/2014 at 22h47</a>\"\n    ensure\n      Time.zone = timezone\n    end\n  end\n\n  describe \"#nofollowified_link_to\" do\n    it \"with dofollowify disabled, links should be nofollowed\" do\n      this_blog.dofollowify = false\n\n      expect(nofollowified_link_to(\"my blog\", \"http://myblog.net\")).\n        to eq '<a rel=\"nofollow\" href=\"http://myblog.net\">my blog</a>'\n    end\n\n    it \"with dofollowify enabled, links should be nofollowed\" do\n      this_blog.dofollowify = true\n\n      expect(nofollowified_link_to(\"my blog\", \"http://myblog.net\")).\n        to eq '<a href=\"http://myblog.net\">my blog</a>'\n    end\n  end\n\n  describe \"#nofollowify_links\" do\n    before do\n      @blog = create :blog\n    end\n\n    it \"with dofollowify disabled, links should be nofollowed\" do\n      @blog.dofollowify = false\n      @blog.save\n\n      expect(nofollowify_links('<a href=\"http://myblog.net\">my blog</a>')).\n        to eq('<a href=\"http://myblog.net\" rel=\"nofollow\">my blog</a>')\n    end\n\n    it \"with dofollowify enabled, links should be nofollowed\" do\n      @blog.dofollowify = true\n      @blog.save\n\n      expect(nofollowify_links('<a href=\"http://myblog.net\">my blog</a>')).\n        to eq('<a href=\"http://myblog.net\">my blog</a>')\n    end\n  end\n\n  describe \"#render_sidebars\" do\n    let(:blog) { create :blog }\n\n    before do\n      allow(controller).to receive(:render_to_string).and_return \"Rendered\"\n    end\n\n    describe \"with an invalid sidebar\" do\n      before do\n        TestBrokenSidebar.new(blog: blog).save\n      end\n\n      def logger\n        fake_logger = double(\"fake logger\")\n        expect(fake_logger).to receive(:error)\n        fake_logger\n      end\n\n      it \"returns a friendly error message\" do\n        expect(render_sidebars).to match(/It seems something went wrong/)\n      end\n    end\n\n    describe \"with a valid sidebar\" do\n      before do\n        Sidebar.new(blog: blog).save\n      end\n\n      it \"renders the sidebar\" do\n        expect(render_sidebars).to match(/Rendered/)\n      end\n    end\n  end\n\n  describe \"#display_date\" do\n    [\"%d/%m/%y\", \"%m/%m/%y\", \"%d %b %Y\", \"%b %d %Y\", \"%I:%M%p\", \"%H:%M\",\n     \"%Hh%M\"].each do |spec|\n      it \"use #{spec} format from blog to render date\" do\n        create(:blog, date_format: spec)\n        article = build(:article)\n        expect(display_date(article.published_at)).\n          to eq(article.published_at.strftime(spec))\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"timecop\"\n\ndescribe Article, type: :model do\n  let(:blog) { create(:blog) }\n\n  it \"test_content_fields\" do\n    a = blog.articles.build\n    assert_equal [:body, :extended], a.content_fields\n  end\n\n  describe \"#permalink_url\" do\n    describe \"with hostname\" do\n      let(:article) do\n        blog.articles.build(permalink: \"article-3\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"includes the full blog url\" do\n        article.publish\n        expect(article.permalink_url(nil, false)).\n          to eq \"#{blog.base_url}/2004/06/01/article-3\"\n      end\n    end\n\n    describe \"without hostname\" do\n      let(:article) do\n        blog.articles.build(permalink: \"article-3\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"includes just the blog root path\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq \"#{blog.root_path}/2004/06/01/article-3\"\n      end\n    end\n\n    # NOTE: URLs must not have any multibyte characters in them. The\n    # browser may display them differently, though.\n    describe \"with a multibyte permalink\" do\n      let(:article) do\n        blog.articles.build(permalink: \"\u30eb\u30d3\u30fc\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"escapes the multibyte characters\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/%E3%83%AB%E3%83%93%E3%83%BC\")\n      end\n    end\n\n    describe \"with a permalink containing a space\" do\n      let(:article) do\n        blog.articles.build(permalink: \"hello there\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"escapes the space as '%20', not as '+'\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/hello%20there\")\n      end\n    end\n\n    describe \"with a permalink containing a plus\" do\n      let(:article) do\n        blog.articles.build(permalink: \"one+two\", published_at: Time.utc(2004,\n                                                                         6, 1))\n      end\n\n      it \"does not escape the plus\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/one+two\")\n      end\n    end\n\n    it \"returns nil when the article is not published\" do\n      article = blog.articles.build(permalink: \"one+two\")\n\n      expect(article.permalink_url(nil, true)).to be_nil\n    end\n  end\n\n  describe \"#initialize\" do\n    it \"accepts a settings field in its parameter hash\" do\n      blog.articles.build(\"password\" => \"foo\")\n    end\n  end\n\n  describe \".feed_url\" do\n    let(:article) do\n      build(:article, permalink: \"article-3\", published_at: Time.utc(2004, 6,\n                                                                     1))\n    end\n\n    it \"returns url for atom feed for a Atom 1.0 asked\" do\n      expect(article.feed_url(\"atom10\")).to eq \"#{blog.base_url}/2004/06/01/article-3.atom\"\n    end\n\n    it \"returns url for rss feed for a RSS 2 asked\" do\n      expect(article.feed_url(\"rss20\")).to eq \"#{blog.base_url}/2004/06/01/article-3.rss\"\n    end\n  end\n\n  it \"test_create\" do\n    a = blog.articles.build\n    a.user_id = 1\n    a.body = \"Foo\"\n    a.title = \"Zzz\"\n    assert a.save\n\n    a.tags << Tag.find(create(:tag).id)\n    assert_equal 1, a.tags.size\n\n    b = described_class.find(a.id)\n    assert_equal 1, b.tags.size\n  end\n\n  it \"test_permalink_with_title\" do\n    article = create(:article, permalink: \"article-3\", published_at: Time.utc(2004, 6, 1))\n    assert_equal(article, described_class.requested_article(year: 2004, month: 6, day: 1,\n                                                            title: \"article-3\"))\n    not_found = described_class.requested_article year: 2005, month: \"06\", day: \"01\",\n                                                  title: \"article-5\"\n    expect(not_found).to be_nil\n  end\n\n  it \"test_strip_title\" do\n    assert_equal \"article-3\", \"Article-3\".to_url\n    assert_equal \"article-3\", \"Article 3!?#\".to_url\n    assert_equal \"there-is-sex-in-my-violence\", \"There is Sex in my Violence!\".to_url\n    assert_equal \"article\", \"-article-\".to_url\n    assert_equal \"lorem-ipsum-dolor-sit-amet-consectetaur-adipisicing-elit\",\n                 \"Lorem ipsum dolor sit amet, consectetaur adipisicing elit\".to_url\n    assert_equal \"my-cats-best-friend\", \"My Cat's Best Friend\".to_url\n  end\n\n  describe \"#set_permalink\" do\n    it \"works for simple cases\" do\n      a = blog.articles.build(title: \"Article 3!\", state: :published)\n      a.set_permalink\n      expect(a.permalink).to eq \"article-3\"\n    end\n\n    it \"strips html\" do\n      a = blog.articles.build(title: \"This <i>is</i> a <b>test</b>\", state: :published)\n      a.set_permalink\n      assert_equal \"this-is-a-test\", a.permalink\n    end\n\n    it \"does not escape multibyte characters\" do\n      a = blog.articles.build(title: \"\u30eb\u30d3\u30fc\", state: :published)\n      a.set_permalink\n      expect(a.permalink).to eq(\"\u30eb\u30d3\u30fc\")\n    end\n\n    it \"is called upon saving a published article\" do\n      a = blog.articles.build(title: \"space separated\")\n      a.publish\n      expect(a.permalink).to be_nil\n      a.blog = create(:blog)\n      a.save\n      expect(a.permalink).to eq(\"space-separated\")\n    end\n\n    it \"does nothing for draft articles\" do\n      a = blog.articles.build(title: \"space separated\", state: :draft)\n      a.set_permalink\n      expect(a.permalink).to be_nil\n    end\n  end\n\n  describe \"the html_urls method\" do\n    let(:blog) { create :blog, text_filter: \"none\" }\n\n    before do\n      @article = blog.articles.build\n    end\n\n    it \"extracts URLs from the generated body html\" do\n      @article.body = 'happy halloween <a href=\"http://www.example.com/public\">with</a>'\n      urls = @article.html_urls\n      assert_equal [\"http://www.example.com/public\"], urls\n    end\n\n    it \"onlies match the href attribute\" do\n      @article.body = '<a href=\"http://a/b\">a</a> <a fhref=\"wrong\">wrong</a>'\n      urls = @article.html_urls\n      assert_equal [\"http://a/b\"], urls\n    end\n\n    it \"matches across newlines\" do\n      @article.body = \"<a\\nhref=\\\"http://foo/bar\\\">foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n\n    it \"matches with single quotes\" do\n      @article.body = \"<a href='http://foo/bar'>foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n\n    it \"matches with no quotes\" do\n      @article.body = \"<a href=http://foo/bar>foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n  end\n\n  describe \"Testing redirects\" do\n    it \"a new published article gets a redirect\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      a.publish!\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n    end\n\n    it \"a new unpublished article should not get a redirect\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      expect(a.redirect).to be_nil\n    end\n\n    it \"Changin a published article permalink url should only change the to redirection\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      a.publish!\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n      r = a.redirect.from_path\n\n      a.permalink = \"some-new-permalink\"\n      a.save\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n      expect(a.redirect.from_path).to eq(r)\n    end\n  end\n\n  it \"test_find_published_by_tag_name\" do\n    art1 = create(:article)\n    art2 = create(:article)\n    create(:tag, name: \"foo\", contents: [art1, art2])\n    articles = Tag.find_by(name: \"foo\").published_contents\n    assert_equal 2, articles.size\n  end\n\n  it \"test_future_publishing\" do\n    art = blog.articles.build(title: \"title\", body: \"body\",\n                              published_at: 2.seconds.from_now)\n    art.publish!\n\n    expect(art).to be_publication_pending\n\n    assert_equal 1, Trigger.count\n    assert Trigger.where(pending_item_id: art.id).first\n    assert !art.published?\n    Timecop.freeze(4.seconds.from_now) do\n      Trigger.fire\n    end\n    art.reload\n    assert art.published?\n  end\n\n  it \"test_triggers_are_dependent\" do\n    # TODO: Needs a fix for Rails ticket #5105: has_many: Dependent deleting\n    # does not work with STI\n    skip\n    art = blog.articles.create!(title: \"title\", body: \"body\",\n                                published_at: 1.hour.from_now)\n    assert_equal 1, Trigger.count\n    art.destroy\n    assert_equal 0, Trigger.count\n  end\n\n  it \"test_destroy_file_upload_associations\" do\n    a = create(:article)\n    create(:resource, content: a)\n    create(:resource, content: a)\n    assert_equal 2, a.resources.size\n    a.resources << create(:resource)\n    assert_equal 3, a.resources.size\n    a.destroy\n    assert_equal 0, Resource.where(content_id: a.id).size\n  end\n\n  describe \"#interested_users\" do\n    it \"gathers users interested in new articles\" do\n      henri = create(:user, login: \"henri\", notify_on_new_articles: true)\n      alice = create(:user, login: \"alice\", notify_on_new_articles: true)\n\n      a = build(:article)\n      users = a.interested_users\n      expect(users).to match_array [alice, henri]\n    end\n  end\n\n  it \"test_withdrawal\" do\n    art = create(:article)\n    assert art.published?\n    assert !art.withdrawn?\n    art.withdraw!\n    assert !art.published?\n    assert art.withdrawn?\n    art.reload\n    assert !art.published?\n    assert art.withdrawn?\n  end\n\n  it \"gets only ham not spam comment\" do\n    article = create(:article)\n    ham_comment = create(:comment, article: article)\n    create(:spam_comment, article: article)\n    expect(article.comments.ham).to eq([ham_comment])\n    expect(article.comments.count).to eq(2)\n  end\n\n  describe \"#access_by?\" do\n    before do\n      @alice = build(:user, :as_admin)\n    end\n\n    it \"admin should have access to an article written by another\" do\n      expect(build(:article)).to be_access_by(@alice)\n    end\n\n    it \"admin should have access to an article written by himself\" do\n      article = build(:article, author: @alice)\n      expect(article).to be_access_by(@alice)\n    end\n  end\n\n  describe \"body_and_extended\" do\n    before do\n      @article = blog.articles.build(\n        body: \"basic text\",\n        extended: \"extended text to explain more and more how Publify is wonderful\")\n    end\n\n    it \"combines body and extended content\" do\n      expect(@article.body_and_extended).to eq(\n        \"#{@article.body}\\n<!--more-->\\n#{@article.extended}\")\n    end\n\n    it \"does not insert <!--more--> tags if extended is empty\" do\n      @article.extended = \"\"\n      expect(@article.body_and_extended).to eq(@article.body)\n    end\n  end\n\n  describe \"#search\" do\n    describe \"with one word and result\" do\n      it \"has two items\" do\n        create(:article, extended: \"extended talk\")\n        create(:article, extended: \"Once uppon a time, an extended story\")\n        assert_equal 2, described_class.search(\"extended\").size\n      end\n    end\n  end\n\n  describe \"body_and_extended=\" do\n    before do\n      @article = blog.articles.build\n    end\n\n    it \"splits apart values at <!--more-->\" do\n      @article.body_and_extended = \"foo<!--more-->bar\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n\n    it \"removes newlines around <!--more-->\" do\n      @article.body_and_extended = \"foo\\n<!--more-->\\nbar\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n\n    it \"makes extended empty if no <!--more--> tag\" do\n      @article.body_and_extended = \"foo\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to be_empty\n    end\n\n    it \"preserves extra <!--more--> tags\" do\n      @article.body_and_extended = \"foo<!--more-->bar<!--more-->baz\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar<!--more-->baz\")\n    end\n\n    it \"is settable via self.attributes=\" do\n      @article.attributes = { body_and_extended: \"foo<!--more-->bar\" }\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n  end\n\n  describe \"#comment_url\" do\n    it \"renders complete url of comment\" do\n      article = build_stubbed(:article, id: 123)\n      expect(article.comment_url).\n        to eq(\"#{blog.root_path}/comments?article_id=#{article.id}\")\n    end\n  end\n\n  describe \"#preview_comment_url\" do\n    it \"renders complete url of comment\" do\n      article = build_stubbed(:article, id: 123)\n      expect(article.preview_comment_url).\n        to eq(\"#{blog.root_path}/comments/preview?article_id=#{article.id}\")\n    end\n  end\n\n  it \"test_can_ping_fresh_article_iff_it_allows_pings\" do\n    a = create(:article, allow_pings: true)\n    assert_equal(false, a.pings_closed?)\n    a.allow_pings = false\n    assert_equal(true, a.pings_closed?)\n  end\n\n  it \"test_cannot_ping_old_article\" do\n    a = create(:article, allow_pings: false)\n    assert_equal(true, a.pings_closed?)\n    a.allow_pings = false\n    assert_equal(true, a.pings_closed?)\n  end\n\n  describe \"#published_at_like\" do\n    before do\n      # Note: these choices of times depend on no other articles within\n      # these timeframes existing in test/fixtures/contents.yaml.\n      # In particular, all articles there are from 2005 or earlier, which\n      # is now more than two years ago, except for two, which are from\n      # yesterday and the day before. The existence of those two makes\n      # 1.month.ago not suitable, because yesterday can be last month.\n      @article_two_month_ago = create(:article, published_at: 2.months.ago)\n\n      @article_four_months_ago = create(:article, published_at: 4.months.ago)\n      @article_2_four_months_ago = create(:article, published_at: 4.months.ago)\n\n      @article_two_year_ago = create(:article, published_at: 2.years.ago)\n      @article_2_two_year_ago = create(:article, published_at: 2.years.ago)\n    end\n\n    it \"returns all content for the year if only year sent\" do\n      expect(described_class.published_at_like(2.years.ago.strftime(\"%Y\")).map(&:id).sort).\n        to eq([@article_two_year_ago.id, @article_2_two_year_ago.id].sort)\n    end\n\n    it \"returns all content for the month if year and month sent\" do\n      result = described_class.published_at_like(4.months.ago.strftime(\"%Y-%m\")).\n        map(&:id).sort\n      expect(result).\n        to eq([@article_four_months_ago.id, @article_2_four_months_ago.id].sort)\n    end\n\n    it \"returns all content on this date if date send\" do\n      result = described_class.published_at_like(2.months.ago.strftime(\"%Y-%m-%d\")).\n        map(&:id).sort\n      expect(result).to eq([@article_two_month_ago.id].sort)\n    end\n  end\n\n  describe \"#has_child?\" do\n    it \"is true if article has one to link it by parent_id\" do\n      parent = create(:article)\n      create(:article, parent_id: parent.id)\n      expect(parent).to be_has_child\n    end\n\n    it \"is false if article has no article to link it by parent_id\" do\n      parent = create(:article)\n      create(:article, parent_id: nil)\n      expect(parent).not_to be_has_child\n    end\n  end\n\n  describe \"self#last_draft(id)\" do\n    it \"returns article if no draft associated\" do\n      draft = create(:article, state: \"draft\")\n      expect(described_class.last_draft(draft.id)).to eq(draft)\n    end\n\n    it \"returns draft associated to this article if there are one\" do\n      parent = create(:article)\n      draft = create(:article, parent_id: parent.id, state: \"draft\")\n      expect(described_class.last_draft(draft.id)).to eq(draft)\n    end\n  end\n\n  describe \"an article published just before midnight UTC\" do\n    before do\n      @timezone = Time.zone\n      Time.zone = \"UTC\"\n      @a = build(:article)\n      @a.set_permalink\n      @a.published_at = \"21 Feb 2011 23:30 UTC\"\n    end\n\n    after do\n      Time.zone = @timezone\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses UTC to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2011/02/21/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses UTC to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2011, month: 2, day: 21,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just after midnight UTC\" do\n    before do\n      @timezone = Time.zone\n      Time.zone = \"UTC\"\n      @a = build(:article)\n      @a.set_permalink\n      @a.published_at = \"22 Feb 2011 00:30 UTC\"\n    end\n\n    after do\n      Time.zone = @timezone\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses UTC to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2011/02/22/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses UTC to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2011, month: 2, day: 22,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just before midnight JST (+0900)\" do\n    before do\n      @time_zone = Time.zone\n      Time.zone = \"Tokyo\"\n      @a = build(:article)\n      @a.set_permalink\n      @a.published_at = \"31 Dec 2012 23:30 +0900\"\n    end\n\n    after do\n      Time.zone = @time_zone\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses JST to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2012/12/31/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses JST to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2012, month: 12, day: 31,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just after midnight  JST (+0900)\" do\n    before do\n      @time_zone = Time.zone\n      Time.zone = \"Tokyo\"\n      @a = build(:article)\n      @a.set_permalink\n      @a.published_at = \"1 Jan 2013 00:30 +0900\"\n    end\n\n    after do\n      Time.zone = @time_zone\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses JST to determine correct day\" do\n        expect(@a.permalink_url).to eq(\"#{blog.base_url}/2013/01/01/a-big-article\")\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses JST to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2013, month: 1, day: 1,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"#published_comments\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn comments\" do\n      comment = create :published_comment, article: article\n      article.reload\n      expect(article.published_comments).to eq [comment]\n      comment.withdraw!\n      article.reload\n      expect(article.published_comments).to eq []\n    end\n\n    it \"sorts comments newest last\" do\n      old_comment = create :published_comment, article: article, created_at: 2.days.ago\n      new_comment = create :published_comment, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_comments).to eq [old_comment, new_comment]\n    end\n  end\n\n  describe \"#published_trackbacks\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn trackbacks\" do\n      trackback = create :trackback, article: article\n      article.reload\n      expect(article.published_trackbacks).to eq [trackback]\n      trackback.withdraw!\n      article.reload\n      expect(article.published_trackbacks).to eq []\n    end\n\n    it \"sorts trackbacks newest last\" do\n      old_trackback = create :trackback, article: article, created_at: 2.days.ago\n      new_trackback = create :trackback, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_trackbacks).to eq [old_trackback, new_trackback]\n    end\n  end\n\n  describe \"#published_feedback\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn comments or trackbacks\" do\n      comment = create :published_comment, article: article\n      trackback = create :trackback, article: article\n      article.reload\n      expect(article.published_feedback).to eq [comment, trackback]\n      comment.withdraw!\n      trackback.withdraw!\n      article.reload\n      expect(article.published_feedback).to eq []\n    end\n\n    it \"sorts feedback newest last\" do\n      old_comment = create :published_comment, article: article, created_at: 4.days.ago\n      old_trackback = create :trackback, article: article, created_at: 3.days.ago\n      new_comment = create :published_comment, article: article, created_at: 2.days.ago\n      new_trackback = create :trackback, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_feedback).\n        to eq [old_comment, old_trackback, new_comment, new_trackback]\n    end\n  end\n\n  describe \"save_attachments!\" do\n    it \"calls save_attachment for each file given\" do\n      first_file = OpenStruct.new\n      second_file = OpenStruct.new\n      hash = { a_key: first_file, a_second_key: second_file }\n      article = build(:article)\n      expect(article).to receive(:save_attachment!).with(first_file)\n      expect(article).to receive(:save_attachment!).with(second_file)\n      article.save_attachments!(hash)\n    end\n\n    it \"do nothing with nil given\" do\n      article = build(:article)\n      article.save_attachments!(nil)\n    end\n  end\n\n  describe \"save_attachment!\" do\n    let(:file) { file_upload(\"testfile.txt\", \"text/plain\") }\n\n    it \"adds a new resource\" do\n      article = create(:article)\n      article.save_attachment!(file)\n      article.reload\n\n      resource = article.resources.first\n      upload = resource.upload\n\n      expect(upload.file.basename).to eq \"testfile\"\n    end\n  end\n\n  describe \"#search_with\" do\n    subject { described_class.search_with(params) }\n\n    context \"without article\" do\n      let(:params) { nil }\n\n      it { expect(subject).to be_empty }\n    end\n\n    context \"with an article\" do\n      let(:params) { nil }\n      let!(:article) { create(:article) }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two article but only one matching searchstring\" do\n      let(:params) { { searchstring: \"match the string\" } }\n      let!(:not_found_article) { create(:article) }\n      let!(:article) { create(:article, body: \"this match the string of article\") }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two articles with differents states and published params\" do\n      let(:params) { { state: \"published\" } }\n      let!(:article) { create(:article, state: \"published\") }\n      let!(:draft_article) { create(:article, state: \"draft\") }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two articles with differents states and no params\" do\n      let(:params) { nil }\n      let(:now) { DateTime.new(2011, 3, 12).in_time_zone }\n      let!(:article) { create(:article, state: \"published\", created_at: now) }\n      let!(:last_draft_article) do\n        create(:article, state: \"draft\",\n                         created_at: now + 2.days)\n      end\n      let!(:draft_article) { create(:article, state: \"draft\", created_at: now + 20.days) }\n\n      it { expect(subject).to eq([draft_article, last_draft_article, article]) }\n    end\n  end\n\n  describe \".allow_comments?\" do\n    it \"true if article set to true\" do\n      expect(blog.articles.build(allow_comments: true)).to be_allow_comments\n    end\n\n    it \"false if article set to false\" do\n      expect(blog.articles.build(allow_comments: false)).not_to be_allow_comments\n    end\n\n    context \"given an article with no allow comments state\" do\n      it \"returns true when blog default allow comments is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_comments).and_return(true)\n        expect(blog.articles.build(allow_comments: nil)).to be_allow_comments\n      end\n\n      it \"returns false when blog default allow comments is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_comments).and_return(false)\n        expect(blog.articles.build(allow_comments: nil)).not_to be_allow_comments\n      end\n    end\n  end\n\n  describe \".allow_pings?\" do\n    it \"true if article set to true\" do\n      expect(blog.articles.build(allow_pings: true)).to be_allow_pings\n    end\n\n    it \"false if article set to false\" do\n      expect(blog.articles.build(allow_pings: false)).not_to be_allow_pings\n    end\n\n    context \"given an article with no allow pings state\" do\n      it \"returns true when blog default allow pings is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_pings).and_return(true)\n        expect(blog.articles.build(allow_pings: nil)).to be_allow_pings\n      end\n\n      it \"returns false when blog default allow pings is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_pings).and_return(false)\n        expect(blog.articles.build(allow_pings: nil)).not_to be_allow_pings\n      end\n    end\n  end\n\n  describe \"#publication_months\" do\n    it \"returns an empty array when no articles\" do\n      expect(described_class.publication_months).to be_empty\n    end\n\n    it \"returns months of publication for published articles\" do\n      create(:article, published_at: Date.new(2010, 11, 23))\n      create(:article, published_at: Date.new(2002, 4, 9))\n      result = described_class.publication_months\n      expect(result).to match_array [[\"2010-11\"], [\"2002-04\"]]\n    end\n  end\n\n  describe \"published_since\" do\n    let(:time) { DateTime.new(2010, 11, 3, 23, 34).in_time_zone }\n\n    it \"empty when no articles\" do\n      expect(described_class.published_since(time)).to be_empty\n    end\n\n    it \"returns article that was published since\" do\n      article = create(:article, published_at: time + 2.hours)\n      expect(described_class.published_since(time)).to eq [article]\n    end\n\n    it \"returns only article that was published since last visit\" do\n      create(:article, published_at: time - 2.hours)\n      article = create(:article, published_at: time + 2.hours)\n      expect(described_class.published_since(time)).to eq [article]\n    end\n  end\n\n  describe \"bestof\" do\n    it \"returns empty array when no content\" do\n      expect(described_class.bestof).to be_empty\n    end\n\n    it \"returns article with comment count field\" do\n      create(:comment)\n      expect(described_class.bestof.first.comment_count.to_i).to eq 1\n    end\n\n    it \"counts comments but not trackbacks\" do\n      article = create :article\n      create :trackback, article: article\n      create_list :comment, 2, article: article\n\n      expect(described_class.bestof.first.comment_count.to_i).to eq 2\n    end\n\n    it \"returns only 5 articles\" do\n      create_list(:comment, 6)\n      expect(described_class.bestof.length).to eq(5)\n    end\n\n    it \"returns only published articles\" do\n      article = create(:article)\n      create(:comment, article: article)\n      unpublished_article = create(:article, state: \"draft\")\n      create(:comment, article: unpublished_article)\n      expect(described_class.published).to eq([article])\n      expect(described_class.bestof).to eq([article])\n    end\n\n    it \"returns article sorted by comment counts\" do\n      last_article = create(:article)\n      create(:comment, article: last_article)\n\n      first_article = create(:article)\n      create(:comment, article: first_article)\n      create(:comment, article: first_article)\n\n      expect(described_class.bestof).to eq([first_article, last_article])\n    end\n  end\n\n  describe \"update tags from article keywords\" do\n    before { article.save }\n\n    context \"without keywords\" do\n      let(:article) { build(:article, keywords: nil) }\n\n      it { expect(article.tags).to be_empty }\n    end\n\n    context \"with a simple keyword\" do\n      let(:article) { build(:article, keywords: \"foo\") }\n\n      it { expect(article.tags.size).to eq(1) }\n      it { expect(article.tags.first).to be_kind_of(Tag) }\n      it { expect(article.tags.first.name).to eq(\"foo\") }\n    end\n\n    context \"with two keyword separate by a space\" do\n      let(:article) { build(:article, keywords: \"foo bar\") }\n\n      it { expect(article.tags.size).to eq(2) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo bar)) }\n    end\n\n    context \"with two keyword separate by a coma\" do\n      let(:article) { build(:article, keywords: \"foo, bar\") }\n\n      it { expect(article.tags.size).to eq(2) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo bar)) }\n    end\n\n    context \"with two keyword with apostrophe\" do\n      let(:article) { build(:article, keywords: \"foo, l'bar\") }\n\n      it { expect(article.tags.size).to eq(3) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo l bar)) }\n    end\n\n    context \"with two identical keywords\" do\n      let(:article) { build(:article, keywords: \"same, same\") }\n\n      it { expect(article.tags.size).to eq(1) }\n      it { expect(article.tags.map(&:name)).to eq([\"same\"]) }\n    end\n\n    context \"with keywords with dot and quote\" do\n      let(:article) { build(:article, keywords: 'foo \"bar quiz\" web2.0') }\n\n      it { expect(article.tags.map(&:name)).to eq([\"foo\", \"bar-quiz\", \"web2-0\"]) }\n    end\n  end\n\n  describe \"#post_type\" do\n    context \"without post_type\" do\n      let(:article) { build(:article, post_type: \"\") }\n\n      it { expect(article.post_type).to eq(\"read\") }\n    end\n\n    context \"with a oldschool read post_type\" do\n      let(:article) { build(:article, post_type: \"read\") }\n\n      it { expect(article.post_type).to eq(\"read\") }\n    end\n\n    context \"with a specific myletter post_type\" do\n      let(:article) { build(:article, post_type: \"myletter\") }\n\n      it { expect(article.post_type).to eq(\"myletter\") }\n    end\n  end\n\n  describe \"#comments_closed?\" do\n    let!(:blog) do\n      create(:blog, sp_article_auto_close: auto_close_value,\n                    default_allow_comments: true)\n    end\n\n    context \"when auto_close setting is zero\" do\n      let(:auto_close_value) { 0 }\n\n      it \"allows comments for a newly published article\" do\n        art = build :article, published_at: 1.second.ago, blog: blog\n        assert !art.comments_closed?\n      end\n\n      it \"allows comments for a very old article\" do\n        art = build :article, created_at: 1000.days.ago, blog: blog\n        assert !art.comments_closed?\n      end\n    end\n\n    context \"when auto_close setting is nonzero\" do\n      let(:auto_close_value) { 30 }\n\n      it \"allows comments for a recently published article\" do\n        art = build :article, published_at: 29.days.ago, blog: blog\n        assert !art.comments_closed?\n      end\n\n      it \"does not allow comments for an old article\" do\n        art = build :article, published_at: 31.days.ago, blog: blog\n        assert art.comments_closed?\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"publify_core/testing_support/dns_mock\"\n\ndescribe Comment, type: :model do\n  let(:blog) { build_stubbed :blog }\n\n  let(:published_article) { build_stubbed(:article, published_at: 1.hour.ago, blog: blog) }\n\n  def valid_comment(options = {})\n    Comment.new({ author: \"Bob\", article: published_article, body: \"nice post\",\n                  ip: \"1.2.3.4\" }.merge(options))\n  end\n\n  describe \"#permalink_url\" do\n    let(:comment) { build_stubbed(:comment) }\n\n    it \"renders permalink to comment in public part\" do\n      expect(comment.permalink_url).\n        to eq(\"#{comment.article.permalink_url}#comment-#{comment.id}\")\n    end\n  end\n\n  describe \"#save\" do\n    it \"saves good comment\" do\n      c = build(:comment, url: \"http://www.google.de\")\n      assert c.save\n      assert_equal \"http://www.google.de\", c.url\n    end\n\n    it \"saves spam comment\" do\n      c = build(:comment, body: 'test <a href=\"http://fakeurl.com\">body</a>')\n      assert c.save\n      assert_equal \"http://fakeurl.com\", c.url\n    end\n\n    it \"does not save when article comment window is closed\" do\n      article = build :article, published_at: 1.year.ago\n      article.blog.sp_article_auto_close = 30\n      comment = build(:comment, author: \"Old Spammer\", body: \"Old trackback body\",\n                                article: article)\n      expect(comment.save).to be_falsey\n      expect(comment.errors[:article_id]).not_to be_empty\n    end\n\n    it \"changes old comment\" do\n      c = build(:comment, body: \"Comment body <em>italic</em> <strong>bold</strong>\")\n      assert c.save\n      assert c.errors.empty?\n    end\n\n    it \"saves a valid comment\" do\n      c = build :comment\n      expect(c.save).to be_truthy\n      expect(c.errors).to be_empty\n    end\n\n    it \"does not save with article not allow comment\" do\n      c = build(:comment, article: build_stubbed(:article, allow_comments: false))\n      expect(c.save).not_to be_truthy\n      expect(c.errors).not_to be_empty\n    end\n\n    it \"generates guid\" do\n      c = build :comment, guid: nil\n      assert c.save\n      assert c.guid.size > 15\n    end\n\n    it \"preserves urls starting with https://\" do\n      c = build :comment, url: \"https://example.com/\"\n      c.save\n      expect(c.url).to eq(\"https://example.com/\")\n    end\n\n    it \"preserves urls starting with http://\" do\n      c = build :comment, url: \"http://example.com/\"\n      c.save\n      expect(c.url).to eq(\"http://example.com/\")\n    end\n\n    it \"prepends http:// to urls without protocol\" do\n      c = build :comment, url: \"example.com\"\n      c.save\n      expect(c.url).to eq(\"http://example.com\")\n    end\n  end\n\n  describe \"#classify_content\" do\n    it \"rejects spam rbl\" do\n      comment = valid_comment(\n        author: \"Spammer\",\n        body: <<-BODY,\n          This is just some random text.\n          &lt;a href=\"http://chinaaircatering.com\"&gt;without any senses.&lt;/a&gt;.\n          Please disregard.\n        BODY\n        url: \"http://buy-computer.us\")\n      comment.classify_content\n      expect(comment).to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    it \"does not define spam a comment rbl with lookup succeeds\" do\n      comment = valid_comment(author: \"Not a Spammer\", body: \"Useful commentary!\",\n                              url: \"http://www.bofh.org.uk\")\n      comment.classify_content\n      expect(comment).not_to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    it \"rejects spam with uri limit\" do\n      comment =\n        valid_comment(author: \"Yet Another Spammer\",\n                      body: <<~HTML,\n                        <a href=\"http://www.one.com/\">one</a>\n                        <a href=\"http://www.two.com/\">two</a>\n                        <a href=\"http://www.three.com/\">three</a>\n                        <a href=\"http://www.four.com/\">four</a>\n                      HTML\n                      url: \"http://www.uri-limit.com\")\n      comment.classify_content\n      expect(comment).to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    describe \"with feedback moderation enabled\" do\n      before do\n        allow(blog).to receive(:sp_global).and_return(false)\n        allow(blog).to receive(:default_moderate_comments).and_return(true)\n      end\n\n      it \"marks comment as presumably spam\" do\n        comment = described_class.new do |c|\n          c.body = \"Test foo\"\n          c.author = \"Bob\"\n          c.article = build_stubbed(:article, blog: blog)\n        end\n\n        comment.classify_content\n\n        assert !comment.published?\n        assert comment.presumed_spam?\n        assert !comment.status_confirmed?\n      end\n\n      it \"marks comment from known user as confirmed ham\" do\n        comment = described_class.new do |c|\n          c.body = \"Test foo\"\n          c.author = \"Henri\"\n          c.article = build_stubbed(:article, blog: blog)\n          c.user = build_stubbed(:user)\n        end\n\n        comment.classify_content\n\n        assert comment.published?\n        assert comment.ham?\n        assert comment.status_confirmed?\n      end\n    end\n  end\n\n  it \"has good relation\" do\n    article = build_stubbed(:article)\n    comment = build_stubbed(:comment, article: article)\n    assert comment.article\n    assert_equal article, comment.article\n  end\n\n  describe \"reject xss\" do\n    let(:comment) do\n      described_class.new do |c|\n        c.body = \"Test foo <script>do_evil();</script>\"\n        c.author = \"Bob\"\n        c.article = build_stubbed(:article, blog: blog)\n      end\n    end\n\n    [\"\", \"textile\", \"markdown\", \"smartypants\", \"markdown smartypants\"].each do |filter|\n      it \"rejects with filter '#{filter}'\" do\n        blog.comment_text_filter = filter\n\n        ActiveSupport::Deprecation.silence do\n          assert comment.html(:body) !~ /<script>/\n        end\n      end\n    end\n  end\n\n  describe \"change state\" do\n    it \"becomes unpublished if withdrawn\" do\n      c = build :comment\n      assert c.published?\n      assert c.withdraw!\n      assert !c.published?\n      assert c.spam?\n      assert c.status_confirmed?\n    end\n\n    it \"becomeses confirmed if withdrawn\" do\n      unconfirmed = build(:comment, state: \"presumed_ham\")\n      expect(unconfirmed).not_to be_status_confirmed\n      unconfirmed.withdraw!\n      expect(unconfirmed).to be_status_confirmed\n    end\n  end\n\n  it \"has good default filter\" do\n    create :blog, text_filter: \"textile\", comment_text_filter: \"markdown\"\n    a = create(:comment)\n    assert_equal \"markdown\", a.default_text_filter.name\n  end\n\n  describe \"spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n\n    it \"returns only spam comment\" do\n      expect(described_class.spam).to eq([comment])\n    end\n  end\n\n  describe \"not_spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n    let!(:presumed_spam_comment) { create(:comment, state: \"presumed_spam\") }\n\n    it \"returns all comment that not_spam\" do\n      expect(described_class.not_spam).to match_array [ham_comment, presumed_spam_comment]\n    end\n  end\n\n  describe \"presumed_spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n    let!(:presumed_spam_comment) { create(:comment, state: \"presumed_spam\") }\n\n    it \"returns only presumed_spam\" do\n      expect(described_class.presumed_spam).to eq([presumed_spam_comment])\n    end\n  end\n\n  describe \"last_published\", integration: true do\n    let(:date) { DateTime.new(2012, 12, 23, 12, 47).in_time_zone }\n    let!(:comment_1) { create(:comment, body: \"1\", created_at: date + 1.day) }\n    let!(:comment_4) { create(:comment, body: \"4\", created_at: date + 4.days) }\n    let!(:comment_2) { create(:comment, body: \"2\", created_at: date + 2.days) }\n    let!(:comment_6) { create(:comment, body: \"6\", created_at: date + 6.days) }\n    let!(:comment_3) { create(:comment, body: \"3\", created_at: date + 3.days) }\n    let!(:comment_5) { create(:comment, body: \"5\", created_at: date + 5.days) }\n\n    it \"respond only 5 last_published\" do\n      expect(described_class.last_published).to eq([comment_6, comment_5, comment_4,\n                                                    comment_3, comment_2])\n    end\n  end\n\n  describe \"#generate_html\" do\n    it \"renders email addresses in the body\" do\n      comment = build_stubbed(:comment, body: \"foo@example.com\")\n      expect(comment.generate_html(:body)).to match(/mailto:/)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Content, type: :model do\n  context \"with a simple blog\" do\n    describe \"#author=\" do\n      let(:content) { described_class.new }\n\n      before { content.author = user }\n\n      context \"with a User as author\" do\n        let(:user) { build(:user) }\n\n        it { expect(content.author).to eq(user.login) }\n        it { expect(content.user).to eq(user) }\n      end\n\n      context \"with a String as author\" do\n        let(:user) { \"George Sand\" }\n\n        it { expect(content.author).to eq(user) }\n        it { expect(content.user).to be_nil }\n      end\n    end\n\n    describe \"#short_url\" do\n      let(:redirect) do\n        build_stubbed(:redirect, from_path: \"foo\", to_path: \"bar\",\n                                 blog: blog)\n      end\n      let(:content) do\n        build_stubbed(:content,\n                      blog: blog,\n                      state: \"published\",\n                      published_at: 1.day.ago,\n                      redirect: redirect)\n      end\n\n      describe \"normally\" do\n        let(:blog) { build_stubbed(:blog, base_url: \"http://myblog.net\") }\n\n        it \"returns the blog's base url combined with the redirection's from path\" do\n          expect(content.short_url).to eq(\"http://myblog.net/foo\")\n        end\n      end\n\n      describe \"when the blog is in a sub-uri\" do\n        let(:blog) { build_stubbed(:blog, base_url: \"http://myblog.net/blog\") }\n\n        it \"includes the sub-uri path\" do\n          expect(content.short_url).to eq(\"http://myblog.net/blog/foo\")\n        end\n      end\n    end\n\n    describe \"#text_filter\" do\n      it \"returns nil by default\" do\n        @content = described_class.new\n        expect(@content.text_filter).to be_nil\n      end\n    end\n\n    # TODO: Move implementation out of models\n    describe \"#really_send_notifications\" do\n      it \"sends notifications to interested users\" do\n        @content = Article.new\n        henri = create(:user, notify_on_new_articles: true)\n        alice = create(:user, notify_on_new_articles: true)\n\n        expect(@content).to receive(:send_notification_to_user).with henri\n        expect(@content).to receive(:send_notification_to_user).with alice\n\n        @content.really_send_notifications\n      end\n    end\n\n    describe \"#search_with\" do\n      context \"with an simple article\" do\n        subject { described_class.search_with(params) }\n\n        context \"with nil params\" do\n          let(:params) { nil }\n\n          it { expect(subject).to be_empty }\n        end\n\n        context \"with a matching searchstring article\" do\n          let(:params) { { searchstring: \"a search string\" } }\n          let!(:match_article) { create(:article, body: \"there is a search string here\") }\n\n          it { expect(subject).to eq([match_article]) }\n        end\n\n        context \"with an article published_at\" do\n          let(:params) { { published_at: \"2012-02\" } }\n          let!(:article) { create(:article) }\n          let!(:match_article) do\n            create(:article,\n                   published_at: DateTime.new(2012, 2, 13).in_time_zone)\n          end\n\n          it { expect(subject).to eq([match_article]) }\n        end\n\n        context \"with same user_id article\" do\n          let(:params) { { user_id: \"13\" } }\n          let!(:article) { create(:article) }\n          let!(:match_article) { create(:article, user_id: 13) }\n\n          it { expect(subject).to eq([match_article]) }\n        end\n\n        context \"with not published status article\" do\n          let(:params) { { published: \"0\" } }\n          let!(:article) { create(:article) }\n          let!(:match_article) { create(:article, state: \"draft\") }\n\n          it { expect(subject).to eq([match_article]) }\n        end\n\n        context \"with published status article\" do\n          let(:params) { { published: \"1\" } }\n          let!(:article) { create(:article) }\n\n          it { expect(subject).to eq([article]) }\n        end\n      end\n    end\n  end\n\n  describe \"#author_name\" do\n    let(:content) { described_class.new(author: author) }\n\n    context \"with an author with a name\" do\n      let(:author) { build(:user, name: \"Henri\") }\n\n      it { expect(content.author_name).to eq(author.name) }\n    end\n\n    context \"with an author without a name\" do\n      let(:author) { build(:user, name: \"\") }\n\n      it { expect(content.author_name).to eq(author.login) }\n    end\n  end\n\n  describe \"#generate_html\" do\n    context \"with a blog with markdown filter\" do\n      let!(:blog) { create(:blog, comment_text_filter: \"markdown\") }\n\n      context \"comment with italic and bold\" do\n        let(:comment) { build(:comment, body: \"Comment body _italic_ **bold**\") }\n\n        it \"converts the comment markup to HTML\" do\n          expect(comment.generate_html(:body)).to match(%r{<em>italic</em>})\n          expect(comment.generate_html(:body)).to match(%r{<strong>bold</strong>})\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Note, type: :model do\n  context \"with a simple blog\" do\n    let!(:blog) { create(:blog) }\n\n    describe \"validations\" do\n      it { expect(build(:note)).to be_valid }\n      it { expect(build(:note).redirect).to be_blank }\n      it { expect(create(:note).redirect).not_to be_blank }\n      it { expect(build(:note, body: nil)).to be_invalid }\n\n      it \"with a nil body, return default error message\" do\n        note = build(:note, body: nil)\n        note.save\n        expect(note.errors[:body]).to eq([\"can't be blank\"])\n      end\n\n      context \"with an existing note\" do\n        let(:existing_note) { create(:note) }\n\n        it { expect(build(:note, guid: existing_note.guid)).to be_invalid }\n      end\n    end\n\n    describe \"permalink\" do\n      let(:note) do\n        Rails.cache.clear\n        create(:note, body: \"\u00e0\u00e9\")\n      end\n\n      it { expect(note.permalink).to eq(\"#{note.id}-ae\") }\n      it { expect(note.permalink_url).to eq(\"#{blog.base_url}/note/#{note.id}-ae\") }\n\n      context \"with a particular blog\" do\n        before do\n          allow_any_instance_of(Blog).\n            to receive(:custom_url_shortener).and_return(url_shortener)\n          allow_any_instance_of(Blog).\n            to receive(:base_url).and_return(\"http://mybaseurl.net\")\n        end\n\n        context \"with a blog that have a custome url shortener\" do\n          let(:url_shortener) { \"shor.tl\" }\n\n          it {\n            expect(note.short_link).\n              to eq(\"#{url_shortener} #{note.redirect.from_path}\")\n          }\n        end\n\n        context \"with a blog that does not have a custome url shortener\" do\n          let(:url_shortener) { nil }\n\n          it { expect(note.short_link).to eq(\"mybaseurl.net #{note.redirect.from_path}\") }\n        end\n      end\n    end\n\n    describe \"#redirect\" do\n      let(:note) { create(:note) }\n\n      it { expect(note.redirect.to_path).to eq note.permalink_url }\n    end\n\n    describe \"scopes\" do\n      describe \"#published\" do\n        let(:note) { create(:note, published_at: 1.minute.ago) }\n\n        context \"with a unpublished note\" do\n          let!(:unpublished_note) { create(:unpublished_note) }\n\n          it { expect(described_class.published).to eq([note]) }\n        end\n\n        context \"with a note to publish later\" do\n          let!(:later_note) { create(:note, published_at: 3.days.from_now) }\n\n          it { expect(described_class.published).to eq([note]) }\n        end\n      end\n    end\n\n    describe \"send_to_twitter\" do\n      context \"with a simple note\" do\n        let(:note) { build(:note) }\n\n        context \"with twitter configured for blog and user\" do\n          before do\n            expect_any_instance_of(Blog).\n              to receive(:has_twitter_configured?).and_return(true)\n            expect_any_instance_of(User).\n              to receive(:has_twitter_configured?).and_return(true)\n          end\n\n          it { expect(note.send_to_twitter).to be_falsey }\n        end\n\n        context \"with twitter not configured for blog\" do\n          before do\n            expect_any_instance_of(Blog).\n              to receive(:has_twitter_configured?).and_return(false)\n          end\n\n          it { expect(note.send_to_twitter).to be_falsey }\n        end\n\n        context \"with a twitter configured for blog but not user\" do\n          before do\n            expect_any_instance_of(Blog).\n              to receive(:has_twitter_configured?).and_return(true)\n            expect_any_instance_of(User).\n              to receive(:has_twitter_configured?).and_return(false)\n          end\n\n          it { expect(note.send_to_twitter).to be_falsey }\n        end\n      end\n\n      context \"with a more than 140 char note\" do\n        let(:note) do\n          create :note, body: <<~TXT\n            A big message that contains more than 140 char is not too\n            hard to do. You only need to speak as a french guy, a lot to\n            say nothing. And that is  probably the best way to write more\n            than 140 char.\n          TXT\n        end\n\n        let(:fake_twitter) { double(Twitter::REST::Client) }\n\n        before do\n          expect(Twitter::REST::Client).to receive(:new).and_return(fake_twitter)\n          expect(fake_twitter).\n            to receive(:update).\n            and_raise(Twitter::Error::Forbidden.new(\"Status is over 140 characters.\"))\n          expect_any_instance_of(Blog).to receive(:has_twitter_configured?).and_return(true)\n          expect_any_instance_of(User).to receive(:has_twitter_configured?).and_return(true)\n          note.send_to_twitter\n        end\n\n        it {\n          expect(note.errors.full_messages).\n            to eq([\"Message Status is over 140 characters.\"])\n        }\n      end\n    end\n\n    describe \"twitter_url\" do\n      let(:user) { build(:user, twitter: \"@hello\") }\n      let(:note) { build(:note, user: user, settings: { twitter_id: \"12345678901234\" }) }\n\n      it {\n        expect(note.twitter_url).\n          to eq(\"https://twitter.com/#{note.user.twitter}/status/#{note.twitter_id}\")\n      }\n    end\n\n    describe \"default_text_filter\" do\n      let(:note) { build(:note) }\n\n      it { expect(note.default_text_filter.name).to eq(note.blog.text_filter) }\n    end\n\n    describe \"twitter_message\" do\n      let(:blog) { create :blog, base_url: \"http://myblog.net\" }\n      let(:note) { create(:note, blog: blog, body: tweet) }\n\n      context \"with a short simple message\" do\n        let(:tweet) { \"A message without URL\" }\n\n        it { expect(note.twitter_message).to start_with(tweet) }\n        it { expect(note.twitter_message).to end_with(\" (#{note.short_link})\") }\n      end\n\n      context \"with a short message with short HTTP url\" do\n        let(:tweet) { \"A message with a short URL http://foo.com\" }\n\n        it { expect(note.twitter_message).to eq(\"#{tweet} (#{note.short_link})\") }\n      end\n\n      context \"with a short message much more than 114 char\" do\n        let(:tweet) do\n          \"A very big(10) message with lot of text (40)inside just to try the\" \\\n          \" shortener and (80)the new link that publify must create and add at the end\"\n        end\n        let(:expected_tweet) do\n          \"A very big(10) message with lot of text (40)inside just to try the\" \\\n          \" shortener and (80)the new link that publify... (#{note.redirect.from_url})\"\n        end\n\n        it { expect(note.twitter_message).to eq(expected_tweet) }\n        it { expect(note.twitter_message.length).to eq(140) }\n      end\n\n      context \"With a test message from production...\" do\n        let(:tweet) do\n          \"Le dojo de nantes, c'est comme au McDo, sans les odeurs, et en plus rigolo:\" \\\n            \" RT @abailly Ce midi c'est coding dojo \u00e0 la Cantine #Nantes.\" \\\n            \" Pour s'inscrire si vous voulez c'est ici:\" \\\n            \" http://cantine.atlantic2.org/evenements/coding-dojo-8/ \u2026\" \\\n            \" Sinon venez comme vous \u00eates\"\n        end\n        let(:expected_tweet) do\n          \"Le dojo de nantes, c'est comme au McDo, sans les odeurs, et en plus rigolo:\" \\\n          \" RT @abailly Ce midi c'est coding... (#{note.redirect.from_url})\"\n        end\n\n        it { expect(note.twitter_message).to eq(expected_tweet) }\n        it { expect(note.twitter_message.length).to eq(138) }\n      end\n\n      context \"with a bug message\" do\n        let(:tweet) do\n          '\"JSFuck is an esoteric and educational programming style based on the' \\\n          \" atomic parts of JavaScript. It uses only six different characters to\" \\\n          ' write and execute code.\" http://www.jsfuck.com/ '\n        end\n        let(:expected_tweet) do\n          \"\\\"JSFuck is an esoteric and educational programming style based on the\" \\\n          \" atomic parts of JavaScript. It uses only... (#{note.redirect.from_url})\"\n        end\n\n        it { expect(note.twitter_message).to eq(expected_tweet) }\n        it { expect(note.twitter_message.length).to eq(140) }\n      end\n\n      context \"don't cut word\" do\n        let(:tweet) do\n          \"Le #mobprogramming c'est un peu comme faire un dojo sur une journ\u00e9e enti\u00e8re\" \\\n          \" (\u00e7a permet s\u00fbrement de faire des petites journ\u00e9es ;-))\"\n        end\n        let(:expected_tweet) do\n          \"Le #mobprogramming c'est un peu comme faire un dojo sur une journ\u00e9e enti\u00e8re\" \\\n          \" (\u00e7a permet s\u00fbrement de faire des... (#{note.redirect.from_url})\"\n        end\n\n        it { expect(note.twitter_message).to eq(expected_tweet) }\n        it { expect(note.twitter_message.length).to eq(138) }\n      end\n\n      context \"shortener host name is counted as an url by twitter\" do\n        let(:tweet) do\n          \"RT @stephaneducasse http://pharocloud.com is so cool. I love love such idea\" \\\n          \" and I wish them success. Excellent work.\"\n        end\n        let(:expected_tweet) do\n          \"RT @stephaneducasse http://pharocloud.com is so cool. I love love such idea\" \\\n          \" and I wish them success. Excellent... (#{note.redirect.from_url})\"\n        end\n\n        it { expect(note.twitter_message).to eq(expected_tweet) }\n        it { expect(note.twitter_message.length).to eq(140) }\n      end\n    end\n  end\n\n  context \"with a dofollowify blog\" do\n    let!(:blog) { create(:blog, dofollowify: true) }\n\n    describe \"Testing hashtag and @mention replacement in html postprocessing\" do\n      it \"replaces a hashtag with a proper URL to Twitter search\" do\n        note = build(:note, body: \"A test tweet with a #hashtag\")\n        expected =\n          \"A test tweet with a <a href='https://twitter.com/search?q=%23hashtag&\" \\\n          \"src=tren&mode=realtime'>#hashtag</a>\"\n        expect(note.html_preprocess(nil, note.body)).to eq(expected)\n      end\n\n      it \"replaces a @mention by a proper URL to the twitter account\" do\n        note = create(:note, body: \"A test tweet with a @mention\")\n        expected = \"A test tweet with a <a href='https://twitter.com/mention'>@mention</a>\"\n        expect(note.html_preprocess(nil, note.body)).to eq(expected)\n      end\n\n      it \"replaces a http URL by a proper link\" do\n        note = create(:note, body: \"A test tweet with a http://link.com\")\n        expected = \"A test tweet with a <a href='http://link.com'>http://link.com</a>\"\n        expect(note.html_preprocess(nil, note.body)).to eq(expected)\n      end\n\n      it \"replaces a https URL with a proper link\" do\n        note = create(:note, body: \"A test tweet with a https://link.com\")\n        expected = \"A test tweet with a <a href='https://link.com'>https://link.com</a>\"\n        expect(note.html_preprocess(nil, note.body)).to eq(expected)\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Page, type: :model do\n  let!(:blog) { create(:blog) }\n\n  describe \"before save\" do\n    context \"when saving a page without a name\" do\n      let(:page) { create(:page, name: nil, title: \"A title\") }\n\n      it \"sets the name based on the title\" do\n        expect(page.name).to eq(\"a-title\")\n      end\n    end\n  end\n\n  describe \"#permalink_url\" do\n    let(:page) { build(:page, name: \"page_one\", blog: blog) }\n\n    it \"returns a full url based on the page name in the pages section\" do\n      expect(page.permalink_url).to eq(\"#{blog.base_url}/pages/page_one\")\n    end\n  end\n\n  describe \"validations\" do\n    context \"with an existing page name\" do\n      let!(:page) { create(:page, name: \"page_one\") }\n\n      it { expect(build(:page, name: page.name)).to be_invalid }\n    end\n\n    context \"without name\" do\n      it { expect(build(:page, name: nil)).to be_valid }\n    end\n\n    context \"without body\" do\n      it { expect(build(:page, body: nil)).to be_invalid }\n    end\n\n    context \"without title\" do\n      it { expect(build(:page, title: nil)).to be_invalid }\n    end\n  end\n\n  describe \"default_text_filter\" do\n    it { expect(create(:page).default_text_filter.name).to eq(blog.text_filter) }\n  end\n\n  describe \"search_with\" do\n    context \"with an simple page\" do\n      subject { described_class.search_with(params) }\n\n      let!(:page) { create(:page) }\n\n      context \"with nil params\" do\n        let(:params) { nil }\n\n        it { expect(subject).to eq([page]) }\n      end\n\n      context \"with a matching searchstring page\" do\n        let(:params) { { searchstring: \"foobar\" } }\n        let!(:match_page) { create(:page, title: \"foobar\") }\n\n        it { expect(subject).to eq([match_page]) }\n      end\n\n      context \"with 2 pages with title aaa and zzz\" do\n        let!(:last_page) { create(:page, title: \"ZZZ\", state: \"published\") }\n        let!(:first_page) { create(:page, title: \"AAA\", state: \"published\") }\n        let(:params) { { published: \"1\" } }\n\n        it { expect(subject).to eq([first_page, page, last_page]) }\n      end\n    end\n  end\n\n  describe \"#redirect\" do\n    context \"with a simple page\" do\n      let(:page) { create(:page) }\n\n      it { expect(page.redirect.to_path).to eq(page.permalink_url) }\n    end\n\n    context \"with an unpublished page\" do\n      let(:page) { create(:page, state: \"draft\") }\n\n      it { expect(page.redirect).to be_blank }\n    end\n  end\nend\n", "<h1 class='page-header'><%= link_to_permalink(@page, @page.title) %></h1>\n<%= raw @page.html %>\n", "<li class='list-unstyled' id=\"comment-<%= comment.id %>\">\n  <%= avatar_tag(email: comment.email, url: comment.url, class: 'img-circle pull-left gravatar') %>\n  <div class='content'>\n    <h4>\n      <%= t('.by') %> <%= comment.url.blank? ? h(comment.author) : nofollowified_link_to(h(comment.author), comment.url) %>\n      <%= display_date_and_time comment.created_at %>\n    </h4>\n    <%= raw comment.html %>\n    <%- unless comment.published? %>\n      <div class=\"spamwarning\"><%= t('.this_comment_has_been_flagged_for_moderator_approval') %></div>\n    <%- end %>\n    <hr />\n  </div>\n</li>\n"], "fixing_code": ["# frozen_string_literal: true\n\n# Methods added to this helper will be available to all templates in the application.\nrequire \"digest/sha1\"\n\nmodule BaseHelper\n  include BlogHelper\n\n  # Need to rewrite this one, quick hack to test my changes.\n  attr_reader :page_title\n\n  def render_sidebars\n    rendered_sidebars = Sidebar.order(:active_position).map do |sb|\n      @sidebar = sb\n      sb.parse_request(content_array, params)\n      render_sidebar(sb)\n    end\n    safe_join rendered_sidebars\n  rescue => e\n    logger.error e\n    logger.error e.backtrace.join(\"\\n\")\n    I18n.t(\"errors.render_sidebar\")\n  end\n\n  def render_sidebar(sidebar)\n    render_to_string(partial: sidebar.content_partial, locals: sidebar.to_locals_hash,\n                     layout: false)\n  end\n\n  def themeable_stylesheet_link_tag(name)\n    src = this_blog.current_theme.path + \"/stylesheets/#{name}.css\"\n    stylesheet_link_tag \"/stylesheets/theme/#{name}.css\" if File.exist? src\n  end\n\n  def themeable_javascript_include_tag(name)\n    src = this_blog.current_theme.path + \"/javascripts/#{name}.js\"\n    javascript_include_tag \"/javascripts/theme/#{name}.js\" if File.exist? src\n  end\n\n  def render_to_string(*args, &block)\n    controller.send(:render_to_string, *args, &block)\n  end\n\n  def link_to_permalink(item, title, anchor = nil, style = nil, nofollow = nil,\n                        only_path = false)\n    options = {}\n    options[:class] = style if style\n    options[:rel] = \"nofollow\" if nofollow\n    url = item.permalink_url(anchor, only_path)\n    if url\n      link_to title, url, options\n    else\n      title\n    end\n  end\n\n  def avatar_tag(options = {})\n    begin\n      avatar_class = this_blog.plugin_avatar.constantize\n    rescue NameError\n      return \"\"\n    end\n    return \"\" unless avatar_class.respond_to?(:get_avatar)\n\n    avatar_class.get_avatar(options)\n  end\n\n  def meta_tag(name, value)\n    tag :meta, name: name, content: value if value.present?\n  end\n\n  def markup_help_popup(markup, text)\n    if markup && markup.commenthelp.size > 1\n      link_to(text,\n              url_for(controller: \"articles\", action: \"markup_help\", id: markup.name),\n              onclick: \"return popup(this, 'Publify Markup Help')\")\n    else\n      \"\"\n    end\n  end\n\n  def onhover_show_admin_tools(type, id = nil)\n    admin_id = \"#admin_#{[type, id].compact.join(\"_\")}\"\n    tag = []\n    tag << %{ onmouseover=\"if (getCookie('publify_user_profile') == 'admin')\\\n             { $('#{admin_id}').show(); }\" }\n    tag << %{ onmouseout=\"$('#{admin_id}').hide();\" }\n    safe_join(tag, \" \")\n  end\n\n  def feed_title\n    if @feed_title.present?\n      @feed_title\n    elsif @page_title.present?\n      @page_title\n    else\n      this_blog.blog_name\n    end\n  end\n\n  def html(content, what = :all, _deprecated = false)\n    content.html(what)\n  end\n\n  def display_user_avatar(user, size = \"avatar\", klass = \"alignleft\")\n    if user.resource.present?\n      avatar_path = case size\n                    when \"thumb\"\n                      user.resource.upload.thumb.url\n                    when \"medium\"\n                      user.resource.upload.medium.url\n                    when \"large\"\n                      user.resource.upload.large.url\n                    else\n                      user.resource.upload.avatar.url\n                    end\n      return if avatar_path.nil?\n\n      avatar_url = this_blog.file_url(avatar_path)\n    elsif user.twitter_profile_image.present?\n      avatar_url = user.twitter_profile_image\n    end\n    return unless avatar_url\n\n    image_tag(avatar_url, alt: user.nickname, class: klass)\n  end\n\n  def author_picture(status)\n    return if status.user.twitter_profile_image.blank?\n\n    image_tag(status.user.twitter_profile_image, class: \"alignleft\",\n                                                 alt: status.user.nickname)\n  end\n\n  def page_header_includes\n    content_array.map(&:whiteboard).map do |w|\n      w.select { |k, _v| k.start_with?(\"page_header_\") }.map do |_, v|\n        v = v.chomp\n        # trim the same number of spaces from the beginning of each line\n        # this way plugins can indent nicely without making ugly source output\n        spaces = /\\A[ \\t]*/.match(v)[0].gsub(/\\t/, \"  \")\n        # add 2 spaces to line up with the assumed position of the surrounding tags\n        v.gsub!(/^#{spaces}/, \"  \")\n      end\n    end.flatten.uniq.join(\"\\n\")\n  end\n\n  def feed_atom\n    feed_for(\"atom\")\n  end\n\n  def feed_rss\n    feed_for(\"rss\")\n  end\n\n  def content_array\n    if @articles\n      @articles\n    elsif @article\n      [@article]\n    elsif @page\n      [@page]\n    else\n      []\n    end\n  end\n\n  def display_date(date)\n    l(date, format: this_blog.date_format)\n  end\n\n  def display_time(time)\n    time.strftime(this_blog.time_format)\n  end\n\n  def display_date_and_time(timestamp)\n    return if timestamp.blank?\n\n    if this_blog.date_format == \"setting_date_format_distance_of_time_in_words\"\n      timeago_tag timestamp, date_only: false\n    else\n      \"#{display_date(timestamp)} #{t(\"helper.at\")} #{display_time(timestamp)}\"\n    end\n  end\n\n  def show_meta_keyword\n    return unless this_blog.use_meta_keyword\n\n    meta_tag \"keywords\", @keywords if @keywords.present?\n  end\n\n  def stop_index_robots?(blog)\n    stop = (params[:year].present? || params[:page].present?)\n    stop = blog.unindex_tags if controller_name == \"tags\"\n    stop = blog.unindex_categories if controller_name == \"categories\"\n    stop\n  end\n\n  def get_reply_context_url(reply)\n    link_to(reply[\"user\"][\"name\"],\n            reply[\"user\"][\"entities\"][\"url\"][\"urls\"][0][\"expanded_url\"])\n  rescue\n    link_to(reply[\"user\"][\"name\"], \"https://twitter.com/#{reply[\"user\"][\"name\"]}\")\n  end\n\n  def get_reply_context_twitter_link(reply)\n    link_to(display_date_and_time(reply[\"created_at\"].to_time.in_time_zone),\n            \"https://twitter.com/#{reply[\"user\"][\"screen_name\"]}/status/#{reply[\"id_str\"]}\")\n  end\n\n  private\n\n  def feed_for(type)\n    if params[:action] == \"search\"\n      url_for(only_path: false, format: type, q: params[:q])\n    elsif !@article.nil?\n      @article.feed_url(type)\n    elsif !@auto_discovery_url_atom.nil?\n      instance_variable_get(\"@auto_discovery_url_#{type}\")\n    end\n  end\n\n  # fetches appropriate html content for RSS and ATOM feeds. Checks for:\n  # - article being password protected\n  # - hiding extended content on RSS. In this case if there is an excerpt we\n  #   show the excerpt, or else we show the body\n  def fetch_html_content_for_feeds(item, this_blog)\n    if item.password_protected?\n      \"<p>This article is password protected. Please \" \\\n        \"<a href='#{item.permalink_url}'>fill in your password</a> to read it</p>\"\n    elsif this_blog.hide_extended_on_rss\n      if item.excerpt? && !item.excerpt.empty?\n        item.excerpt\n      else\n        html(item, :body)\n      end\n    else\n      html(item, :all)\n    end\n  end\n\n  def nofollowify_links(string)\n    raise ArgumentError, \"string\", \"must be html_safe\" unless string.html_safe?\n\n    if this_blog.dofollowify\n      string\n    else\n      followify_scrubber = Loofah::Scrubber.new do |node|\n        node.set_attribute \"rel\", \"nofollow\" if node.name == \"a\"\n      end\n      sanitize h(string), scrubber: followify_scrubber\n    end\n  end\n\n  def nofollowified_link_to(text, url)\n    if this_blog.dofollowify\n      link_to(text, url)\n    else\n      link_to(text, url, rel: \"nofollow\")\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule ContentBase\n  def self.included(base)\n    base.extend ClassMethods\n  end\n\n  class ContentTextHelpers\n    include ActionView::Helpers::UrlHelper\n    include ActionView::Helpers::TextHelper\n    include ActionView::Helpers::SanitizeHelper\n  end\n\n  attr_accessor :just_changed_published_status\n  alias just_changed_published_status? just_changed_published_status\n\n  def really_send_notifications\n    interested_users.each do |value|\n      send_notification_to_user(value)\n    end\n    true\n  end\n\n  def send_notification_to_user(user)\n    notify_user_via_email(user)\n  end\n\n  # Return HTML for some part of this object.\n  def html(field = :all)\n    if field == :all\n      generate_html(:all, content_fields.map { |f| self[f].to_s }.join(\"\\n\\n\"))\n    elsif html_map(field)\n      generate_html(field)\n    else\n      raise ArgumentError, \"Field #{field.inspect} is not valid for #{self.class}\"\n    end\n  end\n\n  # Generate HTML for a specific field using the text_filter in use for this\n  # object.\n  def generate_html(field, text = nil)\n    text ||= self[field].to_s\n    prehtml = html_preprocess(field, text).to_s\n    html = (text_filter || default_text_filter).filter_text(prehtml) || prehtml\n    html_postprocess(field, html).to_s\n  end\n\n  # Post-process the HTML\n  def html_postprocess(_field, html)\n    helper = ContentTextHelpers.new\n    helper.sanitize html\n  end\n\n  def html_preprocess(_field, html)\n    html\n  end\n\n  def html_map(field)\n    content_fields.include? field\n  end\n\n  def excerpt_text(length = 160)\n    text = if respond_to?(:excerpt) && (excerpt || \"\") != \"\"\n             generate_html(:excerpt, excerpt)\n           else\n             html(:all)\n           end\n\n    text = text.strip_html\n\n    text.slice(0, length) +\n      (text.length > length ? \"...\" : \"\")\n  end\n\n  def text_filter\n    TextFilter.make_filter(text_filter_name)\n  end\n\n  # The default text filter.  Generally, this is the filter specified by blog.text_filter,\n  # but comments may use a different default.\n  def default_text_filter\n    blog.text_filter_object\n  end\n\n  module ClassMethods\n    def content_fields(*attribs)\n      class_eval \"def content_fields; #{attribs.inspect}; end\"\n    end\n\n    def default_order\n      \"published_at DESC\"\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"aasm\"\nrequire \"akismet\"\n\nclass Feedback < ApplicationRecord\n  self.table_name = \"feedback\"\n\n  belongs_to :article, touch: true\n\n  include PublifyGuid\n  include ContentBase\n\n  validate :feedback_not_closed, on: :create\n  validates :article, presence: true\n\n  before_save :correct_url, :classify_content\n  before_create :create_guid, :article_allows_this_feedback\n\n  # TODO: Rename so it doesn't sound like only approved ham\n  scope :ham, -> { where(state: %w(presumed_ham ham)) }\n\n  scope :spam, -> { where(state: \"spam\") }\n  scope :created_since, ->(time) { ham.where(\"created_at > ?\", time) }\n  scope :presumed_ham, -> { where(state: \"presumed_ham\") }\n  scope :presumed_spam, -> { where(state: \"presumed_spam\") }\n  scope :unapproved, -> { where(state: [\"presumed_spam\", \"presumed_ham\"]) }\n\n  scope :published, -> { ham }\n  scope :oldest_first, -> { order(:created_at) }\n  scope :newest_first, -> { order(created_at: :desc) }\n\n  include AASM\n\n  aasm column: :state do\n    state :unclassified, initial: true\n    state :presumed_ham\n    state :presumed_spam\n    state :spam, after_enter: [:send_notifications, :report_as_spam]\n    state :ham, after_enter: [:send_notifications, :report_as_ham]\n\n    event :presume_ham do\n      transitions from: :unclassified, to: :ham, if: ->() { user_id.present? }\n      transitions from: :unclassified, to: :presumed_ham\n    end\n\n    event :presume_spam do\n      transitions from: :unclassified, to: :presumed_spam\n    end\n\n    event :mark_as_ham do\n      transitions to: :ham\n    end\n\n    event :mark_as_spam do\n      transitions to: :spam\n    end\n\n    event :withdraw do\n      transitions from: [:presumed_ham, :ham], to: :spam\n    end\n  end\n\n  # FIXME: Inline this method\n  def self.paginated(page, per_page)\n    page(page).per(per_page)\n  end\n\n  def parent\n    article\n  end\n\n  def classify_content\n    return unless unclassified?\n\n    case classify\n    when :ham then presume_ham\n    else presume_spam\n    end\n  end\n\n  def permalink_url(_anchor = :ignored, only_path = false)\n    article.permalink_url(\"#{self.class.to_s.downcase}-#{id}\", only_path)\n  end\n\n  def html_postprocess(_field, html)\n    helper = ContentTextHelpers.new\n    helper.sanitize(helper.auto_link(html))\n  end\n\n  def correct_url\n    return if url.blank?\n\n    self.url = \"http://#{url}\" unless %r{^https?://}.match?(url)\n  end\n\n  def article_allows_this_feedback\n    article && blog_allows_feedback? && article_allows_feedback?\n  end\n\n  def blog_allows_feedback?\n    true\n  end\n\n  def akismet_options\n    { type: self.class.to_s.downcase,\n      author: originator,\n      author_email: email,\n      author_url: url,\n      text: body }\n  end\n\n  def spam_fields\n    [:title, :body, :ip, :url]\n  end\n\n  def classify\n    return :ham if user_id\n    return :spam if blog.default_moderate_comments\n    return :ham unless blog.sp_global\n\n    # Yeah, three state logic is evil...\n    case sp_is_spam? || akismet_is_spam?\n    when nil then :spam\n    when true then :spam\n    when false then :ham\n    end\n  end\n\n  def sp_is_spam?(_options = {})\n    sp = SpamProtection.new(blog)\n    Timeout.timeout(30) do\n      spam_fields.any? do |field|\n        sp.is_spam?(send(field))\n      end\n    end\n  rescue Timeout::Error\n    nil\n  end\n\n  def akismet_is_spam?(_options = {})\n    return false if akismet.nil?\n\n    begin\n      Timeout.timeout(60) do\n        akismet.comment_check(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def change_state!\n    result = \"\"\n    if spam? || presumed_spam?\n      mark_as_ham!\n      result = \"ham\"\n    else\n      mark_as_spam!\n      result = \"spam\"\n    end\n    result\n  end\n\n  def confirm_classification!\n    confirm_classification\n    save!\n  end\n\n  def confirm_classification\n    if presumed_spam?\n      mark_as_spam\n    elsif presumed_ham?\n      mark_as_ham\n    end\n  end\n\n  def report_as_spam\n    return if akismet.nil?\n\n    begin\n      Timeout.timeout(5) do\n        akismet.submit_spam(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def report_as_ham\n    return if akismet.nil?\n\n    begin\n      Timeout.timeout(5) do\n        akismet.ham(ip, user_agent, akismet_options)\n      end\n    rescue Timeout::Error\n      nil\n    end\n  end\n\n  def feedback_not_closed\n    errors.add(:article_id, \"Comment are closed\") if article.comments_closed?\n  end\n\n  def send_notifications\n    nil\n  end\n\n  def published?\n    ham? || presumed_ham?\n  end\n\n  def status_confirmed?\n    ham? || spam?\n  end\n\n  def spammy?\n    spam? || presumed_spam?\n  end\n\n  delegate :blog, to: :article\n\n  private\n\n  def akismet\n    @akismet ||= akismet_client\n  end\n\n  def akismet_client\n    return nil if blog.sp_akismet_key.blank?\n\n    client = Akismet::Client.new(blog.sp_akismet_key, blog.base_url)\n    begin\n      client.verify_key ? client : nil\n    rescue SocketError\n      nil\n    end\n  end\n\n  def blog_id\n    article.blog_id if article.present?\n  end\nend\n", "<% cache article do %>\n  <% if article.excerpt? %>\n    <%= article.excerpt %>\n    <div class=\"extended\">\n      <p><%= link_to_permalink article, t('.continue_reading') %></p>\n    </div>\n  <% else %>\n    <%= article.html(:body) %>\n    <% if article.extended? %>\n      <div class=\"extended\">\n        <p><%= link_to_permalink article, t('.continue_reading') %></p>\n      </div>\n    <% end %>\n  <% end %>\n<% end %>\n", "<% cache article do %>\n  <%= article.html(:body) %>\n  <%= article.html(:extended) %>\n<% end %>\n", "<div id=\"viewpage\">\n  <%= html @page %>\n</div>\n", "<% cache comment do %>\n  <li id=\"comment-<%= comment.id %>\" <%= 'class=\"author_comment\"' if comment.user %> <%= onhover_show_admin_tools(:comment, comment.id) %>>\n    <p class=\"author\">\n    <%= avatar_tag(email: comment.email, url: comment.url) %>\n    <cite><strong><%= link_to_unless(comment.url.blank?, h(comment.author), comment.url) %></strong></cite>\n    <%= t('.said') %> <%= display_date_and_time comment.created_at %>:\n    </p>\n    <div class=\"content\">\n      <%= nofollowify_links comment.generate_html(:body) %>\n      <% unless comment.published? %>\n        <div class=\"spamwarning\">\n          <%= t('.this_comment_has_been_flagged_for_moderator_approval') %>\n        </div>\n      <% end %>\n    </div>\n  </li>\n<% end %>\n", "<% cache [note, note.user] do %>\n  <article class='status'>\n    <%= author_picture note %>\n    <div class='p-name entry-title e-content entry-content article'><%= note.html(:body) %></div>\n    <footer>\n      <small>\n        <%= link_to_permalink(note, display_date_and_time(note.published_at)) %> |\n        <%= link_to note.redirect.from_url, note.redirect.from_url %> |\n        <%= author_link note %>\n        <% unless note.twitter_id.blank? %>\n          <%= \" | #{link_to(t('.view_on_twitter'), note.twitter_url, class: 'u-syndication', rel: 'syndication')}\" %>\n        <% end %>\n      </small>\n    </footer>\n  </article>\n<% end %>\n", "<div class=\"hfeed\">\n  <% for note in @notes %>\n  <div class='h-entry hentry h-as-note'>\n    <article>\n      <p class='p-name entry-title e-content entry-content article'><%= note.html(:body) %></p>\n      <footer>\n        <small><%= link_to_permalink(note, display_date_and_time(note.published_at)) %></small>\n      </footer>\n    </article>\n        <hr />\n  </div>\n  <% end %>\n</div>\n\n<%= paginate @notes %>\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\nclass TestBrokenSidebar < Sidebar\n  description \"Invalid test sidebar\"\n  def parse_request(_contents, _request_params)\n    raise \"I'm b0rked!\"\n  end\nend\n\ndescribe BaseHelper, type: :helper do\n  describe \"#link_to_permalink\" do\n    describe \"for a simple ascii-only permalink\" do\n      let(:article) do\n        build(:article, published_at: Date.new(2004, 6, 1).to_datetime,\n                        title: \"An Article sample\")\n      end\n\n      it {\n        expect(link_to_permalink(article, \"title\")).\n          to eq(\"<a href=\\\"#{article.permalink_url}\\\">title</a>\")\n      }\n    end\n\n    describe \"for a multibyte permalink\" do\n      let(:article) { build(:article, permalink: \"\u30eb\u30d3\u30fc\") }\n\n      it {\n        expect(link_to_permalink(article, \"title\")).\n          to include(\"%E3%83%AB%E3%83%93%E3%83%BC\")\n      }\n    end\n\n    it \"returns just the title for unpublished articles\" do\n      article = build :unpublished_article\n      expect(link_to_permalink(article, \"the-title\")).to eq \"the-title\"\n    end\n  end\n\n  describe \"#stop_index_robots?\" do\n    subject { helper.stop_index_robots?(blog) }\n\n    let(:blog) { build :blog }\n\n    context \"default\" do\n      it { expect(subject).to be_falsey }\n    end\n\n    context \"with year:2010\" do\n      before { params[:year] = 2010 }\n\n      it { expect(subject).to be_truthy }\n    end\n\n    context \"with page:2\" do\n      before { params[:page] = 2 }\n\n      it { expect(subject).to be_truthy }\n    end\n\n    context \"for the tags controller\" do\n      before { allow(helper).to receive(:controller_name).and_return(\"tags\") }\n\n      context \"with unindex_tags set to true in blog\" do\n        before { expect(blog).to receive(:unindex_tags).and_return(true) }\n\n        it { expect(subject).to be_truthy }\n      end\n\n      context \"with unindex_tags set to false in blog\" do\n        before { expect(blog).to receive(:unindex_tags).and_return(false) }\n\n        it { expect(subject).to be_falsey }\n      end\n    end\n\n    context \"for the categories controller\" do\n      before { allow(helper).to receive(:controller_name).and_return(\"categories\") }\n\n      context \"with unindex_tags to true set in blog\" do\n        before { expect(blog).to receive(:unindex_categories).and_return(true) }\n\n        it { expect(subject).to be_truthy }\n      end\n\n      context \"with unindex_tags set to false in blog\" do\n        before { expect(blog).to receive(:unindex_categories).and_return(false) }\n\n        it { expect(subject).to be_falsey }\n      end\n    end\n  end\n\n  describe \"#get_reply_context_url\" do\n    it \"returns a link to the reply's URL if given\" do\n      reply = {\n        \"user\" => {\n          \"name\" => \"truc\",\n          \"entities\" => { \"url\" => { \"urls\" => [{ \"expanded_url\" => \"an url\" }] } },\n        },\n      }\n      expect(get_reply_context_url(reply)).to eq '<a href=\"an url\">truc</a>'\n    end\n\n    it \"returns a link to the reply's user if no URL is given\" do\n      reply = { \"user\" => { \"name\" => \"truc\", \"entities\" => {} } }\n      expect(get_reply_context_url(reply)).\n        to eq '<a href=\"https://twitter.com/truc\">truc</a>'\n    end\n  end\n\n  describe \"#get_reply_context_twitter_link\" do\n    let(:reply) do\n      { \"id_str\" => \"123456789\",\n        \"created_at\" => \"Thu Jan 23 13:47:00 +0000 2014\",\n        \"user\" => {\n          \"screen_name\" => \"a_screen_name\",\n          \"entities\" => { \"url\" => { \"urls\" => [{ \"expanded_url\" => \"an url\" }] } },\n        } }\n    end\n\n    it \"returns a link with the creation date and time\" do\n      timezone = Time.zone\n      Time.zone = \"UTC\"\n\n      expect(get_reply_context_twitter_link(reply)).\n        to eq '<a href=\"https://twitter.com/a_screen_name/status/123456789\">' \\\n        \"23/01/2014 at 13h47</a>\"\n    ensure\n      Time.zone = timezone\n    end\n\n    it \"displays creation date and time in the current time zone\" do\n      timezone = Time.zone\n      Time.zone = \"Tokyo\"\n\n      expect(get_reply_context_twitter_link(reply)).\n        to eq '<a href=\"https://twitter.com/a_screen_name/status/123456789\">' \\\n        \"23/01/2014 at 22h47</a>\"\n    ensure\n      Time.zone = timezone\n    end\n  end\n\n  describe \"#nofollowified_link_to\" do\n    it \"with dofollowify disabled, links should be nofollowed\" do\n      this_blog.dofollowify = false\n\n      expect(nofollowified_link_to(\"my blog\", \"http://myblog.net\")).\n        to eq '<a rel=\"nofollow\" href=\"http://myblog.net\">my blog</a>'\n    end\n\n    it \"with dofollowify enabled, links should be nofollowed\" do\n      this_blog.dofollowify = true\n\n      expect(nofollowified_link_to(\"my blog\", \"http://myblog.net\")).\n        to eq '<a href=\"http://myblog.net\">my blog</a>'\n    end\n  end\n\n  describe \"#nofollowify_links\" do\n    let(:original_html) { '<a href=\"http://myblog.net\">my blog</a>'.html_safe }\n\n    before do\n      @blog = create :blog\n    end\n\n    it \"with dofollowify disabled, links should be nofollowed\" do\n      @blog.dofollowify = false\n      @blog.save\n\n      result = nofollowify_links(original_html)\n\n      aggregate_failures do\n        expect(result).to eq('<a href=\"http://myblog.net\" rel=\"nofollow\">my blog</a>')\n        expect(result).to be_html_safe\n      end\n    end\n\n    it \"with dofollowify enabled, links should be not nofollowed\" do\n      @blog.dofollowify = true\n      @blog.save\n\n      result = nofollowify_links(original_html)\n\n      aggregate_failures do\n        expect(result).to eq('<a href=\"http://myblog.net\">my blog</a>')\n        expect(result).to be_html_safe\n      end\n    end\n\n    it \"does not accept unsafe html\" do\n      expect { nofollowify_links(\"just an unsafe string\") }.to raise_error ArgumentError\n    end\n  end\n\n  describe \"#render_sidebars\" do\n    let(:blog) { create :blog }\n\n    before do\n      allow(controller).to receive(:render_to_string).and_return \"Rendered\"\n    end\n\n    describe \"with an invalid sidebar\" do\n      before do\n        TestBrokenSidebar.new(blog: blog).save\n      end\n\n      def logger\n        fake_logger = double(\"fake logger\")\n        expect(fake_logger).to receive(:error)\n        fake_logger\n      end\n\n      it \"returns a friendly error message\" do\n        expect(render_sidebars).to match(/It seems something went wrong/)\n      end\n    end\n\n    describe \"with a valid sidebar\" do\n      before do\n        Sidebar.new(blog: blog).save\n      end\n\n      it \"renders the sidebar\" do\n        expect(render_sidebars).to match(/Rendered/)\n      end\n    end\n  end\n\n  describe \"#display_date\" do\n    [\"%d/%m/%y\", \"%m/%m/%y\", \"%d %b %Y\", \"%b %d %Y\", \"%I:%M%p\", \"%H:%M\",\n     \"%Hh%M\"].each do |spec|\n      it \"use #{spec} format from blog to render date\" do\n        create(:blog, date_format: spec)\n        article = build(:article)\n        expect(display_date(article.published_at)).\n          to eq(article.published_at.strftime(spec))\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"timecop\"\n\ndescribe Article, type: :model do\n  let(:blog) { create(:blog) }\n\n  it \"test_content_fields\" do\n    a = blog.articles.build\n    assert_equal [:body, :extended], a.content_fields\n  end\n\n  describe \"#permalink_url\" do\n    describe \"with hostname\" do\n      let(:article) do\n        blog.articles.build(permalink: \"article-3\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"includes the full blog url\" do\n        article.publish\n        expect(article.permalink_url(nil, false)).\n          to eq \"#{blog.base_url}/2004/06/01/article-3\"\n      end\n    end\n\n    describe \"without hostname\" do\n      let(:article) do\n        blog.articles.build(permalink: \"article-3\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"includes just the blog root path\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq \"#{blog.root_path}/2004/06/01/article-3\"\n      end\n    end\n\n    # NOTE: URLs must not have any multibyte characters in them. The\n    # browser may display them differently, though.\n    describe \"with a multibyte permalink\" do\n      let(:article) do\n        blog.articles.build(permalink: \"\u30eb\u30d3\u30fc\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"escapes the multibyte characters\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/%E3%83%AB%E3%83%93%E3%83%BC\")\n      end\n    end\n\n    describe \"with a permalink containing a space\" do\n      let(:article) do\n        blog.articles.build(permalink: \"hello there\",\n                            published_at: Time.utc(2004, 6, 1))\n      end\n\n      it \"escapes the space as '%20', not as '+'\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/hello%20there\")\n      end\n    end\n\n    describe \"with a permalink containing a plus\" do\n      let(:article) do\n        blog.articles.build(permalink: \"one+two\", published_at: Time.utc(2004,\n                                                                         6, 1))\n      end\n\n      it \"does not escape the plus\" do\n        article.publish\n        expect(article.permalink_url(nil, true)).\n          to eq(\"#{blog.root_path}/2004/06/01/one+two\")\n      end\n    end\n\n    it \"returns nil when the article is not published\" do\n      article = blog.articles.build(permalink: \"one+two\")\n\n      expect(article.permalink_url(nil, true)).to be_nil\n    end\n  end\n\n  describe \"#initialize\" do\n    it \"accepts a settings field in its parameter hash\" do\n      blog.articles.build(\"password\" => \"foo\")\n    end\n  end\n\n  describe \".feed_url\" do\n    let(:article) do\n      build(:article, permalink: \"article-3\", published_at: Time.utc(2004, 6,\n                                                                     1))\n    end\n\n    it \"returns url for atom feed for a Atom 1.0 asked\" do\n      expect(article.feed_url(\"atom10\")).to eq \"#{blog.base_url}/2004/06/01/article-3.atom\"\n    end\n\n    it \"returns url for rss feed for a RSS 2 asked\" do\n      expect(article.feed_url(\"rss20\")).to eq \"#{blog.base_url}/2004/06/01/article-3.rss\"\n    end\n  end\n\n  it \"test_create\" do\n    a = blog.articles.build\n    a.user_id = 1\n    a.body = \"Foo\"\n    a.title = \"Zzz\"\n    assert a.save\n\n    a.tags << Tag.find(create(:tag).id)\n    assert_equal 1, a.tags.size\n\n    b = described_class.find(a.id)\n    assert_equal 1, b.tags.size\n  end\n\n  it \"test_permalink_with_title\" do\n    article = create(:article, permalink: \"article-3\", published_at: Time.utc(2004, 6, 1))\n    assert_equal(article, described_class.requested_article(year: 2004, month: 6, day: 1,\n                                                            title: \"article-3\"))\n    not_found = described_class.requested_article year: 2005, month: \"06\", day: \"01\",\n                                                  title: \"article-5\"\n    expect(not_found).to be_nil\n  end\n\n  it \"test_strip_title\" do\n    assert_equal \"article-3\", \"Article-3\".to_url\n    assert_equal \"article-3\", \"Article 3!?#\".to_url\n    assert_equal \"there-is-sex-in-my-violence\", \"There is Sex in my Violence!\".to_url\n    assert_equal \"article\", \"-article-\".to_url\n    assert_equal \"lorem-ipsum-dolor-sit-amet-consectetaur-adipisicing-elit\",\n                 \"Lorem ipsum dolor sit amet, consectetaur adipisicing elit\".to_url\n    assert_equal \"my-cats-best-friend\", \"My Cat's Best Friend\".to_url\n  end\n\n  describe \"#set_permalink\" do\n    it \"works for simple cases\" do\n      a = blog.articles.build(title: \"Article 3!\", state: :published)\n      a.set_permalink\n      expect(a.permalink).to eq \"article-3\"\n    end\n\n    it \"strips html\" do\n      a = blog.articles.build(title: \"This <i>is</i> a <b>test</b>\", state: :published)\n      a.set_permalink\n      assert_equal \"this-is-a-test\", a.permalink\n    end\n\n    it \"does not escape multibyte characters\" do\n      a = blog.articles.build(title: \"\u30eb\u30d3\u30fc\", state: :published)\n      a.set_permalink\n      expect(a.permalink).to eq(\"\u30eb\u30d3\u30fc\")\n    end\n\n    it \"is called upon saving a published article\" do\n      a = blog.articles.build(title: \"space separated\")\n      a.publish\n      expect(a.permalink).to be_nil\n      a.blog = create(:blog)\n      a.save\n      expect(a.permalink).to eq(\"space-separated\")\n    end\n\n    it \"does nothing for draft articles\" do\n      a = blog.articles.build(title: \"space separated\", state: :draft)\n      a.set_permalink\n      expect(a.permalink).to be_nil\n    end\n  end\n\n  describe \"the html_urls method\" do\n    let(:blog) { create :blog, text_filter: \"none\" }\n\n    before do\n      @article = blog.articles.build\n    end\n\n    it \"extracts URLs from the generated body html\" do\n      @article.body = 'happy halloween <a href=\"http://www.example.com/public\">with</a>'\n      urls = @article.html_urls\n      assert_equal [\"http://www.example.com/public\"], urls\n    end\n\n    it \"onlies match the href attribute\" do\n      @article.body = '<a href=\"http://a/b\">a</a> <a fhref=\"wrong\">wrong</a>'\n      urls = @article.html_urls\n      assert_equal [\"http://a/b\"], urls\n    end\n\n    it \"matches across newlines\" do\n      @article.body = \"<a\\nhref=\\\"http://foo/bar\\\">foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n\n    it \"matches with single quotes\" do\n      @article.body = \"<a href='http://foo/bar'>foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n\n    it \"matches with no quotes\" do\n      @article.body = \"<a href=http://foo/bar>foo</a>\"\n      urls = @article.html_urls\n      assert_equal [\"http://foo/bar\"], urls\n    end\n  end\n\n  describe \"Testing redirects\" do\n    it \"a new published article gets a redirect\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      a.publish!\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n    end\n\n    it \"a new unpublished article should not get a redirect\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      expect(a.redirect).to be_nil\n    end\n\n    it \"Changin a published article permalink url should only change the to redirection\" do\n      a = blog.articles.create!(title: \"Some title\", body: \"some text\")\n      a.publish!\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n      r = a.redirect.from_path\n\n      a.permalink = \"some-new-permalink\"\n      a.save\n      expect(a.redirect).not_to be_nil\n      expect(a.redirect.to_path).to eq(a.permalink_url)\n      expect(a.redirect.from_path).to eq(r)\n    end\n  end\n\n  it \"test_find_published_by_tag_name\" do\n    art1 = create(:article)\n    art2 = create(:article)\n    create(:tag, name: \"foo\", contents: [art1, art2])\n    articles = Tag.find_by(name: \"foo\").published_contents\n    assert_equal 2, articles.size\n  end\n\n  it \"test_future_publishing\" do\n    art = blog.articles.build(title: \"title\", body: \"body\",\n                              published_at: 2.seconds.from_now)\n    art.publish!\n\n    expect(art).to be_publication_pending\n\n    assert_equal 1, Trigger.count\n    assert Trigger.where(pending_item_id: art.id).first\n    assert !art.published?\n    Timecop.freeze(4.seconds.from_now) do\n      Trigger.fire\n    end\n    art.reload\n    assert art.published?\n  end\n\n  it \"test_triggers_are_dependent\" do\n    # TODO: Needs a fix for Rails ticket #5105: has_many: Dependent deleting\n    # does not work with STI\n    skip\n    art = blog.articles.create!(title: \"title\", body: \"body\",\n                                published_at: 1.hour.from_now)\n    assert_equal 1, Trigger.count\n    art.destroy\n    assert_equal 0, Trigger.count\n  end\n\n  it \"test_destroy_file_upload_associations\" do\n    a = create(:article)\n    create(:resource, content: a)\n    create(:resource, content: a)\n    assert_equal 2, a.resources.size\n    a.resources << create(:resource)\n    assert_equal 3, a.resources.size\n    a.destroy\n    assert_equal 0, Resource.where(content_id: a.id).size\n  end\n\n  describe \"#interested_users\" do\n    it \"gathers users interested in new articles\" do\n      henri = create(:user, login: \"henri\", notify_on_new_articles: true)\n      alice = create(:user, login: \"alice\", notify_on_new_articles: true)\n\n      a = build(:article)\n      users = a.interested_users\n      expect(users).to match_array [alice, henri]\n    end\n  end\n\n  it \"test_withdrawal\" do\n    art = create(:article)\n    assert art.published?\n    assert !art.withdrawn?\n    art.withdraw!\n    assert !art.published?\n    assert art.withdrawn?\n    art.reload\n    assert !art.published?\n    assert art.withdrawn?\n  end\n\n  it \"gets only ham not spam comment\" do\n    article = create(:article)\n    ham_comment = create(:comment, article: article)\n    create(:spam_comment, article: article)\n    expect(article.comments.ham).to eq([ham_comment])\n    expect(article.comments.count).to eq(2)\n  end\n\n  describe \"#access_by?\" do\n    before do\n      @alice = build(:user, :as_admin)\n    end\n\n    it \"admin should have access to an article written by another\" do\n      expect(build(:article)).to be_access_by(@alice)\n    end\n\n    it \"admin should have access to an article written by himself\" do\n      article = build(:article, author: @alice)\n      expect(article).to be_access_by(@alice)\n    end\n  end\n\n  describe \"body_and_extended\" do\n    before do\n      @article = blog.articles.build(\n        body: \"basic text\",\n        extended: \"extended text to explain more and more how Publify is wonderful\")\n    end\n\n    it \"combines body and extended content\" do\n      expect(@article.body_and_extended).to eq(\n        \"#{@article.body}\\n<!--more-->\\n#{@article.extended}\")\n    end\n\n    it \"does not insert <!--more--> tags if extended is empty\" do\n      @article.extended = \"\"\n      expect(@article.body_and_extended).to eq(@article.body)\n    end\n  end\n\n  describe \"#search\" do\n    describe \"with one word and result\" do\n      it \"has two items\" do\n        create(:article, extended: \"extended talk\")\n        create(:article, extended: \"Once uppon a time, an extended story\")\n        assert_equal 2, described_class.search(\"extended\").size\n      end\n    end\n  end\n\n  describe \"body_and_extended=\" do\n    before do\n      @article = blog.articles.build\n    end\n\n    it \"splits apart values at <!--more-->\" do\n      @article.body_and_extended = \"foo<!--more-->bar\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n\n    it \"removes newlines around <!--more-->\" do\n      @article.body_and_extended = \"foo\\n<!--more-->\\nbar\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n\n    it \"makes extended empty if no <!--more--> tag\" do\n      @article.body_and_extended = \"foo\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to be_empty\n    end\n\n    it \"preserves extra <!--more--> tags\" do\n      @article.body_and_extended = \"foo<!--more-->bar<!--more-->baz\"\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar<!--more-->baz\")\n    end\n\n    it \"is settable via self.attributes=\" do\n      @article.attributes = { body_and_extended: \"foo<!--more-->bar\" }\n      expect(@article.body).to eq(\"foo\")\n      expect(@article.extended).to eq(\"bar\")\n    end\n  end\n\n  describe \"#html\" do\n    let(:article) { build_stubbed :article }\n\n    it \"returns an html_safe string\" do\n      expect(article.html).to be_html_safe\n    end\n  end\n\n  describe \"#comment_url\" do\n    it \"renders complete url of comment\" do\n      article = build_stubbed(:article, id: 123)\n      expect(article.comment_url).\n        to eq(\"#{blog.root_path}/comments?article_id=#{article.id}\")\n    end\n  end\n\n  describe \"#preview_comment_url\" do\n    it \"renders complete url of comment\" do\n      article = build_stubbed(:article, id: 123)\n      expect(article.preview_comment_url).\n        to eq(\"#{blog.root_path}/comments/preview?article_id=#{article.id}\")\n    end\n  end\n\n  it \"test_can_ping_fresh_article_iff_it_allows_pings\" do\n    a = create(:article, allow_pings: true)\n    assert_equal(false, a.pings_closed?)\n    a.allow_pings = false\n    assert_equal(true, a.pings_closed?)\n  end\n\n  it \"test_cannot_ping_old_article\" do\n    a = create(:article, allow_pings: false)\n    assert_equal(true, a.pings_closed?)\n    a.allow_pings = false\n    assert_equal(true, a.pings_closed?)\n  end\n\n  describe \"#published_at_like\" do\n    before do\n      # Note: these choices of times depend on no other articles within\n      # these timeframes existing in test/fixtures/contents.yaml.\n      # In particular, all articles there are from 2005 or earlier, which\n      # is now more than two years ago, except for two, which are from\n      # yesterday and the day before. The existence of those two makes\n      # 1.month.ago not suitable, because yesterday can be last month.\n      @article_two_month_ago = create(:article, published_at: 2.months.ago)\n\n      @article_four_months_ago = create(:article, published_at: 4.months.ago)\n      @article_2_four_months_ago = create(:article, published_at: 4.months.ago)\n\n      @article_two_year_ago = create(:article, published_at: 2.years.ago)\n      @article_2_two_year_ago = create(:article, published_at: 2.years.ago)\n    end\n\n    it \"returns all content for the year if only year sent\" do\n      expect(described_class.published_at_like(2.years.ago.strftime(\"%Y\")).map(&:id).sort).\n        to eq([@article_two_year_ago.id, @article_2_two_year_ago.id].sort)\n    end\n\n    it \"returns all content for the month if year and month sent\" do\n      result = described_class.published_at_like(4.months.ago.strftime(\"%Y-%m\")).\n        map(&:id).sort\n      expect(result).\n        to eq([@article_four_months_ago.id, @article_2_four_months_ago.id].sort)\n    end\n\n    it \"returns all content on this date if date send\" do\n      result = described_class.published_at_like(2.months.ago.strftime(\"%Y-%m-%d\")).\n        map(&:id).sort\n      expect(result).to eq([@article_two_month_ago.id].sort)\n    end\n  end\n\n  describe \"#has_child?\" do\n    it \"is true if article has one to link it by parent_id\" do\n      parent = create(:article)\n      create(:article, parent_id: parent.id)\n      expect(parent).to be_has_child\n    end\n\n    it \"is false if article has no article to link it by parent_id\" do\n      parent = create(:article)\n      create(:article, parent_id: nil)\n      expect(parent).not_to be_has_child\n    end\n  end\n\n  describe \"self#last_draft(id)\" do\n    it \"returns article if no draft associated\" do\n      draft = create(:article, state: \"draft\")\n      expect(described_class.last_draft(draft.id)).to eq(draft)\n    end\n\n    it \"returns draft associated to this article if there are one\" do\n      parent = create(:article)\n      draft = create(:article, parent_id: parent.id, state: \"draft\")\n      expect(described_class.last_draft(draft.id)).to eq(draft)\n    end\n  end\n\n  describe \"an article published just before midnight UTC\" do\n    before do\n      @timezone = Time.zone\n      Time.zone = \"UTC\"\n      @a = build(:article)\n      @a.set_permalink\n      @a.published_at = \"21 Feb 2011 23:30 UTC\"\n    end\n\n    after do\n      Time.zone = @timezone\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses UTC to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2011/02/21/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses UTC to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2011, month: 2, day: 21,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just after midnight UTC\" do\n    before do\n      @timezone = Time.zone\n      Time.zone = \"UTC\"\n      @a = build(:article)\n      @a.set_permalink\n      @a.published_at = \"22 Feb 2011 00:30 UTC\"\n    end\n\n    after do\n      Time.zone = @timezone\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses UTC to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2011/02/22/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses UTC to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2011, month: 2, day: 22,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just before midnight JST (+0900)\" do\n    before do\n      @time_zone = Time.zone\n      Time.zone = \"Tokyo\"\n      @a = build(:article)\n      @a.set_permalink\n      @a.published_at = \"31 Dec 2012 23:30 +0900\"\n    end\n\n    after do\n      Time.zone = @time_zone\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses JST to determine correct day\" do\n        expect(@a.permalink_url).to eq \"#{blog.base_url}/2012/12/31/a-big-article\"\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses JST to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2012, month: 12, day: 31,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"an article published just after midnight  JST (+0900)\" do\n    before do\n      @time_zone = Time.zone\n      Time.zone = \"Tokyo\"\n      @a = build(:article)\n      @a.set_permalink\n      @a.published_at = \"1 Jan 2013 00:30 +0900\"\n    end\n\n    after do\n      Time.zone = @time_zone\n    end\n\n    describe \"#permalink_url\" do\n      it \"uses JST to determine correct day\" do\n        expect(@a.permalink_url).to eq(\"#{blog.base_url}/2013/01/01/a-big-article\")\n      end\n    end\n\n    describe \"#requested_article\" do\n      it \"uses JST to determine correct day\" do\n        @a.save\n        a = described_class.requested_article year: 2013, month: 1, day: 1,\n                                              permalink: \"a-big-article\"\n        expect(a).to eq(@a)\n      end\n    end\n  end\n\n  describe \"#published_comments\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn comments\" do\n      comment = create :published_comment, article: article\n      article.reload\n      expect(article.published_comments).to eq [comment]\n      comment.withdraw!\n      article.reload\n      expect(article.published_comments).to eq []\n    end\n\n    it \"sorts comments newest last\" do\n      old_comment = create :published_comment, article: article, created_at: 2.days.ago\n      new_comment = create :published_comment, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_comments).to eq [old_comment, new_comment]\n    end\n  end\n\n  describe \"#published_trackbacks\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn trackbacks\" do\n      trackback = create :trackback, article: article\n      article.reload\n      expect(article.published_trackbacks).to eq [trackback]\n      trackback.withdraw!\n      article.reload\n      expect(article.published_trackbacks).to eq []\n    end\n\n    it \"sorts trackbacks newest last\" do\n      old_trackback = create :trackback, article: article, created_at: 2.days.ago\n      new_trackback = create :trackback, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_trackbacks).to eq [old_trackback, new_trackback]\n    end\n  end\n\n  describe \"#published_feedback\" do\n    let(:article) { create :article }\n\n    it \"does not include withdrawn comments or trackbacks\" do\n      comment = create :published_comment, article: article\n      trackback = create :trackback, article: article\n      article.reload\n      expect(article.published_feedback).to eq [comment, trackback]\n      comment.withdraw!\n      trackback.withdraw!\n      article.reload\n      expect(article.published_feedback).to eq []\n    end\n\n    it \"sorts feedback newest last\" do\n      old_comment = create :published_comment, article: article, created_at: 4.days.ago\n      old_trackback = create :trackback, article: article, created_at: 3.days.ago\n      new_comment = create :published_comment, article: article, created_at: 2.days.ago\n      new_trackback = create :trackback, article: article, created_at: 1.day.ago\n      article.reload\n      expect(article.published_feedback).\n        to eq [old_comment, old_trackback, new_comment, new_trackback]\n    end\n  end\n\n  describe \"save_attachments!\" do\n    it \"calls save_attachment for each file given\" do\n      first_file = OpenStruct.new\n      second_file = OpenStruct.new\n      hash = { a_key: first_file, a_second_key: second_file }\n      article = build(:article)\n      expect(article).to receive(:save_attachment!).with(first_file)\n      expect(article).to receive(:save_attachment!).with(second_file)\n      article.save_attachments!(hash)\n    end\n\n    it \"do nothing with nil given\" do\n      article = build(:article)\n      article.save_attachments!(nil)\n    end\n  end\n\n  describe \"save_attachment!\" do\n    let(:file) { file_upload(\"testfile.txt\", \"text/plain\") }\n\n    it \"adds a new resource\" do\n      article = create(:article)\n      article.save_attachment!(file)\n      article.reload\n\n      resource = article.resources.first\n      upload = resource.upload\n\n      expect(upload.file.basename).to eq \"testfile\"\n    end\n  end\n\n  describe \"#search_with\" do\n    subject { described_class.search_with(params) }\n\n    context \"without article\" do\n      let(:params) { nil }\n\n      it { expect(subject).to be_empty }\n    end\n\n    context \"with an article\" do\n      let(:params) { nil }\n      let!(:article) { create(:article) }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two article but only one matching searchstring\" do\n      let(:params) { { searchstring: \"match the string\" } }\n      let!(:not_found_article) { create(:article) }\n      let!(:article) { create(:article, body: \"this match the string of article\") }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two articles with differents states and published params\" do\n      let(:params) { { state: \"published\" } }\n      let!(:article) { create(:article, state: \"published\") }\n      let!(:draft_article) { create(:article, state: \"draft\") }\n\n      it { expect(subject).to eq([article]) }\n    end\n\n    context \"with two articles with differents states and no params\" do\n      let(:params) { nil }\n      let(:now) { DateTime.new(2011, 3, 12).in_time_zone }\n      let!(:article) { create(:article, state: \"published\", created_at: now) }\n      let!(:last_draft_article) do\n        create(:article, state: \"draft\",\n                         created_at: now + 2.days)\n      end\n      let!(:draft_article) { create(:article, state: \"draft\", created_at: now + 20.days) }\n\n      it { expect(subject).to eq([draft_article, last_draft_article, article]) }\n    end\n  end\n\n  describe \".allow_comments?\" do\n    it \"true if article set to true\" do\n      expect(blog.articles.build(allow_comments: true)).to be_allow_comments\n    end\n\n    it \"false if article set to false\" do\n      expect(blog.articles.build(allow_comments: false)).not_to be_allow_comments\n    end\n\n    context \"given an article with no allow comments state\" do\n      it \"returns true when blog default allow comments is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_comments).and_return(true)\n        expect(blog.articles.build(allow_comments: nil)).to be_allow_comments\n      end\n\n      it \"returns false when blog default allow comments is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_comments).and_return(false)\n        expect(blog.articles.build(allow_comments: nil)).not_to be_allow_comments\n      end\n    end\n  end\n\n  describe \".allow_pings?\" do\n    it \"true if article set to true\" do\n      expect(blog.articles.build(allow_pings: true)).to be_allow_pings\n    end\n\n    it \"false if article set to false\" do\n      expect(blog.articles.build(allow_pings: false)).not_to be_allow_pings\n    end\n\n    context \"given an article with no allow pings state\" do\n      it \"returns true when blog default allow pings is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_pings).and_return(true)\n        expect(blog.articles.build(allow_pings: nil)).to be_allow_pings\n      end\n\n      it \"returns false when blog default allow pings is true\" do\n        expect_any_instance_of(Blog).to receive(:default_allow_pings).and_return(false)\n        expect(blog.articles.build(allow_pings: nil)).not_to be_allow_pings\n      end\n    end\n  end\n\n  describe \"#publication_months\" do\n    it \"returns an empty array when no articles\" do\n      expect(described_class.publication_months).to be_empty\n    end\n\n    it \"returns months of publication for published articles\" do\n      create(:article, published_at: Date.new(2010, 11, 23))\n      create(:article, published_at: Date.new(2002, 4, 9))\n      result = described_class.publication_months\n      expect(result).to match_array [[\"2010-11\"], [\"2002-04\"]]\n    end\n  end\n\n  describe \"published_since\" do\n    let(:time) { DateTime.new(2010, 11, 3, 23, 34).in_time_zone }\n\n    it \"empty when no articles\" do\n      expect(described_class.published_since(time)).to be_empty\n    end\n\n    it \"returns article that was published since\" do\n      article = create(:article, published_at: time + 2.hours)\n      expect(described_class.published_since(time)).to eq [article]\n    end\n\n    it \"returns only article that was published since last visit\" do\n      create(:article, published_at: time - 2.hours)\n      article = create(:article, published_at: time + 2.hours)\n      expect(described_class.published_since(time)).to eq [article]\n    end\n  end\n\n  describe \"bestof\" do\n    it \"returns empty array when no content\" do\n      expect(described_class.bestof).to be_empty\n    end\n\n    it \"returns article with comment count field\" do\n      create(:comment)\n      expect(described_class.bestof.first.comment_count.to_i).to eq 1\n    end\n\n    it \"counts comments but not trackbacks\" do\n      article = create :article\n      create :trackback, article: article\n      create_list :comment, 2, article: article\n\n      expect(described_class.bestof.first.comment_count.to_i).to eq 2\n    end\n\n    it \"returns only 5 articles\" do\n      create_list(:comment, 6)\n      expect(described_class.bestof.length).to eq(5)\n    end\n\n    it \"returns only published articles\" do\n      article = create(:article)\n      create(:comment, article: article)\n      unpublished_article = create(:article, state: \"draft\")\n      create(:comment, article: unpublished_article)\n      expect(described_class.published).to eq([article])\n      expect(described_class.bestof).to eq([article])\n    end\n\n    it \"returns article sorted by comment counts\" do\n      last_article = create(:article)\n      create(:comment, article: last_article)\n\n      first_article = create(:article)\n      create(:comment, article: first_article)\n      create(:comment, article: first_article)\n\n      expect(described_class.bestof).to eq([first_article, last_article])\n    end\n  end\n\n  describe \"update tags from article keywords\" do\n    before { article.save }\n\n    context \"without keywords\" do\n      let(:article) { build(:article, keywords: nil) }\n\n      it { expect(article.tags).to be_empty }\n    end\n\n    context \"with a simple keyword\" do\n      let(:article) { build(:article, keywords: \"foo\") }\n\n      it { expect(article.tags.size).to eq(1) }\n      it { expect(article.tags.first).to be_kind_of(Tag) }\n      it { expect(article.tags.first.name).to eq(\"foo\") }\n    end\n\n    context \"with two keyword separate by a space\" do\n      let(:article) { build(:article, keywords: \"foo bar\") }\n\n      it { expect(article.tags.size).to eq(2) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo bar)) }\n    end\n\n    context \"with two keyword separate by a coma\" do\n      let(:article) { build(:article, keywords: \"foo, bar\") }\n\n      it { expect(article.tags.size).to eq(2) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo bar)) }\n    end\n\n    context \"with two keyword with apostrophe\" do\n      let(:article) { build(:article, keywords: \"foo, l'bar\") }\n\n      it { expect(article.tags.size).to eq(3) }\n      it { expect(article.tags.map(&:name)).to eq(%w(foo l bar)) }\n    end\n\n    context \"with two identical keywords\" do\n      let(:article) { build(:article, keywords: \"same, same\") }\n\n      it { expect(article.tags.size).to eq(1) }\n      it { expect(article.tags.map(&:name)).to eq([\"same\"]) }\n    end\n\n    context \"with keywords with dot and quote\" do\n      let(:article) { build(:article, keywords: 'foo \"bar quiz\" web2.0') }\n\n      it { expect(article.tags.map(&:name)).to eq([\"foo\", \"bar-quiz\", \"web2-0\"]) }\n    end\n  end\n\n  describe \"#post_type\" do\n    context \"without post_type\" do\n      let(:article) { build(:article, post_type: \"\") }\n\n      it { expect(article.post_type).to eq(\"read\") }\n    end\n\n    context \"with a oldschool read post_type\" do\n      let(:article) { build(:article, post_type: \"read\") }\n\n      it { expect(article.post_type).to eq(\"read\") }\n    end\n\n    context \"with a specific myletter post_type\" do\n      let(:article) { build(:article, post_type: \"myletter\") }\n\n      it { expect(article.post_type).to eq(\"myletter\") }\n    end\n  end\n\n  describe \"#comments_closed?\" do\n    let!(:blog) do\n      create(:blog, sp_article_auto_close: auto_close_value,\n                    default_allow_comments: true)\n    end\n\n    context \"when auto_close setting is zero\" do\n      let(:auto_close_value) { 0 }\n\n      it \"allows comments for a newly published article\" do\n        art = build :article, published_at: 1.second.ago, blog: blog\n        assert !art.comments_closed?\n      end\n\n      it \"allows comments for a very old article\" do\n        art = build :article, created_at: 1000.days.ago, blog: blog\n        assert !art.comments_closed?\n      end\n    end\n\n    context \"when auto_close setting is nonzero\" do\n      let(:auto_close_value) { 30 }\n\n      it \"allows comments for a recently published article\" do\n        art = build :article, published_at: 29.days.ago, blog: blog\n        assert !art.comments_closed?\n      end\n\n      it \"does not allow comments for an old article\" do\n        art = build :article, published_at: 31.days.ago, blog: blog\n        assert art.comments_closed?\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\nrequire \"publify_core/testing_support/dns_mock\"\n\ndescribe Comment, type: :model do\n  let(:blog) { build_stubbed :blog }\n\n  let(:published_article) { build_stubbed(:article, published_at: 1.hour.ago, blog: blog) }\n\n  def valid_comment(options = {})\n    Comment.new({ author: \"Bob\", article: published_article, body: \"nice post\",\n                  ip: \"1.2.3.4\" }.merge(options))\n  end\n\n  describe \"#permalink_url\" do\n    let(:comment) { build_stubbed(:comment) }\n\n    it \"renders permalink to comment in public part\" do\n      expect(comment.permalink_url).\n        to eq(\"#{comment.article.permalink_url}#comment-#{comment.id}\")\n    end\n  end\n\n  describe \"#save\" do\n    it \"saves good comment\" do\n      c = build(:comment, url: \"http://www.google.de\")\n      assert c.save\n      assert_equal \"http://www.google.de\", c.url\n    end\n\n    it \"saves spam comment\" do\n      c = build(:comment, body: 'test <a href=\"http://fakeurl.com\">body</a>')\n      assert c.save\n      assert_equal \"http://fakeurl.com\", c.url\n    end\n\n    it \"does not save when article comment window is closed\" do\n      article = build :article, published_at: 1.year.ago\n      article.blog.sp_article_auto_close = 30\n      comment = build(:comment, author: \"Old Spammer\", body: \"Old trackback body\",\n                                article: article)\n      expect(comment.save).to be_falsey\n      expect(comment.errors[:article_id]).not_to be_empty\n    end\n\n    it \"changes old comment\" do\n      c = build(:comment, body: \"Comment body <em>italic</em> <strong>bold</strong>\")\n      assert c.save\n      assert c.errors.empty?\n    end\n\n    it \"saves a valid comment\" do\n      c = build :comment\n      expect(c.save).to be_truthy\n      expect(c.errors).to be_empty\n    end\n\n    it \"does not save with article not allow comment\" do\n      c = build(:comment, article: build_stubbed(:article, allow_comments: false))\n      expect(c.save).not_to be_truthy\n      expect(c.errors).not_to be_empty\n    end\n\n    it \"generates guid\" do\n      c = build :comment, guid: nil\n      assert c.save\n      assert c.guid.size > 15\n    end\n\n    it \"preserves urls starting with https://\" do\n      c = build :comment, url: \"https://example.com/\"\n      c.save\n      expect(c.url).to eq(\"https://example.com/\")\n    end\n\n    it \"preserves urls starting with http://\" do\n      c = build :comment, url: \"http://example.com/\"\n      c.save\n      expect(c.url).to eq(\"http://example.com/\")\n    end\n\n    it \"prepends http:// to urls without protocol\" do\n      c = build :comment, url: \"example.com\"\n      c.save\n      expect(c.url).to eq(\"http://example.com\")\n    end\n  end\n\n  describe \"#classify_content\" do\n    it \"rejects spam rbl\" do\n      comment = valid_comment(\n        author: \"Spammer\",\n        body: <<-BODY,\n          This is just some random text.\n          &lt;a href=\"http://chinaaircatering.com\"&gt;without any senses.&lt;/a&gt;.\n          Please disregard.\n        BODY\n        url: \"http://buy-computer.us\")\n      comment.classify_content\n      expect(comment).to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    it \"does not define spam a comment rbl with lookup succeeds\" do\n      comment = valid_comment(author: \"Not a Spammer\", body: \"Useful commentary!\",\n                              url: \"http://www.bofh.org.uk\")\n      comment.classify_content\n      expect(comment).not_to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    it \"rejects spam with uri limit\" do\n      comment =\n        valid_comment(author: \"Yet Another Spammer\",\n                      body: <<~HTML,\n                        <a href=\"http://www.one.com/\">one</a>\n                        <a href=\"http://www.two.com/\">two</a>\n                        <a href=\"http://www.three.com/\">three</a>\n                        <a href=\"http://www.four.com/\">four</a>\n                      HTML\n                      url: \"http://www.uri-limit.com\")\n      comment.classify_content\n      expect(comment).to be_spammy\n      expect(comment).not_to be_status_confirmed\n    end\n\n    describe \"with feedback moderation enabled\" do\n      before do\n        allow(blog).to receive(:sp_global).and_return(false)\n        allow(blog).to receive(:default_moderate_comments).and_return(true)\n      end\n\n      it \"marks comment as presumably spam\" do\n        comment = described_class.new do |c|\n          c.body = \"Test foo\"\n          c.author = \"Bob\"\n          c.article = build_stubbed(:article, blog: blog)\n        end\n\n        comment.classify_content\n\n        assert !comment.published?\n        assert comment.presumed_spam?\n        assert !comment.status_confirmed?\n      end\n\n      it \"marks comment from known user as confirmed ham\" do\n        comment = described_class.new do |c|\n          c.body = \"Test foo\"\n          c.author = \"Henri\"\n          c.article = build_stubbed(:article, blog: blog)\n          c.user = build_stubbed(:user)\n        end\n\n        comment.classify_content\n\n        assert comment.published?\n        assert comment.ham?\n        assert comment.status_confirmed?\n      end\n    end\n  end\n\n  it \"has good relation\" do\n    article = build_stubbed(:article)\n    comment = build_stubbed(:comment, article: article)\n    assert comment.article\n    assert_equal article, comment.article\n  end\n\n  describe \"reject xss\" do\n    let(:comment) do\n      described_class.new do |c|\n        c.body = \"Test foo <script>do_evil();</script>\"\n        c.author = \"Bob\"\n        c.article = build_stubbed(:article, blog: blog)\n      end\n    end\n\n    [\"\", \"textile\", \"markdown\", \"smartypants\", \"markdown smartypants\"].each do |filter|\n      it \"rejects with filter '#{filter}'\" do\n        blog.comment_text_filter = filter\n\n        ActiveSupport::Deprecation.silence do\n          assert comment.html(:body) !~ /<script>/\n        end\n      end\n    end\n  end\n\n  describe \"change state\" do\n    it \"becomes unpublished if withdrawn\" do\n      c = build :comment\n      assert c.published?\n      assert c.withdraw!\n      assert !c.published?\n      assert c.spam?\n      assert c.status_confirmed?\n    end\n\n    it \"becomeses confirmed if withdrawn\" do\n      unconfirmed = build(:comment, state: \"presumed_ham\")\n      expect(unconfirmed).not_to be_status_confirmed\n      unconfirmed.withdraw!\n      expect(unconfirmed).to be_status_confirmed\n    end\n  end\n\n  it \"has good default filter\" do\n    create :blog, text_filter: \"textile\", comment_text_filter: \"markdown\"\n    a = create(:comment)\n    assert_equal \"markdown\", a.default_text_filter.name\n  end\n\n  describe \"spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n\n    it \"returns only spam comment\" do\n      expect(described_class.spam).to eq([comment])\n    end\n  end\n\n  describe \"not_spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n    let!(:presumed_spam_comment) { create(:comment, state: \"presumed_spam\") }\n\n    it \"returns all comment that not_spam\" do\n      expect(described_class.not_spam).to match_array [ham_comment, presumed_spam_comment]\n    end\n  end\n\n  describe \"presumed_spam\", integration: true do\n    let!(:comment) { create(:comment, state: \"spam\") }\n    let!(:ham_comment) { create(:comment, state: \"ham\") }\n    let!(:presumed_spam_comment) { create(:comment, state: \"presumed_spam\") }\n\n    it \"returns only presumed_spam\" do\n      expect(described_class.presumed_spam).to eq([presumed_spam_comment])\n    end\n  end\n\n  describe \"last_published\", integration: true do\n    let(:date) { DateTime.new(2012, 12, 23, 12, 47).in_time_zone }\n    let!(:comment_1) { create(:comment, body: \"1\", created_at: date + 1.day) }\n    let!(:comment_4) { create(:comment, body: \"4\", created_at: date + 4.days) }\n    let!(:comment_2) { create(:comment, body: \"2\", created_at: date + 2.days) }\n    let!(:comment_6) { create(:comment, body: \"6\", created_at: date + 6.days) }\n    let!(:comment_3) { create(:comment, body: \"3\", created_at: date + 3.days) }\n    let!(:comment_5) { create(:comment, body: \"5\", created_at: date + 5.days) }\n\n    it \"respond only 5 last_published\" do\n      expect(described_class.last_published).to eq([comment_6, comment_5, comment_4,\n                                                    comment_3, comment_2])\n    end\n  end\n\n  describe \"#html\" do\n    it \"renders email addresses in the body\" do\n      comment = build_stubbed(:comment, body: \"foo@example.com\")\n      expect(comment.html).to match(/mailto:/)\n    end\n\n    it \"returns an html_safe string\" do\n      comment = build_stubbed(:comment, body: \"Just a comment\")\n      expect(comment.html).to be_html_safe\n    end\n\n    context \"with an evil comment\" do\n      let(:comment) { build_stubbed :comment, body: \"Test foo <script>do_evil();</script>\" }\n      let(:blog) { comment.article.blog }\n\n      [\"\", \"textile\", \"markdown\", \"smartypants\", \"markdown smartypants\"].each do |filter|\n        it \"rejects xss attempt with filter '#{filter}'\" do\n          blog.comment_text_filter = filter\n\n          ActiveSupport::Deprecation.silence do\n            assert comment.html(:body) !~ /<script>/\n          end\n        end\n      end\n    end\n\n    context \"with a markdown comment with italic and bold\" do\n      let(:comment) { build(:comment, body: \"Comment body _italic_ **bold**\") }\n      let(:blog) { comment.article.blog }\n\n      it \"converts the comment markup to html\" do\n        blog.comment_text_filter = \"markdown\"\n        result = comment.html\n\n        aggregate_failures do\n          expect(result).to match(%r{<em>italic</em>})\n          expect(result).to match(%r{<strong>bold</strong>})\n        end\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Content, type: :model do\n  context \"with a simple blog\" do\n    describe \"#author=\" do\n      let(:content) { described_class.new }\n\n      before { content.author = user }\n\n      context \"with a User as author\" do\n        let(:user) { build(:user) }\n\n        it { expect(content.author).to eq(user.login) }\n        it { expect(content.user).to eq(user) }\n      end\n\n      context \"with a String as author\" do\n        let(:user) { \"George Sand\" }\n\n        it { expect(content.author).to eq(user) }\n        it { expect(content.user).to be_nil }\n      end\n    end\n\n    describe \"#short_url\" do\n      let(:redirect) do\n        build_stubbed(:redirect, from_path: \"foo\", to_path: \"bar\",\n                                 blog: blog)\n      end\n      let(:content) do\n        build_stubbed(:content,\n                      blog: blog,\n                      state: \"published\",\n                      published_at: 1.day.ago,\n                      redirect: redirect)\n      end\n\n      describe \"normally\" do\n        let(:blog) { build_stubbed(:blog, base_url: \"http://myblog.net\") }\n\n        it \"returns the blog's base url combined with the redirection's from path\" do\n          expect(content.short_url).to eq(\"http://myblog.net/foo\")\n        end\n      end\n\n      describe \"when the blog is in a sub-uri\" do\n        let(:blog) { build_stubbed(:blog, base_url: \"http://myblog.net/blog\") }\n\n        it \"includes the sub-uri path\" do\n          expect(content.short_url).to eq(\"http://myblog.net/blog/foo\")\n        end\n      end\n    end\n\n    describe \"#text_filter\" do\n      it \"returns nil by default\" do\n        @content = described_class.new\n        expect(@content.text_filter).to be_nil\n      end\n    end\n\n    # TODO: Move implementation out of models\n    describe \"#really_send_notifications\" do\n      it \"sends notifications to interested users\" do\n        @content = Article.new\n        henri = create(:user, notify_on_new_articles: true)\n        alice = create(:user, notify_on_new_articles: true)\n\n        expect(@content).to receive(:send_notification_to_user).with henri\n        expect(@content).to receive(:send_notification_to_user).with alice\n\n        @content.really_send_notifications\n      end\n    end\n\n    describe \"#search_with\" do\n      context \"with an simple article\" do\n        subject { described_class.search_with(params) }\n\n        context \"with nil params\" do\n          let(:params) { nil }\n\n          it { expect(subject).to be_empty }\n        end\n\n        context \"with a matching searchstring article\" do\n          let(:params) { { searchstring: \"a search string\" } }\n          let!(:match_article) { create(:article, body: \"there is a search string here\") }\n\n          it { expect(subject).to eq([match_article]) }\n        end\n\n        context \"with an article published_at\" do\n          let(:params) { { published_at: \"2012-02\" } }\n          let!(:article) { create(:article) }\n          let!(:match_article) do\n            create(:article,\n                   published_at: DateTime.new(2012, 2, 13).in_time_zone)\n          end\n\n          it { expect(subject).to eq([match_article]) }\n        end\n\n        context \"with same user_id article\" do\n          let(:params) { { user_id: \"13\" } }\n          let!(:article) { create(:article) }\n          let!(:match_article) { create(:article, user_id: 13) }\n\n          it { expect(subject).to eq([match_article]) }\n        end\n\n        context \"with not published status article\" do\n          let(:params) { { published: \"0\" } }\n          let!(:article) { create(:article) }\n          let!(:match_article) { create(:article, state: \"draft\") }\n\n          it { expect(subject).to eq([match_article]) }\n        end\n\n        context \"with published status article\" do\n          let(:params) { { published: \"1\" } }\n          let!(:article) { create(:article) }\n\n          it { expect(subject).to eq([article]) }\n        end\n      end\n    end\n  end\n\n  describe \"#author_name\" do\n    let(:content) { described_class.new(author: author) }\n\n    context \"with an author with a name\" do\n      let(:author) { build(:user, name: \"Henri\") }\n\n      it { expect(content.author_name).to eq(author.name) }\n    end\n\n    context \"with an author without a name\" do\n      let(:author) { build(:user, name: \"\") }\n\n      it { expect(content.author_name).to eq(author.login) }\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Note, type: :model do\n  context \"with a simple blog\" do\n    let!(:blog) { create(:blog) }\n\n    describe \"validations\" do\n      it { expect(build(:note)).to be_valid }\n      it { expect(build(:note).redirect).to be_blank }\n      it { expect(create(:note).redirect).not_to be_blank }\n      it { expect(build(:note, body: nil)).to be_invalid }\n\n      it \"with a nil body, return default error message\" do\n        note = build(:note, body: nil)\n        note.save\n        expect(note.errors[:body]).to eq([\"can't be blank\"])\n      end\n\n      context \"with an existing note\" do\n        let(:existing_note) { create(:note) }\n\n        it { expect(build(:note, guid: existing_note.guid)).to be_invalid }\n      end\n    end\n\n    describe \"permalink\" do\n      let(:note) do\n        Rails.cache.clear\n        create(:note, body: \"\u00e0\u00e9\")\n      end\n\n      it { expect(note.permalink).to eq(\"#{note.id}-ae\") }\n      it { expect(note.permalink_url).to eq(\"#{blog.base_url}/note/#{note.id}-ae\") }\n\n      context \"with a particular blog\" do\n        before do\n          allow_any_instance_of(Blog).\n            to receive(:custom_url_shortener).and_return(url_shortener)\n          allow_any_instance_of(Blog).\n            to receive(:base_url).and_return(\"http://mybaseurl.net\")\n        end\n\n        context \"with a blog that have a custome url shortener\" do\n          let(:url_shortener) { \"shor.tl\" }\n\n          it {\n            expect(note.short_link).\n              to eq(\"#{url_shortener} #{note.redirect.from_path}\")\n          }\n        end\n\n        context \"with a blog that does not have a custome url shortener\" do\n          let(:url_shortener) { nil }\n\n          it { expect(note.short_link).to eq(\"mybaseurl.net #{note.redirect.from_path}\") }\n        end\n      end\n    end\n\n    describe \"#redirect\" do\n      let(:note) { create(:note) }\n\n      it { expect(note.redirect.to_path).to eq note.permalink_url }\n    end\n\n    describe \"scopes\" do\n      describe \"#published\" do\n        let(:note) { create(:note, published_at: 1.minute.ago) }\n\n        context \"with a unpublished note\" do\n          let!(:unpublished_note) { create(:unpublished_note) }\n\n          it { expect(described_class.published).to eq([note]) }\n        end\n\n        context \"with a note to publish later\" do\n          let!(:later_note) { create(:note, published_at: 3.days.from_now) }\n\n          it { expect(described_class.published).to eq([note]) }\n        end\n      end\n    end\n\n    describe \"send_to_twitter\" do\n      context \"with a simple note\" do\n        let(:note) { build(:note) }\n\n        context \"with twitter configured for blog and user\" do\n          before do\n            expect_any_instance_of(Blog).\n              to receive(:has_twitter_configured?).and_return(true)\n            expect_any_instance_of(User).\n              to receive(:has_twitter_configured?).and_return(true)\n          end\n\n          it { expect(note.send_to_twitter).to be_falsey }\n        end\n\n        context \"with twitter not configured for blog\" do\n          before do\n            expect_any_instance_of(Blog).\n              to receive(:has_twitter_configured?).and_return(false)\n          end\n\n          it { expect(note.send_to_twitter).to be_falsey }\n        end\n\n        context \"with a twitter configured for blog but not user\" do\n          before do\n            expect_any_instance_of(Blog).\n              to receive(:has_twitter_configured?).and_return(true)\n            expect_any_instance_of(User).\n              to receive(:has_twitter_configured?).and_return(false)\n          end\n\n          it { expect(note.send_to_twitter).to be_falsey }\n        end\n      end\n\n      context \"with a more than 140 char note\" do\n        let(:note) do\n          create :note, body: <<~TXT\n            A big message that contains more than 140 char is not too\n            hard to do. You only need to speak as a french guy, a lot to\n            say nothing. And that is  probably the best way to write more\n            than 140 char.\n          TXT\n        end\n\n        let(:fake_twitter) { double(Twitter::REST::Client) }\n\n        before do\n          expect(Twitter::REST::Client).to receive(:new).and_return(fake_twitter)\n          expect(fake_twitter).\n            to receive(:update).\n            and_raise(Twitter::Error::Forbidden.new(\"Status is over 140 characters.\"))\n          expect_any_instance_of(Blog).to receive(:has_twitter_configured?).and_return(true)\n          expect_any_instance_of(User).to receive(:has_twitter_configured?).and_return(true)\n          note.send_to_twitter\n        end\n\n        it {\n          expect(note.errors.full_messages).\n            to eq([\"Message Status is over 140 characters.\"])\n        }\n      end\n    end\n\n    describe \"twitter_url\" do\n      let(:user) { build(:user, twitter: \"@hello\") }\n      let(:note) { build(:note, user: user, settings: { twitter_id: \"12345678901234\" }) }\n\n      it {\n        expect(note.twitter_url).\n          to eq(\"https://twitter.com/#{note.user.twitter}/status/#{note.twitter_id}\")\n      }\n    end\n\n    describe \"default_text_filter\" do\n      let(:note) { build(:note) }\n\n      it { expect(note.default_text_filter.name).to eq(note.blog.text_filter) }\n    end\n\n    describe \"twitter_message\" do\n      let(:blog) { create :blog, base_url: \"http://myblog.net\" }\n      let(:note) { create(:note, blog: blog, body: tweet) }\n\n      context \"with a short simple message\" do\n        let(:tweet) { \"A message without URL\" }\n\n        it { expect(note.twitter_message).to start_with(tweet) }\n        it { expect(note.twitter_message).to end_with(\" (#{note.short_link})\") }\n      end\n\n      context \"with a short message with short HTTP url\" do\n        let(:tweet) { \"A message with a short URL http://foo.com\" }\n\n        it { expect(note.twitter_message).to eq(\"#{tweet} (#{note.short_link})\") }\n      end\n\n      context \"with a short message much more than 114 char\" do\n        let(:tweet) do\n          \"A very big(10) message with lot of text (40)inside just to try the\" \\\n          \" shortener and (80)the new link that publify must create and add at the end\"\n        end\n        let(:expected_tweet) do\n          \"A very big(10) message with lot of text (40)inside just to try the\" \\\n          \" shortener and (80)the new link that publify... (#{note.redirect.from_url})\"\n        end\n\n        it { expect(note.twitter_message).to eq(expected_tweet) }\n        it { expect(note.twitter_message.length).to eq(140) }\n      end\n\n      context \"With a test message from production...\" do\n        let(:tweet) do\n          \"Le dojo de nantes, c'est comme au McDo, sans les odeurs, et en plus rigolo:\" \\\n            \" RT @abailly Ce midi c'est coding dojo \u00e0 la Cantine #Nantes.\" \\\n            \" Pour s'inscrire si vous voulez c'est ici:\" \\\n            \" http://cantine.atlantic2.org/evenements/coding-dojo-8/ \u2026\" \\\n            \" Sinon venez comme vous \u00eates\"\n        end\n        let(:expected_tweet) do\n          \"Le dojo de nantes, c'est comme au McDo, sans les odeurs, et en plus rigolo:\" \\\n          \" RT @abailly Ce midi c'est coding... (#{note.redirect.from_url})\"\n        end\n\n        it { expect(note.twitter_message).to eq(expected_tweet) }\n        it { expect(note.twitter_message.length).to eq(138) }\n      end\n\n      context \"with a bug message\" do\n        let(:tweet) do\n          '\"JSFuck is an esoteric and educational programming style based on the' \\\n          \" atomic parts of JavaScript. It uses only six different characters to\" \\\n          ' write and execute code.\" http://www.jsfuck.com/ '\n        end\n        let(:expected_tweet) do\n          \"\\\"JSFuck is an esoteric and educational programming style based on the\" \\\n          \" atomic parts of JavaScript. It uses only... (#{note.redirect.from_url})\"\n        end\n\n        it { expect(note.twitter_message).to eq(expected_tweet) }\n        it { expect(note.twitter_message.length).to eq(140) }\n      end\n\n      context \"don't cut word\" do\n        let(:tweet) do\n          \"Le #mobprogramming c'est un peu comme faire un dojo sur une journ\u00e9e enti\u00e8re\" \\\n          \" (\u00e7a permet s\u00fbrement de faire des petites journ\u00e9es ;-))\"\n        end\n        let(:expected_tweet) do\n          \"Le #mobprogramming c'est un peu comme faire un dojo sur une journ\u00e9e enti\u00e8re\" \\\n          \" (\u00e7a permet s\u00fbrement de faire des... (#{note.redirect.from_url})\"\n        end\n\n        it { expect(note.twitter_message).to eq(expected_tweet) }\n        it { expect(note.twitter_message.length).to eq(138) }\n      end\n\n      context \"shortener host name is counted as an url by twitter\" do\n        let(:tweet) do\n          \"RT @stephaneducasse http://pharocloud.com is so cool. I love love such idea\" \\\n          \" and I wish them success. Excellent work.\"\n        end\n        let(:expected_tweet) do\n          \"RT @stephaneducasse http://pharocloud.com is so cool. I love love such idea\" \\\n          \" and I wish them success. Excellent... (#{note.redirect.from_url})\"\n        end\n\n        it { expect(note.twitter_message).to eq(expected_tweet) }\n        it { expect(note.twitter_message.length).to eq(140) }\n      end\n    end\n\n    describe \"#html\" do\n      it \"returns an html_safe string\" do\n        note = build(:note, body: \"A test tweet with a #hashtag\")\n        expect(note.html).to be_html_safe\n      end\n    end\n  end\n\n  context \"with a dofollowify blog\" do\n    let!(:blog) { create(:blog, dofollowify: true) }\n\n    describe \"Testing hashtag and @mention replacement in html postprocessing\" do\n      it \"replaces a hashtag with a proper URL to Twitter search\" do\n        note = build(:note, body: \"A test tweet with a #hashtag\")\n        expected =\n          \"A test tweet with a <a href='https://twitter.com/search?q=%23hashtag&\" \\\n          \"src=tren&mode=realtime'>#hashtag</a>\"\n        expect(note.html_preprocess(nil, note.body)).to eq(expected)\n      end\n\n      it \"replaces a @mention by a proper URL to the twitter account\" do\n        note = create(:note, body: \"A test tweet with a @mention\")\n        expected = \"A test tweet with a <a href='https://twitter.com/mention'>@mention</a>\"\n        expect(note.html_preprocess(nil, note.body)).to eq(expected)\n      end\n\n      it \"replaces a http URL by a proper link\" do\n        note = create(:note, body: \"A test tweet with a http://link.com\")\n        expected = \"A test tweet with a <a href='http://link.com'>http://link.com</a>\"\n        expect(note.html_preprocess(nil, note.body)).to eq(expected)\n      end\n\n      it \"replaces a https URL with a proper link\" do\n        note = create(:note, body: \"A test tweet with a https://link.com\")\n        expected = \"A test tweet with a <a href='https://link.com'>https://link.com</a>\"\n        expect(note.html_preprocess(nil, note.body)).to eq(expected)\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire \"rails_helper\"\n\ndescribe Page, type: :model do\n  let!(:blog) { create(:blog) }\n\n  describe \"before save\" do\n    context \"when saving a page without a name\" do\n      let(:page) { create(:page, name: nil, title: \"A title\") }\n\n      it \"sets the name based on the title\" do\n        expect(page.name).to eq(\"a-title\")\n      end\n    end\n  end\n\n  describe \"#permalink_url\" do\n    let(:page) { build(:page, name: \"page_one\", blog: blog) }\n\n    it \"returns a full url based on the page name in the pages section\" do\n      expect(page.permalink_url).to eq(\"#{blog.base_url}/pages/page_one\")\n    end\n  end\n\n  describe \"validations\" do\n    context \"with an existing page name\" do\n      let!(:page) { create(:page, name: \"page_one\") }\n\n      it { expect(build(:page, name: page.name)).to be_invalid }\n    end\n\n    context \"without name\" do\n      it { expect(build(:page, name: nil)).to be_valid }\n    end\n\n    context \"without body\" do\n      it { expect(build(:page, body: nil)).to be_invalid }\n    end\n\n    context \"without title\" do\n      it { expect(build(:page, title: nil)).to be_invalid }\n    end\n  end\n\n  describe \"default_text_filter\" do\n    it { expect(create(:page).default_text_filter.name).to eq(blog.text_filter) }\n  end\n\n  describe \"search_with\" do\n    context \"with an simple page\" do\n      subject { described_class.search_with(params) }\n\n      let!(:page) { create(:page) }\n\n      context \"with nil params\" do\n        let(:params) { nil }\n\n        it { expect(subject).to eq([page]) }\n      end\n\n      context \"with a matching searchstring page\" do\n        let(:params) { { searchstring: \"foobar\" } }\n        let!(:match_page) { create(:page, title: \"foobar\") }\n\n        it { expect(subject).to eq([match_page]) }\n      end\n\n      context \"with 2 pages with title aaa and zzz\" do\n        let!(:last_page) { create(:page, title: \"ZZZ\", state: \"published\") }\n        let!(:first_page) { create(:page, title: \"AAA\", state: \"published\") }\n        let(:params) { { published: \"1\" } }\n\n        it { expect(subject).to eq([first_page, page, last_page]) }\n      end\n    end\n  end\n\n  describe \"#redirect\" do\n    context \"with a simple page\" do\n      let(:page) { create(:page) }\n\n      it { expect(page.redirect.to_path).to eq(page.permalink_url) }\n    end\n\n    context \"with an unpublished page\" do\n      let(:page) { create(:page, state: \"draft\") }\n\n      it { expect(page.redirect).to be_blank }\n    end\n  end\n\n  describe \"#html\" do\n    it \"returns an html_safe string\" do\n      page = build(:page)\n      expect(page.html).to be_html_safe\n    end\n  end\nend\n", "<h1 class='page-header'><%= link_to_permalink(@page, @page.title) %></h1>\n<%= @page.html %>\n", "<li class='list-unstyled' id=\"comment-<%= comment.id %>\">\n  <%= avatar_tag(email: comment.email, url: comment.url, class: 'img-circle pull-left gravatar') %>\n  <div class='content'>\n    <h4>\n      <%= t('.by') %> <%= comment.url.blank? ? h(comment.author) : nofollowified_link_to(h(comment.author), comment.url) %>\n      <%= display_date_and_time comment.created_at %>\n    </h4>\n    <%= comment.html %>\n    <%- unless comment.published? %>\n      <div class=\"spamwarning\"><%= t('.this_comment_has_been_flagged_for_moderator_approval') %></div>\n    <%- end %>\n    <hr />\n  </div>\n</li>\n"], "filenames": ["publify_core/app/helpers/base_helper.rb", "publify_core/app/models/content_base.rb", "publify_core/app/models/feedback.rb", "publify_core/app/views/articles/_article_excerpt.html.erb", "publify_core/app/views/articles/_full_article_content.html.erb", "publify_core/app/views/articles/view_page.html.erb", "publify_core/app/views/comments/_comment.html.erb", "publify_core/app/views/notes/_note.html.erb", "publify_core/app/views/notes/index.html.erb", "publify_core/spec/helpers/base_helper_spec.rb", "publify_core/spec/models/article_spec.rb", "publify_core/spec/models/comment_spec.rb", "publify_core/spec/models/content_spec.rb", "publify_core/spec/models/note_spec.rb", "publify_core/spec/models/page_spec.rb", "themes/bootstrap-2/views/articles/view_page.html.erb", "themes/bootstrap-2/views/comments/_comment.html.erb"], "buggy_code_start_loc": [242, 5, 13, 8, 2, 2, 9, 4, 5, 162, 400, 260, 147, 257, 91, 2, 8], "buggy_code_end_loc": [247, 46, 19, 9, 4, 3, 10, 5, 6, 181, 400, 264, 162, 257, 91, 3, 9], "fixing_code_start_loc": [243, 6, 12, 8, 2, 2, 9, 4, 5, 163, 401, 260, 146, 258, 92, 2, 8], "fixing_code_end_loc": [252, 52, 12, 9, 4, 3, 10, 5, 6, 195, 409, 299, 146, 265, 99, 3, 9], "type": "CWE-79", "message": "In Publify, versions v8.0 to v9.2.4 are vulnerable to stored XSS. A user with a \u201cpublisher\u201d role is able to inject and execute arbitrary JavaScript code while creating a page/article.", "other": {"cve": {"id": "CVE-2021-25974", "sourceIdentifier": "vulnerabilitylab@mend.io", "published": "2021-11-10T11:15:07.573", "lastModified": "2021-11-12T20:27:41.693", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Publify, versions v8.0 to v9.2.4 are vulnerable to stored XSS. A user with a \u201cpublisher\u201d role is able to inject and execute arbitrary JavaScript code while creating a page/article."}, {"lang": "es", "value": "En Publify, versiones v8.0 a v9.2.4, son vulnerables a un ataque de tipo XSS almacenado. Un usuario con un rol \"publisher\" es capaz de inyectar y ejecutar c\u00f3digo JavaScript arbitrario mientras crea una p\u00e1gina/art\u00edculo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "vulnerabilitylab@mend.io", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:publify_project:publify:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0", "versionEndIncluding": "9.2.4", "matchCriteriaId": "03BDB5FE-FAF3-4D40-B1D7-D0144A9E3612"}]}]}], "references": [{"url": "https://github.com/publify/publify/commit/fefd5f76302adcc425b2b6e7e7d23587cfc0083e", "source": "vulnerabilitylab@mend.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.whitesourcesoftware.com/vulnerability-database/CVE-2021-25974", "source": "vulnerabilitylab@mend.io", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/publify/publify/commit/fefd5f76302adcc425b2b6e7e7d23587cfc0083e"}}