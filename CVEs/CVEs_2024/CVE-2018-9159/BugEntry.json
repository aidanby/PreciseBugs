{"buggy_code": ["/*\n * Copyright 2002-2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage spark.resource;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\n\nimport spark.utils.Assert;\nimport spark.utils.ClassUtils;\nimport spark.utils.StringUtils;\n\n/**\n * {@link Resource} implementation for class path resources.\n * Uses either a given ClassLoader or a given Class for loading resources.\n * <p>Supports resolution as {@code java.io.File} if the class path\n * resource resides in the file system, but not for resources in a JAR.\n * Always supports resolution as URL.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @see ClassLoader#getResourceAsStream(String)\n * @see Class#getResourceAsStream(String)\n * Code copied from Spring source. Modifications made (mostly removal of methods) by Per Wendel.\n */\npublic class ClassPathResource extends AbstractFileResolvingResource {\n\n    private final String path;\n\n    private ClassLoader classLoader;\n\n    private Class<?> clazz;\n\n\n    /**\n     * Create a new ClassPathResource for ClassLoader usage.\n     * A leading slash will be removed, as the ClassLoader\n     * resource access methods will not accept it.\n     * <p>The thread context class loader will be used for\n     * loading the resource.\n     *\n     * @param path the absolute path within the class path\n     * @see java.lang.ClassLoader#getResourceAsStream(String)\n     * @see spark.utils.ClassUtils#getDefaultClassLoader()\n     */\n    public ClassPathResource(String path) {\n        this(path, null);\n    }\n\n    /**\n     * Create a new ClassPathResource for ClassLoader usage.\n     * A leading slash will be removed, as the ClassLoader\n     * resource access methods will not accept it.\n     *\n     * @param path        the absolute path within the classpath\n     * @param classLoader the class loader to load the resource with,\n     *                    or {@code null} for the thread context class loader\n     * @see ClassLoader#getResourceAsStream(String)\n     */\n    public ClassPathResource(String path, ClassLoader classLoader) {\n        Assert.notNull(path, \"Path must not be null\");\n        Assert.state(doesNotContainFileColon(path), \"Path must not contain 'file:'\");\n\n        String pathToUse = StringUtils.cleanPath(path);\n\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n\n        this.path = pathToUse;\n        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n    }\n\n    private static boolean doesNotContainFileColon(String path) {\n        return !path.contains(\"file:\");\n    }\n\n    /**\n     * Create a new ClassPathResource with optional ClassLoader and Class.\n     * Only for internal usage.\n     *\n     * @param path        relative or absolute path within the classpath\n     * @param classLoader the class loader to load the resource with, if any\n     * @param clazz       the class to load resources with, if any\n     */\n    protected ClassPathResource(String path, ClassLoader classLoader, Class<?> clazz) {\n        this.path = StringUtils.cleanPath(path);\n        this.classLoader = classLoader;\n        this.clazz = clazz;\n    }\n\n    /**\n     * Return the path for this resource (as resource path within the class path).\n     *\n     * @return the path\n     */\n    public final String getPath() {\n        return this.path;\n    }\n\n    /**\n     * This implementation checks for the resolution of a resource URL.\n     *\n     * @return if exists.\n     * @see java.lang.ClassLoader#getResource(String)\n     * @see java.lang.Class#getResource(String)\n     */\n    @Override\n    public boolean exists() {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        return (url != null);\n    }\n\n    /**\n     * This implementation opens an InputStream for the given class path resource.\n     *\n     * @return the input stream.\n     * @see java.lang.ClassLoader#getResourceAsStream(String)\n     * @see java.lang.Class#getResourceAsStream(String)\n     */\n    @Override\n    public InputStream getInputStream() throws IOException {\n        InputStream is;\n        if (this.clazz != null) {\n            is = this.clazz.getResourceAsStream(this.path);\n        } else {\n            is = this.classLoader.getResourceAsStream(this.path);\n        }\n        if (is == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n        }\n        return is;\n    }\n\n    /**\n     * This implementation returns a URL for the underlying class path resource.\n     *\n     * @return the url.\n     * @see java.lang.ClassLoader#getResource(String)\n     * @see java.lang.Class#getResource(String)\n     */\n    @Override\n    public URL getURL() throws IOException {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        if (url == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL because it does not exist\");\n        }\n        return url;\n    }\n\n    /**\n     * This implementation creates a ClassPathResource, applying the given path\n     * relative to the path of the underlying resource of this descriptor.\n     *\n     * @return the resource.\n     * @see spark.utils.StringUtils#applyRelativePath(String, String)\n     */\n    @Override\n    public Resource createRelative(String relativePath) {\n        String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n        return new ClassPathResource(pathToUse, this.classLoader, this.clazz);\n    }\n\n    /**\n     * This implementation returns the name of the file that this class path\n     * resource refers to.\n     *\n     * @return the file name.\n     * @see spark.utils.StringUtils#getFilename(String)\n     */\n    @Override\n    public String getFilename() {\n        return StringUtils.getFilename(this.path);\n    }\n\n    /**\n     * This implementation returns a description that includes the class path location.\n     *\n     * @return the description.\n     */\n    @Override\n    public String getDescription() {\n        StringBuilder builder = new StringBuilder(\"class path resource [\");\n        String pathToUse = path;\n        if (this.clazz != null && !pathToUse.startsWith(\"/\")) {\n            builder.append(ClassUtils.classPackageAsResourcePath(this.clazz));\n            builder.append('/');\n        }\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n        builder.append(pathToUse);\n        builder.append(']');\n        return builder.toString();\n    }\n\n    /**\n     * This implementation compares the underlying class path locations.\n     *\n     * @return if equals.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof ClassPathResource) {\n            ClassPathResource otherRes = (ClassPathResource) obj;\n\n            ClassLoader thisLoader = this.classLoader;\n            ClassLoader otherLoader = otherRes.classLoader;\n\n            return (this.path.equals(otherRes.path) &&\n                thisLoader.equals(otherLoader) &&\n                this.clazz.equals(otherRes.clazz));\n        }\n        return false;\n    }\n\n    /**\n     * This implementation returns the hash code of the underlying\n     * class path location.\n     *\n     * @return the hash code.\n     */\n    @Override\n    public int hashCode() {\n        return this.path.hashCode();\n    }\n\n}\n", "package spark.embeddedserver.jetty;\n\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.util.thread.QueuedThreadPool;\nimport org.junit.After;\nimport org.junit.Test;\nimport spark.embeddedserver.EmbeddedServer;\nimport spark.route.Routes;\nimport spark.staticfiles.StaticFilesConfiguration;\n\nimport static org.mockito.Mockito.*;\n\npublic class EmbeddedJettyFactoryTest {\n    private EmbeddedServer embeddedServer;\n\n    @Test\n    public void create() throws Exception {\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(100,10,10000)).thenReturn(new Server());\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 8080, null, 100,10,10000);\n\n        verify(jettyServerFactory, times(1)).create(100,10,10000);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n\n    @Test\n    public void create_withThreadPool() throws Exception {\n        final QueuedThreadPool threadPool = new QueuedThreadPool(100);\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(threadPool)).thenReturn(new Server(threadPool));\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory).withThreadPool(threadPool);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 8080, null, 0,0,0);\n\n        verify(jettyServerFactory, times(1)).create(threadPool);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n\n    @Test\n    public void create_withNullThreadPool() throws Exception {\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(100,10,10000)).thenReturn(new Server());\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory).withThreadPool(null);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 8080, null, 100,10,10000);\n\n        verify(jettyServerFactory, times(1)).create(100,10,10000);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        if(embeddedServer != null) embeddedServer.extinguish();\n    }\n}\n", "/*\n * Copyright 2011- Per Wendel\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage spark.examples.staticresources;\n\nimport static spark.Spark.get;\nimport static spark.Spark.staticFileLocation;\n\n/**\n * Example showing how serve static resources.\n */\npublic class StaticResources {\n\n    public static void main(String[] args) {\n\n        // Will serve all static file are under \"/public\" in classpath if the route isn't consumed by others routes.\n        staticFileLocation(\"/public\");\n\n        get(\"/hello\", (request, response) -> {\n            return \"Hello World!\";\n        });\n    }\n}\n"], "fixing_code": ["/*\n * Copyright 2002-2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage spark.resource;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\n\nimport spark.utils.Assert;\nimport spark.utils.ClassUtils;\nimport spark.utils.ResourceUtils;\nimport spark.utils.StringUtils;\n\n/**\n * {@link Resource} implementation for class path resources.\n * Uses either a given ClassLoader or a given Class for loading resources.\n * <p>Supports resolution as {@code java.io.File} if the class path\n * resource resides in the file system, but not for resources in a JAR.\n * Always supports resolution as URL.\n *\n * @author Juergen Hoeller\n * @author Sam Brannen\n * @see ClassLoader#getResourceAsStream(String)\n * @see Class#getResourceAsStream(String)\n * Code copied from Spring source. Modifications made (mostly removal of methods) by Per Wendel.\n */\npublic class ClassPathResource extends AbstractFileResolvingResource {\n\n    private final String path;\n\n    private ClassLoader classLoader;\n\n    private Class<?> clazz;\n\n\n    /**\n     * Create a new ClassPathResource for ClassLoader usage.\n     * A leading slash will be removed, as the ClassLoader\n     * resource access methods will not accept it.\n     * <p>The thread context class loader will be used for\n     * loading the resource.\n     *\n     * @param path the absolute path within the class path\n     * @see java.lang.ClassLoader#getResourceAsStream(String)\n     * @see spark.utils.ClassUtils#getDefaultClassLoader()\n     */\n    public ClassPathResource(String path) {\n        this(path, null);\n    }\n\n    /**\n     * Create a new ClassPathResource for ClassLoader usage.\n     * A leading slash will be removed, as the ClassLoader\n     * resource access methods will not accept it.\n     *\n     * @param path        the absolute path within the classpath\n     * @param classLoader the class loader to load the resource with,\n     *                    or {@code null} for the thread context class loader\n     * @see ClassLoader#getResourceAsStream(String)\n     */\n    public ClassPathResource(String path, ClassLoader classLoader) {\n        Assert.notNull(path, \"Path must not be null\");\n        Assert.isTrue(isValid(path), \"Path is not valid\");\n\n        String pathToUse = StringUtils.cleanPath(path);\n\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n\n        this.path = pathToUse;\n        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());\n    }\n\n    private static boolean isValid(final String path) {\n        return !isInvalidPath(path);\n    }\n\n    private static boolean isInvalidPath(String path) {\n        if (path.contains(\"WEB-INF\") || path.contains(\"META-INF\")) {\n            return true;\n        }\n        if (path.contains(\":/\")) {\n            String relativePath = (path.charAt(0) == '/' ? path.substring(1) : path);\n            if (ResourceUtils.isUrl(relativePath) || relativePath.startsWith(\"url:\")) {\n                return true;\n            }\n        }\n        if (path.contains(\"\")) {\n            path = StringUtils.cleanPath(path);\n            if (path.contains(\"../\")) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Create a new ClassPathResource with optional ClassLoader and Class.\n     * Only for internal usage.\n     *\n     * @param path        relative or absolute path within the classpath\n     * @param classLoader the class loader to load the resource with, if any\n     * @param clazz       the class to load resources with, if any\n     */\n    protected ClassPathResource(String path, ClassLoader classLoader, Class<?> clazz) {\n        this.path = StringUtils.cleanPath(path);\n        this.classLoader = classLoader;\n        this.clazz = clazz;\n    }\n\n    /**\n     * Return the path for this resource (as resource path within the class path).\n     *\n     * @return the path\n     */\n    public final String getPath() {\n        return this.path;\n    }\n\n    /**\n     * This implementation checks for the resolution of a resource URL.\n     *\n     * @return if exists.\n     * @see java.lang.ClassLoader#getResource(String)\n     * @see java.lang.Class#getResource(String)\n     */\n    @Override\n    public boolean exists() {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        return (url != null);\n    }\n\n    /**\n     * This implementation opens an InputStream for the given class path resource.\n     *\n     * @return the input stream.\n     * @see java.lang.ClassLoader#getResourceAsStream(String)\n     * @see java.lang.Class#getResourceAsStream(String)\n     */\n    @Override\n    public InputStream getInputStream() throws IOException {\n        InputStream is;\n        if (this.clazz != null) {\n            is = this.clazz.getResourceAsStream(this.path);\n        } else {\n            is = this.classLoader.getResourceAsStream(this.path);\n        }\n        if (is == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be opened because it does not exist\");\n        }\n        return is;\n    }\n\n    /**\n     * This implementation returns a URL for the underlying class path resource.\n     *\n     * @return the url.\n     * @see java.lang.ClassLoader#getResource(String)\n     * @see java.lang.Class#getResource(String)\n     */\n    @Override\n    public URL getURL() throws IOException {\n        URL url;\n        if (this.clazz != null) {\n            url = this.clazz.getResource(this.path);\n        } else {\n            url = this.classLoader.getResource(this.path);\n        }\n        if (url == null) {\n            throw new FileNotFoundException(getDescription() + \" cannot be resolved to URL because it does not exist\");\n        }\n        return url;\n    }\n\n    /**\n     * This implementation creates a ClassPathResource, applying the given path\n     * relative to the path of the underlying resource of this descriptor.\n     *\n     * @return the resource.\n     * @see spark.utils.StringUtils#applyRelativePath(String, String)\n     */\n    @Override\n    public Resource createRelative(String relativePath) {\n        String pathToUse = StringUtils.applyRelativePath(this.path, relativePath);\n        return new ClassPathResource(pathToUse, this.classLoader, this.clazz);\n    }\n\n    /**\n     * This implementation returns the name of the file that this class path\n     * resource refers to.\n     *\n     * @return the file name.\n     * @see spark.utils.StringUtils#getFilename(String)\n     */\n    @Override\n    public String getFilename() {\n        return StringUtils.getFilename(this.path);\n    }\n\n    /**\n     * This implementation returns a description that includes the class path location.\n     *\n     * @return the description.\n     */\n    @Override\n    public String getDescription() {\n        StringBuilder builder = new StringBuilder(\"class path resource [\");\n        String pathToUse = path;\n        if (this.clazz != null && !pathToUse.startsWith(\"/\")) {\n            builder.append(ClassUtils.classPackageAsResourcePath(this.clazz));\n            builder.append('/');\n        }\n        if (pathToUse.startsWith(\"/\")) {\n            pathToUse = pathToUse.substring(1);\n        }\n        builder.append(pathToUse);\n        builder.append(']');\n        return builder.toString();\n    }\n\n    /**\n     * This implementation compares the underlying class path locations.\n     *\n     * @return if equals.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (obj instanceof ClassPathResource) {\n            ClassPathResource otherRes = (ClassPathResource) obj;\n\n            ClassLoader thisLoader = this.classLoader;\n            ClassLoader otherLoader = otherRes.classLoader;\n\n            return (this.path.equals(otherRes.path) &&\n                    thisLoader.equals(otherLoader) &&\n                    this.clazz.equals(otherRes.clazz));\n        }\n        return false;\n    }\n\n    /**\n     * This implementation returns the hash code of the underlying\n     * class path location.\n     *\n     * @return the hash code.\n     */\n    @Override\n    public int hashCode() {\n        return this.path.hashCode();\n    }\n\n}\n", "package spark.embeddedserver.jetty;\n\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.util.thread.QueuedThreadPool;\nimport org.junit.After;\nimport org.junit.Test;\n\nimport spark.embeddedserver.EmbeddedServer;\nimport spark.route.Routes;\nimport spark.staticfiles.StaticFilesConfiguration;\n\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoMoreInteractions;\nimport static org.mockito.Mockito.when;\n\npublic class EmbeddedJettyFactoryTest {\n\n    private EmbeddedServer embeddedServer;\n\n    @Test\n    public void create() throws Exception {\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(100, 10, 10000)).thenReturn(new Server());\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 6757, null, 100, 10, 10000);\n\n        verify(jettyServerFactory, times(1)).create(100, 10, 10000);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n\n    @Test\n    public void create_withThreadPool() throws Exception {\n        final QueuedThreadPool threadPool = new QueuedThreadPool(100);\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(threadPool)).thenReturn(new Server(threadPool));\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory).withThreadPool(threadPool);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 6758, null, 0, 0, 0);\n\n        verify(jettyServerFactory, times(1)).create(threadPool);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n\n    @Test\n    public void create_withNullThreadPool() throws Exception {\n        final JettyServerFactory jettyServerFactory = mock(JettyServerFactory.class);\n        final StaticFilesConfiguration staticFilesConfiguration = mock(StaticFilesConfiguration.class);\n        final Routes routes = mock(Routes.class);\n\n        when(jettyServerFactory.create(100, 10, 10000)).thenReturn(new Server());\n\n        final EmbeddedJettyFactory embeddedJettyFactory = new EmbeddedJettyFactory(jettyServerFactory).withThreadPool(null);\n        embeddedServer = embeddedJettyFactory.create(routes, staticFilesConfiguration, false);\n\n        embeddedServer.ignite(\"localhost\", 6759, null, 100, 10, 10000);\n\n        verify(jettyServerFactory, times(1)).create(100, 10, 10000);\n        verifyNoMoreInteractions(jettyServerFactory);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        if (embeddedServer != null) {\n            embeddedServer.extinguish();\n        }\n    }\n}\n", "/*\n * Copyright 2011- Per Wendel\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage spark.examples.staticresources;\n\nimport static spark.Spark.get;\nimport static spark.Spark.staticFiles;\n\n/**\n * Example showing how serve static resources.\n */\npublic class StaticResources {\n\n    public static void main(String[] args) {\n\n        // Will serve all static file are under \"/public\" in classpath if the route isn't consumed by others routes.\n        staticFiles.location(\"/public\");\n\n        get(\"/hello\", (request, response) -> {\n            return \"Hello World!\";\n        });\n    }\n}\n"], "filenames": ["src/main/java/spark/resource/ClassPathResource.java", "src/test/java/spark/embeddedserver/jetty/EmbeddedJettyFactoryTest.java", "src/test/java/spark/examples/staticresources/StaticResources.java"], "buggy_code_start_loc": [25, 6, 20], "buggy_code_end_loc": [241, 71, 31], "fixing_code_start_loc": [26, 7, 20], "fixing_code_end_loc": [261, 79, 31], "type": "CWE-22", "message": "In Spark before 2.7.2, a remote attacker can read unintended static files via various representations of absolute or relative pathnames, as demonstrated by file: URLs and directory traversal sequences. NOTE: this product is unrelated to Ignite Realtime Spark.", "other": {"cve": {"id": "CVE-2018-9159", "sourceIdentifier": "cve@mitre.org", "published": "2018-03-31T21:29:00.373", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In Spark before 2.7.2, a remote attacker can read unintended static files via various representations of absolute or relative pathnames, as demonstrated by file: URLs and directory traversal sequences. NOTE: this product is unrelated to Ignite Realtime Spark."}, {"lang": "es", "value": "En Spark en versiones anteriores a la 2.7.2, un atacante remoto puede leer archivos est\u00e1ticos no deseados mediante varias representaciones de nombres de ruta relativos o absolutos, tal y como queda demostrado con las secuencias de URL de archivos y saltos de directorio. NOTA: este producto no est\u00e1 relacionado con Ignite Realtime Spark."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sparkjava:spark:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "F6D877A4-D00C-4CDC-9D9F-25A04579D30F"}]}]}], "references": [{"url": "http://sparkjava.com/news#spark-272-released", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2020", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:2405", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/perwendel/spark/commit/030e9d00125cbd1ad759668f85488aba1019c668", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/perwendel/spark/commit/a221a864db28eb736d36041df2fa6eb8839fc5cd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/perwendel/spark/commit/ce9e11517eca69e58ed4378d1e47a02bd06863cc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/perwendel/spark/issues/981", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/perwendel/spark/commit/030e9d00125cbd1ad759668f85488aba1019c668"}}