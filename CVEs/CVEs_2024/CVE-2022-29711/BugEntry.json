{"buggy_code": ["<?php\n/**\n * GraylogController.php\n *\n * -Description-\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * @link       https://www.librenms.org\n *\n * @copyright  2018 Tony Murray\n * @author     Tony Murray <murraytony@gmail.com>\n */\n\nnamespace App\\Http\\Controllers\\Table;\n\nuse App\\ApiClients\\GraylogApi;\nuse App\\Models\\Device;\nuse DateInterval;\nuse DateTime;\nuse DateTimeZone;\nuse Illuminate\\Http\\Request;\nuse LibreNMS\\Config;\nuse LibreNMS\\Util\\Url;\n\nclass GraylogController extends SimpleTableController\n{\n    private $timezone;\n    private $deviceCache = [];\n\n    public function __construct()\n    {\n        $timezone = Config::get('graylog.timezone');\n        $this->timezone = $timezone ? new DateTimeZone($timezone) : null;\n    }\n\n    public function __invoke(Request $request, GraylogApi $api)\n    {\n        if (! $api->isConfigured()) {\n            return response()->json([\n                'error' => 'Graylog is not configured',\n            ], 503);\n        }\n\n        $this->validate($request, [\n            'stream' => 'nullable|alpha_num',\n            'device' => 'nullable|int',\n            'range' => 'nullable|int',\n            'loglevel' => 'nullable|int|min:0|max:7',\n        ]);\n\n        $search = $request->get('searchPhrase');\n        $device_id = $request->get('device');\n        $device = $device_id ? Device::find($device_id) : null;\n        $range = $request->get('range', 0);\n        $limit = $request->get('rowCount', 10);\n        $page = $request->get('current', 1);\n        $offset = ($page - 1) * $limit;\n        $loglevel = $request->get('loglevel') ?? Config::get('graylog.loglevel');\n\n        $query = $api->buildSimpleQuery($search, $device) .\n            ($loglevel !== null ? ' AND level: <=' . $loglevel : '');\n\n        $sort = null;\n        foreach ($request->get('sort', []) as $field => $direction) {\n            $sort = \"$field:$direction\";\n        }\n\n        $stream = $request->get('stream');\n        $filter = $stream ? \"streams:$stream\" : null;\n\n        try {\n            $data = $api->query($query, $range, $limit, $offset, $sort, $filter);\n\n            return $this->formatResponse(\n                array_map([$this, 'formatMessage'], $data['messages']),\n                $page,\n                count($data['messages']),\n                $data['total_results']\n            );\n        } catch (\\Exception $se) {\n            $error = $se->getMessage();\n        }\n\n        return response()->json([\n            'error' => $error,\n        ], 500);\n    }\n\n    private function formatMessage($message)\n    {\n        if ($this->timezone) {\n            $graylogTime = new DateTime($message['message']['timestamp']);\n            $offset = $this->timezone->getOffset($graylogTime);\n\n            $timeInterval = DateInterval::createFromDateString((string) $offset . 'seconds');\n            $graylogTime->add($timeInterval);\n            $displayTime = $graylogTime->format('Y-m-d H:i:s');\n        } else {\n            $displayTime = $message['message']['timestamp'];\n        }\n\n        $device = $this->deviceFromSource($message['message']['source']);\n        $level = $message['message']['level'] ?? '';\n        $facility = $message['message']['facility'] ?? '';\n\n        return [\n            'severity'  => $this->severityLabel($level),\n            'timestamp' => $displayTime,\n            'source'    => $device ? Url::deviceLink($device) : $message['message']['source'],\n            'message'   => $message['message']['message'] ?? '',\n            'facility'  => is_numeric($facility) ? \"($facility) \" . __(\"syslog.facility.$facility\") : $facility,\n            'level'     => (is_numeric($level) && $level >= 0) ? \"($level) \" . __(\"syslog.severity.$level\") : $level,\n        ];\n    }\n\n    private function severityLabel($severity)\n    {\n        $map = [\n            '0' => 'label-danger',\n            '1' => 'label-danger',\n            '2' => 'label-danger',\n            '3' => 'label-danger',\n            '4' => 'label-warning',\n            '5' => 'label-info',\n            '6' => 'label-info',\n            '7' => 'label-default',\n            ''  => 'label-info',\n        ];\n        $barColor = isset($map[$severity]) ? $map[$severity] : 'label-info';\n\n        return '<span class=\"alert-status ' . $barColor . '\" style=\"margin-right:8px;float:left;\"></span>';\n    }\n\n    /**\n     * Cache device lookups so we don't lookup for every entry\n     *\n     * @param  mixed  $source\n     * @return mixed\n     */\n    private function deviceFromSource($source)\n    {\n        if (! isset($this->deviceCache[$source])) {\n            $this->deviceCache[$source] = Device::findByIp($source) ?: Device::findByHostname($source);\n        }\n\n        return $this->deviceCache[$source];\n    }\n}\n"], "fixing_code": ["<?php\n/**\n * GraylogController.php\n *\n * -Description-\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n *\n * @link       https://www.librenms.org\n *\n * @copyright  2018 Tony Murray\n * @author     Tony Murray <murraytony@gmail.com>\n */\n\nnamespace App\\Http\\Controllers\\Table;\n\nuse App\\ApiClients\\GraylogApi;\nuse App\\Models\\Device;\nuse DateInterval;\nuse DateTime;\nuse DateTimeZone;\nuse Illuminate\\Http\\Request;\nuse LibreNMS\\Config;\nuse LibreNMS\\Util\\Url;\n\nclass GraylogController extends SimpleTableController\n{\n    private $timezone;\n    private $deviceCache = [];\n\n    public function __construct()\n    {\n        $timezone = Config::get('graylog.timezone');\n        $this->timezone = $timezone ? new DateTimeZone($timezone) : null;\n    }\n\n    public function __invoke(Request $request, GraylogApi $api)\n    {\n        if (! $api->isConfigured()) {\n            return response()->json([\n                'error' => 'Graylog is not configured',\n            ], 503);\n        }\n\n        $this->validate($request, [\n            'stream' => 'nullable|alpha_num',\n            'device' => 'nullable|int',\n            'range' => 'nullable|int',\n            'loglevel' => 'nullable|int|min:0|max:7',\n        ]);\n\n        $search = $request->get('searchPhrase');\n        $device_id = $request->get('device');\n        $device = $device_id ? Device::find($device_id) : null;\n        $range = $request->get('range', 0);\n        $limit = $request->get('rowCount', 10);\n        $page = $request->get('current', 1);\n        $offset = ($page - 1) * $limit;\n        $loglevel = $request->get('loglevel') ?? Config::get('graylog.loglevel');\n\n        $query = $api->buildSimpleQuery($search, $device) .\n            ($loglevel !== null ? ' AND level: <=' . $loglevel : '');\n\n        $sort = null;\n        foreach ($request->get('sort', []) as $field => $direction) {\n            $sort = \"$field:$direction\";\n        }\n\n        $stream = $request->get('stream');\n        $filter = $stream ? \"streams:$stream\" : null;\n\n        try {\n            $data = $api->query($query, $range, $limit, $offset, $sort, $filter);\n\n            return $this->formatResponse(\n                array_map([$this, 'formatMessage'], $data['messages']),\n                $page,\n                count($data['messages']),\n                $data['total_results']\n            );\n        } catch (\\Exception $se) {\n            $error = $se->getMessage();\n        }\n\n        return response()->json([\n            'error' => $error,\n        ], 500);\n    }\n\n    private function formatMessage($message)\n    {\n        if ($this->timezone) {\n            $graylogTime = new DateTime($message['message']['timestamp']);\n            $offset = $this->timezone->getOffset($graylogTime);\n\n            $timeInterval = DateInterval::createFromDateString((string) $offset . 'seconds');\n            $graylogTime->add($timeInterval);\n            $displayTime = $graylogTime->format('Y-m-d H:i:s');\n        } else {\n            $displayTime = $message['message']['timestamp'];\n        }\n\n        $device = $this->deviceFromSource($message['message']['source']);\n        $level = $message['message']['level'] ?? '';\n        $facility = $message['message']['facility'] ?? '';\n\n        return [\n            'severity'  => $this->severityLabel($level),\n            'timestamp' => $displayTime,\n            'source'    => $device ? Url::deviceLink($device) : htmlspecialchars($message['message']['source']),\n            'message'   => htmlspecialchars($message['message']['message'] ?? ''),\n            'facility'  => is_numeric($facility) ? \"($facility) \" . __(\"syslog.facility.$facility\") : $facility,\n            'level'     => (is_numeric($level) && $level >= 0) ? \"($level) \" . __(\"syslog.severity.$level\") : $level,\n        ];\n    }\n\n    private function severityLabel($severity)\n    {\n        $map = [\n            '0' => 'label-danger',\n            '1' => 'label-danger',\n            '2' => 'label-danger',\n            '3' => 'label-danger',\n            '4' => 'label-warning',\n            '5' => 'label-info',\n            '6' => 'label-info',\n            '7' => 'label-default',\n            ''  => 'label-info',\n        ];\n        $barColor = isset($map[$severity]) ? $map[$severity] : 'label-info';\n\n        return '<span class=\"alert-status ' . $barColor . '\" style=\"margin-right:8px;float:left;\"></span>';\n    }\n\n    /**\n     * Cache device lookups so we don't lookup for every entry\n     *\n     * @param  mixed  $source\n     * @return mixed\n     */\n    private function deviceFromSource($source)\n    {\n        if (! isset($this->deviceCache[$source])) {\n            $this->deviceCache[$source] = Device::findByIp($source) ?: Device::findByHostname($source);\n        }\n\n        return $this->deviceCache[$source];\n    }\n}\n"], "filenames": ["app/Http/Controllers/Table/GraylogController.php"], "buggy_code_start_loc": [121], "buggy_code_end_loc": [123], "fixing_code_start_loc": [121], "fixing_code_end_loc": [123], "type": "CWE-79", "message": "LibreNMS v22.3.0 was discovered to contain a cross-site scripting (XSS) vulnerability via the component /Table/GraylogController.php.", "other": {"cve": {"id": "CVE-2022-29711", "sourceIdentifier": "cve@mitre.org", "published": "2022-06-02T14:15:50.643", "lastModified": "2022-06-09T20:19:26.350", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LibreNMS v22.3.0 was discovered to contain a cross-site scripting (XSS) vulnerability via the component /Table/GraylogController.php."}, {"lang": "es", "value": "Se ha detectado que LibreNMS versi\u00f3n v22.3.0, conten\u00eda una vulnerabilidad de tipo cross-site scripting (XSS) por medio del componente /Table/GraylogController.php"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:librenms:librenms:22.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "273F355E-5A03-4C65-84BE-EACC37953655"}]}]}], "references": [{"url": "https://github.com/librenms/librenms/commit/cc6112b8fb36039b862b42d86eb79ef7ee89d31b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/librenms/librenms/pull/13931", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/librenms/librenms/commit/cc6112b8fb36039b862b42d86eb79ef7ee89d31b"}}