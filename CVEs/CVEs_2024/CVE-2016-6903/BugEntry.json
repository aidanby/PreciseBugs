{"buggy_code": ["#\n#  Limited command Shell (lshell)\n#\n#  Copyright (C) 2008-2013 Ignace Mouzannar (ghantoos) <ghantoos@ghantoos.org>\n#\n#  This file is part of lshell\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\n\n# import lshell specifics\nfrom lshell import utils\n\n\ndef warn_count(messagetype, command, conf, strict=None, ssh=None):\n    \"\"\" Update the warning_counter, log and display a warning to the user\n    \"\"\"\n\n    log = conf['logpath']\n    if not ssh:\n        if strict:\n            conf['warning_counter'] -= 1\n            if conf['warning_counter'] < 0:\n                log.critical('*** forbidden %s -> \"%s\"'\n                             % (messagetype, command))\n                log.critical('*** Kicked out')\n                sys.exit(1)\n            else:\n                log.critical('*** forbidden %s -> \"%s\"'\n                             % (messagetype, command))\n                sys.stderr.write('*** You have %s warning(s) left,'\n                                 ' before getting kicked out.\\n'\n                                 % conf['warning_counter'])\n                log.error('*** User warned, counter: %s'\n                          % conf['warning_counter'])\n                sys.stderr.write('This incident has been reported.\\n')\n        else:\n            if not conf['quiet']:\n                log.critical('*** forbidden %s: %s'\n                             % (messagetype, command))\n\n    # if you are here, means that you did something wrong. Return 1.\n    return 1, conf\n\n\ndef check_path(line, conf, completion=None, ssh=None, strict=None):\n    \"\"\" Check if a path is entered in the line. If so, it checks if user\n    are allowed to see this path. If user is not allowed, it calls\n    warn_count. In case of completion, it only returns 0 or 1.\n    \"\"\"\n    allowed_path_re = str(conf['path'][0])\n    denied_path_re = str(conf['path'][1][:-1])\n\n    # split line depending on the operators\n    sep = re.compile(r'\\ |;|\\||&')\n    line = line.strip()\n    line = sep.split(line)\n\n    for item in line:\n        # remove potential quotes or back-ticks\n        item = re.sub(r'^[\"\\'`]|[\"\\'`]$', '', item)\n\n        # remove potential $(), ${}, ``\n        item = re.sub(r'^\\$[\\(\\{]|[\\)\\}]$', '', item)\n\n        # if item has been converted to something other than a string\n        # or an int, reconvert it to a string\n        if type(item) not in ['str', 'int']:\n            item = str(item)\n        # replace \"~\" with home path\n        item = os.path.expanduser(item)\n\n        # expand shell wildcards using \"echo\"\n        # i know, this a bit nasty...\n        if re.findall('\\$|\\*|\\?', item):\n            # remove quotes if available\n            item = re.sub(\"\\\"|\\'\", \"\", item)\n            import subprocess\n            p = subprocess.Popen(\"`which echo` %s\" % item,\n                                 shell=True,\n                                 stdin=subprocess.PIPE,\n                                 stdout=subprocess.PIPE,\n                                 stderr=subprocess.PIPE)\n            cout = p.stdout\n\n            try:\n                item = cout.readlines()[0].decode('utf8').split(' ')[0]\n                item = item.strip()\n                item = os.path.expandvars(item)\n            except IndexError:\n                conf['logpath'].critical('*** Internal error: command not '\n                                         'executed')\n                return 1, conf\n\n        tomatch = os.path.realpath(item)\n        if os.path.isdir(tomatch) and tomatch[-1] != '/':\n            tomatch += '/'\n        match_allowed = re.findall(allowed_path_re, tomatch)\n        if denied_path_re:\n            match_denied = re.findall(denied_path_re, tomatch)\n        else:\n            match_denied = None\n\n        # if path not allowed\n        # case path executed: warn, and return 1\n        # case completion: return 1\n        if not match_allowed or match_denied:\n            if not completion:\n                ret, conf = warn_count('path',\n                                       tomatch,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n            return 1, conf\n\n    if not completion:\n        if not re.findall(allowed_path_re, os.getcwd() + '/'):\n            ret, conf = warn_count('path',\n                                   tomatch,\n                                   conf,\n                                   strict=strict,\n                                   ssh=ssh)\n            os.chdir(conf['home_path'])\n            conf['promptprint'] = utils.updateprompt(os.getcwd(),\n                                                     conf)\n            return 1, conf\n    return 0, conf\n\n\ndef check_secure(line, conf, strict=None, ssh=None):\n    \"\"\"This method is used to check the content on the typed command.\n    Its purpose is to forbid the user to user to override the lshell\n    command restrictions.\n    The forbidden characters are placed in the 'forbidden' variable.\n    Feel free to update the list. Emptying it would be quite useless..: )\n\n    A warning counter has been added, to kick out of lshell a user if he\n    is warned more than X time (X being the 'warning_counter' variable).\n    \"\"\"\n\n    # store original string\n    oline = line\n\n    # strip all spaces/tabs\n    line = \" \".join(line.split())\n\n    # init return code\n    returncode = 0\n\n    # This logic is kept crudely simple on purpose.\n    # At most we might match the same stanza twice\n    # (for e.g. \"'a'\", 'a') but the converse would\n    # require detecting single quotation stanzas\n    # nested within double quotes and vice versa\n    relist = re.findall(r'[^=]\\\"(.+)\\\"', line)\n    relist2 = re.findall(r'[^=]\\'(.+)\\'', line)\n    relist = relist + relist2\n    for item in relist:\n        if os.path.exists(item):\n            ret_check_path, conf = check_path(item, conf, strict=strict)\n            returncode += ret_check_path\n\n    # ignore quoted text\n    line = re.sub(r'\\\"(.+?)\\\"', '', line)\n    line = re.sub(r'\\'(.+?)\\'', '', line)\n\n    if re.findall('[:cntrl:].*\\n', line):\n        ret, conf = warn_count('syntax',\n                               oline,\n                               conf,\n                               strict=strict,\n                               ssh=ssh)\n        return ret, conf\n\n    for item in conf['forbidden']:\n        # allow '&&' and '||' even if singles are forbidden\n        if item in ['&', '|']:\n            if re.findall(\"[^\\%s]\\%s[^\\%s]\" % (item, item, item), line):\n                ret, conf = warn_count('syntax',\n                                       oline,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n                return ret, conf\n        else:\n            if item in line:\n                ret, conf = warn_count('syntax',\n                                       oline,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n                return ret, conf\n\n    # check if the line contains $(foo) executions, and check them\n    executions = re.findall('\\$\\([^)]+[)]', line)\n    for item in executions:\n        # recurse on check_path\n        ret_check_path, conf = check_path(item[2:-1].strip(),\n                                          conf,\n                                          strict=strict)\n        returncode += ret_check_path\n\n        # recurse on check_secure\n        ret_check_secure, conf = check_secure(item[2:-1].strip(),\n                                              conf,\n                                              strict=strict)\n        returncode += ret_check_secure\n\n    # check for executions using back quotes '`'\n    executions = re.findall('\\`[^`]+[`]', line)\n    for item in executions:\n        ret_check_secure, conf = check_secure(item[1:-1].strip(),\n                                              conf,\n                                              strict=strict)\n        returncode += ret_check_secure\n\n    # check if the line contains ${foo=bar}, and check them\n    curly = re.findall('\\$\\{[^}]+[}]', line)\n    for item in curly:\n        # split to get variable only, and remove last character \"}\"\n        if re.findall(r'=|\\+|\\?|\\-', item):\n            variable = re.split('=|\\+|\\?|\\-', item, 1)\n        else:\n            variable = item\n        ret_check_path, conf = check_path(variable[1][:-1],\n                                          conf,\n                                          strict=strict)\n        returncode += ret_check_path\n\n    # if unknown commands where found, return 1 and don't execute the line\n    if returncode > 0:\n        return 1, conf\n    # in case the $(foo) or `foo` command passed the above tests\n    elif line.startswith('$(') or line.startswith('`'):\n        return 0, conf\n\n    # in case ';', '|' or '&' are not forbidden, check if in line\n    lines = []\n\n    # corrected by Alojzij Blatnik #48\n    # test first character\n    if line[0] in [\"&\", \"|\", \";\"]:\n        start = 1\n    else:\n        start = 0\n\n    # split remaining command line\n    for i in range(1, len(line)):\n        # in case \\& or \\| or \\; don't split it\n        if line[i] in [\"&\", \"|\", \";\"] and line[i - 1] != \"\\\\\":\n            # if there is more && or || skip it\n            if start != i:\n                lines.append(line[start:i])\n            start = i + 1\n\n    # append remaining command line\n    if start != len(line):\n        lines.append(line[start:len(line)])\n\n    # remove trailing parenthesis\n    line = re.sub('\\)$', '', line)\n    for separate_line in lines:\n        separate_line = \" \".join(separate_line.split())\n        splitcmd = separate_line.strip().split(' ')\n        command = splitcmd[0]\n        if len(splitcmd) > 1:\n            cmdargs = splitcmd\n        else:\n            cmdargs = None\n\n        # in case of a sudo command, check in sudo_commands list if allowed\n        if command == 'sudo':\n            if type(cmdargs) == list:\n                # allow the -u (user) flag\n                if cmdargs[1] == '-u' and cmdargs:\n                    sudocmd = cmdargs[3]\n                else:\n                    sudocmd = cmdargs[1]\n                if sudocmd not in conf['sudo_commands'] and cmdargs:\n                    ret, conf = warn_count('sudo command',\n                                           oline,\n                                           conf,\n                                           strict=strict,\n                                           ssh=ssh)\n                    return ret, conf\n\n        # if over SSH, replaced allowed list with the one of overssh\n        if ssh:\n            conf['allowed'] = conf['overssh']\n\n        # for all other commands check in allowed list\n        if command not in conf['allowed'] and command:\n            ret, conf = warn_count('command',\n                                   command,\n                                   conf,\n                                   strict=strict,\n                                   ssh=ssh)\n            return ret, conf\n    return 0, conf\n", "import unittest\nimport pexpect\nimport os\nimport subprocess\nfrom getpass import getuser\n\n# import lshell specifics\nfrom lshell import utils\n\nTOPDIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\n\n\nclass TestFunctions(unittest.TestCase):\n\n    user = getuser()\n\n    def setUp(self):\n        \"\"\" spawn lshell with pexpext and return the child \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf --strict 1'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n    def tearDown(self):\n        self.child.close()\n\n    def test_01_welcome_message(self):\n        \"\"\" F01 | lshell welcome message \"\"\"\n        expected = \"You are in a limited shell.\\r\\nType '?' or 'help' to get\" \\\n            \" the list of allowed commands\\r\\n\"\n        result = self.child.before.decode('utf8')\n        self.assertEqual(expected, result)\n\n    def test_02_builtin_ls_command(self):\n        \"\"\" F02 | built-in ls command \"\"\"\n        p = subprocess.Popen(\"ls ~\",\n                             shell=True,\n                             stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE)\n        cout = p.stdout\n        expected = cout.read(-1)\n        self.child.sendline('ls')\n        self.child.expect('%s:~\\$' % self.user)\n        output = self.child.before.decode('utf8').split('ls\\r', 1)[1]\n        self.assertEqual(len(expected.strip().split()),\n                         len(output.strip().split()))\n\n    def test_03_external_echo_command_num(self):\n        \"\"\" F03 | external echo number \"\"\"\n        expected = \"32\"\n        self.child.sendline('echo 32')\n        self.child.expect(\"%s:~\\$\" % self.user)\n        result = self.child.before.decode('utf8').split()[2]\n        self.assertEqual(expected, result)\n\n    def test_04_external_echo_command_string(self):\n        \"\"\" F04 | external echo random string \"\"\"\n        expected = \"bla blabla  32 blibli! plop.\"\n        self.child.sendline('echo \"%s\"' % expected)\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_05_external_echo_forbidden_syntax(self):\n        \"\"\" F05 | echo forbidden syntax $(bleh) \"\"\"\n        expected = \"*** forbidden syntax -> \\\"echo $(uptime)\\\"\\r\\n*** You \" \\\n            \"have 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('echo $(uptime)')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_06_builtin_cd_change_dir(self):\n        \"\"\" F06 | built-in cd - change directory \"\"\"\n        expected = \"\"\n        home = os.path.expanduser('~')\n        dirpath = None\n        for path in os.listdir(home):\n            dirpath = os.path.join(home, path)\n            if os.path.isdir(dirpath):\n                break\n        if dirpath:\n            self.child.sendline('cd %s' % path)\n            self.child.expect('%s:~/%s\\$' % (self.user, path))\n            self.child.sendline('cd ..')\n            self.child.expect('%s:~\\$' % self.user)\n            result = self.child.before.decode('utf8').split('\\n', 1)[1]\n            self.assertEqual(expected, result)\n\n    def test_07_builtin_cd_tilda(self):\n        \"\"\" F07 | built-in cd - tilda bug \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls ~/../../etc/passwd')\n        self.child.expect(\"%s:~\\$\" % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_08_builtin_cd_quotes(self):\n        \"\"\" F08 | built-in - quotes in cd \"/\" \"\"\"\n        expected = \"*** forbidden path -> \\\"/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -ld \"/\"')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_09_external_forbidden_path(self):\n        \"\"\" F09 | external command forbidden path - ls /root \"\"\"\n        expected = \"*** forbidden path -> \\\"/root/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls ~root')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_10_builtin_cd_forbidden_path(self):\n        \"\"\" F10 | built-in command forbidden path - cd ~root \"\"\"\n        expected = \"*** forbidden path -> \\\"/root/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('cd ~root')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_11_etc_passwd_1(self):\n        \"\"\" F11 | /etc/passwd: empty variable 'ls \"$a\"/etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls \"$a\"/etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_12_etc_passwd_2(self):\n        \"\"\" F12 | /etc/passwd: empty variable 'ls -l .*./.*./etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -l .*./.*./etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_13_etc_passwd_3(self):\n        \"\"\" F13 | /etc/passwd: empty variable 'ls -l .?/.?/etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -l .?/.?/etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_14_path_completion_tilda(self):\n        \"\"\" F14 | path completion with ~/ \"\"\"\n        p = subprocess.Popen(\"ls -F ~/\",\n                             shell=True,\n                             stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE)\n        cout = p.stdout\n        expected = cout.read(-1)\n        self.child.sendline('cd ~/\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        output = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(len(expected.strip().split()),\n                         len(output.strip().split()))\n\n    def test_15_cmd_completion_tab_tab(self):\n        \"\"\" F15 | command completion: tab to list commands \"\"\"\n        expected = '\\x07\\r\\ncd       echo     help     ll       ls       '\\\n                   '\\r\\nclear    exit     history  lpath    lsudo'\n        self.child.sendline('\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').strip()\n\n        self.assertEqual(expected, result)\n\n    def test_16_exitcode_with_separator_external_cmd(self):\n        \"\"\" F16 | external command exit codes with separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('ls nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[2].strip()\n        self.assertEqual(expected, result)\n\n    def test_17_exitcode_without_separator_external_cmd(self):\n        \"\"\" F17 | external command exit codes without separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('ls nRVmmn8RGypVneYIp8HxyVAvaEaD55')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_18_cd_exitcode_with_separator_internal_cmd(self):\n        \"\"\" F18 | built-in command exit codes with separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_19_cd_exitcode_without_separator_external_cmd(self):\n        \"\"\" F19 | built-in exit codes without separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_20_cd_with_cmd_unknwon_dir(self):\n        \"\"\" F20 | test built-in cd with command when dir does not exist\n            Should be returning error, not executing cmd\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = 'lshell: nRVmmn8RGypVneYIp8HxyVAvaEaD55: No such file or '\\\n                   'directory'\n\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_21_allow_slash(self):\n        \"\"\" F21 | user should able to allow / access minus some directory\n            (e.g. /var)\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--path \"[\\'/\\'] - [\\'/var\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"*** forbidden path: /var/\"\n        self.child.sendline('cd /')\n        self.child.expect('%s:/\\$' % self.user)\n        self.child.sendline('cd var')\n        self.child.expect('%s:/\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_22_expand_env_variables(self):\n        \"\"\" F22 | expanding of environment variables \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'export\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"%s/test\" % os.path.expanduser('~')\n        self.child.sendline('export A=test')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $HOME/$A')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_23_expand_env_variables_cd(self):\n        \"\"\" F23 | expanding of environment variables when using cd \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'export\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        random = utils.random_string(32)\n\n        expected = 'lshell: %s/random_%s: No such file or directory' % (\n            os.path.expanduser('~'), random)\n        self.child.sendline('export A=random_%s' % random)\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('cd $HOME/$A')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_24_cd_and_command(self):\n        \"\"\" F24 | cd && command should not be interpreted by internal function\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"OK\"\n        self.child.sendline('cd ~ && echo \"OK\"')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_25_KeyboardInterrupt(self):\n        \"\"\" F25 | test cat(1) with KeyboardInterrupt, should not exit \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'cat\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        self.child.sendline('cat')\n        self.child.sendline(' foo ')\n        self.child.sendcontrol('c')\n        self.child.expect('%s:~\\$' % self.user)\n        try:\n            result = self.child.before.decode('utf8').split('\\n')[1].strip()\n            # both behaviors are correct\n            if result.startswith('foo'):\n                expected = 'foo'\n            elif result.startswith('^C'):\n                expected = '^C'\n        except IndexError:\n            # outputs u' ^C' on Debian\n            expected = u'^C'\n            result = self.child.before.decode('utf8').strip()\n        self.assertIn(expected, result)\n\n    def test_26_cmd_completion_dot_slash(self):\n        \"\"\" F26 | command completion: tab to list ./foo1 ./foo2 \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'./foo1\\', \\'./foo2\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'./\\x07foo\\x07\\r\\nfoo1  foo2'\n        self.child.sendline('./\\t\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').strip()\n\n        self.assertEqual(expected, result)\n\n    def test_27_checksecure_awk(self):\n        \"\"\" F27 | checksecure awk script with /bin/bash \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'awk\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'*** forbidden path: /bin/bash'\n        self.child.sendline('awk \\'BEGIN {system(\"/bin/bash\")}\\'')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n\n        self.assertEqual(expected, result)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"], "fixing_code": ["#\n#  Limited command Shell (lshell)\n#\n#  Copyright (C) 2008-2013 Ignace Mouzannar (ghantoos) <ghantoos@ghantoos.org>\n#\n#  This file is part of lshell\n#\n#  This program is free software: you can redistribute it and/or modify\n#  it under the terms of the GNU General Public License as published by\n#  the Free Software Foundation, either version 3 of the License, or\n#  (at your option) any later version.\n#\n#  This program is distributed in the hope that it will be useful,\n#  but WITHOUT ANY WARRANTY; without even the implied warranty of\n#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#  GNU General Public License for more details.\n#\n#  You should have received a copy of the GNU General Public License\n#  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nimport sys\nimport re\nimport os\n\n# import lshell specifics\nfrom lshell import utils\n\n\ndef warn_count(messagetype, command, conf, strict=None, ssh=None):\n    \"\"\" Update the warning_counter, log and display a warning to the user\n    \"\"\"\n\n    log = conf['logpath']\n    if not ssh:\n        if strict:\n            conf['warning_counter'] -= 1\n            if conf['warning_counter'] < 0:\n                log.critical('*** forbidden %s -> \"%s\"'\n                             % (messagetype, command))\n                log.critical('*** Kicked out')\n                sys.exit(1)\n            else:\n                log.critical('*** forbidden %s -> \"%s\"'\n                             % (messagetype, command))\n                sys.stderr.write('*** You have %s warning(s) left,'\n                                 ' before getting kicked out.\\n'\n                                 % conf['warning_counter'])\n                log.error('*** User warned, counter: %s'\n                          % conf['warning_counter'])\n                sys.stderr.write('This incident has been reported.\\n')\n        else:\n            if not conf['quiet']:\n                log.critical('*** forbidden %s: %s'\n                             % (messagetype, command))\n\n    # if you are here, means that you did something wrong. Return 1.\n    return 1, conf\n\n\ndef check_path(line, conf, completion=None, ssh=None, strict=None):\n    \"\"\" Check if a path is entered in the line. If so, it checks if user\n    are allowed to see this path. If user is not allowed, it calls\n    warn_count. In case of completion, it only returns 0 or 1.\n    \"\"\"\n    allowed_path_re = str(conf['path'][0])\n    denied_path_re = str(conf['path'][1][:-1])\n\n    # split line depending on the operators\n    sep = re.compile(r'\\ |;|\\||&')\n    line = line.strip()\n    line = sep.split(line)\n\n    for item in line:\n        # remove potential quotes or back-ticks\n        item = re.sub(r'^[\"\\'`]|[\"\\'`]$', '', item)\n\n        # remove potential $(), ${}, ``\n        item = re.sub(r'^\\$[\\(\\{]|[\\)\\}]$', '', item)\n\n        # if item has been converted to something other than a string\n        # or an int, reconvert it to a string\n        if type(item) not in ['str', 'int']:\n            item = str(item)\n        # replace \"~\" with home path\n        item = os.path.expanduser(item)\n\n        # expand shell wildcards using \"echo\"\n        # i know, this a bit nasty...\n        if re.findall('\\$|\\*|\\?', item):\n            # remove quotes if available\n            item = re.sub(\"\\\"|\\'\", \"\", item)\n            import subprocess\n            p = subprocess.Popen(\"`which echo` %s\" % item,\n                                 shell=True,\n                                 stdin=subprocess.PIPE,\n                                 stdout=subprocess.PIPE,\n                                 stderr=subprocess.PIPE)\n            cout = p.stdout\n\n            try:\n                item = cout.readlines()[0].decode('utf8').split(' ')[0]\n                item = item.strip()\n                item = os.path.expandvars(item)\n            except IndexError:\n                conf['logpath'].critical('*** Internal error: command not '\n                                         'executed')\n                return 1, conf\n\n        tomatch = os.path.realpath(item)\n        if os.path.isdir(tomatch) and tomatch[-1] != '/':\n            tomatch += '/'\n        match_allowed = re.findall(allowed_path_re, tomatch)\n        if denied_path_re:\n            match_denied = re.findall(denied_path_re, tomatch)\n        else:\n            match_denied = None\n\n        # if path not allowed\n        # case path executed: warn, and return 1\n        # case completion: return 1\n        if not match_allowed or match_denied:\n            if not completion:\n                ret, conf = warn_count('path',\n                                       tomatch,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n            return 1, conf\n\n    if not completion:\n        if not re.findall(allowed_path_re, os.getcwd() + '/'):\n            ret, conf = warn_count('path',\n                                   tomatch,\n                                   conf,\n                                   strict=strict,\n                                   ssh=ssh)\n            os.chdir(conf['home_path'])\n            conf['promptprint'] = utils.updateprompt(os.getcwd(),\n                                                     conf)\n            return 1, conf\n    return 0, conf\n\n\ndef check_secure(line, conf, strict=None, ssh=None):\n    \"\"\"This method is used to check the content on the typed command.\n    Its purpose is to forbid the user to user to override the lshell\n    command restrictions.\n    The forbidden characters are placed in the 'forbidden' variable.\n    Feel free to update the list. Emptying it would be quite useless..: )\n\n    A warning counter has been added, to kick out of lshell a user if he\n    is warned more than X time (X being the 'warning_counter' variable).\n    \"\"\"\n\n    # store original string\n    oline = line\n\n    # strip all spaces/tabs\n    line = line.strip()\n\n    # init return code\n    returncode = 0\n\n    # This logic is kept crudely simple on purpose.\n    # At most we might match the same stanza twice\n    # (for e.g. \"'a'\", 'a') but the converse would\n    # require detecting single quotation stanzas\n    # nested within double quotes and vice versa\n    relist = re.findall(r'[^=]\\\"(.+)\\\"', line)\n    relist2 = re.findall(r'[^=]\\'(.+)\\'', line)\n    relist = relist + relist2\n    for item in relist:\n        if os.path.exists(item):\n            ret_check_path, conf = check_path(item, conf, strict=strict)\n            returncode += ret_check_path\n\n    # ignore quoted text\n    line = re.sub(r'\\\"(.+?)\\\"', '', line)\n    line = re.sub(r'\\'(.+?)\\'', '', line)\n\n    if re.findall('[:cntrl:].*\\n', line):\n        ret, conf = warn_count('syntax',\n                               oline,\n                               conf,\n                               strict=strict,\n                               ssh=ssh)\n        return ret, conf\n\n    for item in conf['forbidden']:\n        # allow '&&' and '||' even if singles are forbidden\n        if item in ['&', '|']:\n            if re.findall(\"[^\\%s]\\%s[^\\%s]\" % (item, item, item), line):\n                ret, conf = warn_count('syntax',\n                                       oline,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n                return ret, conf\n        else:\n            if item in line:\n                ret, conf = warn_count('syntax',\n                                       oline,\n                                       conf,\n                                       strict=strict,\n                                       ssh=ssh)\n                return ret, conf\n\n    # check if the line contains $(foo) executions, and check them\n    executions = re.findall('\\$\\([^)]+[)]', line)\n    for item in executions:\n        # recurse on check_path\n        ret_check_path, conf = check_path(item[2:-1].strip(),\n                                          conf,\n                                          strict=strict)\n        returncode += ret_check_path\n\n        # recurse on check_secure\n        ret_check_secure, conf = check_secure(item[2:-1].strip(),\n                                              conf,\n                                              strict=strict)\n        returncode += ret_check_secure\n\n    # check for executions using back quotes '`'\n    executions = re.findall('\\`[^`]+[`]', line)\n    for item in executions:\n        ret_check_secure, conf = check_secure(item[1:-1].strip(),\n                                              conf,\n                                              strict=strict)\n        returncode += ret_check_secure\n\n    # check if the line contains ${foo=bar}, and check them\n    curly = re.findall('\\$\\{[^}]+[}]', line)\n    for item in curly:\n        # split to get variable only, and remove last character \"}\"\n        if re.findall(r'=|\\+|\\?|\\-', item):\n            variable = re.split('=|\\+|\\?|\\-', item, 1)\n        else:\n            variable = item\n        ret_check_path, conf = check_path(variable[1][:-1],\n                                          conf,\n                                          strict=strict)\n        returncode += ret_check_path\n\n    # if unknown commands where found, return 1 and don't execute the line\n    if returncode > 0:\n        return 1, conf\n    # in case the $(foo) or `foo` command passed the above tests\n    elif line.startswith('$(') or line.startswith('`'):\n        return 0, conf\n\n    # in case ';', '|' or '&' are not forbidden, check if in line\n    lines = []\n\n    # corrected by Alojzij Blatnik #48\n    # test first character\n    if line[0] in [\"&\", \"|\", \";\"]:\n        start = 1\n    else:\n        start = 0\n\n    # split remaining command line\n    for i in range(1, len(line)):\n        # in case \\& or \\| or \\; don't split it\n        if line[i] in [\"&\", \"|\", \";\"] and line[i - 1] != \"\\\\\":\n            # if there is more && or || skip it\n            if start != i:\n                lines.append(line[start:i])\n            start = i + 1\n\n    # append remaining command line\n    if start != len(line):\n        lines.append(line[start:len(line)])\n\n    # remove trailing parenthesis\n    line = re.sub('\\)$', '', line)\n    for separate_line in lines:\n        separate_line = \" \".join(separate_line.split())\n        splitcmd = separate_line.strip().split(' ')\n        command = splitcmd[0]\n        if len(splitcmd) > 1:\n            cmdargs = splitcmd\n        else:\n            cmdargs = None\n\n        # in case of a sudo command, check in sudo_commands list if allowed\n        if command == 'sudo':\n            if type(cmdargs) == list:\n                # allow the -u (user) flag\n                if cmdargs[1] == '-u' and cmdargs:\n                    sudocmd = cmdargs[3]\n                else:\n                    sudocmd = cmdargs[1]\n                if sudocmd not in conf['sudo_commands'] and cmdargs:\n                    ret, conf = warn_count('sudo command',\n                                           oline,\n                                           conf,\n                                           strict=strict,\n                                           ssh=ssh)\n                    return ret, conf\n\n        # if over SSH, replaced allowed list with the one of overssh\n        if ssh:\n            conf['allowed'] = conf['overssh']\n\n        # for all other commands check in allowed list\n        if command not in conf['allowed'] and command:\n            ret, conf = warn_count('command',\n                                   command,\n                                   conf,\n                                   strict=strict,\n                                   ssh=ssh)\n            return ret, conf\n    return 0, conf\n", "import unittest\nimport pexpect\nimport os\nimport subprocess\nfrom getpass import getuser\n\n# import lshell specifics\nfrom lshell import utils\n\nTOPDIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))\n\n\nclass TestFunctions(unittest.TestCase):\n\n    user = getuser()\n\n    def setUp(self):\n        \"\"\" spawn lshell with pexpext and return the child \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf --strict 1'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n    def tearDown(self):\n        self.child.close()\n\n    def test_01_welcome_message(self):\n        \"\"\" F01 | lshell welcome message \"\"\"\n        expected = \"You are in a limited shell.\\r\\nType '?' or 'help' to get\" \\\n            \" the list of allowed commands\\r\\n\"\n        result = self.child.before.decode('utf8')\n        self.assertEqual(expected, result)\n\n    def test_02_builtin_ls_command(self):\n        \"\"\" F02 | built-in ls command \"\"\"\n        p = subprocess.Popen(\"ls ~\",\n                             shell=True,\n                             stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE)\n        cout = p.stdout\n        expected = cout.read(-1)\n        self.child.sendline('ls')\n        self.child.expect('%s:~\\$' % self.user)\n        output = self.child.before.decode('utf8').split('ls\\r', 1)[1]\n        self.assertEqual(len(expected.strip().split()),\n                         len(output.strip().split()))\n\n    def test_03_external_echo_command_num(self):\n        \"\"\" F03 | external echo number \"\"\"\n        expected = \"32\"\n        self.child.sendline('echo 32')\n        self.child.expect(\"%s:~\\$\" % self.user)\n        result = self.child.before.decode('utf8').split()[2]\n        self.assertEqual(expected, result)\n\n    def test_04_external_echo_command_string(self):\n        \"\"\" F04 | external echo random string \"\"\"\n        expected = \"bla blabla  32 blibli! plop.\"\n        self.child.sendline('echo \"%s\"' % expected)\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_05_external_echo_forbidden_syntax(self):\n        \"\"\" F05 | echo forbidden syntax $(bleh) \"\"\"\n        expected = \"*** forbidden syntax -> \\\"echo $(uptime)\\\"\\r\\n*** You \" \\\n            \"have 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('echo $(uptime)')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_06_builtin_cd_change_dir(self):\n        \"\"\" F06 | built-in cd - change directory \"\"\"\n        expected = \"\"\n        home = os.path.expanduser('~')\n        dirpath = None\n        for path in os.listdir(home):\n            dirpath = os.path.join(home, path)\n            if os.path.isdir(dirpath):\n                break\n        if dirpath:\n            self.child.sendline('cd %s' % path)\n            self.child.expect('%s:~/%s\\$' % (self.user, path))\n            self.child.sendline('cd ..')\n            self.child.expect('%s:~\\$' % self.user)\n            result = self.child.before.decode('utf8').split('\\n', 1)[1]\n            self.assertEqual(expected, result)\n\n    def test_07_builtin_cd_tilda(self):\n        \"\"\" F07 | built-in cd - tilda bug \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls ~/../../etc/passwd')\n        self.child.expect(\"%s:~\\$\" % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_08_builtin_cd_quotes(self):\n        \"\"\" F08 | built-in - quotes in cd \"/\" \"\"\"\n        expected = \"*** forbidden path -> \\\"/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -ld \"/\"')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_09_external_forbidden_path(self):\n        \"\"\" F09 | external command forbidden path - ls /root \"\"\"\n        expected = \"*** forbidden path -> \\\"/root/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls ~root')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_10_builtin_cd_forbidden_path(self):\n        \"\"\" F10 | built-in command forbidden path - cd ~root \"\"\"\n        expected = \"*** forbidden path -> \\\"/root/\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('cd ~root')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_11_etc_passwd_1(self):\n        \"\"\" F11 | /etc/passwd: empty variable 'ls \"$a\"/etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls \"$a\"/etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_12_etc_passwd_2(self):\n        \"\"\" F12 | /etc/passwd: empty variable 'ls -l .*./.*./etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -l .*./.*./etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_13_etc_passwd_3(self):\n        \"\"\" F13 | /etc/passwd: empty variable 'ls -l .?/.?/etc/passwd' \"\"\"\n        expected = \"*** forbidden path -> \\\"/etc/passwd\\\"\\r\\n*** You have\" \\\n            \" 1 warning(s) left, before getting kicked out.\\r\\nThis \" \\\n            \"incident has been reported.\\r\\n\"\n        self.child.sendline('ls -l .?/.?/etc/passwd')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(expected, result)\n\n    def test_14_path_completion_tilda(self):\n        \"\"\" F14 | path completion with ~/ \"\"\"\n        p = subprocess.Popen(\"ls -F ~/\",\n                             shell=True,\n                             stdin=subprocess.PIPE,\n                             stdout=subprocess.PIPE)\n        cout = p.stdout\n        expected = cout.read(-1)\n        self.child.sendline('cd ~/\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        output = self.child.before.decode('utf8').split('\\n', 1)[1]\n        self.assertEqual(len(expected.strip().split()),\n                         len(output.strip().split()))\n\n    def test_15_cmd_completion_tab_tab(self):\n        \"\"\" F15 | command completion: tab to list commands \"\"\"\n        expected = '\\x07\\r\\ncd       echo     help     ll       ls       '\\\n                   '\\r\\nclear    exit     history  lpath    lsudo'\n        self.child.sendline('\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').strip()\n\n        self.assertEqual(expected, result)\n\n    def test_16_exitcode_with_separator_external_cmd(self):\n        \"\"\" F16 | external command exit codes with separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('ls nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[2].strip()\n        self.assertEqual(expected, result)\n\n    def test_17_exitcode_without_separator_external_cmd(self):\n        \"\"\" F17 | external command exit codes without separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('ls nRVmmn8RGypVneYIp8HxyVAvaEaD55')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_18_cd_exitcode_with_separator_internal_cmd(self):\n        \"\"\" F18 | built-in command exit codes with separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_19_cd_exitcode_without_separator_external_cmd(self):\n        \"\"\" F19 | built-in exit codes without separator \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"2\"\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_20_cd_with_cmd_unknwon_dir(self):\n        \"\"\" F20 | test built-in cd with command when dir does not exist\n            Should be returning error, not executing cmd\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--forbidden \"[]\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = 'lshell: nRVmmn8RGypVneYIp8HxyVAvaEaD55: No such file or '\\\n                   'directory'\n\n        self.child.sendline('cd nRVmmn8RGypVneYIp8HxyVAvaEaD55; echo $?')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_21_allow_slash(self):\n        \"\"\" F21 | user should able to allow / access minus some directory\n            (e.g. /var)\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--path \"[\\'/\\'] - [\\'/var\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"*** forbidden path: /var/\"\n        self.child.sendline('cd /')\n        self.child.expect('%s:/\\$' % self.user)\n        self.child.sendline('cd var')\n        self.child.expect('%s:/\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_22_expand_env_variables(self):\n        \"\"\" F22 | expanding of environment variables \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'export\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"%s/test\" % os.path.expanduser('~')\n        self.child.sendline('export A=test')\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('echo $HOME/$A')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_23_expand_env_variables_cd(self):\n        \"\"\" F23 | expanding of environment variables when using cd \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'export\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        random = utils.random_string(32)\n\n        expected = 'lshell: %s/random_%s: No such file or directory' % (\n            os.path.expanduser('~'), random)\n        self.child.sendline('export A=random_%s' % random)\n        self.child.expect('%s:~\\$' % self.user)\n        self.child.sendline('cd $HOME/$A')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_24_cd_and_command(self):\n        \"\"\" F24 | cd && command should not be interpreted by internal function\n        \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = \"OK\"\n        self.child.sendline('cd ~ && echo \"OK\"')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n        self.assertEqual(expected, result)\n\n    def test_25_KeyboardInterrupt(self):\n        \"\"\" F25 | test cat(1) with KeyboardInterrupt, should not exit \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'cat\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        self.child.sendline('cat')\n        self.child.sendline(' foo ')\n        self.child.sendcontrol('c')\n        self.child.expect('%s:~\\$' % self.user)\n        try:\n            result = self.child.before.decode('utf8').split('\\n')[1].strip()\n            # both behaviors are correct\n            if result.startswith('foo'):\n                expected = 'foo'\n            elif result.startswith('^C'):\n                expected = '^C'\n        except IndexError:\n            # outputs u' ^C' on Debian\n            expected = u'^C'\n            result = self.child.before.decode('utf8').strip()\n        self.assertIn(expected, result)\n\n    def test_26_cmd_completion_dot_slash(self):\n        \"\"\" F26 | command completion: tab to list ./foo1 ./foo2 \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'./foo1\\', \\'./foo2\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'./\\x07foo\\x07\\r\\nfoo1  foo2'\n        self.child.sendline('./\\t\\t\\t')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').strip()\n\n        self.assertEqual(expected, result)\n\n    def test_27_checksecure_awk(self):\n        \"\"\" F27 | checksecure awk script with /bin/bash \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   '--allowed \"+ [\\'awk\\']\"'\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'*** forbidden path: /bin/bash'\n        self.child.sendline('awk \\'BEGIN {system(\"/bin/bash\")}\\'')\n        self.child.expect('%s:~\\$' % self.user)\n        result = self.child.before.decode('utf8').split('\\n')[1].strip()\n\n        self.assertEqual(expected, result)\n\n    def test_28_catch_lnext_terminal_ctrl(self):\n        \"\"\" F25 | test ctrl-v ctrl-j then command, forbidden/security \"\"\"\n        self.child = pexpect.spawn('%s/bin/lshell '\n                                   '--config %s/etc/lshell.conf '\n                                   % (TOPDIR, TOPDIR))\n        self.child.expect('%s:~\\$' % self.user)\n\n        expected = u'*** forbidden syntax: echo\\r'\n        self.child.send('echo')\n        self.child.sendcontrol('v')\n        self.child.sendcontrol('j')\n        self.child.sendline('bash')\n        self.child.expect('%s:~\\$' % self.user)\n\n        result = self.child.before.decode('utf8').split('\\n')\n\n        self.assertIn(expected, result)\n\nif __name__ == '__main__':\n    unittest.main()\n"], "filenames": ["lshell/sec.py", "test/test_functional.py"], "buggy_code_start_loc": [159, 386], "buggy_code_end_loc": [160, 386], "fixing_code_start_loc": [159, 387], "fixing_code_end_loc": [160, 404], "type": "CWE-264", "message": "lshell 0.9.16 allows remote authenticated users to break out of a limited shell and execute arbitrary commands.", "other": {"cve": {"id": "CVE-2016-6903", "sourceIdentifier": "security@debian.org", "published": "2017-04-24T19:59:00.377", "lastModified": "2017-04-27T19:14:23.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "lshell 0.9.16 allows remote authenticated users to break out of a limited shell and execute arbitrary commands."}, {"lang": "es", "value": "Ishell 0.9.16 permite a usuarios remotos autenticados salir de un shell limitado y ejecutar comandos arbitrarios."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.0}, "baseSeverity": "HIGH", "exploitabilityScore": 8.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-264"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:lshell_project:lshell:0.9.16:*:*:*:*:*:*:*", "matchCriteriaId": "6EF0F461-1D41-493E-8F35-66E153E5CCCD"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2016/08/22/17", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory", "Patch"]}, {"url": "http://www.securityfocus.com/bid/92591", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=834946", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1369345", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://github.com/ghantoos/lshell/commit/e72dfcd1f258193f9aaea3591ecbdaed207661a0", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ghantoos/lshell/issues/149", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ghantoos/lshell/pull/153/commits/a686f71732a3d0f16df52ef46ab8a49ee0083c68", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ghantoos/lshell/commit/e72dfcd1f258193f9aaea3591ecbdaed207661a0"}}