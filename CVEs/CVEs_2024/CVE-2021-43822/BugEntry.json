{"buggy_code": ["<?php\n\nnamespace Jackalope\\Transport\\DoctrineDBAL\\Query;\n\nuse BadMethodCallException;\nuse DateTime;\nuse DateTimeZone;\nuse Doctrine\\DBAL\\Platforms\\MySQLPlatform;\nuse Doctrine\\DBAL\\Platforms\\PostgreSqlPlatform;\nuse Doctrine\\DBAL\\Platforms\\PostgreSQL94Platform;\nuse Doctrine\\DBAL\\Schema\\Schema;\nuse Jackalope\\NotImplementedException;\nuse Jackalope\\Query\\QOM\\PropertyValue;\nuse Jackalope\\Query\\QOM\\QueryObjectModel;\nuse Jackalope\\Transport\\DoctrineDBAL\\RepositorySchema;\nuse Jackalope\\Transport\\DoctrineDBAL\\Util\\Xpath;\nuse PHPCR\\NamespaceException;\nuse PHPCR\\NodeType\\NodeTypeInterface;\nuse PHPCR\\NodeType\\NodeTypeManagerInterface;\nuse PHPCR\\Query\\InvalidQueryException;\nuse PHPCR\\Query\\QOM;\nuse Doctrine\\DBAL\\Connection;\nuse Doctrine\\DBAL\\Platforms\\AbstractPlatform;\nuse Doctrine\\DBAL\\Platforms\\SqlitePlatform;\n\n/**\n * Converts QOM to SQL Statements for the Doctrine DBAL database backend.\n *\n * @license http://www.apache.org/licenses Apache License Version 2.0, January 2004\n * @license http://opensource.org/licenses/MIT MIT License\n */\nclass QOMWalker\n{\n    /**\n     * @var NodeTypeManagerInterface\n     */\n    private $nodeTypeManager;\n\n    /**\n     * @var array\n     */\n    private $alias = [];\n\n    /**\n     * @var QOM\\SelectorInterface\n     */\n    private $source;\n\n    /**\n     * @var Connection\n     */\n    private $conn;\n\n    /**\n     * @var AbstractPlatform\n     */\n    private $platform;\n\n    /**\n     * @var array\n     */\n    private $namespaces;\n\n    /**\n     * @var Schema\n     */\n    private $schema;\n\n    /**\n     * @param NodeTypeManagerInterface $manager\n     * @param Connection               $conn\n     * @param array                    $namespaces\n     */\n    public function __construct(NodeTypeManagerInterface $manager, Connection $conn, array $namespaces = [])\n    {\n        $this->conn = $conn;\n        $this->nodeTypeManager = $manager;\n        $this->platform = $conn->getDatabasePlatform();\n        $this->namespaces = $namespaces;\n        $this->schema = new RepositorySchema([], $this->conn);\n    }\n\n    /**\n     * Generate a table alias\n     *\n     * @param string $selectorName\n     *\n     * @return string\n     */\n    private function getTableAlias($selectorName)\n    {\n        $selectorAlias = $this->getSelectorAlias($selectorName);\n\n        if (!isset($this->alias[$selectorAlias])) {\n            $this->alias[$selectorAlias] = 'n' . count($this->alias);\n        }\n\n        return $this->alias[$selectorAlias];\n    }\n\n    /**\n     * @param string $selectorName\n     *\n     * @return string\n     */\n    private function getSelectorAlias($selectorName)\n    {\n        if (null === $selectorName) {\n            if (count($this->alias)) { // We have aliases, use the first\n                $selectorAlias = array_search('n0', $this->alias);\n            } else { // Currently no aliases, use an empty string as index\n                $selectorAlias = '';\n            }\n        } elseif (strpos($selectorName, '.') === false) {\n            $selectorAlias = $selectorName;\n        } else {\n            $parts = explode('.', $selectorName);\n            $selectorAlias = reset($parts);\n        }\n\n        if (strpos($selectorAlias, '[') === 0) {\n            $selectorAlias = substr($selectorAlias, 1, -1);\n        }\n\n        if ($this->source && $this->source->getNodeTypeName() === $selectorAlias) {\n            $selectorAlias = '';\n        }\n\n        return $selectorAlias;\n    }\n\n    /**\n     * @param QueryObjectModel $qom\n     *\n     * @return string\n     */\n    public function walkQOMQuery(QueryObjectModel $qom)\n    {\n        $source = $qom->getSource();\n        $selectors = $this->validateSource($source);\n\n        $sourceSql = ' ' . $this->walkSource($source);\n        $constraintSql = '';\n        if ($constraint = $qom->getConstraint()) {\n            $constraintSql = ' AND ' . $this->walkConstraint($constraint);\n        }\n\n        $orderingSql = '';\n        if ($orderings = $qom->getOrderings()) {\n            $orderingSql = ' ' . $this->walkOrderings($orderings);\n        }\n\n        $sql = 'SELECT ' . $this->getColumns($qom);\n        $sql .= $sourceSql;\n        $sql .= $constraintSql;\n        $sql .= $orderingSql;\n\n        $limit = $qom->getLimit();\n        $offset = $qom->getOffset();\n\n        if (null !== $offset && null === $limit\n            && ($this->platform instanceof MySQLPlatform || $this->platform instanceof SqlitePlatform)\n        ) {\n            $limit = PHP_INT_MAX;\n        }\n        $sql = $this->platform->modifyLimitQuery($sql, $limit, $offset);\n\n        return [$selectors, $this->alias, $sql];\n    }\n\n    /**\n     * @return string\n     */\n    public function getColumns(QueryObjectModel $qom)\n    {\n        // TODO we should actually build Xpath statements for each column we actually need in the result and not fetch all 'props'\n        $sqlColumns = ['path', 'identifier', 'props'];\n\n        if (count($this->alias)) {\n            $aliasSql = [];\n            foreach ($this->alias as $alias) {\n                foreach ($sqlColumns as $sqlColumn) {\n                    $aliasSql[] = sprintf('%s.%s AS %s_%s', $alias, $sqlColumn, $alias, $sqlColumn);\n                }\n            }\n\n            return implode(', ', $aliasSql);\n        }\n\n        return '*';\n    }\n\n    /**\n     * Validates the nodeTypes in given source\n     *\n     * @param QOM\\SourceInterface $source\n     *\n     * @return QOM\\SelectorInterface[]\n     *\n     * @throws InvalidQueryException\n     */\n    protected function validateSource(QOM\\SourceInterface $source)\n    {\n        if ($source instanceof QOM\\SelectorInterface) {\n            $selectors = [$source];\n            $this->validateSelectorSource($source);\n        } elseif ($source instanceof QOM\\JoinInterface) {\n            $selectors = $this->validateJoinSource($source);\n        } else {\n            $selectors = [];\n        }\n\n        return $selectors;\n    }\n\n    /**\n     * @param QOM\\SelectorInterface $source\n     *\n     * @throws InvalidQueryException\n     */\n    protected function validateSelectorSource(QOM\\SelectorInterface $source)\n    {\n        $nodeType = $source->getNodeTypeName();\n\n        if (!$this->nodeTypeManager->hasNodeType($nodeType)) {\n            $msg = 'Selected node type does not exist: ' . $nodeType;\n            if ($alias = $source->getSelectorName()) {\n                $msg .= ' AS ' . $alias;\n            }\n\n            throw new InvalidQueryException($msg);\n        }\n    }\n\n    /**\n     * @param QOM\\JoinInterface $source\n     *\n     * @return QOM\\SelectorInterface[]\n     *\n     * @throws InvalidQueryException\n     */\n    protected function validateJoinSource(QOM\\JoinInterface $source)\n    {\n        $left = $source->getLeft();\n        $right = $source->getRight();\n\n        if ($left) {\n            $selectors = $this->validateSource($left);\n        } else {\n            $selectors = [];\n        }\n\n        if ($right) {\n            // Ensure that the primary selector is first\n            if (QOM\\QueryObjectModelConstantsInterface::JCR_JOIN_TYPE_RIGHT_OUTER === $source->getJoinType()) {\n                $selectors = array_merge($this->validateSource($right), $selectors);\n            } else {\n                $selectors = array_merge($selectors, $this->validateSource($right));\n            }\n        }\n\n        return $selectors;\n    }\n\n    /**\n     * @param QOM\\SourceInterface $source\n     *\n     * @return string\n     *\n     * @throws NotImplementedException\n     */\n    public function walkSource(QOM\\SourceInterface $source)\n    {\n        if ($source instanceof QOM\\SelectorInterface) {\n            return $this->walkSelectorSource($source);\n        }\n\n        if ($source instanceof QOM\\JoinInterface) {\n            return $this->walkJoinSource($source);\n        }\n\n        throw new NotImplementedException(sprintf(\"The source class '%s' is not supported\", get_class($source)));\n    }\n\n    /**\n     * @param QOM\\SelectorInterface $source\n     *\n     * @return string\n     */\n    public function walkSelectorSource(QOM\\SelectorInterface $source)\n    {\n        $this->source = $source;\n        $alias = $this->getTableAlias($source->getSelectorName());\n        $nodeTypeClause = $this->sqlNodeTypeClause($alias, $source);\n        $sql = \"FROM phpcr_nodes $alias WHERE $alias.workspace_name = ? AND $nodeTypeClause\";\n\n        return $sql;\n    }\n\n    /**\n     * @param QOM\\JoinConditionInterface $right\n     *\n     * @return string the alias on the right side of a join\n     *\n     * @throws BadMethodCallException if the provided JoinCondition has no valid way of getting the right selector\n     */\n    private function getRightJoinSelector(QOM\\JoinConditionInterface $right)\n    {\n        if ($right instanceof QOM\\ChildNodeJoinConditionInterface) {\n            return $right->getParentSelectorName();\n        } elseif ($right instanceof QOM\\DescendantNodeJoinConditionInterface) {\n            return $right->getAncestorSelectorName();\n        } elseif ($right instanceof QOM\\SameNodeJoinConditionInterface || $right instanceof QOM\\EquiJoinConditionInterface) {\n            return $right->getSelector2Name();\n        }\n        throw new BadMethodCallException('Supplied join type should implement getSelector2Name() or be an instance of ChildNodeJoinConditionInterface or DescendantNodeJoinConditionInterface');\n    }\n\n\n    /**\n     * @param QOM\\JoinConditionInterface $right\n     *\n     * @return string the alias on the left side of a join\n     *\n     * @throws BadMethodCallException if the provided JoinCondition has no valid way of getting the left selector\n     */\n    private function getLeftJoinSelector(QOM\\JoinConditionInterface $left)\n    {\n        if ($left instanceof QOM\\ChildNodeJoinConditionInterface) {\n            return $left->getChildSelectorName();\n        } elseif ($left instanceof QOM\\DescendantNodeJoinConditionInterface) {\n            return $left->getAncestorSelectorName();\n        } elseif ($left instanceof QOM\\SameNodeJoinConditionInterface || $left instanceof QOM\\EquiJoinConditionInterface) {\n            return $left->getSelector1Name();\n        }\n        throw new BadMethodCallException('Supplied join type should implement getSelector2Name() or be an instance of ChildNodeJoinConditionInterface or DescendantNodeJoinConditionInterface');\n    }\n\n    /**\n     * find the most left join in a tree\n     *\n     * @param QOM\\JoinInterface $source\n     *\n     * @return QOM\\JoinInterface\n     */\n    private function getLeftMostJoin(QOM\\JoinInterface $source)\n    {\n        if ($source->getLeft() instanceof QOM\\JoinInterface) {\n            return $this->getLeftMostJoin($source->getLeft());\n        }\n        return $source;\n    }\n\n    /**\n     * @param QOM\\JoinInterface $source\n     * @param boolean $root whether the method call is recursed for nested joins. If true, it will add a WHERE clause\n     *        that checks the workspace_name and type\n     *\n     * @return string\n     *\n     * @throws NotImplementedException if the right side of the join consists of another join\n     */\n    public function walkJoinSource(QOM\\JoinInterface $source, $root = true)\n    {\n        $this->source = $left = $source->getLeft(); // The $left variable is used for storing the leftmost selector\n\n        if (!$source->getRight() instanceof QOM\\SelectorInterface) {\n            throw new NotImplementedException('The right side of the join should not consist of another join');\n        }\n\n        if ($source->getLeft() instanceof QOM\\SelectorInterface) {\n            $leftAlias = $this->getTableAlias($source->getLeft()->getSelectorName());\n            $this->getTableAlias($source->getLeft()->getSelectorName());\n            $sql = \"FROM phpcr_nodes $leftAlias \";\n        } else {\n            $sql = $this->walkJoinSource($left, false) . ' '; // One step left, until we're at the selector\n            $leftMostJoin = $this->getLeftMostJoin($source);\n            $leftAlias = $this->getTableAlias(\n                $this->getLeftJoinSelector($leftMostJoin->getJoinCondition())\n            );\n            $left = $leftMostJoin->getLeft();\n        }\n        $rightAlias = $this->getTableAlias($source->getRight()->getSelectorName());\n        $nodeTypeClause = $this->sqlNodeTypeClause($rightAlias, $source->getRight());\n\n        switch ($source->getJoinType()) {\n            case QOM\\QueryObjectModelConstantsInterface::JCR_JOIN_TYPE_INNER:\n                $sql .= \"INNER JOIN phpcr_nodes $rightAlias \";\n                break;\n            case QOM\\QueryObjectModelConstantsInterface::JCR_JOIN_TYPE_LEFT_OUTER:\n                $sql .= \"LEFT JOIN phpcr_nodes $rightAlias \";\n                break;\n            case QOM\\QueryObjectModelConstantsInterface::JCR_JOIN_TYPE_RIGHT_OUTER:\n                $sql .= \"RIGHT JOIN phpcr_nodes $rightAlias \";\n                break;\n        }\n\n        $sql .= \"ON ( $leftAlias.workspace_name = $rightAlias.workspace_name AND $nodeTypeClause \";\n        $sql .= 'AND ' . $this->walkJoinCondition($source->getLeft(), $source->getRight(), $source->getJoinCondition()) . ' ';\n        $sql .= ') '; // close on-clause\n\n\n        if ($root) { // The method call is not recursed when $root is true, so we can add a WHERE clause\n            // TODO: revise this part for alternatives\n            $sql .= \"WHERE $leftAlias.workspace_name = ? AND $leftAlias.type IN ('\" . $left->getNodeTypeName() . \"'\";\n            $subTypes = $this->nodeTypeManager->getSubtypes($left->getNodeTypeName());\n            foreach ($subTypes as $subType) {\n                /* @var $subType NodeTypeInterface */\n                $sql .= \", '\" . $subType->getName() . \"'\";\n            }\n            $sql .= ')';\n        }\n\n        return $sql;\n    }\n\n    /**\n     * @param QOM\\SelectorInterface|QOM\\JoinInterface $left\n     * @param QOM\\SelectorInterface $right\n     * @param QOM\\JoinConditionInterface $condition\n     *\n     * @return string\n     *\n     * @throws NotImplementedException if a SameNodeJoinCondtion is used.\n     */\n    public function walkJoinCondition($left, QOM\\SelectorInterface $right, QOM\\JoinConditionInterface $condition)\n    {\n        if ($condition instanceof QOM\\ChildNodeJoinConditionInterface) {\n            return $this->walkChildNodeJoinCondition($condition);\n        }\n        if ($condition instanceof QOM\\DescendantNodeJoinConditionInterface) {\n            return $this->walkDescendantNodeJoinCondition($condition);\n        }\n        if ($condition instanceof QOM\\EquiJoinConditionInterface) {\n            if ($left instanceof QOM\\SelectorInterface) {\n                $selectorName = $left->getSelectorName();\n            } else {\n                $selectorName = $this->getLeftJoinSelector($this->getLeftMostJoin($left)->getJoinCondition());\n            }\n            return $this->walkEquiJoinCondition($selectorName, $right->getSelectorName(), $condition);\n        }\n        if ($condition instanceof QOM\\SameNodeJoinConditionInterface) {\n            throw new NotImplementedException('SameNodeJoinCondtion');\n        }\n    }\n\n    /**\n     * @param QOM\\ChildNodeJoinConditionInterface $condition\n     *\n     * @return string\n     */\n    public function walkChildNodeJoinCondition(QOM\\ChildNodeJoinConditionInterface $condition)\n    {\n        $rightAlias = $this->getTableAlias($condition->getChildSelectorName());\n        $leftAlias = $this->getTableAlias($condition->getParentSelectorName());\n        $concatExpression = $this->platform->getConcatExpression(\"$leftAlias.path\", \"'/%'\");\n\n        return \"($rightAlias.path LIKE \" . $concatExpression . \" AND $rightAlias.depth = $leftAlias.depth + 1) \";\n    }\n\n    /**\n     * @param QOM\\DescendantNodeJoinConditionInterface $condition\n     *\n     * @return string\n     */\n    public function walkDescendantNodeJoinCondition(QOM\\DescendantNodeJoinConditionInterface $condition)\n    {\n        $rightAlias = $this->getTableAlias($condition->getDescendantSelectorName());\n        $leftAlias = $this->getTableAlias($condition->getAncestorSelectorName());\n        $concatExpression = $this->platform->getConcatExpression(\"$leftAlias.path\", \"'/%'\");\n\n        return \"$rightAlias.path LIKE \" . $concatExpression . \" \";\n    }\n\n    /**\n     * @param QOM\\EquiJoinConditionInterface $condition\n     *\n     * @return string\n     */\n    public function walkEquiJoinCondition($leftSelectorName, $rightSelectorName, QOM\\EquiJoinConditionInterface $condition)\n    {\n        return $this->walkOperand(new PropertyValue($leftSelectorName, $condition->getProperty1Name())) . ' ' .\n               $this->walkOperator(QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_EQUAL_TO) . ' ' .\n               $this->walkOperand(new PropertyValue($rightSelectorName, $condition->getProperty2Name()));\n    }\n\n    /**\n     * @param \\PHPCR\\Query\\QOM\\ConstraintInterface $constraint\n     *\n     * @return string\n     *\n     * @throws InvalidQueryException\n     */\n    public function walkConstraint(QOM\\ConstraintInterface $constraint)\n    {\n        if ($constraint instanceof QOM\\AndInterface) {\n            return $this->walkAndConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\OrInterface) {\n            return $this->walkOrConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\NotInterface) {\n            return $this->walkNotConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\ComparisonInterface) {\n            return $this->walkComparisonConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\DescendantNodeInterface) {\n            return $this->walkDescendantNodeConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\ChildNodeInterface) {\n            return $this->walkChildNodeConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\PropertyExistenceInterface) {\n            return $this->walkPropertyExistenceConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\SameNodeInterface) {\n            return $this->walkSameNodeConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\FullTextSearchInterface) {\n            return $this->walkFullTextSearchConstraint($constraint);\n        }\n\n        throw new InvalidQueryException(\"Constraint \" . get_class($constraint) . \" not yet supported.\");\n    }\n\n    /**\n     * @param QOM\\SameNodeInterface $constraint\n     *\n     * @return string\n     */\n    public function walkSameNodeConstraint(QOM\\SameNodeInterface $constraint)\n    {\n        return $this->getTableAlias($constraint->getSelectorName()) . \".path = '\" . $constraint->getPath() . \"'\";\n    }\n\n    /**\n     * @param QOM\\FullTextSearchInterface $constraint\n     *\n     * @return string\n     */\n    public function walkFullTextSearchConstraint(QOM\\FullTextSearchInterface $constraint)\n    {\n        return $this->sqlXpathExtractValue($this->getTableAlias($constraint->getSelectorName()), $constraint->getPropertyName()).' LIKE '. $this->conn->quote('%'.$constraint->getFullTextSearchExpression().'%');\n    }\n\n    /**\n     * @param QOM\\PropertyExistenceInterface $constraint\n     *\n     * @return string\n     */\n    public function walkPropertyExistenceConstraint(QOM\\PropertyExistenceInterface $constraint)\n    {\n        return $this->sqlXpathValueExists($this->getTableAlias($constraint->getSelectorName()), $constraint->getPropertyName());\n    }\n\n    /**\n     * @param QOM\\DescendantNodeInterface $constraint\n     *\n     * @return string\n     */\n    public function walkDescendantNodeConstraint(QOM\\DescendantNodeInterface $constraint)\n    {\n        $ancestorPath = $constraint->getAncestorPath();\n        if ('/' === $ancestorPath) {\n            $ancestorPath = '';\n        } elseif (substr($ancestorPath, -1) === '/') {\n            throw new InvalidQueryException(\"Trailing slash in $ancestorPath\");\n        }\n\n        return $this->getTableAlias($constraint->getSelectorName()) . \".path LIKE '\" . $ancestorPath . \"/%'\";\n    }\n\n    /**\n     * @param QOM\\ChildNodeInterface $constraint\n     *\n     * @return string\n     */\n    public function walkChildNodeConstraint(QOM\\ChildNodeInterface $constraint)\n    {\n        return $this->getTableAlias($constraint->getSelectorName()) . \".parent = '\" . $constraint->getParentPath() . \"'\";\n    }\n\n    /**\n     * @param QOM\\AndInterface $constraint\n     *\n     * @return string\n     */\n    public function walkAndConstraint(QOM\\AndInterface $constraint)\n    {\n        return \"(\" . $this->walkConstraint($constraint->getConstraint1()) . \" AND \" . $this->walkConstraint($constraint->getConstraint2()) . \")\";\n    }\n\n    /**\n     * @param QOM\\OrInterface $constraint\n     *\n     * @return string\n     */\n    public function walkOrConstraint(QOM\\OrInterface $constraint)\n    {\n        return \"(\" . $this->walkConstraint($constraint->getConstraint1()) . \" OR \" . $this->walkConstraint($constraint->getConstraint2()) . \")\";\n    }\n\n    /**\n     * @param QOM\\NotInterface $constraint\n     *\n     * @return string\n     */\n    public function walkNotConstraint(QOM\\NotInterface $constraint)\n    {\n        return \"NOT (\" . $this->walkConstraint($constraint->getConstraint()) . \")\";\n    }\n\n    /**\n     * This method figures out the best way to do a comparison\n     * When we need to compare a property with a literal value,\n     * we need to be aware of the multivalued properties, we then require\n     * a different xpath statement then with other comparisons\n     *\n     * @param QOM\\ComparisonInterface $constraint\n     *\n     * @return string\n     */\n    public function walkComparisonConstraint(QOM\\ComparisonInterface $constraint)\n    {\n        $operator = $this->walkOperator($constraint->getOperator());\n\n        $operator1 = $constraint->getOperand1();\n        $operator2 = $constraint->getOperand2();\n\n        // Check if we have a property and a literal value (in random order)\n        if (\n            ($operator1 instanceof QOM\\PropertyValueInterface\n                && $operator2 instanceof QOM\\LiteralInterface)\n            || ($operator1 instanceof QOM\\LiteralInterface\n                && $operator2 instanceof QOM\\PropertyValueInterface)\n            || ($operator1 instanceof QOM\\NodeNameInterface\n                && $operator2 instanceof QOM\\LiteralInterface)\n            || ($operator1 instanceof QOM\\LiteralInterface\n                && $operator2 instanceof QOM\\NodeNameInterface)\n        ) {\n            // Check whether the left is the literal, at this point the other always is the literal/nodename operand\n            if ($operator1 instanceof QOM\\LiteralInterface) {\n                $operand = $operator2;\n                $literalOperand = $operator1;\n            } else {\n                $literalOperand = $operator2;\n                $operand = $operator1;\n            }\n\n            if (is_string($literalOperand->getLiteralValue()) && '=' !== $operator && '!=' !== $operator) {\n                return\n                    $this->walkOperand($operator1) . ' ' .\n                    $operator . ' ' .\n                    $this->walkOperand($operator2);\n            }\n\n            if ($operand instanceof QOM\\NodeNameInterface) {\n                $selectorName = $operand->getSelectorName();\n                $alias = $this->getTableAlias($selectorName);\n\n                $literal = $literalOperand->getLiteralValue();\n                if (false !== strpos($literal, ':')) {\n                    $parts = explode(':', $literal);\n                    if (!isset($this->namespaces[$parts[0]])) {\n                        throw new NamespaceException('The namespace ' . $parts[0] . ' was not registered.');\n                    }\n\n                    $parts[0] = $this->namespaces[$parts[0]];\n                    $literal = implode(':', $parts);\n                }\n\n                return $this->platform->getConcatExpression(\"$alias.namespace\", \"(CASE $alias.namespace WHEN '' THEN '' ELSE ':' END)\", \"$alias.local_name\") . \" \" .\n                    $operator . \" \" .\n                    $this->conn->quote($literal);\n            }\n\n            if ('jcr:path' !== $operand->getPropertyName() && 'jcr:uuid' !== $operand->getPropertyName()) {\n                if (is_int($literalOperand->getLiteralValue()) || is_float($literalOperand->getLiteralValue())) {\n                    return $this->walkNumComparisonConstraint($operand, $literalOperand, $operator);\n                }\n                if (is_bool($literalOperand->getLiteralValue())) {\n                    return $this->walkBoolComparisonConstraint($operand, $literalOperand, $operator);\n                }\n\n                return $this->walkTextComparisonConstraint($operand, $literalOperand, $operator);\n            }\n        }\n\n        return\n            $this->walkOperand($operator1) . ' ' .\n            $operator . ' ' .\n            $this->walkOperand($operator2);\n    }\n\n    /**\n     * @param QOM\\PropertyValueInterface $propertyOperand\n     * @param QOM\\LiteralInterface $literalOperand\n     * @param string $operator\n     *\n     * @return string\n     */\n    public function walkTextComparisonConstraint(QOM\\PropertyValueInterface $propertyOperand, QOM\\LiteralInterface $literalOperand, $operator)\n    {\n        $alias = $this->getTableAlias($propertyOperand->getSelectorName() . '.' . $propertyOperand->getPropertyName());\n        $property = $propertyOperand->getPropertyName();\n\n        return $this->sqlXpathComparePropertyValue($alias, $property, $this->getLiteralValue($literalOperand), $operator);\n    }\n\n    public function walkBoolComparisonConstraint(QOM\\PropertyValueInterface $propertyOperand, QOM\\LiteralInterface $literalOperand, $operator)\n    {\n        $value = true === $literalOperand->getLiteralValue() ? '1' : '0';\n\n        return $this->walkOperand($propertyOperand) . ' ' . $operator . ' ' . $this->conn->quote($value);\n    }\n\n    public function walkNumComparisonConstraint(QOM\\PropertyValueInterface $propertyOperand, QOM\\LiteralInterface $literalOperand, $operator)\n    {\n        $alias = $this->getTableAlias($propertyOperand->getSelectorName() . '.' . $propertyOperand->getPropertyName());\n        $property = $propertyOperand->getPropertyName();\n\n\n        if ($this->platform instanceof MySQLPlatform && '=' === $operator) {\n            return sprintf(\n                '0 != FIND_IN_SET(\"%s\", REPLACE(EXTRACTVALUE(%s.props, \\'//sv:property[@sv:name=\"%s\"]/sv:value\\'), \" \", \",\"))',\n                $literalOperand->getLiteralValue(),\n                $alias,\n                $property\n            );\n        }\n\n        if ('=' === $operator) {\n            return $this->sqlXpathComparePropertyValue($alias, $property, $literalOperand->getLiteralValue(), $operator);\n        }\n\n        return sprintf(\n            '%s %s %s',\n            $this->sqlXpathExtractNumValue($alias, $property),\n            $operator,\n            $literalOperand->getLiteralValue()\n        );\n    }\n\n    /**\n     * @param string $operator\n     *\n     * @return string\n     */\n    public function walkOperator($operator)\n    {\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_EQUAL_TO) {\n            return '=';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_GREATER_THAN) {\n            return '>';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO) {\n            return '>=';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_LESS_THAN) {\n            return '<';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO) {\n            return '<=';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_NOT_EQUAL_TO) {\n            return '!=';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_LIKE) {\n            return 'LIKE';\n        }\n\n        return $operator; // no-op for simplicity, not standard conform (but using the constants is a pain)\n    }\n\n    /**\n     * @param QOM\\OperandInterface $operand\n     *\n     * @return string\n     *\n     * @throws InvalidQueryException\n     */\n    public function walkOperand(QOM\\OperandInterface $operand)\n    {\n        if ($operand instanceof QOM\\NodeNameInterface) {\n            $selectorName = $operand->getSelectorName();\n            $alias = $this->getTableAlias($selectorName);\n\n            return $this->platform->getConcatExpression(\"$alias.namespace\", \"(CASE $alias.namespace WHEN '' THEN '' ELSE ':' END)\", \"$alias.local_name\");\n        }\n\n        if ($operand instanceof QOM\\NodeLocalNameInterface) {\n            $selectorName = $operand->getSelectorName();\n            $alias = $this->getTableAlias($selectorName);\n\n            return \"$alias.local_name\";\n        }\n\n        if ($operand instanceof QOM\\LowerCaseInterface) {\n            return $this->platform->getLowerExpression($this->walkOperand($operand->getOperand()));\n        }\n\n        if ($operand instanceof QOM\\UpperCaseInterface) {\n            return $this->platform->getUpperExpression($this->walkOperand($operand->getOperand()));\n        }\n\n        if ($operand instanceof QOM\\LiteralInterface) {\n            return $this->conn->quote($this->getLiteralValue($operand));\n        }\n\n        if ($operand instanceof QOM\\PropertyValueInterface) {\n            $alias = $this->getTableAlias($operand->getSelectorName() . '.' . $operand->getPropertyName());\n            $property = $operand->getPropertyName();\n            if ($property === 'jcr:path') {\n                return \"$alias.path\";\n            }\n            if ($property === \"jcr:uuid\") {\n                return \"$alias.identifier\";\n            }\n\n            return $this->sqlXpathExtractValue($alias, $property);\n        }\n\n        if ($operand instanceof QOM\\LengthInterface) {\n            $alias = $this->getTableAlias($operand->getPropertyValue()->getSelectorName());\n            $property = $operand->getPropertyValue()->getPropertyName();\n\n            return $this->sqlXpathExtractValueAttribute($alias, $property, 'length');\n        }\n\n        throw new InvalidQueryException(\"Dynamic operand \" . get_class($operand) . \" not yet supported.\");\n    }\n\n    /**\n     * @param array $orderings\n     *\n     * @return string\n     */\n    public function walkOrderings(array $orderings)\n    {\n        $sql = '';\n        foreach ($orderings as $ordering) {\n            $sql .= empty($sql) ? 'ORDER BY ' : ', ';\n            $sql .= $this->walkOrdering($ordering);\n        }\n\n        return $sql;\n    }\n\n    /**\n     * @param QOM\\OrderingInterface $ordering\n     *\n     * @return string\n     */\n    public function walkOrdering(QOM\\OrderingInterface $ordering)\n    {\n        $direction = $ordering->getOrder();\n        if ($direction === QOM\\QueryObjectModelConstantsInterface::JCR_ORDER_ASCENDING) {\n            $direction = 'ASC';\n        } elseif ($direction === QOM\\QueryObjectModelConstantsInterface::JCR_ORDER_DESCENDING) {\n            $direction = 'DESC';\n        }\n\n        $sql = $this->walkOperand($ordering->getOperand());\n\n        if ($ordering->getOperand() instanceof QOM\\PropertyValueInterface) {\n            $operand = $ordering->getOperand();\n            $property = $ordering->getOperand()->getPropertyName();\n            if ($property !== 'jcr:path' && $property !== 'jcr:uuid') {\n                $alias = $this->getTableAlias($operand->getSelectorName() . '.' . $property);\n\n                $numericalSelector = $this->sqlXpathExtractValue($alias, $property, 'numerical_props');\n\n                $sql = sprintf(\n                    'CAST(%s AS DECIMAL) %s, %s',\n                    $numericalSelector,\n                    $direction,\n                    $sql\n                );\n            }\n        }\n\n        $sql .= ' ' .$direction;\n\n        return $sql;\n    }\n\n    /**\n     * @param QOM\\LiteralInterface $operand\n     *\n     * @return string\n     *\n     * @throws NamespaceException\n     */\n    private function getLiteralValue(QOM\\LiteralInterface $operand)\n    {\n        $value = $operand->getLiteralValue();\n\n        /**\n         * Normalize Dates to UTC\n         */\n        if ($value instanceof DateTime) {\n            $valueUTC = clone($value);\n            $valueUTC->setTimezone(new DateTimeZone('UTC'));\n            return $valueUTC->format('c');\n        }\n\n        return $value;\n    }\n\n    /**\n     * SQL to execute an XPATH expression checking if the property exist on the node with the given alias.\n     *\n     * @param string $alias\n     * @param string $property\n     *\n     * @return string\n     */\n    private function sqlXpathValueExists($alias, $property)\n    {\n        if ($this->platform instanceof MySQLPlatform) {\n            return \"EXTRACTVALUE($alias.props, 'count(//sv:property[@sv:name=\\\"\" . $property . \"\\\"]/sv:value[1])') = 1\";\n        }\n\n        if ($this->platform instanceof PostgreSQL94Platform || $this->platform instanceof PostgreSqlPlatform) {\n            return \"xpath_exists('//sv:property[@sv:name=\\\"\" . $property . \"\\\"]/sv:value[1]', CAST($alias.props AS xml), \".$this->sqlXpathPostgreSQLNamespaces().\") = 't'\";\n        }\n\n        if ($this->platform instanceof SqlitePlatform) {\n            return \"EXTRACTVALUE($alias.props, 'count(//sv:property[@sv:name=\\\"\" . $property . \"\\\"]/sv:value[1])') = 1\";\n        }\n\n        throw new NotImplementedException(\"Xpath evaluations cannot be executed with '\" . $this->platform->getName() . \"' yet.\");\n    }\n\n    /**\n     * SQL to execute an XPATH expression extracting the property value on the node with the given alias.\n     *\n     * @param string $alias\n     * @param string $property\n     *\n     * @return string\n     */\n    private function sqlXpathExtractValue($alias, $property, $column = 'props')\n    {\n        if ($this->platform instanceof MySQLPlatform) {\n            return \"EXTRACTVALUE($alias.$column, '//sv:property[@sv:name=\\\"\" . $property . \"\\\"]/sv:value[1]')\";\n        }\n\n        if ($this->platform instanceof PostgreSQL94Platform || $this->platform instanceof PostgreSqlPlatform) {\n            return \"(xpath('//sv:property[@sv:name=\\\"\" . $property . \"\\\"]/sv:value[1]/text()', CAST($alias.$column AS xml), \".$this->sqlXpathPostgreSQLNamespaces().\"))[1]::text\";\n        }\n\n        if ($this->platform instanceof SqlitePlatform) {\n            return \"EXTRACTVALUE($alias.$column, '//sv:property[@sv:name=\\\"\" . $property . \"\\\"]/sv:value[1]')\";\n        }\n\n        throw new NotImplementedException(\"Xpath evaluations cannot be executed with '\" . $this->platform->getName() . \"' yet.\");\n    }\n\n    private function sqlXpathExtractNumValue($alias, $property)\n    {\n        if ($this->platform instanceof PostgreSQL94Platform || $this->platform instanceof PostgreSqlPlatform) {\n            return \"(xpath('//sv:property[@sv:name=\\\"\" . $property . \"\\\"]/sv:value[1]/text()', CAST($alias.props AS xml), \".$this->sqlXpathPostgreSQLNamespaces().\"))[1]::text::int\";\n        }\n\n        return 'CAST(' . $this->sqlXpathExtractValue($alias, $property) . ' AS DECIMAL)';\n    }\n\n    private function sqlXpathExtractValueAttribute($alias, $property, $attribute, $valueIndex = 1)\n    {\n        if ($this->platform instanceof MySQLPlatform) {\n            return sprintf(\"EXTRACTVALUE(%s.props, '//sv:property[@sv:name=\\\"%s\\\"]/sv:value[%d]/@%s')\", $alias, $property, $valueIndex, $attribute);\n        }\n\n        if ($this->platform instanceof PostgreSQL94Platform || $this->platform instanceof PostgreSqlPlatform) {\n            return sprintf(\"CAST((xpath('//sv:property[@sv:name=\\\"%s\\\"]/sv:value[%d]/@%s', CAST(%s.props AS xml), %s))[1]::text AS bigint)\", $property, $valueIndex, $attribute, $alias, $this->sqlXpathPostgreSQLNamespaces());\n        }\n\n        if ($this->platform instanceof SqlitePlatform) {\n            return sprintf(\"EXTRACTVALUE(%s.props, '//sv:property[@sv:name=\\\"%s\\\"]/sv:value[%d]/@%s')\", $alias, $property, $valueIndex, $attribute);\n        }\n\n        throw new NotImplementedException(\"Xpath evaluations cannot be executed with '\" . $this->platform->getName() . \"' yet.\");\n    }\n\n    /**\n     * @param $alias\n     * @param $property\n     * @param $value\n     * @param string $operator\n     *\n     * @return string\n     *\n     * @throws NotImplementedException if the storage backend is neither mysql\n     *      nor postgres nor sqlite\n     */\n    private function sqlXpathComparePropertyValue($alias, $property, $value, $operator)\n    {\n        $expression = null;\n\n        if ($this->platform instanceof MySQLPlatform) {\n            $expression = \"EXTRACTVALUE($alias.props, 'count(//sv:property[@sv:name=\\\"\" . $property . \"\\\"]/sv:value[text()%s%s]) > 0')\";\n            // mysql does not escape the backslashes for us, while postgres and sqlite do\n            $value = Xpath::escapeBackslashes($value);\n        } elseif ($this->platform instanceof PostgreSQL94Platform || $this->platform instanceof PostgreSqlPlatform) {\n            $expression = \"xpath_exists('//sv:property[@sv:name=\\\"\" . $property . \"\\\"]/sv:value[text()%s%s]', CAST($alias.props AS xml), \".$this->sqlXpathPostgreSQLNamespaces().\") = 't'\";\n        } elseif ($this->platform instanceof SqlitePlatform) {\n            $expression = \"EXTRACTVALUE($alias.props, 'count(//sv:property[@sv:name=\\\"\" . $property . \"\\\"]/sv:value[text()%s%s]) > 0')\";\n        } else {\n            throw new NotImplementedException(\"Xpath evaluations cannot be executed with '\" . $this->platform->getName() . \"' yet.\");\n        }\n\n        return sprintf($expression, $this->walkOperator($operator), Xpath::escape($value));\n    }\n\n    /**\n     * @return string\n     */\n    private function sqlXpathPostgreSQLNamespaces()\n    {\n        return \"ARRAY[ARRAY['sv', 'http://www.jcp.org/jcr/sv/1.0']]\";\n    }\n\n    /**\n     * @param QOM\\SelectorInterface $source\n     * @param string                $alias\n     *\n     * @return string\n     */\n    private function sqlNodeTypeClause($alias, QOM\\SelectorInterface $source)\n    {\n        $sql = \"$alias.type IN ('\" . $source->getNodeTypeName() .\"'\";\n\n        $subTypes = $this->nodeTypeManager->getSubtypes($source->getNodeTypeName());\n        foreach ($subTypes as $subType) {\n            /* @var $subType NodeTypeInterface */\n            $sql .= \", '\" . $subType->getName() . \"'\";\n        }\n        $sql .= ')';\n\n        return $sql;\n    }\n}\n", "<?php\n\nnamespace Jackalope\\Transport\\DoctrineDBAL;\n\nuse DateTime;\nuse DOMDocument;\nuse DOMXPath;\nuse Jackalope\\NodeType\\NodeTypeTemplate;\nuse Jackalope\\Test\\FunctionalTestCase;\nuse PDO;\nuse PHPCR\\PropertyType;\nuse PHPCR\\Query\\QueryInterface;\nuse PHPCR\\Util\\NodeHelper;\nuse PHPCR\\Util\\PathHelper;\nuse PHPCR\\ValueFormatException;\nuse ReflectionClass;\n\nclass ClientTest extends FunctionalTestCase\n{\n    public function testQueryNodes()\n    {\n        $root = $this->session->getNode('/');\n        $article = $root->addNode('article');\n        $article->setProperty('foo', 'bar');\n        $article->setProperty('bar', 'baz');\n\n        $this->session->save();\n\n        $qm = $this->session->getWorkspace()->getQueryManager();\n        $query = $qm->createQuery('SELECT * FROM [nt:unstructured]', QueryInterface::JCR_SQL2);\n        $result = $query->execute();\n\n        $this->assertCount(2, $result->getNodes());\n\n        $query = $qm->createQuery('SELECT * FROM [nt:unstructured] WHERE foo = \"bar\"', QueryInterface::JCR_SQL2);\n        $result = $query->execute();\n\n        $this->assertCount(1, $result->getNodes());\n    }\n\n    public function testAddNodeTypes()\n    {\n        $workspace = $this->session->getWorkspace();\n        $ntm = $workspace->getNodeTypeManager();\n        $template = $ntm->createNodeTypeTemplate();\n        $template->setName('phpcr:article');\n\n        $propertyDefs = $template->getPropertyDefinitionTemplates();\n        $propertyTemplate = $ntm->createPropertyDefinitionTemplate();\n        $propertyTemplate->setName('headline');\n        $propertyTemplate->setRequiredType(PropertyType::STRING);\n        $propertyDefs[] = $propertyTemplate;\n\n        $childDefs = $template->getNodeDefinitionTemplates();\n        $nodeTemplate = $ntm->createNodeDefinitionTemplate();\n        $nodeTemplate->setName('article_content');\n        $nodeTemplate->setDefaultPrimaryTypeName('nt:unstructured');\n        $nodeTemplate->setMandatory(true);\n        $childDefs[] = $nodeTemplate;\n\n        $ntm->registerNodeTypes([$template], true);\n\n        $def = $ntm->getNodeType('phpcr:article');\n        $this->assertEquals(\"phpcr:article\", $def->getName());\n        $this->assertCount(1, $def->getDeclaredPropertyDefinitions());\n        $this->assertCount(1, $def->getDeclaredChildNodeDefinitions());\n    }\n\n    public function testReorderNodes()\n    {\n        $root = $this->session->getNode('/');\n        $topic = $root->addNode('topic');\n        $topic->addNode('page1');\n        $topic->addNode('page2');\n        $topic->addNode('page3');\n        $topic->addNode('page4');\n        $topic->addNode('page5');\n\n        $this->session->save();\n\n        $topic->orderBefore('page3', 'page1');\n        $topic->orderBefore('page4', null);\n\n        $this->session->save();\n\n        $conn = $this->getConnection();\n        $qb = $conn->createQueryBuilder();\n\n        $qb->select('local_name, sort_order')\n            ->from('phpcr_nodes', 'n')\n            ->where('n.local_name = :name')\n            ->andWhere('n.parent = :parent')\n            ->orderBy('n.sort_order', 'ASC');\n\n        $query = $qb->getSql();\n\n        $stmnt = $this->conn->executeQuery($query, ['name' => 'page3', 'parent' => '/topic']);\n        $row = $stmnt->fetch();\n        $this->assertEquals(0, $row['sort_order']);\n\n        $stmnt = $this->conn->executeQuery($query, ['name' => 'page4', 'parent' => '/topic']);\n\n        $row = $stmnt->fetch();\n        $this->assertEquals(4, $row['sort_order']);\n\n        $retrieved = $this->session->getNode('/topic');\n        foreach ($retrieved as $name => $child) {\n            $check[] = $name;\n        }\n\n        $this->assertEquals($check[0], 'page3');\n        $this->assertEquals($check[4], 'page4');\n    }\n\n    /**\n     * Test cases for depth set when adding nodes\n     */\n    public function testDepthOnAdd()\n    {\n        $root = $this->session->getNode('/');\n        $topic = $root->addNode('topic');\n        $topic->addNode('page1');\n\n        $this->session->save();\n\n        $conn = $this->getConnection();\n        $qb = $conn->createQueryBuilder();\n\n        $qb->select('local_name, depth')\n            ->from('phpcr_nodes', 'n')\n            ->where('n.path = :path');\n\n        $query = $qb->getSql();\n\n        $stmnt = $this->conn->executeQuery($query, ['path' => '/topic']);\n        $row = $stmnt->fetch();\n\n        $this->assertEquals($row['depth'], '1');\n\n        $stmnt = $this->conn->executeQuery($query, ['path' => '/topic/page1']);\n        $row = $stmnt->fetch();\n\n        $this->assertEquals($row['depth'], '2');\n    }\n\n    /**\n     * Test cases for depth when moving nodes\n     */\n    public function testDepthOnMove()\n    {\n        $root = $this->session->getNode('/');\n        $topic1 = $root->addNode('topic1');\n        $topic2 = $root->addNode('topic2');\n        $topic3 = $root->addNode('topic3');\n\n        $topic1->addNode('page1');\n        $topic2->addNode('page2');\n        $topic3->addNode('page3');\n        $this->session->save();\n\n        $this->transport->moveNodeImmediately('/topic2/page2', '/topic1/page1/page2');\n\n        $this->transport->moveNodeImmediately('/topic3', '/topic1/page1/page2/topic3');\n\n        $conn = $this->getConnection();\n        $qb = $conn->createQueryBuilder();\n\n        $qb->select('local_name, depth')\n            ->from('phpcr_nodes', 'n')\n            ->where('n.path = :path');\n\n        $query = $qb->getSql();\n\n        $stmnt = $this->conn->executeQuery($query, ['path' => '/topic1/page1/page2']);\n        $row = $stmnt->fetch();\n        $this->assertEquals($row['depth'], '3');\n\n        $stmnt = $this->conn->executeQuery($query, ['path' => '/topic1/page1/page2/topic3/page3']);\n        $row = $stmnt->fetch();\n        $this->assertEquals($row['depth'], '5');\n    }\n\n    /**\n     * @dataProvider provideTestOutOfRangeCharacters\n     */\n    public function testOutOfRangeCharacterOccurrence($string, $isValid)\n    {\n        if (false === $isValid) {\n            $this->expectException(ValueFormatException::class);\n            $this->expectExceptionMessage('Invalid character detected');\n        }\n\n        $root = $this->session->getNode('/');\n        $article = $root->addNode('article');\n        $article->setProperty('test', $string);\n        $this->session->save();\n        $this->addToAssertionCount(1);\n    }\n\n    public function provideTestOutOfRangeCharacters()\n    {\n        return [\n            ['This is valid too!'.$this->translateCharFromCode('\\u0009'), true],\n            ['This is valid', true],\n            [$this->translateCharFromCode('\\uD7FF'), true],\n            ['This is on the edge, but valid too.'. $this->translateCharFromCode('\\uFFFD'), true],\n            [$this->translateCharFromCode('\\u10000'), true],\n            [$this->translateCharFromCode('\\u10FFFF'), true],\n            [$this->translateCharFromCode('\\u0001'), false],\n            [$this->translateCharFromCode('\\u0002'), false],\n            [$this->translateCharFromCode('\\u0003'), false],\n            [$this->translateCharFromCode('\\u0008'), false],\n            [$this->translateCharFromCode('\\uFFFF'), false],\n        ];\n    }\n\n    private function translateCharFromCode($char)\n    {\n        return json_decode('\"'.$char.'\"');\n    }\n\n    public function testDeleteMoreThanOneThousandNodes()\n    {\n        $root = $this->session->getNode('/');\n        $parent = $root->addNode('test-more-than-one-thousand');\n\n        for ($i = 0; $i <= 1200; $i++) {\n            $parent->addNode('node-'.$i);\n        }\n\n        $this->session->save();\n\n        NodeHelper::purgeWorkspace($this->session);\n\n        $this->session->save();\n\n        $this->addToAssertionCount(1);\n    }\n\n    public function testPropertyLengthAttribute()\n    {\n        $rootNode = $this->session->getRootNode();\n        $node = $rootNode->addNode('testLengthAttribute');\n\n        $data = [\n            // PropertyName         PropertyValue                   PropertyType            Expected Length\n            'simpleString'  => ['simplestring',                PropertyType::STRING,   12],\n            'mbString'      => ['stringMultibit\u6f22',             PropertyType::STRING,   17],\n            'long'          => [42,                            PropertyType::LONG,     2],\n            'double'        => [3.1415,                        PropertyType::DOUBLE,   6],\n            'decimal'       => [3.141592,                      PropertyType::DECIMAL,  8],\n            'date'          => [new DateTime('now'),          PropertyType::DATE,     29],\n            'booleanTrue'   => [true,                          PropertyType::BOOLEAN,  1],\n            'booleanFalse'  => [false,                         PropertyType::BOOLEAN,  0],\n            'name'          => ['nt:unstructured',             PropertyType::NAME,     15],\n            'uri'           => ['https://google.com',          PropertyType::URI,      18],\n            'path'          => ['/root/testLengthAttribute',   PropertyType::PATH,     25],\n            // 'multiString'   => array(array('foo', 'bar'),           PropertyType::STRING,   array(3,3)),\n            // (weak)reference...\n        ];\n\n        foreach ($data as $propertyName => $propertyInfo) {\n            $node->setProperty($propertyName, $propertyInfo[0], $propertyInfo[1]);\n        }\n\n        $this->session->save();\n\n        $statement = $this->getConnection()->executeQuery('SELECT props, numerical_props FROM phpcr_nodes WHERE path = ?', ['/testLengthAttribute']);\n        $row = $statement->fetch(PDO::FETCH_ASSOC);\n        $props = $row['props'];\n        $decimalProps = $row['numerical_props'];\n\n        foreach ($data as $propertyName => $propertyInfo) {\n            $propertyElement = null;\n\n            foreach ([$props, $decimalProps] as $propXml) {\n                if (null === $propXml) {\n                    continue;\n                }\n\n                $doc = new DOMDocument('1.0', 'utf-8');\n                $doc->loadXML($propXml);\n\n                $xpath = new DOMXPath($doc);\n                $propertyElement = $xpath->query(sprintf('sv:property[@sv:name=\"%s\"]', $propertyName));\n\n                if ($propertyElement->length > 0) {\n                    break;\n                }\n            }\n\n            $this->assertEquals(1, $propertyElement->length, 'Property ' . $propertyName . ' exists');\n\n            $values = $xpath->query('sv:value', $propertyElement->item(0));\n\n            /** @var $value \\DOMElement */\n            foreach ($values as $index => $value) {\n                $lengthAttribute = $value->attributes->getNamedItem('length');\n                if (null === $lengthAttribute) {\n                    $this->fail(sprintf('Value %d for property \"%s\" is expected to have an attribute \"length\"', $index, $propertyName));\n                }\n                $this->assertEquals($propertyInfo[2], $lengthAttribute->nodeValue);\n            }\n        }\n    }\n\n    public function testUuid()\n    {\n        $class = new ReflectionClass(Client::class);\n        $method = $class->getMethod('generateUuid');\n        $method->setAccessible(true);\n\n        self::assertIsString($method->invoke($this->transport));\n\n        $this->transport->setUuidGenerator(function () {\n            return 'like-a-uuid';\n        });\n\n        self::assertEquals('like-a-uuid', $method->invoke($this->transport));\n    }\n\n    public function testMoveAndReplace()\n    {\n        $root = $this->session->getNode('/');\n        $topic1 = $root->addNode('topic1');\n        $topic1->addNode('thisisanewnode');\n        $topic1->addNode('topic1Child');\n\n        $this->session->save();\n        $this->session->move('/topic1', '/topic2');\n\n        $root->addNode('topic1');\n        $this->session->save();\n\n        $conn = $this->getConnection();\n        $qb = $conn->createQueryBuilder();\n\n        $qb->select('local_name')\n            ->from('phpcr_nodes', 'n')\n            ->where('n.path = :path');\n\n        $query = $qb->getSql();\n\n        foreach (['/topic1', '/topic2', '/topic2/thisisanewnode', '/topic2/topic1Child'] as $path) {\n            $stmnt = $this->conn->executeQuery($query, ['path' => $path]);\n            $row = $stmnt->fetch();\n            $this->assertNotFalse($row, $path . ' does not exist in database');\n        }\n    }\n\n    public function testMoveNamespacedNodes()\n    {\n        $root = $this->session->getNode('/');\n        $topic1 = $root->addNode('jcr:topic1');\n        $topic1->addNode('jcr:thisisanewnode');\n        $topic1->addNode('jcr:topic1Child');\n\n        $this->session->save();\n        $this->session->move('/jcr:topic1', '/jcr:topic2');\n\n        $this->session->save();\n\n        $conn = $this->getConnection();\n        $qb = $conn->createQueryBuilder();\n\n        $qb->select('local_name')\n            ->from('phpcr_nodes', 'n')\n            ->where('n.path = :path')->andWhere('n.local_name = :local_name');\n\n        $query = $qb->getSql();\n\n        $expectedData = [\n            '/jcr:topic2' => 'topic2',\n            '/jcr:topic2/jcr:thisisanewnode' => 'thisisanewnode',\n            '/jcr:topic2/jcr:topic1Child' => 'topic1Child'\n        ];\n        foreach ($expectedData as $path => $localName) {\n            $stmnt = $this->conn->executeQuery($query, ['path' => $path, 'local_name' => $localName]);\n            $row = $stmnt->fetch();\n            $this->assertNotFalse($row, $path . ' with local_name' . $localName . ' does not exist in database');\n        }\n    }\n\n    public function testCaseInsensativeRename()\n    {\n        $root = $this->session->getNode('/');\n        $topic1 = $root->addNode('topic');\n\n        $this->session->save();\n        $this->session->move('/topic', '/Topic');\n        $this->session->save();\n\n        $this->addToAssertionCount(1);\n    }\n\n    public function testStoreTypes()\n    {\n        $rootNode = $this->session->getRootNode();\n        $node = $rootNode->addNode('testStoreTypes');\n\n        $data = [\n            ['string_1', 'string_1', PropertyType::STRING],\n            ['string_2', 'string_1', PropertyType::STRING],\n            ['long_1', '10', PropertyType::LONG],\n            ['long_2', '20', PropertyType::LONG],\n            ['decimal_1', '10.0', PropertyType::DECIMAL],\n            ['decimal_2', '20.0', PropertyType::DECIMAL],\n        ];\n\n        foreach ($data as $propertyData) {\n            $node->setProperty($propertyData[0], $propertyData[1], $propertyData[2]);\n        }\n\n        $this->session->save();\n        $this->session->refresh(false);\n\n        foreach ($data as $propertyData) {\n            list($propName) = $propertyData;\n            $this->assertTrue($node->hasProperty($propName), 'Node has property \"' . $propName .'\"');\n        }\n    }\n\n    public function provideOrder()\n    {\n        return [\n            [\n                [\n                    'one' => [\n                        'value' => 'AAA',\n                    ],\n                    'two' => [\n                        'value' => 'BBB',\n                    ],\n                    'three' => [\n                        'value' => 'CCC',\n                    ],\n                ],\n                'value DESC',\n                ['three', 'two', 'one'],\n            ],\n\n            // longs\n            [\n                [\n                    'one' => [\n                        'value' => 30,\n                    ],\n                    'two' => [\n                        'value' => 20,\n                    ],\n                    'three' => [\n                        'value' => 10,\n                    ],\n                ],\n                'value',\n                ['three', 'two', 'one'],\n            ],\n\n            // longs (ensure that values are not cast as strings)\n            [\n                [\n                    'one' => [\n                        'value' => 10,\n                    ],\n                    'two' => [\n                        'value' => 100,\n                    ],\n                    'three' => [\n                        'value' => 20,\n                    ],\n                ],\n                'value',\n                ['one', 'three', 'two'],\n            ],\n\n            // decimals\n            [\n                [\n                    'one' => [\n                        'value' => 10.01,\n                    ],\n                    'two' => [\n                        'value' => 0.01,\n                    ],\n                    'three' => [\n                        'value' => 5.05,\n                    ],\n                ],\n                'value',\n                ['two', 'three', 'one'],\n            ],\n\n            // mixed\n            [\n                [\n                    'one' => [\n                        'title' => 'AAA',\n                        'value' => 10.01,\n                    ],\n                    'two' => [\n                        'title' => 'AAA',\n                        'value' => 0.01,\n                    ],\n                    'three' => [\n                        'title' => 'CCC',\n                        'value' => 5.05,\n                    ],\n                    'four' => [\n                        'title' => 'BBB',\n                        'value' => 5.05,\n                    ],\n                ],\n                'title, value ASC',\n                ['two', 'one', 'four', 'three'],\n            ],\n        ];\n    }\n\n    /**\n     * @dataProvider provideOrder\n     */\n    public function testOrder($nodes, $orderBy, $expectedOrder)\n    {\n        $rootNode = $this->session->getNode('/');\n\n        foreach ($nodes as $nodeName => $nodeProperties) {\n            $node = $rootNode->addNode($nodeName);\n            foreach ($nodeProperties as $name => $value) {\n                $node->setProperty($name, $value);\n            }\n        }\n\n        $this->session->save();\n\n        $qm = $this->session->getWorkspace()->getQueryManager();\n        $query = $qm->createQuery('SELECT * FROM [nt:unstructured] WHERE value IS NOT NULL ORDER BY ' . $orderBy, QueryInterface::JCR_SQL2);\n        $result = $query->execute();\n\n        $rows = $result->getRows();\n        $this->assertGreaterThan(0, count($rows));\n\n        foreach ($rows as $index => $row) {\n            $path = $row->getNode()->getPath();\n            $name = PathHelper::getNodeName($path);\n\n            $expectedName = $expectedOrder[$index];\n            $this->assertEquals($expectedName, $name);\n        }\n    }\n\n    public function testCopy()\n    {\n        $rootNode = $this->session->getNode('/');\n        $child1 = $rootNode->addNode('child1');\n        $child1->setProperty('string', 'Hello');\n        $child1->setProperty('number', 1234);\n\n        $this->session->save();\n\n        $this->session->getWorkspace()->copy('/child1', '/child2');\n\n        $stmt = $this->conn->query(\"SELECT * FROM phpcr_nodes WHERE path = '/child1' OR path = '/child2'\");\n        $child1 = $stmt->fetch();\n        $child2 = $stmt->fetch();\n\n        $this->assertNotNull($child1);\n        $this->assertNotNull($child2);\n\n        $this->assertEquals($child1['props'], $child2['props']);\n        $this->assertEquals($child1['numerical_props'], $child2['numerical_props']);\n    }\n\n    public function testCopySiblingWithSamePrefix()\n    {\n        $rootNode = $this->session->getNode('/');\n        $child1 = $rootNode->addNode('child1');\n        $child1->setProperty('string', 'Hello');\n        $child1->setProperty('number', 1234);\n        $child2 = $rootNode->addNode('child1-2');\n        $child2->setProperty('string', 'Hello');\n        $child2->setProperty('number', 1234);\n\n        $this->session->save();\n\n        $this->session->getWorkspace()->copy('/child1', '/child2');\n\n        $stmt = $this->conn->query(\"SELECT * FROM phpcr_nodes WHERE path LIKE '/child%'\");\n        $children = $stmt->fetchAll();\n\n        $this->assertCount(3, $children);\n\n        $paths = array_map(\n            function ($child) {\n                return $child['path'];\n            },\n            $children\n        );\n\n        $this->assertContains('/child1', $paths);\n        $this->assertContains('/child2', $paths);\n        $this->assertContains('/child1-2', $paths);\n    }\n\n    /**\n     * The date value should not change when saving.\n     */\n    public function testDate()\n    {\n        $rootNode = $this->session->getNode('/');\n        $child1 = $rootNode->addNode('child1');\n        $date = new DateTime();\n        $before = $date->format('c');\n        $child1->setProperty('date', $date);\n        $this->session->save();\n        $after = $date->format('c');\n\n        $this->assertEquals($before, $after);\n    }\n\n    public function testNestedJoinForDifferentDocumentTypes()\n    {\n        $ntm = $this->session->getWorkspace()->getNodeTypeManager();\n        $template = $ntm->createNodeTypeTemplate();\n        $template->setName('test');\n        $template->setDeclaredSuperTypeNames(['nt:unstructured']);\n        $ntm->registerNodeType($template, true);\n\n        $root = $this->session->getNode('/');\n        $documentNode = $root->addNode('document', 'test');\n        $category = $root->addNode('category');\n        $category->addMixin('mix:referenceable');\n        $this->session->save();\n        $category = $this->session->getNode('/category');\n        $documentChild = $documentNode->addNode('document_child', 'nt:unstructured');\n        $documentChild->setProperty('title', 'someChild');\n        $documentChild->setProperty('locale', 'en');\n        $category->setProperty('title', 'someCategory');\n        $documentNode->setProperty('category', $category->getProperty('jcr:uuid'), 'WeakReference');\n        $this->session->save();\n\n\n\n        $qm = $this->session->getWorkspace()->getQueryManager();\n        $qom = $qm->getQOMFactory();\n        $documentSelector = $qom->selector('d', 'test');\n        $categorySelector = $qom->selector('c', 'nt:unstructured');\n        $documentChildSelector = $qom->selector('dt', 'nt:base');\n        $join = $qom->join($documentSelector, $categorySelector, $qom::JCR_JOIN_TYPE_INNER, $qom->equiJoinCondition(\n            'd',\n            'category',\n            'c',\n            'jcr:uuid'\n        ));\n        $childTitleProp = $qom->propertyValue('dt', 'title');\n        $childTitleVal = $qom->literal($documentChild->getProperty('title')->getValue());\n        $titleConstraint = $qom->comparison($childTitleProp, $qom::JCR_OPERATOR_EQUAL_TO, $childTitleVal);\n\n        $from = $qom->join($join, $documentChildSelector, $qom::JCR_JOIN_TYPE_INNER, $qom->childNodeJoinCondition(\n            'dt',\n            'd'\n        ));\n        $localeConstraint = $qom->comparison(\n            $qom->propertyValue('dt', 'locale'),\n            $qom::JCR_OPERATOR_EQUAL_TO,\n            $qom->literal($documentChild->getProperty('locale')->getValue())\n        );\n        $where = $qom->andConstraint($titleConstraint, $localeConstraint);\n\n        $queryObjectModel = $qom->createQuery($from, $where);\n        $result = $queryObjectModel->execute();\n\n        $this->assertCount(1, $result);\n    }\n\n    public function testMultiJoiningReferencedDocuments()\n    {\n        $ntm = $this->session->getWorkspace()->getNodeTypeManager();\n        $template = $ntm->createNodeTypeTemplate();\n        $template->setName('test');\n        $template->setDeclaredSuperTypeNames(['nt:unstructured']);\n        $ntm->registerNodeType($template, true);\n\n        $root = $this->session->getNode('/');\n        $documentNode = $root->addNode('document', 'test');\n\n        $category = $root->addNode('category');\n        $category->addMixin('mix:referenceable');\n\n        $group = $root->addNode('group');\n        $group->addMixin('mix:referenceable');\n\n        $this->session->save();\n        $category = $this->session->getNode('/category');\n        $category->setProperty('title', 'someCategory');\n        $group = $this->session->getNode('/group');\n        $group->setProperty('title', 'someGroup');\n\n        $documentNode->setProperty('category', $category->getProperty('jcr:uuid'), 'WeakReference');\n        $documentNode->setProperty('group', $group->getProperty('jcr:uuid'), 'WeakReference');\n        $this->session->save();\n\n        $qm = $this->session->getWorkspace()->getQueryManager();\n        $qom = $qm->getQOMFactory();\n        $documentSelector = $qom->selector('d', 'test');\n        $categorySelector = $qom->selector('c', 'nt:unstructured');\n        $groupSelector = $qom->selector('g', 'nt:unstructured');\n        $join = $qom->join($documentSelector, $categorySelector, $qom::JCR_JOIN_TYPE_INNER, $qom->equiJoinCondition(\n            'd',\n            'category',\n            'c',\n            'jcr:uuid'\n        ));\n\n\n        $from = $qom->join($join, $groupSelector, $qom::JCR_JOIN_TYPE_INNER, $qom->equiJoinCondition(\n            'd',\n            'group',\n            'g',\n            'jcr:uuid'\n        ));\n\n        $queryObjectModel = $qom->createQuery($from);\n        $result = $queryObjectModel->execute();\n\n        $this->assertCount(1, $result);\n    }\n}\n"], "fixing_code": ["<?php\n\nnamespace Jackalope\\Transport\\DoctrineDBAL\\Query;\n\nuse BadMethodCallException;\nuse DateTime;\nuse DateTimeZone;\nuse Doctrine\\DBAL\\Platforms\\MySQLPlatform;\nuse Doctrine\\DBAL\\Platforms\\PostgreSqlPlatform;\nuse Doctrine\\DBAL\\Platforms\\PostgreSQL94Platform;\nuse Doctrine\\DBAL\\Schema\\Schema;\nuse Jackalope\\NotImplementedException;\nuse Jackalope\\Query\\QOM\\PropertyValue;\nuse Jackalope\\Query\\QOM\\QueryObjectModel;\nuse Jackalope\\Transport\\DoctrineDBAL\\RepositorySchema;\nuse Jackalope\\Transport\\DoctrineDBAL\\Util\\Xpath;\nuse PHPCR\\NamespaceException;\nuse PHPCR\\NodeType\\NodeTypeInterface;\nuse PHPCR\\NodeType\\NodeTypeManagerInterface;\nuse PHPCR\\Query\\InvalidQueryException;\nuse PHPCR\\Query\\QOM;\nuse Doctrine\\DBAL\\Connection;\nuse Doctrine\\DBAL\\Platforms\\AbstractPlatform;\nuse Doctrine\\DBAL\\Platforms\\SqlitePlatform;\n\n/**\n * Converts QOM to SQL Statements for the Doctrine DBAL database backend.\n *\n * @license http://www.apache.org/licenses Apache License Version 2.0, January 2004\n * @license http://opensource.org/licenses/MIT MIT License\n */\nclass QOMWalker\n{\n    /**\n     * @var NodeTypeManagerInterface\n     */\n    private $nodeTypeManager;\n\n    /**\n     * @var array\n     */\n    private $alias = [];\n\n    /**\n     * @var QOM\\SelectorInterface\n     */\n    private $source;\n\n    /**\n     * @var Connection\n     */\n    private $conn;\n\n    /**\n     * @var AbstractPlatform\n     */\n    private $platform;\n\n    /**\n     * @var array\n     */\n    private $namespaces;\n\n    /**\n     * @var Schema\n     */\n    private $schema;\n\n    /**\n     * @param NodeTypeManagerInterface $manager\n     * @param Connection               $conn\n     * @param array                    $namespaces\n     */\n    public function __construct(NodeTypeManagerInterface $manager, Connection $conn, array $namespaces = [])\n    {\n        $this->conn = $conn;\n        $this->nodeTypeManager = $manager;\n        $this->platform = $conn->getDatabasePlatform();\n        $this->namespaces = $namespaces;\n        $this->schema = new RepositorySchema([], $this->conn);\n    }\n\n    /**\n     * Generate a table alias\n     *\n     * @param string $selectorName\n     *\n     * @return string\n     */\n    private function getTableAlias($selectorName)\n    {\n        $selectorAlias = $this->getSelectorAlias($selectorName);\n\n        if (!isset($this->alias[$selectorAlias])) {\n            $this->alias[$selectorAlias] = 'n' . count($this->alias);\n        }\n\n        return $this->alias[$selectorAlias];\n    }\n\n    /**\n     * @param string $selectorName\n     *\n     * @return string\n     */\n    private function getSelectorAlias($selectorName)\n    {\n        if (null === $selectorName) {\n            if (count($this->alias)) { // We have aliases, use the first\n                $selectorAlias = array_search('n0', $this->alias);\n            } else { // Currently no aliases, use an empty string as index\n                $selectorAlias = '';\n            }\n        } elseif (strpos($selectorName, '.') === false) {\n            $selectorAlias = $selectorName;\n        } else {\n            $parts = explode('.', $selectorName);\n            $selectorAlias = reset($parts);\n        }\n\n        if (strpos($selectorAlias, '[') === 0) {\n            $selectorAlias = substr($selectorAlias, 1, -1);\n        }\n\n        if ($this->source && $this->source->getNodeTypeName() === $selectorAlias) {\n            $selectorAlias = '';\n        }\n\n        return $selectorAlias;\n    }\n\n    /**\n     * @param QueryObjectModel $qom\n     *\n     * @return string\n     */\n    public function walkQOMQuery(QueryObjectModel $qom)\n    {\n        $source = $qom->getSource();\n        $selectors = $this->validateSource($source);\n\n        $sourceSql = ' ' . $this->walkSource($source);\n        $constraintSql = '';\n        if ($constraint = $qom->getConstraint()) {\n            $constraintSql = ' AND ' . $this->walkConstraint($constraint);\n        }\n\n        $orderingSql = '';\n        if ($orderings = $qom->getOrderings()) {\n            $orderingSql = ' ' . $this->walkOrderings($orderings);\n        }\n\n        $sql = 'SELECT ' . $this->getColumns($qom);\n        $sql .= $sourceSql;\n        $sql .= $constraintSql;\n        $sql .= $orderingSql;\n\n        $limit = $qom->getLimit();\n        $offset = $qom->getOffset();\n\n        if (null !== $offset && null === $limit\n            && ($this->platform instanceof MySQLPlatform || $this->platform instanceof SqlitePlatform)\n        ) {\n            $limit = PHP_INT_MAX;\n        }\n        $sql = $this->platform->modifyLimitQuery($sql, $limit, $offset);\n\n        return [$selectors, $this->alias, $sql];\n    }\n\n    /**\n     * @return string\n     */\n    public function getColumns(QueryObjectModel $qom)\n    {\n        // TODO we should actually build Xpath statements for each column we actually need in the result and not fetch all 'props'\n        $sqlColumns = ['path', 'identifier', 'props'];\n\n        if (count($this->alias)) {\n            $aliasSql = [];\n            foreach ($this->alias as $alias) {\n                foreach ($sqlColumns as $sqlColumn) {\n                    $aliasSql[] = sprintf('%s.%s AS %s_%s', $alias, $sqlColumn, $alias, $sqlColumn);\n                }\n            }\n\n            return implode(', ', $aliasSql);\n        }\n\n        return '*';\n    }\n\n    /**\n     * Validates the nodeTypes in given source\n     *\n     * @param QOM\\SourceInterface $source\n     *\n     * @return QOM\\SelectorInterface[]\n     *\n     * @throws InvalidQueryException\n     */\n    protected function validateSource(QOM\\SourceInterface $source)\n    {\n        if ($source instanceof QOM\\SelectorInterface) {\n            $selectors = [$source];\n            $this->validateSelectorSource($source);\n        } elseif ($source instanceof QOM\\JoinInterface) {\n            $selectors = $this->validateJoinSource($source);\n        } else {\n            $selectors = [];\n        }\n\n        return $selectors;\n    }\n\n    /**\n     * @param QOM\\SelectorInterface $source\n     *\n     * @throws InvalidQueryException\n     */\n    protected function validateSelectorSource(QOM\\SelectorInterface $source)\n    {\n        $nodeType = $source->getNodeTypeName();\n\n        if (!$this->nodeTypeManager->hasNodeType($nodeType)) {\n            $msg = 'Selected node type does not exist: ' . $nodeType;\n            if ($alias = $source->getSelectorName()) {\n                $msg .= ' AS ' . $alias;\n            }\n\n            throw new InvalidQueryException($msg);\n        }\n    }\n\n    /**\n     * @param QOM\\JoinInterface $source\n     *\n     * @return QOM\\SelectorInterface[]\n     *\n     * @throws InvalidQueryException\n     */\n    protected function validateJoinSource(QOM\\JoinInterface $source)\n    {\n        $left = $source->getLeft();\n        $right = $source->getRight();\n\n        if ($left) {\n            $selectors = $this->validateSource($left);\n        } else {\n            $selectors = [];\n        }\n\n        if ($right) {\n            // Ensure that the primary selector is first\n            if (QOM\\QueryObjectModelConstantsInterface::JCR_JOIN_TYPE_RIGHT_OUTER === $source->getJoinType()) {\n                $selectors = array_merge($this->validateSource($right), $selectors);\n            } else {\n                $selectors = array_merge($selectors, $this->validateSource($right));\n            }\n        }\n\n        return $selectors;\n    }\n\n    /**\n     * @param QOM\\SourceInterface $source\n     *\n     * @return string\n     *\n     * @throws NotImplementedException\n     */\n    public function walkSource(QOM\\SourceInterface $source)\n    {\n        if ($source instanceof QOM\\SelectorInterface) {\n            return $this->walkSelectorSource($source);\n        }\n\n        if ($source instanceof QOM\\JoinInterface) {\n            return $this->walkJoinSource($source);\n        }\n\n        throw new NotImplementedException(sprintf(\"The source class '%s' is not supported\", get_class($source)));\n    }\n\n    /**\n     * @param QOM\\SelectorInterface $source\n     *\n     * @return string\n     */\n    public function walkSelectorSource(QOM\\SelectorInterface $source)\n    {\n        $this->source = $source;\n        $alias = $this->getTableAlias($source->getSelectorName());\n        $nodeTypeClause = $this->sqlNodeTypeClause($alias, $source);\n        $sql = \"FROM phpcr_nodes $alias WHERE $alias.workspace_name = ? AND $nodeTypeClause\";\n\n        return $sql;\n    }\n\n    /**\n     * @param QOM\\JoinConditionInterface $right\n     *\n     * @return string the alias on the right side of a join\n     *\n     * @throws BadMethodCallException if the provided JoinCondition has no valid way of getting the right selector\n     */\n    private function getRightJoinSelector(QOM\\JoinConditionInterface $right)\n    {\n        if ($right instanceof QOM\\ChildNodeJoinConditionInterface) {\n            return $right->getParentSelectorName();\n        } elseif ($right instanceof QOM\\DescendantNodeJoinConditionInterface) {\n            return $right->getAncestorSelectorName();\n        } elseif ($right instanceof QOM\\SameNodeJoinConditionInterface || $right instanceof QOM\\EquiJoinConditionInterface) {\n            return $right->getSelector2Name();\n        }\n        throw new BadMethodCallException('Supplied join type should implement getSelector2Name() or be an instance of ChildNodeJoinConditionInterface or DescendantNodeJoinConditionInterface');\n    }\n\n\n    /**\n     * @param QOM\\JoinConditionInterface $right\n     *\n     * @return string the alias on the left side of a join\n     *\n     * @throws BadMethodCallException if the provided JoinCondition has no valid way of getting the left selector\n     */\n    private function getLeftJoinSelector(QOM\\JoinConditionInterface $left)\n    {\n        if ($left instanceof QOM\\ChildNodeJoinConditionInterface) {\n            return $left->getChildSelectorName();\n        } elseif ($left instanceof QOM\\DescendantNodeJoinConditionInterface) {\n            return $left->getAncestorSelectorName();\n        } elseif ($left instanceof QOM\\SameNodeJoinConditionInterface || $left instanceof QOM\\EquiJoinConditionInterface) {\n            return $left->getSelector1Name();\n        }\n        throw new BadMethodCallException('Supplied join type should implement getSelector2Name() or be an instance of ChildNodeJoinConditionInterface or DescendantNodeJoinConditionInterface');\n    }\n\n    /**\n     * find the most left join in a tree\n     *\n     * @param QOM\\JoinInterface $source\n     *\n     * @return QOM\\JoinInterface\n     */\n    private function getLeftMostJoin(QOM\\JoinInterface $source)\n    {\n        if ($source->getLeft() instanceof QOM\\JoinInterface) {\n            return $this->getLeftMostJoin($source->getLeft());\n        }\n        return $source;\n    }\n\n    /**\n     * @param QOM\\JoinInterface $source\n     * @param boolean $root whether the method call is recursed for nested joins. If true, it will add a WHERE clause\n     *        that checks the workspace_name and type\n     *\n     * @return string\n     *\n     * @throws NotImplementedException if the right side of the join consists of another join\n     */\n    public function walkJoinSource(QOM\\JoinInterface $source, $root = true)\n    {\n        $this->source = $left = $source->getLeft(); // The $left variable is used for storing the leftmost selector\n\n        if (!$source->getRight() instanceof QOM\\SelectorInterface) {\n            throw new NotImplementedException('The right side of the join should not consist of another join');\n        }\n\n        if ($source->getLeft() instanceof QOM\\SelectorInterface) {\n            $leftAlias = $this->getTableAlias($source->getLeft()->getSelectorName());\n            $this->getTableAlias($source->getLeft()->getSelectorName());\n            $sql = \"FROM phpcr_nodes $leftAlias \";\n        } else {\n            $sql = $this->walkJoinSource($left, false) . ' '; // One step left, until we're at the selector\n            $leftMostJoin = $this->getLeftMostJoin($source);\n            $leftAlias = $this->getTableAlias(\n                $this->getLeftJoinSelector($leftMostJoin->getJoinCondition())\n            );\n            $left = $leftMostJoin->getLeft();\n        }\n        $rightAlias = $this->getTableAlias($source->getRight()->getSelectorName());\n        $nodeTypeClause = $this->sqlNodeTypeClause($rightAlias, $source->getRight());\n\n        switch ($source->getJoinType()) {\n            case QOM\\QueryObjectModelConstantsInterface::JCR_JOIN_TYPE_INNER:\n                $sql .= sprintf(\"INNER JOIN phpcr_nodes %s \", $rightAlias);\n                break;\n            case QOM\\QueryObjectModelConstantsInterface::JCR_JOIN_TYPE_LEFT_OUTER:\n                $sql .= sprintf(\"LEFT JOIN phpcr_nodes %s \", $rightAlias);\n                break;\n            case QOM\\QueryObjectModelConstantsInterface::JCR_JOIN_TYPE_RIGHT_OUTER:\n                $sql .= sprintf(\"RIGHT JOIN phpcr_nodes %s \", $rightAlias);\n                break;\n        }\n\n        $sql .= sprintf(\"ON ( %s.workspace_name = %s.workspace_name AND %s \", $leftAlias, $rightAlias, $nodeTypeClause);\n        $sql .= 'AND ' . $this->walkJoinCondition($source->getLeft(), $source->getRight(), $source->getJoinCondition()) . ' ';\n        $sql .= ') '; // close on-clause\n\n\n        if ($root) { // The method call is not recursed when $root is true, so we can add a WHERE clause\n            // TODO: revise this part for alternatives\n            $sql .= sprintf(\"WHERE %s.workspace_name = ? AND %s.type IN ('%s'\", $leftAlias, $leftAlias, $left->getNodeTypeName());\n            $subTypes = $this->nodeTypeManager->getSubtypes($left->getNodeTypeName());\n            foreach ($subTypes as $subType) {\n                /* @var $subType NodeTypeInterface */\n                $sql .= sprintf(\", '%s'\", $subType->getName());\n            }\n            $sql .= ')';\n        }\n\n        return $sql;\n    }\n\n    /**\n     * @param QOM\\SelectorInterface|QOM\\JoinInterface $left\n     * @param QOM\\SelectorInterface $right\n     * @param QOM\\JoinConditionInterface $condition\n     *\n     * @return string\n     *\n     * @throws NotImplementedException if a SameNodeJoinCondtion is used.\n     */\n    public function walkJoinCondition($left, QOM\\SelectorInterface $right, QOM\\JoinConditionInterface $condition)\n    {\n        if ($condition instanceof QOM\\ChildNodeJoinConditionInterface) {\n            return $this->walkChildNodeJoinCondition($condition);\n        }\n        if ($condition instanceof QOM\\DescendantNodeJoinConditionInterface) {\n            return $this->walkDescendantNodeJoinCondition($condition);\n        }\n        if ($condition instanceof QOM\\EquiJoinConditionInterface) {\n            if ($left instanceof QOM\\SelectorInterface) {\n                $selectorName = $left->getSelectorName();\n            } else {\n                $selectorName = $this->getLeftJoinSelector($this->getLeftMostJoin($left)->getJoinCondition());\n            }\n            return $this->walkEquiJoinCondition($selectorName, $right->getSelectorName(), $condition);\n        }\n        if ($condition instanceof QOM\\SameNodeJoinConditionInterface) {\n            throw new NotImplementedException('SameNodeJoinCondtion');\n        }\n    }\n\n    /**\n     * @param QOM\\ChildNodeJoinConditionInterface $condition\n     *\n     * @return string\n     */\n    public function walkChildNodeJoinCondition(QOM\\ChildNodeJoinConditionInterface $condition)\n    {\n        $rightAlias = $this->getTableAlias($condition->getChildSelectorName());\n        $leftAlias = $this->getTableAlias($condition->getParentSelectorName());\n        $concatExpression = $this->platform->getConcatExpression(\"$leftAlias.path\", \"'/%'\");\n\n        return sprintf(\"(%s.path LIKE %s AND %s.depth = %s.depth + 1) \", $rightAlias, $concatExpression, $rightAlias, $leftAlias);\n    }\n\n    /**\n     * @param QOM\\DescendantNodeJoinConditionInterface $condition\n     *\n     * @return string\n     */\n    public function walkDescendantNodeJoinCondition(QOM\\DescendantNodeJoinConditionInterface $condition)\n    {\n        $rightAlias = $this->getTableAlias($condition->getDescendantSelectorName());\n        $leftAlias = $this->getTableAlias($condition->getAncestorSelectorName());\n        $concatExpression = $this->platform->getConcatExpression(\"$leftAlias.path\", \"'/%'\");\n\n        return sprintf(\"%s.path LIKE %s \", $rightAlias, $concatExpression);\n    }\n\n    /**\n     * @param QOM\\EquiJoinConditionInterface $condition\n     *\n     * @return string\n     */\n    public function walkEquiJoinCondition($leftSelectorName, $rightSelectorName, QOM\\EquiJoinConditionInterface $condition)\n    {\n        return $this->walkOperand(new PropertyValue($leftSelectorName, $condition->getProperty1Name())) . ' ' .\n               $this->walkOperator(QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_EQUAL_TO) . ' ' .\n               $this->walkOperand(new PropertyValue($rightSelectorName, $condition->getProperty2Name()));\n    }\n\n    /**\n     * @param \\PHPCR\\Query\\QOM\\ConstraintInterface $constraint\n     *\n     * @return string\n     *\n     * @throws InvalidQueryException\n     */\n    public function walkConstraint(QOM\\ConstraintInterface $constraint)\n    {\n        if ($constraint instanceof QOM\\AndInterface) {\n            return $this->walkAndConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\OrInterface) {\n            return $this->walkOrConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\NotInterface) {\n            return $this->walkNotConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\ComparisonInterface) {\n            return $this->walkComparisonConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\DescendantNodeInterface) {\n            return $this->walkDescendantNodeConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\ChildNodeInterface) {\n            return $this->walkChildNodeConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\PropertyExistenceInterface) {\n            return $this->walkPropertyExistenceConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\SameNodeInterface) {\n            return $this->walkSameNodeConstraint($constraint);\n        }\n        if ($constraint instanceof QOM\\FullTextSearchInterface) {\n            return $this->walkFullTextSearchConstraint($constraint);\n        }\n\n        throw new InvalidQueryException(sprintf(\"Constraint %s not yet supported.\", get_class($constraint)));\n    }\n\n    /**\n     * @param QOM\\SameNodeInterface $constraint\n     *\n     * @return string\n     */\n    public function walkSameNodeConstraint(QOM\\SameNodeInterface $constraint)\n    {\n        return sprintf(\n            \"%s.path = '%s'\",\n            $this->getTableAlias($constraint->getSelectorName()),\n            $constraint->getPath()\n        );\n    }\n\n    /**\n     * @param QOM\\FullTextSearchInterface $constraint\n     *\n     * @return string\n     */\n    public function walkFullTextSearchConstraint(QOM\\FullTextSearchInterface $constraint)\n    {\n        return sprintf('%s LIKE %s',\n            $this->sqlXpathExtractValue($this->getTableAlias($constraint->getSelectorName()), $constraint->getPropertyName()),\n            $this->conn->quote('%'.$constraint->getFullTextSearchExpression().'%')\n        );\n    }\n\n    /**\n     * @param QOM\\PropertyExistenceInterface $constraint\n     *\n     * @return string\n     */\n    public function walkPropertyExistenceConstraint(QOM\\PropertyExistenceInterface $constraint)\n    {\n        return $this->sqlXpathValueExists($this->getTableAlias($constraint->getSelectorName()), $constraint->getPropertyName());\n    }\n\n    /**\n     * @param QOM\\DescendantNodeInterface $constraint\n     *\n     * @return string\n     */\n    public function walkDescendantNodeConstraint(QOM\\DescendantNodeInterface $constraint)\n    {\n        $ancestorPath = $constraint->getAncestorPath();\n        if ('/' === $ancestorPath) {\n            $ancestorPath = '';\n        } elseif (substr($ancestorPath, -1) === '/') {\n            throw new InvalidQueryException(\"Trailing slash in $ancestorPath\");\n        }\n\n        return sprintf(\n            \"%s.path LIKE '%s/%%'\",\n            $this->getTableAlias($constraint->getSelectorName()),\n            addcslashes($ancestorPath, \"'\")\n        );\n    }\n\n    /**\n     * @param QOM\\ChildNodeInterface $constraint\n     *\n     * @return string\n     */\n    public function walkChildNodeConstraint(QOM\\ChildNodeInterface $constraint)\n    {\n        return sprintf(\n            \"%s.parent = '%s'\",\n            $this->getTableAlias($constraint->getSelectorName()),\n            addcslashes($constraint->getParentPath(), \"'\")\n        );\n    }\n\n    /**\n     * @param QOM\\AndInterface $constraint\n     *\n     * @return string\n     */\n    public function walkAndConstraint(QOM\\AndInterface $constraint)\n    {\n        return sprintf(\n            \"(%s AND %s)\",\n            $this->walkConstraint($constraint->getConstraint1()),\n            $this->walkConstraint($constraint->getConstraint2())\n        );\n    }\n\n    /**\n     * @param QOM\\OrInterface $constraint\n     *\n     * @return string\n     */\n    public function walkOrConstraint(QOM\\OrInterface $constraint)\n    {\n        return sprintf(\n            \"(%s OR %s)\",\n            $this->walkConstraint($constraint->getConstraint1()),\n            $this->walkConstraint($constraint->getConstraint2())\n        );\n    }\n\n    /**\n     * @param QOM\\NotInterface $constraint\n     *\n     * @return string\n     */\n    public function walkNotConstraint(QOM\\NotInterface $constraint)\n    {\n        return sprintf(\n            \"NOT (%s)\",\n            $this->walkConstraint($constraint->getConstraint())\n        );\n    }\n\n    /**\n     * This method figures out the best way to do a comparison\n     * When we need to compare a property with a literal value,\n     * we need to be aware of the multivalued properties, we then require\n     * a different xpath statement then with other comparisons\n     *\n     * @param QOM\\ComparisonInterface $constraint\n     *\n     * @return string\n     */\n    public function walkComparisonConstraint(QOM\\ComparisonInterface $constraint)\n    {\n        $operator = $this->walkOperator($constraint->getOperator());\n\n        $operator1 = $constraint->getOperand1();\n        $operator2 = $constraint->getOperand2();\n\n        // Check if we have a property and a literal value (in random order)\n        if (\n            ($operator1 instanceof QOM\\PropertyValueInterface\n                && $operator2 instanceof QOM\\LiteralInterface)\n            || ($operator1 instanceof QOM\\LiteralInterface\n                && $operator2 instanceof QOM\\PropertyValueInterface)\n            || ($operator1 instanceof QOM\\NodeNameInterface\n                && $operator2 instanceof QOM\\LiteralInterface)\n            || ($operator1 instanceof QOM\\LiteralInterface\n                && $operator2 instanceof QOM\\NodeNameInterface)\n        ) {\n            // Check whether the left is the literal, at this point the other always is the literal/nodename operand\n            if ($operator1 instanceof QOM\\LiteralInterface) {\n                $operand = $operator2;\n                $literalOperand = $operator1;\n            } else {\n                $literalOperand = $operator2;\n                $operand = $operator1;\n            }\n\n            if (is_string($literalOperand->getLiteralValue()) && '=' !== $operator && '!=' !== $operator) {\n                return\n                    $this->walkOperand($operator1) . ' ' .\n                    $operator . ' ' .\n                    $this->walkOperand($operator2);\n            }\n\n            if ($operand instanceof QOM\\NodeNameInterface) {\n                $selectorName = $operand->getSelectorName();\n                $alias = $this->getTableAlias($selectorName);\n\n                $literal = $literalOperand->getLiteralValue();\n                if (false !== strpos($literal, ':')) {\n                    $parts = explode(':', $literal);\n                    if (!isset($this->namespaces[$parts[0]])) {\n                        throw new NamespaceException('The namespace ' . $parts[0] . ' was not registered.');\n                    }\n\n                    $parts[0] = $this->namespaces[$parts[0]];\n                    $literal = implode(':', $parts);\n                }\n\n                return sprintf(\n                    '%s %s %s',\n                    $this->platform->getConcatExpression(\n                        sprintf(\"%s.namespace\", $alias),\n                        sprintf(\"(CASE %s.namespace WHEN '' THEN '' ELSE ':' END)\", $alias),\n                        sprintf(\"%s.local_name\", $alias)\n                    ),\n                    $operator,\n                    $this->conn->quote($literal)\n                ) ;\n            }\n\n            if ('jcr:path' !== $operand->getPropertyName() && 'jcr:uuid' !== $operand->getPropertyName()) {\n                if (is_int($literalOperand->getLiteralValue()) || is_float($literalOperand->getLiteralValue())) {\n                    return $this->walkNumComparisonConstraint($operand, $literalOperand, $operator);\n                }\n                if (is_bool($literalOperand->getLiteralValue())) {\n                    return $this->walkBoolComparisonConstraint($operand, $literalOperand, $operator);\n                }\n\n                return $this->walkTextComparisonConstraint($operand, $literalOperand, $operator);\n            }\n        }\n\n        return sprintf(\n            '%s %s %s',\n            $this->walkOperand($operator1),\n            $operator,\n            $this->walkOperand($operator2)\n        );\n    }\n\n    /**\n     * @param QOM\\PropertyValueInterface $propertyOperand\n     * @param QOM\\LiteralInterface $literalOperand\n     * @param string $operator\n     *\n     * @return string\n     */\n    public function walkTextComparisonConstraint(QOM\\PropertyValueInterface $propertyOperand, QOM\\LiteralInterface $literalOperand, $operator)\n    {\n        $alias = $this->getTableAlias($propertyOperand->getSelectorName() . '.' . $propertyOperand->getPropertyName());\n        $property = $propertyOperand->getPropertyName();\n\n        return $this->sqlXpathComparePropertyValue($alias, $property, $this->getLiteralValue($literalOperand), $operator);\n    }\n\n    public function walkBoolComparisonConstraint(QOM\\PropertyValueInterface $propertyOperand, QOM\\LiteralInterface $literalOperand, $operator)\n    {\n        $value = true === $literalOperand->getLiteralValue() ? '1' : '0';\n\n        return $this->walkOperand($propertyOperand) . ' ' . $operator . ' ' . $this->conn->quote($value);\n    }\n\n    public function walkNumComparisonConstraint(QOM\\PropertyValueInterface $propertyOperand, QOM\\LiteralInterface $literalOperand, $operator)\n    {\n        $alias = $this->getTableAlias($propertyOperand->getSelectorName() . '.' . $propertyOperand->getPropertyName());\n        $property = $propertyOperand->getPropertyName();\n\n\n        if ($this->platform instanceof MySQLPlatform && '=' === $operator) {\n            return sprintf(\n                '0 != FIND_IN_SET(\"%s\", REPLACE(EXTRACTVALUE(%s.props, \\'//sv:property[@sv:name=%s]/sv:value\\'), \" \", \",\"))',\n                $literalOperand->getLiteralValue(),\n                $alias,\n                Xpath::escape($property)\n            );\n        }\n\n        if ('=' === $operator) {\n            return $this->sqlXpathComparePropertyValue($alias, $property, $literalOperand->getLiteralValue(), $operator);\n        }\n\n        return sprintf(\n            '%s %s %s',\n            $this->sqlXpathExtractNumValue($alias, $property),\n            $operator,\n            $literalOperand->getLiteralValue()\n        );\n    }\n\n    /**\n     * @param string $operator\n     *\n     * @return string\n     */\n    public function walkOperator($operator)\n    {\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_EQUAL_TO) {\n            return '=';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_GREATER_THAN) {\n            return '>';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_GREATER_THAN_OR_EQUAL_TO) {\n            return '>=';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_LESS_THAN) {\n            return '<';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_LESS_THAN_OR_EQUAL_TO) {\n            return '<=';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_NOT_EQUAL_TO) {\n            return '!=';\n        }\n        if ($operator === QOM\\QueryObjectModelConstantsInterface::JCR_OPERATOR_LIKE) {\n            return 'LIKE';\n        }\n\n        return $operator; // no-op for simplicity, not standard conform (but using the constants is a pain)\n    }\n\n    /**\n     * @param QOM\\OperandInterface $operand\n     *\n     * @return string\n     *\n     * @throws InvalidQueryException\n     */\n    public function walkOperand(QOM\\OperandInterface $operand)\n    {\n        if ($operand instanceof QOM\\NodeNameInterface) {\n            $selectorName = $operand->getSelectorName();\n            $alias = $this->getTableAlias($selectorName);\n\n            return $this->platform->getConcatExpression(\n                sprintf(\"%s.namespace\", $alias),\n                sprintf(\"(CASE %s.namespace WHEN '' THEN '' ELSE ':' END)\", $alias),\n                sprintf(\"%s.local_name\", $alias)\n            );\n        }\n\n        if ($operand instanceof QOM\\NodeLocalNameInterface) {\n            $selectorName = $operand->getSelectorName();\n            $alias = $this->getTableAlias($selectorName);\n\n            return sprintf(\"%s.local_name\", $alias);\n        }\n\n        if ($operand instanceof QOM\\LowerCaseInterface) {\n            return $this->platform->getLowerExpression($this->walkOperand($operand->getOperand()));\n        }\n\n        if ($operand instanceof QOM\\UpperCaseInterface) {\n            return $this->platform->getUpperExpression($this->walkOperand($operand->getOperand()));\n        }\n\n        if ($operand instanceof QOM\\LiteralInterface) {\n            return $this->conn->quote($this->getLiteralValue($operand));\n        }\n\n        if ($operand instanceof QOM\\PropertyValueInterface) {\n            $alias = $this->getTableAlias($operand->getSelectorName() . '.' . $operand->getPropertyName());\n            $property = $operand->getPropertyName();\n            if ($property === 'jcr:path') {\n                return sprintf(\"%s.path\", $alias);\n            }\n            if ($property === \"jcr:uuid\") {\n                return sprintf(\"%s.identifier\", $alias);\n            }\n\n            return $this->sqlXpathExtractValue($alias, $property);\n        }\n\n        if ($operand instanceof QOM\\LengthInterface) {\n            $alias = $this->getTableAlias($operand->getPropertyValue()->getSelectorName());\n            $property = $operand->getPropertyValue()->getPropertyName();\n\n            return $this->sqlXpathExtractValueAttribute($alias, $property, 'length');\n        }\n\n        throw new InvalidQueryException(sprintf(\"Dynamic operand %s not yet supported.\", get_class($operand)));\n    }\n\n    /**\n     * @param array $orderings\n     *\n     * @return string\n     */\n    public function walkOrderings(array $orderings)\n    {\n        $sql = '';\n        foreach ($orderings as $ordering) {\n            $sql .= empty($sql) ? 'ORDER BY ' : ', ';\n            $sql .= $this->walkOrdering($ordering);\n        }\n\n        return $sql;\n    }\n\n    /**\n     * @param QOM\\OrderingInterface $ordering\n     *\n     * @return string\n     */\n    public function walkOrdering(QOM\\OrderingInterface $ordering)\n    {\n        $direction = $ordering->getOrder();\n        if ($direction === QOM\\QueryObjectModelConstantsInterface::JCR_ORDER_ASCENDING) {\n            $direction = 'ASC';\n        } elseif ($direction === QOM\\QueryObjectModelConstantsInterface::JCR_ORDER_DESCENDING) {\n            $direction = 'DESC';\n        }\n\n        $sql = $this->walkOperand($ordering->getOperand());\n\n        if ($ordering->getOperand() instanceof QOM\\PropertyValueInterface) {\n            $operand = $ordering->getOperand();\n            $property = $ordering->getOperand()->getPropertyName();\n            if ($property !== 'jcr:path' && $property !== 'jcr:uuid') {\n                $alias = $this->getTableAlias($operand->getSelectorName() . '.' . $property);\n\n                $numericalSelector = $this->sqlXpathExtractValue($alias, $property, 'numerical_props');\n\n                $sql = sprintf(\n                    'CAST(%s AS DECIMAL) %s, %s',\n                    $numericalSelector,\n                    $direction,\n                    $sql\n                );\n            }\n        }\n\n        $sql .= ' ' .$direction;\n\n        return $sql;\n    }\n\n    /**\n     * @param QOM\\LiteralInterface $operand\n     *\n     * @return string\n     *\n     * @throws NamespaceException\n     */\n    private function getLiteralValue(QOM\\LiteralInterface $operand)\n    {\n        $value = $operand->getLiteralValue();\n\n        /**\n         * Normalize Dates to UTC\n         */\n        if ($value instanceof DateTime) {\n            $valueUTC = clone($value);\n            $valueUTC->setTimezone(new DateTimeZone('UTC'));\n            return $valueUTC->format('c');\n        }\n\n        return $value;\n    }\n\n    /**\n     * SQL to execute an XPATH expression checking if the property exist on the node with the given alias.\n     *\n     * @param string $alias\n     * @param string $property\n     *\n     * @return string\n     */\n    private function sqlXpathValueExists($alias, $property)\n    {\n        if ($this->platform instanceof MySQLPlatform) {\n            return sprintf(\"EXTRACTVALUE(%s.props, 'count(//sv:property[@sv:name=%s]/sv:value[1])') = 1\", $alias, Xpath::escape($property));\n        }\n\n        if ($this->platform instanceof PostgreSQL94Platform || $this->platform instanceof PostgreSqlPlatform) {\n            return sprintf(\"xpath_exists('//sv:property[@sv:name=%s]/sv:value[1]', CAST(%s.props AS xml), \".$this->sqlXpathPostgreSQLNamespaces().\") = 't'\", Xpath::escape($property), $alias);\n        }\n\n        if ($this->platform instanceof SqlitePlatform) {\n            return sprintf(\"EXTRACTVALUE(%s.props, 'count(//sv:property[@sv:name=%s]/sv:value[1])') = 1\", $alias, Xpath::escape($property));\n        }\n\n        throw new NotImplementedException(sprintf(\"Xpath evaluations cannot be executed with '%s' yet.\", $this->platform->getName()));\n    }\n\n    /**\n     * SQL to execute an XPATH expression extracting the property value on the node with the given alias.\n     *\n     * @param string $alias\n     * @param string $property\n     *\n     * @return string\n     */\n    private function sqlXpathExtractValue($alias, $property, $column = 'props')\n    {\n        if ($this->platform instanceof MySQLPlatform) {\n            return sprintf(\"EXTRACTVALUE(%s.%s, '//sv:property[@sv:name=%s]/sv:value[1]')\", $alias, $column, Xpath::escape($property));\n        }\n\n        if ($this->platform instanceof PostgreSQL94Platform || $this->platform instanceof PostgreSqlPlatform) {\n            return sprintf(\"(xpath('//sv:property[@sv:name=%s]/sv:value[1]/text()', CAST(%s.%s AS xml), %s))[1]::text\", Xpath::escape($property), $alias, $column, $this->sqlXpathPostgreSQLNamespaces());\n        }\n\n        if ($this->platform instanceof SqlitePlatform) {\n            return sprintf(\"EXTRACTVALUE(%s.%s, '//sv:property[@sv:name=%s]/sv:value[1]')\", $alias, $column, Xpath::escape($property));\n        }\n\n        throw new NotImplementedException(sprintf(\"Xpath evaluations cannot be executed with '%s' yet.\", $this->platform->getName()));\n    }\n\n    private function sqlXpathExtractNumValue($alias, $property)\n    {\n        if ($this->platform instanceof PostgreSQL94Platform || $this->platform instanceof PostgreSqlPlatform) {\n            return sprintf(\"(xpath('//sv:property[@sv:name=%s]/sv:value[1]/text()', CAST(%s.props AS xml), %s))[1]::text::int\", Xpath::escape($property), $alias, $this->sqlXpathPostgreSQLNamespaces());\n        }\n\n        return sprintf('CAST(%s AS DECIMAL)', $this->sqlXpathExtractValue($alias, $property));\n    }\n\n    private function sqlXpathExtractValueAttribute($alias, $property, $attribute, $valueIndex = 1)\n    {\n        if ($this->platform instanceof MySQLPlatform) {\n            return sprintf(\"EXTRACTVALUE(%s.props, '//sv:property[@sv:name=%s]/sv:value[%d]/@%s')\", $alias, Xpath::escape($property), $valueIndex, $attribute);\n        }\n\n        if ($this->platform instanceof PostgreSQL94Platform || $this->platform instanceof PostgreSqlPlatform) {\n            return sprintf(\"CAST((xpath('//sv:property[@sv:name=%s]/sv:value[%d]/@%s', CAST(%s.props AS xml), %s))[1]::text AS bigint)\", Xpath::escape($property), $valueIndex, $attribute, $alias, $this->sqlXpathPostgreSQLNamespaces());\n        }\n\n        if ($this->platform instanceof SqlitePlatform) {\n            return sprintf(\"EXTRACTVALUE(%s.props, '//sv:property[@sv:name=%s]/sv:value[%d]/@%s')\", $alias, Xpath::escape($property), $valueIndex, $attribute);\n        }\n\n        throw new NotImplementedException(sprintf(\"Xpath evaluations cannot be executed with '%s' yet.\", $this->platform->getName()));\n    }\n\n    /**\n     * @param $alias\n     * @param $property\n     * @param $value\n     * @param string $operator\n     *\n     * @return string\n     *\n     * @throws NotImplementedException if the storage backend is neither mysql\n     *      nor postgres nor sqlite\n     */\n    private function sqlXpathComparePropertyValue($alias, $property, $value, $operator)\n    {\n        $expression = null;\n\n        if ($this->platform instanceof MySQLPlatform) {\n            $expression = sprintf(\"EXTRACTVALUE(%s.props, 'count(//sv:property[@sv:name=%s]/sv:value[text()%%s%%s]) > 0')\", $alias, Xpath::escape($property));\n            // mysql does not escape the backslashes for us, while postgres and sqlite do\n            $value = Xpath::escapeBackslashes($value);\n        } elseif ($this->platform instanceof PostgreSQL94Platform || $this->platform instanceof PostgreSqlPlatform) {\n            $expression = sprintf(\"xpath_exists('//sv:property[@sv:name=%s]/sv:value[text()%s%s]', CAST(%%s.props AS xml), %%s) = 't'\", Xpath::escape($property), $alias, $this->sqlXpathPostgreSQLNamespaces());\n        } elseif ($this->platform instanceof SqlitePlatform) {\n            $expression = sprintf(\"EXTRACTVALUE(%s.props, 'count(//sv:property[@sv:name=%s]/sv:value[text()%%s%%s]) > 0')\", $alias, Xpath::escape($property));\n        } else {\n            throw new NotImplementedException(sprintf(\"Xpath evaluations cannot be executed with '%s' yet.\", $this->platform->getName()));\n        }\n\n        return sprintf($expression, $this->walkOperator($operator), Xpath::escape($value));\n    }\n\n    /**\n     * @return string\n     */\n    private function sqlXpathPostgreSQLNamespaces()\n    {\n        return \"ARRAY[ARRAY['sv', 'http://www.jcp.org/jcr/sv/1.0']]\";\n    }\n\n    /**\n     * @param QOM\\SelectorInterface $source\n     * @param string                $alias\n     *\n     * @return string\n     */\n    private function sqlNodeTypeClause($alias, QOM\\SelectorInterface $source)\n    {\n        $sql = sprintf(\"%s.type IN ('%s'\", $alias, $source->getNodeTypeName());\n\n        $subTypes = $this->nodeTypeManager->getSubtypes($source->getNodeTypeName());\n        foreach ($subTypes as $subType) {\n            /* @var $subType NodeTypeInterface */\n            $sql .= sprintf(\", '%s'\", $subType->getName());\n        }\n        $sql .= ')';\n\n        return $sql;\n    }\n}\n", "<?php\n\nnamespace Jackalope\\Transport\\DoctrineDBAL;\n\nuse DateTime;\nuse DOMDocument;\nuse DOMXPath;\nuse Jackalope\\NodeType\\NodeTypeTemplate;\nuse Jackalope\\Test\\FunctionalTestCase;\nuse PDO;\nuse PHPCR\\PropertyType;\nuse PHPCR\\Query\\QOM\\QueryObjectModelConstantsInterface;\nuse PHPCR\\Query\\QueryInterface;\nuse PHPCR\\Util\\NodeHelper;\nuse PHPCR\\Util\\PathHelper;\nuse PHPCR\\Util\\QOM\\QueryBuilder;\nuse PHPCR\\ValueFormatException;\nuse ReflectionClass;\n\nclass ClientTest extends FunctionalTestCase\n{\n    public function testQueryNodes()\n    {\n        $root = $this->session->getNode('/');\n        $article = $root->addNode('article');\n        $article->setProperty('foo', 'bar');\n        $article->setProperty('bar', 'baz');\n\n        $this->session->save();\n\n        $qm = $this->session->getWorkspace()->getQueryManager();\n        $query = $qm->createQuery('SELECT * FROM [nt:unstructured]', QueryInterface::JCR_SQL2);\n        $result = $query->execute();\n\n        $this->assertCount(2, $result->getNodes());\n\n        $query = $qm->createQuery('SELECT * FROM [nt:unstructured] WHERE foo = \"bar\"', QueryInterface::JCR_SQL2);\n        $result = $query->execute();\n\n        $this->assertCount(1, $result->getNodes());\n    }\n\n    public function testAddNodeTypes()\n    {\n        $workspace = $this->session->getWorkspace();\n        $ntm = $workspace->getNodeTypeManager();\n        $template = $ntm->createNodeTypeTemplate();\n        $template->setName('phpcr:article');\n\n        $propertyDefs = $template->getPropertyDefinitionTemplates();\n        $propertyTemplate = $ntm->createPropertyDefinitionTemplate();\n        $propertyTemplate->setName('headline');\n        $propertyTemplate->setRequiredType(PropertyType::STRING);\n        $propertyDefs[] = $propertyTemplate;\n\n        $childDefs = $template->getNodeDefinitionTemplates();\n        $nodeTemplate = $ntm->createNodeDefinitionTemplate();\n        $nodeTemplate->setName('article_content');\n        $nodeTemplate->setDefaultPrimaryTypeName('nt:unstructured');\n        $nodeTemplate->setMandatory(true);\n        $childDefs[] = $nodeTemplate;\n\n        $ntm->registerNodeTypes([$template], true);\n\n        $def = $ntm->getNodeType('phpcr:article');\n        $this->assertEquals(\"phpcr:article\", $def->getName());\n        $this->assertCount(1, $def->getDeclaredPropertyDefinitions());\n        $this->assertCount(1, $def->getDeclaredChildNodeDefinitions());\n    }\n\n    public function testReorderNodes()\n    {\n        $root = $this->session->getNode('/');\n        $topic = $root->addNode('topic');\n        $topic->addNode('page1');\n        $topic->addNode('page2');\n        $topic->addNode('page3');\n        $topic->addNode('page4');\n        $topic->addNode('page5');\n\n        $this->session->save();\n\n        $topic->orderBefore('page3', 'page1');\n        $topic->orderBefore('page4', null);\n\n        $this->session->save();\n\n        $conn = $this->getConnection();\n        $qb = $conn->createQueryBuilder();\n\n        $qb->select('local_name, sort_order')\n            ->from('phpcr_nodes', 'n')\n            ->where('n.local_name = :name')\n            ->andWhere('n.parent = :parent')\n            ->orderBy('n.sort_order', 'ASC');\n\n        $query = $qb->getSql();\n\n        $stmnt = $this->conn->executeQuery($query, ['name' => 'page3', 'parent' => '/topic']);\n        $row = $stmnt->fetch();\n        $this->assertEquals(0, $row['sort_order']);\n\n        $stmnt = $this->conn->executeQuery($query, ['name' => 'page4', 'parent' => '/topic']);\n\n        $row = $stmnt->fetch();\n        $this->assertEquals(4, $row['sort_order']);\n\n        $retrieved = $this->session->getNode('/topic');\n        foreach ($retrieved as $name => $child) {\n            $check[] = $name;\n        }\n\n        $this->assertEquals($check[0], 'page3');\n        $this->assertEquals($check[4], 'page4');\n    }\n\n    /**\n     * Test cases for depth set when adding nodes\n     */\n    public function testDepthOnAdd()\n    {\n        $root = $this->session->getNode('/');\n        $topic = $root->addNode('topic');\n        $topic->addNode('page1');\n\n        $this->session->save();\n\n        $conn = $this->getConnection();\n        $qb = $conn->createQueryBuilder();\n\n        $qb->select('local_name, depth')\n            ->from('phpcr_nodes', 'n')\n            ->where('n.path = :path');\n\n        $query = $qb->getSql();\n\n        $stmnt = $this->conn->executeQuery($query, ['path' => '/topic']);\n        $row = $stmnt->fetch();\n\n        $this->assertEquals($row['depth'], '1');\n\n        $stmnt = $this->conn->executeQuery($query, ['path' => '/topic/page1']);\n        $row = $stmnt->fetch();\n\n        $this->assertEquals($row['depth'], '2');\n    }\n\n    /**\n     * Test cases for depth when moving nodes\n     */\n    public function testDepthOnMove()\n    {\n        $root = $this->session->getNode('/');\n        $topic1 = $root->addNode('topic1');\n        $topic2 = $root->addNode('topic2');\n        $topic3 = $root->addNode('topic3');\n\n        $topic1->addNode('page1');\n        $topic2->addNode('page2');\n        $topic3->addNode('page3');\n        $this->session->save();\n\n        $this->transport->moveNodeImmediately('/topic2/page2', '/topic1/page1/page2');\n\n        $this->transport->moveNodeImmediately('/topic3', '/topic1/page1/page2/topic3');\n\n        $conn = $this->getConnection();\n        $qb = $conn->createQueryBuilder();\n\n        $qb->select('local_name, depth')\n            ->from('phpcr_nodes', 'n')\n            ->where('n.path = :path');\n\n        $query = $qb->getSql();\n\n        $stmnt = $this->conn->executeQuery($query, ['path' => '/topic1/page1/page2']);\n        $row = $stmnt->fetch();\n        $this->assertEquals($row['depth'], '3');\n\n        $stmnt = $this->conn->executeQuery($query, ['path' => '/topic1/page1/page2/topic3/page3']);\n        $row = $stmnt->fetch();\n        $this->assertEquals($row['depth'], '5');\n    }\n\n    /**\n     * @dataProvider provideTestOutOfRangeCharacters\n     */\n    public function testOutOfRangeCharacterOccurrence($string, $isValid)\n    {\n        if (false === $isValid) {\n            $this->expectException(ValueFormatException::class);\n            $this->expectExceptionMessage('Invalid character detected');\n        }\n\n        $root = $this->session->getNode('/');\n        $article = $root->addNode('article');\n        $article->setProperty('test', $string);\n        $this->session->save();\n        $this->addToAssertionCount(1);\n    }\n\n    public function provideTestOutOfRangeCharacters()\n    {\n        return [\n            ['This is valid too!'.$this->translateCharFromCode('\\u0009'), true],\n            ['This is valid', true],\n            [$this->translateCharFromCode('\\uD7FF'), true],\n            ['This is on the edge, but valid too.'. $this->translateCharFromCode('\\uFFFD'), true],\n            [$this->translateCharFromCode('\\u10000'), true],\n            [$this->translateCharFromCode('\\u10FFFF'), true],\n            [$this->translateCharFromCode('\\u0001'), false],\n            [$this->translateCharFromCode('\\u0002'), false],\n            [$this->translateCharFromCode('\\u0003'), false],\n            [$this->translateCharFromCode('\\u0008'), false],\n            [$this->translateCharFromCode('\\uFFFF'), false],\n        ];\n    }\n\n    private function translateCharFromCode($char)\n    {\n        return json_decode('\"'.$char.'\"');\n    }\n\n    public function testDeleteMoreThanOneThousandNodes()\n    {\n        $root = $this->session->getNode('/');\n        $parent = $root->addNode('test-more-than-one-thousand');\n\n        for ($i = 0; $i <= 1200; $i++) {\n            $parent->addNode('node-'.$i);\n        }\n\n        $this->session->save();\n\n        NodeHelper::purgeWorkspace($this->session);\n\n        $this->session->save();\n\n        $this->addToAssertionCount(1);\n    }\n\n    public function testPropertyLengthAttribute()\n    {\n        $rootNode = $this->session->getRootNode();\n        $node = $rootNode->addNode('testLengthAttribute');\n\n        $data = [\n            // PropertyName         PropertyValue                   PropertyType            Expected Length\n            'simpleString'  => ['simplestring',                PropertyType::STRING,   12],\n            'mbString'      => ['stringMultibit\u6f22',             PropertyType::STRING,   17],\n            'long'          => [42,                            PropertyType::LONG,     2],\n            'double'        => [3.1415,                        PropertyType::DOUBLE,   6],\n            'decimal'       => [3.141592,                      PropertyType::DECIMAL,  8],\n            'date'          => [new DateTime('now'),          PropertyType::DATE,     29],\n            'booleanTrue'   => [true,                          PropertyType::BOOLEAN,  1],\n            'booleanFalse'  => [false,                         PropertyType::BOOLEAN,  0],\n            'name'          => ['nt:unstructured',             PropertyType::NAME,     15],\n            'uri'           => ['https://google.com',          PropertyType::URI,      18],\n            'path'          => ['/root/testLengthAttribute',   PropertyType::PATH,     25],\n            // 'multiString'   => array(array('foo', 'bar'),           PropertyType::STRING,   array(3,3)),\n            // (weak)reference...\n        ];\n\n        foreach ($data as $propertyName => $propertyInfo) {\n            $node->setProperty($propertyName, $propertyInfo[0], $propertyInfo[1]);\n        }\n\n        $this->session->save();\n\n        $statement = $this->getConnection()->executeQuery('SELECT props, numerical_props FROM phpcr_nodes WHERE path = ?', ['/testLengthAttribute']);\n        $row = $statement->fetch(PDO::FETCH_ASSOC);\n        $props = $row['props'];\n        $decimalProps = $row['numerical_props'];\n\n        foreach ($data as $propertyName => $propertyInfo) {\n            $propertyElement = null;\n\n            foreach ([$props, $decimalProps] as $propXml) {\n                if (null === $propXml) {\n                    continue;\n                }\n\n                $doc = new DOMDocument('1.0', 'utf-8');\n                $doc->loadXML($propXml);\n\n                $xpath = new DOMXPath($doc);\n                $propertyElement = $xpath->query(sprintf('sv:property[@sv:name=\"%s\"]', $propertyName));\n\n                if ($propertyElement->length > 0) {\n                    break;\n                }\n            }\n\n            $this->assertEquals(1, $propertyElement->length, 'Property ' . $propertyName . ' exists');\n\n            $values = $xpath->query('sv:value', $propertyElement->item(0));\n\n            /** @var $value \\DOMElement */\n            foreach ($values as $index => $value) {\n                $lengthAttribute = $value->attributes->getNamedItem('length');\n                if (null === $lengthAttribute) {\n                    $this->fail(sprintf('Value %d for property \"%s\" is expected to have an attribute \"length\"', $index, $propertyName));\n                }\n                $this->assertEquals($propertyInfo[2], $lengthAttribute->nodeValue);\n            }\n        }\n    }\n\n    public function testUuid()\n    {\n        $class = new ReflectionClass(Client::class);\n        $method = $class->getMethod('generateUuid');\n        $method->setAccessible(true);\n\n        self::assertIsString($method->invoke($this->transport));\n\n        $this->transport->setUuidGenerator(function () {\n            return 'like-a-uuid';\n        });\n\n        self::assertEquals('like-a-uuid', $method->invoke($this->transport));\n    }\n\n    public function testMoveAndReplace()\n    {\n        $root = $this->session->getNode('/');\n        $topic1 = $root->addNode('topic1');\n        $topic1->addNode('thisisanewnode');\n        $topic1->addNode('topic1Child');\n\n        $this->session->save();\n        $this->session->move('/topic1', '/topic2');\n\n        $root->addNode('topic1');\n        $this->session->save();\n\n        $conn = $this->getConnection();\n        $qb = $conn->createQueryBuilder();\n\n        $qb->select('local_name')\n            ->from('phpcr_nodes', 'n')\n            ->where('n.path = :path');\n\n        $query = $qb->getSql();\n\n        foreach (['/topic1', '/topic2', '/topic2/thisisanewnode', '/topic2/topic1Child'] as $path) {\n            $stmnt = $this->conn->executeQuery($query, ['path' => $path]);\n            $row = $stmnt->fetch();\n            $this->assertNotFalse($row, $path . ' does not exist in database');\n        }\n    }\n\n    public function testMoveNamespacedNodes()\n    {\n        $root = $this->session->getNode('/');\n        $topic1 = $root->addNode('jcr:topic1');\n        $topic1->addNode('jcr:thisisanewnode');\n        $topic1->addNode('jcr:topic1Child');\n\n        $this->session->save();\n        $this->session->move('/jcr:topic1', '/jcr:topic2');\n\n        $this->session->save();\n\n        $conn = $this->getConnection();\n        $qb = $conn->createQueryBuilder();\n\n        $qb->select('local_name')\n            ->from('phpcr_nodes', 'n')\n            ->where('n.path = :path')->andWhere('n.local_name = :local_name');\n\n        $query = $qb->getSql();\n\n        $expectedData = [\n            '/jcr:topic2' => 'topic2',\n            '/jcr:topic2/jcr:thisisanewnode' => 'thisisanewnode',\n            '/jcr:topic2/jcr:topic1Child' => 'topic1Child'\n        ];\n        foreach ($expectedData as $path => $localName) {\n            $stmnt = $this->conn->executeQuery($query, ['path' => $path, 'local_name' => $localName]);\n            $row = $stmnt->fetch();\n            $this->assertNotFalse($row, $path . ' with local_name' . $localName . ' does not exist in database');\n        }\n    }\n\n    public function testCaseInsensativeRename()\n    {\n        $root = $this->session->getNode('/');\n        $topic1 = $root->addNode('topic');\n\n        $this->session->save();\n        $this->session->move('/topic', '/Topic');\n        $this->session->save();\n\n        $this->addToAssertionCount(1);\n    }\n\n    public function testStoreTypes()\n    {\n        $rootNode = $this->session->getRootNode();\n        $node = $rootNode->addNode('testStoreTypes');\n\n        $data = [\n            ['string_1', 'string_1', PropertyType::STRING],\n            ['string_2', 'string_1', PropertyType::STRING],\n            ['long_1', '10', PropertyType::LONG],\n            ['long_2', '20', PropertyType::LONG],\n            ['decimal_1', '10.0', PropertyType::DECIMAL],\n            ['decimal_2', '20.0', PropertyType::DECIMAL],\n        ];\n\n        foreach ($data as $propertyData) {\n            $node->setProperty($propertyData[0], $propertyData[1], $propertyData[2]);\n        }\n\n        $this->session->save();\n        $this->session->refresh(false);\n\n        foreach ($data as $propertyData) {\n            list($propName) = $propertyData;\n            $this->assertTrue($node->hasProperty($propName), 'Node has property \"' . $propName .'\"');\n        }\n    }\n\n    public function provideOrder()\n    {\n        return [\n            [\n                [\n                    'one' => [\n                        'value' => 'AAA',\n                    ],\n                    'two' => [\n                        'value' => 'BBB',\n                    ],\n                    'three' => [\n                        'value' => 'CCC',\n                    ],\n                ],\n                'value',\n                'value DESC',\n                ['three', 'two', 'one'],\n            ],\n\n            // longs\n            [\n                [\n                    'one' => [\n                        'value' => 30,\n                    ],\n                    'two' => [\n                        'value' => 20,\n                    ],\n                    'three' => [\n                        'value' => 10,\n                    ],\n                ],\n                'value',\n                'value',\n                ['three', 'two', 'one'],\n            ],\n\n            // longs (ensure that values are not cast as strings)\n            [\n                [\n                    'one' => [\n                        'value' => 10,\n                    ],\n                    'two' => [\n                        'value' => 100,\n                    ],\n                    'three' => [\n                        'value' => 20,\n                    ],\n                ],\n                'value',\n                'value',\n                ['one', 'three', 'two'],\n            ],\n\n            // decimals\n            [\n                [\n                    'one' => [\n                        'value' => 10.01,\n                    ],\n                    'two' => [\n                        'value' => 0.01,\n                    ],\n                    'three' => [\n                        'value' => 5.05,\n                    ],\n                ],\n                'value',\n                'value',\n                ['two', 'three', 'one'],\n            ],\n\n            // mixed\n            [\n                [\n                    'one' => [\n                        'title' => 'AAA',\n                        'value' => 10.01,\n                    ],\n                    'two' => [\n                        'title' => 'AAA',\n                        'value' => 0.01,\n                    ],\n                    'three' => [\n                        'title' => 'CCC',\n                        'value' => 5.05,\n                    ],\n                    'four' => [\n                        'title' => 'BBB',\n                        'value' => 5.05,\n                    ],\n                ],\n                'value',\n                'title, value ASC',\n                ['two', 'one', 'four', 'three'],\n            ],\n\n            // property with double quotes\n            [\n                [\n                    'one' => [\n                        'val\"ue' => 'AAA',\n                    ],\n                    'two' => [\n                        'val\"ue' => 'BBB',\n                    ],\n                    'three' => [\n                        'val\"ue' => 'CCC',\n                    ],\n                ],\n                'val\"ue',\n                'val\"ue DESC',\n                ['three', 'two', 'one'],\n            ],\n\n            // property with single quotes\n            [\n                [\n                    'one' => [\n                        'val\\'ue' => 'AAA',\n                    ],\n                    'two' => [\n                        'val\\'ue' => 'BBB',\n                    ],\n                    'three' => [\n                        'val\\'ue' => 'CCC',\n                    ],\n                ],\n                'val\\'ue',\n                'val\\'ue DESC',\n                ['three', 'two', 'one'],\n            ],\n\n            // property with semicolon quotes\n            [\n                [\n                    'one' => [\n                        'val;ue' => 'AAA',\n                    ],\n                    'two' => [\n                        'val;ue' => 'BBB',\n                    ],\n                    'three' => [\n                        'val;ue' => 'CCC',\n                    ],\n                ],\n                'val;ue',\n                'val;ue DESC',\n                ['three', 'two', 'one'],\n            ],\n        ];\n    }\n\n    /**\n     * @dataProvider provideOrder\n     */\n    public function testOrder($nodes, $propertyName, $orderBy, $expectedOrder)\n    {\n        $rootNode = $this->session->getNode('/');\n\n        foreach ($nodes as $nodeName => $nodeProperties) {\n            $node = $rootNode->addNode($nodeName);\n            foreach ($nodeProperties as $name => $value) {\n                $node->setProperty($name, $value);\n            }\n        }\n\n        $this->session->save();\n\n        $qm = $this->session->getWorkspace()->getQueryManager();\n        $qf = $qm->getQOMFactory();\n        $qb = new QueryBuilder($qf);\n        $qb->from(\n            $qb->qomf()->selector('a', 'nt:unstructured')\n        );\n        $qb->where($qf->comparison(\n            $qf->propertyValue('a', $propertyName),\n            QueryObjectModelConstantsInterface::JCR_OPERATOR_NOT_EQUAL_TO,\n            $qf->literal('NULL')\n        ));\n\n        $orderBys = explode(',', $orderBy);\n        foreach ($orderBys as $orderByItem) {\n            $orderByParts = explode(' ', trim($orderByItem));\n            $propertyName = $orderByParts[0];\n            $order = isset($orderByParts[1]) ? $orderByParts[1] : 'ASC';\n\n            $qb->addOrderBy(\n                $qb->qomf()->propertyValue('a', $propertyName),\n                $order\n            );\n        }\n\n        $query = $qb->getQuery();\n        $result = $query->execute();\n\n        $rows = $result->getRows();\n        $this->assertGreaterThan(0, count($rows));\n\n        foreach ($rows as $index => $row) {\n            $path = $row->getNode()->getPath();\n            $name = PathHelper::getNodeName($path);\n\n            $expectedName = $expectedOrder[$index];\n            $this->assertEquals($expectedName, $name);\n        }\n    }\n\n    public function testCopy()\n    {\n        $rootNode = $this->session->getNode('/');\n        $child1 = $rootNode->addNode('child1');\n        $child1->setProperty('string', 'Hello');\n        $child1->setProperty('number', 1234);\n\n        $this->session->save();\n\n        $this->session->getWorkspace()->copy('/child1', '/child2');\n\n        $stmt = $this->conn->query(\"SELECT * FROM phpcr_nodes WHERE path = '/child1' OR path = '/child2'\");\n        $child1 = $stmt->fetch();\n        $child2 = $stmt->fetch();\n\n        $this->assertNotNull($child1);\n        $this->assertNotNull($child2);\n\n        $this->assertEquals($child1['props'], $child2['props']);\n        $this->assertEquals($child1['numerical_props'], $child2['numerical_props']);\n    }\n\n    public function testCopySiblingWithSamePrefix()\n    {\n        $rootNode = $this->session->getNode('/');\n        $child1 = $rootNode->addNode('child1');\n        $child1->setProperty('string', 'Hello');\n        $child1->setProperty('number', 1234);\n        $child2 = $rootNode->addNode('child1-2');\n        $child2->setProperty('string', 'Hello');\n        $child2->setProperty('number', 1234);\n\n        $this->session->save();\n\n        $this->session->getWorkspace()->copy('/child1', '/child2');\n\n        $stmt = $this->conn->query(\"SELECT * FROM phpcr_nodes WHERE path LIKE '/child%'\");\n        $children = $stmt->fetchAll();\n\n        $this->assertCount(3, $children);\n\n        $paths = array_map(\n            function ($child) {\n                return $child['path'];\n            },\n            $children\n        );\n\n        $this->assertContains('/child1', $paths);\n        $this->assertContains('/child2', $paths);\n        $this->assertContains('/child1-2', $paths);\n    }\n\n    /**\n     * The date value should not change when saving.\n     */\n    public function testDate()\n    {\n        $rootNode = $this->session->getNode('/');\n        $child1 = $rootNode->addNode('child1');\n        $date = new DateTime();\n        $before = $date->format('c');\n        $child1->setProperty('date', $date);\n        $this->session->save();\n        $after = $date->format('c');\n\n        $this->assertEquals($before, $after);\n    }\n\n    public function testNestedJoinForDifferentDocumentTypes()\n    {\n        $ntm = $this->session->getWorkspace()->getNodeTypeManager();\n        $template = $ntm->createNodeTypeTemplate();\n        $template->setName('test');\n        $template->setDeclaredSuperTypeNames(['nt:unstructured']);\n        $ntm->registerNodeType($template, true);\n\n        $root = $this->session->getNode('/');\n        $documentNode = $root->addNode('document', 'test');\n        $category = $root->addNode('category');\n        $category->addMixin('mix:referenceable');\n        $this->session->save();\n        $category = $this->session->getNode('/category');\n        $documentChild = $documentNode->addNode('document_child', 'nt:unstructured');\n        $documentChild->setProperty('title', 'someChild');\n        $documentChild->setProperty('locale', 'en');\n        $category->setProperty('title', 'someCategory');\n        $documentNode->setProperty('category', $category->getProperty('jcr:uuid'), 'WeakReference');\n        $this->session->save();\n\n\n\n        $qm = $this->session->getWorkspace()->getQueryManager();\n        $qom = $qm->getQOMFactory();\n        $documentSelector = $qom->selector('d', 'test');\n        $categorySelector = $qom->selector('c', 'nt:unstructured');\n        $documentChildSelector = $qom->selector('dt', 'nt:base');\n        $join = $qom->join($documentSelector, $categorySelector, $qom::JCR_JOIN_TYPE_INNER, $qom->equiJoinCondition(\n            'd',\n            'category',\n            'c',\n            'jcr:uuid'\n        ));\n        $childTitleProp = $qom->propertyValue('dt', 'title');\n        $childTitleVal = $qom->literal($documentChild->getProperty('title')->getValue());\n        $titleConstraint = $qom->comparison($childTitleProp, $qom::JCR_OPERATOR_EQUAL_TO, $childTitleVal);\n\n        $from = $qom->join($join, $documentChildSelector, $qom::JCR_JOIN_TYPE_INNER, $qom->childNodeJoinCondition(\n            'dt',\n            'd'\n        ));\n        $localeConstraint = $qom->comparison(\n            $qom->propertyValue('dt', 'locale'),\n            $qom::JCR_OPERATOR_EQUAL_TO,\n            $qom->literal($documentChild->getProperty('locale')->getValue())\n        );\n        $where = $qom->andConstraint($titleConstraint, $localeConstraint);\n\n        $queryObjectModel = $qom->createQuery($from, $where);\n        $result = $queryObjectModel->execute();\n\n        $this->assertCount(1, $result);\n    }\n\n    public function testMultiJoiningReferencedDocuments()\n    {\n        $ntm = $this->session->getWorkspace()->getNodeTypeManager();\n        $template = $ntm->createNodeTypeTemplate();\n        $template->setName('test');\n        $template->setDeclaredSuperTypeNames(['nt:unstructured']);\n        $ntm->registerNodeType($template, true);\n\n        $root = $this->session->getNode('/');\n        $documentNode = $root->addNode('document', 'test');\n\n        $category = $root->addNode('category');\n        $category->addMixin('mix:referenceable');\n\n        $group = $root->addNode('group');\n        $group->addMixin('mix:referenceable');\n\n        $this->session->save();\n        $category = $this->session->getNode('/category');\n        $category->setProperty('title', 'someCategory');\n        $group = $this->session->getNode('/group');\n        $group->setProperty('title', 'someGroup');\n\n        $documentNode->setProperty('category', $category->getProperty('jcr:uuid'), 'WeakReference');\n        $documentNode->setProperty('group', $group->getProperty('jcr:uuid'), 'WeakReference');\n        $this->session->save();\n\n        $qm = $this->session->getWorkspace()->getQueryManager();\n        $qom = $qm->getQOMFactory();\n        $documentSelector = $qom->selector('d', 'test');\n        $categorySelector = $qom->selector('c', 'nt:unstructured');\n        $groupSelector = $qom->selector('g', 'nt:unstructured');\n        $join = $qom->join($documentSelector, $categorySelector, $qom::JCR_JOIN_TYPE_INNER, $qom->equiJoinCondition(\n            'd',\n            'category',\n            'c',\n            'jcr:uuid'\n        ));\n\n\n        $from = $qom->join($join, $groupSelector, $qom::JCR_JOIN_TYPE_INNER, $qom->equiJoinCondition(\n            'd',\n            'group',\n            'g',\n            'jcr:uuid'\n        ));\n\n        $queryObjectModel = $qom->createQuery($from);\n        $result = $queryObjectModel->execute();\n\n        $this->assertCount(1, $result);\n    }\n}\n"], "filenames": ["src/Jackalope/Transport/DoctrineDBAL/Query/QOMWalker.php", "tests/Jackalope/Transport/DoctrineDBAL/ClientTest.php"], "buggy_code_start_loc": [388, 11], "buggy_code_end_loc": [1040, 537], "fixing_code_start_loc": [388, 12], "fixing_code_end_loc": [1079, 621], "type": "CWE-89", "message": "Jackalope Doctrine-DBAL is an implementation of the PHP Content Repository API (PHPCR) using a relational database to persist data. In affected versions users can provoke SQL injections if they can specify a node name or query. Upgrade to version 1.7.4 to resolve this issue. If that is not possible, you can escape all places where `$property` is used to filter `sv:name` in the class `Jackalope\\Transport\\DoctrineDBAL\\Query\\QOMWalker`: `XPath::escape($property)`. Node names and xpaths can contain `\"` or `;` according to the JCR specification. The jackalope component that translates the query object model into doctrine dbal queries does not properly escape the names and paths, so that a accordingly crafted node name can lead to an SQL injection. If queries are never done from user input, or if you validate the user input to not contain `;`, you are not affected.", "other": {"cve": {"id": "CVE-2021-43822", "sourceIdentifier": "security-advisories@github.com", "published": "2021-12-13T20:15:07.757", "lastModified": "2021-12-17T19:00:24.720", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Jackalope Doctrine-DBAL is an implementation of the PHP Content Repository API (PHPCR) using a relational database to persist data. In affected versions users can provoke SQL injections if they can specify a node name or query. Upgrade to version 1.7.4 to resolve this issue. If that is not possible, you can escape all places where `$property` is used to filter `sv:name` in the class `Jackalope\\Transport\\DoctrineDBAL\\Query\\QOMWalker`: `XPath::escape($property)`. Node names and xpaths can contain `\"` or `;` according to the JCR specification. The jackalope component that translates the query object model into doctrine dbal queries does not properly escape the names and paths, so that a accordingly crafted node name can lead to an SQL injection. If queries are never done from user input, or if you validate the user input to not contain `;`, you are not affected."}, {"lang": "es", "value": "Jackalope Doctrine-DBAL es una implementaci\u00f3n de la API de Repositorio de Contenido PHP (PHPCR) que usa una base de datos relacional para persistir los datos. En las versiones afectadas los usuarios pueden provocar inyecciones SQL si pueden especificar un nombre de nodo o una consulta. Actualice a versi\u00f3n 1.7.4 para resolver este problema. Si no es posible, puede escapar de todos los lugares donde es usado \"$property\" para filtrar \"sv:name\" en la clase \"Jackalope\\Transport\\DoctrineDBAL\\Query\\QOMWalker\": \"XPath::escape($property)\". Los nombres de nodo y los xpaths pueden contener \"\"\" o \";\" seg\u00fan la especificaci\u00f3n JCR. El componente jackalope que traduce el modelo de objetos de consulta en consultas dbal de la doctrina no escapa adecuadamente los nombres y rutas, por lo que un nombre de nodo convenientemente elaborado puede llevar a una inyecci\u00f3n SQL. Si las consultas nunca son realizadas a partir de la entrada del usuario, o si es comprobada la entrada del usuario para que no contenga \";\", no est\u00e1 afectado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jackalope_doctrine-dbal_project:jackalope_doctrine-dbal:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.7.4", "matchCriteriaId": "8BDEE924-F711-42C6-91CC-DE195A153967"}]}]}], "references": [{"url": "https://github.com/jackalope/jackalope-doctrine-dbal/commit/9d179a36d320330ddb303ea3a7c98d3a33d231db", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/jackalope/jackalope-doctrine-dbal/security/advisories/GHSA-ph98-v78f-jqrm", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/jackalope/jackalope-doctrine-dbal/commit/9d179a36d320330ddb303ea3a7c98d3a33d231db"}}