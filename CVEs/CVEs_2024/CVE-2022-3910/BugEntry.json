{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n#include <linux/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"io_uring.h\"\n#include \"rsrc.h\"\n#include \"filetable.h\"\n#include \"msg_ring.h\"\n\nstruct io_msg {\n\tstruct file\t\t\t*file;\n\tu64 user_data;\n\tu32 len;\n\tu32 cmd;\n\tu32 src_fd;\n\tu32 dst_fd;\n\tu32 flags;\n};\n\nstatic int io_msg_ring_data(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\n\tif (msg->src_fd || msg->dst_fd || msg->flags)\n\t\treturn -EINVAL;\n\n\tif (io_post_aux_cqe(target_ctx, msg->user_data, msg->len, 0, true))\n\t\treturn 0;\n\n\treturn -EOVERFLOW;\n}\n\nstatic void io_double_unlock_ctx(struct io_ring_ctx *ctx,\n\t\t\t\t struct io_ring_ctx *octx,\n\t\t\t\t unsigned int issue_flags)\n{\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_unlock(&ctx->uring_lock);\n\tmutex_unlock(&octx->uring_lock);\n}\n\nstatic int io_double_lock_ctx(struct io_ring_ctx *ctx,\n\t\t\t      struct io_ring_ctx *octx,\n\t\t\t      unsigned int issue_flags)\n{\n\t/*\n\t * To ensure proper ordering between the two ctxs, we can only\n\t * attempt a trylock on the target. If that fails and we already have\n\t * the source ctx lock, punt to io-wq.\n\t */\n\tif (!(issue_flags & IO_URING_F_UNLOCKED)) {\n\t\tif (!mutex_trylock(&octx->uring_lock))\n\t\t\treturn -EAGAIN;\n\t\treturn 0;\n\t}\n\n\t/* Always grab smallest value ctx first. We know ctx != octx. */\n\tif (ctx < octx) {\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tmutex_lock(&octx->uring_lock);\n\t} else {\n\t\tmutex_lock(&octx->uring_lock);\n\t\tmutex_lock(&ctx->uring_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int io_msg_send_fd(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tunsigned long file_ptr;\n\tstruct file *src_file;\n\tint ret;\n\n\tif (target_ctx == ctx)\n\t\treturn -EINVAL;\n\n\tret = io_double_lock_ctx(ctx, target_ctx, issue_flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = -EBADF;\n\tif (unlikely(msg->src_fd >= ctx->nr_user_files))\n\t\tgoto out_unlock;\n\n\tmsg->src_fd = array_index_nospec(msg->src_fd, ctx->nr_user_files);\n\tfile_ptr = io_fixed_file_slot(&ctx->file_table, msg->src_fd)->file_ptr;\n\tsrc_file = (struct file *) (file_ptr & FFS_MASK);\n\tget_file(src_file);\n\n\tret = __io_fixed_fd_install(target_ctx, src_file, msg->dst_fd);\n\tif (ret < 0) {\n\t\tfput(src_file);\n\t\tgoto out_unlock;\n\t}\n\n\tif (msg->flags & IORING_MSG_RING_CQE_SKIP)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If this fails, the target still received the file descriptor but\n\t * wasn't notified of the fact. This means that if this request\n\t * completes with -EOVERFLOW, then the sender must ensure that a\n\t * later IORING_OP_MSG_RING delivers the message.\n\t */\n\tif (!io_post_aux_cqe(target_ctx, msg->user_data, msg->len, 0, true))\n\t\tret = -EOVERFLOW;\nout_unlock:\n\tio_double_unlock_ctx(ctx, target_ctx, issue_flags);\n\treturn ret;\n}\n\nint io_msg_ring_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\n\tif (unlikely(sqe->buf_index || sqe->personality))\n\t\treturn -EINVAL;\n\n\tmsg->user_data = READ_ONCE(sqe->off);\n\tmsg->len = READ_ONCE(sqe->len);\n\tmsg->cmd = READ_ONCE(sqe->addr);\n\tmsg->src_fd = READ_ONCE(sqe->addr3);\n\tmsg->dst_fd = READ_ONCE(sqe->file_index);\n\tmsg->flags = READ_ONCE(sqe->msg_ring_flags);\n\tif (msg->flags & ~IORING_MSG_RING_CQE_SKIP)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\t/* put file to avoid an attempt to IOPOLL the req */\n\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/nospec.h>\n#include <linux/io_uring.h>\n\n#include <uapi/linux/io_uring.h>\n\n#include \"io_uring.h\"\n#include \"rsrc.h\"\n#include \"filetable.h\"\n#include \"msg_ring.h\"\n\nstruct io_msg {\n\tstruct file\t\t\t*file;\n\tu64 user_data;\n\tu32 len;\n\tu32 cmd;\n\tu32 src_fd;\n\tu32 dst_fd;\n\tu32 flags;\n};\n\nstatic int io_msg_ring_data(struct io_kiocb *req)\n{\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\n\tif (msg->src_fd || msg->dst_fd || msg->flags)\n\t\treturn -EINVAL;\n\n\tif (io_post_aux_cqe(target_ctx, msg->user_data, msg->len, 0, true))\n\t\treturn 0;\n\n\treturn -EOVERFLOW;\n}\n\nstatic void io_double_unlock_ctx(struct io_ring_ctx *ctx,\n\t\t\t\t struct io_ring_ctx *octx,\n\t\t\t\t unsigned int issue_flags)\n{\n\tif (issue_flags & IO_URING_F_UNLOCKED)\n\t\tmutex_unlock(&ctx->uring_lock);\n\tmutex_unlock(&octx->uring_lock);\n}\n\nstatic int io_double_lock_ctx(struct io_ring_ctx *ctx,\n\t\t\t      struct io_ring_ctx *octx,\n\t\t\t      unsigned int issue_flags)\n{\n\t/*\n\t * To ensure proper ordering between the two ctxs, we can only\n\t * attempt a trylock on the target. If that fails and we already have\n\t * the source ctx lock, punt to io-wq.\n\t */\n\tif (!(issue_flags & IO_URING_F_UNLOCKED)) {\n\t\tif (!mutex_trylock(&octx->uring_lock))\n\t\t\treturn -EAGAIN;\n\t\treturn 0;\n\t}\n\n\t/* Always grab smallest value ctx first. We know ctx != octx. */\n\tif (ctx < octx) {\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tmutex_lock(&octx->uring_lock);\n\t} else {\n\t\tmutex_lock(&octx->uring_lock);\n\t\tmutex_lock(&ctx->uring_lock);\n\t}\n\n\treturn 0;\n}\n\nstatic int io_msg_send_fd(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_ring_ctx *target_ctx = req->file->private_data;\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tstruct io_ring_ctx *ctx = req->ctx;\n\tunsigned long file_ptr;\n\tstruct file *src_file;\n\tint ret;\n\n\tif (target_ctx == ctx)\n\t\treturn -EINVAL;\n\n\tret = io_double_lock_ctx(ctx, target_ctx, issue_flags);\n\tif (unlikely(ret))\n\t\treturn ret;\n\n\tret = -EBADF;\n\tif (unlikely(msg->src_fd >= ctx->nr_user_files))\n\t\tgoto out_unlock;\n\n\tmsg->src_fd = array_index_nospec(msg->src_fd, ctx->nr_user_files);\n\tfile_ptr = io_fixed_file_slot(&ctx->file_table, msg->src_fd)->file_ptr;\n\tsrc_file = (struct file *) (file_ptr & FFS_MASK);\n\tget_file(src_file);\n\n\tret = __io_fixed_fd_install(target_ctx, src_file, msg->dst_fd);\n\tif (ret < 0) {\n\t\tfput(src_file);\n\t\tgoto out_unlock;\n\t}\n\n\tif (msg->flags & IORING_MSG_RING_CQE_SKIP)\n\t\tgoto out_unlock;\n\n\t/*\n\t * If this fails, the target still received the file descriptor but\n\t * wasn't notified of the fact. This means that if this request\n\t * completes with -EOVERFLOW, then the sender must ensure that a\n\t * later IORING_OP_MSG_RING delivers the message.\n\t */\n\tif (!io_post_aux_cqe(target_ctx, msg->user_data, msg->len, 0, true))\n\t\tret = -EOVERFLOW;\nout_unlock:\n\tio_double_unlock_ctx(ctx, target_ctx, issue_flags);\n\treturn ret;\n}\n\nint io_msg_ring_prep(struct io_kiocb *req, const struct io_uring_sqe *sqe)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\n\tif (unlikely(sqe->buf_index || sqe->personality))\n\t\treturn -EINVAL;\n\n\tmsg->user_data = READ_ONCE(sqe->off);\n\tmsg->len = READ_ONCE(sqe->len);\n\tmsg->cmd = READ_ONCE(sqe->addr);\n\tmsg->src_fd = READ_ONCE(sqe->addr3);\n\tmsg->dst_fd = READ_ONCE(sqe->file_index);\n\tmsg->flags = READ_ONCE(sqe->msg_ring_flags);\n\tif (msg->flags & ~IORING_MSG_RING_CQE_SKIP)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nint io_msg_ring(struct io_kiocb *req, unsigned int issue_flags)\n{\n\tstruct io_msg *msg = io_kiocb_to_cmd(req, struct io_msg);\n\tint ret;\n\n\tret = -EBADFD;\n\tif (!io_is_uring_fops(req->file))\n\t\tgoto done;\n\n\tswitch (msg->cmd) {\n\tcase IORING_MSG_DATA:\n\t\tret = io_msg_ring_data(req);\n\t\tbreak;\n\tcase IORING_MSG_SEND_FD:\n\t\tret = io_msg_send_fd(req, issue_flags);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\ndone:\n\tif (ret < 0)\n\t\treq_set_fail(req);\n\tio_req_set_res(req, ret, 0);\n\t/* put file to avoid an attempt to IOPOLL the req */\n\tif (!(req->flags & REQ_F_FIXED_FILE))\n\t\tio_put_file(req->file);\n\treq->file = NULL;\n\treturn IOU_OK;\n}\n"], "filenames": ["io_uring/msg_ring.c"], "buggy_code_start_loc": [168], "buggy_code_end_loc": [169], "fixing_code_start_loc": [168], "fixing_code_end_loc": [170], "type": "CWE-416", "message": "Use After Free vulnerability in Linux Kernel allows Privilege Escalation. An improper Update of Reference Count in io_uring leads to Use-After-Free and Local Privilege Escalation. When io_msg_ring was invoked with a fixed file, it called io_fput_file() which improperly decreased its reference count (leading to Use-After-Free and Local Privilege Escalation). Fixed files are permanently registered to the ring, and should not be put separately. We recommend upgrading past commit https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679 https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679", "other": {"cve": {"id": "CVE-2022-3910", "sourceIdentifier": "cve-coordination@google.com", "published": "2022-11-22T13:15:13.167", "lastModified": "2023-02-14T21:13:50.050", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use After Free vulnerability in Linux Kernel allows Privilege Escalation. An improper Update of Reference Count in io_uring leads to Use-After-Free and Local Privilege Escalation. When io_msg_ring was invoked with a fixed file, it called io_fput_file() which improperly decreased its reference count (leading to Use-After-Free and Local Privilege Escalation). Fixed files are permanently registered to the ring, and should not be put separately. We recommend upgrading past commit https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679 https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "5.18", "versionEndExcluding": "5.19.11", "matchCriteriaId": "DC7F6228-4E87-46E2-8CD8-A8439BC31E81"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "E8BD11A3-8643-49B6-BADE-5029A0117325"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "5F0AD220-F6A9-4012-8636-155F1B841FAD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "A46498B3-78E1-4623-AAE1-94D29A42BE4E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.0:rc4:*:*:*:*:*:*", "matchCriteriaId": "F8446E87-F5F6-41CA-8201-BAE0F0CA6DD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:6.0:rc5:*:*:*:*:*:*", "matchCriteriaId": "8E5FB72F-67CE-43CC-83FE-541604D98182"}]}]}], "references": [{"url": "https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://kernel.dance/#fc7222c3a9f56271fba02aabbfbae999042f1679", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679"}}