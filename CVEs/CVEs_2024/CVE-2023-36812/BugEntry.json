{"buggy_code": ["// This file is part of OpenTSDB.\n// Copyright (C) 2010-2021  The OpenTSDB Authors.\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 2.1 of the License, or (at your\n// option) any later version.  This program is distributed in the hope that it\n// will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty\n// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser\n// General Public License for more details.  You should have received a copy\n// of the GNU Lesser General Public License along with this program.  If not,\n// see <http://www.gnu.org/licenses/>.\npackage net.opentsdb.tsd;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.regex.Pattern;\n\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Sets;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport net.opentsdb.core.Const;\nimport net.opentsdb.core.DataPoint;\nimport net.opentsdb.core.DataPoints;\nimport net.opentsdb.core.Query;\nimport net.opentsdb.core.TSDB;\nimport net.opentsdb.core.TSQuery;\nimport net.opentsdb.graph.Plot;\nimport net.opentsdb.meta.Annotation;\nimport net.opentsdb.stats.Histogram;\nimport net.opentsdb.stats.StatsCollector;\nimport net.opentsdb.tools.GnuplotInstaller;\nimport net.opentsdb.utils.DateTime;\nimport net.opentsdb.utils.JSON;\n\nimport com.stumbleupon.async.Callback;\n\n/**\n * Stateless handler of HTTP graph requests (the {@code /q} endpoint).\n */\nfinal class GraphHandler implements HttpRpc {\n\n  private static final Logger LOG =\n    LoggerFactory.getLogger(GraphHandler.class);\n\n  private static final boolean IS_WINDOWS =\n    System.getProperty(\"os.name\", \"\").contains(\"Windows\");\n\n  private static final String RANGE_COMPONENT = \"\\\\\\\"?-?\\\\d*\\\\.?(\\\\d+)?([eE]-?\\\\d+)?\\\\\\\"?\";\n  private static Pattern RANGE_VALIDATOR = Pattern.compile(\n      \"^\\\\[\"+RANGE_COMPONENT+\":\"+RANGE_COMPONENT+\"]$\");\n  private static Pattern LABEL_VALIDATOR = Pattern.compile(\"^[a-zA-z0-9 \\\\-_]+$\");\n  private static Pattern KEY_VALIDATOR = Pattern.compile(\n      \"^out|left|top|center|right|horiz|box|bottom$\");\n  private static Pattern STYLE_VALIDATOR = Pattern.compile(\"^linespoint|points|circles|dots$\");\n  private static Pattern COLOR_VALIDATOR = Pattern.compile(\"^(x|X)[a-fA-F0-9]{6}$\");\n  private static Pattern SMOOTH_VALIDATOR = Pattern.compile(\"^unique|frequency|fnormal|cumulative|cnormal|bins|csplines|acsplines|mcsplines|bezier|sbezier|unwrap|zsort$\");\n  // NOTE: This one should be tightened for only time based formatters.\n  private static Pattern FORMAT_VALIDATOR = Pattern.compile(\"^[%0-9.a-zA-Z \\\\-]+$\");\n  private static Pattern WXH_VALIDATOR = Pattern.compile(\"^\\\\d+x\\\\d+$\");\n  /** Number of times we had to do all the work up to running Gnuplot. */\n  private static final AtomicInteger graphs_generated\n    = new AtomicInteger();\n  /** Number of times a graph request was served from disk, no work needed. */\n  private static final AtomicInteger graphs_diskcache_hit\n    = new AtomicInteger();\n\n  /** Keep track of the latency of graphing requests. */\n  private static final Histogram graphlatency =\n    new Histogram(16000, (short) 2, 100);\n\n  /** Keep track of the latency (in ms) introduced by running Gnuplot. */\n  private static final Histogram gnuplotlatency =\n    new Histogram(16000, (short) 2, 100);\n\n  /** Executor to run Gnuplot in separate bounded thread pool. */\n  private final ThreadPoolExecutor gnuplot;\n\n  /**\n   * Constructor.\n   */\n  public GraphHandler() {\n    // Gnuplot is mostly CPU bound and does only a little bit of IO at the\n    // beginning to read the input data and at the end to write its output.\n    // We want to avoid running too many Gnuplot instances concurrently as\n    // it can steal a significant number of CPU cycles from us.  Instead, we\n    // allow only one per core, and we nice it (the nicing is done in the\n    // shell script we use to start Gnuplot).  Similarly, the queue we use\n    // is sized so as to have a fixed backlog per core.\n    final int ncores = Runtime.getRuntime().availableProcessors();\n    gnuplot = new ThreadPoolExecutor(\n      ncores, ncores,  // Thread pool of a fixed size.\n      /* 5m = */ 300000, MILLISECONDS,        // How long to keep idle threads.\n      new ArrayBlockingQueue<Runnable>(20 * ncores),  // XXX Don't hardcode?\n      thread_factory);\n    // ArrayBlockingQueue does not scale as much as LinkedBlockingQueue in terms\n    // of throughput but we don't need high throughput here.  We use ABQ instead\n    // of LBQ because it creates far fewer references.\n  }\n\n  public void execute(final TSDB tsdb, final HttpQuery query) {\n    if (!query.hasQueryStringParam(\"json\")\n        && !query.hasQueryStringParam(\"png\")\n        && !query.hasQueryStringParam(\"ascii\")) {\n      String uri = query.request().getUri();\n      if (uri.length() < 4) {  // Shouldn't happen...\n        uri = \"/\";             // But just in case, redirect.\n      } else {\n        uri = \"/#\" + uri.substring(3);  // Remove \"/q?\"\n      }\n      query.redirect(uri);\n      return;\n    }\n    try {\n      doGraph(tsdb, query);\n    } catch (IOException e) {\n      query.internalError(e);\n    } catch (IllegalArgumentException e) {\n      query.badRequest(e.getMessage());\n    }\n  }\n\n  // TODO(HugoMFernandes): Most of this (query-related) logic is implemented in\n  // net.opentsdb.tsd.QueryRpc.java (which actually does this asynchronously),\n  // so we should refactor both classes to split the actual logic used to\n  // generate the data from the actual visualization (removing all duped code).\n  private void doGraph(final TSDB tsdb, final HttpQuery query)\n    throws IOException {\n    final String basepath = getGnuplotBasePath(tsdb, query);\n    long start_time = DateTime.parseDateTimeString(\n      query.getRequiredQueryStringParam(\"start\"),\n      query.getQueryStringParam(\"tz\"));\n    final boolean nocache = query.hasQueryStringParam(\"nocache\");\n    if (start_time == -1) {\n      throw BadRequestException.missingParameter(\"start\");\n    } else {\n      // temp fixup to seconds from ms until the rest of TSDB supports ms\n      // Note you can't append this to the DateTime.parseDateTimeString() call as\n      // it clobbers -1 results\n      start_time /= 1000;\n    }\n    long end_time = DateTime.parseDateTimeString(\n        query.getQueryStringParam(\"end\"),\n        query.getQueryStringParam(\"tz\"));\n    final long now = System.currentTimeMillis() / 1000;\n    if (end_time == -1) {\n      end_time = now;\n    } else {\n      // temp fixup to seconds from ms until the rest of TSDB supports ms\n      // Note you can't append this to the DateTime.parseDateTimeString() call as\n      // it clobbers -1 results\n      end_time /= 1000;\n    }\n    final int max_age = computeMaxAge(query, start_time, end_time, now);\n    if (!nocache && isDiskCacheHit(query, end_time, max_age, basepath)) {\n      return;\n    }\n\n    // Parse TSQuery from HTTP query\n    final TSQuery tsquery = QueryRpc.parseQuery(tsdb, query);\n    tsquery.validateAndSetQuery();\n\n    // Build the queries for the parsed TSQuery\n    Query[] tsdbqueries = tsquery.buildQueries(tsdb);\n\n    List<String> options = null;\n    final String options_allow_list = tsdb.getConfig().getString(\n        \"tsd.gnuplot.options.allowlist\");\n    if (!Strings.isNullOrEmpty(options_allow_list)) {\n      String[] allow_list_strings = options_allow_list.split(\";\");\n      Set<String> allow_list = Sets.newHashSet();\n      for (int i = 0; i < allow_list_strings.length; i++) {\n        String allow = allow_list_strings[i];\n        if (allow != null) {\n          allow = URLDecoder.decode(allow.trim());\n          allow_list.add(allow);\n        }\n      }\n      \n      options = query.getQueryStringParams(\"o\");\n      for (int i = 0; i < options.size(); i++) {\n        if (!allow_list.contains(options.get(i))) {\n          throw new BadRequestException(\"Query option at index \" + i \n              + \" was not in the allow list.\");\n        }\n      }\n    }\n    \n    if (options == null) {\n      options = new ArrayList<String>(tsdbqueries.length);\n      for (int i = 0; i < tsdbqueries.length; i++) {\n        options.add(\"\");\n      }\n    } else if (options.size() != tsdbqueries.length) {\n      throw new BadRequestException(options.size() + \" `o' parameters, but \"\n        + tsdbqueries.length + \" `m' parameters.\");\n    }\n    for (final Query tsdbquery : tsdbqueries) {\n      try {\n        tsdbquery.setStartTime(start_time);\n      } catch (IllegalArgumentException e) {\n        throw new BadRequestException(\"start time: \" + e.getMessage());\n      }\n      try {\n        tsdbquery.setEndTime(end_time);\n      } catch (IllegalArgumentException e) {\n        throw new BadRequestException(\"end time: \" + e.getMessage());\n      }\n    }\n    final Plot plot = new Plot(start_time, end_time,\n          DateTime.timezones.get(query.getQueryStringParam(\"tz\")));\n    setPlotDimensions(query, plot);\n    setPlotParams(query, plot);\n    final int nqueries = tsdbqueries.length;\n    @SuppressWarnings(\"unchecked\")\n    final HashSet<String>[] aggregated_tags = new HashSet[nqueries];\n    int npoints = 0;\n    for (int i = 0; i < nqueries; i++) {\n      try {  // execute the TSDB query!\n        // XXX This is slow and will block Netty.  TODO(tsuna): Don't block.\n        // TODO(tsuna): Optimization: run each query in parallel.\n        final DataPoints[] series = tsdbqueries[i].run();\n        for (final DataPoints datapoints : series) {\n          plot.add(datapoints, options.get(i));\n          aggregated_tags[i] = new HashSet<String>();\n          aggregated_tags[i].addAll(datapoints.getAggregatedTags());\n          npoints += datapoints.aggregatedSize();\n        }\n      } catch (RuntimeException e) {\n        logInfo(query, \"Query failed (stack trace coming): \"\n                + tsdbqueries[i]);\n        throw e;\n      }\n      tsdbqueries[i] = null;  // free()\n    }\n    tsdbqueries = null;  // free()\n\n    if (query.hasQueryStringParam(\"ascii\")) {\n      respondAsciiQuery(query, max_age, basepath, plot);\n      return;\n    }\n\n    final RunGnuplot rungnuplot = new RunGnuplot(query, max_age, plot, basepath,\n            aggregated_tags, npoints);\n\n    class ErrorCB implements Callback<Object, Exception> {\n      public Object call(final Exception e) throws Exception {\n        LOG.warn(\"Failed to retrieve global annotations: \", e);\n        throw e;\n      }\n    }\n\n    class GlobalCB implements Callback<Object, List<Annotation>> {\n      public Object call(final List<Annotation> global_annotations) throws Exception {\n        rungnuplot.plot.setGlobals(global_annotations);\n        execGnuplot(rungnuplot, query);\n\n        return null;\n      }\n    }\n\n    // Fetch global annotations, if needed\n    if (!tsquery.getNoAnnotations() && tsquery.getGlobalAnnotations()) {\n      Annotation.getGlobalAnnotations(tsdb, start_time, end_time)\n              .addCallback(new GlobalCB()).addErrback(new ErrorCB());\n    } else {\n      execGnuplot(rungnuplot, query);\n    }\n  }\n\n  private void execGnuplot(RunGnuplot rungnuplot, HttpQuery query) {\n    try {\n      gnuplot.execute(rungnuplot);\n    } catch (RejectedExecutionException e) {\n      query.internalError(new Exception(\"Too many requests pending,\"\n                                        + \" please try again later\", e));\n    }\n  }\n\n  /**\n   * Decides how long we're going to allow the client to cache our response.\n   * <p>\n   * Based on the query, we'll decide whether or not we want to allow the\n   * client to cache our response and for how long.\n   * @param query The query to serve.\n   * @param start_time The start time on the query (32-bit unsigned int, secs).\n   * @param end_time The end time on the query (32-bit unsigned int, seconds).\n   * @param now The current time (32-bit unsigned int, seconds).\n   * @return A positive integer, in seconds.\n   */\n  private static int computeMaxAge(final HttpQuery query,\n                                   final long start_time, final long end_time,\n                                   final long now) {\n    // If the end time is in the future (1), make the graph uncacheable.\n    // Otherwise, if the end time is far enough in the past (2) such that\n    // no TSD can still be writing to rows for that time span and it's not\n    // specified in a relative fashion (3) (e.g. \"1d-ago\"), make the graph\n    // cacheable for a day since it's very unlikely that any data will change\n    // for this time span.\n    // Otherwise (4), allow the client to cache the graph for ~0.1% of the\n    // time span covered by the request e.g., for 1h of data, it's OK to\n    // serve something 3s stale, for 1d of data, 84s stale.\n    if (end_time > now) {                            // (1)\n      return 0;\n    } else if (end_time < now - Const.MAX_TIMESPAN   // (2)\n               && !DateTime.isRelativeDate(\n                   query.getQueryStringParam(\"start\"))    // (3)\n               && !DateTime.isRelativeDate(\n                   query.getQueryStringParam(\"end\"))) {\n      return 86400;\n    } else {                                         // (4)\n      return (int) (end_time - start_time) >> 10;\n    }\n  }\n\n  // Runs Gnuplot in a subprocess to generate the graph.\n  private static final class RunGnuplot implements Runnable {\n\n    private final HttpQuery query;\n    private final int max_age;\n    private final Plot plot;\n    private final String basepath;\n    private final HashSet<String>[] aggregated_tags;\n    private final int npoints;\n\n    public RunGnuplot(final HttpQuery query,\n                      final int max_age,\n                      final Plot plot,\n                      final String basepath,\n                      final HashSet<String>[] aggregated_tags,\n                      final int npoints) {\n      this.query = query;\n      this.max_age = max_age;\n      this.plot = plot;\n      if (IS_WINDOWS)\n        this.basepath = basepath.replace(\"\\\\\", \"\\\\\\\\\").replace(\"/\", \"\\\\\\\\\");\n      else\n        this.basepath = basepath;\n      this.aggregated_tags = aggregated_tags;\n      this.npoints = npoints;\n    }\n\n    public void run() {\n      try {\n        execute();\n      } catch (BadRequestException e) {\n        query.badRequest(e.getMessage());\n      } catch (GnuplotException e) {\n        query.badRequest(\"<pre>\" + e.getMessage() + \"</pre>\");\n      } catch (RuntimeException e) {\n        query.internalError(e);\n      } catch (IOException e) {\n        query.internalError(e);\n      }\n    }\n\n    private void execute() throws IOException {\n      final int nplotted = runGnuplot(query, basepath, plot);\n      if (query.hasQueryStringParam(\"json\")) {\n        final HashMap<String, Object> results = new HashMap<String, Object>();\n        results.put(\"plotted\", nplotted);\n        results.put(\"points\", npoints);\n        // 1.0 returned an empty inner array if the 1st hashset was null, to do\n        // the same we need to fudge it with an empty set\n        if (aggregated_tags != null && aggregated_tags.length > 0 &&\n            aggregated_tags[0] == null) {\n          aggregated_tags[0] = new HashSet<String>();\n        }\n        results.put(\"etags\", aggregated_tags);\n        results.put(\"timing\", query.processingTimeMillis());\n        query.sendReply(JSON.serializeToBytes(results));\n        writeFile(query, basepath + \".json\", JSON.serializeToBytes(results));\n      } else if (query.hasQueryStringParam(\"png\")) {\n        query.sendFile(basepath + \".png\", max_age);\n      } else {\n        query.internalError(new Exception(\"Should never be here!\"));\n      }\n\n      // TODO(tsuna): Expire old files from the on-disk cache.\n      graphlatency.add(query.processingTimeMillis());\n      graphs_generated.incrementAndGet();\n    }\n\n  }\n\n  /** Shuts down the thread pool used to run Gnuplot.  */\n  public void shutdown() {\n    gnuplot.shutdown();\n  }\n\n  /**\n   * Collects the stats and metrics tracked by this instance.\n   * @param collector The collector to use.\n   */\n  public static void collectStats(final StatsCollector collector) {\n    collector.record(\"http.latency\", graphlatency, \"type=graph\");\n    collector.record(\"http.latency\", gnuplotlatency, \"type=gnuplot\");\n    collector.record(\"http.graph.requests\", graphs_diskcache_hit, \"cache=disk\");\n    collector.record(\"http.graph.requests\", graphs_generated, \"cache=miss\");\n  }\n\n  /** Returns the base path to use for the Gnuplot files. */\n  private String getGnuplotBasePath(final TSDB tsdb, final HttpQuery query) {\n    final Map<String, List<String>> q = query.getQueryString();\n    q.remove(\"ignore\");\n    // Super cheap caching mechanism: hash the query string.\n    final HashMap<String, List<String>> qs =\n      new HashMap<String, List<String>>(q);\n    // But first remove the parameters that don't influence the output.\n    qs.remove(\"png\");\n    qs.remove(\"json\");\n    qs.remove(\"ascii\");\n    return tsdb.getConfig().getDirectoryName(\"tsd.http.cachedir\") +\n        Integer.toHexString(qs.hashCode());\n  }\n\n  /**\n   * Checks whether or not it's possible to re-serve this query from disk.\n   * @param query The query to serve.\n   * @param end_time The end time on the query (32-bit unsigned int, seconds).\n   * @param max_age The maximum time (in seconds) we wanna allow clients to\n   * cache the result in case of a cache hit.\n   * @param basepath The base path used for the Gnuplot files.\n   * @return {@code true} if this request was served from disk (in which\n   * case processing can stop here), {@code false} otherwise (in which case\n   * the query needs to be processed).\n   */\n  private boolean isDiskCacheHit(final HttpQuery query,\n                                 final long end_time,\n                                 final int max_age,\n                                 final String basepath) throws IOException {\n    final String cachepath = basepath + (query.hasQueryStringParam(\"ascii\")\n                                         ? \".txt\" : \".png\");\n    final File cachedfile = new File(cachepath);\n    if (cachedfile.exists()) {\n      final long bytes = cachedfile.length();\n      if (bytes < 21) {  // Minimum possible size for a PNG: 21 bytes.\n                         // For .txt files, <21 bytes is almost impossible.\n        logWarn(query, \"Cached \" + cachepath + \" is too small (\"\n                + bytes + \" bytes) to be valid.  Ignoring it.\");\n        return false;\n      }\n      if (staleCacheFile(query, end_time, max_age, cachedfile)) {\n        return false;\n      }\n      if (query.hasQueryStringParam(\"json\")) {\n        HashMap<String, Object> map = loadCachedJson(query, end_time,\n            max_age, basepath);\n        if (map == null) {\n          map = new HashMap<String, Object>();\n        }\n        map.put(\"timing\", query.processingTimeMillis());\n        map.put(\"cachehit\", \"disk\");\n        query.sendReply(JSON.serializeToBytes(map));\n      } else if (query.hasQueryStringParam(\"png\")\n                 || query.hasQueryStringParam(\"ascii\")) {\n        query.sendFile(cachepath, max_age);\n      } else {\n        query.sendReply(HttpQuery.makePage(\"TSDB Query\", \"Your graph is ready\",\n            \"<img src=\\\"\" + query.request().getUri() + \"&amp;png\\\"/><br/>\"\n            + \"<small>(served from disk cache)</small>\"));\n      }\n      graphs_diskcache_hit.incrementAndGet();\n      return true;\n    }\n    // We didn't find an image.  Do a negative cache check.  If we've seen\n    // this query before but there was no result, we at least wrote the JSON.\n    final HashMap<String, Object> map = loadCachedJson(query, end_time,\n        max_age, basepath);\n    // If we don't have a JSON file it's a complete cache miss.  If we have\n    // one, and it says 0 data points were plotted, it's a negative cache hit.\n    if (map == null || !map.containsKey(\"plotted\") ||\n        ((Integer)map.get(\"plotted\")) == 0) {\n      return false;\n    }\n    if (query.hasQueryStringParam(\"json\")) {\n      map.put(\"timing\", query.processingTimeMillis());\n      map.put(\"cachehit\", \"disk\");\n      query.sendReply(JSON.serializeToBytes(map));\n    } else if (query.hasQueryStringParam(\"png\")) {\n      query.sendReply(\" \");  // Send back an empty response...\n    } else {\n        query.sendReply(HttpQuery.makePage(\"TSDB Query\", \"No results\",\n            \"Sorry, your query didn't return anything.<br/>\"\n            + \"<small>(served from disk cache)</small>\"));\n    }\n    graphs_diskcache_hit.incrementAndGet();\n    return true;\n  }\n\n  /**\n   * Returns whether or not the given cache file can be used or is stale.\n   * @param query The query to serve.\n   * @param end_time The end time on the query (32-bit unsigned int, seconds).\n   * @param max_age The maximum time (in seconds) we wanna allow clients to\n   * cache the result in case of a cache hit.  If the file is exactly that\n   * old, it is not considered stale.\n   * @param cachedfile The file to check for staleness.\n   */\n  private static boolean staleCacheFile(final HttpQuery query,\n                                        final long end_time,\n                                        final long max_age,\n                                        final File cachedfile) {\n    final long mtime = cachedfile.lastModified() / 1000;\n    if (mtime <= 0) {\n      return true;  // File doesn't exist, or can't be read.\n    }\n\n    final long now = System.currentTimeMillis() / 1000;\n    // How old is the cached file, in seconds?\n    final long staleness = now - mtime;\n    if (staleness < 0) {  // Can happen if the mtime is \"in the future\".\n      logWarn(query, \"Not using file @ \" + cachedfile + \" with weird\"\n              + \" mtime in the future: \" + mtime);\n      return true;  // Play it safe, pretend we can't use this file.\n    }\n\n    // Case 1: The end time is an absolute point in the past.\n    // We might be able to re-use the cached file.\n    if (0 < end_time && end_time < now) {\n      // If the file was created prior to the end time, maybe we first\n      // executed this query while the result was uncacheable.  We can\n      // tell by looking at the mtime on the file.  If the file was created\n      // before the query end time, then it contains partial results that\n      // shouldn't be served again.\n      return mtime < end_time;\n    }\n\n    // Case 2: The end time of the query is now or in the future.\n    // The cached file contains partial data and can only be re-used if it's\n    // not too old.\n    if (staleness > max_age) {\n      logInfo(query, \"Cached file @ \" + cachedfile.getPath() + \" is \"\n              + staleness + \"s stale, which is more than its limit of \"\n              + max_age + \"s, and needs to be regenerated.\");\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Writes the given byte array into a file.\n   * This function logs an error but doesn't throw if it fails.\n   * @param query The query being handled (for logging purposes).\n   * @param path The path to write to.\n   * @param contents The contents to write into the file.\n   */\n  private static void writeFile(final HttpQuery query,\n                                final String path,\n                                final byte[] contents) {\n    try {\n      final FileOutputStream out = new FileOutputStream(path);\n      try {\n        out.write(contents);\n      } finally {\n        out.close();\n      }\n    } catch (FileNotFoundException e) {\n      logError(query, \"Failed to create file \" + path, e);\n    } catch (IOException e) {\n      logError(query, \"Failed to write file \" + path, e);\n    }\n  }\n\n  /**\n   * Reads a file into a byte array.\n   * @param query The query being handled (for logging purposes).\n   * @param file The file to read.\n   * @param max_length The maximum number of bytes to read from the file.\n   * @return {@code null} if the file doesn't exist or is empty or couldn't be\n   * read, otherwise a byte array of up to {@code max_length} bytes.\n   */\n  private static byte[] readFile(final HttpQuery query,\n                                 final File file,\n                                 final int max_length) {\n    final int length = (int) file.length();\n    if (length <= 0) {\n      return null;\n    }\n    FileInputStream in;\n    try {\n      in = new FileInputStream(file.getPath());\n    } catch (FileNotFoundException e) {\n      return null;\n    }\n    try {\n      final byte[] buf = new byte[Math.min(length, max_length)];\n      final int read = in.read(buf);\n      if (read != buf.length) {\n        logError(query, \"When reading \" + file + \": read only \"\n                 + read + \" bytes instead of \" + buf.length);\n        return null;\n      }\n      return buf;\n    } catch (IOException e) {\n      logError(query, \"Error while reading \" + file, e);\n      return null;\n    } finally {\n      try {\n        in.close();\n      } catch (IOException e) {\n        logError(query, \"Error while closing \" + file, e);\n      }\n    }\n  }\n\n  /**\n   * Attempts to read the cached {@code .json} file for this query.\n   * @param query The query to serve.\n   * @param end_time The end time on the query (32-bit unsigned int, seconds).\n   * @param max_age The maximum time (in seconds) we wanna allow clients to\n   * cache the result in case of a cache hit.\n   * @param basepath The base path used for the Gnuplot files.\n   * @return {@code null} in case no file was found, or the contents of the\n   * file if it was found.\n   * @throws IOException If the file cannot be loaded\n   * @throws JsonMappingException If the JSON cannot be parsed to a HashMap\n   * @throws JsonParseException If the JSON is improperly formatted\n   */\n  @SuppressWarnings(\"unchecked\")\n  private HashMap<String, Object> loadCachedJson(final HttpQuery query,\n                                       final long end_time,\n                                       final long max_age,\n                                       final String basepath)\n                                       throws JsonParseException,\n                                       JsonMappingException, IOException {\n    final String json_path = basepath + \".json\";\n    File json_cache = new File(json_path);\n    if (staleCacheFile(query, end_time, max_age, json_cache)) {\n      return null;\n    }\n    final byte[] json = readFile(query, json_cache, 4096);\n    if (json == null) {\n      return null;\n    }\n    json_cache = null;\n\n    return (HashMap<String, Object>) JSON.parseToObject(json, HashMap.class);\n  }\n\n  /** Parses the {@code wxh} query parameter to set the graph dimension. */\n  static void setPlotDimensions(final HttpQuery query, final Plot plot) {\n    String wxh = query.getQueryStringParam(\"wxh\");\n    if (wxh != null && !wxh.isEmpty()) {\n      wxh = URLDecoder.decode(wxh.trim());\n      if (!WXH_VALIDATOR.matcher(wxh).find()) {\n        throw new IllegalArgumentException(\"'wxh' was invalid. \"\n            + \"Must satisfy the pattern \" + WXH_VALIDATOR.toString());\n      }\n      final int wxhlength = wxh.length();\n      if (wxhlength < 7) {  // 100x100 minimum.\n        throw new BadRequestException(\"Parameter wxh too short: \" + wxh);\n      }\n      final int x = wxh.indexOf('x', 3);  // Start at 2 as min size is 100x100\n      if (x < 0) {\n        throw new BadRequestException(\"Invalid wxh parameter: \" + wxh);\n      }\n      try {\n        final short width = Short.parseShort(wxh.substring(0, x));\n        final short height = Short.parseShort(wxh.substring(x + 1, wxhlength));\n        try {\n          plot.setDimensions(width, height);\n        } catch (IllegalArgumentException e) {\n          throw new BadRequestException(\"Invalid wxh parameter: \" + wxh + \", \"\n                                        + e.getMessage());\n        }\n      } catch (NumberFormatException e) {\n        throw new BadRequestException(\"Can't parse wxh '\" + wxh + \"': \"\n                                      + e.getMessage());\n      }\n    }\n  }\n\n  /**\n   * Formats and quotes the given string so it's a suitable Gnuplot string.\n   * @param s The string to stringify.\n   * @return A string suitable for use as a literal string in Gnuplot.\n   */\n  private static String stringify(final String s) {\n    final StringBuilder buf = new StringBuilder(1 + s.length() + 1);\n    buf.append('\"');\n    HttpQuery.escapeJson(s, buf);  // Abusing this function gets the job done.\n    buf.append('\"');\n    return buf.toString();\n  }\n\n  /**\n   * Pops out of the query string the given parameter.\n   * @param querystring The query string.\n   * @param param The name of the parameter to pop out.\n   * @return {@code null} if the parameter wasn't passed, otherwise the\n   * value of the last occurrence of the parameter.\n   */\n  public static String popParam(final Map<String, List<String>> querystring,\n                                final String param) {\n    final List<String> params = querystring.remove(param);\n    if (params == null) {\n      return null;\n    }\n    String given = params.get(params.size() - 1);\n    if (given != null) {\n      given = URLDecoder.decode(given.trim());\n    }\n    // TODO - far from perfect, should help a little.\n    if (given.contains(\"`\") || given.contains(\"%60\") || \n        given.contains(\"&#96;\")) {\n      throw new BadRequestException(\"Parameter \" + param + \" contained a \"\n          + \"back-tick. That's a no-no.\");\n    }\n    return given;\n  }\n\n  /**\n   * Applies the plot parameters from the query to the given plot.\n   * @param query The query from which to get the query string.\n   * @param plot The plot on which to apply the parameters.\n   */\n  static void setPlotParams(final HttpQuery query, final Plot plot) {\n    final HashMap<String, String> params = new HashMap<String, String>();\n    final Map<String, List<String>> querystring = query.getQueryString();\n    String value;\n    if ((value = popParam(querystring, \"yrange\")) != null) {\n      if (!RANGE_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'yrange' was invalid. \"\n            + \"Must be in the format [min:max].\");\n      }\n      params.put(\"yrange\", value);\n    }\n    if ((value = popParam(querystring, \"y2range\")) != null) {\n      if (!RANGE_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'y2range' was invalid. \"\n            + \"Must be in the format [min:max].\");\n      }\n      params.put(\"y2range\", value);\n    }\n    if ((value = popParam(querystring, \"ylabel\")) != null) {\n      if (!LABEL_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'ylabel' was invalid. Must \"\n            + \"satisfy the pattern \" + LABEL_VALIDATOR.toString());\n      }\n      params.put(\"ylabel\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"y2label\")) != null) {\n      if (!LABEL_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'y2label' was invalid. Must \"\n            + \"satisfy the pattern \" + LABEL_VALIDATOR.toString());\n      }\n      params.put(\"y2label\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"yformat\")) != null) {\n      if (!FORMAT_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'yformat' was invalid. Must \"\n            + \"satisfy the pattern \" + FORMAT_VALIDATOR.toString());\n      }\n      params.put(\"format y\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"y2format\")) != null) {\n      if (!FORMAT_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'y2format' was invalid. Must \"\n            + \"satisfy the pattern \" + FORMAT_VALIDATOR.toString());\n      }\n      params.put(\"format y2\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"xformat\")) != null) {\n      if (!FORMAT_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'xformat' was invalid. Must \"\n            + \"satisfy the pattern \" + FORMAT_VALIDATOR.toString());\n      }\n      params.put(\"format x\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"ylog\")) != null) {\n      params.put(\"logscale y\", \"\");\n    }\n    if ((value = popParam(querystring, \"y2log\")) != null) {\n      params.put(\"logscale y2\", \"\");\n    }\n    if ((value = popParam(querystring, \"key\")) != null) {\n      if (!KEY_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'key' was invalid. Must \"\n            + \"satisfy the pattern \" + KEY_VALIDATOR.toString());\n      }\n      params.put(\"key\", value);\n    }\n    if ((value = popParam(querystring, \"title\")) != null) {\n      if (!LABEL_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'title' was invalid. Must \"\n            + \"satisfy the pattern \" + LABEL_VALIDATOR.toString());\n      }\n      params.put(\"title\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"bgcolor\")) != null) {\n      if (!COLOR_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'bgcolor' was invalid. Must \"\n            + \"be a hex value e.g. 'xFFFFFF'\");\n      }\n      params.put(\"bgcolor\", value);\n    }\n    if ((value = popParam(querystring, \"fgcolor\")) != null) {\n      if (!COLOR_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'fgcolor' was invalid. Must \"\n            + \"be a hex value e.g. 'xFFFFFF'\");\n      }\n      params.put(\"fgcolor\", value);\n    }\n    if ((value = popParam(querystring, \"smooth\")) != null) {\n      if (!SMOOTH_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'smooth' was invalid. Must \"\n            + \"satisfy the pattern \" + SMOOTH_VALIDATOR.toString());\n      }\n      params.put(\"smooth\", value);\n    }\n    if ((value = popParam(querystring, \"style\")) != null) {\n      if (!STYLE_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'style' was invalid. Must \"\n            + \"satisfy the pattern \" + STYLE_VALIDATOR.toString());\n      }\n      params.put(\"style\", value);\n    }\n    // This must remain after the previous `if' in order to properly override\n    // any previous `key' parameter if a `nokey' parameter is given.\n    if ((value = popParam(querystring, \"nokey\")) != null) {\n      params.put(\"key\", null);\n    }\n    plot.setParams(params);\n  }\n\n  /**\n   * Runs Gnuplot in a subprocess to generate the graph.\n   * <strong>This function will block</strong> while Gnuplot is running.\n   * @param query The query being handled (for logging purposes).\n   * @param basepath The base path used for the Gnuplot files.\n   * @param plot The plot object to generate Gnuplot's input files.\n   * @return The number of points plotted by Gnuplot (0 or more).\n   * @throws IOException if the Gnuplot files can't be written, or\n   * the Gnuplot subprocess fails to start, or we can't read the\n   * graph from the file it produces, or if we have been interrupted.\n   * @throws GnuplotException if Gnuplot returns non-zero.\n   */\n  static int runGnuplot(final HttpQuery query,\n                        final String basepath,\n                        final Plot plot) throws IOException {\n    final int nplotted = plot.dumpToFiles(basepath);\n    final long start_time = System.nanoTime();\n    final Process gnuplot = new ProcessBuilder(GNUPLOT,\n      basepath + \".out\", basepath + \".err\", basepath + \".gnuplot\").start();\n    final int rv;\n    try {\n      rv = gnuplot.waitFor();  // Couldn't find how to do this asynchronously.\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();  // Restore the interrupted status.\n      throw new IOException(\"interrupted\", e);  // I hate checked exceptions.\n    } finally {\n      // We need to always destroy() the Process, otherwise we \"leak\" file\n      // descriptors and pipes.  Unless I'm blind, this isn't actually\n      // documented in the Javadoc of the !@#$%^ JDK, and in Java 6 there's no\n      // way to ask the stupid-ass ProcessBuilder to not create fucking pipes.\n      // I think when the GC kicks in the JVM may run some kind of a finalizer\n      // that closes the pipes, because I've never seen this issue on long\n      // running TSDs, except where ulimit -n was low (the default, 1024).\n      gnuplot.destroy();\n    }\n    gnuplotlatency.add((int) ((System.nanoTime() - start_time) / 1000000));\n    if (rv != 0) {\n      final byte[] stderr = readFile(query, new File(basepath + \".err\"),\n                                     4096);\n      // Sometimes Gnuplot will error out but still create the file.\n      new File(basepath + \".png\").delete();\n      if (stderr == null) {\n        throw new GnuplotException(rv);\n      }\n      throw new GnuplotException(new String(stderr));\n    }\n    // Remove the files for stderr/stdout if they're empty.\n    deleteFileIfEmpty(basepath + \".out\");\n    deleteFileIfEmpty(basepath + \".err\");\n    return nplotted;\n  }\n\n  private static void deleteFileIfEmpty(final String path) {\n    final File file = new File(path);\n    if (file.length() <= 0) {\n      file.delete();\n    }\n  }\n\n  /**\n   * Respond to a query that wants the output in ASCII.\n   * <p>\n   * When a query specifies the \"ascii\" query string parameter, we send the\n   * data points back to the client in plain text instead of sending a PNG.\n   * @param query The query we're currently serving.\n   * @param max_age The maximum time (in seconds) we wanna allow clients to\n   * cache the result in case of a cache hit.\n   * @param basepath The base path used for the Gnuplot files.\n   * @param plot The plot object to generate Gnuplot's input files.\n   */\n  private static void respondAsciiQuery(final HttpQuery query,\n                                        final int max_age,\n                                        final String basepath,\n                                        final Plot plot) {\n    final String path = basepath + \".txt\";\n    PrintWriter asciifile;\n    try {\n      asciifile = new PrintWriter(path);\n    } catch (IOException e) {\n      query.internalError(e);\n      return;\n    }\n    try {\n      final StringBuilder tagbuf = new StringBuilder();\n      for (final DataPoints dp : plot.getDataPoints()) {\n        final String metric = dp.metricName();\n        tagbuf.setLength(0);\n        for (final Map.Entry<String, String> tag : dp.getTags().entrySet()) {\n          tagbuf.append(' ').append(tag.getKey())\n            .append('=').append(tag.getValue());\n        }\n        for (final DataPoint d : dp) {\n          if (d.isInteger()) {\n            printMetricHeader(asciifile, metric, d.timestamp());\n            asciifile.print(d.longValue());\n          } else {\n            // Doubles require extra processing.\n            final double value = d.doubleValue();\n\n            // Value might be NaN or infinity.\n            if (Double.isInfinite(value)) {\n              // Infinity is invalid.\n              throw new IllegalStateException(\"Infinity:\" + value\n                + \" d=\" + d + \", query=\" + query);\n            } else if (Double.isNaN(value)) {\n              // NaNs should be skipped.\n              continue;\n            }\n\n            printMetricHeader(asciifile, metric, d.timestamp());\n            asciifile.print(value);\n          }\n\n          asciifile.print(tagbuf);\n          asciifile.print('\\n');\n        }\n      }\n    } finally {\n      asciifile.close();\n    }\n    try {\n      query.sendFile(path, max_age);\n    } catch (IOException e) {\n      query.internalError(e);\n    }\n  }\n\n  /**\n   * Helper method to write metric name and timestamp.\n   * @param writer The writer to which to write.\n   * @param metric The metric name.\n   * @param timestamp The timestamp.\n   */\n  private static void printMetricHeader(final PrintWriter writer, final String metric,\n      final long timestamp) {\n    writer.print(metric);\n    writer.print(' ');\n    writer.print(timestamp / 1000L);\n    writer.print(' ');\n  }\n\n  private static final PlotThdFactory thread_factory = new PlotThdFactory();\n\n  private static final class PlotThdFactory implements ThreadFactory {\n    private final AtomicInteger id = new AtomicInteger(0);\n\n    public Thread newThread(final Runnable r) {\n      return new Thread(r, \"Gnuplot #\" + id.incrementAndGet());\n    }\n  }\n\n  /** Name of the wrapper script we use to execute Gnuplot.  */\n  private static final String WRAPPER =\n    IS_WINDOWS ? \"mygnuplot.bat\" : \"mygnuplot.sh\";\n\n  /** Path to the wrapper script.  */\n  private static final String GNUPLOT;\n  static {\n    GNUPLOT = findGnuplotHelperScript();\n  }\n\n  /**\n   * Iterate through the class path and look for the Gnuplot helper script.\n   * @return The path to the wrapper script.\n   */\n  private static String findGnuplotHelperScript() {\n    if(!GnuplotInstaller.FOUND_GP) {\n      LOG.warn(\"Skipping Gnuplot Shell Script Install since Gnuplot executable was not found\");\n      return null;\n    }\n    if(!GnuplotInstaller.GP_FILE.exists()) {\n      GnuplotInstaller.installMyGnuPlot();\n    }\n    if(GnuplotInstaller.GP_FILE.exists() && GnuplotInstaller.GP_FILE.canExecute()) {\n      LOG.info(\"Auto Installed Gnuplot Invoker at [{}]\", GnuplotInstaller.GP_FILE.getAbsolutePath());\n      return GnuplotInstaller.GP_FILE.getAbsolutePath();\n    }\n    \n    final URL url = GraphHandler.class.getClassLoader().getResource(WRAPPER);\n    if (url == null) {\n      throw new RuntimeException(\"Couldn't find \" + WRAPPER + \" on the\"\n        + \" CLASSPATH: \" + System.getProperty(\"java.class.path\"));\n    }\n    final String path = url.getFile();\n    LOG.debug(\"Using Gnuplot wrapper at {}\", path);\n    final File file = new File(path);\n    final String error;\n    if (!file.exists()) {\n      error = \"non-existent\";\n    } else if (!file.canExecute()) {\n      error = \"non-executable\";\n    } else if (!file.canRead()) {\n      error = \"unreadable\";\n    } else {\n      return path;\n    }\n    throw new RuntimeException(\"The \" + WRAPPER + \" found on the\"\n      + \" CLASSPATH (\" + path + \") is a \" + error + \" file...  WTF?\"\n      + \"  CLASSPATH=\" + System.getProperty(\"java.class.path\"));\n  }\n\n\n  // ---------------- //\n  // Logging helpers. //\n  // ---------------- //\n\n  static void logInfo(final HttpQuery query, final String msg) {\n    LOG.info(query.channel().toString() + ' ' + msg);\n  }\n\n  static void logWarn(final HttpQuery query, final String msg) {\n    LOG.warn(query.channel().toString() + ' ' + msg);\n  }\n\n  static void logError(final HttpQuery query, final String msg) {\n    LOG.error(query.channel().toString() + ' ' + msg);\n  }\n\n  static void logError(final HttpQuery query, final String msg,\n                       final Throwable e) {\n    LOG.error(query.channel().toString() + ' ' + msg, e);\n  }\n\n}\n", "// This file is part of OpenTSDB.\n// Copyright (C) 2011-2021  The OpenTSDB Authors.\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 2.1 of the License, or (at your\n// option) any later version.  This program is distributed in the hope that it\n// will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty\n// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser\n// General Public License for more details.  You should have received a copy\n// of the GNU Lesser General Public License along with this program.  If not,\n// see <http://www.gnu.org/licenses/>.\npackage net.opentsdb.tsd;\n\nimport java.io.File;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jboss.netty.channel.Channel;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport org.powermock.api.mockito.PowerMockito;\nimport org.powermock.core.classloader.annotations.PowerMockIgnore;\nimport org.powermock.core.classloader.annotations.PrepareForTest;\nimport org.powermock.modules.junit4.PowerMockRunner;\nimport org.powermock.reflect.Whitebox;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\n\nimport net.opentsdb.graph.Plot;\n\nimport static org.powermock.api.mockito.PowerMockito.mock;\n\n@RunWith(PowerMockRunner.class)\n// \"Classloader hell\"...  It's real.  Tell PowerMock to ignore these classes\n// because they fiddle with the class loader.  We don't test them anyway.\n@PowerMockIgnore({\"javax.management.*\", \"javax.xml.*\",\n                  \"ch.qos.*\", \"org.slf4j.*\",\n                  \"com.sum.*\", \"org.xml.*\"})\n@PrepareForTest({ GraphHandler.class, HttpQuery.class, Plot.class })\npublic final class TestGraphHandler {\n\n  private final static Method sm;\n  static {\n    try {\n      sm = GraphHandler.class.getDeclaredMethod(\"staleCacheFile\",\n          HttpQuery.class, long.class, long.class, File.class);\n      sm.setAccessible(true);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Failed in static initializer\", e);\n    }\n  }\n  \n  @Test  \n  public void setYRangeParams() throws Exception {\n    assertPlotParam(\"yrange\",\"[0:1]\");\n    assertPlotParam(\"yrange\", \"[:]\");\n    assertPlotParam(\"yrange\", \"[:0]\");\n    assertPlotParam(\"yrange\", \"[:42]\");\n    assertPlotParam(\"yrange\", \"[:-42]\");\n    assertPlotParam(\"yrange\", \"[:0.8]\");\n    assertPlotParam(\"yrange\", \"[:-0.8]\");\n    assertPlotParam(\"yrange\", \"[:42.4]\");\n    assertPlotParam(\"yrange\", \"[:-42.4]\");\n    assertPlotParam(\"yrange\", \"[:4e4]\");\n    assertPlotParam(\"yrange\", \"[:-4e4]\");\n    assertPlotParam(\"yrange\", \"[:4e-4]\");\n    assertPlotParam(\"yrange\", \"[:-4e-4]\");\n    assertPlotParam(\"yrange\", \"[:4.2e4]\");\n    assertPlotParam(\"yrange\", \"[:-4.2e4]\");\n    assertPlotParam(\"yrange\", \"[0:]\");\n    assertPlotParam(\"yrange\", \"[5:]\");\n    assertPlotParam(\"yrange\", \"[-5:]\");\n    assertPlotParam(\"yrange\", \"[0.5:]\");\n    assertPlotParam(\"yrange\", \"[-0.5:]\");\n    assertPlotParam(\"yrange\", \"[10.5:]\");\n    assertPlotParam(\"yrange\", \"[-10.5:]\");\n    assertPlotParam(\"yrange\", \"[10e5:]\");\n    assertPlotParam(\"yrange\", \"[-10e5:]\");\n    assertPlotParam(\"yrange\", \"[10e-5:]\");\n    assertPlotParam(\"yrange\", \"[-10e-5:]\");\n    assertPlotParam(\"yrange\", \"[10.1e-5:]\");\n    assertPlotParam(\"yrange\", \"[-10.1e-5:]\");\n    assertPlotParam(\"yrange\", \"[-10.1e-5:-10.1e-6]\");\n    assertInvalidPlotParam(\"yrange\", \"[33:system('touch /tmp/poc.txt')]\");\n  }\n\n  @Test\n  public void setKeyParams() throws Exception {\n    assertPlotParam(\"key\", \"out\");\n    assertPlotParam(\"key\", \"left\");\n    assertPlotParam(\"key\", \"top\");\n    assertPlotParam(\"key\", \"center\");\n    assertPlotParam(\"key\", \"right\");\n    assertPlotParam(\"key\", \"horiz\");\n    assertPlotParam(\"key\", \"box\");\n    assertPlotParam(\"key\", \"bottom\");\n    assertInvalidPlotParam(\"yrange\", \"out%20right%20top%0aset%20yrange%20[33:system(%20\");\n  }\n\n  @Test\n  public void setStyleParams() throws Exception {\n    assertPlotParam(\"style\", \"linespoint\");\n    assertPlotParam(\"style\", \"points\");\n    assertPlotParam(\"style\", \"circles\");\n    assertPlotParam(\"style\", \"dots\");\n    assertInvalidPlotParam(\"style\", \"dots%20[33:system(%20\");\n  }\n\n  @Test\n  public void setLabelParams() throws Exception {\n    assertPlotParam(\"ylabel\", \"This is good\");\n    assertPlotParam(\"ylabel\", \" and so Is this - _ yay\");\n    assertInvalidPlotParam(\"ylabel\", \"[33:system(%20\");\n    assertInvalidPlotParam(\"title\", \"[33:system(%20\");\n    assertInvalidPlotParam(\"y2label\", \"[33:system(%20\");\n  }\n\n  @Test\n  public void setColorParams() throws Exception {\n    assertPlotParam(\"bgcolor\", \"x000000\");\n    assertPlotParam(\"bgcolor\", \"XDEADBE\");\n    assertPlotParam(\"bgcolor\", \"%58DEADBE\");\n    assertInvalidPlotParam(\"bgcolor\", \"XDEADBEF\");\n    assertInvalidPlotParam(\"bgcolor\", \"%5BDEADBE\");\n\n    assertPlotParam(\"fgcolor\", \"x000000\");\n    assertPlotParam(\"fgcolor\", \"XDEADBE\");\n    assertPlotParam(\"fgcolor\", \"%58DEADBE\");\n    assertInvalidPlotParam(\"fgcolor\", \"XDEADBEF\");\n    assertInvalidPlotParam(\"fgcolor\", \"%5BDEADBE\");\n  }\n\n  @Test\n  public void setSmoothParams() throws Exception {\n    assertPlotParam(\"smooth\", \"unique\");\n    assertPlotParam(\"smooth\", \"frequency\");\n    assertPlotParam(\"smooth\", \"fnormal\");\n    assertPlotParam(\"smooth\", \"cumulative\");\n    assertPlotParam(\"smooth\", \"cnormal\");\n    assertPlotParam(\"smooth\", \"bins\");\n    assertPlotParam(\"smooth\", \"csplines\");\n    assertPlotParam(\"smooth\", \"acsplines\");\n    assertPlotParam(\"smooth\", \"mcsplines\");\n    assertPlotParam(\"smooth\", \"bezier\");\n    assertPlotParam(\"smooth\", \"sbezier\");\n    assertPlotParam(\"smooth\", \"unwrap\");\n    assertPlotParam(\"smooth\", \"zsort\");\n    assertInvalidPlotParam(\"smooth\", \"[33:system(%20\");\n  }\n\n  @Test\n  public void setFormatParams() throws Exception {\n    assertPlotParam(\"yformat\", \"%25.2f\");\n    assertPlotParam(\"y2format\", \"%25.2f\");\n    assertPlotParam(\"xformat\", \"%25.2f\");\n    assertPlotParam(\"yformat\", \"%253.0em\");\n    assertPlotParam(\"yformat\", \"%253.0em%25%25\");\n    assertPlotParam(\"yformat\", \"%25.2f seconds\");\n    assertPlotParam(\"yformat\", \"%25.0f ms\");\n    assertInvalidPlotParam(\"yformat\", \"%252.[33:system\");\n  }\n\n  @Test  // If the file doesn't exist, we don't use it, obviously.\n  public void staleCacheFileDoesntExist() throws Exception {\n    final File cachedfile = fakeFile(\"/cache/fake-file\");\n    // From the JDK manual: \"returns 0L if the file does not exist\n    // or if an I/O error occurs\"\n    when(cachedfile.lastModified()).thenReturn(0L);\n\n    assertTrue(\"File is stale\", staleCacheFile(null, 0, 10, cachedfile));\n\n    verify(cachedfile).lastModified();  // Ensure we do a single stat() call.\n  }\n\n  @Test  // If the mtime of a file is in the future, we don't use it.\n  public void staleCacheFileInTheFuture() throws Exception {\n    PowerMockito.mockStatic(System.class);\n\n    final HttpQuery query = fakeHttpQuery();\n    final File cachedfile = fakeFile(\"/cache/fake-file\");\n\n    final long now = 1000L;\n    when(System.currentTimeMillis()).thenReturn(now);\n    when(cachedfile.lastModified()).thenReturn(now + 1000L);\n    final long end_time = now;\n\n    assertTrue(\"File is stale\",\n               staleCacheFile(query, end_time, 10, cachedfile));\n\n    verify(cachedfile).lastModified();  // Ensure we do a single stat() call.\n    PowerMockito.verifyStatic(); // Verify that ...\n    System.currentTimeMillis();  // ... this was called only once.\n  }\n\n//  @Test  // End time in the future => OK to serve stale file up to max_age.\n//  public void staleCacheFileEndTimeInFuture() throws Exception {\n//    PowerMockito.mockStatic(System.class);\n//\n//    final HttpQuery query = fakeHttpQuery();\n//    final File cachedfile = fakeFile(\"/cache/fake-file\");\n//\n//    final long end_time = 20000L;\n//    when(System.currentTimeMillis()).thenReturn(10000L);\n//    when(cachedfile.lastModified()).thenReturn(8000L);\n//\n//    assertFalse(\"File is not more than 3s stale\",\n//                staleCacheFile(query, end_time, 3, cachedfile));\n//    assertFalse(\"File is more than 2s stale\",\n//               staleCacheFile(query, end_time, 2, cachedfile));\n//    assertTrue(\"File is more than 1s stale\",\n//               staleCacheFile(query, end_time, 1, cachedfile));\n//\n//    // Ensure that we stat() the file and look at the current time once per\n//    // invocation of staleCacheFile().\n//    verify(cachedfile, times(3)).lastModified();\n//    PowerMockito.verifyStatic(times(3));\n//    System.currentTimeMillis();\n//  }\n\n//  @Test  // No end time = end time is now.\n//  public void staleCacheFileEndTimeIsNow() throws Exception {\n//    PowerMockito.mockStatic(System.class);\n//\n//    final HttpQuery query = fakeHttpQuery();\n//    final File cachedfile = fakeFile(\"/cache/fake-file\");\n//\n//    final long now = 10000L;\n//    final long end_time = now;\n//    when(System.currentTimeMillis()).thenReturn(now);\n//    when(cachedfile.lastModified()).thenReturn(8000L);\n//\n//    assertFalse(\"File is not more than 3s stale\",\n//                staleCacheFile(query, end_time, 3, cachedfile));\n//    assertFalse(\"File is more than 2s stale\",\n//               staleCacheFile(query, end_time, 2, cachedfile));\n//    assertTrue(\"File is more than 1s stale\",\n//               staleCacheFile(query, end_time, 1, cachedfile));\n//\n//    // Ensure that we stat() the file and look at the current time once per\n//    // invocation of staleCacheFile().\n//    verify(cachedfile, times(3)).lastModified();\n//    PowerMockito.verifyStatic(times(3));\n//    System.currentTimeMillis();\n//  }\n\n  @Test  // End time in the past, file's mtime predates it.\n  public void staleCacheFileEndTimeInPastOlderFile() throws Exception {\n    PowerMockito.mockStatic(System.class);\n\n    final HttpQuery query = fakeHttpQuery();\n    final File cachedfile = fakeFile(\"/cache/fake-file\");\n\n    final long end_time = 8000L;\n    final long now = end_time + 2000L;\n    when(System.currentTimeMillis()).thenReturn(now);\n    when(cachedfile.lastModified()).thenReturn(5000L);\n\n    assertTrue(\"File predates end-time and cannot be re-used\",\n               staleCacheFile(query, end_time, 4, cachedfile));\n\n    verify(cachedfile).lastModified();  // Ensure we do a single stat() call.\n    PowerMockito.verifyStatic(); // Verify that ...\n    System.currentTimeMillis();  // ... this was called only once.\n  }\n\n//  @Test  // End time in the past, file's mtime is after it.\n//  public void staleCacheFileEndTimeInPastCacheableFile() throws Exception {\n//    PowerMockito.mockStatic(System.class);\n//\n//    final HttpQuery query = fakeHttpQuery();\n//    final File cachedfile = fakeFile(\"/cache/fake-file\");\n//\n//    final long end_time = 8000L;\n//    final long now = end_time + 2000L;\n//    when(System.currentTimeMillis()).thenReturn(now);\n//    when(cachedfile.lastModified()).thenReturn(end_time + 1000L);\n//\n//    assertFalse(\"File was created after end-time and can be re-used\",\n//               staleCacheFile(query, end_time, 1, cachedfile));\n//\n//    verify(cachedfile).lastModified();  // Ensure we do a single stat() call.\n//    PowerMockito.verifyStatic(); // Verify that ...\n//    System.currentTimeMillis();  // ... this was called only once.\n//  }\n\n  /**\n   * Helper to call private static method.\n   * There's one slight difference: the {@code end_time} parameter is in\n   * milliseconds here, instead of seconds.\n   */\n  private static boolean staleCacheFile(final HttpQuery query,\n                                        final long end_time,\n                                        final long max_age,\n                                        final File cachedfile) throws Exception {\n    PowerMockito.mockStatic(System.class);\n    PowerMockito.when(System.getProperty(anyString(), anyString())).thenReturn(\"\");\n    PowerMockito.when(System.getProperty(anyString())).thenReturn(\"\");\n    PowerMockito.spy(GraphHandler.class);\n    PowerMockito.doReturn(\"\").when(GraphHandler.class, \"findGnuplotHelperScript\");\n    \n    return Whitebox.<Boolean>invokeMethod(GraphHandler.class, \"staleCacheFile\",\n                                          query, end_time / 1000, max_age,\n                                          cachedfile);\n    \n    //return (Boolean)sm.invoke(null, query, end_time / 1000, max_age, cachedfile);\n  }\n\n  private static HttpQuery fakeHttpQuery() {\n    final HttpQuery query = mock(HttpQuery.class);\n    final Channel chan = NettyMocks.fakeChannel();\n    when(query.channel()).thenReturn(chan);\n    return query;\n  }\n\n  private static File fakeFile(final String path) {\n    final File file = mock(File.class);\n    when(file.getPath()).thenReturn(path);\n    when(file.toString()).thenReturn(path);\n    return file;\n  }\n\n  private static void assertPlotParam(String param, String value) {\n    Plot plot = mock(Plot.class);\n    HttpQuery query = mock(HttpQuery.class);\n    Map<String, List<String>> params = Maps.newHashMap();\n    when(query.getQueryString()).thenReturn(params);\n\n    params.put(param, Lists.newArrayList(value));\n    GraphHandler.setPlotParams(query, plot);\n  }\n\n  private static void assertInvalidPlotParam(String param, String value) {\n    Plot plot = mock(Plot.class);\n    HttpQuery query = mock(HttpQuery.class);\n    Map<String, List<String>> params = Maps.newHashMap();\n    when(query.getQueryString()).thenReturn(params);\n\n    params.put(param, Lists.newArrayList(value));\n    try {\n      GraphHandler.setPlotParams(query, plot);\n      fail(\"Expected BadRequestException\");\n    } catch (BadRequestException e) { }\n  }\n\n}\n"], "fixing_code": ["// This file is part of OpenTSDB.\n// Copyright (C) 2010-2021  The OpenTSDB Authors.\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 2.1 of the License, or (at your\n// option) any later version.  This program is distributed in the hope that it\n// will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty\n// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser\n// General Public License for more details.  You should have received a copy\n// of the GNU Lesser General Public License along with this program.  If not,\n// see <http://www.gnu.org/licenses/>.\npackage net.opentsdb.tsd;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ArrayBlockingQueue;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.regex.Pattern;\n\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\n\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Sets;\n\nimport net.opentsdb.core.*;\nimport net.opentsdb.core.Const;\nimport net.opentsdb.core.DataPoint;\nimport net.opentsdb.core.DataPoints;\nimport net.opentsdb.core.Query;\nimport net.opentsdb.core.TSDB;\nimport net.opentsdb.core.TSQuery;\nimport net.opentsdb.core.Tags;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport net.opentsdb.graph.Plot;\nimport net.opentsdb.meta.Annotation;\nimport net.opentsdb.stats.Histogram;\nimport net.opentsdb.stats.StatsCollector;\nimport net.opentsdb.tools.GnuplotInstaller;\nimport net.opentsdb.utils.DateTime;\nimport net.opentsdb.utils.JSON;\n\nimport com.stumbleupon.async.Callback;\n\n/**\n * Stateless handler of HTTP graph requests (the {@code /q} endpoint).\n */\nfinal class GraphHandler implements HttpRpc {\n\n  private static final Logger LOG =\n    LoggerFactory.getLogger(GraphHandler.class);\n\n  private static final boolean IS_WINDOWS =\n    System.getProperty(\"os.name\", \"\").contains(\"Windows\");\n\n  private static final String RANGE_COMPONENT = \"\\\\\\\"?-?\\\\d*\\\\.?(\\\\d+)?([eE]-?\\\\d+)?\\\\\\\"?\";\n  private static Pattern RANGE_VALIDATOR = Pattern.compile(\n      \"^\\\\[\"+RANGE_COMPONENT+\":\"+RANGE_COMPONENT+\"]$\");\n  private static Pattern LABEL_VALIDATOR = Pattern.compile(\"^[a-zA-z0-9 \\\\-_]+$\");\n  private static Pattern KEY_VALIDATOR = Pattern.compile(\n      \"^out|left|top|center|right|horiz|box|bottom$\");\n  private static Pattern STYLE_VALIDATOR = Pattern.compile(\"^linespoint|points|circles|dots$\");\n  private static Pattern COLOR_VALIDATOR = Pattern.compile(\"^(x|X)[a-fA-F0-9]{6}$\");\n  private static Pattern SMOOTH_VALIDATOR = Pattern.compile(\"^unique|frequency|fnormal|cumulative|cnormal|bins|csplines|acsplines|mcsplines|bezier|sbezier|unwrap|zsort$\");\n  // NOTE: This one should be tightened for only time based formatters.\n  private static Pattern FORMAT_VALIDATOR = Pattern.compile(\"^[%0-9.a-zA-Z \\\\-]+$\");\n  private static Pattern WXH_VALIDATOR = Pattern.compile(\"^\\\\d+x\\\\d+$\");\n  /** Number of times we had to do all the work up to running Gnuplot. */\n  private static final AtomicInteger graphs_generated\n    = new AtomicInteger();\n  /** Number of times a graph request was served from disk, no work needed. */\n  private static final AtomicInteger graphs_diskcache_hit\n    = new AtomicInteger();\n\n  /** Keep track of the latency of graphing requests. */\n  private static final Histogram graphlatency =\n    new Histogram(16000, (short) 2, 100);\n\n  /** Keep track of the latency (in ms) introduced by running Gnuplot. */\n  private static final Histogram gnuplotlatency =\n    new Histogram(16000, (short) 2, 100);\n\n  /** Executor to run Gnuplot in separate bounded thread pool. */\n  private final ThreadPoolExecutor gnuplot;\n\n  /**\n   * Constructor.\n   */\n  public GraphHandler() {\n    // Gnuplot is mostly CPU bound and does only a little bit of IO at the\n    // beginning to read the input data and at the end to write its output.\n    // We want to avoid running too many Gnuplot instances concurrently as\n    // it can steal a significant number of CPU cycles from us.  Instead, we\n    // allow only one per core, and we nice it (the nicing is done in the\n    // shell script we use to start Gnuplot).  Similarly, the queue we use\n    // is sized so as to have a fixed backlog per core.\n    final int ncores = Runtime.getRuntime().availableProcessors();\n    gnuplot = new ThreadPoolExecutor(\n      ncores, ncores,  // Thread pool of a fixed size.\n      /* 5m = */ 300000, MILLISECONDS,        // How long to keep idle threads.\n      new ArrayBlockingQueue<Runnable>(20 * ncores),  // XXX Don't hardcode?\n      thread_factory);\n    // ArrayBlockingQueue does not scale as much as LinkedBlockingQueue in terms\n    // of throughput but we don't need high throughput here.  We use ABQ instead\n    // of LBQ because it creates far fewer references.\n  }\n\n  public void execute(final TSDB tsdb, final HttpQuery query) {\n    if (!query.hasQueryStringParam(\"json\")\n        && !query.hasQueryStringParam(\"png\")\n        && !query.hasQueryStringParam(\"ascii\")) {\n      String uri = query.request().getUri();\n      if (uri.length() < 4) {  // Shouldn't happen...\n        uri = \"/\";             // But just in case, redirect.\n      } else {\n        uri = \"/#\" + uri.substring(3);  // Remove \"/q?\"\n      }\n      query.redirect(uri);\n      return;\n    }\n    try {\n      doGraph(tsdb, query);\n    } catch (IOException e) {\n      query.internalError(e);\n    } catch (IllegalArgumentException e) {\n      query.badRequest(e.getMessage());\n    }\n  }\n\n  // TODO(HugoMFernandes): Most of this (query-related) logic is implemented in\n  // net.opentsdb.tsd.QueryRpc.java (which actually does this asynchronously),\n  // so we should refactor both classes to split the actual logic used to\n  // generate the data from the actual visualization (removing all duped code).\n  private void doGraph(final TSDB tsdb, final HttpQuery query)\n    throws IOException {\n    final String basepath = getGnuplotBasePath(tsdb, query);\n    long start_time = DateTime.parseDateTimeString(\n      query.getRequiredQueryStringParam(\"start\"),\n      query.getQueryStringParam(\"tz\"));\n    final boolean nocache = query.hasQueryStringParam(\"nocache\");\n    if (start_time == -1) {\n      throw BadRequestException.missingParameter(\"start\");\n    } else {\n      // temp fixup to seconds from ms until the rest of TSDB supports ms\n      // Note you can't append this to the DateTime.parseDateTimeString() call as\n      // it clobbers -1 results\n      start_time /= 1000;\n    }\n    long end_time = DateTime.parseDateTimeString(\n        query.getQueryStringParam(\"end\"),\n        query.getQueryStringParam(\"tz\"));\n    final long now = System.currentTimeMillis() / 1000;\n    if (end_time == -1) {\n      end_time = now;\n    } else {\n      // temp fixup to seconds from ms until the rest of TSDB supports ms\n      // Note you can't append this to the DateTime.parseDateTimeString() call as\n      // it clobbers -1 results\n      end_time /= 1000;\n    }\n    final int max_age = computeMaxAge(query, start_time, end_time, now);\n    if (!nocache && isDiskCacheHit(query, end_time, max_age, basepath)) {\n      return;\n    }\n\n    // Parse TSQuery from HTTP query\n    final TSQuery tsquery = QueryRpc.parseQuery(tsdb, query);\n    tsquery.validateAndSetQuery();\n\n    // Build the queries for the parsed TSQuery\n    Query[] tsdbqueries = tsquery.buildQueries(tsdb);\n\n    List<String> options = null;\n    final String options_allow_list = tsdb.getConfig().getString(\n        \"tsd.gnuplot.options.allowlist\");\n    if (!Strings.isNullOrEmpty(options_allow_list)) {\n      String[] allow_list_strings = options_allow_list.split(\";\");\n      Set<String> allow_list = Sets.newHashSet();\n      for (int i = 0; i < allow_list_strings.length; i++) {\n        String allow = allow_list_strings[i];\n        if (allow != null) {\n          allow = URLDecoder.decode(allow.trim());\n          allow_list.add(allow);\n        }\n      }\n      \n      options = query.getQueryStringParams(\"o\");\n      for (int i = 0; i < options.size(); i++) {\n        if (!allow_list.contains(options.get(i))) {\n          throw new BadRequestException(\"Query option at index \" + i \n              + \" was not in the allow list.\");\n        }\n      }\n    }\n    \n    if (options == null) {\n      options = new ArrayList<String>(tsdbqueries.length);\n      for (int i = 0; i < tsdbqueries.length; i++) {\n        options.add(\"\");\n      }\n    } else if (options.size() != tsdbqueries.length) {\n      throw new BadRequestException(options.size() + \" `o' parameters, but \"\n        + tsdbqueries.length + \" `m' parameters.\");\n    }\n    for (final Query tsdbquery : tsdbqueries) {\n      try {\n        tsdbquery.setStartTime(start_time);\n      } catch (IllegalArgumentException e) {\n        throw new BadRequestException(\"start time: \" + e.getMessage());\n      }\n      try {\n        tsdbquery.setEndTime(end_time);\n      } catch (IllegalArgumentException e) {\n        throw new BadRequestException(\"end time: \" + e.getMessage());\n      }\n    }\n    final Plot plot = new Plot(start_time, end_time,\n          DateTime.timezones.get(query.getQueryStringParam(\"tz\")));\n    setPlotDimensions(query, plot);\n    setPlotParams(query, plot);\n    final int nqueries = tsdbqueries.length;\n    @SuppressWarnings(\"unchecked\")\n    final HashSet<String>[] aggregated_tags = new HashSet[nqueries];\n    int npoints = 0;\n    for (int i = 0; i < nqueries; i++) {\n      try {  // execute the TSDB query!\n        // XXX This is slow and will block Netty.  TODO(tsuna): Don't block.\n        // TODO(tsuna): Optimization: run each query in parallel.\n        final DataPoints[] series = tsdbqueries[i].run();\n        for (final DataPoints datapoints : series) {\n          plot.add(datapoints, options.get(i));\n          aggregated_tags[i] = new HashSet<String>();\n          aggregated_tags[i].addAll(datapoints.getAggregatedTags());\n          npoints += datapoints.aggregatedSize();\n        }\n      } catch (RuntimeException e) {\n        logInfo(query, \"Query failed (stack trace coming): \"\n                + tsdbqueries[i]);\n        throw e;\n      }\n      tsdbqueries[i] = null;  // free()\n    }\n    tsdbqueries = null;  // free()\n\n    if (query.hasQueryStringParam(\"ascii\")) {\n      respondAsciiQuery(query, max_age, basepath, plot);\n      return;\n    }\n\n    final RunGnuplot rungnuplot = new RunGnuplot(query, max_age, plot, basepath,\n            aggregated_tags, npoints);\n\n    class ErrorCB implements Callback<Object, Exception> {\n      public Object call(final Exception e) throws Exception {\n        LOG.warn(\"Failed to retrieve global annotations: \", e);\n        throw e;\n      }\n    }\n\n    class GlobalCB implements Callback<Object, List<Annotation>> {\n      public Object call(final List<Annotation> global_annotations) throws Exception {\n        rungnuplot.plot.setGlobals(global_annotations);\n        execGnuplot(rungnuplot, query);\n\n        return null;\n      }\n    }\n\n    // Fetch global annotations, if needed\n    if (!tsquery.getNoAnnotations() && tsquery.getGlobalAnnotations()) {\n      Annotation.getGlobalAnnotations(tsdb, start_time, end_time)\n              .addCallback(new GlobalCB()).addErrback(new ErrorCB());\n    } else {\n      execGnuplot(rungnuplot, query);\n    }\n  }\n\n  private void execGnuplot(RunGnuplot rungnuplot, HttpQuery query) {\n    try {\n      gnuplot.execute(rungnuplot);\n    } catch (RejectedExecutionException e) {\n      query.internalError(new Exception(\"Too many requests pending,\"\n                                        + \" please try again later\", e));\n    }\n  }\n\n  /**\n   * Decides how long we're going to allow the client to cache our response.\n   * <p>\n   * Based on the query, we'll decide whether or not we want to allow the\n   * client to cache our response and for how long.\n   * @param query The query to serve.\n   * @param start_time The start time on the query (32-bit unsigned int, secs).\n   * @param end_time The end time on the query (32-bit unsigned int, seconds).\n   * @param now The current time (32-bit unsigned int, seconds).\n   * @return A positive integer, in seconds.\n   */\n  private static int computeMaxAge(final HttpQuery query,\n                                   final long start_time, final long end_time,\n                                   final long now) {\n    // If the end time is in the future (1), make the graph uncacheable.\n    // Otherwise, if the end time is far enough in the past (2) such that\n    // no TSD can still be writing to rows for that time span and it's not\n    // specified in a relative fashion (3) (e.g. \"1d-ago\"), make the graph\n    // cacheable for a day since it's very unlikely that any data will change\n    // for this time span.\n    // Otherwise (4), allow the client to cache the graph for ~0.1% of the\n    // time span covered by the request e.g., for 1h of data, it's OK to\n    // serve something 3s stale, for 1d of data, 84s stale.\n    if (end_time > now) {                            // (1)\n      return 0;\n    } else if (end_time < now - Const.MAX_TIMESPAN   // (2)\n               && !DateTime.isRelativeDate(\n                   query.getQueryStringParam(\"start\"))    // (3)\n               && !DateTime.isRelativeDate(\n                   query.getQueryStringParam(\"end\"))) {\n      return 86400;\n    } else {                                         // (4)\n      return (int) (end_time - start_time) >> 10;\n    }\n  }\n\n  // Runs Gnuplot in a subprocess to generate the graph.\n  private static final class RunGnuplot implements Runnable {\n\n    private final HttpQuery query;\n    private final int max_age;\n    private final Plot plot;\n    private final String basepath;\n    private final HashSet<String>[] aggregated_tags;\n    private final int npoints;\n\n    public RunGnuplot(final HttpQuery query,\n                      final int max_age,\n                      final Plot plot,\n                      final String basepath,\n                      final HashSet<String>[] aggregated_tags,\n                      final int npoints) {\n      this.query = query;\n      this.max_age = max_age;\n      this.plot = plot;\n      if (IS_WINDOWS)\n        this.basepath = basepath.replace(\"\\\\\", \"\\\\\\\\\").replace(\"/\", \"\\\\\\\\\");\n      else\n        this.basepath = basepath;\n      this.aggregated_tags = aggregated_tags;\n      this.npoints = npoints;\n    }\n\n    public void run() {\n      try {\n        execute();\n      } catch (BadRequestException e) {\n        query.badRequest(e.getMessage());\n      } catch (GnuplotException e) {\n        query.badRequest(\"<pre>\" + e.getMessage() + \"</pre>\");\n      } catch (RuntimeException e) {\n        query.internalError(e);\n      } catch (IOException e) {\n        query.internalError(e);\n      }\n    }\n\n    private void execute() throws IOException {\n      final int nplotted = runGnuplot(query, basepath, plot);\n      if (query.hasQueryStringParam(\"json\")) {\n        final HashMap<String, Object> results = new HashMap<String, Object>();\n        results.put(\"plotted\", nplotted);\n        results.put(\"points\", npoints);\n        // 1.0 returned an empty inner array if the 1st hashset was null, to do\n        // the same we need to fudge it with an empty set\n        if (aggregated_tags != null && aggregated_tags.length > 0 &&\n            aggregated_tags[0] == null) {\n          aggregated_tags[0] = new HashSet<String>();\n        }\n        results.put(\"etags\", aggregated_tags);\n        results.put(\"timing\", query.processingTimeMillis());\n        query.sendReply(JSON.serializeToBytes(results));\n        writeFile(query, basepath + \".json\", JSON.serializeToBytes(results));\n      } else if (query.hasQueryStringParam(\"png\")) {\n        query.sendFile(basepath + \".png\", max_age);\n      } else {\n        query.internalError(new Exception(\"Should never be here!\"));\n      }\n\n      // TODO(tsuna): Expire old files from the on-disk cache.\n      graphlatency.add(query.processingTimeMillis());\n      graphs_generated.incrementAndGet();\n    }\n\n  }\n\n  /** Shuts down the thread pool used to run Gnuplot.  */\n  public void shutdown() {\n    gnuplot.shutdown();\n  }\n\n  /**\n   * Collects the stats and metrics tracked by this instance.\n   * @param collector The collector to use.\n   */\n  public static void collectStats(final StatsCollector collector) {\n    collector.record(\"http.latency\", graphlatency, \"type=graph\");\n    collector.record(\"http.latency\", gnuplotlatency, \"type=gnuplot\");\n    collector.record(\"http.graph.requests\", graphs_diskcache_hit, \"cache=disk\");\n    collector.record(\"http.graph.requests\", graphs_generated, \"cache=miss\");\n  }\n\n  /** Returns the base path to use for the Gnuplot files. */\n  private String getGnuplotBasePath(final TSDB tsdb, final HttpQuery query) {\n    final Map<String, List<String>> q = query.getQueryString();\n    q.remove(\"ignore\");\n    // Super cheap caching mechanism: hash the query string.\n    final HashMap<String, List<String>> qs =\n      new HashMap<String, List<String>>(q);\n    // But first remove the parameters that don't influence the output.\n    qs.remove(\"png\");\n    qs.remove(\"json\");\n    qs.remove(\"ascii\");\n    return tsdb.getConfig().getDirectoryName(\"tsd.http.cachedir\") +\n        Integer.toHexString(qs.hashCode());\n  }\n\n  /**\n   * Checks whether or not it's possible to re-serve this query from disk.\n   * @param query The query to serve.\n   * @param end_time The end time on the query (32-bit unsigned int, seconds).\n   * @param max_age The maximum time (in seconds) we wanna allow clients to\n   * cache the result in case of a cache hit.\n   * @param basepath The base path used for the Gnuplot files.\n   * @return {@code true} if this request was served from disk (in which\n   * case processing can stop here), {@code false} otherwise (in which case\n   * the query needs to be processed).\n   */\n  private boolean isDiskCacheHit(final HttpQuery query,\n                                 final long end_time,\n                                 final int max_age,\n                                 final String basepath) throws IOException {\n    final String cachepath = basepath + (query.hasQueryStringParam(\"ascii\")\n                                         ? \".txt\" : \".png\");\n    final File cachedfile = new File(cachepath);\n    if (cachedfile.exists()) {\n      final long bytes = cachedfile.length();\n      if (bytes < 21) {  // Minimum possible size for a PNG: 21 bytes.\n                         // For .txt files, <21 bytes is almost impossible.\n        logWarn(query, \"Cached \" + cachepath + \" is too small (\"\n                + bytes + \" bytes) to be valid.  Ignoring it.\");\n        return false;\n      }\n      if (staleCacheFile(query, end_time, max_age, cachedfile)) {\n        return false;\n      }\n      if (query.hasQueryStringParam(\"json\")) {\n        HashMap<String, Object> map = loadCachedJson(query, end_time,\n            max_age, basepath);\n        if (map == null) {\n          map = new HashMap<String, Object>();\n        }\n        map.put(\"timing\", query.processingTimeMillis());\n        map.put(\"cachehit\", \"disk\");\n        query.sendReply(JSON.serializeToBytes(map));\n      } else if (query.hasQueryStringParam(\"png\")\n                 || query.hasQueryStringParam(\"ascii\")) {\n        query.sendFile(cachepath, max_age);\n      } else {\n        query.sendReply(HttpQuery.makePage(\"TSDB Query\", \"Your graph is ready\",\n            \"<img src=\\\"\" + query.request().getUri() + \"&amp;png\\\"/><br/>\"\n            + \"<small>(served from disk cache)</small>\"));\n      }\n      graphs_diskcache_hit.incrementAndGet();\n      return true;\n    }\n    // We didn't find an image.  Do a negative cache check.  If we've seen\n    // this query before but there was no result, we at least wrote the JSON.\n    final HashMap<String, Object> map = loadCachedJson(query, end_time,\n        max_age, basepath);\n    // If we don't have a JSON file it's a complete cache miss.  If we have\n    // one, and it says 0 data points were plotted, it's a negative cache hit.\n    if (map == null || !map.containsKey(\"plotted\") ||\n        ((Integer)map.get(\"plotted\")) == 0) {\n      return false;\n    }\n    if (query.hasQueryStringParam(\"json\")) {\n      map.put(\"timing\", query.processingTimeMillis());\n      map.put(\"cachehit\", \"disk\");\n      query.sendReply(JSON.serializeToBytes(map));\n    } else if (query.hasQueryStringParam(\"png\")) {\n      query.sendReply(\" \");  // Send back an empty response...\n    } else {\n        query.sendReply(HttpQuery.makePage(\"TSDB Query\", \"No results\",\n            \"Sorry, your query didn't return anything.<br/>\"\n            + \"<small>(served from disk cache)</small>\"));\n    }\n    graphs_diskcache_hit.incrementAndGet();\n    return true;\n  }\n\n  /**\n   * Returns whether or not the given cache file can be used or is stale.\n   * @param query The query to serve.\n   * @param end_time The end time on the query (32-bit unsigned int, seconds).\n   * @param max_age The maximum time (in seconds) we wanna allow clients to\n   * cache the result in case of a cache hit.  If the file is exactly that\n   * old, it is not considered stale.\n   * @param cachedfile The file to check for staleness.\n   */\n  private static boolean staleCacheFile(final HttpQuery query,\n                                        final long end_time,\n                                        final long max_age,\n                                        final File cachedfile) {\n    final long mtime = cachedfile.lastModified() / 1000;\n    if (mtime <= 0) {\n      return true;  // File doesn't exist, or can't be read.\n    }\n\n    final long now = System.currentTimeMillis() / 1000;\n    // How old is the cached file, in seconds?\n    final long staleness = now - mtime;\n    if (staleness < 0) {  // Can happen if the mtime is \"in the future\".\n      logWarn(query, \"Not using file @ \" + cachedfile + \" with weird\"\n              + \" mtime in the future: \" + mtime);\n      return true;  // Play it safe, pretend we can't use this file.\n    }\n\n    // Case 1: The end time is an absolute point in the past.\n    // We might be able to re-use the cached file.\n    if (0 < end_time && end_time < now) {\n      // If the file was created prior to the end time, maybe we first\n      // executed this query while the result was uncacheable.  We can\n      // tell by looking at the mtime on the file.  If the file was created\n      // before the query end time, then it contains partial results that\n      // shouldn't be served again.\n      return mtime < end_time;\n    }\n\n    // Case 2: The end time of the query is now or in the future.\n    // The cached file contains partial data and can only be re-used if it's\n    // not too old.\n    if (staleness > max_age) {\n      logInfo(query, \"Cached file @ \" + cachedfile.getPath() + \" is \"\n              + staleness + \"s stale, which is more than its limit of \"\n              + max_age + \"s, and needs to be regenerated.\");\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Writes the given byte array into a file.\n   * This function logs an error but doesn't throw if it fails.\n   * @param query The query being handled (for logging purposes).\n   * @param path The path to write to.\n   * @param contents The contents to write into the file.\n   */\n  private static void writeFile(final HttpQuery query,\n                                final String path,\n                                final byte[] contents) {\n    try {\n      final FileOutputStream out = new FileOutputStream(path);\n      try {\n        out.write(contents);\n      } finally {\n        out.close();\n      }\n    } catch (FileNotFoundException e) {\n      logError(query, \"Failed to create file \" + path, e);\n    } catch (IOException e) {\n      logError(query, \"Failed to write file \" + path, e);\n    }\n  }\n\n  /**\n   * Reads a file into a byte array.\n   * @param query The query being handled (for logging purposes).\n   * @param file The file to read.\n   * @param max_length The maximum number of bytes to read from the file.\n   * @return {@code null} if the file doesn't exist or is empty or couldn't be\n   * read, otherwise a byte array of up to {@code max_length} bytes.\n   */\n  private static byte[] readFile(final HttpQuery query,\n                                 final File file,\n                                 final int max_length) {\n    final int length = (int) file.length();\n    if (length <= 0) {\n      return null;\n    }\n    FileInputStream in;\n    try {\n      in = new FileInputStream(file.getPath());\n    } catch (FileNotFoundException e) {\n      return null;\n    }\n    try {\n      final byte[] buf = new byte[Math.min(length, max_length)];\n      final int read = in.read(buf);\n      if (read != buf.length) {\n        logError(query, \"When reading \" + file + \": read only \"\n                 + read + \" bytes instead of \" + buf.length);\n        return null;\n      }\n      return buf;\n    } catch (IOException e) {\n      logError(query, \"Error while reading \" + file, e);\n      return null;\n    } finally {\n      try {\n        in.close();\n      } catch (IOException e) {\n        logError(query, \"Error while closing \" + file, e);\n      }\n    }\n  }\n\n  /**\n   * Attempts to read the cached {@code .json} file for this query.\n   * @param query The query to serve.\n   * @param end_time The end time on the query (32-bit unsigned int, seconds).\n   * @param max_age The maximum time (in seconds) we wanna allow clients to\n   * cache the result in case of a cache hit.\n   * @param basepath The base path used for the Gnuplot files.\n   * @return {@code null} in case no file was found, or the contents of the\n   * file if it was found.\n   * @throws IOException If the file cannot be loaded\n   * @throws JsonMappingException If the JSON cannot be parsed to a HashMap\n   * @throws JsonParseException If the JSON is improperly formatted\n   */\n  @SuppressWarnings(\"unchecked\")\n  private HashMap<String, Object> loadCachedJson(final HttpQuery query,\n                                       final long end_time,\n                                       final long max_age,\n                                       final String basepath)\n                                       throws JsonParseException,\n                                       JsonMappingException, IOException {\n    final String json_path = basepath + \".json\";\n    File json_cache = new File(json_path);\n    if (staleCacheFile(query, end_time, max_age, json_cache)) {\n      return null;\n    }\n    final byte[] json = readFile(query, json_cache, 4096);\n    if (json == null) {\n      return null;\n    }\n    json_cache = null;\n\n    return (HashMap<String, Object>) JSON.parseToObject(json, HashMap.class);\n  }\n\n  /** Parses the {@code wxh} query parameter to set the graph dimension. */\n  static void setPlotDimensions(final HttpQuery query, final Plot plot) {\n    String wxh = query.getQueryStringParam(\"wxh\");\n    if (wxh != null && !wxh.isEmpty()) {\n      wxh = URLDecoder.decode(wxh.trim());\n      validateString(\"wxh\", wxh);\n      if (!WXH_VALIDATOR.matcher(wxh).find()) {\n        throw new IllegalArgumentException(\"'wxh' was invalid. \"\n            + \"Must satisfy the pattern \" + WXH_VALIDATOR.toString());\n      }\n      final int wxhlength = wxh.length();\n      if (wxhlength < 7) {  // 100x100 minimum.\n        throw new BadRequestException(\"Parameter wxh too short: \" + wxh);\n      }\n      final int x = wxh.indexOf('x', 3);  // Start at 2 as min size is 100x100\n      if (x < 0) {\n        throw new BadRequestException(\"Invalid wxh parameter: \" + wxh);\n      }\n      try {\n        final short width = Short.parseShort(wxh.substring(0, x));\n        final short height = Short.parseShort(wxh.substring(x + 1, wxhlength));\n        try {\n          plot.setDimensions(width, height);\n        } catch (IllegalArgumentException e) {\n          throw new BadRequestException(\"Invalid wxh parameter: \" + wxh + \", \"\n                                        + e.getMessage());\n        }\n      } catch (NumberFormatException e) {\n        throw new BadRequestException(\"Can't parse wxh '\" + wxh + \"': \"\n                                      + e.getMessage());\n      }\n    }\n  }\n\n  /**\n   * Formats and quotes the given string so it's a suitable Gnuplot string.\n   * @param s The string to stringify.\n   * @return A string suitable for use as a literal string in Gnuplot.\n   */\n  private static String stringify(final String s) {\n    final StringBuilder buf = new StringBuilder(1 + s.length() + 1);\n    buf.append('\"');\n    HttpQuery.escapeJson(s, buf);  // Abusing this function gets the job done.\n    buf.append('\"');\n    return buf.toString();\n  }\n\n  /**\n   * Pops out of the query string the given parameter.\n   * @param querystring The query string.\n   * @param param The name of the parameter to pop out.\n   * @return {@code null} if the parameter wasn't passed, otherwise the\n   * value of the last occurrence of the parameter.\n   */\n  public static String popParam(final Map<String, List<String>> querystring,\n                                final String param) {\n    final List<String> params = querystring.remove(param);\n    if (params == null) {\n      return null;\n    }\n    String given = params.get(params.size() - 1);\n    if (given != null) {\n      given = URLDecoder.decode(given.trim());\n    }\n    // TODO - far from perfect, should help a little.\n    if (given.contains(\"`\") || given.contains(\"%60\") || \n        given.contains(\"&#96;\")) {\n      throw new BadRequestException(\"Parameter \" + param + \" contained a \"\n          + \"back-tick. That's a no-no.\");\n    }\n    return given;\n  }\n\n  /**\n   * Applies the plot parameters from the query to the given plot.\n   * @param query The query from which to get the query string.\n   * @param plot The plot on which to apply the parameters.\n   */\n  static void setPlotParams(final HttpQuery query, final Plot plot) {\n    final HashMap<String, String> params = new HashMap<String, String>();\n    final Map<String, List<String>> querystring = query.getQueryString();\n    String value;\n    if ((value = popParam(querystring, \"yrange\")) != null) {\n      validateString(\"yrange\", value, \"[:]\");\n      if (!RANGE_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'yrange' was invalid. \"\n            + \"Must be in the format [min:max].\");\n      }\n      params.put(\"yrange\", value);\n    }\n    if ((value = popParam(querystring, \"y2range\")) != null) {\n      validateString(\"y2range\", value, \"[:]\");\n      if (!RANGE_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'y2range' was invalid. \"\n            + \"Must be in the format [min:max].\");\n      }\n      params.put(\"y2range\", value);\n    }\n    if ((value = popParam(querystring, \"ylabel\")) != null) {\n      validateString(\"ylabel\", value, \" \");\n      if (!LABEL_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'ylabel' was invalid. Must \"\n            + \"satisfy the pattern \" + LABEL_VALIDATOR.toString());\n      }\n      params.put(\"ylabel\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"y2label\")) != null) {\n      validateString(\"y2label\", value, \" \");\n      if (!LABEL_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'y2label' was invalid. Must \"\n            + \"satisfy the pattern \" + LABEL_VALIDATOR.toString());\n      }\n      params.put(\"y2label\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"yformat\")) != null) {\n      validateString(\"yformat\", value, \"% \");\n      if (!FORMAT_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'yformat' was invalid. Must \"\n            + \"satisfy the pattern \" + FORMAT_VALIDATOR.toString());\n      }\n      params.put(\"format y\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"y2format\")) != null) {\n      validateString(\"y2format\", value, \"% \");\n      if (!FORMAT_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'y2format' was invalid. Must \"\n            + \"satisfy the pattern \" + FORMAT_VALIDATOR.toString());\n      }\n      params.put(\"format y2\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"xformat\")) != null) {\n      validateString(\"xformat\", value, \"% \");\n      if (!FORMAT_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'xformat' was invalid. Must \"\n            + \"satisfy the pattern \" + FORMAT_VALIDATOR.toString());\n      }\n      params.put(\"format x\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"ylog\")) != null) {\n      params.put(\"logscale y\", \"\");\n    }\n    if ((value = popParam(querystring, \"y2log\")) != null) {\n      params.put(\"logscale y2\", \"\");\n    }\n    if ((value = popParam(querystring, \"key\")) != null) {\n      validateString(\"key\", value);\n      if (!KEY_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'key' was invalid. Must \"\n            + \"satisfy the pattern \" + KEY_VALIDATOR.toString());\n      }\n      params.put(\"key\", value);\n    }\n    if ((value = popParam(querystring, \"title\")) != null) {\n      validateString(\"title\", value, \" \");\n      if (!LABEL_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'title' was invalid. Must \"\n            + \"satisfy the pattern \" + LABEL_VALIDATOR.toString());\n      }\n      params.put(\"title\", stringify(value));\n    }\n    if ((value = popParam(querystring, \"bgcolor\")) != null) {\n      validateString(\"bgcolor\", value);\n      if (!COLOR_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'bgcolor' was invalid. Must \"\n            + \"be a hex value e.g. 'xFFFFFF'\");\n      }\n      params.put(\"bgcolor\", value);\n    }\n    if ((value = popParam(querystring, \"fgcolor\")) != null) {\n      validateString(\"fgcolor\", value);\n      if (!COLOR_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'fgcolor' was invalid. Must \"\n            + \"be a hex value e.g. 'xFFFFFF'\");\n      }\n      params.put(\"fgcolor\", value);\n    }\n    if ((value = popParam(querystring, \"smooth\")) != null) {\n      validateString(\"smooth\", value);\n      if (!SMOOTH_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'smooth' was invalid. Must \"\n            + \"satisfy the pattern \" + SMOOTH_VALIDATOR.toString());\n      }\n      params.put(\"smooth\", value);\n    }\n    if ((value = popParam(querystring, \"style\")) != null) {\n      validateString(\"style\", value);\n      if (!STYLE_VALIDATOR.matcher(value).find()) {\n        throw new BadRequestException(\"'style' was invalid. Must \"\n            + \"satisfy the pattern \" + STYLE_VALIDATOR.toString());\n      }\n      params.put(\"style\", value);\n    }\n    // This must remain after the previous `if' in order to properly override\n    // any previous `key' parameter if a `nokey' parameter is given.\n    if ((value = popParam(querystring, \"nokey\")) != null) {\n      params.put(\"key\", null);\n    }\n    plot.setParams(params);\n  }\n\n  /**\n   * Runs Gnuplot in a subprocess to generate the graph.\n   * <strong>This function will block</strong> while Gnuplot is running.\n   * @param query The query being handled (for logging purposes).\n   * @param basepath The base path used for the Gnuplot files.\n   * @param plot The plot object to generate Gnuplot's input files.\n   * @return The number of points plotted by Gnuplot (0 or more).\n   * @throws IOException if the Gnuplot files can't be written, or\n   * the Gnuplot subprocess fails to start, or we can't read the\n   * graph from the file it produces, or if we have been interrupted.\n   * @throws GnuplotException if Gnuplot returns non-zero.\n   */\n  static int runGnuplot(final HttpQuery query,\n                        final String basepath,\n                        final Plot plot) throws IOException {\n    final int nplotted = plot.dumpToFiles(basepath);\n    final long start_time = System.nanoTime();\n    final Process gnuplot = new ProcessBuilder(GNUPLOT,\n      basepath + \".out\", basepath + \".err\", basepath + \".gnuplot\").start();\n    final int rv;\n    try {\n      rv = gnuplot.waitFor();  // Couldn't find how to do this asynchronously.\n    } catch (InterruptedException e) {\n      Thread.currentThread().interrupt();  // Restore the interrupted status.\n      throw new IOException(\"interrupted\", e);  // I hate checked exceptions.\n    } finally {\n      // We need to always destroy() the Process, otherwise we \"leak\" file\n      // descriptors and pipes.  Unless I'm blind, this isn't actually\n      // documented in the Javadoc of the !@#$%^ JDK, and in Java 6 there's no\n      // way to ask the stupid-ass ProcessBuilder to not create fucking pipes.\n      // I think when the GC kicks in the JVM may run some kind of a finalizer\n      // that closes the pipes, because I've never seen this issue on long\n      // running TSDs, except where ulimit -n was low (the default, 1024).\n      gnuplot.destroy();\n    }\n    gnuplotlatency.add((int) ((System.nanoTime() - start_time) / 1000000));\n    if (rv != 0) {\n      final byte[] stderr = readFile(query, new File(basepath + \".err\"),\n                                     4096);\n      // Sometimes Gnuplot will error out but still create the file.\n      new File(basepath + \".png\").delete();\n      if (stderr == null) {\n        throw new GnuplotException(rv);\n      }\n      throw new GnuplotException(new String(stderr));\n    }\n    // Remove the files for stderr/stdout if they're empty.\n    deleteFileIfEmpty(basepath + \".out\");\n    deleteFileIfEmpty(basepath + \".err\");\n    return nplotted;\n  }\n\n  private static void deleteFileIfEmpty(final String path) {\n    final File file = new File(path);\n    if (file.length() <= 0) {\n      file.delete();\n    }\n  }\n\n  /**\n   * Respond to a query that wants the output in ASCII.\n   * <p>\n   * When a query specifies the \"ascii\" query string parameter, we send the\n   * data points back to the client in plain text instead of sending a PNG.\n   * @param query The query we're currently serving.\n   * @param max_age The maximum time (in seconds) we wanna allow clients to\n   * cache the result in case of a cache hit.\n   * @param basepath The base path used for the Gnuplot files.\n   * @param plot The plot object to generate Gnuplot's input files.\n   */\n  private static void respondAsciiQuery(final HttpQuery query,\n                                        final int max_age,\n                                        final String basepath,\n                                        final Plot plot) {\n    final String path = basepath + \".txt\";\n    PrintWriter asciifile;\n    try {\n      asciifile = new PrintWriter(path);\n    } catch (IOException e) {\n      query.internalError(e);\n      return;\n    }\n    try {\n      final StringBuilder tagbuf = new StringBuilder();\n      for (final DataPoints dp : plot.getDataPoints()) {\n        final String metric = dp.metricName();\n        tagbuf.setLength(0);\n        for (final Map.Entry<String, String> tag : dp.getTags().entrySet()) {\n          tagbuf.append(' ').append(tag.getKey())\n            .append('=').append(tag.getValue());\n        }\n        for (final DataPoint d : dp) {\n          if (d.isInteger()) {\n            printMetricHeader(asciifile, metric, d.timestamp());\n            asciifile.print(d.longValue());\n          } else {\n            // Doubles require extra processing.\n            final double value = d.doubleValue();\n\n            // Value might be NaN or infinity.\n            if (Double.isInfinite(value)) {\n              // Infinity is invalid.\n              throw new IllegalStateException(\"Infinity:\" + value\n                + \" d=\" + d + \", query=\" + query);\n            } else if (Double.isNaN(value)) {\n              // NaNs should be skipped.\n              continue;\n            }\n\n            printMetricHeader(asciifile, metric, d.timestamp());\n            asciifile.print(value);\n          }\n\n          asciifile.print(tagbuf);\n          asciifile.print('\\n');\n        }\n      }\n    } finally {\n      asciifile.close();\n    }\n    try {\n      query.sendFile(path, max_age);\n    } catch (IOException e) {\n      query.internalError(e);\n    }\n  }\n\n  /**\n   * Helper method to write metric name and timestamp.\n   * @param writer The writer to which to write.\n   * @param metric The metric name.\n   * @param timestamp The timestamp.\n   */\n  private static void printMetricHeader(final PrintWriter writer, final String metric,\n      final long timestamp) {\n    writer.print(metric);\n    writer.print(' ');\n    writer.print(timestamp / 1000L);\n    writer.print(' ');\n  }\n\n  private static final PlotThdFactory thread_factory = new PlotThdFactory();\n\n  private static final class PlotThdFactory implements ThreadFactory {\n    private final AtomicInteger id = new AtomicInteger(0);\n\n    public Thread newThread(final Runnable r) {\n      return new Thread(r, \"Gnuplot #\" + id.incrementAndGet());\n    }\n  }\n\n  /** Name of the wrapper script we use to execute Gnuplot.  */\n  private static final String WRAPPER =\n    IS_WINDOWS ? \"mygnuplot.bat\" : \"mygnuplot.sh\";\n\n  /** Path to the wrapper script.  */\n  private static final String GNUPLOT;\n  static {\n    GNUPLOT = findGnuplotHelperScript();\n  }\n\n  /**\n   * Iterate through the class path and look for the Gnuplot helper script.\n   * @return The path to the wrapper script.\n   */\n  private static String findGnuplotHelperScript() {\n    if(!GnuplotInstaller.FOUND_GP) {\n      LOG.warn(\"Skipping Gnuplot Shell Script Install since Gnuplot executable was not found\");\n      return null;\n    }\n    if(!GnuplotInstaller.GP_FILE.exists()) {\n      GnuplotInstaller.installMyGnuPlot();\n    }\n    if(GnuplotInstaller.GP_FILE.exists() && GnuplotInstaller.GP_FILE.canExecute()) {\n      LOG.info(\"Auto Installed Gnuplot Invoker at [{}]\", GnuplotInstaller.GP_FILE.getAbsolutePath());\n      return GnuplotInstaller.GP_FILE.getAbsolutePath();\n    }\n    \n    final URL url = GraphHandler.class.getClassLoader().getResource(WRAPPER);\n    if (url == null) {\n      throw new RuntimeException(\"Couldn't find \" + WRAPPER + \" on the\"\n        + \" CLASSPATH: \" + System.getProperty(\"java.class.path\"));\n    }\n    final String path = url.getFile();\n    LOG.debug(\"Using Gnuplot wrapper at {}\", path);\n    final File file = new File(path);\n    final String error;\n    if (!file.exists()) {\n      error = \"non-existent\";\n    } else if (!file.canExecute()) {\n      error = \"non-executable\";\n    } else if (!file.canRead()) {\n      error = \"unreadable\";\n    } else {\n      return path;\n    }\n    throw new RuntimeException(\"The \" + WRAPPER + \" found on the\"\n      + \" CLASSPATH (\" + path + \") is a \" + error + \" file...  WTF?\"\n      + \"  CLASSPATH=\" + System.getProperty(\"java.class.path\"));\n  }\n\n\n  // ---------------- //\n  // Logging helpers. //\n  // ---------------- //\n\n  static void logInfo(final HttpQuery query, final String msg) {\n    LOG.info(query.channel().toString() + ' ' + msg);\n  }\n\n  static void logWarn(final HttpQuery query, final String msg) {\n    LOG.warn(query.channel().toString() + ' ' + msg);\n  }\n\n  static void logError(final HttpQuery query, final String msg) {\n    LOG.error(query.channel().toString() + ' ' + msg);\n  }\n\n  static void logError(final HttpQuery query, final String msg,\n                       final Throwable e) {\n    LOG.error(query.channel().toString() + ' ' + msg, e);\n  }\n\n  static void validateString(final String what, final String s) {\n    validateString(what, s, \"\");\n  }\n\n  public static void validateString(final String what, final String s, String specials) {\n    if (s == null) {\n      throw new BadRequestException(\"Invalid \" + what + \": null\");\n    } else if (\"\".equals(s)) {\n      throw new BadRequestException(\"Invalid \" + what + \": empty string\");\n    }\n    final int n = s.length();\n    for (int i = 0; i < n; i++) {\n      final char c = s.charAt(i);\n      if (!(('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')\n          || ('0' <= c && c <= '9') || c == '-' || c == '_' || c == '.'\n          || c == '/' || Character.isLetter(c) || specials.indexOf(c) != -1)) {\n        throw new BadRequestException(\"Invalid \" + what\n            + \" (\\\"\" + s + \"\\\"): illegal character: \" + c);\n      }\n    }\n  }\n\n}\n", "// This file is part of OpenTSDB.\n// Copyright (C) 2011-2021  The OpenTSDB Authors.\n//\n// This program is free software: you can redistribute it and/or modify it\n// under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 2.1 of the License, or (at your\n// option) any later version.  This program is distributed in the hope that it\n// will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty\n// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser\n// General Public License for more details.  You should have received a copy\n// of the GNU Lesser General Public License along with this program.  If not,\n// see <http://www.gnu.org/licenses/>.\npackage net.opentsdb.tsd;\n\nimport java.io.File;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.jboss.netty.channel.Channel;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport org.powermock.api.mockito.PowerMockito;\nimport org.powermock.core.classloader.annotations.PowerMockIgnore;\nimport org.powermock.core.classloader.annotations.PrepareForTest;\nimport org.powermock.modules.junit4.PowerMockRunner;\nimport org.powermock.reflect.Whitebox;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\n\nimport net.opentsdb.graph.Plot;\n\nimport static org.powermock.api.mockito.PowerMockito.mock;\n\n@RunWith(PowerMockRunner.class)\n// \"Classloader hell\"...  It's real.  Tell PowerMock to ignore these classes\n// because they fiddle with the class loader.  We don't test them anyway.\n@PowerMockIgnore({\"javax.management.*\", \"javax.xml.*\",\n                  \"ch.qos.*\", \"org.slf4j.*\",\n                  \"com.sum.*\", \"org.xml.*\"})\n@PrepareForTest({ GraphHandler.class, HttpQuery.class, Plot.class })\npublic final class TestGraphHandler {\n\n  private final static Method sm;\n  static {\n    try {\n      sm = GraphHandler.class.getDeclaredMethod(\"staleCacheFile\",\n          HttpQuery.class, long.class, long.class, File.class);\n      sm.setAccessible(true);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Failed in static initializer\", e);\n    }\n  }\n  \n  @Test  \n  public void setYRangeParams() throws Exception {\n    assertPlotParam(\"yrange\",\"[0:1]\");\n    assertPlotParam(\"yrange\", \"[:]\");\n    assertPlotParam(\"yrange\", \"[:0]\");\n    assertPlotParam(\"yrange\", \"[:42]\");\n    assertPlotParam(\"yrange\", \"[:-42]\");\n    assertPlotParam(\"yrange\", \"[:0.8]\");\n    assertPlotParam(\"yrange\", \"[:-0.8]\");\n    assertPlotParam(\"yrange\", \"[:42.4]\");\n    assertPlotParam(\"yrange\", \"[:-42.4]\");\n    assertPlotParam(\"yrange\", \"[:4e4]\");\n    assertPlotParam(\"yrange\", \"[:-4e4]\");\n    assertPlotParam(\"yrange\", \"[:4e-4]\");\n    assertPlotParam(\"yrange\", \"[:-4e-4]\");\n    assertPlotParam(\"yrange\", \"[:4.2e4]\");\n    assertPlotParam(\"yrange\", \"[:-4.2e4]\");\n    assertPlotParam(\"yrange\", \"[0:]\");\n    assertPlotParam(\"yrange\", \"[5:]\");\n    assertPlotParam(\"yrange\", \"[-5:]\");\n    assertPlotParam(\"yrange\", \"[0.5:]\");\n    assertPlotParam(\"yrange\", \"[-0.5:]\");\n    assertPlotParam(\"yrange\", \"[10.5:]\");\n    assertPlotParam(\"yrange\", \"[-10.5:]\");\n    assertPlotParam(\"yrange\", \"[10e5:]\");\n    assertPlotParam(\"yrange\", \"[-10e5:]\");\n    assertPlotParam(\"yrange\", \"[10e-5:]\");\n    assertPlotParam(\"yrange\", \"[-10e-5:]\");\n    assertPlotParam(\"yrange\", \"[10.1e-5:]\");\n    assertPlotParam(\"yrange\", \"[-10.1e-5:]\");\n    assertPlotParam(\"yrange\", \"[-10.1e-5:-10.1e-6]\");\n    assertInvalidPlotParam(\"yrange\", \"[33:system('touch /tmp/poc.txt')]\");\n    assertInvalidPlotParam(\"y2range\", \"[42:%0a[33:system('touch /tmp/poc.txt')]\");\n  }\n\n  @Test\n  public void setKeyParams() throws Exception {\n    assertPlotParam(\"key\", \"out\");\n    assertPlotParam(\"key\", \"left\");\n    assertPlotParam(\"key\", \"top\");\n    assertPlotParam(\"key\", \"center\");\n    assertPlotParam(\"key\", \"right\");\n    assertPlotParam(\"key\", \"horiz\");\n    assertPlotParam(\"key\", \"box\");\n    assertPlotParam(\"key\", \"bottom\");\n    assertInvalidPlotParam(\"key\", \"out%20right%20top%0aset%20yrange%20[33:system(%20\");\n    assertInvalidPlotParam(\"key\", \"%3Bsystem%20%22cat%20/home/ubuntuvm/secret.txt%20%3E/tmp/secret.txt%22%20%22\");\n  }\n\n  @Test\n  public void setStyleParams() throws Exception {\n    assertPlotParam(\"style\", \"linespoint\");\n    assertPlotParam(\"style\", \"points\");\n    assertPlotParam(\"style\", \"circles\");\n    assertPlotParam(\"style\", \"dots\");\n    assertInvalidPlotParam(\"style\", \"dots%20%0a[33:system(%20\");\n    assertInvalidPlotParam(\"style\", \"%3Bsystem%20%22cat%20/home/ubuntuvm/secret.txt%20%3E/tmp/secret.txt%22%20%22\\\"\");\n  }\n\n  @Test\n  public void setLabelParams() throws Exception {\n    assertPlotParam(\"ylabel\", \"This is good\");\n    assertPlotParam(\"ylabel\", \" and so Is this - _ yay\");\n    assertInvalidPlotParam(\"ylabel\", \"system(%20no%0anewlines\");\n    assertInvalidPlotParam(\"title\", \"system(%20no%0anewlines\");\n    assertInvalidPlotParam(\"y2label\", \"system(%20no%0anewlines\");\n  }\n\n  @Test\n  public void setWXH() throws Exception {\n    assertPlotDimension(\"wxh\",  \"720x640\");\n    assertInvalidPlotDimension(\"wxh\", \"720%0ax640\");\n  }\n\n  @Test\n  public void setColorParams() throws Exception {\n    assertPlotParam(\"bgcolor\", \"x000000\");\n    assertPlotParam(\"bgcolor\", \"XDEADBE\");\n    assertPlotParam(\"bgcolor\", \"%58DEADBE\");\n    assertInvalidPlotParam(\"bgcolor\", \"XDEADBEF\");\n    assertInvalidPlotParam(\"bgcolor\", \"%5BDEADBE\");\n    assertInvalidPlotParam(\"bgcolor\", \"xBDE%0AAD\");\n\n    assertPlotParam(\"fgcolor\", \"x000000\");\n    assertPlotParam(\"fgcolor\", \"XDEADBE\");\n    assertPlotParam(\"fgcolor\", \"%58DEADBE\");\n    assertInvalidPlotParam(\"fgcolor\", \"XDEADBEF\");\n    assertInvalidPlotParam(\"fgcolor\", \"%5BDEADBE\");\n    assertInvalidPlotParam(\"fgcolor\", \"xBDE%0AAD\");\n  }\n\n  @Test\n  public void setSmoothParams() throws Exception {\n    assertPlotParam(\"smooth\", \"unique\");\n    assertPlotParam(\"smooth\", \"frequency\");\n    assertPlotParam(\"smooth\", \"fnormal\");\n    assertPlotParam(\"smooth\", \"cumulative\");\n    assertPlotParam(\"smooth\", \"cnormal\");\n    assertPlotParam(\"smooth\", \"bins\");\n    assertPlotParam(\"smooth\", \"csplines\");\n    assertPlotParam(\"smooth\", \"acsplines\");\n    assertPlotParam(\"smooth\", \"mcsplines\");\n    assertPlotParam(\"smooth\", \"bezier\");\n    assertPlotParam(\"smooth\", \"sbezier\");\n    assertPlotParam(\"smooth\", \"unwrap\");\n    assertPlotParam(\"smooth\", \"zsort\");\n    assertInvalidPlotParam(\"smooth\", \"bezier%20system(%20\");\n    assertInvalidPlotParam(\"smooth\", \"fnormal%0asystem(%20\");\n  }\n\n  @Test\n  public void setFormatParams() throws Exception {\n    assertPlotParam(\"yformat\", \"%25.2f\");\n    assertPlotParam(\"y2format\", \"%25.2f\");\n    assertPlotParam(\"xformat\", \"%25.2f\");\n    assertPlotParam(\"yformat\", \"%253.0em\");\n    assertPlotParam(\"yformat\", \"%253.0em%25%25\");\n    assertPlotParam(\"yformat\", \"%25.2f seconds\");\n    assertPlotParam(\"yformat\", \"%25.0f ms\");\n    assertInvalidPlotParam(\"yformat\", \"%252.system(%20\");\n    assertInvalidPlotParam(\"yformat\", \"%252.%0asystem(%20\");\n  }\n\n  @Test  // If the file doesn't exist, we don't use it, obviously.\n  public void staleCacheFileDoesntExist() throws Exception {\n    final File cachedfile = fakeFile(\"/cache/fake-file\");\n    // From the JDK manual: \"returns 0L if the file does not exist\n    // or if an I/O error occurs\"\n    when(cachedfile.lastModified()).thenReturn(0L);\n\n    assertTrue(\"File is stale\", staleCacheFile(null, 0, 10, cachedfile));\n\n    verify(cachedfile).lastModified();  // Ensure we do a single stat() call.\n  }\n\n  @Test  // If the mtime of a file is in the future, we don't use it.\n  public void staleCacheFileInTheFuture() throws Exception {\n    PowerMockito.mockStatic(System.class);\n\n    final HttpQuery query = fakeHttpQuery();\n    final File cachedfile = fakeFile(\"/cache/fake-file\");\n\n    final long now = 1000L;\n    when(System.currentTimeMillis()).thenReturn(now);\n    when(cachedfile.lastModified()).thenReturn(now + 1000L);\n    final long end_time = now;\n\n    assertTrue(\"File is stale\",\n               staleCacheFile(query, end_time, 10, cachedfile));\n\n    verify(cachedfile).lastModified();  // Ensure we do a single stat() call.\n    PowerMockito.verifyStatic(); // Verify that ...\n    System.currentTimeMillis();  // ... this was called only once.\n  }\n\n//  @Test  // End time in the future => OK to serve stale file up to max_age.\n//  public void staleCacheFileEndTimeInFuture() throws Exception {\n//    PowerMockito.mockStatic(System.class);\n//\n//    final HttpQuery query = fakeHttpQuery();\n//    final File cachedfile = fakeFile(\"/cache/fake-file\");\n//\n//    final long end_time = 20000L;\n//    when(System.currentTimeMillis()).thenReturn(10000L);\n//    when(cachedfile.lastModified()).thenReturn(8000L);\n//\n//    assertFalse(\"File is not more than 3s stale\",\n//                staleCacheFile(query, end_time, 3, cachedfile));\n//    assertFalse(\"File is more than 2s stale\",\n//               staleCacheFile(query, end_time, 2, cachedfile));\n//    assertTrue(\"File is more than 1s stale\",\n//               staleCacheFile(query, end_time, 1, cachedfile));\n//\n//    // Ensure that we stat() the file and look at the current time once per\n//    // invocation of staleCacheFile().\n//    verify(cachedfile, times(3)).lastModified();\n//    PowerMockito.verifyStatic(times(3));\n//    System.currentTimeMillis();\n//  }\n\n//  @Test  // No end time = end time is now.\n//  public void staleCacheFileEndTimeIsNow() throws Exception {\n//    PowerMockito.mockStatic(System.class);\n//\n//    final HttpQuery query = fakeHttpQuery();\n//    final File cachedfile = fakeFile(\"/cache/fake-file\");\n//\n//    final long now = 10000L;\n//    final long end_time = now;\n//    when(System.currentTimeMillis()).thenReturn(now);\n//    when(cachedfile.lastModified()).thenReturn(8000L);\n//\n//    assertFalse(\"File is not more than 3s stale\",\n//                staleCacheFile(query, end_time, 3, cachedfile));\n//    assertFalse(\"File is more than 2s stale\",\n//               staleCacheFile(query, end_time, 2, cachedfile));\n//    assertTrue(\"File is more than 1s stale\",\n//               staleCacheFile(query, end_time, 1, cachedfile));\n//\n//    // Ensure that we stat() the file and look at the current time once per\n//    // invocation of staleCacheFile().\n//    verify(cachedfile, times(3)).lastModified();\n//    PowerMockito.verifyStatic(times(3));\n//    System.currentTimeMillis();\n//  }\n\n  @Test  // End time in the past, file's mtime predates it.\n  public void staleCacheFileEndTimeInPastOlderFile() throws Exception {\n    PowerMockito.mockStatic(System.class);\n\n    final HttpQuery query = fakeHttpQuery();\n    final File cachedfile = fakeFile(\"/cache/fake-file\");\n\n    final long end_time = 8000L;\n    final long now = end_time + 2000L;\n    when(System.currentTimeMillis()).thenReturn(now);\n    when(cachedfile.lastModified()).thenReturn(5000L);\n\n    assertTrue(\"File predates end-time and cannot be re-used\",\n               staleCacheFile(query, end_time, 4, cachedfile));\n\n    verify(cachedfile).lastModified();  // Ensure we do a single stat() call.\n    PowerMockito.verifyStatic(); // Verify that ...\n    System.currentTimeMillis();  // ... this was called only once.\n  }\n\n//  @Test  // End time in the past, file's mtime is after it.\n//  public void staleCacheFileEndTimeInPastCacheableFile() throws Exception {\n//    PowerMockito.mockStatic(System.class);\n//\n//    final HttpQuery query = fakeHttpQuery();\n//    final File cachedfile = fakeFile(\"/cache/fake-file\");\n//\n//    final long end_time = 8000L;\n//    final long now = end_time + 2000L;\n//    when(System.currentTimeMillis()).thenReturn(now);\n//    when(cachedfile.lastModified()).thenReturn(end_time + 1000L);\n//\n//    assertFalse(\"File was created after end-time and can be re-used\",\n//               staleCacheFile(query, end_time, 1, cachedfile));\n//\n//    verify(cachedfile).lastModified();  // Ensure we do a single stat() call.\n//    PowerMockito.verifyStatic(); // Verify that ...\n//    System.currentTimeMillis();  // ... this was called only once.\n//  }\n\n  /**\n   * Helper to call private static method.\n   * There's one slight difference: the {@code end_time} parameter is in\n   * milliseconds here, instead of seconds.\n   */\n  private static boolean staleCacheFile(final HttpQuery query,\n                                        final long end_time,\n                                        final long max_age,\n                                        final File cachedfile) throws Exception {\n    PowerMockito.mockStatic(System.class);\n    PowerMockito.when(System.getProperty(anyString(), anyString())).thenReturn(\"\");\n    PowerMockito.when(System.getProperty(anyString())).thenReturn(\"\");\n    PowerMockito.spy(GraphHandler.class);\n    PowerMockito.doReturn(\"\").when(GraphHandler.class, \"findGnuplotHelperScript\");\n    \n    return Whitebox.<Boolean>invokeMethod(GraphHandler.class, \"staleCacheFile\",\n                                          query, end_time / 1000, max_age,\n                                          cachedfile);\n    \n    //return (Boolean)sm.invoke(null, query, end_time / 1000, max_age, cachedfile);\n  }\n\n  private static HttpQuery fakeHttpQuery() {\n    final HttpQuery query = mock(HttpQuery.class);\n    final Channel chan = NettyMocks.fakeChannel();\n    when(query.channel()).thenReturn(chan);\n    return query;\n  }\n\n  private static File fakeFile(final String path) {\n    final File file = mock(File.class);\n    when(file.getPath()).thenReturn(path);\n    when(file.toString()).thenReturn(path);\n    return file;\n  }\n\n  private static void assertPlotParam(String param, String value) {\n    Plot plot = mock(Plot.class);\n    HttpQuery query = mock(HttpQuery.class);\n    Map<String, List<String>> params = Maps.newHashMap();\n    when(query.getQueryString()).thenReturn(params);\n\n    params.put(param, Lists.newArrayList(value));\n    GraphHandler.setPlotParams(query, plot);\n  }\n\n  private static void assertPlotDimension(String param, String value) {\n    Plot plot = mock(Plot.class);\n    HttpQuery query = mock(HttpQuery.class);\n    when(query.getQueryStringParam(param)).thenReturn(value);\n    GraphHandler.setPlotParams(query, plot);\n  }\n\n  private static void assertInvalidPlotParam(String param, String value) {\n    Plot plot = mock(Plot.class);\n    HttpQuery query = mock(HttpQuery.class);\n    Map<String, List<String>> params = Maps.newHashMap();\n    when(query.getQueryString()).thenReturn(params);\n\n    params.put(param, Lists.newArrayList(value));\n    try {\n      GraphHandler.setPlotParams(query, plot);\n      fail(\"Expected BadRequestException\");\n    } catch (BadRequestException e) { }\n  }\n\n  private static void assertInvalidPlotDimension(String param, String value) {\n    Plot plot = mock(Plot.class);\n    HttpQuery query = mock(HttpQuery.class);\n    when(query.getQueryStringParam(param)).thenReturn(value);\n    try {\n      GraphHandler.setPlotDimensions(query, plot);\n      fail(\"Expected BadRequestException\");\n    } catch (BadRequestException e) { }\n  }\n\n}\n"], "filenames": ["src/tsd/GraphHandler.java", "test/tsd/TestGraphHandler.java"], "buggy_code_start_loc": [43, 99], "buggy_code_end_loc": [1073, 359], "fixing_code_start_loc": [43, 100], "fixing_code_end_loc": [1112, 390], "type": "CWE-74", "message": "OpenTSDB is a open source, distributed, scalable Time Series Database (TSDB). OpenTSDB is vulnerable to Remote Code Execution vulnerability by writing user-controlled input to Gnuplot configuration file and running Gnuplot with the generated configuration. This issue has been patched in  commit `07c4641471c` and further refined in commit `fa88d3e4b`. These patches are available in the `2.4.2` release. Users are advised to upgrade. User unable to upgrade may disable Gunuplot via the config option`tsd.core.enable_ui = true` and remove the shell files `mygnuplot.bat` and `mygnuplot.sh`.", "other": {"cve": {"id": "CVE-2023-36812", "sourceIdentifier": "security-advisories@github.com", "published": "2023-06-30T23:15:10.287", "lastModified": "2023-09-08T23:15:11.103", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "OpenTSDB is a open source, distributed, scalable Time Series Database (TSDB). OpenTSDB is vulnerable to Remote Code Execution vulnerability by writing user-controlled input to Gnuplot configuration file and running Gnuplot with the generated configuration. This issue has been patched in  commit `07c4641471c` and further refined in commit `fa88d3e4b`. These patches are available in the `2.4.2` release. Users are advised to upgrade. User unable to upgrade may disable Gunuplot via the config option`tsd.core.enable_ui = true` and remove the shell files `mygnuplot.bat` and `mygnuplot.sh`."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:opentsdb:opentsdb:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.4.2", "matchCriteriaId": "B9965644-CFBE-43D0-9F85-5ADB7B2AF465"}]}]}], "references": [{"url": "http://packetstormsecurity.com/files/174570/OpenTSDB-2.4.1-Unauthenticated-Command-Injection.html", "source": "security-advisories@github.com"}, {"url": "https://github.com/OpenTSDB/opentsdb/commit/07c4641471c6f5c2ab5aab615969e97211eb50d9", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/OpenTSDB/opentsdb/commit/fa88d3e4b5369f9fb73da384fab0b23e246309ba", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/OpenTSDB/opentsdb/security/advisories/GHSA-76f7-9v52-v2fw", "source": "security-advisories@github.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/OpenTSDB/opentsdb/commit/07c4641471c6f5c2ab5aab615969e97211eb50d9"}}