{"buggy_code": ["<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\Discussion\\Command;\n\nuse Exception;\nuse Flarum\\Discussion\\Discussion;\nuse Flarum\\Discussion\\DiscussionValidator;\nuse Flarum\\Discussion\\Event\\Saving;\nuse Flarum\\Foundation\\DispatchEventsTrait;\nuse Flarum\\Post\\Command\\PostReply;\nuse Illuminate\\Contracts\\Bus\\Dispatcher as BusDispatcher;\nuse Illuminate\\Contracts\\Events\\Dispatcher as EventDispatcher;\nuse Illuminate\\Support\\Arr;\n\nclass StartDiscussionHandler\n{\n    use DispatchEventsTrait;\n\n    /**\n     * @var BusDispatcher\n     */\n    protected $bus;\n\n    /**\n     * @var \\Flarum\\Discussion\\DiscussionValidator\n     */\n    protected $validator;\n\n    /**\n     * @param EventDispatcher $events\n     * @param BusDispatcher $bus\n     * @param \\Flarum\\Discussion\\DiscussionValidator $validator\n     */\n    public function __construct(EventDispatcher $events, BusDispatcher $bus, DiscussionValidator $validator)\n    {\n        $this->events = $events;\n        $this->bus = $bus;\n        $this->validator = $validator;\n    }\n\n    /**\n     * @param StartDiscussion $command\n     * @return mixed\n     * @throws Exception\n     */\n    public function handle(StartDiscussion $command)\n    {\n        $actor = $command->actor;\n        $data = $command->data;\n        $ipAddress = $command->ipAddress;\n\n        $actor->assertCan('startDiscussion');\n\n        // Create a new Discussion entity, persist it, and dispatch domain\n        // events. Before persistence, though, fire an event to give plugins\n        // an opportunity to alter the discussion entity based on data in the\n        // command they may have passed through in the controller.\n        $discussion = Discussion::start(\n            Arr::get($data, 'attributes.title'),\n            $actor\n        );\n\n        $this->events->dispatch(\n            new Saving($discussion, $actor, $data)\n        );\n\n        $this->validator->assertValid($discussion->getAttributes());\n\n        $discussion->save();\n\n        // Now that the discussion has been created, we can add the first post.\n        // We will do this by running the PostReply command.\n        try {\n            $post = $this->bus->dispatch(\n                new PostReply($discussion->id, $actor, $data, $ipAddress)\n            );\n        } catch (Exception $e) {\n            $discussion->delete();\n\n            throw $e;\n        }\n\n        // Before we dispatch events, refresh our discussion instance's\n        // attributes as posting the reply will have changed some of them (e.g.\n        // last_time.)\n        $discussion->setRawAttributes($post->discussion->getAttributes(), true);\n        $discussion->setFirstPost($post);\n        $discussion->setLastPost($post);\n\n        $this->dispatchEventsFor($discussion, $actor);\n\n        $discussion->save();\n\n        return $discussion;\n    }\n}\n", "<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\Post\\Command;\n\nuse Flarum\\User\\User;\n\nclass PostReply\n{\n    /**\n     * The ID of the discussion to post the reply to.\n     *\n     * @var int\n     */\n    public $discussionId;\n\n    /**\n     * The user who is performing the action.\n     *\n     * @var User\n     */\n    public $actor;\n\n    /**\n     * The attributes to assign to the new post.\n     *\n     * @var array\n     */\n    public $data;\n\n    /**\n     * The IP address of the actor.\n     *\n     * @var string\n     */\n    public $ipAddress;\n\n    /**\n     * @param int $discussionId The ID of the discussion to post the reply to.\n     * @param User $actor The user who is performing the action.\n     * @param array $data The attributes to assign to the new post.\n     * @param string $ipAddress The IP address of the actor.\n     */\n    public function __construct($discussionId, User $actor, array $data, $ipAddress = null)\n    {\n        $this->discussionId = $discussionId;\n        $this->actor = $actor;\n        $this->data = $data;\n        $this->ipAddress = $ipAddress;\n    }\n}\n", "<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\Post\\Command;\n\nuse Carbon\\Carbon;\nuse Flarum\\Discussion\\DiscussionRepository;\nuse Flarum\\Foundation\\DispatchEventsTrait;\nuse Flarum\\Notification\\NotificationSyncer;\nuse Flarum\\Post\\CommentPost;\nuse Flarum\\Post\\Event\\Saving;\nuse Flarum\\Post\\PostValidator;\nuse Illuminate\\Contracts\\Events\\Dispatcher;\nuse Illuminate\\Support\\Arr;\n\nclass PostReplyHandler\n{\n    use DispatchEventsTrait;\n\n    /**\n     * @var DiscussionRepository\n     */\n    protected $discussions;\n\n    /**\n     * @var \\Flarum\\Notification\\NotificationSyncer\n     */\n    protected $notifications;\n\n    /**\n     * @var \\Flarum\\Post\\PostValidator\n     */\n    protected $validator;\n\n    /**\n     * @param Dispatcher $events\n     * @param DiscussionRepository $discussions\n     * @param \\Flarum\\Notification\\NotificationSyncer $notifications\n     * @param PostValidator $validator\n     */\n    public function __construct(\n        Dispatcher $events,\n        DiscussionRepository $discussions,\n        NotificationSyncer $notifications,\n        PostValidator $validator\n    ) {\n        $this->events = $events;\n        $this->discussions = $discussions;\n        $this->notifications = $notifications;\n        $this->validator = $validator;\n    }\n\n    /**\n     * @param PostReply $command\n     * @return CommentPost\n     * @throws \\Flarum\\User\\Exception\\PermissionDeniedException\n     */\n    public function handle(PostReply $command)\n    {\n        $actor = $command->actor;\n\n        // Make sure the user has permission to reply to this discussion. First,\n        // make sure the discussion exists and that the user has permission to\n        // view it; if not, fail with a ModelNotFound exception so we don't give\n        // away the existence of the discussion. If the user is allowed to view\n        // it, check if they have permission to reply.\n        $discussion = $this->discussions->findOrFail($command->discussionId, $actor);\n\n        // If this is the first post in the discussion, it's technically not a\n        // \"reply\", so we won't check for that permission.\n        if ($discussion->first_post_id !== null) {\n            $actor->assertCan('reply', $discussion);\n        }\n\n        // Create a new Post entity, persist it, and dispatch domain events.\n        // Before persistence, though, fire an event to give plugins an\n        // opportunity to alter the post entity based on data in the command.\n        $post = CommentPost::reply(\n            $discussion->id,\n            Arr::get($command->data, 'attributes.content'),\n            $actor->id,\n            $command->ipAddress,\n            $command->actor,\n        );\n\n        if ($actor->isAdmin() && ($time = Arr::get($command->data, 'attributes.createdAt'))) {\n            $post->created_at = new Carbon($time);\n        }\n\n        $this->events->dispatch(\n            new Saving($post, $actor, $command->data)\n        );\n\n        $this->validator->assertValid($post->getAttributes());\n\n        $post->save();\n\n        $this->notifications->onePerUser(function () use ($post, $actor) {\n            $this->dispatchEventsFor($post, $actor);\n        });\n\n        return $post;\n    }\n}\n", "<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\Tests\\integration\\api\\posts;\n\nuse Carbon\\Carbon;\nuse Flarum\\Testing\\integration\\RetrievesAuthorizedUsers;\nuse Flarum\\Testing\\integration\\TestCase;\n\nclass CreateTest extends TestCase\n{\n    use RetrievesAuthorizedUsers;\n\n    /**\n     * @inheritDoc\n     */\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $this->prepareDatabase([\n            'discussions' => [\n                ['id' => 1, 'title' => __CLASS__, 'created_at' => Carbon::now()->toDateTimeString(), 'user_id' => 2],\n            ],\n            'users' => [\n                $this->normalUser(),\n            ]\n        ]);\n    }\n\n    /**\n     * @test\n     */\n    public function can_create_reply()\n    {\n        $response = $this->send(\n            $this->request('POST', '/api/posts', [\n                'authenticatedAs' => 2,\n                'json' => [\n                    'data' => [\n                        'attributes' => [\n                            'content' => 'reply with predetermined content for automated testing - too-obscure',\n                        ],\n                        'relationships' => [\n                            'discussion' => ['data' => ['id' => 1]],\n                        ],\n                    ],\n                ],\n            ])\n        );\n\n        $this->assertEquals(201, $response->getStatusCode());\n    }\n\n    /**\n     * @test\n     */\n    public function limited_by_throttler()\n    {\n        $this->send(\n            $this->request('POST', '/api/posts', [\n                'authenticatedAs' => 2,\n                'json' => [\n                    'data' => [\n                        'attributes' => [\n                            'content' => 'reply with predetermined content for automated testing - too-obscure',\n                        ],\n                        'relationships' => [\n                            'discussion' => ['data' => ['id' => 1]],\n                        ],\n                    ],\n                ],\n            ])\n        );\n\n        $response = $this->send(\n            $this->request('POST', '/api/posts', [\n                'authenticatedAs' => 2,\n                'json' => [\n                    'data' => [\n                        'attributes' => [\n                            'content' => 'Second reply with predetermined content for automated testing - too-obscure',\n                        ],\n                        'relationships' => [\n                            'discussion' => ['data' => ['id' => 1]],\n                        ],\n                    ],\n                ],\n            ])\n        );\n\n        $this->assertEquals(429, $response->getStatusCode());\n    }\n}\n"], "fixing_code": ["<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\Discussion\\Command;\n\nuse Exception;\nuse Flarum\\Discussion\\Discussion;\nuse Flarum\\Discussion\\DiscussionValidator;\nuse Flarum\\Discussion\\Event\\Saving;\nuse Flarum\\Foundation\\DispatchEventsTrait;\nuse Flarum\\Post\\Command\\PostReply;\nuse Illuminate\\Contracts\\Bus\\Dispatcher as BusDispatcher;\nuse Illuminate\\Contracts\\Events\\Dispatcher as EventDispatcher;\nuse Illuminate\\Support\\Arr;\n\nclass StartDiscussionHandler\n{\n    use DispatchEventsTrait;\n\n    /**\n     * @var BusDispatcher\n     */\n    protected $bus;\n\n    /**\n     * @var \\Flarum\\Discussion\\DiscussionValidator\n     */\n    protected $validator;\n\n    /**\n     * @param EventDispatcher $events\n     * @param BusDispatcher $bus\n     * @param \\Flarum\\Discussion\\DiscussionValidator $validator\n     */\n    public function __construct(EventDispatcher $events, BusDispatcher $bus, DiscussionValidator $validator)\n    {\n        $this->events = $events;\n        $this->bus = $bus;\n        $this->validator = $validator;\n    }\n\n    /**\n     * @param StartDiscussion $command\n     * @return mixed\n     * @throws Exception\n     */\n    public function handle(StartDiscussion $command)\n    {\n        $actor = $command->actor;\n        $data = $command->data;\n        $ipAddress = $command->ipAddress;\n\n        $actor->assertCan('startDiscussion');\n\n        // Create a new Discussion entity, persist it, and dispatch domain\n        // events. Before persistence, though, fire an event to give plugins\n        // an opportunity to alter the discussion entity based on data in the\n        // command they may have passed through in the controller.\n        $discussion = Discussion::start(\n            Arr::get($data, 'attributes.title'),\n            $actor\n        );\n\n        $this->events->dispatch(\n            new Saving($discussion, $actor, $data)\n        );\n\n        $this->validator->assertValid($discussion->getAttributes());\n\n        $discussion->save();\n\n        // Now that the discussion has been created, we can add the first post.\n        // We will do this by running the PostReply command.\n        try {\n            $post = $this->bus->dispatch(\n                new PostReply($discussion->id, $actor, $data, $ipAddress, true)\n            );\n        } catch (Exception $e) {\n            $discussion->delete();\n\n            throw $e;\n        }\n\n        // Before we dispatch events, refresh our discussion instance's\n        // attributes as posting the reply will have changed some of them (e.g.\n        // last_time.)\n        $discussion->setRawAttributes($post->discussion->getAttributes(), true);\n        $discussion->setFirstPost($post);\n        $discussion->setLastPost($post);\n\n        $this->dispatchEventsFor($discussion, $actor);\n\n        $discussion->save();\n\n        return $discussion;\n    }\n}\n", "<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\Post\\Command;\n\nuse Flarum\\User\\User;\n\nclass PostReply\n{\n    /**\n     * The ID of the discussion to post the reply to.\n     *\n     * @var int\n     */\n    public $discussionId;\n\n    /**\n     * The user who is performing the action.\n     *\n     * @var User\n     */\n    public $actor;\n\n    /**\n     * The attributes to assign to the new post.\n     *\n     * @var array\n     */\n    public $data;\n\n    /**\n     * The IP address of the actor.\n     *\n     * @var string\n     */\n    public $ipAddress;\n\n    /**\n     * @var bool\n     */\n    public $isFirstPost;\n\n    /**\n     * @param int $discussionId The ID of the discussion to post the reply to.\n     * @param User $actor The user who is performing the action.\n     * @param array $data The attributes to assign to the new post.\n     * @param string $ipAddress The IP address of the actor.\n     */\n    public function __construct($discussionId, User $actor, array $data, $ipAddress = null, bool $isFirstPost = false)\n    {\n        $this->discussionId = $discussionId;\n        $this->actor = $actor;\n        $this->data = $data;\n        $this->ipAddress = $ipAddress;\n        $this->isFirstPost = $isFirstPost;\n    }\n}\n", "<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\Post\\Command;\n\nuse Carbon\\Carbon;\nuse Flarum\\Discussion\\DiscussionRepository;\nuse Flarum\\Foundation\\DispatchEventsTrait;\nuse Flarum\\Notification\\NotificationSyncer;\nuse Flarum\\Post\\CommentPost;\nuse Flarum\\Post\\Event\\Saving;\nuse Flarum\\Post\\PostValidator;\nuse Illuminate\\Contracts\\Events\\Dispatcher;\nuse Illuminate\\Support\\Arr;\n\nclass PostReplyHandler\n{\n    use DispatchEventsTrait;\n\n    /**\n     * @var DiscussionRepository\n     */\n    protected $discussions;\n\n    /**\n     * @var \\Flarum\\Notification\\NotificationSyncer\n     */\n    protected $notifications;\n\n    /**\n     * @var \\Flarum\\Post\\PostValidator\n     */\n    protected $validator;\n\n    /**\n     * @param Dispatcher $events\n     * @param DiscussionRepository $discussions\n     * @param \\Flarum\\Notification\\NotificationSyncer $notifications\n     * @param PostValidator $validator\n     */\n    public function __construct(\n        Dispatcher $events,\n        DiscussionRepository $discussions,\n        NotificationSyncer $notifications,\n        PostValidator $validator\n    ) {\n        $this->events = $events;\n        $this->discussions = $discussions;\n        $this->notifications = $notifications;\n        $this->validator = $validator;\n    }\n\n    /**\n     * @param PostReply $command\n     * @return CommentPost\n     * @throws \\Flarum\\User\\Exception\\PermissionDeniedException\n     */\n    public function handle(PostReply $command)\n    {\n        $actor = $command->actor;\n\n        // Make sure the user has permission to reply to this discussion. First,\n        // make sure the discussion exists and that the user has permission to\n        // view it; if not, fail with a ModelNotFound exception so we don't give\n        // away the existence of the discussion. If the user is allowed to view\n        // it, check if they have permission to reply.\n        $discussion = $this->discussions->findOrFail($command->discussionId, $actor);\n\n        // If this is the first post in the discussion, it's technically not a\n        // \"reply\", so we won't check for that permission.\n        if (! $command->isFirstPost) {\n            $actor->assertCan('reply', $discussion);\n        }\n\n        // Create a new Post entity, persist it, and dispatch domain events.\n        // Before persistence, though, fire an event to give plugins an\n        // opportunity to alter the post entity based on data in the command.\n        $post = CommentPost::reply(\n            $discussion->id,\n            Arr::get($command->data, 'attributes.content'),\n            $actor->id,\n            $command->ipAddress,\n            $command->actor,\n        );\n\n        if ($actor->isAdmin() && ($time = Arr::get($command->data, 'attributes.createdAt'))) {\n            $post->created_at = new Carbon($time);\n        }\n\n        $this->events->dispatch(\n            new Saving($post, $actor, $command->data)\n        );\n\n        $this->validator->assertValid($post->getAttributes());\n\n        $post->save();\n\n        $this->notifications->onePerUser(function () use ($post, $actor) {\n            $this->dispatchEventsFor($post, $actor);\n        });\n\n        return $post;\n    }\n}\n", "<?php\n\n/*\n * This file is part of Flarum.\n *\n * For detailed copyright and license information, please view the\n * LICENSE file that was distributed with this source code.\n */\n\nnamespace Flarum\\Tests\\integration\\api\\posts;\n\nuse Carbon\\Carbon;\nuse Flarum\\Group\\Group;\nuse Flarum\\Testing\\integration\\RetrievesAuthorizedUsers;\nuse Flarum\\Testing\\integration\\TestCase;\n\nclass CreateTest extends TestCase\n{\n    use RetrievesAuthorizedUsers;\n\n    /**\n     * @inheritDoc\n     */\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $this->prepareDatabase([\n            'discussions' => [\n                ['id' => 1, 'title' => __CLASS__, 'created_at' => Carbon::now()->toDateTimeString(), 'user_id' => 2, 'first_post_id' => 1],\n                // Discussion with deleted first post.\n                ['id' => 2, 'title' => __CLASS__, 'created_at' => Carbon::now()->toDateTimeString(), 'user_id' => 2, 'first_post_id' => null],\n            ],\n            'posts' => [\n                ['id' => 1, 'discussion_id' => 1, 'number' => 1, 'created_at' => Carbon::now()->subDay()->toDateTimeString(), 'user_id' => 2, 'type' => 'comment', 'content' => '<t></t>'],\n            ],\n            'users' => [\n                $this->normalUser(),\n                ['id' => 3, 'username' => 'restricted', 'email' => 'restricted@machine.local', 'is_email_confirmed' => 1],\n            ],\n            'groups' => [\n                ['id' => 40, 'name_singular' => 'tess', 'name_plural' => 'tess'],\n            ],\n            'group_user' => [\n                ['group_id' => 40, 'user_id' => 3],\n            ],\n            'group_permission' => [\n                ['group_id' => 40, 'permission' => 'discussion.reply'],\n            ],\n        ]);\n    }\n\n    /**\n     * @dataProvider discussionRepliesPrvider\n     * @test\n     */\n    public function can_create_reply_if_allowed(int $actorId, int $discussionId, int $responseStatus)\n    {\n        // Reset permissions for normal users group.\n        $this->database()\n            ->table('group_permission')\n            ->where('permission', 'discussion.reply')\n            ->where('group_id', Group::MEMBER_ID)\n            ->delete();\n\n        $response = $this->send(\n            $this->request('POST', '/api/posts', [\n                'authenticatedAs' => $actorId,\n                'json' => [\n                    'data' => [\n                        'attributes' => [\n                            'content' => 'reply with predetermined content for automated testing - too-obscure',\n                        ],\n                        'relationships' => [\n                            'discussion' => ['data' => ['id' => $discussionId]],\n                        ],\n                    ],\n                ],\n            ])\n        );\n\n        $this->assertEquals($responseStatus, $response->getStatusCode());\n    }\n\n    public function discussionRepliesPrvider(): array\n    {\n        return [\n            // [$actorId, $discussionId, $responseStatus]\n            'can_create_reply_with_ability' => [3, 1, 201],\n            'cannot_create_reply_without_ability' => [2, 1, 403],\n            'can_create_reply_with_ability_when_first_post_is_deleted' => [3, 2, 201],\n            'cannot_create_reply_without_ability_when_first_post_is_deleted' => [2, 2, 403],\n        ];\n    }\n\n    /**\n     * @test\n     */\n    public function limited_by_throttler()\n    {\n        $this->send(\n            $this->request('POST', '/api/posts', [\n                'authenticatedAs' => 2,\n                'json' => [\n                    'data' => [\n                        'attributes' => [\n                            'content' => 'reply with predetermined content for automated testing - too-obscure',\n                        ],\n                        'relationships' => [\n                            'discussion' => ['data' => ['id' => 1]],\n                        ],\n                    ],\n                ],\n            ])\n        );\n\n        $response = $this->send(\n            $this->request('POST', '/api/posts', [\n                'authenticatedAs' => 2,\n                'json' => [\n                    'data' => [\n                        'attributes' => [\n                            'content' => 'Second reply with predetermined content for automated testing - too-obscure',\n                        ],\n                        'relationships' => [\n                            'discussion' => ['data' => ['id' => 1]],\n                        ],\n                    ],\n                ],\n            ])\n        );\n\n        $this->assertEquals(429, $response->getStatusCode());\n    }\n}\n"], "filenames": ["framework/core/src/Discussion/Command/StartDiscussionHandler.php", "framework/core/src/Post/Command/PostReply.php", "framework/core/src/Post/Command/PostReplyHandler.php", "framework/core/tests/integration/api/posts/CreateTest.php"], "buggy_code_start_loc": [82, 44, 77, 12], "buggy_code_end_loc": [83, 55, 78, 59], "fixing_code_start_loc": [82, 45, 77, 13], "fixing_code_end_loc": [83, 62, 78, 94], "type": "CWE-862", "message": "Flarum is a discussion platform for websites. If the first post of a discussion is permanently deleted but the discussion stays visible, any actor who can view the discussion is able to create a new reply via the REST API, no matter the reply permission or lock status. This includes users that don't have a validated email. Guests cannot successfully create a reply because the API will fail with a 500 error when the user ID 0 is inserted into the database. This happens because when the first post of a discussion is permanently deleted, the `first_post_id` attribute of the discussion becomes `null` which causes access control to be skipped for all new replies. Flarum automatically makes discussions with zero comments invisible so an additional condition for this vulnerability is that the discussion must have at least one approved reply so that `discussions.comment_count` is still above zero after the post deletion. This can open the discussion to uncontrolled spam or just unintentional replies if users still had their tab open before the vulnerable discussion was locked and then post a reply when they shouldn't be able to. In combination with the email notification settings, this could also be used as a way to send unsolicited emails. Versions between `v1.3.0` and `v1.6.3` are impacted. The vulnerability has been fixed and published as flarum/core v1.6.3. All communities running Flarum should upgrade as soon as possible. There are no known workarounds.", "other": {"cve": {"id": "CVE-2023-22489", "sourceIdentifier": "security-advisories@github.com", "published": "2023-01-13T19:15:12.037", "lastModified": "2023-01-23T17:55:21.397", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Flarum is a discussion platform for websites. If the first post of a discussion is permanently deleted but the discussion stays visible, any actor who can view the discussion is able to create a new reply via the REST API, no matter the reply permission or lock status. This includes users that don't have a validated email. Guests cannot successfully create a reply because the API will fail with a 500 error when the user ID 0 is inserted into the database. This happens because when the first post of a discussion is permanently deleted, the `first_post_id` attribute of the discussion becomes `null` which causes access control to be skipped for all new replies. Flarum automatically makes discussions with zero comments invisible so an additional condition for this vulnerability is that the discussion must have at least one approved reply so that `discussions.comment_count` is still above zero after the post deletion. This can open the discussion to uncontrolled spam or just unintentional replies if users still had their tab open before the vulnerable discussion was locked and then post a reply when they shouldn't be able to. In combination with the email notification settings, this could also be used as a way to send unsolicited emails. Versions between `v1.3.0` and `v1.6.3` are impacted. The vulnerability has been fixed and published as flarum/core v1.6.3. All communities running Flarum should upgrade as soon as possible. There are no known workarounds."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.5, "baseSeverity": "LOW"}, "exploitabilityScore": 2.1, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:flarum:flarum:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.3.0", "versionEndExcluding": "1.6.2", "matchCriteriaId": "0D9F27FD-AE4D-472E-8DF4-1EE22EBE7FCC"}]}]}], "references": [{"url": "https://github.com/flarum/framework/commit/12f14112a0ecd1484d97330b82beb2a145919015", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/flarum/framework/releases/tag/v1.6.3", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/flarum/framework/security/advisories/GHSA-hph3-hv3c-7725", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/flarum/framework/commit/12f14112a0ecd1484d97330b82beb2a145919015"}}