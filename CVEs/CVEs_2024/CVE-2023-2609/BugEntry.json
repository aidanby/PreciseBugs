{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * register.c: functions for managing registers\n */\n\n#include \"vim.h\"\n\n/*\n * Registers:\n *\t0 = unnamed register, for normal yanks and puts\n *   1..9 = registers '1' to '9', for deletes\n * 10..35 = registers 'a' to 'z' ('A' to 'Z' for appending)\n *     36 = delete register '-'\n *     37 = Selection register '*'. Only if FEAT_CLIPBOARD defined\n *     38 = Clipboard register '+'. Only if FEAT_CLIPBOARD and FEAT_X11 defined\n */\nstatic yankreg_T\ty_regs[NUM_REGISTERS];\n\nstatic yankreg_T\t*y_current;\t    // ptr to current yankreg\nstatic int\t\ty_append;\t    // TRUE when appending\nstatic yankreg_T\t*y_previous = NULL; // ptr to last written yankreg\n\nstatic int\tstuff_yank(int, char_u *);\nstatic void\tput_reedit_in_typebuf(int silent);\nstatic int\tput_in_typebuf(char_u *s, int esc, int colon,\n\t\t\t\t\t\t\t\t int silent);\nstatic int\tyank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space);\n#ifdef FEAT_CLIPBOARD\nstatic void\tcopy_yank_reg(yankreg_T *reg);\n#endif\nstatic void\tdis_msg(char_u *p, int skip_esc);\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    yankreg_T *\nget_y_regs(void)\n{\n    return y_regs;\n}\n#endif\n\n#if defined(FEAT_CLIPBOARD) || defined(PROTO)\n    yankreg_T *\nget_y_register(int reg)\n{\n    return &y_regs[reg];\n}\n#endif\n\n    yankreg_T *\nget_y_current(void)\n{\n    return y_current;\n}\n\n    yankreg_T *\nget_y_previous(void)\n{\n    return y_previous;\n}\n\n    void\nset_y_current(yankreg_T *yreg)\n{\n    y_current = yreg;\n}\n\n    void\nset_y_previous(yankreg_T *yreg)\n{\n    y_previous = yreg;\n}\n\n    void\nreset_y_append(void)\n{\n    y_append = FALSE;\n}\n\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Keep the last expression line here, for repeating.\n */\nstatic char_u\t*expr_line = NULL;\nstatic exarg_T\t*expr_eap = NULL;\n\n/*\n * Get an expression for the \"\\\"=expr1\" or \"CTRL-R =expr1\"\n * Returns '=' when OK, NUL otherwise.\n */\n    int\nget_expr_register(void)\n{\n    char_u\t*new_line;\n\n    new_line = getcmdline('=', 0L, 0, 0);\n    if (new_line == NULL)\n\treturn NUL;\n    if (*new_line == NUL)\t// use previous line\n\tvim_free(new_line);\n    else\n\tset_expr_line(new_line, NULL);\n    return '=';\n}\n\n/*\n * Set the expression for the '=' register.\n * Argument must be an allocated string.\n * \"eap\" may be used if the next line needs to be checked when evaluating the\n * expression.\n */\n    void\nset_expr_line(char_u *new_line, exarg_T *eap)\n{\n    vim_free(expr_line);\n    expr_line = new_line;\n    expr_eap = eap;\n}\n\n/*\n * Get the result of the '=' register expression.\n * Returns a pointer to allocated memory, or NULL for failure.\n */\n    char_u *\nget_expr_line(void)\n{\n    char_u\t*expr_copy;\n    char_u\t*rv;\n    static int\tnested = 0;\n\n    if (expr_line == NULL)\n\treturn NULL;\n\n    // Make a copy of the expression, because evaluating it may cause it to be\n    // changed.\n    expr_copy = vim_strsave(expr_line);\n    if (expr_copy == NULL)\n\treturn NULL;\n\n    // When we are invoked recursively limit the evaluation to 10 levels.\n    // Then return the string as-is.\n    if (nested >= 10)\n\treturn expr_copy;\n\n    ++nested;\n    rv = eval_to_string_eap(expr_copy, TRUE, expr_eap, FALSE);\n    --nested;\n    vim_free(expr_copy);\n    return rv;\n}\n\n/*\n * Get the '=' register expression itself, without evaluating it.\n */\n    static char_u *\nget_expr_line_src(void)\n{\n    if (expr_line == NULL)\n\treturn NULL;\n    return vim_strsave(expr_line);\n}\n#endif // FEAT_EVAL\n\n/*\n * Check if 'regname' is a valid name of a yank register.\n * Note: There is no check for 0 (default register), caller should do this\n */\n    int\nvalid_yank_reg(\n    int\t    regname,\n    int\t    writing)\t    // if TRUE check for writable registers\n{\n    if (       (regname > 0 && ASCII_ISALNUM(regname))\n\t    || (!writing && vim_strchr((char_u *)\n#ifdef FEAT_EVAL\n\t\t\t\t    \"/.%:=\"\n#else\n\t\t\t\t    \"/.%:\"\n#endif\n\t\t\t\t\t, regname) != NULL)\n\t    || regname == '#'\n\t    || regname == '\"'\n\t    || regname == '-'\n\t    || regname == '_'\n#ifdef FEAT_CLIPBOARD\n\t    || regname == '*'\n\t    || regname == '+'\n#endif\n#ifdef FEAT_DND\n\t    || (!writing && regname == '~')\n#endif\n\t\t\t\t\t\t\t)\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set y_current and y_append, according to the value of \"regname\".\n * Cannot handle the '_' register.\n * Must only be called with a valid register name!\n *\n * If regname is 0 and writing, use register 0\n * If regname is 0 and reading, use previous register\n *\n * Return TRUE when the register should be inserted literally (selection or\n * clipboard).\n */\n    int\nget_yank_register(int regname, int writing)\n{\n    int\t    i;\n    int\t    ret = FALSE;\n\n    y_append = FALSE;\n    if ((regname == 0 || regname == '\"') && !writing && y_previous != NULL)\n    {\n\ty_current = y_previous;\n\treturn ret;\n    }\n    i = regname;\n    if (VIM_ISDIGIT(i))\n\ti -= '0';\n    else if (ASCII_ISLOWER(i))\n\ti = CharOrdLow(i) + 10;\n    else if (ASCII_ISUPPER(i))\n    {\n\ti = CharOrdUp(i) + 10;\n\ty_append = TRUE;\n    }\n    else if (regname == '-')\n\ti = DELETION_REGISTER;\n#ifdef FEAT_CLIPBOARD\n    // When selection is not available, use register 0 instead of '*'\n    else if (clip_star.available && regname == '*')\n    {\n\ti = STAR_REGISTER;\n\tret = TRUE;\n    }\n    // When clipboard is not available, use register 0 instead of '+'\n    else if (clip_plus.available && regname == '+')\n    {\n\ti = PLUS_REGISTER;\n\tret = TRUE;\n    }\n#endif\n#ifdef FEAT_DND\n    else if (!writing && regname == '~')\n\ti = TILDE_REGISTER;\n#endif\n    else\t\t// not 0-9, a-z, A-Z or '-': use register 0\n\ti = 0;\n    y_current = &(y_regs[i]);\n    if (writing)\t// remember the register we write into for do_put()\n\ty_previous = y_current;\n    return ret;\n}\n\n/*\n * Obtain the contents of a \"normal\" register. The register is made empty.\n * The returned pointer has allocated memory, use put_register() later.\n */\n    void *\nget_register(\n    int\t\tname,\n    int\t\tcopy)\t// make a copy, if FALSE make register empty.\n{\n    yankreg_T\t*reg;\n    int\t\ti;\n\n#ifdef FEAT_CLIPBOARD\n    // When Visual area changed, may have to update selection.  Obtain the\n    // selection too.\n    if (name == '*' && clip_star.available)\n    {\n\tif (clip_isautosel_star())\n\t    clip_update_selection(&clip_star);\n\tmay_get_selection(name);\n    }\n    if (name == '+' && clip_plus.available)\n    {\n\tif (clip_isautosel_plus())\n\t    clip_update_selection(&clip_plus);\n\tmay_get_selection(name);\n    }\n#endif\n\n    get_yank_register(name, 0);\n    reg = ALLOC_ONE(yankreg_T);\n    if (reg == NULL)\n\treturn (void *)NULL;\n\n    *reg = *y_current;\n    if (copy)\n    {\n\t// If we run out of memory some or all of the lines are empty.\n\tif (reg->y_size == 0)\n\t    reg->y_array = NULL;\n\telse\n\t    reg->y_array = ALLOC_MULT(char_u *, reg->y_size);\n\tif (reg->y_array != NULL)\n\t{\n\t    for (i = 0; i < reg->y_size; ++i)\n\t\treg->y_array[i] = vim_strsave(y_current->y_array[i]);\n\t}\n    }\n    else\n\ty_current->y_array = NULL;\n    return (void *)reg;\n}\n\n/*\n * Put \"reg\" into register \"name\".  Free any previous contents and \"reg\".\n */\n    void\nput_register(int name, void *reg)\n{\n    get_yank_register(name, 0);\n    free_yank_all();\n    *y_current = *(yankreg_T *)reg;\n    vim_free(reg);\n\n#ifdef FEAT_CLIPBOARD\n    // Send text written to clipboard register to the clipboard.\n    may_set_selection();\n#endif\n}\n\n#if defined(FEAT_CLIPBOARD) || defined(PROTO)\n    void\nfree_register(void *reg)\n{\n    yankreg_T tmp;\n\n    tmp = *y_current;\n    *y_current = *(yankreg_T *)reg;\n    free_yank_all();\n    vim_free(reg);\n    *y_current = tmp;\n}\n#endif\n\n/*\n * return TRUE if the current yank register has type MLINE\n */\n    int\nyank_register_mline(int regname)\n{\n    if (regname != 0 && !valid_yank_reg(regname, FALSE))\n\treturn FALSE;\n    if (regname == '_')\t\t// black hole is always empty\n\treturn FALSE;\n    get_yank_register(regname, FALSE);\n    return (y_current->y_type == MLINE);\n}\n\n/*\n * Start or stop recording into a yank register.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_record(int c)\n{\n    char_u\t    *p;\n    static int\t    regname;\n    yankreg_T\t    *old_y_previous, *old_y_current;\n    int\t\t    retval;\n\n    if (reg_recording == 0)\t    // start recording\n    {\n\t// registers 0-9, a-z and \" are allowed\n\tif (c < 0 || (!ASCII_ISALNUM(c) && c != '\"'))\n\t    retval = FAIL;\n\telse\n\t{\n\t    reg_recording = c;\n\t    showmode();\n\t    regname = c;\n\t    retval = OK;\n\t}\n    }\n    else\t\t\t    // stop recording\n    {\n\t// Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this\n\t// needs to be removed again to put it in a register.  exec_reg then\n\t// adds the escaping back later.\n\treg_recording = 0;\n\tmsg(\"\");\n\tp = get_recorded();\n\tif (p == NULL)\n\t    retval = FAIL;\n\telse\n\t{\n\t    // Remove escaping for CSI and K_SPECIAL in multi-byte chars.\n\t    vim_unescape_csi(p);\n\n\t    // We don't want to change the default register here, so save and\n\t    // restore the current register name.\n\t    old_y_previous = y_previous;\n\t    old_y_current = y_current;\n\n\t    retval = stuff_yank(regname, p);\n\n\t    y_previous = old_y_previous;\n\t    y_current = old_y_current;\n\t}\n    }\n    return retval;\n}\n\n/*\n * Stuff string \"p\" into yank register \"regname\" as a single line (append if\n * uppercase).\t\"p\" must have been alloced.\n *\n * return FAIL for failure, OK otherwise\n */\n    static int\nstuff_yank(int regname, char_u *p)\n{\n    char_u\t*lp;\n    char_u\t**pp;\n\n    // check for read-only register\n    if (regname != 0 && !valid_yank_reg(regname, TRUE))\n    {\n\tvim_free(p);\n\treturn FAIL;\n    }\n    if (regname == '_')\t\t    // black hole: don't do anything\n    {\n\tvim_free(p);\n\treturn OK;\n    }\n    get_yank_register(regname, TRUE);\n    if (y_append && y_current->y_array != NULL)\n    {\n\tpp = &(y_current->y_array[y_current->y_size - 1]);\n\tlp = alloc(STRLEN(*pp) + STRLEN(p) + 1);\n\tif (lp == NULL)\n\t{\n\t    vim_free(p);\n\t    return FAIL;\n\t}\n\tSTRCPY(lp, *pp);\n\tSTRCAT(lp, p);\n\tvim_free(p);\n\tvim_free(*pp);\n\t*pp = lp;\n    }\n    else\n    {\n\tfree_yank_all();\n\tif ((y_current->y_array = ALLOC_ONE(char_u *)) == NULL)\n\t{\n\t    vim_free(p);\n\t    return FAIL;\n\t}\n\ty_current->y_array[0] = p;\n\ty_current->y_size = 1;\n\ty_current->y_type = MCHAR;  // used to be MLINE, why?\n#ifdef FEAT_VIMINFO\n\ty_current->y_time_set = vim_time();\n#endif\n    }\n    return OK;\n}\n\n/*\n * Last executed register (@ command)\n */\nstatic int execreg_lastc = NUL;\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    int\nget_execreg_lastc(void)\n{\n    return execreg_lastc;\n}\n\n    void\nset_execreg_lastc(int lastc)\n{\n    execreg_lastc = lastc;\n}\n#endif\n\n/*\n * When executing a register as a series of ex-commands, if the\n * line-continuation character is used for a line, then join it with one or\n * more previous lines. Note that lines are processed backwards starting from\n * the last line in the register.\n *\n * Arguments:\n *   lines - list of lines in the register\n *   idx - index of the line starting with \\ or \"\\. Join this line with all the\n *\t   immediate predecessor lines that start with a \\ and the first line\n *\t   that doesn't start with a \\. Lines that start with a comment \"\\\n *\t   character are ignored.\n *\n * Returns the concatenated line. The index of the line that should be\n * processed next is returned in idx.\n */\n    static char_u *\nexecreg_line_continuation(char_u **lines, long *idx)\n{\n    garray_T\tga;\n    long\ti = *idx;\n    char_u\t*p;\n    int\t\tcmd_start;\n    int\t\tcmd_end = i;\n    int\t\tj;\n    char_u\t*str;\n\n    ga_init2(&ga, sizeof(char_u), 400);\n\n    // search backwards to find the first line of this command.\n    // Any line not starting with \\ or \"\\ is the start of the\n    // command.\n    while (--i > 0)\n    {\n\tp = skipwhite(lines[i]);\n\tif (*p != '\\\\' && (p[0] != '\"' || p[1] != '\\\\' || p[2] != ' '))\n\t    break;\n    }\n    cmd_start = i;\n\n    // join all the lines\n    ga_concat(&ga, lines[cmd_start]);\n    for (j = cmd_start + 1; j <= cmd_end; j++)\n    {\n\tp = skipwhite(lines[j]);\n\tif (*p == '\\\\')\n\t{\n\t    // Adjust the growsize to the current length to\n\t    // speed up concatenating many lines.\n\t    if (ga.ga_len > 400)\n\t    {\n\t\tif (ga.ga_len > 8000)\n\t\t    ga.ga_growsize = 8000;\n\t\telse\n\t\t    ga.ga_growsize = ga.ga_len;\n\t    }\n\t    ga_concat(&ga, p + 1);\n\t}\n    }\n    ga_append(&ga, NUL);\n    str = vim_strsave(ga.ga_data);\n    ga_clear(&ga);\n\n    *idx = i;\n    return str;\n}\n\n/*\n * Execute a yank register: copy it into the stuff buffer.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_execreg(\n    int\t    regname,\n    int\t    colon,\t\t// insert ':' before each line\n    int\t    addcr,\t\t// always add '\\n' to end of line\n    int\t    silent)\t\t// set \"silent\" flag in typeahead buffer\n{\n    long\ti;\n    char_u\t*p;\n    int\t\tretval = OK;\n    int\t\tremap;\n\n    // repeat previous one\n    if (regname == '@')\n    {\n\tif (execreg_lastc == NUL)\n\t{\n\t    emsg(_(e_no_previously_used_register));\n\t    return FAIL;\n\t}\n\tregname = execreg_lastc;\n    }\n    // check for valid regname\n    if (regname == '%' || regname == '#' || !valid_yank_reg(regname, FALSE))\n    {\n\temsg_invreg(regname);\n\treturn FAIL;\n    }\n    execreg_lastc = regname;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // black hole: don't stuff anything\n    if (regname == '_')\n\treturn OK;\n\n    // use last command line\n    if (regname == ':')\n    {\n\tif (last_cmdline == NULL)\n\t{\n\t    emsg(_(e_no_previous_command_line));\n\t    return FAIL;\n\t}\n\t// don't keep the cmdline containing @:\n\tVIM_CLEAR(new_last_cmdline);\n\t// Escape all control characters with a CTRL-V\n\tp = vim_strsave_escaped_ext(last_cmdline,\n\t\t    (char_u *)\"\\001\\002\\003\\004\\005\\006\\007\"\n\t\t\t  \"\\010\\011\\012\\013\\014\\015\\016\\017\"\n\t\t\t  \"\\020\\021\\022\\023\\024\\025\\026\\027\"\n\t\t\t  \"\\030\\031\\032\\033\\034\\035\\036\\037\",\n\t\t    Ctrl_V, FALSE);\n\tif (p != NULL)\n\t{\n\t    // When in Visual mode \"'<,'>\" will be prepended to the command.\n\t    // Remove it when it's already there.\n\t    if (VIsual_active && STRNCMP(p, \"'<,'>\", 5) == 0)\n\t\tretval = put_in_typebuf(p + 5, TRUE, TRUE, silent);\n\t    else\n\t\tretval = put_in_typebuf(p, TRUE, TRUE, silent);\n\t}\n\tvim_free(p);\n    }\n#ifdef FEAT_EVAL\n    else if (regname == '=')\n    {\n\tp = get_expr_line();\n\tif (p == NULL)\n\t    return FAIL;\n\tretval = put_in_typebuf(p, TRUE, colon, silent);\n\tvim_free(p);\n    }\n#endif\n    else if (regname == '.')\t\t// use last inserted text\n    {\n\tp = get_last_insert_save();\n\tif (p == NULL)\n\t{\n\t    emsg(_(e_no_inserted_text_yet));\n\t    return FAIL;\n\t}\n\tretval = put_in_typebuf(p, FALSE, colon, silent);\n\tvim_free(p);\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\tif (y_current->y_array == NULL)\n\t    return FAIL;\n\n\t// Disallow remapping for \":@r\".\n\tremap = colon ? REMAP_NONE : REMAP_YES;\n\n\t// Insert lines into typeahead buffer, from last one to first one.\n\tput_reedit_in_typebuf(silent);\n\tfor (i = y_current->y_size; --i >= 0; )\n\t{\n\t    char_u *escaped;\n\t    char_u *str;\n\t    int\t    free_str = FALSE;\n\n\t    // insert NL between lines and after last line if type is MLINE\n\t    if (y_current->y_type == MLINE || i < y_current->y_size - 1\n\t\t\t\t\t\t\t\t     || addcr)\n\t    {\n\t\tif (ins_typebuf((char_u *)\"\\n\", remap, 0, TRUE, silent) == FAIL)\n\t\t    return FAIL;\n\t    }\n\n\t    // Handle line-continuation for :@<register>\n\t    str = y_current->y_array[i];\n\t    if (colon && i > 0)\n\t    {\n\t\tp = skipwhite(str);\n\t\tif (*p == '\\\\' || (p[0] == '\"' && p[1] == '\\\\' && p[2] == ' '))\n\t\t{\n\t\t    str = execreg_line_continuation(y_current->y_array, &i);\n\t\t    if (str == NULL)\n\t\t\treturn FAIL;\n\t\t    free_str = TRUE;\n\t\t}\n\t    }\n\t    escaped = vim_strsave_escape_csi(str);\n\t    if (free_str)\n\t\tvim_free(str);\n\t    if (escaped == NULL)\n\t\treturn FAIL;\n\t    retval = ins_typebuf(escaped, remap, 0, TRUE, silent);\n\t    vim_free(escaped);\n\t    if (retval == FAIL)\n\t\treturn FAIL;\n\t    if (colon && ins_typebuf((char_u *)\":\", remap, 0, TRUE, silent)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t}\n\treg_executing = regname == 0 ? '\"' : regname; // disable \"q\" command\n    }\n    return retval;\n}\n\n/*\n * If \"restart_edit\" is not zero, put it in the typeahead buffer, so that it's\n * used only after other typeahead has been processed.\n */\n    static void\nput_reedit_in_typebuf(int silent)\n{\n    char_u\tbuf[3];\n\n    if (restart_edit == NUL)\n\treturn;\n\n    if (restart_edit == 'V')\n    {\n\tbuf[0] = 'g';\n\tbuf[1] = 'R';\n\tbuf[2] = NUL;\n    }\n    else\n    {\n\tbuf[0] = restart_edit == 'I' ? 'i' : restart_edit;\n\tbuf[1] = NUL;\n    }\n    if (ins_typebuf(buf, REMAP_NONE, 0, TRUE, silent) == OK)\n\trestart_edit = NUL;\n}\n\n/*\n * Insert register contents \"s\" into the typeahead buffer, so that it will be\n * executed again.\n * When \"esc\" is TRUE it is to be taken literally: Escape CSI characters and\n * no remapping.\n */\n    static int\nput_in_typebuf(\n    char_u\t*s,\n    int\t\tesc,\n    int\t\tcolon,\t    // add ':' before the line\n    int\t\tsilent)\n{\n    int\t\tretval = OK;\n\n    put_reedit_in_typebuf(silent);\n    if (colon)\n\tretval = ins_typebuf((char_u *)\"\\n\", REMAP_NONE, 0, TRUE, silent);\n    if (retval == OK)\n    {\n\tchar_u\t*p;\n\n\tif (esc)\n\t    p = vim_strsave_escape_csi(s);\n\telse\n\t    p = s;\n\tif (p == NULL)\n\t    retval = FAIL;\n\telse\n\t    retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES,\n\t\t\t\t\t\t\t     0, TRUE, silent);\n\tif (esc)\n\t    vim_free(p);\n    }\n    if (colon && retval == OK)\n\tretval = ins_typebuf((char_u *)\":\", REMAP_NONE, 0, TRUE, silent);\n    return retval;\n}\n\n/*\n * Insert a yank register: copy it into the Read buffer.\n * Used by CTRL-R command and middle mouse button in insert mode.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ninsert_reg(\n    int\t\tregname,\n    int\t\tliterally_arg)\t// insert literally, not as if typed\n{\n    long\ti;\n    int\t\tretval = OK;\n    char_u\t*arg;\n    int\t\tallocated;\n    int\t\tliterally = literally_arg;\n\n    // It is possible to get into an endless loop by having CTRL-R a in\n    // register a and then, in insert mode, doing CTRL-R a.\n    // If you hit CTRL-C, the loop will be broken here.\n    ui_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n    // check for valid regname\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    if (regname == '.')\t\t\t// insert last inserted text\n\tretval = stuff_inserted(NUL, 1L, TRUE);\n    else if (get_spec_reg(regname, &arg, &allocated, TRUE))\n    {\n\tif (arg == NULL)\n\t    return FAIL;\n\tstuffescaped(arg, literally);\n\tif (allocated)\n\t    vim_free(arg);\n    }\n    else\t\t\t\t// name or number register\n    {\n\tif (get_yank_register(regname, FALSE))\n\t    literally = TRUE;\n\tif (y_current->y_array == NULL)\n\t    retval = FAIL;\n\telse\n\t{\n\t    for (i = 0; i < y_current->y_size; ++i)\n\t    {\n\t\tif (regname == '-')\n\t\t{\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(regname);\n\t\t    do_put(regname, NULL, BACKWARD, 1L, PUT_CURSEND);\n\t\t}\n\t\telse\n\t\t    stuffescaped(y_current->y_array[i], literally);\n\t\t// Insert a newline between lines and after last line if\n\t\t// y_type is MLINE.\n\t\tif (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t\t    stuffcharReadbuff('\\n');\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * If \"regname\" is a special register, return TRUE and store a pointer to its\n * value in \"argp\".\n */\n    int\nget_spec_reg(\n    int\t\tregname,\n    char_u\t**argp,\n    int\t\t*allocated,\t// return: TRUE when value was allocated\n    int\t\terrmsg)\t\t// give error message when failing\n{\n    int\t\tcnt;\n\n    *argp = NULL;\n    *allocated = FALSE;\n    switch (regname)\n    {\n\tcase '%':\t\t// file name\n\t    if (errmsg)\n\t\tcheck_fname();\t// will give emsg if not set\n\t    *argp = curbuf->b_fname;\n\t    return TRUE;\n\n\tcase '#':\t\t// alternate file name\n\t    *argp = getaltfname(errmsg);\t// may give emsg if not set\n\t    return TRUE;\n\n#ifdef FEAT_EVAL\n\tcase '=':\t\t// result of expression\n\t    *argp = get_expr_line();\n\t    *allocated = TRUE;\n\t    return TRUE;\n#endif\n\n\tcase ':':\t\t// last command line\n\t    if (last_cmdline == NULL && errmsg)\n\t\temsg(_(e_no_previous_command_line));\n\t    *argp = last_cmdline;\n\t    return TRUE;\n\n\tcase '/':\t\t// last search-pattern\n\t    if (last_search_pat() == NULL && errmsg)\n\t\temsg(_(e_no_previous_regular_expression));\n\t    *argp = last_search_pat();\n\t    return TRUE;\n\n\tcase '.':\t\t// last inserted text\n\t    *argp = get_last_insert_save();\n\t    *allocated = TRUE;\n\t    if (*argp == NULL && errmsg)\n\t\temsg(_(e_no_inserted_text_yet));\n\t    return TRUE;\n\n\tcase Ctrl_F:\t\t// Filename under cursor\n\tcase Ctrl_P:\t\t// Path under cursor, expand via \"path\"\n\t    if (!errmsg)\n\t\treturn FALSE;\n\t    *argp = file_name_at_cursor(FNAME_MESS | FNAME_HYP\n\t\t\t    | (regname == Ctrl_P ? FNAME_EXP : 0), 1L, NULL);\n\t    *allocated = TRUE;\n\t    return TRUE;\n\n\tcase Ctrl_W:\t\t// word under cursor\n\tcase Ctrl_A:\t\t// WORD (mnemonic All) under cursor\n\t    if (!errmsg)\n\t\treturn FALSE;\n\t    cnt = find_ident_under_cursor(argp, regname == Ctrl_W\n\t\t\t\t   ?  (FIND_IDENT|FIND_STRING) : FIND_STRING);\n\t    *argp = cnt ? vim_strnsave(*argp, cnt) : NULL;\n\t    *allocated = TRUE;\n\t    return TRUE;\n\n\tcase Ctrl_L:\t\t// Line under cursor\n\t    if (!errmsg)\n\t\treturn FALSE;\n\n\t    *argp = ml_get_buf(curwin->w_buffer,\n\t\t\tcurwin->w_cursor.lnum, FALSE);\n\t    return TRUE;\n\n\tcase '_':\t\t// black hole: always empty\n\t    *argp = (char_u *)\"\";\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Paste a yank register into the command line.\n * Only for non-special registers.\n * Used by CTRL-R command in command-line mode\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ncmdline_paste_reg(\n    int regname,\n    int literally_arg,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// don't add CR characters\n{\n    long\ti;\n    int\t\tliterally = literally_arg;\n\n    if (get_yank_register(regname, FALSE))\n\tliterally = TRUE;\n    if (y_current->y_array == NULL)\n\treturn FAIL;\n\n    for (i = 0; i < y_current->y_size; ++i)\n    {\n\tcmdline_paste_str(y_current->y_array[i], literally);\n\n\t// Insert ^M between lines and after last line if type is MLINE.\n\t// Don't do this when \"remcr\" is TRUE.\n\tif ((y_current->y_type == MLINE || i < y_current->y_size - 1) && !remcr)\n\t    cmdline_paste_str((char_u *)\"\\r\", literally);\n\n\t// Check for CTRL-C, in case someone tries to paste a few thousand\n\t// lines and gets bored.\n\tui_breakcheck();\n\tif (got_int)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Shift the delete registers: \"9 is cleared, \"8 becomes \"9, etc.\n */\n    void\nshift_delete_registers(void)\n{\n    int\t\tn;\n\n    y_current = &y_regs[9];\n    free_yank_all();\t\t\t// free register nine\n    for (n = 9; n > 1; --n)\n\ty_regs[n] = y_regs[n - 1];\n    y_current = &y_regs[1];\n    if (!y_append)\n\ty_previous = y_current;\n    y_regs[1].y_array = NULL;\t\t// set register one to empty\n}\n\n#if defined(FEAT_EVAL)\n    void\nyank_do_autocmd(oparg_T *oap, yankreg_T *reg)\n{\n    static int\t    recursive = FALSE;\n    dict_T\t    *v_event;\n    list_T\t    *list;\n    int\t\t    n;\n    char_u\t    buf[NUMBUFLEN + 2];\n    long\t    reglen = 0;\n    save_v_event_T  save_v_event;\n\n    if (recursive)\n\treturn;\n\n    v_event = get_v_event(&save_v_event);\n\n    list = list_alloc();\n    if (list == NULL)\n\treturn;\n\n    // yanked text contents\n    for (n = 0; n < reg->y_size; n++)\n\tlist_append_string(list, reg->y_array[n], -1);\n    list->lv_lock = VAR_FIXED;\n    (void)dict_add_list(v_event, \"regcontents\", list);\n\n    // register name or empty string for unnamed operation\n    buf[0] = (char_u)oap->regname;\n    buf[1] = NUL;\n    (void)dict_add_string(v_event, \"regname\", buf);\n\n    // motion type: inclusive or exclusive\n    (void)dict_add_bool(v_event, \"inclusive\", oap->inclusive);\n\n    // kind of operation (yank, delete, change)\n    buf[0] = get_op_char(oap->op_type);\n    buf[1] = get_extra_op_char(oap->op_type);\n    buf[2] = NUL;\n    (void)dict_add_string(v_event, \"operator\", buf);\n\n    // register type\n    buf[0] = NUL;\n    buf[1] = NUL;\n    switch (get_reg_type(oap->regname, &reglen))\n    {\n\tcase MLINE: buf[0] = 'V'; break;\n\tcase MCHAR: buf[0] = 'v'; break;\n\tcase MBLOCK:\n\t\tvim_snprintf((char *)buf, sizeof(buf), \"%c%ld\", Ctrl_V,\n\t\t\t     reglen + 1);\n\t\tbreak;\n    }\n    (void)dict_add_string(v_event, \"regtype\", buf);\n\n    // selection type - visual or not\n    (void)dict_add_bool(v_event, \"visual\", oap->is_VIsual);\n\n    // Lock the dictionary and its keys\n    dict_set_items_ro(v_event);\n\n    recursive = TRUE;\n    textlock++;\n    apply_autocmds(EVENT_TEXTYANKPOST, NULL, NULL, FALSE, curbuf);\n    textlock--;\n    recursive = FALSE;\n\n    // Empty the dictionary, v:event is still valid\n    restore_v_event(v_event, &save_v_event);\n}\n#endif\n\n/*\n * set all the yank registers to empty (called from main())\n */\n    void\ninit_yank(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < NUM_REGISTERS; ++i)\n\ty_regs[i].y_array = NULL;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nclear_registers(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < NUM_REGISTERS; ++i)\n    {\n\ty_current = &y_regs[i];\n\tif (y_current->y_array != NULL)\n\t    free_yank_all();\n    }\n}\n#endif\n\n/*\n * Free \"n\" lines from the current yank register.\n * Called for normal freeing and in case of error.\n */\n    static void\nfree_yank(long n)\n{\n    if (y_current->y_array == NULL)\n\treturn;\n\n    long\t    i;\n\n    for (i = n; --i >= 0; )\n\tvim_free(y_current->y_array[i]);\n    VIM_CLEAR(y_current->y_array);\n}\n\n    void\nfree_yank_all(void)\n{\n    free_yank(y_current->y_size);\n}\n\n/*\n * Yank the text between \"oap->start\" and \"oap->end\" into a yank register.\n * If we are to append (uppercase register), we first yank into a new yank\n * register and then concatenate the old and the new one (so we keep the old\n * one in case of out-of-memory).\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\nop_yank(oparg_T *oap, int deleting, int mess)\n{\n    long\t\ty_idx;\t\t// index in y_array[]\n    yankreg_T\t\t*curr;\t\t// copy of y_current\n    yankreg_T\t\tnewreg;\t\t// new yank register when appending\n    char_u\t\t**new_ptr;\n    linenr_T\t\tlnum;\t\t// current line number\n    long\t\tj;\n    int\t\t\tyanktype = oap->motion_type;\n    long\t\tyanklines = oap->line_count;\n    linenr_T\t\tyankendlnum = oap->end.lnum;\n    char_u\t\t*p;\n    char_u\t\t*pnew;\n    struct block_def\tbd;\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\n    int\t\t\tdid_star = FALSE;\n#endif\n\n\t\t\t\t    // check for read-only register\n    if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n    if (oap->regname == '_')\t    // black hole: nothing to do\n\treturn OK;\n\n#ifdef FEAT_CLIPBOARD\n    if (!clip_star.available && oap->regname == '*')\n\toap->regname = 0;\n    else if (!clip_plus.available && oap->regname == '+')\n\toap->regname = 0;\n#endif\n\n    if (!deleting)\t\t    // op_delete() already set y_current\n\tget_yank_register(oap->regname, TRUE);\n\n    curr = y_current;\n\t\t\t\t    // append to existing contents\n    if (y_append && y_current->y_array != NULL)\n\ty_current = &newreg;\n    else\n\tfree_yank_all();\t    // free previously yanked lines\n\n    // If the cursor was in column 1 before and after the movement, and the\n    // operator is not inclusive, the yank is always linewise.\n    if (       oap->motion_type == MCHAR\n\t    && oap->start.col == 0\n\t    && !oap->inclusive\n\t    && (!oap->is_VIsual || *p_sel == 'o')\n\t    && !oap->block_mode\n\t    && oap->end.col == 0\n\t    && yanklines > 1)\n    {\n\tyanktype = MLINE;\n\t--yankendlnum;\n\t--yanklines;\n    }\n\n    y_current->y_size = yanklines;\n    y_current->y_type = yanktype;   // set the yank register type\n    y_current->y_width = 0;\n    y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);\n    if (y_current->y_array == NULL)\n    {\n\ty_current = curr;\n\treturn FAIL;\n    }\n#ifdef FEAT_VIMINFO\n    y_current->y_time_set = vim_time();\n#endif\n\n    y_idx = 0;\n    lnum = oap->start.lnum;\n\n    if (oap->block_mode)\n    {\n\t// Visual block mode\n\ty_current->y_type = MBLOCK;\t    // set the yank register type\n\ty_current->y_width = oap->end_vcol - oap->start_vcol;\n\n\tif (curwin->w_curswant == MAXCOL && y_current->y_width > 0)\n\t    y_current->y_width--;\n    }\n\n    for ( ; lnum <= yankendlnum; lnum++, y_idx++)\n    {\n\tswitch (y_current->y_type)\n\t{\n\t    case MBLOCK:\n\t\tblock_prep(oap, &bd, lnum, FALSE);\n\t\tif (yank_copy_line(&bd, y_idx, oap->excl_tr_ws) == FAIL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MLINE:\n\t\tif ((y_current->y_array[y_idx] =\n\t\t\t\t\t    vim_strsave(ml_get(lnum))) == NULL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MCHAR:\n\t\t{\n\t\t    colnr_T startcol = 0, endcol = MAXCOL;\n\t\t    int\t    is_oneChar = FALSE;\n\t\t    colnr_T cs, ce;\n\n\t\t    p = ml_get(lnum);\n\t\t    bd.startspaces = 0;\n\t\t    bd.endspaces = 0;\n\n\t\t    if (lnum == oap->start.lnum)\n\t\t    {\n\t\t\tstartcol = oap->start.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->start, &cs, NULL, &ce);\n\t\t\t    if (ce != cs && oap->start.coladd > 0)\n\t\t\t    {\n\t\t\t\t// Part of a tab selected -- but don't\n\t\t\t\t// double-count it.\n\t\t\t\tbd.startspaces = (ce - cs + 1)\n\t\t\t\t\t\t\t  - oap->start.coladd;\n\t\t\t\tif (bd.startspaces < 0)\n\t\t\t\t    bd.startspaces = 0;\n\t\t\t\tstartcol++;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    if (lnum == oap->end.lnum)\n\t\t    {\n\t\t\tendcol = oap->end.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->end, &cs, NULL, &ce);\n\t\t\t    if (p[endcol] == NUL || (cs + oap->end.coladd < ce\n\t\t\t\t\t// Don't add space for double-wide\n\t\t\t\t\t// char; endcol will be on last byte\n\t\t\t\t\t// of multi-byte char.\n\t\t\t\t\t&& (*mb_head_off)(p, p + endcol) == 0))\n\t\t\t    {\n\t\t\t\tif (oap->start.lnum == oap->end.lnum\n\t\t\t\t\t    && oap->start.col == oap->end.col)\n\t\t\t\t{\n\t\t\t\t    // Special case: inside a single char\n\t\t\t\t    is_oneChar = TRUE;\n\t\t\t\t    bd.startspaces = oap->end.coladd\n\t\t\t\t\t - oap->start.coladd + oap->inclusive;\n\t\t\t\t    endcol = startcol;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    bd.endspaces = oap->end.coladd\n\t\t\t\t\t\t\t     + oap->inclusive;\n\t\t\t\t    endcol -= oap->inclusive;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (endcol == MAXCOL)\n\t\t\tendcol = (colnr_T)STRLEN(p);\n\t\t    if (startcol > endcol || is_oneChar)\n\t\t\tbd.textlen = 0;\n\t\t    else\n\t\t\tbd.textlen = endcol - startcol + oap->inclusive;\n\t\t    bd.textstart = p + startcol;\n\t\t    if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)\n\t\t\tgoto fail;\n\t\t    break;\n\t\t}\n\t\t// NOTREACHED\n\t}\n    }\n\n    if (curr != y_current)\t// append the new block to the old block\n    {\n\tnew_ptr = ALLOC_MULT(char_u *, curr->y_size + y_current->y_size);\n\tif (new_ptr == NULL)\n\t    goto fail;\n\tfor (j = 0; j < curr->y_size; ++j)\n\t    new_ptr[j] = curr->y_array[j];\n\tvim_free(curr->y_array);\n\tcurr->y_array = new_ptr;\n#ifdef FEAT_VIMINFO\n\tcurr->y_time_set = vim_time();\n#endif\n\n\tif (yanktype == MLINE)\t// MLINE overrides MCHAR and MBLOCK\n\t    curr->y_type = MLINE;\n\n\t// Concatenate the last line of the old block with the first line of\n\t// the new block, unless being Vi compatible.\n\tif (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)\n\t{\n\t    pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])\n\t\t\t\t\t  + STRLEN(y_current->y_array[0]) + 1);\n\t    if (pnew == NULL)\n\t    {\n\t\ty_idx = y_current->y_size - 1;\n\t\tgoto fail;\n\t    }\n\t    STRCPY(pnew, curr->y_array[--j]);\n\t    STRCAT(pnew, y_current->y_array[0]);\n\t    vim_free(curr->y_array[j]);\n\t    vim_free(y_current->y_array[0]);\n\t    curr->y_array[j++] = pnew;\n\t    y_idx = 1;\n\t}\n\telse\n\t    y_idx = 0;\n\twhile (y_idx < y_current->y_size)\n\t    curr->y_array[j++] = y_current->y_array[y_idx++];\n\tcurr->y_size = j;\n\tvim_free(y_current->y_array);\n\ty_current = curr;\n    }\n\n    if (mess)\t\t\t// Display message about yank?\n    {\n\tif (yanktype == MCHAR\n\t\t&& !oap->block_mode\n\t\t&& yanklines == 1)\n\t    yanklines = 0;\n\t// Some versions of Vi use \">=\" here, some don't...\n\tif (yanklines > p_report)\n\t{\n\t    char namebuf[100];\n\n\t    if (oap->regname == NUL)\n\t\t*namebuf = NUL;\n\t    else\n\t\tvim_snprintf(namebuf, sizeof(namebuf),\n\t\t\t\t\t\t_(\" into \\\"%c\"), oap->regname);\n\n\t    // redisplay now, so message is not deleted\n\t    update_topline_redraw();\n\t    if (oap->block_mode)\n\t    {\n\t\tsmsg(NGETTEXT(\"block of %ld line yanked%s\",\n\t\t\t\t     \"block of %ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t    else\n\t    {\n\t\tsmsg(NGETTEXT(\"%ld line yanked%s\",\n\t\t\t\t\t      \"%ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t}\n    }\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n\tif (yanktype == MLINE && !oap->block_mode)\n\t{\n\t    curbuf->b_op_start.col = 0;\n\t    curbuf->b_op_end.col = MAXCOL;\n\t}\n    }\n\n#ifdef FEAT_CLIPBOARD\n    // If we were yanking to the '*' register, send result to clipboard.\n    // If no register was specified, and \"unnamed\" in 'clipboard', make a copy\n    // to the '*' register.\n    if (clip_star.available\n\t    && (curr == &(y_regs[STAR_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t   && ((clip_unnamed | clip_unnamed_saved) & CLIP_UNNAMED))))\n    {\n\tif (curr != &(y_regs[STAR_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\n\tclip_own_selection(&clip_star);\n\tclip_gen_set_selection(&clip_star);\n# ifdef FEAT_X11\n\tdid_star = TRUE;\n# endif\n    }\n\n# ifdef FEAT_X11\n    // If we were yanking to the '+' register, send result to selection.\n    // Also copy to the '*' register, in case auto-select is off.  But not when\n    // 'clipboard' has \"unnamedplus\" and not \"unnamed\"; and not when\n    // deleting and both \"unnamedplus\" and \"unnamed\".\n    if (clip_plus.available\n\t    && (curr == &(y_regs[PLUS_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t  && ((clip_unnamed | clip_unnamed_saved) &\n\t\t\t\t\t\t\t  CLIP_UNNAMED_PLUS))))\n    {\n\tif (curr != &(y_regs[PLUS_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[PLUS_REGISTER]));\n\n\tclip_own_selection(&clip_plus);\n\tclip_gen_set_selection(&clip_plus);\n\tif (!clip_isautosel_star()\n\t\t&& !clip_isautosel_plus()\n\t\t&& !((clip_unnamed | clip_unnamed_saved) == CLIP_UNNAMED_PLUS)\n\t\t&& !(deleting && (clip_unnamed | clip_unnamed_saved)\n\t\t\t\t\t == (CLIP_UNNAMED | CLIP_UNNAMED_PLUS))\n\t\t&& !did_star\n\t\t&& curr == &(y_regs[PLUS_REGISTER]))\n\t{\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\t    clip_own_selection(&clip_star);\n\t    clip_gen_set_selection(&clip_star);\n\t}\n    }\n# endif\n#endif\n\n#if defined(FEAT_EVAL)\n    if (!deleting && has_textyankpost())\n\tyank_do_autocmd(oap, y_current);\n#endif\n\n    return OK;\n\nfail:\t\t// free the allocated lines\n    free_yank(y_idx + 1);\n    y_current = curr;\n    return FAIL;\n}\n\n/*\n * Copy a block range into a register.\n * If \"exclude_trailing_space\" is set, do not copy trailing whitespaces.\n */\n    static int\nyank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\n\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}\n\n#ifdef FEAT_CLIPBOARD\n/*\n * Make a copy of the y_current register to register \"reg\".\n */\n    static void\ncopy_yank_reg(yankreg_T *reg)\n{\n    yankreg_T\t*curr = y_current;\n    long\tj;\n\n    y_current = reg;\n    free_yank_all();\n    *y_current = *curr;\n    y_current->y_array = lalloc_clear(\n\t\t\t\t    sizeof(char_u *) * y_current->y_size, TRUE);\n    if (y_current->y_array == NULL)\n\ty_current->y_size = 0;\n    else\n\tfor (j = 0; j < y_current->y_size; ++j)\n\t    if ((y_current->y_array[j] = vim_strsave(curr->y_array[j])) == NULL)\n\t    {\n\t\tfree_yank(j);\n\t\ty_current->y_size = 0;\n\t\tbreak;\n\t    }\n    y_current = curr;\n}\n#endif\n\n/*\n * Put contents of register \"regname\" into the text.\n * Caller must check \"regname\" to be valid!\n * \"flags\": PUT_FIXINDENT\tmake indent look nice\n *\t    PUT_CURSEND\t\tleave cursor after end of new text\n *\t    PUT_LINE\t\tforce linewise put (\":put\")\n *\t    PUT_BLOCK_INNER     in block mode, do not add trailing spaces\n */\n    void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int\t\t    spaces = 0;\n\t    char\t    shortline;\n\t    chartabsize_T   cts;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    init_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum, 0,\n\t\t\t\t\t\t\t\t  oldp, oldp);\n\n\t    while (cts.cts_vcol < col && *cts.cts_ptr != NUL)\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(&cts);\n\t\tcts.cts_vcol += incr;\n\t    }\n\t    vcol = cts.cts_vcol;\n\t    ptr = cts.cts_ptr;\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    clear_chartabsize_arg(&cts);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, pad with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tinit_chartabsize_arg(&cts, curwin, 0, 0,\n\t\t\t\t\t\t      y_array[i], y_array[i]);\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t{\n\t\t    spaces -= lbr_chartabsize(&cts);\n\t\t    ++cts.cts_ptr;\n\t\t    cts.cts_vcol = 0;\n\t\t}\n\t\tclear_chartabsize_arg(&cts);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces > 0)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tif (curbuf->b_op_end.col < 0)\n\t    curbuf->b_op_end.col = 0;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Note: this may free \"newp\"\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    inserted_bytes(lnum, col, totlen);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    mark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\n    // Make sure the cursor is not after the NUL.\n    int len = (int)STRLEN(ml_get_curline());\n    if (curwin->w_cursor.col > len)\n    {\n\tif (cur_ve_flags == VE_ALL)\n\t    curwin->w_cursor.coladd = curwin->w_cursor.col - len;\n\tcurwin->w_cursor.col = len;\n    }\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}\n\n/*\n * Return the character name of the register with the given number.\n */\n    int\nget_register_name(int num)\n{\n    if (num == -1)\n\treturn '\"';\n    else if (num < 10)\n\treturn num + '0';\n    else if (num == DELETION_REGISTER)\n\treturn '-';\n#ifdef FEAT_CLIPBOARD\n    else if (num == STAR_REGISTER)\n\treturn '*';\n    else if (num == PLUS_REGISTER)\n\treturn '+';\n#endif\n    else\n\treturn num + 'a' - 10;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the index of the register \"\" points to.\n */\n    int\nget_unname_register(void)\n{\n    return y_previous == NULL ? -1 : y_previous - &y_regs[0];\n}\n#endif\n\n/*\n * \":dis\" and \":registers\": Display the contents of the yank registers.\n */\n    void\nex_display(exarg_T *eap)\n{\n    int\t\ti, n;\n    long\tj;\n    char_u\t*p;\n    yankreg_T\t*yb;\n    int\t\tname;\n    int\t\tattr;\n    char_u\t*arg = eap->arg;\n    int\t\tclen;\n    int\t\ttype;\n\n    if (arg != NULL && *arg == NUL)\n\targ = NULL;\n    attr = HL_ATTR(HLF_8);\n\n    // Highlight title\n    msg_puts_title(_(\"\\nType Name Content\"));\n    for (i = -1; i < NUM_REGISTERS && !got_int; ++i)\n    {\n\tname = get_register_name(i);\n\tswitch (get_reg_type(name, NULL))\n\t{\n\t    case MLINE: type = 'l'; break;\n\t    case MCHAR: type = 'c'; break;\n\t    default:\ttype = 'b'; break;\n\t}\n\tif (arg != NULL && vim_strchr(arg, name) == NULL\n#ifdef ONE_CLIPBOARD\n\t    // Star register and plus register contain the same thing.\n\t\t&& (name != '*' || vim_strchr(arg, '+') == NULL)\n#endif\n\t\t)\n\t    continue;\t    // did not ask for this register\n\n#ifdef FEAT_CLIPBOARD\n\t// Adjust register name for \"unnamed\" in 'clipboard'.\n\t// When it's a clipboard register, fill it with the current contents\n\t// of the clipboard.\n\tadjust_clip_reg(&name);\n\t(void)may_get_selection(name);\n#endif\n\n\tif (i == -1)\n\t{\n\t    if (y_previous != NULL)\n\t\tyb = y_previous;\n\t    else\n\t\tyb = &(y_regs[0]);\n\t}\n\telse\n\t    yb = &(y_regs[i]);\n\n#ifdef FEAT_EVAL\n\tif (name == MB_TOLOWER(redir_reg)\n\t\t|| (redir_reg == '\"' && yb == y_previous))\n\t    continue;\t    // do not list register being written to, the\n\t\t\t    // pointer can be freed\n#endif\n\n\tif (yb->y_array != NULL)\n\t{\n\t    int do_show = FALSE;\n\n\t    for (j = 0; !do_show && j < yb->y_size; ++j)\n\t\tdo_show = !message_filtered(yb->y_array[j]);\n\n\t    if (do_show || yb->y_size == 0)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tmsg_puts(\"  \");\n\t\tmsg_putchar(type);\n\t\tmsg_puts(\"  \");\n\t\tmsg_putchar('\"');\n\t\tmsg_putchar(name);\n\t\tmsg_puts(\"   \");\n\n\t\tn = (int)Columns - 11;\n\t\tfor (j = 0; j < yb->y_size && n > 1; ++j)\n\t\t{\n\t\t    if (j)\n\t\t    {\n\t\t\tmsg_puts_attr(\"^J\", attr);\n\t\t\tn -= 2;\n\t\t    }\n\t\t    for (p = yb->y_array[j];\n\t\t\t\t    *p != NUL && (n -= ptr2cells(p)) >= 0; ++p)\n\t\t    {\n\t\t\tclen = (*mb_ptr2len)(p);\n\t\t\tmsg_outtrans_len(p, clen);\n\t\t\tp += clen - 1;\n\t\t    }\n\t\t}\n\t\tif (n > 1 && yb->y_type == MLINE)\n\t\t    msg_puts_attr(\"^J\", attr);\n\t\tout_flush();\t\t    // show one line at a time\n\t    }\n\t    ui_breakcheck();\n\t}\n    }\n\n    // display last inserted text\n    if ((p = get_last_insert()) != NULL\n\t\t  && (arg == NULL || vim_strchr(arg, '.') != NULL) && !got_int\n\t\t\t\t\t\t      && !message_filtered(p))\n    {\n\tmsg_puts(\"\\n  c  \\\".   \");\n\tdis_msg(p, TRUE);\n    }\n\n    // display last command line\n    if (last_cmdline != NULL && (arg == NULL || vim_strchr(arg, ':') != NULL)\n\t\t\t       && !got_int && !message_filtered(last_cmdline))\n    {\n\tmsg_puts(\"\\n  c  \\\":   \");\n\tdis_msg(last_cmdline, FALSE);\n    }\n\n    // display current file name\n    if (curbuf->b_fname != NULL\n\t    && (arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int\n\t\t\t\t\t&& !message_filtered(curbuf->b_fname))\n    {\n\tmsg_puts(\"\\n  c  \\\"%   \");\n\tdis_msg(curbuf->b_fname, FALSE);\n    }\n\n    // display alternate file name\n    if ((arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int)\n    {\n\tchar_u\t    *fname;\n\tlinenr_T    dummy;\n\n\tif (buflist_name_nr(0, &fname, &dummy) != FAIL\n\t\t\t\t\t\t  && !message_filtered(fname))\n\t{\n\t    msg_puts(\"\\n  c  \\\"#   \");\n\t    dis_msg(fname, FALSE);\n\t}\n    }\n\n    // display last search pattern\n    if (last_search_pat() != NULL\n\t\t && (arg == NULL || vim_strchr(arg, '/') != NULL) && !got_int\n\t\t\t\t      && !message_filtered(last_search_pat()))\n    {\n\tmsg_puts(\"\\n  c  \\\"/   \");\n\tdis_msg(last_search_pat(), FALSE);\n    }\n\n#ifdef FEAT_EVAL\n    // display last used expression\n    if (expr_line != NULL && (arg == NULL || vim_strchr(arg, '=') != NULL)\n\t\t\t\t  && !got_int && !message_filtered(expr_line))\n    {\n\tmsg_puts(\"\\n  c  \\\"=   \");\n\tdis_msg(expr_line, FALSE);\n    }\n#endif\n}\n\n/*\n * display a string for do_dis()\n * truncate at end of screen line\n */\n    static void\ndis_msg(\n    char_u\t*p,\n    int\t\tskip_esc)\t    // if TRUE, ignore trailing ESC\n{\n    int\t\tn;\n    int\t\tl;\n\n    n = (int)Columns - 6;\n    while (*p != NUL\n\t    && !(*p == ESC && skip_esc && *(p + 1) == NUL)\n\t    && (n -= ptr2cells(p)) >= 0)\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t{\n\t    msg_outtrans_len(p, l);\n\t    p += l;\n\t}\n\telse\n\t    msg_outtrans_len(p++, 1);\n    }\n    ui_breakcheck();\n}\n\n#if defined(FEAT_DND) || defined(PROTO)\n/*\n * Replace the contents of the '~' register with str.\n */\n    void\ndnd_yank_drag_data(char_u *str, long len)\n{\n    yankreg_T *curr;\n\n    curr = y_current;\n    y_current = &y_regs[TILDE_REGISTER];\n    free_yank_all();\n    str_to_reg(y_current, MCHAR, str, len, 0L, FALSE);\n    y_current = curr;\n}\n#endif\n\n\n/*\n * Return the type of a register.\n * Used for getregtype()\n * Returns MAUTO for error.\n */\n    char_u\nget_reg_type(int regname, long *reglen)\n{\n    switch (regname)\n    {\n\tcase '%':\t\t// file name\n\tcase '#':\t\t// alternate file name\n\tcase '=':\t\t// expression\n\tcase ':':\t\t// last command line\n\tcase '/':\t\t// last search-pattern\n\tcase '.':\t\t// last inserted text\n\tcase Ctrl_F:\t\t// Filename under cursor\n\tcase Ctrl_P:\t\t// Path under cursor, expand via \"path\"\n\tcase Ctrl_W:\t\t// word under cursor\n\tcase Ctrl_A:\t\t// WORD (mnemonic All) under cursor\n\tcase '_':\t\t// black hole: always empty\n\t    return MCHAR;\n    }\n\n# ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n# endif\n\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn MAUTO;\n\n    get_yank_register(regname, FALSE);\n\n    if (y_current->y_array != NULL)\n    {\n\tif (reglen != NULL && y_current->y_type == MBLOCK)\n\t    *reglen = y_current->y_width;\n\treturn y_current->y_type;\n    }\n    return MAUTO;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * When \"flags\" has GREG_LIST return a list with text \"s\".\n * Otherwise just return \"s\".\n */\n    static char_u *\ngetreg_wrap_one_line(char_u *s, int flags)\n{\n    if (flags & GREG_LIST)\n    {\n\tlist_T *list = list_alloc();\n\n\tif (list != NULL)\n\t{\n\t    if (list_append_string(list, NULL, -1) == FAIL)\n\t    {\n\t\tlist_free(list);\n\t\treturn NULL;\n\t    }\n\t    list->lv_first->li_tv.vval.v_string = s;\n\t}\n\treturn (char_u *)list;\n    }\n    return s;\n}\n\n/*\n * Return the contents of a register as a single allocated string or as a list.\n * Used for \"@r\" in expressions and for getreg().\n * Returns NULL for error.\n * Flags:\n *\tGREG_NO_EXPR\tDo not allow expression register\n *\tGREG_EXPR_SRC\tFor the expression register: return expression itself,\n *\t\t\tnot the result of its evaluation.\n *\tGREG_LIST\tReturn a list of lines instead of a single string.\n */\n    char_u *\nget_reg_contents(int regname, int flags)\n{\n    long\ti;\n    char_u\t*retval;\n    int\t\tallocated;\n    long\tlen;\n\n    // Don't allow using an expression register inside an expression\n    if (regname == '=')\n    {\n\tif (flags & GREG_NO_EXPR)\n\t    return NULL;\n\tif (flags & GREG_EXPR_SRC)\n\t    return getreg_wrap_one_line(get_expr_line_src(), flags);\n\treturn getreg_wrap_one_line(get_expr_line(), flags);\n    }\n\n    if (regname == '@')\t    // \"@@\" is used for unnamed register\n\tregname = '\"';\n\n    // check for valid regname\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn NULL;\n\n# ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n# endif\n\n    if (get_spec_reg(regname, &retval, &allocated, FALSE))\n    {\n\tif (retval == NULL)\n\t    return NULL;\n\tif (allocated)\n\t    return getreg_wrap_one_line(retval, flags);\n\treturn getreg_wrap_one_line(vim_strsave(retval), flags);\n    }\n\n    get_yank_register(regname, FALSE);\n    if (y_current->y_array == NULL)\n\treturn NULL;\n\n    if (flags & GREG_LIST)\n    {\n\tlist_T\t*list = list_alloc();\n\tint\terror = FALSE;\n\n\tif (list == NULL)\n\t    return NULL;\n\tfor (i = 0; i < y_current->y_size; ++i)\n\t    if (list_append_string(list, y_current->y_array[i], -1) == FAIL)\n\t\terror = TRUE;\n\tif (error)\n\t{\n\t    list_free(list);\n\t    return NULL;\n\t}\n\treturn (char_u *)list;\n    }\n\n    // Compute length of resulting string.\n    len = 0;\n    for (i = 0; i < y_current->y_size; ++i)\n    {\n\tlen += (long)STRLEN(y_current->y_array[i]);\n\t// Insert a newline between lines and after last line if\n\t// y_type is MLINE.\n\tif (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t    ++len;\n    }\n\n    retval = alloc(len + 1);\n    if (retval == NULL)\n\treturn NULL;\n\n    // Copy the lines of the yank register into the string.\n    len = 0;\n    for (i = 0; i < y_current->y_size; ++i)\n    {\n\tSTRCPY(retval + len, y_current->y_array[i]);\n\tlen += (long)STRLEN(retval + len);\n\n\t// Insert a NL between lines and after the last line if y_type is\n\t// MLINE.\n\tif (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t    retval[len++] = '\\n';\n    }\n    retval[len] = NUL;\n\n    return retval;\n}\n\n    static int\ninit_write_reg(\n    int\t\tname,\n    yankreg_T\t**old_y_previous,\n    yankreg_T\t**old_y_current,\n    int\t\tmust_append,\n    int\t\t*yank_type UNUSED)\n{\n    if (!valid_yank_reg(name, TRUE))\t    // check for valid reg name\n    {\n\temsg_invreg(name);\n\treturn FAIL;\n    }\n\n    // Don't want to change the current (unnamed) register\n    *old_y_previous = y_previous;\n    *old_y_current = y_current;\n\n    get_yank_register(name, TRUE);\n    if (!y_append && !must_append)\n\tfree_yank_all();\n    return OK;\n}\n\n    static void\nfinish_write_reg(\n    int\t\tname,\n    yankreg_T\t*old_y_previous,\n    yankreg_T\t*old_y_current)\n{\n# ifdef FEAT_CLIPBOARD\n    // Send text of clipboard register to the clipboard.\n    may_set_selection();\n# endif\n\n    // ':let @\" = \"val\"' should change the meaning of the \"\" register\n    if (name != '\"')\n\ty_previous = old_y_previous;\n    y_current = old_y_current;\n}\n\n/*\n * Store string \"str\" in register \"name\".\n * \"maxlen\" is the maximum number of bytes to use, -1 for all bytes.\n * If \"must_append\" is TRUE, always append to the register.  Otherwise append\n * if \"name\" is an uppercase letter.\n * Note: \"maxlen\" and \"must_append\" don't work for the \"/\" register.\n * Careful: 'str' is modified, you may have to use a copy!\n * If \"str\" ends in '\\n' or '\\r', use linewise, otherwise use characterwise.\n */\n    void\nwrite_reg_contents(\n    int\t\tname,\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tmust_append)\n{\n    write_reg_contents_ex(name, str, maxlen, must_append, MAUTO, 0L);\n}\n\n    void\nwrite_reg_contents_lst(\n    int\t\tname,\n    char_u\t**strings,\n    int\t\tmaxlen UNUSED,\n    int\t\tmust_append,\n    int\t\tyank_type,\n    long\tblock_len)\n{\n    yankreg_T  *old_y_previous, *old_y_current;\n\n    if (name == '/' || name == '=')\n    {\n\tchar_u\t*s;\n\n\tif (strings[0] == NULL)\n\t    s = (char_u *)\"\";\n\telse if (strings[1] != NULL)\n\t{\n\t    emsg(_(e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines));\n\t    return;\n\t}\n\telse\n\t    s = strings[0];\n\twrite_reg_contents_ex(name, s, -1, must_append, yank_type, block_len);\n\treturn;\n    }\n\n    if (name == '_')\t    // black hole: nothing to do\n\treturn;\n\n    if (init_write_reg(name, &old_y_previous, &old_y_current, must_append,\n\t\t&yank_type) == FAIL)\n\treturn;\n\n    str_to_reg(y_current, yank_type, (char_u *)strings, -1, block_len, TRUE);\n\n    finish_write_reg(name, old_y_previous, old_y_current);\n}\n\n    void\nwrite_reg_contents_ex(\n    int\t\tname,\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tmust_append,\n    int\t\tyank_type,\n    long\tblock_len)\n{\n    yankreg_T\t*old_y_previous, *old_y_current;\n    long\tlen;\n\n    if (maxlen >= 0)\n\tlen = maxlen;\n    else\n\tlen = (long)STRLEN(str);\n\n    // Special case: '/' search pattern\n    if (name == '/')\n    {\n\tset_last_search_pat(str, RE_SEARCH, TRUE, TRUE);\n\treturn;\n    }\n\n    if (name == '#')\n    {\n\tbuf_T\t*buf;\n\n\tif (VIM_ISDIGIT(*str))\n\t{\n\t    int\tnum = atoi((char *)str);\n\n\t    buf = buflist_findnr(num);\n\t    if (buf == NULL)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), (long)num);\n\t}\n\telse\n\t    buf = buflist_findnr(buflist_findpat(str, str + STRLEN(str),\n\t\t\t\t\t\t\t TRUE, FALSE, FALSE));\n\tif (buf == NULL)\n\t    return;\n\tcurwin->w_alt_fnum = buf->b_fnum;\n\treturn;\n    }\n\n    if (name == '=')\n    {\n\tchar_u\t    *p, *s;\n\n\tp = vim_strnsave(str, len);\n\tif (p == NULL)\n\t    return;\n\tif (must_append && expr_line != NULL)\n\t{\n\t    s = concat_str(expr_line, p);\n\t    vim_free(p);\n\t    p = s;\n\t}\n\tset_expr_line(p, NULL);\n\treturn;\n    }\n\n    if (name == '_')\t    // black hole: nothing to do\n\treturn;\n\n    if (init_write_reg(name, &old_y_previous, &old_y_current, must_append,\n\t\t&yank_type) == FAIL)\n\treturn;\n\n    str_to_reg(y_current, yank_type, str, len, block_len, FALSE);\n\n    finish_write_reg(name, old_y_previous, old_y_current);\n}\n#endif\t// FEAT_EVAL\n\n#if defined(FEAT_CLIPBOARD) || defined(FEAT_EVAL)\n/*\n * Put a string into a register.  When the register is not empty, the string\n * is appended.\n */\n    void\nstr_to_reg(\n    yankreg_T\t*y_ptr,\t\t// pointer to yank register\n    int\t\tyank_type,\t// MCHAR, MLINE, MBLOCK, MAUTO\n    char_u\t*str,\t\t// string to put in register\n    long\tlen,\t\t// length of string\n    long\tblocklen,\t// width of Visual block\n    int\t\tstr_list)\t// TRUE if str is char_u **\n{\n    int\t\ttype;\t\t\t// MCHAR, MLINE or MBLOCK\n    int\t\tlnum;\n    long\tstart;\n    long\ti;\n    int\t\textra;\n    int\t\tnewlines;\t\t// number of lines added\n    int\t\textraline = 0;\t\t// extra line at the end\n    int\t\tappend = FALSE;\t\t// append to last line in register\n    char_u\t*s;\n    char_u\t**ss;\n    char_u\t**pp;\n    long\tmaxlen;\n\n    if (y_ptr->y_array == NULL)\t\t// NULL means empty register\n\ty_ptr->y_size = 0;\n\n    if (yank_type == MAUTO)\n\ttype = ((str_list || (len > 0 && (str[len - 1] == NL\n\t\t\t\t\t    || str[len - 1] == CAR)))\n\t\t\t\t\t\t\t     ? MLINE : MCHAR);\n    else\n\ttype = yank_type;\n\n    // Count the number of lines within the string\n    newlines = 0;\n    if (str_list)\n    {\n\tfor (ss = (char_u **) str; *ss != NULL; ++ss)\n\t    ++newlines;\n    }\n    else\n    {\n\tfor (i = 0; i < len; i++)\n\t    if (str[i] == '\\n')\n\t\t++newlines;\n\tif (type == MCHAR || len == 0 || str[len - 1] != '\\n')\n\t{\n\t    extraline = 1;\n\t    ++newlines;\t// count extra newline at the end\n\t}\n\tif (y_ptr->y_size > 0 && y_ptr->y_type == MCHAR)\n\t{\n\t    append = TRUE;\n\t    --newlines;\t// uncount newline when appending first line\n\t}\n    }\n\n    // Without any lines make the register empty.\n    if (y_ptr->y_size + newlines == 0)\n    {\n\tVIM_CLEAR(y_ptr->y_array);\n\treturn;\n    }\n\n    // Allocate an array to hold the pointers to the new register lines.\n    // If the register was not empty, move the existing lines to the new array.\n    pp = lalloc_clear((y_ptr->y_size + newlines) * sizeof(char_u *), TRUE);\n    if (pp == NULL)\t// out of memory\n\treturn;\n    for (lnum = 0; lnum < y_ptr->y_size; ++lnum)\n\tpp[lnum] = y_ptr->y_array[lnum];\n    vim_free(y_ptr->y_array);\n    y_ptr->y_array = pp;\n    maxlen = 0;\n\n    // Find the end of each line and save it into the array.\n    if (str_list)\n    {\n\tfor (ss = (char_u **) str; *ss != NULL; ++ss, ++lnum)\n\t{\n\t    pp[lnum] = vim_strsave(*ss);\n\t    if (type == MBLOCK)\n\t    {\n\t\tint charlen = mb_string2cells(*ss, -1);\n\n\t\tif (charlen > maxlen)\n\t\t    maxlen = charlen;\n\t    }\n\t}\n    }\n    else\n    {\n\tfor (start = 0; start < len + extraline; start += i + 1)\n\t{\n\t    int charlen = 0;\n\n\t    for (i = start; i < len; ++i)\t// find the end of the line\n\t    {\n\t\tif (str[i] == '\\n')\n\t\t    break;\n\t\tif (type == MBLOCK)\n\t\t    charlen += mb_ptr2cells_len(str + i, len - i);\n\t    }\n\t    i -= start;\t\t\t// i is now length of line\n\t    if (charlen > maxlen)\n\t\tmaxlen = charlen;\n\t    if (append)\n\t    {\n\t\t--lnum;\n\t\textra = (int)STRLEN(y_ptr->y_array[lnum]);\n\t    }\n\t    else\n\t\textra = 0;\n\t    s = alloc(i + extra + 1);\n\t    if (s == NULL)\n\t\tbreak;\n\t    if (extra)\n\t\tmch_memmove(s, y_ptr->y_array[lnum], (size_t)extra);\n\t    if (append)\n\t\tvim_free(y_ptr->y_array[lnum]);\n\t    if (i > 0)\n\t\tmch_memmove(s + extra, str + start, (size_t)i);\n\t    extra += i;\n\t    s[extra] = NUL;\n\t    y_ptr->y_array[lnum++] = s;\n\t    while (--extra >= 0)\n\t    {\n\t\tif (*s == NUL)\n\t\t    *s = '\\n';\t    // replace NUL with newline\n\t\t++s;\n\t    }\n\t    append = FALSE;\t\t    // only first line is appended\n\t}\n    }\n    y_ptr->y_type = type;\n    y_ptr->y_size = lnum;\n    if (type == MBLOCK)\n\ty_ptr->y_width = (blocklen < 0 ? maxlen - 1 : blocklen);\n    else\n\ty_ptr->y_width = 0;\n# ifdef FEAT_VIMINFO\n    y_ptr->y_time_set = vim_time();\n# endif\n}\n#endif // FEAT_CLIPBOARD || FEAT_EVAL || PROTO\n", "\" Tests for register operations\n\nsource check.vim\nsource view_util.vim\n\n\" This test must be executed first to check for empty and unset registers.\nfunc Test_aaa_empty_reg_test()\n  call assert_fails('normal @@', 'E748:')\n  call assert_fails('normal @%', 'E354:')\n  call assert_fails('normal @#', 'E354:')\n  call assert_fails('normal @!', 'E354:')\n  call assert_fails('normal @:', 'E30:')\n  call assert_fails('normal @.', 'E29:')\n  call assert_fails('put /', 'E35:')\n  call assert_fails('put .', 'E29:')\nendfunc\n\nfunc Test_yank_shows_register()\n    enew\n    set report=0\n    call setline(1, ['foo', 'bar'])\n    \" Line-wise\n    exe 'norm! yy'\n    call assert_equal('1 line yanked', v:statusmsg)\n    exe 'norm! \"zyy'\n    call assert_equal('1 line yanked into \"z', v:statusmsg)\n    exe 'norm! yj'\n    call assert_equal('2 lines yanked', v:statusmsg)\n    exe 'norm! \"zyj'\n    call assert_equal('2 lines yanked into \"z', v:statusmsg)\n\n    \" Block-wise\n    exe \"norm! \\<C-V>y\"\n    call assert_equal('block of 1 line yanked', v:statusmsg)\n    exe \"norm! \\<C-V>\\\"zy\"\n    call assert_equal('block of 1 line yanked into \"z', v:statusmsg)\n    exe \"norm! \\<C-V>jy\"\n    call assert_equal('block of 2 lines yanked', v:statusmsg)\n    exe \"norm! \\<C-V>j\\\"zy\"\n    call assert_equal('block of 2 lines yanked into \"z', v:statusmsg)\n\n    bwipe!\nendfunc\n\nfunc Test_display_registers()\n    e file1\n    e file2\n    call setline(1, ['foo', 'bar'])\n    /bar\n    exe 'norm! y2l\"axx'\n    call feedkeys(\"i\\<C-R>=2*4\\n\\<esc>\")\n    call feedkeys(\":ls\\n\", 'xt')\n\n    let a = execute('display')\n    let b = execute('registers')\n\n    call assert_equal(a, b)\n    call assert_match('^\\nType Name Content\\n'\n          \\ .         '  c  \"\"   a\\n'\n          \\ .         '  c  \"0   ba\\n'\n          \\ .         '  c  \"a   b\\n'\n          \\ .         '.*'\n          \\ .         '  c  \"-   a\\n'\n          \\ .         '.*'\n          \\ .         '  c  \":   ls\\n'\n          \\ .         '  c  \"%   file2\\n'\n          \\ .         '  c  \"#   file1\\n'\n          \\ .         '  c  \"/   bar\\n'\n          \\ .         '  c  \"=   2\\*4', a)\n\n    let a = execute('registers a')\n    call assert_match('^\\nType Name Content\\n'\n          \\ .         '  c  \"a   b', a)\n\n    let a = execute('registers :')\n    call assert_match('^\\nType Name Content\\n'\n          \\ .         '  c  \":   ls', a)\n\n    bwipe!\nendfunc\n\nfunc Test_register_one()\n  \" delete a line goes into register one\n  new\n  call setline(1, \"one\")\n  normal dd\n  call assert_equal(\"one\\n\", @1)\n\n  \" delete a word does not change register one, does change \"-\n  call setline(1, \"two\")\n  normal de\n  call assert_equal(\"one\\n\", @1)\n  call assert_equal(\"two\", @-)\n\n  \" delete a word with a register does not change register one\n  call setline(1, \"three\")\n  normal \"ade\n  call assert_equal(\"three\", @a)\n  call assert_equal(\"one\\n\", @1)\n\n  \" delete a word with register DOES change register one with one of a list of\n  \" operators\n  \" %\n  call setline(1, [\"(12)3\"])\n  normal \"ad%\n  call assert_equal(\"(12)\", @a)\n  call assert_equal(\"(12)\", @1)\n\n  \" (\n  call setline(1, [\"first second\"])\n  normal $\"ad(\n  call assert_equal(\"first secon\", @a)\n  call assert_equal(\"first secon\", @1)\n\n  \" )\n  call setline(1, [\"First Second.\"])\n  normal gg0\"ad)\n  call assert_equal(\"First Second.\", @a)\n  call assert_equal(\"First Second.\", @1)\n\n  \" `\n  call setline(1, [\"start here.\"])\n  normal gg0fhmx0\"ad`x\n  call assert_equal(\"start \", @a)\n  call assert_equal(\"start \", @1)\n\n  \" /\n  call setline(1, [\"searchX\"])\n  exe \"normal gg0\\\"ad/X\\<CR>\"\n  call assert_equal(\"search\", @a)\n  call assert_equal(\"search\", @1)\n\n  \" ?\n  call setline(1, [\"Ysearch\"])\n  exe \"normal gg$\\\"ad?Y\\<CR>\"\n  call assert_equal(\"Ysearc\", @a)\n  call assert_equal(\"Ysearc\", @1)\n\n  \" n\n  call setline(1, [\"Ynext\"])\n  normal gg$\"adn\n  call assert_equal(\"Ynex\", @a)\n  call assert_equal(\"Ynex\", @1)\n\n  \" N\n  call setline(1, [\"prevY\"])\n  normal gg0\"adN\n  call assert_equal(\"prev\", @a)\n  call assert_equal(\"prev\", @1)\n\n  \" }\n  call setline(1, [\"one\", \"\"])\n  normal gg0\"ad}\n  call assert_equal(\"one\\n\", @a)\n  call assert_equal(\"one\\n\", @1)\n\n  \" {\n  call setline(1, [\"\", \"two\"])\n  normal 2G$\"ad{\n  call assert_equal(\"\\ntw\", @a)\n  call assert_equal(\"\\ntw\", @1)\n\n  bwipe!\nendfunc\n\nfunc Test_recording_status_in_ex_line()\n  norm qx\n  redraw!\n  call assert_equal('recording @x', Screenline(&lines))\n  set shortmess=q\n  redraw!\n  call assert_equal('recording', Screenline(&lines))\n  set shortmess&\n  norm q\n  redraw!\n  call assert_equal('', Screenline(&lines))\nendfunc\n\n\" Check that replaying a typed sequence does not use an Esc and following\n\" characters as an escape sequence.\nfunc Test_recording_esc_sequence()\n  new\n  try\n    let save_F2 = &t_F2\n  catch\n  endtry\n  let t_F2 = \"\\<Esc>OQ\"\n  call feedkeys(\"qqiTest\\<Esc>\", \"xt\")\n  call feedkeys(\"OQuirk\\<Esc>q\", \"xt\")\n  call feedkeys(\"Go\\<Esc>@q\", \"xt\")\n  call assert_equal(['Quirk', 'Test', 'Quirk', 'Test'], getline(1, 4))\n  bwipe!\n  if exists('save_F2')\n    let &t_F2 = save_F2\n  else\n    set t_F2=\n  endif\nendfunc\n\nfunc Test_recording_with_select_mode()\n  new\n  call feedkeys(\"qacc12345\\<Esc>gH98765\\<Esc>q\", \"tx\")\n  call assert_equal(\"98765\", getline(1))\n  call assert_equal(\"cc12345\\<Esc>gH98765\\<Esc>\", @a)\n  call setline(1, 'asdf')\n  normal! @a\n  call assert_equal(\"98765\", getline(1))\n  bwipe!\nendfunc\n\n\" Test for executing the last used register (@)\nfunc Test_last_used_exec_reg()\n  \" Test for the @: command\n  let a = ''\n  call feedkeys(\":let a ..= 'Vim'\\<CR>\", 'xt')\n  normal @:\n  call assert_equal('VimVim', a)\n\n  \" Test for the @= command\n  let x = ''\n  let a = \":let x ..= 'Vim'\\<CR>\"\n  exe \"normal @=a\\<CR>\"\n  normal @@\n  call assert_equal('VimVim', x)\n\n  \" Test for the @. command\n  let a = ''\n  call feedkeys(\"i:let a ..= 'Edit'\\<CR>\", 'xt')\n  normal @.\n  normal @@\n  call assert_equal('EditEdit', a)\n\n  \" Test for repeating the last command-line in visual mode\n  call append(0, 'register')\n  normal gg\n  let @r = ''\n  call feedkeys(\"v:yank R\\<CR>\", 'xt')\n  call feedkeys(\"v@:\", 'xt')\n  call assert_equal(\"\\nregister\\nregister\\n\", @r)\n\n  enew!\nendfunc\n\nfunc Test_get_register()\n  enew\n  edit Xfile1\n  edit Xfile2\n  call assert_equal('Xfile2', getreg('%'))\n  call assert_equal('Xfile1', getreg('#'))\n\n  call feedkeys(\"iTwo\\<Esc>\", 'xt')\n  call assert_equal('Two', getreg('.'))\n  call assert_equal('', getreg('_'))\n  call assert_beeps('normal \":yy')\n  call assert_beeps('normal \"%yy')\n  call assert_beeps('normal \".yy')\n\n  call assert_equal('', getreg(\"\\<C-F>\"))\n  call assert_equal('', getreg(\"\\<C-W>\"))\n  call assert_equal('', getreg(\"\\<C-L>\"))\n  \" Change the last used register to '\"' for the next test\n  normal! \"\"yy\n  let @\" = 'happy'\n  call assert_equal('happy', getreg())\n  call assert_equal('happy', getreg(''))\n\n  call assert_equal('', getregtype('!'))\n  call assert_fails('echo getregtype([])', 'E730:')\n  call assert_equal('v', getregtype())\n  call assert_equal('v', getregtype(''))\n\n  \" Test for inserting an invalid register content\n  call assert_beeps('exe \"normal i\\<C-R>!\"')\n\n  \" Test for inserting a register with multiple lines\n  call deletebufline('', 1, '$')\n  call setreg('r', ['a', 'b'])\n  exe \"normal i\\<C-R>r\"\n  call assert_equal(['a', 'b', ''], getline(1, '$'))\n\n  \" Test for inserting a multi-line register in the command line\n  call feedkeys(\":\\<C-R>r\\<Esc>\", 'xt')\n  call assert_equal(\"a\\rb\\r\", histget(':', -1))\n\n  call assert_fails('let r = getreg(\"=\", [])', 'E745:')\n  call assert_fails('let r = getreg(\"=\", 1, [])', 'E745:')\n  enew!\n\n  \" Using a register in operator-pending mode should fail\n  call assert_beeps('norm! c\"')\nendfunc\n\nfunc Test_set_register()\n  call assert_fails(\"call setreg('#', 200)\", 'E86:')\n  call assert_fails(\"call setreg('a', test_unknown())\", 'E908:')\n\n  edit Xfile_alt_1\n  let b1 = bufnr('')\n  edit Xfile_alt_2\n  let b2 = bufnr('')\n  edit Xfile_alt_3\n  let b3 = bufnr('')\n  call setreg('#', 'alt_1')\n  call assert_equal('Xfile_alt_1', getreg('#'))\n  call setreg('#', b2)\n  call assert_equal('Xfile_alt_2', getreg('#'))\n\n  let ab = 'regwrite'\n  call setreg('=', '')\n  call setreg('=', 'a', 'a')\n  call setreg('=', 'b', 'a')\n  call assert_equal('regwrite', getreg('='))\n\n  \" Test for setting a list of lines to special registers\n  call setreg('/', [])\n  call assert_equal('', @/)\n  call setreg('=', [])\n  call assert_equal('', @=)\n  call assert_fails(\"call setreg('/', ['a', 'b'])\", 'E883:')\n  call assert_fails(\"call setreg('=', ['a', 'b'])\", 'E883:')\n  call assert_equal(0, setreg('_', ['a', 'b']))\n\n  \" Test for recording to a invalid register\n  call assert_beeps('normal q$')\n\n  \" Appending to a register when recording\n  call append(0, \"text for clipboard test\")\n  normal gg\n  call feedkeys('qrllq', 'xt')\n  call feedkeys('qRhhq', 'xt')\n  call assert_equal('llhh', getreg('r'))\n\n  \" Appending a list of characters to a register from different lines\n  let @r = ''\n  call append(0, ['abcdef', '123456'])\n  normal gg\"ry3l\n  call cursor(2, 4)\n  normal \"Ry3l\n  call assert_equal('abc456', @r)\n\n  \" Test for gP with multiple lines selected using characterwise motion\n  %delete\n  call append(0, ['vim editor', 'vim editor'])\n  let @r = ''\n  exe \"normal ggwy/vim /e\\<CR>gP\"\n  call assert_equal(['vim editor', 'vim editor', 'vim editor'], getline(1, 3))\n\n  \" Test for gP with . register\n  %delete\n  normal iabc\n  normal \".gp\n  call assert_equal('abcabc', getline(1))\n  normal 0\".gP\n  call assert_equal('abcabcabc', getline(1))\n\n  let @\"=''\n  call setreg('', '1')\n  call assert_equal('1', @\")\n  call setreg('@', '2')\n  call assert_equal('2', @\")\n\n  enew!\nendfunc\n\n\" Test for clipboard registers (* and +)\nfunc Test_clipboard_regs()\n  CheckNotGui\n  CheckFeature clipboard_working\n\n  new\n  call append(0, \"text for clipboard test\")\n  normal gg\"*yiw\n  call assert_equal('text', getreg('*'))\n  normal gg2w\"+yiw\n  call assert_equal('clipboard', getreg('+'))\n\n  \" Test for replacing the clipboard register contents\n  set clipboard=unnamed\n  let @* = 'food'\n  normal ggviw\"*p\n  call assert_equal('text', getreg('*'))\n  call assert_equal('food for clipboard test', getline(1))\n  normal ggviw\"*p\n  call assert_equal('food', getreg('*'))\n  call assert_equal('text for clipboard test', getline(1))\n\n  \" Test for replacing the selection register contents\n  set clipboard=unnamedplus\n  let @+ = 'food'\n  normal ggviw\"+p\n  call assert_equal('text', getreg('+'))\n  call assert_equal('food for clipboard test', getline(1))\n  normal ggviw\"+p\n  call assert_equal('food', getreg('+'))\n  call assert_equal('text for clipboard test', getline(1))\n\n  \" Test for auto copying visually selected text to clipboard register\n  call setline(1, \"text for clipboard test\")\n  let @* = ''\n  set clipboard=autoselect\n  normal ggwwviwy\n  call assert_equal('clipboard', @*)\n\n  \" Test for auto copying visually selected text to selection register\n  let @+ = ''\n  set clipboard=autoselectplus\n  normal ggwviwy\n  call assert_equal('for', @+)\n\n  set clipboard&vim\n  bwipe!\nendfunc\n\n\" Test unnamed for both clipboard registers (* and +)\nfunc Test_clipboard_regs_both_unnamed()\n  CheckNotGui\n  CheckFeature clipboard_working\n  CheckTwoClipboards\n\n  let @* = 'xxx'\n  let @+ = 'xxx'\n\n  new\n\n  set clipboard=unnamed,unnamedplus\n  call setline(1, ['foo', 'bar'])\n\n  \" op_yank copies to both\n  :1\n  :normal yw\n  call assert_equal('foo', getreg('*'))\n  call assert_equal('foo', getreg('+'))\n\n  \" op_delete only copies to '+'\n  :2\n  :normal dw\n  call assert_equal('foo', getreg('*'))\n  call assert_equal('bar', getreg('+'))\n\n  set clipboard&vim\n  bwipe!\nendfunc\n\n\" Test for restarting the current mode (insert or virtual replace) after\n\" executing the contents of a register\nfunc Test_put_reg_restart_mode()\n  new\n  call append(0, 'editor')\n  normal gg\n  let @r = \"ivim \\<Esc>\"\n  call feedkeys(\"i\\<C-O>@r\\<C-R>=mode()\\<CR>\", 'xt')\n  call assert_equal('vimi editor', getline(1))\n\n  call setline(1, 'editor')\n  normal gg\n  call feedkeys(\"gR\\<C-O>@r\\<C-R>=mode()\\<CR>\", 'xt')\n  call assert_equal('vimReditor', getline(1))\n\n  bwipe!\nendfunc\n\n\" Test for executing a register using :@ command\nfunc Test_execute_register()\n  call setreg('r', [])\n  call assert_beeps('@r')\n  let i = 1\n  let @q = 'let i+= 1'\n  @q\n  @\n  call assert_equal(3, i)\n\n  \" try to execute expression register and use a backspace to cancel it\n  new\n  call feedkeys(\"@=\\<BS>ax\\<CR>y\", 'xt')\n  call assert_equal(['x', 'y'], getline(1, '$'))\n  close!\n\n  \" cannot execute a register in operator pending mode\n  call assert_beeps('normal! c@r')\nendfunc\n\n\" Test for getting register info\nfunc Test_get_reginfo()\n  enew\n  call setline(1, ['foo', 'bar'])\n\n  exe 'norm! \"zyy'\n  let info = getreginfo('\"')\n  call assert_equal('z', info.points_to)\n  call setreg('y', 'baz')\n  call assert_equal('z', getreginfo('').points_to)\n  call setreg('y', { 'isunnamed': v:true })\n  call assert_equal('y', getreginfo('\"').points_to)\n\n  exe '$put'\n  call assert_equal(getreg('y'), getline(3))\n  call setreg('', 'qux')\n  call assert_equal('0', getreginfo('').points_to)\n  call setreg('x', 'quux')\n  call assert_equal('0', getreginfo('').points_to)\n\n  let info = getreginfo('')\n  call assert_equal(getreg('', 1, 1), info.regcontents)\n  call assert_equal(getregtype(''), info.regtype)\n\n  exe \"norm! 0\\<c-v>e\" .. '\"zy'\n  let info = getreginfo('z')\n  call assert_equal(getreg('z', 1, 1), info.regcontents)\n  call assert_equal(getregtype('z'), info.regtype)\n  call assert_equal(1, +info.isunnamed)\n\n  let info = getreginfo('\"')\n  call assert_equal('z', info.points_to)\n\n  let @a=\"a1b2\"\n  nnoremap <F2> <Cmd>let g:RegInfo = getreginfo()<CR>\n  exe \"normal \\\"a\\<F2>\"\n  call assert_equal({'regcontents': ['a1b2'], 'isunnamed': v:false,\n        \\ 'regtype': 'v'}, g:RegInfo)\n  nunmap <F2>\n  unlet g:RegInfo\n\n  \" The type of \"isunnamed\" was VAR_SPECIAL but should be VAR_BOOL.  Can only\n  \" be noticed when using json_encod().\n  call setreg('a', 'foo')\n  let reginfo = getreginfo('a')\n  let expected = #{regcontents: ['foo'], isunnamed: v:false, regtype: 'v'}\n  call assert_equal(json_encode(expected), json_encode(reginfo))\n\n  bwipe!\nendfunc\n\n\" Test for restoring register with dict from getreginfo\nfunc Test_set_register_dict()\n  enew!\n\n  call setreg('\"', #{ regcontents: ['one', 'two'],\n        \\ regtype: 'V', points_to: 'z' })\n  call assert_equal(['one', 'two'], getreg('\"', 1, 1))\n  let info = getreginfo('\"')\n  call assert_equal('z', info.points_to)\n  call assert_equal('V', info.regtype)\n  call assert_equal(1, +getreginfo('z').isunnamed)\n\n  call setreg('x', #{ regcontents: ['three', 'four'],\n        \\ regtype: 'v', isunnamed: v:true })\n  call assert_equal(['three', 'four'], getreg('\"', 1, 1))\n  let info = getreginfo('\"')\n  call assert_equal('x', info.points_to)\n  call assert_equal('v', info.regtype)\n  call assert_equal(1, +getreginfo('x').isunnamed)\n\n  call setreg('y', #{ regcontents: 'five',\n        \\ regtype: \"\\<c-v>\", isunnamed: v:false })\n  call assert_equal(\"\\<c-v>4\", getreginfo('y').regtype)\n  call assert_equal(0, +getreginfo('y').isunnamed)\n  call assert_equal(['three', 'four'], getreg('\"', 1, 1))\n  call assert_equal('x', getreginfo('\"').points_to)\n\n  call setreg('\"', #{ regcontents: 'six' })\n  call assert_equal('0', getreginfo('\"').points_to)\n  call assert_equal(1, +getreginfo('0').isunnamed)\n  call assert_equal(['six'], getreginfo('0').regcontents)\n  call assert_equal(['six'], getreginfo('\"').regcontents)\n\n  let @x = 'one'\n  call setreg('x', {})\n  call assert_equal(1, len(split(execute('reg x'), '\\n')))\n\n  call assert_fails(\"call setreg('0', #{regtype: 'V'}, 'v')\", 'E118:')\n  call assert_fails(\"call setreg('0', #{regtype: 'X'})\", 'E475:')\n  call assert_fails(\"call setreg('0', #{regtype: 'vy'})\", 'E475:')\n\n  bwipe!\nendfunc\n\nfunc Test_v_register()\n  enew\n  call setline(1, 'nothing')\n\n  func s:Put()\n    let s:register = v:register\n    exec 'normal! \"' .. v:register .. 'P'\n  endfunc\n  nnoremap <buffer> <plug>(test) :<c-u>call s:Put()<cr>\n  nmap <buffer> S <plug>(test)\n\n  let @z = \"testz\\n\"\n  let @\" = \"test@\\n\"\n\n  let s:register = ''\n  call feedkeys('\"_ddS', 'mx')\n  call assert_equal('test@', getline('.'))  \" fails before 8.2.0929\n  call assert_equal('\"', s:register)        \" fails before 8.2.0929\n\n  let s:register = ''\n  call feedkeys('\"zS', 'mx')\n  call assert_equal('z', s:register)\n\n  let s:register = ''\n  call feedkeys('\"zSS', 'mx')\n  call assert_equal('\"', s:register)\n\n  let s:register = ''\n  call feedkeys('\"_S', 'mx')\n  call assert_equal('_', s:register)\n\n  let s:register = ''\n  normal \"_ddS\n  call assert_equal('\"', s:register)        \" fails before 8.2.0929\n  call assert_equal('test@', getline('.'))  \" fails before 8.2.0929\n\n  let s:register = ''\n  execute 'normal \"z:call' \"s:Put()\\n\"\n  call assert_equal('z', s:register)\n  call assert_equal('testz', getline('.'))\n\n  \" Test operator and omap\n  let @b = 'testb'\n  func s:OpFunc(...)\n    let s:register2 = v:register\n  endfunc\n  set opfunc=s:OpFunc\n\n  normal \"bg@l\n  normal S\n  call assert_equal('\"', s:register)        \" fails before 8.2.0929\n  call assert_equal('b', s:register2)\n\n  func s:Motion()\n    let s:register1 = v:register\n    normal! l\n  endfunc\n  onoremap <buffer> Q :<c-u>call s:Motion()<cr>\n\n  normal \"bg@Q\n  normal S\n  call assert_equal('\"', s:register)\n  call assert_equal('b', s:register1)\n  call assert_equal('\"', s:register2)\n\n  set opfunc&\n  bwipe!\nendfunc\n\n\" Test for executing the contents of a register as an Ex command with line\n\" continuation.\nfunc Test_execute_reg_as_ex_cmd()\n  \" Line continuation with just two lines\n  let code =<< trim END\n    let l = [\n      \\ 1]\n  END\n  let @r = code->join(\"\\n\")\n  let l = []\n  @r\n  call assert_equal([1], l)\n\n  \" Line continuation with more than two lines\n  let code =<< trim END\n    let l = [\n      \\ 1,\n      \\ 2,\n      \\ 3]\n  END\n  let @r = code->join(\"\\n\")\n  let l = []\n  @r\n  call assert_equal([1, 2, 3], l)\n\n  \" use comments interspersed with code\n  let code =<< trim END\n    let l = [\n      \"\\ one\n      \\ 1,\n      \"\\ two\n      \\ 2,\n      \"\\ three\n      \\ 3]\n  END\n  let @r = code->join(\"\\n\")\n  let l = []\n  @r\n  call assert_equal([1, 2, 3], l)\n\n  \" use line continuation in the middle\n  let code =<< trim END\n    let a = \"one\"\n    let l = [\n      \\ 1,\n      \\ 2]\n    let b = \"two\"\n  END\n  let @r = code->join(\"\\n\")\n  let l = []\n  @r\n  call assert_equal([1, 2], l)\n  call assert_equal(\"one\", a)\n  call assert_equal(\"two\", b)\n\n  \" only one line with a \\\n  let @r = \"\\\\let l = 1\"\n  call assert_fails('@r', 'E10:')\n\n  \" only one line with a \"\\\n  let @r = '   \"\\ let i = 1'\n  @r\n  call assert_false(exists('i'))\n\n  \" first line also begins with a \\\n  let @r = \"\\\\let l = [\\n\\\\ 1]\"\n  call assert_fails('@r', 'E10:')\n\n  \" Test with a large number of lines\n  let @r = \"let str = \\n\"\n  let @r ..= repeat(\"  \\\\ 'abcdefghijklmnopqrstuvwxyz' ..\\n\", 312)\n  let @r ..= '  \\ \"\"'\n  @r\n  call assert_equal(repeat('abcdefghijklmnopqrstuvwxyz', 312), str)\nendfunc\n\n\" Test for clipboard registers with ASCII NUL\nfunc Test_clipboard_nul()\n  CheckFeature clipboard_working\n  new\n\n  \" Test for putting ASCII NUL into the clipboard\n  set clipboard=unnamed\n  call append(0, \"\\ntest\")\n  normal ggyyp\n  call assert_equal(\"^@test^@\", strtrans(getreg('*')))\n  call assert_equal(getline(1), getline(2))\n  let b = split(execute(\":reg *\"), \"\\n\")\n  call assert_match('\"\\*\\s*\\^@test\\^J',b[1])\n\n  set clipboard&vim\n  bwipe!\nendfunc\n\nfunc Test_ve_blockpaste()\n  new\n  set ve=all\n  0put =['QWERTZ','ASDFGH']\n  call cursor(1,1)\n  exe \":norm! \\<C-V>3ljdP\"\n  call assert_equal(1, col('.'))\n  call assert_equal(getline(1, 2), ['QWERTZ', 'ASDFGH'])\n  call cursor(1,1)\n  exe \":norm! \\<C-V>3ljd\"\n  call cursor(1,1)\n  norm! $3lP\n  call assert_equal(5, col('.'))\n  call assert_equal(getline(1, 2), ['TZ  QWER', 'GH  ASDF'])\n  set ve&vim\n  bwipe!\nendfunc\n\nfunc Test_insert_small_delete()\n  new\n  call setline(1, ['foo foobar bar'])\n  call cursor(1,1)\n  exe \":norm! ciw'\\<C-R>-'\"\n  call assert_equal(\"'foo' foobar bar\", getline(1))\n  exe \":norm! w.w.\"\n  call assert_equal(\"'foo' 'foobar' 'bar'\", getline(1))\n  bwipe!\nendfunc\n\n\" Record in insert mode using CTRL-O\nfunc Test_record_in_insert_mode()\n  new\n  let @r = ''\n  call setline(1, ['foo'])\n  call feedkeys(\"i\\<C-O>qrbaz\\<C-O>q\", 'xt')\n  call assert_equal('baz', @r)\n  bwipe!\nendfunc\n\nfunc Test_record_in_select_mode()\n  new\n  call setline(1, 'text')\n  sil norm \u0016q0\u00070\n  sil norm q\n  call assert_equal('0ext', getline(1))\n\n  %delete\n  let @r = ''\n  call setline(1, ['abc', 'abc', 'abc'])\n  smap <F2> <Right><Right>,\n  call feedkeys(\"qrgh\\<F2>Dk\\<Esc>q\", 'xt')\n  call assert_equal(\"gh\\<F2>Dk\\<Esc>\", @r)\n  norm j0@rj0@@\n  call assert_equal([',Dk', ',Dk', ',Dk'], getline(1, 3))\n  sunmap <F2>\n\n  bwipe!\nendfunc\n\n\" mapping that ends macro recording should be removed from recorded macro\nfunc Test_end_record_using_mapping()\n  call setline(1, 'aaa')\n  nnoremap s q\n  call feedkeys('safas', 'tx')\n  call assert_equal('fa', @a)\n  nunmap s\n\n  nnoremap xx q\n  call feedkeys('0xxafaxx', 'tx')\n  call assert_equal('fa', @a)\n  nunmap xx\n\n  nnoremap xsx q\n  call feedkeys('0qafaxsx', 'tx')\n  call assert_equal('fa', @a)\n  nunmap xsx\n\n  bwipe!\nendfunc\n\nfunc Test_end_reg_executing()\n  nnoremap s <Nop>\n  let @a = 's'\n  call feedkeys(\"@aqaq\\<Esc>\", 'tx')\n  call assert_equal('', @a)\n  call assert_equal('', getline(1))\n\n  call setline(1, 'aaa')\n  nnoremap s qa\n  let @a = 'fa'\n  call feedkeys(\"@asq\\<Esc>\", 'tx')\n  call assert_equal('', @a)\n  call assert_equal('aaa', getline(1))\n\n  nunmap s\n  bwipe!\nendfunc\n\n\" Make sure that y_append is correctly reset\n\" and the previous register is working as expected\nfunc Test_register_y_append_reset()\n  new\n  call setline(1, ['1',\n    \\ '2 ----------------------------------------------------',\n    \\ '3',\n    \\ '4',\n    \\ '5 ----------------------------------------------------',\n    \\ '6',\n    \\ '7',\n    \\ '8 ----------------------------------------------------',\n    \\ '9',\n    \\ '10 aaaaaaa 4.',\n    \\ '11 Game Dbl-Figures Leaders:',\n    \\ '12 Player Pts FG% 3P% FT% RB AS BL ST TO PF EFF',\n    \\ '13 bbbbbbbbb 12 (50 /0 /67 )/ 7/ 3/ 0/ 2/ 3/ 4/+15',\n    \\ '14 cccccc 12 (57 /67 /100)/ 2/ 1/ 1/ 0/ 1/ 3/+12',\n    \\ '15 ddddddd 10 (63 /0 /0 )/ 1/ 3/ 0/ 3/ 5/ 3/ +9',\n    \\ '16 4 5-15 0-3 2-2 5-12 1-1 3-4 33.3 0.0 100 41.7 100 75 12 14',\n    \\ '17 F 23-55 2-10 9-11 23-52 3-13 26-29 41.8 20 81.8 44.2 23.1 89.7 57 75',\n    \\ '18 4 3 6 3 2 3 3 4 3 3 7 3 1 4 6 -1 -1 +2 -1 -2',\n    \\ '19 F 13 19 5 10 4 17 22 9 14 32 13 4 20 17 -1 -13 -4 -3 -3 +5'])\n  11\n  exe \"norm! \\\"a5dd\"\n  norm! j\n  exe \"norm! \\\"bY\"\n  norm! 2j\n  exe \"norm! \\\"BY\"\n  norm! 4k\n  norm! 5dd\n  norm! 3k\n  \" The next put should put the content of the unnamed register, not of\n  \" register b!\n  norm! p\n  call assert_equal(['1',\n    \\ '2 ----------------------------------------------------',\n    \\ '3',\n    \\ '4',\n    \\ '5 ----------------------------------------------------',\n    \\ '6',\n    \\ '10 aaaaaaa 4.',\n    \\ '16 4 5-15 0-3 2-2 5-12 1-1 3-4 33.3 0.0 100 41.7 100 75 12 14',\n    \\ '17 F 23-55 2-10 9-11 23-52 3-13 26-29 41.8 20 81.8 44.2 23.1 89.7 57 75',\n    \\ '18 4 3 6 3 2 3 3 4 3 3 7 3 1 4 6 -1 -1 +2 -1 -2',\n    \\ '19 F 13 19 5 10 4 17 22 9 14 32 13 4 20 17 -1 -13 -4 -3 -3 +5',\n    \\ '7',\n    \\ '8 ----------------------------------------------------',\n    \\ '9'], getline(1,'$'))\n  bwipe!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * register.c: functions for managing registers\n */\n\n#include \"vim.h\"\n\n/*\n * Registers:\n *\t0 = unnamed register, for normal yanks and puts\n *   1..9 = registers '1' to '9', for deletes\n * 10..35 = registers 'a' to 'z' ('A' to 'Z' for appending)\n *     36 = delete register '-'\n *     37 = Selection register '*'. Only if FEAT_CLIPBOARD defined\n *     38 = Clipboard register '+'. Only if FEAT_CLIPBOARD and FEAT_X11 defined\n */\nstatic yankreg_T\ty_regs[NUM_REGISTERS];\n\nstatic yankreg_T\t*y_current;\t    // ptr to current yankreg\nstatic int\t\ty_append;\t    // TRUE when appending\nstatic yankreg_T\t*y_previous = NULL; // ptr to last written yankreg\n\nstatic int\tstuff_yank(int, char_u *);\nstatic void\tput_reedit_in_typebuf(int silent);\nstatic int\tput_in_typebuf(char_u *s, int esc, int colon,\n\t\t\t\t\t\t\t\t int silent);\nstatic int\tyank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space);\n#ifdef FEAT_CLIPBOARD\nstatic void\tcopy_yank_reg(yankreg_T *reg);\n#endif\nstatic void\tdis_msg(char_u *p, int skip_esc);\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    yankreg_T *\nget_y_regs(void)\n{\n    return y_regs;\n}\n#endif\n\n#if defined(FEAT_CLIPBOARD) || defined(PROTO)\n    yankreg_T *\nget_y_register(int reg)\n{\n    return &y_regs[reg];\n}\n#endif\n\n    yankreg_T *\nget_y_current(void)\n{\n    return y_current;\n}\n\n    yankreg_T *\nget_y_previous(void)\n{\n    return y_previous;\n}\n\n    void\nset_y_current(yankreg_T *yreg)\n{\n    y_current = yreg;\n}\n\n    void\nset_y_previous(yankreg_T *yreg)\n{\n    y_previous = yreg;\n}\n\n    void\nreset_y_append(void)\n{\n    y_append = FALSE;\n}\n\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Keep the last expression line here, for repeating.\n */\nstatic char_u\t*expr_line = NULL;\nstatic exarg_T\t*expr_eap = NULL;\n\n/*\n * Get an expression for the \"\\\"=expr1\" or \"CTRL-R =expr1\"\n * Returns '=' when OK, NUL otherwise.\n */\n    int\nget_expr_register(void)\n{\n    char_u\t*new_line;\n\n    new_line = getcmdline('=', 0L, 0, 0);\n    if (new_line == NULL)\n\treturn NUL;\n    if (*new_line == NUL)\t// use previous line\n\tvim_free(new_line);\n    else\n\tset_expr_line(new_line, NULL);\n    return '=';\n}\n\n/*\n * Set the expression for the '=' register.\n * Argument must be an allocated string.\n * \"eap\" may be used if the next line needs to be checked when evaluating the\n * expression.\n */\n    void\nset_expr_line(char_u *new_line, exarg_T *eap)\n{\n    vim_free(expr_line);\n    expr_line = new_line;\n    expr_eap = eap;\n}\n\n/*\n * Get the result of the '=' register expression.\n * Returns a pointer to allocated memory, or NULL for failure.\n */\n    char_u *\nget_expr_line(void)\n{\n    char_u\t*expr_copy;\n    char_u\t*rv;\n    static int\tnested = 0;\n\n    if (expr_line == NULL)\n\treturn NULL;\n\n    // Make a copy of the expression, because evaluating it may cause it to be\n    // changed.\n    expr_copy = vim_strsave(expr_line);\n    if (expr_copy == NULL)\n\treturn NULL;\n\n    // When we are invoked recursively limit the evaluation to 10 levels.\n    // Then return the string as-is.\n    if (nested >= 10)\n\treturn expr_copy;\n\n    ++nested;\n    rv = eval_to_string_eap(expr_copy, TRUE, expr_eap, FALSE);\n    --nested;\n    vim_free(expr_copy);\n    return rv;\n}\n\n/*\n * Get the '=' register expression itself, without evaluating it.\n */\n    static char_u *\nget_expr_line_src(void)\n{\n    if (expr_line == NULL)\n\treturn NULL;\n    return vim_strsave(expr_line);\n}\n#endif // FEAT_EVAL\n\n/*\n * Check if 'regname' is a valid name of a yank register.\n * Note: There is no check for 0 (default register), caller should do this\n */\n    int\nvalid_yank_reg(\n    int\t    regname,\n    int\t    writing)\t    // if TRUE check for writable registers\n{\n    if (       (regname > 0 && ASCII_ISALNUM(regname))\n\t    || (!writing && vim_strchr((char_u *)\n#ifdef FEAT_EVAL\n\t\t\t\t    \"/.%:=\"\n#else\n\t\t\t\t    \"/.%:\"\n#endif\n\t\t\t\t\t, regname) != NULL)\n\t    || regname == '#'\n\t    || regname == '\"'\n\t    || regname == '-'\n\t    || regname == '_'\n#ifdef FEAT_CLIPBOARD\n\t    || regname == '*'\n\t    || regname == '+'\n#endif\n#ifdef FEAT_DND\n\t    || (!writing && regname == '~')\n#endif\n\t\t\t\t\t\t\t)\n\treturn TRUE;\n    return FALSE;\n}\n\n/*\n * Set y_current and y_append, according to the value of \"regname\".\n * Cannot handle the '_' register.\n * Must only be called with a valid register name!\n *\n * If regname is 0 and writing, use register 0\n * If regname is 0 and reading, use previous register\n *\n * Return TRUE when the register should be inserted literally (selection or\n * clipboard).\n */\n    int\nget_yank_register(int regname, int writing)\n{\n    int\t    i;\n    int\t    ret = FALSE;\n\n    y_append = FALSE;\n    if ((regname == 0 || regname == '\"') && !writing && y_previous != NULL)\n    {\n\ty_current = y_previous;\n\treturn ret;\n    }\n    i = regname;\n    if (VIM_ISDIGIT(i))\n\ti -= '0';\n    else if (ASCII_ISLOWER(i))\n\ti = CharOrdLow(i) + 10;\n    else if (ASCII_ISUPPER(i))\n    {\n\ti = CharOrdUp(i) + 10;\n\ty_append = TRUE;\n    }\n    else if (regname == '-')\n\ti = DELETION_REGISTER;\n#ifdef FEAT_CLIPBOARD\n    // When selection is not available, use register 0 instead of '*'\n    else if (clip_star.available && regname == '*')\n    {\n\ti = STAR_REGISTER;\n\tret = TRUE;\n    }\n    // When clipboard is not available, use register 0 instead of '+'\n    else if (clip_plus.available && regname == '+')\n    {\n\ti = PLUS_REGISTER;\n\tret = TRUE;\n    }\n#endif\n#ifdef FEAT_DND\n    else if (!writing && regname == '~')\n\ti = TILDE_REGISTER;\n#endif\n    else\t\t// not 0-9, a-z, A-Z or '-': use register 0\n\ti = 0;\n    y_current = &(y_regs[i]);\n    if (writing)\t// remember the register we write into for do_put()\n\ty_previous = y_current;\n    return ret;\n}\n\n/*\n * Obtain the contents of a \"normal\" register. The register is made empty.\n * The returned pointer has allocated memory, use put_register() later.\n */\n    void *\nget_register(\n    int\t\tname,\n    int\t\tcopy)\t// make a copy, if FALSE make register empty.\n{\n    yankreg_T\t*reg;\n    int\t\ti;\n\n#ifdef FEAT_CLIPBOARD\n    // When Visual area changed, may have to update selection.  Obtain the\n    // selection too.\n    if (name == '*' && clip_star.available)\n    {\n\tif (clip_isautosel_star())\n\t    clip_update_selection(&clip_star);\n\tmay_get_selection(name);\n    }\n    if (name == '+' && clip_plus.available)\n    {\n\tif (clip_isautosel_plus())\n\t    clip_update_selection(&clip_plus);\n\tmay_get_selection(name);\n    }\n#endif\n\n    get_yank_register(name, 0);\n    reg = ALLOC_ONE(yankreg_T);\n    if (reg == NULL)\n\treturn (void *)NULL;\n\n    *reg = *y_current;\n    if (copy)\n    {\n\t// If we run out of memory some or all of the lines are empty.\n\tif (reg->y_size == 0 || y_current->y_array == NULL)\n\t    reg->y_array = NULL;\n\telse\n\t    reg->y_array = ALLOC_MULT(char_u *, reg->y_size);\n\tif (reg->y_array != NULL)\n\t{\n\t    for (i = 0; i < reg->y_size; ++i)\n\t\treg->y_array[i] = vim_strsave(y_current->y_array[i]);\n\t}\n    }\n    else\n\ty_current->y_array = NULL;\n    return (void *)reg;\n}\n\n/*\n * Put \"reg\" into register \"name\".  Free any previous contents and \"reg\".\n */\n    void\nput_register(int name, void *reg)\n{\n    get_yank_register(name, 0);\n    free_yank_all();\n    *y_current = *(yankreg_T *)reg;\n    vim_free(reg);\n\n#ifdef FEAT_CLIPBOARD\n    // Send text written to clipboard register to the clipboard.\n    may_set_selection();\n#endif\n}\n\n#if defined(FEAT_CLIPBOARD) || defined(PROTO)\n    void\nfree_register(void *reg)\n{\n    yankreg_T tmp;\n\n    tmp = *y_current;\n    *y_current = *(yankreg_T *)reg;\n    free_yank_all();\n    vim_free(reg);\n    *y_current = tmp;\n}\n#endif\n\n/*\n * return TRUE if the current yank register has type MLINE\n */\n    int\nyank_register_mline(int regname)\n{\n    if (regname != 0 && !valid_yank_reg(regname, FALSE))\n\treturn FALSE;\n    if (regname == '_')\t\t// black hole is always empty\n\treturn FALSE;\n    get_yank_register(regname, FALSE);\n    return (y_current->y_type == MLINE);\n}\n\n/*\n * Start or stop recording into a yank register.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_record(int c)\n{\n    char_u\t    *p;\n    static int\t    regname;\n    yankreg_T\t    *old_y_previous, *old_y_current;\n    int\t\t    retval;\n\n    if (reg_recording == 0)\t    // start recording\n    {\n\t// registers 0-9, a-z and \" are allowed\n\tif (c < 0 || (!ASCII_ISALNUM(c) && c != '\"'))\n\t    retval = FAIL;\n\telse\n\t{\n\t    reg_recording = c;\n\t    showmode();\n\t    regname = c;\n\t    retval = OK;\n\t}\n    }\n    else\t\t\t    // stop recording\n    {\n\t// Get the recorded key hits.  K_SPECIAL and CSI will be escaped, this\n\t// needs to be removed again to put it in a register.  exec_reg then\n\t// adds the escaping back later.\n\treg_recording = 0;\n\tmsg(\"\");\n\tp = get_recorded();\n\tif (p == NULL)\n\t    retval = FAIL;\n\telse\n\t{\n\t    // Remove escaping for CSI and K_SPECIAL in multi-byte chars.\n\t    vim_unescape_csi(p);\n\n\t    // We don't want to change the default register here, so save and\n\t    // restore the current register name.\n\t    old_y_previous = y_previous;\n\t    old_y_current = y_current;\n\n\t    retval = stuff_yank(regname, p);\n\n\t    y_previous = old_y_previous;\n\t    y_current = old_y_current;\n\t}\n    }\n    return retval;\n}\n\n/*\n * Stuff string \"p\" into yank register \"regname\" as a single line (append if\n * uppercase).\t\"p\" must have been alloced.\n *\n * return FAIL for failure, OK otherwise\n */\n    static int\nstuff_yank(int regname, char_u *p)\n{\n    char_u\t*lp;\n    char_u\t**pp;\n\n    // check for read-only register\n    if (regname != 0 && !valid_yank_reg(regname, TRUE))\n    {\n\tvim_free(p);\n\treturn FAIL;\n    }\n    if (regname == '_')\t\t    // black hole: don't do anything\n    {\n\tvim_free(p);\n\treturn OK;\n    }\n    get_yank_register(regname, TRUE);\n    if (y_append && y_current->y_array != NULL)\n    {\n\tpp = &(y_current->y_array[y_current->y_size - 1]);\n\tlp = alloc(STRLEN(*pp) + STRLEN(p) + 1);\n\tif (lp == NULL)\n\t{\n\t    vim_free(p);\n\t    return FAIL;\n\t}\n\tSTRCPY(lp, *pp);\n\tSTRCAT(lp, p);\n\tvim_free(p);\n\tvim_free(*pp);\n\t*pp = lp;\n    }\n    else\n    {\n\tfree_yank_all();\n\tif ((y_current->y_array = ALLOC_ONE(char_u *)) == NULL)\n\t{\n\t    vim_free(p);\n\t    return FAIL;\n\t}\n\ty_current->y_array[0] = p;\n\ty_current->y_size = 1;\n\ty_current->y_type = MCHAR;  // used to be MLINE, why?\n#ifdef FEAT_VIMINFO\n\ty_current->y_time_set = vim_time();\n#endif\n    }\n    return OK;\n}\n\n/*\n * Last executed register (@ command)\n */\nstatic int execreg_lastc = NUL;\n\n#if defined(FEAT_VIMINFO) || defined(PROTO)\n    int\nget_execreg_lastc(void)\n{\n    return execreg_lastc;\n}\n\n    void\nset_execreg_lastc(int lastc)\n{\n    execreg_lastc = lastc;\n}\n#endif\n\n/*\n * When executing a register as a series of ex-commands, if the\n * line-continuation character is used for a line, then join it with one or\n * more previous lines. Note that lines are processed backwards starting from\n * the last line in the register.\n *\n * Arguments:\n *   lines - list of lines in the register\n *   idx - index of the line starting with \\ or \"\\. Join this line with all the\n *\t   immediate predecessor lines that start with a \\ and the first line\n *\t   that doesn't start with a \\. Lines that start with a comment \"\\\n *\t   character are ignored.\n *\n * Returns the concatenated line. The index of the line that should be\n * processed next is returned in idx.\n */\n    static char_u *\nexecreg_line_continuation(char_u **lines, long *idx)\n{\n    garray_T\tga;\n    long\ti = *idx;\n    char_u\t*p;\n    int\t\tcmd_start;\n    int\t\tcmd_end = i;\n    int\t\tj;\n    char_u\t*str;\n\n    ga_init2(&ga, sizeof(char_u), 400);\n\n    // search backwards to find the first line of this command.\n    // Any line not starting with \\ or \"\\ is the start of the\n    // command.\n    while (--i > 0)\n    {\n\tp = skipwhite(lines[i]);\n\tif (*p != '\\\\' && (p[0] != '\"' || p[1] != '\\\\' || p[2] != ' '))\n\t    break;\n    }\n    cmd_start = i;\n\n    // join all the lines\n    ga_concat(&ga, lines[cmd_start]);\n    for (j = cmd_start + 1; j <= cmd_end; j++)\n    {\n\tp = skipwhite(lines[j]);\n\tif (*p == '\\\\')\n\t{\n\t    // Adjust the growsize to the current length to\n\t    // speed up concatenating many lines.\n\t    if (ga.ga_len > 400)\n\t    {\n\t\tif (ga.ga_len > 8000)\n\t\t    ga.ga_growsize = 8000;\n\t\telse\n\t\t    ga.ga_growsize = ga.ga_len;\n\t    }\n\t    ga_concat(&ga, p + 1);\n\t}\n    }\n    ga_append(&ga, NUL);\n    str = vim_strsave(ga.ga_data);\n    ga_clear(&ga);\n\n    *idx = i;\n    return str;\n}\n\n/*\n * Execute a yank register: copy it into the stuff buffer.\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\ndo_execreg(\n    int\t    regname,\n    int\t    colon,\t\t// insert ':' before each line\n    int\t    addcr,\t\t// always add '\\n' to end of line\n    int\t    silent)\t\t// set \"silent\" flag in typeahead buffer\n{\n    long\ti;\n    char_u\t*p;\n    int\t\tretval = OK;\n    int\t\tremap;\n\n    // repeat previous one\n    if (regname == '@')\n    {\n\tif (execreg_lastc == NUL)\n\t{\n\t    emsg(_(e_no_previously_used_register));\n\t    return FAIL;\n\t}\n\tregname = execreg_lastc;\n    }\n    // check for valid regname\n    if (regname == '%' || regname == '#' || !valid_yank_reg(regname, FALSE))\n    {\n\temsg_invreg(regname);\n\treturn FAIL;\n    }\n    execreg_lastc = regname;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    // black hole: don't stuff anything\n    if (regname == '_')\n\treturn OK;\n\n    // use last command line\n    if (regname == ':')\n    {\n\tif (last_cmdline == NULL)\n\t{\n\t    emsg(_(e_no_previous_command_line));\n\t    return FAIL;\n\t}\n\t// don't keep the cmdline containing @:\n\tVIM_CLEAR(new_last_cmdline);\n\t// Escape all control characters with a CTRL-V\n\tp = vim_strsave_escaped_ext(last_cmdline,\n\t\t    (char_u *)\"\\001\\002\\003\\004\\005\\006\\007\"\n\t\t\t  \"\\010\\011\\012\\013\\014\\015\\016\\017\"\n\t\t\t  \"\\020\\021\\022\\023\\024\\025\\026\\027\"\n\t\t\t  \"\\030\\031\\032\\033\\034\\035\\036\\037\",\n\t\t    Ctrl_V, FALSE);\n\tif (p != NULL)\n\t{\n\t    // When in Visual mode \"'<,'>\" will be prepended to the command.\n\t    // Remove it when it's already there.\n\t    if (VIsual_active && STRNCMP(p, \"'<,'>\", 5) == 0)\n\t\tretval = put_in_typebuf(p + 5, TRUE, TRUE, silent);\n\t    else\n\t\tretval = put_in_typebuf(p, TRUE, TRUE, silent);\n\t}\n\tvim_free(p);\n    }\n#ifdef FEAT_EVAL\n    else if (regname == '=')\n    {\n\tp = get_expr_line();\n\tif (p == NULL)\n\t    return FAIL;\n\tretval = put_in_typebuf(p, TRUE, colon, silent);\n\tvim_free(p);\n    }\n#endif\n    else if (regname == '.')\t\t// use last inserted text\n    {\n\tp = get_last_insert_save();\n\tif (p == NULL)\n\t{\n\t    emsg(_(e_no_inserted_text_yet));\n\t    return FAIL;\n\t}\n\tretval = put_in_typebuf(p, FALSE, colon, silent);\n\tvim_free(p);\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\tif (y_current->y_array == NULL)\n\t    return FAIL;\n\n\t// Disallow remapping for \":@r\".\n\tremap = colon ? REMAP_NONE : REMAP_YES;\n\n\t// Insert lines into typeahead buffer, from last one to first one.\n\tput_reedit_in_typebuf(silent);\n\tfor (i = y_current->y_size; --i >= 0; )\n\t{\n\t    char_u *escaped;\n\t    char_u *str;\n\t    int\t    free_str = FALSE;\n\n\t    // insert NL between lines and after last line if type is MLINE\n\t    if (y_current->y_type == MLINE || i < y_current->y_size - 1\n\t\t\t\t\t\t\t\t     || addcr)\n\t    {\n\t\tif (ins_typebuf((char_u *)\"\\n\", remap, 0, TRUE, silent) == FAIL)\n\t\t    return FAIL;\n\t    }\n\n\t    // Handle line-continuation for :@<register>\n\t    str = y_current->y_array[i];\n\t    if (colon && i > 0)\n\t    {\n\t\tp = skipwhite(str);\n\t\tif (*p == '\\\\' || (p[0] == '\"' && p[1] == '\\\\' && p[2] == ' '))\n\t\t{\n\t\t    str = execreg_line_continuation(y_current->y_array, &i);\n\t\t    if (str == NULL)\n\t\t\treturn FAIL;\n\t\t    free_str = TRUE;\n\t\t}\n\t    }\n\t    escaped = vim_strsave_escape_csi(str);\n\t    if (free_str)\n\t\tvim_free(str);\n\t    if (escaped == NULL)\n\t\treturn FAIL;\n\t    retval = ins_typebuf(escaped, remap, 0, TRUE, silent);\n\t    vim_free(escaped);\n\t    if (retval == FAIL)\n\t\treturn FAIL;\n\t    if (colon && ins_typebuf((char_u *)\":\", remap, 0, TRUE, silent)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\treturn FAIL;\n\t}\n\treg_executing = regname == 0 ? '\"' : regname; // disable \"q\" command\n    }\n    return retval;\n}\n\n/*\n * If \"restart_edit\" is not zero, put it in the typeahead buffer, so that it's\n * used only after other typeahead has been processed.\n */\n    static void\nput_reedit_in_typebuf(int silent)\n{\n    char_u\tbuf[3];\n\n    if (restart_edit == NUL)\n\treturn;\n\n    if (restart_edit == 'V')\n    {\n\tbuf[0] = 'g';\n\tbuf[1] = 'R';\n\tbuf[2] = NUL;\n    }\n    else\n    {\n\tbuf[0] = restart_edit == 'I' ? 'i' : restart_edit;\n\tbuf[1] = NUL;\n    }\n    if (ins_typebuf(buf, REMAP_NONE, 0, TRUE, silent) == OK)\n\trestart_edit = NUL;\n}\n\n/*\n * Insert register contents \"s\" into the typeahead buffer, so that it will be\n * executed again.\n * When \"esc\" is TRUE it is to be taken literally: Escape CSI characters and\n * no remapping.\n */\n    static int\nput_in_typebuf(\n    char_u\t*s,\n    int\t\tesc,\n    int\t\tcolon,\t    // add ':' before the line\n    int\t\tsilent)\n{\n    int\t\tretval = OK;\n\n    put_reedit_in_typebuf(silent);\n    if (colon)\n\tretval = ins_typebuf((char_u *)\"\\n\", REMAP_NONE, 0, TRUE, silent);\n    if (retval == OK)\n    {\n\tchar_u\t*p;\n\n\tif (esc)\n\t    p = vim_strsave_escape_csi(s);\n\telse\n\t    p = s;\n\tif (p == NULL)\n\t    retval = FAIL;\n\telse\n\t    retval = ins_typebuf(p, esc ? REMAP_NONE : REMAP_YES,\n\t\t\t\t\t\t\t     0, TRUE, silent);\n\tif (esc)\n\t    vim_free(p);\n    }\n    if (colon && retval == OK)\n\tretval = ins_typebuf((char_u *)\":\", REMAP_NONE, 0, TRUE, silent);\n    return retval;\n}\n\n/*\n * Insert a yank register: copy it into the Read buffer.\n * Used by CTRL-R command and middle mouse button in insert mode.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ninsert_reg(\n    int\t\tregname,\n    int\t\tliterally_arg)\t// insert literally, not as if typed\n{\n    long\ti;\n    int\t\tretval = OK;\n    char_u\t*arg;\n    int\t\tallocated;\n    int\t\tliterally = literally_arg;\n\n    // It is possible to get into an endless loop by having CTRL-R a in\n    // register a and then, in insert mode, doing CTRL-R a.\n    // If you hit CTRL-C, the loop will be broken here.\n    ui_breakcheck();\n    if (got_int)\n\treturn FAIL;\n\n    // check for valid regname\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn FAIL;\n\n#ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n#endif\n\n    if (regname == '.')\t\t\t// insert last inserted text\n\tretval = stuff_inserted(NUL, 1L, TRUE);\n    else if (get_spec_reg(regname, &arg, &allocated, TRUE))\n    {\n\tif (arg == NULL)\n\t    return FAIL;\n\tstuffescaped(arg, literally);\n\tif (allocated)\n\t    vim_free(arg);\n    }\n    else\t\t\t\t// name or number register\n    {\n\tif (get_yank_register(regname, FALSE))\n\t    literally = TRUE;\n\tif (y_current->y_array == NULL)\n\t    retval = FAIL;\n\telse\n\t{\n\t    for (i = 0; i < y_current->y_size; ++i)\n\t    {\n\t\tif (regname == '-')\n\t\t{\n\t\t    AppendCharToRedobuff(Ctrl_R);\n\t\t    AppendCharToRedobuff(regname);\n\t\t    do_put(regname, NULL, BACKWARD, 1L, PUT_CURSEND);\n\t\t}\n\t\telse\n\t\t    stuffescaped(y_current->y_array[i], literally);\n\t\t// Insert a newline between lines and after last line if\n\t\t// y_type is MLINE.\n\t\tif (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t\t    stuffcharReadbuff('\\n');\n\t    }\n\t}\n    }\n\n    return retval;\n}\n\n/*\n * If \"regname\" is a special register, return TRUE and store a pointer to its\n * value in \"argp\".\n */\n    int\nget_spec_reg(\n    int\t\tregname,\n    char_u\t**argp,\n    int\t\t*allocated,\t// return: TRUE when value was allocated\n    int\t\terrmsg)\t\t// give error message when failing\n{\n    int\t\tcnt;\n\n    *argp = NULL;\n    *allocated = FALSE;\n    switch (regname)\n    {\n\tcase '%':\t\t// file name\n\t    if (errmsg)\n\t\tcheck_fname();\t// will give emsg if not set\n\t    *argp = curbuf->b_fname;\n\t    return TRUE;\n\n\tcase '#':\t\t// alternate file name\n\t    *argp = getaltfname(errmsg);\t// may give emsg if not set\n\t    return TRUE;\n\n#ifdef FEAT_EVAL\n\tcase '=':\t\t// result of expression\n\t    *argp = get_expr_line();\n\t    *allocated = TRUE;\n\t    return TRUE;\n#endif\n\n\tcase ':':\t\t// last command line\n\t    if (last_cmdline == NULL && errmsg)\n\t\temsg(_(e_no_previous_command_line));\n\t    *argp = last_cmdline;\n\t    return TRUE;\n\n\tcase '/':\t\t// last search-pattern\n\t    if (last_search_pat() == NULL && errmsg)\n\t\temsg(_(e_no_previous_regular_expression));\n\t    *argp = last_search_pat();\n\t    return TRUE;\n\n\tcase '.':\t\t// last inserted text\n\t    *argp = get_last_insert_save();\n\t    *allocated = TRUE;\n\t    if (*argp == NULL && errmsg)\n\t\temsg(_(e_no_inserted_text_yet));\n\t    return TRUE;\n\n\tcase Ctrl_F:\t\t// Filename under cursor\n\tcase Ctrl_P:\t\t// Path under cursor, expand via \"path\"\n\t    if (!errmsg)\n\t\treturn FALSE;\n\t    *argp = file_name_at_cursor(FNAME_MESS | FNAME_HYP\n\t\t\t    | (regname == Ctrl_P ? FNAME_EXP : 0), 1L, NULL);\n\t    *allocated = TRUE;\n\t    return TRUE;\n\n\tcase Ctrl_W:\t\t// word under cursor\n\tcase Ctrl_A:\t\t// WORD (mnemonic All) under cursor\n\t    if (!errmsg)\n\t\treturn FALSE;\n\t    cnt = find_ident_under_cursor(argp, regname == Ctrl_W\n\t\t\t\t   ?  (FIND_IDENT|FIND_STRING) : FIND_STRING);\n\t    *argp = cnt ? vim_strnsave(*argp, cnt) : NULL;\n\t    *allocated = TRUE;\n\t    return TRUE;\n\n\tcase Ctrl_L:\t\t// Line under cursor\n\t    if (!errmsg)\n\t\treturn FALSE;\n\n\t    *argp = ml_get_buf(curwin->w_buffer,\n\t\t\tcurwin->w_cursor.lnum, FALSE);\n\t    return TRUE;\n\n\tcase '_':\t\t// black hole: always empty\n\t    *argp = (char_u *)\"\";\n\t    return TRUE;\n    }\n\n    return FALSE;\n}\n\n/*\n * Paste a yank register into the command line.\n * Only for non-special registers.\n * Used by CTRL-R command in command-line mode\n * insert_reg() can't be used here, because special characters from the\n * register contents will be interpreted as commands.\n *\n * return FAIL for failure, OK otherwise\n */\n    int\ncmdline_paste_reg(\n    int regname,\n    int literally_arg,\t// Insert text literally instead of \"as typed\"\n    int remcr)\t\t// don't add CR characters\n{\n    long\ti;\n    int\t\tliterally = literally_arg;\n\n    if (get_yank_register(regname, FALSE))\n\tliterally = TRUE;\n    if (y_current->y_array == NULL)\n\treturn FAIL;\n\n    for (i = 0; i < y_current->y_size; ++i)\n    {\n\tcmdline_paste_str(y_current->y_array[i], literally);\n\n\t// Insert ^M between lines and after last line if type is MLINE.\n\t// Don't do this when \"remcr\" is TRUE.\n\tif ((y_current->y_type == MLINE || i < y_current->y_size - 1) && !remcr)\n\t    cmdline_paste_str((char_u *)\"\\r\", literally);\n\n\t// Check for CTRL-C, in case someone tries to paste a few thousand\n\t// lines and gets bored.\n\tui_breakcheck();\n\tif (got_int)\n\t    return FAIL;\n    }\n    return OK;\n}\n\n/*\n * Shift the delete registers: \"9 is cleared, \"8 becomes \"9, etc.\n */\n    void\nshift_delete_registers(void)\n{\n    int\t\tn;\n\n    y_current = &y_regs[9];\n    free_yank_all();\t\t\t// free register nine\n    for (n = 9; n > 1; --n)\n\ty_regs[n] = y_regs[n - 1];\n    y_current = &y_regs[1];\n    if (!y_append)\n\ty_previous = y_current;\n    y_regs[1].y_array = NULL;\t\t// set register one to empty\n}\n\n#if defined(FEAT_EVAL)\n    void\nyank_do_autocmd(oparg_T *oap, yankreg_T *reg)\n{\n    static int\t    recursive = FALSE;\n    dict_T\t    *v_event;\n    list_T\t    *list;\n    int\t\t    n;\n    char_u\t    buf[NUMBUFLEN + 2];\n    long\t    reglen = 0;\n    save_v_event_T  save_v_event;\n\n    if (recursive)\n\treturn;\n\n    v_event = get_v_event(&save_v_event);\n\n    list = list_alloc();\n    if (list == NULL)\n\treturn;\n\n    // yanked text contents\n    for (n = 0; n < reg->y_size; n++)\n\tlist_append_string(list, reg->y_array[n], -1);\n    list->lv_lock = VAR_FIXED;\n    (void)dict_add_list(v_event, \"regcontents\", list);\n\n    // register name or empty string for unnamed operation\n    buf[0] = (char_u)oap->regname;\n    buf[1] = NUL;\n    (void)dict_add_string(v_event, \"regname\", buf);\n\n    // motion type: inclusive or exclusive\n    (void)dict_add_bool(v_event, \"inclusive\", oap->inclusive);\n\n    // kind of operation (yank, delete, change)\n    buf[0] = get_op_char(oap->op_type);\n    buf[1] = get_extra_op_char(oap->op_type);\n    buf[2] = NUL;\n    (void)dict_add_string(v_event, \"operator\", buf);\n\n    // register type\n    buf[0] = NUL;\n    buf[1] = NUL;\n    switch (get_reg_type(oap->regname, &reglen))\n    {\n\tcase MLINE: buf[0] = 'V'; break;\n\tcase MCHAR: buf[0] = 'v'; break;\n\tcase MBLOCK:\n\t\tvim_snprintf((char *)buf, sizeof(buf), \"%c%ld\", Ctrl_V,\n\t\t\t     reglen + 1);\n\t\tbreak;\n    }\n    (void)dict_add_string(v_event, \"regtype\", buf);\n\n    // selection type - visual or not\n    (void)dict_add_bool(v_event, \"visual\", oap->is_VIsual);\n\n    // Lock the dictionary and its keys\n    dict_set_items_ro(v_event);\n\n    recursive = TRUE;\n    textlock++;\n    apply_autocmds(EVENT_TEXTYANKPOST, NULL, NULL, FALSE, curbuf);\n    textlock--;\n    recursive = FALSE;\n\n    // Empty the dictionary, v:event is still valid\n    restore_v_event(v_event, &save_v_event);\n}\n#endif\n\n/*\n * set all the yank registers to empty (called from main())\n */\n    void\ninit_yank(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < NUM_REGISTERS; ++i)\n\ty_regs[i].y_array = NULL;\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nclear_registers(void)\n{\n    int\t\ti;\n\n    for (i = 0; i < NUM_REGISTERS; ++i)\n    {\n\ty_current = &y_regs[i];\n\tif (y_current->y_array != NULL)\n\t    free_yank_all();\n    }\n}\n#endif\n\n/*\n * Free \"n\" lines from the current yank register.\n * Called for normal freeing and in case of error.\n */\n    static void\nfree_yank(long n)\n{\n    if (y_current->y_array == NULL)\n\treturn;\n\n    long\t    i;\n\n    for (i = n; --i >= 0; )\n\tvim_free(y_current->y_array[i]);\n    VIM_CLEAR(y_current->y_array);\n}\n\n    void\nfree_yank_all(void)\n{\n    free_yank(y_current->y_size);\n}\n\n/*\n * Yank the text between \"oap->start\" and \"oap->end\" into a yank register.\n * If we are to append (uppercase register), we first yank into a new yank\n * register and then concatenate the old and the new one (so we keep the old\n * one in case of out-of-memory).\n *\n * Return FAIL for failure, OK otherwise.\n */\n    int\nop_yank(oparg_T *oap, int deleting, int mess)\n{\n    long\t\ty_idx;\t\t// index in y_array[]\n    yankreg_T\t\t*curr;\t\t// copy of y_current\n    yankreg_T\t\tnewreg;\t\t// new yank register when appending\n    char_u\t\t**new_ptr;\n    linenr_T\t\tlnum;\t\t// current line number\n    long\t\tj;\n    int\t\t\tyanktype = oap->motion_type;\n    long\t\tyanklines = oap->line_count;\n    linenr_T\t\tyankendlnum = oap->end.lnum;\n    char_u\t\t*p;\n    char_u\t\t*pnew;\n    struct block_def\tbd;\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)\n    int\t\t\tdid_star = FALSE;\n#endif\n\n\t\t\t\t    // check for read-only register\n    if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))\n    {\n\tbeep_flush();\n\treturn FAIL;\n    }\n    if (oap->regname == '_')\t    // black hole: nothing to do\n\treturn OK;\n\n#ifdef FEAT_CLIPBOARD\n    if (!clip_star.available && oap->regname == '*')\n\toap->regname = 0;\n    else if (!clip_plus.available && oap->regname == '+')\n\toap->regname = 0;\n#endif\n\n    if (!deleting)\t\t    // op_delete() already set y_current\n\tget_yank_register(oap->regname, TRUE);\n\n    curr = y_current;\n\t\t\t\t    // append to existing contents\n    if (y_append && y_current->y_array != NULL)\n\ty_current = &newreg;\n    else\n\tfree_yank_all();\t    // free previously yanked lines\n\n    // If the cursor was in column 1 before and after the movement, and the\n    // operator is not inclusive, the yank is always linewise.\n    if (       oap->motion_type == MCHAR\n\t    && oap->start.col == 0\n\t    && !oap->inclusive\n\t    && (!oap->is_VIsual || *p_sel == 'o')\n\t    && !oap->block_mode\n\t    && oap->end.col == 0\n\t    && yanklines > 1)\n    {\n\tyanktype = MLINE;\n\t--yankendlnum;\n\t--yanklines;\n    }\n\n    y_current->y_size = yanklines;\n    y_current->y_type = yanktype;   // set the yank register type\n    y_current->y_width = 0;\n    y_current->y_array = lalloc_clear(sizeof(char_u *) * yanklines, TRUE);\n    if (y_current->y_array == NULL)\n    {\n\ty_current = curr;\n\treturn FAIL;\n    }\n#ifdef FEAT_VIMINFO\n    y_current->y_time_set = vim_time();\n#endif\n\n    y_idx = 0;\n    lnum = oap->start.lnum;\n\n    if (oap->block_mode)\n    {\n\t// Visual block mode\n\ty_current->y_type = MBLOCK;\t    // set the yank register type\n\ty_current->y_width = oap->end_vcol - oap->start_vcol;\n\n\tif (curwin->w_curswant == MAXCOL && y_current->y_width > 0)\n\t    y_current->y_width--;\n    }\n\n    for ( ; lnum <= yankendlnum; lnum++, y_idx++)\n    {\n\tswitch (y_current->y_type)\n\t{\n\t    case MBLOCK:\n\t\tblock_prep(oap, &bd, lnum, FALSE);\n\t\tif (yank_copy_line(&bd, y_idx, oap->excl_tr_ws) == FAIL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MLINE:\n\t\tif ((y_current->y_array[y_idx] =\n\t\t\t\t\t    vim_strsave(ml_get(lnum))) == NULL)\n\t\t    goto fail;\n\t\tbreak;\n\n\t    case MCHAR:\n\t\t{\n\t\t    colnr_T startcol = 0, endcol = MAXCOL;\n\t\t    int\t    is_oneChar = FALSE;\n\t\t    colnr_T cs, ce;\n\n\t\t    p = ml_get(lnum);\n\t\t    bd.startspaces = 0;\n\t\t    bd.endspaces = 0;\n\n\t\t    if (lnum == oap->start.lnum)\n\t\t    {\n\t\t\tstartcol = oap->start.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->start, &cs, NULL, &ce);\n\t\t\t    if (ce != cs && oap->start.coladd > 0)\n\t\t\t    {\n\t\t\t\t// Part of a tab selected -- but don't\n\t\t\t\t// double-count it.\n\t\t\t\tbd.startspaces = (ce - cs + 1)\n\t\t\t\t\t\t\t  - oap->start.coladd;\n\t\t\t\tif (bd.startspaces < 0)\n\t\t\t\t    bd.startspaces = 0;\n\t\t\t\tstartcol++;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\n\t\t    if (lnum == oap->end.lnum)\n\t\t    {\n\t\t\tendcol = oap->end.col;\n\t\t\tif (virtual_op)\n\t\t\t{\n\t\t\t    getvcol(curwin, &oap->end, &cs, NULL, &ce);\n\t\t\t    if (p[endcol] == NUL || (cs + oap->end.coladd < ce\n\t\t\t\t\t// Don't add space for double-wide\n\t\t\t\t\t// char; endcol will be on last byte\n\t\t\t\t\t// of multi-byte char.\n\t\t\t\t\t&& (*mb_head_off)(p, p + endcol) == 0))\n\t\t\t    {\n\t\t\t\tif (oap->start.lnum == oap->end.lnum\n\t\t\t\t\t    && oap->start.col == oap->end.col)\n\t\t\t\t{\n\t\t\t\t    // Special case: inside a single char\n\t\t\t\t    is_oneChar = TRUE;\n\t\t\t\t    bd.startspaces = oap->end.coladd\n\t\t\t\t\t - oap->start.coladd + oap->inclusive;\n\t\t\t\t    endcol = startcol;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t    bd.endspaces = oap->end.coladd\n\t\t\t\t\t\t\t     + oap->inclusive;\n\t\t\t\t    endcol -= oap->inclusive;\n\t\t\t\t}\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    if (endcol == MAXCOL)\n\t\t\tendcol = (colnr_T)STRLEN(p);\n\t\t    if (startcol > endcol || is_oneChar)\n\t\t\tbd.textlen = 0;\n\t\t    else\n\t\t\tbd.textlen = endcol - startcol + oap->inclusive;\n\t\t    bd.textstart = p + startcol;\n\t\t    if (yank_copy_line(&bd, y_idx, FALSE) == FAIL)\n\t\t\tgoto fail;\n\t\t    break;\n\t\t}\n\t\t// NOTREACHED\n\t}\n    }\n\n    if (curr != y_current)\t// append the new block to the old block\n    {\n\tnew_ptr = ALLOC_MULT(char_u *, curr->y_size + y_current->y_size);\n\tif (new_ptr == NULL)\n\t    goto fail;\n\tfor (j = 0; j < curr->y_size; ++j)\n\t    new_ptr[j] = curr->y_array[j];\n\tvim_free(curr->y_array);\n\tcurr->y_array = new_ptr;\n#ifdef FEAT_VIMINFO\n\tcurr->y_time_set = vim_time();\n#endif\n\n\tif (yanktype == MLINE)\t// MLINE overrides MCHAR and MBLOCK\n\t    curr->y_type = MLINE;\n\n\t// Concatenate the last line of the old block with the first line of\n\t// the new block, unless being Vi compatible.\n\tif (curr->y_type == MCHAR && vim_strchr(p_cpo, CPO_REGAPPEND) == NULL)\n\t{\n\t    pnew = alloc(STRLEN(curr->y_array[curr->y_size - 1])\n\t\t\t\t\t  + STRLEN(y_current->y_array[0]) + 1);\n\t    if (pnew == NULL)\n\t    {\n\t\ty_idx = y_current->y_size - 1;\n\t\tgoto fail;\n\t    }\n\t    STRCPY(pnew, curr->y_array[--j]);\n\t    STRCAT(pnew, y_current->y_array[0]);\n\t    vim_free(curr->y_array[j]);\n\t    vim_free(y_current->y_array[0]);\n\t    curr->y_array[j++] = pnew;\n\t    y_idx = 1;\n\t}\n\telse\n\t    y_idx = 0;\n\twhile (y_idx < y_current->y_size)\n\t    curr->y_array[j++] = y_current->y_array[y_idx++];\n\tcurr->y_size = j;\n\tvim_free(y_current->y_array);\n\ty_current = curr;\n    }\n\n    if (mess)\t\t\t// Display message about yank?\n    {\n\tif (yanktype == MCHAR\n\t\t&& !oap->block_mode\n\t\t&& yanklines == 1)\n\t    yanklines = 0;\n\t// Some versions of Vi use \">=\" here, some don't...\n\tif (yanklines > p_report)\n\t{\n\t    char namebuf[100];\n\n\t    if (oap->regname == NUL)\n\t\t*namebuf = NUL;\n\t    else\n\t\tvim_snprintf(namebuf, sizeof(namebuf),\n\t\t\t\t\t\t_(\" into \\\"%c\"), oap->regname);\n\n\t    // redisplay now, so message is not deleted\n\t    update_topline_redraw();\n\t    if (oap->block_mode)\n\t    {\n\t\tsmsg(NGETTEXT(\"block of %ld line yanked%s\",\n\t\t\t\t     \"block of %ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t    else\n\t    {\n\t\tsmsg(NGETTEXT(\"%ld line yanked%s\",\n\t\t\t\t\t      \"%ld lines yanked%s\", yanklines),\n\t\t\tyanklines, namebuf);\n\t    }\n\t}\n    }\n\n    if ((cmdmod.cmod_flags & CMOD_LOCKMARKS) == 0)\n    {\n\t// Set \"'[\" and \"']\" marks.\n\tcurbuf->b_op_start = oap->start;\n\tcurbuf->b_op_end = oap->end;\n\tif (yanktype == MLINE && !oap->block_mode)\n\t{\n\t    curbuf->b_op_start.col = 0;\n\t    curbuf->b_op_end.col = MAXCOL;\n\t}\n    }\n\n#ifdef FEAT_CLIPBOARD\n    // If we were yanking to the '*' register, send result to clipboard.\n    // If no register was specified, and \"unnamed\" in 'clipboard', make a copy\n    // to the '*' register.\n    if (clip_star.available\n\t    && (curr == &(y_regs[STAR_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t   && ((clip_unnamed | clip_unnamed_saved) & CLIP_UNNAMED))))\n    {\n\tif (curr != &(y_regs[STAR_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\n\tclip_own_selection(&clip_star);\n\tclip_gen_set_selection(&clip_star);\n# ifdef FEAT_X11\n\tdid_star = TRUE;\n# endif\n    }\n\n# ifdef FEAT_X11\n    // If we were yanking to the '+' register, send result to selection.\n    // Also copy to the '*' register, in case auto-select is off.  But not when\n    // 'clipboard' has \"unnamedplus\" and not \"unnamed\"; and not when\n    // deleting and both \"unnamedplus\" and \"unnamed\".\n    if (clip_plus.available\n\t    && (curr == &(y_regs[PLUS_REGISTER])\n\t\t|| (!deleting && oap->regname == 0\n\t\t  && ((clip_unnamed | clip_unnamed_saved) &\n\t\t\t\t\t\t\t  CLIP_UNNAMED_PLUS))))\n    {\n\tif (curr != &(y_regs[PLUS_REGISTER]))\n\t    // Copy the text from register 0 to the clipboard register.\n\t    copy_yank_reg(&(y_regs[PLUS_REGISTER]));\n\n\tclip_own_selection(&clip_plus);\n\tclip_gen_set_selection(&clip_plus);\n\tif (!clip_isautosel_star()\n\t\t&& !clip_isautosel_plus()\n\t\t&& !((clip_unnamed | clip_unnamed_saved) == CLIP_UNNAMED_PLUS)\n\t\t&& !(deleting && (clip_unnamed | clip_unnamed_saved)\n\t\t\t\t\t == (CLIP_UNNAMED | CLIP_UNNAMED_PLUS))\n\t\t&& !did_star\n\t\t&& curr == &(y_regs[PLUS_REGISTER]))\n\t{\n\t    copy_yank_reg(&(y_regs[STAR_REGISTER]));\n\t    clip_own_selection(&clip_star);\n\t    clip_gen_set_selection(&clip_star);\n\t}\n    }\n# endif\n#endif\n\n#if defined(FEAT_EVAL)\n    if (!deleting && has_textyankpost())\n\tyank_do_autocmd(oap, y_current);\n#endif\n\n    return OK;\n\nfail:\t\t// free the allocated lines\n    free_yank(y_idx + 1);\n    y_current = curr;\n    return FAIL;\n}\n\n/*\n * Copy a block range into a register.\n * If \"exclude_trailing_space\" is set, do not copy trailing whitespaces.\n */\n    static int\nyank_copy_line(struct block_def *bd, long y_idx, int exclude_trailing_space)\n{\n    char_u\t*pnew;\n\n    if (exclude_trailing_space)\n\tbd->endspaces = 0;\n    if ((pnew = alloc(bd->startspaces + bd->endspaces + bd->textlen + 1))\n\t\t\t\t\t\t\t\t      == NULL)\n\treturn FAIL;\n    y_current->y_array[y_idx] = pnew;\n    vim_memset(pnew, ' ', (size_t)bd->startspaces);\n    pnew += bd->startspaces;\n    mch_memmove(pnew, bd->textstart, (size_t)bd->textlen);\n    pnew += bd->textlen;\n    vim_memset(pnew, ' ', (size_t)bd->endspaces);\n    pnew += bd->endspaces;\n    if (exclude_trailing_space)\n    {\n\tint s = bd->textlen + bd->endspaces;\n\n\twhile (s > 0 && VIM_ISWHITE(*(bd->textstart + s - 1)))\n\t{\n\t    s = s - (*mb_head_off)(bd->textstart, bd->textstart + s - 1) - 1;\n\t    pnew--;\n\t}\n    }\n    *pnew = NUL;\n    return OK;\n}\n\n#ifdef FEAT_CLIPBOARD\n/*\n * Make a copy of the y_current register to register \"reg\".\n */\n    static void\ncopy_yank_reg(yankreg_T *reg)\n{\n    yankreg_T\t*curr = y_current;\n    long\tj;\n\n    y_current = reg;\n    free_yank_all();\n    *y_current = *curr;\n    y_current->y_array = lalloc_clear(\n\t\t\t\t    sizeof(char_u *) * y_current->y_size, TRUE);\n    if (y_current->y_array == NULL)\n\ty_current->y_size = 0;\n    else\n\tfor (j = 0; j < y_current->y_size; ++j)\n\t    if ((y_current->y_array[j] = vim_strsave(curr->y_array[j])) == NULL)\n\t    {\n\t\tfree_yank(j);\n\t\ty_current->y_size = 0;\n\t\tbreak;\n\t    }\n    y_current = curr;\n}\n#endif\n\n/*\n * Put contents of register \"regname\" into the text.\n * Caller must check \"regname\" to be valid!\n * \"flags\": PUT_FIXINDENT\tmake indent look nice\n *\t    PUT_CURSEND\t\tleave cursor after end of new text\n *\t    PUT_LINE\t\tforce linewise put (\":put\")\n *\t    PUT_BLOCK_INNER     in block mode, do not add trailing spaces\n */\n    void\ndo_put(\n    int\t\tregname,\n    char_u\t*expr_result,\t// result for regname \"=\" when compiled\n    int\t\tdir,\t\t// BACKWARD for 'P', FORWARD for 'p'\n    long\tcount,\n    int\t\tflags)\n{\n    char_u\t*ptr;\n    char_u\t*newp, *oldp;\n    int\t\tyanklen;\n    int\t\ttotlen = 0;\t\t// init for gcc\n    linenr_T\tlnum;\n    colnr_T\tcol;\n    long\ti;\t\t\t// index in y_array[]\n    int\t\ty_type;\n    long\ty_size;\n    int\t\toldlen;\n    long\ty_width = 0;\n    colnr_T\tvcol;\n    int\t\tdelcount;\n    int\t\tincr = 0;\n    long\tj;\n    struct block_def bd;\n    char_u\t**y_array = NULL;\n    yankreg_T\t*y_current_used = NULL;\n    long\tnr_lines = 0;\n    pos_T\tnew_cursor;\n    int\t\tindent;\n    int\t\torig_indent = 0;\t// init for gcc\n    int\t\tindent_diff = 0;\t// init for gcc\n    int\t\tfirst_indent = TRUE;\n    int\t\tlendiff = 0;\n    pos_T\told_pos;\n    char_u\t*insert_string = NULL;\n    int\t\tallocated = FALSE;\n    long\tcnt;\n    pos_T\torig_start = curbuf->b_op_start;\n    pos_T\torig_end = curbuf->b_op_end;\n    unsigned int cur_ve_flags = get_ve_flags();\n\n#ifdef FEAT_CLIPBOARD\n    // Adjust register name for \"unnamed\" in 'clipboard'.\n    adjust_clip_reg(&regname);\n    (void)may_get_selection(regname);\n#endif\n\n    if (flags & PUT_FIXINDENT)\n\torig_indent = get_indent();\n\n    curbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n    curbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n\n    // Using inserted text works differently, because the register includes\n    // special characters (newlines, etc.).\n    if (regname == '.')\n    {\n\tif (VIsual_active)\n\t    stuffcharReadbuff(VIsual_mode);\n\t(void)stuff_inserted((dir == FORWARD ? (count == -1 ? 'o' : 'a') :\n\t\t\t\t    (count == -1 ? 'O' : 'i')), count, FALSE);\n\t// Putting the text is done later, so can't really move the cursor to\n\t// the next character.  Use \"l\" to simulate it.\n\tif ((flags & PUT_CURSEND) && gchar_cursor() != NUL)\n\t    stuffcharReadbuff('l');\n\treturn;\n    }\n\n    // For special registers '%' (file name), '#' (alternate file name) and\n    // ':' (last command line), etc. we have to create a fake yank register.\n    // For compiled code \"expr_result\" holds the expression result.\n    if (regname == '=' && expr_result != NULL)\n\tinsert_string = expr_result;\n    else if (get_spec_reg(regname, &insert_string, &allocated, TRUE)\n\t\t&& insert_string == NULL)\n\treturn;\n\n    // Autocommands may be executed when saving lines for undo.  This might\n    // make \"y_array\" invalid, so we start undo now to avoid that.\n    if (u_save(curwin->w_cursor.lnum, curwin->w_cursor.lnum + 1) == FAIL)\n\tgoto end;\n\n    if (insert_string != NULL)\n    {\n\ty_type = MCHAR;\n#ifdef FEAT_EVAL\n\tif (regname == '=')\n\t{\n\t    // For the = register we need to split the string at NL\n\t    // characters.\n\t    // Loop twice: count the number of lines and save them.\n\t    for (;;)\n\t    {\n\t\ty_size = 0;\n\t\tptr = insert_string;\n\t\twhile (ptr != NULL)\n\t\t{\n\t\t    if (y_array != NULL)\n\t\t\ty_array[y_size] = ptr;\n\t\t    ++y_size;\n\t\t    ptr = vim_strchr(ptr, '\\n');\n\t\t    if (ptr != NULL)\n\t\t    {\n\t\t\tif (y_array != NULL)\n\t\t\t    *ptr = NUL;\n\t\t\t++ptr;\n\t\t\t// A trailing '\\n' makes the register linewise.\n\t\t\tif (*ptr == NUL)\n\t\t\t{\n\t\t\t    y_type = MLINE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif (y_array != NULL)\n\t\t    break;\n\t\ty_array = ALLOC_MULT(char_u *, y_size);\n\t\tif (y_array == NULL)\n\t\t    goto end;\n\t    }\n\t}\n\telse\n#endif\n\t{\n\t    y_size = 1;\t\t// use fake one-line yank register\n\t    y_array = &insert_string;\n\t}\n    }\n    else\n    {\n\tget_yank_register(regname, FALSE);\n\n\ty_type = y_current->y_type;\n\ty_width = y_current->y_width;\n\ty_size = y_current->y_size;\n\ty_array = y_current->y_array;\n\ty_current_used = y_current;\n    }\n\n    if (y_type == MLINE)\n    {\n\tif (flags & PUT_LINE_SPLIT)\n\t{\n\t    char_u *p;\n\n\t    // \"p\" or \"P\" in Visual mode: split the lines to put the text in\n\t    // between.\n\t    if (u_save_cursor() == FAIL)\n\t\tgoto end;\n\t    p = ml_get_cursor();\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strsave(p);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_append(curwin->w_cursor.lnum, ptr, (colnr_T)0, FALSE);\n\t    vim_free(ptr);\n\n\t    oldp = ml_get_curline();\n\t    p = oldp + curwin->w_cursor.col;\n\t    if (dir == FORWARD && *p != NUL)\n\t\tMB_PTR_ADV(p);\n\t    ptr = vim_strnsave(oldp, p - oldp);\n\t    if (ptr == NULL)\n\t\tgoto end;\n\t    ml_replace(curwin->w_cursor.lnum, ptr, FALSE);\n\t    ++nr_lines;\n\t    dir = FORWARD;\n\t}\n\tif (flags & PUT_LINE_FORWARD)\n\t{\n\t    // Must be \"p\" for a Visual block, put lines below the block.\n\t    curwin->w_cursor = curbuf->b_visual.vi_end;\n\t    dir = FORWARD;\n\t}\n\tcurbuf->b_op_start = curwin->w_cursor;\t// default for '[ mark\n\tcurbuf->b_op_end = curwin->w_cursor;\t// default for '] mark\n    }\n\n    if (flags & PUT_LINE)\t// :put command or \"p\" in Visual line mode.\n\ty_type = MLINE;\n\n    if (y_size == 0 || y_array == NULL)\n    {\n\tsemsg(_(e_nothing_in_register_str),\n\t\t  regname == 0 ? (char_u *)\"\\\"\" : transchar(regname));\n\tgoto end;\n    }\n\n    if (y_type == MBLOCK)\n    {\n\tlnum = curwin->w_cursor.lnum + y_size + 1;\n\tif (lnum > curbuf->b_ml.ml_line_count)\n\t    lnum = curbuf->b_ml.ml_line_count + 1;\n\tif (u_save(curwin->w_cursor.lnum - 1, lnum) == FAIL)\n\t    goto end;\n    }\n    else if (y_type == MLINE)\n    {\n\tlnum = curwin->w_cursor.lnum;\n#ifdef FEAT_FOLDING\n\t// Correct line number for closed fold.  Don't move the cursor yet,\n\t// u_save() uses it.\n\tif (dir == BACKWARD)\n\t    (void)hasFolding(lnum, &lnum, NULL);\n\telse\n\t    (void)hasFolding(lnum, NULL, &lnum);\n#endif\n\tif (dir == FORWARD)\n\t    ++lnum;\n\t// In an empty buffer the empty line is going to be replaced, include\n\t// it in the saved lines.\n\tif ((BUFEMPTY() ? u_save(0, 2) : u_save(lnum - 1, lnum)) == FAIL)\n\t    goto end;\n#ifdef FEAT_FOLDING\n\tif (dir == FORWARD)\n\t    curwin->w_cursor.lnum = lnum - 1;\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n\tcurbuf->b_op_start = curwin->w_cursor;\t// for mark_adjust()\n#endif\n    }\n    else if (u_save_cursor() == FAIL)\n\tgoto end;\n\n    yanklen = (int)STRLEN(y_array[0]);\n\n    if (cur_ve_flags == VE_ALL && y_type == MCHAR)\n    {\n\tif (gchar_cursor() == TAB)\n\t{\n\t    int viscol = getviscol();\n\t    int ts = curbuf->b_p_ts;\n\n\t    // Don't need to insert spaces when \"p\" on the last position of a\n\t    // tab or \"P\" on the first position.\n\t    if (dir == FORWARD ?\n#ifdef FEAT_VARTABS\n\t\t    tabstop_padding(viscol, ts, curbuf->b_p_vts_array) != 1\n#else\n\t\t    ts - (viscol % ts) != 1\n#endif\n\t\t    : curwin->w_cursor.coladd > 0)\n\t\tcoladvance_force(viscol);\n\t    else\n\t\tcurwin->w_cursor.coladd = 0;\n\t}\n\telse if (curwin->w_cursor.coladd > 0 || gchar_cursor() == NUL)\n\t    coladvance_force(getviscol() + (dir == FORWARD));\n    }\n\n    lnum = curwin->w_cursor.lnum;\n    col = curwin->w_cursor.col;\n\n    // Block mode\n    if (y_type == MBLOCK)\n    {\n\tint\tc = gchar_cursor();\n\tcolnr_T\tendcol2 = 0;\n\n\tif (dir == FORWARD && c != NUL)\n\t{\n\t    if (cur_ve_flags == VE_ALL)\n\t\tgetvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\t    else\n\t\tgetvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\n\t    if (has_mbyte)\n\t\t// move to start of next multi-byte character\n\t\tcurwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t    else\n\t    if (c != TAB || cur_ve_flags != VE_ALL)\n\t\t++curwin->w_cursor.col;\n\t    ++col;\n\t}\n\telse\n\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, &endcol2);\n\n\tcol += curwin->w_cursor.coladd;\n\tif (cur_ve_flags == VE_ALL\n\t\t&& (curwin->w_cursor.coladd > 0\n\t\t    || endcol2 == curwin->w_cursor.col))\n\t{\n\t    if (dir == FORWARD && c == NUL)\n\t\t++col;\n\t    if (dir != FORWARD && c != NUL && curwin->w_cursor.coladd > 0)\n\t\t++curwin->w_cursor.col;\n\t    if (c == TAB)\n\t    {\n\t\tif (dir == BACKWARD && curwin->w_cursor.col)\n\t\t    curwin->w_cursor.col--;\n\t\tif (dir == FORWARD && col - 1 == endcol2)\n\t\t    curwin->w_cursor.col++;\n\t    }\n\t}\n\tcurwin->w_cursor.coladd = 0;\n\tbd.textcol = 0;\n\tfor (i = 0; i < y_size; ++i)\n\t{\n\t    int\t\t    spaces = 0;\n\t    char\t    shortline;\n\t    chartabsize_T   cts;\n\n\t    bd.startspaces = 0;\n\t    bd.endspaces = 0;\n\t    vcol = 0;\n\t    delcount = 0;\n\n\t    // add a new line\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tif (ml_append(curbuf->b_ml.ml_line_count, (char_u *)\"\",\n\t\t\t\t\t\t   (colnr_T)1, FALSE) == FAIL)\n\t\t    break;\n\t\t++nr_lines;\n\t    }\n\t    // get the old line and advance to the position to insert at\n\t    oldp = ml_get_curline();\n\t    oldlen = (int)STRLEN(oldp);\n\t    init_chartabsize_arg(&cts, curwin, curwin->w_cursor.lnum, 0,\n\t\t\t\t\t\t\t\t  oldp, oldp);\n\n\t    while (cts.cts_vcol < col && *cts.cts_ptr != NUL)\n\t    {\n\t\t// Count a tab for what it's worth (if list mode not on)\n\t\tincr = lbr_chartabsize_adv(&cts);\n\t\tcts.cts_vcol += incr;\n\t    }\n\t    vcol = cts.cts_vcol;\n\t    ptr = cts.cts_ptr;\n\t    bd.textcol = (colnr_T)(ptr - oldp);\n\t    clear_chartabsize_arg(&cts);\n\n\t    shortline = (vcol < col) || (vcol == col && !*ptr) ;\n\n\t    if (vcol < col) // line too short, pad with spaces\n\t\tbd.startspaces = col - vcol;\n\t    else if (vcol > col)\n\t    {\n\t\tbd.endspaces = vcol - col;\n\t\tbd.startspaces = incr - bd.endspaces;\n\t\t--bd.textcol;\n\t\tdelcount = 1;\n\t\tif (has_mbyte)\n\t\t    bd.textcol -= (*mb_head_off)(oldp, oldp + bd.textcol);\n\t\tif (oldp[bd.textcol] != TAB)\n\t\t{\n\t\t    // Only a Tab can be split into spaces.  Other\n\t\t    // characters will have to be moved to after the\n\t\t    // block, causing misalignment.\n\t\t    delcount = 0;\n\t\t    bd.endspaces = 0;\n\t\t}\n\t    }\n\n\t    yanklen = (int)STRLEN(y_array[i]);\n\n\t    if ((flags & PUT_BLOCK_INNER) == 0)\n\t    {\n\t\t// calculate number of spaces required to fill right side of\n\t\t// block\n\t\tspaces = y_width + 1;\n\t\tinit_chartabsize_arg(&cts, curwin, 0, 0,\n\t\t\t\t\t\t      y_array[i], y_array[i]);\n\t\tfor (j = 0; j < yanklen; j++)\n\t\t{\n\t\t    spaces -= lbr_chartabsize(&cts);\n\t\t    ++cts.cts_ptr;\n\t\t    cts.cts_vcol = 0;\n\t\t}\n\t\tclear_chartabsize_arg(&cts);\n\t\tif (spaces < 0)\n\t\t    spaces = 0;\n\t    }\n\n\t    // Insert the new text.\n\t    // First check for multiplication overflow.\n\t    if (yanklen + spaces != 0\n\t\t     && count > ((INT_MAX - (bd.startspaces + bd.endspaces))\n\t\t\t\t\t\t\t/ (yanklen + spaces)))\n\t    {\n\t\temsg(_(e_resulting_text_too_long));\n\t\tbreak;\n\t    }\n\n\t    totlen = count * (yanklen + spaces) + bd.startspaces + bd.endspaces;\n\t    newp = alloc(totlen + oldlen + 1);\n\t    if (newp == NULL)\n\t\tbreak;\n\n\t    // copy part up to cursor to new line\n\t    ptr = newp;\n\t    mch_memmove(ptr, oldp, (size_t)bd.textcol);\n\t    ptr += bd.textcol;\n\n\t    // may insert some spaces before the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.startspaces);\n\t    ptr += bd.startspaces;\n\n\t    // insert the new text\n\t    for (j = 0; j < count; ++j)\n\t    {\n\t\tmch_memmove(ptr, y_array[i], (size_t)yanklen);\n\t\tptr += yanklen;\n\n\t\t// insert block's trailing spaces only if there's text behind\n\t\tif ((j < count - 1 || !shortline) && spaces > 0)\n\t\t{\n\t\t    vim_memset(ptr, ' ', (size_t)spaces);\n\t\t    ptr += spaces;\n\t\t}\n\t\telse\n\t\t    totlen -= spaces;  // didn't use these spaces\n\t    }\n\n\t    // may insert some spaces after the new text\n\t    vim_memset(ptr, ' ', (size_t)bd.endspaces);\n\t    ptr += bd.endspaces;\n\n\t    // move the text after the cursor to the end of the line.\n\t    mch_memmove(ptr, oldp + bd.textcol + delcount,\n\t\t\t\t(size_t)(oldlen - bd.textcol - delcount + 1));\n\t    ml_replace(curwin->w_cursor.lnum, newp, FALSE);\n\n\t    ++curwin->w_cursor.lnum;\n\t    if (i == 0)\n\t\tcurwin->w_cursor.col += bd.startspaces;\n\t}\n\n\tchanged_lines(lnum, 0, curwin->w_cursor.lnum, nr_lines);\n\n\t// Set '[ mark.\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tcurbuf->b_op_start.lnum = lnum;\n\n\t// adjust '] mark\n\tcurbuf->b_op_end.lnum = curwin->w_cursor.lnum - 1;\n\tcurbuf->b_op_end.col = bd.textcol + totlen - 1;\n\tif (curbuf->b_op_end.col < 0)\n\t    curbuf->b_op_end.col = 0;\n\tcurbuf->b_op_end.coladd = 0;\n\tif (flags & PUT_CURSEND)\n\t{\n\t    colnr_T len;\n\n\t    curwin->w_cursor = curbuf->b_op_end;\n\t    curwin->w_cursor.col++;\n\n\t    // in Insert mode we might be after the NUL, correct for that\n\t    len = (colnr_T)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > len)\n\t\tcurwin->w_cursor.col = len;\n\t}\n\telse\n\t    curwin->w_cursor.lnum = lnum;\n    }\n    else\n    {\n\t// Character or Line mode\n\tif (y_type == MCHAR)\n\t{\n\t    // if type is MCHAR, FORWARD is the same as BACKWARD on the next\n\t    // char\n\t    if (dir == FORWARD && gchar_cursor() != NUL)\n\t    {\n\t\tif (has_mbyte)\n\t\t{\n\t\t    int bytelen = (*mb_ptr2len)(ml_get_cursor());\n\n\t\t    // put it on the next of the multi-byte character.\n\t\t    col += bytelen;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\tcurwin->w_cursor.col += bytelen;\n\t\t\tcurbuf->b_op_end.col += bytelen;\n\t\t    }\n\t\t}\n\t\telse\n\t\t{\n\t\t    ++col;\n\t\t    if (yanklen)\n\t\t    {\n\t\t\t++curwin->w_cursor.col;\n\t\t\t++curbuf->b_op_end.col;\n\t\t    }\n\t\t}\n\t    }\n\t    curbuf->b_op_start = curwin->w_cursor;\n\t}\n\t// Line mode: BACKWARD is the same as FORWARD on the previous line\n\telse if (dir == BACKWARD)\n\t    --lnum;\n\tnew_cursor = curwin->w_cursor;\n\n\t// simple case: insert into one line at a time\n\tif (y_type == MCHAR && y_size == 1)\n\t{\n\t    linenr_T\tend_lnum = 0; // init for gcc\n\t    linenr_T\tstart_lnum = lnum;\n\t    int\t\tfirst_byte_off = 0;\n\n\t    if (VIsual_active)\n\t    {\n\t\tend_lnum = curbuf->b_visual.vi_end.lnum;\n\t\tif (end_lnum < curbuf->b_visual.vi_start.lnum)\n\t\t    end_lnum = curbuf->b_visual.vi_start.lnum;\n\t\tif (end_lnum > start_lnum)\n\t\t{\n\t\t    pos_T   pos;\n\n\t\t    // \"col\" is valid for the first line, in following lines\n\t\t    // the virtual column needs to be used.  Matters for\n\t\t    // multi-byte characters.\n\t\t    pos.lnum = lnum;\n\t\t    pos.col = col;\n\t\t    pos.coladd = 0;\n\t\t    getvcol(curwin, &pos, NULL, &vcol, NULL);\n\t\t}\n\t    }\n\n\t    if (count == 0 || yanklen == 0)\n\t    {\n\t\tif (VIsual_active)\n\t\t    lnum = end_lnum;\n\t    }\n\t    else if (count > INT_MAX / yanklen)\n\t\t// multiplication overflow\n\t\temsg(_(e_resulting_text_too_long));\n\t    else\n\t    {\n\t\ttotlen = count * yanklen;\n\t\tdo {\n\t\t    oldp = ml_get(lnum);\n\t\t    oldlen = (int)STRLEN(oldp);\n\t\t    if (lnum > start_lnum)\n\t\t    {\n\t\t\tpos_T   pos;\n\n\t\t\tpos.lnum = lnum;\n\t\t\tif (getvpos(&pos, vcol) == OK)\n\t\t\t    col = pos.col;\n\t\t\telse\n\t\t\t    col = MAXCOL;\n\t\t    }\n\t\t    if (VIsual_active && col > oldlen)\n\t\t    {\n\t\t\tlnum++;\n\t\t\tcontinue;\n\t\t    }\n\t\t    newp = alloc(totlen + oldlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto end;\t// alloc() gave an error message\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t    ptr = newp + col;\n\t\t    for (i = 0; i < count; ++i)\n\t\t    {\n\t\t\tmch_memmove(ptr, y_array[0], (size_t)yanklen);\n\t\t\tptr += yanklen;\n\t\t    }\n\t\t    STRMOVE(ptr, oldp + col);\n\n\t\t    // compute the byte offset for the last character\n\t\t    first_byte_off = mb_head_off(newp, ptr - 1);\n\n\t\t    // Note: this may free \"newp\"\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    inserted_bytes(lnum, col, totlen);\n\n\t\t    // Place cursor on last putted char.\n\t\t    if (lnum == curwin->w_cursor.lnum)\n\t\t    {\n\t\t\t// make sure curwin->w_virtcol is updated\n\t\t\tchanged_cline_bef_curs();\n\t\t\tcurwin->w_cursor.col += (colnr_T)(totlen - 1);\n\t\t    }\n\t\t    if (VIsual_active)\n\t\t\tlnum++;\n\t\t} while (VIsual_active && lnum <= end_lnum);\n\n\t\tif (VIsual_active) // reset lnum to the last visual line\n\t\t    lnum--;\n\t    }\n\n\t    // put '] at the first byte of the last character\n\t    curbuf->b_op_end = curwin->w_cursor;\n\t    curbuf->b_op_end.col -= first_byte_off;\n\n\t    // For \"CTRL-O p\" in Insert mode, put cursor after last char\n\t    if (totlen && (restart_edit != 0 || (flags & PUT_CURSEND)))\n\t\t++curwin->w_cursor.col;\n\t    else\n\t\tcurwin->w_cursor.col -= first_byte_off;\n\t}\n\telse\n\t{\n\t    linenr_T\tnew_lnum = new_cursor.lnum;\n\t    size_t\tlen;\n\n\t    // Insert at least one line.  When y_type is MCHAR, break the first\n\t    // line in two.\n\t    for (cnt = 1; cnt <= count; ++cnt)\n\t    {\n\t\ti = 0;\n\t\tif (y_type == MCHAR)\n\t\t{\n\t\t    // Split the current line in two at the insert position.\n\t\t    // First insert y_array[size - 1] in front of second line.\n\t\t    // Then append y_array[0] to first line.\n\t\t    lnum = new_cursor.lnum;\n\t\t    ptr = ml_get(lnum) + col;\n\t\t    totlen = (int)STRLEN(y_array[y_size - 1]);\n\t\t    newp = alloc(STRLEN(ptr) + totlen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t    STRCPY(newp, y_array[y_size - 1]);\n\t\t    STRCAT(newp, ptr);\n\t\t    // insert second line\n\t\t    ml_append(lnum, newp, (colnr_T)0, FALSE);\n\t\t    ++new_lnum;\n\t\t    vim_free(newp);\n\n\t\t    oldp = ml_get(lnum);\n\t\t    newp = alloc(col + yanklen + 1);\n\t\t    if (newp == NULL)\n\t\t\tgoto error;\n\t\t\t\t\t    // copy first part of line\n\t\t    mch_memmove(newp, oldp, (size_t)col);\n\t\t\t\t\t    // append to first line\n\t\t    mch_memmove(newp + col, y_array[0], (size_t)(yanklen + 1));\n\t\t    ml_replace(lnum, newp, FALSE);\n\n\t\t    curwin->w_cursor.lnum = lnum;\n\t\t    i = 1;\n\t\t}\n\n\t\tfor (; i < y_size; ++i)\n\t\t{\n\t\t    if (y_type != MCHAR || i < y_size - 1)\n\t\t    {\n\t\t\tif (ml_append(lnum, y_array[i], (colnr_T)0, FALSE)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\t    goto error;\n\t\t\tnew_lnum++;\n\t\t    }\n\t\t    lnum++;\n\t\t    ++nr_lines;\n\t\t    if (flags & PUT_FIXINDENT)\n\t\t    {\n\t\t\told_pos = curwin->w_cursor;\n\t\t\tcurwin->w_cursor.lnum = lnum;\n\t\t\tptr = ml_get(lnum);\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff = (int)STRLEN(ptr);\n\t\t\tif (*ptr == '#' && preprocs_left())\n\t\t\t    indent = 0;     // Leave # lines at start\n\t\t\telse\n\t\t\t     if (*ptr == NUL)\n\t\t\t    indent = 0;     // Ignore empty lines\n\t\t\telse if (first_indent)\n\t\t\t{\n\t\t\t    indent_diff = orig_indent - get_indent();\n\t\t\t    indent = orig_indent;\n\t\t\t    first_indent = FALSE;\n\t\t\t}\n\t\t\telse if ((indent = get_indent() + indent_diff) < 0)\n\t\t\t    indent = 0;\n\t\t\t(void)set_indent(indent, 0);\n\t\t\tcurwin->w_cursor = old_pos;\n\t\t\t// remember how many chars were removed\n\t\t\tif (cnt == count && i == y_size - 1)\n\t\t\t    lendiff -= (int)STRLEN(ml_get(lnum));\n\t\t    }\n\t\t}\n\t\tif (cnt == 1)\n\t\t    new_lnum = lnum;\n\t    }\n\nerror:\n\t    // Adjust marks.\n\t    if (y_type == MLINE)\n\t    {\n\t\tcurbuf->b_op_start.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    curbuf->b_op_start.lnum++;\n\t    }\n\t    mark_adjust(curbuf->b_op_start.lnum + (y_type == MCHAR),\n\t\t\t\t\t     (linenr_T)MAXLNUM, nr_lines, 0L);\n\n\t    // note changed text for displaying and folding\n\t    if (y_type == MCHAR)\n\t\tchanged_lines(curwin->w_cursor.lnum, col,\n\t\t\t\t\t curwin->w_cursor.lnum + 1, nr_lines);\n\t    else\n\t\tchanged_lines(curbuf->b_op_start.lnum, 0,\n\t\t\t\t\t   curbuf->b_op_start.lnum, nr_lines);\n\t    if (y_current_used != NULL && (y_current_used != y_current\n\t\t\t\t\t     || y_current->y_array != y_array))\n\t    {\n\t\t// Something invoked through changed_lines() has changed the\n\t\t// yank buffer, e.g. a GUI clipboard callback.\n\t\temsg(_(e_yank_register_changed_while_using_it));\n\t\tgoto end;\n\t    }\n\n\t    // Put the '] mark on the first byte of the last inserted character.\n\t    // Correct the length for change in indent.\n\t    curbuf->b_op_end.lnum = new_lnum;\n\t    len = STRLEN(y_array[y_size - 1]);\n\t    col = (colnr_T)len - lendiff;\n\t    if (col > 1)\n\t    {\n\t\tcurbuf->b_op_end.col = col - 1;\n\t\tif (len > 0)\n\t\t    curbuf->b_op_end.col -= mb_head_off(y_array[y_size - 1],\n\t\t\t\t\t\ty_array[y_size - 1] + len - 1);\n\t    }\n\t    else\n\t\tcurbuf->b_op_end.col = 0;\n\n\t    if (flags & PUT_CURSLINE)\n\t    {\n\t\t// \":put\": put cursor on last inserted line\n\t\tcurwin->w_cursor.lnum = lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else if (flags & PUT_CURSEND)\n\t    {\n\t\t// put cursor after inserted text\n\t\tif (y_type == MLINE)\n\t\t{\n\t\t    if (lnum >= curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = lnum + 1;\n\t\t    curwin->w_cursor.col = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    curwin->w_cursor.lnum = new_lnum;\n\t\t    curwin->w_cursor.col = col;\n\t\t    curbuf->b_op_end = curwin->w_cursor;\n\t\t    if (col > 1)\n\t\t\tcurbuf->b_op_end.col = col - 1;\n\t\t}\n\t    }\n\t    else if (y_type == MLINE)\n\t    {\n\t\t// put cursor on first non-blank in first inserted line\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (dir == FORWARD)\n\t\t    ++curwin->w_cursor.lnum;\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t    }\n\t    else\t// put cursor on first inserted character\n\t\tcurwin->w_cursor = new_cursor;\n\t}\n    }\n\n    msgmore(nr_lines);\n    curwin->w_set_curswant = TRUE;\n\n    // Make sure the cursor is not after the NUL.\n    int len = (int)STRLEN(ml_get_curline());\n    if (curwin->w_cursor.col > len)\n    {\n\tif (cur_ve_flags == VE_ALL)\n\t    curwin->w_cursor.coladd = curwin->w_cursor.col - len;\n\tcurwin->w_cursor.col = len;\n    }\n\nend:\n    if (cmdmod.cmod_flags & CMOD_LOCKMARKS)\n    {\n\tcurbuf->b_op_start = orig_start;\n\tcurbuf->b_op_end = orig_end;\n    }\n    if (allocated)\n\tvim_free(insert_string);\n    if (regname == '=')\n\tvim_free(y_array);\n\n    VIsual_active = FALSE;\n\n    // If the cursor is past the end of the line put it at the end.\n    adjust_cursor_eol();\n}\n\n/*\n * Return the character name of the register with the given number.\n */\n    int\nget_register_name(int num)\n{\n    if (num == -1)\n\treturn '\"';\n    else if (num < 10)\n\treturn num + '0';\n    else if (num == DELETION_REGISTER)\n\treturn '-';\n#ifdef FEAT_CLIPBOARD\n    else if (num == STAR_REGISTER)\n\treturn '*';\n    else if (num == PLUS_REGISTER)\n\treturn '+';\n#endif\n    else\n\treturn num + 'a' - 10;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the index of the register \"\" points to.\n */\n    int\nget_unname_register(void)\n{\n    return y_previous == NULL ? -1 : y_previous - &y_regs[0];\n}\n#endif\n\n/*\n * \":dis\" and \":registers\": Display the contents of the yank registers.\n */\n    void\nex_display(exarg_T *eap)\n{\n    int\t\ti, n;\n    long\tj;\n    char_u\t*p;\n    yankreg_T\t*yb;\n    int\t\tname;\n    int\t\tattr;\n    char_u\t*arg = eap->arg;\n    int\t\tclen;\n    int\t\ttype;\n\n    if (arg != NULL && *arg == NUL)\n\targ = NULL;\n    attr = HL_ATTR(HLF_8);\n\n    // Highlight title\n    msg_puts_title(_(\"\\nType Name Content\"));\n    for (i = -1; i < NUM_REGISTERS && !got_int; ++i)\n    {\n\tname = get_register_name(i);\n\tswitch (get_reg_type(name, NULL))\n\t{\n\t    case MLINE: type = 'l'; break;\n\t    case MCHAR: type = 'c'; break;\n\t    default:\ttype = 'b'; break;\n\t}\n\tif (arg != NULL && vim_strchr(arg, name) == NULL\n#ifdef ONE_CLIPBOARD\n\t    // Star register and plus register contain the same thing.\n\t\t&& (name != '*' || vim_strchr(arg, '+') == NULL)\n#endif\n\t\t)\n\t    continue;\t    // did not ask for this register\n\n#ifdef FEAT_CLIPBOARD\n\t// Adjust register name for \"unnamed\" in 'clipboard'.\n\t// When it's a clipboard register, fill it with the current contents\n\t// of the clipboard.\n\tadjust_clip_reg(&name);\n\t(void)may_get_selection(name);\n#endif\n\n\tif (i == -1)\n\t{\n\t    if (y_previous != NULL)\n\t\tyb = y_previous;\n\t    else\n\t\tyb = &(y_regs[0]);\n\t}\n\telse\n\t    yb = &(y_regs[i]);\n\n#ifdef FEAT_EVAL\n\tif (name == MB_TOLOWER(redir_reg)\n\t\t|| (redir_reg == '\"' && yb == y_previous))\n\t    continue;\t    // do not list register being written to, the\n\t\t\t    // pointer can be freed\n#endif\n\n\tif (yb->y_array != NULL)\n\t{\n\t    int do_show = FALSE;\n\n\t    for (j = 0; !do_show && j < yb->y_size; ++j)\n\t\tdo_show = !message_filtered(yb->y_array[j]);\n\n\t    if (do_show || yb->y_size == 0)\n\t    {\n\t\tmsg_putchar('\\n');\n\t\tmsg_puts(\"  \");\n\t\tmsg_putchar(type);\n\t\tmsg_puts(\"  \");\n\t\tmsg_putchar('\"');\n\t\tmsg_putchar(name);\n\t\tmsg_puts(\"   \");\n\n\t\tn = (int)Columns - 11;\n\t\tfor (j = 0; j < yb->y_size && n > 1; ++j)\n\t\t{\n\t\t    if (j)\n\t\t    {\n\t\t\tmsg_puts_attr(\"^J\", attr);\n\t\t\tn -= 2;\n\t\t    }\n\t\t    for (p = yb->y_array[j];\n\t\t\t\t    *p != NUL && (n -= ptr2cells(p)) >= 0; ++p)\n\t\t    {\n\t\t\tclen = (*mb_ptr2len)(p);\n\t\t\tmsg_outtrans_len(p, clen);\n\t\t\tp += clen - 1;\n\t\t    }\n\t\t}\n\t\tif (n > 1 && yb->y_type == MLINE)\n\t\t    msg_puts_attr(\"^J\", attr);\n\t\tout_flush();\t\t    // show one line at a time\n\t    }\n\t    ui_breakcheck();\n\t}\n    }\n\n    // display last inserted text\n    if ((p = get_last_insert()) != NULL\n\t\t  && (arg == NULL || vim_strchr(arg, '.') != NULL) && !got_int\n\t\t\t\t\t\t      && !message_filtered(p))\n    {\n\tmsg_puts(\"\\n  c  \\\".   \");\n\tdis_msg(p, TRUE);\n    }\n\n    // display last command line\n    if (last_cmdline != NULL && (arg == NULL || vim_strchr(arg, ':') != NULL)\n\t\t\t       && !got_int && !message_filtered(last_cmdline))\n    {\n\tmsg_puts(\"\\n  c  \\\":   \");\n\tdis_msg(last_cmdline, FALSE);\n    }\n\n    // display current file name\n    if (curbuf->b_fname != NULL\n\t    && (arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int\n\t\t\t\t\t&& !message_filtered(curbuf->b_fname))\n    {\n\tmsg_puts(\"\\n  c  \\\"%   \");\n\tdis_msg(curbuf->b_fname, FALSE);\n    }\n\n    // display alternate file name\n    if ((arg == NULL || vim_strchr(arg, '%') != NULL) && !got_int)\n    {\n\tchar_u\t    *fname;\n\tlinenr_T    dummy;\n\n\tif (buflist_name_nr(0, &fname, &dummy) != FAIL\n\t\t\t\t\t\t  && !message_filtered(fname))\n\t{\n\t    msg_puts(\"\\n  c  \\\"#   \");\n\t    dis_msg(fname, FALSE);\n\t}\n    }\n\n    // display last search pattern\n    if (last_search_pat() != NULL\n\t\t && (arg == NULL || vim_strchr(arg, '/') != NULL) && !got_int\n\t\t\t\t      && !message_filtered(last_search_pat()))\n    {\n\tmsg_puts(\"\\n  c  \\\"/   \");\n\tdis_msg(last_search_pat(), FALSE);\n    }\n\n#ifdef FEAT_EVAL\n    // display last used expression\n    if (expr_line != NULL && (arg == NULL || vim_strchr(arg, '=') != NULL)\n\t\t\t\t  && !got_int && !message_filtered(expr_line))\n    {\n\tmsg_puts(\"\\n  c  \\\"=   \");\n\tdis_msg(expr_line, FALSE);\n    }\n#endif\n}\n\n/*\n * display a string for do_dis()\n * truncate at end of screen line\n */\n    static void\ndis_msg(\n    char_u\t*p,\n    int\t\tskip_esc)\t    // if TRUE, ignore trailing ESC\n{\n    int\t\tn;\n    int\t\tl;\n\n    n = (int)Columns - 6;\n    while (*p != NUL\n\t    && !(*p == ESC && skip_esc && *(p + 1) == NUL)\n\t    && (n -= ptr2cells(p)) >= 0)\n    {\n\tif (has_mbyte && (l = (*mb_ptr2len)(p)) > 1)\n\t{\n\t    msg_outtrans_len(p, l);\n\t    p += l;\n\t}\n\telse\n\t    msg_outtrans_len(p++, 1);\n    }\n    ui_breakcheck();\n}\n\n#if defined(FEAT_DND) || defined(PROTO)\n/*\n * Replace the contents of the '~' register with str.\n */\n    void\ndnd_yank_drag_data(char_u *str, long len)\n{\n    yankreg_T *curr;\n\n    curr = y_current;\n    y_current = &y_regs[TILDE_REGISTER];\n    free_yank_all();\n    str_to_reg(y_current, MCHAR, str, len, 0L, FALSE);\n    y_current = curr;\n}\n#endif\n\n\n/*\n * Return the type of a register.\n * Used for getregtype()\n * Returns MAUTO for error.\n */\n    char_u\nget_reg_type(int regname, long *reglen)\n{\n    switch (regname)\n    {\n\tcase '%':\t\t// file name\n\tcase '#':\t\t// alternate file name\n\tcase '=':\t\t// expression\n\tcase ':':\t\t// last command line\n\tcase '/':\t\t// last search-pattern\n\tcase '.':\t\t// last inserted text\n\tcase Ctrl_F:\t\t// Filename under cursor\n\tcase Ctrl_P:\t\t// Path under cursor, expand via \"path\"\n\tcase Ctrl_W:\t\t// word under cursor\n\tcase Ctrl_A:\t\t// WORD (mnemonic All) under cursor\n\tcase '_':\t\t// black hole: always empty\n\t    return MCHAR;\n    }\n\n# ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n# endif\n\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn MAUTO;\n\n    get_yank_register(regname, FALSE);\n\n    if (y_current->y_array != NULL)\n    {\n\tif (reglen != NULL && y_current->y_type == MBLOCK)\n\t    *reglen = y_current->y_width;\n\treturn y_current->y_type;\n    }\n    return MAUTO;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * When \"flags\" has GREG_LIST return a list with text \"s\".\n * Otherwise just return \"s\".\n */\n    static char_u *\ngetreg_wrap_one_line(char_u *s, int flags)\n{\n    if (flags & GREG_LIST)\n    {\n\tlist_T *list = list_alloc();\n\n\tif (list != NULL)\n\t{\n\t    if (list_append_string(list, NULL, -1) == FAIL)\n\t    {\n\t\tlist_free(list);\n\t\treturn NULL;\n\t    }\n\t    list->lv_first->li_tv.vval.v_string = s;\n\t}\n\treturn (char_u *)list;\n    }\n    return s;\n}\n\n/*\n * Return the contents of a register as a single allocated string or as a list.\n * Used for \"@r\" in expressions and for getreg().\n * Returns NULL for error.\n * Flags:\n *\tGREG_NO_EXPR\tDo not allow expression register\n *\tGREG_EXPR_SRC\tFor the expression register: return expression itself,\n *\t\t\tnot the result of its evaluation.\n *\tGREG_LIST\tReturn a list of lines instead of a single string.\n */\n    char_u *\nget_reg_contents(int regname, int flags)\n{\n    long\ti;\n    char_u\t*retval;\n    int\t\tallocated;\n    long\tlen;\n\n    // Don't allow using an expression register inside an expression\n    if (regname == '=')\n    {\n\tif (flags & GREG_NO_EXPR)\n\t    return NULL;\n\tif (flags & GREG_EXPR_SRC)\n\t    return getreg_wrap_one_line(get_expr_line_src(), flags);\n\treturn getreg_wrap_one_line(get_expr_line(), flags);\n    }\n\n    if (regname == '@')\t    // \"@@\" is used for unnamed register\n\tregname = '\"';\n\n    // check for valid regname\n    if (regname != NUL && !valid_yank_reg(regname, FALSE))\n\treturn NULL;\n\n# ifdef FEAT_CLIPBOARD\n    regname = may_get_selection(regname);\n# endif\n\n    if (get_spec_reg(regname, &retval, &allocated, FALSE))\n    {\n\tif (retval == NULL)\n\t    return NULL;\n\tif (allocated)\n\t    return getreg_wrap_one_line(retval, flags);\n\treturn getreg_wrap_one_line(vim_strsave(retval), flags);\n    }\n\n    get_yank_register(regname, FALSE);\n    if (y_current->y_array == NULL)\n\treturn NULL;\n\n    if (flags & GREG_LIST)\n    {\n\tlist_T\t*list = list_alloc();\n\tint\terror = FALSE;\n\n\tif (list == NULL)\n\t    return NULL;\n\tfor (i = 0; i < y_current->y_size; ++i)\n\t    if (list_append_string(list, y_current->y_array[i], -1) == FAIL)\n\t\terror = TRUE;\n\tif (error)\n\t{\n\t    list_free(list);\n\t    return NULL;\n\t}\n\treturn (char_u *)list;\n    }\n\n    // Compute length of resulting string.\n    len = 0;\n    for (i = 0; i < y_current->y_size; ++i)\n    {\n\tlen += (long)STRLEN(y_current->y_array[i]);\n\t// Insert a newline between lines and after last line if\n\t// y_type is MLINE.\n\tif (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t    ++len;\n    }\n\n    retval = alloc(len + 1);\n    if (retval == NULL)\n\treturn NULL;\n\n    // Copy the lines of the yank register into the string.\n    len = 0;\n    for (i = 0; i < y_current->y_size; ++i)\n    {\n\tSTRCPY(retval + len, y_current->y_array[i]);\n\tlen += (long)STRLEN(retval + len);\n\n\t// Insert a NL between lines and after the last line if y_type is\n\t// MLINE.\n\tif (y_current->y_type == MLINE || i < y_current->y_size - 1)\n\t    retval[len++] = '\\n';\n    }\n    retval[len] = NUL;\n\n    return retval;\n}\n\n    static int\ninit_write_reg(\n    int\t\tname,\n    yankreg_T\t**old_y_previous,\n    yankreg_T\t**old_y_current,\n    int\t\tmust_append,\n    int\t\t*yank_type UNUSED)\n{\n    if (!valid_yank_reg(name, TRUE))\t    // check for valid reg name\n    {\n\temsg_invreg(name);\n\treturn FAIL;\n    }\n\n    // Don't want to change the current (unnamed) register\n    *old_y_previous = y_previous;\n    *old_y_current = y_current;\n\n    get_yank_register(name, TRUE);\n    if (!y_append && !must_append)\n\tfree_yank_all();\n    return OK;\n}\n\n    static void\nfinish_write_reg(\n    int\t\tname,\n    yankreg_T\t*old_y_previous,\n    yankreg_T\t*old_y_current)\n{\n# ifdef FEAT_CLIPBOARD\n    // Send text of clipboard register to the clipboard.\n    may_set_selection();\n# endif\n\n    // ':let @\" = \"val\"' should change the meaning of the \"\" register\n    if (name != '\"')\n\ty_previous = old_y_previous;\n    y_current = old_y_current;\n}\n\n/*\n * Store string \"str\" in register \"name\".\n * \"maxlen\" is the maximum number of bytes to use, -1 for all bytes.\n * If \"must_append\" is TRUE, always append to the register.  Otherwise append\n * if \"name\" is an uppercase letter.\n * Note: \"maxlen\" and \"must_append\" don't work for the \"/\" register.\n * Careful: 'str' is modified, you may have to use a copy!\n * If \"str\" ends in '\\n' or '\\r', use linewise, otherwise use characterwise.\n */\n    void\nwrite_reg_contents(\n    int\t\tname,\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tmust_append)\n{\n    write_reg_contents_ex(name, str, maxlen, must_append, MAUTO, 0L);\n}\n\n    void\nwrite_reg_contents_lst(\n    int\t\tname,\n    char_u\t**strings,\n    int\t\tmaxlen UNUSED,\n    int\t\tmust_append,\n    int\t\tyank_type,\n    long\tblock_len)\n{\n    yankreg_T  *old_y_previous, *old_y_current;\n\n    if (name == '/' || name == '=')\n    {\n\tchar_u\t*s;\n\n\tif (strings[0] == NULL)\n\t    s = (char_u *)\"\";\n\telse if (strings[1] != NULL)\n\t{\n\t    emsg(_(e_search_pattern_and_expression_register_may_not_contain_two_or_more_lines));\n\t    return;\n\t}\n\telse\n\t    s = strings[0];\n\twrite_reg_contents_ex(name, s, -1, must_append, yank_type, block_len);\n\treturn;\n    }\n\n    if (name == '_')\t    // black hole: nothing to do\n\treturn;\n\n    if (init_write_reg(name, &old_y_previous, &old_y_current, must_append,\n\t\t&yank_type) == FAIL)\n\treturn;\n\n    str_to_reg(y_current, yank_type, (char_u *)strings, -1, block_len, TRUE);\n\n    finish_write_reg(name, old_y_previous, old_y_current);\n}\n\n    void\nwrite_reg_contents_ex(\n    int\t\tname,\n    char_u\t*str,\n    int\t\tmaxlen,\n    int\t\tmust_append,\n    int\t\tyank_type,\n    long\tblock_len)\n{\n    yankreg_T\t*old_y_previous, *old_y_current;\n    long\tlen;\n\n    if (maxlen >= 0)\n\tlen = maxlen;\n    else\n\tlen = (long)STRLEN(str);\n\n    // Special case: '/' search pattern\n    if (name == '/')\n    {\n\tset_last_search_pat(str, RE_SEARCH, TRUE, TRUE);\n\treturn;\n    }\n\n    if (name == '#')\n    {\n\tbuf_T\t*buf;\n\n\tif (VIM_ISDIGIT(*str))\n\t{\n\t    int\tnum = atoi((char *)str);\n\n\t    buf = buflist_findnr(num);\n\t    if (buf == NULL)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), (long)num);\n\t}\n\telse\n\t    buf = buflist_findnr(buflist_findpat(str, str + STRLEN(str),\n\t\t\t\t\t\t\t TRUE, FALSE, FALSE));\n\tif (buf == NULL)\n\t    return;\n\tcurwin->w_alt_fnum = buf->b_fnum;\n\treturn;\n    }\n\n    if (name == '=')\n    {\n\tchar_u\t    *p, *s;\n\n\tp = vim_strnsave(str, len);\n\tif (p == NULL)\n\t    return;\n\tif (must_append && expr_line != NULL)\n\t{\n\t    s = concat_str(expr_line, p);\n\t    vim_free(p);\n\t    p = s;\n\t}\n\tset_expr_line(p, NULL);\n\treturn;\n    }\n\n    if (name == '_')\t    // black hole: nothing to do\n\treturn;\n\n    if (init_write_reg(name, &old_y_previous, &old_y_current, must_append,\n\t\t&yank_type) == FAIL)\n\treturn;\n\n    str_to_reg(y_current, yank_type, str, len, block_len, FALSE);\n\n    finish_write_reg(name, old_y_previous, old_y_current);\n}\n#endif\t// FEAT_EVAL\n\n#if defined(FEAT_CLIPBOARD) || defined(FEAT_EVAL)\n/*\n * Put a string into a register.  When the register is not empty, the string\n * is appended.\n */\n    void\nstr_to_reg(\n    yankreg_T\t*y_ptr,\t\t// pointer to yank register\n    int\t\tyank_type,\t// MCHAR, MLINE, MBLOCK, MAUTO\n    char_u\t*str,\t\t// string to put in register\n    long\tlen,\t\t// length of string\n    long\tblocklen,\t// width of Visual block\n    int\t\tstr_list)\t// TRUE if str is char_u **\n{\n    int\t\ttype;\t\t\t// MCHAR, MLINE or MBLOCK\n    int\t\tlnum;\n    long\tstart;\n    long\ti;\n    int\t\textra;\n    int\t\tnewlines;\t\t// number of lines added\n    int\t\textraline = 0;\t\t// extra line at the end\n    int\t\tappend = FALSE;\t\t// append to last line in register\n    char_u\t*s;\n    char_u\t**ss;\n    char_u\t**pp;\n    long\tmaxlen;\n\n    if (y_ptr->y_array == NULL)\t\t// NULL means empty register\n\ty_ptr->y_size = 0;\n\n    if (yank_type == MAUTO)\n\ttype = ((str_list || (len > 0 && (str[len - 1] == NL\n\t\t\t\t\t    || str[len - 1] == CAR)))\n\t\t\t\t\t\t\t     ? MLINE : MCHAR);\n    else\n\ttype = yank_type;\n\n    // Count the number of lines within the string\n    newlines = 0;\n    if (str_list)\n    {\n\tfor (ss = (char_u **) str; *ss != NULL; ++ss)\n\t    ++newlines;\n    }\n    else\n    {\n\tfor (i = 0; i < len; i++)\n\t    if (str[i] == '\\n')\n\t\t++newlines;\n\tif (type == MCHAR || len == 0 || str[len - 1] != '\\n')\n\t{\n\t    extraline = 1;\n\t    ++newlines;\t// count extra newline at the end\n\t}\n\tif (y_ptr->y_size > 0 && y_ptr->y_type == MCHAR)\n\t{\n\t    append = TRUE;\n\t    --newlines;\t// uncount newline when appending first line\n\t}\n    }\n\n    // Without any lines make the register empty.\n    if (y_ptr->y_size + newlines == 0)\n    {\n\tVIM_CLEAR(y_ptr->y_array);\n\treturn;\n    }\n\n    // Allocate an array to hold the pointers to the new register lines.\n    // If the register was not empty, move the existing lines to the new array.\n    pp = lalloc_clear((y_ptr->y_size + newlines) * sizeof(char_u *), TRUE);\n    if (pp == NULL)\t// out of memory\n\treturn;\n    for (lnum = 0; lnum < y_ptr->y_size; ++lnum)\n\tpp[lnum] = y_ptr->y_array[lnum];\n    vim_free(y_ptr->y_array);\n    y_ptr->y_array = pp;\n    maxlen = 0;\n\n    // Find the end of each line and save it into the array.\n    if (str_list)\n    {\n\tfor (ss = (char_u **) str; *ss != NULL; ++ss, ++lnum)\n\t{\n\t    pp[lnum] = vim_strsave(*ss);\n\t    if (type == MBLOCK)\n\t    {\n\t\tint charlen = mb_string2cells(*ss, -1);\n\n\t\tif (charlen > maxlen)\n\t\t    maxlen = charlen;\n\t    }\n\t}\n    }\n    else\n    {\n\tfor (start = 0; start < len + extraline; start += i + 1)\n\t{\n\t    int charlen = 0;\n\n\t    for (i = start; i < len; ++i)\t// find the end of the line\n\t    {\n\t\tif (str[i] == '\\n')\n\t\t    break;\n\t\tif (type == MBLOCK)\n\t\t    charlen += mb_ptr2cells_len(str + i, len - i);\n\t    }\n\t    i -= start;\t\t\t// i is now length of line\n\t    if (charlen > maxlen)\n\t\tmaxlen = charlen;\n\t    if (append)\n\t    {\n\t\t--lnum;\n\t\textra = (int)STRLEN(y_ptr->y_array[lnum]);\n\t    }\n\t    else\n\t\textra = 0;\n\t    s = alloc(i + extra + 1);\n\t    if (s == NULL)\n\t\tbreak;\n\t    if (extra)\n\t\tmch_memmove(s, y_ptr->y_array[lnum], (size_t)extra);\n\t    if (append)\n\t\tvim_free(y_ptr->y_array[lnum]);\n\t    if (i > 0)\n\t\tmch_memmove(s + extra, str + start, (size_t)i);\n\t    extra += i;\n\t    s[extra] = NUL;\n\t    y_ptr->y_array[lnum++] = s;\n\t    while (--extra >= 0)\n\t    {\n\t\tif (*s == NUL)\n\t\t    *s = '\\n';\t    // replace NUL with newline\n\t\t++s;\n\t    }\n\t    append = FALSE;\t\t    // only first line is appended\n\t}\n    }\n    y_ptr->y_type = type;\n    y_ptr->y_size = lnum;\n    if (type == MBLOCK)\n\ty_ptr->y_width = (blocklen < 0 ? maxlen - 1 : blocklen);\n    else\n\ty_ptr->y_width = 0;\n# ifdef FEAT_VIMINFO\n    y_ptr->y_time_set = vim_time();\n# endif\n}\n#endif // FEAT_CLIPBOARD || FEAT_EVAL || PROTO\n", "\" Tests for register operations\n\nsource check.vim\nsource view_util.vim\n\n\" This test must be executed first to check for empty and unset registers.\nfunc Test_aaa_empty_reg_test()\n  call assert_fails('normal @@', 'E748:')\n  call assert_fails('normal @%', 'E354:')\n  call assert_fails('normal @#', 'E354:')\n  call assert_fails('normal @!', 'E354:')\n  call assert_fails('normal @:', 'E30:')\n  call assert_fails('normal @.', 'E29:')\n  call assert_fails('put /', 'E35:')\n  call assert_fails('put .', 'E29:')\nendfunc\n\nfunc Test_yank_shows_register()\n    enew\n    set report=0\n    call setline(1, ['foo', 'bar'])\n    \" Line-wise\n    exe 'norm! yy'\n    call assert_equal('1 line yanked', v:statusmsg)\n    exe 'norm! \"zyy'\n    call assert_equal('1 line yanked into \"z', v:statusmsg)\n    exe 'norm! yj'\n    call assert_equal('2 lines yanked', v:statusmsg)\n    exe 'norm! \"zyj'\n    call assert_equal('2 lines yanked into \"z', v:statusmsg)\n\n    \" Block-wise\n    exe \"norm! \\<C-V>y\"\n    call assert_equal('block of 1 line yanked', v:statusmsg)\n    exe \"norm! \\<C-V>\\\"zy\"\n    call assert_equal('block of 1 line yanked into \"z', v:statusmsg)\n    exe \"norm! \\<C-V>jy\"\n    call assert_equal('block of 2 lines yanked', v:statusmsg)\n    exe \"norm! \\<C-V>j\\\"zy\"\n    call assert_equal('block of 2 lines yanked into \"z', v:statusmsg)\n\n    bwipe!\nendfunc\n\nfunc Test_display_registers()\n    e file1\n    e file2\n    call setline(1, ['foo', 'bar'])\n    /bar\n    exe 'norm! y2l\"axx'\n    call feedkeys(\"i\\<C-R>=2*4\\n\\<esc>\")\n    call feedkeys(\":ls\\n\", 'xt')\n\n    let a = execute('display')\n    let b = execute('registers')\n\n    call assert_equal(a, b)\n    call assert_match('^\\nType Name Content\\n'\n          \\ .         '  c  \"\"   a\\n'\n          \\ .         '  c  \"0   ba\\n'\n          \\ .         '  c  \"a   b\\n'\n          \\ .         '.*'\n          \\ .         '  c  \"-   a\\n'\n          \\ .         '.*'\n          \\ .         '  c  \":   ls\\n'\n          \\ .         '  c  \"%   file2\\n'\n          \\ .         '  c  \"#   file1\\n'\n          \\ .         '  c  \"/   bar\\n'\n          \\ .         '  c  \"=   2\\*4', a)\n\n    let a = execute('registers a')\n    call assert_match('^\\nType Name Content\\n'\n          \\ .         '  c  \"a   b', a)\n\n    let a = execute('registers :')\n    call assert_match('^\\nType Name Content\\n'\n          \\ .         '  c  \":   ls', a)\n\n    bwipe!\nendfunc\n\nfunc Test_register_one()\n  \" delete a line goes into register one\n  new\n  call setline(1, \"one\")\n  normal dd\n  call assert_equal(\"one\\n\", @1)\n\n  \" delete a word does not change register one, does change \"-\n  call setline(1, \"two\")\n  normal de\n  call assert_equal(\"one\\n\", @1)\n  call assert_equal(\"two\", @-)\n\n  \" delete a word with a register does not change register one\n  call setline(1, \"three\")\n  normal \"ade\n  call assert_equal(\"three\", @a)\n  call assert_equal(\"one\\n\", @1)\n\n  \" delete a word with register DOES change register one with one of a list of\n  \" operators\n  \" %\n  call setline(1, [\"(12)3\"])\n  normal \"ad%\n  call assert_equal(\"(12)\", @a)\n  call assert_equal(\"(12)\", @1)\n\n  \" (\n  call setline(1, [\"first second\"])\n  normal $\"ad(\n  call assert_equal(\"first secon\", @a)\n  call assert_equal(\"first secon\", @1)\n\n  \" )\n  call setline(1, [\"First Second.\"])\n  normal gg0\"ad)\n  call assert_equal(\"First Second.\", @a)\n  call assert_equal(\"First Second.\", @1)\n\n  \" `\n  call setline(1, [\"start here.\"])\n  normal gg0fhmx0\"ad`x\n  call assert_equal(\"start \", @a)\n  call assert_equal(\"start \", @1)\n\n  \" /\n  call setline(1, [\"searchX\"])\n  exe \"normal gg0\\\"ad/X\\<CR>\"\n  call assert_equal(\"search\", @a)\n  call assert_equal(\"search\", @1)\n\n  \" ?\n  call setline(1, [\"Ysearch\"])\n  exe \"normal gg$\\\"ad?Y\\<CR>\"\n  call assert_equal(\"Ysearc\", @a)\n  call assert_equal(\"Ysearc\", @1)\n\n  \" n\n  call setline(1, [\"Ynext\"])\n  normal gg$\"adn\n  call assert_equal(\"Ynex\", @a)\n  call assert_equal(\"Ynex\", @1)\n\n  \" N\n  call setline(1, [\"prevY\"])\n  normal gg0\"adN\n  call assert_equal(\"prev\", @a)\n  call assert_equal(\"prev\", @1)\n\n  \" }\n  call setline(1, [\"one\", \"\"])\n  normal gg0\"ad}\n  call assert_equal(\"one\\n\", @a)\n  call assert_equal(\"one\\n\", @1)\n\n  \" {\n  call setline(1, [\"\", \"two\"])\n  normal 2G$\"ad{\n  call assert_equal(\"\\ntw\", @a)\n  call assert_equal(\"\\ntw\", @1)\n\n  bwipe!\nendfunc\n\nfunc Test_recording_status_in_ex_line()\n  norm qx\n  redraw!\n  call assert_equal('recording @x', Screenline(&lines))\n  set shortmess=q\n  redraw!\n  call assert_equal('recording', Screenline(&lines))\n  set shortmess&\n  norm q\n  redraw!\n  call assert_equal('', Screenline(&lines))\nendfunc\n\n\" Check that replaying a typed sequence does not use an Esc and following\n\" characters as an escape sequence.\nfunc Test_recording_esc_sequence()\n  new\n  try\n    let save_F2 = &t_F2\n  catch\n  endtry\n  let t_F2 = \"\\<Esc>OQ\"\n  call feedkeys(\"qqiTest\\<Esc>\", \"xt\")\n  call feedkeys(\"OQuirk\\<Esc>q\", \"xt\")\n  call feedkeys(\"Go\\<Esc>@q\", \"xt\")\n  call assert_equal(['Quirk', 'Test', 'Quirk', 'Test'], getline(1, 4))\n  bwipe!\n  if exists('save_F2')\n    let &t_F2 = save_F2\n  else\n    set t_F2=\n  endif\nendfunc\n\nfunc Test_recording_with_select_mode()\n  new\n  call feedkeys(\"qacc12345\\<Esc>gH98765\\<Esc>q\", \"tx\")\n  call assert_equal(\"98765\", getline(1))\n  call assert_equal(\"cc12345\\<Esc>gH98765\\<Esc>\", @a)\n  call setline(1, 'asdf')\n  normal! @a\n  call assert_equal(\"98765\", getline(1))\n  bwipe!\nendfunc\n\n\" Test for executing the last used register (@)\nfunc Test_last_used_exec_reg()\n  \" Test for the @: command\n  let a = ''\n  call feedkeys(\":let a ..= 'Vim'\\<CR>\", 'xt')\n  normal @:\n  call assert_equal('VimVim', a)\n\n  \" Test for the @= command\n  let x = ''\n  let a = \":let x ..= 'Vim'\\<CR>\"\n  exe \"normal @=a\\<CR>\"\n  normal @@\n  call assert_equal('VimVim', x)\n\n  \" Test for the @. command\n  let a = ''\n  call feedkeys(\"i:let a ..= 'Edit'\\<CR>\", 'xt')\n  normal @.\n  normal @@\n  call assert_equal('EditEdit', a)\n\n  \" Test for repeating the last command-line in visual mode\n  call append(0, 'register')\n  normal gg\n  let @r = ''\n  call feedkeys(\"v:yank R\\<CR>\", 'xt')\n  call feedkeys(\"v@:\", 'xt')\n  call assert_equal(\"\\nregister\\nregister\\n\", @r)\n\n  enew!\nendfunc\n\nfunc Test_get_register()\n  enew\n  edit Xfile1\n  edit Xfile2\n  call assert_equal('Xfile2', getreg('%'))\n  call assert_equal('Xfile1', getreg('#'))\n\n  call feedkeys(\"iTwo\\<Esc>\", 'xt')\n  call assert_equal('Two', getreg('.'))\n  call assert_equal('', getreg('_'))\n  call assert_beeps('normal \":yy')\n  call assert_beeps('normal \"%yy')\n  call assert_beeps('normal \".yy')\n\n  call assert_equal('', getreg(\"\\<C-F>\"))\n  call assert_equal('', getreg(\"\\<C-W>\"))\n  call assert_equal('', getreg(\"\\<C-L>\"))\n  \" Change the last used register to '\"' for the next test\n  normal! \"\"yy\n  let @\" = 'happy'\n  call assert_equal('happy', getreg())\n  call assert_equal('happy', getreg(''))\n\n  call assert_equal('', getregtype('!'))\n  call assert_fails('echo getregtype([])', 'E730:')\n  call assert_equal('v', getregtype())\n  call assert_equal('v', getregtype(''))\n\n  \" Test for inserting an invalid register content\n  call assert_beeps('exe \"normal i\\<C-R>!\"')\n\n  \" Test for inserting a register with multiple lines\n  call deletebufline('', 1, '$')\n  call setreg('r', ['a', 'b'])\n  exe \"normal i\\<C-R>r\"\n  call assert_equal(['a', 'b', ''], getline(1, '$'))\n\n  \" Test for inserting a multi-line register in the command line\n  call feedkeys(\":\\<C-R>r\\<Esc>\", 'xt')\n  call assert_equal(\"a\\rb\\r\", histget(':', -1))\n\n  call assert_fails('let r = getreg(\"=\", [])', 'E745:')\n  call assert_fails('let r = getreg(\"=\", 1, [])', 'E745:')\n  enew!\n\n  \" Using a register in operator-pending mode should fail\n  call assert_beeps('norm! c\"')\nendfunc\n\nfunc Test_set_register()\n  call assert_fails(\"call setreg('#', 200)\", 'E86:')\n  call assert_fails(\"call setreg('a', test_unknown())\", 'E908:')\n\n  edit Xfile_alt_1\n  let b1 = bufnr('')\n  edit Xfile_alt_2\n  let b2 = bufnr('')\n  edit Xfile_alt_3\n  let b3 = bufnr('')\n  call setreg('#', 'alt_1')\n  call assert_equal('Xfile_alt_1', getreg('#'))\n  call setreg('#', b2)\n  call assert_equal('Xfile_alt_2', getreg('#'))\n\n  let ab = 'regwrite'\n  call setreg('=', '')\n  call setreg('=', 'a', 'a')\n  call setreg('=', 'b', 'a')\n  call assert_equal('regwrite', getreg('='))\n\n  \" Test for setting a list of lines to special registers\n  call setreg('/', [])\n  call assert_equal('', @/)\n  call setreg('=', [])\n  call assert_equal('', @=)\n  call assert_fails(\"call setreg('/', ['a', 'b'])\", 'E883:')\n  call assert_fails(\"call setreg('=', ['a', 'b'])\", 'E883:')\n  call assert_equal(0, setreg('_', ['a', 'b']))\n\n  \" Test for recording to a invalid register\n  call assert_beeps('normal q$')\n\n  \" Appending to a register when recording\n  call append(0, \"text for clipboard test\")\n  normal gg\n  call feedkeys('qrllq', 'xt')\n  call feedkeys('qRhhq', 'xt')\n  call assert_equal('llhh', getreg('r'))\n\n  \" Appending a list of characters to a register from different lines\n  let @r = ''\n  call append(0, ['abcdef', '123456'])\n  normal gg\"ry3l\n  call cursor(2, 4)\n  normal \"Ry3l\n  call assert_equal('abc456', @r)\n\n  \" Test for gP with multiple lines selected using characterwise motion\n  %delete\n  call append(0, ['vim editor', 'vim editor'])\n  let @r = ''\n  exe \"normal ggwy/vim /e\\<CR>gP\"\n  call assert_equal(['vim editor', 'vim editor', 'vim editor'], getline(1, 3))\n\n  \" Test for gP with . register\n  %delete\n  normal iabc\n  normal \".gp\n  call assert_equal('abcabc', getline(1))\n  normal 0\".gP\n  call assert_equal('abcabcabc', getline(1))\n\n  let @\"=''\n  call setreg('', '1')\n  call assert_equal('1', @\")\n  call setreg('@', '2')\n  call assert_equal('2', @\")\n\n  enew!\nendfunc\n\n\" Test for clipboard registers (* and +)\nfunc Test_clipboard_regs()\n  CheckNotGui\n  CheckFeature clipboard_working\n\n  new\n  call append(0, \"text for clipboard test\")\n  normal gg\"*yiw\n  call assert_equal('text', getreg('*'))\n  normal gg2w\"+yiw\n  call assert_equal('clipboard', getreg('+'))\n\n  \" Test for replacing the clipboard register contents\n  set clipboard=unnamed\n  let @* = 'food'\n  normal ggviw\"*p\n  call assert_equal('text', getreg('*'))\n  call assert_equal('food for clipboard test', getline(1))\n  normal ggviw\"*p\n  call assert_equal('food', getreg('*'))\n  call assert_equal('text for clipboard test', getline(1))\n\n  \" Test for replacing the selection register contents\n  set clipboard=unnamedplus\n  let @+ = 'food'\n  normal ggviw\"+p\n  call assert_equal('text', getreg('+'))\n  call assert_equal('food for clipboard test', getline(1))\n  normal ggviw\"+p\n  call assert_equal('food', getreg('+'))\n  call assert_equal('text for clipboard test', getline(1))\n\n  \" Test for auto copying visually selected text to clipboard register\n  call setline(1, \"text for clipboard test\")\n  let @* = ''\n  set clipboard=autoselect\n  normal ggwwviwy\n  call assert_equal('clipboard', @*)\n\n  \" Test for auto copying visually selected text to selection register\n  let @+ = ''\n  set clipboard=autoselectplus\n  normal ggwviwy\n  call assert_equal('for', @+)\n\n  set clipboard&vim\n  bwipe!\nendfunc\n\n\" Test unnamed for both clipboard registers (* and +)\nfunc Test_clipboard_regs_both_unnamed()\n  CheckNotGui\n  CheckFeature clipboard_working\n  CheckTwoClipboards\n\n  let @* = 'xxx'\n  let @+ = 'xxx'\n\n  new\n\n  set clipboard=unnamed,unnamedplus\n  call setline(1, ['foo', 'bar'])\n\n  \" op_yank copies to both\n  :1\n  :normal yw\n  call assert_equal('foo', getreg('*'))\n  call assert_equal('foo', getreg('+'))\n\n  \" op_delete only copies to '+'\n  :2\n  :normal dw\n  call assert_equal('foo', getreg('*'))\n  call assert_equal('bar', getreg('+'))\n\n  set clipboard&vim\n  bwipe!\nendfunc\n\n\" Test for restarting the current mode (insert or virtual replace) after\n\" executing the contents of a register\nfunc Test_put_reg_restart_mode()\n  new\n  call append(0, 'editor')\n  normal gg\n  let @r = \"ivim \\<Esc>\"\n  call feedkeys(\"i\\<C-O>@r\\<C-R>=mode()\\<CR>\", 'xt')\n  call assert_equal('vimi editor', getline(1))\n\n  call setline(1, 'editor')\n  normal gg\n  call feedkeys(\"gR\\<C-O>@r\\<C-R>=mode()\\<CR>\", 'xt')\n  call assert_equal('vimReditor', getline(1))\n\n  bwipe!\nendfunc\n\n\" Test for executing a register using :@ command\nfunc Test_execute_register()\n  call setreg('r', [])\n  call assert_beeps('@r')\n  let i = 1\n  let @q = 'let i+= 1'\n  @q\n  @\n  call assert_equal(3, i)\n\n  \" try to execute expression register and use a backspace to cancel it\n  new\n  call feedkeys(\"@=\\<BS>ax\\<CR>y\", 'xt')\n  call assert_equal(['x', 'y'], getline(1, '$'))\n  close!\n\n  \" cannot execute a register in operator pending mode\n  call assert_beeps('normal! c@r')\nendfunc\n\n\" Test for getting register info\nfunc Test_get_reginfo()\n  enew\n  call setline(1, ['foo', 'bar'])\n\n  exe 'norm! \"zyy'\n  let info = getreginfo('\"')\n  call assert_equal('z', info.points_to)\n  call setreg('y', 'baz')\n  call assert_equal('z', getreginfo('').points_to)\n  call setreg('y', { 'isunnamed': v:true })\n  call assert_equal('y', getreginfo('\"').points_to)\n\n  exe '$put'\n  call assert_equal(getreg('y'), getline(3))\n  call setreg('', 'qux')\n  call assert_equal('0', getreginfo('').points_to)\n  call setreg('x', 'quux')\n  call assert_equal('0', getreginfo('').points_to)\n\n  let info = getreginfo('')\n  call assert_equal(getreg('', 1, 1), info.regcontents)\n  call assert_equal(getregtype(''), info.regtype)\n\n  exe \"norm! 0\\<c-v>e\" .. '\"zy'\n  let info = getreginfo('z')\n  call assert_equal(getreg('z', 1, 1), info.regcontents)\n  call assert_equal(getregtype('z'), info.regtype)\n  call assert_equal(1, +info.isunnamed)\n\n  let info = getreginfo('\"')\n  call assert_equal('z', info.points_to)\n\n  let @a=\"a1b2\"\n  nnoremap <F2> <Cmd>let g:RegInfo = getreginfo()<CR>\n  exe \"normal \\\"a\\<F2>\"\n  call assert_equal({'regcontents': ['a1b2'], 'isunnamed': v:false,\n        \\ 'regtype': 'v'}, g:RegInfo)\n  nunmap <F2>\n  unlet g:RegInfo\n\n  \" The type of \"isunnamed\" was VAR_SPECIAL but should be VAR_BOOL.  Can only\n  \" be noticed when using json_encod().\n  call setreg('a', 'foo')\n  let reginfo = getreginfo('a')\n  let expected = #{regcontents: ['foo'], isunnamed: v:false, regtype: 'v'}\n  call assert_equal(json_encode(expected), json_encode(reginfo))\n\n  bwipe!\nendfunc\n\n\" Test for restoring register with dict from getreginfo\nfunc Test_set_register_dict()\n  enew!\n\n  call setreg('\"', #{ regcontents: ['one', 'two'],\n        \\ regtype: 'V', points_to: 'z' })\n  call assert_equal(['one', 'two'], getreg('\"', 1, 1))\n  let info = getreginfo('\"')\n  call assert_equal('z', info.points_to)\n  call assert_equal('V', info.regtype)\n  call assert_equal(1, +getreginfo('z').isunnamed)\n\n  call setreg('x', #{ regcontents: ['three', 'four'],\n        \\ regtype: 'v', isunnamed: v:true })\n  call assert_equal(['three', 'four'], getreg('\"', 1, 1))\n  let info = getreginfo('\"')\n  call assert_equal('x', info.points_to)\n  call assert_equal('v', info.regtype)\n  call assert_equal(1, +getreginfo('x').isunnamed)\n\n  call setreg('y', #{ regcontents: 'five',\n        \\ regtype: \"\\<c-v>\", isunnamed: v:false })\n  call assert_equal(\"\\<c-v>4\", getreginfo('y').regtype)\n  call assert_equal(0, +getreginfo('y').isunnamed)\n  call assert_equal(['three', 'four'], getreg('\"', 1, 1))\n  call assert_equal('x', getreginfo('\"').points_to)\n\n  call setreg('\"', #{ regcontents: 'six' })\n  call assert_equal('0', getreginfo('\"').points_to)\n  call assert_equal(1, +getreginfo('0').isunnamed)\n  call assert_equal(['six'], getreginfo('0').regcontents)\n  call assert_equal(['six'], getreginfo('\"').regcontents)\n\n  let @x = 'one'\n  call setreg('x', {})\n  call assert_equal(1, len(split(execute('reg x'), '\\n')))\n\n  call assert_fails(\"call setreg('0', #{regtype: 'V'}, 'v')\", 'E118:')\n  call assert_fails(\"call setreg('0', #{regtype: 'X'})\", 'E475:')\n  call assert_fails(\"call setreg('0', #{regtype: 'vy'})\", 'E475:')\n\n  bwipe!\nendfunc\n\nfunc Test_v_register()\n  enew\n  call setline(1, 'nothing')\n\n  func s:Put()\n    let s:register = v:register\n    exec 'normal! \"' .. v:register .. 'P'\n  endfunc\n  nnoremap <buffer> <plug>(test) :<c-u>call s:Put()<cr>\n  nmap <buffer> S <plug>(test)\n\n  let @z = \"testz\\n\"\n  let @\" = \"test@\\n\"\n\n  let s:register = ''\n  call feedkeys('\"_ddS', 'mx')\n  call assert_equal('test@', getline('.'))  \" fails before 8.2.0929\n  call assert_equal('\"', s:register)        \" fails before 8.2.0929\n\n  let s:register = ''\n  call feedkeys('\"zS', 'mx')\n  call assert_equal('z', s:register)\n\n  let s:register = ''\n  call feedkeys('\"zSS', 'mx')\n  call assert_equal('\"', s:register)\n\n  let s:register = ''\n  call feedkeys('\"_S', 'mx')\n  call assert_equal('_', s:register)\n\n  let s:register = ''\n  normal \"_ddS\n  call assert_equal('\"', s:register)        \" fails before 8.2.0929\n  call assert_equal('test@', getline('.'))  \" fails before 8.2.0929\n\n  let s:register = ''\n  execute 'normal \"z:call' \"s:Put()\\n\"\n  call assert_equal('z', s:register)\n  call assert_equal('testz', getline('.'))\n\n  \" Test operator and omap\n  let @b = 'testb'\n  func s:OpFunc(...)\n    let s:register2 = v:register\n  endfunc\n  set opfunc=s:OpFunc\n\n  normal \"bg@l\n  normal S\n  call assert_equal('\"', s:register)        \" fails before 8.2.0929\n  call assert_equal('b', s:register2)\n\n  func s:Motion()\n    let s:register1 = v:register\n    normal! l\n  endfunc\n  onoremap <buffer> Q :<c-u>call s:Motion()<cr>\n\n  normal \"bg@Q\n  normal S\n  call assert_equal('\"', s:register)\n  call assert_equal('b', s:register1)\n  call assert_equal('\"', s:register2)\n\n  set opfunc&\n  bwipe!\nendfunc\n\n\" Test for executing the contents of a register as an Ex command with line\n\" continuation.\nfunc Test_execute_reg_as_ex_cmd()\n  \" Line continuation with just two lines\n  let code =<< trim END\n    let l = [\n      \\ 1]\n  END\n  let @r = code->join(\"\\n\")\n  let l = []\n  @r\n  call assert_equal([1], l)\n\n  \" Line continuation with more than two lines\n  let code =<< trim END\n    let l = [\n      \\ 1,\n      \\ 2,\n      \\ 3]\n  END\n  let @r = code->join(\"\\n\")\n  let l = []\n  @r\n  call assert_equal([1, 2, 3], l)\n\n  \" use comments interspersed with code\n  let code =<< trim END\n    let l = [\n      \"\\ one\n      \\ 1,\n      \"\\ two\n      \\ 2,\n      \"\\ three\n      \\ 3]\n  END\n  let @r = code->join(\"\\n\")\n  let l = []\n  @r\n  call assert_equal([1, 2, 3], l)\n\n  \" use line continuation in the middle\n  let code =<< trim END\n    let a = \"one\"\n    let l = [\n      \\ 1,\n      \\ 2]\n    let b = \"two\"\n  END\n  let @r = code->join(\"\\n\")\n  let l = []\n  @r\n  call assert_equal([1, 2], l)\n  call assert_equal(\"one\", a)\n  call assert_equal(\"two\", b)\n\n  \" only one line with a \\\n  let @r = \"\\\\let l = 1\"\n  call assert_fails('@r', 'E10:')\n\n  \" only one line with a \"\\\n  let @r = '   \"\\ let i = 1'\n  @r\n  call assert_false(exists('i'))\n\n  \" first line also begins with a \\\n  let @r = \"\\\\let l = [\\n\\\\ 1]\"\n  call assert_fails('@r', 'E10:')\n\n  \" Test with a large number of lines\n  let @r = \"let str = \\n\"\n  let @r ..= repeat(\"  \\\\ 'abcdefghijklmnopqrstuvwxyz' ..\\n\", 312)\n  let @r ..= '  \\ \"\"'\n  @r\n  call assert_equal(repeat('abcdefghijklmnopqrstuvwxyz', 312), str)\nendfunc\n\n\" Test for clipboard registers with ASCII NUL\nfunc Test_clipboard_nul()\n  CheckFeature clipboard_working\n  new\n\n  \" Test for putting ASCII NUL into the clipboard\n  set clipboard=unnamed\n  call append(0, \"\\ntest\")\n  normal ggyyp\n  call assert_equal(\"^@test^@\", strtrans(getreg('*')))\n  call assert_equal(getline(1), getline(2))\n  let b = split(execute(\":reg *\"), \"\\n\")\n  call assert_match('\"\\*\\s*\\^@test\\^J',b[1])\n\n  set clipboard&vim\n  bwipe!\nendfunc\n\nfunc Test_ve_blockpaste()\n  new\n  set ve=all\n  0put =['QWERTZ','ASDFGH']\n  call cursor(1,1)\n  exe \":norm! \\<C-V>3ljdP\"\n  call assert_equal(1, col('.'))\n  call assert_equal(getline(1, 2), ['QWERTZ', 'ASDFGH'])\n  call cursor(1,1)\n  exe \":norm! \\<C-V>3ljd\"\n  call cursor(1,1)\n  norm! $3lP\n  call assert_equal(5, col('.'))\n  call assert_equal(getline(1, 2), ['TZ  QWER', 'GH  ASDF'])\n  set ve&vim\n  bwipe!\nendfunc\n\nfunc Test_insert_small_delete()\n  new\n  call setline(1, ['foo foobar bar'])\n  call cursor(1,1)\n  exe \":norm! ciw'\\<C-R>-'\"\n  call assert_equal(\"'foo' foobar bar\", getline(1))\n  exe \":norm! w.w.\"\n  call assert_equal(\"'foo' 'foobar' 'bar'\", getline(1))\n  bwipe!\nendfunc\n\n\" Record in insert mode using CTRL-O\nfunc Test_record_in_insert_mode()\n  new\n  let @r = ''\n  call setline(1, ['foo'])\n  call feedkeys(\"i\\<C-O>qrbaz\\<C-O>q\", 'xt')\n  call assert_equal('baz', @r)\n  bwipe!\nendfunc\n\nfunc Test_record_in_select_mode()\n  new\n  call setline(1, 'text')\n  sil norm \u0016q0\u00070\n  sil norm q\n  call assert_equal('0ext', getline(1))\n\n  %delete\n  let @r = ''\n  call setline(1, ['abc', 'abc', 'abc'])\n  smap <F2> <Right><Right>,\n  call feedkeys(\"qrgh\\<F2>Dk\\<Esc>q\", 'xt')\n  call assert_equal(\"gh\\<F2>Dk\\<Esc>\", @r)\n  norm j0@rj0@@\n  call assert_equal([',Dk', ',Dk', ',Dk'], getline(1, 3))\n  sunmap <F2>\n\n  bwipe!\nendfunc\n\n\" mapping that ends macro recording should be removed from recorded macro\nfunc Test_end_record_using_mapping()\n  call setline(1, 'aaa')\n  nnoremap s q\n  call feedkeys('safas', 'tx')\n  call assert_equal('fa', @a)\n  nunmap s\n\n  nnoremap xx q\n  call feedkeys('0xxafaxx', 'tx')\n  call assert_equal('fa', @a)\n  nunmap xx\n\n  nnoremap xsx q\n  call feedkeys('0qafaxsx', 'tx')\n  call assert_equal('fa', @a)\n  nunmap xsx\n\n  bwipe!\nendfunc\n\nfunc Test_end_reg_executing()\n  nnoremap s <Nop>\n  let @a = 's'\n  call feedkeys(\"@aqaq\\<Esc>\", 'tx')\n  call assert_equal('', @a)\n  call assert_equal('', getline(1))\n\n  call setline(1, 'aaa')\n  nnoremap s qa\n  let @a = 'fa'\n  call feedkeys(\"@asq\\<Esc>\", 'tx')\n  call assert_equal('', @a)\n  call assert_equal('aaa', getline(1))\n\n  nunmap s\n  bwipe!\nendfunc\n\n\" This was causing a crash because y_append was ending up being NULL\nfunc Test_zero_y_append()\n  \" Run in a separate Vim instance because changing 'encoding' may cause\n  \" trouble for later tests.\n  let lines =<< trim END\n      d\n      silent ?n\n      next <sfile>\n      so\n      sil! norm 0V\u0080PS\u0003\u0011P\n      set enc=latin1\n      \u00a0\n  END\n  call writefile(lines, 'XTest_zero_y_append', 'D')\n  call RunVim([], [], '-u NONE -i NONE -e -s -S XTest_zero_y_append -c qa\\!')\nendfunc\n\n\" Make sure that y_append is correctly reset\n\" and the previous register is working as expected\nfunc Test_register_y_append_reset()\n  new\n  call setline(1, ['1',\n    \\ '2 ----------------------------------------------------',\n    \\ '3',\n    \\ '4',\n    \\ '5 ----------------------------------------------------',\n    \\ '6',\n    \\ '7',\n    \\ '8 ----------------------------------------------------',\n    \\ '9',\n    \\ '10 aaaaaaa 4.',\n    \\ '11 Game Dbl-Figures Leaders:',\n    \\ '12 Player Pts FG% 3P% FT% RB AS BL ST TO PF EFF',\n    \\ '13 bbbbbbbbb 12 (50 /0 /67 )/ 7/ 3/ 0/ 2/ 3/ 4/+15',\n    \\ '14 cccccc 12 (57 /67 /100)/ 2/ 1/ 1/ 0/ 1/ 3/+12',\n    \\ '15 ddddddd 10 (63 /0 /0 )/ 1/ 3/ 0/ 3/ 5/ 3/ +9',\n    \\ '16 4 5-15 0-3 2-2 5-12 1-1 3-4 33.3 0.0 100 41.7 100 75 12 14',\n    \\ '17 F 23-55 2-10 9-11 23-52 3-13 26-29 41.8 20 81.8 44.2 23.1 89.7 57 75',\n    \\ '18 4 3 6 3 2 3 3 4 3 3 7 3 1 4 6 -1 -1 +2 -1 -2',\n    \\ '19 F 13 19 5 10 4 17 22 9 14 32 13 4 20 17 -1 -13 -4 -3 -3 +5'])\n  11\n  exe \"norm! \\\"a5dd\"\n  norm! j\n  exe \"norm! \\\"bY\"\n  norm! 2j\n  exe \"norm! \\\"BY\"\n  norm! 4k\n  norm! 5dd\n  norm! 3k\n  \" The next put should put the content of the unnamed register, not of\n  \" register b!\n  norm! p\n  call assert_equal(['1',\n    \\ '2 ----------------------------------------------------',\n    \\ '3',\n    \\ '4',\n    \\ '5 ----------------------------------------------------',\n    \\ '6',\n    \\ '10 aaaaaaa 4.',\n    \\ '16 4 5-15 0-3 2-2 5-12 1-1 3-4 33.3 0.0 100 41.7 100 75 12 14',\n    \\ '17 F 23-55 2-10 9-11 23-52 3-13 26-29 41.8 20 81.8 44.2 23.1 89.7 57 75',\n    \\ '18 4 3 6 3 2 3 3 4 3 3 7 3 1 4 6 -1 -1 +2 -1 -2',\n    \\ '19 F 13 19 5 10 4 17 22 9 14 32 13 4 20 17 -1 -13 -4 -3 -3 +5',\n    \\ '7',\n    \\ '8 ----------------------------------------------------',\n    \\ '9'], getline(1,'$'))\n  bwipe!\nendfunc\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/register.c", "src/testdir/test_registers.vim", "src/version.c"], "buggy_code_start_loc": [304, 835, 697], "buggy_code_end_loc": [305, 835, 697], "fixing_code_start_loc": [304, 836, 698], "fixing_code_end_loc": [305, 853, 700], "type": "CWE-476", "message": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1531.", "other": {"cve": {"id": "CVE-2023-2609", "sourceIdentifier": "security@huntr.dev", "published": "2023-05-09T18:15:14.147", "lastModified": "2023-05-24T05:15:09.897", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "NULL Pointer Dereference in GitHub repository vim/vim prior to 9.0.1531."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.1531", "matchCriteriaId": "46AFDD8D-F54F-4E02-883F-5A99472531C4"}]}]}], "references": [{"url": "https://github.com/vim/vim/commit/d1ae8366aff286d41e7f5bc513cc0a1af5130aad", "source": "security@huntr.dev", "tags": ["Patch"]}, {"url": "https://huntr.dev/bounties/1679be5a-565f-4a44-a430-836412a0b622", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PCLJN4QINITA3ZASKLEJ64C5TFNKELMO/", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/vim/vim/commit/d1ae8366aff286d41e7f5bc513cc0a1af5130aad"}}