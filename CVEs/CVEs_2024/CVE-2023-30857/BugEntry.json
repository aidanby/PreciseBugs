{"buggy_code": ["import type {Key} from \"@aedart/contracts/support\";\nimport type {\n    Context,\n    MetaCallback,\n    MetaEntry,\n    MetadataRecord,\n    MetaTargetContext\n} from \"@aedart/contracts/support/meta\";\nimport { METADATA } from \"@aedart/contracts/support/meta\";\nimport { set, get } from \"@aedart/support/objects\";\nimport { cloneDeep } from \"lodash-es\";\n\n/**\n * Registry that contains the writable metadata (`context.metadata`).\n * \n * **Warning**: _This registry is **NOT intended** to be available for writing,\n * outside the scope of the meta decorator._\n *\n * @type {WeakMap<object, MetadataRecord>}\n */\nconst registry: WeakMap<object, MetadataRecord> = new WeakMap<object, MetadataRecord>();\n\n/**\n * Store value as metadata, for given key.\n *\n * @see getMeta\n * @see getAllMeta\n *\n * @param {Key | MetaCallback} key Key or path identifier. If callback is given,\n *                                 then its resulting {@link MetaEntry}'s `key`\n *                                 and `value` are stored.\n * @param {unknown} [value] Value to store. Ignored if `key` argument is\n *                          a callback.\n * @returns {(target: object, context: Context) => (void | ((initialValue: unknown) => unknown) | undefined)}\n */\nexport function meta(\n    key: Key | MetaCallback,\n    value?: unknown\n) {\n    return (target: object, context: Context) => {\n\n        switch(context.kind) {\n            // For a class target, the meta can be added directly.\n            case 'class':\n                return save(\n                    resolveMetaTargetContext(target, target, context),\n                    context,\n                    key,\n                    value\n                );\n\n            // When a field is decorated, we need to rely on the value initialisation to\n            // obtain correct owner...\n            case 'field':\n                return function(initialValue: unknown) {\n                    save(\n                        // @ts-expect-error: \"this\" corresponds to class instance.\n                        resolveMetaTargetContext(target, this, context),\n                        context,\n                        key,\n                        value\n                    );\n\n                    return initialValue;\n                }\n\n            // For all other kinds of targets, we need to use the initialisation logic\n            // to obtain the correct owner. This is needed for current implementation\n            // and until the TC39 proposal is approved and implemented.\n            // @see https://github.com/tc39/proposal-decorator-metadata\n            default:\n                context.addInitializer(function() {\n                    save(\n                        resolveMetaTargetContext(target, this, context),\n                        context,\n                        key,\n                        value\n                    );\n                });\n                return;\n        }\n    }\n}\n\n/**\n * Return metadata that matches key, for given target\n *\n * @see getAllMeta\n *\n * @template T\n * @template D=unknown Type of default value\n *\n * @param {object} owner Class that owns metadata\n * @param {Key} key Key or path identifier\n * @param {D} [defaultValue=undefined] Default value to return, in case key does not exist\n *\n * @returns {T | D | undefined}\n */\nexport function getMeta<T, D = unknown>(owner: object, key: Key, defaultValue?: D): T | D | undefined\n{\n    const metadata: Readonly<MetadataRecord> | undefined = getAllMeta(owner);\n    if (metadata === undefined) {\n        return defaultValue;\n    }\n    \n    return get(metadata, key, defaultValue);\n}\n\n/**\n * Returns all registered metadata for given target, if available\n *\n * @see getMeta\n *\n * @param {object} owner Class that owns metadata\n *\n * @returns {Readonly<MetadataRecord> | undefined}\n */\nexport function getAllMeta(owner: object): Readonly<MetadataRecord> | undefined\n{\n    // @ts-expect-error: Owner can have Symbol.metadata defined - or not\n    return owner[METADATA] ?? undefined;\n}\n\n/**\n * Save metadata\n * \n * @param {MetaTargetContext} targetContext\n * @param {Context} context Decorator context\n * @param {Key | MetaCallback} key Key or path identifier. If callback is given,\n *                                 then its resulting {@link MetaEntry}'s `key`\n *                                 and `value` are stored.\n * @param {unknown} [value] Value to store. Ignored if `key` argument is\n *                          a callback.\n *\n * @return {void}\n */\nfunction save(\n    targetContext: MetaTargetContext,\n    context: Context,\n    key: Key | MetaCallback,\n    value?: unknown,\n)\n{\n    // Determine if metadata from context can be used (if it's available), and resolve it either from\n    // the decorator context or from the registry.\n    const useMetaFromContext: boolean = Reflect.has(context, 'metadata') && typeof context.metadata === 'object';\n    const metadata: MetadataRecord = resolveMetadataRecord(targetContext.owner, context, useMetaFromContext);\n\n    // Set context.metadata, in case that it didn't exist in the decorator context, when\n    // reaching this point. This also allows \"meta callback\" to access previous defined\n    // metadata.\n    context.metadata = metadata;\n\n    // Whenever the key is a \"meta\" callback, for any other kind than a class or a field,\n    // we overwrite the \"context.addInitializer\" method, so init callbacks can be invoked\n    // manually after meta has been defined.\n    const initCallbacks: ((this: any /* eslint-disable-line @typescript-eslint/no-explicit-any */) => void)[] = [];\n    if (typeof key === 'function' && (context.kind !== 'class' && context.kind !== 'field')) {\n        context.addInitializer = (callback: (this: any /* eslint-disable-line @typescript-eslint/no-explicit-any */) => void) => {\n            initCallbacks.push(callback);\n        }\n    }\n\n    // Resolve meta entry (key and value). When a \"meta callback\" is given, it is invoked\n    // here. Afterward, set the resolved key-value. \n    const entry: MetaEntry = resolveEntry(\n        targetContext,\n        context,\n        key,\n        value,\n    );\n\n    set(metadata, entry.key, entry.value);\n    \n    // When the metadata originates from the decorator context, we can stop here.\n    // Otherwise, we need to save it in the internal registry...\n    if (useMetaFromContext) {\n        runIniCallbacks(targetContext, initCallbacks);\n        return;\n    }\n\n    registry.set(targetContext.owner, metadata);\n\n    // Lastly, define the owner[Symbol.metadata] property (only done once for the owner).\n    // In case that owner is a subclass, then this ensures that it \"overwrites\" the parent's\n    // [Symbol.metadata] property and offers its own version thereof.\n    Reflect.defineProperty(targetContext.owner, METADATA, {\n        get: () => {\n            // To ensure that metadata cannot be changed outside the scope and context of a\n            // meta decorator, a deep clone of the record is returned here. JavaScript's\n            // native structuredClone cannot be used, because it does not support symbols.\n            return cloneDeep(registry.get(targetContext.owner));\n        },\n        \n        // Ensure that the property cannot be deleted\n        configurable: false\n    });\n\n    // Invoke evt. init callbacks...\n    runIniCallbacks(targetContext, initCallbacks);\n}\n\n/**\n * Resolve the metadata record that must be used when writing new metadata\n * \n * @param {object} owner\n * @param {Context} context\n * @param {boolean} useMetaFromContext\n * \n * @returns {MetadataRecord}\n */\nfunction resolveMetadataRecord(owner: object, context: Context, useMetaFromContext: boolean): MetadataRecord\n{\n    // If registry is not to be used, it means that context.metadata is available \n    if (useMetaFromContext) {\n        return context.metadata as MetadataRecord;\n    }\n\n    // Obtain record from registry, or create new empty object.\n    let metadata: MetadataRecord = registry.get(owner) ?? {};\n\n    // In case that the owner has Symbol.metadata defined (e.g. from base class),\n    // then merge it current metadata. This ensures that inheritance works as\n    // intended, whilst a base class still keeping its original metadata.\n    if (Reflect.has(owner, METADATA)) {\n        // @ts-expect-error: Owner has Symbol.metadata!\n        metadata = Object.assign(metadata, owner[METADATA]);\n    }\n\n    return metadata;\n}\n\n/**\n * Resolve the \"meta\" entry's key and value\n * \n * @param {MetaTargetContext} targetContext\n * @param {Context} context\n * @param {Key | MetaCallback} key If callback is given, then it is invoked.\n *                                 It's resulting meta entry is returned.\n * @param {unknown} value Value to store as metadata. Ignored if callback is given\n *                        as key.\n *                        \n * @returns {MetaEntry}\n */\nfunction resolveEntry(\n    targetContext: MetaTargetContext,\n    context: Context,\n    key: Key | MetaCallback,\n    value: unknown,\n): MetaEntry\n{\n    if (typeof key === 'function') {\n        return (key as MetaCallback)(targetContext.target, context, targetContext.owner);\n    }\n\n    return {\n        key: (key as Key),\n        value: value\n    }\n}\n\n/**\n * Invokes the given initialisation callbacks\n * \n * @param {MetaTargetContext} targetContext\n * @param {((this:any) => void)[]} callbacks\n */\nfunction runIniCallbacks(targetContext: MetaTargetContext, callbacks: ((this: any /* eslint-disable-line @typescript-eslint/no-explicit-any */) => void)[]): void\n{\n    callbacks.forEach((callback: (this: any /* eslint-disable-line @typescript-eslint/no-explicit-any */) => void) => {\n        callback.call(targetContext.thisArg);\n    });\n}\n\n/**\n * Resolve the meta target context\n *\n * **Caution**: _`thisArg` should only be set from an \"addInitializer\" callback\n * function, via decorator context._\n * \n * @param {object} target Target the is being decorated\n * @param {object} thisArg The bound \"this\" value, from \"addInitializer\" callback function.\n * @param {Context} context\n * \n * @returns {MetaTargetContext}\n */\nfunction resolveMetaTargetContext(\n    target: object,\n    thisArg: any, /* eslint-disable-line @typescript-eslint/no-explicit-any */\n    context: Context\n): MetaTargetContext\n{\n    return {\n        owner: resolveTargetOwner(thisArg, context),\n        thisArg: thisArg,\n        target: target\n    }\n}\n\n/**\n * Resolve the target's \"owner\"\n *\n * **Caution**: _`thisArg` should only be set from an \"addInitializer\" callback\n * function, via decorator context._\n * \n * @param {object} thisArg The bound \"this\" value, from \"addInitializer\" callback function.\n * @param {Context} context\n * \n * @returns {object} Target owner class\n */\nfunction resolveTargetOwner(thisArg: object, context: Context): object\n{\n    if (context.kind === 'class') {\n        return thisArg;\n    }\n\n    // @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#class_context\n    return (context.static)\n        ? thisArg\n        // @ts-expect-error: When target is not static, then it's obtainable via prototype\n        : Reflect.getPrototypeOf(thisArg).constructor;\n}"], "fixing_code": ["import type {Key} from \"@aedart/contracts/support\";\nimport type {\n    Context,\n    MetaCallback,\n    MetaEntry,\n    MetadataRecord,\n    MetaTargetContext\n} from \"@aedart/contracts/support/meta\";\nimport { METADATA } from \"@aedart/contracts/support/meta\";\nimport { set, get } from \"@aedart/support/objects\";\nimport { cloneDeep } from \"lodash-es\";\n\n/**\n * Registry that contains the writable metadata (`context.metadata`).\n * \n * **Warning**: _This registry is **NOT intended** to be available for writing,\n * outside the scope of the meta decorator._\n *\n * @type {WeakMap<object, MetadataRecord>}\n */\nconst registry: WeakMap<object, MetadataRecord> = new WeakMap<object, MetadataRecord>();\n\n/**\n * Store value as metadata, for given key.\n *\n * @see getMeta\n * @see getAllMeta\n *\n * @param {Key | MetaCallback} key Key or path identifier. If callback is given,\n *                                 then its resulting {@link MetaEntry}'s `key`\n *                                 and `value` are stored.\n * @param {unknown} [value] Value to store. Ignored if `key` argument is\n *                          a callback.\n * @returns {(target: object, context: Context) => (void | ((initialValue: unknown) => unknown) | undefined)}\n */\nexport function meta(\n    key: Key | MetaCallback,\n    value?: unknown\n) {\n    return (target: object, context: Context) => {\n\n        switch(context.kind) {\n            // For a class target, the meta can be added directly.\n            case 'class':\n                return save(\n                    resolveMetaTargetContext(target, target, context),\n                    context,\n                    key,\n                    value\n                );\n\n            // When a field is decorated, we need to rely on the value initialisation to\n            // obtain correct owner...\n            case 'field':\n                return function(initialValue: unknown) {\n                    save(\n                        // @ts-expect-error: \"this\" corresponds to class instance.\n                        resolveMetaTargetContext(target, this, context),\n                        context,\n                        key,\n                        value\n                    );\n\n                    return initialValue;\n                }\n\n            // For all other kinds of targets, we need to use the initialisation logic\n            // to obtain the correct owner. This is needed for current implementation\n            // and until the TC39 proposal is approved and implemented.\n            // @see https://github.com/tc39/proposal-decorator-metadata\n            default:\n                context.addInitializer(function() {\n                    save(\n                        resolveMetaTargetContext(target, this, context),\n                        context,\n                        key,\n                        value\n                    );\n                });\n                return;\n        }\n    }\n}\n\n/**\n * Return metadata that matches key, for given target\n *\n * @see getAllMeta\n *\n * @template T\n * @template D=unknown Type of default value\n *\n * @param {object} owner Class that owns metadata\n * @param {Key} key Key or path identifier\n * @param {D} [defaultValue=undefined] Default value to return, in case key does not exist\n *\n * @returns {T | D | undefined}\n */\nexport function getMeta<T, D = unknown>(owner: object, key: Key, defaultValue?: D): T | D | undefined\n{\n    const metadata: Readonly<MetadataRecord> | undefined = getAllMeta(owner);\n    if (metadata === undefined) {\n        return defaultValue;\n    }\n    \n    return get(metadata, key, defaultValue);\n}\n\n/**\n * Returns all registered metadata for given target, if available\n *\n * @see getMeta\n *\n * @param {object} owner Class that owns metadata\n *\n * @returns {Readonly<MetadataRecord> | undefined}\n */\nexport function getAllMeta(owner: object): Readonly<MetadataRecord> | undefined\n{\n    // @ts-expect-error: Owner can have Symbol.metadata defined - or not\n    return owner[METADATA] ?? undefined;\n}\n\n/**\n * Save metadata\n * \n * @param {MetaTargetContext} targetContext\n * @param {Context} context Decorator context\n * @param {Key | MetaCallback} key Key or path identifier. If callback is given,\n *                                 then its resulting {@link MetaEntry}'s `key`\n *                                 and `value` are stored.\n * @param {unknown} [value] Value to store. Ignored if `key` argument is\n *                          a callback.\n *\n * @return {void}\n */\nfunction save(\n    targetContext: MetaTargetContext,\n    context: Context,\n    key: Key | MetaCallback,\n    value?: unknown,\n)\n{\n    // Determine if metadata from context can be used (if it's available), and resolve it either from\n    // the decorator context or from the registry.\n    const useMetaFromContext: boolean = Reflect.has(context, 'metadata') && typeof context.metadata === 'object';\n    const metadata: MetadataRecord = resolveMetadataRecord(targetContext.owner, context, useMetaFromContext);\n\n    // Set context.metadata, in case that it didn't exist in the decorator context, when\n    // reaching this point. This also allows \"meta callback\" to access previous defined\n    // metadata.\n    context.metadata = metadata;\n\n    // Whenever the key is a \"meta\" callback, for any other kind than a class or a field,\n    // we overwrite the \"context.addInitializer\" method, so init callbacks can be invoked\n    // manually after meta has been defined.\n    const initCallbacks: ((this: any /* eslint-disable-line @typescript-eslint/no-explicit-any */) => void)[] = [];\n    if (typeof key === 'function' && (context.kind !== 'class' && context.kind !== 'field')) {\n        context.addInitializer = (callback: (this: any /* eslint-disable-line @typescript-eslint/no-explicit-any */) => void) => {\n            initCallbacks.push(callback);\n        }\n    }\n\n    // Resolve meta entry (key and value). When a \"meta callback\" is given, it is invoked\n    // here. Afterward, set the resolved key-value. \n    const entry: MetaEntry = resolveEntry(\n        targetContext,\n        context,\n        key,\n        value,\n    );\n\n    set(metadata, entry.key, entry.value);\n    \n    // When the metadata originates from the decorator context, we can stop here.\n    // Otherwise, we need to save it in the internal registry...\n    if (useMetaFromContext) {\n        runIniCallbacks(targetContext, initCallbacks);\n        return;\n    }\n\n    registry.set(targetContext.owner, metadata);\n\n    // Lastly, define the owner[Symbol.metadata] property (only done once for the owner).\n    // In case that owner is a subclass, then this ensures that it \"overwrites\" the parent's\n    // [Symbol.metadata] property and offers its own version thereof.\n    Reflect.defineProperty(targetContext.owner, METADATA, {\n        get: () => {\n            // To ensure that metadata cannot be changed outside the scope and context of a\n            // meta decorator, a deep clone of the record is returned here. JavaScript's\n            // native structuredClone cannot be used, because it does not support symbols.\n            return cloneDeep(registry.get(targetContext.owner));\n        },\n        \n        // Ensure that the property cannot be deleted\n        configurable: false\n    });\n\n    // Invoke evt. init callbacks...\n    runIniCallbacks(targetContext, initCallbacks);\n}\n\n/**\n * Resolve the metadata record that must be used when writing new metadata\n * \n * @param {object} owner\n * @param {Context} context\n * @param {boolean} useMetaFromContext\n * \n * @returns {MetadataRecord}\n */\nfunction resolveMetadataRecord(owner: object, context: Context, useMetaFromContext: boolean): MetadataRecord\n{\n    // If registry is not to be used, it means that context.metadata is available \n    if (useMetaFromContext) {\n        return context.metadata as MetadataRecord;\n    }\n\n    // Obtain record from registry, or create new empty object.\n    let metadata: MetadataRecord = registry.get(owner) ?? Object.create(null);\n\n    // In case that the owner has Symbol.metadata defined (e.g. from base class),\n    // then merge it current metadata. This ensures that inheritance works as\n    // intended, whilst a base class still keeping its original metadata.\n    if (Reflect.has(owner, METADATA)) {\n        // @ts-expect-error: Owner has Symbol.metadata!\n        metadata = Object.assign(metadata, owner[METADATA]);\n    }\n\n    return metadata;\n}\n\n/**\n * Resolve the \"meta\" entry's key and value\n * \n * @param {MetaTargetContext} targetContext\n * @param {Context} context\n * @param {Key | MetaCallback} key If callback is given, then it is invoked.\n *                                 It's resulting meta entry is returned.\n * @param {unknown} value Value to store as metadata. Ignored if callback is given\n *                        as key.\n *                        \n * @returns {MetaEntry}\n */\nfunction resolveEntry(\n    targetContext: MetaTargetContext,\n    context: Context,\n    key: Key | MetaCallback,\n    value: unknown,\n): MetaEntry\n{\n    if (typeof key === 'function') {\n        return (key as MetaCallback)(targetContext.target, context, targetContext.owner);\n    }\n\n    return {\n        key: (key as Key),\n        value: value\n    }\n}\n\n/**\n * Invokes the given initialisation callbacks\n * \n * @param {MetaTargetContext} targetContext\n * @param {((this:any) => void)[]} callbacks\n */\nfunction runIniCallbacks(targetContext: MetaTargetContext, callbacks: ((this: any /* eslint-disable-line @typescript-eslint/no-explicit-any */) => void)[]): void\n{\n    callbacks.forEach((callback: (this: any /* eslint-disable-line @typescript-eslint/no-explicit-any */) => void) => {\n        callback.call(targetContext.thisArg);\n    });\n}\n\n/**\n * Resolve the meta target context\n *\n * **Caution**: _`thisArg` should only be set from an \"addInitializer\" callback\n * function, via decorator context._\n * \n * @param {object} target Target the is being decorated\n * @param {object} thisArg The bound \"this\" value, from \"addInitializer\" callback function.\n * @param {Context} context\n * \n * @returns {MetaTargetContext}\n */\nfunction resolveMetaTargetContext(\n    target: object,\n    thisArg: any, /* eslint-disable-line @typescript-eslint/no-explicit-any */\n    context: Context\n): MetaTargetContext\n{\n    return {\n        owner: resolveTargetOwner(thisArg, context),\n        thisArg: thisArg,\n        target: target\n    }\n}\n\n/**\n * Resolve the target's \"owner\"\n *\n * **Caution**: _`thisArg` should only be set from an \"addInitializer\" callback\n * function, via decorator context._\n * \n * @param {object} thisArg The bound \"this\" value, from \"addInitializer\" callback function.\n * @param {Context} context\n * \n * @returns {object} Target owner class\n */\nfunction resolveTargetOwner(thisArg: object, context: Context): object\n{\n    if (context.kind === 'class') {\n        return thisArg;\n    }\n\n    // @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#class_context\n    return (context.static)\n        ? thisArg\n        // @ts-expect-error: When target is not static, then it's obtainable via prototype\n        : Reflect.getPrototypeOf(thisArg).constructor;\n}"], "filenames": ["packages/support/src/meta/meta.ts"], "buggy_code_start_loc": [220], "buggy_code_end_loc": [221], "fixing_code_start_loc": [220], "fixing_code_end_loc": [221], "type": "CWE-1321", "message": "@aedart/support is the support package for Ion, a monorepo for JavaScript/TypeScript packages. Prior to version `0.6.1`, there is a possible prototype pollution issue for the `MetadataRecord`, when merged with a base class' metadata object, in `meta` decorator from the `@aedart/support` package. The likelihood of exploitation is questionable, given that a class's metadata can only be set or altered when the class is decorated via `meta()`. Furthermore, object(s) of sensitive nature would have to be stored as metadata, before this can lead to a security impact. The issue has been patched in version `0.6.1`.\n", "other": {"cve": {"id": "CVE-2023-30857", "sourceIdentifier": "security-advisories@github.com", "published": "2023-04-28T21:15:09.127", "lastModified": "2023-05-08T17:29:51.240", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "@aedart/support is the support package for Ion, a monorepo for JavaScript/TypeScript packages. Prior to version `0.6.1`, there is a possible prototype pollution issue for the `MetadataRecord`, when merged with a base class' metadata object, in `meta` decorator from the `@aedart/support` package. The likelihood of exploitation is questionable, given that a class's metadata can only be set or altered when the class is decorated via `meta()`. Furthermore, object(s) of sensitive nature would have to be stored as metadata, before this can lead to a security impact. The issue has been patched in version `0.6.1`.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:aedart:ion:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "0.6.1", "matchCriteriaId": "80FB7841-5B3F-48A1-9CD7-5B4CDF9723A1"}]}]}], "references": [{"url": "https://github.com/aedart/ion/commit/c3e2ee08710d4164d796ecb66ed291335dae9291", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/aedart/ion/security/advisories/GHSA-wwxh-74fx-33c6", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/aedart/ion/commit/c3e2ee08710d4164d796ecb66ed291335dae9291"}}