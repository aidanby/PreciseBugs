{"buggy_code": ["/*\n *  Linux MegaRAID driver for SAS based RAID controllers\n *\n *  Copyright (c) 2003-2013  LSI Corporation\n *  Copyright (c) 2013-2016  Avago Technologies\n *  Copyright (c) 2016-2018  Broadcom Inc.\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License\n *  as published by the Free Software Foundation; either version 2\n *  of the License, or (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  Authors: Broadcom Inc.\n *           Sreenivas Bagalkote\n *           Sumant Patro\n *           Bo Yang\n *           Adam Radford\n *           Kashyap Desai <kashyap.desai@broadcom.com>\n *           Sumit Saxena <sumit.saxena@broadcom.com>\n *\n *  Send feedback to: megaraidlinux.pdl@broadcom.com\n */\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/uio.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/vmalloc.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"megaraid_sas_fusion.h\"\n#include \"megaraid_sas.h\"\n\n/*\n * Number of sectors per IO command\n * Will be set in megasas_init_mfi if user does not provide\n */\nstatic unsigned int max_sectors;\nmodule_param_named(max_sectors, max_sectors, int, 0);\nMODULE_PARM_DESC(max_sectors,\n\t\"Maximum number of sectors per IO command\");\n\nstatic int msix_disable;\nmodule_param(msix_disable, int, S_IRUGO);\nMODULE_PARM_DESC(msix_disable, \"Disable MSI-X interrupt handling. Default: 0\");\n\nstatic unsigned int msix_vectors;\nmodule_param(msix_vectors, int, S_IRUGO);\nMODULE_PARM_DESC(msix_vectors, \"MSI-X max vector count. Default: Set by FW\");\n\nstatic int allow_vf_ioctls;\nmodule_param(allow_vf_ioctls, int, S_IRUGO);\nMODULE_PARM_DESC(allow_vf_ioctls, \"Allow ioctls in SR-IOV VF mode. Default: 0\");\n\nstatic unsigned int throttlequeuedepth = MEGASAS_THROTTLE_QUEUE_DEPTH;\nmodule_param(throttlequeuedepth, int, S_IRUGO);\nMODULE_PARM_DESC(throttlequeuedepth,\n\t\"Adapter queue depth when throttled due to I/O timeout. Default: 16\");\n\nunsigned int resetwaittime = MEGASAS_RESET_WAIT_TIME;\nmodule_param(resetwaittime, int, S_IRUGO);\nMODULE_PARM_DESC(resetwaittime, \"Wait time in (1-180s) after I/O timeout before resetting adapter. Default: 180s\");\n\nint smp_affinity_enable = 1;\nmodule_param(smp_affinity_enable, int, S_IRUGO);\nMODULE_PARM_DESC(smp_affinity_enable, \"SMP affinity feature enable/disable Default: enable(1)\");\n\nint rdpq_enable = 1;\nmodule_param(rdpq_enable, int, S_IRUGO);\nMODULE_PARM_DESC(rdpq_enable, \"Allocate reply queue in chunks for large queue depth enable/disable Default: enable(1)\");\n\nunsigned int dual_qdepth_disable;\nmodule_param(dual_qdepth_disable, int, S_IRUGO);\nMODULE_PARM_DESC(dual_qdepth_disable, \"Disable dual queue depth feature. Default: 0\");\n\nunsigned int scmd_timeout = MEGASAS_DEFAULT_CMD_TIMEOUT;\nmodule_param(scmd_timeout, int, S_IRUGO);\nMODULE_PARM_DESC(scmd_timeout, \"scsi command timeout (10-90s), default 90s. See megasas_reset_timer.\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(MEGASAS_VERSION);\nMODULE_AUTHOR(\"megaraidlinux.pdl@broadcom.com\");\nMODULE_DESCRIPTION(\"Broadcom MegaRAID SAS Driver\");\n\nint megasas_transition_to_ready(struct megasas_instance *instance, int ocr);\nstatic int megasas_get_pd_list(struct megasas_instance *instance);\nstatic int megasas_ld_list_query(struct megasas_instance *instance,\n\t\t\t\t u8 query_type);\nstatic int megasas_issue_init_mfi(struct megasas_instance *instance);\nstatic int megasas_register_aen(struct megasas_instance *instance,\n\t\t\t\tu32 seq_num, u32 class_locale_word);\nstatic void megasas_get_pd_info(struct megasas_instance *instance,\n\t\t\t\tstruct scsi_device *sdev);\n\n/*\n * PCI ID table for all supported controllers\n */\nstatic struct pci_device_id megasas_pci_table[] = {\n\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1064R)},\n\t/* xscale IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078R)},\n\t/* ppc IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078DE)},\n\t/* ppc IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078GEN2)},\n\t/* gen2*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0079GEN2)},\n\t/* gen2*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0073SKINNY)},\n\t/* skinny*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0071SKINNY)},\n\t/* skinny*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VERDE_ZCR)},\n\t/* xscale IOP, vega */\n\t{PCI_DEVICE(PCI_VENDOR_ID_DELL, PCI_DEVICE_ID_DELL_PERC5)},\n\t/* xscale IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FUSION)},\n\t/* Fusion */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_PLASMA)},\n\t/* Plasma */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INVADER)},\n\t/* Invader */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FURY)},\n\t/* Fury */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INTRUDER)},\n\t/* Intruder */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INTRUDER_24)},\n\t/* Intruder 24 port*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CUTLASS_52)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CUTLASS_53)},\n\t/* VENTURA */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VENTURA)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CRUSADER)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_HARPOON)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_TOMCAT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VENTURA_4PORT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CRUSADER_4PORT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E1)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E2)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E5)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E6)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, megasas_pci_table);\n\nstatic int megasas_mgmt_majorno;\nstruct megasas_mgmt_info megasas_mgmt_info;\nstatic struct fasync_struct *megasas_async_queue;\nstatic DEFINE_MUTEX(megasas_async_queue_mutex);\n\nstatic int megasas_poll_wait_aen;\nstatic DECLARE_WAIT_QUEUE_HEAD(megasas_poll_wait);\nstatic u32 support_poll_for_event;\nu32 megasas_dbg_lvl;\nstatic u32 support_device_change;\nstatic bool support_nvme_encapsulation;\n\n/* define lock for aen poll */\nspinlock_t poll_aen_lock;\n\nvoid\nmegasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\t\t     u8 alt_status);\nstatic u32\nmegasas_read_fw_status_reg_gen2(struct megasas_instance *instance);\nstatic int\nmegasas_adp_reset_gen2(struct megasas_instance *instance,\n\t\t       struct megasas_register_set __iomem *reg_set);\nstatic irqreturn_t megasas_isr(int irq, void *devp);\nstatic u32\nmegasas_init_adapter_mfi(struct megasas_instance *instance);\nu32\nmegasas_build_and_issue_cmd(struct megasas_instance *instance,\n\t\t\t    struct scsi_cmnd *scmd);\nstatic void megasas_complete_cmd_dpc(unsigned long instance_addr);\nint\nwait_and_poll(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\tint seconds);\nvoid megasas_fusion_ocr_wq(struct work_struct *work);\nstatic int megasas_get_ld_vf_affiliation(struct megasas_instance *instance,\n\t\t\t\t\t int initial);\nstatic int\nmegasas_set_dma_mask(struct megasas_instance *instance);\nstatic int\nmegasas_alloc_ctrl_mem(struct megasas_instance *instance);\nstatic inline void\nmegasas_free_ctrl_mem(struct megasas_instance *instance);\nstatic inline int\nmegasas_alloc_ctrl_dma_buffers(struct megasas_instance *instance);\nstatic inline void\nmegasas_free_ctrl_dma_buffers(struct megasas_instance *instance);\nstatic inline void\nmegasas_init_ctrl_params(struct megasas_instance *instance);\n\nu32 megasas_readl(struct megasas_instance *instance,\n\t\t  const volatile void __iomem *addr)\n{\n\tu32 i = 0, ret_val;\n\t/*\n\t * Due to a HW errata in Aero controllers, reads to certain\n\t * Fusion registers could intermittently return all zeroes.\n\t * This behavior is transient in nature and subsequent reads will\n\t * return valid value. As a workaround in driver, retry readl for\n\t * upto three times until a non-zero value is read.\n\t */\n\tif (instance->adapter_type == AERO_SERIES) {\n\t\tdo {\n\t\t\tret_val = readl(addr);\n\t\t\ti++;\n\t\t} while (ret_val == 0 && i < 3);\n\t\treturn ret_val;\n\t} else {\n\t\treturn readl(addr);\n\t}\n}\n\n/**\n * megasas_set_dma_settings -\tPopulate DMA address, length and flags for DCMDs\n * @instance:\t\t\tAdapter soft state\n * @dcmd:\t\t\tDCMD frame inside MFI command\n * @dma_addr:\t\t\tDMA address of buffer to be passed to FW\n * @dma_len:\t\t\tLength of DMA buffer to be passed to FW\n * @return:\t\t\tvoid\n */\nvoid megasas_set_dma_settings(struct megasas_instance *instance,\n\t\t\t      struct megasas_dcmd_frame *dcmd,\n\t\t\t      dma_addr_t dma_addr, u32 dma_len)\n{\n\tif (instance->consistent_mask_64bit) {\n\t\tdcmd->sgl.sge64[0].phys_addr = cpu_to_le64(dma_addr);\n\t\tdcmd->sgl.sge64[0].length = cpu_to_le32(dma_len);\n\t\tdcmd->flags = cpu_to_le16(dcmd->flags | MFI_FRAME_SGL64);\n\n\t} else {\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\t\tcpu_to_le32(lower_32_bits(dma_addr));\n\t\tdcmd->sgl.sge32[0].length = cpu_to_le32(dma_len);\n\t\tdcmd->flags = cpu_to_le16(dcmd->flags);\n\t}\n}\n\nvoid\nmegasas_issue_dcmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tinstance->instancet->fire_cmd(instance,\n\t\tcmd->frame_phys_addr, 0, instance->reg_set);\n\treturn;\n}\n\n/**\n * megasas_get_cmd -\tGet a command from the free pool\n * @instance:\t\tAdapter soft state\n *\n * Returns a free command from the pool\n */\nstruct megasas_cmd *megasas_get_cmd(struct megasas_instance\n\t\t\t\t\t\t  *instance)\n{\n\tunsigned long flags;\n\tstruct megasas_cmd *cmd = NULL;\n\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\n\tif (!list_empty(&instance->cmd_pool)) {\n\t\tcmd = list_entry((&instance->cmd_pool)->next,\n\t\t\t\t struct megasas_cmd, list);\n\t\tlist_del_init(&cmd->list);\n\t} else {\n\t\tdev_err(&instance->pdev->dev, \"Command pool empty!\\n\");\n\t}\n\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n\treturn cmd;\n}\n\n/**\n * megasas_return_cmd -\tReturn a cmd to free command pool\n * @instance:\t\tAdapter soft state\n * @cmd:\t\tCommand packet to be returned to free command pool\n */\nvoid\nmegasas_return_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunsigned long flags;\n\tu32 blk_tags;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\t/* This flag is used only for fusion adapter.\n\t * Wait for Interrupt for Polled mode DCMD\n\t */\n\tif (cmd->flags & DRV_DCMD_POLLED_MODE)\n\t\treturn;\n\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\n\tif (fusion) {\n\t\tblk_tags = instance->max_scsi_cmds + cmd->index;\n\t\tcmd_fusion = fusion->cmd_list[blk_tags];\n\t\tmegasas_return_cmd_fusion(instance, cmd_fusion);\n\t}\n\tcmd->scmd = NULL;\n\tcmd->frame_count = 0;\n\tcmd->flags = 0;\n\tmemset(cmd->frame, 0, instance->mfi_frame_size);\n\tcmd->frame->io.context = cpu_to_le32(cmd->index);\n\tif (!fusion && reset_devices)\n\t\tcmd->frame->hdr.cmd = MFI_CMD_INVALID;\n\tlist_add(&cmd->list, (&instance->cmd_pool)->next);\n\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n\n}\n\nstatic const char *\nformat_timestamp(uint32_t timestamp)\n{\n\tstatic char buffer[32];\n\n\tif ((timestamp & 0xff000000) == 0xff000000)\n\t\tsnprintf(buffer, sizeof(buffer), \"boot + %us\", timestamp &\n\t\t0x00ffffff);\n\telse\n\t\tsnprintf(buffer, sizeof(buffer), \"%us\", timestamp);\n\treturn buffer;\n}\n\nstatic const char *\nformat_class(int8_t class)\n{\n\tstatic char buffer[6];\n\n\tswitch (class) {\n\tcase MFI_EVT_CLASS_DEBUG:\n\t\treturn \"debug\";\n\tcase MFI_EVT_CLASS_PROGRESS:\n\t\treturn \"progress\";\n\tcase MFI_EVT_CLASS_INFO:\n\t\treturn \"info\";\n\tcase MFI_EVT_CLASS_WARNING:\n\t\treturn \"WARN\";\n\tcase MFI_EVT_CLASS_CRITICAL:\n\t\treturn \"CRIT\";\n\tcase MFI_EVT_CLASS_FATAL:\n\t\treturn \"FATAL\";\n\tcase MFI_EVT_CLASS_DEAD:\n\t\treturn \"DEAD\";\n\tdefault:\n\t\tsnprintf(buffer, sizeof(buffer), \"%d\", class);\n\t\treturn buffer;\n\t}\n}\n\n/**\n  * megasas_decode_evt: Decode FW AEN event and print critical event\n  * for information.\n  * @instance:\t\t\tAdapter soft state\n  */\nstatic void\nmegasas_decode_evt(struct megasas_instance *instance)\n{\n\tstruct megasas_evt_detail *evt_detail = instance->evt_detail;\n\tunion megasas_evt_class_locale class_locale;\n\tclass_locale.word = le32_to_cpu(evt_detail->cl.word);\n\n\tif (class_locale.members.class >= MFI_EVT_CLASS_CRITICAL)\n\t\tdev_info(&instance->pdev->dev, \"%d (%s/0x%04x/%s) - %s\\n\",\n\t\t\tle32_to_cpu(evt_detail->seq_num),\n\t\t\tformat_timestamp(le32_to_cpu(evt_detail->time_stamp)),\n\t\t\t(class_locale.members.locale),\n\t\t\tformat_class(class_locale.members.class),\n\t\t\tevt_detail->description);\n}\n\n/**\n*\tThe following functions are defined for xscale\n*\t(deviceid : 1064R, PERC5) controllers\n*/\n\n/**\n * megasas_enable_intr_xscale -\tEnables interrupts\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_enable_intr_xscale(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_xscale -Disables interrupt\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_disable_intr_xscale(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0x1f;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_xscale - returns the current FW status value\n * @regs:\t\t\tMFI register set\n */\nstatic u32\nmegasas_read_fw_status_reg_xscale(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_msg_0);\n}\n/**\n * megasas_clear_interrupt_xscale -\tCheck & clear interrupt\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_clear_intr_xscale(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_OB_INTR_STATUS_MASK)\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\tif (status & MFI_XSCALE_OMR0_CHANGE_INTERRUPT)\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\tif (mfiStatus)\n\t\twritel(status, &regs->outbound_intr_status);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n\n/**\n * megasas_fire_cmd_xscale -\tSends command to the FW\n * @frame_phys_addr :\t\tPhysical address of cmd\n * @frame_count :\t\tNumber of frames for the command\n * @regs :\t\t\tMFI register set\n */\nstatic inline void\nmegasas_fire_cmd_xscale(struct megasas_instance *instance,\n\t\tdma_addr_t frame_phys_addr,\n\t\tu32 frame_count,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr >> 3)|(frame_count),\n\t       &(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_adp_reset_xscale -  For controller reset\n * @regs:                              MFI register set\n */\nstatic int\nmegasas_adp_reset_xscale(struct megasas_instance *instance,\n\tstruct megasas_register_set __iomem *regs)\n{\n\tu32 i;\n\tu32 pcidata;\n\n\twritel(MFI_ADP_RESET, &regs->inbound_doorbell);\n\n\tfor (i = 0; i < 3; i++)\n\t\tmsleep(1000); /* sleep for 3 secs */\n\tpcidata  = 0;\n\tpci_read_config_dword(instance->pdev, MFI_1068_PCSR_OFFSET, &pcidata);\n\tdev_notice(&instance->pdev->dev, \"pcidata = %x\\n\", pcidata);\n\tif (pcidata & 0x2) {\n\t\tdev_notice(&instance->pdev->dev, \"mfi 1068 offset read=%x\\n\", pcidata);\n\t\tpcidata &= ~0x2;\n\t\tpci_write_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_PCSR_OFFSET, pcidata);\n\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tmsleep(1000); /* need to wait 2 secs again */\n\n\t\tpcidata  = 0;\n\t\tpci_read_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_FW_HANDSHAKE_OFFSET, &pcidata);\n\t\tdev_notice(&instance->pdev->dev, \"1068 offset handshake read=%x\\n\", pcidata);\n\t\tif ((pcidata & 0xffff0000) == MFI_1068_FW_READY) {\n\t\t\tdev_notice(&instance->pdev->dev, \"1068 offset pcidt=%x\\n\", pcidata);\n\t\t\tpcidata = 0;\n\t\t\tpci_write_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_FW_HANDSHAKE_OFFSET, pcidata);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * megasas_check_reset_xscale -\tFor controller reset check\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_check_reset_xscale(struct megasas_instance *instance,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif ((atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) &&\n\t    (le32_to_cpu(*instance->consumer) ==\n\t\tMEGASAS_ADPRESET_INPROG_SIGN))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_xscale = {\n\n\t.fire_cmd = megasas_fire_cmd_xscale,\n\t.enable_intr = megasas_enable_intr_xscale,\n\t.disable_intr = megasas_disable_intr_xscale,\n\t.clear_intr = megasas_clear_intr_xscale,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_xscale,\n\t.adp_reset = megasas_adp_reset_xscale,\n\t.check_reset = megasas_check_reset_xscale,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n/**\n*\tThis is the end of set of functions & definitions specific\n*\tto xscale (deviceid : 1064R, PERC5) controllers\n*/\n\n/**\n*\tThe following functions are defined for ppc (deviceid : 0x60)\n*\tcontrollers\n*/\n\n/**\n * megasas_enable_intr_ppc -\tEnables interrupts\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_enable_intr_ppc(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\n\n\twritel(~0x80000000, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_ppc -\tDisable interrupt\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_disable_intr_ppc(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_ppc - returns the current FW status value\n * @regs:\t\t\tMFI register set\n */\nstatic u32\nmegasas_read_fw_status_reg_ppc(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n/**\n * megasas_clear_interrupt_ppc -\tCheck & clear interrupt\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_clear_intr_ppc(struct megasas_instance *instance)\n{\n\tu32 status, mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_REPLY_1078_MESSAGE_INTERRUPT)\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\n\tif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT)\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\twritel(status, &regs->outbound_doorbell_clear);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_doorbell_clear);\n\n\treturn mfiStatus;\n}\n\n/**\n * megasas_fire_cmd_ppc -\tSends command to the FW\n * @frame_phys_addr :\t\tPhysical address of cmd\n * @frame_count :\t\tNumber of frames for the command\n * @regs :\t\t\tMFI register set\n */\nstatic inline void\nmegasas_fire_cmd_ppc(struct megasas_instance *instance,\n\t\tdma_addr_t frame_phys_addr,\n\t\tu32 frame_count,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr | (frame_count<<1))|1,\n\t\t\t&(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_check_reset_ppc -\tFor controller reset check\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_check_reset_ppc(struct megasas_instance *instance,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_ppc = {\n\n\t.fire_cmd = megasas_fire_cmd_ppc,\n\t.enable_intr = megasas_enable_intr_ppc,\n\t.disable_intr = megasas_disable_intr_ppc,\n\t.clear_intr = megasas_clear_intr_ppc,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_ppc,\n\t.adp_reset = megasas_adp_reset_xscale,\n\t.check_reset = megasas_check_reset_ppc,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n/**\n * megasas_enable_intr_skinny -\tEnables interrupts\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_enable_intr_skinny(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_intr_mask);\n\n\twritel(~MFI_SKINNY_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_skinny -\tDisables interrupt\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_disable_intr_skinny(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_skinny - returns the current FW status value\n * @regs:\t\t\tMFI register set\n */\nstatic u32\nmegasas_read_fw_status_reg_skinny(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n/**\n * megasas_clear_interrupt_skinny -\tCheck & clear interrupt\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_clear_intr_skinny(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (!(status & MFI_SKINNY_ENABLE_INTERRUPT_MASK)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tif ((megasas_read_fw_status_reg_skinny(instance) & MFI_STATE_MASK) ==\n\t    MFI_STATE_FAULT) {\n\t\tmfiStatus = MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\t} else\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\twritel(status, &regs->outbound_intr_status);\n\n\t/*\n\t * dummy read to flush PCI\n\t */\n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n\n/**\n * megasas_fire_cmd_skinny -\tSends command to the FW\n * @frame_phys_addr :\t\tPhysical address of cmd\n * @frame_count :\t\tNumber of frames for the command\n * @regs :\t\t\tMFI register set\n */\nstatic inline void\nmegasas_fire_cmd_skinny(struct megasas_instance *instance,\n\t\t\tdma_addr_t frame_phys_addr,\n\t\t\tu32 frame_count,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel(upper_32_bits(frame_phys_addr),\n\t       &(regs)->inbound_high_queue_port);\n\twritel((lower_32_bits(frame_phys_addr) | (frame_count<<1))|1,\n\t       &(regs)->inbound_low_queue_port);\n\tmmiowb();\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_check_reset_skinny -\tFor controller reset check\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_check_reset_skinny(struct megasas_instance *instance,\n\t\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_skinny = {\n\n\t.fire_cmd = megasas_fire_cmd_skinny,\n\t.enable_intr = megasas_enable_intr_skinny,\n\t.disable_intr = megasas_disable_intr_skinny,\n\t.clear_intr = megasas_clear_intr_skinny,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_skinny,\n\t.adp_reset = megasas_adp_reset_gen2,\n\t.check_reset = megasas_check_reset_skinny,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n\n/**\n*\tThe following functions are defined for gen2 (deviceid : 0x78 0x79)\n*\tcontrollers\n*/\n\n/**\n * megasas_enable_intr_gen2 -  Enables interrupts\n * @regs:                      MFI register set\n */\nstatic inline void\nmegasas_enable_intr_gen2(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\n\n\t/* write ~0x00000005 (4 & 1) to the intr mask*/\n\twritel(~MFI_GEN2_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_gen2 - Disables interrupt\n * @regs:                      MFI register set\n */\nstatic inline void\nmegasas_disable_intr_gen2(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_gen2 - returns the current FW status value\n * @regs:                      MFI register set\n */\nstatic u32\nmegasas_read_fw_status_reg_gen2(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n/**\n * megasas_clear_interrupt_gen2 -      Check & clear interrupt\n * @regs:                              MFI register set\n */\nstatic int\nmegasas_clear_intr_gen2(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_INTR_FLAG_REPLY_MESSAGE) {\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\t}\n\tif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT) {\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\t}\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\tif (mfiStatus)\n\t\twritel(status, &regs->outbound_doorbell_clear);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n/**\n * megasas_fire_cmd_gen2 -     Sends command to the FW\n * @frame_phys_addr :          Physical address of cmd\n * @frame_count :              Number of frames for the command\n * @regs :                     MFI register set\n */\nstatic inline void\nmegasas_fire_cmd_gen2(struct megasas_instance *instance,\n\t\t\tdma_addr_t frame_phys_addr,\n\t\t\tu32 frame_count,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr | (frame_count<<1))|1,\n\t\t\t&(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_adp_reset_gen2 -\tFor controller reset\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_adp_reset_gen2(struct megasas_instance *instance,\n\t\t\tstruct megasas_register_set __iomem *reg_set)\n{\n\tu32 retry = 0 ;\n\tu32 HostDiag;\n\tu32 __iomem *seq_offset = &reg_set->seq_offset;\n\tu32 __iomem *hostdiag_offset = &reg_set->host_diag;\n\n\tif (instance->instancet == &megasas_instance_template_skinny) {\n\t\tseq_offset = &reg_set->fusion_seq_offset;\n\t\thostdiag_offset = &reg_set->fusion_host_diag;\n\t}\n\n\twritel(0, seq_offset);\n\twritel(4, seq_offset);\n\twritel(0xb, seq_offset);\n\twritel(2, seq_offset);\n\twritel(7, seq_offset);\n\twritel(0xd, seq_offset);\n\n\tmsleep(1000);\n\n\tHostDiag = (u32)readl(hostdiag_offset);\n\n\twhile (!(HostDiag & DIAG_WRITE_ENABLE)) {\n\t\tmsleep(100);\n\t\tHostDiag = (u32)readl(hostdiag_offset);\n\t\tdev_notice(&instance->pdev->dev, \"RESETGEN2: retry=%x, hostdiag=%x\\n\",\n\t\t\t\t\tretry, HostDiag);\n\n\t\tif (retry++ >= 100)\n\t\t\treturn 1;\n\n\t}\n\n\tdev_notice(&instance->pdev->dev, \"ADP_RESET_GEN2: HostDiag=%x\\n\", HostDiag);\n\n\twritel((HostDiag | DIAG_RESET_ADAPTER), hostdiag_offset);\n\n\tssleep(10);\n\n\tHostDiag = (u32)readl(hostdiag_offset);\n\twhile (HostDiag & DIAG_RESET_ADAPTER) {\n\t\tmsleep(100);\n\t\tHostDiag = (u32)readl(hostdiag_offset);\n\t\tdev_notice(&instance->pdev->dev, \"RESET_GEN2: retry=%x, hostdiag=%x\\n\",\n\t\t\t\tretry, HostDiag);\n\n\t\tif (retry++ >= 1000)\n\t\t\treturn 1;\n\n\t}\n\treturn 0;\n}\n\n/**\n * megasas_check_reset_gen2 -\tFor controller reset check\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_check_reset_gen2(struct megasas_instance *instance,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_gen2 = {\n\n\t.fire_cmd = megasas_fire_cmd_gen2,\n\t.enable_intr = megasas_enable_intr_gen2,\n\t.disable_intr = megasas_disable_intr_gen2,\n\t.clear_intr = megasas_clear_intr_gen2,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_gen2,\n\t.adp_reset = megasas_adp_reset_gen2,\n\t.check_reset = megasas_check_reset_gen2,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n/**\n*\tThis is the end of set of functions & definitions\n*       specific to gen2 (deviceid : 0x78, 0x79) controllers\n*/\n\n/*\n * Template added for TB (Fusion)\n */\nextern struct megasas_instance_template megasas_instance_template_fusion;\n\n/**\n * megasas_issue_polled -\tIssues a polling command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand packet to be issued\n *\n * For polling, MFI requires the cmd_status to be set to MFI_STAT_INVALID_STATUS before posting.\n */\nint\nmegasas_issue_polled(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tstruct megasas_header *frame_hdr = &cmd->frame->hdr;\n\n\tframe_hdr->cmd_status = MFI_STAT_INVALID_STATUS;\n\tframe_hdr->flags |= cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE);\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_NOT_FIRED;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\treturn wait_and_poll(instance, cmd, instance->requestorId ?\n\t\t\tMEGASAS_ROUTINE_WAIT_TIME_VF : MFI_IO_TIMEOUT_SECS);\n}\n\n/**\n * megasas_issue_blocked_cmd -\tSynchronous wrapper around regular FW cmds\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand to be issued\n * @timeout:\t\t\tTimeout in seconds\n *\n * This function waits on an event for the command to be returned from ISR.\n * Max wait time is MEGASAS_INTERNAL_CMD_WAIT_TIME secs\n * Used to issue ioctl commands.\n */\nint\nmegasas_issue_blocked_cmd(struct megasas_instance *instance,\n\t\t\t  struct megasas_cmd *cmd, int timeout)\n{\n\tint ret = 0;\n\tcmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_NOT_FIRED;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\tif (timeout) {\n\t\tret = wait_event_timeout(instance->int_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS, timeout * HZ);\n\t\tif (!ret) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d DCMD Timed out\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\treturn DCMD_TIMEOUT;\n\t\t}\n\t} else\n\t\twait_event(instance->int_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS);\n\n\treturn (cmd->cmd_status_drv == MFI_STAT_OK) ?\n\t\tDCMD_SUCCESS : DCMD_FAILED;\n}\n\n/**\n * megasas_issue_blocked_abort_cmd -\tAborts previously issued cmd\n * @instance:\t\t\t\tAdapter soft state\n * @cmd_to_abort:\t\t\tPreviously issued cmd to be aborted\n * @timeout:\t\t\t\tTimeout in seconds\n *\n * MFI firmware can abort previously issued AEN comamnd (automatic event\n * notification). The megasas_issue_blocked_abort_cmd() issues such abort\n * cmd and waits for return status.\n * Max wait time is MEGASAS_INTERNAL_CMD_WAIT_TIME secs\n */\nstatic int\nmegasas_issue_blocked_abort_cmd(struct megasas_instance *instance,\n\t\t\t\tstruct megasas_cmd *cmd_to_abort, int timeout)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_abort_frame *abort_fr;\n\tint ret = 0;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn -1;\n\n\tabort_fr = &cmd->frame->abort;\n\n\t/*\n\t * Prepare and issue the abort frame\n\t */\n\tabort_fr->cmd = MFI_CMD_ABORT;\n\tabort_fr->cmd_status = MFI_STAT_INVALID_STATUS;\n\tabort_fr->flags = cpu_to_le16(0);\n\tabort_fr->abort_context = cpu_to_le32(cmd_to_abort->index);\n\tabort_fr->abort_mfi_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(cmd_to_abort->frame_phys_addr));\n\tabort_fr->abort_mfi_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(cmd_to_abort->frame_phys_addr));\n\n\tcmd->sync_cmd = 1;\n\tcmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_NOT_FIRED;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\tif (timeout) {\n\t\tret = wait_event_timeout(instance->abort_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS, timeout * HZ);\n\t\tif (!ret) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d Abort Timed out\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\treturn DCMD_TIMEOUT;\n\t\t}\n\t} else\n\t\twait_event(instance->abort_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS);\n\n\tcmd->sync_cmd = 0;\n\n\tmegasas_return_cmd(instance, cmd);\n\treturn (cmd->cmd_status_drv == MFI_STAT_OK) ?\n\t\tDCMD_SUCCESS : DCMD_FAILED;\n}\n\n/**\n * megasas_make_sgl32 -\tPrepares 32-bit SGL\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command from the mid-layer\n * @mfi_sgl:\t\tSGL to be filled in\n *\n * If successful, this function returns the number of SG elements. Otherwise,\n * it returnes -1.\n */\nstatic int\nmegasas_make_sgl32(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\tBUG_ON(sge_count < 0);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge32[i].length = cpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge32[i].phys_addr = cpu_to_le32(sg_dma_address(os_sgl));\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n/**\n * megasas_make_sgl64 -\tPrepares 64-bit SGL\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command from the mid-layer\n * @mfi_sgl:\t\tSGL to be filled in\n *\n * If successful, this function returns the number of SG elements. Otherwise,\n * it returnes -1.\n */\nstatic int\nmegasas_make_sgl64(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\tBUG_ON(sge_count < 0);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge64[i].length = cpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge64[i].phys_addr = cpu_to_le64(sg_dma_address(os_sgl));\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n/**\n * megasas_make_sgl_skinny - Prepares IEEE SGL\n * @instance:           Adapter soft state\n * @scp:                SCSI command from the mid-layer\n * @mfi_sgl:            SGL to be filled in\n *\n * If successful, this function returns the number of SG elements. Otherwise,\n * it returnes -1.\n */\nstatic int\nmegasas_make_sgl_skinny(struct megasas_instance *instance,\n\t\tstruct scsi_cmnd *scp, union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge_skinny[i].length =\n\t\t\t\tcpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge_skinny[i].phys_addr =\n\t\t\t\tcpu_to_le64(sg_dma_address(os_sgl));\n\t\t\tmfi_sgl->sge_skinny[i].flag = cpu_to_le32(0);\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n /**\n * megasas_get_frame_count - Computes the number of frames\n * @frame_type\t\t: type of frame- io or pthru frame\n * @sge_count\t\t: number of sg elements\n *\n * Returns the number of frames required for numnber of sge's (sge_count)\n */\n\nstatic u32 megasas_get_frame_count(struct megasas_instance *instance,\n\t\t\tu8 sge_count, u8 frame_type)\n{\n\tint num_cnt;\n\tint sge_bytes;\n\tu32 sge_sz;\n\tu32 frame_count = 0;\n\n\tsge_sz = (IS_DMA64) ? sizeof(struct megasas_sge64) :\n\t    sizeof(struct megasas_sge32);\n\n\tif (instance->flag_ieee) {\n\t\tsge_sz = sizeof(struct megasas_sge_skinny);\n\t}\n\n\t/*\n\t * Main frame can contain 2 SGEs for 64-bit SGLs and\n\t * 3 SGEs for 32-bit SGLs for ldio &\n\t * 1 SGEs for 64-bit SGLs and\n\t * 2 SGEs for 32-bit SGLs for pthru frame\n\t */\n\tif (unlikely(frame_type == PTHRU_FRAME)) {\n\t\tif (instance->flag_ieee == 1) {\n\t\t\tnum_cnt = sge_count - 1;\n\t\t} else if (IS_DMA64)\n\t\t\tnum_cnt = sge_count - 1;\n\t\telse\n\t\t\tnum_cnt = sge_count - 2;\n\t} else {\n\t\tif (instance->flag_ieee == 1) {\n\t\t\tnum_cnt = sge_count - 1;\n\t\t} else if (IS_DMA64)\n\t\t\tnum_cnt = sge_count - 2;\n\t\telse\n\t\t\tnum_cnt = sge_count - 3;\n\t}\n\n\tif (num_cnt > 0) {\n\t\tsge_bytes = sge_sz * num_cnt;\n\n\t\tframe_count = (sge_bytes / MEGAMFI_FRAME_SIZE) +\n\t\t    ((sge_bytes % MEGAMFI_FRAME_SIZE) ? 1 : 0) ;\n\t}\n\t/* Main frame */\n\tframe_count += 1;\n\n\tif (frame_count > 7)\n\t\tframe_count = 8;\n\treturn frame_count;\n}\n\n/**\n * megasas_build_dcdb -\tPrepares a direct cdb (DCDB) command\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command\n * @cmd:\t\tCommand to be prepared in\n *\n * This function prepares CDB commands. These are typcially pass-through\n * commands to the devices.\n */\nstatic int\nmegasas_build_dcdb(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   struct megasas_cmd *cmd)\n{\n\tu32 is_logical;\n\tu32 device_id;\n\tu16 flags = 0;\n\tstruct megasas_pthru_frame *pthru;\n\n\tis_logical = MEGASAS_IS_LOGICAL(scp->device);\n\tdevice_id = MEGASAS_DEV_INDEX(scp);\n\tpthru = (struct megasas_pthru_frame *)cmd->frame;\n\n\tif (scp->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags = MFI_FRAME_DIR_WRITE;\n\telse if (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\tflags = MFI_FRAME_DIR_READ;\n\telse if (scp->sc_data_direction == DMA_NONE)\n\t\tflags = MFI_FRAME_DIR_NONE;\n\n\tif (instance->flag_ieee == 1) {\n\t\tflags |= MFI_FRAME_IEEE;\n\t}\n\n\t/*\n\t * Prepare the DCDB frame\n\t */\n\tpthru->cmd = (is_logical) ? MFI_CMD_LD_SCSI_IO : MFI_CMD_PD_SCSI_IO;\n\tpthru->cmd_status = 0x0;\n\tpthru->scsi_status = 0x0;\n\tpthru->target_id = device_id;\n\tpthru->lun = scp->device->lun;\n\tpthru->cdb_len = scp->cmd_len;\n\tpthru->timeout = 0;\n\tpthru->pad_0 = 0;\n\tpthru->flags = cpu_to_le16(flags);\n\tpthru->data_xfer_len = cpu_to_le32(scsi_bufflen(scp));\n\n\tmemcpy(pthru->cdb, scp->cmnd, scp->cmd_len);\n\n\t/*\n\t * If the command is for the tape device, set the\n\t * pthru timeout to the os layer timeout value.\n\t */\n\tif (scp->device->type == TYPE_TAPE) {\n\t\tif ((scp->request->timeout / HZ) > 0xFFFF)\n\t\t\tpthru->timeout = cpu_to_le16(0xFFFF);\n\t\telse\n\t\t\tpthru->timeout = cpu_to_le16(scp->request->timeout / HZ);\n\t}\n\n\t/*\n\t * Construct SGL\n\t */\n\tif (instance->flag_ieee == 1) {\n\t\tpthru->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tpthru->sge_count = megasas_make_sgl_skinny(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\t} else if (IS_DMA64) {\n\t\tpthru->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tpthru->sge_count = megasas_make_sgl64(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\t} else\n\t\tpthru->sge_count = megasas_make_sgl32(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\n\tif (pthru->sge_count > instance->max_num_sge) {\n\t\tdev_err(&instance->pdev->dev, \"DCDB too many SGE NUM=%x\\n\",\n\t\t\tpthru->sge_count);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Sense info specific\n\t */\n\tpthru->sense_len = SCSI_SENSE_BUFFERSIZE;\n\tpthru->sense_buf_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(cmd->sense_phys_addr));\n\tpthru->sense_buf_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(cmd->sense_phys_addr));\n\n\t/*\n\t * Compute the total number of frames this command consumes. FW uses\n\t * this number to pull sufficient number of frames from host memory.\n\t */\n\tcmd->frame_count = megasas_get_frame_count(instance, pthru->sge_count,\n\t\t\t\t\t\t\tPTHRU_FRAME);\n\n\treturn cmd->frame_count;\n}\n\n/**\n * megasas_build_ldio -\tPrepares IOs to logical devices\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command\n * @cmd:\t\tCommand to be prepared\n *\n * Frames (and accompanying SGLs) for regular SCSI IOs use this function.\n */\nstatic int\nmegasas_build_ldio(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   struct megasas_cmd *cmd)\n{\n\tu32 device_id;\n\tu8 sc = scp->cmnd[0];\n\tu16 flags = 0;\n\tstruct megasas_io_frame *ldio;\n\n\tdevice_id = MEGASAS_DEV_INDEX(scp);\n\tldio = (struct megasas_io_frame *)cmd->frame;\n\n\tif (scp->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags = MFI_FRAME_DIR_WRITE;\n\telse if (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\tflags = MFI_FRAME_DIR_READ;\n\n\tif (instance->flag_ieee == 1) {\n\t\tflags |= MFI_FRAME_IEEE;\n\t}\n\n\t/*\n\t * Prepare the Logical IO frame: 2nd bit is zero for all read cmds\n\t */\n\tldio->cmd = (sc & 0x02) ? MFI_CMD_LD_WRITE : MFI_CMD_LD_READ;\n\tldio->cmd_status = 0x0;\n\tldio->scsi_status = 0x0;\n\tldio->target_id = device_id;\n\tldio->timeout = 0;\n\tldio->reserved_0 = 0;\n\tldio->pad_0 = 0;\n\tldio->flags = cpu_to_le16(flags);\n\tldio->start_lba_hi = 0;\n\tldio->access_byte = (scp->cmd_len != 6) ? scp->cmnd[1] : 0;\n\n\t/*\n\t * 6-byte READ(0x08) or WRITE(0x0A) cdb\n\t */\n\tif (scp->cmd_len == 6) {\n\t\tldio->lba_count = cpu_to_le32((u32) scp->cmnd[4]);\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[1] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[2] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[3]);\n\n\t\tldio->start_lba_lo &= cpu_to_le32(0x1FFFFF);\n\t}\n\n\t/*\n\t * 10-byte READ(0x28) or WRITE(0x2A) cdb\n\t */\n\telse if (scp->cmd_len == 10) {\n\t\tldio->lba_count = cpu_to_le32((u32) scp->cmnd[8] |\n\t\t\t\t\t      ((u32) scp->cmnd[7] << 8));\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\t}\n\n\t/*\n\t * 12-byte READ(0xA8) or WRITE(0xAA) cdb\n\t */\n\telse if (scp->cmd_len == 12) {\n\t\tldio->lba_count = cpu_to_le32(((u32) scp->cmnd[6] << 24) |\n\t\t\t\t\t      ((u32) scp->cmnd[7] << 16) |\n\t\t\t\t\t      ((u32) scp->cmnd[8] << 8) |\n\t\t\t\t\t      (u32) scp->cmnd[9]);\n\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\t}\n\n\t/*\n\t * 16-byte READ(0x88) or WRITE(0x8A) cdb\n\t */\n\telse if (scp->cmd_len == 16) {\n\t\tldio->lba_count = cpu_to_le32(((u32) scp->cmnd[10] << 24) |\n\t\t\t\t\t      ((u32) scp->cmnd[11] << 16) |\n\t\t\t\t\t      ((u32) scp->cmnd[12] << 8) |\n\t\t\t\t\t      (u32) scp->cmnd[13]);\n\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[6] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[7] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[8] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[9]);\n\n\t\tldio->start_lba_hi = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\n\t}\n\n\t/*\n\t * Construct SGL\n\t */\n\tif (instance->flag_ieee) {\n\t\tldio->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tldio->sge_count = megasas_make_sgl_skinny(instance, scp,\n\t\t\t\t\t      &ldio->sgl);\n\t} else if (IS_DMA64) {\n\t\tldio->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tldio->sge_count = megasas_make_sgl64(instance, scp, &ldio->sgl);\n\t} else\n\t\tldio->sge_count = megasas_make_sgl32(instance, scp, &ldio->sgl);\n\n\tif (ldio->sge_count > instance->max_num_sge) {\n\t\tdev_err(&instance->pdev->dev, \"build_ld_io: sge_count = %x\\n\",\n\t\t\tldio->sge_count);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Sense info specific\n\t */\n\tldio->sense_len = SCSI_SENSE_BUFFERSIZE;\n\tldio->sense_buf_phys_addr_hi = 0;\n\tldio->sense_buf_phys_addr_lo = cpu_to_le32(cmd->sense_phys_addr);\n\n\t/*\n\t * Compute the total number of frames this command consumes. FW uses\n\t * this number to pull sufficient number of frames from host memory.\n\t */\n\tcmd->frame_count = megasas_get_frame_count(instance,\n\t\t\tldio->sge_count, IO_FRAME);\n\n\treturn cmd->frame_count;\n}\n\n/**\n * megasas_cmd_type -\t\tChecks if the cmd is for logical drive/sysPD\n *\t\t\t\tand whether it's RW or non RW\n * @scmd:\t\t\tSCSI command\n *\n */\ninline int megasas_cmd_type(struct scsi_cmnd *cmd)\n{\n\tint ret;\n\n\tswitch (cmd->cmnd[0]) {\n\tcase READ_10:\n\tcase WRITE_10:\n\tcase READ_12:\n\tcase WRITE_12:\n\tcase READ_6:\n\tcase WRITE_6:\n\tcase READ_16:\n\tcase WRITE_16:\n\t\tret = (MEGASAS_IS_LOGICAL(cmd->device)) ?\n\t\t\tREAD_WRITE_LDIO : READ_WRITE_SYSPDIO;\n\t\tbreak;\n\tdefault:\n\t\tret = (MEGASAS_IS_LOGICAL(cmd->device)) ?\n\t\t\tNON_READ_WRITE_LDIO : NON_READ_WRITE_SYSPDIO;\n\t}\n\treturn ret;\n}\n\n /**\n * megasas_dump_pending_frames -\tDumps the frame address of all pending cmds\n *\t\t\t\t\tin FW\n * @instance:\t\t\t\tAdapter soft state\n */\nstatic inline void\nmegasas_dump_pending_frames(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tint i,n;\n\tunion megasas_sgl *mfi_sgl;\n\tstruct megasas_io_frame *ldio;\n\tstruct megasas_pthru_frame *pthru;\n\tu32 sgcount;\n\tu16 max_cmd = instance->max_fw_cmds;\n\n\tdev_err(&instance->pdev->dev, \"[%d]: Dumping Frame Phys Address of all pending cmds in FW\\n\",instance->host->host_no);\n\tdev_err(&instance->pdev->dev, \"[%d]: Total OS Pending cmds : %d\\n\",instance->host->host_no,atomic_read(&instance->fw_outstanding));\n\tif (IS_DMA64)\n\t\tdev_err(&instance->pdev->dev, \"[%d]: 64 bit SGLs were sent to FW\\n\",instance->host->host_no);\n\telse\n\t\tdev_err(&instance->pdev->dev, \"[%d]: 32 bit SGLs were sent to FW\\n\",instance->host->host_no);\n\n\tdev_err(&instance->pdev->dev, \"[%d]: Pending OS cmds in FW : \\n\",instance->host->host_no);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tif (!cmd->scmd)\n\t\t\tcontinue;\n\t\tdev_err(&instance->pdev->dev, \"[%d]: Frame addr :0x%08lx : \",instance->host->host_no,(unsigned long)cmd->frame_phys_addr);\n\t\tif (megasas_cmd_type(cmd->scmd) == READ_WRITE_LDIO) {\n\t\t\tldio = (struct megasas_io_frame *)cmd->frame;\n\t\t\tmfi_sgl = &ldio->sgl;\n\t\t\tsgcount = ldio->sge_count;\n\t\t\tdev_err(&instance->pdev->dev, \"[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x,\"\n\t\t\t\" lba lo : 0x%x, lba_hi : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\\n\",\n\t\t\tinstance->host->host_no, cmd->frame_count, ldio->cmd, ldio->target_id,\n\t\t\tle32_to_cpu(ldio->start_lba_lo), le32_to_cpu(ldio->start_lba_hi),\n\t\t\tle32_to_cpu(ldio->sense_buf_phys_addr_lo), sgcount);\n\t\t} else {\n\t\t\tpthru = (struct megasas_pthru_frame *) cmd->frame;\n\t\t\tmfi_sgl = &pthru->sgl;\n\t\t\tsgcount = pthru->sge_count;\n\t\t\tdev_err(&instance->pdev->dev, \"[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, \"\n\t\t\t\"lun : 0x%x, cdb_len : 0x%x, data xfer len : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\\n\",\n\t\t\tinstance->host->host_no, cmd->frame_count, pthru->cmd, pthru->target_id,\n\t\t\tpthru->lun, pthru->cdb_len, le32_to_cpu(pthru->data_xfer_len),\n\t\t\tle32_to_cpu(pthru->sense_buf_phys_addr_lo), sgcount);\n\t\t}\n\t\tif (megasas_dbg_lvl & MEGASAS_DBG_LVL) {\n\t\t\tfor (n = 0; n < sgcount; n++) {\n\t\t\t\tif (IS_DMA64)\n\t\t\t\t\tdev_err(&instance->pdev->dev, \"sgl len : 0x%x, sgl addr : 0x%llx\\n\",\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge64[n].length),\n\t\t\t\t\t\tle64_to_cpu(mfi_sgl->sge64[n].phys_addr));\n\t\t\t\telse\n\t\t\t\t\tdev_err(&instance->pdev->dev, \"sgl len : 0x%x, sgl addr : 0x%x\\n\",\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge32[n].length),\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge32[n].phys_addr));\n\t\t\t}\n\t\t}\n\t} /*for max_cmd*/\n\tdev_err(&instance->pdev->dev, \"[%d]: Pending Internal cmds in FW : \\n\",instance->host->host_no);\n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tif (cmd->sync_cmd == 1)\n\t\t\tdev_err(&instance->pdev->dev, \"0x%08lx : \", (unsigned long)cmd->frame_phys_addr);\n\t}\n\tdev_err(&instance->pdev->dev, \"[%d]: Dumping Done\\n\\n\",instance->host->host_no);\n}\n\nu32\nmegasas_build_and_issue_cmd(struct megasas_instance *instance,\n\t\t\t    struct scsi_cmnd *scmd)\n{\n\tstruct megasas_cmd *cmd;\n\tu32 frame_count;\n\n\tcmd = megasas_get_cmd(instance);\n\tif (!cmd)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t/*\n\t * Logical drive command\n\t */\n\tif (megasas_cmd_type(scmd) == READ_WRITE_LDIO)\n\t\tframe_count = megasas_build_ldio(instance, scmd, cmd);\n\telse\n\t\tframe_count = megasas_build_dcdb(instance, scmd, cmd);\n\n\tif (!frame_count)\n\t\tgoto out_return_cmd;\n\n\tcmd->scmd = scmd;\n\tscmd->SCp.ptr = (char *)cmd;\n\n\t/*\n\t * Issue the command to the FW\n\t */\n\tatomic_inc(&instance->fw_outstanding);\n\n\tinstance->instancet->fire_cmd(instance, cmd->frame_phys_addr,\n\t\t\t\tcmd->frame_count-1, instance->reg_set);\n\n\treturn 0;\nout_return_cmd:\n\tmegasas_return_cmd(instance, cmd);\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\n\n/**\n * megasas_queue_command -\tQueue entry point\n * @scmd:\t\t\tSCSI command to be queued\n * @done:\t\t\tCallback entry point\n */\nstatic int\nmegasas_queue_command(struct Scsi_Host *shost, struct scsi_cmnd *scmd)\n{\n\tstruct megasas_instance *instance;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = (struct megasas_instance *)\n\t    scmd->device->host->hostdata;\n\n\tif (instance->unload == 1) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tif (instance->issuepend_done == 0)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\n\t/* Check for an mpio path and adjust behavior */\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tif (megasas_check_mpio_paths(instance, scmd) ==\n\t\t    (DID_REQUEUE << 16)) {\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t\t} else {\n\t\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\t\tscmd->scsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tmr_device_priv_data = scmd->device->hostdata;\n\tif (!mr_device_priv_data) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tif (mr_device_priv_data->tm_busy)\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\n\n\tscmd->result = 0;\n\n\tif (MEGASAS_IS_LOGICAL(scmd->device) &&\n\t    (scmd->device->id >= instance->fw_supported_vd_count ||\n\t\tscmd->device->lun)) {\n\t\tscmd->result = DID_BAD_TARGET << 16;\n\t\tgoto out_done;\n\t}\n\n\tif ((scmd->cmnd[0] == SYNCHRONIZE_CACHE) &&\n\t    MEGASAS_IS_LOGICAL(scmd->device) &&\n\t    (!instance->fw_sync_cache_support)) {\n\t\tscmd->result = DID_OK << 16;\n\t\tgoto out_done;\n\t}\n\n\treturn instance->instancet->build_and_issue_cmd(instance, scmd);\n\n out_done:\n\tscmd->scsi_done(scmd);\n\treturn 0;\n}\n\nstatic struct megasas_instance *megasas_lookup_instance(u16 host_no)\n{\n\tint i;\n\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\n\t\tif ((megasas_mgmt_info.instance[i]) &&\n\t\t    (megasas_mgmt_info.instance[i]->host->host_no == host_no))\n\t\t\treturn megasas_mgmt_info.instance[i];\n\t}\n\n\treturn NULL;\n}\n\n/*\n* megasas_set_dynamic_target_properties -\n* Device property set by driver may not be static and it is required to be\n* updated after OCR\n*\n* set tm_capable.\n* set dma alignment (only for eedp protection enable vd).\n*\n* @sdev: OS provided scsi device\n*\n* Returns void\n*/\nvoid megasas_set_dynamic_target_properties(struct scsi_device *sdev,\n\t\t\t\t\t   bool is_target_prop)\n{\n\tu16 pd_index = 0, ld;\n\tu32 device_id;\n\tstruct megasas_instance *instance;\n\tstruct fusion_context *fusion;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tstruct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;\n\tstruct MR_LD_RAID *raid;\n\tstruct MR_DRV_RAID_MAP_ALL *local_map_ptr;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tfusion = instance->ctrl_context;\n\tmr_device_priv_data = sdev->hostdata;\n\n\tif (!fusion || !mr_device_priv_data)\n\t\treturn;\n\n\tif (MEGASAS_IS_LOGICAL(sdev)) {\n\t\tdevice_id = ((sdev->channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL)\n\t\t\t\t\t+ sdev->id;\n\t\tlocal_map_ptr = fusion->ld_drv_map[(instance->map_id & 1)];\n\t\tld = MR_TargetIdToLdGet(device_id, local_map_ptr);\n\t\tif (ld >= instance->fw_supported_vd_count)\n\t\t\treturn;\n\t\traid = MR_LdRaidGet(ld, local_map_ptr);\n\n\t\tif (raid->capability.ldPiMode == MR_PROT_INFO_TYPE_CONTROLLER)\n\t\tblk_queue_update_dma_alignment(sdev->request_queue, 0x7);\n\n\t\tmr_device_priv_data->is_tm_capable =\n\t\t\traid->capability.tmCapable;\n\t} else if (instance->use_seqnum_jbod_fp) {\n\t\tpd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\tsdev->id;\n\t\tpd_sync = (void *)fusion->pd_seq_sync\n\t\t\t\t[(instance->pd_seq_map_id - 1) & 1];\n\t\tmr_device_priv_data->is_tm_capable =\n\t\t\tpd_sync->seq[pd_index].capability.tmCapable;\n\t}\n\n\tif (is_target_prop && instance->tgt_prop->reset_tmo) {\n\t\t/*\n\t\t * If FW provides a target reset timeout value, driver will use\n\t\t * it. If not set, fallback to default values.\n\t\t */\n\t\tmr_device_priv_data->target_reset_tmo =\n\t\t\tmin_t(u8, instance->max_reset_tmo,\n\t\t\t      instance->tgt_prop->reset_tmo);\n\t\tmr_device_priv_data->task_abort_tmo = instance->task_abort_tmo;\n\t} else {\n\t\tmr_device_priv_data->target_reset_tmo =\n\t\t\t\t\t\tMEGASAS_DEFAULT_TM_TIMEOUT;\n\t\tmr_device_priv_data->task_abort_tmo =\n\t\t\t\t\t\tMEGASAS_DEFAULT_TM_TIMEOUT;\n\t}\n}\n\n/*\n * megasas_set_nvme_device_properties -\n * set nomerges=2\n * set virtual page boundary = 4K (current mr_nvme_pg_size is 4K).\n * set maximum io transfer = MDTS of NVME device provided by MR firmware.\n *\n * MR firmware provides value in KB. Caller of this function converts\n * kb into bytes.\n *\n * e.a MDTS=5 means 2^5 * nvme page size. (In case of 4K page size,\n * MR firmware provides value 128 as (32 * 4K) = 128K.\n *\n * @sdev:\t\t\t\tscsi device\n * @max_io_size:\t\t\t\tmaximum io transfer size\n *\n */\nstatic inline void\nmegasas_set_nvme_device_properties(struct scsi_device *sdev, u32 max_io_size)\n{\n\tstruct megasas_instance *instance;\n\tu32 mr_nvme_pg_size;\n\n\tinstance = (struct megasas_instance *)sdev->host->hostdata;\n\tmr_nvme_pg_size = max_t(u32, instance->nvme_page_size,\n\t\t\t\tMR_DEFAULT_NVME_PAGE_SIZE);\n\n\tblk_queue_max_hw_sectors(sdev->request_queue, (max_io_size / 512));\n\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, sdev->request_queue);\n\tblk_queue_virt_boundary(sdev->request_queue, mr_nvme_pg_size - 1);\n}\n\n\n/*\n * megasas_set_static_target_properties -\n * Device property set by driver are static and it is not required to be\n * updated after OCR.\n *\n * set io timeout\n * set device queue depth\n * set nvme device properties. see - megasas_set_nvme_device_properties\n *\n * @sdev:\t\t\t\tscsi device\n * @is_target_prop\t\t\ttrue, if fw provided target properties.\n */\nstatic void megasas_set_static_target_properties(struct scsi_device *sdev,\n\t\t\t\t\t\t bool is_target_prop)\n{\n\tu16\ttarget_index = 0;\n\tu8 interface_type;\n\tu32 device_qd = MEGASAS_DEFAULT_CMD_PER_LUN;\n\tu32 max_io_size_kb = MR_DEFAULT_NVME_MDTS_KB;\n\tu32 tgt_device_qd;\n\tstruct megasas_instance *instance;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tmr_device_priv_data = sdev->hostdata;\n\tinterface_type  = mr_device_priv_data->interface_type;\n\n\t/*\n\t * The RAID firmware may require extended timeouts.\n\t */\n\tblk_queue_rq_timeout(sdev->request_queue, scmd_timeout * HZ);\n\n\ttarget_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) + sdev->id;\n\n\tswitch (interface_type) {\n\tcase SAS_PD:\n\t\tdevice_qd = MEGASAS_SAS_QD;\n\t\tbreak;\n\tcase SATA_PD:\n\t\tdevice_qd = MEGASAS_SATA_QD;\n\t\tbreak;\n\tcase NVME_PD:\n\t\tdevice_qd = MEGASAS_NVME_QD;\n\t\tbreak;\n\t}\n\n\tif (is_target_prop) {\n\t\ttgt_device_qd = le32_to_cpu(instance->tgt_prop->device_qdepth);\n\t\tif (tgt_device_qd &&\n\t\t    (tgt_device_qd <= instance->host->can_queue))\n\t\t\tdevice_qd = tgt_device_qd;\n\n\t\t/* max_io_size_kb will be set to non zero for\n\t\t * nvme based vd and syspd.\n\t\t */\n\t\tmax_io_size_kb = le32_to_cpu(instance->tgt_prop->max_io_size_kb);\n\t}\n\n\tif (instance->nvme_page_size && max_io_size_kb)\n\t\tmegasas_set_nvme_device_properties(sdev, (max_io_size_kb << 10));\n\n\tscsi_change_queue_depth(sdev, device_qd);\n\n}\n\n\nstatic int megasas_slave_configure(struct scsi_device *sdev)\n{\n\tu16 pd_index = 0;\n\tstruct megasas_instance *instance;\n\tint ret_target_prop = DCMD_FAILED;\n\tbool is_target_prop = false;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tif (instance->pd_list_not_supported) {\n\t\tif (!MEGASAS_IS_LOGICAL(sdev) && sdev->type == TYPE_DISK) {\n\t\t\tpd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\t\tsdev->id;\n\t\t\tif (instance->pd_list[pd_index].driveState !=\n\t\t\t\tMR_PD_STATE_SYSTEM)\n\t\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\t/* Send DCMD to Firmware and cache the information */\n\tif ((instance->pd_info) && !MEGASAS_IS_LOGICAL(sdev))\n\t\tmegasas_get_pd_info(instance, sdev);\n\n\t/* Some ventura firmware may not have instance->nvme_page_size set.\n\t * Do not send MR_DCMD_DRV_GET_TARGET_PROP\n\t */\n\tif ((instance->tgt_prop) && (instance->nvme_page_size))\n\t\tret_target_prop = megasas_get_target_prop(instance, sdev);\n\n\tis_target_prop = (ret_target_prop == DCMD_SUCCESS) ? true : false;\n\tmegasas_set_static_target_properties(sdev, is_target_prop);\n\n\t/* This sdev property may change post OCR */\n\tmegasas_set_dynamic_target_properties(sdev, is_target_prop);\n\n\tmutex_unlock(&instance->reset_mutex);\n\n\treturn 0;\n}\n\nstatic int megasas_slave_alloc(struct scsi_device *sdev)\n{\n\tu16 pd_index = 0;\n\tstruct megasas_instance *instance ;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tif (!MEGASAS_IS_LOGICAL(sdev)) {\n\t\t/*\n\t\t * Open the OS scan to the SYSTEM PD\n\t\t */\n\t\tpd_index =\n\t\t\t(sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\tsdev->id;\n\t\tif ((instance->pd_list_not_supported ||\n\t\t\tinstance->pd_list[pd_index].driveState ==\n\t\t\tMR_PD_STATE_SYSTEM)) {\n\t\t\tgoto scan_target;\n\t\t}\n\t\treturn -ENXIO;\n\t}\n\nscan_target:\n\tmr_device_priv_data = kzalloc(sizeof(*mr_device_priv_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!mr_device_priv_data)\n\t\treturn -ENOMEM;\n\tsdev->hostdata = mr_device_priv_data;\n\n\tatomic_set(&mr_device_priv_data->r1_ldio_hint,\n\t\t   instance->r1_ldio_hint_default);\n\treturn 0;\n}\n\nstatic void megasas_slave_destroy(struct scsi_device *sdev)\n{\n\tkfree(sdev->hostdata);\n\tsdev->hostdata = NULL;\n}\n\n/*\n* megasas_complete_outstanding_ioctls - Complete outstanding ioctls after a\n*                                       kill adapter\n* @instance:\t\t\t\tAdapter soft state\n*\n*/\nstatic void megasas_complete_outstanding_ioctls(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct megasas_cmd *cmd_mfi;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\t/* Find all outstanding ioctls */\n\tif (fusion) {\n\t\tfor (i = 0; i < instance->max_fw_cmds; i++) {\n\t\t\tcmd_fusion = fusion->cmd_list[i];\n\t\t\tif (cmd_fusion->sync_cmd_idx != (u32)ULONG_MAX) {\n\t\t\t\tcmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\n\t\t\t\tif (cmd_mfi->sync_cmd &&\n\t\t\t\t    (cmd_mfi->frame->hdr.cmd != MFI_CMD_ABORT)) {\n\t\t\t\t\tcmd_mfi->frame->hdr.cmd_status =\n\t\t\t\t\t\t\tMFI_STAT_WRONG_STATE;\n\t\t\t\t\tmegasas_complete_cmd(instance,\n\t\t\t\t\t\t\t     cmd_mfi, DID_OK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < instance->max_fw_cmds; i++) {\n\t\t\tcmd_mfi = instance->cmd_list[i];\n\t\t\tif (cmd_mfi->sync_cmd && cmd_mfi->frame->hdr.cmd !=\n\t\t\t\tMFI_CMD_ABORT)\n\t\t\t\tmegasas_complete_cmd(instance, cmd_mfi, DID_OK);\n\t\t}\n\t}\n}\n\n\nvoid megaraid_sas_kill_hba(struct megasas_instance *instance)\n{\n\t/* Set critical error to block I/O & ioctls in case caller didn't */\n\tatomic_set(&instance->adprecovery, MEGASAS_HW_CRITICAL_ERROR);\n\t/* Wait 1 second to ensure IO or ioctls in build have posted */\n\tmsleep(1000);\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t(instance->adapter_type != MFI_SERIES)) {\n\t\tif (!instance->requestorId) {\n\t\t\twritel(MFI_STOP_ADP, &instance->reg_set->doorbell);\n\t\t\t/* Flush */\n\t\t\treadl(&instance->reg_set->doorbell);\n\t\t}\n\t\tif (instance->requestorId && instance->peerIsPresent)\n\t\t\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\t} else {\n\t\twritel(MFI_STOP_ADP,\n\t\t\t&instance->reg_set->inbound_doorbell);\n\t}\n\t/* Complete outstanding ioctls when adapter is killed */\n\tmegasas_complete_outstanding_ioctls(instance);\n}\n\n /**\n  * megasas_check_and_restore_queue_depth - Check if queue depth needs to be\n  *\t\t\t\t\trestored to max value\n  * @instance:\t\t\tAdapter soft state\n  *\n  */\nvoid\nmegasas_check_and_restore_queue_depth(struct megasas_instance *instance)\n{\n\tunsigned long flags;\n\n\tif (instance->flag & MEGASAS_FW_BUSY\n\t    && time_after(jiffies, instance->last_time + 5 * HZ)\n\t    && atomic_read(&instance->fw_outstanding) <\n\t    instance->throttlequeuedepth + 1) {\n\n\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\tinstance->flag &= ~MEGASAS_FW_BUSY;\n\n\t\tinstance->host->can_queue = instance->cur_can_queue;\n\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t}\n}\n\n/**\n * megasas_complete_cmd_dpc\t -\tReturns FW's controller structure\n * @instance_addr:\t\t\tAddress of adapter soft state\n *\n * Tasklet to complete cmds\n */\nstatic void megasas_complete_cmd_dpc(unsigned long instance_addr)\n{\n\tu32 producer;\n\tu32 consumer;\n\tu32 context;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_instance *instance =\n\t\t\t\t(struct megasas_instance *)instance_addr;\n\tunsigned long flags;\n\n\t/* If we have already declared adapter dead, donot complete cmds */\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tspin_lock_irqsave(&instance->completion_lock, flags);\n\n\tproducer = le32_to_cpu(*instance->producer);\n\tconsumer = le32_to_cpu(*instance->consumer);\n\n\twhile (consumer != producer) {\n\t\tcontext = le32_to_cpu(instance->reply_queue[consumer]);\n\t\tif (context >= instance->max_fw_cmds) {\n\t\t\tdev_err(&instance->pdev->dev, \"Unexpected context value %x\\n\",\n\t\t\t\tcontext);\n\t\t\tBUG();\n\t\t}\n\n\t\tcmd = instance->cmd_list[context];\n\n\t\tmegasas_complete_cmd(instance, cmd, DID_OK);\n\n\t\tconsumer++;\n\t\tif (consumer == (instance->max_fw_cmds + 1)) {\n\t\t\tconsumer = 0;\n\t\t}\n\t}\n\n\t*instance->consumer = cpu_to_le32(producer);\n\n\tspin_unlock_irqrestore(&instance->completion_lock, flags);\n\n\t/*\n\t * Check if we can restore can_queue\n\t */\n\tmegasas_check_and_restore_queue_depth(instance);\n}\n\nstatic void megasas_sriov_heartbeat_handler(struct timer_list *t);\n\n/**\n * megasas_start_timer - Initializes sriov heartbeat timer object\n * @instance:\t\tAdapter soft state\n *\n */\nvoid megasas_start_timer(struct megasas_instance *instance)\n{\n\tstruct timer_list *timer = &instance->sriov_heartbeat_timer;\n\n\ttimer_setup(timer, megasas_sriov_heartbeat_handler, 0);\n\ttimer->expires = jiffies + MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF;\n\tadd_timer(timer);\n}\n\nstatic void\nmegasas_internal_reset_defer_cmds(struct megasas_instance *instance);\n\nstatic void\nprocess_fw_state_change_wq(struct work_struct *work);\n\nvoid megasas_do_ocr(struct megasas_instance *instance)\n{\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\n\t(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\n\t(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)) {\n\t\t*instance->consumer = cpu_to_le32(MEGASAS_ADPRESET_INPROG_SIGN);\n\t}\n\tinstance->instancet->disable_intr(instance);\n\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\n\tinstance->issuepend_done = 0;\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\tmegasas_internal_reset_defer_cmds(instance);\n\tprocess_fw_state_change_wq(&instance->work_init);\n}\n\nstatic int megasas_get_ld_vf_affiliation_111(struct megasas_instance *instance,\n\t\t\t\t\t    int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_VF_AFFILIATION_111 *new_affiliation_111 = NULL;\n\tdma_addr_t new_affiliation_111_h;\n\tint ld, retval = 0;\n\tu8 thisVf;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_vf_affiliation_111:\"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t\tinstance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (!instance->vf_affiliation_111) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Couldn't get LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (initial)\n\t\t\tmemset(instance->vf_affiliation_111, 0,\n\t\t\t       sizeof(struct MR_LD_VF_AFFILIATION_111));\n\telse {\n\t\tnew_affiliation_111 =\n\t\t\tdma_zalloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t      sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t\t      &new_affiliation_111_h, GFP_KERNEL);\n\t\tif (!new_affiliation_111) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate \"\n\t\t\t       \"memory for new affiliation for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len =\n\t\tcpu_to_le32(sizeof(struct MR_LD_VF_AFFILIATION_111));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_VF_MAP_GET_ALL_LDS_111);\n\n\tif (initial)\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(instance->vf_affiliation_111_h);\n\telse\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(new_affiliation_111_h);\n\n\tdcmd->sgl.sge32[0].length = cpu_to_le32(\n\t\tsizeof(struct MR_LD_VF_AFFILIATION_111));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Getting LD/VF affiliation for \"\n\t       \"scsi%d\\n\", instance->host->host_no);\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, 0) != DCMD_SUCCESS) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: LD/VF affiliation DCMD\"\n\t\t       \" failed with status 0x%x for scsi%d\\n\",\n\t\t       dcmd->cmd_status, instance->host->host_no);\n\t\tretval = 1; /* Do a scan if we couldn't get affiliation */\n\t\tgoto out;\n\t}\n\n\tif (!initial) {\n\t\tthisVf = new_affiliation_111->thisVf;\n\t\tfor (ld = 0 ; ld < new_affiliation_111->vdCount; ld++)\n\t\t\tif (instance->vf_affiliation_111->map[ld].policy[thisVf] !=\n\t\t\t    new_affiliation_111->map[ld].policy[thisVf]) {\n\t\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: \"\n\t\t\t\t       \"Got new LD/VF affiliation for scsi%d\\n\",\n\t\t\t\t       instance->host->host_no);\n\t\t\t\tmemcpy(instance->vf_affiliation_111,\n\t\t\t\t       new_affiliation_111,\n\t\t\t\t       sizeof(struct MR_LD_VF_AFFILIATION_111));\n\t\t\t\tretval = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\nout:\n\tif (new_affiliation_111) {\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t    new_affiliation_111,\n\t\t\t\t    new_affiliation_111_h);\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\nstatic int megasas_get_ld_vf_affiliation_12(struct megasas_instance *instance,\n\t\t\t\t\t    int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_VF_AFFILIATION *new_affiliation = NULL;\n\tstruct MR_LD_VF_MAP *newmap = NULL, *savedmap = NULL;\n\tdma_addr_t new_affiliation_h;\n\tint i, j, retval = 0, found = 0, doscan = 0;\n\tu8 thisVf;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_vf_affiliation12: \"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t       instance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (!instance->vf_affiliation) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Couldn't get LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (initial)\n\t\tmemset(instance->vf_affiliation, 0, (MAX_LOGICAL_DRIVES + 1) *\n\t\t       sizeof(struct MR_LD_VF_AFFILIATION));\n\telse {\n\t\tnew_affiliation =\n\t\t\tdma_zalloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t      (MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t\t      sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t\t      &new_affiliation_h, GFP_KERNEL);\n\t\tif (!new_affiliation) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate \"\n\t\t\t       \"memory for new affiliation for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32((MAX_LOGICAL_DRIVES + 1) *\n\t\tsizeof(struct MR_LD_VF_AFFILIATION));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_VF_MAP_GET_ALL_LDS);\n\n\tif (initial)\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(instance->vf_affiliation_h);\n\telse\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(new_affiliation_h);\n\n\tdcmd->sgl.sge32[0].length = cpu_to_le32((MAX_LOGICAL_DRIVES + 1) *\n\t\tsizeof(struct MR_LD_VF_AFFILIATION));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Getting LD/VF affiliation for \"\n\t       \"scsi%d\\n\", instance->host->host_no);\n\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, 0) != DCMD_SUCCESS) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: LD/VF affiliation DCMD\"\n\t\t       \" failed with status 0x%x for scsi%d\\n\",\n\t\t       dcmd->cmd_status, instance->host->host_no);\n\t\tretval = 1; /* Do a scan if we couldn't get affiliation */\n\t\tgoto out;\n\t}\n\n\tif (!initial) {\n\t\tif (!new_affiliation->ldCount) {\n\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Got new LD/VF \"\n\t\t\t       \"affiliation for passive path for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tretval = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tnewmap = new_affiliation->map;\n\t\tsavedmap = instance->vf_affiliation->map;\n\t\tthisVf = new_affiliation->thisVf;\n\t\tfor (i = 0 ; i < new_affiliation->ldCount; i++) {\n\t\t\tfound = 0;\n\t\t\tfor (j = 0; j < instance->vf_affiliation->ldCount;\n\t\t\t     j++) {\n\t\t\t\tif (newmap->ref.targetId ==\n\t\t\t\t    savedmap->ref.targetId) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif (newmap->policy[thisVf] !=\n\t\t\t\t\t    savedmap->policy[thisVf]) {\n\t\t\t\t\t\tdoscan = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsavedmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t\t((unsigned char *)savedmap +\n\t\t\t\t\t savedmap->size);\n\t\t\t}\n\t\t\tif (!found && newmap->policy[thisVf] !=\n\t\t\t    MR_LD_ACCESS_HIDDEN) {\n\t\t\t\tdoscan = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnewmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t((unsigned char *)newmap + newmap->size);\n\t\t}\n\n\t\tnewmap = new_affiliation->map;\n\t\tsavedmap = instance->vf_affiliation->map;\n\n\t\tfor (i = 0 ; i < instance->vf_affiliation->ldCount; i++) {\n\t\t\tfound = 0;\n\t\t\tfor (j = 0 ; j < new_affiliation->ldCount; j++) {\n\t\t\t\tif (savedmap->ref.targetId ==\n\t\t\t\t    newmap->ref.targetId) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif (savedmap->policy[thisVf] !=\n\t\t\t\t\t    newmap->policy[thisVf]) {\n\t\t\t\t\t\tdoscan = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t\t((unsigned char *)newmap +\n\t\t\t\t\t newmap->size);\n\t\t\t}\n\t\t\tif (!found && savedmap->policy[thisVf] !=\n\t\t\t    MR_LD_ACCESS_HIDDEN) {\n\t\t\t\tdoscan = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsavedmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t((unsigned char *)savedmap +\n\t\t\t\t savedmap->size);\n\t\t}\n\t}\nout:\n\tif (doscan) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Got new LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmemcpy(instance->vf_affiliation, new_affiliation,\n\t\t       new_affiliation->size);\n\t\tretval = 1;\n\t}\n\n\tif (new_affiliation)\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t    (MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t    new_affiliation, new_affiliation_h);\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\n/* This function will get the current SR-IOV LD/VF affiliation */\nstatic int megasas_get_ld_vf_affiliation(struct megasas_instance *instance,\n\tint initial)\n{\n\tint retval;\n\n\tif (instance->PlasmaFW111)\n\t\tretval = megasas_get_ld_vf_affiliation_111(instance, initial);\n\telse\n\t\tretval = megasas_get_ld_vf_affiliation_12(instance, initial);\n\treturn retval;\n}\n\n/* This function will tell FW to start the SR-IOV heartbeat */\nint megasas_sriov_start_heartbeat(struct megasas_instance *instance,\n\t\t\t\t\t int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tint retval = 0;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_sriov_start_heartbeat: \"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t       instance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (initial) {\n\t\tinstance->hb_host_mem =\n\t\t\tdma_zalloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t      sizeof(struct MR_CTRL_HB_HOST_MEM),\n\t\t\t\t\t      &instance->hb_host_mem_h, GFP_KERNEL);\n\t\tif (!instance->hb_host_mem) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate\"\n\t\t\t       \" memory for heartbeat host memory for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.s[0] = cpu_to_le16(sizeof(struct MR_CTRL_HB_HOST_MEM));\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_CTRL_HB_HOST_MEM));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SHARED_HOST_MEM_ALLOC);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->hb_host_mem_h,\n\t\t\t\t sizeof(struct MR_CTRL_HB_HOST_MEM));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Starting heartbeat for scsi%d\\n\",\n\t       instance->host->host_no);\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tretval = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMEGASAS_ROUTINE_WAIT_TIME_VF);\n\telse\n\t\tretval = megasas_issue_polled(instance, cmd);\n\n\tif (retval) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: MR_DCMD_CTRL_SHARED_HOST\"\n\t\t\t\"_MEM_ALLOC DCMD %s for scsi%d\\n\",\n\t\t\t(dcmd->cmd_status == MFI_STAT_INVALID_STATUS) ?\n\t\t\t\"timed out\" : \"failed\", instance->host->host_no);\n\t\tretval = 1;\n\t}\n\nout:\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\n/* Handler for SR-IOV heartbeat */\nstatic void megasas_sriov_heartbeat_handler(struct timer_list *t)\n{\n\tstruct megasas_instance *instance =\n\t\tfrom_timer(instance, t, sriov_heartbeat_timer);\n\n\tif (instance->hb_host_mem->HB.fwCounter !=\n\t    instance->hb_host_mem->HB.driverCounter) {\n\t\tinstance->hb_host_mem->HB.driverCounter =\n\t\t\tinstance->hb_host_mem->HB.fwCounter;\n\t\tmod_timer(&instance->sriov_heartbeat_timer,\n\t\t\t  jiffies + MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF);\n\t} else {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Heartbeat never \"\n\t\t       \"completed for scsi%d\\n\", instance->host->host_no);\n\t\tschedule_work(&instance->work_init);\n\t}\n}\n\n/**\n * megasas_wait_for_outstanding -\tWait for all outstanding cmds\n * @instance:\t\t\t\tAdapter soft state\n *\n * This function waits for up to MEGASAS_RESET_WAIT_TIME seconds for FW to\n * complete all its outstanding commands. Returns error if one or more IOs\n * are pending after this time period. It also marks the controller dead.\n */\nstatic int megasas_wait_for_outstanding(struct megasas_instance *instance)\n{\n\tint i, sl, outstanding;\n\tu32 reset_index;\n\tu32 wait_time = MEGASAS_RESET_WAIT_TIME;\n\tunsigned long flags;\n\tstruct list_head clist_local;\n\tstruct megasas_cmd *reset_cmd;\n\tu32 fw_state;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_info(&instance->pdev->dev, \"%s:%d HBA is killed.\\n\",\n\t\t__func__, __LINE__);\n\t\treturn FAILED;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\n\n\t\tINIT_LIST_HEAD(&clist_local);\n\t\tspin_lock_irqsave(&instance->hba_lock, flags);\n\t\tlist_splice_init(&instance->internal_reset_pending_q,\n\t\t\t\t&clist_local);\n\t\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\t\tdev_notice(&instance->pdev->dev, \"HBA reset wait ...\\n\");\n\t\tfor (i = 0; i < wait_time; i++) {\n\t\t\tmsleep(1000);\n\t\t\tif (atomic_read(&instance->adprecovery) == MEGASAS_HBA_OPERATIONAL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\n\t\t\tdev_notice(&instance->pdev->dev, \"reset: Stopping HBA.\\n\");\n\t\t\tatomic_set(&instance->adprecovery, MEGASAS_HW_CRITICAL_ERROR);\n\t\t\treturn FAILED;\n\t\t}\n\n\t\treset_index = 0;\n\t\twhile (!list_empty(&clist_local)) {\n\t\t\treset_cmd = list_entry((&clist_local)->next,\n\t\t\t\t\t\tstruct megasas_cmd, list);\n\t\t\tlist_del_init(&reset_cmd->list);\n\t\t\tif (reset_cmd->scmd) {\n\t\t\t\treset_cmd->scmd->result = DID_REQUEUE << 16;\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%d:%p reset [%02x]\\n\",\n\t\t\t\t\treset_index, reset_cmd,\n\t\t\t\t\treset_cmd->scmd->cmnd[0]);\n\n\t\t\t\treset_cmd->scmd->scsi_done(reset_cmd->scmd);\n\t\t\t\tmegasas_return_cmd(instance, reset_cmd);\n\t\t\t} else if (reset_cmd->sync_cmd) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%p synch cmds\"\n\t\t\t\t\t\t\"reset queue\\n\",\n\t\t\t\t\t\treset_cmd);\n\n\t\t\t\treset_cmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;\n\t\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\t\treset_cmd->frame_phys_addr,\n\t\t\t\t\t\t0, instance->reg_set);\n\t\t\t} else {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%p unexpected\"\n\t\t\t\t\t\"cmds lst\\n\",\n\t\t\t\t\treset_cmd);\n\t\t\t}\n\t\t\treset_index++;\n\t\t}\n\n\t\treturn SUCCESS;\n\t}\n\n\tfor (i = 0; i < resetwaittime; i++) {\n\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\n\t\tif (!outstanding)\n\t\t\tbreak;\n\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"[%2d]waiting for %d \"\n\t\t\t       \"commands to complete\\n\",i,outstanding);\n\t\t\t/*\n\t\t\t * Call cmd completion routine. Cmd to be\n\t\t\t * be completed directly without depending on isr.\n\t\t\t */\n\t\t\tmegasas_complete_cmd_dpc((unsigned long)instance);\n\t\t}\n\n\t\tmsleep(1000);\n\t}\n\n\ti = 0;\n\toutstanding = atomic_read(&instance->fw_outstanding);\n\tfw_state = instance->instancet->read_fw_status_reg(instance) & MFI_STATE_MASK;\n\n\tif ((!outstanding && (fw_state == MFI_STATE_OPERATIONAL)))\n\t\tgoto no_outstanding;\n\n\tif (instance->disableOnlineCtrlReset)\n\t\tgoto kill_hba_and_failed;\n\tdo {\n\t\tif ((fw_state == MFI_STATE_FAULT) || atomic_read(&instance->fw_outstanding)) {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\"%s:%d waiting_for_outstanding: before issue OCR. FW state = 0x%x, oustanding 0x%x\\n\",\n\t\t\t\t__func__, __LINE__, fw_state, atomic_read(&instance->fw_outstanding));\n\t\t\tif (i == 3)\n\t\t\t\tgoto kill_hba_and_failed;\n\t\t\tmegasas_do_ocr(instance);\n\n\t\t\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\t\t\tdev_info(&instance->pdev->dev, \"%s:%d OCR failed and HBA is killed.\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\t\treturn FAILED;\n\t\t\t}\n\t\t\tdev_info(&instance->pdev->dev, \"%s:%d waiting_for_outstanding: after issue OCR.\\n\",\n\t\t\t\t__func__, __LINE__);\n\n\t\t\tfor (sl = 0; sl < 10; sl++)\n\t\t\t\tmsleep(500);\n\n\t\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\n\t\t\tfw_state = instance->instancet->read_fw_status_reg(instance) & MFI_STATE_MASK;\n\t\t\tif ((!outstanding && (fw_state == MFI_STATE_OPERATIONAL)))\n\t\t\t\tgoto no_outstanding;\n\t\t}\n\t\ti++;\n\t} while (i <= 3);\n\nno_outstanding:\n\n\tdev_info(&instance->pdev->dev, \"%s:%d no more pending commands remain after reset handling.\\n\",\n\t\t__func__, __LINE__);\n\treturn SUCCESS;\n\nkill_hba_and_failed:\n\n\t/* Reset not supported, kill adapter */\n\tdev_info(&instance->pdev->dev, \"%s:%d killing adapter scsi%d\"\n\t\t\" disableOnlineCtrlReset %d fw_outstanding %d \\n\",\n\t\t__func__, __LINE__, instance->host->host_no, instance->disableOnlineCtrlReset,\n\t\tatomic_read(&instance->fw_outstanding));\n\tmegasas_dump_pending_frames(instance);\n\tmegaraid_sas_kill_hba(instance);\n\n\treturn FAILED;\n}\n\n/**\n * megasas_generic_reset -\tGeneric reset routine\n * @scmd:\t\t\tMid-layer SCSI command\n *\n * This routine implements a generic reset handler for device, bus and host\n * reset requests. Device, bus and host specific reset handlers can use this\n * function after they do their specific tasks.\n */\nstatic int megasas_generic_reset(struct scsi_cmnd *scmd)\n{\n\tint ret_val;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tscmd_printk(KERN_NOTICE, scmd, \"megasas: RESET cmd=%x retries=%x\\n\",\n\t\t scmd->cmnd[0], scmd->retries);\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"cannot recover from previous reset failures\\n\");\n\t\treturn FAILED;\n\t}\n\n\tret_val = megasas_wait_for_outstanding(instance);\n\tif (ret_val == SUCCESS)\n\t\tdev_notice(&instance->pdev->dev, \"reset successful\\n\");\n\telse\n\t\tdev_err(&instance->pdev->dev, \"failed to do reset\\n\");\n\n\treturn ret_val;\n}\n\n/**\n * megasas_reset_timer - quiesce the adapter if required\n * @scmd:\t\tscsi cmnd\n *\n * Sets the FW busy flag and reduces the host->can_queue if the\n * cmd has not been completed within the timeout period.\n */\nstatic enum\nblk_eh_timer_return megasas_reset_timer(struct scsi_cmnd *scmd)\n{\n\tstruct megasas_instance *instance;\n\tunsigned long flags;\n\n\tif (time_after(jiffies, scmd->jiffies_at_alloc +\n\t\t\t\t(scmd_timeout * 2) * HZ)) {\n\t\treturn BLK_EH_DONE;\n\t}\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\tif (!(instance->flag & MEGASAS_FW_BUSY)) {\n\t\t/* FW is busy, throttle IO */\n\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\n\t\tinstance->host->can_queue = instance->throttlequeuedepth;\n\t\tinstance->last_time = jiffies;\n\t\tinstance->flag |= MEGASAS_FW_BUSY;\n\n\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t}\n\treturn BLK_EH_RESET_TIMER;\n}\n\n/**\n * megasas_dump_frame -\tThis function will dump MPT/MFI frame\n */\nstatic inline void\nmegasas_dump_frame(void *mpi_request, int sz)\n{\n\tint i;\n\t__le32 *mfp = (__le32 *)mpi_request;\n\n\tprintk(KERN_INFO \"IO request frame:\\n\\t\");\n\tfor (i = 0; i < sz / sizeof(__le32); i++) {\n\t\tif (i && ((i % 8) == 0))\n\t\t\tprintk(\"\\n\\t\");\n\t\tprintk(\"%08x \", le32_to_cpu(mfp[i]));\n\t}\n\tprintk(\"\\n\");\n}\n\n/**\n * megasas_reset_bus_host -\tBus & host reset handler entry point\n */\nstatic int megasas_reset_bus_host(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, scmd,\n\t\t\"Controller reset is requested due to IO timeout\\n\"\n\t\t\"SCSI command pointer: (%p)\\t SCSI host state: %d\\t\"\n\t\t\" SCSI host busy: %d\\t FW outstanding: %d\\n\",\n\t\tscmd, scmd->device->host->shost_state,\n\t\tscsi_host_busy(scmd->device->host),\n\t\tatomic_read(&instance->fw_outstanding));\n\n\t/*\n\t * First wait for all commands to complete\n\t */\n\tif (instance->adapter_type == MFI_SERIES) {\n\t\tret = megasas_generic_reset(scmd);\n\t} else {\n\t\tstruct megasas_cmd_fusion *cmd;\n\t\tcmd = (struct megasas_cmd_fusion *)scmd->SCp.ptr;\n\t\tif (cmd)\n\t\t\tmegasas_dump_frame(cmd->io_request,\n\t\t\t\tMEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE);\n\t\tret = megasas_reset_fusion(scmd->device->host,\n\t\t\t\tSCSIIO_TIMEOUT_OCR);\n\t}\n\n\treturn ret;\n}\n\n/**\n * megasas_task_abort - Issues task abort request to firmware\n *\t\t\t(supported only for fusion adapters)\n * @scmd:\t\tSCSI command pointer\n */\nstatic int megasas_task_abort(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tret = megasas_task_abort_fusion(scmd);\n\telse {\n\t\tsdev_printk(KERN_NOTICE, scmd->device, \"TASK ABORT not supported\\n\");\n\t\tret = FAILED;\n\t}\n\n\treturn ret;\n}\n\n/**\n * megasas_reset_target:  Issues target reset request to firmware\n *                        (supported only for fusion adapters)\n * @scmd:                 SCSI command pointer\n */\nstatic int megasas_reset_target(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tret = megasas_reset_target_fusion(scmd);\n\telse {\n\t\tsdev_printk(KERN_NOTICE, scmd->device, \"TARGET RESET not supported\\n\");\n\t\tret = FAILED;\n\t}\n\n\treturn ret;\n}\n\n/**\n * megasas_bios_param - Returns disk geometry for a disk\n * @sdev:\t\tdevice handle\n * @bdev:\t\tblock device\n * @capacity:\t\tdrive capacity\n * @geom:\t\tgeometry parameters\n */\nstatic int\nmegasas_bios_param(struct scsi_device *sdev, struct block_device *bdev,\n\t\t sector_t capacity, int geom[])\n{\n\tint heads;\n\tint sectors;\n\tsector_t cylinders;\n\tunsigned long tmp;\n\n\t/* Default heads (64) & sectors (32) */\n\theads = 64;\n\tsectors = 32;\n\n\ttmp = heads * sectors;\n\tcylinders = capacity;\n\n\tsector_div(cylinders, tmp);\n\n\t/*\n\t * Handle extended translation size for logical drives > 1Gb\n\t */\n\n\tif (capacity >= 0x200000) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\ttmp = heads*sectors;\n\t\tcylinders = capacity;\n\t\tsector_div(cylinders, tmp);\n\t}\n\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\n\treturn 0;\n}\n\nstatic void megasas_aen_polling(struct work_struct *work);\n\n/**\n * megasas_service_aen -\tProcesses an event notification\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tAEN command completed by the ISR\n *\n * For AEN, driver sends a command down to FW that is held by the FW till an\n * event occurs. When an event of interest occurs, FW completes the command\n * that it was previously holding.\n *\n * This routines sends SIGIO signal to processes that have registered with the\n * driver for AEN.\n */\nstatic void\nmegasas_service_aen(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Don't signal app if it is just an aborted previously registered aen\n\t */\n\tif ((!cmd->abort_aen) && (instance->unload == 0)) {\n\t\tspin_lock_irqsave(&poll_aen_lock, flags);\n\t\tmegasas_poll_wait_aen = 1;\n\t\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\t\twake_up(&megasas_poll_wait);\n\t\tkill_fasync(&megasas_async_queue, SIGIO, POLL_IN);\n\t}\n\telse\n\t\tcmd->abort_aen = 0;\n\n\tinstance->aen_cmd = NULL;\n\n\tmegasas_return_cmd(instance, cmd);\n\n\tif ((instance->unload == 0) &&\n\t\t((instance->issuepend_done == 1))) {\n\t\tstruct megasas_aen_event *ev;\n\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (!ev) {\n\t\t\tdev_err(&instance->pdev->dev, \"megasas_service_aen: out of memory\\n\");\n\t\t} else {\n\t\t\tev->instance = instance;\n\t\t\tinstance->ev = ev;\n\t\t\tINIT_DELAYED_WORK(&ev->hotplug_work,\n\t\t\t\t\t  megasas_aen_polling);\n\t\t\tschedule_delayed_work(&ev->hotplug_work, 0);\n\t\t}\n\t}\n}\n\nstatic ssize_t\nmegasas_fw_crash_buffer_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tint val = 0;\n\tunsigned long flags;\n\n\tif (kstrtoint(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&instance->crashdump_lock, flags);\n\tinstance->fw_crash_buffer_offset = val;\n\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nmegasas_fw_crash_buffer_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tu32 size;\n\tunsigned long buff_addr;\n\tunsigned long dmachunk = CRASH_DMA_BUF_SIZE;\n\tunsigned long src_addr;\n\tunsigned long flags;\n\tu32 buff_offset;\n\n\tspin_lock_irqsave(&instance->crashdump_lock, flags);\n\tbuff_offset = instance->fw_crash_buffer_offset;\n\tif (!instance->crash_dump_buf &&\n\t\t!((instance->fw_crash_state == AVAILABLE) ||\n\t\t(instance->fw_crash_state == COPYING))) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Firmware crash dump is not available\\n\");\n\t\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tbuff_addr = (unsigned long) buf;\n\n\tif (buff_offset > (instance->fw_crash_buffer_size * dmachunk)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Firmware crash dump offset is out of range\\n\");\n\t\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\t\treturn 0;\n\t}\n\n\tsize = (instance->fw_crash_buffer_size * dmachunk) - buff_offset;\n\tsize = (size >= PAGE_SIZE) ? (PAGE_SIZE - 1) : size;\n\n\tsrc_addr = (unsigned long)instance->crash_buf[buff_offset / dmachunk] +\n\t\t(buff_offset % dmachunk);\n\tmemcpy(buf, (void *)src_addr, size);\n\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\n\treturn size;\n}\n\nstatic ssize_t\nmegasas_fw_crash_buffer_size_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%ld\\n\", (unsigned long)\n\t\t((instance->fw_crash_buffer_size) * 1024 * 1024)/PAGE_SIZE);\n}\n\nstatic ssize_t\nmegasas_fw_crash_state_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tint val = 0;\n\tunsigned long flags;\n\n\tif (kstrtoint(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\n\tif ((val <= AVAILABLE || val > COPY_ERROR)) {\n\t\tdev_err(&instance->pdev->dev, \"application updates invalid \"\n\t\t\t\"firmware crash state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinstance->fw_crash_state = val;\n\n\tif ((val == COPIED) || (val == COPY_ERROR)) {\n\t\tspin_lock_irqsave(&instance->crashdump_lock, flags);\n\t\tmegasas_free_host_crash_buffer(instance);\n\t\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\t\tif (val == COPY_ERROR)\n\t\t\tdev_info(&instance->pdev->dev, \"application failed to \"\n\t\t\t\t\"copy Firmware crash dump\\n\");\n\t\telse\n\t\t\tdev_info(&instance->pdev->dev, \"Firmware crash dump \"\n\t\t\t\t\"copied successfully\\n\");\n\t}\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nmegasas_fw_crash_state_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", instance->fw_crash_state);\n}\n\nstatic ssize_t\nmegasas_page_size_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%ld\\n\", (unsigned long)PAGE_SIZE - 1);\n}\n\nstatic ssize_t\nmegasas_ldio_outstanding_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&instance->ldio_outstanding));\n}\n\nstatic ssize_t\nmegasas_fw_cmds_outstanding_show(struct device *cdev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&instance->fw_outstanding));\n}\n\nstatic DEVICE_ATTR(fw_crash_buffer, S_IRUGO | S_IWUSR,\n\tmegasas_fw_crash_buffer_show, megasas_fw_crash_buffer_store);\nstatic DEVICE_ATTR(fw_crash_buffer_size, S_IRUGO,\n\tmegasas_fw_crash_buffer_size_show, NULL);\nstatic DEVICE_ATTR(fw_crash_state, S_IRUGO | S_IWUSR,\n\tmegasas_fw_crash_state_show, megasas_fw_crash_state_store);\nstatic DEVICE_ATTR(page_size, S_IRUGO,\n\tmegasas_page_size_show, NULL);\nstatic DEVICE_ATTR(ldio_outstanding, S_IRUGO,\n\tmegasas_ldio_outstanding_show, NULL);\nstatic DEVICE_ATTR(fw_cmds_outstanding, S_IRUGO,\n\tmegasas_fw_cmds_outstanding_show, NULL);\n\nstruct device_attribute *megaraid_host_attrs[] = {\n\t&dev_attr_fw_crash_buffer_size,\n\t&dev_attr_fw_crash_buffer,\n\t&dev_attr_fw_crash_state,\n\t&dev_attr_page_size,\n\t&dev_attr_ldio_outstanding,\n\t&dev_attr_fw_cmds_outstanding,\n\tNULL,\n};\n\n/*\n * Scsi host template for megaraid_sas driver\n */\nstatic struct scsi_host_template megasas_template = {\n\n\t.module = THIS_MODULE,\n\t.name = \"Avago SAS based MegaRAID driver\",\n\t.proc_name = \"megaraid_sas\",\n\t.slave_configure = megasas_slave_configure,\n\t.slave_alloc = megasas_slave_alloc,\n\t.slave_destroy = megasas_slave_destroy,\n\t.queuecommand = megasas_queue_command,\n\t.eh_target_reset_handler = megasas_reset_target,\n\t.eh_abort_handler = megasas_task_abort,\n\t.eh_host_reset_handler = megasas_reset_bus_host,\n\t.eh_timed_out = megasas_reset_timer,\n\t.shost_attrs = megaraid_host_attrs,\n\t.bios_param = megasas_bios_param,\n\t.change_queue_depth = scsi_change_queue_depth,\n\t.no_write_same = 1,\n};\n\n/**\n * megasas_complete_int_cmd -\tCompletes an internal command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand to be completed\n *\n * The megasas_issue_blocked_cmd() function waits for a command to complete\n * after it issues a command. This function wakes up that waiting routine by\n * calling wake_up() on the wait queue.\n */\nstatic void\nmegasas_complete_int_cmd(struct megasas_instance *instance,\n\t\t\t struct megasas_cmd *cmd)\n{\n\tcmd->cmd_status_drv = cmd->frame->io.cmd_status;\n\twake_up(&instance->int_cmd_wait_q);\n}\n\n/**\n * megasas_complete_abort -\tCompletes aborting a command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCmd that was issued to abort another cmd\n *\n * The megasas_issue_blocked_abort_cmd() function waits on abort_cmd_wait_q\n * after it issues an abort on a previously issued command. This function\n * wakes up all functions waiting on the same wait queue.\n */\nstatic void\nmegasas_complete_abort(struct megasas_instance *instance,\n\t\t       struct megasas_cmd *cmd)\n{\n\tif (cmd->sync_cmd) {\n\t\tcmd->sync_cmd = 0;\n\t\tcmd->cmd_status_drv = 0;\n\t\twake_up(&instance->abort_cmd_wait_q);\n\t}\n}\n\n/**\n * megasas_complete_cmd -\tCompletes a command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand to be completed\n * @alt_status:\t\t\tIf non-zero, use this value as status to\n *\t\t\t\tSCSI mid-layer instead of the value returned\n *\t\t\t\tby the FW. This should be used if caller wants\n *\t\t\t\tan alternate status (as in the case of aborted\n *\t\t\t\tcommands)\n */\nvoid\nmegasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\t\t     u8 alt_status)\n{\n\tint exception = 0;\n\tstruct megasas_header *hdr = &cmd->frame->hdr;\n\tunsigned long flags;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tu32 opcode, status;\n\n\t/* flag for the retry reset */\n\tcmd->retry_for_fw_reset = 0;\n\n\tif (cmd->scmd)\n\t\tcmd->scmd->SCp.ptr = NULL;\n\n\tswitch (hdr->cmd) {\n\tcase MFI_CMD_INVALID:\n\t\t/* Some older 1068 controller FW may keep a pended\n\t\t   MR_DCMD_CTRL_EVENT_GET_INFO left over from the main kernel\n\t\t   when booting the kdump kernel.  Ignore this command to\n\t\t   prevent a kernel panic on shutdown of the kdump kernel. */\n\t\tdev_warn(&instance->pdev->dev, \"MFI_CMD_INVALID command \"\n\t\t       \"completed\\n\");\n\t\tdev_warn(&instance->pdev->dev, \"If you have a controller \"\n\t\t       \"other than PERC5, please upgrade your firmware\\n\");\n\t\tbreak;\n\tcase MFI_CMD_PD_SCSI_IO:\n\tcase MFI_CMD_LD_SCSI_IO:\n\n\t\t/*\n\t\t * MFI_CMD_PD_SCSI_IO and MFI_CMD_LD_SCSI_IO could have been\n\t\t * issued either through an IO path or an IOCTL path. If it\n\t\t * was via IOCTL, we will send it to internal completion.\n\t\t */\n\t\tif (cmd->sync_cmd) {\n\t\t\tcmd->sync_cmd = 0;\n\t\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\n\tcase MFI_CMD_LD_READ:\n\tcase MFI_CMD_LD_WRITE:\n\n\t\tif (alt_status) {\n\t\t\tcmd->scmd->result = alt_status << 16;\n\t\t\texception = 1;\n\t\t}\n\n\t\tif (exception) {\n\n\t\t\tatomic_dec(&instance->fw_outstanding);\n\n\t\t\tscsi_dma_unmap(cmd->scmd);\n\t\t\tcmd->scmd->scsi_done(cmd->scmd);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (hdr->cmd_status) {\n\n\t\tcase MFI_STAT_OK:\n\t\t\tcmd->scmd->result = DID_OK << 16;\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_SCSI_IO_FAILED:\n\t\tcase MFI_STAT_LD_INIT_IN_PROGRESS:\n\t\t\tcmd->scmd->result =\n\t\t\t    (DID_ERROR << 16) | hdr->scsi_status;\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_SCSI_DONE_WITH_ERROR:\n\n\t\t\tcmd->scmd->result = (DID_OK << 16) | hdr->scsi_status;\n\n\t\t\tif (hdr->scsi_status == SAM_STAT_CHECK_CONDITION) {\n\t\t\t\tmemset(cmd->scmd->sense_buffer, 0,\n\t\t\t\t       SCSI_SENSE_BUFFERSIZE);\n\t\t\t\tmemcpy(cmd->scmd->sense_buffer, cmd->sense,\n\t\t\t\t       hdr->sense_len);\n\n\t\t\t\tcmd->scmd->result |= DRIVER_SENSE << 24;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_LD_OFFLINE:\n\t\tcase MFI_STAT_DEVICE_NOT_FOUND:\n\t\t\tcmd->scmd->result = DID_BAD_TARGET << 16;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"MFI FW status %#x\\n\",\n\t\t\t       hdr->cmd_status);\n\t\t\tcmd->scmd->result = DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tatomic_dec(&instance->fw_outstanding);\n\n\t\tscsi_dma_unmap(cmd->scmd);\n\t\tcmd->scmd->scsi_done(cmd->scmd);\n\t\tmegasas_return_cmd(instance, cmd);\n\n\t\tbreak;\n\n\tcase MFI_CMD_SMP:\n\tcase MFI_CMD_STP:\n\tcase MFI_CMD_NVME:\n\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\tbreak;\n\n\tcase MFI_CMD_DCMD:\n\t\topcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n\t\t/* Check for LD map update */\n\t\tif ((opcode == MR_DCMD_LD_MAP_GET_INFO)\n\t\t\t&& (cmd->frame->dcmd.mbox.b[1] == 1)) {\n\t\t\tfusion->fast_path_io = 0;\n\t\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\t\tstatus = cmd->frame->hdr.cmd_status;\n\t\t\tinstance->map_update_cmd = NULL;\n\t\t\tif (status != MFI_STAT_OK) {\n\t\t\t\tif (status != MFI_STAT_NOT_FOUND)\n\t\t\t\t\tdev_warn(&instance->pdev->dev, \"map syncfailed, status = 0x%x\\n\",\n\t\t\t\t\t       cmd->frame->hdr.cmd_status);\n\t\t\t\telse {\n\t\t\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\tinstance->host->host_lock,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\t/*\n\t\t\t * Set fast path IO to ZERO.\n\t\t\t * Validate Map will set proper value.\n\t\t\t * Meanwhile all IOs will go as LD IO.\n\t\t\t */\n\t\t\tif (status == MFI_STAT_OK &&\n\t\t\t    (MR_ValidateMapInfo(instance, (instance->map_id + 1)))) {\n\t\t\t\tinstance->map_id++;\n\t\t\t\tfusion->fast_path_io = 1;\n\t\t\t} else {\n\t\t\t\tfusion->fast_path_io = 0;\n\t\t\t}\n\n\t\t\tmegasas_sync_map_info(instance);\n\t\t\tspin_unlock_irqrestore(instance->host->host_lock,\n\t\t\t\t\t       flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (opcode == MR_DCMD_CTRL_EVENT_GET_INFO ||\n\t\t    opcode == MR_DCMD_CTRL_EVENT_GET) {\n\t\t\tspin_lock_irqsave(&poll_aen_lock, flags);\n\t\t\tmegasas_poll_wait_aen = 0;\n\t\t\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\t\t}\n\n\t\t/* FW has an updated PD sequence */\n\t\tif ((opcode == MR_DCMD_SYSTEM_PD_MAP_GET_INFO) &&\n\t\t\t(cmd->frame->dcmd.mbox.b[0] == 1)) {\n\n\t\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\t\tstatus = cmd->frame->hdr.cmd_status;\n\t\t\tinstance->jbod_seq_cmd = NULL;\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\tif (status == MFI_STAT_OK) {\n\t\t\t\tinstance->pd_seq_map_id++;\n\t\t\t\t/* Re-register a pd sync seq num cmd */\n\t\t\t\tif (megasas_sync_pd_seq_num(instance, true))\n\t\t\t\t\tinstance->use_seqnum_jbod_fp = false;\n\t\t\t} else\n\t\t\t\tinstance->use_seqnum_jbod_fp = false;\n\n\t\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * See if got an event notification\n\t\t */\n\t\tif (opcode == MR_DCMD_CTRL_EVENT_WAIT)\n\t\t\tmegasas_service_aen(instance, cmd);\n\t\telse\n\t\t\tmegasas_complete_int_cmd(instance, cmd);\n\n\t\tbreak;\n\n\tcase MFI_CMD_ABORT:\n\t\t/*\n\t\t * Cmd issued to abort another cmd returned\n\t\t */\n\t\tmegasas_complete_abort(instance, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_info(&instance->pdev->dev, \"Unknown command completed! [0x%X]\\n\",\n\t\t       hdr->cmd);\n\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\tbreak;\n\t}\n}\n\n/**\n * megasas_issue_pending_cmds_again -\tissue all pending cmds\n *\t\t\t\t\tin FW again because of the fw reset\n * @instance:\t\t\t\tAdapter soft state\n */\nstatic inline void\nmegasas_issue_pending_cmds_again(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct list_head clist_local;\n\tunion megasas_evt_class_locale class_locale;\n\tunsigned long flags;\n\tu32 seq_num;\n\n\tINIT_LIST_HEAD(&clist_local);\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\tlist_splice_init(&instance->internal_reset_pending_q, &clist_local);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\twhile (!list_empty(&clist_local)) {\n\t\tcmd = list_entry((&clist_local)->next,\n\t\t\t\t\tstruct megasas_cmd, list);\n\t\tlist_del_init(&cmd->list);\n\n\t\tif (cmd->sync_cmd || cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"command %p, %p:%d\"\n\t\t\t\t\"detected to be pending while HBA reset\\n\",\n\t\t\t\t\tcmd, cmd->scmd, cmd->sync_cmd);\n\n\t\t\tcmd->retry_for_fw_reset++;\n\n\t\t\tif (cmd->retry_for_fw_reset == 3) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"cmd %p, %p:%d\"\n\t\t\t\t\t\"was tried multiple times during reset.\"\n\t\t\t\t\t\"Shutting down the HBA\\n\",\n\t\t\t\t\tcmd, cmd->scmd, cmd->sync_cmd);\n\t\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (cmd->sync_cmd == 1) {\n\t\t\tif (cmd->scmd) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"unexpected\"\n\t\t\t\t\t\"cmd attached to internal command!\\n\");\n\t\t\t}\n\t\t\tdev_notice(&instance->pdev->dev, \"%p synchronous cmd\"\n\t\t\t\t\t\t\"on the internal reset queue,\"\n\t\t\t\t\t\t\"issue it again.\\n\", cmd);\n\t\t\tcmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;\n\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\t\t\tcmd->frame_phys_addr,\n\t\t\t\t\t\t\t0, instance->reg_set);\n\t\t} else if (cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"%p scsi cmd [%02x]\"\n\t\t\t\"detected on the internal queue, issue again.\\n\",\n\t\t\tcmd, cmd->scmd->cmnd[0]);\n\n\t\t\tatomic_inc(&instance->fw_outstanding);\n\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\tcmd->frame_phys_addr,\n\t\t\t\t\tcmd->frame_count-1, instance->reg_set);\n\t\t} else {\n\t\t\tdev_notice(&instance->pdev->dev, \"%p unexpected cmd on the\"\n\t\t\t\t\"internal reset defer list while re-issue!!\\n\",\n\t\t\t\tcmd);\n\t\t}\n\t}\n\n\tif (instance->aen_cmd) {\n\t\tdev_notice(&instance->pdev->dev, \"aen_cmd in def process\\n\");\n\t\tmegasas_return_cmd(instance, instance->aen_cmd);\n\n\t\tinstance->aen_cmd = NULL;\n\t}\n\n\t/*\n\t * Initiate AEN (Asynchronous Event Notification)\n\t */\n\tseq_num = instance->last_seq_num;\n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\tmegasas_register_aen(instance, seq_num, class_locale.word);\n}\n\n/**\n * Move the internal reset pending commands to a deferred queue.\n *\n * We move the commands pending at internal reset time to a\n * pending queue. This queue would be flushed after successful\n * completion of the internal reset sequence. if the internal reset\n * did not complete in time, the kernel reset handler would flush\n * these commands.\n **/\nstatic void\nmegasas_internal_reset_defer_cmds(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tint i;\n\tu16 max_cmd = instance->max_fw_cmds;\n\tu32 defer_index;\n\tunsigned long flags;\n\n\tdefer_index = 0;\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tif (cmd->sync_cmd == 1 || cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"moving cmd[%d]:%p:%d:%p\"\n\t\t\t\t\t\"on the defer queue as internal\\n\",\n\t\t\t\tdefer_index, cmd, cmd->sync_cmd, cmd->scmd);\n\n\t\t\tif (!list_empty(&cmd->list)) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"ERROR while\"\n\t\t\t\t\t\" moving this cmd:%p, %d %p, it was\"\n\t\t\t\t\t\"discovered on some list?\\n\",\n\t\t\t\t\tcmd, cmd->sync_cmd, cmd->scmd);\n\n\t\t\t\tlist_del_init(&cmd->list);\n\t\t\t}\n\t\t\tdefer_index++;\n\t\t\tlist_add_tail(&cmd->list,\n\t\t\t\t&instance->internal_reset_pending_q);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n}\n\n\nstatic void\nprocess_fw_state_change_wq(struct work_struct *work)\n{\n\tstruct megasas_instance *instance =\n\t\tcontainer_of(work, struct megasas_instance, work_init);\n\tu32 wait;\n\tunsigned long flags;\n\n    if (atomic_read(&instance->adprecovery) != MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tdev_notice(&instance->pdev->dev, \"error, recovery st %x\\n\",\n\t\t\t\tatomic_read(&instance->adprecovery));\n\t\treturn ;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tdev_notice(&instance->pdev->dev, \"FW detected to be in fault\"\n\t\t\t\t\t\"state, restarting it...\\n\");\n\n\t\tinstance->instancet->disable_intr(instance);\n\t\tatomic_set(&instance->fw_outstanding, 0);\n\n\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\tinstance->instancet->adp_reset(instance, instance->reg_set);\n\t\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t\tdev_notice(&instance->pdev->dev, \"FW restarted successfully,\"\n\t\t\t\t\t\"initiating next stage...\\n\");\n\n\t\tdev_notice(&instance->pdev->dev, \"HBA recovery state machine,\"\n\t\t\t\t\t\"state 2 starting...\\n\");\n\n\t\t/* waiting for about 20 second before start the second init */\n\t\tfor (wait = 0; wait < 30; wait++) {\n\t\t\tmsleep(1000);\n\t\t}\n\n\t\tif (megasas_transition_to_ready(instance, 1)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"adapter not ready\\n\");\n\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\treturn ;\n\t\t}\n\n\t\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\n\t\t\t(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\n\t\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)\n\t\t\t) {\n\t\t\t*instance->consumer = *instance->producer;\n\t\t} else {\n\t\t\t*instance->consumer = 0;\n\t\t\t*instance->producer = 0;\n\t\t}\n\n\t\tmegasas_issue_init_mfi(instance);\n\n\t\tspin_lock_irqsave(&instance->hba_lock, flags);\n\t\tatomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n\t\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\t\tinstance->instancet->enable_intr(instance);\n\n\t\tmegasas_issue_pending_cmds_again(instance);\n\t\tinstance->issuepend_done = 1;\n\t}\n}\n\n/**\n * megasas_deplete_reply_queue -\tProcesses all completed commands\n * @instance:\t\t\t\tAdapter soft state\n * @alt_status:\t\t\t\tAlternate status to be returned to\n *\t\t\t\t\tSCSI mid-layer instead of the status\n *\t\t\t\t\treturned by the FW\n * Note: this must be called with hba lock held\n */\nstatic int\nmegasas_deplete_reply_queue(struct megasas_instance *instance,\n\t\t\t\t\tu8 alt_status)\n{\n\tu32 mfiStatus;\n\tu32 fw_state;\n\n\tif ((mfiStatus = instance->instancet->check_reset(instance,\n\t\t\t\t\tinstance->reg_set)) == 1) {\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmfiStatus = instance->instancet->clear_intr(instance);\n\tif (mfiStatus == 0) {\n\t\t/* Hardware may not set outbound_intr_status in MSI-X mode */\n\t\tif (!instance->msix_vectors)\n\t\t\treturn IRQ_NONE;\n\t}\n\n\tinstance->mfiStatus = mfiStatus;\n\n\tif ((mfiStatus & MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE)) {\n\t\tfw_state = instance->instancet->read_fw_status_reg(\n\t\t\t\tinstance) & MFI_STATE_MASK;\n\n\t\tif (fw_state != MFI_STATE_FAULT) {\n\t\t\tdev_notice(&instance->pdev->dev, \"fw state:%x\\n\",\n\t\t\t\t\t\tfw_state);\n\t\t}\n\n\t\tif ((fw_state == MFI_STATE_FAULT) &&\n\t\t\t\t(instance->disableOnlineCtrlReset == 0)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"wait adp restart\\n\");\n\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_LSI_SAS1064R) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_DELL_PERC5) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_LSI_VERDE_ZCR)) {\n\n\t\t\t\t*instance->consumer =\n\t\t\t\t\tcpu_to_le32(MEGASAS_ADPRESET_INPROG_SIGN);\n\t\t\t}\n\n\n\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\n\t\t\tinstance->issuepend_done = 0;\n\n\t\t\tatomic_set(&instance->fw_outstanding, 0);\n\t\t\tmegasas_internal_reset_defer_cmds(instance);\n\n\t\t\tdev_notice(&instance->pdev->dev, \"fwState=%x, stage:%d\\n\",\n\t\t\t\t\tfw_state, atomic_read(&instance->adprecovery));\n\n\t\t\tschedule_work(&instance->work_init);\n\t\t\treturn IRQ_HANDLED;\n\n\t\t} else {\n\t\t\tdev_notice(&instance->pdev->dev, \"fwstate:%x, dis_OCR=%x\\n\",\n\t\t\t\tfw_state, instance->disableOnlineCtrlReset);\n\t\t}\n\t}\n\n\ttasklet_schedule(&instance->isr_tasklet);\n\treturn IRQ_HANDLED;\n}\n/**\n * megasas_isr - isr entry point\n */\nstatic irqreturn_t megasas_isr(int irq, void *devp)\n{\n\tstruct megasas_irq_context *irq_context = devp;\n\tstruct megasas_instance *instance = irq_context->instance;\n\tunsigned long flags;\n\tirqreturn_t rc;\n\n\tif (atomic_read(&instance->fw_reset_no_pci_access))\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\trc = megasas_deplete_reply_queue(instance, DID_OK);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\treturn rc;\n}\n\n/**\n * megasas_transition_to_ready -\tMove the FW to READY state\n * @instance:\t\t\t\tAdapter soft state\n *\n * During the initialization, FW passes can potentially be in any one of\n * several possible states. If the FW in operational, waiting-for-handshake\n * states, driver must take steps to bring it to ready state. Otherwise, it\n * has to wait for the ready state.\n */\nint\nmegasas_transition_to_ready(struct megasas_instance *instance, int ocr)\n{\n\tint i;\n\tu8 max_wait;\n\tu32 fw_state;\n\tu32 cur_state;\n\tu32 abs_state, curr_abs_state;\n\n\tabs_state = instance->instancet->read_fw_status_reg(instance);\n\tfw_state = abs_state & MFI_STATE_MASK;\n\n\tif (fw_state != MFI_STATE_READY)\n\t\tdev_info(&instance->pdev->dev, \"Waiting for FW to come to ready\"\n\t\t       \" state\\n\");\n\n\twhile (fw_state != MFI_STATE_READY) {\n\n\t\tswitch (fw_state) {\n\n\t\tcase MFI_STATE_FAULT:\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"FW in FAULT state!!\\n\");\n\t\t\tif (ocr) {\n\t\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\t\tcur_state = MFI_STATE_FAULT;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treturn -ENODEV;\n\n\t\tcase MFI_STATE_WAIT_HANDSHAKE:\n\t\t\t/*\n\t\t\t * Set the CLR bit in inbound doorbell\n\t\t\t */\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES))\n\t\t\t\twritel(\n\t\t\t\t  MFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\n\t\t\t\t  &instance->reg_set->doorbell);\n\t\t\telse\n\t\t\t\twritel(\n\t\t\t\t    MFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_WAIT_HANDSHAKE;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_BOOT_MESSAGE_PENDING:\n\t\t\tif ((instance->pdev->device ==\n\t\t\t     PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES))\n\t\t\t\twritel(MFI_INIT_HOTPLUG,\n\t\t\t\t       &instance->reg_set->doorbell);\n\t\t\telse\n\t\t\t\twritel(MFI_INIT_HOTPLUG,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_BOOT_MESSAGE_PENDING;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_OPERATIONAL:\n\t\t\t/*\n\t\t\t * Bring it to READY state; assuming max wait 10 secs\n\t\t\t */\n\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0071SKINNY)  ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES)) {\n\t\t\t\twritel(MFI_RESET_FLAGS,\n\t\t\t\t\t&instance->reg_set->doorbell);\n\n\t\t\t\tif (instance->adapter_type != MFI_SERIES) {\n\t\t\t\t\tfor (i = 0; i < (10 * 1000); i += 20) {\n\t\t\t\t\t\tif (megasas_readl(\n\t\t\t\t\t\t\t    instance,\n\t\t\t\t\t\t\t    &instance->\n\t\t\t\t\t\t\t    reg_set->\n\t\t\t\t\t\t\t    doorbell) & 1)\n\t\t\t\t\t\t\tmsleep(20);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\twritel(MFI_RESET_FLAGS,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_OPERATIONAL;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_UNDEFINED:\n\t\t\t/*\n\t\t\t * This state should not last for more than 2 seconds\n\t\t\t */\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_UNDEFINED;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_BB_INIT:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_BB_INIT;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FW_INIT:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_FW_INIT;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FW_INIT_2:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_FW_INIT_2;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_DEVICE_SCAN:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_DEVICE_SCAN;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FLUSH_CACHE:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_FLUSH_CACHE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Unknown state 0x%x\\n\",\n\t\t\t       fw_state);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/*\n\t\t * The cur_state should not last for more than max_wait secs\n\t\t */\n\t\tfor (i = 0; i < max_wait; i++) {\n\t\t\tcurr_abs_state = instance->instancet->\n\t\t\t\tread_fw_status_reg(instance);\n\n\t\t\tif (abs_state == curr_abs_state) {\n\t\t\t\tmsleep(1000);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Return error if fw_state hasn't changed after max_wait\n\t\t */\n\t\tif (curr_abs_state == abs_state) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"FW state [%d] hasn't changed \"\n\t\t\t       \"in %d secs\\n\", fw_state, max_wait);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tabs_state = curr_abs_state;\n\t\tfw_state = curr_abs_state & MFI_STATE_MASK;\n\t}\n\tdev_info(&instance->pdev->dev, \"FW now in Ready state\\n\");\n\n\treturn 0;\n}\n\n/**\n * megasas_teardown_frame_pool -\tDestroy the cmd frame DMA pool\n * @instance:\t\t\t\tAdapter soft state\n */\nstatic void megasas_teardown_frame_pool(struct megasas_instance *instance)\n{\n\tint i;\n\tu16 max_cmd = instance->max_mfi_cmds;\n\tstruct megasas_cmd *cmd;\n\n\tif (!instance->frame_dma_pool)\n\t\treturn;\n\n\t/*\n\t * Return all frames to pool\n\t */\n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tif (cmd->frame)\n\t\t\tdma_pool_free(instance->frame_dma_pool, cmd->frame,\n\t\t\t\t      cmd->frame_phys_addr);\n\n\t\tif (cmd->sense)\n\t\t\tdma_pool_free(instance->sense_dma_pool, cmd->sense,\n\t\t\t\t      cmd->sense_phys_addr);\n\t}\n\n\t/*\n\t * Now destroy the pool itself\n\t */\n\tdma_pool_destroy(instance->frame_dma_pool);\n\tdma_pool_destroy(instance->sense_dma_pool);\n\n\tinstance->frame_dma_pool = NULL;\n\tinstance->sense_dma_pool = NULL;\n}\n\n/**\n * megasas_create_frame_pool -\tCreates DMA pool for cmd frames\n * @instance:\t\t\tAdapter soft state\n *\n * Each command packet has an embedded DMA memory buffer that is used for\n * filling MFI frame and the SG list that immediately follows the frame. This\n * function creates those DMA memory buffers for each command packet by using\n * PCI pool facility.\n */\nstatic int megasas_create_frame_pool(struct megasas_instance *instance)\n{\n\tint i;\n\tu16 max_cmd;\n\tu32 sge_sz;\n\tu32 frame_count;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * Size of our frame is 64 bytes for MFI frame, followed by max SG\n\t * elements and finally SCSI_SENSE_BUFFERSIZE bytes for sense buffer\n\t */\n\tsge_sz = (IS_DMA64) ? sizeof(struct megasas_sge64) :\n\t    sizeof(struct megasas_sge32);\n\n\tif (instance->flag_ieee)\n\t\tsge_sz = sizeof(struct megasas_sge_skinny);\n\n\t/*\n\t * For MFI controllers.\n\t * max_num_sge = 60\n\t * max_sge_sz  = 16 byte (sizeof megasas_sge_skinny)\n\t * Total 960 byte (15 MFI frame of 64 byte)\n\t *\n\t * Fusion adapter require only 3 extra frame.\n\t * max_num_sge = 16 (defined as MAX_IOCTL_SGE)\n\t * max_sge_sz  = 12 byte (sizeof  megasas_sge64)\n\t * Total 192 byte (3 MFI frame of 64 byte)\n\t */\n\tframe_count = (instance->adapter_type == MFI_SERIES) ?\n\t\t\t(15 + 1) : (3 + 1);\n\tinstance->mfi_frame_size = MEGAMFI_FRAME_SIZE * frame_count;\n\t/*\n\t * Use DMA pool facility provided by PCI layer\n\t */\n\tinstance->frame_dma_pool = dma_pool_create(\"megasas frame pool\",\n\t\t\t\t\t&instance->pdev->dev,\n\t\t\t\t\tinstance->mfi_frame_size, 256, 0);\n\n\tif (!instance->frame_dma_pool) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"failed to setup frame pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->sense_dma_pool = dma_pool_create(\"megasas sense pool\",\n\t\t\t\t\t\t   &instance->pdev->dev, 128,\n\t\t\t\t\t\t   4, 0);\n\n\tif (!instance->sense_dma_pool) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"failed to setup sense pool\\n\");\n\n\t\tdma_pool_destroy(instance->frame_dma_pool);\n\t\tinstance->frame_dma_pool = NULL;\n\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Allocate and attach a frame to each of the commands in cmd_list.\n\t * By making cmd->index as the context instead of the &cmd, we can\n\t * always use 32bit context regardless of the architecture\n\t */\n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tcmd->frame = dma_pool_zalloc(instance->frame_dma_pool,\n\t\t\t\t\t    GFP_KERNEL, &cmd->frame_phys_addr);\n\n\t\tcmd->sense = dma_pool_alloc(instance->sense_dma_pool,\n\t\t\t\t\t    GFP_KERNEL, &cmd->sense_phys_addr);\n\n\t\t/*\n\t\t * megasas_teardown_frame_pool() takes care of freeing\n\t\t * whatever has been allocated\n\t\t */\n\t\tif (!cmd->frame || !cmd->sense) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"dma_pool_alloc failed\\n\");\n\t\t\tmegasas_teardown_frame_pool(instance);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcmd->frame->io.context = cpu_to_le32(cmd->index);\n\t\tcmd->frame->io.pad_0 = 0;\n\t\tif ((instance->adapter_type == MFI_SERIES) && reset_devices)\n\t\t\tcmd->frame->hdr.cmd = MFI_CMD_INVALID;\n\t}\n\n\treturn 0;\n}\n\n/**\n * megasas_free_cmds -\tFree all the cmds in the free cmd pool\n * @instance:\t\tAdapter soft state\n */\nvoid megasas_free_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\n\t/* First free the MFI frame pool */\n\tmegasas_teardown_frame_pool(instance);\n\n\t/* Free all the commands in the cmd_list */\n\tfor (i = 0; i < instance->max_mfi_cmds; i++)\n\n\t\tkfree(instance->cmd_list[i]);\n\n\t/* Free the cmd_list buffer itself */\n\tkfree(instance->cmd_list);\n\tinstance->cmd_list = NULL;\n\n\tINIT_LIST_HEAD(&instance->cmd_pool);\n}\n\n/**\n * megasas_alloc_cmds -\tAllocates the command packets\n * @instance:\t\tAdapter soft state\n *\n * Each command that is issued to the FW, whether IO commands from the OS or\n * internal commands like IOCTLs, are wrapped in local data structure called\n * megasas_cmd. The frame embedded in this megasas_cmd is actually issued to\n * the FW.\n *\n * Each frame has a 32-bit field called context (tag). This context is used\n * to get back the megasas_cmd from the frame when a frame gets completed in\n * the ISR. Typically the address of the megasas_cmd itself would be used as\n * the context. But we wanted to keep the differences between 32 and 64 bit\n * systems to the mininum. We always use 32 bit integers for the context. In\n * this driver, the 32 bit values are the indices into an array cmd_list.\n * This array is used only to look up the megasas_cmd given the context. The\n * free commands themselves are maintained in a linked list called cmd_pool.\n */\nint megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * instance->cmd_list is an array of struct megasas_cmd pointers.\n\t * Allocate the dynamic array first and then allocate individual\n\t * commands.\n\t */\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->cmd_list[i]) {\n\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\n\t/*\n\t * Create a frame pool and assign one frame to each cmd\n\t */\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t}\n\n\treturn 0;\n}\n\n/*\n * dcmd_timeout_ocr_possible -\tCheck if OCR is possible based on Driver/FW state.\n * @instance:\t\t\t\tAdapter soft state\n *\n * Return 0 for only Fusion adapter, if driver load/unload is not in progress\n * or FW is not under OCR.\n */\ninline int\ndcmd_timeout_ocr_possible(struct megasas_instance *instance) {\n\n\tif (instance->adapter_type == MFI_SERIES)\n\t\treturn KILL_ADAPTER;\n\telse if (instance->unload ||\n\t\t\ttest_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags))\n\t\treturn IGNORE_TIMEOUT;\n\telse\n\t\treturn INITIATE_OCR;\n}\n\nstatic void\nmegasas_get_pd_info(struct megasas_instance *instance, struct scsi_device *sdev)\n{\n\tint ret;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tu16 device_id = 0;\n\n\tdevice_id = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) + sdev->id;\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to get cmd %s\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->pd_info, 0, sizeof(*instance->pd_info));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.s[0] = cpu_to_le16(device_id);\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_PD_INFO));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_PD_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->pd_info_h,\n\t\t\t\t sizeof(struct MR_PD_INFO));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\tmr_device_priv_data = sdev->hostdata;\n\t\tle16_to_cpus((u16 *)&instance->pd_info->state.ddf.pdType);\n\t\tmr_device_priv_data->interface_type =\n\t\t\t\tinstance->pd_info->state.ddf.pdType.intf;\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn;\n}\n/*\n * megasas_get_pd_list_info -\tReturns FW's pd_list structure\n * @instance:\t\t\t\tAdapter soft state\n * @pd_list:\t\t\t\tpd_list structure\n *\n * Issues an internal command (DCMD) to get the FW's controller PD\n * list structure.  This information is mainly used to find out SYSTEM\n * supported by the FW.\n */\nstatic int\nmegasas_get_pd_list(struct megasas_instance *instance)\n{\n\tint ret = 0, pd_index = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_PD_LIST *ci;\n\tstruct MR_PD_ADDRESS *pd_addr;\n\tdma_addr_t ci_h = 0;\n\n\tif (instance->pd_list_not_supported) {\n\t\tdev_info(&instance->pdev->dev, \"MR_DCMD_PD_LIST_QUERY \"\n\t\t\"not supported by firmware\\n\");\n\t\treturn ret;\n\t}\n\n\tci = instance->pd_list_buf;\n\tci_h = instance->pd_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"(get_pd_list): Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = MR_PD_QUERY_TYPE_EXPOSED_TO_HOST;\n\tdcmd->mbox.b[1] = 0;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_PD_LIST_QUERY);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->pd_list_buf_h,\n\t\t\t\t (MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST)));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tdev_info(&instance->pdev->dev, \"MR_DCMD_PD_LIST_QUERY \"\n\t\t\t\"failed/not supported by firmware\\n\");\n\n\t\tif (instance->adapter_type != MFI_SERIES)\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\telse\n\t\t\tinstance->pd_list_not_supported = 1;\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d \\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase DCMD_SUCCESS:\n\t\tpd_addr = ci->addr;\n\n\t\tif ((le32_to_cpu(ci->count) >\n\t\t\t(MEGASAS_MAX_PD_CHANNELS * MEGASAS_MAX_DEV_PER_CHANNEL)))\n\t\t\tbreak;\n\n\t\tmemset(instance->local_pd_list, 0,\n\t\t\t\tMEGASAS_MAX_PD * sizeof(struct megasas_pd_list));\n\n\t\tfor (pd_index = 0; pd_index < le32_to_cpu(ci->count); pd_index++) {\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].tid\t=\n\t\t\t\t\tle16_to_cpu(pd_addr->deviceId);\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveType\t=\n\t\t\t\t\tpd_addr->scsiDevType;\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveState\t=\n\t\t\t\t\tMR_PD_STATE_SYSTEM;\n\t\t\tpd_addr++;\n\t\t}\n\n\t\tmemcpy(instance->pd_list, instance->local_pd_list,\n\t\t\tsizeof(instance->pd_list));\n\t\tbreak;\n\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/*\n * megasas_get_ld_list_info -\tReturns FW's ld_list structure\n * @instance:\t\t\t\tAdapter soft state\n * @ld_list:\t\t\t\tld_list structure\n *\n * Issues an internal command (DCMD) to get the FW's controller PD\n * list structure.  This information is mainly used to find out SYSTEM\n * supported by the FW.\n */\nstatic int\nmegasas_get_ld_list(struct megasas_instance *instance)\n{\n\tint ret = 0, ld_index = 0, ids = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_LIST *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 ld_count;\n\n\tci = instance->ld_list_buf;\n\tci_h = instance->ld_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_list: Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tif (instance->supportmax256vd)\n\t\tdcmd->mbox.b[0] = 1;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_GET_LIST);\n\tdcmd->pad_0  = 0;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_LD_LIST));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tld_count = le32_to_cpu(ci->ldCount);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tmegaraid_sas_kill_hba(instance);\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase DCMD_SUCCESS:\n\t\tif (ld_count > instance->fw_supported_vd_count)\n\t\t\tbreak;\n\n\t\tmemset(instance->ld_ids, 0xff, MAX_LOGICAL_DRIVES_EXT);\n\n\t\tfor (ld_index = 0; ld_index < ld_count; ld_index++) {\n\t\t\tif (ci->ldList[ld_index].state != 0) {\n\t\t\t\tids = ci->ldList[ld_index].ref.targetId;\n\t\t\t\tinstance->ld_ids[ids] = ci->ldList[ld_index].ref.targetId;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * megasas_ld_list_query -\tReturns FW's ld_list structure\n * @instance:\t\t\t\tAdapter soft state\n * @ld_list:\t\t\t\tld_list structure\n *\n * Issues an internal command (DCMD) to get the FW's controller PD\n * list structure.  This information is mainly used to find out SYSTEM\n * supported by the FW.\n */\nstatic int\nmegasas_ld_list_query(struct megasas_instance *instance, u8 query_type)\n{\n\tint ret = 0, ld_index = 0, ids = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_TARGETID_LIST *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 tgtid_count;\n\n\tci = instance->ld_targetid_list_buf;\n\tci_h = instance->ld_targetid_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t         \"megasas_ld_list_query: Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = query_type;\n\tif (instance->supportmax256vd)\n\t\tdcmd->mbox.b[2] = 1;\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_TARGETID_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_LIST_QUERY);\n\tdcmd->pad_0  = 0;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_LD_TARGETID_LIST));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"DCMD not supported by firmware - %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\tret = megasas_get_ld_list(instance);\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase DCMD_SUCCESS:\n\t\ttgtid_count = le32_to_cpu(ci->count);\n\n\t\tif ((tgtid_count > (instance->fw_supported_vd_count)))\n\t\t\tbreak;\n\n\t\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\t\tfor (ld_index = 0; ld_index < tgtid_count; ld_index++) {\n\t\t\tids = ci->targetId[ld_index];\n\t\t\tinstance->ld_ids[ids] = ci->targetId[ld_index];\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * dcmd.opcode            - MR_DCMD_CTRL_DEVICE_LIST_GET\n * dcmd.mbox              - reserved\n * dcmd.sge IN            - ptr to return MR_HOST_DEVICE_LIST structure\n * Desc:    This DCMD will return the combined device list\n * Status:  MFI_STAT_OK - List returned successfully\n *          MFI_STAT_INVALID_CMD - Firmware support for the feature has been\n *                                 disabled\n * @instance:\t\t\tAdapter soft state\n * @is_probe:\t\t\tDriver probe check\n * Return:\t\t\t0 if DCMD succeeded\n *\t\t\t\t non-zero if failed\n */\nint\nmegasas_host_device_list_query(struct megasas_instance *instance,\n\t\t\t       bool is_probe)\n{\n\tint ret, i, target_id;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_HOST_DEVICE_LIST *ci;\n\tu32 count;\n\tdma_addr_t ci_h;\n\n\tci = instance->host_device_list_buf;\n\tci_h = instance->host_device_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t \"%s: failed to get cmd\\n\",\n\t\t\t __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = is_probe ? 0 : 1;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(HOST_DEVICE_LIST_SZ);\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_DEVICE_LIST_GET);\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h, HOST_DEVICE_LIST_SZ);\n\n\tif (!instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\t/* Fill the internal pd_list and ld_ids array based on\n\t\t * targetIds returned by FW\n\t\t */\n\t\tcount = le32_to_cpu(ci->count);\n\n\t\tmemset(instance->local_pd_list, 0,\n\t\t       MEGASAS_MAX_PD * sizeof(struct megasas_pd_list));\n\t\tmemset(instance->ld_ids, 0xff, MAX_LOGICAL_DRIVES_EXT);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\ttarget_id = le16_to_cpu(ci->host_device_list[i].target_id);\n\t\t\tif (ci->host_device_list[i].flags.u.bits.is_sys_pd) {\n\t\t\t\tinstance->local_pd_list[target_id].tid = target_id;\n\t\t\t\tinstance->local_pd_list[target_id].driveType =\n\t\t\t\t\t\tci->host_device_list[i].scsi_type;\n\t\t\t\tinstance->local_pd_list[target_id].driveState =\n\t\t\t\t\t\tMR_PD_STATE_SYSTEM;\n\t\t\t} else {\n\t\t\t\tinstance->ld_ids[target_id] = target_id;\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(instance->pd_list, instance->local_pd_list,\n\t\t       sizeof(instance->pd_list));\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t __func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DCMD_FAILED:\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"%s: MR_DCMD_CTRL_DEVICE_LIST_GET failed\\n\",\n\t\t\t__func__);\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/*\n * megasas_update_ext_vd_details : Update details w.r.t Extended VD\n * instance\t\t\t : Controller's instance\n*/\nstatic void megasas_update_ext_vd_details(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\tu32 ventura_map_sz = 0;\n\n\tfusion = instance->ctrl_context;\n\t/* For MFI based controllers return dummy success */\n\tif (!fusion)\n\t\treturn;\n\n\tinstance->supportmax256vd =\n\t\tinstance->ctrl_info_buf->adapterOperations3.supportMaxExtLDs;\n\t/* Below is additional check to address future FW enhancement */\n\tif (instance->ctrl_info_buf->max_lds > 64)\n\t\tinstance->supportmax256vd = 1;\n\n\tinstance->drv_supported_vd_count = MEGASAS_MAX_LD_CHANNELS\n\t\t\t\t\t* MEGASAS_MAX_DEV_PER_CHANNEL;\n\tinstance->drv_supported_pd_count = MEGASAS_MAX_PD_CHANNELS\n\t\t\t\t\t* MEGASAS_MAX_DEV_PER_CHANNEL;\n\tif (instance->supportmax256vd) {\n\t\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES_EXT;\n\t\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t} else {\n\t\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES;\n\t\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"FW provided supportMaxExtLDs: %d\\tmax_lds: %d\\n\",\n\t\tinstance->ctrl_info_buf->adapterOperations3.supportMaxExtLDs ? 1 : 0,\n\t\tinstance->ctrl_info_buf->max_lds);\n\n\tif (instance->max_raid_mapsize) {\n\t\tventura_map_sz = instance->max_raid_mapsize *\n\t\t\t\t\t\tMR_MIN_MAP_SIZE; /* 64k */\n\t\tfusion->current_map_sz = ventura_map_sz;\n\t\tfusion->max_map_sz = ventura_map_sz;\n\t} else {\n\t\tfusion->old_map_sz =  sizeof(struct MR_FW_RAID_MAP) +\n\t\t\t\t\t(sizeof(struct MR_LD_SPAN_MAP) *\n\t\t\t\t\t(instance->fw_supported_vd_count - 1));\n\t\tfusion->new_map_sz =  sizeof(struct MR_FW_RAID_MAP_EXT);\n\n\t\tfusion->max_map_sz =\n\t\t\tmax(fusion->old_map_sz, fusion->new_map_sz);\n\n\t\tif (instance->supportmax256vd)\n\t\t\tfusion->current_map_sz = fusion->new_map_sz;\n\t\telse\n\t\t\tfusion->current_map_sz = fusion->old_map_sz;\n\t}\n\t/* irrespective of FW raid maps, driver raid map is constant */\n\tfusion->drv_map_sz = sizeof(struct MR_DRV_RAID_MAP_ALL);\n}\n\n/*\n * dcmd.opcode                - MR_DCMD_CTRL_SNAPDUMP_GET_PROPERTIES\n * dcmd.hdr.length            - number of bytes to read\n * dcmd.sge                   - Ptr to MR_SNAPDUMP_PROPERTIES\n * Desc:\t\t\t Fill in snapdump properties\n * Status:\t\t\t MFI_STAT_OK- Command successful\n */\nvoid megasas_get_snapdump_properties(struct megasas_instance *instance)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_SNAPDUMP_PROPERTIES *ci;\n\tdma_addr_t ci_h = 0;\n\n\tci = instance->snapdump_prop;\n\tci_h = instance->snapdump_prop_h;\n\n\tif (!ci)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_dbg(&instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_SNAPDUMP_PROPERTIES));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SNAPDUMP_GET_PROPERTIES);\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_SNAPDUMP_PROPERTIES));\n\n\tif (!instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\tinstance->snapdump_wait_time =\n\t\t\tmin_t(u8, ci->trigger_min_num_sec_before_ocr,\n\t\t\t\tMEGASAS_MAX_SNAP_DUMP_WAIT_TIME);\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n}\n\n/**\n * megasas_get_controller_info -\tReturns FW's controller structure\n * @instance:\t\t\t\tAdapter soft state\n *\n * Issues an internal command (DCMD) to get the FW's controller structure.\n * This information is mainly used to find out the maximum IO transfer per\n * command supported by the FW.\n */\nint\nmegasas_get_ctrl_info(struct megasas_instance *instance)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct megasas_ctrl_info *ci;\n\tdma_addr_t ci_h = 0;\n\n\tci = instance->ctrl_info_buf;\n\tci_h = instance->ctrl_info_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_ctrl_info));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_GET_INFO);\n\tdcmd->mbox.b[0] = 1;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct megasas_ctrl_info));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\t/* Save required controller information in\n\t\t * CPU endianness format.\n\t\t */\n\t\tle32_to_cpus((u32 *)&ci->properties.OnOffProperties);\n\t\tle16_to_cpus((u16 *)&ci->properties.on_off_properties2);\n\t\tle32_to_cpus((u32 *)&ci->adapterOperations2);\n\t\tle32_to_cpus((u32 *)&ci->adapterOperations3);\n\t\tle16_to_cpus((u16 *)&ci->adapter_operations4);\n\n\t\t/* Update the latest Ext VD info.\n\t\t * From Init path, store current firmware details.\n\t\t * From OCR path, detect any firmware properties changes.\n\t\t * in case of Firmware upgrade without system reboot.\n\t\t */\n\t\tmegasas_update_ext_vd_details(instance);\n\t\tinstance->use_seqnum_jbod_fp =\n\t\t\tci->adapterOperations3.useSeqNumJbodFP;\n\t\tinstance->support_morethan256jbod =\n\t\t\tci->adapter_operations4.support_pd_map_target_id;\n\t\tinstance->support_nvme_passthru =\n\t\t\tci->adapter_operations4.support_nvme_passthru;\n\t\tinstance->task_abort_tmo = ci->TaskAbortTO;\n\t\tinstance->max_reset_tmo = ci->MaxResetTO;\n\n\t\t/*Check whether controller is iMR or MR */\n\t\tinstance->is_imr = (ci->memory_size ? 0 : 1);\n\n\t\tinstance->snapdump_wait_time =\n\t\t\t(ci->properties.on_off_properties2.enable_snap_dump ?\n\t\t\t MEGASAS_DEFAULT_SNAP_DUMP_WAIT_TIME : 0);\n\n\t\tinstance->enable_fw_dev_list =\n\t\t\tci->properties.on_off_properties2.enable_fw_dev_list;\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"controller type\\t: %s(%dMB)\\n\",\n\t\t\tinstance->is_imr ? \"iMR\" : \"MR\",\n\t\t\tle16_to_cpu(ci->memory_size));\n\n\t\tinstance->disableOnlineCtrlReset =\n\t\t\tci->properties.OnOffProperties.disableOnlineCtrlReset;\n\t\tinstance->secure_jbod_support =\n\t\t\tci->adapterOperations3.supportSecurityonJBOD;\n\t\tdev_info(&instance->pdev->dev, \"Online Controller Reset(OCR)\\t: %s\\n\",\n\t\t\tinstance->disableOnlineCtrlReset ? \"Disabled\" : \"Enabled\");\n\t\tdev_info(&instance->pdev->dev, \"Secure JBOD support\\t: %s\\n\",\n\t\t\tinstance->secure_jbod_support ? \"Yes\" : \"No\");\n\t\tdev_info(&instance->pdev->dev, \"NVMe passthru support\\t: %s\\n\",\n\t\t\t instance->support_nvme_passthru ? \"Yes\" : \"No\");\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"FW provided TM TaskAbort/Reset timeout\\t: %d secs/%d secs\\n\",\n\t\t\t instance->task_abort_tmo, instance->max_reset_tmo);\n\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DCMD_FAILED:\n\t\tmegaraid_sas_kill_hba(instance);\n\t\tbreak;\n\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/*\n * megasas_set_crash_dump_params -\tSends address of crash dump DMA buffer\n *\t\t\t\t\tto firmware\n *\n * @instance:\t\t\t\tAdapter soft state\n * @crash_buf_state\t\t-\ttell FW to turn ON/OFF crash dump feature\n\t\t\t\t\tMR_CRASH_BUF_TURN_OFF = 0\n\t\t\t\t\tMR_CRASH_BUF_TURN_ON = 1\n * @return 0 on success non-zero on failure.\n * Issues an internal command (DCMD) to set parameters for crash dump feature.\n * Driver will send address of crash dump DMA buffer and set mbox to tell FW\n * that driver supports crash dump feature. This DCMD will be sent only if\n * crash dump feature is supported by the FW.\n *\n */\nint megasas_set_crash_dump_params(struct megasas_instance *instance,\n\tu8 crash_buf_state)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\tdcmd->mbox.b[0] = crash_buf_state;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_NONE;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(CRASH_DMA_BUF_SIZE);\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SET_CRASH_DUMP_PARAMS);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->crash_dump_h,\n\t\t\t\t CRASH_DMA_BUF_SIZE);\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tif (ret == DCMD_TIMEOUT) {\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * megasas_issue_init_mfi -\tInitializes the FW\n * @instance:\t\tAdapter soft state\n *\n * Issues the INIT MFI cmd\n */\nstatic int\nmegasas_issue_init_mfi(struct megasas_instance *instance)\n{\n\t__le32 context;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_init_frame *init_frame;\n\tstruct megasas_init_queue_info *initq_info;\n\tdma_addr_t init_frame_h;\n\tdma_addr_t initq_info_h;\n\n\t/*\n\t * Prepare a init frame. Note the init frame points to queue info\n\t * structure. Each frame has SGL allocated after first 64 bytes. For\n\t * this frame - since we don't need any SGL - we use SGL's space as\n\t * queue info structure\n\t *\n\t * We will not get a NULL command below. We just created the pool.\n\t */\n\tcmd = megasas_get_cmd(instance);\n\n\tinit_frame = (struct megasas_init_frame *)cmd->frame;\n\tinitq_info = (struct megasas_init_queue_info *)\n\t\t((unsigned long)init_frame + 64);\n\n\tinit_frame_h = cmd->frame_phys_addr;\n\tinitq_info_h = init_frame_h + 64;\n\n\tcontext = init_frame->context;\n\tmemset(init_frame, 0, MEGAMFI_FRAME_SIZE);\n\tmemset(initq_info, 0, sizeof(struct megasas_init_queue_info));\n\tinit_frame->context = context;\n\n\tinitq_info->reply_queue_entries = cpu_to_le32(instance->max_fw_cmds + 1);\n\tinitq_info->reply_queue_start_phys_addr_lo = cpu_to_le32(instance->reply_queue_h);\n\n\tinitq_info->producer_index_phys_addr_lo = cpu_to_le32(instance->producer_h);\n\tinitq_info->consumer_index_phys_addr_lo = cpu_to_le32(instance->consumer_h);\n\n\tinit_frame->cmd = MFI_CMD_INIT;\n\tinit_frame->cmd_status = MFI_STAT_INVALID_STATUS;\n\tinit_frame->queue_info_new_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(initq_info_h));\n\tinit_frame->queue_info_new_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(initq_info_h));\n\n\tinit_frame->data_xfer_len = cpu_to_le32(sizeof(struct megasas_init_queue_info));\n\n\t/*\n\t * disable the intr before firing the init frame to FW\n\t */\n\tinstance->instancet->disable_intr(instance);\n\n\t/*\n\t * Issue the init frame in polled mode\n\t */\n\n\tif (megasas_issue_polled(instance, cmd)) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to init firmware\\n\");\n\t\tmegasas_return_cmd(instance, cmd);\n\t\tgoto fail_fw_init;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn 0;\n\nfail_fw_init:\n\treturn -EINVAL;\n}\n\nstatic u32\nmegasas_init_adapter_mfi(struct megasas_instance *instance)\n{\n\tu32 context_sz;\n\tu32 reply_q_sz;\n\n\t/*\n\t * Get various operational parameters from status register\n\t */\n\tinstance->max_fw_cmds = instance->instancet->read_fw_status_reg(instance) & 0x00FFFF;\n\t/*\n\t * Reduce the max supported cmds by 1. This is to ensure that the\n\t * reply_q_sz (1 more than the max cmd that driver may send)\n\t * does not exceed max cmds that the FW can support\n\t */\n\tinstance->max_fw_cmds = instance->max_fw_cmds-1;\n\tinstance->max_mfi_cmds = instance->max_fw_cmds;\n\tinstance->max_num_sge = (instance->instancet->read_fw_status_reg(instance) & 0xFF0000) >>\n\t\t\t\t\t0x10;\n\t/*\n\t * For MFI skinny adapters, MEGASAS_SKINNY_INT_CMDS commands\n\t * are reserved for IOCTL + driver's internal DCMDs.\n\t */\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY)) {\n\t\tinstance->max_scsi_cmds = (instance->max_fw_cmds -\n\t\t\tMEGASAS_SKINNY_INT_CMDS);\n\t\tsema_init(&instance->ioctl_sem, MEGASAS_SKINNY_INT_CMDS);\n\t} else {\n\t\tinstance->max_scsi_cmds = (instance->max_fw_cmds -\n\t\t\tMEGASAS_INT_CMDS);\n\t\tsema_init(&instance->ioctl_sem, (MEGASAS_MFI_IOCTL_CMDS));\n\t}\n\n\tinstance->cur_can_queue = instance->max_scsi_cmds;\n\t/*\n\t * Create a pool of commands\n\t */\n\tif (megasas_alloc_cmds(instance))\n\t\tgoto fail_alloc_cmds;\n\n\t/*\n\t * Allocate memory for reply queue. Length of reply queue should\n\t * be _one_ more than the maximum commands handled by the firmware.\n\t *\n\t * Note: When FW completes commands, it places corresponding contex\n\t * values in this circular reply queue. This circular queue is a fairly\n\t * typical producer-consumer queue. FW is the producer (of completed\n\t * commands) and the driver is the consumer.\n\t */\n\tcontext_sz = sizeof(u32);\n\treply_q_sz = context_sz * (instance->max_fw_cmds + 1);\n\n\tinstance->reply_queue = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\treply_q_sz, &instance->reply_queue_h, GFP_KERNEL);\n\n\tif (!instance->reply_queue) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Out of DMA mem for reply queue\\n\");\n\t\tgoto fail_reply_queue;\n\t}\n\n\tif (megasas_issue_init_mfi(instance))\n\t\tgoto fail_fw_init;\n\n\tif (megasas_get_ctrl_info(instance)) {\n\t\tdev_err(&instance->pdev->dev, \"(%d): Could get controller info \"\n\t\t\t\"Fail from %s %d\\n\", instance->unique_id,\n\t\t\t__func__, __LINE__);\n\t\tgoto fail_fw_init;\n\t}\n\n\tinstance->fw_support_ieee = 0;\n\tinstance->fw_support_ieee =\n\t\t(instance->instancet->read_fw_status_reg(instance) &\n\t\t0x04000000);\n\n\tdev_notice(&instance->pdev->dev, \"megasas_init_mfi: fw_support_ieee=%d\",\n\t\t\tinstance->fw_support_ieee);\n\n\tif (instance->fw_support_ieee)\n\t\tinstance->flag_ieee = 1;\n\n\treturn 0;\n\nfail_fw_init:\n\n\tdma_free_coherent(&instance->pdev->dev, reply_q_sz,\n\t\t\t    instance->reply_queue, instance->reply_queue_h);\nfail_reply_queue:\n\tmegasas_free_cmds(instance);\n\nfail_alloc_cmds:\n\treturn 1;\n}\n\n/*\n * megasas_setup_irqs_ioapic -\t\tregister legacy interrupts.\n * @instance:\t\t\t\tAdapter soft state\n *\n * Do not enable interrupt, only setup ISRs.\n *\n * Return 0 on success.\n */\nstatic int\nmegasas_setup_irqs_ioapic(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = instance->pdev;\n\tinstance->irq_context[0].instance = instance;\n\tinstance->irq_context[0].MSIxIndex = 0;\n\tif (request_irq(pci_irq_vector(pdev, 0),\n\t\t\tinstance->instancet->service_isr, IRQF_SHARED,\n\t\t\t\"megasas\", &instance->irq_context[0])) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to register IRQ from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/**\n * megasas_setup_irqs_msix -\t\tregister MSI-x interrupts.\n * @instance:\t\t\t\tAdapter soft state\n * @is_probe:\t\t\t\tDriver probe check\n *\n * Do not enable interrupt, only setup ISRs.\n *\n * Return 0 on success.\n */\nstatic int\nmegasas_setup_irqs_msix(struct megasas_instance *instance, u8 is_probe)\n{\n\tint i, j;\n\tstruct pci_dev *pdev;\n\n\tpdev = instance->pdev;\n\n\t/* Try MSI-x */\n\tfor (i = 0; i < instance->msix_vectors; i++) {\n\t\tinstance->irq_context[i].instance = instance;\n\t\tinstance->irq_context[i].MSIxIndex = i;\n\t\tif (request_irq(pci_irq_vector(pdev, i),\n\t\t\tinstance->instancet->service_isr, 0, \"megasas\",\n\t\t\t&instance->irq_context[i])) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to register IRQ for vector %d.\\n\", i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree_irq(pci_irq_vector(pdev, j),\n\t\t\t\t\t &instance->irq_context[j]);\n\t\t\t/* Retry irq register for IO_APIC*/\n\t\t\tinstance->msix_vectors = 0;\n\t\t\tif (is_probe) {\n\t\t\t\tpci_free_irq_vectors(instance->pdev);\n\t\t\t\treturn megasas_setup_irqs_ioapic(instance);\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * megasas_destroy_irqs-\t\tunregister interrupts.\n * @instance:\t\t\t\tAdapter soft state\n * return:\t\t\t\tvoid\n */\nstatic void\nmegasas_destroy_irqs(struct megasas_instance *instance) {\n\n\tint i;\n\n\tif (instance->msix_vectors)\n\t\tfor (i = 0; i < instance->msix_vectors; i++) {\n\t\t\tfree_irq(pci_irq_vector(instance->pdev, i),\n\t\t\t\t &instance->irq_context[i]);\n\t\t}\n\telse\n\t\tfree_irq(pci_irq_vector(instance->pdev, 0),\n\t\t\t &instance->irq_context[0]);\n}\n\n/**\n * megasas_setup_jbod_map -\tsetup jbod map for FP seq_number.\n * @instance:\t\t\t\tAdapter soft state\n * @is_probe:\t\t\t\tDriver probe check\n *\n * Return 0 on success.\n */\nvoid\nmegasas_setup_jbod_map(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tu32 pd_seq_map_sz;\n\n\tpd_seq_map_sz = sizeof(struct MR_PD_CFG_SEQ_NUM_SYNC) +\n\t\t(sizeof(struct MR_PD_CFG_SEQ) * (MAX_PHYSICAL_DEVICES - 1));\n\n\tif (reset_devices || !fusion ||\n\t\t!instance->ctrl_info_buf->adapterOperations3.useSeqNumJbodFP) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"Jbod map is not supported %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\tinstance->use_seqnum_jbod_fp = false;\n\t\treturn;\n\t}\n\n\tif (fusion->pd_seq_sync[0])\n\t\tgoto skip_alloc;\n\n\tfor (i = 0; i < JBOD_MAPS_COUNT; i++) {\n\t\tfusion->pd_seq_sync[i] = dma_alloc_coherent\n\t\t\t(&instance->pdev->dev, pd_seq_map_sz,\n\t\t\t&fusion->pd_seq_phys[i], GFP_KERNEL);\n\t\tif (!fusion->pd_seq_sync[i]) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate memory from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tif (i == 1) {\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tpd_seq_map_sz, fusion->pd_seq_sync[0],\n\t\t\t\t\tfusion->pd_seq_phys[0]);\n\t\t\t\tfusion->pd_seq_sync[0] = NULL;\n\t\t\t}\n\t\t\tinstance->use_seqnum_jbod_fp = false;\n\t\t\treturn;\n\t\t}\n\t}\n\nskip_alloc:\n\tif (!megasas_sync_pd_seq_num(instance, false) &&\n\t\t!megasas_sync_pd_seq_num(instance, true))\n\t\tinstance->use_seqnum_jbod_fp = true;\n\telse\n\t\tinstance->use_seqnum_jbod_fp = false;\n}\n\nstatic void megasas_setup_reply_map(struct megasas_instance *instance)\n{\n\tconst struct cpumask *mask;\n\tunsigned int queue, cpu;\n\n\tfor (queue = 0; queue < instance->msix_vectors; queue++) {\n\t\tmask = pci_irq_get_affinity(instance->pdev, queue);\n\t\tif (!mask)\n\t\t\tgoto fallback;\n\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tinstance->reply_map[cpu] = queue;\n\t}\n\treturn;\n\nfallback:\n\tfor_each_possible_cpu(cpu)\n\t\tinstance->reply_map[cpu] = cpu % instance->msix_vectors;\n}\n\n/**\n * megasas_get_device_list -\tGet the PD and LD device list from FW.\n * @instance:\t\t\tAdapter soft state\n * @return:\t\t\tSuccess or failure\n *\n * Issue DCMDs to Firmware to get the PD and LD list.\n * Based on the FW support, driver sends the HOST_DEVICE_LIST or combination\n * of PD_LIST/LD_LIST_QUERY DCMDs to get the device list.\n */\nstatic\nint megasas_get_device_list(struct megasas_instance *instance)\n{\n\tmemset(instance->pd_list, 0,\n\t       (MEGASAS_MAX_PD * sizeof(struct megasas_pd_list)));\n\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\n\tif (instance->enable_fw_dev_list) {\n\t\tif (megasas_host_device_list_query(instance, true))\n\t\t\treturn FAILED;\n\t} else {\n\t\tif (megasas_get_pd_list(instance) < 0) {\n\t\t\tdev_err(&instance->pdev->dev, \"failed to get PD list\\n\");\n\t\t\treturn FAILED;\n\t\t}\n\n\t\tif (megasas_ld_list_query(instance,\n\t\t\t\t\t  MR_LD_QUERY_TYPE_EXPOSED_TO_HOST)) {\n\t\t\tdev_err(&instance->pdev->dev, \"failed to get LD list\\n\");\n\t\t\treturn FAILED;\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n/**\n * megasas_init_fw -\tInitializes the FW\n * @instance:\t\tAdapter soft state\n *\n * This is the main function for initializing firmware\n */\n\nstatic int megasas_init_fw(struct megasas_instance *instance)\n{\n\tu32 max_sectors_1;\n\tu32 max_sectors_2, tmp_sectors, msix_enable;\n\tu32 scratch_pad_1, scratch_pad_2, scratch_pad_3, status_reg;\n\tresource_size_t base_addr;\n\tstruct megasas_ctrl_info *ctrl_info = NULL;\n\tunsigned long bar_list;\n\tint i, j, loop, fw_msix_count = 0;\n\tstruct IOV_111 *iovPtr;\n\tstruct fusion_context *fusion;\n\tbool do_adp_reset = true;\n\n\tfusion = instance->ctrl_context;\n\n\t/* Find first memory bar */\n\tbar_list = pci_select_bars(instance->pdev, IORESOURCE_MEM);\n\tinstance->bar = find_first_bit(&bar_list, BITS_PER_LONG);\n\tif (pci_request_selected_regions(instance->pdev, 1<<instance->bar,\n\t\t\t\t\t \"megasas: LSI\")) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"IO memory region busy!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tbase_addr = pci_resource_start(instance->pdev, instance->bar);\n\tinstance->reg_set = ioremap_nocache(base_addr, 8192);\n\n\tif (!instance->reg_set) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to map IO mem\\n\");\n\t\tgoto fail_ioremap;\n\t}\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tinstance->instancet = &megasas_instance_template_fusion;\n\telse {\n\t\tswitch (instance->pdev->device) {\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078R:\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078DE:\n\t\t\tinstance->instancet = &megasas_instance_template_ppc;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078GEN2:\n\t\tcase PCI_DEVICE_ID_LSI_SAS0079GEN2:\n\t\t\tinstance->instancet = &megasas_instance_template_gen2;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS0073SKINNY:\n\t\tcase PCI_DEVICE_ID_LSI_SAS0071SKINNY:\n\t\t\tinstance->instancet = &megasas_instance_template_skinny;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS1064R:\n\t\tcase PCI_DEVICE_ID_DELL_PERC5:\n\t\tdefault:\n\t\t\tinstance->instancet = &megasas_instance_template_xscale;\n\t\t\tinstance->pd_list_not_supported = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (megasas_transition_to_ready(instance, 0)) {\n\t\tif (instance->adapter_type >= INVADER_SERIES) {\n\t\t\tstatus_reg = instance->instancet->read_fw_status_reg(\n\t\t\t\t\tinstance);\n\t\t\tdo_adp_reset = status_reg & MFI_RESET_ADAPTER;\n\t\t}\n\n\t\tif (do_adp_reset) {\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\tinstance->instancet->adp_reset\n\t\t\t\t(instance, instance->reg_set);\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"FW restarted successfully from %s!\\n\",\n\t\t\t\t __func__);\n\n\t\t\t/*waiting for about 30 second before retry*/\n\t\t\tssleep(30);\n\n\t\t\tif (megasas_transition_to_ready(instance, 0))\n\t\t\t\tgoto fail_ready_state;\n\t\t} else {\n\t\t\tgoto fail_ready_state;\n\t\t}\n\t}\n\n\tmegasas_init_ctrl_params(instance);\n\n\tif (megasas_set_dma_mask(instance))\n\t\tgoto fail_ready_state;\n\n\tif (megasas_alloc_ctrl_mem(instance))\n\t\tgoto fail_alloc_dma_buf;\n\n\tif (megasas_alloc_ctrl_dma_buffers(instance))\n\t\tgoto fail_alloc_dma_buf;\n\n\tfusion = instance->ctrl_context;\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tscratch_pad_2 =\n\t\t\tmegasas_readl(instance,\n\t\t\t\t      &instance->reg_set->outbound_scratch_pad_2);\n\t\tinstance->max_raid_mapsize = ((scratch_pad_2 >>\n\t\t\tMR_MAX_RAID_MAP_SIZE_OFFSET_SHIFT) &\n\t\t\tMR_MAX_RAID_MAP_SIZE_MASK);\n\t}\n\n\t/* Check if MSI-X is supported while in ready state */\n\tmsix_enable = (instance->instancet->read_fw_status_reg(instance) &\n\t\t       0x4000000) >> 0x1a;\n\tif (msix_enable && !msix_disable) {\n\t\tint irq_flags = PCI_IRQ_MSIX;\n\n\t\tscratch_pad_1 = megasas_readl\n\t\t\t(instance, &instance->reg_set->outbound_scratch_pad_1);\n\t\t/* Check max MSI-X vectors */\n\t\tif (fusion) {\n\t\t\tif (instance->adapter_type == THUNDERBOLT_SERIES) {\n\t\t\t\t/* Thunderbolt Series*/\n\t\t\t\tinstance->msix_vectors = (scratch_pad_1\n\t\t\t\t\t& MR_MAX_REPLY_QUEUES_OFFSET) + 1;\n\t\t\t\tfw_msix_count = instance->msix_vectors;\n\t\t\t} else {\n\t\t\t\tinstance->msix_vectors = ((scratch_pad_1\n\t\t\t\t\t& MR_MAX_REPLY_QUEUES_EXT_OFFSET)\n\t\t\t\t\t>> MR_MAX_REPLY_QUEUES_EXT_OFFSET_SHIFT) + 1;\n\n\t\t\t\t/*\n\t\t\t\t * For Invader series, > 8 MSI-x vectors\n\t\t\t\t * supported by FW/HW implies combined\n\t\t\t\t * reply queue mode is enabled.\n\t\t\t\t * For Ventura series, > 16 MSI-x vectors\n\t\t\t\t * supported by FW/HW implies combined\n\t\t\t\t * reply queue mode is enabled.\n\t\t\t\t */\n\t\t\t\tswitch (instance->adapter_type) {\n\t\t\t\tcase INVADER_SERIES:\n\t\t\t\t\tif (instance->msix_vectors > 8)\n\t\t\t\t\t\tinstance->msix_combined = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase AERO_SERIES:\n\t\t\t\tcase VENTURA_SERIES:\n\t\t\t\t\tif (instance->msix_vectors > 16)\n\t\t\t\t\t\tinstance->msix_combined = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (rdpq_enable)\n\t\t\t\t\tinstance->is_rdpq = (scratch_pad_1 & MR_RDPQ_MODE_OFFSET) ?\n\t\t\t\t\t\t\t\t1 : 0;\n\t\t\t\tfw_msix_count = instance->msix_vectors;\n\t\t\t\t/* Save 1-15 reply post index address to local memory\n\t\t\t\t * Index 0 is already saved from reg offset\n\t\t\t\t * MPI2_REPLY_POST_HOST_INDEX_OFFSET\n\t\t\t\t */\n\t\t\t\tfor (loop = 1; loop < MR_MAX_MSIX_REG_ARRAY; loop++) {\n\t\t\t\t\tinstance->reply_post_host_index_addr[loop] =\n\t\t\t\t\t\t(u32 __iomem *)\n\t\t\t\t\t\t((u8 __iomem *)instance->reg_set +\n\t\t\t\t\t\tMPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET\n\t\t\t\t\t\t+ (loop * 0x10));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (msix_vectors)\n\t\t\t\tinstance->msix_vectors = min(msix_vectors,\n\t\t\t\t\tinstance->msix_vectors);\n\t\t} else /* MFI adapters */\n\t\t\tinstance->msix_vectors = 1;\n\t\t/* Don't bother allocating more MSI-X vectors than cpus */\n\t\tinstance->msix_vectors = min(instance->msix_vectors,\n\t\t\t\t\t     (unsigned int)num_online_cpus());\n\t\tif (smp_affinity_enable)\n\t\t\tirq_flags |= PCI_IRQ_AFFINITY;\n\t\ti = pci_alloc_irq_vectors(instance->pdev, 1,\n\t\t\t\t\t  instance->msix_vectors, irq_flags);\n\t\tif (i > 0)\n\t\t\tinstance->msix_vectors = i;\n\t\telse\n\t\t\tinstance->msix_vectors = 0;\n\t}\n\t/*\n\t * MSI-X host index 0 is common for all adapter.\n\t * It is used for all MPT based Adapters.\n\t */\n\tif (instance->msix_combined) {\n\t\tinstance->reply_post_host_index_addr[0] =\n\t\t\t\t(u32 *)((u8 *)instance->reg_set +\n\t\t\t\tMPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET);\n\t} else {\n\t\tinstance->reply_post_host_index_addr[0] =\n\t\t\t(u32 *)((u8 *)instance->reg_set +\n\t\t\tMPI2_REPLY_POST_HOST_INDEX_OFFSET);\n\t}\n\n\tif (!instance->msix_vectors) {\n\t\ti = pci_alloc_irq_vectors(instance->pdev, 1, 1, PCI_IRQ_LEGACY);\n\t\tif (i < 0)\n\t\t\tgoto fail_init_adapter;\n\t}\n\n\tmegasas_setup_reply_map(instance);\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"firmware supports msix\\t: (%d)\", fw_msix_count);\n\tdev_info(&instance->pdev->dev,\n\t\t\"current msix/online cpus\\t: (%d/%d)\\n\",\n\t\tinstance->msix_vectors, (unsigned int)num_online_cpus());\n\tdev_info(&instance->pdev->dev,\n\t\t\"RDPQ mode\\t: (%s)\\n\", instance->is_rdpq ? \"enabled\" : \"disabled\");\n\n\ttasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\n\t\t(unsigned long)instance);\n\n\t/*\n\t * Below are default value for legacy Firmware.\n\t * non-fusion based controllers\n\t */\n\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES;\n\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t/* Get operational params, sge flags, send init cmd to controller */\n\tif (instance->instancet->init_adapter(instance))\n\t\tgoto fail_init_adapter;\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tscratch_pad_3 =\n\t\t\tmegasas_readl(instance,\n\t\t\t\t      &instance->reg_set->outbound_scratch_pad_3);\n\t\tif ((scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK) >=\n\t\t\tMR_DEFAULT_NVME_PAGE_SHIFT)\n\t\t\tinstance->nvme_page_size =\n\t\t\t\t(1 << (scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK));\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"NVME page size\\t: (%d)\\n\", instance->nvme_page_size);\n\t}\n\n\tif (instance->msix_vectors ?\n\t\tmegasas_setup_irqs_msix(instance, 1) :\n\t\tmegasas_setup_irqs_ioapic(instance))\n\t\tgoto fail_init_adapter;\n\n\tinstance->instancet->enable_intr(instance);\n\n\tdev_info(&instance->pdev->dev, \"INIT adapter done\\n\");\n\n\tmegasas_setup_jbod_map(instance);\n\n\tif (megasas_get_device_list(instance) != SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"%s: megasas_get_device_list failed\\n\",\n\t\t\t__func__);\n\t\tgoto fail_get_ld_pd_list;\n\t}\n\n\t/* stream detection initialization */\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tfusion->stream_detect_by_ld =\n\t\t\tkcalloc(MAX_LOGICAL_DRIVES_EXT,\n\t\t\t\tsizeof(struct LD_STREAM_DETECT *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!fusion->stream_detect_by_ld) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"unable to allocate stream detection for pool of LDs\\n\");\n\t\t\tgoto fail_get_ld_pd_list;\n\t\t}\n\t\tfor (i = 0; i < MAX_LOGICAL_DRIVES_EXT; ++i) {\n\t\t\tfusion->stream_detect_by_ld[i] =\n\t\t\t\tkzalloc(sizeof(struct LD_STREAM_DETECT),\n\t\t\t\tGFP_KERNEL);\n\t\t\tif (!fusion->stream_detect_by_ld[i]) {\n\t\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\t\"unable to allocate stream detect by LD\\n \");\n\t\t\t\tfor (j = 0; j < i; ++j)\n\t\t\t\t\tkfree(fusion->stream_detect_by_ld[j]);\n\t\t\t\tkfree(fusion->stream_detect_by_ld);\n\t\t\t\tfusion->stream_detect_by_ld = NULL;\n\t\t\t\tgoto fail_get_ld_pd_list;\n\t\t\t}\n\t\t\tfusion->stream_detect_by_ld[i]->mru_bit_map\n\t\t\t\t= MR_STREAM_BITMAP;\n\t\t}\n\t}\n\n\t/*\n\t * Compute the max allowed sectors per IO: The controller info has two\n\t * limits on max sectors. Driver should use the minimum of these two.\n\t *\n\t * 1 << stripe_sz_ops.min = max sectors per strip\n\t *\n\t * Note that older firmwares ( < FW ver 30) didn't report information\n\t * to calculate max_sectors_1. So the number ended up as zero always.\n\t */\n\ttmp_sectors = 0;\n\tctrl_info = instance->ctrl_info_buf;\n\n\tmax_sectors_1 = (1 << ctrl_info->stripe_sz_ops.min) *\n\t\tle16_to_cpu(ctrl_info->max_strips_per_io);\n\tmax_sectors_2 = le32_to_cpu(ctrl_info->max_request_size);\n\n\ttmp_sectors = min_t(u32, max_sectors_1, max_sectors_2);\n\n\tinstance->peerIsPresent = ctrl_info->cluster.peerIsPresent;\n\tinstance->passive = ctrl_info->cluster.passive;\n\tmemcpy(instance->clusterId, ctrl_info->clusterId, sizeof(instance->clusterId));\n\tinstance->UnevenSpanSupport =\n\t\tctrl_info->adapterOperations2.supportUnevenSpans;\n\tif (instance->UnevenSpanSupport) {\n\t\tstruct fusion_context *fusion = instance->ctrl_context;\n\t\tif (MR_ValidateMapInfo(instance, instance->map_id))\n\t\t\tfusion->fast_path_io = 1;\n\t\telse\n\t\t\tfusion->fast_path_io = 0;\n\n\t}\n\tif (ctrl_info->host_interface.SRIOV) {\n\t\tinstance->requestorId = ctrl_info->iov.requestorId;\n\t\tif (instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA) {\n\t\t\tif (!ctrl_info->adapterOperations2.activePassive)\n\t\t\t    instance->PlasmaFW111 = 1;\n\n\t\t\tdev_info(&instance->pdev->dev, \"SR-IOV: firmware type: %s\\n\",\n\t\t\t    instance->PlasmaFW111 ? \"1.11\" : \"new\");\n\n\t\t\tif (instance->PlasmaFW111) {\n\t\t\t    iovPtr = (struct IOV_111 *)\n\t\t\t\t((unsigned char *)ctrl_info + IOV_111_OFFSET);\n\t\t\t    instance->requestorId = iovPtr->requestorId;\n\t\t\t}\n\t\t}\n\t\tdev_info(&instance->pdev->dev, \"SRIOV: VF requestorId %d\\n\",\n\t\t\tinstance->requestorId);\n\t}\n\n\tinstance->crash_dump_fw_support =\n\t\tctrl_info->adapterOperations3.supportCrashDump;\n\tinstance->crash_dump_drv_support =\n\t\t(instance->crash_dump_fw_support &&\n\t\tinstance->crash_dump_buf);\n\tif (instance->crash_dump_drv_support)\n\t\tmegasas_set_crash_dump_params(instance,\n\t\t\tMR_CRASH_BUF_TURN_OFF);\n\n\telse {\n\t\tif (instance->crash_dump_buf)\n\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\tCRASH_DMA_BUF_SIZE,\n\t\t\t\tinstance->crash_dump_buf,\n\t\t\t\tinstance->crash_dump_h);\n\t\tinstance->crash_dump_buf = NULL;\n\t}\n\n\tif (instance->snapdump_wait_time) {\n\t\tmegasas_get_snapdump_properties(instance);\n\t\tdev_info(&instance->pdev->dev, \"Snap dump wait time\\t: %d\\n\",\n\t\t\t instance->snapdump_wait_time);\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"pci id\\t\\t: (0x%04x)/(0x%04x)/(0x%04x)/(0x%04x)\\n\",\n\t\tle16_to_cpu(ctrl_info->pci.vendor_id),\n\t\tle16_to_cpu(ctrl_info->pci.device_id),\n\t\tle16_to_cpu(ctrl_info->pci.sub_vendor_id),\n\t\tle16_to_cpu(ctrl_info->pci.sub_device_id));\n\tdev_info(&instance->pdev->dev, \"unevenspan support\t: %s\\n\",\n\t\tinstance->UnevenSpanSupport ? \"yes\" : \"no\");\n\tdev_info(&instance->pdev->dev, \"firmware crash dump\t: %s\\n\",\n\t\tinstance->crash_dump_drv_support ? \"yes\" : \"no\");\n\tdev_info(&instance->pdev->dev, \"jbod sync map\t\t: %s\\n\",\n\t\tinstance->use_seqnum_jbod_fp ? \"yes\" : \"no\");\n\n\tinstance->max_sectors_per_req = instance->max_num_sge *\n\t\t\t\t\t\tSGE_BUFFER_SIZE / 512;\n\tif (tmp_sectors && (instance->max_sectors_per_req > tmp_sectors))\n\t\tinstance->max_sectors_per_req = tmp_sectors;\n\n\t/* Check for valid throttlequeuedepth module parameter */\n\tif (throttlequeuedepth &&\n\t\t\tthrottlequeuedepth <= instance->max_scsi_cmds)\n\t\tinstance->throttlequeuedepth = throttlequeuedepth;\n\telse\n\t\tinstance->throttlequeuedepth =\n\t\t\t\tMEGASAS_THROTTLE_QUEUE_DEPTH;\n\n\tif ((resetwaittime < 1) ||\n\t    (resetwaittime > MEGASAS_RESET_WAIT_TIME))\n\t\tresetwaittime = MEGASAS_RESET_WAIT_TIME;\n\n\tif ((scmd_timeout < 10) || (scmd_timeout > MEGASAS_DEFAULT_CMD_TIMEOUT))\n\t\tscmd_timeout = MEGASAS_DEFAULT_CMD_TIMEOUT;\n\n\t/* Launch SR-IOV heartbeat timer */\n\tif (instance->requestorId) {\n\t\tif (!megasas_sriov_start_heartbeat(instance, 1)) {\n\t\t\tmegasas_start_timer(instance);\n\t\t} else {\n\t\t\tinstance->skip_heartbeat_timer_del = 1;\n\t\t\tgoto fail_get_ld_pd_list;\n\t\t}\n\t}\n\n\t/*\n\t * Create and start watchdog thread which will monitor\n\t * controller state every 1 sec and trigger OCR when\n\t * it enters fault state\n\t */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tif (megasas_fusion_start_watchdog(instance) != SUCCESS)\n\t\t\tgoto fail_start_watchdog;\n\n\treturn 0;\n\nfail_start_watchdog:\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\nfail_get_ld_pd_list:\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\nfail_init_adapter:\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\tinstance->msix_vectors = 0;\nfail_alloc_dma_buf:\n\tmegasas_free_ctrl_dma_buffers(instance);\n\tmegasas_free_ctrl_mem(instance);\nfail_ready_state:\n\tiounmap(instance->reg_set);\n\nfail_ioremap:\n\tpci_release_selected_regions(instance->pdev, 1<<instance->bar);\n\n\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t__func__, __LINE__);\n\treturn -EINVAL;\n}\n\n/**\n * megasas_release_mfi -\tReverses the FW initialization\n * @instance:\t\t\tAdapter soft state\n */\nstatic void megasas_release_mfi(struct megasas_instance *instance)\n{\n\tu32 reply_q_sz = sizeof(u32) *(instance->max_mfi_cmds + 1);\n\n\tif (instance->reply_queue)\n\t\tdma_free_coherent(&instance->pdev->dev, reply_q_sz,\n\t\t\t    instance->reply_queue, instance->reply_queue_h);\n\n\tmegasas_free_cmds(instance);\n\n\tiounmap(instance->reg_set);\n\n\tpci_release_selected_regions(instance->pdev, 1<<instance->bar);\n}\n\n/**\n * megasas_get_seq_num -\tGets latest event sequence numbers\n * @instance:\t\t\tAdapter soft state\n * @eli:\t\t\tFW event log sequence numbers information\n *\n * FW maintains a log of all events in a non-volatile area. Upper layers would\n * usually find out the latest sequence number of the events, the seq number at\n * the boot etc. They would \"read\" all the events below the latest seq number\n * by issuing a direct fw cmd (DCMD). For the future events (beyond latest seq\n * number), they would subsribe to AEN (asynchronous event notification) and\n * wait for the events to happen.\n */\nstatic int\nmegasas_get_seq_num(struct megasas_instance *instance,\n\t\t    struct megasas_evt_log_info *eli)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct megasas_evt_log_info *el_info;\n\tdma_addr_t el_info_h = 0;\n\tint ret;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\tel_info = dma_zalloc_coherent(&instance->pdev->dev,\n\t\t\tsizeof(struct megasas_evt_log_info), &el_info_h,\n\t\t\tGFP_KERNEL);\n\tif (!el_info) {\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_evt_log_info));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_EVENT_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, el_info_h,\n\t\t\t\t sizeof(struct megasas_evt_log_info));\n\n\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\tif (ret != DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto dcmd_failed;\n\t}\n\n\t/*\n\t * Copy the data back into callers buffer\n\t */\n\teli->newest_seq_num = el_info->newest_seq_num;\n\teli->oldest_seq_num = el_info->oldest_seq_num;\n\teli->clear_seq_num = el_info->clear_seq_num;\n\teli->shutdown_seq_num = el_info->shutdown_seq_num;\n\teli->boot_seq_num = el_info->boot_seq_num;\n\ndcmd_failed:\n\tdma_free_coherent(&instance->pdev->dev,\n\t\t\tsizeof(struct megasas_evt_log_info),\n\t\t\tel_info, el_info_h);\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * megasas_register_aen -\tRegisters for asynchronous event notification\n * @instance:\t\t\tAdapter soft state\n * @seq_num:\t\t\tThe starting sequence number\n * @class_locale:\t\tClass of the event\n *\n * This function subscribes for AEN for events beyond the @seq_num. It requests\n * to be notified if and only if the event is of type @class_locale\n */\nstatic int\nmegasas_register_aen(struct megasas_instance *instance, u32 seq_num,\n\t\t     u32 class_locale_word)\n{\n\tint ret_val;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tunion megasas_evt_class_locale curr_aen;\n\tunion megasas_evt_class_locale prev_aen;\n\n\t/*\n\t * If there an AEN pending already (aen_cmd), check if the\n\t * class_locale of that pending AEN is inclusive of the new\n\t * AEN request we currently have. If it is, then we don't have\n\t * to do anything. In other words, whichever events the current\n\t * AEN request is subscribing to, have already been subscribed\n\t * to.\n\t *\n\t * If the old_cmd is _not_ inclusive, then we have to abort\n\t * that command, form a class_locale that is superset of both\n\t * old and current and re-issue to the FW\n\t */\n\n\tcurr_aen.word = class_locale_word;\n\n\tif (instance->aen_cmd) {\n\n\t\tprev_aen.word =\n\t\t\tle32_to_cpu(instance->aen_cmd->frame->dcmd.mbox.w[1]);\n\n\t\tif ((curr_aen.members.class < MFI_EVT_CLASS_DEBUG) ||\n\t\t    (curr_aen.members.class > MFI_EVT_CLASS_DEAD)) {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"%s %d out of range class %d send by application\\n\",\n\t\t\t\t __func__, __LINE__, curr_aen.members.class);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * A class whose enum value is smaller is inclusive of all\n\t\t * higher values. If a PROGRESS (= -1) was previously\n\t\t * registered, then a new registration requests for higher\n\t\t * classes need not be sent to FW. They are automatically\n\t\t * included.\n\t\t *\n\t\t * Locale numbers don't have such hierarchy. They are bitmap\n\t\t * values\n\t\t */\n\t\tif ((prev_aen.members.class <= curr_aen.members.class) &&\n\t\t    !((prev_aen.members.locale & curr_aen.members.locale) ^\n\t\t      curr_aen.members.locale)) {\n\t\t\t/*\n\t\t\t * Previously issued event registration includes\n\t\t\t * current request. Nothing to do.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcurr_aen.members.locale |= prev_aen.members.locale;\n\n\t\t\tif (prev_aen.members.class < curr_aen.members.class)\n\t\t\t\tcurr_aen.members.class = prev_aen.members.class;\n\n\t\t\tinstance->aen_cmd->abort_aen = 1;\n\t\t\tret_val = megasas_issue_blocked_abort_cmd(instance,\n\t\t\t\t\t\t\t\t  instance->\n\t\t\t\t\t\t\t\t  aen_cmd, 30);\n\n\t\t\tif (ret_val) {\n\t\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to abort \"\n\t\t\t\t       \"previous AEN command\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->evt_detail, 0, sizeof(struct megasas_evt_detail));\n\n\t/*\n\t * Prepare DCMD for aen registration\n\t */\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_evt_detail));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_EVENT_WAIT);\n\tdcmd->mbox.w[0] = cpu_to_le32(seq_num);\n\tinstance->last_seq_num = seq_num;\n\tdcmd->mbox.w[1] = cpu_to_le32(curr_aen.word);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->evt_detail_h,\n\t\t\t\t sizeof(struct megasas_evt_detail));\n\n\tif (instance->aen_cmd != NULL) {\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Store reference to the cmd used to register for AEN. When an\n\t * application wants us to register for AEN, we have to abort this\n\t * cmd and re-register with a new EVENT LOCALE supplied by that app\n\t */\n\tinstance->aen_cmd = cmd;\n\n\t/*\n\t * Issue the aen registration frame\n\t */\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\treturn 0;\n}\n\n/* megasas_get_target_prop - Send DCMD with below details to firmware.\n *\n * This DCMD will fetch few properties of LD/system PD defined\n * in MR_TARGET_DEV_PROPERTIES. eg. Queue Depth, MDTS value.\n *\n * DCMD send by drivers whenever new target is added to the OS.\n *\n * dcmd.opcode         - MR_DCMD_DEV_GET_TARGET_PROP\n * dcmd.mbox.b[0]      - DCMD is to be fired for LD or system PD.\n *                       0 = system PD, 1 = LD.\n * dcmd.mbox.s[1]      - TargetID for LD/system PD.\n * dcmd.sge IN         - Pointer to return MR_TARGET_DEV_PROPERTIES.\n *\n * @instance:\t\tAdapter soft state\n * @sdev:\t\tOS provided scsi device\n *\n * Returns 0 on success non-zero on failure.\n */\nint\nmegasas_get_target_prop(struct megasas_instance *instance,\n\t\t\tstruct scsi_device *sdev)\n{\n\tint ret;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tu16 targetId = (sdev->channel % 2) + sdev->id;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to get cmd %s\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->tgt_prop, 0, sizeof(*instance->tgt_prop));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\tdcmd->mbox.b[0] = MEGASAS_IS_LOGICAL(sdev);\n\n\tdcmd->mbox.s[1] = cpu_to_le16(targetId);\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len =\n\t\tcpu_to_le32(sizeof(struct MR_TARGET_PROPERTIES));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_DRV_GET_TARGET_PROP);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->tgt_prop_h,\n\t\t\t\t sizeof(struct MR_TARGET_PROPERTIES));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance,\n\t\t\t\t\t\tcmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t     MFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t __func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tmegasas_return_cmd(instance, cmd);\n\t}\n\tif (ret != DCMD_SUCCESS)\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d return value %d\\n\",\n\t\t\t__func__, __LINE__, ret);\n\n\treturn ret;\n}\n\n/**\n * megasas_start_aen -\tSubscribes to AEN during driver load time\n * @instance:\t\tAdapter soft state\n */\nstatic int megasas_start_aen(struct megasas_instance *instance)\n{\n\tstruct megasas_evt_log_info eli;\n\tunion megasas_evt_class_locale class_locale;\n\n\t/*\n\t * Get the latest sequence number from FW\n\t */\n\tmemset(&eli, 0, sizeof(eli));\n\n\tif (megasas_get_seq_num(instance, &eli))\n\t\treturn -1;\n\n\t/*\n\t * Register AEN with FW for latest sequence number plus 1\n\t */\n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\treturn megasas_register_aen(instance,\n\t\t\tle32_to_cpu(eli.newest_seq_num) + 1,\n\t\t\tclass_locale.word);\n}\n\n/**\n * megasas_io_attach -\tAttaches this driver to SCSI mid-layer\n * @instance:\t\tAdapter soft state\n */\nstatic int megasas_io_attach(struct megasas_instance *instance)\n{\n\tstruct Scsi_Host *host = instance->host;\n\n\t/*\n\t * Export parameters required by SCSI mid-layer\n\t */\n\thost->unique_id = instance->unique_id;\n\thost->can_queue = instance->max_scsi_cmds;\n\thost->this_id = instance->init_id;\n\thost->sg_tablesize = instance->max_num_sge;\n\n\tif (instance->fw_support_ieee)\n\t\tinstance->max_sectors_per_req = MEGASAS_MAX_SECTORS_IEEE;\n\n\t/*\n\t * Check if the module parameter value for max_sectors can be used\n\t */\n\tif (max_sectors && max_sectors < instance->max_sectors_per_req)\n\t\tinstance->max_sectors_per_req = max_sectors;\n\telse {\n\t\tif (max_sectors) {\n\t\t\tif (((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS1078GEN2) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0079GEN2)) &&\n\t\t\t\t(max_sectors <= MEGASAS_MAX_SECTORS)) {\n\t\t\t\tinstance->max_sectors_per_req = max_sectors;\n\t\t\t} else {\n\t\t\tdev_info(&instance->pdev->dev, \"max_sectors should be > 0\"\n\t\t\t\t\"and <= %d (or < 1MB for GEN2 controller)\\n\",\n\t\t\t\tinstance->max_sectors_per_req);\n\t\t\t}\n\t\t}\n\t}\n\n\thost->max_sectors = instance->max_sectors_per_req;\n\thost->cmd_per_lun = MEGASAS_DEFAULT_CMD_PER_LUN;\n\thost->max_channel = MEGASAS_MAX_CHANNELS - 1;\n\thost->max_id = MEGASAS_MAX_DEV_PER_CHANNEL;\n\thost->max_lun = MEGASAS_MAX_LUN;\n\thost->max_cmd_len = 16;\n\n\t/*\n\t * Notify the mid-layer about the new controller\n\t */\n\tif (scsi_add_host(host, &instance->pdev->dev)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to add host from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n/**\n * megasas_set_dma_mask -\tSet DMA mask for supported controllers\n *\n * @instance:\t\tAdapter soft state\n * Description:\n *\n * For Ventura, driver/FW will operate in 63bit DMA addresses.\n *\n * For invader-\n *\tBy default, driver/FW will operate in 32bit DMA addresses\n *\tfor consistent DMA mapping but if 32 bit consistent\n *\tDMA mask fails, driver will try with 63 bit consistent\n *\tmask provided FW is true 63bit DMA capable\n *\n * For older controllers(Thunderbolt and MFI based adapters)-\n *\tdriver/FW will operate in 32 bit consistent DMA addresses.\n */\nstatic int\nmegasas_set_dma_mask(struct megasas_instance *instance)\n{\n\tu64 consistent_mask;\n\tstruct pci_dev *pdev;\n\tu32 scratch_pad_1;\n\n\tpdev = instance->pdev;\n\tconsistent_mask = (instance->adapter_type >= VENTURA_SERIES) ?\n\t\t\t\tDMA_BIT_MASK(63) : DMA_BIT_MASK(32);\n\n\tif (IS_DMA64) {\n\t\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(63)) &&\n\t\t    dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))\n\t\t\tgoto fail_set_dma_mask;\n\n\t\tif ((*pdev->dev.dma_mask == DMA_BIT_MASK(63)) &&\n\t\t    (dma_set_coherent_mask(&pdev->dev, consistent_mask) &&\n\t\t     dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))) {\n\t\t\t/*\n\t\t\t * If 32 bit DMA mask fails, then try for 64 bit mask\n\t\t\t * for FW capable of handling 64 bit DMA.\n\t\t\t */\n\t\t\tscratch_pad_1 = megasas_readl\n\t\t\t\t(instance, &instance->reg_set->outbound_scratch_pad_1);\n\n\t\t\tif (!(scratch_pad_1 & MR_CAN_HANDLE_64_BIT_DMA_OFFSET))\n\t\t\t\tgoto fail_set_dma_mask;\n\t\t\telse if (dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\t\t\t   DMA_BIT_MASK(63)))\n\t\t\t\tgoto fail_set_dma_mask;\n\t\t}\n\t} else if (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))\n\t\tgoto fail_set_dma_mask;\n\n\tif (pdev->dev.coherent_dma_mask == DMA_BIT_MASK(32))\n\t\tinstance->consistent_mask_64bit = false;\n\telse\n\t\tinstance->consistent_mask_64bit = true;\n\n\tdev_info(&pdev->dev, \"%s bit DMA mask and %s bit consistent mask\\n\",\n\t\t ((*pdev->dev.dma_mask == DMA_BIT_MASK(64)) ? \"63\" : \"32\"),\n\t\t (instance->consistent_mask_64bit ? \"63\" : \"32\"));\n\n\treturn 0;\n\nfail_set_dma_mask:\n\tdev_err(&pdev->dev, \"Failed to set DMA mask\\n\");\n\treturn -1;\n\n}\n\n/*\n * megasas_set_adapter_type -\tSet adapter type.\n *\t\t\t\tSupported controllers can be divided in\n *\t\t\t\tdifferent categories-\n *\t\t\t\t\tenum MR_ADAPTER_TYPE {\n *\t\t\t\t\t\tMFI_SERIES = 1,\n *\t\t\t\t\t\tTHUNDERBOLT_SERIES = 2,\n *\t\t\t\t\t\tINVADER_SERIES = 3,\n *\t\t\t\t\t\tVENTURA_SERIES = 4,\n *\t\t\t\t\t\tAERO_SERIES = 5,\n *\t\t\t\t\t};\n * @instance:\t\t\tAdapter soft state\n * return:\t\t\tvoid\n */\nstatic inline void megasas_set_adapter_type(struct megasas_instance *instance)\n{\n\tif ((instance->pdev->vendor == PCI_VENDOR_ID_DELL) &&\n\t    (instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5)) {\n\t\tinstance->adapter_type = MFI_SERIES;\n\t} else {\n\t\tswitch (instance->pdev->device) {\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E1:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E2:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E5:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E6:\n\t\t\tinstance->adapter_type = AERO_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_VENTURA:\n\t\tcase PCI_DEVICE_ID_LSI_CRUSADER:\n\t\tcase PCI_DEVICE_ID_LSI_HARPOON:\n\t\tcase PCI_DEVICE_ID_LSI_TOMCAT:\n\t\tcase PCI_DEVICE_ID_LSI_VENTURA_4PORT:\n\t\tcase PCI_DEVICE_ID_LSI_CRUSADER_4PORT:\n\t\t\tinstance->adapter_type = VENTURA_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_FUSION:\n\t\tcase PCI_DEVICE_ID_LSI_PLASMA:\n\t\t\tinstance->adapter_type = THUNDERBOLT_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_INVADER:\n\t\tcase PCI_DEVICE_ID_LSI_INTRUDER:\n\t\tcase PCI_DEVICE_ID_LSI_INTRUDER_24:\n\t\tcase PCI_DEVICE_ID_LSI_CUTLASS_52:\n\t\tcase PCI_DEVICE_ID_LSI_CUTLASS_53:\n\t\tcase PCI_DEVICE_ID_LSI_FURY:\n\t\t\tinstance->adapter_type = INVADER_SERIES;\n\t\t\tbreak;\n\t\tdefault: /* For all other supported controllers */\n\t\t\tinstance->adapter_type = MFI_SERIES;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline int megasas_alloc_mfi_ctrl_mem(struct megasas_instance *instance)\n{\n\tinstance->producer = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\tsizeof(u32), &instance->producer_h, GFP_KERNEL);\n\tinstance->consumer = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\tsizeof(u32), &instance->consumer_h, GFP_KERNEL);\n\n\tif (!instance->producer || !instance->consumer) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to allocate memory for producer, consumer\\n\");\n\t\treturn -1;\n\t}\n\n\t*instance->producer = 0;\n\t*instance->consumer = 0;\n\treturn 0;\n}\n\n/**\n * megasas_alloc_ctrl_mem -\tAllocate per controller memory for core data\n *\t\t\t\tstructures which are not common across MFI\n *\t\t\t\tadapters and fusion adapters.\n *\t\t\t\tFor MFI based adapters, allocate producer and\n *\t\t\t\tconsumer buffers. For fusion adapters, allocate\n *\t\t\t\tmemory for fusion context.\n * @instance:\t\t\tAdapter soft state\n * return:\t\t\t0 for SUCCESS\n */\nstatic int megasas_alloc_ctrl_mem(struct megasas_instance *instance)\n{\n\tinstance->reply_map = kcalloc(nr_cpu_ids, sizeof(unsigned int),\n\t\t\t\t      GFP_KERNEL);\n\tif (!instance->reply_map)\n\t\treturn -ENOMEM;\n\n\tswitch (instance->adapter_type) {\n\tcase MFI_SERIES:\n\t\tif (megasas_alloc_mfi_ctrl_mem(instance))\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase AERO_SERIES:\n\tcase VENTURA_SERIES:\n\tcase THUNDERBOLT_SERIES:\n\tcase INVADER_SERIES:\n\t\tif (megasas_alloc_fusion_context(instance))\n\t\t\tgoto fail;\n\t\tbreak;\n\t}\n\n\treturn 0;\n fail:\n\tkfree(instance->reply_map);\n\tinstance->reply_map = NULL;\n\treturn -ENOMEM;\n}\n\n/*\n * megasas_free_ctrl_mem -\tFree fusion context for fusion adapters and\n *\t\t\t\tproducer, consumer buffers for MFI adapters\n *\n * @instance -\t\t\tAdapter soft instance\n *\n */\nstatic inline void megasas_free_ctrl_mem(struct megasas_instance *instance)\n{\n\tkfree(instance->reply_map);\n\tif (instance->adapter_type == MFI_SERIES) {\n\t\tif (instance->producer)\n\t\t\tdma_free_coherent(&instance->pdev->dev, sizeof(u32),\n\t\t\t\t\t    instance->producer,\n\t\t\t\t\t    instance->producer_h);\n\t\tif (instance->consumer)\n\t\t\tdma_free_coherent(&instance->pdev->dev, sizeof(u32),\n\t\t\t\t\t    instance->consumer,\n\t\t\t\t\t    instance->consumer_h);\n\t} else {\n\t\tmegasas_free_fusion_context(instance);\n\t}\n}\n\n/**\n * megasas_alloc_ctrl_dma_buffers -\tAllocate consistent DMA buffers during\n *\t\t\t\t\tdriver load time\n *\n * @instance-\t\t\t\tAdapter soft instance\n * @return-\t\t\t\tO for SUCCESS\n */\nstatic inline\nint megasas_alloc_ctrl_dma_buffers(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev = instance->pdev;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\tinstance->evt_detail = dma_alloc_coherent(&pdev->dev,\n\t\t\tsizeof(struct megasas_evt_detail),\n\t\t\t&instance->evt_detail_h, GFP_KERNEL);\n\n\tif (!instance->evt_detail) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to allocate event detail buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (fusion) {\n\t\tfusion->ioc_init_request =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t   sizeof(struct MPI2_IOC_INIT_REQUEST),\n\t\t\t\t\t   &fusion->ioc_init_request_phys,\n\t\t\t\t\t   GFP_KERNEL);\n\n\t\tif (!fusion->ioc_init_request) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate PD list buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tinstance->snapdump_prop = dma_alloc_coherent(&pdev->dev,\n\t\t\t\tsizeof(struct MR_SNAPDUMP_PROPERTIES),\n\t\t\t\t&instance->snapdump_prop_h, GFP_KERNEL);\n\n\t\tif (!instance->snapdump_prop)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate snapdump properties buffer\\n\");\n\n\t\tinstance->host_device_list_buf = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t\tHOST_DEVICE_LIST_SZ,\n\t\t\t\t\t\t\t&instance->host_device_list_buf_h,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->host_device_list_buf) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate targetid list buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t}\n\n\tinstance->pd_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),\n\t\t\t\t     &instance->pd_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->pd_list_buf) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate PD list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ctrl_info_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     sizeof(struct megasas_ctrl_info),\n\t\t\t\t     &instance->ctrl_info_buf_h, GFP_KERNEL);\n\n\tif (!instance->ctrl_info_buf) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to allocate controller info buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ld_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     sizeof(struct MR_LD_LIST),\n\t\t\t\t     &instance->ld_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->ld_list_buf) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate LD list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ld_targetid_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\tsizeof(struct MR_LD_TARGETID_LIST),\n\t\t\t\t&instance->ld_targetid_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->ld_targetid_list_buf) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to allocate LD targetid list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!reset_devices) {\n\t\tinstance->system_info_buf =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_DRV_SYSTEM_INFO),\n\t\t\t\t\t&instance->system_info_h, GFP_KERNEL);\n\t\tinstance->pd_info =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_PD_INFO),\n\t\t\t\t\t&instance->pd_info_h, GFP_KERNEL);\n\t\tinstance->tgt_prop =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_TARGET_PROPERTIES),\n\t\t\t\t\t&instance->tgt_prop_h, GFP_KERNEL);\n\t\tinstance->crash_dump_buf =\n\t\t\tdma_alloc_coherent(&pdev->dev, CRASH_DMA_BUF_SIZE,\n\t\t\t\t\t&instance->crash_dump_h, GFP_KERNEL);\n\n\t\tif (!instance->system_info_buf)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate system info buffer\\n\");\n\n\t\tif (!instance->pd_info)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate pd_info buffer\\n\");\n\n\t\tif (!instance->tgt_prop)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate tgt_prop buffer\\n\");\n\n\t\tif (!instance->crash_dump_buf)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate crash dump buffer\\n\");\n\t}\n\n\treturn 0;\n}\n\n/*\n * megasas_free_ctrl_dma_buffers -\tFree consistent DMA buffers allocated\n *\t\t\t\t\tduring driver load time\n *\n * @instance-\t\t\t\tAdapter soft instance\n *\n */\nstatic inline\nvoid megasas_free_ctrl_dma_buffers(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev = instance->pdev;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\tif (instance->evt_detail)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct megasas_evt_detail),\n\t\t\t\t    instance->evt_detail,\n\t\t\t\t    instance->evt_detail_h);\n\n\tif (fusion && fusion->ioc_init_request)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  sizeof(struct MPI2_IOC_INIT_REQUEST),\n\t\t\t\t  fusion->ioc_init_request,\n\t\t\t\t  fusion->ioc_init_request_phys);\n\n\tif (instance->pd_list_buf)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t    MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),\n\t\t\t\t    instance->pd_list_buf,\n\t\t\t\t    instance->pd_list_buf_h);\n\n\tif (instance->ld_list_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_LD_LIST),\n\t\t\t\t    instance->ld_list_buf,\n\t\t\t\t    instance->ld_list_buf_h);\n\n\tif (instance->ld_targetid_list_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_LD_TARGETID_LIST),\n\t\t\t\t    instance->ld_targetid_list_buf,\n\t\t\t\t    instance->ld_targetid_list_buf_h);\n\n\tif (instance->ctrl_info_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct megasas_ctrl_info),\n\t\t\t\t    instance->ctrl_info_buf,\n\t\t\t\t    instance->ctrl_info_buf_h);\n\n\tif (instance->system_info_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_DRV_SYSTEM_INFO),\n\t\t\t\t    instance->system_info_buf,\n\t\t\t\t    instance->system_info_h);\n\n\tif (instance->pd_info)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_PD_INFO),\n\t\t\t\t    instance->pd_info, instance->pd_info_h);\n\n\tif (instance->tgt_prop)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_TARGET_PROPERTIES),\n\t\t\t\t    instance->tgt_prop, instance->tgt_prop_h);\n\n\tif (instance->crash_dump_buf)\n\t\tdma_free_coherent(&pdev->dev, CRASH_DMA_BUF_SIZE,\n\t\t\t\t    instance->crash_dump_buf,\n\t\t\t\t    instance->crash_dump_h);\n\n\tif (instance->snapdump_prop)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  sizeof(struct MR_SNAPDUMP_PROPERTIES),\n\t\t\t\t  instance->snapdump_prop,\n\t\t\t\t  instance->snapdump_prop_h);\n\n\tif (instance->host_device_list_buf)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  HOST_DEVICE_LIST_SZ,\n\t\t\t\t  instance->host_device_list_buf,\n\t\t\t\t  instance->host_device_list_buf_h);\n\n}\n\n/*\n * megasas_init_ctrl_params -\t\tInitialize controller's instance\n *\t\t\t\t\tparameters before FW init\n * @instance -\t\t\t\tAdapter soft instance\n * @return -\t\t\t\tvoid\n */\nstatic inline void megasas_init_ctrl_params(struct megasas_instance *instance)\n{\n\tinstance->fw_crash_state = UNAVAILABLE;\n\n\tmegasas_poll_wait_aen = 0;\n\tinstance->issuepend_done = 1;\n\tatomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n\n\t/*\n\t * Initialize locks and queues\n\t */\n\tINIT_LIST_HEAD(&instance->cmd_pool);\n\tINIT_LIST_HEAD(&instance->internal_reset_pending_q);\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\n\tinit_waitqueue_head(&instance->int_cmd_wait_q);\n\tinit_waitqueue_head(&instance->abort_cmd_wait_q);\n\n\tspin_lock_init(&instance->crashdump_lock);\n\tspin_lock_init(&instance->mfi_pool_lock);\n\tspin_lock_init(&instance->hba_lock);\n\tspin_lock_init(&instance->stream_lock);\n\tspin_lock_init(&instance->completion_lock);\n\n\tmutex_init(&instance->reset_mutex);\n\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t    (instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY))\n\t\tinstance->flag_ieee = 1;\n\n\tmegasas_dbg_lvl = 0;\n\tinstance->flag = 0;\n\tinstance->unload = 1;\n\tinstance->last_time = 0;\n\tinstance->disableOnlineCtrlReset = 1;\n\tinstance->UnevenSpanSupport = 0;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tINIT_WORK(&instance->work_init, megasas_fusion_ocr_wq);\n\telse\n\t\tINIT_WORK(&instance->work_init, process_fw_state_change_wq);\n}\n\n/**\n * megasas_probe_one -\tPCI hotplug entry point\n * @pdev:\t\tPCI device structure\n * @id:\t\t\tPCI ids of supported hotplugged adapter\n */\nstatic int megasas_probe_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tint rval, pos;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tu16 control = 0;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_LSI_AERO_10E1:\n\tcase PCI_DEVICE_ID_LSI_AERO_10E5:\n\t\tdev_info(&pdev->dev, \"Adapter is in configurable secure mode\\n\");\n\t\tbreak;\n\t}\n\n\t/* Reset MSI-X in the kdump kernel */\n\tif (reset_devices) {\n\t\tpos = pci_find_capability(pdev, PCI_CAP_ID_MSIX);\n\t\tif (pos) {\n\t\t\tpci_read_config_word(pdev, pos + PCI_MSIX_FLAGS,\n\t\t\t\t\t     &control);\n\t\t\tif (control & PCI_MSIX_FLAGS_ENABLE) {\n\t\t\t\tdev_info(&pdev->dev, \"resetting MSI-X\\n\");\n\t\t\t\tpci_write_config_word(pdev,\n\t\t\t\t\t\t      pos + PCI_MSIX_FLAGS,\n\t\t\t\t\t\t      control &\n\t\t\t\t\t\t      ~PCI_MSIX_FLAGS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * PCI prepping: enable device set bus mastering and dma mask\n\t */\n\trval = pci_enable_device_mem(pdev);\n\n\tif (rval) {\n\t\treturn rval;\n\t}\n\n\tpci_set_master(pdev);\n\n\thost = scsi_host_alloc(&megasas_template,\n\t\t\t       sizeof(struct megasas_instance));\n\n\tif (!host) {\n\t\tdev_printk(KERN_DEBUG, &pdev->dev, \"scsi_host_alloc failed\\n\");\n\t\tgoto fail_alloc_instance;\n\t}\n\n\tinstance = (struct megasas_instance *)host->hostdata;\n\tmemset(instance, 0, sizeof(*instance));\n\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t/*\n\t * Initialize PCI related and misc parameters\n\t */\n\tinstance->pdev = pdev;\n\tinstance->host = host;\n\tinstance->unique_id = pdev->bus->number << 8 | pdev->devfn;\n\tinstance->init_id = MEGASAS_DEFAULT_INIT_ID;\n\n\tmegasas_set_adapter_type(instance);\n\n\t/*\n\t * Initialize MFI Firmware\n\t */\n\tif (megasas_init_fw(instance))\n\t\tgoto fail_init_mfi;\n\n\tif (instance->requestorId) {\n\t\tif (instance->PlasmaFW111) {\n\t\t\tinstance->vf_affiliation_111 =\n\t\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t\t&instance->vf_affiliation_111_h,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!instance->vf_affiliation_111)\n\t\t\t\tdev_warn(&pdev->dev, \"Can't allocate \"\n\t\t\t\t       \"memory for VF affiliation buffer\\n\");\n\t\t} else {\n\t\t\tinstance->vf_affiliation =\n\t\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t(MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t\tsizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t\t&instance->vf_affiliation_h,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!instance->vf_affiliation)\n\t\t\t\tdev_warn(&pdev->dev, \"Can't allocate \"\n\t\t\t\t       \"memory for VF affiliation buffer\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * Store instance in PCI softstate\n\t */\n\tpci_set_drvdata(pdev, instance);\n\n\t/*\n\t * Add this controller to megasas_mgmt_info structure so that it\n\t * can be exported to management applications\n\t */\n\tmegasas_mgmt_info.count++;\n\tmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = instance;\n\tmegasas_mgmt_info.max_index++;\n\n\t/*\n\t * Register with SCSI mid-layer\n\t */\n\tif (megasas_io_attach(instance))\n\t\tgoto fail_io_attach;\n\n\tinstance->unload = 0;\n\t/*\n\t * Trigger SCSI to scan our drives\n\t */\n\tif (!instance->enable_fw_dev_list ||\n\t    (instance->host_device_list_buf->count > 0))\n\t\tscsi_scan_host(host);\n\n\t/*\n\t * Initiate AEN (Asynchronous Event Notification)\n\t */\n\tif (megasas_start_aen(instance)) {\n\t\tdev_printk(KERN_DEBUG, &pdev->dev, \"start aen failed\\n\");\n\t\tgoto fail_start_aen;\n\t}\n\n\t/* Get current SR-IOV LD/VF affiliation */\n\tif (instance->requestorId)\n\t\tmegasas_get_ld_vf_affiliation(instance, 1);\n\n\treturn 0;\n\nfail_start_aen:\nfail_io_attach:\n\tmegasas_mgmt_info.count--;\n\tmegasas_mgmt_info.max_index--;\n\tmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = NULL;\n\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_release_fusion(instance);\n\telse\n\t\tmegasas_release_mfi(instance);\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\nfail_init_mfi:\n\tscsi_host_put(host);\nfail_alloc_instance:\n\tpci_disable_device(pdev);\n\n\treturn -ENODEV;\n}\n\n/**\n * megasas_flush_cache -\tRequests FW to flush all its caches\n * @instance:\t\t\tAdapter soft state\n */\nstatic void megasas_flush_cache(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn;\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 0;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = 0;\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_CACHE_FLUSH);\n\tdcmd->mbox.b[0] = MR_FLUSH_CTRL_CACHE | MR_FLUSH_DISK_CACHE;\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS)\n\t\t\t!= DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n}\n\n/**\n * megasas_shutdown_controller -\tInstructs FW to shutdown the controller\n * @instance:\t\t\t\tAdapter soft state\n * @opcode:\t\t\t\tShutdown/Hibernate\n */\nstatic void megasas_shutdown_controller(struct megasas_instance *instance,\n\t\t\t\t\tu32 opcode)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn;\n\n\tif (instance->aen_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->aen_cmd, MFI_IO_TIMEOUT_SECS);\n\tif (instance->map_update_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->map_update_cmd, MFI_IO_TIMEOUT_SECS);\n\tif (instance->jbod_seq_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->jbod_seq_cmd, MFI_IO_TIMEOUT_SECS);\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 0;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = 0;\n\tdcmd->opcode = cpu_to_le32(opcode);\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS)\n\t\t\t!= DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n}\n\n#ifdef CONFIG_PM\n/**\n * megasas_suspend -\tdriver suspend entry point\n * @pdev:\t\tPCI device structure\n * @state:\t\tPCI power state to suspend routine\n */\nstatic int\nmegasas_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\n\tinstance = pci_get_drvdata(pdev);\n\thost = instance->host;\n\tinstance->unload = 1;\n\n\t/* Shutdown SR-IOV heartbeat timer */\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\n\n\t/* Stop the FW fault detection watchdog */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_fusion_stop_watchdog(instance);\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_HIBERNATE_SHUTDOWN);\n\n\t/* cancel the delayed work if this work still in queue */\n\tif (instance->ev != NULL) {\n\t\tstruct megasas_aen_event *ev = instance->ev;\n\t\tcancel_delayed_work_sync(&ev->hotplug_work);\n\t\tinstance->ev = NULL;\n\t}\n\n\ttasklet_kill(&instance->isr_tasklet);\n\n\tpci_set_drvdata(instance->pdev, instance);\n\tinstance->instancet->disable_intr(instance);\n\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n\n/**\n * megasas_resume-      driver resume entry point\n * @pdev:               PCI device structure\n */\nstatic int\nmegasas_resume(struct pci_dev *pdev)\n{\n\tint rval;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tint irq_flags = PCI_IRQ_LEGACY;\n\n\tinstance = pci_get_drvdata(pdev);\n\thost = instance->host;\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\n\t/*\n\t * PCI prepping: enable device set bus mastering and dma mask\n\t */\n\trval = pci_enable_device_mem(pdev);\n\n\tif (rval) {\n\t\tdev_err(&pdev->dev, \"Enable device failed\\n\");\n\t\treturn rval;\n\t}\n\n\tpci_set_master(pdev);\n\n\t/*\n\t * We expect the FW state to be READY\n\t */\n\tif (megasas_transition_to_ready(instance, 0))\n\t\tgoto fail_ready_state;\n\n\tif (megasas_set_dma_mask(instance))\n\t\tgoto fail_set_dma_mask;\n\n\t/*\n\t * Initialize MFI Firmware\n\t */\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\tatomic_set(&instance->ldio_outstanding, 0);\n\n\t/* Now re-enable MSI-X */\n\tif (instance->msix_vectors) {\n\t\tirq_flags = PCI_IRQ_MSIX;\n\t\tif (smp_affinity_enable)\n\t\t\tirq_flags |= PCI_IRQ_AFFINITY;\n\t}\n\trval = pci_alloc_irq_vectors(instance->pdev, 1,\n\t\t\t\t     instance->msix_vectors ?\n\t\t\t\t     instance->msix_vectors : 1, irq_flags);\n\tif (rval < 0)\n\t\tgoto fail_reenable_msix;\n\n\tmegasas_setup_reply_map(instance);\n\n\tif (instance->adapter_type != MFI_SERIES) {\n\t\tmegasas_reset_reply_desc(instance);\n\t\tif (megasas_ioc_init_fusion(instance)) {\n\t\t\tmegasas_free_cmds(instance);\n\t\t\tmegasas_free_cmds_fusion(instance);\n\t\t\tgoto fail_init_mfi;\n\t\t}\n\t\tif (!megasas_get_map_info(instance))\n\t\t\tmegasas_sync_map_info(instance);\n\t} else {\n\t\t*instance->producer = 0;\n\t\t*instance->consumer = 0;\n\t\tif (megasas_issue_init_mfi(instance))\n\t\t\tgoto fail_init_mfi;\n\t}\n\n\tif (megasas_get_ctrl_info(instance) != DCMD_SUCCESS)\n\t\tgoto fail_init_mfi;\n\n\ttasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\n\t\t     (unsigned long)instance);\n\n\tif (instance->msix_vectors ?\n\t\t\tmegasas_setup_irqs_msix(instance, 0) :\n\t\t\tmegasas_setup_irqs_ioapic(instance))\n\t\tgoto fail_init_mfi;\n\n\t/* Re-launch SR-IOV heartbeat timer */\n\tif (instance->requestorId) {\n\t\tif (!megasas_sriov_start_heartbeat(instance, 0))\n\t\t\tmegasas_start_timer(instance);\n\t\telse {\n\t\t\tinstance->skip_heartbeat_timer_del = 1;\n\t\t\tgoto fail_init_mfi;\n\t\t}\n\t}\n\n\tinstance->instancet->enable_intr(instance);\n\tmegasas_setup_jbod_map(instance);\n\tinstance->unload = 0;\n\n\t/*\n\t * Initiate AEN (Asynchronous Event Notification)\n\t */\n\tif (megasas_start_aen(instance))\n\t\tdev_err(&instance->pdev->dev, \"Start AEN failed\\n\");\n\n\t/* Re-launch FW fault watchdog */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tif (megasas_fusion_start_watchdog(instance) != SUCCESS)\n\t\t\tgoto fail_start_watchdog;\n\n\treturn 0;\n\nfail_start_watchdog:\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\nfail_init_mfi:\n\tmegasas_free_ctrl_dma_buffers(instance);\n\tmegasas_free_ctrl_mem(instance);\n\tscsi_host_put(host);\n\nfail_reenable_msix:\nfail_set_dma_mask:\nfail_ready_state:\n\n\tpci_disable_device(pdev);\n\n\treturn -ENODEV;\n}\n#else\n#define megasas_suspend\tNULL\n#define megasas_resume\tNULL\n#endif\n\nstatic inline int\nmegasas_wait_for_adapter_operational(struct megasas_instance *instance)\n{\n\tint wait_time = MEGASAS_RESET_WAIT_TIME * 2;\n\tint i;\n\tu8 adp_state;\n\n\tfor (i = 0; i < wait_time; i++) {\n\t\tadp_state = atomic_read(&instance->adprecovery);\n\t\tif ((adp_state == MEGASAS_HBA_OPERATIONAL) ||\n\t\t    (adp_state == MEGASAS_HW_CRITICAL_ERROR))\n\t\t\tbreak;\n\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL))\n\t\t\tdev_notice(&instance->pdev->dev, \"waiting for controller reset to finish\\n\");\n\n\t\tmsleep(1000);\n\t}\n\n\tif (adp_state != MEGASAS_HBA_OPERATIONAL) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"%s HBA failed to become operational, adp_state %d\\n\",\n\t\t\t __func__, adp_state);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * megasas_detach_one -\tPCI hot\"un\"plug entry point\n * @pdev:\t\tPCI device structure\n */\nstatic void megasas_detach_one(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tstruct fusion_context *fusion;\n\tu32 pd_seq_map_sz;\n\n\tinstance = pci_get_drvdata(pdev);\n\thost = instance->host;\n\tfusion = instance->ctrl_context;\n\n\t/* Shutdown SR-IOV heartbeat timer */\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\n\n\t/* Stop the FW fault detection watchdog */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_fusion_stop_watchdog(instance);\n\n\tif (instance->fw_crash_state != UNAVAILABLE)\n\t\tmegasas_free_host_crash_buffer(instance);\n\tscsi_remove_host(instance->host);\n\tinstance->unload = 1;\n\n\tif (megasas_wait_for_adapter_operational(instance))\n\t\tgoto skip_firing_dcmds;\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\n\nskip_firing_dcmds:\n\t/* cancel the delayed work if this work still in queue*/\n\tif (instance->ev != NULL) {\n\t\tstruct megasas_aen_event *ev = instance->ev;\n\t\tcancel_delayed_work_sync(&ev->hotplug_work);\n\t\tinstance->ev = NULL;\n\t}\n\n\t/* cancel all wait events */\n\twake_up_all(&instance->int_cmd_wait_q);\n\n\ttasklet_kill(&instance->isr_tasklet);\n\n\t/*\n\t * Take the instance off the instance array. Note that we will not\n\t * decrement the max_index. We let this array be sparse array\n\t */\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\t\tif (megasas_mgmt_info.instance[i] == instance) {\n\t\t\tmegasas_mgmt_info.count--;\n\t\t\tmegasas_mgmt_info.instance[i] = NULL;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinstance->instancet->disable_intr(instance);\n\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tfor (i = 0; i < MAX_LOGICAL_DRIVES_EXT; ++i)\n\t\t\tkfree(fusion->stream_detect_by_ld[i]);\n\t\tkfree(fusion->stream_detect_by_ld);\n\t\tfusion->stream_detect_by_ld = NULL;\n\t}\n\n\n\tif (instance->adapter_type != MFI_SERIES) {\n\t\tmegasas_release_fusion(instance);\n\t\t\tpd_seq_map_sz = sizeof(struct MR_PD_CFG_SEQ_NUM_SYNC) +\n\t\t\t\t(sizeof(struct MR_PD_CFG_SEQ) *\n\t\t\t\t\t(MAX_PHYSICAL_DEVICES - 1));\n\t\tfor (i = 0; i < 2 ; i++) {\n\t\t\tif (fusion->ld_map[i])\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\t\t  fusion->max_map_sz,\n\t\t\t\t\t\t  fusion->ld_map[i],\n\t\t\t\t\t\t  fusion->ld_map_phys[i]);\n\t\t\tif (fusion->ld_drv_map[i]) {\n\t\t\t\tif (is_vmalloc_addr(fusion->ld_drv_map[i]))\n\t\t\t\t\tvfree(fusion->ld_drv_map[i]);\n\t\t\t\telse\n\t\t\t\t\tfree_pages((ulong)fusion->ld_drv_map[i],\n\t\t\t\t\t\t   fusion->drv_map_pages);\n\t\t\t}\n\n\t\t\tif (fusion->pd_seq_sync[i])\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tpd_seq_map_sz,\n\t\t\t\t\tfusion->pd_seq_sync[i],\n\t\t\t\t\tfusion->pd_seq_phys[i]);\n\t\t}\n\t} else {\n\t\tmegasas_release_mfi(instance);\n\t}\n\n\tif (instance->vf_affiliation)\n\t\tdma_free_coherent(&pdev->dev, (MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t    instance->vf_affiliation,\n\t\t\t\t    instance->vf_affiliation_h);\n\n\tif (instance->vf_affiliation_111)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t    instance->vf_affiliation_111,\n\t\t\t\t    instance->vf_affiliation_111_h);\n\n\tif (instance->hb_host_mem)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_CTRL_HB_HOST_MEM),\n\t\t\t\t    instance->hb_host_mem,\n\t\t\t\t    instance->hb_host_mem_h);\n\n\tmegasas_free_ctrl_dma_buffers(instance);\n\n\tmegasas_free_ctrl_mem(instance);\n\n\tscsi_host_put(host);\n\n\tpci_disable_device(pdev);\n}\n\n/**\n * megasas_shutdown -\tShutdown entry point\n * @device:\t\tGeneric device structure\n */\nstatic void megasas_shutdown(struct pci_dev *pdev)\n{\n\tstruct megasas_instance *instance = pci_get_drvdata(pdev);\n\n\tinstance->unload = 1;\n\n\tif (megasas_wait_for_adapter_operational(instance))\n\t\tgoto skip_firing_dcmds;\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\n\nskip_firing_dcmds:\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n}\n\n/**\n * megasas_mgmt_open -\tchar node \"open\" entry point\n */\nstatic int megasas_mgmt_open(struct inode *inode, struct file *filep)\n{\n\t/*\n\t * Allow only those users with admin rights\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\n/**\n * megasas_mgmt_fasync -\tAsync notifier registration from applications\n *\n * This function adds the calling process to a driver global queue. When an\n * event occurs, SIGIO will be sent to all processes in this queue.\n */\nstatic int megasas_mgmt_fasync(int fd, struct file *filep, int mode)\n{\n\tint rc;\n\n\tmutex_lock(&megasas_async_queue_mutex);\n\n\trc = fasync_helper(fd, filep, mode, &megasas_async_queue);\n\n\tmutex_unlock(&megasas_async_queue_mutex);\n\n\tif (rc >= 0) {\n\t\t/* For sanity check when we get ioctl */\n\t\tfilep->private_data = filep;\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_DEBUG \"megasas: fasync_helper failed [%d]\\n\", rc);\n\n\treturn rc;\n}\n\n/**\n * megasas_mgmt_poll -  char node \"poll\" entry point\n * */\nstatic __poll_t megasas_mgmt_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t mask;\n\tunsigned long flags;\n\n\tpoll_wait(file, &megasas_poll_wait, wait);\n\tspin_lock_irqsave(&poll_aen_lock, flags);\n\tif (megasas_poll_wait_aen)\n\t\tmask = (EPOLLIN | EPOLLRDNORM);\n\telse\n\t\tmask = 0;\n\tmegasas_poll_wait_aen = 0;\n\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\treturn mask;\n}\n\n/*\n * megasas_set_crash_dump_params_ioctl:\n *\t\tSend CRASH_DUMP_MODE DCMD to all controllers\n * @cmd:\tMFI command frame\n */\n\nstatic int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)\n{\n\tstruct megasas_instance *local_instance;\n\tint i, error = 0;\n\tint crash_support;\n\n\tcrash_support = cmd->frame->dcmd.mbox.w[0];\n\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\t\tlocal_instance = megasas_mgmt_info.instance[i];\n\t\tif (local_instance && local_instance->crash_dump_drv_support) {\n\t\t\tif ((atomic_read(&local_instance->adprecovery) ==\n\t\t\t\tMEGASAS_HBA_OPERATIONAL) &&\n\t\t\t\t!megasas_set_crash_dump_params(local_instance,\n\t\t\t\t\tcrash_support)) {\n\t\t\t\tlocal_instance->crash_dump_app_support =\n\t\t\t\t\tcrash_support;\n\t\t\t\tdev_info(&local_instance->pdev->dev,\n\t\t\t\t\t\"Application firmware crash \"\n\t\t\t\t\t\"dump mode set success\\n\");\n\t\t\t\terror = 0;\n\t\t\t} else {\n\t\t\t\tdev_info(&local_instance->pdev->dev,\n\t\t\t\t\t\"Application firmware crash \"\n\t\t\t\t\t\"dump mode set failed\\n\");\n\t\t\t\terror = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn error;\n}\n\n/**\n * megasas_mgmt_fw_ioctl -\tIssues management ioctls to FW\n * @instance:\t\t\tAdapter soft state\n * @argp:\t\t\tUser's ioctl packet\n */\nstatic int\nmegasas_mgmt_fw_ioctl(struct megasas_instance *instance,\n\t\t      struct megasas_iocpacket __user * user_ioc,\n\t\t      struct megasas_iocpacket *ioc)\n{\n\tstruct megasas_sge64 *kern_sge64 = NULL;\n\tstruct megasas_sge32 *kern_sge32 = NULL;\n\tstruct megasas_cmd *cmd;\n\tvoid *kbuff_arr[MAX_IOCTL_SGE];\n\tdma_addr_t buf_handle = 0;\n\tint error = 0, i;\n\tvoid *sense = NULL;\n\tdma_addr_t sense_handle;\n\tunsigned long *sense_ptr;\n\tu32 opcode = 0;\n\n\tmemset(kbuff_arr, 0, sizeof(kbuff_arr));\n\n\tif (ioc->sge_count > MAX_IOCTL_SGE) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SGE count [%d] >  max limit [%d]\\n\",\n\t\t       ioc->sge_count, MAX_IOCTL_SGE);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ioc->frame.hdr.cmd >= MFI_CMD_OP_COUNT) ||\n\t    ((ioc->frame.hdr.cmd == MFI_CMD_NVME) &&\n\t    !instance->support_nvme_passthru)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Received invalid ioctl command 0x%x\\n\",\n\t\t\tioc->frame.hdr.cmd);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tcmd = megasas_get_cmd(instance);\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to get a cmd packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * User's IOCTL packet has 2 frames (maximum). Copy those two\n\t * frames into our cmd's frames. cmd->frame's context will get\n\t * overwritten when we copy from user's frames. So set that value\n\t * alone separately\n\t */\n\tmemcpy(cmd->frame, ioc->frame.raw, 2 * MEGAMFI_FRAME_SIZE);\n\tcmd->frame->hdr.context = cpu_to_le32(cmd->index);\n\tcmd->frame->hdr.pad_0 = 0;\n\n\tcmd->frame->hdr.flags &= (~MFI_FRAME_IEEE);\n\n\tif (instance->consistent_mask_64bit)\n\t\tcmd->frame->hdr.flags |= cpu_to_le16((MFI_FRAME_SGL64 |\n\t\t\t\t       MFI_FRAME_SENSE64));\n\telse\n\t\tcmd->frame->hdr.flags &= cpu_to_le16(~(MFI_FRAME_SGL64 |\n\t\t\t\t\t       MFI_FRAME_SENSE64));\n\n\tif (cmd->frame->hdr.cmd == MFI_CMD_DCMD)\n\t\topcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n\n\tif (opcode == MR_DCMD_CTRL_SHUTDOWN) {\n\t\tif (megasas_get_ctrl_info(instance) != DCMD_SUCCESS) {\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (opcode == MR_DRIVER_SET_APP_CRASHDUMP_MODE) {\n\t\terror = megasas_set_crash_dump_params_ioctl(cmd);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn error;\n\t}\n\n\t/*\n\t * The management interface between applications and the fw uses\n\t * MFI frames. E.g, RAID configuration changes, LD property changes\n\t * etc are accomplishes through different kinds of MFI frames. The\n\t * driver needs to care only about substituting user buffers with\n\t * kernel buffers in SGLs. The location of SGL is embedded in the\n\t * struct iocpacket itself.\n\t */\n\tif (instance->consistent_mask_64bit)\n\t\tkern_sge64 = (struct megasas_sge64 *)\n\t\t\t((unsigned long)cmd->frame + ioc->sgl_off);\n\telse\n\t\tkern_sge32 = (struct megasas_sge32 *)\n\t\t\t((unsigned long)cmd->frame + ioc->sgl_off);\n\n\t/*\n\t * For each user buffer, create a mirror buffer and copy in\n\t */\n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (!ioc->sgl[i].iov_len)\n\t\t\tcontinue;\n\n\t\tkbuff_arr[i] = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t\t    ioc->sgl[i].iov_len,\n\t\t\t\t\t\t    &buf_handle, GFP_KERNEL);\n\t\tif (!kbuff_arr[i]) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to alloc \"\n\t\t\t       \"kernel SGL buffer for IOCTL\\n\");\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We don't change the dma_coherent_mask, so\n\t\t * dma_alloc_coherent only returns 32bit addresses\n\t\t */\n\t\tif (instance->consistent_mask_64bit) {\n\t\t\tkern_sge64[i].phys_addr = cpu_to_le64(buf_handle);\n\t\t\tkern_sge64[i].length = cpu_to_le32(ioc->sgl[i].iov_len);\n\t\t} else {\n\t\t\tkern_sge32[i].phys_addr = cpu_to_le32(buf_handle);\n\t\t\tkern_sge32[i].length = cpu_to_le32(ioc->sgl[i].iov_len);\n\t\t}\n\n\t\t/*\n\t\t * We created a kernel buffer corresponding to the\n\t\t * user buffer. Now copy in from the user buffer\n\t\t */\n\t\tif (copy_from_user(kbuff_arr[i], ioc->sgl[i].iov_base,\n\t\t\t\t   (u32) (ioc->sgl[i].iov_len))) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ioc->sense_len) {\n\t\tsense = dma_alloc_coherent(&instance->pdev->dev, ioc->sense_len,\n\t\t\t\t\t     &sense_handle, GFP_KERNEL);\n\t\tif (!sense) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsense_ptr =\n\t\t(unsigned long *) ((unsigned long)cmd->frame + ioc->sense_off);\n\t\tif (instance->consistent_mask_64bit)\n\t\t\t*sense_ptr = cpu_to_le64(sense_handle);\n\t\telse\n\t\t\t*sense_ptr = cpu_to_le32(sense_handle);\n\t}\n\n\t/*\n\t * Set the sync_cmd flag so that the ISR knows not to complete this\n\t * cmd to the SCSI mid-layer\n\t */\n\tcmd->sync_cmd = 1;\n\tif (megasas_issue_blocked_cmd(instance, cmd, 0) == DCMD_NOT_FIRED) {\n\t\tcmd->sync_cmd = 0;\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return -EBUSY from %s %d cmd 0x%x opcode 0x%x cmd->cmd_status_drv 0x%x\\n\",\n\t\t\t__func__, __LINE__, cmd->frame->hdr.cmd, opcode,\n\t\t\tcmd->cmd_status_drv);\n\t\treturn -EBUSY;\n\t}\n\n\tcmd->sync_cmd = 0;\n\n\tif (instance->unload == 1) {\n\t\tdev_info(&instance->pdev->dev, \"Driver unload is in progress \"\n\t\t\t\"don't submit data to application\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * copy out the kernel buffers to user buffers\n\t */\n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (copy_to_user(ioc->sgl[i].iov_base, kbuff_arr[i],\n\t\t\t\t ioc->sgl[i].iov_len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * copy out the sense\n\t */\n\tif (ioc->sense_len) {\n\t\t/*\n\t\t * sense_ptr points to the location that has the user\n\t\t * sense buffer address\n\t\t */\n\t\tsense_ptr = (unsigned long *) ((unsigned long)ioc->frame.raw +\n\t\t\t\tioc->sense_off);\n\n\t\tif (copy_to_user((void __user *)((unsigned long)\n\t\t\t\t get_unaligned((unsigned long *)sense_ptr)),\n\t\t\t\t sense, ioc->sense_len)) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed to copy out to user \"\n\t\t\t\t\t\"sense data\\n\");\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * copy the status codes returned by the fw\n\t */\n\tif (copy_to_user(&user_ioc->frame.hdr.cmd_status,\n\t\t\t &cmd->frame->hdr.cmd_status, sizeof(u8))) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error copying out cmd_status\\n\");\n\t\terror = -EFAULT;\n\t}\n\nout:\n\tif (sense) {\n\t\tdma_free_coherent(&instance->pdev->dev, ioc->sense_len,\n\t\t\t\t    sense, sense_handle);\n\t}\n\n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (kbuff_arr[i]) {\n\t\t\tif (instance->consistent_mask_64bit)\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tle32_to_cpu(kern_sge64[i].length),\n\t\t\t\t\tkbuff_arr[i],\n\t\t\t\t\tle64_to_cpu(kern_sge64[i].phys_addr));\n\t\t\telse\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tle32_to_cpu(kern_sge32[i].length),\n\t\t\t\t\tkbuff_arr[i],\n\t\t\t\t\tle32_to_cpu(kern_sge32[i].phys_addr));\n\t\t\tkbuff_arr[i] = NULL;\n\t\t}\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\treturn error;\n}\n\nstatic int megasas_mgmt_ioctl_fw(struct file *file, unsigned long arg)\n{\n\tstruct megasas_iocpacket __user *user_ioc =\n\t    (struct megasas_iocpacket __user *)arg;\n\tstruct megasas_iocpacket *ioc;\n\tstruct megasas_instance *instance;\n\tint error;\n\n\tioc = memdup_user(user_ioc, sizeof(*ioc));\n\tif (IS_ERR(ioc))\n\t\treturn PTR_ERR(ioc);\n\n\tinstance = megasas_lookup_instance(ioc->host_no);\n\tif (!instance) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\t/* Block ioctls in VF mode */\n\tif (instance->requestorId && !allow_vf_ioctls) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Controller in crit error\\n\");\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (instance->unload == 1) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (down_interruptible(&instance->ioctl_sem)) {\n\t\terror = -ERESTARTSYS;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif  (megasas_wait_for_adapter_operational(instance)) {\n\t\terror = -ENODEV;\n\t\tgoto out_up;\n\t}\n\n\terror = megasas_mgmt_fw_ioctl(instance, user_ioc, ioc);\nout_up:\n\tup(&instance->ioctl_sem);\n\nout_kfree_ioc:\n\tkfree(ioc);\n\treturn error;\n}\n\nstatic int megasas_mgmt_ioctl_aen(struct file *file, unsigned long arg)\n{\n\tstruct megasas_instance *instance;\n\tstruct megasas_aen aen;\n\tint error;\n\n\tif (file->private_data != file) {\n\t\tprintk(KERN_DEBUG \"megasas: fasync_helper was not \"\n\t\t       \"called first\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&aen, (void __user *)arg, sizeof(aen)))\n\t\treturn -EFAULT;\n\n\tinstance = megasas_lookup_instance(aen.host_no);\n\n\tif (!instance)\n\t\treturn -ENODEV;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\treturn -ENODEV;\n\t}\n\n\tif (instance->unload == 1) {\n\t\treturn -ENODEV;\n\t}\n\n\tif  (megasas_wait_for_adapter_operational(instance))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&instance->reset_mutex);\n\terror = megasas_register_aen(instance, aen.seq_num,\n\t\t\t\t     aen.class_locale_word);\n\tmutex_unlock(&instance->reset_mutex);\n\treturn error;\n}\n\n/**\n * megasas_mgmt_ioctl -\tchar node ioctl entry point\n */\nstatic long\nmegasas_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase MEGASAS_IOC_FIRMWARE:\n\t\treturn megasas_mgmt_ioctl_fw(file, arg);\n\n\tcase MEGASAS_IOC_GET_AEN:\n\t\treturn megasas_mgmt_ioctl_aen(file, arg);\n\t}\n\n\treturn -ENOTTY;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int megasas_mgmt_compat_ioctl_fw(struct file *file, unsigned long arg)\n{\n\tstruct compat_megasas_iocpacket __user *cioc =\n\t    (struct compat_megasas_iocpacket __user *)arg;\n\tstruct megasas_iocpacket __user *ioc =\n\t    compat_alloc_user_space(sizeof(struct megasas_iocpacket));\n\tint i;\n\tint error = 0;\n\tcompat_uptr_t ptr;\n\tu32 local_sense_off;\n\tu32 local_sense_len;\n\tu32 user_sense_off;\n\n\tif (clear_user(ioc, sizeof(*ioc)))\n\t\treturn -EFAULT;\n\n\tif (copy_in_user(&ioc->host_no, &cioc->host_no, sizeof(u16)) ||\n\t    copy_in_user(&ioc->sgl_off, &cioc->sgl_off, sizeof(u32)) ||\n\t    copy_in_user(&ioc->sense_off, &cioc->sense_off, sizeof(u32)) ||\n\t    copy_in_user(&ioc->sense_len, &cioc->sense_len, sizeof(u32)) ||\n\t    copy_in_user(ioc->frame.raw, cioc->frame.raw, 128) ||\n\t    copy_in_user(&ioc->sge_count, &cioc->sge_count, sizeof(u32)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * The sense_ptr is used in megasas_mgmt_fw_ioctl only when\n\t * sense_len is not null, so prepare the 64bit value under\n\t * the same condition.\n\t */\n\tif (get_user(local_sense_off, &ioc->sense_off) ||\n\t\tget_user(local_sense_len, &ioc->sense_len) ||\n\t\tget_user(user_sense_off, &cioc->sense_off))\n\t\treturn -EFAULT;\n\n\tif (local_sense_off != user_sense_off)\n\t\treturn -EINVAL;\n\n\tif (local_sense_len) {\n\t\tvoid __user **sense_ioc_ptr =\n\t\t\t(void __user **)((u8 *)((unsigned long)&ioc->frame.raw) + local_sense_off);\n\t\tcompat_uptr_t *sense_cioc_ptr =\n\t\t\t(compat_uptr_t *)(((unsigned long)&cioc->frame.raw) + user_sense_off);\n\t\tif (get_user(ptr, sense_cioc_ptr) ||\n\t\t    put_user(compat_ptr(ptr), sense_ioc_ptr))\n\t\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < MAX_IOCTL_SGE; i++) {\n\t\tif (get_user(ptr, &cioc->sgl[i].iov_base) ||\n\t\t    put_user(compat_ptr(ptr), &ioc->sgl[i].iov_base) ||\n\t\t    copy_in_user(&ioc->sgl[i].iov_len,\n\t\t\t\t &cioc->sgl[i].iov_len, sizeof(compat_size_t)))\n\t\t\treturn -EFAULT;\n\t}\n\n\terror = megasas_mgmt_ioctl_fw(file, (unsigned long)ioc);\n\n\tif (copy_in_user(&cioc->frame.hdr.cmd_status,\n\t\t\t &ioc->frame.hdr.cmd_status, sizeof(u8))) {\n\t\tprintk(KERN_DEBUG \"megasas: error copy_in_user cmd_status\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn error;\n}\n\nstatic long\nmegasas_mgmt_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase MEGASAS_IOC_FIRMWARE32:\n\t\treturn megasas_mgmt_compat_ioctl_fw(file, arg);\n\tcase MEGASAS_IOC_GET_AEN:\n\t\treturn megasas_mgmt_ioctl_aen(file, arg);\n\t}\n\n\treturn -ENOTTY;\n}\n#endif\n\n/*\n * File operations structure for management interface\n */\nstatic const struct file_operations megasas_mgmt_fops = {\n\t.owner = THIS_MODULE,\n\t.open = megasas_mgmt_open,\n\t.fasync = megasas_mgmt_fasync,\n\t.unlocked_ioctl = megasas_mgmt_ioctl,\n\t.poll = megasas_mgmt_poll,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = megasas_mgmt_compat_ioctl,\n#endif\n\t.llseek = noop_llseek,\n};\n\n/*\n * PCI hotplug support registration structure\n */\nstatic struct pci_driver megasas_pci_driver = {\n\n\t.name = \"megaraid_sas\",\n\t.id_table = megasas_pci_table,\n\t.probe = megasas_probe_one,\n\t.remove = megasas_detach_one,\n\t.suspend = megasas_suspend,\n\t.resume = megasas_resume,\n\t.shutdown = megasas_shutdown,\n};\n\n/*\n * Sysfs driver attributes\n */\nstatic ssize_t version_show(struct device_driver *dd, char *buf)\n{\n\treturn snprintf(buf, strlen(MEGASAS_VERSION) + 2, \"%s\\n\",\n\t\t\tMEGASAS_VERSION);\n}\nstatic DRIVER_ATTR_RO(version);\n\nstatic ssize_t release_date_show(struct device_driver *dd, char *buf)\n{\n\treturn snprintf(buf, strlen(MEGASAS_RELDATE) + 2, \"%s\\n\",\n\t\tMEGASAS_RELDATE);\n}\nstatic DRIVER_ATTR_RO(release_date);\n\nstatic ssize_t support_poll_for_event_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_poll_for_event);\n}\nstatic DRIVER_ATTR_RO(support_poll_for_event);\n\nstatic ssize_t support_device_change_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_device_change);\n}\nstatic DRIVER_ATTR_RO(support_device_change);\n\nstatic ssize_t dbg_lvl_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", megasas_dbg_lvl);\n}\n\nstatic ssize_t dbg_lvl_store(struct device_driver *dd, const char *buf,\n\t\t\t     size_t count)\n{\n\tint retval = count;\n\n\tif (sscanf(buf, \"%u\", &megasas_dbg_lvl) < 1) {\n\t\tprintk(KERN_ERR \"megasas: could not set dbg_lvl\\n\");\n\t\tretval = -EINVAL;\n\t}\n\treturn retval;\n}\nstatic DRIVER_ATTR_RW(dbg_lvl);\n\nstatic ssize_t\nsupport_nvme_encapsulation_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_nvme_encapsulation);\n}\n\nstatic DRIVER_ATTR_RO(support_nvme_encapsulation);\n\nstatic inline void megasas_remove_scsi_device(struct scsi_device *sdev)\n{\n\tsdev_printk(KERN_INFO, sdev, \"SCSI device is removed\\n\");\n\tscsi_remove_device(sdev);\n\tscsi_device_put(sdev);\n}\n\n/**\n * megasas_update_device_list -\tUpdate the PD and LD device list from FW\n *\t\t\t\tafter an AEN event notification\n * @instance:\t\t\tAdapter soft state\n * @event_type:\t\t\tIndicates type of event (PD or LD event)\n *\n * @return:\t\t\tSuccess or failure\n *\n * Issue DCMDs to Firmware to update the internal device list in driver.\n * Based on the FW support, driver sends the HOST_DEVICE_LIST or combination\n * of PD_LIST/LD_LIST_QUERY DCMDs to get the device list.\n */\nstatic\nint megasas_update_device_list(struct megasas_instance *instance,\n\t\t\t       int event_type)\n{\n\tint dcmd_ret = DCMD_SUCCESS;\n\n\tif (instance->enable_fw_dev_list) {\n\t\tdcmd_ret = megasas_host_device_list_query(instance, false);\n\t\tif (dcmd_ret != DCMD_SUCCESS)\n\t\t\tgoto out;\n\t} else {\n\t\tif (event_type & SCAN_PD_CHANNEL) {\n\t\t\tdcmd_ret = megasas_get_pd_list(instance);\n\n\t\t\tif (dcmd_ret != DCMD_SUCCESS)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (event_type & SCAN_VD_CHANNEL) {\n\t\t\tif (!instance->requestorId ||\n\t\t\t    (instance->requestorId &&\n\t\t\t     megasas_get_ld_vf_affiliation(instance, 0))) {\n\t\t\t\tdcmd_ret = megasas_ld_list_query(instance,\n\t\t\t\t\t\tMR_LD_QUERY_TYPE_EXPOSED_TO_HOST);\n\t\t\t\tif (dcmd_ret != DCMD_SUCCESS)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn dcmd_ret;\n}\n\n/**\n * megasas_add_remove_devices -\tAdd/remove devices to SCSI mid-layer\n *\t\t\t\tafter an AEN event notification\n * @instance:\t\t\tAdapter soft state\n * @scan_type:\t\t\tIndicates type of devices (PD/LD) to add\n * @return\t\t\tvoid\n */\nstatic\nvoid megasas_add_remove_devices(struct megasas_instance *instance,\n\t\t\t\tint scan_type)\n{\n\tint i, j;\n\tu16 pd_index = 0;\n\tu16 ld_index = 0;\n\tu16 channel = 0, id = 0;\n\tstruct Scsi_Host *host;\n\tstruct scsi_device *sdev1;\n\tstruct MR_HOST_DEVICE_LIST *targetid_list = NULL;\n\tstruct MR_HOST_DEVICE_LIST_ENTRY *targetid_entry = NULL;\n\n\thost = instance->host;\n\n\tif (instance->enable_fw_dev_list) {\n\t\ttargetid_list = instance->host_device_list_buf;\n\t\tfor (i = 0; i < targetid_list->count; i++) {\n\t\t\ttargetid_entry = &targetid_list->host_device_list[i];\n\t\t\tif (targetid_entry->flags.u.bits.is_sys_pd) {\n\t\t\t\tchannel = le16_to_cpu(targetid_entry->target_id) /\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t\tid = le16_to_cpu(targetid_entry->target_id) %\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t} else {\n\t\t\t\tchannel = MEGASAS_MAX_PD_CHANNELS +\n\t\t\t\t\t  (le16_to_cpu(targetid_entry->target_id) /\n\t\t\t\t\t   MEGASAS_MAX_DEV_PER_CHANNEL);\n\t\t\t\tid = le16_to_cpu(targetid_entry->target_id) %\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t}\n\t\t\tsdev1 = scsi_device_lookup(host, channel, id, 0);\n\t\t\tif (!sdev1) {\n\t\t\t\tscsi_add_device(host, channel, id, 0);\n\t\t\t} else {\n\t\t\t\tscsi_device_put(sdev1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scan_type & SCAN_PD_CHANNEL) {\n\t\tfor (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {\n\t\t\tfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\n\t\t\t\tpd_index = i * MEGASAS_MAX_DEV_PER_CHANNEL + j;\n\t\t\t\tsdev1 = scsi_device_lookup(host, i, j, 0);\n\t\t\t\tif (instance->pd_list[pd_index].driveState ==\n\t\t\t\t\t\t\tMR_PD_STATE_SYSTEM) {\n\t\t\t\t\tif (!sdev1)\n\t\t\t\t\t\tscsi_add_device(host, i, j, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tscsi_device_put(sdev1);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdev1)\n\t\t\t\t\t\tmegasas_remove_scsi_device(sdev1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scan_type & SCAN_VD_CHANNEL) {\n\t\tfor (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {\n\t\t\tfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\n\t\t\t\tld_index = (i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\n\t\t\t\tsdev1 = scsi_device_lookup(host,\n\t\t\t\t\t\tMEGASAS_MAX_PD_CHANNELS + i, j, 0);\n\t\t\t\tif (instance->ld_ids[ld_index] != 0xff) {\n\t\t\t\t\tif (!sdev1)\n\t\t\t\t\t\tscsi_add_device(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tscsi_device_put(sdev1);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdev1)\n\t\t\t\t\t\tmegasas_remove_scsi_device(sdev1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nstatic void\nmegasas_aen_polling(struct work_struct *work)\n{\n\tstruct megasas_aen_event *ev =\n\t\tcontainer_of(work, struct megasas_aen_event, hotplug_work.work);\n\tstruct megasas_instance *instance = ev->instance;\n\tunion megasas_evt_class_locale class_locale;\n\tint event_type = 0;\n\tu32 seq_num, wait_time = MEGASAS_RESET_WAIT_TIME;\n\tint error;\n\tu8  dcmd_ret = DCMD_SUCCESS;\n\n\tif (!instance) {\n\t\tprintk(KERN_ERR \"invalid instance!\\n\");\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\t/* Adjust event workqueue thread wait time for VF mode */\n\tif (instance->requestorId)\n\t\twait_time = MEGASAS_ROUTINE_WAIT_TIME_VF;\n\n\t/* Don't run the event workqueue thread if OCR is running */\n\tmutex_lock(&instance->reset_mutex);\n\n\tinstance->ev = NULL;\n\tif (instance->evt_detail) {\n\t\tmegasas_decode_evt(instance);\n\n\t\tswitch (le32_to_cpu(instance->evt_detail->code)) {\n\n\t\tcase MR_EVT_PD_INSERTED:\n\t\tcase MR_EVT_PD_REMOVED:\n\t\t\tevent_type = SCAN_PD_CHANNEL;\n\t\t\tbreak;\n\n\t\tcase MR_EVT_LD_OFFLINE:\n\t\tcase MR_EVT_CFG_CLEARED:\n\t\tcase MR_EVT_LD_DELETED:\n\t\tcase MR_EVT_LD_CREATED:\n\t\t\tevent_type = SCAN_VD_CHANNEL;\n\t\t\tbreak;\n\n\t\tcase MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED:\n\t\tcase MR_EVT_FOREIGN_CFG_IMPORTED:\n\t\tcase MR_EVT_LD_STATE_CHANGE:\n\t\t\tevent_type = SCAN_PD_CHANNEL | SCAN_VD_CHANNEL;\n\t\t\tdev_info(&instance->pdev->dev, \"scanning for scsi%d...\\n\",\n\t\t\t\tinstance->host->host_no);\n\t\t\tbreak;\n\n\t\tcase MR_EVT_CTRL_PROP_CHANGED:\n\t\t\tdcmd_ret = megasas_get_ctrl_info(instance);\n\t\t\tif (dcmd_ret == DCMD_SUCCESS &&\n\t\t\t    instance->snapdump_wait_time) {\n\t\t\t\tmegasas_get_snapdump_properties(instance);\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t \"Snap dump wait time\\t: %d\\n\",\n\t\t\t\t\t instance->snapdump_wait_time);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tevent_type = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdev_err(&instance->pdev->dev, \"invalid evt_detail!\\n\");\n\t\tmutex_unlock(&instance->reset_mutex);\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\tif (event_type)\n\t\tdcmd_ret = megasas_update_device_list(instance, event_type);\n\n\tmutex_unlock(&instance->reset_mutex);\n\n\tif (event_type && dcmd_ret == DCMD_SUCCESS)\n\t\tmegasas_add_remove_devices(instance, event_type);\n\n\tif (dcmd_ret == DCMD_SUCCESS)\n\t\tseq_num = le32_to_cpu(instance->evt_detail->seq_num) + 1;\n\telse\n\t\tseq_num = instance->last_seq_num;\n\n\t/* Register AEN with FW for latest sequence number plus 1 */\n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\tif (instance->aen_cmd != NULL) {\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\terror = megasas_register_aen(instance, seq_num,\n\t\t\t\t\tclass_locale.word);\n\tif (error)\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"register aen failed error %x\\n\", error);\n\n\tmutex_unlock(&instance->reset_mutex);\n\tkfree(ev);\n}\n\n/**\n * megasas_init - Driver load entry point\n */\nstatic int __init megasas_init(void)\n{\n\tint rval;\n\n\t/*\n\t * Booted in kdump kernel, minimize memory footprints by\n\t * disabling few features\n\t */\n\tif (reset_devices) {\n\t\tmsix_vectors = 1;\n\t\trdpq_enable = 0;\n\t\tdual_qdepth_disable = 1;\n\t}\n\n\t/*\n\t * Announce driver version and other information\n\t */\n\tpr_info(\"megasas: %s\\n\", MEGASAS_VERSION);\n\n\tspin_lock_init(&poll_aen_lock);\n\n\tsupport_poll_for_event = 2;\n\tsupport_device_change = 1;\n\tsupport_nvme_encapsulation = true;\n\n\tmemset(&megasas_mgmt_info, 0, sizeof(megasas_mgmt_info));\n\n\t/*\n\t * Register character device node\n\t */\n\trval = register_chrdev(0, \"megaraid_sas_ioctl\", &megasas_mgmt_fops);\n\n\tif (rval < 0) {\n\t\tprintk(KERN_DEBUG \"megasas: failed to open device node\\n\");\n\t\treturn rval;\n\t}\n\n\tmegasas_mgmt_majorno = rval;\n\n\t/*\n\t * Register ourselves as PCI hotplug module\n\t */\n\trval = pci_register_driver(&megasas_pci_driver);\n\n\tif (rval) {\n\t\tprintk(KERN_DEBUG \"megasas: PCI hotplug registration failed \\n\");\n\t\tgoto err_pcidrv;\n\t}\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_version);\n\tif (rval)\n\t\tgoto err_dcf_attr_ver;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_release_date);\n\tif (rval)\n\t\tgoto err_dcf_rel_date;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t&driver_attr_support_poll_for_event);\n\tif (rval)\n\t\tgoto err_dcf_support_poll_for_event;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_dbg_lvl);\n\tif (rval)\n\t\tgoto err_dcf_dbg_lvl;\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t&driver_attr_support_device_change);\n\tif (rval)\n\t\tgoto err_dcf_support_device_change;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_support_nvme_encapsulation);\n\tif (rval)\n\t\tgoto err_dcf_support_nvme_encapsulation;\n\n\treturn rval;\n\nerr_dcf_support_nvme_encapsulation:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_device_change);\n\nerr_dcf_support_device_change:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_dbg_lvl);\nerr_dcf_dbg_lvl:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_poll_for_event);\nerr_dcf_support_poll_for_event:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_release_date);\nerr_dcf_rel_date:\n\tdriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\nerr_dcf_attr_ver:\n\tpci_unregister_driver(&megasas_pci_driver);\nerr_pcidrv:\n\tunregister_chrdev(megasas_mgmt_majorno, \"megaraid_sas_ioctl\");\n\treturn rval;\n}\n\n/**\n * megasas_exit - Driver unload entry point\n */\nstatic void __exit megasas_exit(void)\n{\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_dbg_lvl);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_poll_for_event);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_device_change);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_release_date);\n\tdriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_nvme_encapsulation);\n\n\tpci_unregister_driver(&megasas_pci_driver);\n\tunregister_chrdev(megasas_mgmt_majorno, \"megaraid_sas_ioctl\");\n}\n\nmodule_init(megasas_init);\nmodule_exit(megasas_exit);\n"], "fixing_code": ["/*\n *  Linux MegaRAID driver for SAS based RAID controllers\n *\n *  Copyright (c) 2003-2013  LSI Corporation\n *  Copyright (c) 2013-2016  Avago Technologies\n *  Copyright (c) 2016-2018  Broadcom Inc.\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License\n *  as published by the Free Software Foundation; either version 2\n *  of the License, or (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program.  If not, see <http://www.gnu.org/licenses/>.\n *\n *  Authors: Broadcom Inc.\n *           Sreenivas Bagalkote\n *           Sumant Patro\n *           Bo Yang\n *           Adam Radford\n *           Kashyap Desai <kashyap.desai@broadcom.com>\n *           Sumit Saxena <sumit.saxena@broadcom.com>\n *\n *  Send feedback to: megaraidlinux.pdl@broadcom.com\n */\n\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/pci.h>\n#include <linux/list.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/spinlock.h>\n#include <linux/interrupt.h>\n#include <linux/delay.h>\n#include <linux/uio.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <asm/unaligned.h>\n#include <linux/fs.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/mutex.h>\n#include <linux/poll.h>\n#include <linux/vmalloc.h>\n\n#include <scsi/scsi.h>\n#include <scsi/scsi_cmnd.h>\n#include <scsi/scsi_device.h>\n#include <scsi/scsi_host.h>\n#include <scsi/scsi_tcq.h>\n#include \"megaraid_sas_fusion.h\"\n#include \"megaraid_sas.h\"\n\n/*\n * Number of sectors per IO command\n * Will be set in megasas_init_mfi if user does not provide\n */\nstatic unsigned int max_sectors;\nmodule_param_named(max_sectors, max_sectors, int, 0);\nMODULE_PARM_DESC(max_sectors,\n\t\"Maximum number of sectors per IO command\");\n\nstatic int msix_disable;\nmodule_param(msix_disable, int, S_IRUGO);\nMODULE_PARM_DESC(msix_disable, \"Disable MSI-X interrupt handling. Default: 0\");\n\nstatic unsigned int msix_vectors;\nmodule_param(msix_vectors, int, S_IRUGO);\nMODULE_PARM_DESC(msix_vectors, \"MSI-X max vector count. Default: Set by FW\");\n\nstatic int allow_vf_ioctls;\nmodule_param(allow_vf_ioctls, int, S_IRUGO);\nMODULE_PARM_DESC(allow_vf_ioctls, \"Allow ioctls in SR-IOV VF mode. Default: 0\");\n\nstatic unsigned int throttlequeuedepth = MEGASAS_THROTTLE_QUEUE_DEPTH;\nmodule_param(throttlequeuedepth, int, S_IRUGO);\nMODULE_PARM_DESC(throttlequeuedepth,\n\t\"Adapter queue depth when throttled due to I/O timeout. Default: 16\");\n\nunsigned int resetwaittime = MEGASAS_RESET_WAIT_TIME;\nmodule_param(resetwaittime, int, S_IRUGO);\nMODULE_PARM_DESC(resetwaittime, \"Wait time in (1-180s) after I/O timeout before resetting adapter. Default: 180s\");\n\nint smp_affinity_enable = 1;\nmodule_param(smp_affinity_enable, int, S_IRUGO);\nMODULE_PARM_DESC(smp_affinity_enable, \"SMP affinity feature enable/disable Default: enable(1)\");\n\nint rdpq_enable = 1;\nmodule_param(rdpq_enable, int, S_IRUGO);\nMODULE_PARM_DESC(rdpq_enable, \"Allocate reply queue in chunks for large queue depth enable/disable Default: enable(1)\");\n\nunsigned int dual_qdepth_disable;\nmodule_param(dual_qdepth_disable, int, S_IRUGO);\nMODULE_PARM_DESC(dual_qdepth_disable, \"Disable dual queue depth feature. Default: 0\");\n\nunsigned int scmd_timeout = MEGASAS_DEFAULT_CMD_TIMEOUT;\nmodule_param(scmd_timeout, int, S_IRUGO);\nMODULE_PARM_DESC(scmd_timeout, \"scsi command timeout (10-90s), default 90s. See megasas_reset_timer.\");\n\nMODULE_LICENSE(\"GPL\");\nMODULE_VERSION(MEGASAS_VERSION);\nMODULE_AUTHOR(\"megaraidlinux.pdl@broadcom.com\");\nMODULE_DESCRIPTION(\"Broadcom MegaRAID SAS Driver\");\n\nint megasas_transition_to_ready(struct megasas_instance *instance, int ocr);\nstatic int megasas_get_pd_list(struct megasas_instance *instance);\nstatic int megasas_ld_list_query(struct megasas_instance *instance,\n\t\t\t\t u8 query_type);\nstatic int megasas_issue_init_mfi(struct megasas_instance *instance);\nstatic int megasas_register_aen(struct megasas_instance *instance,\n\t\t\t\tu32 seq_num, u32 class_locale_word);\nstatic void megasas_get_pd_info(struct megasas_instance *instance,\n\t\t\t\tstruct scsi_device *sdev);\n\n/*\n * PCI ID table for all supported controllers\n */\nstatic struct pci_device_id megasas_pci_table[] = {\n\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1064R)},\n\t/* xscale IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078R)},\n\t/* ppc IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078DE)},\n\t/* ppc IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS1078GEN2)},\n\t/* gen2*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0079GEN2)},\n\t/* gen2*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0073SKINNY)},\n\t/* skinny*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_SAS0071SKINNY)},\n\t/* skinny*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VERDE_ZCR)},\n\t/* xscale IOP, vega */\n\t{PCI_DEVICE(PCI_VENDOR_ID_DELL, PCI_DEVICE_ID_DELL_PERC5)},\n\t/* xscale IOP */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FUSION)},\n\t/* Fusion */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_PLASMA)},\n\t/* Plasma */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INVADER)},\n\t/* Invader */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_FURY)},\n\t/* Fury */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INTRUDER)},\n\t/* Intruder */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_INTRUDER_24)},\n\t/* Intruder 24 port*/\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CUTLASS_52)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CUTLASS_53)},\n\t/* VENTURA */\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VENTURA)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CRUSADER)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_HARPOON)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_TOMCAT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_VENTURA_4PORT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_CRUSADER_4PORT)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E1)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E2)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E5)},\n\t{PCI_DEVICE(PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_LSI_AERO_10E6)},\n\t{}\n};\n\nMODULE_DEVICE_TABLE(pci, megasas_pci_table);\n\nstatic int megasas_mgmt_majorno;\nstruct megasas_mgmt_info megasas_mgmt_info;\nstatic struct fasync_struct *megasas_async_queue;\nstatic DEFINE_MUTEX(megasas_async_queue_mutex);\n\nstatic int megasas_poll_wait_aen;\nstatic DECLARE_WAIT_QUEUE_HEAD(megasas_poll_wait);\nstatic u32 support_poll_for_event;\nu32 megasas_dbg_lvl;\nstatic u32 support_device_change;\nstatic bool support_nvme_encapsulation;\n\n/* define lock for aen poll */\nspinlock_t poll_aen_lock;\n\nvoid\nmegasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\t\t     u8 alt_status);\nstatic u32\nmegasas_read_fw_status_reg_gen2(struct megasas_instance *instance);\nstatic int\nmegasas_adp_reset_gen2(struct megasas_instance *instance,\n\t\t       struct megasas_register_set __iomem *reg_set);\nstatic irqreturn_t megasas_isr(int irq, void *devp);\nstatic u32\nmegasas_init_adapter_mfi(struct megasas_instance *instance);\nu32\nmegasas_build_and_issue_cmd(struct megasas_instance *instance,\n\t\t\t    struct scsi_cmnd *scmd);\nstatic void megasas_complete_cmd_dpc(unsigned long instance_addr);\nint\nwait_and_poll(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\tint seconds);\nvoid megasas_fusion_ocr_wq(struct work_struct *work);\nstatic int megasas_get_ld_vf_affiliation(struct megasas_instance *instance,\n\t\t\t\t\t int initial);\nstatic int\nmegasas_set_dma_mask(struct megasas_instance *instance);\nstatic int\nmegasas_alloc_ctrl_mem(struct megasas_instance *instance);\nstatic inline void\nmegasas_free_ctrl_mem(struct megasas_instance *instance);\nstatic inline int\nmegasas_alloc_ctrl_dma_buffers(struct megasas_instance *instance);\nstatic inline void\nmegasas_free_ctrl_dma_buffers(struct megasas_instance *instance);\nstatic inline void\nmegasas_init_ctrl_params(struct megasas_instance *instance);\n\nu32 megasas_readl(struct megasas_instance *instance,\n\t\t  const volatile void __iomem *addr)\n{\n\tu32 i = 0, ret_val;\n\t/*\n\t * Due to a HW errata in Aero controllers, reads to certain\n\t * Fusion registers could intermittently return all zeroes.\n\t * This behavior is transient in nature and subsequent reads will\n\t * return valid value. As a workaround in driver, retry readl for\n\t * upto three times until a non-zero value is read.\n\t */\n\tif (instance->adapter_type == AERO_SERIES) {\n\t\tdo {\n\t\t\tret_val = readl(addr);\n\t\t\ti++;\n\t\t} while (ret_val == 0 && i < 3);\n\t\treturn ret_val;\n\t} else {\n\t\treturn readl(addr);\n\t}\n}\n\n/**\n * megasas_set_dma_settings -\tPopulate DMA address, length and flags for DCMDs\n * @instance:\t\t\tAdapter soft state\n * @dcmd:\t\t\tDCMD frame inside MFI command\n * @dma_addr:\t\t\tDMA address of buffer to be passed to FW\n * @dma_len:\t\t\tLength of DMA buffer to be passed to FW\n * @return:\t\t\tvoid\n */\nvoid megasas_set_dma_settings(struct megasas_instance *instance,\n\t\t\t      struct megasas_dcmd_frame *dcmd,\n\t\t\t      dma_addr_t dma_addr, u32 dma_len)\n{\n\tif (instance->consistent_mask_64bit) {\n\t\tdcmd->sgl.sge64[0].phys_addr = cpu_to_le64(dma_addr);\n\t\tdcmd->sgl.sge64[0].length = cpu_to_le32(dma_len);\n\t\tdcmd->flags = cpu_to_le16(dcmd->flags | MFI_FRAME_SGL64);\n\n\t} else {\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\t\tcpu_to_le32(lower_32_bits(dma_addr));\n\t\tdcmd->sgl.sge32[0].length = cpu_to_le32(dma_len);\n\t\tdcmd->flags = cpu_to_le16(dcmd->flags);\n\t}\n}\n\nvoid\nmegasas_issue_dcmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tinstance->instancet->fire_cmd(instance,\n\t\tcmd->frame_phys_addr, 0, instance->reg_set);\n\treturn;\n}\n\n/**\n * megasas_get_cmd -\tGet a command from the free pool\n * @instance:\t\tAdapter soft state\n *\n * Returns a free command from the pool\n */\nstruct megasas_cmd *megasas_get_cmd(struct megasas_instance\n\t\t\t\t\t\t  *instance)\n{\n\tunsigned long flags;\n\tstruct megasas_cmd *cmd = NULL;\n\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\n\tif (!list_empty(&instance->cmd_pool)) {\n\t\tcmd = list_entry((&instance->cmd_pool)->next,\n\t\t\t\t struct megasas_cmd, list);\n\t\tlist_del_init(&cmd->list);\n\t} else {\n\t\tdev_err(&instance->pdev->dev, \"Command pool empty!\\n\");\n\t}\n\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n\treturn cmd;\n}\n\n/**\n * megasas_return_cmd -\tReturn a cmd to free command pool\n * @instance:\t\tAdapter soft state\n * @cmd:\t\tCommand packet to be returned to free command pool\n */\nvoid\nmegasas_return_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunsigned long flags;\n\tu32 blk_tags;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\t/* This flag is used only for fusion adapter.\n\t * Wait for Interrupt for Polled mode DCMD\n\t */\n\tif (cmd->flags & DRV_DCMD_POLLED_MODE)\n\t\treturn;\n\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\n\tif (fusion) {\n\t\tblk_tags = instance->max_scsi_cmds + cmd->index;\n\t\tcmd_fusion = fusion->cmd_list[blk_tags];\n\t\tmegasas_return_cmd_fusion(instance, cmd_fusion);\n\t}\n\tcmd->scmd = NULL;\n\tcmd->frame_count = 0;\n\tcmd->flags = 0;\n\tmemset(cmd->frame, 0, instance->mfi_frame_size);\n\tcmd->frame->io.context = cpu_to_le32(cmd->index);\n\tif (!fusion && reset_devices)\n\t\tcmd->frame->hdr.cmd = MFI_CMD_INVALID;\n\tlist_add(&cmd->list, (&instance->cmd_pool)->next);\n\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n\n}\n\nstatic const char *\nformat_timestamp(uint32_t timestamp)\n{\n\tstatic char buffer[32];\n\n\tif ((timestamp & 0xff000000) == 0xff000000)\n\t\tsnprintf(buffer, sizeof(buffer), \"boot + %us\", timestamp &\n\t\t0x00ffffff);\n\telse\n\t\tsnprintf(buffer, sizeof(buffer), \"%us\", timestamp);\n\treturn buffer;\n}\n\nstatic const char *\nformat_class(int8_t class)\n{\n\tstatic char buffer[6];\n\n\tswitch (class) {\n\tcase MFI_EVT_CLASS_DEBUG:\n\t\treturn \"debug\";\n\tcase MFI_EVT_CLASS_PROGRESS:\n\t\treturn \"progress\";\n\tcase MFI_EVT_CLASS_INFO:\n\t\treturn \"info\";\n\tcase MFI_EVT_CLASS_WARNING:\n\t\treturn \"WARN\";\n\tcase MFI_EVT_CLASS_CRITICAL:\n\t\treturn \"CRIT\";\n\tcase MFI_EVT_CLASS_FATAL:\n\t\treturn \"FATAL\";\n\tcase MFI_EVT_CLASS_DEAD:\n\t\treturn \"DEAD\";\n\tdefault:\n\t\tsnprintf(buffer, sizeof(buffer), \"%d\", class);\n\t\treturn buffer;\n\t}\n}\n\n/**\n  * megasas_decode_evt: Decode FW AEN event and print critical event\n  * for information.\n  * @instance:\t\t\tAdapter soft state\n  */\nstatic void\nmegasas_decode_evt(struct megasas_instance *instance)\n{\n\tstruct megasas_evt_detail *evt_detail = instance->evt_detail;\n\tunion megasas_evt_class_locale class_locale;\n\tclass_locale.word = le32_to_cpu(evt_detail->cl.word);\n\n\tif (class_locale.members.class >= MFI_EVT_CLASS_CRITICAL)\n\t\tdev_info(&instance->pdev->dev, \"%d (%s/0x%04x/%s) - %s\\n\",\n\t\t\tle32_to_cpu(evt_detail->seq_num),\n\t\t\tformat_timestamp(le32_to_cpu(evt_detail->time_stamp)),\n\t\t\t(class_locale.members.locale),\n\t\t\tformat_class(class_locale.members.class),\n\t\t\tevt_detail->description);\n}\n\n/**\n*\tThe following functions are defined for xscale\n*\t(deviceid : 1064R, PERC5) controllers\n*/\n\n/**\n * megasas_enable_intr_xscale -\tEnables interrupts\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_enable_intr_xscale(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_xscale -Disables interrupt\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_disable_intr_xscale(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0x1f;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_xscale - returns the current FW status value\n * @regs:\t\t\tMFI register set\n */\nstatic u32\nmegasas_read_fw_status_reg_xscale(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_msg_0);\n}\n/**\n * megasas_clear_interrupt_xscale -\tCheck & clear interrupt\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_clear_intr_xscale(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_OB_INTR_STATUS_MASK)\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\tif (status & MFI_XSCALE_OMR0_CHANGE_INTERRUPT)\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\tif (mfiStatus)\n\t\twritel(status, &regs->outbound_intr_status);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n\n/**\n * megasas_fire_cmd_xscale -\tSends command to the FW\n * @frame_phys_addr :\t\tPhysical address of cmd\n * @frame_count :\t\tNumber of frames for the command\n * @regs :\t\t\tMFI register set\n */\nstatic inline void\nmegasas_fire_cmd_xscale(struct megasas_instance *instance,\n\t\tdma_addr_t frame_phys_addr,\n\t\tu32 frame_count,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr >> 3)|(frame_count),\n\t       &(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_adp_reset_xscale -  For controller reset\n * @regs:                              MFI register set\n */\nstatic int\nmegasas_adp_reset_xscale(struct megasas_instance *instance,\n\tstruct megasas_register_set __iomem *regs)\n{\n\tu32 i;\n\tu32 pcidata;\n\n\twritel(MFI_ADP_RESET, &regs->inbound_doorbell);\n\n\tfor (i = 0; i < 3; i++)\n\t\tmsleep(1000); /* sleep for 3 secs */\n\tpcidata  = 0;\n\tpci_read_config_dword(instance->pdev, MFI_1068_PCSR_OFFSET, &pcidata);\n\tdev_notice(&instance->pdev->dev, \"pcidata = %x\\n\", pcidata);\n\tif (pcidata & 0x2) {\n\t\tdev_notice(&instance->pdev->dev, \"mfi 1068 offset read=%x\\n\", pcidata);\n\t\tpcidata &= ~0x2;\n\t\tpci_write_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_PCSR_OFFSET, pcidata);\n\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tmsleep(1000); /* need to wait 2 secs again */\n\n\t\tpcidata  = 0;\n\t\tpci_read_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_FW_HANDSHAKE_OFFSET, &pcidata);\n\t\tdev_notice(&instance->pdev->dev, \"1068 offset handshake read=%x\\n\", pcidata);\n\t\tif ((pcidata & 0xffff0000) == MFI_1068_FW_READY) {\n\t\t\tdev_notice(&instance->pdev->dev, \"1068 offset pcidt=%x\\n\", pcidata);\n\t\t\tpcidata = 0;\n\t\t\tpci_write_config_dword(instance->pdev,\n\t\t\t\tMFI_1068_FW_HANDSHAKE_OFFSET, pcidata);\n\t\t}\n\t}\n\treturn 0;\n}\n\n/**\n * megasas_check_reset_xscale -\tFor controller reset check\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_check_reset_xscale(struct megasas_instance *instance,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif ((atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) &&\n\t    (le32_to_cpu(*instance->consumer) ==\n\t\tMEGASAS_ADPRESET_INPROG_SIGN))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_xscale = {\n\n\t.fire_cmd = megasas_fire_cmd_xscale,\n\t.enable_intr = megasas_enable_intr_xscale,\n\t.disable_intr = megasas_disable_intr_xscale,\n\t.clear_intr = megasas_clear_intr_xscale,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_xscale,\n\t.adp_reset = megasas_adp_reset_xscale,\n\t.check_reset = megasas_check_reset_xscale,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n/**\n*\tThis is the end of set of functions & definitions specific\n*\tto xscale (deviceid : 1064R, PERC5) controllers\n*/\n\n/**\n*\tThe following functions are defined for ppc (deviceid : 0x60)\n*\tcontrollers\n*/\n\n/**\n * megasas_enable_intr_ppc -\tEnables interrupts\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_enable_intr_ppc(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\n\n\twritel(~0x80000000, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_ppc -\tDisable interrupt\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_disable_intr_ppc(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_ppc - returns the current FW status value\n * @regs:\t\t\tMFI register set\n */\nstatic u32\nmegasas_read_fw_status_reg_ppc(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n/**\n * megasas_clear_interrupt_ppc -\tCheck & clear interrupt\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_clear_intr_ppc(struct megasas_instance *instance)\n{\n\tu32 status, mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_REPLY_1078_MESSAGE_INTERRUPT)\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\n\tif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT)\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\twritel(status, &regs->outbound_doorbell_clear);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_doorbell_clear);\n\n\treturn mfiStatus;\n}\n\n/**\n * megasas_fire_cmd_ppc -\tSends command to the FW\n * @frame_phys_addr :\t\tPhysical address of cmd\n * @frame_count :\t\tNumber of frames for the command\n * @regs :\t\t\tMFI register set\n */\nstatic inline void\nmegasas_fire_cmd_ppc(struct megasas_instance *instance,\n\t\tdma_addr_t frame_phys_addr,\n\t\tu32 frame_count,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr | (frame_count<<1))|1,\n\t\t\t&(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_check_reset_ppc -\tFor controller reset check\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_check_reset_ppc(struct megasas_instance *instance,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_ppc = {\n\n\t.fire_cmd = megasas_fire_cmd_ppc,\n\t.enable_intr = megasas_enable_intr_ppc,\n\t.disable_intr = megasas_disable_intr_ppc,\n\t.clear_intr = megasas_clear_intr_ppc,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_ppc,\n\t.adp_reset = megasas_adp_reset_xscale,\n\t.check_reset = megasas_check_reset_ppc,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n/**\n * megasas_enable_intr_skinny -\tEnables interrupts\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_enable_intr_skinny(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_intr_mask);\n\n\twritel(~MFI_SKINNY_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_skinny -\tDisables interrupt\n * @regs:\t\t\tMFI register set\n */\nstatic inline void\nmegasas_disable_intr_skinny(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_skinny - returns the current FW status value\n * @regs:\t\t\tMFI register set\n */\nstatic u32\nmegasas_read_fw_status_reg_skinny(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n/**\n * megasas_clear_interrupt_skinny -\tCheck & clear interrupt\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_clear_intr_skinny(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (!(status & MFI_SKINNY_ENABLE_INTERRUPT_MASK)) {\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tif ((megasas_read_fw_status_reg_skinny(instance) & MFI_STATE_MASK) ==\n\t    MFI_STATE_FAULT) {\n\t\tmfiStatus = MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\t} else\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\twritel(status, &regs->outbound_intr_status);\n\n\t/*\n\t * dummy read to flush PCI\n\t */\n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n\n/**\n * megasas_fire_cmd_skinny -\tSends command to the FW\n * @frame_phys_addr :\t\tPhysical address of cmd\n * @frame_count :\t\tNumber of frames for the command\n * @regs :\t\t\tMFI register set\n */\nstatic inline void\nmegasas_fire_cmd_skinny(struct megasas_instance *instance,\n\t\t\tdma_addr_t frame_phys_addr,\n\t\t\tu32 frame_count,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel(upper_32_bits(frame_phys_addr),\n\t       &(regs)->inbound_high_queue_port);\n\twritel((lower_32_bits(frame_phys_addr) | (frame_count<<1))|1,\n\t       &(regs)->inbound_low_queue_port);\n\tmmiowb();\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_check_reset_skinny -\tFor controller reset check\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_check_reset_skinny(struct megasas_instance *instance,\n\t\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_skinny = {\n\n\t.fire_cmd = megasas_fire_cmd_skinny,\n\t.enable_intr = megasas_enable_intr_skinny,\n\t.disable_intr = megasas_disable_intr_skinny,\n\t.clear_intr = megasas_clear_intr_skinny,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_skinny,\n\t.adp_reset = megasas_adp_reset_gen2,\n\t.check_reset = megasas_check_reset_skinny,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n\n/**\n*\tThe following functions are defined for gen2 (deviceid : 0x78 0x79)\n*\tcontrollers\n*/\n\n/**\n * megasas_enable_intr_gen2 -  Enables interrupts\n * @regs:                      MFI register set\n */\nstatic inline void\nmegasas_enable_intr_gen2(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\n\tregs = instance->reg_set;\n\twritel(0xFFFFFFFF, &(regs)->outbound_doorbell_clear);\n\n\t/* write ~0x00000005 (4 & 1) to the intr mask*/\n\twritel(~MFI_GEN2_ENABLE_INTERRUPT_MASK, &(regs)->outbound_intr_mask);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_disable_intr_gen2 - Disables interrupt\n * @regs:                      MFI register set\n */\nstatic inline void\nmegasas_disable_intr_gen2(struct megasas_instance *instance)\n{\n\tstruct megasas_register_set __iomem *regs;\n\tu32 mask = 0xFFFFFFFF;\n\n\tregs = instance->reg_set;\n\twritel(mask, &regs->outbound_intr_mask);\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_mask);\n}\n\n/**\n * megasas_read_fw_status_reg_gen2 - returns the current FW status value\n * @regs:                      MFI register set\n */\nstatic u32\nmegasas_read_fw_status_reg_gen2(struct megasas_instance *instance)\n{\n\treturn readl(&instance->reg_set->outbound_scratch_pad_0);\n}\n\n/**\n * megasas_clear_interrupt_gen2 -      Check & clear interrupt\n * @regs:                              MFI register set\n */\nstatic int\nmegasas_clear_intr_gen2(struct megasas_instance *instance)\n{\n\tu32 status;\n\tu32 mfiStatus = 0;\n\tstruct megasas_register_set __iomem *regs;\n\tregs = instance->reg_set;\n\n\t/*\n\t * Check if it is our interrupt\n\t */\n\tstatus = readl(&regs->outbound_intr_status);\n\n\tif (status & MFI_INTR_FLAG_REPLY_MESSAGE) {\n\t\tmfiStatus = MFI_INTR_FLAG_REPLY_MESSAGE;\n\t}\n\tif (status & MFI_G2_OUTBOUND_DOORBELL_CHANGE_INTERRUPT) {\n\t\tmfiStatus |= MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE;\n\t}\n\n\t/*\n\t * Clear the interrupt by writing back the same value\n\t */\n\tif (mfiStatus)\n\t\twritel(status, &regs->outbound_doorbell_clear);\n\n\t/* Dummy readl to force pci flush */\n\treadl(&regs->outbound_intr_status);\n\n\treturn mfiStatus;\n}\n/**\n * megasas_fire_cmd_gen2 -     Sends command to the FW\n * @frame_phys_addr :          Physical address of cmd\n * @frame_count :              Number of frames for the command\n * @regs :                     MFI register set\n */\nstatic inline void\nmegasas_fire_cmd_gen2(struct megasas_instance *instance,\n\t\t\tdma_addr_t frame_phys_addr,\n\t\t\tu32 frame_count,\n\t\t\tstruct megasas_register_set __iomem *regs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\twritel((frame_phys_addr | (frame_count<<1))|1,\n\t\t\t&(regs)->inbound_queue_port);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n}\n\n/**\n * megasas_adp_reset_gen2 -\tFor controller reset\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_adp_reset_gen2(struct megasas_instance *instance,\n\t\t\tstruct megasas_register_set __iomem *reg_set)\n{\n\tu32 retry = 0 ;\n\tu32 HostDiag;\n\tu32 __iomem *seq_offset = &reg_set->seq_offset;\n\tu32 __iomem *hostdiag_offset = &reg_set->host_diag;\n\n\tif (instance->instancet == &megasas_instance_template_skinny) {\n\t\tseq_offset = &reg_set->fusion_seq_offset;\n\t\thostdiag_offset = &reg_set->fusion_host_diag;\n\t}\n\n\twritel(0, seq_offset);\n\twritel(4, seq_offset);\n\twritel(0xb, seq_offset);\n\twritel(2, seq_offset);\n\twritel(7, seq_offset);\n\twritel(0xd, seq_offset);\n\n\tmsleep(1000);\n\n\tHostDiag = (u32)readl(hostdiag_offset);\n\n\twhile (!(HostDiag & DIAG_WRITE_ENABLE)) {\n\t\tmsleep(100);\n\t\tHostDiag = (u32)readl(hostdiag_offset);\n\t\tdev_notice(&instance->pdev->dev, \"RESETGEN2: retry=%x, hostdiag=%x\\n\",\n\t\t\t\t\tretry, HostDiag);\n\n\t\tif (retry++ >= 100)\n\t\t\treturn 1;\n\n\t}\n\n\tdev_notice(&instance->pdev->dev, \"ADP_RESET_GEN2: HostDiag=%x\\n\", HostDiag);\n\n\twritel((HostDiag | DIAG_RESET_ADAPTER), hostdiag_offset);\n\n\tssleep(10);\n\n\tHostDiag = (u32)readl(hostdiag_offset);\n\twhile (HostDiag & DIAG_RESET_ADAPTER) {\n\t\tmsleep(100);\n\t\tHostDiag = (u32)readl(hostdiag_offset);\n\t\tdev_notice(&instance->pdev->dev, \"RESET_GEN2: retry=%x, hostdiag=%x\\n\",\n\t\t\t\tretry, HostDiag);\n\n\t\tif (retry++ >= 1000)\n\t\t\treturn 1;\n\n\t}\n\treturn 0;\n}\n\n/**\n * megasas_check_reset_gen2 -\tFor controller reset check\n * @regs:\t\t\t\tMFI register set\n */\nstatic int\nmegasas_check_reset_gen2(struct megasas_instance *instance,\n\t\tstruct megasas_register_set __iomem *regs)\n{\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic struct megasas_instance_template megasas_instance_template_gen2 = {\n\n\t.fire_cmd = megasas_fire_cmd_gen2,\n\t.enable_intr = megasas_enable_intr_gen2,\n\t.disable_intr = megasas_disable_intr_gen2,\n\t.clear_intr = megasas_clear_intr_gen2,\n\t.read_fw_status_reg = megasas_read_fw_status_reg_gen2,\n\t.adp_reset = megasas_adp_reset_gen2,\n\t.check_reset = megasas_check_reset_gen2,\n\t.service_isr = megasas_isr,\n\t.tasklet = megasas_complete_cmd_dpc,\n\t.init_adapter = megasas_init_adapter_mfi,\n\t.build_and_issue_cmd = megasas_build_and_issue_cmd,\n\t.issue_dcmd = megasas_issue_dcmd,\n};\n\n/**\n*\tThis is the end of set of functions & definitions\n*       specific to gen2 (deviceid : 0x78, 0x79) controllers\n*/\n\n/*\n * Template added for TB (Fusion)\n */\nextern struct megasas_instance_template megasas_instance_template_fusion;\n\n/**\n * megasas_issue_polled -\tIssues a polling command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand packet to be issued\n *\n * For polling, MFI requires the cmd_status to be set to MFI_STAT_INVALID_STATUS before posting.\n */\nint\nmegasas_issue_polled(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tstruct megasas_header *frame_hdr = &cmd->frame->hdr;\n\n\tframe_hdr->cmd_status = MFI_STAT_INVALID_STATUS;\n\tframe_hdr->flags |= cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE);\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_NOT_FIRED;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\treturn wait_and_poll(instance, cmd, instance->requestorId ?\n\t\t\tMEGASAS_ROUTINE_WAIT_TIME_VF : MFI_IO_TIMEOUT_SECS);\n}\n\n/**\n * megasas_issue_blocked_cmd -\tSynchronous wrapper around regular FW cmds\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand to be issued\n * @timeout:\t\t\tTimeout in seconds\n *\n * This function waits on an event for the command to be returned from ISR.\n * Max wait time is MEGASAS_INTERNAL_CMD_WAIT_TIME secs\n * Used to issue ioctl commands.\n */\nint\nmegasas_issue_blocked_cmd(struct megasas_instance *instance,\n\t\t\t  struct megasas_cmd *cmd, int timeout)\n{\n\tint ret = 0;\n\tcmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_NOT_FIRED;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\tif (timeout) {\n\t\tret = wait_event_timeout(instance->int_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS, timeout * HZ);\n\t\tif (!ret) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d DCMD Timed out\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\treturn DCMD_TIMEOUT;\n\t\t}\n\t} else\n\t\twait_event(instance->int_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS);\n\n\treturn (cmd->cmd_status_drv == MFI_STAT_OK) ?\n\t\tDCMD_SUCCESS : DCMD_FAILED;\n}\n\n/**\n * megasas_issue_blocked_abort_cmd -\tAborts previously issued cmd\n * @instance:\t\t\t\tAdapter soft state\n * @cmd_to_abort:\t\t\tPreviously issued cmd to be aborted\n * @timeout:\t\t\t\tTimeout in seconds\n *\n * MFI firmware can abort previously issued AEN comamnd (automatic event\n * notification). The megasas_issue_blocked_abort_cmd() issues such abort\n * cmd and waits for return status.\n * Max wait time is MEGASAS_INTERNAL_CMD_WAIT_TIME secs\n */\nstatic int\nmegasas_issue_blocked_abort_cmd(struct megasas_instance *instance,\n\t\t\t\tstruct megasas_cmd *cmd_to_abort, int timeout)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_abort_frame *abort_fr;\n\tint ret = 0;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn -1;\n\n\tabort_fr = &cmd->frame->abort;\n\n\t/*\n\t * Prepare and issue the abort frame\n\t */\n\tabort_fr->cmd = MFI_CMD_ABORT;\n\tabort_fr->cmd_status = MFI_STAT_INVALID_STATUS;\n\tabort_fr->flags = cpu_to_le16(0);\n\tabort_fr->abort_context = cpu_to_le32(cmd_to_abort->index);\n\tabort_fr->abort_mfi_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(cmd_to_abort->frame_phys_addr));\n\tabort_fr->abort_mfi_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(cmd_to_abort->frame_phys_addr));\n\n\tcmd->sync_cmd = 1;\n\tcmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn DCMD_NOT_FIRED;\n\t}\n\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\tif (timeout) {\n\t\tret = wait_event_timeout(instance->abort_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS, timeout * HZ);\n\t\tif (!ret) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d Abort Timed out\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\treturn DCMD_TIMEOUT;\n\t\t}\n\t} else\n\t\twait_event(instance->abort_cmd_wait_q,\n\t\t\t\tcmd->cmd_status_drv != MFI_STAT_INVALID_STATUS);\n\n\tcmd->sync_cmd = 0;\n\n\tmegasas_return_cmd(instance, cmd);\n\treturn (cmd->cmd_status_drv == MFI_STAT_OK) ?\n\t\tDCMD_SUCCESS : DCMD_FAILED;\n}\n\n/**\n * megasas_make_sgl32 -\tPrepares 32-bit SGL\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command from the mid-layer\n * @mfi_sgl:\t\tSGL to be filled in\n *\n * If successful, this function returns the number of SG elements. Otherwise,\n * it returnes -1.\n */\nstatic int\nmegasas_make_sgl32(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\tBUG_ON(sge_count < 0);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge32[i].length = cpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge32[i].phys_addr = cpu_to_le32(sg_dma_address(os_sgl));\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n/**\n * megasas_make_sgl64 -\tPrepares 64-bit SGL\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command from the mid-layer\n * @mfi_sgl:\t\tSGL to be filled in\n *\n * If successful, this function returns the number of SG elements. Otherwise,\n * it returnes -1.\n */\nstatic int\nmegasas_make_sgl64(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\tBUG_ON(sge_count < 0);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge64[i].length = cpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge64[i].phys_addr = cpu_to_le64(sg_dma_address(os_sgl));\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n/**\n * megasas_make_sgl_skinny - Prepares IEEE SGL\n * @instance:           Adapter soft state\n * @scp:                SCSI command from the mid-layer\n * @mfi_sgl:            SGL to be filled in\n *\n * If successful, this function returns the number of SG elements. Otherwise,\n * it returnes -1.\n */\nstatic int\nmegasas_make_sgl_skinny(struct megasas_instance *instance,\n\t\tstruct scsi_cmnd *scp, union megasas_sgl *mfi_sgl)\n{\n\tint i;\n\tint sge_count;\n\tstruct scatterlist *os_sgl;\n\n\tsge_count = scsi_dma_map(scp);\n\n\tif (sge_count) {\n\t\tscsi_for_each_sg(scp, os_sgl, sge_count, i) {\n\t\t\tmfi_sgl->sge_skinny[i].length =\n\t\t\t\tcpu_to_le32(sg_dma_len(os_sgl));\n\t\t\tmfi_sgl->sge_skinny[i].phys_addr =\n\t\t\t\tcpu_to_le64(sg_dma_address(os_sgl));\n\t\t\tmfi_sgl->sge_skinny[i].flag = cpu_to_le32(0);\n\t\t}\n\t}\n\treturn sge_count;\n}\n\n /**\n * megasas_get_frame_count - Computes the number of frames\n * @frame_type\t\t: type of frame- io or pthru frame\n * @sge_count\t\t: number of sg elements\n *\n * Returns the number of frames required for numnber of sge's (sge_count)\n */\n\nstatic u32 megasas_get_frame_count(struct megasas_instance *instance,\n\t\t\tu8 sge_count, u8 frame_type)\n{\n\tint num_cnt;\n\tint sge_bytes;\n\tu32 sge_sz;\n\tu32 frame_count = 0;\n\n\tsge_sz = (IS_DMA64) ? sizeof(struct megasas_sge64) :\n\t    sizeof(struct megasas_sge32);\n\n\tif (instance->flag_ieee) {\n\t\tsge_sz = sizeof(struct megasas_sge_skinny);\n\t}\n\n\t/*\n\t * Main frame can contain 2 SGEs for 64-bit SGLs and\n\t * 3 SGEs for 32-bit SGLs for ldio &\n\t * 1 SGEs for 64-bit SGLs and\n\t * 2 SGEs for 32-bit SGLs for pthru frame\n\t */\n\tif (unlikely(frame_type == PTHRU_FRAME)) {\n\t\tif (instance->flag_ieee == 1) {\n\t\t\tnum_cnt = sge_count - 1;\n\t\t} else if (IS_DMA64)\n\t\t\tnum_cnt = sge_count - 1;\n\t\telse\n\t\t\tnum_cnt = sge_count - 2;\n\t} else {\n\t\tif (instance->flag_ieee == 1) {\n\t\t\tnum_cnt = sge_count - 1;\n\t\t} else if (IS_DMA64)\n\t\t\tnum_cnt = sge_count - 2;\n\t\telse\n\t\t\tnum_cnt = sge_count - 3;\n\t}\n\n\tif (num_cnt > 0) {\n\t\tsge_bytes = sge_sz * num_cnt;\n\n\t\tframe_count = (sge_bytes / MEGAMFI_FRAME_SIZE) +\n\t\t    ((sge_bytes % MEGAMFI_FRAME_SIZE) ? 1 : 0) ;\n\t}\n\t/* Main frame */\n\tframe_count += 1;\n\n\tif (frame_count > 7)\n\t\tframe_count = 8;\n\treturn frame_count;\n}\n\n/**\n * megasas_build_dcdb -\tPrepares a direct cdb (DCDB) command\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command\n * @cmd:\t\tCommand to be prepared in\n *\n * This function prepares CDB commands. These are typcially pass-through\n * commands to the devices.\n */\nstatic int\nmegasas_build_dcdb(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   struct megasas_cmd *cmd)\n{\n\tu32 is_logical;\n\tu32 device_id;\n\tu16 flags = 0;\n\tstruct megasas_pthru_frame *pthru;\n\n\tis_logical = MEGASAS_IS_LOGICAL(scp->device);\n\tdevice_id = MEGASAS_DEV_INDEX(scp);\n\tpthru = (struct megasas_pthru_frame *)cmd->frame;\n\n\tif (scp->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags = MFI_FRAME_DIR_WRITE;\n\telse if (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\tflags = MFI_FRAME_DIR_READ;\n\telse if (scp->sc_data_direction == DMA_NONE)\n\t\tflags = MFI_FRAME_DIR_NONE;\n\n\tif (instance->flag_ieee == 1) {\n\t\tflags |= MFI_FRAME_IEEE;\n\t}\n\n\t/*\n\t * Prepare the DCDB frame\n\t */\n\tpthru->cmd = (is_logical) ? MFI_CMD_LD_SCSI_IO : MFI_CMD_PD_SCSI_IO;\n\tpthru->cmd_status = 0x0;\n\tpthru->scsi_status = 0x0;\n\tpthru->target_id = device_id;\n\tpthru->lun = scp->device->lun;\n\tpthru->cdb_len = scp->cmd_len;\n\tpthru->timeout = 0;\n\tpthru->pad_0 = 0;\n\tpthru->flags = cpu_to_le16(flags);\n\tpthru->data_xfer_len = cpu_to_le32(scsi_bufflen(scp));\n\n\tmemcpy(pthru->cdb, scp->cmnd, scp->cmd_len);\n\n\t/*\n\t * If the command is for the tape device, set the\n\t * pthru timeout to the os layer timeout value.\n\t */\n\tif (scp->device->type == TYPE_TAPE) {\n\t\tif ((scp->request->timeout / HZ) > 0xFFFF)\n\t\t\tpthru->timeout = cpu_to_le16(0xFFFF);\n\t\telse\n\t\t\tpthru->timeout = cpu_to_le16(scp->request->timeout / HZ);\n\t}\n\n\t/*\n\t * Construct SGL\n\t */\n\tif (instance->flag_ieee == 1) {\n\t\tpthru->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tpthru->sge_count = megasas_make_sgl_skinny(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\t} else if (IS_DMA64) {\n\t\tpthru->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tpthru->sge_count = megasas_make_sgl64(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\t} else\n\t\tpthru->sge_count = megasas_make_sgl32(instance, scp,\n\t\t\t\t\t\t      &pthru->sgl);\n\n\tif (pthru->sge_count > instance->max_num_sge) {\n\t\tdev_err(&instance->pdev->dev, \"DCDB too many SGE NUM=%x\\n\",\n\t\t\tpthru->sge_count);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Sense info specific\n\t */\n\tpthru->sense_len = SCSI_SENSE_BUFFERSIZE;\n\tpthru->sense_buf_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(cmd->sense_phys_addr));\n\tpthru->sense_buf_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(cmd->sense_phys_addr));\n\n\t/*\n\t * Compute the total number of frames this command consumes. FW uses\n\t * this number to pull sufficient number of frames from host memory.\n\t */\n\tcmd->frame_count = megasas_get_frame_count(instance, pthru->sge_count,\n\t\t\t\t\t\t\tPTHRU_FRAME);\n\n\treturn cmd->frame_count;\n}\n\n/**\n * megasas_build_ldio -\tPrepares IOs to logical devices\n * @instance:\t\tAdapter soft state\n * @scp:\t\tSCSI command\n * @cmd:\t\tCommand to be prepared\n *\n * Frames (and accompanying SGLs) for regular SCSI IOs use this function.\n */\nstatic int\nmegasas_build_ldio(struct megasas_instance *instance, struct scsi_cmnd *scp,\n\t\t   struct megasas_cmd *cmd)\n{\n\tu32 device_id;\n\tu8 sc = scp->cmnd[0];\n\tu16 flags = 0;\n\tstruct megasas_io_frame *ldio;\n\n\tdevice_id = MEGASAS_DEV_INDEX(scp);\n\tldio = (struct megasas_io_frame *)cmd->frame;\n\n\tif (scp->sc_data_direction == DMA_TO_DEVICE)\n\t\tflags = MFI_FRAME_DIR_WRITE;\n\telse if (scp->sc_data_direction == DMA_FROM_DEVICE)\n\t\tflags = MFI_FRAME_DIR_READ;\n\n\tif (instance->flag_ieee == 1) {\n\t\tflags |= MFI_FRAME_IEEE;\n\t}\n\n\t/*\n\t * Prepare the Logical IO frame: 2nd bit is zero for all read cmds\n\t */\n\tldio->cmd = (sc & 0x02) ? MFI_CMD_LD_WRITE : MFI_CMD_LD_READ;\n\tldio->cmd_status = 0x0;\n\tldio->scsi_status = 0x0;\n\tldio->target_id = device_id;\n\tldio->timeout = 0;\n\tldio->reserved_0 = 0;\n\tldio->pad_0 = 0;\n\tldio->flags = cpu_to_le16(flags);\n\tldio->start_lba_hi = 0;\n\tldio->access_byte = (scp->cmd_len != 6) ? scp->cmnd[1] : 0;\n\n\t/*\n\t * 6-byte READ(0x08) or WRITE(0x0A) cdb\n\t */\n\tif (scp->cmd_len == 6) {\n\t\tldio->lba_count = cpu_to_le32((u32) scp->cmnd[4]);\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[1] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[2] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[3]);\n\n\t\tldio->start_lba_lo &= cpu_to_le32(0x1FFFFF);\n\t}\n\n\t/*\n\t * 10-byte READ(0x28) or WRITE(0x2A) cdb\n\t */\n\telse if (scp->cmd_len == 10) {\n\t\tldio->lba_count = cpu_to_le32((u32) scp->cmnd[8] |\n\t\t\t\t\t      ((u32) scp->cmnd[7] << 8));\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\t}\n\n\t/*\n\t * 12-byte READ(0xA8) or WRITE(0xAA) cdb\n\t */\n\telse if (scp->cmd_len == 12) {\n\t\tldio->lba_count = cpu_to_le32(((u32) scp->cmnd[6] << 24) |\n\t\t\t\t\t      ((u32) scp->cmnd[7] << 16) |\n\t\t\t\t\t      ((u32) scp->cmnd[8] << 8) |\n\t\t\t\t\t      (u32) scp->cmnd[9]);\n\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\t}\n\n\t/*\n\t * 16-byte READ(0x88) or WRITE(0x8A) cdb\n\t */\n\telse if (scp->cmd_len == 16) {\n\t\tldio->lba_count = cpu_to_le32(((u32) scp->cmnd[10] << 24) |\n\t\t\t\t\t      ((u32) scp->cmnd[11] << 16) |\n\t\t\t\t\t      ((u32) scp->cmnd[12] << 8) |\n\t\t\t\t\t      (u32) scp->cmnd[13]);\n\n\t\tldio->start_lba_lo = cpu_to_le32(((u32) scp->cmnd[6] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[7] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[8] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[9]);\n\n\t\tldio->start_lba_hi = cpu_to_le32(((u32) scp->cmnd[2] << 24) |\n\t\t\t\t\t\t ((u32) scp->cmnd[3] << 16) |\n\t\t\t\t\t\t ((u32) scp->cmnd[4] << 8) |\n\t\t\t\t\t\t (u32) scp->cmnd[5]);\n\n\t}\n\n\t/*\n\t * Construct SGL\n\t */\n\tif (instance->flag_ieee) {\n\t\tldio->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tldio->sge_count = megasas_make_sgl_skinny(instance, scp,\n\t\t\t\t\t      &ldio->sgl);\n\t} else if (IS_DMA64) {\n\t\tldio->flags |= cpu_to_le16(MFI_FRAME_SGL64);\n\t\tldio->sge_count = megasas_make_sgl64(instance, scp, &ldio->sgl);\n\t} else\n\t\tldio->sge_count = megasas_make_sgl32(instance, scp, &ldio->sgl);\n\n\tif (ldio->sge_count > instance->max_num_sge) {\n\t\tdev_err(&instance->pdev->dev, \"build_ld_io: sge_count = %x\\n\",\n\t\t\tldio->sge_count);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Sense info specific\n\t */\n\tldio->sense_len = SCSI_SENSE_BUFFERSIZE;\n\tldio->sense_buf_phys_addr_hi = 0;\n\tldio->sense_buf_phys_addr_lo = cpu_to_le32(cmd->sense_phys_addr);\n\n\t/*\n\t * Compute the total number of frames this command consumes. FW uses\n\t * this number to pull sufficient number of frames from host memory.\n\t */\n\tcmd->frame_count = megasas_get_frame_count(instance,\n\t\t\tldio->sge_count, IO_FRAME);\n\n\treturn cmd->frame_count;\n}\n\n/**\n * megasas_cmd_type -\t\tChecks if the cmd is for logical drive/sysPD\n *\t\t\t\tand whether it's RW or non RW\n * @scmd:\t\t\tSCSI command\n *\n */\ninline int megasas_cmd_type(struct scsi_cmnd *cmd)\n{\n\tint ret;\n\n\tswitch (cmd->cmnd[0]) {\n\tcase READ_10:\n\tcase WRITE_10:\n\tcase READ_12:\n\tcase WRITE_12:\n\tcase READ_6:\n\tcase WRITE_6:\n\tcase READ_16:\n\tcase WRITE_16:\n\t\tret = (MEGASAS_IS_LOGICAL(cmd->device)) ?\n\t\t\tREAD_WRITE_LDIO : READ_WRITE_SYSPDIO;\n\t\tbreak;\n\tdefault:\n\t\tret = (MEGASAS_IS_LOGICAL(cmd->device)) ?\n\t\t\tNON_READ_WRITE_LDIO : NON_READ_WRITE_SYSPDIO;\n\t}\n\treturn ret;\n}\n\n /**\n * megasas_dump_pending_frames -\tDumps the frame address of all pending cmds\n *\t\t\t\t\tin FW\n * @instance:\t\t\t\tAdapter soft state\n */\nstatic inline void\nmegasas_dump_pending_frames(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tint i,n;\n\tunion megasas_sgl *mfi_sgl;\n\tstruct megasas_io_frame *ldio;\n\tstruct megasas_pthru_frame *pthru;\n\tu32 sgcount;\n\tu16 max_cmd = instance->max_fw_cmds;\n\n\tdev_err(&instance->pdev->dev, \"[%d]: Dumping Frame Phys Address of all pending cmds in FW\\n\",instance->host->host_no);\n\tdev_err(&instance->pdev->dev, \"[%d]: Total OS Pending cmds : %d\\n\",instance->host->host_no,atomic_read(&instance->fw_outstanding));\n\tif (IS_DMA64)\n\t\tdev_err(&instance->pdev->dev, \"[%d]: 64 bit SGLs were sent to FW\\n\",instance->host->host_no);\n\telse\n\t\tdev_err(&instance->pdev->dev, \"[%d]: 32 bit SGLs were sent to FW\\n\",instance->host->host_no);\n\n\tdev_err(&instance->pdev->dev, \"[%d]: Pending OS cmds in FW : \\n\",instance->host->host_no);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tif (!cmd->scmd)\n\t\t\tcontinue;\n\t\tdev_err(&instance->pdev->dev, \"[%d]: Frame addr :0x%08lx : \",instance->host->host_no,(unsigned long)cmd->frame_phys_addr);\n\t\tif (megasas_cmd_type(cmd->scmd) == READ_WRITE_LDIO) {\n\t\t\tldio = (struct megasas_io_frame *)cmd->frame;\n\t\t\tmfi_sgl = &ldio->sgl;\n\t\t\tsgcount = ldio->sge_count;\n\t\t\tdev_err(&instance->pdev->dev, \"[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x,\"\n\t\t\t\" lba lo : 0x%x, lba_hi : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\\n\",\n\t\t\tinstance->host->host_no, cmd->frame_count, ldio->cmd, ldio->target_id,\n\t\t\tle32_to_cpu(ldio->start_lba_lo), le32_to_cpu(ldio->start_lba_hi),\n\t\t\tle32_to_cpu(ldio->sense_buf_phys_addr_lo), sgcount);\n\t\t} else {\n\t\t\tpthru = (struct megasas_pthru_frame *) cmd->frame;\n\t\t\tmfi_sgl = &pthru->sgl;\n\t\t\tsgcount = pthru->sge_count;\n\t\t\tdev_err(&instance->pdev->dev, \"[%d]: frame count : 0x%x, Cmd : 0x%x, Tgt id : 0x%x, \"\n\t\t\t\"lun : 0x%x, cdb_len : 0x%x, data xfer len : 0x%x, sense_buf addr : 0x%x,sge count : 0x%x\\n\",\n\t\t\tinstance->host->host_no, cmd->frame_count, pthru->cmd, pthru->target_id,\n\t\t\tpthru->lun, pthru->cdb_len, le32_to_cpu(pthru->data_xfer_len),\n\t\t\tle32_to_cpu(pthru->sense_buf_phys_addr_lo), sgcount);\n\t\t}\n\t\tif (megasas_dbg_lvl & MEGASAS_DBG_LVL) {\n\t\t\tfor (n = 0; n < sgcount; n++) {\n\t\t\t\tif (IS_DMA64)\n\t\t\t\t\tdev_err(&instance->pdev->dev, \"sgl len : 0x%x, sgl addr : 0x%llx\\n\",\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge64[n].length),\n\t\t\t\t\t\tle64_to_cpu(mfi_sgl->sge64[n].phys_addr));\n\t\t\t\telse\n\t\t\t\t\tdev_err(&instance->pdev->dev, \"sgl len : 0x%x, sgl addr : 0x%x\\n\",\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge32[n].length),\n\t\t\t\t\t\tle32_to_cpu(mfi_sgl->sge32[n].phys_addr));\n\t\t\t}\n\t\t}\n\t} /*for max_cmd*/\n\tdev_err(&instance->pdev->dev, \"[%d]: Pending Internal cmds in FW : \\n\",instance->host->host_no);\n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tif (cmd->sync_cmd == 1)\n\t\t\tdev_err(&instance->pdev->dev, \"0x%08lx : \", (unsigned long)cmd->frame_phys_addr);\n\t}\n\tdev_err(&instance->pdev->dev, \"[%d]: Dumping Done\\n\\n\",instance->host->host_no);\n}\n\nu32\nmegasas_build_and_issue_cmd(struct megasas_instance *instance,\n\t\t\t    struct scsi_cmnd *scmd)\n{\n\tstruct megasas_cmd *cmd;\n\tu32 frame_count;\n\n\tcmd = megasas_get_cmd(instance);\n\tif (!cmd)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\t/*\n\t * Logical drive command\n\t */\n\tif (megasas_cmd_type(scmd) == READ_WRITE_LDIO)\n\t\tframe_count = megasas_build_ldio(instance, scmd, cmd);\n\telse\n\t\tframe_count = megasas_build_dcdb(instance, scmd, cmd);\n\n\tif (!frame_count)\n\t\tgoto out_return_cmd;\n\n\tcmd->scmd = scmd;\n\tscmd->SCp.ptr = (char *)cmd;\n\n\t/*\n\t * Issue the command to the FW\n\t */\n\tatomic_inc(&instance->fw_outstanding);\n\n\tinstance->instancet->fire_cmd(instance, cmd->frame_phys_addr,\n\t\t\t\tcmd->frame_count-1, instance->reg_set);\n\n\treturn 0;\nout_return_cmd:\n\tmegasas_return_cmd(instance, cmd);\n\treturn SCSI_MLQUEUE_HOST_BUSY;\n}\n\n\n/**\n * megasas_queue_command -\tQueue entry point\n * @scmd:\t\t\tSCSI command to be queued\n * @done:\t\t\tCallback entry point\n */\nstatic int\nmegasas_queue_command(struct Scsi_Host *shost, struct scsi_cmnd *scmd)\n{\n\tstruct megasas_instance *instance;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = (struct megasas_instance *)\n\t    scmd->device->host->hostdata;\n\n\tif (instance->unload == 1) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tif (instance->issuepend_done == 0)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\n\t/* Check for an mpio path and adjust behavior */\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tif (megasas_check_mpio_paths(instance, scmd) ==\n\t\t    (DID_REQUEUE << 16)) {\n\t\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\t\t} else {\n\t\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\t\tscmd->scsi_done(scmd);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tmr_device_priv_data = scmd->device->hostdata;\n\tif (!mr_device_priv_data) {\n\t\tscmd->result = DID_NO_CONNECT << 16;\n\t\tscmd->scsi_done(scmd);\n\t\treturn 0;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL)\n\t\treturn SCSI_MLQUEUE_HOST_BUSY;\n\n\tif (mr_device_priv_data->tm_busy)\n\t\treturn SCSI_MLQUEUE_DEVICE_BUSY;\n\n\n\tscmd->result = 0;\n\n\tif (MEGASAS_IS_LOGICAL(scmd->device) &&\n\t    (scmd->device->id >= instance->fw_supported_vd_count ||\n\t\tscmd->device->lun)) {\n\t\tscmd->result = DID_BAD_TARGET << 16;\n\t\tgoto out_done;\n\t}\n\n\tif ((scmd->cmnd[0] == SYNCHRONIZE_CACHE) &&\n\t    MEGASAS_IS_LOGICAL(scmd->device) &&\n\t    (!instance->fw_sync_cache_support)) {\n\t\tscmd->result = DID_OK << 16;\n\t\tgoto out_done;\n\t}\n\n\treturn instance->instancet->build_and_issue_cmd(instance, scmd);\n\n out_done:\n\tscmd->scsi_done(scmd);\n\treturn 0;\n}\n\nstatic struct megasas_instance *megasas_lookup_instance(u16 host_no)\n{\n\tint i;\n\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\n\t\tif ((megasas_mgmt_info.instance[i]) &&\n\t\t    (megasas_mgmt_info.instance[i]->host->host_no == host_no))\n\t\t\treturn megasas_mgmt_info.instance[i];\n\t}\n\n\treturn NULL;\n}\n\n/*\n* megasas_set_dynamic_target_properties -\n* Device property set by driver may not be static and it is required to be\n* updated after OCR\n*\n* set tm_capable.\n* set dma alignment (only for eedp protection enable vd).\n*\n* @sdev: OS provided scsi device\n*\n* Returns void\n*/\nvoid megasas_set_dynamic_target_properties(struct scsi_device *sdev,\n\t\t\t\t\t   bool is_target_prop)\n{\n\tu16 pd_index = 0, ld;\n\tu32 device_id;\n\tstruct megasas_instance *instance;\n\tstruct fusion_context *fusion;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tstruct MR_PD_CFG_SEQ_NUM_SYNC *pd_sync;\n\tstruct MR_LD_RAID *raid;\n\tstruct MR_DRV_RAID_MAP_ALL *local_map_ptr;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tfusion = instance->ctrl_context;\n\tmr_device_priv_data = sdev->hostdata;\n\n\tif (!fusion || !mr_device_priv_data)\n\t\treturn;\n\n\tif (MEGASAS_IS_LOGICAL(sdev)) {\n\t\tdevice_id = ((sdev->channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL)\n\t\t\t\t\t+ sdev->id;\n\t\tlocal_map_ptr = fusion->ld_drv_map[(instance->map_id & 1)];\n\t\tld = MR_TargetIdToLdGet(device_id, local_map_ptr);\n\t\tif (ld >= instance->fw_supported_vd_count)\n\t\t\treturn;\n\t\traid = MR_LdRaidGet(ld, local_map_ptr);\n\n\t\tif (raid->capability.ldPiMode == MR_PROT_INFO_TYPE_CONTROLLER)\n\t\tblk_queue_update_dma_alignment(sdev->request_queue, 0x7);\n\n\t\tmr_device_priv_data->is_tm_capable =\n\t\t\traid->capability.tmCapable;\n\t} else if (instance->use_seqnum_jbod_fp) {\n\t\tpd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\tsdev->id;\n\t\tpd_sync = (void *)fusion->pd_seq_sync\n\t\t\t\t[(instance->pd_seq_map_id - 1) & 1];\n\t\tmr_device_priv_data->is_tm_capable =\n\t\t\tpd_sync->seq[pd_index].capability.tmCapable;\n\t}\n\n\tif (is_target_prop && instance->tgt_prop->reset_tmo) {\n\t\t/*\n\t\t * If FW provides a target reset timeout value, driver will use\n\t\t * it. If not set, fallback to default values.\n\t\t */\n\t\tmr_device_priv_data->target_reset_tmo =\n\t\t\tmin_t(u8, instance->max_reset_tmo,\n\t\t\t      instance->tgt_prop->reset_tmo);\n\t\tmr_device_priv_data->task_abort_tmo = instance->task_abort_tmo;\n\t} else {\n\t\tmr_device_priv_data->target_reset_tmo =\n\t\t\t\t\t\tMEGASAS_DEFAULT_TM_TIMEOUT;\n\t\tmr_device_priv_data->task_abort_tmo =\n\t\t\t\t\t\tMEGASAS_DEFAULT_TM_TIMEOUT;\n\t}\n}\n\n/*\n * megasas_set_nvme_device_properties -\n * set nomerges=2\n * set virtual page boundary = 4K (current mr_nvme_pg_size is 4K).\n * set maximum io transfer = MDTS of NVME device provided by MR firmware.\n *\n * MR firmware provides value in KB. Caller of this function converts\n * kb into bytes.\n *\n * e.a MDTS=5 means 2^5 * nvme page size. (In case of 4K page size,\n * MR firmware provides value 128 as (32 * 4K) = 128K.\n *\n * @sdev:\t\t\t\tscsi device\n * @max_io_size:\t\t\t\tmaximum io transfer size\n *\n */\nstatic inline void\nmegasas_set_nvme_device_properties(struct scsi_device *sdev, u32 max_io_size)\n{\n\tstruct megasas_instance *instance;\n\tu32 mr_nvme_pg_size;\n\n\tinstance = (struct megasas_instance *)sdev->host->hostdata;\n\tmr_nvme_pg_size = max_t(u32, instance->nvme_page_size,\n\t\t\t\tMR_DEFAULT_NVME_PAGE_SIZE);\n\n\tblk_queue_max_hw_sectors(sdev->request_queue, (max_io_size / 512));\n\n\tblk_queue_flag_set(QUEUE_FLAG_NOMERGES, sdev->request_queue);\n\tblk_queue_virt_boundary(sdev->request_queue, mr_nvme_pg_size - 1);\n}\n\n\n/*\n * megasas_set_static_target_properties -\n * Device property set by driver are static and it is not required to be\n * updated after OCR.\n *\n * set io timeout\n * set device queue depth\n * set nvme device properties. see - megasas_set_nvme_device_properties\n *\n * @sdev:\t\t\t\tscsi device\n * @is_target_prop\t\t\ttrue, if fw provided target properties.\n */\nstatic void megasas_set_static_target_properties(struct scsi_device *sdev,\n\t\t\t\t\t\t bool is_target_prop)\n{\n\tu16\ttarget_index = 0;\n\tu8 interface_type;\n\tu32 device_qd = MEGASAS_DEFAULT_CMD_PER_LUN;\n\tu32 max_io_size_kb = MR_DEFAULT_NVME_MDTS_KB;\n\tu32 tgt_device_qd;\n\tstruct megasas_instance *instance;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tmr_device_priv_data = sdev->hostdata;\n\tinterface_type  = mr_device_priv_data->interface_type;\n\n\t/*\n\t * The RAID firmware may require extended timeouts.\n\t */\n\tblk_queue_rq_timeout(sdev->request_queue, scmd_timeout * HZ);\n\n\ttarget_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) + sdev->id;\n\n\tswitch (interface_type) {\n\tcase SAS_PD:\n\t\tdevice_qd = MEGASAS_SAS_QD;\n\t\tbreak;\n\tcase SATA_PD:\n\t\tdevice_qd = MEGASAS_SATA_QD;\n\t\tbreak;\n\tcase NVME_PD:\n\t\tdevice_qd = MEGASAS_NVME_QD;\n\t\tbreak;\n\t}\n\n\tif (is_target_prop) {\n\t\ttgt_device_qd = le32_to_cpu(instance->tgt_prop->device_qdepth);\n\t\tif (tgt_device_qd &&\n\t\t    (tgt_device_qd <= instance->host->can_queue))\n\t\t\tdevice_qd = tgt_device_qd;\n\n\t\t/* max_io_size_kb will be set to non zero for\n\t\t * nvme based vd and syspd.\n\t\t */\n\t\tmax_io_size_kb = le32_to_cpu(instance->tgt_prop->max_io_size_kb);\n\t}\n\n\tif (instance->nvme_page_size && max_io_size_kb)\n\t\tmegasas_set_nvme_device_properties(sdev, (max_io_size_kb << 10));\n\n\tscsi_change_queue_depth(sdev, device_qd);\n\n}\n\n\nstatic int megasas_slave_configure(struct scsi_device *sdev)\n{\n\tu16 pd_index = 0;\n\tstruct megasas_instance *instance;\n\tint ret_target_prop = DCMD_FAILED;\n\tbool is_target_prop = false;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tif (instance->pd_list_not_supported) {\n\t\tif (!MEGASAS_IS_LOGICAL(sdev) && sdev->type == TYPE_DISK) {\n\t\t\tpd_index = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\t\tsdev->id;\n\t\t\tif (instance->pd_list[pd_index].driveState !=\n\t\t\t\tMR_PD_STATE_SYSTEM)\n\t\t\t\treturn -ENXIO;\n\t\t}\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\t/* Send DCMD to Firmware and cache the information */\n\tif ((instance->pd_info) && !MEGASAS_IS_LOGICAL(sdev))\n\t\tmegasas_get_pd_info(instance, sdev);\n\n\t/* Some ventura firmware may not have instance->nvme_page_size set.\n\t * Do not send MR_DCMD_DRV_GET_TARGET_PROP\n\t */\n\tif ((instance->tgt_prop) && (instance->nvme_page_size))\n\t\tret_target_prop = megasas_get_target_prop(instance, sdev);\n\n\tis_target_prop = (ret_target_prop == DCMD_SUCCESS) ? true : false;\n\tmegasas_set_static_target_properties(sdev, is_target_prop);\n\n\t/* This sdev property may change post OCR */\n\tmegasas_set_dynamic_target_properties(sdev, is_target_prop);\n\n\tmutex_unlock(&instance->reset_mutex);\n\n\treturn 0;\n}\n\nstatic int megasas_slave_alloc(struct scsi_device *sdev)\n{\n\tu16 pd_index = 0;\n\tstruct megasas_instance *instance ;\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\n\tinstance = megasas_lookup_instance(sdev->host->host_no);\n\tif (!MEGASAS_IS_LOGICAL(sdev)) {\n\t\t/*\n\t\t * Open the OS scan to the SYSTEM PD\n\t\t */\n\t\tpd_index =\n\t\t\t(sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) +\n\t\t\tsdev->id;\n\t\tif ((instance->pd_list_not_supported ||\n\t\t\tinstance->pd_list[pd_index].driveState ==\n\t\t\tMR_PD_STATE_SYSTEM)) {\n\t\t\tgoto scan_target;\n\t\t}\n\t\treturn -ENXIO;\n\t}\n\nscan_target:\n\tmr_device_priv_data = kzalloc(sizeof(*mr_device_priv_data),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!mr_device_priv_data)\n\t\treturn -ENOMEM;\n\tsdev->hostdata = mr_device_priv_data;\n\n\tatomic_set(&mr_device_priv_data->r1_ldio_hint,\n\t\t   instance->r1_ldio_hint_default);\n\treturn 0;\n}\n\nstatic void megasas_slave_destroy(struct scsi_device *sdev)\n{\n\tkfree(sdev->hostdata);\n\tsdev->hostdata = NULL;\n}\n\n/*\n* megasas_complete_outstanding_ioctls - Complete outstanding ioctls after a\n*                                       kill adapter\n* @instance:\t\t\t\tAdapter soft state\n*\n*/\nstatic void megasas_complete_outstanding_ioctls(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct megasas_cmd *cmd_mfi;\n\tstruct megasas_cmd_fusion *cmd_fusion;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\t/* Find all outstanding ioctls */\n\tif (fusion) {\n\t\tfor (i = 0; i < instance->max_fw_cmds; i++) {\n\t\t\tcmd_fusion = fusion->cmd_list[i];\n\t\t\tif (cmd_fusion->sync_cmd_idx != (u32)ULONG_MAX) {\n\t\t\t\tcmd_mfi = instance->cmd_list[cmd_fusion->sync_cmd_idx];\n\t\t\t\tif (cmd_mfi->sync_cmd &&\n\t\t\t\t    (cmd_mfi->frame->hdr.cmd != MFI_CMD_ABORT)) {\n\t\t\t\t\tcmd_mfi->frame->hdr.cmd_status =\n\t\t\t\t\t\t\tMFI_STAT_WRONG_STATE;\n\t\t\t\t\tmegasas_complete_cmd(instance,\n\t\t\t\t\t\t\t     cmd_mfi, DID_OK);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < instance->max_fw_cmds; i++) {\n\t\t\tcmd_mfi = instance->cmd_list[i];\n\t\t\tif (cmd_mfi->sync_cmd && cmd_mfi->frame->hdr.cmd !=\n\t\t\t\tMFI_CMD_ABORT)\n\t\t\t\tmegasas_complete_cmd(instance, cmd_mfi, DID_OK);\n\t\t}\n\t}\n}\n\n\nvoid megaraid_sas_kill_hba(struct megasas_instance *instance)\n{\n\t/* Set critical error to block I/O & ioctls in case caller didn't */\n\tatomic_set(&instance->adprecovery, MEGASAS_HW_CRITICAL_ERROR);\n\t/* Wait 1 second to ensure IO or ioctls in build have posted */\n\tmsleep(1000);\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t(instance->adapter_type != MFI_SERIES)) {\n\t\tif (!instance->requestorId) {\n\t\t\twritel(MFI_STOP_ADP, &instance->reg_set->doorbell);\n\t\t\t/* Flush */\n\t\t\treadl(&instance->reg_set->doorbell);\n\t\t}\n\t\tif (instance->requestorId && instance->peerIsPresent)\n\t\t\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\t} else {\n\t\twritel(MFI_STOP_ADP,\n\t\t\t&instance->reg_set->inbound_doorbell);\n\t}\n\t/* Complete outstanding ioctls when adapter is killed */\n\tmegasas_complete_outstanding_ioctls(instance);\n}\n\n /**\n  * megasas_check_and_restore_queue_depth - Check if queue depth needs to be\n  *\t\t\t\t\trestored to max value\n  * @instance:\t\t\tAdapter soft state\n  *\n  */\nvoid\nmegasas_check_and_restore_queue_depth(struct megasas_instance *instance)\n{\n\tunsigned long flags;\n\n\tif (instance->flag & MEGASAS_FW_BUSY\n\t    && time_after(jiffies, instance->last_time + 5 * HZ)\n\t    && atomic_read(&instance->fw_outstanding) <\n\t    instance->throttlequeuedepth + 1) {\n\n\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\tinstance->flag &= ~MEGASAS_FW_BUSY;\n\n\t\tinstance->host->can_queue = instance->cur_can_queue;\n\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t}\n}\n\n/**\n * megasas_complete_cmd_dpc\t -\tReturns FW's controller structure\n * @instance_addr:\t\t\tAddress of adapter soft state\n *\n * Tasklet to complete cmds\n */\nstatic void megasas_complete_cmd_dpc(unsigned long instance_addr)\n{\n\tu32 producer;\n\tu32 consumer;\n\tu32 context;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_instance *instance =\n\t\t\t\t(struct megasas_instance *)instance_addr;\n\tunsigned long flags;\n\n\t/* If we have already declared adapter dead, donot complete cmds */\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tspin_lock_irqsave(&instance->completion_lock, flags);\n\n\tproducer = le32_to_cpu(*instance->producer);\n\tconsumer = le32_to_cpu(*instance->consumer);\n\n\twhile (consumer != producer) {\n\t\tcontext = le32_to_cpu(instance->reply_queue[consumer]);\n\t\tif (context >= instance->max_fw_cmds) {\n\t\t\tdev_err(&instance->pdev->dev, \"Unexpected context value %x\\n\",\n\t\t\t\tcontext);\n\t\t\tBUG();\n\t\t}\n\n\t\tcmd = instance->cmd_list[context];\n\n\t\tmegasas_complete_cmd(instance, cmd, DID_OK);\n\n\t\tconsumer++;\n\t\tif (consumer == (instance->max_fw_cmds + 1)) {\n\t\t\tconsumer = 0;\n\t\t}\n\t}\n\n\t*instance->consumer = cpu_to_le32(producer);\n\n\tspin_unlock_irqrestore(&instance->completion_lock, flags);\n\n\t/*\n\t * Check if we can restore can_queue\n\t */\n\tmegasas_check_and_restore_queue_depth(instance);\n}\n\nstatic void megasas_sriov_heartbeat_handler(struct timer_list *t);\n\n/**\n * megasas_start_timer - Initializes sriov heartbeat timer object\n * @instance:\t\tAdapter soft state\n *\n */\nvoid megasas_start_timer(struct megasas_instance *instance)\n{\n\tstruct timer_list *timer = &instance->sriov_heartbeat_timer;\n\n\ttimer_setup(timer, megasas_sriov_heartbeat_handler, 0);\n\ttimer->expires = jiffies + MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF;\n\tadd_timer(timer);\n}\n\nstatic void\nmegasas_internal_reset_defer_cmds(struct megasas_instance *instance);\n\nstatic void\nprocess_fw_state_change_wq(struct work_struct *work);\n\nvoid megasas_do_ocr(struct megasas_instance *instance)\n{\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\n\t(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\n\t(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)) {\n\t\t*instance->consumer = cpu_to_le32(MEGASAS_ADPRESET_INPROG_SIGN);\n\t}\n\tinstance->instancet->disable_intr(instance);\n\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\n\tinstance->issuepend_done = 0;\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\tmegasas_internal_reset_defer_cmds(instance);\n\tprocess_fw_state_change_wq(&instance->work_init);\n}\n\nstatic int megasas_get_ld_vf_affiliation_111(struct megasas_instance *instance,\n\t\t\t\t\t    int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_VF_AFFILIATION_111 *new_affiliation_111 = NULL;\n\tdma_addr_t new_affiliation_111_h;\n\tint ld, retval = 0;\n\tu8 thisVf;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_vf_affiliation_111:\"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t\tinstance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (!instance->vf_affiliation_111) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Couldn't get LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (initial)\n\t\t\tmemset(instance->vf_affiliation_111, 0,\n\t\t\t       sizeof(struct MR_LD_VF_AFFILIATION_111));\n\telse {\n\t\tnew_affiliation_111 =\n\t\t\tdma_zalloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t      sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t\t      &new_affiliation_111_h, GFP_KERNEL);\n\t\tif (!new_affiliation_111) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate \"\n\t\t\t       \"memory for new affiliation for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len =\n\t\tcpu_to_le32(sizeof(struct MR_LD_VF_AFFILIATION_111));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_VF_MAP_GET_ALL_LDS_111);\n\n\tif (initial)\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(instance->vf_affiliation_111_h);\n\telse\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(new_affiliation_111_h);\n\n\tdcmd->sgl.sge32[0].length = cpu_to_le32(\n\t\tsizeof(struct MR_LD_VF_AFFILIATION_111));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Getting LD/VF affiliation for \"\n\t       \"scsi%d\\n\", instance->host->host_no);\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, 0) != DCMD_SUCCESS) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: LD/VF affiliation DCMD\"\n\t\t       \" failed with status 0x%x for scsi%d\\n\",\n\t\t       dcmd->cmd_status, instance->host->host_no);\n\t\tretval = 1; /* Do a scan if we couldn't get affiliation */\n\t\tgoto out;\n\t}\n\n\tif (!initial) {\n\t\tthisVf = new_affiliation_111->thisVf;\n\t\tfor (ld = 0 ; ld < new_affiliation_111->vdCount; ld++)\n\t\t\tif (instance->vf_affiliation_111->map[ld].policy[thisVf] !=\n\t\t\t    new_affiliation_111->map[ld].policy[thisVf]) {\n\t\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: \"\n\t\t\t\t       \"Got new LD/VF affiliation for scsi%d\\n\",\n\t\t\t\t       instance->host->host_no);\n\t\t\t\tmemcpy(instance->vf_affiliation_111,\n\t\t\t\t       new_affiliation_111,\n\t\t\t\t       sizeof(struct MR_LD_VF_AFFILIATION_111));\n\t\t\t\tretval = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t}\nout:\n\tif (new_affiliation_111) {\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t    new_affiliation_111,\n\t\t\t\t    new_affiliation_111_h);\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\nstatic int megasas_get_ld_vf_affiliation_12(struct megasas_instance *instance,\n\t\t\t\t\t    int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_VF_AFFILIATION *new_affiliation = NULL;\n\tstruct MR_LD_VF_MAP *newmap = NULL, *savedmap = NULL;\n\tdma_addr_t new_affiliation_h;\n\tint i, j, retval = 0, found = 0, doscan = 0;\n\tu8 thisVf;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_vf_affiliation12: \"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t       instance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (!instance->vf_affiliation) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Couldn't get LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (initial)\n\t\tmemset(instance->vf_affiliation, 0, (MAX_LOGICAL_DRIVES + 1) *\n\t\t       sizeof(struct MR_LD_VF_AFFILIATION));\n\telse {\n\t\tnew_affiliation =\n\t\t\tdma_zalloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t      (MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t\t      sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t\t      &new_affiliation_h, GFP_KERNEL);\n\t\tif (!new_affiliation) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate \"\n\t\t\t       \"memory for new affiliation for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32((MAX_LOGICAL_DRIVES + 1) *\n\t\tsizeof(struct MR_LD_VF_AFFILIATION));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_VF_MAP_GET_ALL_LDS);\n\n\tif (initial)\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(instance->vf_affiliation_h);\n\telse\n\t\tdcmd->sgl.sge32[0].phys_addr =\n\t\t\tcpu_to_le32(new_affiliation_h);\n\n\tdcmd->sgl.sge32[0].length = cpu_to_le32((MAX_LOGICAL_DRIVES + 1) *\n\t\tsizeof(struct MR_LD_VF_AFFILIATION));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Getting LD/VF affiliation for \"\n\t       \"scsi%d\\n\", instance->host->host_no);\n\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, 0) != DCMD_SUCCESS) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: LD/VF affiliation DCMD\"\n\t\t       \" failed with status 0x%x for scsi%d\\n\",\n\t\t       dcmd->cmd_status, instance->host->host_no);\n\t\tretval = 1; /* Do a scan if we couldn't get affiliation */\n\t\tgoto out;\n\t}\n\n\tif (!initial) {\n\t\tif (!new_affiliation->ldCount) {\n\t\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Got new LD/VF \"\n\t\t\t       \"affiliation for passive path for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tretval = 1;\n\t\t\tgoto out;\n\t\t}\n\t\tnewmap = new_affiliation->map;\n\t\tsavedmap = instance->vf_affiliation->map;\n\t\tthisVf = new_affiliation->thisVf;\n\t\tfor (i = 0 ; i < new_affiliation->ldCount; i++) {\n\t\t\tfound = 0;\n\t\t\tfor (j = 0; j < instance->vf_affiliation->ldCount;\n\t\t\t     j++) {\n\t\t\t\tif (newmap->ref.targetId ==\n\t\t\t\t    savedmap->ref.targetId) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif (newmap->policy[thisVf] !=\n\t\t\t\t\t    savedmap->policy[thisVf]) {\n\t\t\t\t\t\tdoscan = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsavedmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t\t((unsigned char *)savedmap +\n\t\t\t\t\t savedmap->size);\n\t\t\t}\n\t\t\tif (!found && newmap->policy[thisVf] !=\n\t\t\t    MR_LD_ACCESS_HIDDEN) {\n\t\t\t\tdoscan = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tnewmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t((unsigned char *)newmap + newmap->size);\n\t\t}\n\n\t\tnewmap = new_affiliation->map;\n\t\tsavedmap = instance->vf_affiliation->map;\n\n\t\tfor (i = 0 ; i < instance->vf_affiliation->ldCount; i++) {\n\t\t\tfound = 0;\n\t\t\tfor (j = 0 ; j < new_affiliation->ldCount; j++) {\n\t\t\t\tif (savedmap->ref.targetId ==\n\t\t\t\t    newmap->ref.targetId) {\n\t\t\t\t\tfound = 1;\n\t\t\t\t\tif (savedmap->policy[thisVf] !=\n\t\t\t\t\t    newmap->policy[thisVf]) {\n\t\t\t\t\t\tdoscan = 1;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t\t((unsigned char *)newmap +\n\t\t\t\t\t newmap->size);\n\t\t\t}\n\t\t\tif (!found && savedmap->policy[thisVf] !=\n\t\t\t    MR_LD_ACCESS_HIDDEN) {\n\t\t\t\tdoscan = 1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tsavedmap = (struct MR_LD_VF_MAP *)\n\t\t\t\t((unsigned char *)savedmap +\n\t\t\t\t savedmap->size);\n\t\t}\n\t}\nout:\n\tif (doscan) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Got new LD/VF \"\n\t\t       \"affiliation for scsi%d\\n\", instance->host->host_no);\n\t\tmemcpy(instance->vf_affiliation, new_affiliation,\n\t\t       new_affiliation->size);\n\t\tretval = 1;\n\t}\n\n\tif (new_affiliation)\n\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t    (MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t    new_affiliation, new_affiliation_h);\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\n/* This function will get the current SR-IOV LD/VF affiliation */\nstatic int megasas_get_ld_vf_affiliation(struct megasas_instance *instance,\n\tint initial)\n{\n\tint retval;\n\n\tif (instance->PlasmaFW111)\n\t\tretval = megasas_get_ld_vf_affiliation_111(instance, initial);\n\telse\n\t\tretval = megasas_get_ld_vf_affiliation_12(instance, initial);\n\treturn retval;\n}\n\n/* This function will tell FW to start the SR-IOV heartbeat */\nint megasas_sriov_start_heartbeat(struct megasas_instance *instance,\n\t\t\t\t\t int initial)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tint retval = 0;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_sriov_start_heartbeat: \"\n\t\t       \"Failed to get cmd for scsi%d\\n\",\n\t\t       instance->host->host_no);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tif (initial) {\n\t\tinstance->hb_host_mem =\n\t\t\tdma_zalloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t      sizeof(struct MR_CTRL_HB_HOST_MEM),\n\t\t\t\t\t      &instance->hb_host_mem_h, GFP_KERNEL);\n\t\tif (!instance->hb_host_mem) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SR-IOV: Couldn't allocate\"\n\t\t\t       \" memory for heartbeat host memory for scsi%d\\n\",\n\t\t\t       instance->host->host_no);\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.s[0] = cpu_to_le16(sizeof(struct MR_CTRL_HB_HOST_MEM));\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_BOTH);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_CTRL_HB_HOST_MEM));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SHARED_HOST_MEM_ALLOC);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->hb_host_mem_h,\n\t\t\t\t sizeof(struct MR_CTRL_HB_HOST_MEM));\n\n\tdev_warn(&instance->pdev->dev, \"SR-IOV: Starting heartbeat for scsi%d\\n\",\n\t       instance->host->host_no);\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tretval = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMEGASAS_ROUTINE_WAIT_TIME_VF);\n\telse\n\t\tretval = megasas_issue_polled(instance, cmd);\n\n\tif (retval) {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: MR_DCMD_CTRL_SHARED_HOST\"\n\t\t\t\"_MEM_ALLOC DCMD %s for scsi%d\\n\",\n\t\t\t(dcmd->cmd_status == MFI_STAT_INVALID_STATUS) ?\n\t\t\t\"timed out\" : \"failed\", instance->host->host_no);\n\t\tretval = 1;\n\t}\n\nout:\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn retval;\n}\n\n/* Handler for SR-IOV heartbeat */\nstatic void megasas_sriov_heartbeat_handler(struct timer_list *t)\n{\n\tstruct megasas_instance *instance =\n\t\tfrom_timer(instance, t, sriov_heartbeat_timer);\n\n\tif (instance->hb_host_mem->HB.fwCounter !=\n\t    instance->hb_host_mem->HB.driverCounter) {\n\t\tinstance->hb_host_mem->HB.driverCounter =\n\t\t\tinstance->hb_host_mem->HB.fwCounter;\n\t\tmod_timer(&instance->sriov_heartbeat_timer,\n\t\t\t  jiffies + MEGASAS_SRIOV_HEARTBEAT_INTERVAL_VF);\n\t} else {\n\t\tdev_warn(&instance->pdev->dev, \"SR-IOV: Heartbeat never \"\n\t\t       \"completed for scsi%d\\n\", instance->host->host_no);\n\t\tschedule_work(&instance->work_init);\n\t}\n}\n\n/**\n * megasas_wait_for_outstanding -\tWait for all outstanding cmds\n * @instance:\t\t\t\tAdapter soft state\n *\n * This function waits for up to MEGASAS_RESET_WAIT_TIME seconds for FW to\n * complete all its outstanding commands. Returns error if one or more IOs\n * are pending after this time period. It also marks the controller dead.\n */\nstatic int megasas_wait_for_outstanding(struct megasas_instance *instance)\n{\n\tint i, sl, outstanding;\n\tu32 reset_index;\n\tu32 wait_time = MEGASAS_RESET_WAIT_TIME;\n\tunsigned long flags;\n\tstruct list_head clist_local;\n\tstruct megasas_cmd *reset_cmd;\n\tu32 fw_state;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_info(&instance->pdev->dev, \"%s:%d HBA is killed.\\n\",\n\t\t__func__, __LINE__);\n\t\treturn FAILED;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\n\n\t\tINIT_LIST_HEAD(&clist_local);\n\t\tspin_lock_irqsave(&instance->hba_lock, flags);\n\t\tlist_splice_init(&instance->internal_reset_pending_q,\n\t\t\t\t&clist_local);\n\t\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\t\tdev_notice(&instance->pdev->dev, \"HBA reset wait ...\\n\");\n\t\tfor (i = 0; i < wait_time; i++) {\n\t\t\tmsleep(1000);\n\t\t\tif (atomic_read(&instance->adprecovery) == MEGASAS_HBA_OPERATIONAL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (atomic_read(&instance->adprecovery) != MEGASAS_HBA_OPERATIONAL) {\n\t\t\tdev_notice(&instance->pdev->dev, \"reset: Stopping HBA.\\n\");\n\t\t\tatomic_set(&instance->adprecovery, MEGASAS_HW_CRITICAL_ERROR);\n\t\t\treturn FAILED;\n\t\t}\n\n\t\treset_index = 0;\n\t\twhile (!list_empty(&clist_local)) {\n\t\t\treset_cmd = list_entry((&clist_local)->next,\n\t\t\t\t\t\tstruct megasas_cmd, list);\n\t\t\tlist_del_init(&reset_cmd->list);\n\t\t\tif (reset_cmd->scmd) {\n\t\t\t\treset_cmd->scmd->result = DID_REQUEUE << 16;\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%d:%p reset [%02x]\\n\",\n\t\t\t\t\treset_index, reset_cmd,\n\t\t\t\t\treset_cmd->scmd->cmnd[0]);\n\n\t\t\t\treset_cmd->scmd->scsi_done(reset_cmd->scmd);\n\t\t\t\tmegasas_return_cmd(instance, reset_cmd);\n\t\t\t} else if (reset_cmd->sync_cmd) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%p synch cmds\"\n\t\t\t\t\t\t\"reset queue\\n\",\n\t\t\t\t\t\treset_cmd);\n\n\t\t\t\treset_cmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;\n\t\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\t\treset_cmd->frame_phys_addr,\n\t\t\t\t\t\t0, instance->reg_set);\n\t\t\t} else {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"%p unexpected\"\n\t\t\t\t\t\"cmds lst\\n\",\n\t\t\t\t\treset_cmd);\n\t\t\t}\n\t\t\treset_index++;\n\t\t}\n\n\t\treturn SUCCESS;\n\t}\n\n\tfor (i = 0; i < resetwaittime; i++) {\n\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\n\t\tif (!outstanding)\n\t\t\tbreak;\n\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"[%2d]waiting for %d \"\n\t\t\t       \"commands to complete\\n\",i,outstanding);\n\t\t\t/*\n\t\t\t * Call cmd completion routine. Cmd to be\n\t\t\t * be completed directly without depending on isr.\n\t\t\t */\n\t\t\tmegasas_complete_cmd_dpc((unsigned long)instance);\n\t\t}\n\n\t\tmsleep(1000);\n\t}\n\n\ti = 0;\n\toutstanding = atomic_read(&instance->fw_outstanding);\n\tfw_state = instance->instancet->read_fw_status_reg(instance) & MFI_STATE_MASK;\n\n\tif ((!outstanding && (fw_state == MFI_STATE_OPERATIONAL)))\n\t\tgoto no_outstanding;\n\n\tif (instance->disableOnlineCtrlReset)\n\t\tgoto kill_hba_and_failed;\n\tdo {\n\t\tif ((fw_state == MFI_STATE_FAULT) || atomic_read(&instance->fw_outstanding)) {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\"%s:%d waiting_for_outstanding: before issue OCR. FW state = 0x%x, oustanding 0x%x\\n\",\n\t\t\t\t__func__, __LINE__, fw_state, atomic_read(&instance->fw_outstanding));\n\t\t\tif (i == 3)\n\t\t\t\tgoto kill_hba_and_failed;\n\t\t\tmegasas_do_ocr(instance);\n\n\t\t\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\t\t\tdev_info(&instance->pdev->dev, \"%s:%d OCR failed and HBA is killed.\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\t\treturn FAILED;\n\t\t\t}\n\t\t\tdev_info(&instance->pdev->dev, \"%s:%d waiting_for_outstanding: after issue OCR.\\n\",\n\t\t\t\t__func__, __LINE__);\n\n\t\t\tfor (sl = 0; sl < 10; sl++)\n\t\t\t\tmsleep(500);\n\n\t\t\toutstanding = atomic_read(&instance->fw_outstanding);\n\n\t\t\tfw_state = instance->instancet->read_fw_status_reg(instance) & MFI_STATE_MASK;\n\t\t\tif ((!outstanding && (fw_state == MFI_STATE_OPERATIONAL)))\n\t\t\t\tgoto no_outstanding;\n\t\t}\n\t\ti++;\n\t} while (i <= 3);\n\nno_outstanding:\n\n\tdev_info(&instance->pdev->dev, \"%s:%d no more pending commands remain after reset handling.\\n\",\n\t\t__func__, __LINE__);\n\treturn SUCCESS;\n\nkill_hba_and_failed:\n\n\t/* Reset not supported, kill adapter */\n\tdev_info(&instance->pdev->dev, \"%s:%d killing adapter scsi%d\"\n\t\t\" disableOnlineCtrlReset %d fw_outstanding %d \\n\",\n\t\t__func__, __LINE__, instance->host->host_no, instance->disableOnlineCtrlReset,\n\t\tatomic_read(&instance->fw_outstanding));\n\tmegasas_dump_pending_frames(instance);\n\tmegaraid_sas_kill_hba(instance);\n\n\treturn FAILED;\n}\n\n/**\n * megasas_generic_reset -\tGeneric reset routine\n * @scmd:\t\t\tMid-layer SCSI command\n *\n * This routine implements a generic reset handler for device, bus and host\n * reset requests. Device, bus and host specific reset handlers can use this\n * function after they do their specific tasks.\n */\nstatic int megasas_generic_reset(struct scsi_cmnd *scmd)\n{\n\tint ret_val;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tscmd_printk(KERN_NOTICE, scmd, \"megasas: RESET cmd=%x retries=%x\\n\",\n\t\t scmd->cmnd[0], scmd->retries);\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"cannot recover from previous reset failures\\n\");\n\t\treturn FAILED;\n\t}\n\n\tret_val = megasas_wait_for_outstanding(instance);\n\tif (ret_val == SUCCESS)\n\t\tdev_notice(&instance->pdev->dev, \"reset successful\\n\");\n\telse\n\t\tdev_err(&instance->pdev->dev, \"failed to do reset\\n\");\n\n\treturn ret_val;\n}\n\n/**\n * megasas_reset_timer - quiesce the adapter if required\n * @scmd:\t\tscsi cmnd\n *\n * Sets the FW busy flag and reduces the host->can_queue if the\n * cmd has not been completed within the timeout period.\n */\nstatic enum\nblk_eh_timer_return megasas_reset_timer(struct scsi_cmnd *scmd)\n{\n\tstruct megasas_instance *instance;\n\tunsigned long flags;\n\n\tif (time_after(jiffies, scmd->jiffies_at_alloc +\n\t\t\t\t(scmd_timeout * 2) * HZ)) {\n\t\treturn BLK_EH_DONE;\n\t}\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\tif (!(instance->flag & MEGASAS_FW_BUSY)) {\n\t\t/* FW is busy, throttle IO */\n\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\n\t\tinstance->host->can_queue = instance->throttlequeuedepth;\n\t\tinstance->last_time = jiffies;\n\t\tinstance->flag |= MEGASAS_FW_BUSY;\n\n\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t}\n\treturn BLK_EH_RESET_TIMER;\n}\n\n/**\n * megasas_dump_frame -\tThis function will dump MPT/MFI frame\n */\nstatic inline void\nmegasas_dump_frame(void *mpi_request, int sz)\n{\n\tint i;\n\t__le32 *mfp = (__le32 *)mpi_request;\n\n\tprintk(KERN_INFO \"IO request frame:\\n\\t\");\n\tfor (i = 0; i < sz / sizeof(__le32); i++) {\n\t\tif (i && ((i % 8) == 0))\n\t\t\tprintk(\"\\n\\t\");\n\t\tprintk(\"%08x \", le32_to_cpu(mfp[i]));\n\t}\n\tprintk(\"\\n\");\n}\n\n/**\n * megasas_reset_bus_host -\tBus & host reset handler entry point\n */\nstatic int megasas_reset_bus_host(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tscmd_printk(KERN_INFO, scmd,\n\t\t\"Controller reset is requested due to IO timeout\\n\"\n\t\t\"SCSI command pointer: (%p)\\t SCSI host state: %d\\t\"\n\t\t\" SCSI host busy: %d\\t FW outstanding: %d\\n\",\n\t\tscmd, scmd->device->host->shost_state,\n\t\tscsi_host_busy(scmd->device->host),\n\t\tatomic_read(&instance->fw_outstanding));\n\n\t/*\n\t * First wait for all commands to complete\n\t */\n\tif (instance->adapter_type == MFI_SERIES) {\n\t\tret = megasas_generic_reset(scmd);\n\t} else {\n\t\tstruct megasas_cmd_fusion *cmd;\n\t\tcmd = (struct megasas_cmd_fusion *)scmd->SCp.ptr;\n\t\tif (cmd)\n\t\t\tmegasas_dump_frame(cmd->io_request,\n\t\t\t\tMEGA_MPI2_RAID_DEFAULT_IO_FRAME_SIZE);\n\t\tret = megasas_reset_fusion(scmd->device->host,\n\t\t\t\tSCSIIO_TIMEOUT_OCR);\n\t}\n\n\treturn ret;\n}\n\n/**\n * megasas_task_abort - Issues task abort request to firmware\n *\t\t\t(supported only for fusion adapters)\n * @scmd:\t\tSCSI command pointer\n */\nstatic int megasas_task_abort(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tret = megasas_task_abort_fusion(scmd);\n\telse {\n\t\tsdev_printk(KERN_NOTICE, scmd->device, \"TASK ABORT not supported\\n\");\n\t\tret = FAILED;\n\t}\n\n\treturn ret;\n}\n\n/**\n * megasas_reset_target:  Issues target reset request to firmware\n *                        (supported only for fusion adapters)\n * @scmd:                 SCSI command pointer\n */\nstatic int megasas_reset_target(struct scsi_cmnd *scmd)\n{\n\tint ret;\n\tstruct megasas_instance *instance;\n\n\tinstance = (struct megasas_instance *)scmd->device->host->hostdata;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tret = megasas_reset_target_fusion(scmd);\n\telse {\n\t\tsdev_printk(KERN_NOTICE, scmd->device, \"TARGET RESET not supported\\n\");\n\t\tret = FAILED;\n\t}\n\n\treturn ret;\n}\n\n/**\n * megasas_bios_param - Returns disk geometry for a disk\n * @sdev:\t\tdevice handle\n * @bdev:\t\tblock device\n * @capacity:\t\tdrive capacity\n * @geom:\t\tgeometry parameters\n */\nstatic int\nmegasas_bios_param(struct scsi_device *sdev, struct block_device *bdev,\n\t\t sector_t capacity, int geom[])\n{\n\tint heads;\n\tint sectors;\n\tsector_t cylinders;\n\tunsigned long tmp;\n\n\t/* Default heads (64) & sectors (32) */\n\theads = 64;\n\tsectors = 32;\n\n\ttmp = heads * sectors;\n\tcylinders = capacity;\n\n\tsector_div(cylinders, tmp);\n\n\t/*\n\t * Handle extended translation size for logical drives > 1Gb\n\t */\n\n\tif (capacity >= 0x200000) {\n\t\theads = 255;\n\t\tsectors = 63;\n\t\ttmp = heads*sectors;\n\t\tcylinders = capacity;\n\t\tsector_div(cylinders, tmp);\n\t}\n\n\tgeom[0] = heads;\n\tgeom[1] = sectors;\n\tgeom[2] = cylinders;\n\n\treturn 0;\n}\n\nstatic void megasas_aen_polling(struct work_struct *work);\n\n/**\n * megasas_service_aen -\tProcesses an event notification\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tAEN command completed by the ISR\n *\n * For AEN, driver sends a command down to FW that is held by the FW till an\n * event occurs. When an event of interest occurs, FW completes the command\n * that it was previously holding.\n *\n * This routines sends SIGIO signal to processes that have registered with the\n * driver for AEN.\n */\nstatic void\nmegasas_service_aen(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n\tunsigned long flags;\n\n\t/*\n\t * Don't signal app if it is just an aborted previously registered aen\n\t */\n\tif ((!cmd->abort_aen) && (instance->unload == 0)) {\n\t\tspin_lock_irqsave(&poll_aen_lock, flags);\n\t\tmegasas_poll_wait_aen = 1;\n\t\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\t\twake_up(&megasas_poll_wait);\n\t\tkill_fasync(&megasas_async_queue, SIGIO, POLL_IN);\n\t}\n\telse\n\t\tcmd->abort_aen = 0;\n\n\tinstance->aen_cmd = NULL;\n\n\tmegasas_return_cmd(instance, cmd);\n\n\tif ((instance->unload == 0) &&\n\t\t((instance->issuepend_done == 1))) {\n\t\tstruct megasas_aen_event *ev;\n\n\t\tev = kzalloc(sizeof(*ev), GFP_ATOMIC);\n\t\tif (!ev) {\n\t\t\tdev_err(&instance->pdev->dev, \"megasas_service_aen: out of memory\\n\");\n\t\t} else {\n\t\t\tev->instance = instance;\n\t\t\tinstance->ev = ev;\n\t\t\tINIT_DELAYED_WORK(&ev->hotplug_work,\n\t\t\t\t\t  megasas_aen_polling);\n\t\t\tschedule_delayed_work(&ev->hotplug_work, 0);\n\t\t}\n\t}\n}\n\nstatic ssize_t\nmegasas_fw_crash_buffer_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tint val = 0;\n\tunsigned long flags;\n\n\tif (kstrtoint(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&instance->crashdump_lock, flags);\n\tinstance->fw_crash_buffer_offset = val;\n\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nmegasas_fw_crash_buffer_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tu32 size;\n\tunsigned long buff_addr;\n\tunsigned long dmachunk = CRASH_DMA_BUF_SIZE;\n\tunsigned long src_addr;\n\tunsigned long flags;\n\tu32 buff_offset;\n\n\tspin_lock_irqsave(&instance->crashdump_lock, flags);\n\tbuff_offset = instance->fw_crash_buffer_offset;\n\tif (!instance->crash_dump_buf &&\n\t\t!((instance->fw_crash_state == AVAILABLE) ||\n\t\t(instance->fw_crash_state == COPYING))) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Firmware crash dump is not available\\n\");\n\t\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\t\treturn -EINVAL;\n\t}\n\n\tbuff_addr = (unsigned long) buf;\n\n\tif (buff_offset > (instance->fw_crash_buffer_size * dmachunk)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Firmware crash dump offset is out of range\\n\");\n\t\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\t\treturn 0;\n\t}\n\n\tsize = (instance->fw_crash_buffer_size * dmachunk) - buff_offset;\n\tsize = (size >= PAGE_SIZE) ? (PAGE_SIZE - 1) : size;\n\n\tsrc_addr = (unsigned long)instance->crash_buf[buff_offset / dmachunk] +\n\t\t(buff_offset % dmachunk);\n\tmemcpy(buf, (void *)src_addr, size);\n\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\n\treturn size;\n}\n\nstatic ssize_t\nmegasas_fw_crash_buffer_size_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%ld\\n\", (unsigned long)\n\t\t((instance->fw_crash_buffer_size) * 1024 * 1024)/PAGE_SIZE);\n}\n\nstatic ssize_t\nmegasas_fw_crash_state_store(struct device *cdev,\n\tstruct device_attribute *attr, const char *buf, size_t count)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\tint val = 0;\n\tunsigned long flags;\n\n\tif (kstrtoint(buf, 0, &val) != 0)\n\t\treturn -EINVAL;\n\n\tif ((val <= AVAILABLE || val > COPY_ERROR)) {\n\t\tdev_err(&instance->pdev->dev, \"application updates invalid \"\n\t\t\t\"firmware crash state\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tinstance->fw_crash_state = val;\n\n\tif ((val == COPIED) || (val == COPY_ERROR)) {\n\t\tspin_lock_irqsave(&instance->crashdump_lock, flags);\n\t\tmegasas_free_host_crash_buffer(instance);\n\t\tspin_unlock_irqrestore(&instance->crashdump_lock, flags);\n\t\tif (val == COPY_ERROR)\n\t\t\tdev_info(&instance->pdev->dev, \"application failed to \"\n\t\t\t\t\"copy Firmware crash dump\\n\");\n\t\telse\n\t\t\tdev_info(&instance->pdev->dev, \"Firmware crash dump \"\n\t\t\t\t\"copied successfully\\n\");\n\t}\n\treturn strlen(buf);\n}\n\nstatic ssize_t\nmegasas_fw_crash_state_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance =\n\t\t(struct megasas_instance *) shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", instance->fw_crash_state);\n}\n\nstatic ssize_t\nmegasas_page_size_show(struct device *cdev,\n\tstruct device_attribute *attr, char *buf)\n{\n\treturn snprintf(buf, PAGE_SIZE, \"%ld\\n\", (unsigned long)PAGE_SIZE - 1);\n}\n\nstatic ssize_t\nmegasas_ldio_outstanding_show(struct device *cdev, struct device_attribute *attr,\n\tchar *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&instance->ldio_outstanding));\n}\n\nstatic ssize_t\nmegasas_fw_cmds_outstanding_show(struct device *cdev,\n\t\t\t\t struct device_attribute *attr, char *buf)\n{\n\tstruct Scsi_Host *shost = class_to_shost(cdev);\n\tstruct megasas_instance *instance = (struct megasas_instance *)shost->hostdata;\n\n\treturn snprintf(buf, PAGE_SIZE, \"%d\\n\", atomic_read(&instance->fw_outstanding));\n}\n\nstatic DEVICE_ATTR(fw_crash_buffer, S_IRUGO | S_IWUSR,\n\tmegasas_fw_crash_buffer_show, megasas_fw_crash_buffer_store);\nstatic DEVICE_ATTR(fw_crash_buffer_size, S_IRUGO,\n\tmegasas_fw_crash_buffer_size_show, NULL);\nstatic DEVICE_ATTR(fw_crash_state, S_IRUGO | S_IWUSR,\n\tmegasas_fw_crash_state_show, megasas_fw_crash_state_store);\nstatic DEVICE_ATTR(page_size, S_IRUGO,\n\tmegasas_page_size_show, NULL);\nstatic DEVICE_ATTR(ldio_outstanding, S_IRUGO,\n\tmegasas_ldio_outstanding_show, NULL);\nstatic DEVICE_ATTR(fw_cmds_outstanding, S_IRUGO,\n\tmegasas_fw_cmds_outstanding_show, NULL);\n\nstruct device_attribute *megaraid_host_attrs[] = {\n\t&dev_attr_fw_crash_buffer_size,\n\t&dev_attr_fw_crash_buffer,\n\t&dev_attr_fw_crash_state,\n\t&dev_attr_page_size,\n\t&dev_attr_ldio_outstanding,\n\t&dev_attr_fw_cmds_outstanding,\n\tNULL,\n};\n\n/*\n * Scsi host template for megaraid_sas driver\n */\nstatic struct scsi_host_template megasas_template = {\n\n\t.module = THIS_MODULE,\n\t.name = \"Avago SAS based MegaRAID driver\",\n\t.proc_name = \"megaraid_sas\",\n\t.slave_configure = megasas_slave_configure,\n\t.slave_alloc = megasas_slave_alloc,\n\t.slave_destroy = megasas_slave_destroy,\n\t.queuecommand = megasas_queue_command,\n\t.eh_target_reset_handler = megasas_reset_target,\n\t.eh_abort_handler = megasas_task_abort,\n\t.eh_host_reset_handler = megasas_reset_bus_host,\n\t.eh_timed_out = megasas_reset_timer,\n\t.shost_attrs = megaraid_host_attrs,\n\t.bios_param = megasas_bios_param,\n\t.change_queue_depth = scsi_change_queue_depth,\n\t.no_write_same = 1,\n};\n\n/**\n * megasas_complete_int_cmd -\tCompletes an internal command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand to be completed\n *\n * The megasas_issue_blocked_cmd() function waits for a command to complete\n * after it issues a command. This function wakes up that waiting routine by\n * calling wake_up() on the wait queue.\n */\nstatic void\nmegasas_complete_int_cmd(struct megasas_instance *instance,\n\t\t\t struct megasas_cmd *cmd)\n{\n\tcmd->cmd_status_drv = cmd->frame->io.cmd_status;\n\twake_up(&instance->int_cmd_wait_q);\n}\n\n/**\n * megasas_complete_abort -\tCompletes aborting a command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCmd that was issued to abort another cmd\n *\n * The megasas_issue_blocked_abort_cmd() function waits on abort_cmd_wait_q\n * after it issues an abort on a previously issued command. This function\n * wakes up all functions waiting on the same wait queue.\n */\nstatic void\nmegasas_complete_abort(struct megasas_instance *instance,\n\t\t       struct megasas_cmd *cmd)\n{\n\tif (cmd->sync_cmd) {\n\t\tcmd->sync_cmd = 0;\n\t\tcmd->cmd_status_drv = 0;\n\t\twake_up(&instance->abort_cmd_wait_q);\n\t}\n}\n\n/**\n * megasas_complete_cmd -\tCompletes a command\n * @instance:\t\t\tAdapter soft state\n * @cmd:\t\t\tCommand to be completed\n * @alt_status:\t\t\tIf non-zero, use this value as status to\n *\t\t\t\tSCSI mid-layer instead of the value returned\n *\t\t\t\tby the FW. This should be used if caller wants\n *\t\t\t\tan alternate status (as in the case of aborted\n *\t\t\t\tcommands)\n */\nvoid\nmegasas_complete_cmd(struct megasas_instance *instance, struct megasas_cmd *cmd,\n\t\t     u8 alt_status)\n{\n\tint exception = 0;\n\tstruct megasas_header *hdr = &cmd->frame->hdr;\n\tunsigned long flags;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tu32 opcode, status;\n\n\t/* flag for the retry reset */\n\tcmd->retry_for_fw_reset = 0;\n\n\tif (cmd->scmd)\n\t\tcmd->scmd->SCp.ptr = NULL;\n\n\tswitch (hdr->cmd) {\n\tcase MFI_CMD_INVALID:\n\t\t/* Some older 1068 controller FW may keep a pended\n\t\t   MR_DCMD_CTRL_EVENT_GET_INFO left over from the main kernel\n\t\t   when booting the kdump kernel.  Ignore this command to\n\t\t   prevent a kernel panic on shutdown of the kdump kernel. */\n\t\tdev_warn(&instance->pdev->dev, \"MFI_CMD_INVALID command \"\n\t\t       \"completed\\n\");\n\t\tdev_warn(&instance->pdev->dev, \"If you have a controller \"\n\t\t       \"other than PERC5, please upgrade your firmware\\n\");\n\t\tbreak;\n\tcase MFI_CMD_PD_SCSI_IO:\n\tcase MFI_CMD_LD_SCSI_IO:\n\n\t\t/*\n\t\t * MFI_CMD_PD_SCSI_IO and MFI_CMD_LD_SCSI_IO could have been\n\t\t * issued either through an IO path or an IOCTL path. If it\n\t\t * was via IOCTL, we will send it to internal completion.\n\t\t */\n\t\tif (cmd->sync_cmd) {\n\t\t\tcmd->sync_cmd = 0;\n\t\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\t\tbreak;\n\t\t}\n\t\t/* fall through */\n\n\tcase MFI_CMD_LD_READ:\n\tcase MFI_CMD_LD_WRITE:\n\n\t\tif (alt_status) {\n\t\t\tcmd->scmd->result = alt_status << 16;\n\t\t\texception = 1;\n\t\t}\n\n\t\tif (exception) {\n\n\t\t\tatomic_dec(&instance->fw_outstanding);\n\n\t\t\tscsi_dma_unmap(cmd->scmd);\n\t\t\tcmd->scmd->scsi_done(cmd->scmd);\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (hdr->cmd_status) {\n\n\t\tcase MFI_STAT_OK:\n\t\t\tcmd->scmd->result = DID_OK << 16;\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_SCSI_IO_FAILED:\n\t\tcase MFI_STAT_LD_INIT_IN_PROGRESS:\n\t\t\tcmd->scmd->result =\n\t\t\t    (DID_ERROR << 16) | hdr->scsi_status;\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_SCSI_DONE_WITH_ERROR:\n\n\t\t\tcmd->scmd->result = (DID_OK << 16) | hdr->scsi_status;\n\n\t\t\tif (hdr->scsi_status == SAM_STAT_CHECK_CONDITION) {\n\t\t\t\tmemset(cmd->scmd->sense_buffer, 0,\n\t\t\t\t       SCSI_SENSE_BUFFERSIZE);\n\t\t\t\tmemcpy(cmd->scmd->sense_buffer, cmd->sense,\n\t\t\t\t       hdr->sense_len);\n\n\t\t\t\tcmd->scmd->result |= DRIVER_SENSE << 24;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase MFI_STAT_LD_OFFLINE:\n\t\tcase MFI_STAT_DEVICE_NOT_FOUND:\n\t\t\tcmd->scmd->result = DID_BAD_TARGET << 16;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"MFI FW status %#x\\n\",\n\t\t\t       hdr->cmd_status);\n\t\t\tcmd->scmd->result = DID_ERROR << 16;\n\t\t\tbreak;\n\t\t}\n\n\t\tatomic_dec(&instance->fw_outstanding);\n\n\t\tscsi_dma_unmap(cmd->scmd);\n\t\tcmd->scmd->scsi_done(cmd->scmd);\n\t\tmegasas_return_cmd(instance, cmd);\n\n\t\tbreak;\n\n\tcase MFI_CMD_SMP:\n\tcase MFI_CMD_STP:\n\tcase MFI_CMD_NVME:\n\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\tbreak;\n\n\tcase MFI_CMD_DCMD:\n\t\topcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n\t\t/* Check for LD map update */\n\t\tif ((opcode == MR_DCMD_LD_MAP_GET_INFO)\n\t\t\t&& (cmd->frame->dcmd.mbox.b[1] == 1)) {\n\t\t\tfusion->fast_path_io = 0;\n\t\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\t\tstatus = cmd->frame->hdr.cmd_status;\n\t\t\tinstance->map_update_cmd = NULL;\n\t\t\tif (status != MFI_STAT_OK) {\n\t\t\t\tif (status != MFI_STAT_NOT_FOUND)\n\t\t\t\t\tdev_warn(&instance->pdev->dev, \"map syncfailed, status = 0x%x\\n\",\n\t\t\t\t\t       cmd->frame->hdr.cmd_status);\n\t\t\t\telse {\n\t\t\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\tinstance->host->host_lock,\n\t\t\t\t\t\tflags);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\t/*\n\t\t\t * Set fast path IO to ZERO.\n\t\t\t * Validate Map will set proper value.\n\t\t\t * Meanwhile all IOs will go as LD IO.\n\t\t\t */\n\t\t\tif (status == MFI_STAT_OK &&\n\t\t\t    (MR_ValidateMapInfo(instance, (instance->map_id + 1)))) {\n\t\t\t\tinstance->map_id++;\n\t\t\t\tfusion->fast_path_io = 1;\n\t\t\t} else {\n\t\t\t\tfusion->fast_path_io = 0;\n\t\t\t}\n\n\t\t\tmegasas_sync_map_info(instance);\n\t\t\tspin_unlock_irqrestore(instance->host->host_lock,\n\t\t\t\t\t       flags);\n\t\t\tbreak;\n\t\t}\n\t\tif (opcode == MR_DCMD_CTRL_EVENT_GET_INFO ||\n\t\t    opcode == MR_DCMD_CTRL_EVENT_GET) {\n\t\t\tspin_lock_irqsave(&poll_aen_lock, flags);\n\t\t\tmegasas_poll_wait_aen = 0;\n\t\t\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\t\t}\n\n\t\t/* FW has an updated PD sequence */\n\t\tif ((opcode == MR_DCMD_SYSTEM_PD_MAP_GET_INFO) &&\n\t\t\t(cmd->frame->dcmd.mbox.b[0] == 1)) {\n\n\t\t\tspin_lock_irqsave(instance->host->host_lock, flags);\n\t\t\tstatus = cmd->frame->hdr.cmd_status;\n\t\t\tinstance->jbod_seq_cmd = NULL;\n\t\t\tmegasas_return_cmd(instance, cmd);\n\n\t\t\tif (status == MFI_STAT_OK) {\n\t\t\t\tinstance->pd_seq_map_id++;\n\t\t\t\t/* Re-register a pd sync seq num cmd */\n\t\t\t\tif (megasas_sync_pd_seq_num(instance, true))\n\t\t\t\t\tinstance->use_seqnum_jbod_fp = false;\n\t\t\t} else\n\t\t\t\tinstance->use_seqnum_jbod_fp = false;\n\n\t\t\tspin_unlock_irqrestore(instance->host->host_lock, flags);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * See if got an event notification\n\t\t */\n\t\tif (opcode == MR_DCMD_CTRL_EVENT_WAIT)\n\t\t\tmegasas_service_aen(instance, cmd);\n\t\telse\n\t\t\tmegasas_complete_int_cmd(instance, cmd);\n\n\t\tbreak;\n\n\tcase MFI_CMD_ABORT:\n\t\t/*\n\t\t * Cmd issued to abort another cmd returned\n\t\t */\n\t\tmegasas_complete_abort(instance, cmd);\n\t\tbreak;\n\n\tdefault:\n\t\tdev_info(&instance->pdev->dev, \"Unknown command completed! [0x%X]\\n\",\n\t\t       hdr->cmd);\n\t\tmegasas_complete_int_cmd(instance, cmd);\n\t\tbreak;\n\t}\n}\n\n/**\n * megasas_issue_pending_cmds_again -\tissue all pending cmds\n *\t\t\t\t\tin FW again because of the fw reset\n * @instance:\t\t\t\tAdapter soft state\n */\nstatic inline void\nmegasas_issue_pending_cmds_again(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct list_head clist_local;\n\tunion megasas_evt_class_locale class_locale;\n\tunsigned long flags;\n\tu32 seq_num;\n\n\tINIT_LIST_HEAD(&clist_local);\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\tlist_splice_init(&instance->internal_reset_pending_q, &clist_local);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\twhile (!list_empty(&clist_local)) {\n\t\tcmd = list_entry((&clist_local)->next,\n\t\t\t\t\tstruct megasas_cmd, list);\n\t\tlist_del_init(&cmd->list);\n\n\t\tif (cmd->sync_cmd || cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"command %p, %p:%d\"\n\t\t\t\t\"detected to be pending while HBA reset\\n\",\n\t\t\t\t\tcmd, cmd->scmd, cmd->sync_cmd);\n\n\t\t\tcmd->retry_for_fw_reset++;\n\n\t\t\tif (cmd->retry_for_fw_reset == 3) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"cmd %p, %p:%d\"\n\t\t\t\t\t\"was tried multiple times during reset.\"\n\t\t\t\t\t\"Shutting down the HBA\\n\",\n\t\t\t\t\tcmd, cmd->scmd, cmd->sync_cmd);\n\t\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (cmd->sync_cmd == 1) {\n\t\t\tif (cmd->scmd) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"unexpected\"\n\t\t\t\t\t\"cmd attached to internal command!\\n\");\n\t\t\t}\n\t\t\tdev_notice(&instance->pdev->dev, \"%p synchronous cmd\"\n\t\t\t\t\t\t\"on the internal reset queue,\"\n\t\t\t\t\t\t\"issue it again.\\n\", cmd);\n\t\t\tcmd->cmd_status_drv = MFI_STAT_INVALID_STATUS;\n\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\t\t\tcmd->frame_phys_addr,\n\t\t\t\t\t\t\t0, instance->reg_set);\n\t\t} else if (cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"%p scsi cmd [%02x]\"\n\t\t\t\"detected on the internal queue, issue again.\\n\",\n\t\t\tcmd, cmd->scmd->cmnd[0]);\n\n\t\t\tatomic_inc(&instance->fw_outstanding);\n\t\t\tinstance->instancet->fire_cmd(instance,\n\t\t\t\t\tcmd->frame_phys_addr,\n\t\t\t\t\tcmd->frame_count-1, instance->reg_set);\n\t\t} else {\n\t\t\tdev_notice(&instance->pdev->dev, \"%p unexpected cmd on the\"\n\t\t\t\t\"internal reset defer list while re-issue!!\\n\",\n\t\t\t\tcmd);\n\t\t}\n\t}\n\n\tif (instance->aen_cmd) {\n\t\tdev_notice(&instance->pdev->dev, \"aen_cmd in def process\\n\");\n\t\tmegasas_return_cmd(instance, instance->aen_cmd);\n\n\t\tinstance->aen_cmd = NULL;\n\t}\n\n\t/*\n\t * Initiate AEN (Asynchronous Event Notification)\n\t */\n\tseq_num = instance->last_seq_num;\n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\tmegasas_register_aen(instance, seq_num, class_locale.word);\n}\n\n/**\n * Move the internal reset pending commands to a deferred queue.\n *\n * We move the commands pending at internal reset time to a\n * pending queue. This queue would be flushed after successful\n * completion of the internal reset sequence. if the internal reset\n * did not complete in time, the kernel reset handler would flush\n * these commands.\n **/\nstatic void\nmegasas_internal_reset_defer_cmds(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tint i;\n\tu16 max_cmd = instance->max_fw_cmds;\n\tu32 defer_index;\n\tunsigned long flags;\n\n\tdefer_index = 0;\n\tspin_lock_irqsave(&instance->mfi_pool_lock, flags);\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tif (cmd->sync_cmd == 1 || cmd->scmd) {\n\t\t\tdev_notice(&instance->pdev->dev, \"moving cmd[%d]:%p:%d:%p\"\n\t\t\t\t\t\"on the defer queue as internal\\n\",\n\t\t\t\tdefer_index, cmd, cmd->sync_cmd, cmd->scmd);\n\n\t\t\tif (!list_empty(&cmd->list)) {\n\t\t\t\tdev_notice(&instance->pdev->dev, \"ERROR while\"\n\t\t\t\t\t\" moving this cmd:%p, %d %p, it was\"\n\t\t\t\t\t\"discovered on some list?\\n\",\n\t\t\t\t\tcmd, cmd->sync_cmd, cmd->scmd);\n\n\t\t\t\tlist_del_init(&cmd->list);\n\t\t\t}\n\t\t\tdefer_index++;\n\t\t\tlist_add_tail(&cmd->list,\n\t\t\t\t&instance->internal_reset_pending_q);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&instance->mfi_pool_lock, flags);\n}\n\n\nstatic void\nprocess_fw_state_change_wq(struct work_struct *work)\n{\n\tstruct megasas_instance *instance =\n\t\tcontainer_of(work, struct megasas_instance, work_init);\n\tu32 wait;\n\tunsigned long flags;\n\n    if (atomic_read(&instance->adprecovery) != MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tdev_notice(&instance->pdev->dev, \"error, recovery st %x\\n\",\n\t\t\t\tatomic_read(&instance->adprecovery));\n\t\treturn ;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_ADPRESET_SM_INFAULT) {\n\t\tdev_notice(&instance->pdev->dev, \"FW detected to be in fault\"\n\t\t\t\t\t\"state, restarting it...\\n\");\n\n\t\tinstance->instancet->disable_intr(instance);\n\t\tatomic_set(&instance->fw_outstanding, 0);\n\n\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\tinstance->instancet->adp_reset(instance, instance->reg_set);\n\t\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t\tdev_notice(&instance->pdev->dev, \"FW restarted successfully,\"\n\t\t\t\t\t\"initiating next stage...\\n\");\n\n\t\tdev_notice(&instance->pdev->dev, \"HBA recovery state machine,\"\n\t\t\t\t\t\"state 2 starting...\\n\");\n\n\t\t/* waiting for about 20 second before start the second init */\n\t\tfor (wait = 0; wait < 30; wait++) {\n\t\t\tmsleep(1000);\n\t\t}\n\n\t\tif (megasas_transition_to_ready(instance, 1)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"adapter not ready\\n\");\n\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\treturn ;\n\t\t}\n\n\t\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\n\t\t\t(instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\n\t\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)\n\t\t\t) {\n\t\t\t*instance->consumer = *instance->producer;\n\t\t} else {\n\t\t\t*instance->consumer = 0;\n\t\t\t*instance->producer = 0;\n\t\t}\n\n\t\tmegasas_issue_init_mfi(instance);\n\n\t\tspin_lock_irqsave(&instance->hba_lock, flags);\n\t\tatomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n\t\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\t\tinstance->instancet->enable_intr(instance);\n\n\t\tmegasas_issue_pending_cmds_again(instance);\n\t\tinstance->issuepend_done = 1;\n\t}\n}\n\n/**\n * megasas_deplete_reply_queue -\tProcesses all completed commands\n * @instance:\t\t\t\tAdapter soft state\n * @alt_status:\t\t\t\tAlternate status to be returned to\n *\t\t\t\t\tSCSI mid-layer instead of the status\n *\t\t\t\t\treturned by the FW\n * Note: this must be called with hba lock held\n */\nstatic int\nmegasas_deplete_reply_queue(struct megasas_instance *instance,\n\t\t\t\t\tu8 alt_status)\n{\n\tu32 mfiStatus;\n\tu32 fw_state;\n\n\tif ((mfiStatus = instance->instancet->check_reset(instance,\n\t\t\t\t\tinstance->reg_set)) == 1) {\n\t\treturn IRQ_HANDLED;\n\t}\n\n\tmfiStatus = instance->instancet->clear_intr(instance);\n\tif (mfiStatus == 0) {\n\t\t/* Hardware may not set outbound_intr_status in MSI-X mode */\n\t\tif (!instance->msix_vectors)\n\t\t\treturn IRQ_NONE;\n\t}\n\n\tinstance->mfiStatus = mfiStatus;\n\n\tif ((mfiStatus & MFI_INTR_FLAG_FIRMWARE_STATE_CHANGE)) {\n\t\tfw_state = instance->instancet->read_fw_status_reg(\n\t\t\t\tinstance) & MFI_STATE_MASK;\n\n\t\tif (fw_state != MFI_STATE_FAULT) {\n\t\t\tdev_notice(&instance->pdev->dev, \"fw state:%x\\n\",\n\t\t\t\t\t\tfw_state);\n\t\t}\n\n\t\tif ((fw_state == MFI_STATE_FAULT) &&\n\t\t\t\t(instance->disableOnlineCtrlReset == 0)) {\n\t\t\tdev_notice(&instance->pdev->dev, \"wait adp restart\\n\");\n\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_LSI_SAS1064R) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_DELL_PERC5) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t\tPCI_DEVICE_ID_LSI_VERDE_ZCR)) {\n\n\t\t\t\t*instance->consumer =\n\t\t\t\t\tcpu_to_le32(MEGASAS_ADPRESET_INPROG_SIGN);\n\t\t\t}\n\n\n\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\tatomic_set(&instance->adprecovery, MEGASAS_ADPRESET_SM_INFAULT);\n\t\t\tinstance->issuepend_done = 0;\n\n\t\t\tatomic_set(&instance->fw_outstanding, 0);\n\t\t\tmegasas_internal_reset_defer_cmds(instance);\n\n\t\t\tdev_notice(&instance->pdev->dev, \"fwState=%x, stage:%d\\n\",\n\t\t\t\t\tfw_state, atomic_read(&instance->adprecovery));\n\n\t\t\tschedule_work(&instance->work_init);\n\t\t\treturn IRQ_HANDLED;\n\n\t\t} else {\n\t\t\tdev_notice(&instance->pdev->dev, \"fwstate:%x, dis_OCR=%x\\n\",\n\t\t\t\tfw_state, instance->disableOnlineCtrlReset);\n\t\t}\n\t}\n\n\ttasklet_schedule(&instance->isr_tasklet);\n\treturn IRQ_HANDLED;\n}\n/**\n * megasas_isr - isr entry point\n */\nstatic irqreturn_t megasas_isr(int irq, void *devp)\n{\n\tstruct megasas_irq_context *irq_context = devp;\n\tstruct megasas_instance *instance = irq_context->instance;\n\tunsigned long flags;\n\tirqreturn_t rc;\n\n\tif (atomic_read(&instance->fw_reset_no_pci_access))\n\t\treturn IRQ_HANDLED;\n\n\tspin_lock_irqsave(&instance->hba_lock, flags);\n\trc = megasas_deplete_reply_queue(instance, DID_OK);\n\tspin_unlock_irqrestore(&instance->hba_lock, flags);\n\n\treturn rc;\n}\n\n/**\n * megasas_transition_to_ready -\tMove the FW to READY state\n * @instance:\t\t\t\tAdapter soft state\n *\n * During the initialization, FW passes can potentially be in any one of\n * several possible states. If the FW in operational, waiting-for-handshake\n * states, driver must take steps to bring it to ready state. Otherwise, it\n * has to wait for the ready state.\n */\nint\nmegasas_transition_to_ready(struct megasas_instance *instance, int ocr)\n{\n\tint i;\n\tu8 max_wait;\n\tu32 fw_state;\n\tu32 cur_state;\n\tu32 abs_state, curr_abs_state;\n\n\tabs_state = instance->instancet->read_fw_status_reg(instance);\n\tfw_state = abs_state & MFI_STATE_MASK;\n\n\tif (fw_state != MFI_STATE_READY)\n\t\tdev_info(&instance->pdev->dev, \"Waiting for FW to come to ready\"\n\t\t       \" state\\n\");\n\n\twhile (fw_state != MFI_STATE_READY) {\n\n\t\tswitch (fw_state) {\n\n\t\tcase MFI_STATE_FAULT:\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"FW in FAULT state!!\\n\");\n\t\t\tif (ocr) {\n\t\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\t\tcur_state = MFI_STATE_FAULT;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\treturn -ENODEV;\n\n\t\tcase MFI_STATE_WAIT_HANDSHAKE:\n\t\t\t/*\n\t\t\t * Set the CLR bit in inbound doorbell\n\t\t\t */\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES))\n\t\t\t\twritel(\n\t\t\t\t  MFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\n\t\t\t\t  &instance->reg_set->doorbell);\n\t\t\telse\n\t\t\t\twritel(\n\t\t\t\t    MFI_INIT_CLEAR_HANDSHAKE|MFI_INIT_HOTPLUG,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_WAIT_HANDSHAKE;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_BOOT_MESSAGE_PENDING:\n\t\t\tif ((instance->pdev->device ==\n\t\t\t     PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\t PCI_DEVICE_ID_LSI_SAS0071SKINNY) ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES))\n\t\t\t\twritel(MFI_INIT_HOTPLUG,\n\t\t\t\t       &instance->reg_set->doorbell);\n\t\t\telse\n\t\t\t\twritel(MFI_INIT_HOTPLUG,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_BOOT_MESSAGE_PENDING;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_OPERATIONAL:\n\t\t\t/*\n\t\t\t * Bring it to READY state; assuming max wait 10 secs\n\t\t\t */\n\t\t\tinstance->instancet->disable_intr(instance);\n\t\t\tif ((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0071SKINNY)  ||\n\t\t\t\t(instance->adapter_type != MFI_SERIES)) {\n\t\t\t\twritel(MFI_RESET_FLAGS,\n\t\t\t\t\t&instance->reg_set->doorbell);\n\n\t\t\t\tif (instance->adapter_type != MFI_SERIES) {\n\t\t\t\t\tfor (i = 0; i < (10 * 1000); i += 20) {\n\t\t\t\t\t\tif (megasas_readl(\n\t\t\t\t\t\t\t    instance,\n\t\t\t\t\t\t\t    &instance->\n\t\t\t\t\t\t\t    reg_set->\n\t\t\t\t\t\t\t    doorbell) & 1)\n\t\t\t\t\t\t\tmsleep(20);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\twritel(MFI_RESET_FLAGS,\n\t\t\t\t\t&instance->reg_set->inbound_doorbell);\n\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_OPERATIONAL;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_UNDEFINED:\n\t\t\t/*\n\t\t\t * This state should not last for more than 2 seconds\n\t\t\t */\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_UNDEFINED;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_BB_INIT:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_BB_INIT;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FW_INIT:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_FW_INIT;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FW_INIT_2:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_FW_INIT_2;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_DEVICE_SCAN:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_DEVICE_SCAN;\n\t\t\tbreak;\n\n\t\tcase MFI_STATE_FLUSH_CACHE:\n\t\t\tmax_wait = MEGASAS_RESET_WAIT_TIME;\n\t\t\tcur_state = MFI_STATE_FLUSH_CACHE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Unknown state 0x%x\\n\",\n\t\t\t       fw_state);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\t/*\n\t\t * The cur_state should not last for more than max_wait secs\n\t\t */\n\t\tfor (i = 0; i < max_wait; i++) {\n\t\t\tcurr_abs_state = instance->instancet->\n\t\t\t\tread_fw_status_reg(instance);\n\n\t\t\tif (abs_state == curr_abs_state) {\n\t\t\t\tmsleep(1000);\n\t\t\t} else\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Return error if fw_state hasn't changed after max_wait\n\t\t */\n\t\tif (curr_abs_state == abs_state) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"FW state [%d] hasn't changed \"\n\t\t\t       \"in %d secs\\n\", fw_state, max_wait);\n\t\t\treturn -ENODEV;\n\t\t}\n\n\t\tabs_state = curr_abs_state;\n\t\tfw_state = curr_abs_state & MFI_STATE_MASK;\n\t}\n\tdev_info(&instance->pdev->dev, \"FW now in Ready state\\n\");\n\n\treturn 0;\n}\n\n/**\n * megasas_teardown_frame_pool -\tDestroy the cmd frame DMA pool\n * @instance:\t\t\t\tAdapter soft state\n */\nstatic void megasas_teardown_frame_pool(struct megasas_instance *instance)\n{\n\tint i;\n\tu16 max_cmd = instance->max_mfi_cmds;\n\tstruct megasas_cmd *cmd;\n\n\tif (!instance->frame_dma_pool)\n\t\treturn;\n\n\t/*\n\t * Return all frames to pool\n\t */\n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tif (cmd->frame)\n\t\t\tdma_pool_free(instance->frame_dma_pool, cmd->frame,\n\t\t\t\t      cmd->frame_phys_addr);\n\n\t\tif (cmd->sense)\n\t\t\tdma_pool_free(instance->sense_dma_pool, cmd->sense,\n\t\t\t\t      cmd->sense_phys_addr);\n\t}\n\n\t/*\n\t * Now destroy the pool itself\n\t */\n\tdma_pool_destroy(instance->frame_dma_pool);\n\tdma_pool_destroy(instance->sense_dma_pool);\n\n\tinstance->frame_dma_pool = NULL;\n\tinstance->sense_dma_pool = NULL;\n}\n\n/**\n * megasas_create_frame_pool -\tCreates DMA pool for cmd frames\n * @instance:\t\t\tAdapter soft state\n *\n * Each command packet has an embedded DMA memory buffer that is used for\n * filling MFI frame and the SG list that immediately follows the frame. This\n * function creates those DMA memory buffers for each command packet by using\n * PCI pool facility.\n */\nstatic int megasas_create_frame_pool(struct megasas_instance *instance)\n{\n\tint i;\n\tu16 max_cmd;\n\tu32 sge_sz;\n\tu32 frame_count;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * Size of our frame is 64 bytes for MFI frame, followed by max SG\n\t * elements and finally SCSI_SENSE_BUFFERSIZE bytes for sense buffer\n\t */\n\tsge_sz = (IS_DMA64) ? sizeof(struct megasas_sge64) :\n\t    sizeof(struct megasas_sge32);\n\n\tif (instance->flag_ieee)\n\t\tsge_sz = sizeof(struct megasas_sge_skinny);\n\n\t/*\n\t * For MFI controllers.\n\t * max_num_sge = 60\n\t * max_sge_sz  = 16 byte (sizeof megasas_sge_skinny)\n\t * Total 960 byte (15 MFI frame of 64 byte)\n\t *\n\t * Fusion adapter require only 3 extra frame.\n\t * max_num_sge = 16 (defined as MAX_IOCTL_SGE)\n\t * max_sge_sz  = 12 byte (sizeof  megasas_sge64)\n\t * Total 192 byte (3 MFI frame of 64 byte)\n\t */\n\tframe_count = (instance->adapter_type == MFI_SERIES) ?\n\t\t\t(15 + 1) : (3 + 1);\n\tinstance->mfi_frame_size = MEGAMFI_FRAME_SIZE * frame_count;\n\t/*\n\t * Use DMA pool facility provided by PCI layer\n\t */\n\tinstance->frame_dma_pool = dma_pool_create(\"megasas frame pool\",\n\t\t\t\t\t&instance->pdev->dev,\n\t\t\t\t\tinstance->mfi_frame_size, 256, 0);\n\n\tif (!instance->frame_dma_pool) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"failed to setup frame pool\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->sense_dma_pool = dma_pool_create(\"megasas sense pool\",\n\t\t\t\t\t\t   &instance->pdev->dev, 128,\n\t\t\t\t\t\t   4, 0);\n\n\tif (!instance->sense_dma_pool) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"failed to setup sense pool\\n\");\n\n\t\tdma_pool_destroy(instance->frame_dma_pool);\n\t\tinstance->frame_dma_pool = NULL;\n\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Allocate and attach a frame to each of the commands in cmd_list.\n\t * By making cmd->index as the context instead of the &cmd, we can\n\t * always use 32bit context regardless of the architecture\n\t */\n\tfor (i = 0; i < max_cmd; i++) {\n\n\t\tcmd = instance->cmd_list[i];\n\n\t\tcmd->frame = dma_pool_zalloc(instance->frame_dma_pool,\n\t\t\t\t\t    GFP_KERNEL, &cmd->frame_phys_addr);\n\n\t\tcmd->sense = dma_pool_alloc(instance->sense_dma_pool,\n\t\t\t\t\t    GFP_KERNEL, &cmd->sense_phys_addr);\n\n\t\t/*\n\t\t * megasas_teardown_frame_pool() takes care of freeing\n\t\t * whatever has been allocated\n\t\t */\n\t\tif (!cmd->frame || !cmd->sense) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"dma_pool_alloc failed\\n\");\n\t\t\tmegasas_teardown_frame_pool(instance);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tcmd->frame->io.context = cpu_to_le32(cmd->index);\n\t\tcmd->frame->io.pad_0 = 0;\n\t\tif ((instance->adapter_type == MFI_SERIES) && reset_devices)\n\t\t\tcmd->frame->hdr.cmd = MFI_CMD_INVALID;\n\t}\n\n\treturn 0;\n}\n\n/**\n * megasas_free_cmds -\tFree all the cmds in the free cmd pool\n * @instance:\t\tAdapter soft state\n */\nvoid megasas_free_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\n\t/* First free the MFI frame pool */\n\tmegasas_teardown_frame_pool(instance);\n\n\t/* Free all the commands in the cmd_list */\n\tfor (i = 0; i < instance->max_mfi_cmds; i++)\n\n\t\tkfree(instance->cmd_list[i]);\n\n\t/* Free the cmd_list buffer itself */\n\tkfree(instance->cmd_list);\n\tinstance->cmd_list = NULL;\n\n\tINIT_LIST_HEAD(&instance->cmd_pool);\n}\n\n/**\n * megasas_alloc_cmds -\tAllocates the command packets\n * @instance:\t\tAdapter soft state\n *\n * Each command that is issued to the FW, whether IO commands from the OS or\n * internal commands like IOCTLs, are wrapped in local data structure called\n * megasas_cmd. The frame embedded in this megasas_cmd is actually issued to\n * the FW.\n *\n * Each frame has a 32-bit field called context (tag). This context is used\n * to get back the megasas_cmd from the frame when a frame gets completed in\n * the ISR. Typically the address of the megasas_cmd itself would be used as\n * the context. But we wanted to keep the differences between 32 and 64 bit\n * systems to the mininum. We always use 32 bit integers for the context. In\n * this driver, the 32 bit values are the indices into an array cmd_list.\n * This array is used only to look up the megasas_cmd given the context. The\n * free commands themselves are maintained in a linked list called cmd_pool.\n */\nint megasas_alloc_cmds(struct megasas_instance *instance)\n{\n\tint i;\n\tint j;\n\tu16 max_cmd;\n\tstruct megasas_cmd *cmd;\n\n\tmax_cmd = instance->max_mfi_cmds;\n\n\t/*\n\t * instance->cmd_list is an array of struct megasas_cmd pointers.\n\t * Allocate the dynamic array first and then allocate individual\n\t * commands.\n\t */\n\tinstance->cmd_list = kcalloc(max_cmd, sizeof(struct megasas_cmd*), GFP_KERNEL);\n\n\tif (!instance->cmd_list) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"out of memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(instance->cmd_list, 0, sizeof(struct megasas_cmd *) *max_cmd);\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tinstance->cmd_list[i] = kmalloc(sizeof(struct megasas_cmd),\n\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->cmd_list[i]) {\n\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tkfree(instance->cmd_list[j]);\n\n\t\t\tkfree(instance->cmd_list);\n\t\t\tinstance->cmd_list = NULL;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tfor (i = 0; i < max_cmd; i++) {\n\t\tcmd = instance->cmd_list[i];\n\t\tmemset(cmd, 0, sizeof(struct megasas_cmd));\n\t\tcmd->index = i;\n\t\tcmd->scmd = NULL;\n\t\tcmd->instance = instance;\n\n\t\tlist_add_tail(&cmd->list, &instance->cmd_pool);\n\t}\n\n\t/*\n\t * Create a frame pool and assign one frame to each cmd\n\t */\n\tif (megasas_create_frame_pool(instance)) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error creating frame DMA pool\\n\");\n\t\tmegasas_free_cmds(instance);\n\t\treturn -ENOMEM;\n\t}\n\n\treturn 0;\n}\n\n/*\n * dcmd_timeout_ocr_possible -\tCheck if OCR is possible based on Driver/FW state.\n * @instance:\t\t\t\tAdapter soft state\n *\n * Return 0 for only Fusion adapter, if driver load/unload is not in progress\n * or FW is not under OCR.\n */\ninline int\ndcmd_timeout_ocr_possible(struct megasas_instance *instance) {\n\n\tif (instance->adapter_type == MFI_SERIES)\n\t\treturn KILL_ADAPTER;\n\telse if (instance->unload ||\n\t\t\ttest_bit(MEGASAS_FUSION_IN_RESET, &instance->reset_flags))\n\t\treturn IGNORE_TIMEOUT;\n\telse\n\t\treturn INITIATE_OCR;\n}\n\nstatic void\nmegasas_get_pd_info(struct megasas_instance *instance, struct scsi_device *sdev)\n{\n\tint ret;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tstruct MR_PRIV_DEVICE *mr_device_priv_data;\n\tu16 device_id = 0;\n\n\tdevice_id = (sdev->channel * MEGASAS_MAX_DEV_PER_CHANNEL) + sdev->id;\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to get cmd %s\\n\", __func__);\n\t\treturn;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->pd_info, 0, sizeof(*instance->pd_info));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.s[0] = cpu_to_le16(device_id);\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_PD_INFO));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_PD_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->pd_info_h,\n\t\t\t\t sizeof(struct MR_PD_INFO));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\tmr_device_priv_data = sdev->hostdata;\n\t\tle16_to_cpus((u16 *)&instance->pd_info->state.ddf.pdType);\n\t\tmr_device_priv_data->interface_type =\n\t\t\t\tinstance->pd_info->state.ddf.pdType.intf;\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn;\n}\n/*\n * megasas_get_pd_list_info -\tReturns FW's pd_list structure\n * @instance:\t\t\t\tAdapter soft state\n * @pd_list:\t\t\t\tpd_list structure\n *\n * Issues an internal command (DCMD) to get the FW's controller PD\n * list structure.  This information is mainly used to find out SYSTEM\n * supported by the FW.\n */\nstatic int\nmegasas_get_pd_list(struct megasas_instance *instance)\n{\n\tint ret = 0, pd_index = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_PD_LIST *ci;\n\tstruct MR_PD_ADDRESS *pd_addr;\n\tdma_addr_t ci_h = 0;\n\n\tif (instance->pd_list_not_supported) {\n\t\tdev_info(&instance->pdev->dev, \"MR_DCMD_PD_LIST_QUERY \"\n\t\t\"not supported by firmware\\n\");\n\t\treturn ret;\n\t}\n\n\tci = instance->pd_list_buf;\n\tci_h = instance->pd_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"(get_pd_list): Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = MR_PD_QUERY_TYPE_EXPOSED_TO_HOST;\n\tdcmd->mbox.b[1] = 0;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_PD_LIST_QUERY);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->pd_list_buf_h,\n\t\t\t\t (MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST)));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tdev_info(&instance->pdev->dev, \"MR_DCMD_PD_LIST_QUERY \"\n\t\t\t\"failed/not supported by firmware\\n\");\n\n\t\tif (instance->adapter_type != MFI_SERIES)\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\telse\n\t\t\tinstance->pd_list_not_supported = 1;\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d \\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase DCMD_SUCCESS:\n\t\tpd_addr = ci->addr;\n\n\t\tif ((le32_to_cpu(ci->count) >\n\t\t\t(MEGASAS_MAX_PD_CHANNELS * MEGASAS_MAX_DEV_PER_CHANNEL)))\n\t\t\tbreak;\n\n\t\tmemset(instance->local_pd_list, 0,\n\t\t\t\tMEGASAS_MAX_PD * sizeof(struct megasas_pd_list));\n\n\t\tfor (pd_index = 0; pd_index < le32_to_cpu(ci->count); pd_index++) {\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].tid\t=\n\t\t\t\t\tle16_to_cpu(pd_addr->deviceId);\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveType\t=\n\t\t\t\t\tpd_addr->scsiDevType;\n\t\t\tinstance->local_pd_list[le16_to_cpu(pd_addr->deviceId)].driveState\t=\n\t\t\t\t\tMR_PD_STATE_SYSTEM;\n\t\t\tpd_addr++;\n\t\t}\n\n\t\tmemcpy(instance->pd_list, instance->local_pd_list,\n\t\t\tsizeof(instance->pd_list));\n\t\tbreak;\n\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/*\n * megasas_get_ld_list_info -\tReturns FW's ld_list structure\n * @instance:\t\t\t\tAdapter soft state\n * @ld_list:\t\t\t\tld_list structure\n *\n * Issues an internal command (DCMD) to get the FW's controller PD\n * list structure.  This information is mainly used to find out SYSTEM\n * supported by the FW.\n */\nstatic int\nmegasas_get_ld_list(struct megasas_instance *instance)\n{\n\tint ret = 0, ld_index = 0, ids = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_LIST *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 ld_count;\n\n\tci = instance->ld_list_buf;\n\tci_h = instance->ld_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"megasas_get_ld_list: Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tif (instance->supportmax256vd)\n\t\tdcmd->mbox.b[0] = 1;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_GET_LIST);\n\tdcmd->pad_0  = 0;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_LD_LIST));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\tMFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tld_count = le32_to_cpu(ci->ldCount);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tmegaraid_sas_kill_hba(instance);\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\n\tcase DCMD_SUCCESS:\n\t\tif (ld_count > instance->fw_supported_vd_count)\n\t\t\tbreak;\n\n\t\tmemset(instance->ld_ids, 0xff, MAX_LOGICAL_DRIVES_EXT);\n\n\t\tfor (ld_index = 0; ld_index < ld_count; ld_index++) {\n\t\t\tif (ci->ldList[ld_index].state != 0) {\n\t\t\t\tids = ci->ldList[ld_index].ref.targetId;\n\t\t\t\tinstance->ld_ids[ids] = ci->ldList[ld_index].ref.targetId;\n\t\t\t}\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * megasas_ld_list_query -\tReturns FW's ld_list structure\n * @instance:\t\t\t\tAdapter soft state\n * @ld_list:\t\t\t\tld_list structure\n *\n * Issues an internal command (DCMD) to get the FW's controller PD\n * list structure.  This information is mainly used to find out SYSTEM\n * supported by the FW.\n */\nstatic int\nmegasas_ld_list_query(struct megasas_instance *instance, u8 query_type)\n{\n\tint ret = 0, ld_index = 0, ids = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_LD_TARGETID_LIST *ci;\n\tdma_addr_t ci_h = 0;\n\tu32 tgtid_count;\n\n\tci = instance->ld_targetid_list_buf;\n\tci_h = instance->ld_targetid_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t         \"megasas_ld_list_query: Failed to get cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = query_type;\n\tif (instance->supportmax256vd)\n\t\tdcmd->mbox.b[2] = 1;\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_LD_TARGETID_LIST));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_LD_LIST_QUERY);\n\tdcmd->pad_0  = 0;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_LD_TARGETID_LIST));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_FAILED:\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"DCMD not supported by firmware - %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\tret = megasas_get_ld_list(instance);\n\t\tbreak;\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\t/*\n\t\t\t * DCMD failed from AEN path.\n\t\t\t * AEN path already hold reset_mutex to avoid PCI access\n\t\t\t * while OCR is in progress.\n\t\t\t */\n\t\t\tmutex_unlock(&instance->reset_mutex);\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tmutex_lock(&instance->reset_mutex);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\n\t\tbreak;\n\tcase DCMD_SUCCESS:\n\t\ttgtid_count = le32_to_cpu(ci->count);\n\n\t\tif ((tgtid_count > (instance->fw_supported_vd_count)))\n\t\t\tbreak;\n\n\t\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\t\tfor (ld_index = 0; ld_index < tgtid_count; ld_index++) {\n\t\t\tids = ci->targetId[ld_index];\n\t\t\tinstance->ld_ids[ids] = ci->targetId[ld_index];\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * dcmd.opcode            - MR_DCMD_CTRL_DEVICE_LIST_GET\n * dcmd.mbox              - reserved\n * dcmd.sge IN            - ptr to return MR_HOST_DEVICE_LIST structure\n * Desc:    This DCMD will return the combined device list\n * Status:  MFI_STAT_OK - List returned successfully\n *          MFI_STAT_INVALID_CMD - Firmware support for the feature has been\n *                                 disabled\n * @instance:\t\t\tAdapter soft state\n * @is_probe:\t\t\tDriver probe check\n * Return:\t\t\t0 if DCMD succeeded\n *\t\t\t\t non-zero if failed\n */\nint\nmegasas_host_device_list_query(struct megasas_instance *instance,\n\t\t\t       bool is_probe)\n{\n\tint ret, i, target_id;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_HOST_DEVICE_LIST *ci;\n\tu32 count;\n\tdma_addr_t ci_h;\n\n\tci = instance->host_device_list_buf;\n\tci_h = instance->host_device_list_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_warn(&instance->pdev->dev,\n\t\t\t \"%s: failed to get cmd\\n\",\n\t\t\t __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->mbox.b[0] = is_probe ? 0 : 1;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(HOST_DEVICE_LIST_SZ);\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_DEVICE_LIST_GET);\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h, HOST_DEVICE_LIST_SZ);\n\n\tif (!instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\t/* Fill the internal pd_list and ld_ids array based on\n\t\t * targetIds returned by FW\n\t\t */\n\t\tcount = le32_to_cpu(ci->count);\n\n\t\tmemset(instance->local_pd_list, 0,\n\t\t       MEGASAS_MAX_PD * sizeof(struct megasas_pd_list));\n\t\tmemset(instance->ld_ids, 0xff, MAX_LOGICAL_DRIVES_EXT);\n\t\tfor (i = 0; i < count; i++) {\n\t\t\ttarget_id = le16_to_cpu(ci->host_device_list[i].target_id);\n\t\t\tif (ci->host_device_list[i].flags.u.bits.is_sys_pd) {\n\t\t\t\tinstance->local_pd_list[target_id].tid = target_id;\n\t\t\t\tinstance->local_pd_list[target_id].driveType =\n\t\t\t\t\t\tci->host_device_list[i].scsi_type;\n\t\t\t\tinstance->local_pd_list[target_id].driveState =\n\t\t\t\t\t\tMR_PD_STATE_SYSTEM;\n\t\t\t} else {\n\t\t\t\tinstance->ld_ids[target_id] = target_id;\n\t\t\t}\n\t\t}\n\n\t\tmemcpy(instance->pd_list, instance->local_pd_list,\n\t\t       sizeof(instance->pd_list));\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t __func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DCMD_FAILED:\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"%s: MR_DCMD_CTRL_DEVICE_LIST_GET failed\\n\",\n\t\t\t__func__);\n\t\tbreak;\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/*\n * megasas_update_ext_vd_details : Update details w.r.t Extended VD\n * instance\t\t\t : Controller's instance\n*/\nstatic void megasas_update_ext_vd_details(struct megasas_instance *instance)\n{\n\tstruct fusion_context *fusion;\n\tu32 ventura_map_sz = 0;\n\n\tfusion = instance->ctrl_context;\n\t/* For MFI based controllers return dummy success */\n\tif (!fusion)\n\t\treturn;\n\n\tinstance->supportmax256vd =\n\t\tinstance->ctrl_info_buf->adapterOperations3.supportMaxExtLDs;\n\t/* Below is additional check to address future FW enhancement */\n\tif (instance->ctrl_info_buf->max_lds > 64)\n\t\tinstance->supportmax256vd = 1;\n\n\tinstance->drv_supported_vd_count = MEGASAS_MAX_LD_CHANNELS\n\t\t\t\t\t* MEGASAS_MAX_DEV_PER_CHANNEL;\n\tinstance->drv_supported_pd_count = MEGASAS_MAX_PD_CHANNELS\n\t\t\t\t\t* MEGASAS_MAX_DEV_PER_CHANNEL;\n\tif (instance->supportmax256vd) {\n\t\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES_EXT;\n\t\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t} else {\n\t\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES;\n\t\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"FW provided supportMaxExtLDs: %d\\tmax_lds: %d\\n\",\n\t\tinstance->ctrl_info_buf->adapterOperations3.supportMaxExtLDs ? 1 : 0,\n\t\tinstance->ctrl_info_buf->max_lds);\n\n\tif (instance->max_raid_mapsize) {\n\t\tventura_map_sz = instance->max_raid_mapsize *\n\t\t\t\t\t\tMR_MIN_MAP_SIZE; /* 64k */\n\t\tfusion->current_map_sz = ventura_map_sz;\n\t\tfusion->max_map_sz = ventura_map_sz;\n\t} else {\n\t\tfusion->old_map_sz =  sizeof(struct MR_FW_RAID_MAP) +\n\t\t\t\t\t(sizeof(struct MR_LD_SPAN_MAP) *\n\t\t\t\t\t(instance->fw_supported_vd_count - 1));\n\t\tfusion->new_map_sz =  sizeof(struct MR_FW_RAID_MAP_EXT);\n\n\t\tfusion->max_map_sz =\n\t\t\tmax(fusion->old_map_sz, fusion->new_map_sz);\n\n\t\tif (instance->supportmax256vd)\n\t\t\tfusion->current_map_sz = fusion->new_map_sz;\n\t\telse\n\t\t\tfusion->current_map_sz = fusion->old_map_sz;\n\t}\n\t/* irrespective of FW raid maps, driver raid map is constant */\n\tfusion->drv_map_sz = sizeof(struct MR_DRV_RAID_MAP_ALL);\n}\n\n/*\n * dcmd.opcode                - MR_DCMD_CTRL_SNAPDUMP_GET_PROPERTIES\n * dcmd.hdr.length            - number of bytes to read\n * dcmd.sge                   - Ptr to MR_SNAPDUMP_PROPERTIES\n * Desc:\t\t\t Fill in snapdump properties\n * Status:\t\t\t MFI_STAT_OK- Command successful\n */\nvoid megasas_get_snapdump_properties(struct megasas_instance *instance)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct MR_SNAPDUMP_PROPERTIES *ci;\n\tdma_addr_t ci_h = 0;\n\n\tci = instance->snapdump_prop;\n\tci_h = instance->snapdump_prop_h;\n\n\tif (!ci)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_dbg(&instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct MR_SNAPDUMP_PROPERTIES));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SNAPDUMP_GET_PROPERTIES);\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct MR_SNAPDUMP_PROPERTIES));\n\n\tif (!instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd,\n\t\t\t\t\t\tMFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\tinstance->snapdump_wait_time =\n\t\t\tmin_t(u8, ci->trigger_min_num_sec_before_ocr,\n\t\t\t\tMEGASAS_MAX_SNAP_DUMP_WAIT_TIME);\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n}\n\n/**\n * megasas_get_controller_info -\tReturns FW's controller structure\n * @instance:\t\t\t\tAdapter soft state\n *\n * Issues an internal command (DCMD) to get the FW's controller structure.\n * This information is mainly used to find out the maximum IO transfer per\n * command supported by the FW.\n */\nint\nmegasas_get_ctrl_info(struct megasas_instance *instance)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct megasas_ctrl_info *ci;\n\tdma_addr_t ci_h = 0;\n\n\tci = instance->ctrl_info_buf;\n\tci_h = instance->ctrl_info_buf_h;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(ci, 0, sizeof(*ci));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_ctrl_info));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_GET_INFO);\n\tdcmd->mbox.b[0] = 1;\n\n\tmegasas_set_dma_settings(instance, dcmd, ci_h,\n\t\t\t\t sizeof(struct megasas_ctrl_info));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts) {\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\t} else {\n\t\tret = megasas_issue_polled(instance, cmd);\n\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t}\n\n\tswitch (ret) {\n\tcase DCMD_SUCCESS:\n\t\t/* Save required controller information in\n\t\t * CPU endianness format.\n\t\t */\n\t\tle32_to_cpus((u32 *)&ci->properties.OnOffProperties);\n\t\tle16_to_cpus((u16 *)&ci->properties.on_off_properties2);\n\t\tle32_to_cpus((u32 *)&ci->adapterOperations2);\n\t\tle32_to_cpus((u32 *)&ci->adapterOperations3);\n\t\tle16_to_cpus((u16 *)&ci->adapter_operations4);\n\n\t\t/* Update the latest Ext VD info.\n\t\t * From Init path, store current firmware details.\n\t\t * From OCR path, detect any firmware properties changes.\n\t\t * in case of Firmware upgrade without system reboot.\n\t\t */\n\t\tmegasas_update_ext_vd_details(instance);\n\t\tinstance->use_seqnum_jbod_fp =\n\t\t\tci->adapterOperations3.useSeqNumJbodFP;\n\t\tinstance->support_morethan256jbod =\n\t\t\tci->adapter_operations4.support_pd_map_target_id;\n\t\tinstance->support_nvme_passthru =\n\t\t\tci->adapter_operations4.support_nvme_passthru;\n\t\tinstance->task_abort_tmo = ci->TaskAbortTO;\n\t\tinstance->max_reset_tmo = ci->MaxResetTO;\n\n\t\t/*Check whether controller is iMR or MR */\n\t\tinstance->is_imr = (ci->memory_size ? 0 : 1);\n\n\t\tinstance->snapdump_wait_time =\n\t\t\t(ci->properties.on_off_properties2.enable_snap_dump ?\n\t\t\t MEGASAS_DEFAULT_SNAP_DUMP_WAIT_TIME : 0);\n\n\t\tinstance->enable_fw_dev_list =\n\t\t\tci->properties.on_off_properties2.enable_fw_dev_list;\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"controller type\\t: %s(%dMB)\\n\",\n\t\t\tinstance->is_imr ? \"iMR\" : \"MR\",\n\t\t\tle16_to_cpu(ci->memory_size));\n\n\t\tinstance->disableOnlineCtrlReset =\n\t\t\tci->properties.OnOffProperties.disableOnlineCtrlReset;\n\t\tinstance->secure_jbod_support =\n\t\t\tci->adapterOperations3.supportSecurityonJBOD;\n\t\tdev_info(&instance->pdev->dev, \"Online Controller Reset(OCR)\\t: %s\\n\",\n\t\t\tinstance->disableOnlineCtrlReset ? \"Disabled\" : \"Enabled\");\n\t\tdev_info(&instance->pdev->dev, \"Secure JBOD support\\t: %s\\n\",\n\t\t\tinstance->secure_jbod_support ? \"Yes\" : \"No\");\n\t\tdev_info(&instance->pdev->dev, \"NVMe passthru support\\t: %s\\n\",\n\t\t\t instance->support_nvme_passthru ? \"Yes\" : \"No\");\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"FW provided TM TaskAbort/Reset timeout\\t: %d secs/%d secs\\n\",\n\t\t\t instance->task_abort_tmo, instance->max_reset_tmo);\n\n\t\tbreak;\n\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase DCMD_FAILED:\n\t\tmegaraid_sas_kill_hba(instance);\n\t\tbreak;\n\n\t}\n\n\tif (ret != DCMD_TIMEOUT)\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/*\n * megasas_set_crash_dump_params -\tSends address of crash dump DMA buffer\n *\t\t\t\t\tto firmware\n *\n * @instance:\t\t\t\tAdapter soft state\n * @crash_buf_state\t\t-\ttell FW to turn ON/OFF crash dump feature\n\t\t\t\t\tMR_CRASH_BUF_TURN_OFF = 0\n\t\t\t\t\tMR_CRASH_BUF_TURN_ON = 1\n * @return 0 on success non-zero on failure.\n * Issues an internal command (DCMD) to set parameters for crash dump feature.\n * Driver will send address of crash dump DMA buffer and set mbox to tell FW\n * that driver supports crash dump feature. This DCMD will be sent only if\n * crash dump feature is supported by the FW.\n *\n */\nint megasas_set_crash_dump_params(struct megasas_instance *instance,\n\tu8 crash_buf_state)\n{\n\tint ret = 0;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to get a free cmd\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\tdcmd->mbox.b[0] = crash_buf_state;\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = MFI_STAT_INVALID_STATUS;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_NONE;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(CRASH_DMA_BUF_SIZE);\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_SET_CRASH_DUMP_PARAMS);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->crash_dump_h,\n\t\t\t\t CRASH_DMA_BUF_SIZE);\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tif (ret == DCMD_TIMEOUT) {\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\tMFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev, \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t} else\n\t\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * megasas_issue_init_mfi -\tInitializes the FW\n * @instance:\t\tAdapter soft state\n *\n * Issues the INIT MFI cmd\n */\nstatic int\nmegasas_issue_init_mfi(struct megasas_instance *instance)\n{\n\t__le32 context;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_init_frame *init_frame;\n\tstruct megasas_init_queue_info *initq_info;\n\tdma_addr_t init_frame_h;\n\tdma_addr_t initq_info_h;\n\n\t/*\n\t * Prepare a init frame. Note the init frame points to queue info\n\t * structure. Each frame has SGL allocated after first 64 bytes. For\n\t * this frame - since we don't need any SGL - we use SGL's space as\n\t * queue info structure\n\t *\n\t * We will not get a NULL command below. We just created the pool.\n\t */\n\tcmd = megasas_get_cmd(instance);\n\n\tinit_frame = (struct megasas_init_frame *)cmd->frame;\n\tinitq_info = (struct megasas_init_queue_info *)\n\t\t((unsigned long)init_frame + 64);\n\n\tinit_frame_h = cmd->frame_phys_addr;\n\tinitq_info_h = init_frame_h + 64;\n\n\tcontext = init_frame->context;\n\tmemset(init_frame, 0, MEGAMFI_FRAME_SIZE);\n\tmemset(initq_info, 0, sizeof(struct megasas_init_queue_info));\n\tinit_frame->context = context;\n\n\tinitq_info->reply_queue_entries = cpu_to_le32(instance->max_fw_cmds + 1);\n\tinitq_info->reply_queue_start_phys_addr_lo = cpu_to_le32(instance->reply_queue_h);\n\n\tinitq_info->producer_index_phys_addr_lo = cpu_to_le32(instance->producer_h);\n\tinitq_info->consumer_index_phys_addr_lo = cpu_to_le32(instance->consumer_h);\n\n\tinit_frame->cmd = MFI_CMD_INIT;\n\tinit_frame->cmd_status = MFI_STAT_INVALID_STATUS;\n\tinit_frame->queue_info_new_phys_addr_lo =\n\t\tcpu_to_le32(lower_32_bits(initq_info_h));\n\tinit_frame->queue_info_new_phys_addr_hi =\n\t\tcpu_to_le32(upper_32_bits(initq_info_h));\n\n\tinit_frame->data_xfer_len = cpu_to_le32(sizeof(struct megasas_init_queue_info));\n\n\t/*\n\t * disable the intr before firing the init frame to FW\n\t */\n\tinstance->instancet->disable_intr(instance);\n\n\t/*\n\t * Issue the init frame in polled mode\n\t */\n\n\tif (megasas_issue_polled(instance, cmd)) {\n\t\tdev_err(&instance->pdev->dev, \"Failed to init firmware\\n\");\n\t\tmegasas_return_cmd(instance, cmd);\n\t\tgoto fail_fw_init;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn 0;\n\nfail_fw_init:\n\treturn -EINVAL;\n}\n\nstatic u32\nmegasas_init_adapter_mfi(struct megasas_instance *instance)\n{\n\tu32 context_sz;\n\tu32 reply_q_sz;\n\n\t/*\n\t * Get various operational parameters from status register\n\t */\n\tinstance->max_fw_cmds = instance->instancet->read_fw_status_reg(instance) & 0x00FFFF;\n\t/*\n\t * Reduce the max supported cmds by 1. This is to ensure that the\n\t * reply_q_sz (1 more than the max cmd that driver may send)\n\t * does not exceed max cmds that the FW can support\n\t */\n\tinstance->max_fw_cmds = instance->max_fw_cmds-1;\n\tinstance->max_mfi_cmds = instance->max_fw_cmds;\n\tinstance->max_num_sge = (instance->instancet->read_fw_status_reg(instance) & 0xFF0000) >>\n\t\t\t\t\t0x10;\n\t/*\n\t * For MFI skinny adapters, MEGASAS_SKINNY_INT_CMDS commands\n\t * are reserved for IOCTL + driver's internal DCMDs.\n\t */\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t\t(instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY)) {\n\t\tinstance->max_scsi_cmds = (instance->max_fw_cmds -\n\t\t\tMEGASAS_SKINNY_INT_CMDS);\n\t\tsema_init(&instance->ioctl_sem, MEGASAS_SKINNY_INT_CMDS);\n\t} else {\n\t\tinstance->max_scsi_cmds = (instance->max_fw_cmds -\n\t\t\tMEGASAS_INT_CMDS);\n\t\tsema_init(&instance->ioctl_sem, (MEGASAS_MFI_IOCTL_CMDS));\n\t}\n\n\tinstance->cur_can_queue = instance->max_scsi_cmds;\n\t/*\n\t * Create a pool of commands\n\t */\n\tif (megasas_alloc_cmds(instance))\n\t\tgoto fail_alloc_cmds;\n\n\t/*\n\t * Allocate memory for reply queue. Length of reply queue should\n\t * be _one_ more than the maximum commands handled by the firmware.\n\t *\n\t * Note: When FW completes commands, it places corresponding contex\n\t * values in this circular reply queue. This circular queue is a fairly\n\t * typical producer-consumer queue. FW is the producer (of completed\n\t * commands) and the driver is the consumer.\n\t */\n\tcontext_sz = sizeof(u32);\n\treply_q_sz = context_sz * (instance->max_fw_cmds + 1);\n\n\tinstance->reply_queue = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\treply_q_sz, &instance->reply_queue_h, GFP_KERNEL);\n\n\tif (!instance->reply_queue) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Out of DMA mem for reply queue\\n\");\n\t\tgoto fail_reply_queue;\n\t}\n\n\tif (megasas_issue_init_mfi(instance))\n\t\tgoto fail_fw_init;\n\n\tif (megasas_get_ctrl_info(instance)) {\n\t\tdev_err(&instance->pdev->dev, \"(%d): Could get controller info \"\n\t\t\t\"Fail from %s %d\\n\", instance->unique_id,\n\t\t\t__func__, __LINE__);\n\t\tgoto fail_fw_init;\n\t}\n\n\tinstance->fw_support_ieee = 0;\n\tinstance->fw_support_ieee =\n\t\t(instance->instancet->read_fw_status_reg(instance) &\n\t\t0x04000000);\n\n\tdev_notice(&instance->pdev->dev, \"megasas_init_mfi: fw_support_ieee=%d\",\n\t\t\tinstance->fw_support_ieee);\n\n\tif (instance->fw_support_ieee)\n\t\tinstance->flag_ieee = 1;\n\n\treturn 0;\n\nfail_fw_init:\n\n\tdma_free_coherent(&instance->pdev->dev, reply_q_sz,\n\t\t\t    instance->reply_queue, instance->reply_queue_h);\nfail_reply_queue:\n\tmegasas_free_cmds(instance);\n\nfail_alloc_cmds:\n\treturn 1;\n}\n\n/*\n * megasas_setup_irqs_ioapic -\t\tregister legacy interrupts.\n * @instance:\t\t\t\tAdapter soft state\n *\n * Do not enable interrupt, only setup ISRs.\n *\n * Return 0 on success.\n */\nstatic int\nmegasas_setup_irqs_ioapic(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev;\n\n\tpdev = instance->pdev;\n\tinstance->irq_context[0].instance = instance;\n\tinstance->irq_context[0].MSIxIndex = 0;\n\tif (request_irq(pci_irq_vector(pdev, 0),\n\t\t\tinstance->instancet->service_isr, IRQF_SHARED,\n\t\t\t\"megasas\", &instance->irq_context[0])) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to register IRQ from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\n/**\n * megasas_setup_irqs_msix -\t\tregister MSI-x interrupts.\n * @instance:\t\t\t\tAdapter soft state\n * @is_probe:\t\t\t\tDriver probe check\n *\n * Do not enable interrupt, only setup ISRs.\n *\n * Return 0 on success.\n */\nstatic int\nmegasas_setup_irqs_msix(struct megasas_instance *instance, u8 is_probe)\n{\n\tint i, j;\n\tstruct pci_dev *pdev;\n\n\tpdev = instance->pdev;\n\n\t/* Try MSI-x */\n\tfor (i = 0; i < instance->msix_vectors; i++) {\n\t\tinstance->irq_context[i].instance = instance;\n\t\tinstance->irq_context[i].MSIxIndex = i;\n\t\tif (request_irq(pci_irq_vector(pdev, i),\n\t\t\tinstance->instancet->service_isr, 0, \"megasas\",\n\t\t\t&instance->irq_context[i])) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to register IRQ for vector %d.\\n\", i);\n\t\t\tfor (j = 0; j < i; j++)\n\t\t\t\tfree_irq(pci_irq_vector(pdev, j),\n\t\t\t\t\t &instance->irq_context[j]);\n\t\t\t/* Retry irq register for IO_APIC*/\n\t\t\tinstance->msix_vectors = 0;\n\t\t\tif (is_probe) {\n\t\t\t\tpci_free_irq_vectors(instance->pdev);\n\t\t\t\treturn megasas_setup_irqs_ioapic(instance);\n\t\t\t} else {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n/*\n * megasas_destroy_irqs-\t\tunregister interrupts.\n * @instance:\t\t\t\tAdapter soft state\n * return:\t\t\t\tvoid\n */\nstatic void\nmegasas_destroy_irqs(struct megasas_instance *instance) {\n\n\tint i;\n\n\tif (instance->msix_vectors)\n\t\tfor (i = 0; i < instance->msix_vectors; i++) {\n\t\t\tfree_irq(pci_irq_vector(instance->pdev, i),\n\t\t\t\t &instance->irq_context[i]);\n\t\t}\n\telse\n\t\tfree_irq(pci_irq_vector(instance->pdev, 0),\n\t\t\t &instance->irq_context[0]);\n}\n\n/**\n * megasas_setup_jbod_map -\tsetup jbod map for FP seq_number.\n * @instance:\t\t\t\tAdapter soft state\n * @is_probe:\t\t\t\tDriver probe check\n *\n * Return 0 on success.\n */\nvoid\nmegasas_setup_jbod_map(struct megasas_instance *instance)\n{\n\tint i;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\tu32 pd_seq_map_sz;\n\n\tpd_seq_map_sz = sizeof(struct MR_PD_CFG_SEQ_NUM_SYNC) +\n\t\t(sizeof(struct MR_PD_CFG_SEQ) * (MAX_PHYSICAL_DEVICES - 1));\n\n\tif (reset_devices || !fusion ||\n\t\t!instance->ctrl_info_buf->adapterOperations3.useSeqNumJbodFP) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t\"Jbod map is not supported %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\tinstance->use_seqnum_jbod_fp = false;\n\t\treturn;\n\t}\n\n\tif (fusion->pd_seq_sync[0])\n\t\tgoto skip_alloc;\n\n\tfor (i = 0; i < JBOD_MAPS_COUNT; i++) {\n\t\tfusion->pd_seq_sync[i] = dma_alloc_coherent\n\t\t\t(&instance->pdev->dev, pd_seq_map_sz,\n\t\t\t&fusion->pd_seq_phys[i], GFP_KERNEL);\n\t\tif (!fusion->pd_seq_sync[i]) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate memory from %s %d\\n\",\n\t\t\t\t__func__, __LINE__);\n\t\t\tif (i == 1) {\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tpd_seq_map_sz, fusion->pd_seq_sync[0],\n\t\t\t\t\tfusion->pd_seq_phys[0]);\n\t\t\t\tfusion->pd_seq_sync[0] = NULL;\n\t\t\t}\n\t\t\tinstance->use_seqnum_jbod_fp = false;\n\t\t\treturn;\n\t\t}\n\t}\n\nskip_alloc:\n\tif (!megasas_sync_pd_seq_num(instance, false) &&\n\t\t!megasas_sync_pd_seq_num(instance, true))\n\t\tinstance->use_seqnum_jbod_fp = true;\n\telse\n\t\tinstance->use_seqnum_jbod_fp = false;\n}\n\nstatic void megasas_setup_reply_map(struct megasas_instance *instance)\n{\n\tconst struct cpumask *mask;\n\tunsigned int queue, cpu;\n\n\tfor (queue = 0; queue < instance->msix_vectors; queue++) {\n\t\tmask = pci_irq_get_affinity(instance->pdev, queue);\n\t\tif (!mask)\n\t\t\tgoto fallback;\n\n\t\tfor_each_cpu(cpu, mask)\n\t\t\tinstance->reply_map[cpu] = queue;\n\t}\n\treturn;\n\nfallback:\n\tfor_each_possible_cpu(cpu)\n\t\tinstance->reply_map[cpu] = cpu % instance->msix_vectors;\n}\n\n/**\n * megasas_get_device_list -\tGet the PD and LD device list from FW.\n * @instance:\t\t\tAdapter soft state\n * @return:\t\t\tSuccess or failure\n *\n * Issue DCMDs to Firmware to get the PD and LD list.\n * Based on the FW support, driver sends the HOST_DEVICE_LIST or combination\n * of PD_LIST/LD_LIST_QUERY DCMDs to get the device list.\n */\nstatic\nint megasas_get_device_list(struct megasas_instance *instance)\n{\n\tmemset(instance->pd_list, 0,\n\t       (MEGASAS_MAX_PD * sizeof(struct megasas_pd_list)));\n\tmemset(instance->ld_ids, 0xff, MEGASAS_MAX_LD_IDS);\n\n\tif (instance->enable_fw_dev_list) {\n\t\tif (megasas_host_device_list_query(instance, true))\n\t\t\treturn FAILED;\n\t} else {\n\t\tif (megasas_get_pd_list(instance) < 0) {\n\t\t\tdev_err(&instance->pdev->dev, \"failed to get PD list\\n\");\n\t\t\treturn FAILED;\n\t\t}\n\n\t\tif (megasas_ld_list_query(instance,\n\t\t\t\t\t  MR_LD_QUERY_TYPE_EXPOSED_TO_HOST)) {\n\t\t\tdev_err(&instance->pdev->dev, \"failed to get LD list\\n\");\n\t\t\treturn FAILED;\n\t\t}\n\t}\n\n\treturn SUCCESS;\n}\n/**\n * megasas_init_fw -\tInitializes the FW\n * @instance:\t\tAdapter soft state\n *\n * This is the main function for initializing firmware\n */\n\nstatic int megasas_init_fw(struct megasas_instance *instance)\n{\n\tu32 max_sectors_1;\n\tu32 max_sectors_2, tmp_sectors, msix_enable;\n\tu32 scratch_pad_1, scratch_pad_2, scratch_pad_3, status_reg;\n\tresource_size_t base_addr;\n\tstruct megasas_ctrl_info *ctrl_info = NULL;\n\tunsigned long bar_list;\n\tint i, j, loop, fw_msix_count = 0;\n\tstruct IOV_111 *iovPtr;\n\tstruct fusion_context *fusion;\n\tbool do_adp_reset = true;\n\n\tfusion = instance->ctrl_context;\n\n\t/* Find first memory bar */\n\tbar_list = pci_select_bars(instance->pdev, IORESOURCE_MEM);\n\tinstance->bar = find_first_bit(&bar_list, BITS_PER_LONG);\n\tif (pci_request_selected_regions(instance->pdev, 1<<instance->bar,\n\t\t\t\t\t \"megasas: LSI\")) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"IO memory region busy!\\n\");\n\t\treturn -EBUSY;\n\t}\n\n\tbase_addr = pci_resource_start(instance->pdev, instance->bar);\n\tinstance->reg_set = ioremap_nocache(base_addr, 8192);\n\n\tif (!instance->reg_set) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to map IO mem\\n\");\n\t\tgoto fail_ioremap;\n\t}\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tinstance->instancet = &megasas_instance_template_fusion;\n\telse {\n\t\tswitch (instance->pdev->device) {\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078R:\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078DE:\n\t\t\tinstance->instancet = &megasas_instance_template_ppc;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS1078GEN2:\n\t\tcase PCI_DEVICE_ID_LSI_SAS0079GEN2:\n\t\t\tinstance->instancet = &megasas_instance_template_gen2;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS0073SKINNY:\n\t\tcase PCI_DEVICE_ID_LSI_SAS0071SKINNY:\n\t\t\tinstance->instancet = &megasas_instance_template_skinny;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_SAS1064R:\n\t\tcase PCI_DEVICE_ID_DELL_PERC5:\n\t\tdefault:\n\t\t\tinstance->instancet = &megasas_instance_template_xscale;\n\t\t\tinstance->pd_list_not_supported = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (megasas_transition_to_ready(instance, 0)) {\n\t\tif (instance->adapter_type >= INVADER_SERIES) {\n\t\t\tstatus_reg = instance->instancet->read_fw_status_reg(\n\t\t\t\t\tinstance);\n\t\t\tdo_adp_reset = status_reg & MFI_RESET_ADAPTER;\n\t\t}\n\n\t\tif (do_adp_reset) {\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 1);\n\t\t\tinstance->instancet->adp_reset\n\t\t\t\t(instance, instance->reg_set);\n\t\t\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"FW restarted successfully from %s!\\n\",\n\t\t\t\t __func__);\n\n\t\t\t/*waiting for about 30 second before retry*/\n\t\t\tssleep(30);\n\n\t\t\tif (megasas_transition_to_ready(instance, 0))\n\t\t\t\tgoto fail_ready_state;\n\t\t} else {\n\t\t\tgoto fail_ready_state;\n\t\t}\n\t}\n\n\tmegasas_init_ctrl_params(instance);\n\n\tif (megasas_set_dma_mask(instance))\n\t\tgoto fail_ready_state;\n\n\tif (megasas_alloc_ctrl_mem(instance))\n\t\tgoto fail_alloc_dma_buf;\n\n\tif (megasas_alloc_ctrl_dma_buffers(instance))\n\t\tgoto fail_alloc_dma_buf;\n\n\tfusion = instance->ctrl_context;\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tscratch_pad_2 =\n\t\t\tmegasas_readl(instance,\n\t\t\t\t      &instance->reg_set->outbound_scratch_pad_2);\n\t\tinstance->max_raid_mapsize = ((scratch_pad_2 >>\n\t\t\tMR_MAX_RAID_MAP_SIZE_OFFSET_SHIFT) &\n\t\t\tMR_MAX_RAID_MAP_SIZE_MASK);\n\t}\n\n\t/* Check if MSI-X is supported while in ready state */\n\tmsix_enable = (instance->instancet->read_fw_status_reg(instance) &\n\t\t       0x4000000) >> 0x1a;\n\tif (msix_enable && !msix_disable) {\n\t\tint irq_flags = PCI_IRQ_MSIX;\n\n\t\tscratch_pad_1 = megasas_readl\n\t\t\t(instance, &instance->reg_set->outbound_scratch_pad_1);\n\t\t/* Check max MSI-X vectors */\n\t\tif (fusion) {\n\t\t\tif (instance->adapter_type == THUNDERBOLT_SERIES) {\n\t\t\t\t/* Thunderbolt Series*/\n\t\t\t\tinstance->msix_vectors = (scratch_pad_1\n\t\t\t\t\t& MR_MAX_REPLY_QUEUES_OFFSET) + 1;\n\t\t\t\tfw_msix_count = instance->msix_vectors;\n\t\t\t} else {\n\t\t\t\tinstance->msix_vectors = ((scratch_pad_1\n\t\t\t\t\t& MR_MAX_REPLY_QUEUES_EXT_OFFSET)\n\t\t\t\t\t>> MR_MAX_REPLY_QUEUES_EXT_OFFSET_SHIFT) + 1;\n\n\t\t\t\t/*\n\t\t\t\t * For Invader series, > 8 MSI-x vectors\n\t\t\t\t * supported by FW/HW implies combined\n\t\t\t\t * reply queue mode is enabled.\n\t\t\t\t * For Ventura series, > 16 MSI-x vectors\n\t\t\t\t * supported by FW/HW implies combined\n\t\t\t\t * reply queue mode is enabled.\n\t\t\t\t */\n\t\t\t\tswitch (instance->adapter_type) {\n\t\t\t\tcase INVADER_SERIES:\n\t\t\t\t\tif (instance->msix_vectors > 8)\n\t\t\t\t\t\tinstance->msix_combined = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase AERO_SERIES:\n\t\t\t\tcase VENTURA_SERIES:\n\t\t\t\t\tif (instance->msix_vectors > 16)\n\t\t\t\t\t\tinstance->msix_combined = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (rdpq_enable)\n\t\t\t\t\tinstance->is_rdpq = (scratch_pad_1 & MR_RDPQ_MODE_OFFSET) ?\n\t\t\t\t\t\t\t\t1 : 0;\n\t\t\t\tfw_msix_count = instance->msix_vectors;\n\t\t\t\t/* Save 1-15 reply post index address to local memory\n\t\t\t\t * Index 0 is already saved from reg offset\n\t\t\t\t * MPI2_REPLY_POST_HOST_INDEX_OFFSET\n\t\t\t\t */\n\t\t\t\tfor (loop = 1; loop < MR_MAX_MSIX_REG_ARRAY; loop++) {\n\t\t\t\t\tinstance->reply_post_host_index_addr[loop] =\n\t\t\t\t\t\t(u32 __iomem *)\n\t\t\t\t\t\t((u8 __iomem *)instance->reg_set +\n\t\t\t\t\t\tMPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET\n\t\t\t\t\t\t+ (loop * 0x10));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (msix_vectors)\n\t\t\t\tinstance->msix_vectors = min(msix_vectors,\n\t\t\t\t\tinstance->msix_vectors);\n\t\t} else /* MFI adapters */\n\t\t\tinstance->msix_vectors = 1;\n\t\t/* Don't bother allocating more MSI-X vectors than cpus */\n\t\tinstance->msix_vectors = min(instance->msix_vectors,\n\t\t\t\t\t     (unsigned int)num_online_cpus());\n\t\tif (smp_affinity_enable)\n\t\t\tirq_flags |= PCI_IRQ_AFFINITY;\n\t\ti = pci_alloc_irq_vectors(instance->pdev, 1,\n\t\t\t\t\t  instance->msix_vectors, irq_flags);\n\t\tif (i > 0)\n\t\t\tinstance->msix_vectors = i;\n\t\telse\n\t\t\tinstance->msix_vectors = 0;\n\t}\n\t/*\n\t * MSI-X host index 0 is common for all adapter.\n\t * It is used for all MPT based Adapters.\n\t */\n\tif (instance->msix_combined) {\n\t\tinstance->reply_post_host_index_addr[0] =\n\t\t\t\t(u32 *)((u8 *)instance->reg_set +\n\t\t\t\tMPI2_SUP_REPLY_POST_HOST_INDEX_OFFSET);\n\t} else {\n\t\tinstance->reply_post_host_index_addr[0] =\n\t\t\t(u32 *)((u8 *)instance->reg_set +\n\t\t\tMPI2_REPLY_POST_HOST_INDEX_OFFSET);\n\t}\n\n\tif (!instance->msix_vectors) {\n\t\ti = pci_alloc_irq_vectors(instance->pdev, 1, 1, PCI_IRQ_LEGACY);\n\t\tif (i < 0)\n\t\t\tgoto fail_init_adapter;\n\t}\n\n\tmegasas_setup_reply_map(instance);\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"firmware supports msix\\t: (%d)\", fw_msix_count);\n\tdev_info(&instance->pdev->dev,\n\t\t\"current msix/online cpus\\t: (%d/%d)\\n\",\n\t\tinstance->msix_vectors, (unsigned int)num_online_cpus());\n\tdev_info(&instance->pdev->dev,\n\t\t\"RDPQ mode\\t: (%s)\\n\", instance->is_rdpq ? \"enabled\" : \"disabled\");\n\n\ttasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\n\t\t(unsigned long)instance);\n\n\t/*\n\t * Below are default value for legacy Firmware.\n\t * non-fusion based controllers\n\t */\n\tinstance->fw_supported_vd_count = MAX_LOGICAL_DRIVES;\n\tinstance->fw_supported_pd_count = MAX_PHYSICAL_DEVICES;\n\t/* Get operational params, sge flags, send init cmd to controller */\n\tif (instance->instancet->init_adapter(instance))\n\t\tgoto fail_init_adapter;\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tscratch_pad_3 =\n\t\t\tmegasas_readl(instance,\n\t\t\t\t      &instance->reg_set->outbound_scratch_pad_3);\n\t\tif ((scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK) >=\n\t\t\tMR_DEFAULT_NVME_PAGE_SHIFT)\n\t\t\tinstance->nvme_page_size =\n\t\t\t\t(1 << (scratch_pad_3 & MR_NVME_PAGE_SIZE_MASK));\n\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"NVME page size\\t: (%d)\\n\", instance->nvme_page_size);\n\t}\n\n\tif (instance->msix_vectors ?\n\t\tmegasas_setup_irqs_msix(instance, 1) :\n\t\tmegasas_setup_irqs_ioapic(instance))\n\t\tgoto fail_init_adapter;\n\n\tinstance->instancet->enable_intr(instance);\n\n\tdev_info(&instance->pdev->dev, \"INIT adapter done\\n\");\n\n\tmegasas_setup_jbod_map(instance);\n\n\tif (megasas_get_device_list(instance) != SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"%s: megasas_get_device_list failed\\n\",\n\t\t\t__func__);\n\t\tgoto fail_get_ld_pd_list;\n\t}\n\n\t/* stream detection initialization */\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tfusion->stream_detect_by_ld =\n\t\t\tkcalloc(MAX_LOGICAL_DRIVES_EXT,\n\t\t\t\tsizeof(struct LD_STREAM_DETECT *),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!fusion->stream_detect_by_ld) {\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"unable to allocate stream detection for pool of LDs\\n\");\n\t\t\tgoto fail_get_ld_pd_list;\n\t\t}\n\t\tfor (i = 0; i < MAX_LOGICAL_DRIVES_EXT; ++i) {\n\t\t\tfusion->stream_detect_by_ld[i] =\n\t\t\t\tkzalloc(sizeof(struct LD_STREAM_DETECT),\n\t\t\t\tGFP_KERNEL);\n\t\t\tif (!fusion->stream_detect_by_ld[i]) {\n\t\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\t\"unable to allocate stream detect by LD\\n \");\n\t\t\t\tfor (j = 0; j < i; ++j)\n\t\t\t\t\tkfree(fusion->stream_detect_by_ld[j]);\n\t\t\t\tkfree(fusion->stream_detect_by_ld);\n\t\t\t\tfusion->stream_detect_by_ld = NULL;\n\t\t\t\tgoto fail_get_ld_pd_list;\n\t\t\t}\n\t\t\tfusion->stream_detect_by_ld[i]->mru_bit_map\n\t\t\t\t= MR_STREAM_BITMAP;\n\t\t}\n\t}\n\n\t/*\n\t * Compute the max allowed sectors per IO: The controller info has two\n\t * limits on max sectors. Driver should use the minimum of these two.\n\t *\n\t * 1 << stripe_sz_ops.min = max sectors per strip\n\t *\n\t * Note that older firmwares ( < FW ver 30) didn't report information\n\t * to calculate max_sectors_1. So the number ended up as zero always.\n\t */\n\ttmp_sectors = 0;\n\tctrl_info = instance->ctrl_info_buf;\n\n\tmax_sectors_1 = (1 << ctrl_info->stripe_sz_ops.min) *\n\t\tle16_to_cpu(ctrl_info->max_strips_per_io);\n\tmax_sectors_2 = le32_to_cpu(ctrl_info->max_request_size);\n\n\ttmp_sectors = min_t(u32, max_sectors_1, max_sectors_2);\n\n\tinstance->peerIsPresent = ctrl_info->cluster.peerIsPresent;\n\tinstance->passive = ctrl_info->cluster.passive;\n\tmemcpy(instance->clusterId, ctrl_info->clusterId, sizeof(instance->clusterId));\n\tinstance->UnevenSpanSupport =\n\t\tctrl_info->adapterOperations2.supportUnevenSpans;\n\tif (instance->UnevenSpanSupport) {\n\t\tstruct fusion_context *fusion = instance->ctrl_context;\n\t\tif (MR_ValidateMapInfo(instance, instance->map_id))\n\t\t\tfusion->fast_path_io = 1;\n\t\telse\n\t\t\tfusion->fast_path_io = 0;\n\n\t}\n\tif (ctrl_info->host_interface.SRIOV) {\n\t\tinstance->requestorId = ctrl_info->iov.requestorId;\n\t\tif (instance->pdev->device == PCI_DEVICE_ID_LSI_PLASMA) {\n\t\t\tif (!ctrl_info->adapterOperations2.activePassive)\n\t\t\t    instance->PlasmaFW111 = 1;\n\n\t\t\tdev_info(&instance->pdev->dev, \"SR-IOV: firmware type: %s\\n\",\n\t\t\t    instance->PlasmaFW111 ? \"1.11\" : \"new\");\n\n\t\t\tif (instance->PlasmaFW111) {\n\t\t\t    iovPtr = (struct IOV_111 *)\n\t\t\t\t((unsigned char *)ctrl_info + IOV_111_OFFSET);\n\t\t\t    instance->requestorId = iovPtr->requestorId;\n\t\t\t}\n\t\t}\n\t\tdev_info(&instance->pdev->dev, \"SRIOV: VF requestorId %d\\n\",\n\t\t\tinstance->requestorId);\n\t}\n\n\tinstance->crash_dump_fw_support =\n\t\tctrl_info->adapterOperations3.supportCrashDump;\n\tinstance->crash_dump_drv_support =\n\t\t(instance->crash_dump_fw_support &&\n\t\tinstance->crash_dump_buf);\n\tif (instance->crash_dump_drv_support)\n\t\tmegasas_set_crash_dump_params(instance,\n\t\t\tMR_CRASH_BUF_TURN_OFF);\n\n\telse {\n\t\tif (instance->crash_dump_buf)\n\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\tCRASH_DMA_BUF_SIZE,\n\t\t\t\tinstance->crash_dump_buf,\n\t\t\t\tinstance->crash_dump_h);\n\t\tinstance->crash_dump_buf = NULL;\n\t}\n\n\tif (instance->snapdump_wait_time) {\n\t\tmegasas_get_snapdump_properties(instance);\n\t\tdev_info(&instance->pdev->dev, \"Snap dump wait time\\t: %d\\n\",\n\t\t\t instance->snapdump_wait_time);\n\t}\n\n\tdev_info(&instance->pdev->dev,\n\t\t\"pci id\\t\\t: (0x%04x)/(0x%04x)/(0x%04x)/(0x%04x)\\n\",\n\t\tle16_to_cpu(ctrl_info->pci.vendor_id),\n\t\tle16_to_cpu(ctrl_info->pci.device_id),\n\t\tle16_to_cpu(ctrl_info->pci.sub_vendor_id),\n\t\tle16_to_cpu(ctrl_info->pci.sub_device_id));\n\tdev_info(&instance->pdev->dev, \"unevenspan support\t: %s\\n\",\n\t\tinstance->UnevenSpanSupport ? \"yes\" : \"no\");\n\tdev_info(&instance->pdev->dev, \"firmware crash dump\t: %s\\n\",\n\t\tinstance->crash_dump_drv_support ? \"yes\" : \"no\");\n\tdev_info(&instance->pdev->dev, \"jbod sync map\t\t: %s\\n\",\n\t\tinstance->use_seqnum_jbod_fp ? \"yes\" : \"no\");\n\n\tinstance->max_sectors_per_req = instance->max_num_sge *\n\t\t\t\t\t\tSGE_BUFFER_SIZE / 512;\n\tif (tmp_sectors && (instance->max_sectors_per_req > tmp_sectors))\n\t\tinstance->max_sectors_per_req = tmp_sectors;\n\n\t/* Check for valid throttlequeuedepth module parameter */\n\tif (throttlequeuedepth &&\n\t\t\tthrottlequeuedepth <= instance->max_scsi_cmds)\n\t\tinstance->throttlequeuedepth = throttlequeuedepth;\n\telse\n\t\tinstance->throttlequeuedepth =\n\t\t\t\tMEGASAS_THROTTLE_QUEUE_DEPTH;\n\n\tif ((resetwaittime < 1) ||\n\t    (resetwaittime > MEGASAS_RESET_WAIT_TIME))\n\t\tresetwaittime = MEGASAS_RESET_WAIT_TIME;\n\n\tif ((scmd_timeout < 10) || (scmd_timeout > MEGASAS_DEFAULT_CMD_TIMEOUT))\n\t\tscmd_timeout = MEGASAS_DEFAULT_CMD_TIMEOUT;\n\n\t/* Launch SR-IOV heartbeat timer */\n\tif (instance->requestorId) {\n\t\tif (!megasas_sriov_start_heartbeat(instance, 1)) {\n\t\t\tmegasas_start_timer(instance);\n\t\t} else {\n\t\t\tinstance->skip_heartbeat_timer_del = 1;\n\t\t\tgoto fail_get_ld_pd_list;\n\t\t}\n\t}\n\n\t/*\n\t * Create and start watchdog thread which will monitor\n\t * controller state every 1 sec and trigger OCR when\n\t * it enters fault state\n\t */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tif (megasas_fusion_start_watchdog(instance) != SUCCESS)\n\t\t\tgoto fail_start_watchdog;\n\n\treturn 0;\n\nfail_start_watchdog:\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\nfail_get_ld_pd_list:\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\nfail_init_adapter:\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\tinstance->msix_vectors = 0;\nfail_alloc_dma_buf:\n\tmegasas_free_ctrl_dma_buffers(instance);\n\tmegasas_free_ctrl_mem(instance);\nfail_ready_state:\n\tiounmap(instance->reg_set);\n\nfail_ioremap:\n\tpci_release_selected_regions(instance->pdev, 1<<instance->bar);\n\n\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t__func__, __LINE__);\n\treturn -EINVAL;\n}\n\n/**\n * megasas_release_mfi -\tReverses the FW initialization\n * @instance:\t\t\tAdapter soft state\n */\nstatic void megasas_release_mfi(struct megasas_instance *instance)\n{\n\tu32 reply_q_sz = sizeof(u32) *(instance->max_mfi_cmds + 1);\n\n\tif (instance->reply_queue)\n\t\tdma_free_coherent(&instance->pdev->dev, reply_q_sz,\n\t\t\t    instance->reply_queue, instance->reply_queue_h);\n\n\tmegasas_free_cmds(instance);\n\n\tiounmap(instance->reg_set);\n\n\tpci_release_selected_regions(instance->pdev, 1<<instance->bar);\n}\n\n/**\n * megasas_get_seq_num -\tGets latest event sequence numbers\n * @instance:\t\t\tAdapter soft state\n * @eli:\t\t\tFW event log sequence numbers information\n *\n * FW maintains a log of all events in a non-volatile area. Upper layers would\n * usually find out the latest sequence number of the events, the seq number at\n * the boot etc. They would \"read\" all the events below the latest seq number\n * by issuing a direct fw cmd (DCMD). For the future events (beyond latest seq\n * number), they would subsribe to AEN (asynchronous event notification) and\n * wait for the events to happen.\n */\nstatic int\nmegasas_get_seq_num(struct megasas_instance *instance,\n\t\t    struct megasas_evt_log_info *eli)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tstruct megasas_evt_log_info *el_info;\n\tdma_addr_t el_info_h = 0;\n\tint ret;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\tel_info = dma_zalloc_coherent(&instance->pdev->dev,\n\t\t\tsizeof(struct megasas_evt_log_info), &el_info_h,\n\t\t\tGFP_KERNEL);\n\tif (!el_info) {\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_evt_log_info));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_EVENT_GET_INFO);\n\n\tmegasas_set_dma_settings(instance, dcmd, el_info_h,\n\t\t\t\t sizeof(struct megasas_evt_log_info));\n\n\tret = megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS);\n\tif (ret != DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\tgoto dcmd_failed;\n\t}\n\n\t/*\n\t * Copy the data back into callers buffer\n\t */\n\teli->newest_seq_num = el_info->newest_seq_num;\n\teli->oldest_seq_num = el_info->oldest_seq_num;\n\teli->clear_seq_num = el_info->clear_seq_num;\n\teli->shutdown_seq_num = el_info->shutdown_seq_num;\n\teli->boot_seq_num = el_info->boot_seq_num;\n\ndcmd_failed:\n\tdma_free_coherent(&instance->pdev->dev,\n\t\t\tsizeof(struct megasas_evt_log_info),\n\t\t\tel_info, el_info_h);\n\n\tmegasas_return_cmd(instance, cmd);\n\n\treturn ret;\n}\n\n/**\n * megasas_register_aen -\tRegisters for asynchronous event notification\n * @instance:\t\t\tAdapter soft state\n * @seq_num:\t\t\tThe starting sequence number\n * @class_locale:\t\tClass of the event\n *\n * This function subscribes for AEN for events beyond the @seq_num. It requests\n * to be notified if and only if the event is of type @class_locale\n */\nstatic int\nmegasas_register_aen(struct megasas_instance *instance, u32 seq_num,\n\t\t     u32 class_locale_word)\n{\n\tint ret_val;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tunion megasas_evt_class_locale curr_aen;\n\tunion megasas_evt_class_locale prev_aen;\n\n\t/*\n\t * If there an AEN pending already (aen_cmd), check if the\n\t * class_locale of that pending AEN is inclusive of the new\n\t * AEN request we currently have. If it is, then we don't have\n\t * to do anything. In other words, whichever events the current\n\t * AEN request is subscribing to, have already been subscribed\n\t * to.\n\t *\n\t * If the old_cmd is _not_ inclusive, then we have to abort\n\t * that command, form a class_locale that is superset of both\n\t * old and current and re-issue to the FW\n\t */\n\n\tcurr_aen.word = class_locale_word;\n\n\tif (instance->aen_cmd) {\n\n\t\tprev_aen.word =\n\t\t\tle32_to_cpu(instance->aen_cmd->frame->dcmd.mbox.w[1]);\n\n\t\tif ((curr_aen.members.class < MFI_EVT_CLASS_DEBUG) ||\n\t\t    (curr_aen.members.class > MFI_EVT_CLASS_DEAD)) {\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"%s %d out of range class %d send by application\\n\",\n\t\t\t\t __func__, __LINE__, curr_aen.members.class);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * A class whose enum value is smaller is inclusive of all\n\t\t * higher values. If a PROGRESS (= -1) was previously\n\t\t * registered, then a new registration requests for higher\n\t\t * classes need not be sent to FW. They are automatically\n\t\t * included.\n\t\t *\n\t\t * Locale numbers don't have such hierarchy. They are bitmap\n\t\t * values\n\t\t */\n\t\tif ((prev_aen.members.class <= curr_aen.members.class) &&\n\t\t    !((prev_aen.members.locale & curr_aen.members.locale) ^\n\t\t      curr_aen.members.locale)) {\n\t\t\t/*\n\t\t\t * Previously issued event registration includes\n\t\t\t * current request. Nothing to do.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tcurr_aen.members.locale |= prev_aen.members.locale;\n\n\t\t\tif (prev_aen.members.class < curr_aen.members.class)\n\t\t\t\tcurr_aen.members.class = prev_aen.members.class;\n\n\t\t\tinstance->aen_cmd->abort_aen = 1;\n\t\t\tret_val = megasas_issue_blocked_abort_cmd(instance,\n\t\t\t\t\t\t\t\t  instance->\n\t\t\t\t\t\t\t\t  aen_cmd, 30);\n\n\t\t\tif (ret_val) {\n\t\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to abort \"\n\t\t\t\t       \"previous AEN command\\n\");\n\t\t\t\treturn ret_val;\n\t\t\t}\n\t\t}\n\t}\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn -ENOMEM;\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->evt_detail, 0, sizeof(struct megasas_evt_detail));\n\n\t/*\n\t * Prepare DCMD for aen registration\n\t */\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = cpu_to_le32(sizeof(struct megasas_evt_detail));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_EVENT_WAIT);\n\tdcmd->mbox.w[0] = cpu_to_le32(seq_num);\n\tinstance->last_seq_num = seq_num;\n\tdcmd->mbox.w[1] = cpu_to_le32(curr_aen.word);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->evt_detail_h,\n\t\t\t\t sizeof(struct megasas_evt_detail));\n\n\tif (instance->aen_cmd != NULL) {\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Store reference to the cmd used to register for AEN. When an\n\t * application wants us to register for AEN, we have to abort this\n\t * cmd and re-register with a new EVENT LOCALE supplied by that app\n\t */\n\tinstance->aen_cmd = cmd;\n\n\t/*\n\t * Issue the aen registration frame\n\t */\n\tinstance->instancet->issue_dcmd(instance, cmd);\n\n\treturn 0;\n}\n\n/* megasas_get_target_prop - Send DCMD with below details to firmware.\n *\n * This DCMD will fetch few properties of LD/system PD defined\n * in MR_TARGET_DEV_PROPERTIES. eg. Queue Depth, MDTS value.\n *\n * DCMD send by drivers whenever new target is added to the OS.\n *\n * dcmd.opcode         - MR_DCMD_DEV_GET_TARGET_PROP\n * dcmd.mbox.b[0]      - DCMD is to be fired for LD or system PD.\n *                       0 = system PD, 1 = LD.\n * dcmd.mbox.s[1]      - TargetID for LD/system PD.\n * dcmd.sge IN         - Pointer to return MR_TARGET_DEV_PROPERTIES.\n *\n * @instance:\t\tAdapter soft state\n * @sdev:\t\tOS provided scsi device\n *\n * Returns 0 on success non-zero on failure.\n */\nint\nmegasas_get_target_prop(struct megasas_instance *instance,\n\t\t\tstruct scsi_device *sdev)\n{\n\tint ret;\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\tu16 targetId = (sdev->channel % 2) + sdev->id;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to get cmd %s\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(instance->tgt_prop, 0, sizeof(*instance->tgt_prop));\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\tdcmd->mbox.b[0] = MEGASAS_IS_LOGICAL(sdev);\n\n\tdcmd->mbox.s[1] = cpu_to_le16(targetId);\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0xFF;\n\tdcmd->sge_count = 1;\n\tdcmd->flags = MFI_FRAME_DIR_READ;\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len =\n\t\tcpu_to_le32(sizeof(struct MR_TARGET_PROPERTIES));\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_DRV_GET_TARGET_PROP);\n\n\tmegasas_set_dma_settings(instance, dcmd, instance->tgt_prop_h,\n\t\t\t\t sizeof(struct MR_TARGET_PROPERTIES));\n\n\tif ((instance->adapter_type != MFI_SERIES) &&\n\t    !instance->mask_interrupts)\n\t\tret = megasas_issue_blocked_cmd(instance,\n\t\t\t\t\t\tcmd, MFI_IO_TIMEOUT_SECS);\n\telse\n\t\tret = megasas_issue_polled(instance, cmd);\n\n\tswitch (ret) {\n\tcase DCMD_TIMEOUT:\n\t\tswitch (dcmd_timeout_ocr_possible(instance)) {\n\t\tcase INITIATE_OCR:\n\t\t\tcmd->flags |= DRV_DCMD_SKIP_REFIRE;\n\t\t\tmegasas_reset_fusion(instance->host,\n\t\t\t\t\t     MFI_IO_TIMEOUT_OCR);\n\t\t\tbreak;\n\t\tcase KILL_ADAPTER:\n\t\t\tmegaraid_sas_kill_hba(instance);\n\t\t\tbreak;\n\t\tcase IGNORE_TIMEOUT:\n\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t \"Ignore DCMD timeout: %s %d\\n\",\n\t\t\t\t __func__, __LINE__);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\tmegasas_return_cmd(instance, cmd);\n\t}\n\tif (ret != DCMD_SUCCESS)\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d return value %d\\n\",\n\t\t\t__func__, __LINE__, ret);\n\n\treturn ret;\n}\n\n/**\n * megasas_start_aen -\tSubscribes to AEN during driver load time\n * @instance:\t\tAdapter soft state\n */\nstatic int megasas_start_aen(struct megasas_instance *instance)\n{\n\tstruct megasas_evt_log_info eli;\n\tunion megasas_evt_class_locale class_locale;\n\n\t/*\n\t * Get the latest sequence number from FW\n\t */\n\tmemset(&eli, 0, sizeof(eli));\n\n\tif (megasas_get_seq_num(instance, &eli))\n\t\treturn -1;\n\n\t/*\n\t * Register AEN with FW for latest sequence number plus 1\n\t */\n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\treturn megasas_register_aen(instance,\n\t\t\tle32_to_cpu(eli.newest_seq_num) + 1,\n\t\t\tclass_locale.word);\n}\n\n/**\n * megasas_io_attach -\tAttaches this driver to SCSI mid-layer\n * @instance:\t\tAdapter soft state\n */\nstatic int megasas_io_attach(struct megasas_instance *instance)\n{\n\tstruct Scsi_Host *host = instance->host;\n\n\t/*\n\t * Export parameters required by SCSI mid-layer\n\t */\n\thost->unique_id = instance->unique_id;\n\thost->can_queue = instance->max_scsi_cmds;\n\thost->this_id = instance->init_id;\n\thost->sg_tablesize = instance->max_num_sge;\n\n\tif (instance->fw_support_ieee)\n\t\tinstance->max_sectors_per_req = MEGASAS_MAX_SECTORS_IEEE;\n\n\t/*\n\t * Check if the module parameter value for max_sectors can be used\n\t */\n\tif (max_sectors && max_sectors < instance->max_sectors_per_req)\n\t\tinstance->max_sectors_per_req = max_sectors;\n\telse {\n\t\tif (max_sectors) {\n\t\t\tif (((instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS1078GEN2) ||\n\t\t\t\t(instance->pdev->device ==\n\t\t\t\tPCI_DEVICE_ID_LSI_SAS0079GEN2)) &&\n\t\t\t\t(max_sectors <= MEGASAS_MAX_SECTORS)) {\n\t\t\t\tinstance->max_sectors_per_req = max_sectors;\n\t\t\t} else {\n\t\t\tdev_info(&instance->pdev->dev, \"max_sectors should be > 0\"\n\t\t\t\t\"and <= %d (or < 1MB for GEN2 controller)\\n\",\n\t\t\t\tinstance->max_sectors_per_req);\n\t\t\t}\n\t\t}\n\t}\n\n\thost->max_sectors = instance->max_sectors_per_req;\n\thost->cmd_per_lun = MEGASAS_DEFAULT_CMD_PER_LUN;\n\thost->max_channel = MEGASAS_MAX_CHANNELS - 1;\n\thost->max_id = MEGASAS_MAX_DEV_PER_CHANNEL;\n\thost->max_lun = MEGASAS_MAX_LUN;\n\thost->max_cmd_len = 16;\n\n\t/*\n\t * Notify the mid-layer about the new controller\n\t */\n\tif (scsi_add_host(host, &instance->pdev->dev)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to add host from %s %d\\n\",\n\t\t\t__func__, __LINE__);\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\n/**\n * megasas_set_dma_mask -\tSet DMA mask for supported controllers\n *\n * @instance:\t\tAdapter soft state\n * Description:\n *\n * For Ventura, driver/FW will operate in 63bit DMA addresses.\n *\n * For invader-\n *\tBy default, driver/FW will operate in 32bit DMA addresses\n *\tfor consistent DMA mapping but if 32 bit consistent\n *\tDMA mask fails, driver will try with 63 bit consistent\n *\tmask provided FW is true 63bit DMA capable\n *\n * For older controllers(Thunderbolt and MFI based adapters)-\n *\tdriver/FW will operate in 32 bit consistent DMA addresses.\n */\nstatic int\nmegasas_set_dma_mask(struct megasas_instance *instance)\n{\n\tu64 consistent_mask;\n\tstruct pci_dev *pdev;\n\tu32 scratch_pad_1;\n\n\tpdev = instance->pdev;\n\tconsistent_mask = (instance->adapter_type >= VENTURA_SERIES) ?\n\t\t\t\tDMA_BIT_MASK(63) : DMA_BIT_MASK(32);\n\n\tif (IS_DMA64) {\n\t\tif (dma_set_mask(&pdev->dev, DMA_BIT_MASK(63)) &&\n\t\t    dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))\n\t\t\tgoto fail_set_dma_mask;\n\n\t\tif ((*pdev->dev.dma_mask == DMA_BIT_MASK(63)) &&\n\t\t    (dma_set_coherent_mask(&pdev->dev, consistent_mask) &&\n\t\t     dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))) {\n\t\t\t/*\n\t\t\t * If 32 bit DMA mask fails, then try for 64 bit mask\n\t\t\t * for FW capable of handling 64 bit DMA.\n\t\t\t */\n\t\t\tscratch_pad_1 = megasas_readl\n\t\t\t\t(instance, &instance->reg_set->outbound_scratch_pad_1);\n\n\t\t\tif (!(scratch_pad_1 & MR_CAN_HANDLE_64_BIT_DMA_OFFSET))\n\t\t\t\tgoto fail_set_dma_mask;\n\t\t\telse if (dma_set_mask_and_coherent(&pdev->dev,\n\t\t\t\t\t\t\t   DMA_BIT_MASK(63)))\n\t\t\t\tgoto fail_set_dma_mask;\n\t\t}\n\t} else if (dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32)))\n\t\tgoto fail_set_dma_mask;\n\n\tif (pdev->dev.coherent_dma_mask == DMA_BIT_MASK(32))\n\t\tinstance->consistent_mask_64bit = false;\n\telse\n\t\tinstance->consistent_mask_64bit = true;\n\n\tdev_info(&pdev->dev, \"%s bit DMA mask and %s bit consistent mask\\n\",\n\t\t ((*pdev->dev.dma_mask == DMA_BIT_MASK(64)) ? \"63\" : \"32\"),\n\t\t (instance->consistent_mask_64bit ? \"63\" : \"32\"));\n\n\treturn 0;\n\nfail_set_dma_mask:\n\tdev_err(&pdev->dev, \"Failed to set DMA mask\\n\");\n\treturn -1;\n\n}\n\n/*\n * megasas_set_adapter_type -\tSet adapter type.\n *\t\t\t\tSupported controllers can be divided in\n *\t\t\t\tdifferent categories-\n *\t\t\t\t\tenum MR_ADAPTER_TYPE {\n *\t\t\t\t\t\tMFI_SERIES = 1,\n *\t\t\t\t\t\tTHUNDERBOLT_SERIES = 2,\n *\t\t\t\t\t\tINVADER_SERIES = 3,\n *\t\t\t\t\t\tVENTURA_SERIES = 4,\n *\t\t\t\t\t\tAERO_SERIES = 5,\n *\t\t\t\t\t};\n * @instance:\t\t\tAdapter soft state\n * return:\t\t\tvoid\n */\nstatic inline void megasas_set_adapter_type(struct megasas_instance *instance)\n{\n\tif ((instance->pdev->vendor == PCI_VENDOR_ID_DELL) &&\n\t    (instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5)) {\n\t\tinstance->adapter_type = MFI_SERIES;\n\t} else {\n\t\tswitch (instance->pdev->device) {\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E1:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E2:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E5:\n\t\tcase PCI_DEVICE_ID_LSI_AERO_10E6:\n\t\t\tinstance->adapter_type = AERO_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_VENTURA:\n\t\tcase PCI_DEVICE_ID_LSI_CRUSADER:\n\t\tcase PCI_DEVICE_ID_LSI_HARPOON:\n\t\tcase PCI_DEVICE_ID_LSI_TOMCAT:\n\t\tcase PCI_DEVICE_ID_LSI_VENTURA_4PORT:\n\t\tcase PCI_DEVICE_ID_LSI_CRUSADER_4PORT:\n\t\t\tinstance->adapter_type = VENTURA_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_FUSION:\n\t\tcase PCI_DEVICE_ID_LSI_PLASMA:\n\t\t\tinstance->adapter_type = THUNDERBOLT_SERIES;\n\t\t\tbreak;\n\t\tcase PCI_DEVICE_ID_LSI_INVADER:\n\t\tcase PCI_DEVICE_ID_LSI_INTRUDER:\n\t\tcase PCI_DEVICE_ID_LSI_INTRUDER_24:\n\t\tcase PCI_DEVICE_ID_LSI_CUTLASS_52:\n\t\tcase PCI_DEVICE_ID_LSI_CUTLASS_53:\n\t\tcase PCI_DEVICE_ID_LSI_FURY:\n\t\t\tinstance->adapter_type = INVADER_SERIES;\n\t\t\tbreak;\n\t\tdefault: /* For all other supported controllers */\n\t\t\tinstance->adapter_type = MFI_SERIES;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nstatic inline int megasas_alloc_mfi_ctrl_mem(struct megasas_instance *instance)\n{\n\tinstance->producer = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\tsizeof(u32), &instance->producer_h, GFP_KERNEL);\n\tinstance->consumer = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\tsizeof(u32), &instance->consumer_h, GFP_KERNEL);\n\n\tif (!instance->producer || !instance->consumer) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to allocate memory for producer, consumer\\n\");\n\t\treturn -1;\n\t}\n\n\t*instance->producer = 0;\n\t*instance->consumer = 0;\n\treturn 0;\n}\n\n/**\n * megasas_alloc_ctrl_mem -\tAllocate per controller memory for core data\n *\t\t\t\tstructures which are not common across MFI\n *\t\t\t\tadapters and fusion adapters.\n *\t\t\t\tFor MFI based adapters, allocate producer and\n *\t\t\t\tconsumer buffers. For fusion adapters, allocate\n *\t\t\t\tmemory for fusion context.\n * @instance:\t\t\tAdapter soft state\n * return:\t\t\t0 for SUCCESS\n */\nstatic int megasas_alloc_ctrl_mem(struct megasas_instance *instance)\n{\n\tinstance->reply_map = kcalloc(nr_cpu_ids, sizeof(unsigned int),\n\t\t\t\t      GFP_KERNEL);\n\tif (!instance->reply_map)\n\t\treturn -ENOMEM;\n\n\tswitch (instance->adapter_type) {\n\tcase MFI_SERIES:\n\t\tif (megasas_alloc_mfi_ctrl_mem(instance))\n\t\t\tgoto fail;\n\t\tbreak;\n\tcase AERO_SERIES:\n\tcase VENTURA_SERIES:\n\tcase THUNDERBOLT_SERIES:\n\tcase INVADER_SERIES:\n\t\tif (megasas_alloc_fusion_context(instance))\n\t\t\tgoto fail;\n\t\tbreak;\n\t}\n\n\treturn 0;\n fail:\n\tkfree(instance->reply_map);\n\tinstance->reply_map = NULL;\n\treturn -ENOMEM;\n}\n\n/*\n * megasas_free_ctrl_mem -\tFree fusion context for fusion adapters and\n *\t\t\t\tproducer, consumer buffers for MFI adapters\n *\n * @instance -\t\t\tAdapter soft instance\n *\n */\nstatic inline void megasas_free_ctrl_mem(struct megasas_instance *instance)\n{\n\tkfree(instance->reply_map);\n\tif (instance->adapter_type == MFI_SERIES) {\n\t\tif (instance->producer)\n\t\t\tdma_free_coherent(&instance->pdev->dev, sizeof(u32),\n\t\t\t\t\t    instance->producer,\n\t\t\t\t\t    instance->producer_h);\n\t\tif (instance->consumer)\n\t\t\tdma_free_coherent(&instance->pdev->dev, sizeof(u32),\n\t\t\t\t\t    instance->consumer,\n\t\t\t\t\t    instance->consumer_h);\n\t} else {\n\t\tmegasas_free_fusion_context(instance);\n\t}\n}\n\n/**\n * megasas_alloc_ctrl_dma_buffers -\tAllocate consistent DMA buffers during\n *\t\t\t\t\tdriver load time\n *\n * @instance-\t\t\t\tAdapter soft instance\n * @return-\t\t\t\tO for SUCCESS\n */\nstatic inline\nint megasas_alloc_ctrl_dma_buffers(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev = instance->pdev;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\tinstance->evt_detail = dma_alloc_coherent(&pdev->dev,\n\t\t\tsizeof(struct megasas_evt_detail),\n\t\t\t&instance->evt_detail_h, GFP_KERNEL);\n\n\tif (!instance->evt_detail) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Failed to allocate event detail buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (fusion) {\n\t\tfusion->ioc_init_request =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t   sizeof(struct MPI2_IOC_INIT_REQUEST),\n\t\t\t\t\t   &fusion->ioc_init_request_phys,\n\t\t\t\t\t   GFP_KERNEL);\n\n\t\tif (!fusion->ioc_init_request) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate PD list buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tinstance->snapdump_prop = dma_alloc_coherent(&pdev->dev,\n\t\t\t\tsizeof(struct MR_SNAPDUMP_PROPERTIES),\n\t\t\t\t&instance->snapdump_prop_h, GFP_KERNEL);\n\n\t\tif (!instance->snapdump_prop)\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate snapdump properties buffer\\n\");\n\n\t\tinstance->host_device_list_buf = dma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t\t\tHOST_DEVICE_LIST_SZ,\n\t\t\t\t\t\t\t&instance->host_device_list_buf_h,\n\t\t\t\t\t\t\tGFP_KERNEL);\n\n\t\tif (!instance->host_device_list_buf) {\n\t\t\tdev_err(&pdev->dev,\n\t\t\t\t\"Failed to allocate targetid list buffer\\n\");\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t}\n\n\tinstance->pd_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),\n\t\t\t\t     &instance->pd_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->pd_list_buf) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate PD list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ctrl_info_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     sizeof(struct megasas_ctrl_info),\n\t\t\t\t     &instance->ctrl_info_buf_h, GFP_KERNEL);\n\n\tif (!instance->ctrl_info_buf) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to allocate controller info buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ld_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t     sizeof(struct MR_LD_LIST),\n\t\t\t\t     &instance->ld_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->ld_list_buf) {\n\t\tdev_err(&pdev->dev, \"Failed to allocate LD list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tinstance->ld_targetid_list_buf =\n\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\tsizeof(struct MR_LD_TARGETID_LIST),\n\t\t\t\t&instance->ld_targetid_list_buf_h, GFP_KERNEL);\n\n\tif (!instance->ld_targetid_list_buf) {\n\t\tdev_err(&pdev->dev,\n\t\t\t\"Failed to allocate LD targetid list buffer\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tif (!reset_devices) {\n\t\tinstance->system_info_buf =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_DRV_SYSTEM_INFO),\n\t\t\t\t\t&instance->system_info_h, GFP_KERNEL);\n\t\tinstance->pd_info =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_PD_INFO),\n\t\t\t\t\t&instance->pd_info_h, GFP_KERNEL);\n\t\tinstance->tgt_prop =\n\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_TARGET_PROPERTIES),\n\t\t\t\t\t&instance->tgt_prop_h, GFP_KERNEL);\n\t\tinstance->crash_dump_buf =\n\t\t\tdma_alloc_coherent(&pdev->dev, CRASH_DMA_BUF_SIZE,\n\t\t\t\t\t&instance->crash_dump_h, GFP_KERNEL);\n\n\t\tif (!instance->system_info_buf)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate system info buffer\\n\");\n\n\t\tif (!instance->pd_info)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate pd_info buffer\\n\");\n\n\t\tif (!instance->tgt_prop)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate tgt_prop buffer\\n\");\n\n\t\tif (!instance->crash_dump_buf)\n\t\t\tdev_err(&instance->pdev->dev,\n\t\t\t\t\"Failed to allocate crash dump buffer\\n\");\n\t}\n\n\treturn 0;\n}\n\n/*\n * megasas_free_ctrl_dma_buffers -\tFree consistent DMA buffers allocated\n *\t\t\t\t\tduring driver load time\n *\n * @instance-\t\t\t\tAdapter soft instance\n *\n */\nstatic inline\nvoid megasas_free_ctrl_dma_buffers(struct megasas_instance *instance)\n{\n\tstruct pci_dev *pdev = instance->pdev;\n\tstruct fusion_context *fusion = instance->ctrl_context;\n\n\tif (instance->evt_detail)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct megasas_evt_detail),\n\t\t\t\t    instance->evt_detail,\n\t\t\t\t    instance->evt_detail_h);\n\n\tif (fusion && fusion->ioc_init_request)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  sizeof(struct MPI2_IOC_INIT_REQUEST),\n\t\t\t\t  fusion->ioc_init_request,\n\t\t\t\t  fusion->ioc_init_request_phys);\n\n\tif (instance->pd_list_buf)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t    MEGASAS_MAX_PD * sizeof(struct MR_PD_LIST),\n\t\t\t\t    instance->pd_list_buf,\n\t\t\t\t    instance->pd_list_buf_h);\n\n\tif (instance->ld_list_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_LD_LIST),\n\t\t\t\t    instance->ld_list_buf,\n\t\t\t\t    instance->ld_list_buf_h);\n\n\tif (instance->ld_targetid_list_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_LD_TARGETID_LIST),\n\t\t\t\t    instance->ld_targetid_list_buf,\n\t\t\t\t    instance->ld_targetid_list_buf_h);\n\n\tif (instance->ctrl_info_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct megasas_ctrl_info),\n\t\t\t\t    instance->ctrl_info_buf,\n\t\t\t\t    instance->ctrl_info_buf_h);\n\n\tif (instance->system_info_buf)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_DRV_SYSTEM_INFO),\n\t\t\t\t    instance->system_info_buf,\n\t\t\t\t    instance->system_info_h);\n\n\tif (instance->pd_info)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_PD_INFO),\n\t\t\t\t    instance->pd_info, instance->pd_info_h);\n\n\tif (instance->tgt_prop)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_TARGET_PROPERTIES),\n\t\t\t\t    instance->tgt_prop, instance->tgt_prop_h);\n\n\tif (instance->crash_dump_buf)\n\t\tdma_free_coherent(&pdev->dev, CRASH_DMA_BUF_SIZE,\n\t\t\t\t    instance->crash_dump_buf,\n\t\t\t\t    instance->crash_dump_h);\n\n\tif (instance->snapdump_prop)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  sizeof(struct MR_SNAPDUMP_PROPERTIES),\n\t\t\t\t  instance->snapdump_prop,\n\t\t\t\t  instance->snapdump_prop_h);\n\n\tif (instance->host_device_list_buf)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t  HOST_DEVICE_LIST_SZ,\n\t\t\t\t  instance->host_device_list_buf,\n\t\t\t\t  instance->host_device_list_buf_h);\n\n}\n\n/*\n * megasas_init_ctrl_params -\t\tInitialize controller's instance\n *\t\t\t\t\tparameters before FW init\n * @instance -\t\t\t\tAdapter soft instance\n * @return -\t\t\t\tvoid\n */\nstatic inline void megasas_init_ctrl_params(struct megasas_instance *instance)\n{\n\tinstance->fw_crash_state = UNAVAILABLE;\n\n\tmegasas_poll_wait_aen = 0;\n\tinstance->issuepend_done = 1;\n\tatomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n\n\t/*\n\t * Initialize locks and queues\n\t */\n\tINIT_LIST_HEAD(&instance->cmd_pool);\n\tINIT_LIST_HEAD(&instance->internal_reset_pending_q);\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\n\tinit_waitqueue_head(&instance->int_cmd_wait_q);\n\tinit_waitqueue_head(&instance->abort_cmd_wait_q);\n\n\tspin_lock_init(&instance->crashdump_lock);\n\tspin_lock_init(&instance->mfi_pool_lock);\n\tspin_lock_init(&instance->hba_lock);\n\tspin_lock_init(&instance->stream_lock);\n\tspin_lock_init(&instance->completion_lock);\n\n\tmutex_init(&instance->reset_mutex);\n\n\tif ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0073SKINNY) ||\n\t    (instance->pdev->device == PCI_DEVICE_ID_LSI_SAS0071SKINNY))\n\t\tinstance->flag_ieee = 1;\n\n\tmegasas_dbg_lvl = 0;\n\tinstance->flag = 0;\n\tinstance->unload = 1;\n\tinstance->last_time = 0;\n\tinstance->disableOnlineCtrlReset = 1;\n\tinstance->UnevenSpanSupport = 0;\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tINIT_WORK(&instance->work_init, megasas_fusion_ocr_wq);\n\telse\n\t\tINIT_WORK(&instance->work_init, process_fw_state_change_wq);\n}\n\n/**\n * megasas_probe_one -\tPCI hotplug entry point\n * @pdev:\t\tPCI device structure\n * @id:\t\t\tPCI ids of supported hotplugged adapter\n */\nstatic int megasas_probe_one(struct pci_dev *pdev,\n\t\t\t     const struct pci_device_id *id)\n{\n\tint rval, pos;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tu16 control = 0;\n\n\tswitch (pdev->device) {\n\tcase PCI_DEVICE_ID_LSI_AERO_10E1:\n\tcase PCI_DEVICE_ID_LSI_AERO_10E5:\n\t\tdev_info(&pdev->dev, \"Adapter is in configurable secure mode\\n\");\n\t\tbreak;\n\t}\n\n\t/* Reset MSI-X in the kdump kernel */\n\tif (reset_devices) {\n\t\tpos = pci_find_capability(pdev, PCI_CAP_ID_MSIX);\n\t\tif (pos) {\n\t\t\tpci_read_config_word(pdev, pos + PCI_MSIX_FLAGS,\n\t\t\t\t\t     &control);\n\t\t\tif (control & PCI_MSIX_FLAGS_ENABLE) {\n\t\t\t\tdev_info(&pdev->dev, \"resetting MSI-X\\n\");\n\t\t\t\tpci_write_config_word(pdev,\n\t\t\t\t\t\t      pos + PCI_MSIX_FLAGS,\n\t\t\t\t\t\t      control &\n\t\t\t\t\t\t      ~PCI_MSIX_FLAGS_ENABLE);\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * PCI prepping: enable device set bus mastering and dma mask\n\t */\n\trval = pci_enable_device_mem(pdev);\n\n\tif (rval) {\n\t\treturn rval;\n\t}\n\n\tpci_set_master(pdev);\n\n\thost = scsi_host_alloc(&megasas_template,\n\t\t\t       sizeof(struct megasas_instance));\n\n\tif (!host) {\n\t\tdev_printk(KERN_DEBUG, &pdev->dev, \"scsi_host_alloc failed\\n\");\n\t\tgoto fail_alloc_instance;\n\t}\n\n\tinstance = (struct megasas_instance *)host->hostdata;\n\tmemset(instance, 0, sizeof(*instance));\n\tatomic_set(&instance->fw_reset_no_pci_access, 0);\n\n\t/*\n\t * Initialize PCI related and misc parameters\n\t */\n\tinstance->pdev = pdev;\n\tinstance->host = host;\n\tinstance->unique_id = pdev->bus->number << 8 | pdev->devfn;\n\tinstance->init_id = MEGASAS_DEFAULT_INIT_ID;\n\n\tmegasas_set_adapter_type(instance);\n\n\t/*\n\t * Initialize MFI Firmware\n\t */\n\tif (megasas_init_fw(instance))\n\t\tgoto fail_init_mfi;\n\n\tif (instance->requestorId) {\n\t\tif (instance->PlasmaFW111) {\n\t\t\tinstance->vf_affiliation_111 =\n\t\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\tsizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t\t&instance->vf_affiliation_111_h,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!instance->vf_affiliation_111)\n\t\t\t\tdev_warn(&pdev->dev, \"Can't allocate \"\n\t\t\t\t       \"memory for VF affiliation buffer\\n\");\n\t\t} else {\n\t\t\tinstance->vf_affiliation =\n\t\t\t\tdma_alloc_coherent(&pdev->dev,\n\t\t\t\t\t(MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t\tsizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t\t&instance->vf_affiliation_h,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!instance->vf_affiliation)\n\t\t\t\tdev_warn(&pdev->dev, \"Can't allocate \"\n\t\t\t\t       \"memory for VF affiliation buffer\\n\");\n\t\t}\n\t}\n\n\t/*\n\t * Store instance in PCI softstate\n\t */\n\tpci_set_drvdata(pdev, instance);\n\n\t/*\n\t * Add this controller to megasas_mgmt_info structure so that it\n\t * can be exported to management applications\n\t */\n\tmegasas_mgmt_info.count++;\n\tmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = instance;\n\tmegasas_mgmt_info.max_index++;\n\n\t/*\n\t * Register with SCSI mid-layer\n\t */\n\tif (megasas_io_attach(instance))\n\t\tgoto fail_io_attach;\n\n\tinstance->unload = 0;\n\t/*\n\t * Trigger SCSI to scan our drives\n\t */\n\tif (!instance->enable_fw_dev_list ||\n\t    (instance->host_device_list_buf->count > 0))\n\t\tscsi_scan_host(host);\n\n\t/*\n\t * Initiate AEN (Asynchronous Event Notification)\n\t */\n\tif (megasas_start_aen(instance)) {\n\t\tdev_printk(KERN_DEBUG, &pdev->dev, \"start aen failed\\n\");\n\t\tgoto fail_start_aen;\n\t}\n\n\t/* Get current SR-IOV LD/VF affiliation */\n\tif (instance->requestorId)\n\t\tmegasas_get_ld_vf_affiliation(instance, 1);\n\n\treturn 0;\n\nfail_start_aen:\nfail_io_attach:\n\tmegasas_mgmt_info.count--;\n\tmegasas_mgmt_info.max_index--;\n\tmegasas_mgmt_info.instance[megasas_mgmt_info.max_index] = NULL;\n\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_release_fusion(instance);\n\telse\n\t\tmegasas_release_mfi(instance);\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\nfail_init_mfi:\n\tscsi_host_put(host);\nfail_alloc_instance:\n\tpci_disable_device(pdev);\n\n\treturn -ENODEV;\n}\n\n/**\n * megasas_flush_cache -\tRequests FW to flush all its caches\n * @instance:\t\t\tAdapter soft state\n */\nstatic void megasas_flush_cache(struct megasas_instance *instance)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn;\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 0;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = 0;\n\tdcmd->opcode = cpu_to_le32(MR_DCMD_CTRL_CACHE_FLUSH);\n\tdcmd->mbox.b[0] = MR_FLUSH_CTRL_CACHE | MR_FLUSH_DISK_CACHE;\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS)\n\t\t\t!= DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n}\n\n/**\n * megasas_shutdown_controller -\tInstructs FW to shutdown the controller\n * @instance:\t\t\t\tAdapter soft state\n * @opcode:\t\t\t\tShutdown/Hibernate\n */\nstatic void megasas_shutdown_controller(struct megasas_instance *instance,\n\t\t\t\t\tu32 opcode)\n{\n\tstruct megasas_cmd *cmd;\n\tstruct megasas_dcmd_frame *dcmd;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR)\n\t\treturn;\n\n\tcmd = megasas_get_cmd(instance);\n\n\tif (!cmd)\n\t\treturn;\n\n\tif (instance->aen_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->aen_cmd, MFI_IO_TIMEOUT_SECS);\n\tif (instance->map_update_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->map_update_cmd, MFI_IO_TIMEOUT_SECS);\n\tif (instance->jbod_seq_cmd)\n\t\tmegasas_issue_blocked_abort_cmd(instance,\n\t\t\tinstance->jbod_seq_cmd, MFI_IO_TIMEOUT_SECS);\n\n\tdcmd = &cmd->frame->dcmd;\n\n\tmemset(dcmd->mbox.b, 0, MFI_MBOX_SIZE);\n\n\tdcmd->cmd = MFI_CMD_DCMD;\n\tdcmd->cmd_status = 0x0;\n\tdcmd->sge_count = 0;\n\tdcmd->flags = cpu_to_le16(MFI_FRAME_DIR_NONE);\n\tdcmd->timeout = 0;\n\tdcmd->pad_0 = 0;\n\tdcmd->data_xfer_len = 0;\n\tdcmd->opcode = cpu_to_le32(opcode);\n\n\tif (megasas_issue_blocked_cmd(instance, cmd, MFI_IO_TIMEOUT_SECS)\n\t\t\t!= DCMD_SUCCESS) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return from %s %d\\n\", __func__, __LINE__);\n\t\treturn;\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n}\n\n#ifdef CONFIG_PM\n/**\n * megasas_suspend -\tdriver suspend entry point\n * @pdev:\t\tPCI device structure\n * @state:\t\tPCI power state to suspend routine\n */\nstatic int\nmegasas_suspend(struct pci_dev *pdev, pm_message_t state)\n{\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\n\tinstance = pci_get_drvdata(pdev);\n\thost = instance->host;\n\tinstance->unload = 1;\n\n\t/* Shutdown SR-IOV heartbeat timer */\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\n\n\t/* Stop the FW fault detection watchdog */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_fusion_stop_watchdog(instance);\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_HIBERNATE_SHUTDOWN);\n\n\t/* cancel the delayed work if this work still in queue */\n\tif (instance->ev != NULL) {\n\t\tstruct megasas_aen_event *ev = instance->ev;\n\t\tcancel_delayed_work_sync(&ev->hotplug_work);\n\t\tinstance->ev = NULL;\n\t}\n\n\ttasklet_kill(&instance->isr_tasklet);\n\n\tpci_set_drvdata(instance->pdev, instance);\n\tinstance->instancet->disable_intr(instance);\n\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\n\tpci_save_state(pdev);\n\tpci_disable_device(pdev);\n\n\tpci_set_power_state(pdev, pci_choose_state(pdev, state));\n\n\treturn 0;\n}\n\n/**\n * megasas_resume-      driver resume entry point\n * @pdev:               PCI device structure\n */\nstatic int\nmegasas_resume(struct pci_dev *pdev)\n{\n\tint rval;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tint irq_flags = PCI_IRQ_LEGACY;\n\n\tinstance = pci_get_drvdata(pdev);\n\thost = instance->host;\n\tpci_set_power_state(pdev, PCI_D0);\n\tpci_enable_wake(pdev, PCI_D0, 0);\n\tpci_restore_state(pdev);\n\n\t/*\n\t * PCI prepping: enable device set bus mastering and dma mask\n\t */\n\trval = pci_enable_device_mem(pdev);\n\n\tif (rval) {\n\t\tdev_err(&pdev->dev, \"Enable device failed\\n\");\n\t\treturn rval;\n\t}\n\n\tpci_set_master(pdev);\n\n\t/*\n\t * We expect the FW state to be READY\n\t */\n\tif (megasas_transition_to_ready(instance, 0))\n\t\tgoto fail_ready_state;\n\n\tif (megasas_set_dma_mask(instance))\n\t\tgoto fail_set_dma_mask;\n\n\t/*\n\t * Initialize MFI Firmware\n\t */\n\n\tatomic_set(&instance->fw_outstanding, 0);\n\tatomic_set(&instance->ldio_outstanding, 0);\n\n\t/* Now re-enable MSI-X */\n\tif (instance->msix_vectors) {\n\t\tirq_flags = PCI_IRQ_MSIX;\n\t\tif (smp_affinity_enable)\n\t\t\tirq_flags |= PCI_IRQ_AFFINITY;\n\t}\n\trval = pci_alloc_irq_vectors(instance->pdev, 1,\n\t\t\t\t     instance->msix_vectors ?\n\t\t\t\t     instance->msix_vectors : 1, irq_flags);\n\tif (rval < 0)\n\t\tgoto fail_reenable_msix;\n\n\tmegasas_setup_reply_map(instance);\n\n\tif (instance->adapter_type != MFI_SERIES) {\n\t\tmegasas_reset_reply_desc(instance);\n\t\tif (megasas_ioc_init_fusion(instance)) {\n\t\t\tmegasas_free_cmds(instance);\n\t\t\tmegasas_free_cmds_fusion(instance);\n\t\t\tgoto fail_init_mfi;\n\t\t}\n\t\tif (!megasas_get_map_info(instance))\n\t\t\tmegasas_sync_map_info(instance);\n\t} else {\n\t\t*instance->producer = 0;\n\t\t*instance->consumer = 0;\n\t\tif (megasas_issue_init_mfi(instance))\n\t\t\tgoto fail_init_mfi;\n\t}\n\n\tif (megasas_get_ctrl_info(instance) != DCMD_SUCCESS)\n\t\tgoto fail_init_mfi;\n\n\ttasklet_init(&instance->isr_tasklet, instance->instancet->tasklet,\n\t\t     (unsigned long)instance);\n\n\tif (instance->msix_vectors ?\n\t\t\tmegasas_setup_irqs_msix(instance, 0) :\n\t\t\tmegasas_setup_irqs_ioapic(instance))\n\t\tgoto fail_init_mfi;\n\n\t/* Re-launch SR-IOV heartbeat timer */\n\tif (instance->requestorId) {\n\t\tif (!megasas_sriov_start_heartbeat(instance, 0))\n\t\t\tmegasas_start_timer(instance);\n\t\telse {\n\t\t\tinstance->skip_heartbeat_timer_del = 1;\n\t\t\tgoto fail_init_mfi;\n\t\t}\n\t}\n\n\tinstance->instancet->enable_intr(instance);\n\tmegasas_setup_jbod_map(instance);\n\tinstance->unload = 0;\n\n\t/*\n\t * Initiate AEN (Asynchronous Event Notification)\n\t */\n\tif (megasas_start_aen(instance))\n\t\tdev_err(&instance->pdev->dev, \"Start AEN failed\\n\");\n\n\t/* Re-launch FW fault watchdog */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tif (megasas_fusion_start_watchdog(instance) != SUCCESS)\n\t\t\tgoto fail_start_watchdog;\n\n\treturn 0;\n\nfail_start_watchdog:\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\nfail_init_mfi:\n\tmegasas_free_ctrl_dma_buffers(instance);\n\tmegasas_free_ctrl_mem(instance);\n\tscsi_host_put(host);\n\nfail_reenable_msix:\nfail_set_dma_mask:\nfail_ready_state:\n\n\tpci_disable_device(pdev);\n\n\treturn -ENODEV;\n}\n#else\n#define megasas_suspend\tNULL\n#define megasas_resume\tNULL\n#endif\n\nstatic inline int\nmegasas_wait_for_adapter_operational(struct megasas_instance *instance)\n{\n\tint wait_time = MEGASAS_RESET_WAIT_TIME * 2;\n\tint i;\n\tu8 adp_state;\n\n\tfor (i = 0; i < wait_time; i++) {\n\t\tadp_state = atomic_read(&instance->adprecovery);\n\t\tif ((adp_state == MEGASAS_HBA_OPERATIONAL) ||\n\t\t    (adp_state == MEGASAS_HW_CRITICAL_ERROR))\n\t\t\tbreak;\n\n\t\tif (!(i % MEGASAS_RESET_NOTICE_INTERVAL))\n\t\t\tdev_notice(&instance->pdev->dev, \"waiting for controller reset to finish\\n\");\n\n\t\tmsleep(1000);\n\t}\n\n\tif (adp_state != MEGASAS_HBA_OPERATIONAL) {\n\t\tdev_info(&instance->pdev->dev,\n\t\t\t \"%s HBA failed to become operational, adp_state %d\\n\",\n\t\t\t __func__, adp_state);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n/**\n * megasas_detach_one -\tPCI hot\"un\"plug entry point\n * @pdev:\t\tPCI device structure\n */\nstatic void megasas_detach_one(struct pci_dev *pdev)\n{\n\tint i;\n\tstruct Scsi_Host *host;\n\tstruct megasas_instance *instance;\n\tstruct fusion_context *fusion;\n\tu32 pd_seq_map_sz;\n\n\tinstance = pci_get_drvdata(pdev);\n\thost = instance->host;\n\tfusion = instance->ctrl_context;\n\n\t/* Shutdown SR-IOV heartbeat timer */\n\tif (instance->requestorId && !instance->skip_heartbeat_timer_del)\n\t\tdel_timer_sync(&instance->sriov_heartbeat_timer);\n\n\t/* Stop the FW fault detection watchdog */\n\tif (instance->adapter_type != MFI_SERIES)\n\t\tmegasas_fusion_stop_watchdog(instance);\n\n\tif (instance->fw_crash_state != UNAVAILABLE)\n\t\tmegasas_free_host_crash_buffer(instance);\n\tscsi_remove_host(instance->host);\n\tinstance->unload = 1;\n\n\tif (megasas_wait_for_adapter_operational(instance))\n\t\tgoto skip_firing_dcmds;\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\n\nskip_firing_dcmds:\n\t/* cancel the delayed work if this work still in queue*/\n\tif (instance->ev != NULL) {\n\t\tstruct megasas_aen_event *ev = instance->ev;\n\t\tcancel_delayed_work_sync(&ev->hotplug_work);\n\t\tinstance->ev = NULL;\n\t}\n\n\t/* cancel all wait events */\n\twake_up_all(&instance->int_cmd_wait_q);\n\n\ttasklet_kill(&instance->isr_tasklet);\n\n\t/*\n\t * Take the instance off the instance array. Note that we will not\n\t * decrement the max_index. We let this array be sparse array\n\t */\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\t\tif (megasas_mgmt_info.instance[i] == instance) {\n\t\t\tmegasas_mgmt_info.count--;\n\t\t\tmegasas_mgmt_info.instance[i] = NULL;\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tinstance->instancet->disable_intr(instance);\n\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n\n\tif (instance->adapter_type >= VENTURA_SERIES) {\n\t\tfor (i = 0; i < MAX_LOGICAL_DRIVES_EXT; ++i)\n\t\t\tkfree(fusion->stream_detect_by_ld[i]);\n\t\tkfree(fusion->stream_detect_by_ld);\n\t\tfusion->stream_detect_by_ld = NULL;\n\t}\n\n\n\tif (instance->adapter_type != MFI_SERIES) {\n\t\tmegasas_release_fusion(instance);\n\t\t\tpd_seq_map_sz = sizeof(struct MR_PD_CFG_SEQ_NUM_SYNC) +\n\t\t\t\t(sizeof(struct MR_PD_CFG_SEQ) *\n\t\t\t\t\t(MAX_PHYSICAL_DEVICES - 1));\n\t\tfor (i = 0; i < 2 ; i++) {\n\t\t\tif (fusion->ld_map[i])\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\t\t  fusion->max_map_sz,\n\t\t\t\t\t\t  fusion->ld_map[i],\n\t\t\t\t\t\t  fusion->ld_map_phys[i]);\n\t\t\tif (fusion->ld_drv_map[i]) {\n\t\t\t\tif (is_vmalloc_addr(fusion->ld_drv_map[i]))\n\t\t\t\t\tvfree(fusion->ld_drv_map[i]);\n\t\t\t\telse\n\t\t\t\t\tfree_pages((ulong)fusion->ld_drv_map[i],\n\t\t\t\t\t\t   fusion->drv_map_pages);\n\t\t\t}\n\n\t\t\tif (fusion->pd_seq_sync[i])\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tpd_seq_map_sz,\n\t\t\t\t\tfusion->pd_seq_sync[i],\n\t\t\t\t\tfusion->pd_seq_phys[i]);\n\t\t}\n\t} else {\n\t\tmegasas_release_mfi(instance);\n\t}\n\n\tif (instance->vf_affiliation)\n\t\tdma_free_coherent(&pdev->dev, (MAX_LOGICAL_DRIVES + 1) *\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION),\n\t\t\t\t    instance->vf_affiliation,\n\t\t\t\t    instance->vf_affiliation_h);\n\n\tif (instance->vf_affiliation_111)\n\t\tdma_free_coherent(&pdev->dev,\n\t\t\t\t    sizeof(struct MR_LD_VF_AFFILIATION_111),\n\t\t\t\t    instance->vf_affiliation_111,\n\t\t\t\t    instance->vf_affiliation_111_h);\n\n\tif (instance->hb_host_mem)\n\t\tdma_free_coherent(&pdev->dev, sizeof(struct MR_CTRL_HB_HOST_MEM),\n\t\t\t\t    instance->hb_host_mem,\n\t\t\t\t    instance->hb_host_mem_h);\n\n\tmegasas_free_ctrl_dma_buffers(instance);\n\n\tmegasas_free_ctrl_mem(instance);\n\n\tscsi_host_put(host);\n\n\tpci_disable_device(pdev);\n}\n\n/**\n * megasas_shutdown -\tShutdown entry point\n * @device:\t\tGeneric device structure\n */\nstatic void megasas_shutdown(struct pci_dev *pdev)\n{\n\tstruct megasas_instance *instance = pci_get_drvdata(pdev);\n\n\tinstance->unload = 1;\n\n\tif (megasas_wait_for_adapter_operational(instance))\n\t\tgoto skip_firing_dcmds;\n\n\tmegasas_flush_cache(instance);\n\tmegasas_shutdown_controller(instance, MR_DCMD_CTRL_SHUTDOWN);\n\nskip_firing_dcmds:\n\tinstance->instancet->disable_intr(instance);\n\tmegasas_destroy_irqs(instance);\n\n\tif (instance->msix_vectors)\n\t\tpci_free_irq_vectors(instance->pdev);\n}\n\n/**\n * megasas_mgmt_open -\tchar node \"open\" entry point\n */\nstatic int megasas_mgmt_open(struct inode *inode, struct file *filep)\n{\n\t/*\n\t * Allow only those users with admin rights\n\t */\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EACCES;\n\n\treturn 0;\n}\n\n/**\n * megasas_mgmt_fasync -\tAsync notifier registration from applications\n *\n * This function adds the calling process to a driver global queue. When an\n * event occurs, SIGIO will be sent to all processes in this queue.\n */\nstatic int megasas_mgmt_fasync(int fd, struct file *filep, int mode)\n{\n\tint rc;\n\n\tmutex_lock(&megasas_async_queue_mutex);\n\n\trc = fasync_helper(fd, filep, mode, &megasas_async_queue);\n\n\tmutex_unlock(&megasas_async_queue_mutex);\n\n\tif (rc >= 0) {\n\t\t/* For sanity check when we get ioctl */\n\t\tfilep->private_data = filep;\n\t\treturn 0;\n\t}\n\n\tprintk(KERN_DEBUG \"megasas: fasync_helper failed [%d]\\n\", rc);\n\n\treturn rc;\n}\n\n/**\n * megasas_mgmt_poll -  char node \"poll\" entry point\n * */\nstatic __poll_t megasas_mgmt_poll(struct file *file, poll_table *wait)\n{\n\t__poll_t mask;\n\tunsigned long flags;\n\n\tpoll_wait(file, &megasas_poll_wait, wait);\n\tspin_lock_irqsave(&poll_aen_lock, flags);\n\tif (megasas_poll_wait_aen)\n\t\tmask = (EPOLLIN | EPOLLRDNORM);\n\telse\n\t\tmask = 0;\n\tmegasas_poll_wait_aen = 0;\n\tspin_unlock_irqrestore(&poll_aen_lock, flags);\n\treturn mask;\n}\n\n/*\n * megasas_set_crash_dump_params_ioctl:\n *\t\tSend CRASH_DUMP_MODE DCMD to all controllers\n * @cmd:\tMFI command frame\n */\n\nstatic int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)\n{\n\tstruct megasas_instance *local_instance;\n\tint i, error = 0;\n\tint crash_support;\n\n\tcrash_support = cmd->frame->dcmd.mbox.w[0];\n\n\tfor (i = 0; i < megasas_mgmt_info.max_index; i++) {\n\t\tlocal_instance = megasas_mgmt_info.instance[i];\n\t\tif (local_instance && local_instance->crash_dump_drv_support) {\n\t\t\tif ((atomic_read(&local_instance->adprecovery) ==\n\t\t\t\tMEGASAS_HBA_OPERATIONAL) &&\n\t\t\t\t!megasas_set_crash_dump_params(local_instance,\n\t\t\t\t\tcrash_support)) {\n\t\t\t\tlocal_instance->crash_dump_app_support =\n\t\t\t\t\tcrash_support;\n\t\t\t\tdev_info(&local_instance->pdev->dev,\n\t\t\t\t\t\"Application firmware crash \"\n\t\t\t\t\t\"dump mode set success\\n\");\n\t\t\t\terror = 0;\n\t\t\t} else {\n\t\t\t\tdev_info(&local_instance->pdev->dev,\n\t\t\t\t\t\"Application firmware crash \"\n\t\t\t\t\t\"dump mode set failed\\n\");\n\t\t\t\terror = -1;\n\t\t\t}\n\t\t}\n\t}\n\treturn error;\n}\n\n/**\n * megasas_mgmt_fw_ioctl -\tIssues management ioctls to FW\n * @instance:\t\t\tAdapter soft state\n * @argp:\t\t\tUser's ioctl packet\n */\nstatic int\nmegasas_mgmt_fw_ioctl(struct megasas_instance *instance,\n\t\t      struct megasas_iocpacket __user * user_ioc,\n\t\t      struct megasas_iocpacket *ioc)\n{\n\tstruct megasas_sge64 *kern_sge64 = NULL;\n\tstruct megasas_sge32 *kern_sge32 = NULL;\n\tstruct megasas_cmd *cmd;\n\tvoid *kbuff_arr[MAX_IOCTL_SGE];\n\tdma_addr_t buf_handle = 0;\n\tint error = 0, i;\n\tvoid *sense = NULL;\n\tdma_addr_t sense_handle;\n\tunsigned long *sense_ptr;\n\tu32 opcode = 0;\n\n\tmemset(kbuff_arr, 0, sizeof(kbuff_arr));\n\n\tif (ioc->sge_count > MAX_IOCTL_SGE) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"SGE count [%d] >  max limit [%d]\\n\",\n\t\t       ioc->sge_count, MAX_IOCTL_SGE);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((ioc->frame.hdr.cmd >= MFI_CMD_OP_COUNT) ||\n\t    ((ioc->frame.hdr.cmd == MFI_CMD_NVME) &&\n\t    !instance->support_nvme_passthru)) {\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"Received invalid ioctl command 0x%x\\n\",\n\t\t\tioc->frame.hdr.cmd);\n\t\treturn -ENOTSUPP;\n\t}\n\n\tcmd = megasas_get_cmd(instance);\n\tif (!cmd) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to get a cmd packet\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * User's IOCTL packet has 2 frames (maximum). Copy those two\n\t * frames into our cmd's frames. cmd->frame's context will get\n\t * overwritten when we copy from user's frames. So set that value\n\t * alone separately\n\t */\n\tmemcpy(cmd->frame, ioc->frame.raw, 2 * MEGAMFI_FRAME_SIZE);\n\tcmd->frame->hdr.context = cpu_to_le32(cmd->index);\n\tcmd->frame->hdr.pad_0 = 0;\n\n\tcmd->frame->hdr.flags &= (~MFI_FRAME_IEEE);\n\n\tif (instance->consistent_mask_64bit)\n\t\tcmd->frame->hdr.flags |= cpu_to_le16((MFI_FRAME_SGL64 |\n\t\t\t\t       MFI_FRAME_SENSE64));\n\telse\n\t\tcmd->frame->hdr.flags &= cpu_to_le16(~(MFI_FRAME_SGL64 |\n\t\t\t\t\t       MFI_FRAME_SENSE64));\n\n\tif (cmd->frame->hdr.cmd == MFI_CMD_DCMD)\n\t\topcode = le32_to_cpu(cmd->frame->dcmd.opcode);\n\n\tif (opcode == MR_DCMD_CTRL_SHUTDOWN) {\n\t\tif (megasas_get_ctrl_info(instance) != DCMD_SUCCESS) {\n\t\t\tmegasas_return_cmd(instance, cmd);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (opcode == MR_DRIVER_SET_APP_CRASHDUMP_MODE) {\n\t\terror = megasas_set_crash_dump_params_ioctl(cmd);\n\t\tmegasas_return_cmd(instance, cmd);\n\t\treturn error;\n\t}\n\n\t/*\n\t * The management interface between applications and the fw uses\n\t * MFI frames. E.g, RAID configuration changes, LD property changes\n\t * etc are accomplishes through different kinds of MFI frames. The\n\t * driver needs to care only about substituting user buffers with\n\t * kernel buffers in SGLs. The location of SGL is embedded in the\n\t * struct iocpacket itself.\n\t */\n\tif (instance->consistent_mask_64bit)\n\t\tkern_sge64 = (struct megasas_sge64 *)\n\t\t\t((unsigned long)cmd->frame + ioc->sgl_off);\n\telse\n\t\tkern_sge32 = (struct megasas_sge32 *)\n\t\t\t((unsigned long)cmd->frame + ioc->sgl_off);\n\n\t/*\n\t * For each user buffer, create a mirror buffer and copy in\n\t */\n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (!ioc->sgl[i].iov_len)\n\t\t\tcontinue;\n\n\t\tkbuff_arr[i] = dma_alloc_coherent(&instance->pdev->dev,\n\t\t\t\t\t\t    ioc->sgl[i].iov_len,\n\t\t\t\t\t\t    &buf_handle, GFP_KERNEL);\n\t\tif (!kbuff_arr[i]) {\n\t\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Failed to alloc \"\n\t\t\t       \"kernel SGL buffer for IOCTL\\n\");\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\t/*\n\t\t * We don't change the dma_coherent_mask, so\n\t\t * dma_alloc_coherent only returns 32bit addresses\n\t\t */\n\t\tif (instance->consistent_mask_64bit) {\n\t\t\tkern_sge64[i].phys_addr = cpu_to_le64(buf_handle);\n\t\t\tkern_sge64[i].length = cpu_to_le32(ioc->sgl[i].iov_len);\n\t\t} else {\n\t\t\tkern_sge32[i].phys_addr = cpu_to_le32(buf_handle);\n\t\t\tkern_sge32[i].length = cpu_to_le32(ioc->sgl[i].iov_len);\n\t\t}\n\n\t\t/*\n\t\t * We created a kernel buffer corresponding to the\n\t\t * user buffer. Now copy in from the user buffer\n\t\t */\n\t\tif (copy_from_user(kbuff_arr[i], ioc->sgl[i].iov_base,\n\t\t\t\t   (u32) (ioc->sgl[i].iov_len))) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (ioc->sense_len) {\n\t\tsense = dma_alloc_coherent(&instance->pdev->dev, ioc->sense_len,\n\t\t\t\t\t     &sense_handle, GFP_KERNEL);\n\t\tif (!sense) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsense_ptr =\n\t\t(unsigned long *) ((unsigned long)cmd->frame + ioc->sense_off);\n\t\tif (instance->consistent_mask_64bit)\n\t\t\t*sense_ptr = cpu_to_le64(sense_handle);\n\t\telse\n\t\t\t*sense_ptr = cpu_to_le32(sense_handle);\n\t}\n\n\t/*\n\t * Set the sync_cmd flag so that the ISR knows not to complete this\n\t * cmd to the SCSI mid-layer\n\t */\n\tcmd->sync_cmd = 1;\n\tif (megasas_issue_blocked_cmd(instance, cmd, 0) == DCMD_NOT_FIRED) {\n\t\tcmd->sync_cmd = 0;\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"return -EBUSY from %s %d cmd 0x%x opcode 0x%x cmd->cmd_status_drv 0x%x\\n\",\n\t\t\t__func__, __LINE__, cmd->frame->hdr.cmd, opcode,\n\t\t\tcmd->cmd_status_drv);\n\t\treturn -EBUSY;\n\t}\n\n\tcmd->sync_cmd = 0;\n\n\tif (instance->unload == 1) {\n\t\tdev_info(&instance->pdev->dev, \"Driver unload is in progress \"\n\t\t\t\"don't submit data to application\\n\");\n\t\tgoto out;\n\t}\n\t/*\n\t * copy out the kernel buffers to user buffers\n\t */\n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (copy_to_user(ioc->sgl[i].iov_base, kbuff_arr[i],\n\t\t\t\t ioc->sgl[i].iov_len)) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * copy out the sense\n\t */\n\tif (ioc->sense_len) {\n\t\t/*\n\t\t * sense_ptr points to the location that has the user\n\t\t * sense buffer address\n\t\t */\n\t\tsense_ptr = (unsigned long *) ((unsigned long)ioc->frame.raw +\n\t\t\t\tioc->sense_off);\n\n\t\tif (copy_to_user((void __user *)((unsigned long)\n\t\t\t\t get_unaligned((unsigned long *)sense_ptr)),\n\t\t\t\t sense, ioc->sense_len)) {\n\t\t\tdev_err(&instance->pdev->dev, \"Failed to copy out to user \"\n\t\t\t\t\t\"sense data\\n\");\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/*\n\t * copy the status codes returned by the fw\n\t */\n\tif (copy_to_user(&user_ioc->frame.hdr.cmd_status,\n\t\t\t &cmd->frame->hdr.cmd_status, sizeof(u8))) {\n\t\tdev_printk(KERN_DEBUG, &instance->pdev->dev, \"Error copying out cmd_status\\n\");\n\t\terror = -EFAULT;\n\t}\n\nout:\n\tif (sense) {\n\t\tdma_free_coherent(&instance->pdev->dev, ioc->sense_len,\n\t\t\t\t    sense, sense_handle);\n\t}\n\n\tfor (i = 0; i < ioc->sge_count; i++) {\n\t\tif (kbuff_arr[i]) {\n\t\t\tif (instance->consistent_mask_64bit)\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tle32_to_cpu(kern_sge64[i].length),\n\t\t\t\t\tkbuff_arr[i],\n\t\t\t\t\tle64_to_cpu(kern_sge64[i].phys_addr));\n\t\t\telse\n\t\t\t\tdma_free_coherent(&instance->pdev->dev,\n\t\t\t\t\tle32_to_cpu(kern_sge32[i].length),\n\t\t\t\t\tkbuff_arr[i],\n\t\t\t\t\tle32_to_cpu(kern_sge32[i].phys_addr));\n\t\t\tkbuff_arr[i] = NULL;\n\t\t}\n\t}\n\n\tmegasas_return_cmd(instance, cmd);\n\treturn error;\n}\n\nstatic int megasas_mgmt_ioctl_fw(struct file *file, unsigned long arg)\n{\n\tstruct megasas_iocpacket __user *user_ioc =\n\t    (struct megasas_iocpacket __user *)arg;\n\tstruct megasas_iocpacket *ioc;\n\tstruct megasas_instance *instance;\n\tint error;\n\n\tioc = memdup_user(user_ioc, sizeof(*ioc));\n\tif (IS_ERR(ioc))\n\t\treturn PTR_ERR(ioc);\n\n\tinstance = megasas_lookup_instance(ioc->host_no);\n\tif (!instance) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\t/* Block ioctls in VF mode */\n\tif (instance->requestorId && !allow_vf_ioctls) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\tdev_err(&instance->pdev->dev, \"Controller in crit error\\n\");\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (instance->unload == 1) {\n\t\terror = -ENODEV;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif (down_interruptible(&instance->ioctl_sem)) {\n\t\terror = -ERESTARTSYS;\n\t\tgoto out_kfree_ioc;\n\t}\n\n\tif  (megasas_wait_for_adapter_operational(instance)) {\n\t\terror = -ENODEV;\n\t\tgoto out_up;\n\t}\n\n\terror = megasas_mgmt_fw_ioctl(instance, user_ioc, ioc);\nout_up:\n\tup(&instance->ioctl_sem);\n\nout_kfree_ioc:\n\tkfree(ioc);\n\treturn error;\n}\n\nstatic int megasas_mgmt_ioctl_aen(struct file *file, unsigned long arg)\n{\n\tstruct megasas_instance *instance;\n\tstruct megasas_aen aen;\n\tint error;\n\n\tif (file->private_data != file) {\n\t\tprintk(KERN_DEBUG \"megasas: fasync_helper was not \"\n\t\t       \"called first\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (copy_from_user(&aen, (void __user *)arg, sizeof(aen)))\n\t\treturn -EFAULT;\n\n\tinstance = megasas_lookup_instance(aen.host_no);\n\n\tif (!instance)\n\t\treturn -ENODEV;\n\n\tif (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n\t\treturn -ENODEV;\n\t}\n\n\tif (instance->unload == 1) {\n\t\treturn -ENODEV;\n\t}\n\n\tif  (megasas_wait_for_adapter_operational(instance))\n\t\treturn -ENODEV;\n\n\tmutex_lock(&instance->reset_mutex);\n\terror = megasas_register_aen(instance, aen.seq_num,\n\t\t\t\t     aen.class_locale_word);\n\tmutex_unlock(&instance->reset_mutex);\n\treturn error;\n}\n\n/**\n * megasas_mgmt_ioctl -\tchar node ioctl entry point\n */\nstatic long\nmegasas_mgmt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase MEGASAS_IOC_FIRMWARE:\n\t\treturn megasas_mgmt_ioctl_fw(file, arg);\n\n\tcase MEGASAS_IOC_GET_AEN:\n\t\treturn megasas_mgmt_ioctl_aen(file, arg);\n\t}\n\n\treturn -ENOTTY;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int megasas_mgmt_compat_ioctl_fw(struct file *file, unsigned long arg)\n{\n\tstruct compat_megasas_iocpacket __user *cioc =\n\t    (struct compat_megasas_iocpacket __user *)arg;\n\tstruct megasas_iocpacket __user *ioc =\n\t    compat_alloc_user_space(sizeof(struct megasas_iocpacket));\n\tint i;\n\tint error = 0;\n\tcompat_uptr_t ptr;\n\tu32 local_sense_off;\n\tu32 local_sense_len;\n\tu32 user_sense_off;\n\n\tif (clear_user(ioc, sizeof(*ioc)))\n\t\treturn -EFAULT;\n\n\tif (copy_in_user(&ioc->host_no, &cioc->host_no, sizeof(u16)) ||\n\t    copy_in_user(&ioc->sgl_off, &cioc->sgl_off, sizeof(u32)) ||\n\t    copy_in_user(&ioc->sense_off, &cioc->sense_off, sizeof(u32)) ||\n\t    copy_in_user(&ioc->sense_len, &cioc->sense_len, sizeof(u32)) ||\n\t    copy_in_user(ioc->frame.raw, cioc->frame.raw, 128) ||\n\t    copy_in_user(&ioc->sge_count, &cioc->sge_count, sizeof(u32)))\n\t\treturn -EFAULT;\n\n\t/*\n\t * The sense_ptr is used in megasas_mgmt_fw_ioctl only when\n\t * sense_len is not null, so prepare the 64bit value under\n\t * the same condition.\n\t */\n\tif (get_user(local_sense_off, &ioc->sense_off) ||\n\t\tget_user(local_sense_len, &ioc->sense_len) ||\n\t\tget_user(user_sense_off, &cioc->sense_off))\n\t\treturn -EFAULT;\n\n\tif (local_sense_off != user_sense_off)\n\t\treturn -EINVAL;\n\n\tif (local_sense_len) {\n\t\tvoid __user **sense_ioc_ptr =\n\t\t\t(void __user **)((u8 *)((unsigned long)&ioc->frame.raw) + local_sense_off);\n\t\tcompat_uptr_t *sense_cioc_ptr =\n\t\t\t(compat_uptr_t *)(((unsigned long)&cioc->frame.raw) + user_sense_off);\n\t\tif (get_user(ptr, sense_cioc_ptr) ||\n\t\t    put_user(compat_ptr(ptr), sense_ioc_ptr))\n\t\t\treturn -EFAULT;\n\t}\n\n\tfor (i = 0; i < MAX_IOCTL_SGE; i++) {\n\t\tif (get_user(ptr, &cioc->sgl[i].iov_base) ||\n\t\t    put_user(compat_ptr(ptr), &ioc->sgl[i].iov_base) ||\n\t\t    copy_in_user(&ioc->sgl[i].iov_len,\n\t\t\t\t &cioc->sgl[i].iov_len, sizeof(compat_size_t)))\n\t\t\treturn -EFAULT;\n\t}\n\n\terror = megasas_mgmt_ioctl_fw(file, (unsigned long)ioc);\n\n\tif (copy_in_user(&cioc->frame.hdr.cmd_status,\n\t\t\t &ioc->frame.hdr.cmd_status, sizeof(u8))) {\n\t\tprintk(KERN_DEBUG \"megasas: error copy_in_user cmd_status\\n\");\n\t\treturn -EFAULT;\n\t}\n\treturn error;\n}\n\nstatic long\nmegasas_mgmt_compat_ioctl(struct file *file, unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tswitch (cmd) {\n\tcase MEGASAS_IOC_FIRMWARE32:\n\t\treturn megasas_mgmt_compat_ioctl_fw(file, arg);\n\tcase MEGASAS_IOC_GET_AEN:\n\t\treturn megasas_mgmt_ioctl_aen(file, arg);\n\t}\n\n\treturn -ENOTTY;\n}\n#endif\n\n/*\n * File operations structure for management interface\n */\nstatic const struct file_operations megasas_mgmt_fops = {\n\t.owner = THIS_MODULE,\n\t.open = megasas_mgmt_open,\n\t.fasync = megasas_mgmt_fasync,\n\t.unlocked_ioctl = megasas_mgmt_ioctl,\n\t.poll = megasas_mgmt_poll,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = megasas_mgmt_compat_ioctl,\n#endif\n\t.llseek = noop_llseek,\n};\n\n/*\n * PCI hotplug support registration structure\n */\nstatic struct pci_driver megasas_pci_driver = {\n\n\t.name = \"megaraid_sas\",\n\t.id_table = megasas_pci_table,\n\t.probe = megasas_probe_one,\n\t.remove = megasas_detach_one,\n\t.suspend = megasas_suspend,\n\t.resume = megasas_resume,\n\t.shutdown = megasas_shutdown,\n};\n\n/*\n * Sysfs driver attributes\n */\nstatic ssize_t version_show(struct device_driver *dd, char *buf)\n{\n\treturn snprintf(buf, strlen(MEGASAS_VERSION) + 2, \"%s\\n\",\n\t\t\tMEGASAS_VERSION);\n}\nstatic DRIVER_ATTR_RO(version);\n\nstatic ssize_t release_date_show(struct device_driver *dd, char *buf)\n{\n\treturn snprintf(buf, strlen(MEGASAS_RELDATE) + 2, \"%s\\n\",\n\t\tMEGASAS_RELDATE);\n}\nstatic DRIVER_ATTR_RO(release_date);\n\nstatic ssize_t support_poll_for_event_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_poll_for_event);\n}\nstatic DRIVER_ATTR_RO(support_poll_for_event);\n\nstatic ssize_t support_device_change_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_device_change);\n}\nstatic DRIVER_ATTR_RO(support_device_change);\n\nstatic ssize_t dbg_lvl_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", megasas_dbg_lvl);\n}\n\nstatic ssize_t dbg_lvl_store(struct device_driver *dd, const char *buf,\n\t\t\t     size_t count)\n{\n\tint retval = count;\n\n\tif (sscanf(buf, \"%u\", &megasas_dbg_lvl) < 1) {\n\t\tprintk(KERN_ERR \"megasas: could not set dbg_lvl\\n\");\n\t\tretval = -EINVAL;\n\t}\n\treturn retval;\n}\nstatic DRIVER_ATTR_RW(dbg_lvl);\n\nstatic ssize_t\nsupport_nvme_encapsulation_show(struct device_driver *dd, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", support_nvme_encapsulation);\n}\n\nstatic DRIVER_ATTR_RO(support_nvme_encapsulation);\n\nstatic inline void megasas_remove_scsi_device(struct scsi_device *sdev)\n{\n\tsdev_printk(KERN_INFO, sdev, \"SCSI device is removed\\n\");\n\tscsi_remove_device(sdev);\n\tscsi_device_put(sdev);\n}\n\n/**\n * megasas_update_device_list -\tUpdate the PD and LD device list from FW\n *\t\t\t\tafter an AEN event notification\n * @instance:\t\t\tAdapter soft state\n * @event_type:\t\t\tIndicates type of event (PD or LD event)\n *\n * @return:\t\t\tSuccess or failure\n *\n * Issue DCMDs to Firmware to update the internal device list in driver.\n * Based on the FW support, driver sends the HOST_DEVICE_LIST or combination\n * of PD_LIST/LD_LIST_QUERY DCMDs to get the device list.\n */\nstatic\nint megasas_update_device_list(struct megasas_instance *instance,\n\t\t\t       int event_type)\n{\n\tint dcmd_ret = DCMD_SUCCESS;\n\n\tif (instance->enable_fw_dev_list) {\n\t\tdcmd_ret = megasas_host_device_list_query(instance, false);\n\t\tif (dcmd_ret != DCMD_SUCCESS)\n\t\t\tgoto out;\n\t} else {\n\t\tif (event_type & SCAN_PD_CHANNEL) {\n\t\t\tdcmd_ret = megasas_get_pd_list(instance);\n\n\t\t\tif (dcmd_ret != DCMD_SUCCESS)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tif (event_type & SCAN_VD_CHANNEL) {\n\t\t\tif (!instance->requestorId ||\n\t\t\t    (instance->requestorId &&\n\t\t\t     megasas_get_ld_vf_affiliation(instance, 0))) {\n\t\t\t\tdcmd_ret = megasas_ld_list_query(instance,\n\t\t\t\t\t\tMR_LD_QUERY_TYPE_EXPOSED_TO_HOST);\n\t\t\t\tif (dcmd_ret != DCMD_SUCCESS)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\treturn dcmd_ret;\n}\n\n/**\n * megasas_add_remove_devices -\tAdd/remove devices to SCSI mid-layer\n *\t\t\t\tafter an AEN event notification\n * @instance:\t\t\tAdapter soft state\n * @scan_type:\t\t\tIndicates type of devices (PD/LD) to add\n * @return\t\t\tvoid\n */\nstatic\nvoid megasas_add_remove_devices(struct megasas_instance *instance,\n\t\t\t\tint scan_type)\n{\n\tint i, j;\n\tu16 pd_index = 0;\n\tu16 ld_index = 0;\n\tu16 channel = 0, id = 0;\n\tstruct Scsi_Host *host;\n\tstruct scsi_device *sdev1;\n\tstruct MR_HOST_DEVICE_LIST *targetid_list = NULL;\n\tstruct MR_HOST_DEVICE_LIST_ENTRY *targetid_entry = NULL;\n\n\thost = instance->host;\n\n\tif (instance->enable_fw_dev_list) {\n\t\ttargetid_list = instance->host_device_list_buf;\n\t\tfor (i = 0; i < targetid_list->count; i++) {\n\t\t\ttargetid_entry = &targetid_list->host_device_list[i];\n\t\t\tif (targetid_entry->flags.u.bits.is_sys_pd) {\n\t\t\t\tchannel = le16_to_cpu(targetid_entry->target_id) /\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t\tid = le16_to_cpu(targetid_entry->target_id) %\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t} else {\n\t\t\t\tchannel = MEGASAS_MAX_PD_CHANNELS +\n\t\t\t\t\t  (le16_to_cpu(targetid_entry->target_id) /\n\t\t\t\t\t   MEGASAS_MAX_DEV_PER_CHANNEL);\n\t\t\t\tid = le16_to_cpu(targetid_entry->target_id) %\n\t\t\t\t\t\tMEGASAS_MAX_DEV_PER_CHANNEL;\n\t\t\t}\n\t\t\tsdev1 = scsi_device_lookup(host, channel, id, 0);\n\t\t\tif (!sdev1) {\n\t\t\t\tscsi_add_device(host, channel, id, 0);\n\t\t\t} else {\n\t\t\t\tscsi_device_put(sdev1);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scan_type & SCAN_PD_CHANNEL) {\n\t\tfor (i = 0; i < MEGASAS_MAX_PD_CHANNELS; i++) {\n\t\t\tfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\n\t\t\t\tpd_index = i * MEGASAS_MAX_DEV_PER_CHANNEL + j;\n\t\t\t\tsdev1 = scsi_device_lookup(host, i, j, 0);\n\t\t\t\tif (instance->pd_list[pd_index].driveState ==\n\t\t\t\t\t\t\tMR_PD_STATE_SYSTEM) {\n\t\t\t\t\tif (!sdev1)\n\t\t\t\t\t\tscsi_add_device(host, i, j, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tscsi_device_put(sdev1);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdev1)\n\t\t\t\t\t\tmegasas_remove_scsi_device(sdev1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (scan_type & SCAN_VD_CHANNEL) {\n\t\tfor (i = 0; i < MEGASAS_MAX_LD_CHANNELS; i++) {\n\t\t\tfor (j = 0; j < MEGASAS_MAX_DEV_PER_CHANNEL; j++) {\n\t\t\t\tld_index = (i * MEGASAS_MAX_DEV_PER_CHANNEL) + j;\n\t\t\t\tsdev1 = scsi_device_lookup(host,\n\t\t\t\t\t\tMEGASAS_MAX_PD_CHANNELS + i, j, 0);\n\t\t\t\tif (instance->ld_ids[ld_index] != 0xff) {\n\t\t\t\t\tif (!sdev1)\n\t\t\t\t\t\tscsi_add_device(host, MEGASAS_MAX_PD_CHANNELS + i, j, 0);\n\t\t\t\t\telse\n\t\t\t\t\t\tscsi_device_put(sdev1);\n\t\t\t\t} else {\n\t\t\t\t\tif (sdev1)\n\t\t\t\t\t\tmegasas_remove_scsi_device(sdev1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nstatic void\nmegasas_aen_polling(struct work_struct *work)\n{\n\tstruct megasas_aen_event *ev =\n\t\tcontainer_of(work, struct megasas_aen_event, hotplug_work.work);\n\tstruct megasas_instance *instance = ev->instance;\n\tunion megasas_evt_class_locale class_locale;\n\tint event_type = 0;\n\tu32 seq_num, wait_time = MEGASAS_RESET_WAIT_TIME;\n\tint error;\n\tu8  dcmd_ret = DCMD_SUCCESS;\n\n\tif (!instance) {\n\t\tprintk(KERN_ERR \"invalid instance!\\n\");\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\t/* Adjust event workqueue thread wait time for VF mode */\n\tif (instance->requestorId)\n\t\twait_time = MEGASAS_ROUTINE_WAIT_TIME_VF;\n\n\t/* Don't run the event workqueue thread if OCR is running */\n\tmutex_lock(&instance->reset_mutex);\n\n\tinstance->ev = NULL;\n\tif (instance->evt_detail) {\n\t\tmegasas_decode_evt(instance);\n\n\t\tswitch (le32_to_cpu(instance->evt_detail->code)) {\n\n\t\tcase MR_EVT_PD_INSERTED:\n\t\tcase MR_EVT_PD_REMOVED:\n\t\t\tevent_type = SCAN_PD_CHANNEL;\n\t\t\tbreak;\n\n\t\tcase MR_EVT_LD_OFFLINE:\n\t\tcase MR_EVT_CFG_CLEARED:\n\t\tcase MR_EVT_LD_DELETED:\n\t\tcase MR_EVT_LD_CREATED:\n\t\t\tevent_type = SCAN_VD_CHANNEL;\n\t\t\tbreak;\n\n\t\tcase MR_EVT_CTRL_HOST_BUS_SCAN_REQUESTED:\n\t\tcase MR_EVT_FOREIGN_CFG_IMPORTED:\n\t\tcase MR_EVT_LD_STATE_CHANGE:\n\t\t\tevent_type = SCAN_PD_CHANNEL | SCAN_VD_CHANNEL;\n\t\t\tdev_info(&instance->pdev->dev, \"scanning for scsi%d...\\n\",\n\t\t\t\tinstance->host->host_no);\n\t\t\tbreak;\n\n\t\tcase MR_EVT_CTRL_PROP_CHANGED:\n\t\t\tdcmd_ret = megasas_get_ctrl_info(instance);\n\t\t\tif (dcmd_ret == DCMD_SUCCESS &&\n\t\t\t    instance->snapdump_wait_time) {\n\t\t\t\tmegasas_get_snapdump_properties(instance);\n\t\t\t\tdev_info(&instance->pdev->dev,\n\t\t\t\t\t \"Snap dump wait time\\t: %d\\n\",\n\t\t\t\t\t instance->snapdump_wait_time);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tevent_type = 0;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tdev_err(&instance->pdev->dev, \"invalid evt_detail!\\n\");\n\t\tmutex_unlock(&instance->reset_mutex);\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\tif (event_type)\n\t\tdcmd_ret = megasas_update_device_list(instance, event_type);\n\n\tmutex_unlock(&instance->reset_mutex);\n\n\tif (event_type && dcmd_ret == DCMD_SUCCESS)\n\t\tmegasas_add_remove_devices(instance, event_type);\n\n\tif (dcmd_ret == DCMD_SUCCESS)\n\t\tseq_num = le32_to_cpu(instance->evt_detail->seq_num) + 1;\n\telse\n\t\tseq_num = instance->last_seq_num;\n\n\t/* Register AEN with FW for latest sequence number plus 1 */\n\tclass_locale.members.reserved = 0;\n\tclass_locale.members.locale = MR_EVT_LOCALE_ALL;\n\tclass_locale.members.class = MR_EVT_CLASS_DEBUG;\n\n\tif (instance->aen_cmd != NULL) {\n\t\tkfree(ev);\n\t\treturn;\n\t}\n\n\tmutex_lock(&instance->reset_mutex);\n\terror = megasas_register_aen(instance, seq_num,\n\t\t\t\t\tclass_locale.word);\n\tif (error)\n\t\tdev_err(&instance->pdev->dev,\n\t\t\t\"register aen failed error %x\\n\", error);\n\n\tmutex_unlock(&instance->reset_mutex);\n\tkfree(ev);\n}\n\n/**\n * megasas_init - Driver load entry point\n */\nstatic int __init megasas_init(void)\n{\n\tint rval;\n\n\t/*\n\t * Booted in kdump kernel, minimize memory footprints by\n\t * disabling few features\n\t */\n\tif (reset_devices) {\n\t\tmsix_vectors = 1;\n\t\trdpq_enable = 0;\n\t\tdual_qdepth_disable = 1;\n\t}\n\n\t/*\n\t * Announce driver version and other information\n\t */\n\tpr_info(\"megasas: %s\\n\", MEGASAS_VERSION);\n\n\tspin_lock_init(&poll_aen_lock);\n\n\tsupport_poll_for_event = 2;\n\tsupport_device_change = 1;\n\tsupport_nvme_encapsulation = true;\n\n\tmemset(&megasas_mgmt_info, 0, sizeof(megasas_mgmt_info));\n\n\t/*\n\t * Register character device node\n\t */\n\trval = register_chrdev(0, \"megaraid_sas_ioctl\", &megasas_mgmt_fops);\n\n\tif (rval < 0) {\n\t\tprintk(KERN_DEBUG \"megasas: failed to open device node\\n\");\n\t\treturn rval;\n\t}\n\n\tmegasas_mgmt_majorno = rval;\n\n\t/*\n\t * Register ourselves as PCI hotplug module\n\t */\n\trval = pci_register_driver(&megasas_pci_driver);\n\n\tif (rval) {\n\t\tprintk(KERN_DEBUG \"megasas: PCI hotplug registration failed \\n\");\n\t\tgoto err_pcidrv;\n\t}\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_version);\n\tif (rval)\n\t\tgoto err_dcf_attr_ver;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_release_date);\n\tif (rval)\n\t\tgoto err_dcf_rel_date;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t&driver_attr_support_poll_for_event);\n\tif (rval)\n\t\tgoto err_dcf_support_poll_for_event;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_dbg_lvl);\n\tif (rval)\n\t\tgoto err_dcf_dbg_lvl;\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t&driver_attr_support_device_change);\n\tif (rval)\n\t\tgoto err_dcf_support_device_change;\n\n\trval = driver_create_file(&megasas_pci_driver.driver,\n\t\t\t\t  &driver_attr_support_nvme_encapsulation);\n\tif (rval)\n\t\tgoto err_dcf_support_nvme_encapsulation;\n\n\treturn rval;\n\nerr_dcf_support_nvme_encapsulation:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_device_change);\n\nerr_dcf_support_device_change:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_dbg_lvl);\nerr_dcf_dbg_lvl:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_poll_for_event);\nerr_dcf_support_poll_for_event:\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_release_date);\nerr_dcf_rel_date:\n\tdriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\nerr_dcf_attr_ver:\n\tpci_unregister_driver(&megasas_pci_driver);\nerr_pcidrv:\n\tunregister_chrdev(megasas_mgmt_majorno, \"megaraid_sas_ioctl\");\n\treturn rval;\n}\n\n/**\n * megasas_exit - Driver unload entry point\n */\nstatic void __exit megasas_exit(void)\n{\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_dbg_lvl);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_poll_for_event);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t&driver_attr_support_device_change);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_release_date);\n\tdriver_remove_file(&megasas_pci_driver.driver, &driver_attr_version);\n\tdriver_remove_file(&megasas_pci_driver.driver,\n\t\t\t   &driver_attr_support_nvme_encapsulation);\n\n\tpci_unregister_driver(&megasas_pci_driver);\n\tunregister_chrdev(megasas_mgmt_majorno, \"megaraid_sas_ioctl\");\n}\n\nmodule_init(megasas_init);\nmodule_exit(megasas_exit);\n"], "filenames": ["drivers/scsi/megaraid/megaraid_sas_base.c"], "buggy_code_start_loc": [4190], "buggy_code_end_loc": [4190], "fixing_code_start_loc": [4191], "fixing_code_end_loc": [4192], "type": "CWE-416", "message": "An issue was discovered in the Linux kernel before 5.0.7. A NULL pointer dereference can occur when megasas_create_frame_pool() fails in megasas_alloc_cmds() in drivers/scsi/megaraid/megaraid_sas_base.c. This causes a Denial of Service, related to a use-after-free.", "other": {"cve": {"id": "CVE-2019-11810", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-07T14:29:00.723", "lastModified": "2022-12-02T19:46:50.643", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in the Linux kernel before 5.0.7. A NULL pointer dereference can occur when megasas_create_frame_pool() fails in megasas_alloc_cmds() in drivers/scsi/megaraid/megaraid_sas_base.c. This causes a Denial of Service, related to a use-after-free."}, {"lang": "es", "value": "Fue descubierto un fallo en el kernel de Linux anterior a 5.0.7. Una desreferencia de puntero NULL puede ocurrir cuando falla megasas_create_frame_pool() en megasas_alloc_cmds() en drivers/scsi/megaraid/megaraid_sas_base.c. Esto puede causar una denegaci\u00f3n de servicio (DoS), relacionada a un uso despu\u00e9s de liberaci\u00f3n de memoria."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}, {"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.16.69", "matchCriteriaId": "13415BA8-9AFC-436B-A059-5221AC943D3D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "3.18.139", "matchCriteriaId": "38D2BE0B-B7B1-4798-AE02-F25BCE43D452"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.19", "versionEndExcluding": "4.4.179", "matchCriteriaId": "4C8AD265-4D57-4C96-8CDE-E40908DC401D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.9.168", "matchCriteriaId": "8304FB1C-7B08-430C-A216-D34C84DA6552"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.14.111", "matchCriteriaId": "D115C211-8C5A-4719-9D22-40B18D74916D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.15", "versionEndExcluding": "4.19.34", "matchCriteriaId": "7879FC6A-D81E-47D1-896A-AEDCEC919A99"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.20", "versionEndExcluding": "5.0.7", "matchCriteriaId": "F797BBD2-45F5-4BFC-826C-3991BE850C62"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00055.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00056.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/108286", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1959", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:1971", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2029", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2043", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2736", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:2837", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:3217", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2020:0036", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.0.7", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=bcf3b67d16a4c8ffae0aa79de5853435e683945c", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/06/msg00010.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190719-0003/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://support.f5.com/csp/article/K50484570", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4005-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4008-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4008-3/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4115-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4118-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c"}}