{"buggy_code": ["from flask import jsonify, request, make_response, g\nfrom sqlalchemy.exc import IntegrityError\nfrom . import api\nfrom .. import db, auth\nfrom ..models import Song\nfrom .errors import bad_request, route_not_found\n\n@api.route('/songs/<name>')\ndef song(name):\n    return jsonify(name=name)\n\n@api.route('/songs/<int:id>')\ndef get_song(id):\n    song = Song.query.filter_by(id=id).first()\n    if not song:\n        return route_not_found(song)\n    return make_response(jsonify(song.to_json()), 200)\n\n@api.route('/songs/', methods=['POST'])\n@auth.login_required\ndef new_song():\n    # check if json\n    if request.headers['content_type'] == 'application/json':\n        payload = request.get_json()\n\n        # validate payload\n        if not request.json or \\\n        not 'title' in payload or \\\n        not 'artist' in payload or \\\n        not 'url' in payload:\n            message = 'the payload aint right'\n            return bad_request(message)\n\n        # validate that song doesn't already exist\n        # TODO: this needs to be way more sophisticated\n        if Song.query.filter_by(url=payload['url']).first():\n            message = 'this song already exists'\n            return bad_request(message)\n\n        # add song\n        try:\n            song = Song(title=payload['title'], \\\n                        artist=payload['artist'], \\\n                        url=payload['url'], \\\n                        user=g.current_user)\n            db.session.add(song)\n            db.session.commit()\n            return make_response(jsonify(song.to_json()), 200)\n        except IntegrityError:\n            message = 'this song already exists'\n            return bad_request(message)\n        except AssertionError as ex:\n            return bad_request(ex.args[0])\n        except Exception as ex:\n            template = \"An exception of type {0} occured. Arguments:\\n{1!r}\"\n            message = template.format(type(ex).__name__, ex.args)\n            return bad_request(message)\n\n    else:\n        message = 'that aint json'\n        return bad_request(message)\n\n@api.route('/songs/<int:id>/related')\ndef get_song_relations(id):\n    top = request.args.get('top')\n    song = Song.query.filter_by(id=id).first()\n    if not song:\n        return route_not_found(song)\n    return make_response(jsonify(song.get_related_songs_json(top)), 200)\n\n\n\n\n", "from flask import url_for\nfrom app.models import User,Song\nfrom dateutil.parser import *\nimport json\nimport pytest\nimport base64\n\n@pytest.mark.usefixtures('client_class', 'db_class')\nclass TestSongRelationsApi():\n\n    # test users\n    hiphop_user = {\n        'username': 'hiphop',\n        'email': 'hiphop@soundslike.io',\n        'password': 'ifyoudontknownowyouknow'\n    }\n    edm_user = {\n        'username': 'edm',\n        'email': 'edm@soundslike.io',\n        'password': 'edmedm'\n    }\n    indie_user = {\n        'username': 'indie',\n        'email': 'indie@soundslike.io',\n        'password': 'indieindie'\n    }\n\n    users = {'hiphop': hiphop_user,\n             'edm': edm_user,\n             'indie': indie_user}\n\n    # test songs\n    hiphop_song_1 = {\n        'title': 'Best Friend',\n        'artist': 'Young Thug',\n        'url': 'https://www.youtube.com/watch?v=Tz6OUIjtM6E'\n    }\n    hiphop_song_2 = {\n        'title': 'We the People....',\n        'artist': 'A Tribe Called Quest',\n        'url': 'https://www.youtube.com/watch?v=vO2Su3erRIA'\n    }\n    edm_song_1 = {\n        'title': 'Never Be Like You feat. Kai',\n        'artist': 'Flume',\n        'url': 'https://www.youtube.com/watch?v=-KPnyf8vwXI'\n    }\n    edm_song_2 = {\n        'title': 'GLOWED UP (feat. Anderson .Paak)',\n        'artist': 'Kaytranada',\n        'url': 'https://www.youtube.com/watch?v=yaWesK-nWts'\n    }\n    indie_song_1 = {\n        'title': 'i know there\\'s gonna be (good times) ft. young thug, popcaan',\n        'artist': 'jamie xx',\n        'url': 'https://www.youtube.com/watch?v=bjlbb-tma84'\n    }\n    indie_song_2 = {\n        'title': '1901',\n        'artist': 'Phoenix',\n        'url': 'https://www.youtube.com/watch?v=HL548cHH3OY'\n    }\n\n    songs = {'hiphop': (hiphop_song_1, hiphop_song_2),\n             'edm': (edm_song_1, edm_song_2),\n             'indie': (indie_song_1, indie_song_2)}\n\n    def get_auth_str(self, user):\n        return 'Basic ' + base64.b64encode( \\\n            (user['username'] + ':' +user['password']) \\\n                .encode('utf-8')).decode('utf-8')\n\n    def get_auth_header(self, user):\n        return {'Authorization': self.get_auth_str(user)}\n\n    def test_setup(self):\n        # add users to database\n        for user in self.users.values():\n            user_obj = User(username=user['username'],\n                            email=user['email'],\n                            password=user['password'])\n            self.db.session.add(user_obj)\n        self.db.session.commit()\n\n        # add songs to database\n        for username, st in self.songs.items():\n            user_obj = User.query.filter_by(username=username).first()\n            song1 = Song(title=st[0]['title'],\n                         artist=st[0]['artist'],\n                         url=st[0]['url'],\n                         user=user_obj)\n            song2 = Song(title=st[1]['title'],\n                         artist=st[1]['artist'],\n                         url=st[1]['url'],\n                         user=user_obj)\n            self.db.session.add(song1)\n            self.db.session.add(song2)\n\n            # use actual song objects in songs dict (so we have ids)\n            song1 = Song.query.filter_by(title=song1.title).first()\n            song2 = Song.query.filter_by(title=song2.title).first()\n            song1_dict = self.songs[username][0]\n            song2_dict = self.songs[username][1]\n            song1_dict['id'] = song1.id\n            song2_dict['id'] = song2.id\n            self.songs[username] = (song1_dict, song2_dict)\n        self.db.session.commit()\n\n    def test_new_song_relation_invalid_payload(self):\n        data = ''\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               data=data)\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'that aint json'\n\n    def test_new_song_relation_empty_payload(self):\n        data = dict()\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'the payload aint right'\n\n    def test_new_song_relation_missing_fields(self):\n        data = dict(song2_id=self.songs['hiphop'][1]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'the payload aint right'\n\n        data = dict(song1_id=self.songs['hiphop'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'the payload aint right'\n\n    def test_new_song_relation_no_auth(self):\n        data = dict(song1_id=self.songs['hiphop'][0]['id'],\n                    song2_id=self.songs['hiphop'][1]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 401\n        assert res.json['error'] == 'unauthorized'\n        assert res.json['message'] == 'Invalid credentials'\n\n    def test_new_song_relation_relate_song_to_self(self):\n        data = dict(song1_id=self.songs['hiphop'][0]['id'],\n                    song2_id=self.songs['hiphop'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'cannot relate a song to itself'\n\n    def test_new_song_relation_success(self):\n        data = dict(song1_id=self.songs['hiphop'][0]['id'],\n                    song2_id=self.songs['hiphop'][1]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        assert res.json['id']\n        assert res.json['song1']['id'] == self.songs['hiphop'][0]['id']\n        assert res.json['song2']['id'] == self.songs['hiphop'][1]['id']\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 1\n        assert res.json['created']\n        assert res.json['created_by']['username'] == self.hiphop_user['username']\n\n    def test_new_song_relation_duplicate(self):\n        data = dict(song1_id=self.songs['hiphop'][1]['id'],\n                    song2_id=self.songs['indie'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'this song relation already exists'\n\n    def test_song_relation_vote_by_another_user(self):\n        data = dict(song1_id=self.songs['indie'][1]['id'],\n                    song2_id=self.songs['indie'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['indie']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        song_relation_id = res.json['id']\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 1\n\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json')\n        assert res.status_code == 200\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 2\n\n    def test_song_relation_vote_twice(self):\n        data = dict(song1_id=self.songs['indie'][1]['id'],\n                    song2_id=self.songs['hiphop'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['indie']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        song_relation_id = res.json['id']\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 1\n\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['indie']),\n                               content_type='application/json')\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'you''ve already voted for this song relation'\n\n    def test_song_relation_vote_then_delete(self):\n        data = dict(song1_id=self.songs['edm'][0]['id'],\n                    song2_id=self.songs['hiphop'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['edm']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 1\n        song_relation_id = res.json['id']\n\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json')\n        assert res.status_code == 200\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 2\n\n        res = self.client.delete(url_for('api.delete_vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json')\n        assert res.status_code == 200\n        assert res.json['has_voted'] == False\n        assert res.json['vote_count'] == 1\n\n        res = self.client.delete(url_for('api.delete_vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['edm']),\n                               content_type='application/json')\n        assert res.status_code == 200\n        assert res.json['has_voted'] == False\n        assert res.json['vote_count'] == 0\n\n    def test_song_relation_vote_delete_nonexistent_vote(self):\n        res = self.client.delete(url_for('api.delete_vote_song_relation', id=420),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json')\n        assert res.status_code == 400\n        assert res.json['message'] == 'this user has not voted for this relation'\n\n    def test_song_relation_get_related_songs(self):\n        data = dict(song1_id=self.songs['edm'][0]['id'],\n                    song2_id=self.songs['edm'][1]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['edm']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        song_relation_id = res.json['id']\n\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json')\n        assert res.status_code == 200\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['indie']),\n                               content_type='application/json')\n        assert res.status_code == 200\n\n        data = dict(song1_id=self.songs['edm'][0]['id'],\n                    song2_id=self.songs['hiphop'][1]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        song_relation_id = res.json['id']\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['indie']),\n                               content_type='application/json')\n        assert res.status_code == 200\n\n        data = dict(song1_id=self.songs['edm'][0]['id'],\n                    song2_id=self.songs['indie'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n\n        song_id = self.songs['edm'][0]['id']\n        res = self.client.get(url_for('api.get_song_relations', id=song_id, top=10),\n                               content_type='application/json')\n        assert res.status_code == 200\n        assert len(res.json) == 3\n        assert res.json[0]['id'] == self.songs['edm'][1]['id']\n        assert res.json[1]['id'] == self.songs['hiphop'][1]['id']\n        assert res.json[2]['id'] == self.songs['indie'][0]['id']\n\n        res = self.client.get(url_for('api.get_song_relations', id=song_id, top=1),\n                              content_type='application/json')\n        assert res.status_code == 200\n        assert len(res.json) == 1\n        assert res.json[0]['id'] == self.songs['edm'][1]['id']\n\n"], "fixing_code": ["from flask import jsonify, request, make_response, g\nfrom sqlalchemy.exc import IntegrityError\nfrom . import api\nfrom .. import db, auth\nfrom ..models import Song\nfrom .errors import bad_request, route_not_found\n\n@api.route('/songs/<name>')\ndef song(name):\n    return jsonify(name=name)\n\n@api.route('/songs/<int:id>')\ndef get_song(id):\n    song = Song.query.filter_by(id=id).first()\n    if not song:\n        return route_not_found(song)\n    return make_response(jsonify(song.to_json()), 200)\n\n@api.route('/songs/', methods=['POST'])\n@auth.login_required\ndef new_song():\n    # check if json\n    if request.headers['content_type'] == 'application/json':\n        payload = request.get_json()\n\n        # validate payload\n        if not request.json or \\\n        not 'title' in payload or \\\n        not 'artist' in payload or \\\n        not 'url' in payload:\n            message = 'the payload aint right'\n            return bad_request(message)\n\n        # validate that song doesn't already exist\n        # TODO: this needs to be way more sophisticated\n        if Song.query.filter_by(url=payload['url']).first():\n            message = 'this song already exists'\n            return bad_request(message)\n\n        # add song\n        try:\n            song = Song(title=payload['title'], \\\n                        artist=payload['artist'], \\\n                        url=payload['url'], \\\n                        user=g.current_user)\n            db.session.add(song)\n            db.session.commit()\n            return make_response(jsonify(song.to_json()), 200)\n        except IntegrityError:\n            message = 'this song already exists'\n            return bad_request(message)\n        except AssertionError as ex:\n            return bad_request(ex.args[0])\n        except Exception as ex:\n            template = \"An exception of type {0} occured. Arguments:\\n{1!r}\"\n            message = template.format(type(ex).__name__, ex.args)\n            return bad_request(message)\n\n    else:\n        message = 'that aint json'\n        return bad_request(message)\n\n@api.route('/songs/<int:id>/related')\ndef get_song_relations(id):\n    top_str = request.args.get('top')\n    if not top_str.isdigit() or not int(top_str) > 0:\n        message = 'top query param must be an int greater than 0'\n        return bad_request(message)\n    top = int(request.args.get('top'))\n    song = Song.query.filter_by(id=id).first()\n    if not song:\n        return route_not_found(song)\n    return make_response(jsonify(song.get_related_songs_json(top)), 200)\n\n\n\n\n", "from flask import url_for\nfrom app.models import User,Song\nfrom dateutil.parser import *\nimport json\nimport pytest\nimport base64\n\n@pytest.mark.usefixtures('client_class', 'db_class')\nclass TestSongRelationsApi():\n\n    # test users\n    hiphop_user = {\n        'username': 'hiphop',\n        'email': 'hiphop@soundslike.io',\n        'password': 'ifyoudontknownowyouknow'\n    }\n    edm_user = {\n        'username': 'edm',\n        'email': 'edm@soundslike.io',\n        'password': 'edmedm'\n    }\n    indie_user = {\n        'username': 'indie',\n        'email': 'indie@soundslike.io',\n        'password': 'indieindie'\n    }\n\n    users = {'hiphop': hiphop_user,\n             'edm': edm_user,\n             'indie': indie_user}\n\n    # test songs\n    hiphop_song_1 = {\n        'title': 'Best Friend',\n        'artist': 'Young Thug',\n        'url': 'https://www.youtube.com/watch?v=Tz6OUIjtM6E'\n    }\n    hiphop_song_2 = {\n        'title': 'We the People....',\n        'artist': 'A Tribe Called Quest',\n        'url': 'https://www.youtube.com/watch?v=vO2Su3erRIA'\n    }\n    edm_song_1 = {\n        'title': 'Never Be Like You feat. Kai',\n        'artist': 'Flume',\n        'url': 'https://www.youtube.com/watch?v=-KPnyf8vwXI'\n    }\n    edm_song_2 = {\n        'title': 'GLOWED UP (feat. Anderson .Paak)',\n        'artist': 'Kaytranada',\n        'url': 'https://www.youtube.com/watch?v=yaWesK-nWts'\n    }\n    indie_song_1 = {\n        'title': 'i know there\\'s gonna be (good times) ft. young thug, popcaan',\n        'artist': 'jamie xx',\n        'url': 'https://www.youtube.com/watch?v=bjlbb-tma84'\n    }\n    indie_song_2 = {\n        'title': '1901',\n        'artist': 'Phoenix',\n        'url': 'https://www.youtube.com/watch?v=HL548cHH3OY'\n    }\n\n    songs = {'hiphop': (hiphop_song_1, hiphop_song_2),\n             'edm': (edm_song_1, edm_song_2),\n             'indie': (indie_song_1, indie_song_2)}\n\n    def get_auth_str(self, user):\n        return 'Basic ' + base64.b64encode( \\\n            (user['username'] + ':' +user['password']) \\\n                .encode('utf-8')).decode('utf-8')\n\n    def get_auth_header(self, user):\n        return {'Authorization': self.get_auth_str(user)}\n\n    def test_setup(self):\n        # add users to database\n        for user in self.users.values():\n            user_obj = User(username=user['username'],\n                            email=user['email'],\n                            password=user['password'])\n            self.db.session.add(user_obj)\n        self.db.session.commit()\n\n        # add songs to database\n        for username, st in self.songs.items():\n            user_obj = User.query.filter_by(username=username).first()\n            song1 = Song(title=st[0]['title'],\n                         artist=st[0]['artist'],\n                         url=st[0]['url'],\n                         user=user_obj)\n            song2 = Song(title=st[1]['title'],\n                         artist=st[1]['artist'],\n                         url=st[1]['url'],\n                         user=user_obj)\n            self.db.session.add(song1)\n            self.db.session.add(song2)\n\n            # use actual song objects in songs dict (so we have ids)\n            song1 = Song.query.filter_by(title=song1.title).first()\n            song2 = Song.query.filter_by(title=song2.title).first()\n            song1_dict = self.songs[username][0]\n            song2_dict = self.songs[username][1]\n            song1_dict['id'] = song1.id\n            song2_dict['id'] = song2.id\n            self.songs[username] = (song1_dict, song2_dict)\n        self.db.session.commit()\n\n    def test_new_song_relation_invalid_payload(self):\n        data = ''\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               data=data)\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'that aint json'\n\n    def test_new_song_relation_empty_payload(self):\n        data = dict()\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'the payload aint right'\n\n    def test_new_song_relation_missing_fields(self):\n        data = dict(song2_id=self.songs['hiphop'][1]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'the payload aint right'\n\n        data = dict(song1_id=self.songs['hiphop'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'the payload aint right'\n\n    def test_new_song_relation_no_auth(self):\n        data = dict(song1_id=self.songs['hiphop'][0]['id'],\n                    song2_id=self.songs['hiphop'][1]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 401\n        assert res.json['error'] == 'unauthorized'\n        assert res.json['message'] == 'Invalid credentials'\n\n    def test_new_song_relation_relate_song_to_self(self):\n        data = dict(song1_id=self.songs['hiphop'][0]['id'],\n                    song2_id=self.songs['hiphop'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'cannot relate a song to itself'\n\n    def test_new_song_relation_success(self):\n        data = dict(song1_id=self.songs['hiphop'][0]['id'],\n                    song2_id=self.songs['hiphop'][1]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        assert res.json['id']\n        assert res.json['song1']['id'] == self.songs['hiphop'][0]['id']\n        assert res.json['song2']['id'] == self.songs['hiphop'][1]['id']\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 1\n        assert res.json['created']\n        assert res.json['created_by']['username'] == self.hiphop_user['username']\n\n    def test_new_song_relation_duplicate(self):\n        data = dict(song1_id=self.songs['hiphop'][1]['id'],\n                    song2_id=self.songs['indie'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'this song relation already exists'\n\n    def test_song_relation_vote_by_another_user(self):\n        data = dict(song1_id=self.songs['indie'][1]['id'],\n                    song2_id=self.songs['indie'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['indie']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        song_relation_id = res.json['id']\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 1\n\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json')\n        assert res.status_code == 200\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 2\n\n    def test_song_relation_vote_twice(self):\n        data = dict(song1_id=self.songs['indie'][1]['id'],\n                    song2_id=self.songs['hiphop'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['indie']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        song_relation_id = res.json['id']\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 1\n\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['indie']),\n                               content_type='application/json')\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'you''ve already voted for this song relation'\n\n    def test_song_relation_vote_then_delete(self):\n        data = dict(song1_id=self.songs['edm'][0]['id'],\n                    song2_id=self.songs['hiphop'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['edm']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 1\n        song_relation_id = res.json['id']\n\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json')\n        assert res.status_code == 200\n        assert res.json['has_voted'] == True\n        assert res.json['vote_count'] == 2\n\n        res = self.client.delete(url_for('api.delete_vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json')\n        assert res.status_code == 200\n        assert res.json['has_voted'] == False\n        assert res.json['vote_count'] == 1\n\n        res = self.client.delete(url_for('api.delete_vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['edm']),\n                               content_type='application/json')\n        assert res.status_code == 200\n        assert res.json['has_voted'] == False\n        assert res.json['vote_count'] == 0\n\n    def test_song_relation_vote_delete_nonexistent_vote(self):\n        res = self.client.delete(url_for('api.delete_vote_song_relation', id=420),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json')\n        assert res.status_code == 400\n        assert res.json['message'] == 'this user has not voted for this relation'\n\n    def test_song_relation_get_related_songs(self):\n        data = dict(song1_id=self.songs['edm'][0]['id'],\n                    song2_id=self.songs['edm'][1]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['edm']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        song_relation_id = res.json['id']\n\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json')\n        assert res.status_code == 200\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['indie']),\n                               content_type='application/json')\n        assert res.status_code == 200\n\n        data = dict(song1_id=self.songs['edm'][0]['id'],\n                    song2_id=self.songs['hiphop'][1]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n        song_relation_id = res.json['id']\n        res = self.client.post(url_for('api.vote_song_relation', id=song_relation_id),\n                               headers=self.get_auth_header(self.users['indie']),\n                               content_type='application/json')\n        assert res.status_code == 200\n\n        data = dict(song1_id=self.songs['edm'][0]['id'],\n                    song2_id=self.songs['indie'][0]['id'])\n        res = self.client.post(url_for('api.new_song_relation'),\n                               headers=self.get_auth_header(self.users['hiphop']),\n                               content_type='application/json',\n                               data=json.dumps(data))\n        assert res.status_code == 200\n\n        song_id = self.songs['edm'][0]['id']\n        res = self.client.get(url_for('api.get_song_relations', id=song_id, top=10),\n                               content_type='application/json')\n        assert res.status_code == 200\n        assert len(res.json) == 3\n        assert res.json[0]['id'] == self.songs['edm'][1]['id']\n        assert res.json[1]['id'] == self.songs['hiphop'][1]['id']\n        assert res.json[2]['id'] == self.songs['indie'][0]['id']\n\n        res = self.client.get(url_for('api.get_song_relations', id=song_id, top=1),\n                              content_type='application/json')\n        assert res.status_code == 200\n        assert len(res.json) == 1\n        assert res.json[0]['id'] == self.songs['edm'][1]['id']\n\n    def test_get_song_relations_top_query_param(self):\n        song_id = self.songs['edm'][0]['id']\n        res = self.client.get(url_for('api.get_song_relations', id=song_id, top=0),\n                              content_type='application/json')\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'top query param must be an int greater than 0'\n\n        res = self.client.get(url_for('api.get_song_relations', id=song_id, top=-1),\n                              content_type='application/json')\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'top query param must be an int greater than 0'\n\n        res = self.client.get(url_for('api.get_song_relations', id=song_id, top='10; select * from users'),\n                              content_type='application/json')\n        assert res.status_code == 400\n        assert res.json['error'] == 'bad request'\n        assert res.json['message'] == 'top query param must be an int greater than 0'\n"], "filenames": ["app/api/songs.py", "test/api/test_song_relations.py"], "buggy_code_start_loc": [65, 333], "buggy_code_end_loc": [66, 333], "fixing_code_start_loc": [65, 334], "fixing_code_end_loc": [70, 353], "type": "CWE-89", "message": "A vulnerability was found in ridhoq soundslike. It has been classified as critical. Affected is the function get_song_relations of the file app/api/songs.py. The manipulation leads to sql injection. The name of the patch is 90bb4fb667d9253d497b619b9adaac83bf0ce0f8. It is recommended to apply a patch to fix this issue. VDB-218490 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2017-20172", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-18T15:15:11.083", "lastModified": "2023-01-25T19:07:55.423", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in ridhoq soundslike. It has been classified as critical. Affected is the function get_song_relations of the file app/api/songs.py. The manipulation leads to sql injection. The name of the patch is 90bb4fb667d9253d497b619b9adaac83bf0ce0f8. It is recommended to apply a patch to fix this issue. VDB-218490 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:soundslike_project:soundslike:*:*:*:*:*:*:*:*", "versionEndExcluding": "2017-03-17", "matchCriteriaId": "9F6EEF25-D362-4026-8E60-4D0E2CFBDB3E"}]}]}], "references": [{"url": "https://github.com/ridhoq/soundslike/commit/90bb4fb667d9253d497b619b9adaac83bf0ce0f8", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ridhoq/soundslike/pull/5", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218490", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218490", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ridhoq/soundslike/commit/90bb4fb667d9253d497b619b9adaac83bf0ce0f8"}}