{"buggy_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* plugins/kdb/ldap/libkdb_ldap/ldap_pwd_policy.c */\n/*\n * Copyright (c) 2004-2005, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n#include \"ldap_main.h\"\n#include \"kdb_ldap.h\"\n#include \"ldap_pwd_policy.h\"\n#include \"ldap_err.h\"\n\nstatic char *password_policy_attributes[] = { \"cn\", \"krbmaxpwdlife\", \"krbminpwdlife\",\n                                              \"krbpwdmindiffchars\", \"krbpwdminlength\",\n                                              \"krbpwdhistorylength\", \"krbpwdmaxfailure\",\n                                              \"krbpwdfailurecountinterval\",\n                                              \"krbpwdlockoutduration\",\n                                              \"krbpwdattributes\",\n                                              \"krbpwdmaxlife\",\n                                              \"krbpwdmaxrenewablelife\",\n                                              \"krbpwdallowedkeysalts\", NULL };\n\n/* Fill in mods with LDAP operations for the fields of policy, using the\n * modification type op.  mods must be freed by the caller on error. */\nstatic krb5_error_code\nadd_policy_mods(krb5_context context, LDAPMod ***mods, osa_policy_ent_t policy,\n                int op)\n{\n    krb5_error_code st;\n    char *strval[2] = { NULL };\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbmaxpwdlife\", op,\n                                   (int)policy->pw_max_life);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbminpwdlife\", op,\n                                   (int)policy->pw_min_life);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdmindiffchars\", op,\n                                   (int)policy->pw_min_classes);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdminlength\", op,\n                                   (int)policy->pw_min_length);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdhistorylength\", op,\n                                   (int)policy->pw_history_num);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdmaxfailure\", op,\n                                   (int)policy->pw_max_fail);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdfailurecountinterval\", op,\n                                   (int)policy->pw_failcnt_interval);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdlockoutduration\", op,\n                                   (int)policy->pw_lockout_duration);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdattributes\", op,\n                                   (int)policy->attributes);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdmaxlife\", op,\n                                   (int)policy->max_life);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdmaxrenewablelife\", op,\n                                   (int)policy->max_renewable_life);\n    if (st)\n        return st;\n\n    if (policy->allowed_keysalts != NULL) {\n        strval[0] = policy->allowed_keysalts;\n        st = krb5_add_str_mem_ldap_mod(mods, \"krbpwdallowedkeysalts\",\n                                       op, strval);\n        if (st)\n            return st;\n    }\n\n    /*\n     * Each policy tl-data type we add should be explicitly marshalled here.\n     * Unlike principals, we do not marshal unrecognized policy tl-data.\n     */\n\n    return 0;\n}\n\n/*\n * Function to create password policy object.\n */\n\nkrb5_error_code\nkrb5_ldap_create_password_policy(krb5_context context, osa_policy_ent_t policy)\n{\n    krb5_error_code             st=0;\n    LDAP                        *ld=NULL;\n    LDAPMod                     **mods={NULL};\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    char                        *strval[2]={NULL}, *policy_dn=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (policy == NULL || policy->name == NULL)\n        return EINVAL;\n\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    st = krb5_ldap_name_to_policydn (context, policy->name, &policy_dn);\n    if (st != 0)\n        goto cleanup;\n\n    strval[0] = policy->name;\n    if ((st=krb5_add_str_mem_ldap_mod(&mods, \"cn\", LDAP_MOD_ADD, strval)) != 0)\n        goto cleanup;\n\n    strval[0] = \"krbPwdPolicy\";\n    if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n        goto cleanup;\n\n    st = add_policy_mods(context, &mods, policy, LDAP_MOD_ADD);\n    if (st)\n        goto cleanup;\n\n    /* password policy object creation */\n    if ((st=ldap_add_ext_s(ld, policy_dn, mods, NULL, NULL)) != LDAP_SUCCESS) {\n        st = set_ldap_error (context, st, OP_ADD);\n        goto cleanup;\n    }\n\ncleanup:\n    free(policy_dn);\n    ldap_mods_free(mods, 1);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}\n\n/*\n * Function to modify password policy object.\n */\n\nkrb5_error_code\nkrb5_ldap_put_password_policy(krb5_context context, osa_policy_ent_t policy)\n{\n    char                        *policy_dn=NULL;\n    krb5_error_code             st=0;\n    LDAP                        *ld=NULL;\n    LDAPMod                     **mods=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (policy == NULL || policy->name == NULL)\n        return EINVAL;\n\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    st = krb5_ldap_name_to_policydn (context, policy->name, &policy_dn);\n    if (st != 0)\n        goto cleanup;\n\n    st = add_policy_mods(context, &mods, policy, LDAP_MOD_REPLACE);\n    if (st)\n        goto cleanup;\n\n    /* modify the password policy object. */\n    /*\n     * This will fail if the 'policy_dn' is anywhere other than under the realm\n     * container. This is correct behaviour. 'kdb5_ldap_util' will support\n     * management of only such policy objects.\n     */\n    if ((st=ldap_modify_ext_s(ld, policy_dn, mods, NULL, NULL)) != LDAP_SUCCESS) {\n        st = set_ldap_error (context, st, OP_MOD);\n        goto cleanup;\n    }\n\ncleanup:\n    free(policy_dn);\n    ldap_mods_free(mods, 1);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}\n\nstatic void\nget_ui4(LDAP *ld, LDAPMessage *ent, char *name, krb5_ui_4 *out)\n{\n    int val;\n\n    krb5_ldap_get_value(ld, ent, name, &val);\n    *out = val;\n}\n\nstatic krb5_error_code\npopulate_policy(krb5_context context,\n                LDAP *ld,\n                LDAPMessage *ent,\n                char *pol_name,\n                osa_policy_ent_t pol_entry)\n{\n    int st = 0;\n\n    pol_entry->name = strdup(pol_name);\n    CHECK_NULL(pol_entry->name);\n    pol_entry->version = 1;\n\n    get_ui4(ld, ent, \"krbmaxpwdlife\", &pol_entry->pw_max_life);\n    get_ui4(ld, ent, \"krbminpwdlife\", &pol_entry->pw_min_life);\n    get_ui4(ld, ent, \"krbpwdmindiffchars\", &pol_entry->pw_min_classes);\n    get_ui4(ld, ent, \"krbpwdminlength\", &pol_entry->pw_min_length);\n    get_ui4(ld, ent, \"krbpwdhistorylength\", &pol_entry->pw_history_num);\n    get_ui4(ld, ent, \"krbpwdmaxfailure\", &pol_entry->pw_max_fail);\n    get_ui4(ld, ent, \"krbpwdfailurecountinterval\",\n            &pol_entry->pw_failcnt_interval);\n    get_ui4(ld, ent, \"krbpwdlockoutduration\", &pol_entry->pw_lockout_duration);\n    get_ui4(ld, ent, \"krbpwdattributes\", &pol_entry->attributes);\n    get_ui4(ld, ent, \"krbpwdmaxlife\", &pol_entry->max_life);\n    get_ui4(ld, ent, \"krbpwdmaxrenewablelife\", &pol_entry->max_renewable_life);\n\n    st = krb5_ldap_get_string(ld, ent, \"krbpwdallowedkeysalts\",\n                              &(pol_entry->allowed_keysalts), NULL);\n    if (st)\n        goto cleanup;\n    /*\n     * We don't store the policy refcnt, because principals might be maintained\n     * outside of kadmin.  Instead, we will check for principal references when\n     * policies are deleted.\n     */\n    pol_entry->policy_refcnt = 0;\n\ncleanup:\n    return st;\n}\n\nstatic krb5_error_code\nkrb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n\n    ent=ldap_first_entry(ld, result);\n    if (ent != NULL) {\n        if ((st = populate_policy(context, ld, ent, pol_name, *policy)) != 0)\n            goto cleanup;\n    }\n\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}\n\n/*\n * Convert 'name' into a directory DN and call\n * 'krb5_ldap_get_password_policy_from_dn'\n */\nkrb5_error_code\nkrb5_ldap_get_password_policy(krb5_context context, char *name,\n                              osa_policy_ent_t *policy)\n{\n    krb5_error_code             st = 0;\n    char                        *policy_dn = NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (name == NULL) {\n        st = EINVAL;\n        goto cleanup;\n    }\n\n    st = krb5_ldap_name_to_policydn(context, name, &policy_dn);\n    if (st != 0)\n        goto cleanup;\n\n    st = krb5_ldap_get_password_policy_from_dn(context, name, policy_dn,\n                                               policy);\n\ncleanup:\n    free(policy_dn);\n    return st;\n}\n\nkrb5_error_code\nkrb5_ldap_delete_password_policy(krb5_context context, char *policy)\n{\n    int                         mask = 0;\n    char                        *policy_dn = NULL, *class[] = {\"krbpwdpolicy\", NULL};\n    krb5_error_code             st=0;\n    LDAP                        *ld=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (policy == NULL)\n        return EINVAL;\n\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    st = krb5_ldap_name_to_policydn (context, policy, &policy_dn);\n    if (st != 0)\n        goto cleanup;\n\n    /* Ensure that the object is a password policy */\n    if ((st=checkattributevalue(ld, policy_dn, \"objectclass\", class, &mask)) != 0)\n        goto cleanup;\n\n    if (mask == 0) {\n        st = KRB5_KDB_NOENTRY;\n        goto cleanup;\n    }\n\n    if ((st=ldap_delete_ext_s(ld, policy_dn, NULL, NULL)) != LDAP_SUCCESS) {\n        st = set_ldap_error (context, st, OP_DEL);\n        goto cleanup;\n    }\n\ncleanup:\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    free(policy_dn);\n\n    return st;\n}\n\nkrb5_error_code\nkrb5_ldap_iterate_password_policy(krb5_context context, char *match_expr,\n                                  void (*func)(krb5_pointer, osa_policy_ent_t),\n                                  krb5_pointer func_arg)\n{\n    osa_policy_ent_rec          *entry=NULL;\n    char                        *policy=NULL;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    if (ldap_context->lrparams->realmdn == NULL) {\n        st = EINVAL;\n        goto cleanup;\n    }\n\n    LDAP_SEARCH(ldap_context->lrparams->realmdn, LDAP_SCOPE_ONELEVEL, \"(objectclass=krbpwdpolicy)\", password_policy_attributes);\n    for (ent=ldap_first_entry(ld, result); ent != NULL; ent=ldap_next_entry(ld, ent)) {\n        krb5_boolean attr_present;\n\n        st = krb5_ldap_get_string(ld, ent, \"cn\", &policy, &attr_present);\n        if (st != 0)\n            goto cleanup;\n        if (attr_present == FALSE)\n            continue;\n\n        entry = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n        CHECK_NULL(entry);\n        memset(entry, 0, sizeof(osa_policy_ent_rec));\n        if ((st = populate_policy(context, ld, ent, policy, entry)) != 0)\n            goto cleanup;\n\n        (*func)(func_arg, entry);\n        krb5_ldap_free_password_policy(context, entry);\n        entry = NULL;\n\n        free(policy);\n        policy = NULL;\n    }\n\ncleanup:\n    free(entry);\n    free(policy);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}\n\nvoid\nkrb5_ldap_free_password_policy (context, entry)\n    krb5_context                context;\n    osa_policy_ent_t            entry;\n{\n    if (entry) {\n        free(entry->name);\n        free(entry->allowed_keysalts);\n        free(entry);\n    }\n    return;\n}\n"], "fixing_code": ["/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* plugins/kdb/ldap/libkdb_ldap/ldap_pwd_policy.c */\n/*\n * Copyright (c) 2004-2005, Novell, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *       notice, this list of conditions and the following disclaimer in the\n *       documentation and/or other materials provided with the distribution.\n *   * The copyright holder's name is not used to endorse or promote products\n *       derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n/*\n * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.\n * Use is subject to license terms.\n */\n\n#include \"ldap_main.h\"\n#include \"kdb_ldap.h\"\n#include \"ldap_pwd_policy.h\"\n#include \"ldap_err.h\"\n\nstatic char *password_policy_attributes[] = { \"cn\", \"krbmaxpwdlife\", \"krbminpwdlife\",\n                                              \"krbpwdmindiffchars\", \"krbpwdminlength\",\n                                              \"krbpwdhistorylength\", \"krbpwdmaxfailure\",\n                                              \"krbpwdfailurecountinterval\",\n                                              \"krbpwdlockoutduration\",\n                                              \"krbpwdattributes\",\n                                              \"krbpwdmaxlife\",\n                                              \"krbpwdmaxrenewablelife\",\n                                              \"krbpwdallowedkeysalts\", NULL };\n\n/* Fill in mods with LDAP operations for the fields of policy, using the\n * modification type op.  mods must be freed by the caller on error. */\nstatic krb5_error_code\nadd_policy_mods(krb5_context context, LDAPMod ***mods, osa_policy_ent_t policy,\n                int op)\n{\n    krb5_error_code st;\n    char *strval[2] = { NULL };\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbmaxpwdlife\", op,\n                                   (int)policy->pw_max_life);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbminpwdlife\", op,\n                                   (int)policy->pw_min_life);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdmindiffchars\", op,\n                                   (int)policy->pw_min_classes);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdminlength\", op,\n                                   (int)policy->pw_min_length);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdhistorylength\", op,\n                                   (int)policy->pw_history_num);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdmaxfailure\", op,\n                                   (int)policy->pw_max_fail);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdfailurecountinterval\", op,\n                                   (int)policy->pw_failcnt_interval);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdlockoutduration\", op,\n                                   (int)policy->pw_lockout_duration);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdattributes\", op,\n                                   (int)policy->attributes);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdmaxlife\", op,\n                                   (int)policy->max_life);\n    if (st)\n        return st;\n\n    st = krb5_add_int_mem_ldap_mod(mods, \"krbpwdmaxrenewablelife\", op,\n                                   (int)policy->max_renewable_life);\n    if (st)\n        return st;\n\n    if (policy->allowed_keysalts != NULL) {\n        strval[0] = policy->allowed_keysalts;\n        st = krb5_add_str_mem_ldap_mod(mods, \"krbpwdallowedkeysalts\",\n                                       op, strval);\n        if (st)\n            return st;\n    }\n\n    /*\n     * Each policy tl-data type we add should be explicitly marshalled here.\n     * Unlike principals, we do not marshal unrecognized policy tl-data.\n     */\n\n    return 0;\n}\n\n/*\n * Function to create password policy object.\n */\n\nkrb5_error_code\nkrb5_ldap_create_password_policy(krb5_context context, osa_policy_ent_t policy)\n{\n    krb5_error_code             st=0;\n    LDAP                        *ld=NULL;\n    LDAPMod                     **mods={NULL};\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n    char                        *strval[2]={NULL}, *policy_dn=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (policy == NULL || policy->name == NULL)\n        return EINVAL;\n\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    st = krb5_ldap_name_to_policydn (context, policy->name, &policy_dn);\n    if (st != 0)\n        goto cleanup;\n\n    strval[0] = policy->name;\n    if ((st=krb5_add_str_mem_ldap_mod(&mods, \"cn\", LDAP_MOD_ADD, strval)) != 0)\n        goto cleanup;\n\n    strval[0] = \"krbPwdPolicy\";\n    if ((st=krb5_add_str_mem_ldap_mod(&mods, \"objectclass\", LDAP_MOD_ADD, strval)) != 0)\n        goto cleanup;\n\n    st = add_policy_mods(context, &mods, policy, LDAP_MOD_ADD);\n    if (st)\n        goto cleanup;\n\n    /* password policy object creation */\n    if ((st=ldap_add_ext_s(ld, policy_dn, mods, NULL, NULL)) != LDAP_SUCCESS) {\n        st = set_ldap_error (context, st, OP_ADD);\n        goto cleanup;\n    }\n\ncleanup:\n    free(policy_dn);\n    ldap_mods_free(mods, 1);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}\n\n/*\n * Function to modify password policy object.\n */\n\nkrb5_error_code\nkrb5_ldap_put_password_policy(krb5_context context, osa_policy_ent_t policy)\n{\n    char                        *policy_dn=NULL;\n    krb5_error_code             st=0;\n    LDAP                        *ld=NULL;\n    LDAPMod                     **mods=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (policy == NULL || policy->name == NULL)\n        return EINVAL;\n\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    st = krb5_ldap_name_to_policydn (context, policy->name, &policy_dn);\n    if (st != 0)\n        goto cleanup;\n\n    st = add_policy_mods(context, &mods, policy, LDAP_MOD_REPLACE);\n    if (st)\n        goto cleanup;\n\n    /* modify the password policy object. */\n    /*\n     * This will fail if the 'policy_dn' is anywhere other than under the realm\n     * container. This is correct behaviour. 'kdb5_ldap_util' will support\n     * management of only such policy objects.\n     */\n    if ((st=ldap_modify_ext_s(ld, policy_dn, mods, NULL, NULL)) != LDAP_SUCCESS) {\n        st = set_ldap_error (context, st, OP_MOD);\n        goto cleanup;\n    }\n\ncleanup:\n    free(policy_dn);\n    ldap_mods_free(mods, 1);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return(st);\n}\n\nstatic void\nget_ui4(LDAP *ld, LDAPMessage *ent, char *name, krb5_ui_4 *out)\n{\n    int val;\n\n    krb5_ldap_get_value(ld, ent, name, &val);\n    *out = val;\n}\n\nstatic krb5_error_code\npopulate_policy(krb5_context context,\n                LDAP *ld,\n                LDAPMessage *ent,\n                char *pol_name,\n                osa_policy_ent_t pol_entry)\n{\n    int st = 0;\n\n    pol_entry->name = strdup(pol_name);\n    CHECK_NULL(pol_entry->name);\n    pol_entry->version = 1;\n\n    get_ui4(ld, ent, \"krbmaxpwdlife\", &pol_entry->pw_max_life);\n    get_ui4(ld, ent, \"krbminpwdlife\", &pol_entry->pw_min_life);\n    get_ui4(ld, ent, \"krbpwdmindiffchars\", &pol_entry->pw_min_classes);\n    get_ui4(ld, ent, \"krbpwdminlength\", &pol_entry->pw_min_length);\n    get_ui4(ld, ent, \"krbpwdhistorylength\", &pol_entry->pw_history_num);\n    get_ui4(ld, ent, \"krbpwdmaxfailure\", &pol_entry->pw_max_fail);\n    get_ui4(ld, ent, \"krbpwdfailurecountinterval\",\n            &pol_entry->pw_failcnt_interval);\n    get_ui4(ld, ent, \"krbpwdlockoutduration\", &pol_entry->pw_lockout_duration);\n    get_ui4(ld, ent, \"krbpwdattributes\", &pol_entry->attributes);\n    get_ui4(ld, ent, \"krbpwdmaxlife\", &pol_entry->max_life);\n    get_ui4(ld, ent, \"krbpwdmaxrenewablelife\", &pol_entry->max_renewable_life);\n\n    st = krb5_ldap_get_string(ld, ent, \"krbpwdallowedkeysalts\",\n                              &(pol_entry->allowed_keysalts), NULL);\n    if (st)\n        goto cleanup;\n    /*\n     * We don't store the policy refcnt, because principals might be maintained\n     * outside of kadmin.  Instead, we will check for principal references when\n     * policies are deleted.\n     */\n    pol_entry->policy_refcnt = 0;\n\ncleanup:\n    return st;\n}\n\nstatic krb5_error_code\nkrb5_ldap_get_password_policy_from_dn(krb5_context context, char *pol_name,\n                                      char *pol_dn, osa_policy_ent_t *policy)\n{\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL,*ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (pol_dn == NULL)\n        return EINVAL;\n\n    *policy = NULL;\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    *(policy) = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n    if (*policy == NULL) {\n        st = ENOMEM;\n        goto cleanup;\n    }\n    memset(*policy, 0, sizeof(osa_policy_ent_rec));\n\n    LDAP_SEARCH(pol_dn, LDAP_SCOPE_BASE, \"(objectclass=krbPwdPolicy)\", password_policy_attributes);\n\n    ent=ldap_first_entry(ld, result);\n    if (ent == NULL) {\n        st = KRB5_KDB_NOENTRY;\n        goto cleanup;\n    }\n    st = populate_policy(context, ld, ent, pol_name, *policy);\n\ncleanup:\n    ldap_msgfree(result);\n    if (st != 0) {\n        if (*policy != NULL) {\n            krb5_ldap_free_password_policy(context, *policy);\n            *policy = NULL;\n        }\n    }\n\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}\n\n/*\n * Convert 'name' into a directory DN and call\n * 'krb5_ldap_get_password_policy_from_dn'\n */\nkrb5_error_code\nkrb5_ldap_get_password_policy(krb5_context context, char *name,\n                              osa_policy_ent_t *policy)\n{\n    krb5_error_code             st = 0;\n    char                        *policy_dn = NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (name == NULL) {\n        st = EINVAL;\n        goto cleanup;\n    }\n\n    st = krb5_ldap_name_to_policydn(context, name, &policy_dn);\n    if (st != 0)\n        goto cleanup;\n\n    st = krb5_ldap_get_password_policy_from_dn(context, name, policy_dn,\n                                               policy);\n\ncleanup:\n    free(policy_dn);\n    return st;\n}\n\nkrb5_error_code\nkrb5_ldap_delete_password_policy(krb5_context context, char *policy)\n{\n    int                         mask = 0;\n    char                        *policy_dn = NULL, *class[] = {\"krbpwdpolicy\", NULL};\n    krb5_error_code             st=0;\n    LDAP                        *ld=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    /* validate the input parameters */\n    if (policy == NULL)\n        return EINVAL;\n\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    st = krb5_ldap_name_to_policydn (context, policy, &policy_dn);\n    if (st != 0)\n        goto cleanup;\n\n    /* Ensure that the object is a password policy */\n    if ((st=checkattributevalue(ld, policy_dn, \"objectclass\", class, &mask)) != 0)\n        goto cleanup;\n\n    if (mask == 0) {\n        st = KRB5_KDB_NOENTRY;\n        goto cleanup;\n    }\n\n    if ((st=ldap_delete_ext_s(ld, policy_dn, NULL, NULL)) != LDAP_SUCCESS) {\n        st = set_ldap_error (context, st, OP_DEL);\n        goto cleanup;\n    }\n\ncleanup:\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    free(policy_dn);\n\n    return st;\n}\n\nkrb5_error_code\nkrb5_ldap_iterate_password_policy(krb5_context context, char *match_expr,\n                                  void (*func)(krb5_pointer, osa_policy_ent_t),\n                                  krb5_pointer func_arg)\n{\n    osa_policy_ent_rec          *entry=NULL;\n    char                        *policy=NULL;\n    krb5_error_code             st=0, tempst=0;\n    LDAP                        *ld=NULL;\n    LDAPMessage                 *result=NULL, *ent=NULL;\n    kdb5_dal_handle             *dal_handle=NULL;\n    krb5_ldap_context           *ldap_context=NULL;\n    krb5_ldap_server_handle     *ldap_server_handle=NULL;\n\n    /* Clear the global error string */\n    krb5_clear_error_message(context);\n\n    SETUP_CONTEXT();\n    GET_HANDLE();\n\n    if (ldap_context->lrparams->realmdn == NULL) {\n        st = EINVAL;\n        goto cleanup;\n    }\n\n    LDAP_SEARCH(ldap_context->lrparams->realmdn, LDAP_SCOPE_ONELEVEL, \"(objectclass=krbpwdpolicy)\", password_policy_attributes);\n    for (ent=ldap_first_entry(ld, result); ent != NULL; ent=ldap_next_entry(ld, ent)) {\n        krb5_boolean attr_present;\n\n        st = krb5_ldap_get_string(ld, ent, \"cn\", &policy, &attr_present);\n        if (st != 0)\n            goto cleanup;\n        if (attr_present == FALSE)\n            continue;\n\n        entry = (osa_policy_ent_t) malloc(sizeof(osa_policy_ent_rec));\n        CHECK_NULL(entry);\n        memset(entry, 0, sizeof(osa_policy_ent_rec));\n        if ((st = populate_policy(context, ld, ent, policy, entry)) != 0)\n            goto cleanup;\n\n        (*func)(func_arg, entry);\n        krb5_ldap_free_password_policy(context, entry);\n        entry = NULL;\n\n        free(policy);\n        policy = NULL;\n    }\n\ncleanup:\n    free(entry);\n    free(policy);\n    ldap_msgfree(result);\n    krb5_ldap_put_handle_to_pool(ldap_context, ldap_server_handle);\n    return st;\n}\n\nvoid\nkrb5_ldap_free_password_policy (context, entry)\n    krb5_context                context;\n    osa_policy_ent_t            entry;\n{\n    if (entry) {\n        free(entry->name);\n        free(entry->allowed_keysalts);\n        free(entry);\n    }\n    return;\n}\n"], "filenames": ["src/plugins/kdb/ldap/libkdb_ldap/ldap_pwd_policy.c"], "buggy_code_start_loc": [317], "buggy_code_end_loc": [321], "fixing_code_start_loc": [317], "fixing_code_end_loc": [322], "type": "CWE-476", "message": "The krb5_ldap_get_password_policy_from_dn function in plugins/kdb/ldap/libkdb_ldap/ldap_pwd_policy.c in MIT Kerberos 5 (aka krb5) before 1.13.1, when the KDC uses LDAP, allows remote authenticated users to cause a denial of service (daemon crash) via a successful LDAP query with no results, as demonstrated by using an incorrect object type for a password policy.", "other": {"cve": {"id": "CVE-2014-5353", "sourceIdentifier": "cve@mitre.org", "published": "2014-12-16T23:59:00.073", "lastModified": "2021-02-02T18:57:13.267", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The krb5_ldap_get_password_policy_from_dn function in plugins/kdb/ldap/libkdb_ldap/ldap_pwd_policy.c in MIT Kerberos 5 (aka krb5) before 1.13.1, when the KDC uses LDAP, allows remote authenticated users to cause a denial of service (daemon crash) via a successful LDAP query with no results, as demonstrated by using an incorrect object type for a password policy."}, {"lang": "es", "value": "La funci\u00f3n krb5_ldap_get_password_policy_from_dn en plugins/kdb/ldap/libkdb_ldap/ldap_pwd_policy.c en MIT Kerberos 5 (tambi\u00e9n conocido como krb5) anterior a 1.13.1, cuando el KDC utiliza LDAP, permite a usuarios remotos autenticados causar una denegaci\u00f3n de servicio (ca\u00edda del demonio) a trav\u00e9s de una consulta LDAP con \u00e9xito pero sin resultados, tal y como fue demostrado mediante el uso de un tipo de objeto incorrecto para una pol\u00edtica de contrase\u00f1as."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mit:kerberos_5:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.1", "matchCriteriaId": "50EE1080-9A6B-4BF1-BF9C-A0F9453AFD2D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_desktop:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE249E1B-A1FD-4E08-AA71-A0E1F10FFE97"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "319EC0C6-94C5-494A-9C5D-DC5124DFC8E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "807C024A-F8E8-4B48-A349-4C68CD252CA1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "F96E3779-F56A-45FF-BB3D-4980527D721E"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.5:*:*:*:*:*:*:*", "matchCriteriaId": "0CF73560-2F5B-4723-A8A1-9AADBB3ADA00"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "5BF3C7A5-9117-42C7-BEA1-4AA378A582EF"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "83737173-E12E-4641-BC49-0BD84A6B29D0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "9BBCD86A-E6C7-4444-9D74-F861084090F0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "51EF4996-72F4-4FA4-814F-F5991E7A8318"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "16E6D998-B41D-4B49-9E00-8336D2E40A4A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "98381E61-F082-4302-B51F-5648884F998B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.4:*:*:*:*:*:*:*", "matchCriteriaId": "D99A687E-EAE6-417E-A88E-D0082BC194CD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B353CE99-D57C-465B-AAB0-73EF581127D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_aus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "7431ABC1-9252-419E-8CC1-311B41360078"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:6.6:*:*:*:*:*:*:*", "matchCriteriaId": "13E02156-E748-4820-B76F-7074793837E1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.3:*:*:*:*:*:*:*", "matchCriteriaId": "24C0F4E1-C52C-41E0-9F14-F83ADD5CC7ED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.6:*:*:*:*:*:*:*", "matchCriteriaId": "B76AA310-FEC7-497F-AF04-C3EC1E76C4CC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_server_tus:7.7:*:*:*:*:*:*:*", "matchCriteriaId": "17F256A9-D3B9-4C72-B013-4EFD878BFEA8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_workstation:6.0:*:*:*:*:*:*:*", "matchCriteriaId": "E5ED5807-55B7-47C5-97A6-03233F4FBC3A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:22:*:*:*:*:*:*:*", "matchCriteriaId": "253C303A-E577-4488-93E6-68A8DD942C38"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:7.0:*:*:*:*:*:*:*", "matchCriteriaId": "16F59A04-14CF-49E2-9973-645477EA09DA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:10.04:*:*:*:-:*:*:*", "matchCriteriaId": "01EDA41C-6B2E-49AF-B503-EB3882265C11"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:12.04:*:*:*:-:*:*:*", "matchCriteriaId": "CB66DB75-2B16-4EBF-9B93-CE49D8086E41"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.10:*:*:*:*:*:*:*", "matchCriteriaId": "49A63F39-30BE-443F-AF10-6245587D3359"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:10:*:*:*:*:*:*:*", "matchCriteriaId": "964B57CD-CB8A-4520-B358-1C93EC5EF2DC"}, {"vulnerable": true, "criteria": "cpe:2.3:o:oracle:solaris:11.2:*:*:*:*:*:*:*", "matchCriteriaId": "0B1C288F-326B-497B-B26C-D26E01262DDB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.1:*:*:*:*:*:*:*", "matchCriteriaId": "A10BC294-9196-425F-9FB0-B1625465B47F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:opensuse:13.2:*:*:*:*:*:*:*", "matchCriteriaId": "03117DF1-3BEC-4B8D-AD63-DBBDB2126081"}]}]}], "references": [{"url": "http://advisories.mageia.org/MGASA-2014-0536.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2015-April/155828.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-updates/2015-03/msg00061.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0439.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://rhn.redhat.com/errata/RHSA-2015-0794.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.mandriva.com/security/advisories?name=MDVSA-2015:009", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.oracle.com/technetwork/topics/security/bulletinapr2015-2511959.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/71679", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1031376", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-2498-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=773226", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/krb5/krb5/commit/d1f707024f1d0af6e54a18885322d70fa15ec4d3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2018/01/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/krb5/krb5/commit/d1f707024f1d0af6e54a18885322d70fa15ec4d3"}}