{"buggy_code": ["install plugin server_audit soname 'server_audit';\nshow variables like 'server_audit%';\nVariable_name\tValue\nserver_audit_events\t\nserver_audit_excl_users\t\nserver_audit_file_path\tserver_audit.log\nserver_audit_file_rotate_now\tOFF\nserver_audit_file_rotate_size\t1000000\nserver_audit_file_rotations\t9\nserver_audit_incl_users\t\nserver_audit_logging\tOFF\nserver_audit_mode\t0\nserver_audit_output_type\tfile\nserver_audit_query_log_limit\t1024\nserver_audit_syslog_facility\tLOG_USER\nserver_audit_syslog_ident\tmysql-server_auditing\nserver_audit_syslog_info\t\nserver_audit_syslog_priority\tLOG_INFO\nset global server_audit_file_path=null;\nset global server_audit_incl_users=null;\nset global server_audit_file_path='server_audit.log';\nset global server_audit_output_type=file;\nset global server_audit_logging=on;\nset global server_audit_incl_users= repeat(\"'root',\", 10000);\nERROR 42000: Variable 'server_audit_incl_users' can't be set to the value of ''root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','...'\nshow variables like 'server_audit_incl_users';\nVariable_name\tValue\nserver_audit_incl_users\t\nset global server_audit_excl_users= repeat(\"'root',\", 10000);\nERROR 42000: Variable 'server_audit_excl_users' can't be set to the value of ''root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','...'\nshow variables like 'server_audit_excl_users';\nVariable_name\tValue\nserver_audit_excl_users\t\nconnect  con1,localhost,root,,mysql;\ndisconnect con1;\nconnect(localhost,no_such_user,,mysql,MASTER_PORT,MASTER_SOCKET);\nconnect  con1,localhost,no_such_user,,mysql;\nERROR 28000: Access denied for user 'no_such_user'@'localhost' (using password: NO)\nconnection default;\nset global server_audit_incl_users='odin, dva, tri';\ncreate table t1 (id int);\nset global server_audit_incl_users='odin, root, dva, tri';\ncreate table t2 (id int);\nset global server_audit_excl_users='odin, dva, tri';\nWarnings:\nWarning\t1\tUser 'odin' is in the server_audit_incl_users, so wasn't added.\nWarning\t1\tUser 'dva' is in the server_audit_incl_users, so wasn't added.\nWarning\t1\tUser 'tri' is in the server_audit_incl_users, so wasn't added.\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nset global server_audit_incl_users='odin, root, dva, tri';\ninsert into t2 values (1), (2);\nselect * from t2;\nid\n1\n2\nalter table t1 rename renamed_t1;\nset global server_audit_events='connect,query';\nselect 1,\n2,\n# comment\n3;\n1\t2\t3\n1\t2\t3\ninsert into t2 values (1), (2);\nselect * from t2;\nid\n1\n2\n1\n2\nselect * from t_doesnt_exist;\nERROR 42S02: Table 'test.t_doesnt_exist' doesn't exist\nsyntax_error_query;\nERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'syntax_error_query' at line 1\ndrop table renamed_t1, t2;\nshow variables like 'server_audit%';\nVariable_name\tValue\nserver_audit_events\tCONNECT,QUERY\nserver_audit_excl_users\t\nserver_audit_file_path\tserver_audit.log\nserver_audit_file_rotate_now\tOFF\nserver_audit_file_rotate_size\t1000000\nserver_audit_file_rotations\t9\nserver_audit_incl_users\todin, root, dva, tri\nserver_audit_logging\tON\nserver_audit_mode\t0\nserver_audit_output_type\tfile\nserver_audit_query_log_limit\t1024\nserver_audit_syslog_facility\tLOG_USER\nserver_audit_syslog_ident\tmysql-server_auditing\nserver_audit_syslog_info\t\nserver_audit_syslog_priority\tLOG_INFO\nset global server_audit_mode=1;\nset global server_audit_events='';\ncreate database sa_db;\nconnect  con1,localhost,root,,test;\ncreate table t1 (id2 int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid2\n1\n2\ndrop table t1;\nuse sa_db;\ncreate table sa_t1(id int);\ninsert into sa_t1 values (1), (2);\ndrop table sa_t1;\ndrop database sa_db;\ndisconnect con1;\nconnection default;\ncreate database sa_db;\nuse sa_db;\nCREATE USER u1 IDENTIFIED BY 'pwd-123';\nGRANT ALL ON sa_db TO u2 IDENTIFIED BY \"pwd-321\";\nSET PASSWORD FOR u1 = PASSWORD('pwd 098');\nCREATE USER u3 IDENTIFIED BY '';\nALTER USER u3 IDENTIFIED BY 'pwd-456';\ndrop user u1, u2, u3;\nset global server_audit_events='query_ddl';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nselect 2;\n2\n2\n(select 2);\n2\n2\n/*! select 2*/;\n2\n2\n/*comment*/ select 2;\n2\n2\ndrop table t1;\ncreate procedure pr1() insert into test.t1 values (\"foo\", 42);\ncreate function fn1(i int) returns int deterministic return i+1;\ndrop procedure pr1;\ndrop function fn1;\nset global server_audit_events='query_ddl,query_dml';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nselect 2;\n2\n2\ndrop table t1;\nset global server_audit_events='query_dml';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nselect 2;\n2\n2\n(select 2);\n2\n2\n/*! select 2*/;\n2\n2\n/*comment*/ select 2;\n2\n2\ndrop table t1;\nset global server_audit_events='query_dcl';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nCREATE USER u1 IDENTIFIED BY 'pwd-123';\nGRANT ALL ON sa_db TO u2 IDENTIFIED BY \"pwd-321\";\nSET PASSWORD \n# comment\nFOR u1 = PASSWORD('pwd 098');\nSET PASSWORD FOR u1=<secret>;\nERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '<secret>' at line 1\nCREATE USER u3 IDENTIFIED BY '';\ndrop user u1, u2, u3;\nselect 2;\n2\n2\n(select 2);\n2\n2\n/*! select 2*/;\n2\n2\n/*comment*/ select 2;\n2\n2\ndrop table t1;\nset global server_audit_events='query_dml_no_select';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nselect 2;\n2\n2\ndrop table t1;\ncreate procedure pr1() insert into test.t1 values (\"foo\", 42);\ncreate function fn1(i int) returns int deterministic return i+1;\ndrop procedure pr1;\ndrop function fn1;\nset global server_audit_events='table';\nset global server_audit_incl_users='user1';\ncreate user user1@localhost;\ngrant all on sa_db.* to user1@localhost;\nconnect  cn1,localhost,user1,,sa_db;\nconnection cn1;\ncreate table t1(id int) engine=myisam;\ninsert delayed into t1 values (1);\nconnection default;\n# Waiting until INSERT DELAYED thread does the insert.\ndrop table t1;\nset global server_audit_logging= off;\nset global server_audit_incl_users='root';\nset global server_audit_logging= on;\ndisconnect cn1;\ndrop user user1@localhost;\nset global server_audit_events='';\nset global server_audit_incl_users='root, plug_dest';\nCREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest';\nCREATE USER plug_dest IDENTIFIED BY 'plug_dest_passwd';\nconnect(localhost,plug,plug_dest,test,MYSQL_PORT,MYSQL_SOCK);\nconnect plug_con,localhost,plug,plug_dest;\nERROR 28000: Access denied for user 'plug'@'localhost' (using password: YES)\nGRANT PROXY ON plug_dest TO plug;\nconnect plug_con,localhost,plug,plug_dest;\nconnection plug_con;\nselect USER(),CURRENT_USER();\nUSER()\tCURRENT_USER()\nplug@localhost\tplug_dest@%\nconnection default;\ndisconnect plug_con;\nDROP USER plug;\nDROP USER plug_dest;\nset global server_audit_query_log_limit= 15;\nselect (1), (2), (3), (4);\n1\t2\t3\t4\n1\t2\t3\t4\nselect 'A', 'B', 'C', 'D';\nA\tB\tC\tD\nA\tB\tC\tD\nset global server_audit_query_log_limit= 1024;\ndrop database sa_db;\nset global server_audit_file_path='.';\nshow status like 'server_audit_current_log';\nVariable_name\tValue\nServer_audit_current_log\tHOME_DIR/server_audit.log\nset global server_audit_file_path='';\nshow status like 'server_audit_current_log';\nVariable_name\tValue\nServer_audit_current_log\tserver_audit.log\nset global server_audit_file_path='  ';\nshow status like 'server_audit_current_log';\nVariable_name\tValue\nServer_audit_current_log\tserver_audit.log\nset global server_audit_file_path='nonexisting_dir/';\nWarnings:\nWarning\t1\tSERVER AUDIT plugin can't create file 'nonexisting_dir/'.\nshow status like 'server_audit_current_log';\nVariable_name\tValue\nServer_audit_current_log\tserver_audit.log\nshow variables like 'server_audit%';\nVariable_name\tValue\nserver_audit_events\t\nserver_audit_excl_users\t\nserver_audit_file_path\t  \nserver_audit_file_rotate_now\tOFF\nserver_audit_file_rotate_size\t1000000\nserver_audit_file_rotations\t9\nserver_audit_incl_users\troot, plug_dest\nserver_audit_logging\tON\nserver_audit_mode\t1\nserver_audit_output_type\tfile\nserver_audit_query_log_limit\t1024\nserver_audit_syslog_facility\tLOG_USER\nserver_audit_syslog_ident\tmysql-server_auditing\nserver_audit_syslog_info\t\nserver_audit_syslog_priority\tLOG_INFO\nuninstall plugin server_audit;\nWarnings:\nWarning\t1620\tPlugin is busy and will be uninstalled on shutdown\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_logging=on',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_incl_users= repeat(\"\\'root\\',\", 10000)',ID\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'show variables like \\'server_audit_incl_users\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_excl_users= repeat(\"\\'root\\',\", 10000)',ID\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'show variables like \\'server_audit_excl_users\\'',0\nTIME,HOSTNAME,root,localhost,ID,0,CONNECT,mysql,,0\nTIME,HOSTNAME,root,localhost,ID,0,DISCONNECT,mysql,,0\nTIME,HOSTNAME,no_such_user,localhost,ID,0,FAILED_CONNECT,,,ID\nTIME,HOSTNAME,no_such_user,localhost,ID,0,DISCONNECT,,,0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_incl_users=\\'odin, dva, tri\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_incl_users=\\'odin, root, dva, tri\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,CREATE,test,t2,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'create table t2 (id int)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_excl_users=\\'odin, dva, tri\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'SHOW WARNINGS',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'insert into t1 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,READ,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select * from t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_incl_users=\\'odin, root, dva, tri\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,test,t2,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'insert into t2 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,READ,test,t2,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select * from t2',0\nTIME,HOSTNAME,root,localhost,ID,ID,ALTER,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,table_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,column_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,index_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,RENAME,test,t1|test.renamed_t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'alter table t1 rename renamed_t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_events=\\'connect,query\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select 1,\\n2,\\n# comment\\n3',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'insert into t2 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select * from t2',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select * from t_doesnt_exist',ID\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'syntax_error_query',ID\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'drop table renamed_t1, t2',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'show variables like \\'server_audit%\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_mode=1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_events=\\'\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'create database sa_db',0\nTIME,HOSTNAME,root,localhost,ID,0,CONNECT,test,,0\nTIME,HOSTNAME,root,localhost,ID,ID,CREATE,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'create table t1 (id2 int)',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'insert into t1 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,READ,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select * from t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,table_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,column_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,index_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,DROP,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'drop table t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'use sa_db',0\nTIME,HOSTNAME,root,localhost,ID,ID,CREATE,sa_db,sa_t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'create table sa_t1(id int)',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,sa_db,sa_t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'insert into sa_t1 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,table_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,column_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,index_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,DROP,sa_db,sa_t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop table sa_t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,READ,mysql,proc,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proc,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,event,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop database sa_db',0\nTIME,HOSTNAME,root,localhost,ID,0,DISCONNECT,,,0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'create database sa_db',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'use sa_db',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER u1 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'GRANT ALL ON sa_db TO u2 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'SET PASSWORD FOR u1 = PASSWORD(*****)',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER u3 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'ALTER USER u3 IDENTIFIED BY \\'pwd-456\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop user u1, u2, u3',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'create table t1(id int)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop table t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'create procedure pr1() insert into test.t1 values (\"foo\", 42)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'create function fn1(i int) returns int deterministic return i+1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop procedure pr1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop function fn1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'create table t1(id int)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'insert into t1 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select * from t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select 2',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop table t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'insert into t1 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select * from t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select 2',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'(select 2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'/*! select 2*/',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'/*comment*/ select 2',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER u1 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'GRANT ALL ON sa_db TO u2 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'SET PASSWORD \\n# comment\\nFOR u1 = PASSWORD(*****)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'SET PASSWORD FOR u1=<secret>',ID\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER u3 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop user u1, u2, u3',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'insert into t1 values (1), (2)',0\nTIME,HOSTNAME,user1,localhost,ID,ID,CREATE,sa_db,t1,\nTIME,HOSTNAME,user1,localhost,ID,ID,WRITE,sa_db,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_logging= off',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_events=\\'\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_incl_users=\\'root, plug_dest\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER plug IDENTIFIED WITH \\'test_plugin_server\\' AS \\'plug_dest\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER plug_dest IDENTIFIED BY *****',0\nTIME,HOSTNAME,plug,localhost,ID,0,FAILED_CONNECT,,,ID\nTIME,HOSTNAME,plug,localhost,ID,0,DISCONNECT,,,0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'GRANT PROXY ON plug_dest TO plug',0\nTIME,HOSTNAME,plug,localhost,ID,0,CONNECT,test,,0\nTIME,HOSTNAME,plug,localhost,ID,0,PROXY_CONNECT,test,`plug_dest`@`%`,0\nTIME,HOSTNAME,plug,localhost,ID,ID,QUERY,test,'select USER(),CURRENT_USER()',0\nTIME,HOSTNAME,plug,localhost,ID,0,DISCONNECT,test,,0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'DROP USER plug',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'DROP USER plug_dest',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global serv',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select \\'A\\', ',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_query_log_limit= 1024',0\nTIME,HOSTNAME,root,localhost,ID,ID,READ,mysql,proc,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proc,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,event,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop database sa_db',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'.\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'.\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'show status like \\'server_audit_current_log\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'show status like \\'server_audit_current_log\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'  \\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'  \\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'show status like \\'server_audit_current_log\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'nonexisting_dir/\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'nonexisting_dir/\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'SHOW WARNINGS',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'show status like \\'server_audit_current_log\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'show variables like \\'server_audit%\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,plugin,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'uninstall plugin server_audit',0\n", "--source include/have_plugin_auth.inc\n--source include/not_embedded.inc\n\nif (!$SERVER_AUDIT_SO) {\n  skip No SERVER_AUDIT plugin;\n}\n\n# An unfortunate wait for check-testcase.test to complete disconnect.\nlet count_sessions= 1;\nsource include/wait_until_count_sessions.inc;\n\nlet $MYSQLD_DATADIR= `SELECT @@datadir`;\nlet SEARCH_FILE= $MYSQLD_DATADIR/server_audit.log;\n\ninstall plugin server_audit soname 'server_audit';\n\nshow variables like 'server_audit%';\nset global server_audit_file_path=null;\nset global server_audit_incl_users=null;\nset global server_audit_file_path='server_audit.log';\nset global server_audit_output_type=file;\nset global server_audit_logging=on;\n\n--error ER_WRONG_VALUE_FOR_VAR\nset global server_audit_incl_users= repeat(\"'root',\", 10000);\nshow variables like 'server_audit_incl_users';\n--error ER_WRONG_VALUE_FOR_VAR\nset global server_audit_excl_users= repeat(\"'root',\", 10000);\nshow variables like 'server_audit_excl_users';\nlet SEARCH_COUNT= 5;\nsource include/wait_for_line_count_in_file.inc;\n\nconnect (con1,localhost,root,,mysql);\ndisconnect con1;\nlet SEARCH_COUNT= 7;\nsource include/wait_for_line_count_in_file.inc;\n\n--replace_result $MASTER_MYSOCK MASTER_SOCKET $MASTER_MYPORT MASTER_PORT\n--error ER_ACCESS_DENIED_ERROR\nconnect (con1,localhost,no_such_user,,mysql);\nlet SEARCH_COUNT= 9;\nsource include/wait_for_line_count_in_file.inc;\n\nconnection default;\nset global server_audit_incl_users='odin, dva, tri';\ncreate table t1 (id int);\nset global server_audit_incl_users='odin, root, dva, tri';\ncreate table t2 (id int);\nset global server_audit_excl_users='odin, dva, tri';\ninsert into t1 values (1), (2);\nselect * from t1;\nset global server_audit_incl_users='odin, root, dva, tri';\ninsert into t2 values (1), (2);\nselect * from t2;\nalter table t1 rename renamed_t1;\nset global server_audit_events='connect,query';\nselect 1,\n        2,\n# comment\n        3;\ninsert into t2 values (1), (2);\nselect * from t2;\n--disable_ps_protocol\n--error ER_NO_SUCH_TABLE\nselect * from t_doesnt_exist;\n--enable_ps_protocol\n--error 1064\nsyntax_error_query;\ndrop table renamed_t1, t2;\nshow variables like 'server_audit%';\nset global server_audit_mode=1;\nset global server_audit_events='';\ncreate database sa_db;\nlet SEARCH_COUNT= 41;\nsource include/wait_for_line_count_in_file.inc;\n\nconnect (con1,localhost,root,,test);\ncreate table t1 (id2 int);\ninsert into t1 values (1), (2);\nselect * from t1;\ndrop table t1;\nuse sa_db;\ncreate table sa_t1(id int);\ninsert into sa_t1 values (1), (2);\ndrop table sa_t1;\ndrop database sa_db;\ndisconnect con1;\nlet SEARCH_COUNT= 68;\nsource include/wait_for_line_count_in_file.inc;\n\nconnection default;\ncreate database sa_db;\nuse sa_db;\nCREATE USER u1 IDENTIFIED BY 'pwd-123';\nGRANT ALL ON sa_db TO u2 IDENTIFIED BY \"pwd-321\";\nSET PASSWORD FOR u1 = PASSWORD('pwd 098');\nCREATE USER u3 IDENTIFIED BY '';\nALTER USER u3 IDENTIFIED BY 'pwd-456';\ndrop user u1, u2, u3;\n\nset global server_audit_events='query_ddl';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nselect 2;\n(select 2);\n/*! select 2*/;\n/*comment*/ select 2;\ndrop table t1;\ncreate procedure pr1() insert into test.t1 values (\"foo\", 42);\ncreate function fn1(i int) returns int deterministic return i+1;\ndrop procedure pr1;\ndrop function fn1;\n\nset global server_audit_events='query_ddl,query_dml';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nselect 2;\ndrop table t1;\nset global server_audit_events='query_dml';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nselect 2;\n(select 2);\n/*! select 2*/;\n/*comment*/ select 2;\ndrop table t1;\nset global server_audit_events='query_dcl';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nCREATE USER u1 IDENTIFIED BY 'pwd-123';\nGRANT ALL ON sa_db TO u2 IDENTIFIED BY \"pwd-321\";\nSET PASSWORD \n# comment\nFOR u1 = PASSWORD('pwd 098');\n--error 1064\nSET PASSWORD FOR u1=<secret>;\nCREATE USER u3 IDENTIFIED BY '';\ndrop user u1, u2, u3;\nselect 2;\n(select 2);\n/*! select 2*/;\n/*comment*/ select 2;\ndrop table t1;\nset global server_audit_events='query_dml_no_select';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nselect 2;\ndrop table t1;\ncreate procedure pr1() insert into test.t1 values (\"foo\", 42);\ncreate function fn1(i int) returns int deterministic return i+1;\ndrop procedure pr1;\ndrop function fn1;\n\nset global server_audit_events='table';\nset global server_audit_incl_users='user1';\n\ncreate user user1@localhost;\ngrant all on sa_db.* to user1@localhost;\n\nconnect (cn1,localhost,user1,,sa_db);\nconnection cn1;\n\ncreate table t1(id int) engine=myisam;\ninsert delayed into t1 values (1);\nconnection default;\n--echo # Waiting until INSERT DELAYED thread does the insert.\nlet $wait_condition= SELECT COUNT(*) = 1 FROM t1;\n--source include/wait_condition.inc\ndrop table t1;\n\nset global server_audit_logging= off;\nset global server_audit_incl_users='root';\nset global server_audit_logging= on;\ndisconnect cn1;\nlet $count_sessions=1;\nsource include/wait_until_count_sessions.inc;\n\ndrop user user1@localhost;\n\nset global server_audit_events='';\nset global server_audit_incl_users='root, plug_dest';\n\nCREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest';\nCREATE USER plug_dest IDENTIFIED BY 'plug_dest_passwd';\n--sleep 2\n--replace_result $MASTER_MYPORT MYSQL_PORT $MASTER_MYSOCK MYSQL_SOCK\n--error ER_ACCESS_DENIED_ERROR : this should fail : no grant\nconnect(plug_con,localhost,plug,plug_dest);\n--sleep 2\nGRANT PROXY ON plug_dest TO plug;\n--sleep 2\nconnect(plug_con,localhost,plug,plug_dest);\nconnection plug_con;\nselect USER(),CURRENT_USER();\nconnection default;\ndisconnect plug_con;\n--sleep 2\n--sleep 2\nDROP USER plug;\nDROP USER plug_dest;\n\nset global server_audit_query_log_limit= 15;\nselect (1), (2), (3), (4);\nselect 'A', 'B', 'C', 'D';\nset global server_audit_query_log_limit= 1024;\ndrop database sa_db;\n\nset global server_audit_file_path='.';\n--replace_regex /\\.[\\\\\\/]/HOME_DIR\\//\nshow status like 'server_audit_current_log';\nset global server_audit_file_path='';\nshow status like 'server_audit_current_log';\nset global server_audit_file_path='  ';\nshow status like 'server_audit_current_log';\nset global server_audit_file_path='nonexisting_dir/';\nshow status like 'server_audit_current_log';\nshow variables like 'server_audit%';\nuninstall plugin server_audit;\n\n# replace the timestamp and the hostname with constant values\n--replace_regex /[0-9]* [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\,[^,]*\\,/TIME,HOSTNAME,/ /\\,[1-9][0-9]*\\,/,1,/ /\\,[1-9][0-9]*/,ID/\ncat_file $MYSQLD_DATADIR/server_audit.log;\nremove_file $MYSQLD_DATADIR/server_audit.log;\n\n", "/* Copyright (C) 2013, 2015, Alexey Botchkov and SkySQL Ab\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA */\n\n\n#define PLUGIN_VERSION 0x104\n#define PLUGIN_STR_VERSION \"1.4.12\"\n\n#define _my_thread_var loc_thread_var\n\n#include <my_config.h>\n#include <stdio.h>\n#include <time.h>\n#include <string.h>\n#include <fcntl.h>\n#include <assert.h>\n\n#ifndef _WIN32\n#define DO_SYSLOG\n#include <syslog.h>\nstatic const char out_type_desc[]= \"Desired output type. Possible values - 'syslog', 'file'\"\n                                   \" or 'null' as no output.\";\n#else\nstatic const char out_type_desc[]= \"Desired output type. Possible values - 'file'\"\n                                   \" or 'null' as no output.\";\n#define syslog(PRIORITY, FORMAT, INFO, MESSAGE_LEN, MESSAGE) do {}while(0)\nstatic void closelog() {}\n#define openlog(IDENT, LOG_NOWAIT, LOG_USER)  do {}while(0)\n\n/* priorities */\n#define LOG_EMERG       0       /* system is unusable */\n#define LOG_ALERT       1       /* action must be taken immediately */\n#define LOG_CRIT        2       /* critical conditions */\n#define LOG_ERR         3       /* error conditions */\n#define LOG_WARNING     4       /* warning conditions */\n#define LOG_NOTICE      5       /* normal but significant condition */\n#define LOG_INFO        6       /* informational */\n#define LOG_DEBUG       7       /* debug-level messages */\n\n#define LOG_MAKEPRI(fac, pri)   (((fac) << 3) | (pri))\n\n/* facility codes */\n#define LOG_KERN        (0<<3)  /* kernel messages */\n#define LOG_USER        (1<<3)  /* random user-level messages */\n#define LOG_MAIL        (2<<3)  /* mail system */\n#define LOG_DAEMON      (3<<3)  /* system daemons */\n#define LOG_AUTH        (4<<3)  /* security/authorization messages */\n#define LOG_SYSLOG      (5<<3)  /* messages generated internally by syslogd */\n#define LOG_LPR         (6<<3)  /* line printer subsystem */\n#define LOG_NEWS        (7<<3)  /* network news subsystem */\n#define LOG_UUCP        (8<<3)  /* UUCP subsystem */\n#define LOG_CRON        (9<<3)  /* clock daemon */\n#define LOG_AUTHPRIV    (10<<3) /* security/authorization messages (private) */\n#define LOG_FTP         (11<<3) /* ftp daemon */\n#define LOG_LOCAL0      (16<<3) /* reserved for local use */\n#define LOG_LOCAL1      (17<<3) /* reserved for local use */\n#define LOG_LOCAL2      (18<<3) /* reserved for local use */\n#define LOG_LOCAL3      (19<<3) /* reserved for local use */\n#define LOG_LOCAL4      (20<<3) /* reserved for local use */\n#define LOG_LOCAL5      (21<<3) /* reserved for local use */\n#define LOG_LOCAL6      (22<<3) /* reserved for local use */\n#define LOG_LOCAL7      (23<<3) /* reserved for local use */\n\n#endif /*!_WIN32*/\n\n/*\n   Defines that can be used to reshape the pluging:\n   #define MARIADB_ONLY\n   #define USE_MARIA_PLUGIN_INTERFACE\n*/\n\n#if !defined(MYSQL_DYNAMIC_PLUGIN) && !defined(MARIADB_ONLY)\n#define MARIADB_ONLY\n#endif /*MYSQL_PLUGIN_DYNAMIC*/\n\n#ifndef MARIADB_ONLY\n#define MYSQL_SERVICE_LOGGER_INCLUDED\n#endif /*MARIADB_ONLY*/\n\n#include <my_base.h>\n//#include <my_dir.h>\n#include <typelib.h>\n#include <mysql/plugin.h>\n#include <mysql/plugin_audit.h>\n#include \"../../mysys/mysys_priv.h\"\n#ifndef RTLD_DEFAULT\n#define RTLD_DEFAULT NULL\n#endif\n\n#ifndef MARIADB_ONLY\n#undef MYSQL_SERVICE_LOGGER_INCLUDED\n#undef MYSQL_DYNAMIC_PLUGIN\n#define FLOGGER_NO_PSI\n\n/* How to access the pthread_mutex in mysql_mutex_t */\n#ifdef SAFE_MUTEX\n#define mysql_mutex_real_mutex(A) &(A)->m_mutex.mutex\n#else\n#define mysql_mutex_real_mutex(A) &(A)->m_mutex\n#endif\n\n#define flogger_mutex_init(A,B,C) do{}while(0)\n#define flogger_mutex_destroy(A) do{}while(0)\n#define flogger_mutex_lock(A) do{}while(0)\n#define flogger_mutex_unlock(A) do{}while(0)\n\nstatic char **int_mysql_data_home;\nstatic char *default_home= (char *)\".\";\n#define mysql_data_home (*int_mysql_data_home)\n\n#define FLOGGER_SKIP_INCLUDES\n#define my_open(A, B, C) loc_open(A, B)\n#define my_close(A, B) loc_close(A)\n#define my_rename(A, B, C) loc_rename(A, B)\n#define my_tell(A, B) loc_tell(A)\n#define my_write(A, B, C, D) loc_write(A, B, C)\n#define my_malloc(A, B) malloc(A)\n#define my_free(A) free(A)\n#ifdef my_errno\n  #undef my_errno\n#endif\nstatic int loc_file_errno;\n#define my_errno loc_file_errno\n#ifdef my_vsnprintf\n  #undef my_vsnprintf\n#endif\n#define my_vsnprintf vsnprintf\n#define logger_open loc_logger_open\n#define logger_close loc_logger_close\n#define logger_write loc_logger_write\n#define logger_rotate loc_logger_rotate\n#define logger_init_mutexts loc_logger_init_mutexts\n\n\nstatic size_t loc_write(File Filedes, const uchar *Buffer, size_t Count)\n{\n  size_t writtenbytes;\n#ifdef _WIN32\n  writtenbytes= (size_t)_write(Filedes, Buffer, (unsigned int)Count);\n#else\n  writtenbytes= write(Filedes, Buffer, Count);\n#endif\n  return writtenbytes;\n}\n\n\nstatic File loc_open(const char *FileName, int Flags)\n\t\t\t\t/* Path-name of file */\n\t\t\t\t/* Read | write .. */\n\t\t\t\t/* Special flags */\n{\n  File fd;\n#ifdef _WIN32\n  HANDLE h;\n  /*\n    We could just use _open() here. but prefer to open in unix-similar way\n    just like my_open() does it on Windows.\n    This gives atomic multiprocess-safe appends, and possibility to rename\n    or even delete file while it is open, and CRT lacks this features.\n  */\n  assert(Flags == (O_APPEND | O_CREAT | O_WRONLY));\n  h= CreateFile(FileName, FILE_APPEND_DATA,\n    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, NULL,\n    OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n  if (h == INVALID_HANDLE_VALUE)\n  {\n    fd= -1;\n    my_osmaperr(GetLastError());\n  }\n  else\n  {\n    fd= _open_osfhandle((intptr)h, O_WRONLY|O_BINARY);\n  }\n#else\n  fd= open(FileName, Flags, my_umask);\n#endif\n  my_errno= errno;\n  return fd;\n} \n\n\nstatic int loc_close(File fd)\n{\n  int err;\n#ifndef _WIN32\n  do\n  {\n    err= close(fd);\n  } while (err == -1 && errno == EINTR);\n#else\n  err= close(fd);\n#endif\n  my_errno=errno;\n  return err;\n}\n\n\nstatic int loc_rename(const char *from, const char *to)\n{\n  int error = 0;\n\n#if defined(__WIN__)\n  if (!MoveFileEx(from, to, MOVEFILE_COPY_ALLOWED |\n                            MOVEFILE_REPLACE_EXISTING))\n  {\n    my_osmaperr(GetLastError());\n#elif defined(HAVE_RENAME)\n  if (rename(from,to))\n  {\n#else\n  if (link(from, to) || unlink(from))\n  {\n#endif\n    my_errno=errno;\n    error = -1;\n  }\n  return error;\n}\n\n\nstatic my_off_t loc_tell(File fd)\n{\n  os_off_t pos= IF_WIN(_telli64(fd),lseek(fd, 0, SEEK_CUR));\n  if (pos == (os_off_t) -1)\n  {\n    my_errno= errno;\n  }\n  return (my_off_t) pos;\n}\n\n#ifdef HAVE_PSI_INTERFACE\n#undef HAVE_PSI_INTERFACE\n#include <mysql/service_logger.h>\n#include \"../../mysys/file_logger.c\"\n#define HAVE_PSI_INTERFACE\n#else\n#include <mysql/service_logger.h>\n#include \"../../mysys/file_logger.c\"\n#endif\n#endif /*!MARIADB_ONLY*/\n\n#undef flogger_mutex_init\n#undef flogger_mutex_destroy\n#undef flogger_mutex_lock\n#undef flogger_mutex_unlock\n\n#define flogger_mutex_init(A,B,C) pthread_mutex_init(mysql_mutex_real_mutex(B), C)\n#define flogger_mutex_destroy(A) pthread_mutex_destroy(mysql_mutex_real_mutex(A))\n#define flogger_mutex_lock(A) pthread_mutex_lock(mysql_mutex_real_mutex(A))\n#define flogger_mutex_unlock(A) pthread_mutex_unlock(mysql_mutex_real_mutex(A))\n\n#ifndef DBUG_OFF\n#define PLUGIN_DEBUG_VERSION \"-debug\"\n#else\n#define PLUGIN_DEBUG_VERSION \"\"\n#endif /*DBUG_OFF*/\n/*\n Disable __attribute__() on non-gcc compilers.\n*/\n#if !defined(__attribute__) && !defined(__GNUC__)\n#define __attribute__(A)\n#endif\n\n#ifdef _WIN32\n#define localtime_r(a, b) localtime_s(b, a)\n#endif /*WIN32*/\n\n\nextern char server_version[];\nstatic const char *serv_ver= NULL;\nstatic int started_mysql= 0;\nstatic int mysql_57_started= 0;\nstatic int debug_server_started= 0;\nstatic int use_event_data_for_disconnect= 0;\nstatic int started_mariadb= 0;\nstatic int maria_55_started= 0;\nstatic int maria_above_5= 0;\nstatic char *incl_users, *excl_users,\n            *file_path, *syslog_info;\nstatic char path_buffer[FN_REFLEN];\nstatic unsigned int mode, mode_readonly= 0;\nstatic ulong output_type;\nstatic ulong syslog_facility, syslog_priority;\n\nstatic ulonglong events; /* mask for events to log */\nstatic unsigned long long file_rotate_size;\nstatic unsigned int rotations;\nstatic my_bool rotate= TRUE;\nstatic char logging;\nstatic volatile int internal_stop_logging= 0;\nstatic char incl_user_buffer[1024];\nstatic char excl_user_buffer[1024];\nstatic char *big_buffer= NULL;\nstatic size_t big_buffer_alloced= 0;\nstatic unsigned int query_log_limit= 0;\n\nstatic char servhost[256];\nstatic uint servhost_len;\nstatic char *syslog_ident;\nstatic char syslog_ident_buffer[128]= \"mysql-server_auditing\";\n\nstruct connection_info\n{\n  int header;\n  unsigned long thread_id;\n  unsigned long long query_id;\n  char db[256];\n  int db_length;\n  char user[64];\n  int user_length;\n  char host[64];\n  int host_length;\n  char ip[64];\n  int ip_length;\n  const char *query;\n  int query_length;\n  char query_buffer[1024];\n  time_t query_time;\n  int log_always;\n  char proxy[64];\n  int proxy_length;\n  char proxy_host[64];\n  int proxy_host_length;\n};\n\n#define DEFAULT_FILENAME_LEN 16\nstatic char default_file_name[DEFAULT_FILENAME_LEN+1]= \"server_audit.log\";\n\nstatic void update_file_path(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                             void *var_ptr, const void *save);\nstatic void update_file_rotate_size(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                    void *var_ptr, const void *save);\nstatic void update_file_rotations(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                  void *var_ptr, const void *save);\nstatic void update_incl_users(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                              void *var_ptr, const void *save);\nstatic int check_incl_users(MYSQL_THD thd, struct st_mysql_sys_var *var, void *save,\n                            struct st_mysql_value *value);\nstatic int check_excl_users(MYSQL_THD thd, struct st_mysql_sys_var *var, void *save,\n                            struct st_mysql_value *value);\nstatic void update_excl_users(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                              void *var_ptr, const void *save);\nstatic void update_output_type(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                               void *var_ptr, const void *save);\nstatic void update_syslog_facility(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                   void *var_ptr, const void *save);\nstatic void update_syslog_priority(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                   void *var_ptr, const void *save);\nstatic void update_mode(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                        void *var_ptr, const void *save);\nstatic void update_logging(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                           void *var_ptr, const void *save);\nstatic void update_syslog_ident(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                void *var_ptr, const void *save);\nstatic void rotate_log(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                       void *var_ptr, const void *save);\n\nstatic MYSQL_SYSVAR_STR(incl_users, incl_users, PLUGIN_VAR_RQCMDARG,\n       \"Comma separated list of users to monitor.\",\n       check_incl_users, update_incl_users, NULL);\nstatic MYSQL_SYSVAR_STR(excl_users, excl_users, PLUGIN_VAR_RQCMDARG,\n       \"Comma separated list of users to exclude from auditing.\",\n       check_excl_users, update_excl_users, NULL);\n/* bits in the event filter. */\n#define EVENT_CONNECT 1\n#define EVENT_QUERY_ALL 2\n#define EVENT_QUERY 122\n#define EVENT_TABLE 4\n#define EVENT_QUERY_DDL 8\n#define EVENT_QUERY_DML 16\n#define EVENT_QUERY_DCL 32\n#define EVENT_QUERY_DML_NO_SELECT 64\n\nstatic const char *event_names[]=\n{\n  \"CONNECT\", \"QUERY\", \"TABLE\", \"QUERY_DDL\", \"QUERY_DML\", \"QUERY_DCL\",\n  \"QUERY_DML_NO_SELECT\", NULL\n};\nstatic TYPELIB events_typelib=\n{\n  array_elements(event_names) - 1, \"\", event_names, NULL\n};\nstatic MYSQL_SYSVAR_SET(events, events, PLUGIN_VAR_RQCMDARG,\n       \"Specifies the set of events to monitor. Can be CONNECT, QUERY, TABLE,\"\n           \" QUERY_DDL, QUERY_DML, QUERY_DML_NO_SELECT, QUERY_DCL.\",\n       NULL, NULL, 0, &events_typelib);\n#ifdef DO_SYSLOG\n#define OUTPUT_SYSLOG 0\n#define OUTPUT_FILE 1\n#else\n#define OUTPUT_SYSLOG 0xFFFF\n#define OUTPUT_FILE 0\n#endif /*DO_SYSLOG*/\n\n#define OUTPUT_NO 0xFFFF\nstatic const char *output_type_names[]= {\n#ifdef DO_SYSLOG\n  \"syslog\",\n#endif\n  \"file\", 0 };\nstatic TYPELIB output_typelib=\n{\n    array_elements(output_type_names) - 1, \"output_typelib\",\n    output_type_names, NULL\n};\nstatic MYSQL_SYSVAR_ENUM(output_type, output_type, PLUGIN_VAR_RQCMDARG,\n       out_type_desc,\n       0, update_output_type, OUTPUT_FILE,\n       &output_typelib);\nstatic MYSQL_SYSVAR_STR(file_path, file_path, PLUGIN_VAR_RQCMDARG,\n       \"Path to the log file.\", NULL, update_file_path, default_file_name);\nstatic MYSQL_SYSVAR_ULONGLONG(file_rotate_size, file_rotate_size,\n       PLUGIN_VAR_RQCMDARG, \"Maximum size of the log to start the rotation.\",\n       NULL, update_file_rotate_size,\n       1000000, 100, ((long long) 0x7FFFFFFFFFFFFFFFLL), 1);\nstatic MYSQL_SYSVAR_UINT(file_rotations, rotations,\n       PLUGIN_VAR_RQCMDARG, \"Number of rotations before log is removed.\",\n       NULL, update_file_rotations, 9, 0, 999, 1);\nstatic MYSQL_SYSVAR_BOOL(file_rotate_now, rotate, PLUGIN_VAR_OPCMDARG,\n       \"Force log rotation now.\", NULL, rotate_log, FALSE);\nstatic MYSQL_SYSVAR_BOOL(logging, logging,\n       PLUGIN_VAR_OPCMDARG, \"Turn on/off the logging.\", NULL,\n       update_logging, 0);\nstatic MYSQL_SYSVAR_UINT(mode, mode,\n       PLUGIN_VAR_OPCMDARG, \"Auditing mode.\", NULL, update_mode, 0, 0, 1, 1);\nstatic MYSQL_SYSVAR_STR(syslog_ident, syslog_ident, PLUGIN_VAR_RQCMDARG,\n       \"The SYSLOG identifier - the beginning of each SYSLOG record.\",\n       NULL, update_syslog_ident, syslog_ident_buffer);\nstatic MYSQL_SYSVAR_STR(syslog_info, syslog_info,\n       PLUGIN_VAR_RQCMDARG | PLUGIN_VAR_MEMALLOC,\n       \"The <info> string to be added to the SYSLOG record.\", NULL, NULL, \"\");\nstatic MYSQL_SYSVAR_UINT(query_log_limit, query_log_limit,\n       PLUGIN_VAR_OPCMDARG, \"Limit on the length of the query string in a record.\",\n       NULL, NULL, 1024, 0, 0x7FFFFFFF, 1);\n\nchar locinfo_ini_value[sizeof(struct connection_info)+4];\n\nstatic MYSQL_THDVAR_STR(loc_info,\n                        PLUGIN_VAR_NOSYSVAR | PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_MEMALLOC,\n                        \"Internal info\", NULL, NULL, locinfo_ini_value);\n\nstatic const char *syslog_facility_names[]=\n{\n  \"LOG_USER\", \"LOG_MAIL\", \"LOG_DAEMON\", \"LOG_AUTH\",\n  \"LOG_SYSLOG\", \"LOG_LPR\", \"LOG_NEWS\", \"LOG_UUCP\",\n  \"LOG_CRON\",\n#ifdef LOG_AUTHPRIV\n \"LOG_AUTHPRIV\",\n#endif\n#ifdef LOG_FTP\n \"LOG_FTP\",\n#endif\n  \"LOG_LOCAL0\", \"LOG_LOCAL1\", \"LOG_LOCAL2\", \"LOG_LOCAL3\",\n  \"LOG_LOCAL4\", \"LOG_LOCAL5\", \"LOG_LOCAL6\", \"LOG_LOCAL7\",\n  0\n};\nstatic unsigned int syslog_facility_codes[]=\n{\n  LOG_USER, LOG_MAIL, LOG_DAEMON, LOG_AUTH,\n  LOG_SYSLOG, LOG_LPR, LOG_NEWS, LOG_UUCP,\n  LOG_CRON,\n#ifdef LOG_AUTHPRIV\n LOG_AUTHPRIV,\n#endif\n#ifdef LOG_FTP\n  LOG_FTP,\n#endif\n  LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3,\n  LOG_LOCAL4, LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7,\n};\nstatic TYPELIB syslog_facility_typelib=\n{\n    array_elements(syslog_facility_names) - 1, \"syslog_facility_typelib\",\n    syslog_facility_names, NULL\n};\nstatic MYSQL_SYSVAR_ENUM(syslog_facility, syslog_facility, PLUGIN_VAR_RQCMDARG,\n       \"The 'facility' parameter of the SYSLOG record.\"\n       \" The default is LOG_USER.\", 0, update_syslog_facility, 0/*LOG_USER*/,\n       &syslog_facility_typelib);\n\nstatic const char *syslog_priority_names[]=\n{\n  \"LOG_EMERG\", \"LOG_ALERT\", \"LOG_CRIT\", \"LOG_ERR\",\n  \"LOG_WARNING\", \"LOG_NOTICE\", \"LOG_INFO\", \"LOG_DEBUG\",\n  0\n};\n\nstatic unsigned int syslog_priority_codes[]=\n{\n  LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR,\n  LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG,\n};\n\nstatic TYPELIB syslog_priority_typelib=\n{\n    array_elements(syslog_priority_names) - 1, \"syslog_priority_typelib\",\n    syslog_priority_names, NULL\n};\nstatic MYSQL_SYSVAR_ENUM(syslog_priority, syslog_priority, PLUGIN_VAR_RQCMDARG,\n       \"The 'priority' parameter of the SYSLOG record.\"\n       \" The default is LOG_INFO.\", 0, update_syslog_priority, 6/*LOG_INFO*/,\n       &syslog_priority_typelib);\n\n\nstatic struct st_mysql_sys_var* vars[] = {\n    MYSQL_SYSVAR(incl_users),\n    MYSQL_SYSVAR(excl_users),\n    MYSQL_SYSVAR(events),\n    MYSQL_SYSVAR(output_type),\n    MYSQL_SYSVAR(file_path),\n    MYSQL_SYSVAR(file_rotate_size),\n    MYSQL_SYSVAR(file_rotations),\n    MYSQL_SYSVAR(file_rotate_now),\n    MYSQL_SYSVAR(logging),\n    MYSQL_SYSVAR(mode),\n    MYSQL_SYSVAR(syslog_info),\n    MYSQL_SYSVAR(syslog_ident),\n    MYSQL_SYSVAR(syslog_facility),\n    MYSQL_SYSVAR(syslog_priority),\n    MYSQL_SYSVAR(query_log_limit),\n    MYSQL_SYSVAR(loc_info),\n    NULL\n};\n\n\n/* Status variables for SHOW STATUS */\nstatic int is_active= 0;\nstatic long log_write_failures= 0;\nstatic char current_log_buf[FN_REFLEN]= \"\";\nstatic char last_error_buf[512]= \"\";\n\nextern void *mysql_v4_descriptor;\n\nstatic struct st_mysql_show_var audit_status[]=\n{\n  {\"server_audit_active\", (char *)&is_active, SHOW_BOOL},\n  {\"server_audit_current_log\", current_log_buf, SHOW_CHAR},\n  {\"server_audit_writes_failed\", (char *)&log_write_failures, SHOW_LONG},\n  {\"server_audit_last_error\", last_error_buf, SHOW_CHAR},\n  {0,0,0}\n};\n\n#if defined(HAVE_PSI_INTERFACE) && !defined(FLOGGER_NO_PSI)\n/* These belong to the service initialization */\nstatic PSI_mutex_key key_LOCK_operations;\nstatic PSI_mutex_key key_LOCK_atomic;\nstatic PSI_mutex_key key_LOCK_bigbuffer;\nstatic PSI_mutex_info mutex_key_list[]=\n{\n  { &key_LOCK_operations, \"SERVER_AUDIT_plugin::lock_operations\",\n    PSI_FLAG_GLOBAL},\n  { &key_LOCK_atomic, \"SERVER_AUDIT_plugin::lock_atomic\",\n    PSI_FLAG_GLOBAL},\n  { &key_LOCK_bigbuffer, \"SERVER_AUDIT_plugin::lock_bigbuffer\",\n    PSI_FLAG_GLOBAL}\n};\n#endif\nstatic mysql_mutex_t lock_operations;\nstatic mysql_mutex_t lock_atomic;\nstatic mysql_mutex_t lock_bigbuffer;\n\n/* The Percona server and partly MySQL don't support         */\n/* launching client errors in the 'update_variable' methods. */\n/* So the client errors just disabled for them.              */\n/* The possible solution is to implement the 'check_variable'*/\n/* methods there properly, but at the moment i'm not sure it */\n/* worths doing.                                             */\n#define CLIENT_ERROR if (!started_mysql) my_printf_error\n\n#define ADD_ATOMIC(x, a)              \\\n  do {                                \\\n  flogger_mutex_lock(&lock_atomic);   \\\n  x+= a;                              \\\n  flogger_mutex_unlock(&lock_atomic); \\\n  } while (0)\n\n\nstatic uchar *getkey_user(const char *entry, size_t *length,\n                          my_bool nu __attribute__((unused)) )\n{\n  const char *e= entry;\n  while (*e && *e != ' ' && *e != ',')\n    ++e;\n  *length= e - entry;\n  return (uchar *) entry;\n}\n\n\nstatic void blank_user(char *user)\n{\n  for (; *user && *user != ','; user++)\n    *user= ' ';\n}\n\n\nstatic void remove_user(char *user)\n{\n  char *start_user= user;\n  while (*user != ',')\n  {\n    if (*user == 0)\n    {\n      *start_user= 0;\n      return;\n    }\n    user++;\n  }\n  user++;\n  while (*user == ' ')\n    user++;\n\n  do {\n    *(start_user++)= *user;\n  } while (*(user++));\n}\n\n\nstatic void remove_blanks(char *user)\n{\n  char *user_orig= user;\n  char *user_to= user;\n  char *start_tok;\n  int blank_name;\n\n  while (*user != 0)\n  {\n    start_tok= user;\n    blank_name= 1;\n    while (*user !=0 && *user != ',')\n    {\n      if (*user != ' ')\n        blank_name= 0;\n      user++;\n    }\n    if (!blank_name)\n    {\n      while (start_tok <= user)\n        *(user_to++)= *(start_tok++);\n    }\n    if (*user == ',')\n      user++;\n  }\n  if (user_to > user_orig && user_to[-1] == ',')\n    user_to--;\n  *user_to= 0;\n}\n\n\nstruct user_name\n{\n  size_t name_len;\n  char *name;\n};\n\n\nstruct user_coll\n{\n  int n_users;\n  struct user_name *users;\n  int n_alloced;\n};\n\n\nstatic void coll_init(struct user_coll *c)\n{\n  c->n_users= 0;\n  c->users= 0;\n  c->n_alloced= 0;\n}\n\n\nstatic void coll_free(struct user_coll *c)\n{\n  if (c->users)\n  {\n    free(c->users);\n    coll_init(c);\n  }\n}\n\n\nstatic int cmp_users(const void *ia, const void *ib)\n{\n  const struct user_name *a= (const struct user_name *) ia;\n  const struct user_name *b= (const struct user_name *) ib;\n  int dl= (int)(a->name_len - b->name_len);\n  if (dl != 0)\n    return dl;\n\n  return strncmp(a->name, b->name, a->name_len);\n}\n\n\nstatic char *coll_search(struct user_coll *c, const char *n, size_t len)\n{\n  struct user_name un;\n  struct user_name *found;\n  if (!c->n_users)\n    return 0;\n  un.name_len= len;\n  un.name= (char *) n;\n  found= (struct user_name*)  bsearch(&un, c->users, c->n_users,\n                                      sizeof(c->users[0]), cmp_users);\n  return found ? found->name : 0;\n}\n\n\nstatic int coll_insert(struct user_coll *c, char *n, size_t len)\n{\n  if (c->n_users >= c->n_alloced)\n  {\n    c->n_alloced+= 128;\n    if (c->users == NULL)\n      c->users= malloc(c->n_alloced * sizeof(c->users[0]));\n    else\n      c->users= realloc(c->users, c->n_alloced * sizeof(c->users[0]));\n\n    if (c->users == NULL)\n      return 1;\n  }\n  c->users[c->n_users].name= n;\n  c->users[c->n_users].name_len= len;\n  c->n_users++;\n  return 0;\n}\n\n\nstatic void coll_sort(struct user_coll *c)\n{\n  if (c->n_users)\n    qsort(c->users, c->n_users, sizeof(c->users[0]), cmp_users);\n}\n\n\nstatic int user_coll_fill(struct user_coll *c, char *users,\n                          struct user_coll *cmp_c, int take_over_cmp)\n{\n  char *orig_users= users;\n  char *cmp_user= 0;\n  size_t cmp_length;\n  int refill_cmp_coll= 0;\n\n  c->n_users= 0;\n\n  while (*users)\n  {\n    while (*users == ' ')\n      users++;\n    if (!*users)\n      return 0;\n\n    (void) getkey_user(users, &cmp_length, FALSE);\n    if (cmp_c)\n    {\n      cmp_user= coll_search(cmp_c, users, cmp_length);\n\n      if (cmp_user && take_over_cmp)\n      {\n        ADD_ATOMIC(internal_stop_logging, 1);\n        CLIENT_ERROR(1, \"User '%.*b' was removed from the\"\n            \" server_audit_excl_users.\",\n            MYF(ME_JUST_WARNING), (int) cmp_length, users);\n        ADD_ATOMIC(internal_stop_logging, -1);\n        blank_user(cmp_user);\n        refill_cmp_coll= 1;\n      }\n      else if (cmp_user)\n      {\n        ADD_ATOMIC(internal_stop_logging, 1);\n        CLIENT_ERROR(1, \"User '%.*b' is in the server_audit_incl_users, \"\n            \"so wasn't added.\", MYF(ME_JUST_WARNING), (int) cmp_length, users);\n        ADD_ATOMIC(internal_stop_logging, -1);\n        remove_user(users);\n        continue;\n      }\n    }\n    if (coll_insert(c, users, cmp_length))\n      return 1;\n    while (*users && *users != ',')\n      users++;\n    if (!*users)\n      break;\n    users++;\n  }\n\n  if (refill_cmp_coll)\n  {\n    remove_blanks(excl_users);\n    return user_coll_fill(cmp_c, excl_users, 0, 0);\n  }\n\n  if (users > orig_users && users[-1] == ',')\n    users[-1]= 0;\n\n  coll_sort(c);\n\n  return 0;\n}\n\n\nenum sa_keywords\n{\n  SQLCOM_NOTHING=0,\n  SQLCOM_DDL,\n  SQLCOM_DML,\n  SQLCOM_GRANT,\n  SQLCOM_CREATE_USER,\n  SQLCOM_CHANGE_MASTER,\n  SQLCOM_CREATE_SERVER,\n  SQLCOM_SET_OPTION,\n  SQLCOM_ALTER_SERVER,\n  SQLCOM_TRUNCATE,\n  SQLCOM_QUERY_ADMIN,\n  SQLCOM_DCL,\n};\n\nstruct sa_keyword\n{\n  int length;\n  const char *wd;\n  struct sa_keyword *next;\n  enum sa_keywords type;\n};\n\n\nstruct sa_keyword xml_word=   {3, \"XML\", 0, SQLCOM_NOTHING};\nstruct sa_keyword user_word=   {4, \"USER\", 0, SQLCOM_NOTHING};\nstruct sa_keyword data_word=   {4, \"DATA\", 0, SQLCOM_NOTHING};\nstruct sa_keyword server_word= {6, \"SERVER\", 0, SQLCOM_NOTHING};\nstruct sa_keyword master_word= {6, \"MASTER\", 0, SQLCOM_NOTHING};\nstruct sa_keyword password_word= {8, \"PASSWORD\", 0, SQLCOM_NOTHING};\nstruct sa_keyword function_word= {8, \"FUNCTION\", 0, SQLCOM_NOTHING};\nstruct sa_keyword statement_word= {9, \"STATEMENT\", 0, SQLCOM_NOTHING};\nstruct sa_keyword procedure_word= {9, \"PROCEDURE\", 0, SQLCOM_NOTHING};\n\n\nstruct sa_keyword keywords_to_skip[]=\n{\n  {3, \"SET\", &statement_word, SQLCOM_QUERY_ADMIN},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword not_ddl_keywords[]=\n{\n  {4, \"DROP\", &user_word, SQLCOM_DCL},\n  {6, \"CREATE\", &user_word, SQLCOM_DCL},\n  {6, \"RENAME\", &user_word, SQLCOM_DCL},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword ddl_keywords[]=\n{\n  {4, \"DROP\", 0, SQLCOM_DDL},\n  {5, \"ALTER\", 0, SQLCOM_DDL},\n  {6, \"CREATE\", 0, SQLCOM_DDL},\n  {6, \"RENAME\", 0, SQLCOM_DDL},\n  {8, \"TRUNCATE\", 0, SQLCOM_DDL},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword dml_keywords[]=\n{\n  {2, \"DO\", 0, SQLCOM_DML},\n  {4, \"CALL\", 0, SQLCOM_DML},\n  {4, \"LOAD\", &data_word, SQLCOM_DML},\n  {4, \"LOAD\", &xml_word, SQLCOM_DML},\n  {6, \"DELETE\", 0, SQLCOM_DML},\n  {6, \"INSERT\", 0, SQLCOM_DML},\n  {6, \"SELECT\", 0, SQLCOM_DML},\n  {6, \"UPDATE\", 0, SQLCOM_DML},\n  {7, \"HANDLER\", 0, SQLCOM_DML},\n  {7, \"REPLACE\", 0, SQLCOM_DML},\n  {0, NULL, 0, SQLCOM_DML}\n};\n\n\nstruct sa_keyword dml_no_select_keywords[]=\n{\n  {2, \"DO\", 0, SQLCOM_DML},\n  {4, \"CALL\", 0, SQLCOM_DML},\n  {4, \"LOAD\", &data_word, SQLCOM_DML},\n  {4, \"LOAD\", &xml_word, SQLCOM_DML},\n  {6, \"DELETE\", 0, SQLCOM_DML},\n  {6, \"INSERT\", 0, SQLCOM_DML},\n  {6, \"UPDATE\", 0, SQLCOM_DML},\n  {7, \"HANDLER\", 0, SQLCOM_DML},\n  {7, \"REPLACE\", 0, SQLCOM_DML},\n  {0, NULL, 0, SQLCOM_DML}\n};\n\n\nstruct sa_keyword dcl_keywords[]=\n{\n  {6, \"CREATE\", &user_word, SQLCOM_DCL},\n  {4, \"DROP\", &user_word, SQLCOM_DCL},\n  {6, \"RENAME\", &user_word, SQLCOM_DCL},\n  {5, \"GRANT\", 0, SQLCOM_DCL},\n  {6, \"REVOKE\", 0, SQLCOM_DCL},\n  {3, \"SET\", &password_word, SQLCOM_DCL},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword passwd_keywords[]=\n{\n  {3, \"SET\", &password_word, SQLCOM_SET_OPTION},\n  {5, \"ALTER\", &server_word, SQLCOM_ALTER_SERVER},\n  {5, \"GRANT\", 0, SQLCOM_GRANT},\n  {6, \"CREATE\", &user_word, SQLCOM_CREATE_USER},\n  {6, \"CREATE\", &server_word, SQLCOM_CREATE_SERVER},\n  {6, \"CHANGE\", &master_word, SQLCOM_CHANGE_MASTER},\n  {0, NULL, 0, SQLCOM_NOTHING}\n};\n\n#define MAX_KEYWORD 9\n\n\nstatic void error_header()\n{\n  struct tm tm_time;\n  time_t curtime;\n\n  (void) time(&curtime);\n  (void) localtime_r(&curtime, &tm_time);\n\n  (void) fprintf(stderr,\"%02d%02d%02d %2d:%02d:%02d server_audit: \",\n    tm_time.tm_year % 100, tm_time.tm_mon + 1,\n    tm_time.tm_mday, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);\n}\n\n\nstatic LOGGER_HANDLE *logfile;\nstatic struct user_coll incl_user_coll, excl_user_coll;\nstatic unsigned long long query_counter= 1;\n\n\nstatic struct connection_info *get_loc_info(MYSQL_THD thd)\n{\n  return (struct connection_info *) THDVAR(thd, loc_info);\n}\n\n\nstatic int ci_needs_setup(const struct connection_info *ci)\n{\n  return ci->header != 0;\n}\n\n\nstatic void get_str_n(char *dest, int *dest_len, size_t dest_size,\n                      const char *src, size_t src_len)\n{\n  if (src_len >= dest_size)\n    src_len= dest_size - 1;\n\n  if (src_len)\n    memcpy(dest, src, src_len);\n  dest[src_len]= 0;\n  *dest_len= (int)src_len;\n}\n\n\nstatic int get_user_host(const char *uh_line, unsigned int uh_len,\n                         char *buffer, size_t buf_len,\n                         size_t *user_len, size_t *host_len, size_t *ip_len)\n{\n  const char *buf_end= buffer + buf_len - 1;\n  const char *buf_start;\n  const char *uh_end= uh_line + uh_len;\n\n  while (uh_line < uh_end && *uh_line != '[')\n    ++uh_line;\n\n  if (uh_line == uh_end)\n    return 1;\n  ++uh_line;\n\n  buf_start= buffer;\n  while (uh_line < uh_end && *uh_line != ']')\n  {\n    if (buffer == buf_end)\n      return 1;\n    *(buffer++)= *(uh_line++);\n  }\n  if (uh_line == uh_end)\n    return 1;\n  *user_len= buffer - buf_start;\n  *(buffer++)= 0;\n\n  while (uh_line < uh_end && *uh_line != '@')\n    ++uh_line;\n  if (uh_line == uh_end || *(++uh_line) == 0)\n    return 1;\n  ++uh_line;\n\n  buf_start= buffer;\n  while (uh_line < uh_end && *uh_line != ' ' && *uh_line != '[')\n  {\n    if (buffer == buf_end)\n      break;\n    *(buffer++)= *(uh_line++);\n  }\n  *host_len= buffer - buf_start;\n  *(buffer++)= 0;\n\n  while (uh_line < uh_end && *uh_line != '[')\n    ++uh_line;\n\n  buf_start= buffer;\n  if (*uh_line == '[')\n  {\n    ++uh_line;\n    while (uh_line < uh_end && *uh_line != ']')\n      *(buffer++)= *(uh_line++);\n  }\n  *ip_len= buffer - buf_start;\n  return 0;\n}\n\n#if defined(__WIN__) && !defined(S_ISDIR)\n#define S_ISDIR(x) ((x) & _S_IFDIR)\n#endif /*__WIN__ && !S_ISDIR*/\n\nstatic int start_logging()\n{\n  last_error_buf[0]= 0;\n  log_write_failures= 0;\n  if (output_type == OUTPUT_FILE)\n  {\n    char alt_path_buffer[FN_REFLEN+1+DEFAULT_FILENAME_LEN];\n    struct stat *f_stat= (struct stat *)alt_path_buffer;\n    const char *alt_fname= file_path;\n\n    while (*alt_fname == ' ')\n      alt_fname++;\n\n    if (*alt_fname == 0)\n    {\n      /* Empty string means the default file name. */\n      alt_fname= default_file_name;\n    }\n    else\n    {\n      /* See if the directory exists with the name of file_path.    */\n      /* Log file name should be [file_path]/server_audit.log then. */\n      if (stat(file_path, (struct stat *)alt_path_buffer) == 0 &&\n          S_ISDIR(f_stat->st_mode))\n      {\n        size_t p_len= strlen(file_path);\n        memcpy(alt_path_buffer, file_path, p_len);\n        if (alt_path_buffer[p_len-1] != FN_LIBCHAR)\n        {\n          alt_path_buffer[p_len]= FN_LIBCHAR;\n          p_len++;\n        }\n        memcpy(alt_path_buffer+p_len, default_file_name, DEFAULT_FILENAME_LEN);\n        alt_path_buffer[p_len+DEFAULT_FILENAME_LEN]= 0;\n        alt_fname= alt_path_buffer;\n      }\n    }\n\n    logfile= logger_open(alt_fname, file_rotate_size, rotations);\n\n    if (logfile == NULL)\n    {\n      error_header();\n      fprintf(stderr, \"Could not create file '%s'.\\n\",\n              alt_fname);\n      logging= 0;\n      my_snprintf(last_error_buf, sizeof(last_error_buf),\n                  \"Could not create file '%s'.\", alt_fname);\n      is_active= 0;\n      CLIENT_ERROR(1, \"SERVER AUDIT plugin can't create file '%s'.\",\n          MYF(ME_JUST_WARNING), alt_fname);\n      return 1;\n    }\n    error_header();\n    fprintf(stderr, \"logging started to the file %s.\\n\", alt_fname);\n    strncpy(current_log_buf, alt_fname, sizeof(current_log_buf)-1);\n    current_log_buf[sizeof(current_log_buf)-1]= 0;\n  }\n  else if (output_type == OUTPUT_SYSLOG)\n  {\n    openlog(syslog_ident, LOG_NOWAIT, syslog_facility_codes[syslog_facility]);\n    error_header();\n    fprintf(stderr, \"logging started to the syslog.\\n\");\n    strncpy(current_log_buf, \"[SYSLOG]\", sizeof(current_log_buf)-1);\n    compile_time_assert(sizeof current_log_buf > sizeof \"[SYSLOG]\");\n  }\n  is_active= 1;\n  return 0;\n}\n\n\nstatic int stop_logging()\n{\n  last_error_buf[0]= 0;\n  if (output_type == OUTPUT_FILE && logfile)\n  {\n    logger_close(logfile);\n    logfile= NULL;\n  }\n  else if (output_type == OUTPUT_SYSLOG)\n  {\n    closelog();\n  }\n  error_header();\n  fprintf(stderr, \"logging was stopped.\\n\");\n  is_active= 0;\n  return 0;\n}\n\n\nstatic void setup_connection_simple(struct connection_info *ci)\n{\n  ci->db_length= 0;\n  ci->user_length= 0;\n  ci->host_length= 0;\n  ci->ip_length= 0;\n  ci->query_length= 0;\n  ci->header= 0;\n  ci->proxy_length= 0;\n}\n\n\n#define MAX_HOSTNAME 61\n#define USERNAME_LENGTH 384\n\nstatic void setup_connection_connect(struct connection_info *cn,\n    const struct mysql_event_connection *event)\n{\n  cn->query_id= 0;\n  cn->query_length= 0;\n  cn->log_always= 0;\n  cn->thread_id= event->thread_id;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n            event->database, event->database_length);\n  get_str_n(cn->user, &cn->user_length, sizeof(cn->db),\n            event->user, event->user_length);\n  get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n            event->host, event->host_length);\n  get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n            event->ip, event->ip_length);\n  cn->header= 0;\n  if (event->proxy_user && event->proxy_user[0])\n  {\n    const char *priv_host= event->proxy_user +\n            sizeof(char[MAX_HOSTNAME+USERNAME_LENGTH+5]);\n    size_t priv_host_length;\n\n    if (mysql_57_started)\n    {\n      priv_host+= sizeof(size_t);\n      priv_host_length= *(size_t *) (priv_host + MAX_HOSTNAME);\n    }\n    else\n      priv_host_length= strlen(priv_host);\n\n\n    get_str_n(cn->proxy, &cn->proxy_length, sizeof(cn->proxy),\n              event->priv_user, event->priv_user_length);\n    get_str_n(cn->proxy_host, &cn->proxy_host_length,\n              sizeof(cn->proxy_host),\n              priv_host, priv_host_length);\n  }\n  else\n    cn->proxy_length= 0;\n}\n\n\n#define SAFE_STRLEN(s) (s ? strlen(s) : 0)\n#define SAFE_STRLEN_UI(s) ((unsigned int) (s ? strlen(s) : 0))\nstatic char empty_str[1]= { 0 };\n\n\nstatic int is_space(char c)\n{\n  return c == ' ' || c == '\\r' || c == '\\n' || c == '\\t';\n}\n\n\n#define SKIP_SPACES(str) \\\ndo { \\\n  while (is_space(*str)) \\\n    ++str; \\\n} while(0)\n\n\n#define ESC_MAP_SIZE 0x60\nstatic const char esc_map[ESC_MAP_SIZE]=\n{\n  0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, '\\'', 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '\\\\', 0, 0, 0\n};\n\nstatic char escaped_char(char c)\n{\n  return ((unsigned char ) c) >= ESC_MAP_SIZE ? 0 : esc_map[(unsigned char) c];\n}\n\n\nstatic void setup_connection_initdb(struct connection_info *cn,\n    const struct mysql_event_general *event)\n{\n  size_t user_len, host_len, ip_len;\n  char uh_buffer[512];\n\n  cn->thread_id= event->general_thread_id;\n  cn->query_id= 0;\n  cn->query_length= 0;\n  cn->log_always= 0;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n            event->general_query, event->general_query_length);\n\n  if (get_user_host(event->general_user, event->general_user_length,\n                    uh_buffer, sizeof(uh_buffer),\n                    &user_len, &host_len, &ip_len))\n  {\n    /* The user@host line is incorrect. */\n    cn->user_length= 0;\n    cn->host_length= 0;\n    cn->ip_length= 0;\n  }\n  else\n  {\n    get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n              uh_buffer, user_len);\n    get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n              uh_buffer+user_len+1, host_len);\n    get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n              uh_buffer+user_len+1+host_len+1, ip_len);\n  }\n  cn->header= 0;\n}\n\n\nstatic void setup_connection_table(struct connection_info *cn,\n    const struct mysql_event_table *event)\n{\n  cn->thread_id= event->thread_id;\n  cn->query_id= query_counter++;\n  cn->log_always= 0;\n  cn->query_length= 0;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n            event->database, event->database_length);\n  get_str_n(cn->user, &cn->user_length, sizeof(cn->db),\n            event->user, SAFE_STRLEN(event->user));\n  get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n            event->host, SAFE_STRLEN(event->host));\n  get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n            event->ip, SAFE_STRLEN(event->ip));\n  cn->header= 0;\n}\n\n\nstatic void setup_connection_query(struct connection_info *cn,\n    const struct mysql_event_general *event)\n{\n  size_t user_len, host_len, ip_len;\n  char uh_buffer[512];\n\n  cn->thread_id= event->general_thread_id;\n  cn->query_id= query_counter++;\n  cn->log_always= 0;\n  cn->query_length= 0;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db), \"\", 0);\n\n  if (get_user_host(event->general_user, event->general_user_length,\n                    uh_buffer, sizeof(uh_buffer),\n                    &user_len, &host_len, &ip_len))\n  {\n    /* The user@host line is incorrect. */\n    cn->user_length= 0;\n    cn->host_length= 0;\n    cn->ip_length= 0;\n  }\n  else\n  {\n    get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n              uh_buffer, user_len);\n    get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n              uh_buffer+user_len+1, host_len);\n    get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n              uh_buffer+user_len+1+host_len+1, ip_len);\n  }\n  cn->header= 0;\n}\n\n\nstatic void change_connection(struct connection_info *cn,\n    const struct mysql_event_connection *event)\n{\n  get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n            event->user, event->user_length);\n  get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n            event->ip, event->ip_length);\n}\n\nstatic int write_log(const char *message, size_t len, int take_lock)\n{\n  int result= 0;\n  if (take_lock)\n    flogger_mutex_lock(&lock_operations);\n\n  if (output_type == OUTPUT_FILE)\n  {\n    if (logfile &&\n        (is_active= (logger_write(logfile, message, len) == (int) len)))\n      goto exit;\n    ++log_write_failures;\n    result= 1;\n  }\n  else if (output_type == OUTPUT_SYSLOG)\n  {\n    syslog(syslog_facility_codes[syslog_facility] |\n           syslog_priority_codes[syslog_priority],\n           \"%s %.*s\", syslog_info, (int) len, message);\n  }\nexit:\n  if (take_lock)\n    flogger_mutex_unlock(&lock_operations);\n  return result;\n}\n\n\nstatic size_t log_header(char *message, size_t message_len,\n                      time_t *ts,\n                      const char *serverhost, size_t serverhost_len,\n                      const char *username, unsigned int username_len,\n                      const char *host, unsigned int host_len,\n                      const char *userip, unsigned int userip_len,\n                      unsigned int connection_id, long long query_id,\n                      const char *operation)\n{\n  struct tm tm_time;\n\n  if (host_len == 0 && userip_len != 0)\n  {\n    host_len= userip_len;\n    host= userip;\n  }\n\n  if (output_type == OUTPUT_SYSLOG)\n    return my_snprintf(message, message_len,\n        \"%.*s,%.*s,%.*s,%d,%lld,%s\",\n        (unsigned int) serverhost_len, serverhost,\n        username_len, username,\n        host_len, host,\n        connection_id, query_id, operation);\n\n  (void) localtime_r(ts, &tm_time);\n  return my_snprintf(message, message_len,\n      \"%04d%02d%02d %02d:%02d:%02d,%.*s,%.*s,%.*s,%d,%lld,%s\",\n      tm_time.tm_year+1900, tm_time.tm_mon+1, tm_time.tm_mday,\n      tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,\n      serverhost_len, serverhost,\n      username_len, username,\n      host_len, host,\n      connection_id, query_id, operation);\n}\n\n\nstatic int log_proxy(const struct connection_info *cn,\n                     const struct mysql_event_connection *event)\n                   \n{\n  time_t ctime;\n  size_t csize;\n  char message[1024];\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    cn->user, cn->user_length,\n                    cn->host, cn->host_length,\n                    cn->ip, cn->ip_length,\n                    event->thread_id, 0, \"PROXY_CONNECT\");\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n    \",%.*s,`%.*s`@`%.*s`,%d\", cn->db_length, cn->db,\n                     cn->proxy_length, cn->proxy,\n                     cn->proxy_host_length, cn->proxy_host,\n                     event->status);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1, 1);\n}\n\n\nstatic int log_connection(const struct connection_info *cn,\n                          const struct mysql_event_connection *event,\n                          const char *type)\n{\n  time_t ctime;\n  size_t csize;\n  char message[1024];\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    cn->user, cn->user_length,\n                    cn->host, cn->host_length,\n                    cn->ip, cn->ip_length,\n                    event->thread_id, 0, type);\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n    \",%.*s,,%d\", cn->db_length, cn->db, event->status);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1, 1);\n}\n\n\nstatic int log_connection_event(const struct mysql_event_connection *event,\n                                const char *type)\n{\n  time_t ctime;\n  size_t csize;\n  char message[1024];\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    event->user, event->user_length,\n                    event->host, event->host_length,\n                    event->ip, event->ip_length,\n                    event->thread_id, 0, type);\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n    \",%.*s,,%d\", event->database_length, event->database, event->status);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1, 1);\n}\n\n\nstatic size_t escape_string(const char *str, unsigned int len,\n                          char *result, size_t result_len)\n{\n  const char *res_start= result;\n  const char *res_end= result + result_len - 2;\n  while (len)\n  {\n    char esc_c;\n\n    if (result >= res_end)\n      break;\n    if ((esc_c= escaped_char(*str)))\n    {\n      if (result+1 >= res_end)\n        break;\n      *(result++)= '\\\\';\n      *(result++)= esc_c;\n    }\n    else if (is_space(*str))\n      *(result++)= ' ';\n    else\n      *(result++)= *str;\n    str++;\n    len--;\n  }\n  *result= 0;\n  return result - res_start;\n}\n\n\nstatic size_t escape_string_hide_passwords(const char *str, unsigned int len,\n    char *result, size_t result_len,\n    const char *word1, size_t word1_len,\n    const char *word2, size_t word2_len,\n    int next_text_string)\n{\n  const char *res_start= result;\n  const char *res_end= result + result_len - 2;\n  size_t d_len;\n\n  while (len)\n  {\n    if (len > word1_len + 1 && strncasecmp(str, word1, word1_len) == 0)\n    {\n      const char *next_s= str + word1_len;\n      size_t c;\n\n      if (next_text_string)\n      {\n        while (*next_s && *next_s != '\\'' && *next_s != '\"')\n          ++next_s;\n      }\n      else\n      {\n        if (word2)\n        {\n          SKIP_SPACES(next_s);\n          if (len < (next_s - str) + word2_len + 1 ||\n              strncasecmp(next_s, word2, word2_len) != 0)\n            goto no_password;\n          next_s+= word2_len;\n        }\n\n        while (*next_s && *next_s != '\\'' && *next_s != '\"')\n          ++next_s;\n      }\n\n      d_len= next_s - str;\n      if (result + d_len + 5 > res_end)\n        break;\n\n      for (c=0; c<d_len; c++)\n        result[c]= is_space(str[c]) ? ' ' : str[c];\n\n      if (*next_s)\n      {\n        const char b_char= *next_s++;\n        memset(result + d_len, '*', 5);\n        result+= d_len + 5;\n\n        while (*next_s)\n        {\n          if (*next_s == b_char)\n          {\n            ++next_s;\n            break;\n          }\n          if (*next_s == '\\\\')\n          {\n            if (next_s[1])\n              next_s++;\n          }\n          next_s++;\n        }\n      }\n      else\n        result+= d_len;\n\n      len-= (uint)(next_s - str);\n      str= next_s;\n      continue;\n    }\nno_password:\n    if (result >= res_end)\n      break;\n    else\n    {\n      const char b_char= escaped_char(*str);\n      if (b_char)\n      {\n        if (result+1 >= res_end)\n          break;\n        *(result++)= '\\\\';\n        *(result++)= b_char;\n      }\n      else if (is_space(*str))\n        *(result++)= ' ';\n      else\n        *(result++)= *str;\n      str++;\n      len--;\n    }\n  }\n  *result= 0;\n  return result - res_start;\n}\n\n\n\nstatic int do_log_user(const char *name, int len,\n                       const char *proxy, int proxy_len, int take_lock)\n{\n  int result;\n\n  if (!name)\n    return 0;\n\n  if (take_lock)\n    flogger_mutex_lock(&lock_operations);\n\n  if (incl_user_coll.n_users)\n  {\n    result= coll_search(&incl_user_coll, name, len) != 0 ||\n            (proxy && coll_search(&incl_user_coll, proxy, proxy_len) != 0);\n  }\n  else if (excl_user_coll.n_users)\n  {\n    result= coll_search(&excl_user_coll, name, len) == 0 &&\n            (proxy && coll_search(&excl_user_coll, proxy, proxy_len) == 0);\n  }\n  else\n    result= 1;\n\n  if (take_lock)\n    flogger_mutex_unlock(&lock_operations);\n  return result;\n}\n\n\nstatic int get_next_word(const char *query, char *word)\n{\n  int len= 0;\n  char c;\n  while ((c= query[len]))\n  {\n    if (c >= 'a' && c <= 'z')\n      word[len]= 'A' + (c-'a');\n    else if (c >= 'A' && c <= 'Z')\n      word[len]= c;\n    else\n      break;\n\n    if (len++ == MAX_KEYWORD)\n      return 0;\n  }\n  word[len]= 0;\n  return len;\n}\n\n\nstatic int filter_query_type(const char *query, struct sa_keyword *kwd)\n{\n  int qwe_in_list;\n  char fword[MAX_KEYWORD + 1], nword[MAX_KEYWORD + 1];\n  int len, nlen= 0;\n  const struct sa_keyword *l_keywords;\n\n  while (*query && (is_space(*query) || *query == '(' || *query == '/'))\n  {\n    /* comment handling */\n    if (*query == '/' && query[1] == '*')\n    {\n      if (query[2] == '!')\n      {\n        query+= 3;\n        while (*query >= '0' && *query <= '9')\n          query++;\n        continue;\n      }\n      query+= 2;\n      while (*query)\n      {\n        if (*query=='*' && query[1] == '/')\n        {\n          query+= 2;\n          break;\n        }\n        query++;\n      }\n      continue;\n    }\n    query++;\n  }\n\n  qwe_in_list= 0;\n  if (!(len= get_next_word(query, fword)))\n    goto not_in_list;\n  query+= len+1;\n\n  l_keywords= kwd;\n  while (l_keywords->length)\n  {\n    if (l_keywords->length == len && strncmp(l_keywords->wd, fword, len) == 0)\n    {\n      if (l_keywords->next)\n      {\n        if (nlen == 0)\n        {\n          while (*query && is_space(*query))\n            query++;\n          nlen= get_next_word(query, nword);\n        }\n        if (l_keywords->next->length != nlen ||\n            strncmp(l_keywords->next->wd, nword, nlen) != 0)\n          goto do_loop;\n      }\n\n      qwe_in_list= l_keywords->type;\n      break;\n    };\ndo_loop:\n    l_keywords++;\n  }\n\nnot_in_list:\n  return qwe_in_list;\n}\n\n\nstatic int log_statement_ex(const struct connection_info *cn,\n                            time_t ev_time, unsigned long thd_id,\n                            const char *query, unsigned int query_len,\n                            int error_code, const char *type, int take_lock)\n{\n  size_t csize;\n  char message_loc[1024];\n  char *message= message_loc;\n  size_t message_size= sizeof(message_loc);\n  char *uh_buffer;\n  size_t uh_buffer_size;\n  const char *db;\n  unsigned int db_length;\n  long long query_id;\n  int result;\n\n  if ((db= cn->db))\n    db_length= cn->db_length;\n  else\n  {\n    db= \"\";\n    db_length= 0;\n  }\n\n  if (!(query_id= cn->query_id))\n    query_id= query_counter++;\n\n  if (query == 0)\n  {\n    /* Can happen after the error in mysqld_prepare_stmt() */\n    query= cn->query;\n    query_len= cn->query_length;\n    if (query == 0 || query_len == 0)\n      return 0;\n  }\n\n  if (query && !(events & EVENT_QUERY_ALL) &&\n      (events & EVENT_QUERY && !cn->log_always))\n  {\n    const char *orig_query= query;\n\n    if (filter_query_type(query, keywords_to_skip))\n    {\n      char fword[MAX_KEYWORD + 1];\n      int len;\n      do\n      {\n        len= get_next_word(query, fword);\n        query+= len ? len : 1;\n        if (len == 3 && strncmp(fword, \"FOR\", 3) == 0)\n          break;\n      } while (*query);\n\n      if (*query == 0)\n        return 0;\n    }\n\n    if (events & EVENT_QUERY_DDL)\n    {\n      if (!filter_query_type(query, not_ddl_keywords) &&\n          filter_query_type(query, ddl_keywords))\n        goto do_log_query;\n    }\n    if (events & EVENT_QUERY_DML)\n    {\n      if (filter_query_type(query, dml_keywords))\n        goto do_log_query;\n    }\n    if (events & EVENT_QUERY_DML_NO_SELECT)\n    {\n      if (filter_query_type(query, dml_no_select_keywords))\n        goto do_log_query;\n    }\n    if (events & EVENT_QUERY_DCL)\n    {\n      if (filter_query_type(query, dcl_keywords))\n        goto do_log_query;\n    }\n\n    return 0;\ndo_log_query:\n    query= orig_query;\n  }\n\n  csize= log_header(message, message_size-1, &ev_time,\n                    servhost, servhost_len,\n                    cn->user, cn->user_length,cn->host, cn->host_length,\n                    cn->ip, cn->ip_length, thd_id, query_id, type);\n\n  csize+= my_snprintf(message+csize, message_size - 1 - csize,\n      \",%.*s,\\'\", db_length, db);\n\n  if (query_log_limit > 0 && query_len > query_log_limit)\n    query_len= query_log_limit;\n\n  if (query_len > (message_size - csize)/2)\n  {\n    flogger_mutex_lock(&lock_bigbuffer);\n    if (big_buffer_alloced < (query_len * 2 + csize))\n    {\n      big_buffer_alloced= (query_len * 2 + csize + 4095) & ~4095L;\n      big_buffer= realloc(big_buffer, big_buffer_alloced);\n      if (big_buffer == NULL)\n      {\n        big_buffer_alloced= 0;\n        return 0;\n      }\n    }\n\n    memcpy(big_buffer, message, csize);\n    message= big_buffer;\n    message_size= big_buffer_alloced;\n  }\n\n  uh_buffer= message + csize;\n  uh_buffer_size= message_size - csize;\n  if (query_log_limit > 0 && uh_buffer_size > query_log_limit+2)\n    uh_buffer_size= query_log_limit+2;\n\n  switch (filter_query_type(query, passwd_keywords))\n  {\n    case SQLCOM_GRANT:\n    case SQLCOM_CREATE_USER:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"IDENTIFIED\", 10, \"BY\", 2, 0);\n      break;\n    case SQLCOM_CHANGE_MASTER:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"MASTER_PASSWORD\", 15, \"=\", 1, 0);\n      break;\n    case SQLCOM_CREATE_SERVER:\n    case SQLCOM_ALTER_SERVER:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"PASSWORD\", 8, NULL, 0, 0);\n      break;\n    case SQLCOM_SET_OPTION:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"=\", 1, NULL, 0, 1);\n      break;\n    default:\n      csize+= escape_string(query, query_len,\n                               uh_buffer, uh_buffer_size); \n      break;\n  }\n  csize+= my_snprintf(message+csize, message_size - 1 - csize,\n                      \"\\',%d\", error_code);\n  message[csize]= '\\n';\n  result= write_log(message, csize + 1, take_lock);\n  if (message == big_buffer)\n    flogger_mutex_unlock(&lock_bigbuffer);\n\n  return result;\n}\n\n\nstatic int log_statement(const struct connection_info *cn,\n                         const struct mysql_event_general *event,\n                         const char *type)\n{\n  return log_statement_ex(cn, event->general_time, event->general_thread_id,\n                          event->general_query, event->general_query_length,\n                          event->general_error_code, type, 1);\n}\n\n\nstatic int log_table(const struct connection_info *cn,\n                     const struct mysql_event_table *event, const char *type)\n{\n  size_t csize;\n  char message[1024];\n  time_t ctime;\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    event->user, SAFE_STRLEN_UI(event->user),\n                    event->host, SAFE_STRLEN_UI(event->host),\n                    event->ip, SAFE_STRLEN_UI(event->ip),\n                    event->thread_id, cn->query_id, type);\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n            \",%.*s,%.*s,\",event->database_length, event->database,\n                          event->table_length, event->table);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1, 1);\n}\n\n\nstatic int log_rename(const struct connection_info *cn,\n                      const struct mysql_event_table *event)\n{\n  size_t csize;\n  char message[1024];\n  time_t ctime;\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    event->user, SAFE_STRLEN_UI(event->user),\n                    event->host, SAFE_STRLEN_UI(event->host),\n                    event->ip, SAFE_STRLEN_UI(event->ip),\n                    event->thread_id, cn->query_id, \"RENAME\");\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n            \",%.*s,%.*s|%.*s.%.*s,\",event->database_length, event->database,\n                         event->table_length, event->table,\n                         event->new_database_length, event->new_database,\n                         event->new_table_length, event->new_table);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1, 1);\n}\n\n\nstatic int event_query_command(const struct mysql_event_general *event)\n{\n  return (event->general_command_length == 5 &&\n           strncmp(event->general_command, \"Query\", 5) == 0) ||\n         (event->general_command_length == 7 &&\n           (strncmp(event->general_command, \"Execute\", 7) == 0 ||\n             (event->general_error_code != 0 &&\n              strncmp(event->general_command, \"Prepare\", 7) == 0)));\n}\n\n\nstatic void update_general_user(struct connection_info *cn,\n    const struct mysql_event_general *event)\n{\n  char uh_buffer[768];\n  size_t user_len, host_len, ip_len;\n  if (cn->user_length == 0 && cn->host_length == 0 && cn->ip_length == 0 &&\n      get_user_host(event->general_user, event->general_user_length,\n                    uh_buffer, sizeof(uh_buffer),\n                    &user_len, &host_len, &ip_len) == 0)\n  {\n    get_str_n(cn->user, &cn->user_length, sizeof(cn->user), \n              uh_buffer, user_len);\n    get_str_n(cn->host, &cn->host_length, sizeof(cn->host), \n              uh_buffer+user_len+1, host_len);\n    get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip), \n              uh_buffer+user_len+1+host_len+1, ip_len);\n  }\n\n}\n\n\nstatic struct connection_info ci_disconnect_buffer;\n\n#define AA_FREE_CONNECTION 1\n#define AA_CHANGE_USER 2\n\nstatic void update_connection_info(struct connection_info *cn,\n    unsigned int event_class, const void *ev, int *after_action)\n{\n  *after_action= 0;\n\n  switch (event_class) {\n  case MYSQL_AUDIT_GENERAL_CLASS:\n  {\n    const struct mysql_event_general *event =\n      (const struct mysql_event_general *) ev;\n    switch (event->event_subclass) {\n      case MYSQL_AUDIT_GENERAL_LOG:\n      {\n        int init_db_command= event->general_command_length == 7 &&\n          strncmp(event->general_command, \"Init DB\", 7) == 0;\n        if (!ci_needs_setup(cn))\n        {\n          if (init_db_command)\n          {\n            /* Change DB */\n            if (mysql_57_started)\n              get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                  event->database, event->database_length);\n            else\n              get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                  event->general_query, event->general_query_length);\n          }\n          cn->query_id= mode ? query_counter++ : event->query_id;\n          cn->query= event->general_query;\n          cn->query_length= event->general_query_length;\n          cn->query_time= (time_t) event->general_time;\n          update_general_user(cn, event);\n        }\n        else if (init_db_command)\n          setup_connection_initdb(cn, event);\n        else if (event_query_command(event))\n          setup_connection_query(cn, event);\n        else\n          setup_connection_simple(cn);\n        break;\n      }\n\n      case MYSQL_AUDIT_GENERAL_STATUS:\n        if (event_query_command(event))\n        {\n          if (ci_needs_setup(cn))\n            setup_connection_query(cn, event);\n\n          if (mode == 0 && cn->db_length == 0 && event->database_length > 0)\n            get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                      event->database, event->database_length);\n\n          if (event->general_error_code == 0)\n          {\n            /* We need to check if it's the USE command to change the DB */\n            int use_command= event->general_query_length > 4 &&\n              strncasecmp(event->general_query, \"use \", 4) == 0;\n            if (use_command)\n            {\n              /* Change DB */\n              if (mode)\n                get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                    event->general_query + 4, event->general_query_length - 4);\n              else\n                get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                    event->database, event->database_length);\n            }\n          }\n          update_general_user(cn, event);\n        }\n        break;\n      case MYSQL_AUDIT_GENERAL_ERROR:\n        /*\n          We need this because the MariaDB returns NULL query field for the\n          MYSQL_AUDIT_GENERAL_STATUS in the mysqld_stmt_prepare.\n          As a result we get empty QUERY field for errors.\n        */\n        if (ci_needs_setup(cn))\n          setup_connection_query(cn, event);\n        cn->query_id= mode ? query_counter++ : event->query_id;\n        get_str_n(cn->query_buffer, &cn->query_length, sizeof(cn->query_buffer),\n            event->general_query, event->general_query_length);\n        cn->query= cn->query_buffer;\n        cn->query_time= (time_t) event->general_time;\n        break;\n      default:;\n    }\n    break;\n  }\n  case MYSQL_AUDIT_TABLE_CLASS:\n  {\n    const struct mysql_event_table *event =\n      (const struct mysql_event_table *) ev;\n    if (ci_needs_setup(cn))\n      setup_connection_table(cn, event);\n\n    if (cn->user_length == 0 && cn->host_length == 0 && cn->ip_length == 0)\n    {\n      get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n                event->user, SAFE_STRLEN(event->user));\n      get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n                event->host, SAFE_STRLEN(event->host));\n      get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n                event->ip, SAFE_STRLEN(event->ip));\n    }\n\n    if (cn->db_length == 0 && event->database_length != 0)\n      get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                event->database, event->database_length);\n\n    if (mode == 0)\n      cn->query_id= event->query_id;\n    break;\n  }\n  case MYSQL_AUDIT_CONNECTION_CLASS:\n  {\n    const struct mysql_event_connection *event =\n      (const struct mysql_event_connection *) ev;\n    switch (event->event_subclass)\n    {\n      case MYSQL_AUDIT_CONNECTION_CONNECT:\n        setup_connection_connect(cn, event);\n        break;\n      case MYSQL_AUDIT_CONNECTION_CHANGE_USER:\n        *after_action= AA_CHANGE_USER;\n        break;\n      default:;\n    }\n    break;\n  }\n  default:\n    break;\n  }\n}\n\n\nstruct connection_info cn_error_buffer;\n\n\n#define FILTER(MASK) (events == 0 || (events & MASK))\nvoid auditing(MYSQL_THD thd, unsigned int event_class, const void *ev)\n{\n  struct connection_info *cn= 0;\n  int after_action= 0;\n\n  /* That one is important as this function can be called with      */\n  /* &lock_operations locked when the server logs an error reported */\n  /* by this plugin.                                                */\n  if (!thd || internal_stop_logging)\n    return;\n\n  if (maria_55_started && debug_server_started &&\n      event_class == MYSQL_AUDIT_GENERAL_CLASS)\n  {\n    /*\n      There's a bug in MariaDB 5.5 that prevents using thread local\n      variables in some cases.\n      The 'select * from notexisting_table;' query produces such case.\n      So just use the static buffer in this case.\n    */\n    const struct mysql_event_general *event =\n      (const struct mysql_event_general *) ev;\n\n    if (event->event_subclass == MYSQL_AUDIT_GENERAL_ERROR ||\n        (event->event_subclass == MYSQL_AUDIT_GENERAL_STATUS && \n         event->general_query_length == 0 &&\n         cn_error_buffer.query_id == event->query_id))\n    {\n      cn= &cn_error_buffer;\n      cn->header= 1;\n    }\n    else\n      cn= get_loc_info(thd);\n  }\n  else\n  {\n    cn= get_loc_info(thd);\n  }\n\n  update_connection_info(cn, event_class, ev, &after_action);\n\n  if (!logging)\n  {\n    if (cn)\n      cn->log_always= 0;\n    goto exit_func;\n  }\n\n  if (event_class == MYSQL_AUDIT_GENERAL_CLASS && FILTER(EVENT_QUERY) &&\n      cn && (cn->log_always || do_log_user(cn->user, cn->user_length,\n                                           cn->proxy, cn->proxy_length,\n                                           1)))\n  {\n    const struct mysql_event_general *event =\n      (const struct mysql_event_general *) ev;\n\n    /*\n      Only one subclass is logged.\n    */\n    if (event->event_subclass == MYSQL_AUDIT_GENERAL_STATUS &&\n        event_query_command(event))\n    {\n      log_statement(cn, event, \"QUERY\");\n      cn->query_length= 0; /* So the log_current_query() won't log this again. */\n      cn->log_always= 0;\n    }\n  }\n  else if (event_class == MYSQL_AUDIT_TABLE_CLASS && FILTER(EVENT_TABLE) && cn)\n  {\n    const struct mysql_event_table *event =\n      (const struct mysql_event_table *) ev;\n    if (do_log_user(event->user, (int) SAFE_STRLEN(event->user),\n                    cn->proxy, cn->proxy_length, 1))\n    {\n      switch (event->event_subclass)\n      {\n        case MYSQL_AUDIT_TABLE_LOCK:\n          log_table(cn, event, event->read_only ? \"READ\" : \"WRITE\");\n          break;\n        case MYSQL_AUDIT_TABLE_CREATE:\n          log_table(cn, event, \"CREATE\");\n          break;\n        case MYSQL_AUDIT_TABLE_DROP:\n          log_table(cn, event, \"DROP\");\n          break;\n        case MYSQL_AUDIT_TABLE_RENAME:\n          log_rename(cn, event);\n          break;\n        case MYSQL_AUDIT_TABLE_ALTER:\n          log_table(cn, event, \"ALTER\");\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  else if (event_class == MYSQL_AUDIT_CONNECTION_CLASS &&\n           FILTER(EVENT_CONNECT) && cn)\n  {\n    const struct mysql_event_connection *event =\n      (const struct mysql_event_connection *) ev;\n    switch (event->event_subclass)\n    {\n      case MYSQL_AUDIT_CONNECTION_CONNECT:\n        log_connection(cn, event, event->status ? \"FAILED_CONNECT\": \"CONNECT\");\n        if (event->status == 0 && event->proxy_user && event->proxy_user[0])\n          log_proxy(cn, event);\n        break;\n      case MYSQL_AUDIT_CONNECTION_DISCONNECT:\n        if (use_event_data_for_disconnect)\n          log_connection_event(event, \"DISCONNECT\");\n        else\n          log_connection(&ci_disconnect_buffer, event, \"DISCONNECT\");\n        break;\n      case MYSQL_AUDIT_CONNECTION_CHANGE_USER:\n        log_connection(cn, event, \"CHANGEUSER\");\n        if (event->proxy_user && event->proxy_user[0])\n          log_proxy(cn, event);\n        break;\n      default:;\n    }\n  }\nexit_func:\n  /*\n    This must work always, whether logging is ON or not.\n  */\n  if (after_action)\n  {\n    switch (after_action) {\n    case AA_CHANGE_USER:\n    {\n      const struct mysql_event_connection *event =\n        (const struct mysql_event_connection *) ev;\n      change_connection(cn, event);\n      break;\n    }\n    default:\n      break;\n    }\n  }\n}\n\n\nstruct mysql_event_general_v8\n{\n  unsigned int event_class;\n  unsigned int event_subclass;\n  int general_error_code;\n  unsigned long general_thread_id;\n  const char *general_user;\n  unsigned int general_user_length;\n  const char *general_command;\n  unsigned int general_command_length;\n  const char *general_query;\n  unsigned int general_query_length;\n  struct charset_info_st *general_charset;\n  unsigned long long general_time;\n  unsigned long long general_rows;\n};\n\n\nstatic void auditing_v8(MYSQL_THD thd, struct mysql_event_general_v8 *ev_v8)\n{\n#ifdef __linux__\n#ifdef DBUG_OFF\n  #ifdef __x86_64__\n  static const int cmd_off= 4200;\n  static const int db_off= 120;\n  static const int db_len_off= 128;\n  #else\n  static const int cmd_off= 2668;\n  static const int db_off= 60;\n  static const int db_len_off= 64;\n  #endif /*x86_64*/\n#else\n  #ifdef __x86_64__\n  static const int cmd_off= 4432;\n  static const int db_off= 120;\n  static const int db_len_off= 128;\n  #else\n  static const int cmd_off= 2808;\n  static const int db_off= 64;\n  static const int db_len_off= 68;\n  #endif /*x86_64*/\n#endif /*DBUG_OFF*/\n#endif /*__linux*/\n\n  struct mysql_event_general event;\n\n  if (ev_v8->event_class != MYSQL_AUDIT_GENERAL_CLASS)\n    return;\n\n  event.event_subclass= ev_v8->event_subclass;\n  event.general_error_code= ev_v8->general_error_code;\n  event.general_thread_id= ev_v8->general_thread_id;\n  event.general_user= ev_v8->general_user;\n  event.general_user_length= ev_v8->general_user_length;\n  event.general_command= ev_v8->general_command;\n  event.general_command_length= ev_v8->general_command_length;\n  event.general_query= ev_v8->general_query;\n  event.general_query_length= ev_v8->general_query_length;\n  event.general_charset= ev_v8->general_charset;\n  event.general_time= ev_v8->general_time;\n  event.general_rows= ev_v8->general_rows;\n  event.database= 0;\n  event.database_length= 0;\n\n  if (event.general_query_length > 0)\n  {\n    event.event_subclass= MYSQL_AUDIT_GENERAL_STATUS;\n    event.general_command= \"Query\";\n    event.general_command_length= 5;\n#ifdef __linux__\n    event.database= *(char **) (((char *) thd) + db_off);\n    event.database_length= *(size_t *) (((char *) thd) + db_len_off);\n#endif /*__linux*/\n  }\n#ifdef __linux__\n  else if (*((int *) (((char *)thd) + cmd_off)) == 2)\n  {\n    event.event_subclass= MYSQL_AUDIT_GENERAL_LOG;\n    event.general_command= \"Init DB\";\n    event.general_command_length= 7;\n    event.general_query= *(char **) (((char *) thd) + db_off);\n    event.general_query_length= *(size_t *) (((char *) thd) + db_len_off);\n  }\n#endif /*__linux*/\n  auditing(thd, ev_v8->event_class, &event);\n}\n\n\nstatic void auditing_v13(MYSQL_THD thd, unsigned int *ev_v0)\n{\n  struct mysql_event_general event= *(const struct mysql_event_general *) (ev_v0+1);\n\n  if (event.general_query_length > 0)\n  {\n    event.event_subclass= MYSQL_AUDIT_GENERAL_STATUS;\n    event.general_command= \"Query\";\n    event.general_command_length= 5;\n  }\n  auditing(thd, ev_v0[0], &event);\n}\n\n\nint get_db_mysql57(MYSQL_THD thd, char **name, int *len)\n{\n#ifdef __linux__\n  int db_off;\n  int db_len_off;\n  if (debug_server_started)\n  {\n#ifdef __x86_64__\n    db_off= 608;\n    db_len_off= 616;\n#else\n    db_off= 0;\n    db_len_off= 0;\n#endif /*x86_64*/\n  }\n  else\n  {\n#ifdef __x86_64__\n    db_off= 536;\n    db_len_off= 544;\n#else\n    db_off= 0;\n    db_len_off= 0;\n#endif /*x86_64*/\n  }\n\n  *name= *(char **) (((char *) thd) + db_off);\n  *len= *((int *) (((char*) thd) + db_len_off));\n  if (*name && (*name)[*len] != 0)\n    return 1;\n  return 0;\n#else\n  return 1;\n#endif\n}\n/*\n   As it's just too difficult to #include \"sql_class.h\",\n   let's just copy the necessary part of the system_variables\n   structure here.\n*/\ntypedef struct loc_system_variables\n{\n  ulong dynamic_variables_version;\n  char* dynamic_variables_ptr;\n  uint dynamic_variables_head;    /* largest valid variable offset */\n  uint dynamic_variables_size;    /* how many bytes are in use */\n  \n  ulonglong max_heap_table_size;\n  ulonglong tmp_table_size;\n  ulonglong long_query_time;\n  ulonglong optimizer_switch;\n  ulonglong sql_mode; ///< which non-standard SQL behaviour should be enabled\n  ulonglong option_bits; ///< OPTION_xxx constants, e.g. OPTION_PROFILING\n  ulonglong join_buff_space_limit;\n  ulonglong log_slow_filter; \n  ulonglong log_slow_verbosity; \n  ulonglong bulk_insert_buff_size;\n  ulonglong join_buff_size;\n  ulonglong sortbuff_size;\n  ulonglong group_concat_max_len;\n  ha_rows select_limit;\n  ha_rows max_join_size;\n  ha_rows expensive_subquery_limit;\n  ulong auto_increment_increment, auto_increment_offset;\n  ulong lock_wait_timeout;\n  ulong join_cache_level;\n  ulong max_allowed_packet;\n  ulong max_error_count;\n  ulong max_length_for_sort_data;\n  ulong max_sort_length;\n  ulong max_tmp_tables;\n  ulong max_insert_delayed_threads;\n  ulong min_examined_row_limit;\n  ulong multi_range_count;\n  ulong net_buffer_length;\n  ulong net_interactive_timeout;\n  ulong net_read_timeout;\n  ulong net_retry_count;\n  ulong net_wait_timeout;\n  ulong net_write_timeout;\n  ulong optimizer_prune_level;\n  ulong optimizer_search_depth;\n  ulong preload_buff_size;\n  ulong profiling_history_size;\n  ulong read_buff_size;\n  ulong read_rnd_buff_size;\n  ulong mrr_buff_size;\n  ulong div_precincrement;\n  /* Total size of all buffers used by the subselect_rowid_merge_engine. */\n  ulong rowid_merge_buff_size;\n  ulong max_sp_recursion_depth;\n  ulong default_week_format;\n  ulong max_seeks_for_key;\n  ulong range_alloc_block_size;\n  ulong query_alloc_block_size;\n  ulong query_prealloc_size;\n  ulong trans_alloc_block_size;\n  ulong trans_prealloc_size;\n  ulong log_warnings;\n  /* Flags for slow log filtering */\n  ulong log_slow_rate_limit; \n  ulong binlog_format; ///< binlog format for this thd (see enum_binlog_format)\n  ulong progress_report_time;\n  my_bool binlog_annotate_row_events;\n  my_bool binlog_direct_non_trans_update;\n  my_bool sql_log_bin;\n  ulong completion_type;\n  ulong query_cache_type;\n} LOC_SV;\n\n\nstatic int init_done= 0;\n\nstatic int server_audit_init(void *p __attribute__((unused)))\n{\n  if (!serv_ver)\n  {\n#ifdef _WIN32\n    serv_ver= (const char *) GetProcAddress(0, \"server_version\");\n#else\n    serv_ver= server_version;\n#endif /*_WIN32*/\n  }\n  if (!mysql_57_started)\n  {\n    const void *my_hash_init_ptr= dlsym(RTLD_DEFAULT, \"_my_hash_init\");\n    if (!my_hash_init_ptr)\n    {\n      maria_above_5= 1;\n      my_hash_init_ptr= dlsym(RTLD_DEFAULT, \"my_hash_init2\");\n    }\n    if (!my_hash_init_ptr)\n      return 1;\n  }\n\n  if(!(int_mysql_data_home= dlsym(RTLD_DEFAULT, \"mysql_data_home\")))\n  {\n    if(!(int_mysql_data_home= dlsym(RTLD_DEFAULT, \"?mysql_data_home@@3PADA\")))\n      int_mysql_data_home= &default_home;\n  }\n\n  if (!serv_ver)\n    return 1;\n\n  if (!started_mysql)\n  {\n    if (!maria_above_5 && serv_ver[4]=='3' && serv_ver[5]<'3')\n    {\n      mode= 1;\n      mode_readonly= 1;\n    }\n  }\n\n  if (gethostname(servhost, sizeof(servhost)))\n    strcpy(servhost, \"unknown\");\n\n  servhost_len= (uint)strlen(servhost);\n\n  logger_init_mutexes();\n#if defined(HAVE_PSI_INTERFACE) && !defined(FLOGGER_NO_PSI)\n  if (PSI_server)\n    PSI_server->register_mutex(\"server_audit\", mutex_key_list, 1);\n#endif\n  flogger_mutex_init(key_LOCK_operations, &lock_operations, MY_MUTEX_INIT_FAST);\n  flogger_mutex_init(key_LOCK_operations, &lock_atomic, MY_MUTEX_INIT_FAST);\n  flogger_mutex_init(key_LOCK_operations, &lock_bigbuffer, MY_MUTEX_INIT_FAST);\n\n  coll_init(&incl_user_coll);\n  coll_init(&excl_user_coll);\n\n  if (incl_users)\n  {\n    if (excl_users)\n    {\n      incl_users= excl_users= NULL;\n      error_header();\n      fprintf(stderr, \"INCL_DML_USERS and EXCL_DML_USERS specified\"\n                      \" simultaneously - both set to empty\\n\");\n    }\n    update_incl_users(NULL, NULL, NULL, &incl_users);\n  }\n  else if (excl_users)\n  {\n    update_excl_users(NULL, NULL, NULL, &excl_users);\n  }\n\n  error_header();\n  fprintf(stderr, \"MariaDB Audit Plugin version %s%s STARTED.\\n\",\n          PLUGIN_STR_VERSION, PLUGIN_DEBUG_VERSION);\n\n  /* The Query Cache shadows TABLE events if the result is taken from it */\n  /* so we warn users if both Query Cashe and TABLE events enabled.      */\n  if (!started_mysql && FILTER(EVENT_TABLE))\n  {\n    ulonglong *qc_size= (ulonglong *) dlsym(RTLD_DEFAULT, \"query_cache_size\");\n    if (qc_size == NULL || *qc_size != 0)\n    {\n      struct loc_system_variables *g_sys_var=\n        (struct loc_system_variables *) dlsym(RTLD_DEFAULT,\n                                          \"global_system_variables\");\n      if (g_sys_var && g_sys_var->query_cache_type != 0)\n      {\n        error_header();\n        fprintf(stderr, \"Query cache is enabled with the TABLE events.\"\n                        \" Some table reads can be veiled.\");\n      }\n    }\n  }\n\n  ci_disconnect_buffer.header= 10;\n  ci_disconnect_buffer.thread_id= 0;\n  ci_disconnect_buffer.query_id= 0;\n  ci_disconnect_buffer.db_length= 0;\n  ci_disconnect_buffer.user_length= 0;\n  ci_disconnect_buffer.host_length= 0;\n  ci_disconnect_buffer.ip_length= 0;\n  ci_disconnect_buffer.query= empty_str;\n  ci_disconnect_buffer.query_length= 0;\n\n  if (logging)\n    start_logging();\n\n  init_done= 1;\n  return 0;\n}\n\n\nstatic int server_audit_init_mysql(void *p)\n{\n  started_mysql= 1;\n  mode= 1;\n  mode_readonly= 1;\n  return server_audit_init(p);\n}\n\n\nstatic int server_audit_deinit(void *p __attribute__((unused)))\n{\n  if (!init_done)\n    return 0;\n\n  init_done= 0;\n  coll_free(&incl_user_coll);\n  coll_free(&excl_user_coll);\n\n  if (output_type == OUTPUT_FILE && logfile)\n    logger_close(logfile);\n  else if (output_type == OUTPUT_SYSLOG)\n    closelog();\n\n  (void) free(big_buffer);\n  flogger_mutex_destroy(&lock_operations);\n  flogger_mutex_destroy(&lock_atomic);\n  flogger_mutex_destroy(&lock_bigbuffer);\n\n  error_header();\n  fprintf(stderr, \"STOPPED\\n\");\n  return 0;\n}\n\n\nstatic void rotate_log(MYSQL_THD thd  __attribute__((unused)),\n                       struct st_mysql_sys_var *var  __attribute__((unused)),\n                       void *var_ptr  __attribute__((unused)),\n                       const void *save  __attribute__((unused)))\n{\n  if (output_type == OUTPUT_FILE && logfile && *(my_bool*) save)\n    (void) logger_rotate(logfile);\n}\n\n\nstatic struct st_mysql_audit mysql_descriptor =\n{\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  NULL,\n  auditing,\n  { MYSQL_AUDIT_GENERAL_CLASSMASK | MYSQL_AUDIT_CONNECTION_CLASSMASK }\n};\n\n\nmysql_declare_plugin(server_audit)\n{\n  MYSQL_AUDIT_PLUGIN,\n  &mysql_descriptor,\n  \"SERVER_AUDIT\",\n  \" Alexey Botchkov (MariaDB Corporation)\",\n  \"Audit the server activity\",\n  PLUGIN_LICENSE_GPL,\n  server_audit_init_mysql,\n  server_audit_deinit,\n  PLUGIN_VERSION,\n  audit_status,\n  vars,\n  NULL,\n  0\n}\nmysql_declare_plugin_end;\n\n\nstatic struct st_mysql_audit maria_descriptor =\n{\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  NULL,\n  auditing,\n  { MYSQL_AUDIT_GENERAL_CLASSMASK |\n    MYSQL_AUDIT_TABLE_CLASSMASK |\n    MYSQL_AUDIT_CONNECTION_CLASSMASK }\n};\nmaria_declare_plugin(server_audit)\n{\n  MYSQL_AUDIT_PLUGIN,\n  &maria_descriptor,\n  \"SERVER_AUDIT\",\n  \"Alexey Botchkov (MariaDB Corporation)\",\n  \"Audit the server activity\",\n  PLUGIN_LICENSE_GPL,\n  server_audit_init,\n  server_audit_deinit,\n  PLUGIN_VERSION,\n  audit_status,\n  vars,\n  PLUGIN_STR_VERSION,\n  MariaDB_PLUGIN_MATURITY_STABLE\n}\nmaria_declare_plugin_end;\n\n\nstatic void mark_always_logged(MYSQL_THD thd)\n{\n  struct connection_info *cn;\n  if (thd && (cn= get_loc_info(thd)))\n    cn->log_always= 1;\n}\n\n\nstatic void log_current_query(MYSQL_THD thd)\n{\n  struct connection_info *cn;\n  if (!thd)\n    return;\n  cn= get_loc_info(thd);\n  if (!ci_needs_setup(cn) && cn->query_length)\n  {\n    cn->log_always= 1;\n    log_statement_ex(cn, cn->query_time, thd_get_thread_id(thd),\n\t\t     cn->query, cn->query_length, 0, \"QUERY\", 0);\n    cn->log_always= 0;\n  }\n}\n\n\nstatic void update_file_path(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_name= (*(char **) save) ? *(char **) save : empty_str;\n\n  ADD_ATOMIC(internal_stop_logging, 1);\n  error_header();\n  fprintf(stderr, \"Log file name was changed to '%s'.\\n\", new_name);\n\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n\n  if (logging)\n    log_current_query(thd);\n\n  if (logging && output_type == OUTPUT_FILE)\n  {\n    char *sav_path= file_path;\n\n    file_path= new_name;\n    stop_logging();\n    if (start_logging())\n    {\n      file_path= sav_path;\n      error_header();\n      fprintf(stderr, \"Reverting log filename back to '%s'.\\n\", file_path);\n      logging= (start_logging() == 0);\n      if (!logging)\n      {\n        error_header();\n        fprintf(stderr, \"Logging was disabled..\\n\");\n        CLIENT_ERROR(1, \"Logging was disabled.\", MYF(ME_JUST_WARNING));\n      }\n      goto exit_func;\n    }\n  }\n\n  strncpy(path_buffer, new_name, sizeof(path_buffer)-1);\n  path_buffer[sizeof(path_buffer)-1]= 0;\n  file_path= path_buffer;\nexit_func:\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n  ADD_ATOMIC(internal_stop_logging, -1);\n}\n\n\nstatic void update_file_rotations(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  rotations= *(unsigned int *) save;\n  error_header();\n  fprintf(stderr, \"Log file rotations was changed to '%d'.\\n\", rotations);\n\n  if (!logging || output_type != OUTPUT_FILE)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n  logfile->rotations= rotations;\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_file_rotate_size(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  file_rotate_size= *(unsigned long long *) save;\n  error_header();\n  fprintf(stderr, \"Log file rotate size was changed to '%lld'.\\n\",\n          file_rotate_size);\n\n  if (!logging || output_type != OUTPUT_FILE)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n  logfile->size_limit= file_rotate_size;\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic int check_users(void *save, struct st_mysql_value *value,\n                       size_t s, const char *name)\n{\n  const char *users;\n  int len= 0;\n\n  users= value->val_str(value, NULL, &len);\n  if ((size_t) len > s)\n  {\n    error_header();\n    fprintf(stderr,\n            \"server_audit_%s_users value can't be longer than %zu characters.\\n\",\n            name, s);\n    return 1;\n  }\n  *((const char**)save)= users;\n  return 0;\n}\n\nstatic int check_incl_users(MYSQL_THD thd  __attribute__((unused)),\n                            struct st_mysql_sys_var *var  __attribute__((unused)),\n                            void *save, struct st_mysql_value *value)\n{\n  return check_users(save, value, sizeof(incl_user_buffer), \"incl\");\n}\n\nstatic int check_excl_users(MYSQL_THD thd  __attribute__((unused)),\n                            struct st_mysql_sys_var *var  __attribute__((unused)),\n                            void *save, struct st_mysql_value *value)\n{\n  return check_users(save, value, sizeof(excl_user_buffer), \"excl\");\n}\n\n\nstatic void update_incl_users(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_users= (*(char **) save) ? *(char **) save : empty_str;\n  size_t new_len= strlen(new_users) + 1;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n\n  if (new_len > sizeof(incl_user_buffer))\n    new_len= sizeof(incl_user_buffer);\n\n  memcpy(incl_user_buffer, new_users, new_len - 1);\n  incl_user_buffer[new_len - 1]= 0;\n\n  incl_users= incl_user_buffer;\n  user_coll_fill(&incl_user_coll, incl_users, &excl_user_coll, 1);\n  error_header();\n  fprintf(stderr, \"server_audit_incl_users set to '%s'.\\n\", incl_users);\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_excl_users(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_users= (*(char **) save) ? *(char **) save : empty_str;\n  size_t new_len= strlen(new_users) + 1;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n\n  if (new_len > sizeof(excl_user_buffer))\n    new_len= sizeof(excl_user_buffer);\n\n  memcpy(excl_user_buffer, new_users, new_len - 1);\n  excl_user_buffer[new_len - 1]= 0;\n\n  excl_users= excl_user_buffer;\n  user_coll_fill(&excl_user_coll, excl_users, &incl_user_coll, 0);\n  error_header();\n  fprintf(stderr, \"server_audit_excl_users set to '%s'.\\n\", excl_users);\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_output_type(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  ulong new_output_type= *((ulong *) save);\n  if (output_type == new_output_type)\n    return;\n\n  ADD_ATOMIC(internal_stop_logging, 1);\n  flogger_mutex_lock(&lock_operations);\n  if (logging)\n  {\n    log_current_query(thd);\n    stop_logging();\n  }\n\n  output_type= new_output_type;\n  error_header();\n  fprintf(stderr, \"Output was redirected to '%s'\\n\",\n          output_type_names[output_type]);\n\n  if (logging)\n    start_logging();\n  flogger_mutex_unlock(&lock_operations);\n  ADD_ATOMIC(internal_stop_logging, -1);\n}\n\n\nstatic void update_syslog_facility(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  ulong new_facility= *((ulong *) save);\n  if (syslog_facility == new_facility)\n    return;\n\n  mark_always_logged(thd);\n  error_header();\n  fprintf(stderr, \"SysLog facility was changed from '%s' to '%s'.\\n\",\n          syslog_facility_names[syslog_facility],\n          syslog_facility_names[new_facility]);\n  syslog_facility= new_facility;\n}\n\n\nstatic void update_syslog_priority(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  ulong new_priority= *((ulong *) save);\n  if (syslog_priority == new_priority)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n  flogger_mutex_unlock(&lock_operations);\n  error_header();\n  fprintf(stderr, \"SysLog priority was changed from '%s' to '%s'.\\n\",\n          syslog_priority_names[syslog_priority],\n          syslog_priority_names[new_priority]);\n  syslog_priority= new_priority;\n}\n\n\nstatic void update_logging(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char new_logging= *(char *) save;\n  if (new_logging == logging)\n    return;\n\n  ADD_ATOMIC(internal_stop_logging, 1);\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  if ((logging= new_logging))\n  {\n    start_logging();\n    if (!logging)\n    {\n      CLIENT_ERROR(1, \"Logging was disabled.\", MYF(ME_JUST_WARNING));\n    }\n    mark_always_logged(thd);\n  }\n  else\n  {\n    log_current_query(thd);\n    stop_logging();\n  }\n\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n  ADD_ATOMIC(internal_stop_logging, -1);\n}\n\n\nstatic void update_mode(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  unsigned int new_mode= *(unsigned int *) save;\n  if (mode_readonly || new_mode == mode)\n    return;\n\n  ADD_ATOMIC(internal_stop_logging, 1);\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n  error_header();\n  fprintf(stderr, \"Logging mode was changed from %d to %d.\\n\", mode, new_mode);\n  mode= new_mode;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n  ADD_ATOMIC(internal_stop_logging, -1);\n}\n\n\nstatic void update_syslog_ident(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_ident= (*(char **) save) ? *(char **) save : empty_str;\n  strncpy(syslog_ident_buffer, new_ident, sizeof(syslog_ident_buffer)-1);\n  syslog_ident_buffer[sizeof(syslog_ident_buffer)-1]= 0;\n  syslog_ident= syslog_ident_buffer;\n  error_header();\n  fprintf(stderr, \"SYSYLOG ident was changed to '%s'\\n\", syslog_ident);\n  flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n  if (logging && output_type == OUTPUT_SYSLOG)\n  {\n    stop_logging();\n    start_logging();\n  }\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstruct st_my_thread_var *loc_thread_var(void)\n{\n  return 0;\n}\n\n\n\n#ifdef _WIN32\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n  if (fdwReason != DLL_PROCESS_ATTACH)\n    return 1;\n\n  serv_ver= (const char *) GetProcAddress(0, \"server_version\");\n#else\nvoid __attribute__ ((constructor)) audit_plugin_so_init(void)\n{\n  serv_ver= server_version;\n#endif /*_WIN32*/\n\n  if (!serv_ver)\n    goto exit;\n\n  started_mariadb= strstr(serv_ver, \"MariaDB\") != 0;\n  debug_server_started= strstr(serv_ver, \"debug\") != 0;\n\n  if (started_mariadb)\n  {\n    if (serv_ver[0] == '1')\n      use_event_data_for_disconnect= 1;\n    else\n      maria_55_started= 1;\n  }\n  else\n  {\n    /* Started MySQL. */\n    if (serv_ver[0] == '5' && serv_ver[2] == '5')\n    {\n      int sc= serv_ver[4] - '0';\n      if (serv_ver[5] >= '0' && serv_ver[5] <= '9')\n        sc= sc * 10 + serv_ver[5] - '0';\n      if (sc <= 10)\n      {\n        mysql_descriptor.interface_version= 0x0200;\n        mysql_descriptor.event_notify= (void *) auditing_v8;\n      }\n      else if (sc < 14)\n      {\n        mysql_descriptor.interface_version= 0x0200;\n        mysql_descriptor.event_notify= (void *) auditing_v13;\n      }\n    }\n    else if (serv_ver[0] == '5' && serv_ver[2] == '6')\n    {\n      int sc= serv_ver[4] - '0';\n      if (serv_ver[5] >= '0' && serv_ver[5] <= '9')\n        sc= sc * 10 + serv_ver[5] - '0';\n      if (sc >= 24)\n        use_event_data_for_disconnect= 1;\n    }\n    else if ((serv_ver[0] == '5' && serv_ver[2] == '7') ||\n             (serv_ver[0] == '8' && serv_ver[2] == '0'))\n    {\n      mysql_57_started= 1;\n      _mysql_plugin_declarations_[0].info= mysql_v4_descriptor;\n      use_event_data_for_disconnect= 1;\n    }\n    MYSQL_SYSVAR_NAME(loc_info).flags= PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL |\n      PLUGIN_VAR_READONLY | PLUGIN_VAR_MEMALLOC;\n  }\n\n  memset(locinfo_ini_value, 'O', sizeof(locinfo_ini_value)-1);\n  locinfo_ini_value[sizeof(locinfo_ini_value)-1]= 0;\n\nexit:\n#ifdef _WIN32\n  return 1;\n#else\n  return;\n#endif\n}\n\n"], "fixing_code": ["install plugin server_audit soname 'server_audit';\nshow variables like 'server_audit%';\nVariable_name\tValue\nserver_audit_events\t\nserver_audit_excl_users\t\nserver_audit_file_path\tserver_audit.log\nserver_audit_file_rotate_now\tOFF\nserver_audit_file_rotate_size\t1000000\nserver_audit_file_rotations\t9\nserver_audit_incl_users\t\nserver_audit_logging\tOFF\nserver_audit_mode\t0\nserver_audit_output_type\tfile\nserver_audit_query_log_limit\t1024\nserver_audit_syslog_facility\tLOG_USER\nserver_audit_syslog_ident\tmysql-server_auditing\nserver_audit_syslog_info\t\nserver_audit_syslog_priority\tLOG_INFO\nset global server_audit_file_path=null;\nset global server_audit_incl_users=null;\nset global server_audit_file_path='server_audit.log';\nset global server_audit_output_type=file;\nset global server_audit_logging=on;\nset global server_audit_incl_users= repeat(\"'root',\", 10000);\nERROR 42000: Variable 'server_audit_incl_users' can't be set to the value of ''root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','...'\nshow variables like 'server_audit_incl_users';\nVariable_name\tValue\nserver_audit_incl_users\t\nset global server_audit_excl_users= repeat(\"'root',\", 10000);\nERROR 42000: Variable 'server_audit_excl_users' can't be set to the value of ''root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','root','...'\nshow variables like 'server_audit_excl_users';\nVariable_name\tValue\nserver_audit_excl_users\t\nconnect  con1,localhost,root,,mysql;\ndisconnect con1;\nconnect(localhost,no_such_user,,mysql,MASTER_PORT,MASTER_SOCKET);\nconnect  con1,localhost,no_such_user,,mysql;\nERROR 28000: Access denied for user 'no_such_user'@'localhost' (using password: NO)\nconnection default;\nset global server_audit_incl_users='odin, dva, tri';\ncreate table t1 (id int);\nset global server_audit_incl_users='odin, root, dva, tri';\ncreate table t2 (id int);\nset global server_audit_excl_users='odin, dva, tri';\nWarnings:\nWarning\t1\tUser 'odin' is in the server_audit_incl_users, so wasn't added.\nWarning\t1\tUser 'dva' is in the server_audit_incl_users, so wasn't added.\nWarning\t1\tUser 'tri' is in the server_audit_incl_users, so wasn't added.\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nset global server_audit_incl_users='odin, root, dva, tri';\ninsert into t2 values (1), (2);\nselect * from t2;\nid\n1\n2\nalter table t1 rename renamed_t1;\nset global server_audit_events='connect,query';\nselect 1,\n2,\n# comment\n3;\n1\t2\t3\n1\t2\t3\ninsert into t2 values (1), (2);\nselect * from t2;\nid\n1\n2\n1\n2\nselect * from t_doesnt_exist;\nERROR 42S02: Table 'test.t_doesnt_exist' doesn't exist\nsyntax_error_query;\nERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'syntax_error_query' at line 1\ndrop table renamed_t1, t2;\nshow variables like 'server_audit%';\nVariable_name\tValue\nserver_audit_events\tCONNECT,QUERY\nserver_audit_excl_users\t\nserver_audit_file_path\tserver_audit.log\nserver_audit_file_rotate_now\tOFF\nserver_audit_file_rotate_size\t1000000\nserver_audit_file_rotations\t9\nserver_audit_incl_users\todin, root, dva, tri\nserver_audit_logging\tON\nserver_audit_mode\t0\nserver_audit_output_type\tfile\nserver_audit_query_log_limit\t1024\nserver_audit_syslog_facility\tLOG_USER\nserver_audit_syslog_ident\tmysql-server_auditing\nserver_audit_syslog_info\t\nserver_audit_syslog_priority\tLOG_INFO\nset global server_audit_mode=1;\nset global server_audit_events='';\ncreate database sa_db;\nconnect  con1,localhost,root,,test;\ncreate table t1 (id2 int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid2\n1\n2\ndrop table t1;\nuse sa_db;\ncreate table sa_t1(id int);\ninsert into sa_t1 values (1), (2);\ndrop table sa_t1;\ndrop database sa_db;\ndisconnect con1;\nconnection default;\ncreate database sa_db;\nuse sa_db;\nCREATE USER u1 IDENTIFIED BY 'pwd-123';\nGRANT ALL ON sa_db TO u2 IDENTIFIED BY \"pwd-321\";\nSET PASSWORD FOR u1 = PASSWORD('pwd 098');\nCREATE USER u3 IDENTIFIED BY '';\nALTER USER u3 IDENTIFIED BY 'pwd-456';\ndrop user u1, u2, u3;\nset global server_audit_events='query_ddl';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nselect 2;\n2\n2\n(select 2);\n2\n2\n/*! select 2*/;\n2\n2\n/*comment*/ select 2;\n2\n2\ndrop table t1;\ncreate procedure pr1() insert into test.t1 values (\"foo\", 42);\ncreate function fn1(i int) returns int deterministic return i+1;\ndrop procedure pr1;\ndrop function fn1;\nset global server_audit_events='query_ddl,query_dml';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nselect 2;\n2\n2\ndrop table t1;\nset global server_audit_events='query_dml';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nselect 2;\n2\n2\n(select 2);\n2\n2\n/*! select 2*/;\n2\n2\n/*comment*/ select 2;\n2\n2\ndrop table t1;\nset global server_audit_events='query_dcl';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nCREATE USER u1 IDENTIFIED BY 'pwd-123';\nGRANT ALL ON sa_db TO u2 IDENTIFIED BY \"pwd-321\";\nSET PASSWORD \n# comment\nFOR u1 = PASSWORD('pwd 098');\nSET PASSWORD FOR u1=<secret>;\nERROR 42000: You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near '<secret>' at line 1\nCREATE USER u3 IDENTIFIED BY '';\ndrop user u1, u2, u3;\nselect 2;\n2\n2\n(select 2);\n2\n2\n/*! select 2*/;\n2\n2\n/*comment*/ select 2;\n2\n2\ndrop table t1;\nset global server_audit_events='query_dml_no_select';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nid\n1\n2\nselect 2;\n2\n2\ndrop table t1;\ncreate procedure pr1() insert into test.t1 values (\"foo\", 42);\ncreate function fn1(i int) returns int deterministic return i+1;\ndrop procedure pr1;\ndrop function fn1;\nset global server_audit_events='table';\nset global server_audit_incl_users='user1';\ncreate user user1@localhost;\ngrant all on sa_db.* to user1@localhost;\nconnect  cn1,localhost,user1,,sa_db;\nconnection cn1;\ncreate table t1(id int) engine=myisam;\ninsert delayed into t1 values (1);\nconnection default;\n# Waiting until INSERT DELAYED thread does the insert.\ndrop table t1;\nset global server_audit_logging= off;\nset global server_audit_incl_users='root';\nset global server_audit_logging= on;\ndisconnect cn1;\ndrop user user1@localhost;\nset global server_audit_events='';\nset global server_audit_incl_users='root, plug_dest';\nCREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest';\nCREATE USER plug_dest IDENTIFIED BY 'plug_dest_passwd';\nconnect(localhost,plug,plug_dest,test,MYSQL_PORT,MYSQL_SOCK);\nconnect plug_con,localhost,plug,plug_dest;\nERROR 28000: Access denied for user 'plug'@'localhost' (using password: YES)\nGRANT PROXY ON plug_dest TO plug;\nconnect plug_con,localhost,plug,plug_dest;\nconnection plug_con;\nselect USER(),CURRENT_USER();\nUSER()\tCURRENT_USER()\nplug@localhost\tplug_dest@%\nconnection default;\ndisconnect plug_con;\nDROP USER plug;\nDROP USER plug_dest;\nset global server_audit_query_log_limit= 15;\nselect (1), (2), (3), (4);\n1\t2\t3\t4\n1\t2\t3\t4\nselect 'A', 'B', 'C', 'D';\nA\tB\tC\tD\nA\tB\tC\tD\nset global server_audit_query_log_limit= 1024;\ndrop database sa_db;\nselect length('01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789');\nlength('0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456\n2750\nset global server_audit_file_path='.';\nshow status like 'server_audit_current_log';\nVariable_name\tValue\nServer_audit_current_log\tHOME_DIR/server_audit.log\nset global server_audit_file_path='';\nshow status like 'server_audit_current_log';\nVariable_name\tValue\nServer_audit_current_log\tserver_audit.log\nset global server_audit_file_path='  ';\nshow status like 'server_audit_current_log';\nVariable_name\tValue\nServer_audit_current_log\tserver_audit.log\nset global server_audit_file_path='nonexisting_dir/';\nWarnings:\nWarning\t1\tSERVER AUDIT plugin can't create file 'nonexisting_dir/'.\nshow status like 'server_audit_current_log';\nVariable_name\tValue\nServer_audit_current_log\tserver_audit.log\nshow variables like 'server_audit%';\nVariable_name\tValue\nserver_audit_events\t\nserver_audit_excl_users\t\nserver_audit_file_path\t  \nserver_audit_file_rotate_now\tOFF\nserver_audit_file_rotate_size\t1000000\nserver_audit_file_rotations\t9\nserver_audit_incl_users\troot, plug_dest\nserver_audit_logging\tON\nserver_audit_mode\t1\nserver_audit_output_type\tfile\nserver_audit_query_log_limit\t1024\nserver_audit_syslog_facility\tLOG_USER\nserver_audit_syslog_ident\tmysql-server_auditing\nserver_audit_syslog_info\t\nserver_audit_syslog_priority\tLOG_INFO\nuninstall plugin server_audit;\nWarnings:\nWarning\t1620\tPlugin is busy and will be uninstalled on shutdown\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_logging=on',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_incl_users= repeat(\"\\'root\\',\", 10000)',ID\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'show variables like \\'server_audit_incl_users\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_excl_users= repeat(\"\\'root\\',\", 10000)',ID\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'show variables like \\'server_audit_excl_users\\'',0\nTIME,HOSTNAME,root,localhost,ID,0,CONNECT,mysql,,0\nTIME,HOSTNAME,root,localhost,ID,0,DISCONNECT,mysql,,0\nTIME,HOSTNAME,no_such_user,localhost,ID,0,FAILED_CONNECT,,,ID\nTIME,HOSTNAME,no_such_user,localhost,ID,0,DISCONNECT,,,0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_incl_users=\\'odin, dva, tri\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_incl_users=\\'odin, root, dva, tri\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,CREATE,test,t2,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'create table t2 (id int)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_excl_users=\\'odin, dva, tri\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'SHOW WARNINGS',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'insert into t1 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,READ,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select * from t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_incl_users=\\'odin, root, dva, tri\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,test,t2,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'insert into t2 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,READ,test,t2,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select * from t2',0\nTIME,HOSTNAME,root,localhost,ID,ID,ALTER,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,table_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,column_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,index_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,RENAME,test,t1|test.renamed_t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'alter table t1 rename renamed_t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_events=\\'connect,query\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select 1,\\n2,\\n# comment\\n3',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'insert into t2 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select * from t2',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select * from t_doesnt_exist',ID\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'syntax_error_query',ID\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'drop table renamed_t1, t2',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'show variables like \\'server_audit%\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_mode=1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'set global server_audit_events=\\'\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'create database sa_db',0\nTIME,HOSTNAME,root,localhost,ID,0,CONNECT,test,,0\nTIME,HOSTNAME,root,localhost,ID,ID,CREATE,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'create table t1 (id2 int)',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'insert into t1 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,READ,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'select * from t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,table_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,column_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,index_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,DROP,test,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'drop table t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'use sa_db',0\nTIME,HOSTNAME,root,localhost,ID,ID,CREATE,sa_db,sa_t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'create table sa_t1(id int)',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,sa_db,sa_t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'insert into sa_t1 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,table_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,column_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,index_stats,\nTIME,HOSTNAME,root,localhost,ID,ID,DROP,sa_db,sa_t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop table sa_t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,READ,mysql,proc,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proc,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,event,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop database sa_db',0\nTIME,HOSTNAME,root,localhost,ID,0,DISCONNECT,,,0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,test,'create database sa_db',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'use sa_db',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER u1 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'GRANT ALL ON sa_db TO u2 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'SET PASSWORD FOR u1 = PASSWORD(*****)',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER u3 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'ALTER USER u3 IDENTIFIED BY \\'pwd-456\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop user u1, u2, u3',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'create table t1(id int)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop table t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'create procedure pr1() insert into test.t1 values (\"foo\", 42)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'create function fn1(i int) returns int deterministic return i+1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop procedure pr1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop function fn1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'create table t1(id int)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'insert into t1 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select * from t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select 2',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop table t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'insert into t1 values (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select * from t1',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select 2',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'(select 2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'/*! select 2*/',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'/*comment*/ select 2',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER u1 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'GRANT ALL ON sa_db TO u2 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'SET PASSWORD \\n# comment\\nFOR u1 = PASSWORD(*****)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'SET PASSWORD FOR u1=<secret>',ID\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER u3 IDENTIFIED BY *****',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop user u1, u2, u3',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'insert into t1 values (1), (2)',0\nTIME,HOSTNAME,user1,localhost,ID,ID,CREATE,sa_db,t1,\nTIME,HOSTNAME,user1,localhost,ID,ID,WRITE,sa_db,t1,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_logging= off',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_events=\\'\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_incl_users=\\'root, plug_dest\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER plug IDENTIFIED WITH \\'test_plugin_server\\' AS \\'plug_dest\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'CREATE USER plug_dest IDENTIFIED BY *****',0\nTIME,HOSTNAME,plug,localhost,ID,0,FAILED_CONNECT,,,ID\nTIME,HOSTNAME,plug,localhost,ID,0,DISCONNECT,,,0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'GRANT PROXY ON plug_dest TO plug',0\nTIME,HOSTNAME,plug,localhost,ID,0,CONNECT,test,,0\nTIME,HOSTNAME,plug,localhost,ID,0,PROXY_CONNECT,test,`plug_dest`@`%`,0\nTIME,HOSTNAME,plug,localhost,ID,ID,QUERY,test,'select USER(),CURRENT_USER()',0\nTIME,HOSTNAME,plug,localhost,ID,0,DISCONNECT,test,,0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'DROP USER plug',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,user,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,db,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,tables_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,columns_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,procs_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proxies_priv,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,roles_mapping,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'DROP USER plug_dest',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global serv',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select (1), (2)',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select \\'A\\', ',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_query_log_limit= 1024',0\nTIME,HOSTNAME,root,localhost,ID,ID,READ,mysql,proc,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,proc,\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,event,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'drop database sa_db',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'select length(\\'012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'.\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'.\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'show status like \\'server_audit_current_log\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'show status like \\'server_audit_current_log\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'  \\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'  \\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'show status like \\'server_audit_current_log\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'nonexisting_dir/\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'set global server_audit_file_path=\\'nonexisting_dir/\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'SHOW WARNINGS',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'show status like \\'server_audit_current_log\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'show variables like \\'server_audit%\\'',0\nTIME,HOSTNAME,root,localhost,ID,ID,WRITE,mysql,plugin,\nTIME,HOSTNAME,root,localhost,ID,ID,QUERY,sa_db,'uninstall plugin server_audit',0\n", "--source include/have_plugin_auth.inc\n--source include/not_embedded.inc\n\nif (!$SERVER_AUDIT_SO) {\n  skip No SERVER_AUDIT plugin;\n}\n\n# An unfortunate wait for check-testcase.test to complete disconnect.\nlet count_sessions= 1;\nsource include/wait_until_count_sessions.inc;\n\nlet $MYSQLD_DATADIR= `SELECT @@datadir`;\nlet SEARCH_FILE= $MYSQLD_DATADIR/server_audit.log;\n\ninstall plugin server_audit soname 'server_audit';\n\nshow variables like 'server_audit%';\nset global server_audit_file_path=null;\nset global server_audit_incl_users=null;\nset global server_audit_file_path='server_audit.log';\nset global server_audit_output_type=file;\nset global server_audit_logging=on;\n\n--error ER_WRONG_VALUE_FOR_VAR\nset global server_audit_incl_users= repeat(\"'root',\", 10000);\nshow variables like 'server_audit_incl_users';\n--error ER_WRONG_VALUE_FOR_VAR\nset global server_audit_excl_users= repeat(\"'root',\", 10000);\nshow variables like 'server_audit_excl_users';\nlet SEARCH_COUNT= 5;\nsource include/wait_for_line_count_in_file.inc;\n\nconnect (con1,localhost,root,,mysql);\ndisconnect con1;\nlet SEARCH_COUNT= 7;\nsource include/wait_for_line_count_in_file.inc;\n\n--replace_result $MASTER_MYSOCK MASTER_SOCKET $MASTER_MYPORT MASTER_PORT\n--error ER_ACCESS_DENIED_ERROR\nconnect (con1,localhost,no_such_user,,mysql);\nlet SEARCH_COUNT= 9;\nsource include/wait_for_line_count_in_file.inc;\n\nconnection default;\nset global server_audit_incl_users='odin, dva, tri';\ncreate table t1 (id int);\nset global server_audit_incl_users='odin, root, dva, tri';\ncreate table t2 (id int);\nset global server_audit_excl_users='odin, dva, tri';\ninsert into t1 values (1), (2);\nselect * from t1;\nset global server_audit_incl_users='odin, root, dva, tri';\ninsert into t2 values (1), (2);\nselect * from t2;\nalter table t1 rename renamed_t1;\nset global server_audit_events='connect,query';\nselect 1,\n        2,\n# comment\n        3;\ninsert into t2 values (1), (2);\nselect * from t2;\n--disable_ps_protocol\n--error ER_NO_SUCH_TABLE\nselect * from t_doesnt_exist;\n--enable_ps_protocol\n--error 1064\nsyntax_error_query;\ndrop table renamed_t1, t2;\nshow variables like 'server_audit%';\nset global server_audit_mode=1;\nset global server_audit_events='';\ncreate database sa_db;\nlet SEARCH_COUNT= 41;\nsource include/wait_for_line_count_in_file.inc;\n\nconnect (con1,localhost,root,,test);\ncreate table t1 (id2 int);\ninsert into t1 values (1), (2);\nselect * from t1;\ndrop table t1;\nuse sa_db;\ncreate table sa_t1(id int);\ninsert into sa_t1 values (1), (2);\ndrop table sa_t1;\ndrop database sa_db;\ndisconnect con1;\nlet SEARCH_COUNT= 68;\nsource include/wait_for_line_count_in_file.inc;\n\nconnection default;\ncreate database sa_db;\nuse sa_db;\nCREATE USER u1 IDENTIFIED BY 'pwd-123';\nGRANT ALL ON sa_db TO u2 IDENTIFIED BY \"pwd-321\";\nSET PASSWORD FOR u1 = PASSWORD('pwd 098');\nCREATE USER u3 IDENTIFIED BY '';\nALTER USER u3 IDENTIFIED BY 'pwd-456';\ndrop user u1, u2, u3;\n\nset global server_audit_events='query_ddl';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nselect 2;\n(select 2);\n/*! select 2*/;\n/*comment*/ select 2;\ndrop table t1;\ncreate procedure pr1() insert into test.t1 values (\"foo\", 42);\ncreate function fn1(i int) returns int deterministic return i+1;\ndrop procedure pr1;\ndrop function fn1;\n\nset global server_audit_events='query_ddl,query_dml';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nselect 2;\ndrop table t1;\nset global server_audit_events='query_dml';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nselect 2;\n(select 2);\n/*! select 2*/;\n/*comment*/ select 2;\ndrop table t1;\nset global server_audit_events='query_dcl';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nCREATE USER u1 IDENTIFIED BY 'pwd-123';\nGRANT ALL ON sa_db TO u2 IDENTIFIED BY \"pwd-321\";\nSET PASSWORD \n# comment\nFOR u1 = PASSWORD('pwd 098');\n--error 1064\nSET PASSWORD FOR u1=<secret>;\nCREATE USER u3 IDENTIFIED BY '';\ndrop user u1, u2, u3;\nselect 2;\n(select 2);\n/*! select 2*/;\n/*comment*/ select 2;\ndrop table t1;\nset global server_audit_events='query_dml_no_select';\ncreate table t1(id int);\ninsert into t1 values (1), (2);\nselect * from t1;\nselect 2;\ndrop table t1;\ncreate procedure pr1() insert into test.t1 values (\"foo\", 42);\ncreate function fn1(i int) returns int deterministic return i+1;\ndrop procedure pr1;\ndrop function fn1;\n\nset global server_audit_events='table';\nset global server_audit_incl_users='user1';\n\ncreate user user1@localhost;\ngrant all on sa_db.* to user1@localhost;\n\nconnect (cn1,localhost,user1,,sa_db);\nconnection cn1;\n\ncreate table t1(id int) engine=myisam;\ninsert delayed into t1 values (1);\nconnection default;\n--echo # Waiting until INSERT DELAYED thread does the insert.\nlet $wait_condition= SELECT COUNT(*) = 1 FROM t1;\n--source include/wait_condition.inc\ndrop table t1;\n\nset global server_audit_logging= off;\nset global server_audit_incl_users='root';\nset global server_audit_logging= on;\ndisconnect cn1;\nlet $count_sessions=1;\nsource include/wait_until_count_sessions.inc;\n\ndrop user user1@localhost;\n\nset global server_audit_events='';\nset global server_audit_incl_users='root, plug_dest';\n\nCREATE USER plug IDENTIFIED WITH 'test_plugin_server' AS 'plug_dest';\nCREATE USER plug_dest IDENTIFIED BY 'plug_dest_passwd';\n--sleep 2\n--replace_result $MASTER_MYPORT MYSQL_PORT $MASTER_MYSOCK MYSQL_SOCK\n--error ER_ACCESS_DENIED_ERROR : this should fail : no grant\nconnect(plug_con,localhost,plug,plug_dest);\n--sleep 2\nGRANT PROXY ON plug_dest TO plug;\n--sleep 2\nconnect(plug_con,localhost,plug,plug_dest);\nconnection plug_con;\nselect USER(),CURRENT_USER();\nconnection default;\ndisconnect plug_con;\n--sleep 2\n--sleep 2\nDROP USER plug;\nDROP USER plug_dest;\n\nset global server_audit_query_log_limit= 15;\nselect (1), (2), (3), (4);\nselect 'A', 'B', 'C', 'D';\nset global server_audit_query_log_limit= 1024;\ndrop database sa_db;\n\nselect length('01234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789');\n\nset global server_audit_file_path='.';\n--replace_regex /\\.[\\\\\\/]/HOME_DIR\\//\nshow status like 'server_audit_current_log';\nset global server_audit_file_path='';\nshow status like 'server_audit_current_log';\nset global server_audit_file_path='  ';\nshow status like 'server_audit_current_log';\nset global server_audit_file_path='nonexisting_dir/';\nshow status like 'server_audit_current_log';\nshow variables like 'server_audit%';\nuninstall plugin server_audit;\n\n# replace the timestamp and the hostname with constant values\n--replace_regex /[0-9]* [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\,[^,]*\\,/TIME,HOSTNAME,/ /\\,[1-9][0-9]*\\,/,1,/ /\\,[1-9][0-9]*/,ID/\ncat_file $MYSQLD_DATADIR/server_audit.log;\nremove_file $MYSQLD_DATADIR/server_audit.log;\n\n", "/* Copyright (C) 2013, 2015, Alexey Botchkov and SkySQL Ab\n\n   This program is free software; you can redistribute it and/or modify\n   it under the terms of the GNU General Public License as published by\n   the Free Software Foundation; version 2 of the License.\n\n   This program is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License\n   along with this program; if not, write to the Free Software\n   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1335 USA */\n\n\n#define PLUGIN_VERSION 0x104\n#define PLUGIN_STR_VERSION \"1.4.12\"\n\n#define _my_thread_var loc_thread_var\n\n#include <my_config.h>\n#include <stdio.h>\n#include <time.h>\n#include <string.h>\n#include <fcntl.h>\n#include <assert.h>\n\n#ifndef _WIN32\n#define DO_SYSLOG\n#include <syslog.h>\nstatic const char out_type_desc[]= \"Desired output type. Possible values - 'syslog', 'file'\"\n                                   \" or 'null' as no output.\";\n#else\nstatic const char out_type_desc[]= \"Desired output type. Possible values - 'file'\"\n                                   \" or 'null' as no output.\";\n#define syslog(PRIORITY, FORMAT, INFO, MESSAGE_LEN, MESSAGE) do {}while(0)\nstatic void closelog() {}\n#define openlog(IDENT, LOG_NOWAIT, LOG_USER)  do {}while(0)\n\n/* priorities */\n#define LOG_EMERG       0       /* system is unusable */\n#define LOG_ALERT       1       /* action must be taken immediately */\n#define LOG_CRIT        2       /* critical conditions */\n#define LOG_ERR         3       /* error conditions */\n#define LOG_WARNING     4       /* warning conditions */\n#define LOG_NOTICE      5       /* normal but significant condition */\n#define LOG_INFO        6       /* informational */\n#define LOG_DEBUG       7       /* debug-level messages */\n\n#define LOG_MAKEPRI(fac, pri)   (((fac) << 3) | (pri))\n\n/* facility codes */\n#define LOG_KERN        (0<<3)  /* kernel messages */\n#define LOG_USER        (1<<3)  /* random user-level messages */\n#define LOG_MAIL        (2<<3)  /* mail system */\n#define LOG_DAEMON      (3<<3)  /* system daemons */\n#define LOG_AUTH        (4<<3)  /* security/authorization messages */\n#define LOG_SYSLOG      (5<<3)  /* messages generated internally by syslogd */\n#define LOG_LPR         (6<<3)  /* line printer subsystem */\n#define LOG_NEWS        (7<<3)  /* network news subsystem */\n#define LOG_UUCP        (8<<3)  /* UUCP subsystem */\n#define LOG_CRON        (9<<3)  /* clock daemon */\n#define LOG_AUTHPRIV    (10<<3) /* security/authorization messages (private) */\n#define LOG_FTP         (11<<3) /* ftp daemon */\n#define LOG_LOCAL0      (16<<3) /* reserved for local use */\n#define LOG_LOCAL1      (17<<3) /* reserved for local use */\n#define LOG_LOCAL2      (18<<3) /* reserved for local use */\n#define LOG_LOCAL3      (19<<3) /* reserved for local use */\n#define LOG_LOCAL4      (20<<3) /* reserved for local use */\n#define LOG_LOCAL5      (21<<3) /* reserved for local use */\n#define LOG_LOCAL6      (22<<3) /* reserved for local use */\n#define LOG_LOCAL7      (23<<3) /* reserved for local use */\n\n#endif /*!_WIN32*/\n\n/*\n   Defines that can be used to reshape the pluging:\n   #define MARIADB_ONLY\n   #define USE_MARIA_PLUGIN_INTERFACE\n*/\n\n#if !defined(MYSQL_DYNAMIC_PLUGIN) && !defined(MARIADB_ONLY)\n#define MARIADB_ONLY\n#endif /*MYSQL_PLUGIN_DYNAMIC*/\n\n#ifndef MARIADB_ONLY\n#define MYSQL_SERVICE_LOGGER_INCLUDED\n#endif /*MARIADB_ONLY*/\n\n#include <my_base.h>\n//#include <my_dir.h>\n#include <typelib.h>\n#include <mysql/plugin.h>\n#include <mysql/plugin_audit.h>\n#include \"../../mysys/mysys_priv.h\"\n#ifndef RTLD_DEFAULT\n#define RTLD_DEFAULT NULL\n#endif\n\n#ifndef MARIADB_ONLY\n#undef MYSQL_SERVICE_LOGGER_INCLUDED\n#undef MYSQL_DYNAMIC_PLUGIN\n#define FLOGGER_NO_PSI\n\n/* How to access the pthread_mutex in mysql_mutex_t */\n#ifdef SAFE_MUTEX\n#define mysql_mutex_real_mutex(A) &(A)->m_mutex.mutex\n#else\n#define mysql_mutex_real_mutex(A) &(A)->m_mutex\n#endif\n\n#define flogger_mutex_init(A,B,C) do{}while(0)\n#define flogger_mutex_destroy(A) do{}while(0)\n#define flogger_mutex_lock(A) do{}while(0)\n#define flogger_mutex_unlock(A) do{}while(0)\n\nstatic char **int_mysql_data_home;\nstatic char *default_home= (char *)\".\";\n#define mysql_data_home (*int_mysql_data_home)\n\n#define FLOGGER_SKIP_INCLUDES\n#define my_open(A, B, C) loc_open(A, B)\n#define my_close(A, B) loc_close(A)\n#define my_rename(A, B, C) loc_rename(A, B)\n#define my_tell(A, B) loc_tell(A)\n#define my_write(A, B, C, D) loc_write(A, B, C)\n#define my_malloc(A, B) malloc(A)\n#define my_free(A) free(A)\n#ifdef my_errno\n  #undef my_errno\n#endif\nstatic int loc_file_errno;\n#define my_errno loc_file_errno\n#ifdef my_vsnprintf\n  #undef my_vsnprintf\n#endif\n#define my_vsnprintf vsnprintf\n#define logger_open loc_logger_open\n#define logger_close loc_logger_close\n#define logger_write loc_logger_write\n#define logger_rotate loc_logger_rotate\n#define logger_init_mutexts loc_logger_init_mutexts\n\n\nstatic size_t loc_write(File Filedes, const uchar *Buffer, size_t Count)\n{\n  size_t writtenbytes;\n#ifdef _WIN32\n  writtenbytes= (size_t)_write(Filedes, Buffer, (unsigned int)Count);\n#else\n  writtenbytes= write(Filedes, Buffer, Count);\n#endif\n  return writtenbytes;\n}\n\n\nstatic File loc_open(const char *FileName, int Flags)\n\t\t\t\t/* Path-name of file */\n\t\t\t\t/* Read | write .. */\n\t\t\t\t/* Special flags */\n{\n  File fd;\n#ifdef _WIN32\n  HANDLE h;\n  /*\n    We could just use _open() here. but prefer to open in unix-similar way\n    just like my_open() does it on Windows.\n    This gives atomic multiprocess-safe appends, and possibility to rename\n    or even delete file while it is open, and CRT lacks this features.\n  */\n  assert(Flags == (O_APPEND | O_CREAT | O_WRONLY));\n  h= CreateFile(FileName, FILE_APPEND_DATA,\n    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE, NULL,\n    OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);\n  if (h == INVALID_HANDLE_VALUE)\n  {\n    fd= -1;\n    my_osmaperr(GetLastError());\n  }\n  else\n  {\n    fd= _open_osfhandle((intptr)h, O_WRONLY|O_BINARY);\n  }\n#else\n  fd= open(FileName, Flags, my_umask);\n#endif\n  my_errno= errno;\n  return fd;\n} \n\n\nstatic int loc_close(File fd)\n{\n  int err;\n#ifndef _WIN32\n  do\n  {\n    err= close(fd);\n  } while (err == -1 && errno == EINTR);\n#else\n  err= close(fd);\n#endif\n  my_errno=errno;\n  return err;\n}\n\n\nstatic int loc_rename(const char *from, const char *to)\n{\n  int error = 0;\n\n#if defined(__WIN__)\n  if (!MoveFileEx(from, to, MOVEFILE_COPY_ALLOWED |\n                            MOVEFILE_REPLACE_EXISTING))\n  {\n    my_osmaperr(GetLastError());\n#elif defined(HAVE_RENAME)\n  if (rename(from,to))\n  {\n#else\n  if (link(from, to) || unlink(from))\n  {\n#endif\n    my_errno=errno;\n    error = -1;\n  }\n  return error;\n}\n\n\nstatic my_off_t loc_tell(File fd)\n{\n  os_off_t pos= IF_WIN(_telli64(fd),lseek(fd, 0, SEEK_CUR));\n  if (pos == (os_off_t) -1)\n  {\n    my_errno= errno;\n  }\n  return (my_off_t) pos;\n}\n\n#ifdef HAVE_PSI_INTERFACE\n#undef HAVE_PSI_INTERFACE\n#include <mysql/service_logger.h>\n#include \"../../mysys/file_logger.c\"\n#define HAVE_PSI_INTERFACE\n#else\n#include <mysql/service_logger.h>\n#include \"../../mysys/file_logger.c\"\n#endif\n#endif /*!MARIADB_ONLY*/\n\n#undef flogger_mutex_init\n#undef flogger_mutex_destroy\n#undef flogger_mutex_lock\n#undef flogger_mutex_unlock\n\n#define flogger_mutex_init(A,B,C) pthread_mutex_init(mysql_mutex_real_mutex(B), C)\n#define flogger_mutex_destroy(A) pthread_mutex_destroy(mysql_mutex_real_mutex(A))\n#define flogger_mutex_lock(A) pthread_mutex_lock(mysql_mutex_real_mutex(A))\n#define flogger_mutex_unlock(A) pthread_mutex_unlock(mysql_mutex_real_mutex(A))\n\n#ifndef DBUG_OFF\n#define PLUGIN_DEBUG_VERSION \"-debug\"\n#else\n#define PLUGIN_DEBUG_VERSION \"\"\n#endif /*DBUG_OFF*/\n/*\n Disable __attribute__() on non-gcc compilers.\n*/\n#if !defined(__attribute__) && !defined(__GNUC__)\n#define __attribute__(A)\n#endif\n\n#ifdef _WIN32\n#define localtime_r(a, b) localtime_s(b, a)\n#endif /*WIN32*/\n\n\nextern char server_version[];\nstatic const char *serv_ver= NULL;\nstatic int started_mysql= 0;\nstatic int mysql_57_started= 0;\nstatic int debug_server_started= 0;\nstatic int use_event_data_for_disconnect= 0;\nstatic int started_mariadb= 0;\nstatic int maria_55_started= 0;\nstatic int maria_above_5= 0;\nstatic char *incl_users, *excl_users,\n            *file_path, *syslog_info;\nstatic char path_buffer[FN_REFLEN];\nstatic unsigned int mode, mode_readonly= 0;\nstatic ulong output_type;\nstatic ulong syslog_facility, syslog_priority;\n\nstatic ulonglong events; /* mask for events to log */\nstatic unsigned long long file_rotate_size;\nstatic unsigned int rotations;\nstatic my_bool rotate= TRUE;\nstatic char logging;\nstatic volatile int internal_stop_logging= 0;\nstatic char incl_user_buffer[1024];\nstatic char excl_user_buffer[1024];\nstatic unsigned int query_log_limit= 0;\n\nstatic char servhost[256];\nstatic uint servhost_len;\nstatic char *syslog_ident;\nstatic char syslog_ident_buffer[128]= \"mysql-server_auditing\";\n\nstruct connection_info\n{\n  int header;\n  unsigned long thread_id;\n  unsigned long long query_id;\n  char db[256];\n  int db_length;\n  char user[64];\n  int user_length;\n  char host[64];\n  int host_length;\n  char ip[64];\n  int ip_length;\n  const char *query;\n  int query_length;\n  char query_buffer[1024];\n  time_t query_time;\n  int log_always;\n  char proxy[64];\n  int proxy_length;\n  char proxy_host[64];\n  int proxy_host_length;\n};\n\n#define DEFAULT_FILENAME_LEN 16\nstatic char default_file_name[DEFAULT_FILENAME_LEN+1]= \"server_audit.log\";\n\nstatic void update_file_path(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                             void *var_ptr, const void *save);\nstatic void update_file_rotate_size(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                    void *var_ptr, const void *save);\nstatic void update_file_rotations(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                  void *var_ptr, const void *save);\nstatic void update_incl_users(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                              void *var_ptr, const void *save);\nstatic int check_incl_users(MYSQL_THD thd, struct st_mysql_sys_var *var, void *save,\n                            struct st_mysql_value *value);\nstatic int check_excl_users(MYSQL_THD thd, struct st_mysql_sys_var *var, void *save,\n                            struct st_mysql_value *value);\nstatic void update_excl_users(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                              void *var_ptr, const void *save);\nstatic void update_output_type(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                               void *var_ptr, const void *save);\nstatic void update_syslog_facility(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                   void *var_ptr, const void *save);\nstatic void update_syslog_priority(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                   void *var_ptr, const void *save);\nstatic void update_mode(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                        void *var_ptr, const void *save);\nstatic void update_logging(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                           void *var_ptr, const void *save);\nstatic void update_syslog_ident(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                                void *var_ptr, const void *save);\nstatic void rotate_log(MYSQL_THD thd, struct st_mysql_sys_var *var,\n                       void *var_ptr, const void *save);\n\nstatic MYSQL_SYSVAR_STR(incl_users, incl_users, PLUGIN_VAR_RQCMDARG,\n       \"Comma separated list of users to monitor.\",\n       check_incl_users, update_incl_users, NULL);\nstatic MYSQL_SYSVAR_STR(excl_users, excl_users, PLUGIN_VAR_RQCMDARG,\n       \"Comma separated list of users to exclude from auditing.\",\n       check_excl_users, update_excl_users, NULL);\n/* bits in the event filter. */\n#define EVENT_CONNECT 1\n#define EVENT_QUERY_ALL 2\n#define EVENT_QUERY 122\n#define EVENT_TABLE 4\n#define EVENT_QUERY_DDL 8\n#define EVENT_QUERY_DML 16\n#define EVENT_QUERY_DCL 32\n#define EVENT_QUERY_DML_NO_SELECT 64\n\nstatic const char *event_names[]=\n{\n  \"CONNECT\", \"QUERY\", \"TABLE\", \"QUERY_DDL\", \"QUERY_DML\", \"QUERY_DCL\",\n  \"QUERY_DML_NO_SELECT\", NULL\n};\nstatic TYPELIB events_typelib=\n{\n  array_elements(event_names) - 1, \"\", event_names, NULL\n};\nstatic MYSQL_SYSVAR_SET(events, events, PLUGIN_VAR_RQCMDARG,\n       \"Specifies the set of events to monitor. Can be CONNECT, QUERY, TABLE,\"\n           \" QUERY_DDL, QUERY_DML, QUERY_DML_NO_SELECT, QUERY_DCL.\",\n       NULL, NULL, 0, &events_typelib);\n#ifdef DO_SYSLOG\n#define OUTPUT_SYSLOG 0\n#define OUTPUT_FILE 1\n#else\n#define OUTPUT_SYSLOG 0xFFFF\n#define OUTPUT_FILE 0\n#endif /*DO_SYSLOG*/\n\n#define OUTPUT_NO 0xFFFF\nstatic const char *output_type_names[]= {\n#ifdef DO_SYSLOG\n  \"syslog\",\n#endif\n  \"file\", 0 };\nstatic TYPELIB output_typelib=\n{\n    array_elements(output_type_names) - 1, \"output_typelib\",\n    output_type_names, NULL\n};\nstatic MYSQL_SYSVAR_ENUM(output_type, output_type, PLUGIN_VAR_RQCMDARG,\n       out_type_desc,\n       0, update_output_type, OUTPUT_FILE,\n       &output_typelib);\nstatic MYSQL_SYSVAR_STR(file_path, file_path, PLUGIN_VAR_RQCMDARG,\n       \"Path to the log file.\", NULL, update_file_path, default_file_name);\nstatic MYSQL_SYSVAR_ULONGLONG(file_rotate_size, file_rotate_size,\n       PLUGIN_VAR_RQCMDARG, \"Maximum size of the log to start the rotation.\",\n       NULL, update_file_rotate_size,\n       1000000, 100, ((long long) 0x7FFFFFFFFFFFFFFFLL), 1);\nstatic MYSQL_SYSVAR_UINT(file_rotations, rotations,\n       PLUGIN_VAR_RQCMDARG, \"Number of rotations before log is removed.\",\n       NULL, update_file_rotations, 9, 0, 999, 1);\nstatic MYSQL_SYSVAR_BOOL(file_rotate_now, rotate, PLUGIN_VAR_OPCMDARG,\n       \"Force log rotation now.\", NULL, rotate_log, FALSE);\nstatic MYSQL_SYSVAR_BOOL(logging, logging,\n       PLUGIN_VAR_OPCMDARG, \"Turn on/off the logging.\", NULL,\n       update_logging, 0);\nstatic MYSQL_SYSVAR_UINT(mode, mode,\n       PLUGIN_VAR_OPCMDARG, \"Auditing mode.\", NULL, update_mode, 0, 0, 1, 1);\nstatic MYSQL_SYSVAR_STR(syslog_ident, syslog_ident, PLUGIN_VAR_RQCMDARG,\n       \"The SYSLOG identifier - the beginning of each SYSLOG record.\",\n       NULL, update_syslog_ident, syslog_ident_buffer);\nstatic MYSQL_SYSVAR_STR(syslog_info, syslog_info,\n       PLUGIN_VAR_RQCMDARG | PLUGIN_VAR_MEMALLOC,\n       \"The <info> string to be added to the SYSLOG record.\", NULL, NULL, \"\");\nstatic MYSQL_SYSVAR_UINT(query_log_limit, query_log_limit,\n       PLUGIN_VAR_OPCMDARG, \"Limit on the length of the query string in a record.\",\n       NULL, NULL, 1024, 0, 0x7FFFFFFF, 1);\n\nchar locinfo_ini_value[sizeof(struct connection_info)+4];\n\nstatic MYSQL_THDVAR_STR(loc_info,\n                        PLUGIN_VAR_NOSYSVAR | PLUGIN_VAR_NOCMDOPT | PLUGIN_VAR_MEMALLOC,\n                        \"Internal info\", NULL, NULL, locinfo_ini_value);\n\nstatic const char *syslog_facility_names[]=\n{\n  \"LOG_USER\", \"LOG_MAIL\", \"LOG_DAEMON\", \"LOG_AUTH\",\n  \"LOG_SYSLOG\", \"LOG_LPR\", \"LOG_NEWS\", \"LOG_UUCP\",\n  \"LOG_CRON\",\n#ifdef LOG_AUTHPRIV\n \"LOG_AUTHPRIV\",\n#endif\n#ifdef LOG_FTP\n \"LOG_FTP\",\n#endif\n  \"LOG_LOCAL0\", \"LOG_LOCAL1\", \"LOG_LOCAL2\", \"LOG_LOCAL3\",\n  \"LOG_LOCAL4\", \"LOG_LOCAL5\", \"LOG_LOCAL6\", \"LOG_LOCAL7\",\n  0\n};\nstatic unsigned int syslog_facility_codes[]=\n{\n  LOG_USER, LOG_MAIL, LOG_DAEMON, LOG_AUTH,\n  LOG_SYSLOG, LOG_LPR, LOG_NEWS, LOG_UUCP,\n  LOG_CRON,\n#ifdef LOG_AUTHPRIV\n LOG_AUTHPRIV,\n#endif\n#ifdef LOG_FTP\n  LOG_FTP,\n#endif\n  LOG_LOCAL0, LOG_LOCAL1, LOG_LOCAL2, LOG_LOCAL3,\n  LOG_LOCAL4, LOG_LOCAL5, LOG_LOCAL6, LOG_LOCAL7,\n};\nstatic TYPELIB syslog_facility_typelib=\n{\n    array_elements(syslog_facility_names) - 1, \"syslog_facility_typelib\",\n    syslog_facility_names, NULL\n};\nstatic MYSQL_SYSVAR_ENUM(syslog_facility, syslog_facility, PLUGIN_VAR_RQCMDARG,\n       \"The 'facility' parameter of the SYSLOG record.\"\n       \" The default is LOG_USER.\", 0, update_syslog_facility, 0/*LOG_USER*/,\n       &syslog_facility_typelib);\n\nstatic const char *syslog_priority_names[]=\n{\n  \"LOG_EMERG\", \"LOG_ALERT\", \"LOG_CRIT\", \"LOG_ERR\",\n  \"LOG_WARNING\", \"LOG_NOTICE\", \"LOG_INFO\", \"LOG_DEBUG\",\n  0\n};\n\nstatic unsigned int syslog_priority_codes[]=\n{\n  LOG_EMERG, LOG_ALERT, LOG_CRIT, LOG_ERR,\n  LOG_WARNING, LOG_NOTICE, LOG_INFO, LOG_DEBUG,\n};\n\nstatic TYPELIB syslog_priority_typelib=\n{\n    array_elements(syslog_priority_names) - 1, \"syslog_priority_typelib\",\n    syslog_priority_names, NULL\n};\nstatic MYSQL_SYSVAR_ENUM(syslog_priority, syslog_priority, PLUGIN_VAR_RQCMDARG,\n       \"The 'priority' parameter of the SYSLOG record.\"\n       \" The default is LOG_INFO.\", 0, update_syslog_priority, 6/*LOG_INFO*/,\n       &syslog_priority_typelib);\n\n\nstatic struct st_mysql_sys_var* vars[] = {\n    MYSQL_SYSVAR(incl_users),\n    MYSQL_SYSVAR(excl_users),\n    MYSQL_SYSVAR(events),\n    MYSQL_SYSVAR(output_type),\n    MYSQL_SYSVAR(file_path),\n    MYSQL_SYSVAR(file_rotate_size),\n    MYSQL_SYSVAR(file_rotations),\n    MYSQL_SYSVAR(file_rotate_now),\n    MYSQL_SYSVAR(logging),\n    MYSQL_SYSVAR(mode),\n    MYSQL_SYSVAR(syslog_info),\n    MYSQL_SYSVAR(syslog_ident),\n    MYSQL_SYSVAR(syslog_facility),\n    MYSQL_SYSVAR(syslog_priority),\n    MYSQL_SYSVAR(query_log_limit),\n    MYSQL_SYSVAR(loc_info),\n    NULL\n};\n\n\n/* Status variables for SHOW STATUS */\nstatic int is_active= 0;\nstatic long log_write_failures= 0;\nstatic char current_log_buf[FN_REFLEN]= \"\";\nstatic char last_error_buf[512]= \"\";\n\nextern void *mysql_v4_descriptor;\n\nstatic struct st_mysql_show_var audit_status[]=\n{\n  {\"server_audit_active\", (char *)&is_active, SHOW_BOOL},\n  {\"server_audit_current_log\", current_log_buf, SHOW_CHAR},\n  {\"server_audit_writes_failed\", (char *)&log_write_failures, SHOW_LONG},\n  {\"server_audit_last_error\", last_error_buf, SHOW_CHAR},\n  {0,0,0}\n};\n\n#if defined(HAVE_PSI_INTERFACE) && !defined(FLOGGER_NO_PSI)\n/* These belong to the service initialization */\nstatic PSI_mutex_key key_LOCK_operations;\nstatic PSI_mutex_key key_LOCK_atomic;\nstatic PSI_mutex_info mutex_key_list[]=\n{\n  { &key_LOCK_operations, \"SERVER_AUDIT_plugin::lock_operations\",\n    PSI_FLAG_GLOBAL},\n  { &key_LOCK_atomic, \"SERVER_AUDIT_plugin::lock_atomic\",\n    PSI_FLAG_GLOBAL},\n};\n#endif\nstatic mysql_mutex_t lock_operations;\nstatic mysql_mutex_t lock_atomic;\n\n/* The Percona server and partly MySQL don't support         */\n/* launching client errors in the 'update_variable' methods. */\n/* So the client errors just disabled for them.              */\n/* The possible solution is to implement the 'check_variable'*/\n/* methods there properly, but at the moment i'm not sure it */\n/* worths doing.                                             */\n#define CLIENT_ERROR if (!started_mysql) my_printf_error\n\n#define ADD_ATOMIC(x, a)              \\\n  do {                                \\\n  flogger_mutex_lock(&lock_atomic);   \\\n  x+= a;                              \\\n  flogger_mutex_unlock(&lock_atomic); \\\n  } while (0)\n\n\nstatic uchar *getkey_user(const char *entry, size_t *length,\n                          my_bool nu __attribute__((unused)) )\n{\n  const char *e= entry;\n  while (*e && *e != ' ' && *e != ',')\n    ++e;\n  *length= e - entry;\n  return (uchar *) entry;\n}\n\n\nstatic void blank_user(char *user)\n{\n  for (; *user && *user != ','; user++)\n    *user= ' ';\n}\n\n\nstatic void remove_user(char *user)\n{\n  char *start_user= user;\n  while (*user != ',')\n  {\n    if (*user == 0)\n    {\n      *start_user= 0;\n      return;\n    }\n    user++;\n  }\n  user++;\n  while (*user == ' ')\n    user++;\n\n  do {\n    *(start_user++)= *user;\n  } while (*(user++));\n}\n\n\nstatic void remove_blanks(char *user)\n{\n  char *user_orig= user;\n  char *user_to= user;\n  char *start_tok;\n  int blank_name;\n\n  while (*user != 0)\n  {\n    start_tok= user;\n    blank_name= 1;\n    while (*user !=0 && *user != ',')\n    {\n      if (*user != ' ')\n        blank_name= 0;\n      user++;\n    }\n    if (!blank_name)\n    {\n      while (start_tok <= user)\n        *(user_to++)= *(start_tok++);\n    }\n    if (*user == ',')\n      user++;\n  }\n  if (user_to > user_orig && user_to[-1] == ',')\n    user_to--;\n  *user_to= 0;\n}\n\n\nstruct user_name\n{\n  size_t name_len;\n  char *name;\n};\n\n\nstruct user_coll\n{\n  int n_users;\n  struct user_name *users;\n  int n_alloced;\n};\n\n\nstatic void coll_init(struct user_coll *c)\n{\n  c->n_users= 0;\n  c->users= 0;\n  c->n_alloced= 0;\n}\n\n\nstatic void coll_free(struct user_coll *c)\n{\n  if (c->users)\n  {\n    free(c->users);\n    coll_init(c);\n  }\n}\n\n\nstatic int cmp_users(const void *ia, const void *ib)\n{\n  const struct user_name *a= (const struct user_name *) ia;\n  const struct user_name *b= (const struct user_name *) ib;\n  int dl= (int)(a->name_len - b->name_len);\n  if (dl != 0)\n    return dl;\n\n  return strncmp(a->name, b->name, a->name_len);\n}\n\n\nstatic char *coll_search(struct user_coll *c, const char *n, size_t len)\n{\n  struct user_name un;\n  struct user_name *found;\n  if (!c->n_users)\n    return 0;\n  un.name_len= len;\n  un.name= (char *) n;\n  found= (struct user_name*)  bsearch(&un, c->users, c->n_users,\n                                      sizeof(c->users[0]), cmp_users);\n  return found ? found->name : 0;\n}\n\n\nstatic int coll_insert(struct user_coll *c, char *n, size_t len)\n{\n  if (c->n_users >= c->n_alloced)\n  {\n    c->n_alloced+= 128;\n    if (c->users == NULL)\n      c->users= malloc(c->n_alloced * sizeof(c->users[0]));\n    else\n      c->users= realloc(c->users, c->n_alloced * sizeof(c->users[0]));\n\n    if (c->users == NULL)\n      return 1;\n  }\n  c->users[c->n_users].name= n;\n  c->users[c->n_users].name_len= len;\n  c->n_users++;\n  return 0;\n}\n\n\nstatic void coll_sort(struct user_coll *c)\n{\n  if (c->n_users)\n    qsort(c->users, c->n_users, sizeof(c->users[0]), cmp_users);\n}\n\n\nstatic int user_coll_fill(struct user_coll *c, char *users,\n                          struct user_coll *cmp_c, int take_over_cmp)\n{\n  char *orig_users= users;\n  char *cmp_user= 0;\n  size_t cmp_length;\n  int refill_cmp_coll= 0;\n\n  c->n_users= 0;\n\n  while (*users)\n  {\n    while (*users == ' ')\n      users++;\n    if (!*users)\n      return 0;\n\n    (void) getkey_user(users, &cmp_length, FALSE);\n    if (cmp_c)\n    {\n      cmp_user= coll_search(cmp_c, users, cmp_length);\n\n      if (cmp_user && take_over_cmp)\n      {\n        ADD_ATOMIC(internal_stop_logging, 1);\n        CLIENT_ERROR(1, \"User '%.*b' was removed from the\"\n            \" server_audit_excl_users.\",\n            MYF(ME_JUST_WARNING), (int) cmp_length, users);\n        ADD_ATOMIC(internal_stop_logging, -1);\n        blank_user(cmp_user);\n        refill_cmp_coll= 1;\n      }\n      else if (cmp_user)\n      {\n        ADD_ATOMIC(internal_stop_logging, 1);\n        CLIENT_ERROR(1, \"User '%.*b' is in the server_audit_incl_users, \"\n            \"so wasn't added.\", MYF(ME_JUST_WARNING), (int) cmp_length, users);\n        ADD_ATOMIC(internal_stop_logging, -1);\n        remove_user(users);\n        continue;\n      }\n    }\n    if (coll_insert(c, users, cmp_length))\n      return 1;\n    while (*users && *users != ',')\n      users++;\n    if (!*users)\n      break;\n    users++;\n  }\n\n  if (refill_cmp_coll)\n  {\n    remove_blanks(excl_users);\n    return user_coll_fill(cmp_c, excl_users, 0, 0);\n  }\n\n  if (users > orig_users && users[-1] == ',')\n    users[-1]= 0;\n\n  coll_sort(c);\n\n  return 0;\n}\n\n\nenum sa_keywords\n{\n  SQLCOM_NOTHING=0,\n  SQLCOM_DDL,\n  SQLCOM_DML,\n  SQLCOM_GRANT,\n  SQLCOM_CREATE_USER,\n  SQLCOM_CHANGE_MASTER,\n  SQLCOM_CREATE_SERVER,\n  SQLCOM_SET_OPTION,\n  SQLCOM_ALTER_SERVER,\n  SQLCOM_TRUNCATE,\n  SQLCOM_QUERY_ADMIN,\n  SQLCOM_DCL,\n};\n\nstruct sa_keyword\n{\n  int length;\n  const char *wd;\n  struct sa_keyword *next;\n  enum sa_keywords type;\n};\n\n\nstruct sa_keyword xml_word=   {3, \"XML\", 0, SQLCOM_NOTHING};\nstruct sa_keyword user_word=   {4, \"USER\", 0, SQLCOM_NOTHING};\nstruct sa_keyword data_word=   {4, \"DATA\", 0, SQLCOM_NOTHING};\nstruct sa_keyword server_word= {6, \"SERVER\", 0, SQLCOM_NOTHING};\nstruct sa_keyword master_word= {6, \"MASTER\", 0, SQLCOM_NOTHING};\nstruct sa_keyword password_word= {8, \"PASSWORD\", 0, SQLCOM_NOTHING};\nstruct sa_keyword function_word= {8, \"FUNCTION\", 0, SQLCOM_NOTHING};\nstruct sa_keyword statement_word= {9, \"STATEMENT\", 0, SQLCOM_NOTHING};\nstruct sa_keyword procedure_word= {9, \"PROCEDURE\", 0, SQLCOM_NOTHING};\n\n\nstruct sa_keyword keywords_to_skip[]=\n{\n  {3, \"SET\", &statement_word, SQLCOM_QUERY_ADMIN},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword not_ddl_keywords[]=\n{\n  {4, \"DROP\", &user_word, SQLCOM_DCL},\n  {6, \"CREATE\", &user_word, SQLCOM_DCL},\n  {6, \"RENAME\", &user_word, SQLCOM_DCL},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword ddl_keywords[]=\n{\n  {4, \"DROP\", 0, SQLCOM_DDL},\n  {5, \"ALTER\", 0, SQLCOM_DDL},\n  {6, \"CREATE\", 0, SQLCOM_DDL},\n  {6, \"RENAME\", 0, SQLCOM_DDL},\n  {8, \"TRUNCATE\", 0, SQLCOM_DDL},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword dml_keywords[]=\n{\n  {2, \"DO\", 0, SQLCOM_DML},\n  {4, \"CALL\", 0, SQLCOM_DML},\n  {4, \"LOAD\", &data_word, SQLCOM_DML},\n  {4, \"LOAD\", &xml_word, SQLCOM_DML},\n  {6, \"DELETE\", 0, SQLCOM_DML},\n  {6, \"INSERT\", 0, SQLCOM_DML},\n  {6, \"SELECT\", 0, SQLCOM_DML},\n  {6, \"UPDATE\", 0, SQLCOM_DML},\n  {7, \"HANDLER\", 0, SQLCOM_DML},\n  {7, \"REPLACE\", 0, SQLCOM_DML},\n  {0, NULL, 0, SQLCOM_DML}\n};\n\n\nstruct sa_keyword dml_no_select_keywords[]=\n{\n  {2, \"DO\", 0, SQLCOM_DML},\n  {4, \"CALL\", 0, SQLCOM_DML},\n  {4, \"LOAD\", &data_word, SQLCOM_DML},\n  {4, \"LOAD\", &xml_word, SQLCOM_DML},\n  {6, \"DELETE\", 0, SQLCOM_DML},\n  {6, \"INSERT\", 0, SQLCOM_DML},\n  {6, \"UPDATE\", 0, SQLCOM_DML},\n  {7, \"HANDLER\", 0, SQLCOM_DML},\n  {7, \"REPLACE\", 0, SQLCOM_DML},\n  {0, NULL, 0, SQLCOM_DML}\n};\n\n\nstruct sa_keyword dcl_keywords[]=\n{\n  {6, \"CREATE\", &user_word, SQLCOM_DCL},\n  {4, \"DROP\", &user_word, SQLCOM_DCL},\n  {6, \"RENAME\", &user_word, SQLCOM_DCL},\n  {5, \"GRANT\", 0, SQLCOM_DCL},\n  {6, \"REVOKE\", 0, SQLCOM_DCL},\n  {3, \"SET\", &password_word, SQLCOM_DCL},\n  {0, NULL, 0, SQLCOM_DDL}\n};\n\n\nstruct sa_keyword passwd_keywords[]=\n{\n  {3, \"SET\", &password_word, SQLCOM_SET_OPTION},\n  {5, \"ALTER\", &server_word, SQLCOM_ALTER_SERVER},\n  {5, \"GRANT\", 0, SQLCOM_GRANT},\n  {6, \"CREATE\", &user_word, SQLCOM_CREATE_USER},\n  {6, \"CREATE\", &server_word, SQLCOM_CREATE_SERVER},\n  {6, \"CHANGE\", &master_word, SQLCOM_CHANGE_MASTER},\n  {0, NULL, 0, SQLCOM_NOTHING}\n};\n\n#define MAX_KEYWORD 9\n\n\nstatic void error_header()\n{\n  struct tm tm_time;\n  time_t curtime;\n\n  (void) time(&curtime);\n  (void) localtime_r(&curtime, &tm_time);\n\n  (void) fprintf(stderr,\"%02d%02d%02d %2d:%02d:%02d server_audit: \",\n    tm_time.tm_year % 100, tm_time.tm_mon + 1,\n    tm_time.tm_mday, tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);\n}\n\n\nstatic LOGGER_HANDLE *logfile;\nstatic struct user_coll incl_user_coll, excl_user_coll;\nstatic unsigned long long query_counter= 1;\n\n\nstatic struct connection_info *get_loc_info(MYSQL_THD thd)\n{\n  return (struct connection_info *) THDVAR(thd, loc_info);\n}\n\n\nstatic int ci_needs_setup(const struct connection_info *ci)\n{\n  return ci->header != 0;\n}\n\n\nstatic void get_str_n(char *dest, int *dest_len, size_t dest_size,\n                      const char *src, size_t src_len)\n{\n  if (src_len >= dest_size)\n    src_len= dest_size - 1;\n\n  if (src_len)\n    memcpy(dest, src, src_len);\n  dest[src_len]= 0;\n  *dest_len= (int)src_len;\n}\n\n\nstatic int get_user_host(const char *uh_line, unsigned int uh_len,\n                         char *buffer, size_t buf_len,\n                         size_t *user_len, size_t *host_len, size_t *ip_len)\n{\n  const char *buf_end= buffer + buf_len - 1;\n  const char *buf_start;\n  const char *uh_end= uh_line + uh_len;\n\n  while (uh_line < uh_end && *uh_line != '[')\n    ++uh_line;\n\n  if (uh_line == uh_end)\n    return 1;\n  ++uh_line;\n\n  buf_start= buffer;\n  while (uh_line < uh_end && *uh_line != ']')\n  {\n    if (buffer == buf_end)\n      return 1;\n    *(buffer++)= *(uh_line++);\n  }\n  if (uh_line == uh_end)\n    return 1;\n  *user_len= buffer - buf_start;\n  *(buffer++)= 0;\n\n  while (uh_line < uh_end && *uh_line != '@')\n    ++uh_line;\n  if (uh_line == uh_end || *(++uh_line) == 0)\n    return 1;\n  ++uh_line;\n\n  buf_start= buffer;\n  while (uh_line < uh_end && *uh_line != ' ' && *uh_line != '[')\n  {\n    if (buffer == buf_end)\n      break;\n    *(buffer++)= *(uh_line++);\n  }\n  *host_len= buffer - buf_start;\n  *(buffer++)= 0;\n\n  while (uh_line < uh_end && *uh_line != '[')\n    ++uh_line;\n\n  buf_start= buffer;\n  if (*uh_line == '[')\n  {\n    ++uh_line;\n    while (uh_line < uh_end && *uh_line != ']')\n      *(buffer++)= *(uh_line++);\n  }\n  *ip_len= buffer - buf_start;\n  return 0;\n}\n\n#if defined(__WIN__) && !defined(S_ISDIR)\n#define S_ISDIR(x) ((x) & _S_IFDIR)\n#endif /*__WIN__ && !S_ISDIR*/\n\nstatic int start_logging()\n{\n  last_error_buf[0]= 0;\n  log_write_failures= 0;\n  if (output_type == OUTPUT_FILE)\n  {\n    char alt_path_buffer[FN_REFLEN+1+DEFAULT_FILENAME_LEN];\n    struct stat *f_stat= (struct stat *)alt_path_buffer;\n    const char *alt_fname= file_path;\n\n    while (*alt_fname == ' ')\n      alt_fname++;\n\n    if (*alt_fname == 0)\n    {\n      /* Empty string means the default file name. */\n      alt_fname= default_file_name;\n    }\n    else\n    {\n      /* See if the directory exists with the name of file_path.    */\n      /* Log file name should be [file_path]/server_audit.log then. */\n      if (stat(file_path, (struct stat *)alt_path_buffer) == 0 &&\n          S_ISDIR(f_stat->st_mode))\n      {\n        size_t p_len= strlen(file_path);\n        memcpy(alt_path_buffer, file_path, p_len);\n        if (alt_path_buffer[p_len-1] != FN_LIBCHAR)\n        {\n          alt_path_buffer[p_len]= FN_LIBCHAR;\n          p_len++;\n        }\n        memcpy(alt_path_buffer+p_len, default_file_name, DEFAULT_FILENAME_LEN);\n        alt_path_buffer[p_len+DEFAULT_FILENAME_LEN]= 0;\n        alt_fname= alt_path_buffer;\n      }\n    }\n\n    logfile= logger_open(alt_fname, file_rotate_size, rotations);\n\n    if (logfile == NULL)\n    {\n      error_header();\n      fprintf(stderr, \"Could not create file '%s'.\\n\",\n              alt_fname);\n      logging= 0;\n      my_snprintf(last_error_buf, sizeof(last_error_buf),\n                  \"Could not create file '%s'.\", alt_fname);\n      is_active= 0;\n      CLIENT_ERROR(1, \"SERVER AUDIT plugin can't create file '%s'.\",\n          MYF(ME_JUST_WARNING), alt_fname);\n      return 1;\n    }\n    error_header();\n    fprintf(stderr, \"logging started to the file %s.\\n\", alt_fname);\n    strncpy(current_log_buf, alt_fname, sizeof(current_log_buf)-1);\n    current_log_buf[sizeof(current_log_buf)-1]= 0;\n  }\n  else if (output_type == OUTPUT_SYSLOG)\n  {\n    openlog(syslog_ident, LOG_NOWAIT, syslog_facility_codes[syslog_facility]);\n    error_header();\n    fprintf(stderr, \"logging started to the syslog.\\n\");\n    strncpy(current_log_buf, \"[SYSLOG]\", sizeof(current_log_buf)-1);\n    compile_time_assert(sizeof current_log_buf > sizeof \"[SYSLOG]\");\n  }\n  is_active= 1;\n  return 0;\n}\n\n\nstatic int stop_logging()\n{\n  last_error_buf[0]= 0;\n  if (output_type == OUTPUT_FILE && logfile)\n  {\n    logger_close(logfile);\n    logfile= NULL;\n  }\n  else if (output_type == OUTPUT_SYSLOG)\n  {\n    closelog();\n  }\n  error_header();\n  fprintf(stderr, \"logging was stopped.\\n\");\n  is_active= 0;\n  return 0;\n}\n\n\nstatic void setup_connection_simple(struct connection_info *ci)\n{\n  ci->db_length= 0;\n  ci->user_length= 0;\n  ci->host_length= 0;\n  ci->ip_length= 0;\n  ci->query_length= 0;\n  ci->header= 0;\n  ci->proxy_length= 0;\n}\n\n\n#define MAX_HOSTNAME 61\n#define USERNAME_LENGTH 384\n\nstatic void setup_connection_connect(struct connection_info *cn,\n    const struct mysql_event_connection *event)\n{\n  cn->query_id= 0;\n  cn->query_length= 0;\n  cn->log_always= 0;\n  cn->thread_id= event->thread_id;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n            event->database, event->database_length);\n  get_str_n(cn->user, &cn->user_length, sizeof(cn->db),\n            event->user, event->user_length);\n  get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n            event->host, event->host_length);\n  get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n            event->ip, event->ip_length);\n  cn->header= 0;\n  if (event->proxy_user && event->proxy_user[0])\n  {\n    const char *priv_host= event->proxy_user +\n            sizeof(char[MAX_HOSTNAME+USERNAME_LENGTH+5]);\n    size_t priv_host_length;\n\n    if (mysql_57_started)\n    {\n      priv_host+= sizeof(size_t);\n      priv_host_length= *(size_t *) (priv_host + MAX_HOSTNAME);\n    }\n    else\n      priv_host_length= strlen(priv_host);\n\n\n    get_str_n(cn->proxy, &cn->proxy_length, sizeof(cn->proxy),\n              event->priv_user, event->priv_user_length);\n    get_str_n(cn->proxy_host, &cn->proxy_host_length,\n              sizeof(cn->proxy_host),\n              priv_host, priv_host_length);\n  }\n  else\n    cn->proxy_length= 0;\n}\n\n\n#define SAFE_STRLEN(s) (s ? strlen(s) : 0)\n#define SAFE_STRLEN_UI(s) ((unsigned int) (s ? strlen(s) : 0))\nstatic char empty_str[1]= { 0 };\n\n\nstatic int is_space(char c)\n{\n  return c == ' ' || c == '\\r' || c == '\\n' || c == '\\t';\n}\n\n\n#define SKIP_SPACES(str) \\\ndo { \\\n  while (is_space(*str)) \\\n    ++str; \\\n} while(0)\n\n\n#define ESC_MAP_SIZE 0x60\nstatic const char esc_map[ESC_MAP_SIZE]=\n{\n  0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, '\\'', 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '\\\\', 0, 0, 0\n};\n\nstatic char escaped_char(char c)\n{\n  return ((unsigned char ) c) >= ESC_MAP_SIZE ? 0 : esc_map[(unsigned char) c];\n}\n\n\nstatic void setup_connection_initdb(struct connection_info *cn,\n    const struct mysql_event_general *event)\n{\n  size_t user_len, host_len, ip_len;\n  char uh_buffer[512];\n\n  cn->thread_id= event->general_thread_id;\n  cn->query_id= 0;\n  cn->query_length= 0;\n  cn->log_always= 0;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n            event->general_query, event->general_query_length);\n\n  if (get_user_host(event->general_user, event->general_user_length,\n                    uh_buffer, sizeof(uh_buffer),\n                    &user_len, &host_len, &ip_len))\n  {\n    /* The user@host line is incorrect. */\n    cn->user_length= 0;\n    cn->host_length= 0;\n    cn->ip_length= 0;\n  }\n  else\n  {\n    get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n              uh_buffer, user_len);\n    get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n              uh_buffer+user_len+1, host_len);\n    get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n              uh_buffer+user_len+1+host_len+1, ip_len);\n  }\n  cn->header= 0;\n}\n\n\nstatic void setup_connection_table(struct connection_info *cn,\n    const struct mysql_event_table *event)\n{\n  cn->thread_id= event->thread_id;\n  cn->query_id= query_counter++;\n  cn->log_always= 0;\n  cn->query_length= 0;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n            event->database, event->database_length);\n  get_str_n(cn->user, &cn->user_length, sizeof(cn->db),\n            event->user, SAFE_STRLEN(event->user));\n  get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n            event->host, SAFE_STRLEN(event->host));\n  get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n            event->ip, SAFE_STRLEN(event->ip));\n  cn->header= 0;\n}\n\n\nstatic void setup_connection_query(struct connection_info *cn,\n    const struct mysql_event_general *event)\n{\n  size_t user_len, host_len, ip_len;\n  char uh_buffer[512];\n\n  cn->thread_id= event->general_thread_id;\n  cn->query_id= query_counter++;\n  cn->log_always= 0;\n  cn->query_length= 0;\n  get_str_n(cn->db, &cn->db_length, sizeof(cn->db), \"\", 0);\n\n  if (get_user_host(event->general_user, event->general_user_length,\n                    uh_buffer, sizeof(uh_buffer),\n                    &user_len, &host_len, &ip_len))\n  {\n    /* The user@host line is incorrect. */\n    cn->user_length= 0;\n    cn->host_length= 0;\n    cn->ip_length= 0;\n  }\n  else\n  {\n    get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n              uh_buffer, user_len);\n    get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n              uh_buffer+user_len+1, host_len);\n    get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n              uh_buffer+user_len+1+host_len+1, ip_len);\n  }\n  cn->header= 0;\n}\n\n\nstatic void change_connection(struct connection_info *cn,\n    const struct mysql_event_connection *event)\n{\n  get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n            event->user, event->user_length);\n  get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n            event->ip, event->ip_length);\n}\n\nstatic int write_log(const char *message, size_t len, int take_lock)\n{\n  int result= 0;\n  if (take_lock)\n    flogger_mutex_lock(&lock_operations);\n\n  if (output_type == OUTPUT_FILE)\n  {\n    if (logfile &&\n        (is_active= (logger_write(logfile, message, len) == (int) len)))\n      goto exit;\n    ++log_write_failures;\n    result= 1;\n  }\n  else if (output_type == OUTPUT_SYSLOG)\n  {\n    syslog(syslog_facility_codes[syslog_facility] |\n           syslog_priority_codes[syslog_priority],\n           \"%s %.*s\", syslog_info, (int) len, message);\n  }\nexit:\n  if (take_lock)\n    flogger_mutex_unlock(&lock_operations);\n  return result;\n}\n\n\nstatic size_t log_header(char *message, size_t message_len,\n                      time_t *ts,\n                      const char *serverhost, size_t serverhost_len,\n                      const char *username, unsigned int username_len,\n                      const char *host, unsigned int host_len,\n                      const char *userip, unsigned int userip_len,\n                      unsigned int connection_id, long long query_id,\n                      const char *operation)\n{\n  struct tm tm_time;\n\n  if (host_len == 0 && userip_len != 0)\n  {\n    host_len= userip_len;\n    host= userip;\n  }\n\n  if (output_type == OUTPUT_SYSLOG)\n    return my_snprintf(message, message_len,\n        \"%.*s,%.*s,%.*s,%d,%lld,%s\",\n        (unsigned int) serverhost_len, serverhost,\n        username_len, username,\n        host_len, host,\n        connection_id, query_id, operation);\n\n  (void) localtime_r(ts, &tm_time);\n  return my_snprintf(message, message_len,\n      \"%04d%02d%02d %02d:%02d:%02d,%.*s,%.*s,%.*s,%d,%lld,%s\",\n      tm_time.tm_year+1900, tm_time.tm_mon+1, tm_time.tm_mday,\n      tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec,\n      serverhost_len, serverhost,\n      username_len, username,\n      host_len, host,\n      connection_id, query_id, operation);\n}\n\n\nstatic int log_proxy(const struct connection_info *cn,\n                     const struct mysql_event_connection *event)\n                   \n{\n  time_t ctime;\n  size_t csize;\n  char message[1024];\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    cn->user, cn->user_length,\n                    cn->host, cn->host_length,\n                    cn->ip, cn->ip_length,\n                    event->thread_id, 0, \"PROXY_CONNECT\");\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n    \",%.*s,`%.*s`@`%.*s`,%d\", cn->db_length, cn->db,\n                     cn->proxy_length, cn->proxy,\n                     cn->proxy_host_length, cn->proxy_host,\n                     event->status);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1, 1);\n}\n\n\nstatic int log_connection(const struct connection_info *cn,\n                          const struct mysql_event_connection *event,\n                          const char *type)\n{\n  time_t ctime;\n  size_t csize;\n  char message[1024];\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    cn->user, cn->user_length,\n                    cn->host, cn->host_length,\n                    cn->ip, cn->ip_length,\n                    event->thread_id, 0, type);\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n    \",%.*s,,%d\", cn->db_length, cn->db, event->status);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1, 1);\n}\n\n\nstatic int log_connection_event(const struct mysql_event_connection *event,\n                                const char *type)\n{\n  time_t ctime;\n  size_t csize;\n  char message[1024];\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    event->user, event->user_length,\n                    event->host, event->host_length,\n                    event->ip, event->ip_length,\n                    event->thread_id, 0, type);\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n    \",%.*s,,%d\", event->database_length, event->database, event->status);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1, 1);\n}\n\n\nstatic size_t escape_string(const char *str, unsigned int len,\n                          char *result, size_t result_len)\n{\n  const char *res_start= result;\n  const char *res_end= result + result_len - 2;\n  while (len)\n  {\n    char esc_c;\n\n    if (result >= res_end)\n      break;\n    if ((esc_c= escaped_char(*str)))\n    {\n      if (result+1 >= res_end)\n        break;\n      *(result++)= '\\\\';\n      *(result++)= esc_c;\n    }\n    else if (is_space(*str))\n      *(result++)= ' ';\n    else\n      *(result++)= *str;\n    str++;\n    len--;\n  }\n  *result= 0;\n  return result - res_start;\n}\n\n\nstatic size_t escape_string_hide_passwords(const char *str, unsigned int len,\n    char *result, size_t result_len,\n    const char *word1, size_t word1_len,\n    const char *word2, size_t word2_len,\n    int next_text_string)\n{\n  const char *res_start= result;\n  const char *res_end= result + result_len - 2;\n  size_t d_len;\n\n  while (len)\n  {\n    if (len > word1_len + 1 && strncasecmp(str, word1, word1_len) == 0)\n    {\n      const char *next_s= str + word1_len;\n      size_t c;\n\n      if (next_text_string)\n      {\n        while (*next_s && *next_s != '\\'' && *next_s != '\"')\n          ++next_s;\n      }\n      else\n      {\n        if (word2)\n        {\n          SKIP_SPACES(next_s);\n          if (len < (next_s - str) + word2_len + 1 ||\n              strncasecmp(next_s, word2, word2_len) != 0)\n            goto no_password;\n          next_s+= word2_len;\n        }\n\n        while (*next_s && *next_s != '\\'' && *next_s != '\"')\n          ++next_s;\n      }\n\n      d_len= next_s - str;\n      if (result + d_len + 5 > res_end)\n        break;\n\n      for (c=0; c<d_len; c++)\n        result[c]= is_space(str[c]) ? ' ' : str[c];\n\n      if (*next_s)\n      {\n        const char b_char= *next_s++;\n        memset(result + d_len, '*', 5);\n        result+= d_len + 5;\n\n        while (*next_s)\n        {\n          if (*next_s == b_char)\n          {\n            ++next_s;\n            break;\n          }\n          if (*next_s == '\\\\')\n          {\n            if (next_s[1])\n              next_s++;\n          }\n          next_s++;\n        }\n      }\n      else\n        result+= d_len;\n\n      len-= (uint)(next_s - str);\n      str= next_s;\n      continue;\n    }\nno_password:\n    if (result >= res_end)\n      break;\n    else\n    {\n      const char b_char= escaped_char(*str);\n      if (b_char)\n      {\n        if (result+1 >= res_end)\n          break;\n        *(result++)= '\\\\';\n        *(result++)= b_char;\n      }\n      else if (is_space(*str))\n        *(result++)= ' ';\n      else\n        *(result++)= *str;\n      str++;\n      len--;\n    }\n  }\n  *result= 0;\n  return result - res_start;\n}\n\n\n\nstatic int do_log_user(const char *name, int len,\n                       const char *proxy, int proxy_len, int take_lock)\n{\n  int result;\n\n  if (!name)\n    return 0;\n\n  if (take_lock)\n    flogger_mutex_lock(&lock_operations);\n\n  if (incl_user_coll.n_users)\n  {\n    result= coll_search(&incl_user_coll, name, len) != 0 ||\n            (proxy && coll_search(&incl_user_coll, proxy, proxy_len) != 0);\n  }\n  else if (excl_user_coll.n_users)\n  {\n    result= coll_search(&excl_user_coll, name, len) == 0 &&\n            (proxy && coll_search(&excl_user_coll, proxy, proxy_len) == 0);\n  }\n  else\n    result= 1;\n\n  if (take_lock)\n    flogger_mutex_unlock(&lock_operations);\n  return result;\n}\n\n\nstatic int get_next_word(const char *query, char *word)\n{\n  int len= 0;\n  char c;\n  while ((c= query[len]))\n  {\n    if (c >= 'a' && c <= 'z')\n      word[len]= 'A' + (c-'a');\n    else if (c >= 'A' && c <= 'Z')\n      word[len]= c;\n    else\n      break;\n\n    if (len++ == MAX_KEYWORD)\n      return 0;\n  }\n  word[len]= 0;\n  return len;\n}\n\n\nstatic int filter_query_type(const char *query, struct sa_keyword *kwd)\n{\n  int qwe_in_list;\n  char fword[MAX_KEYWORD + 1], nword[MAX_KEYWORD + 1];\n  int len, nlen= 0;\n  const struct sa_keyword *l_keywords;\n\n  while (*query && (is_space(*query) || *query == '(' || *query == '/'))\n  {\n    /* comment handling */\n    if (*query == '/' && query[1] == '*')\n    {\n      if (query[2] == '!')\n      {\n        query+= 3;\n        while (*query >= '0' && *query <= '9')\n          query++;\n        continue;\n      }\n      query+= 2;\n      while (*query)\n      {\n        if (*query=='*' && query[1] == '/')\n        {\n          query+= 2;\n          break;\n        }\n        query++;\n      }\n      continue;\n    }\n    query++;\n  }\n\n  qwe_in_list= 0;\n  if (!(len= get_next_word(query, fword)))\n    goto not_in_list;\n  query+= len+1;\n\n  l_keywords= kwd;\n  while (l_keywords->length)\n  {\n    if (l_keywords->length == len && strncmp(l_keywords->wd, fword, len) == 0)\n    {\n      if (l_keywords->next)\n      {\n        if (nlen == 0)\n        {\n          while (*query && is_space(*query))\n            query++;\n          nlen= get_next_word(query, nword);\n        }\n        if (l_keywords->next->length != nlen ||\n            strncmp(l_keywords->next->wd, nword, nlen) != 0)\n          goto do_loop;\n      }\n\n      qwe_in_list= l_keywords->type;\n      break;\n    };\ndo_loop:\n    l_keywords++;\n  }\n\nnot_in_list:\n  return qwe_in_list;\n}\n\n\nstatic int log_statement_ex(const struct connection_info *cn,\n                            time_t ev_time, unsigned long thd_id,\n                            const char *query, unsigned int query_len,\n                            int error_code, const char *type, int take_lock)\n{\n  size_t csize;\n  char message_loc[2048];\n  char *message= message_loc;\n  size_t message_size= sizeof(message_loc);\n  char *uh_buffer;\n  size_t uh_buffer_size;\n  const char *db;\n  unsigned int db_length;\n  long long query_id;\n  int result;\n  char *big_buffer= NULL;\n\n  if ((db= cn->db))\n    db_length= cn->db_length;\n  else\n  {\n    db= \"\";\n    db_length= 0;\n  }\n\n  if (!(query_id= cn->query_id))\n    query_id= query_counter++;\n\n  if (query == 0)\n  {\n    /* Can happen after the error in mysqld_prepare_stmt() */\n    query= cn->query;\n    query_len= cn->query_length;\n    if (query == 0 || query_len == 0)\n      return 0;\n  }\n\n  if (query && !(events & EVENT_QUERY_ALL) &&\n      (events & EVENT_QUERY && !cn->log_always))\n  {\n    const char *orig_query= query;\n\n    if (filter_query_type(query, keywords_to_skip))\n    {\n      char fword[MAX_KEYWORD + 1];\n      int len;\n      do\n      {\n        len= get_next_word(query, fword);\n        query+= len ? len : 1;\n        if (len == 3 && strncmp(fword, \"FOR\", 3) == 0)\n          break;\n      } while (*query);\n\n      if (*query == 0)\n        return 0;\n    }\n\n    if (events & EVENT_QUERY_DDL)\n    {\n      if (!filter_query_type(query, not_ddl_keywords) &&\n          filter_query_type(query, ddl_keywords))\n        goto do_log_query;\n    }\n    if (events & EVENT_QUERY_DML)\n    {\n      if (filter_query_type(query, dml_keywords))\n        goto do_log_query;\n    }\n    if (events & EVENT_QUERY_DML_NO_SELECT)\n    {\n      if (filter_query_type(query, dml_no_select_keywords))\n        goto do_log_query;\n    }\n    if (events & EVENT_QUERY_DCL)\n    {\n      if (filter_query_type(query, dcl_keywords))\n        goto do_log_query;\n    }\n\n    return 0;\ndo_log_query:\n    query= orig_query;\n  }\n\n  csize= log_header(message, message_size-1, &ev_time,\n                    servhost, servhost_len,\n                    cn->user, cn->user_length,cn->host, cn->host_length,\n                    cn->ip, cn->ip_length, thd_id, query_id, type);\n\n  csize+= my_snprintf(message+csize, message_size - 1 - csize,\n      \",%.*s,\\'\", db_length, db);\n\n  if (query_log_limit > 0 && query_len > query_log_limit)\n    query_len= query_log_limit;\n\n  if (query_len > (message_size - csize)/2)\n  {\n    size_t big_buffer_alloced= (query_len * 2 + csize + 4095) & ~4095L;\n    if(!(big_buffer= malloc(big_buffer_alloced)))\n      return 0;\n\n    memcpy(big_buffer, message, csize);\n    message= big_buffer;\n    message_size= big_buffer_alloced;\n  }\n\n  uh_buffer= message + csize;\n  uh_buffer_size= message_size - csize;\n  if (query_log_limit > 0 && uh_buffer_size > query_log_limit+2)\n    uh_buffer_size= query_log_limit+2;\n\n  switch (filter_query_type(query, passwd_keywords))\n  {\n    case SQLCOM_GRANT:\n    case SQLCOM_CREATE_USER:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"IDENTIFIED\", 10, \"BY\", 2, 0);\n      break;\n    case SQLCOM_CHANGE_MASTER:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"MASTER_PASSWORD\", 15, \"=\", 1, 0);\n      break;\n    case SQLCOM_CREATE_SERVER:\n    case SQLCOM_ALTER_SERVER:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"PASSWORD\", 8, NULL, 0, 0);\n      break;\n    case SQLCOM_SET_OPTION:\n      csize+= escape_string_hide_passwords(query, query_len,\n                                           uh_buffer, uh_buffer_size,\n                                           \"=\", 1, NULL, 0, 1);\n      break;\n    default:\n      csize+= escape_string(query, query_len,\n                               uh_buffer, uh_buffer_size); \n      break;\n  }\n  csize+= my_snprintf(message+csize, message_size - 1 - csize,\n                      \"\\',%d\", error_code);\n  message[csize]= '\\n';\n  result= write_log(message, csize + 1, take_lock);\n  if (big_buffer)\n    free(big_buffer);\n\n  return result;\n}\n\n\nstatic int log_statement(const struct connection_info *cn,\n                         const struct mysql_event_general *event,\n                         const char *type)\n{\n  return log_statement_ex(cn, event->general_time, event->general_thread_id,\n                          event->general_query, event->general_query_length,\n                          event->general_error_code, type, 1);\n}\n\n\nstatic int log_table(const struct connection_info *cn,\n                     const struct mysql_event_table *event, const char *type)\n{\n  size_t csize;\n  char message[1024];\n  time_t ctime;\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    event->user, SAFE_STRLEN_UI(event->user),\n                    event->host, SAFE_STRLEN_UI(event->host),\n                    event->ip, SAFE_STRLEN_UI(event->ip),\n                    event->thread_id, cn->query_id, type);\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n            \",%.*s,%.*s,\",event->database_length, event->database,\n                          event->table_length, event->table);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1, 1);\n}\n\n\nstatic int log_rename(const struct connection_info *cn,\n                      const struct mysql_event_table *event)\n{\n  size_t csize;\n  char message[1024];\n  time_t ctime;\n\n  (void) time(&ctime);\n  csize= log_header(message, sizeof(message)-1, &ctime,\n                    servhost, servhost_len,\n                    event->user, SAFE_STRLEN_UI(event->user),\n                    event->host, SAFE_STRLEN_UI(event->host),\n                    event->ip, SAFE_STRLEN_UI(event->ip),\n                    event->thread_id, cn->query_id, \"RENAME\");\n  csize+= my_snprintf(message+csize, sizeof(message) - 1 - csize,\n            \",%.*s,%.*s|%.*s.%.*s,\",event->database_length, event->database,\n                         event->table_length, event->table,\n                         event->new_database_length, event->new_database,\n                         event->new_table_length, event->new_table);\n  message[csize]= '\\n';\n  return write_log(message, csize + 1, 1);\n}\n\n\nstatic int event_query_command(const struct mysql_event_general *event)\n{\n  return (event->general_command_length == 5 &&\n           strncmp(event->general_command, \"Query\", 5) == 0) ||\n         (event->general_command_length == 7 &&\n           (strncmp(event->general_command, \"Execute\", 7) == 0 ||\n             (event->general_error_code != 0 &&\n              strncmp(event->general_command, \"Prepare\", 7) == 0)));\n}\n\n\nstatic void update_general_user(struct connection_info *cn,\n    const struct mysql_event_general *event)\n{\n  char uh_buffer[768];\n  size_t user_len, host_len, ip_len;\n  if (cn->user_length == 0 && cn->host_length == 0 && cn->ip_length == 0 &&\n      get_user_host(event->general_user, event->general_user_length,\n                    uh_buffer, sizeof(uh_buffer),\n                    &user_len, &host_len, &ip_len) == 0)\n  {\n    get_str_n(cn->user, &cn->user_length, sizeof(cn->user), \n              uh_buffer, user_len);\n    get_str_n(cn->host, &cn->host_length, sizeof(cn->host), \n              uh_buffer+user_len+1, host_len);\n    get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip), \n              uh_buffer+user_len+1+host_len+1, ip_len);\n  }\n\n}\n\n\nstatic struct connection_info ci_disconnect_buffer;\n\n#define AA_FREE_CONNECTION 1\n#define AA_CHANGE_USER 2\n\nstatic void update_connection_info(struct connection_info *cn,\n    unsigned int event_class, const void *ev, int *after_action)\n{\n  *after_action= 0;\n\n  switch (event_class) {\n  case MYSQL_AUDIT_GENERAL_CLASS:\n  {\n    const struct mysql_event_general *event =\n      (const struct mysql_event_general *) ev;\n    switch (event->event_subclass) {\n      case MYSQL_AUDIT_GENERAL_LOG:\n      {\n        int init_db_command= event->general_command_length == 7 &&\n          strncmp(event->general_command, \"Init DB\", 7) == 0;\n        if (!ci_needs_setup(cn))\n        {\n          if (init_db_command)\n          {\n            /* Change DB */\n            if (mysql_57_started)\n              get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                  event->database, event->database_length);\n            else\n              get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                  event->general_query, event->general_query_length);\n          }\n          cn->query_id= mode ? query_counter++ : event->query_id;\n          cn->query= event->general_query;\n          cn->query_length= event->general_query_length;\n          cn->query_time= (time_t) event->general_time;\n          update_general_user(cn, event);\n        }\n        else if (init_db_command)\n          setup_connection_initdb(cn, event);\n        else if (event_query_command(event))\n          setup_connection_query(cn, event);\n        else\n          setup_connection_simple(cn);\n        break;\n      }\n\n      case MYSQL_AUDIT_GENERAL_STATUS:\n        if (event_query_command(event))\n        {\n          if (ci_needs_setup(cn))\n            setup_connection_query(cn, event);\n\n          if (mode == 0 && cn->db_length == 0 && event->database_length > 0)\n            get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                      event->database, event->database_length);\n\n          if (event->general_error_code == 0)\n          {\n            /* We need to check if it's the USE command to change the DB */\n            int use_command= event->general_query_length > 4 &&\n              strncasecmp(event->general_query, \"use \", 4) == 0;\n            if (use_command)\n            {\n              /* Change DB */\n              if (mode)\n                get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                    event->general_query + 4, event->general_query_length - 4);\n              else\n                get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                    event->database, event->database_length);\n            }\n          }\n          update_general_user(cn, event);\n        }\n        break;\n      case MYSQL_AUDIT_GENERAL_ERROR:\n        /*\n          We need this because the MariaDB returns NULL query field for the\n          MYSQL_AUDIT_GENERAL_STATUS in the mysqld_stmt_prepare.\n          As a result we get empty QUERY field for errors.\n        */\n        if (ci_needs_setup(cn))\n          setup_connection_query(cn, event);\n        cn->query_id= mode ? query_counter++ : event->query_id;\n        get_str_n(cn->query_buffer, &cn->query_length, sizeof(cn->query_buffer),\n            event->general_query, event->general_query_length);\n        cn->query= cn->query_buffer;\n        cn->query_time= (time_t) event->general_time;\n        break;\n      default:;\n    }\n    break;\n  }\n  case MYSQL_AUDIT_TABLE_CLASS:\n  {\n    const struct mysql_event_table *event =\n      (const struct mysql_event_table *) ev;\n    if (ci_needs_setup(cn))\n      setup_connection_table(cn, event);\n\n    if (cn->user_length == 0 && cn->host_length == 0 && cn->ip_length == 0)\n    {\n      get_str_n(cn->user, &cn->user_length, sizeof(cn->user),\n                event->user, SAFE_STRLEN(event->user));\n      get_str_n(cn->host, &cn->host_length, sizeof(cn->host),\n                event->host, SAFE_STRLEN(event->host));\n      get_str_n(cn->ip, &cn->ip_length, sizeof(cn->ip),\n                event->ip, SAFE_STRLEN(event->ip));\n    }\n\n    if (cn->db_length == 0 && event->database_length != 0)\n      get_str_n(cn->db, &cn->db_length, sizeof(cn->db),\n                event->database, event->database_length);\n\n    if (mode == 0)\n      cn->query_id= event->query_id;\n    break;\n  }\n  case MYSQL_AUDIT_CONNECTION_CLASS:\n  {\n    const struct mysql_event_connection *event =\n      (const struct mysql_event_connection *) ev;\n    switch (event->event_subclass)\n    {\n      case MYSQL_AUDIT_CONNECTION_CONNECT:\n        setup_connection_connect(cn, event);\n        break;\n      case MYSQL_AUDIT_CONNECTION_CHANGE_USER:\n        *after_action= AA_CHANGE_USER;\n        break;\n      default:;\n    }\n    break;\n  }\n  default:\n    break;\n  }\n}\n\n\nstruct connection_info cn_error_buffer;\n\n\n#define FILTER(MASK) (events == 0 || (events & MASK))\nvoid auditing(MYSQL_THD thd, unsigned int event_class, const void *ev)\n{\n  struct connection_info *cn= 0;\n  int after_action= 0;\n\n  /* That one is important as this function can be called with      */\n  /* &lock_operations locked when the server logs an error reported */\n  /* by this plugin.                                                */\n  if (!thd || internal_stop_logging)\n    return;\n\n  if (maria_55_started && debug_server_started &&\n      event_class == MYSQL_AUDIT_GENERAL_CLASS)\n  {\n    /*\n      There's a bug in MariaDB 5.5 that prevents using thread local\n      variables in some cases.\n      The 'select * from notexisting_table;' query produces such case.\n      So just use the static buffer in this case.\n    */\n    const struct mysql_event_general *event =\n      (const struct mysql_event_general *) ev;\n\n    if (event->event_subclass == MYSQL_AUDIT_GENERAL_ERROR ||\n        (event->event_subclass == MYSQL_AUDIT_GENERAL_STATUS && \n         event->general_query_length == 0 &&\n         cn_error_buffer.query_id == event->query_id))\n    {\n      cn= &cn_error_buffer;\n      cn->header= 1;\n    }\n    else\n      cn= get_loc_info(thd);\n  }\n  else\n  {\n    cn= get_loc_info(thd);\n  }\n\n  update_connection_info(cn, event_class, ev, &after_action);\n\n  if (!logging)\n  {\n    if (cn)\n      cn->log_always= 0;\n    goto exit_func;\n  }\n\n  if (event_class == MYSQL_AUDIT_GENERAL_CLASS && FILTER(EVENT_QUERY) &&\n      cn && (cn->log_always || do_log_user(cn->user, cn->user_length,\n                                           cn->proxy, cn->proxy_length,\n                                           1)))\n  {\n    const struct mysql_event_general *event =\n      (const struct mysql_event_general *) ev;\n\n    /*\n      Only one subclass is logged.\n    */\n    if (event->event_subclass == MYSQL_AUDIT_GENERAL_STATUS &&\n        event_query_command(event))\n    {\n      log_statement(cn, event, \"QUERY\");\n      cn->query_length= 0; /* So the log_current_query() won't log this again. */\n      cn->log_always= 0;\n    }\n  }\n  else if (event_class == MYSQL_AUDIT_TABLE_CLASS && FILTER(EVENT_TABLE) && cn)\n  {\n    const struct mysql_event_table *event =\n      (const struct mysql_event_table *) ev;\n    if (do_log_user(event->user, (int) SAFE_STRLEN(event->user),\n                    cn->proxy, cn->proxy_length, 1))\n    {\n      switch (event->event_subclass)\n      {\n        case MYSQL_AUDIT_TABLE_LOCK:\n          log_table(cn, event, event->read_only ? \"READ\" : \"WRITE\");\n          break;\n        case MYSQL_AUDIT_TABLE_CREATE:\n          log_table(cn, event, \"CREATE\");\n          break;\n        case MYSQL_AUDIT_TABLE_DROP:\n          log_table(cn, event, \"DROP\");\n          break;\n        case MYSQL_AUDIT_TABLE_RENAME:\n          log_rename(cn, event);\n          break;\n        case MYSQL_AUDIT_TABLE_ALTER:\n          log_table(cn, event, \"ALTER\");\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  else if (event_class == MYSQL_AUDIT_CONNECTION_CLASS &&\n           FILTER(EVENT_CONNECT) && cn)\n  {\n    const struct mysql_event_connection *event =\n      (const struct mysql_event_connection *) ev;\n    switch (event->event_subclass)\n    {\n      case MYSQL_AUDIT_CONNECTION_CONNECT:\n        log_connection(cn, event, event->status ? \"FAILED_CONNECT\": \"CONNECT\");\n        if (event->status == 0 && event->proxy_user && event->proxy_user[0])\n          log_proxy(cn, event);\n        break;\n      case MYSQL_AUDIT_CONNECTION_DISCONNECT:\n        if (use_event_data_for_disconnect)\n          log_connection_event(event, \"DISCONNECT\");\n        else\n          log_connection(&ci_disconnect_buffer, event, \"DISCONNECT\");\n        break;\n      case MYSQL_AUDIT_CONNECTION_CHANGE_USER:\n        log_connection(cn, event, \"CHANGEUSER\");\n        if (event->proxy_user && event->proxy_user[0])\n          log_proxy(cn, event);\n        break;\n      default:;\n    }\n  }\nexit_func:\n  /*\n    This must work always, whether logging is ON or not.\n  */\n  if (after_action)\n  {\n    switch (after_action) {\n    case AA_CHANGE_USER:\n    {\n      const struct mysql_event_connection *event =\n        (const struct mysql_event_connection *) ev;\n      change_connection(cn, event);\n      break;\n    }\n    default:\n      break;\n    }\n  }\n}\n\n\nstruct mysql_event_general_v8\n{\n  unsigned int event_class;\n  unsigned int event_subclass;\n  int general_error_code;\n  unsigned long general_thread_id;\n  const char *general_user;\n  unsigned int general_user_length;\n  const char *general_command;\n  unsigned int general_command_length;\n  const char *general_query;\n  unsigned int general_query_length;\n  struct charset_info_st *general_charset;\n  unsigned long long general_time;\n  unsigned long long general_rows;\n};\n\n\nstatic void auditing_v8(MYSQL_THD thd, struct mysql_event_general_v8 *ev_v8)\n{\n#ifdef __linux__\n#ifdef DBUG_OFF\n  #ifdef __x86_64__\n  static const int cmd_off= 4200;\n  static const int db_off= 120;\n  static const int db_len_off= 128;\n  #else\n  static const int cmd_off= 2668;\n  static const int db_off= 60;\n  static const int db_len_off= 64;\n  #endif /*x86_64*/\n#else\n  #ifdef __x86_64__\n  static const int cmd_off= 4432;\n  static const int db_off= 120;\n  static const int db_len_off= 128;\n  #else\n  static const int cmd_off= 2808;\n  static const int db_off= 64;\n  static const int db_len_off= 68;\n  #endif /*x86_64*/\n#endif /*DBUG_OFF*/\n#endif /*__linux*/\n\n  struct mysql_event_general event;\n\n  if (ev_v8->event_class != MYSQL_AUDIT_GENERAL_CLASS)\n    return;\n\n  event.event_subclass= ev_v8->event_subclass;\n  event.general_error_code= ev_v8->general_error_code;\n  event.general_thread_id= ev_v8->general_thread_id;\n  event.general_user= ev_v8->general_user;\n  event.general_user_length= ev_v8->general_user_length;\n  event.general_command= ev_v8->general_command;\n  event.general_command_length= ev_v8->general_command_length;\n  event.general_query= ev_v8->general_query;\n  event.general_query_length= ev_v8->general_query_length;\n  event.general_charset= ev_v8->general_charset;\n  event.general_time= ev_v8->general_time;\n  event.general_rows= ev_v8->general_rows;\n  event.database= 0;\n  event.database_length= 0;\n\n  if (event.general_query_length > 0)\n  {\n    event.event_subclass= MYSQL_AUDIT_GENERAL_STATUS;\n    event.general_command= \"Query\";\n    event.general_command_length= 5;\n#ifdef __linux__\n    event.database= *(char **) (((char *) thd) + db_off);\n    event.database_length= *(size_t *) (((char *) thd) + db_len_off);\n#endif /*__linux*/\n  }\n#ifdef __linux__\n  else if (*((int *) (((char *)thd) + cmd_off)) == 2)\n  {\n    event.event_subclass= MYSQL_AUDIT_GENERAL_LOG;\n    event.general_command= \"Init DB\";\n    event.general_command_length= 7;\n    event.general_query= *(char **) (((char *) thd) + db_off);\n    event.general_query_length= *(size_t *) (((char *) thd) + db_len_off);\n  }\n#endif /*__linux*/\n  auditing(thd, ev_v8->event_class, &event);\n}\n\n\nstatic void auditing_v13(MYSQL_THD thd, unsigned int *ev_v0)\n{\n  struct mysql_event_general event= *(const struct mysql_event_general *) (ev_v0+1);\n\n  if (event.general_query_length > 0)\n  {\n    event.event_subclass= MYSQL_AUDIT_GENERAL_STATUS;\n    event.general_command= \"Query\";\n    event.general_command_length= 5;\n  }\n  auditing(thd, ev_v0[0], &event);\n}\n\n\nint get_db_mysql57(MYSQL_THD thd, char **name, int *len)\n{\n#ifdef __linux__\n  int db_off;\n  int db_len_off;\n  if (debug_server_started)\n  {\n#ifdef __x86_64__\n    db_off= 608;\n    db_len_off= 616;\n#else\n    db_off= 0;\n    db_len_off= 0;\n#endif /*x86_64*/\n  }\n  else\n  {\n#ifdef __x86_64__\n    db_off= 536;\n    db_len_off= 544;\n#else\n    db_off= 0;\n    db_len_off= 0;\n#endif /*x86_64*/\n  }\n\n  *name= *(char **) (((char *) thd) + db_off);\n  *len= *((int *) (((char*) thd) + db_len_off));\n  if (*name && (*name)[*len] != 0)\n    return 1;\n  return 0;\n#else\n  return 1;\n#endif\n}\n/*\n   As it's just too difficult to #include \"sql_class.h\",\n   let's just copy the necessary part of the system_variables\n   structure here.\n*/\ntypedef struct loc_system_variables\n{\n  ulong dynamic_variables_version;\n  char* dynamic_variables_ptr;\n  uint dynamic_variables_head;    /* largest valid variable offset */\n  uint dynamic_variables_size;    /* how many bytes are in use */\n  \n  ulonglong max_heap_table_size;\n  ulonglong tmp_table_size;\n  ulonglong long_query_time;\n  ulonglong optimizer_switch;\n  ulonglong sql_mode; ///< which non-standard SQL behaviour should be enabled\n  ulonglong option_bits; ///< OPTION_xxx constants, e.g. OPTION_PROFILING\n  ulonglong join_buff_space_limit;\n  ulonglong log_slow_filter; \n  ulonglong log_slow_verbosity; \n  ulonglong bulk_insert_buff_size;\n  ulonglong join_buff_size;\n  ulonglong sortbuff_size;\n  ulonglong group_concat_max_len;\n  ha_rows select_limit;\n  ha_rows max_join_size;\n  ha_rows expensive_subquery_limit;\n  ulong auto_increment_increment, auto_increment_offset;\n  ulong lock_wait_timeout;\n  ulong join_cache_level;\n  ulong max_allowed_packet;\n  ulong max_error_count;\n  ulong max_length_for_sort_data;\n  ulong max_sort_length;\n  ulong max_tmp_tables;\n  ulong max_insert_delayed_threads;\n  ulong min_examined_row_limit;\n  ulong multi_range_count;\n  ulong net_buffer_length;\n  ulong net_interactive_timeout;\n  ulong net_read_timeout;\n  ulong net_retry_count;\n  ulong net_wait_timeout;\n  ulong net_write_timeout;\n  ulong optimizer_prune_level;\n  ulong optimizer_search_depth;\n  ulong preload_buff_size;\n  ulong profiling_history_size;\n  ulong read_buff_size;\n  ulong read_rnd_buff_size;\n  ulong mrr_buff_size;\n  ulong div_precincrement;\n  /* Total size of all buffers used by the subselect_rowid_merge_engine. */\n  ulong rowid_merge_buff_size;\n  ulong max_sp_recursion_depth;\n  ulong default_week_format;\n  ulong max_seeks_for_key;\n  ulong range_alloc_block_size;\n  ulong query_alloc_block_size;\n  ulong query_prealloc_size;\n  ulong trans_alloc_block_size;\n  ulong trans_prealloc_size;\n  ulong log_warnings;\n  /* Flags for slow log filtering */\n  ulong log_slow_rate_limit; \n  ulong binlog_format; ///< binlog format for this thd (see enum_binlog_format)\n  ulong progress_report_time;\n  my_bool binlog_annotate_row_events;\n  my_bool binlog_direct_non_trans_update;\n  my_bool sql_log_bin;\n  ulong completion_type;\n  ulong query_cache_type;\n} LOC_SV;\n\n\nstatic int init_done= 0;\n\nstatic int server_audit_init(void *p __attribute__((unused)))\n{\n  if (!serv_ver)\n  {\n#ifdef _WIN32\n    serv_ver= (const char *) GetProcAddress(0, \"server_version\");\n#else\n    serv_ver= server_version;\n#endif /*_WIN32*/\n  }\n  if (!mysql_57_started)\n  {\n    const void *my_hash_init_ptr= dlsym(RTLD_DEFAULT, \"_my_hash_init\");\n    if (!my_hash_init_ptr)\n    {\n      maria_above_5= 1;\n      my_hash_init_ptr= dlsym(RTLD_DEFAULT, \"my_hash_init2\");\n    }\n    if (!my_hash_init_ptr)\n      return 1;\n  }\n\n  if(!(int_mysql_data_home= dlsym(RTLD_DEFAULT, \"mysql_data_home\")))\n  {\n    if(!(int_mysql_data_home= dlsym(RTLD_DEFAULT, \"?mysql_data_home@@3PADA\")))\n      int_mysql_data_home= &default_home;\n  }\n\n  if (!serv_ver)\n    return 1;\n\n  if (!started_mysql)\n  {\n    if (!maria_above_5 && serv_ver[4]=='3' && serv_ver[5]<'3')\n    {\n      mode= 1;\n      mode_readonly= 1;\n    }\n  }\n\n  if (gethostname(servhost, sizeof(servhost)))\n    strcpy(servhost, \"unknown\");\n\n  servhost_len= (uint)strlen(servhost);\n\n  logger_init_mutexes();\n#if defined(HAVE_PSI_INTERFACE) && !defined(FLOGGER_NO_PSI)\n  if (PSI_server)\n    PSI_server->register_mutex(\"server_audit\", mutex_key_list, 1);\n#endif\n  flogger_mutex_init(key_LOCK_operations, &lock_operations, MY_MUTEX_INIT_FAST);\n  flogger_mutex_init(key_LOCK_operations, &lock_atomic, MY_MUTEX_INIT_FAST);\n\n  coll_init(&incl_user_coll);\n  coll_init(&excl_user_coll);\n\n  if (incl_users)\n  {\n    if (excl_users)\n    {\n      incl_users= excl_users= NULL;\n      error_header();\n      fprintf(stderr, \"INCL_DML_USERS and EXCL_DML_USERS specified\"\n                      \" simultaneously - both set to empty\\n\");\n    }\n    update_incl_users(NULL, NULL, NULL, &incl_users);\n  }\n  else if (excl_users)\n  {\n    update_excl_users(NULL, NULL, NULL, &excl_users);\n  }\n\n  error_header();\n  fprintf(stderr, \"MariaDB Audit Plugin version %s%s STARTED.\\n\",\n          PLUGIN_STR_VERSION, PLUGIN_DEBUG_VERSION);\n\n  /* The Query Cache shadows TABLE events if the result is taken from it */\n  /* so we warn users if both Query Cashe and TABLE events enabled.      */\n  if (!started_mysql && FILTER(EVENT_TABLE))\n  {\n    ulonglong *qc_size= (ulonglong *) dlsym(RTLD_DEFAULT, \"query_cache_size\");\n    if (qc_size == NULL || *qc_size != 0)\n    {\n      struct loc_system_variables *g_sys_var=\n        (struct loc_system_variables *) dlsym(RTLD_DEFAULT,\n                                          \"global_system_variables\");\n      if (g_sys_var && g_sys_var->query_cache_type != 0)\n      {\n        error_header();\n        fprintf(stderr, \"Query cache is enabled with the TABLE events.\"\n                        \" Some table reads can be veiled.\");\n      }\n    }\n  }\n\n  ci_disconnect_buffer.header= 10;\n  ci_disconnect_buffer.thread_id= 0;\n  ci_disconnect_buffer.query_id= 0;\n  ci_disconnect_buffer.db_length= 0;\n  ci_disconnect_buffer.user_length= 0;\n  ci_disconnect_buffer.host_length= 0;\n  ci_disconnect_buffer.ip_length= 0;\n  ci_disconnect_buffer.query= empty_str;\n  ci_disconnect_buffer.query_length= 0;\n\n  if (logging)\n    start_logging();\n\n  init_done= 1;\n  return 0;\n}\n\n\nstatic int server_audit_init_mysql(void *p)\n{\n  started_mysql= 1;\n  mode= 1;\n  mode_readonly= 1;\n  return server_audit_init(p);\n}\n\n\nstatic int server_audit_deinit(void *p __attribute__((unused)))\n{\n  if (!init_done)\n    return 0;\n\n  init_done= 0;\n  coll_free(&incl_user_coll);\n  coll_free(&excl_user_coll);\n\n  if (output_type == OUTPUT_FILE && logfile)\n    logger_close(logfile);\n  else if (output_type == OUTPUT_SYSLOG)\n    closelog();\n\n  flogger_mutex_destroy(&lock_operations);\n  flogger_mutex_destroy(&lock_atomic);\n\n  error_header();\n  fprintf(stderr, \"STOPPED\\n\");\n  return 0;\n}\n\n\nstatic void rotate_log(MYSQL_THD thd  __attribute__((unused)),\n                       struct st_mysql_sys_var *var  __attribute__((unused)),\n                       void *var_ptr  __attribute__((unused)),\n                       const void *save  __attribute__((unused)))\n{\n  if (output_type == OUTPUT_FILE && logfile && *(my_bool*) save)\n    (void) logger_rotate(logfile);\n}\n\n\nstatic struct st_mysql_audit mysql_descriptor =\n{\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  NULL,\n  auditing,\n  { MYSQL_AUDIT_GENERAL_CLASSMASK | MYSQL_AUDIT_CONNECTION_CLASSMASK }\n};\n\n\nmysql_declare_plugin(server_audit)\n{\n  MYSQL_AUDIT_PLUGIN,\n  &mysql_descriptor,\n  \"SERVER_AUDIT\",\n  \" Alexey Botchkov (MariaDB Corporation)\",\n  \"Audit the server activity\",\n  PLUGIN_LICENSE_GPL,\n  server_audit_init_mysql,\n  server_audit_deinit,\n  PLUGIN_VERSION,\n  audit_status,\n  vars,\n  NULL,\n  0\n}\nmysql_declare_plugin_end;\n\n\nstatic struct st_mysql_audit maria_descriptor =\n{\n  MYSQL_AUDIT_INTERFACE_VERSION,\n  NULL,\n  auditing,\n  { MYSQL_AUDIT_GENERAL_CLASSMASK |\n    MYSQL_AUDIT_TABLE_CLASSMASK |\n    MYSQL_AUDIT_CONNECTION_CLASSMASK }\n};\nmaria_declare_plugin(server_audit)\n{\n  MYSQL_AUDIT_PLUGIN,\n  &maria_descriptor,\n  \"SERVER_AUDIT\",\n  \"Alexey Botchkov (MariaDB Corporation)\",\n  \"Audit the server activity\",\n  PLUGIN_LICENSE_GPL,\n  server_audit_init,\n  server_audit_deinit,\n  PLUGIN_VERSION,\n  audit_status,\n  vars,\n  PLUGIN_STR_VERSION,\n  MariaDB_PLUGIN_MATURITY_STABLE\n}\nmaria_declare_plugin_end;\n\n\nstatic void mark_always_logged(MYSQL_THD thd)\n{\n  struct connection_info *cn;\n  if (thd && (cn= get_loc_info(thd)))\n    cn->log_always= 1;\n}\n\n\nstatic void log_current_query(MYSQL_THD thd)\n{\n  struct connection_info *cn;\n  if (!thd)\n    return;\n  cn= get_loc_info(thd);\n  if (!ci_needs_setup(cn) && cn->query_length)\n  {\n    cn->log_always= 1;\n    log_statement_ex(cn, cn->query_time, thd_get_thread_id(thd),\n\t\t     cn->query, cn->query_length, 0, \"QUERY\", 0);\n    cn->log_always= 0;\n  }\n}\n\n\nstatic void update_file_path(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_name= (*(char **) save) ? *(char **) save : empty_str;\n\n  ADD_ATOMIC(internal_stop_logging, 1);\n  error_header();\n  fprintf(stderr, \"Log file name was changed to '%s'.\\n\", new_name);\n\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n\n  if (logging)\n    log_current_query(thd);\n\n  if (logging && output_type == OUTPUT_FILE)\n  {\n    char *sav_path= file_path;\n\n    file_path= new_name;\n    stop_logging();\n    if (start_logging())\n    {\n      file_path= sav_path;\n      error_header();\n      fprintf(stderr, \"Reverting log filename back to '%s'.\\n\", file_path);\n      logging= (start_logging() == 0);\n      if (!logging)\n      {\n        error_header();\n        fprintf(stderr, \"Logging was disabled..\\n\");\n        CLIENT_ERROR(1, \"Logging was disabled.\", MYF(ME_JUST_WARNING));\n      }\n      goto exit_func;\n    }\n  }\n\n  strncpy(path_buffer, new_name, sizeof(path_buffer)-1);\n  path_buffer[sizeof(path_buffer)-1]= 0;\n  file_path= path_buffer;\nexit_func:\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n  ADD_ATOMIC(internal_stop_logging, -1);\n}\n\n\nstatic void update_file_rotations(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  rotations= *(unsigned int *) save;\n  error_header();\n  fprintf(stderr, \"Log file rotations was changed to '%d'.\\n\", rotations);\n\n  if (!logging || output_type != OUTPUT_FILE)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n  logfile->rotations= rotations;\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_file_rotate_size(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  file_rotate_size= *(unsigned long long *) save;\n  error_header();\n  fprintf(stderr, \"Log file rotate size was changed to '%lld'.\\n\",\n          file_rotate_size);\n\n  if (!logging || output_type != OUTPUT_FILE)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n  logfile->size_limit= file_rotate_size;\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic int check_users(void *save, struct st_mysql_value *value,\n                       size_t s, const char *name)\n{\n  const char *users;\n  int len= 0;\n\n  users= value->val_str(value, NULL, &len);\n  if ((size_t) len > s)\n  {\n    error_header();\n    fprintf(stderr,\n            \"server_audit_%s_users value can't be longer than %zu characters.\\n\",\n            name, s);\n    return 1;\n  }\n  *((const char**)save)= users;\n  return 0;\n}\n\nstatic int check_incl_users(MYSQL_THD thd  __attribute__((unused)),\n                            struct st_mysql_sys_var *var  __attribute__((unused)),\n                            void *save, struct st_mysql_value *value)\n{\n  return check_users(save, value, sizeof(incl_user_buffer), \"incl\");\n}\n\nstatic int check_excl_users(MYSQL_THD thd  __attribute__((unused)),\n                            struct st_mysql_sys_var *var  __attribute__((unused)),\n                            void *save, struct st_mysql_value *value)\n{\n  return check_users(save, value, sizeof(excl_user_buffer), \"excl\");\n}\n\n\nstatic void update_incl_users(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_users= (*(char **) save) ? *(char **) save : empty_str;\n  size_t new_len= strlen(new_users) + 1;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n\n  if (new_len > sizeof(incl_user_buffer))\n    new_len= sizeof(incl_user_buffer);\n\n  memcpy(incl_user_buffer, new_users, new_len - 1);\n  incl_user_buffer[new_len - 1]= 0;\n\n  incl_users= incl_user_buffer;\n  user_coll_fill(&incl_user_coll, incl_users, &excl_user_coll, 1);\n  error_header();\n  fprintf(stderr, \"server_audit_incl_users set to '%s'.\\n\", incl_users);\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_excl_users(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_users= (*(char **) save) ? *(char **) save : empty_str;\n  size_t new_len= strlen(new_users) + 1;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n\n  if (new_len > sizeof(excl_user_buffer))\n    new_len= sizeof(excl_user_buffer);\n\n  memcpy(excl_user_buffer, new_users, new_len - 1);\n  excl_user_buffer[new_len - 1]= 0;\n\n  excl_users= excl_user_buffer;\n  user_coll_fill(&excl_user_coll, excl_users, &incl_user_coll, 0);\n  error_header();\n  fprintf(stderr, \"server_audit_excl_users set to '%s'.\\n\", excl_users);\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n}\n\n\nstatic void update_output_type(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  ulong new_output_type= *((ulong *) save);\n  if (output_type == new_output_type)\n    return;\n\n  ADD_ATOMIC(internal_stop_logging, 1);\n  flogger_mutex_lock(&lock_operations);\n  if (logging)\n  {\n    log_current_query(thd);\n    stop_logging();\n  }\n\n  output_type= new_output_type;\n  error_header();\n  fprintf(stderr, \"Output was redirected to '%s'\\n\",\n          output_type_names[output_type]);\n\n  if (logging)\n    start_logging();\n  flogger_mutex_unlock(&lock_operations);\n  ADD_ATOMIC(internal_stop_logging, -1);\n}\n\n\nstatic void update_syslog_facility(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  ulong new_facility= *((ulong *) save);\n  if (syslog_facility == new_facility)\n    return;\n\n  mark_always_logged(thd);\n  error_header();\n  fprintf(stderr, \"SysLog facility was changed from '%s' to '%s'.\\n\",\n          syslog_facility_names[syslog_facility],\n          syslog_facility_names[new_facility]);\n  syslog_facility= new_facility;\n}\n\n\nstatic void update_syslog_priority(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  ulong new_priority= *((ulong *) save);\n  if (syslog_priority == new_priority)\n    return;\n\n  flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n  flogger_mutex_unlock(&lock_operations);\n  error_header();\n  fprintf(stderr, \"SysLog priority was changed from '%s' to '%s'.\\n\",\n          syslog_priority_names[syslog_priority],\n          syslog_priority_names[new_priority]);\n  syslog_priority= new_priority;\n}\n\n\nstatic void update_logging(MYSQL_THD thd,\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char new_logging= *(char *) save;\n  if (new_logging == logging)\n    return;\n\n  ADD_ATOMIC(internal_stop_logging, 1);\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  if ((logging= new_logging))\n  {\n    start_logging();\n    if (!logging)\n    {\n      CLIENT_ERROR(1, \"Logging was disabled.\", MYF(ME_JUST_WARNING));\n    }\n    mark_always_logged(thd);\n  }\n  else\n  {\n    log_current_query(thd);\n    stop_logging();\n  }\n\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n  ADD_ATOMIC(internal_stop_logging, -1);\n}\n\n\nstatic void update_mode(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  unsigned int new_mode= *(unsigned int *) save;\n  if (mode_readonly || new_mode == mode)\n    return;\n\n  ADD_ATOMIC(internal_stop_logging, 1);\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n  error_header();\n  fprintf(stderr, \"Logging mode was changed from %d to %d.\\n\", mode, new_mode);\n  mode= new_mode;\n  if (!maria_55_started || !debug_server_started)\n    flogger_mutex_unlock(&lock_operations);\n  ADD_ATOMIC(internal_stop_logging, -1);\n}\n\n\nstatic void update_syslog_ident(MYSQL_THD thd  __attribute__((unused)),\n              struct st_mysql_sys_var *var  __attribute__((unused)),\n              void *var_ptr  __attribute__((unused)), const void *save)\n{\n  char *new_ident= (*(char **) save) ? *(char **) save : empty_str;\n  strncpy(syslog_ident_buffer, new_ident, sizeof(syslog_ident_buffer)-1);\n  syslog_ident_buffer[sizeof(syslog_ident_buffer)-1]= 0;\n  syslog_ident= syslog_ident_buffer;\n  error_header();\n  fprintf(stderr, \"SYSYLOG ident was changed to '%s'\\n\", syslog_ident);\n  flogger_mutex_lock(&lock_operations);\n  mark_always_logged(thd);\n  if (logging && output_type == OUTPUT_SYSLOG)\n  {\n    stop_logging();\n    start_logging();\n  }\n  flogger_mutex_unlock(&lock_operations);\n}\n\n\nstruct st_my_thread_var *loc_thread_var(void)\n{\n  return 0;\n}\n\n\n\n#ifdef _WIN32\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)\n{\n  if (fdwReason != DLL_PROCESS_ATTACH)\n    return 1;\n\n  serv_ver= (const char *) GetProcAddress(0, \"server_version\");\n#else\nvoid __attribute__ ((constructor)) audit_plugin_so_init(void)\n{\n  serv_ver= server_version;\n#endif /*_WIN32*/\n\n  if (!serv_ver)\n    goto exit;\n\n  started_mariadb= strstr(serv_ver, \"MariaDB\") != 0;\n  debug_server_started= strstr(serv_ver, \"debug\") != 0;\n\n  if (started_mariadb)\n  {\n    if (serv_ver[0] == '1')\n      use_event_data_for_disconnect= 1;\n    else\n      maria_55_started= 1;\n  }\n  else\n  {\n    /* Started MySQL. */\n    if (serv_ver[0] == '5' && serv_ver[2] == '5')\n    {\n      int sc= serv_ver[4] - '0';\n      if (serv_ver[5] >= '0' && serv_ver[5] <= '9')\n        sc= sc * 10 + serv_ver[5] - '0';\n      if (sc <= 10)\n      {\n        mysql_descriptor.interface_version= 0x0200;\n        mysql_descriptor.event_notify= (void *) auditing_v8;\n      }\n      else if (sc < 14)\n      {\n        mysql_descriptor.interface_version= 0x0200;\n        mysql_descriptor.event_notify= (void *) auditing_v13;\n      }\n    }\n    else if (serv_ver[0] == '5' && serv_ver[2] == '6')\n    {\n      int sc= serv_ver[4] - '0';\n      if (serv_ver[5] >= '0' && serv_ver[5] <= '9')\n        sc= sc * 10 + serv_ver[5] - '0';\n      if (sc >= 24)\n        use_event_data_for_disconnect= 1;\n    }\n    else if ((serv_ver[0] == '5' && serv_ver[2] == '7') ||\n             (serv_ver[0] == '8' && serv_ver[2] == '0'))\n    {\n      mysql_57_started= 1;\n      _mysql_plugin_declarations_[0].info= mysql_v4_descriptor;\n      use_event_data_for_disconnect= 1;\n    }\n    MYSQL_SYSVAR_NAME(loc_info).flags= PLUGIN_VAR_STR | PLUGIN_VAR_THDLOCAL |\n      PLUGIN_VAR_READONLY | PLUGIN_VAR_MEMALLOC;\n  }\n\n  memset(locinfo_ini_value, 'O', sizeof(locinfo_ini_value)-1);\n  locinfo_ini_value[sizeof(locinfo_ini_value)-1]= 0;\n\nexit:\n#ifdef _WIN32\n  return 1;\n#else\n  return;\n#endif\n}\n\n"], "filenames": ["mysql-test/suite/plugins/r/server_audit.result", "mysql-test/suite/plugins/t/server_audit.test", "plugin/server_audit/server_audit.c"], "buggy_code_start_loc": [263, 212, 304], "buggy_code_end_loc": [487, 212, 2588], "fixing_code_start_loc": [264, 213, 303], "fixing_code_end_loc": [492, 215, 2571], "type": "CWE-404", "message": "MariaDB Server before 10.7 is vulnerable to Denial of Service. While executing the plugin/server_audit/server_audit.c method log_statement_ex, the held lock lock_bigbuffer is not released correctly, which allows local users to trigger a denial of service due to the deadlock.", "other": {"cve": {"id": "CVE-2022-31624", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-25T21:15:08.700", "lastModified": "2022-11-05T02:01:16.307", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "MariaDB Server before 10.7 is vulnerable to Denial of Service. While executing the plugin/server_audit/server_audit.c method log_statement_ex, the held lock lock_bigbuffer is not released correctly, which allows local users to trigger a denial of service due to the deadlock."}, {"lang": "es", "value": "MariaDB Server versiones anteriores a 10.7, es vulnerable a una denegaci\u00f3n de servicio. Mientras es ejecutado el m\u00e9todo log_statement_ex del archivo plugin/server_audit/server_audit.c, el bloqueo mantenido lock_bigbuffer no es liberado correctamente, lo que permite a usuarios locales desencadenar una denegaci\u00f3n de servicio debido al bloqueo"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionEndExcluding": "10.2.41", "matchCriteriaId": "0A447A17-E295-4F60-AC74-E04F843E9FE8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.3.0", "versionEndExcluding": "10.3.32", "matchCriteriaId": "705DFD55-1C4B-41E3-BD84-EE76F9B497E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.4.0", "versionEndExcluding": "10.4.22", "matchCriteriaId": "A8F611A5-866A-4E49-9689-0A47B05FA738"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.5.0", "versionEndExcluding": "10.5.13", "matchCriteriaId": "0A15558C-2B98-4AA5-9775-A1A4374D7BD6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mariadb:mariadb:*:*:*:*:*:*:*:*", "versionStartIncluding": "10.6.0", "versionEndExcluding": "10.6.5", "matchCriteriaId": "73DE2000-2CBA-4811-AD1F-F6EB3B9E4556"}]}]}], "references": [{"url": "https://github.com/MariaDB/server/commit/d627d00b13ab2f2c0954ea7b77202470cb102944", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://jira.mariadb.org/browse/MDEV-26556?filter=-2", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Permissions Required", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20220707-0006/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/MariaDB/server/commit/d627d00b13ab2f2c0954ea7b77202470cb102944"}}