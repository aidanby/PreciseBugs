{"buggy_code": ["import graphene\nimport jwt\nfrom django.conf import settings\nfrom django.contrib.auth import password_validation\nfrom django.core.exceptions import ValidationError\nfrom django.db import transaction\n\nfrom ....account import events as account_events\nfrom ....account import models, notifications, search, utils\nfrom ....account.error_codes import AccountErrorCode\nfrom ....account.utils import remove_the_oldest_user_address_if_address_limit_is_reached\nfrom ....checkout import AddressType\nfrom ....core.jwt import create_token, jwt_decode\nfrom ....core.permissions import AuthorizationFilters\nfrom ....core.tokens import account_delete_token_generator\nfrom ....core.tracing import traced_atomic_transaction\nfrom ....core.utils.url import validate_storefront_url\nfrom ....giftcard.utils import assign_user_gift_cards\nfrom ....order.utils import match_orders_with_new_user\nfrom ...channel.utils import clean_channel\nfrom ...core.enums import LanguageCodeEnum\nfrom ...core.mutations import BaseMutation, ModelDeleteMutation, ModelMutation\nfrom ...core.types import AccountError, NonNullList\nfrom ...meta.mutations import MetadataInput\nfrom ...plugins.dataloaders import load_plugin_manager\nfrom ..enums import AddressTypeEnum\nfrom ..i18n import I18nMixin\nfrom ..types import Address, AddressInput, User\nfrom .base import (\n    INVALID_TOKEN,\n    BaseAddressDelete,\n    BaseAddressUpdate,\n    BaseCustomerCreate,\n)\n\n\nclass AccountBaseInput(graphene.InputObjectType):\n    first_name = graphene.String(description=\"Given name.\")\n    last_name = graphene.String(description=\"Family name.\")\n    language_code = graphene.Argument(\n        LanguageCodeEnum, required=False, description=\"User language code.\"\n    )\n\n\nclass AccountRegisterInput(AccountBaseInput):\n    email = graphene.String(description=\"The email address of the user.\", required=True)\n    password = graphene.String(description=\"Password.\", required=True)\n    first_name = graphene.String(description=\"Given name.\")\n    last_name = graphene.String(description=\"Family name.\")\n    redirect_url = graphene.String(\n        description=(\n            \"Base of frontend URL that will be needed to create confirmation URL.\"\n        ),\n        required=False,\n    )\n    language_code = graphene.Argument(\n        LanguageCodeEnum, required=False, description=\"User language code.\"\n    )\n    metadata = NonNullList(\n        MetadataInput,\n        description=\"User public metadata.\",\n        required=False,\n    )\n    channel = graphene.String(\n        description=(\n            \"Slug of a channel which will be used to notify users. Optional when \"\n            \"only one channel exists.\"\n        )\n    )\n\n\nclass AccountRegister(ModelMutation):\n    class Arguments:\n        input = AccountRegisterInput(\n            description=\"Fields required to create a user.\", required=True\n        )\n\n    requires_confirmation = graphene.Boolean(\n        description=\"Informs whether users need to confirm their email address.\"\n    )\n\n    class Meta:\n        description = \"Register a new user.\"\n        exclude = [\"password\"]\n        model = models.User\n        object_type = User\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def mutate(cls, root, info, **data):\n        response = super().mutate(root, info, **data)\n        response.requires_confirmation = settings.ENABLE_ACCOUNT_CONFIRMATION_BY_EMAIL\n        return response\n\n    @classmethod\n    def clean_input(cls, info, instance, data, input_cls=None):\n        data[\"metadata\"] = {\n            item[\"key\"]: item[\"value\"] for item in data.get(\"metadata\") or []\n        }\n        if not settings.ENABLE_ACCOUNT_CONFIRMATION_BY_EMAIL:\n            return super().clean_input(info, instance, data, input_cls=None)\n        elif not data.get(\"redirect_url\"):\n            raise ValidationError(\n                {\n                    \"redirect_url\": ValidationError(\n                        \"This field is required.\", code=AccountErrorCode.REQUIRED\n                    )\n                }\n            )\n\n        try:\n            validate_storefront_url(data[\"redirect_url\"])\n        except ValidationError as error:\n            raise ValidationError(\n                {\n                    \"redirect_url\": ValidationError(\n                        error.message, code=AccountErrorCode.INVALID\n                    )\n                }\n            )\n\n        data[\"channel\"] = clean_channel(\n            data.get(\"channel\"), error_class=AccountErrorCode\n        ).slug\n\n        password = data[\"password\"]\n        try:\n            password_validation.validate_password(password, instance)\n        except ValidationError as error:\n            raise ValidationError({\"password\": error})\n\n        data[\"language_code\"] = data.get(\"language_code\", settings.LANGUAGE_CODE)\n        return super().clean_input(info, instance, data, input_cls=None)\n\n    @classmethod\n    @traced_atomic_transaction()\n    def save(cls, info, user, cleaned_input):\n        password = cleaned_input[\"password\"]\n        user.set_password(password)\n        user.search_document = search.prepare_user_search_document_value(\n            user, attach_addresses_data=False\n        )\n        manager = load_plugin_manager(info.context)\n        if settings.ENABLE_ACCOUNT_CONFIRMATION_BY_EMAIL:\n            user.is_active = False\n            user.save()\n            notifications.send_account_confirmation(\n                user,\n                cleaned_input[\"redirect_url\"],\n                manager,\n                channel_slug=cleaned_input[\"channel\"],\n            )\n        else:\n            user.save()\n\n        account_events.customer_account_created_event(user=user)\n        manager.customer_created(customer=user)\n\n\nclass AccountInput(AccountBaseInput):\n    default_billing_address = AddressInput(\n        description=\"Billing address of the customer.\"\n    )\n    default_shipping_address = AddressInput(\n        description=\"Shipping address of the customer.\"\n    )\n\n\nclass AccountUpdate(BaseCustomerCreate):\n    class Arguments:\n        input = AccountInput(\n            description=\"Fields required to update the account of the logged-in user.\",\n            required=True,\n        )\n\n    class Meta:\n        description = \"Updates the account of the logged-in user.\"\n        exclude = [\"password\"]\n        model = models.User\n        object_type = User\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def perform_mutation(cls, root, info, **data):\n        user = info.context.user\n        data[\"id\"] = graphene.Node.to_global_id(\"User\", user.id)\n        return super().perform_mutation(root, info, **data)\n\n\nclass AccountRequestDeletion(BaseMutation):\n    class Arguments:\n        redirect_url = graphene.String(\n            required=True,\n            description=(\n                \"URL of a view where users should be redirected to \"\n                \"delete their account. URL in RFC 1808 format.\"\n            ),\n        )\n        channel = graphene.String(\n            description=(\n                \"Slug of a channel which will be used to notify users. Optional when \"\n                \"only one channel exists.\"\n            )\n        )\n\n    class Meta:\n        description = (\n            \"Sends an email with the account removal link for the logged-in user.\"\n        )\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n        redirect_url = data[\"redirect_url\"]\n        try:\n            validate_storefront_url(redirect_url)\n        except ValidationError as error:\n            raise ValidationError(\n                {\"redirect_url\": error}, code=AccountErrorCode.INVALID\n            )\n        channel_slug = clean_channel(\n            data.get(\"channel\"), error_class=AccountErrorCode\n        ).slug\n        manager = load_plugin_manager(info.context)\n        notifications.send_account_delete_confirmation_notification(\n            redirect_url, user, manager, channel_slug=channel_slug\n        )\n        return AccountRequestDeletion()\n\n\nclass AccountDelete(ModelDeleteMutation):\n    class Arguments:\n        token = graphene.String(\n            description=(\n                \"A one-time token required to remove account. \"\n                \"Sent by email using AccountRequestDeletion mutation.\"\n            ),\n            required=True,\n        )\n\n    class Meta:\n        description = \"Remove user account.\"\n        model = models.User\n        object_type = User\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    def clean_instance(cls, info, instance):\n        super().clean_instance(info, instance)\n        if instance.is_staff:\n            raise ValidationError(\n                \"Cannot delete a staff account.\",\n                code=AccountErrorCode.DELETE_STAFF_ACCOUNT,\n            )\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n        cls.clean_instance(info, user)\n\n        token = data.pop(\"token\")\n        if not account_delete_token_generator.check_token(user, token):\n            raise ValidationError(\n                {\"token\": ValidationError(INVALID_TOKEN, code=AccountErrorCode.INVALID)}\n            )\n\n        db_id = user.id\n\n        user.delete()\n        # After the instance is deleted, set its ID to the original database's\n        # ID so that the success response contains ID of the deleted object.\n        user.id = db_id\n        return cls.success_response(user)\n\n\nclass AccountAddressCreate(ModelMutation, I18nMixin):\n    user = graphene.Field(\n        User, description=\"A user instance for which the address was created.\"\n    )\n\n    class Arguments:\n        input = AddressInput(\n            description=\"Fields required to create address.\", required=True\n        )\n        type = AddressTypeEnum(\n            required=False,\n            description=(\n                \"A type of address. If provided, the new address will be \"\n                \"automatically assigned as the customer's default address \"\n                \"of that type.\"\n            ),\n        )\n\n    class Meta:\n        description = \"Create a new address for the customer.\"\n        model = models.Address\n        object_type = Address\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, **data):\n        address_type = data.get(\"type\", None)\n        user = info.context.user\n        cleaned_input = cls.clean_input(\n            info=info, instance=Address(), data=data.get(\"input\")\n        )\n        address = cls.validate_address(cleaned_input, address_type=address_type)\n        cls.clean_instance(info, address)\n        cls.save(info, address, cleaned_input)\n        cls._save_m2m(info, address, cleaned_input)\n        if address_type:\n            manager = load_plugin_manager(info.context)\n            utils.change_user_default_address(user, address, address_type, manager)\n        return AccountAddressCreate(user=user, address=address)\n\n    @classmethod\n    def save(cls, info, instance, cleaned_input):\n        super().save(info, instance, cleaned_input)\n        user = info.context.user\n        remove_the_oldest_user_address_if_address_limit_is_reached(user)\n        instance.user_addresses.add(user)\n        user.search_document = search.prepare_user_search_document_value(user)\n        user.save(update_fields=[\"search_document\", \"updated_at\"])\n        transaction.on_commit(\n            lambda: cls.trigger_post_account_address_create_webhooks(\n                info, instance, user\n            )\n        )\n\n    @classmethod\n    def trigger_post_account_address_create_webhooks(cls, info, address, user):\n        manager = load_plugin_manager(info.context)\n        manager.customer_updated(user)\n        manager.address_created(address)\n\n\nclass AccountAddressUpdate(BaseAddressUpdate):\n    class Meta:\n        auto_permission_message = False\n        description = (\n            \"Updates an address of the logged-in user. Requires one of the following \"\n            \"permissions: MANAGE_USERS, IS_OWNER.\"\n        )\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        model = models.Address\n        object_type = Address\n\n\nclass AccountAddressDelete(BaseAddressDelete):\n    class Meta:\n        auto_permission_message = False\n        description = (\n            \"Delete an address of the logged-in user. Requires one of the following \"\n            \"permissions: MANAGE_USERS, IS_OWNER.\"\n        )\n        model = models.Address\n        object_type = Address\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n\nclass AccountSetDefaultAddress(BaseMutation):\n    user = graphene.Field(User, description=\"An updated user instance.\")\n\n    class Arguments:\n        id = graphene.ID(\n            required=True, description=\"ID of the address to set as default.\"\n        )\n        type = AddressTypeEnum(required=True, description=\"The type of address.\")\n\n    class Meta:\n        description = \"Sets a default address for the authenticated user.\"\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        address = cls.get_node_or_error(info, data.get(\"id\"), Address)\n        user = info.context.user\n\n        if not user.addresses.filter(pk=address.pk).exists():\n            raise ValidationError(\n                {\n                    \"id\": ValidationError(\n                        \"The address doesn't belong to that user.\",\n                        code=AccountErrorCode.INVALID,\n                    )\n                }\n            )\n\n        if data.get(\"type\") == AddressTypeEnum.BILLING.value:\n            address_type = AddressType.BILLING\n        else:\n            address_type = AddressType.SHIPPING\n        manager = load_plugin_manager(info.context)\n        utils.change_user_default_address(user, address, address_type, manager)\n        manager.customer_updated(user)\n        return cls(user=user)\n\n\nclass RequestEmailChange(BaseMutation):\n    user = graphene.Field(User, description=\"A user instance.\")\n\n    class Arguments:\n        password = graphene.String(required=True, description=\"User password.\")\n        new_email = graphene.String(required=True, description=\"New user email.\")\n        redirect_url = graphene.String(\n            required=True,\n            description=(\n                \"URL of a view where users should be redirected to \"\n                \"update the email address. URL in RFC 1808 format.\"\n            ),\n        )\n        channel = graphene.String(\n            description=(\n                \"Slug of a channel which will be used to notify users. Optional when \"\n                \"only one channel exists.\"\n            )\n        )\n\n    class Meta:\n        description = \"Request email change of the logged in user.\"\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n        password = data[\"password\"]\n        new_email = data[\"new_email\"]\n        redirect_url = data[\"redirect_url\"]\n\n        if not user.check_password(password):\n            raise ValidationError(\n                {\n                    \"password\": ValidationError(\n                        \"Password isn't valid.\",\n                        code=AccountErrorCode.INVALID_CREDENTIALS,\n                    )\n                }\n            )\n        if models.User.objects.filter(email=new_email).exists():\n            raise ValidationError(\n                {\n                    \"new_email\": ValidationError(\n                        \"Email is used by other user.\", code=AccountErrorCode.UNIQUE\n                    )\n                }\n            )\n        try:\n            validate_storefront_url(redirect_url)\n        except ValidationError as error:\n            raise ValidationError(\n                {\"redirect_url\": error}, code=AccountErrorCode.INVALID\n            )\n        channel_slug = clean_channel(\n            data.get(\"channel\"),\n            error_class=AccountErrorCode,\n        ).slug\n\n        token_payload = {\n            \"old_email\": user.email,\n            \"new_email\": new_email,\n            \"user_pk\": user.pk,\n        }\n        token = create_token(token_payload, settings.JWT_TTL_REQUEST_EMAIL_CHANGE)\n        manager = load_plugin_manager(info.context)\n        notifications.send_request_user_change_email_notification(\n            redirect_url,\n            user,\n            new_email,\n            token,\n            manager,\n            channel_slug=channel_slug,\n        )\n        return RequestEmailChange(user=user)\n\n\nclass ConfirmEmailChange(BaseMutation):\n    user = graphene.Field(User, description=\"A user instance with a new email.\")\n\n    class Arguments:\n        token = graphene.String(\n            description=\"A one-time token required to change the email.\", required=True\n        )\n        channel = graphene.String(\n            description=(\n                \"Slug of a channel which will be used to notify users. Optional when \"\n                \"only one channel exists.\"\n            )\n        )\n\n    class Meta:\n        description = \"Confirm the email change of the logged-in user.\"\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    def get_token_payload(cls, token):\n        try:\n            payload = jwt_decode(token)\n        except jwt.PyJWTError:\n            raise ValidationError(\n                {\n                    \"token\": ValidationError(\n                        \"Invalid or expired token.\",\n                        code=AccountErrorCode.JWT_INVALID_TOKEN,\n                    )\n                }\n            )\n        return payload\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n        token = data[\"token\"]\n\n        payload = cls.get_token_payload(token)\n        new_email = payload[\"new_email\"]\n        old_email = payload[\"old_email\"]\n\n        if models.User.objects.filter(email=new_email).exists():\n            raise ValidationError(\n                {\n                    \"new_email\": ValidationError(\n                        \"Email is used by other user.\", code=AccountErrorCode.UNIQUE\n                    )\n                }\n            )\n\n        user.email = new_email\n        user.search_document = search.prepare_user_search_document_value(user)\n        user.save(update_fields=[\"email\", \"search_document\", \"updated_at\"])\n\n        channel_slug = clean_channel(\n            data.get(\"channel\"), error_class=AccountErrorCode\n        ).slug\n\n        assign_user_gift_cards(user)\n        match_orders_with_new_user(user)\n        manager = load_plugin_manager(info.context)\n        notifications.send_user_change_email_notification(\n            old_email, user, manager, channel_slug=channel_slug\n        )\n        manager.customer_updated(user)\n        return ConfirmEmailChange(user=user)\n", "import graphene\nfrom django.contrib.auth import password_validation\nfrom django.contrib.auth.tokens import default_token_generator\nfrom django.core.exceptions import ObjectDoesNotExist, ValidationError\n\nfrom ....account import events as account_events\nfrom ....account import models\nfrom ....account.error_codes import AccountErrorCode\nfrom ....account.notifications import (\n    send_password_reset_notification,\n    send_set_password_notification,\n)\nfrom ....account.search import prepare_user_search_document_value\nfrom ....checkout import AddressType\nfrom ....core.exceptions import PermissionDenied\nfrom ....core.permissions import AccountPermissions, AuthorizationFilters\nfrom ....core.tracing import traced_atomic_transaction\nfrom ....core.utils.url import validate_storefront_url\nfrom ....giftcard.utils import assign_user_gift_cards\nfrom ....graphql.utils import get_user_or_app_from_context\nfrom ....order.utils import match_orders_with_new_user\nfrom ...account.i18n import I18nMixin\nfrom ...account.types import Address, AddressInput, User\nfrom ...app.dataloaders import load_app\nfrom ...channel.utils import clean_channel, validate_channel\nfrom ...core.context import set_mutation_flag_in_context\nfrom ...core.enums import LanguageCodeEnum\nfrom ...core.mutations import (\n    BaseMutation,\n    ModelDeleteMutation,\n    ModelMutation,\n    validation_error_to_error_type,\n)\nfrom ...core.types import AccountError\nfrom ...plugins.dataloaders import load_plugin_manager\nfrom .authentication import CreateToken\n\nBILLING_ADDRESS_FIELD = \"default_billing_address\"\nSHIPPING_ADDRESS_FIELD = \"default_shipping_address\"\nINVALID_TOKEN = \"Invalid or expired token.\"\n\n\ndef check_can_edit_address(context, address):\n    \"\"\"Determine whether the user or app can edit the given address.\n\n    This method assumes that an address can be edited by:\n    - apps with manage users permission\n    - staff with manage users permission\n    - customers associated to the given address.\n    \"\"\"\n    requester = get_user_or_app_from_context(context)\n    if requester.has_perm(AccountPermissions.MANAGE_USERS):\n        return True\n    app = load_app(context)\n    if not app and not context.user.is_anonymous:\n        is_owner = requester.addresses.filter(pk=address.pk).exists()\n        if is_owner:\n            return True\n    raise PermissionDenied(\n        permissions=[AccountPermissions.MANAGE_USERS, AuthorizationFilters.OWNER]\n    )\n\n\nclass SetPassword(CreateToken):\n    class Arguments:\n        token = graphene.String(\n            description=\"A one-time token required to set the password.\", required=True\n        )\n        email = graphene.String(required=True, description=\"Email of a user.\")\n        password = graphene.String(required=True, description=\"Password of a user.\")\n\n    class Meta:\n        description = (\n            \"Sets the user's password from the token sent by email \"\n            \"using the RequestPasswordReset mutation.\"\n        )\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def mutate(cls, root, info, **data):\n        set_mutation_flag_in_context(info.context)\n        manager = load_plugin_manager(info.context)\n        result = manager.perform_mutation(\n            mutation_cls=cls, root=root, info=info, data=data\n        )\n        if result is not None:\n            return result\n\n        email = data[\"email\"]\n        password = data[\"password\"]\n        token = data[\"token\"]\n\n        try:\n            cls._set_password_for_user(email, password, token)\n        except ValidationError as e:\n            errors = validation_error_to_error_type(e, AccountError)\n            return cls.handle_typed_errors(errors)\n        return super().mutate(root, info, **data)\n\n    @classmethod\n    def _set_password_for_user(cls, email, password, token):\n        try:\n            user = models.User.objects.get(email=email)\n        except ObjectDoesNotExist:\n            raise ValidationError(\n                {\n                    \"email\": ValidationError(\n                        \"User doesn't exist\", code=AccountErrorCode.NOT_FOUND\n                    )\n                }\n            )\n        if not default_token_generator.check_token(user, token):\n            raise ValidationError(\n                {\"token\": ValidationError(INVALID_TOKEN, code=AccountErrorCode.INVALID)}\n            )\n        try:\n            password_validation.validate_password(password, user)\n        except ValidationError as error:\n            raise ValidationError({\"password\": error})\n        user.set_password(password)\n        user.save(update_fields=[\"password\", \"updated_at\"])\n        account_events.customer_password_reset_event(user=user)\n\n\nclass RequestPasswordReset(BaseMutation):\n    class Arguments:\n        email = graphene.String(\n            required=True,\n            description=\"Email of the user that will be used for password recovery.\",\n        )\n        redirect_url = graphene.String(\n            required=True,\n            description=(\n                \"URL of a view where users should be redirected to \"\n                \"reset the password. URL in RFC 1808 format.\"\n            ),\n        )\n        channel = graphene.String(\n            description=(\n                \"Slug of a channel which will be used for notify user. Optional when \"\n                \"only one channel exists.\"\n            )\n        )\n\n    class Meta:\n        description = \"Sends an email with the account password modification link.\"\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def clean_user(cls, email, redirect_url):\n\n        try:\n            validate_storefront_url(redirect_url)\n        except ValidationError as error:\n            raise ValidationError(\n                {\"redirect_url\": error}, code=AccountErrorCode.INVALID\n            )\n\n        try:\n            user = models.User.objects.get(email=email)\n        except ObjectDoesNotExist:\n            raise ValidationError(\n                {\n                    \"email\": ValidationError(\n                        \"User with this email doesn't exist\",\n                        code=AccountErrorCode.NOT_FOUND,\n                    )\n                }\n            )\n        if not user.is_active:\n            raise ValidationError(\n                {\n                    \"email\": ValidationError(\n                        \"User with this email is inactive\",\n                        code=AccountErrorCode.INACTIVE,\n                    )\n                }\n            )\n        return user\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        email = data[\"email\"]\n        redirect_url = data[\"redirect_url\"]\n        channel_slug = data.get(\"channel\")\n        user = cls.clean_user(email, redirect_url)\n\n        if not user.is_staff:\n            channel_slug = clean_channel(\n                channel_slug, error_class=AccountErrorCode\n            ).slug\n        elif channel_slug is not None:\n            channel_slug = validate_channel(\n                channel_slug, error_class=AccountErrorCode\n            ).slug\n        manager = load_plugin_manager(info.context)\n        send_password_reset_notification(\n            redirect_url,\n            user,\n            manager,\n            channel_slug=channel_slug,\n            staff=user.is_staff,\n        )\n        return RequestPasswordReset()\n\n\nclass ConfirmAccount(BaseMutation):\n    user = graphene.Field(User, description=\"An activated user account.\")\n\n    class Arguments:\n        token = graphene.String(\n            description=\"A one-time token required to confirm the account.\",\n            required=True,\n        )\n        email = graphene.String(\n            description=\"E-mail of the user performing account confirmation.\",\n            required=True,\n        )\n\n    class Meta:\n        description = (\n            \"Confirm user account with token sent by email during registration.\"\n        )\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        try:\n            user = models.User.objects.get(email=data[\"email\"])\n        except ObjectDoesNotExist:\n            raise ValidationError(\n                {\n                    \"email\": ValidationError(\n                        \"User with this email doesn't exist\",\n                        code=AccountErrorCode.NOT_FOUND,\n                    )\n                }\n            )\n\n        if not default_token_generator.check_token(user, data[\"token\"]):\n            raise ValidationError(\n                {\"token\": ValidationError(INVALID_TOKEN, code=AccountErrorCode.INVALID)}\n            )\n\n        user.is_active = True\n        user.save(update_fields=[\"is_active\", \"updated_at\"])\n\n        match_orders_with_new_user(user)\n        assign_user_gift_cards(user)\n\n        return ConfirmAccount(user=user)\n\n\nclass PasswordChange(BaseMutation):\n    user = graphene.Field(User, description=\"A user instance with a new password.\")\n\n    class Arguments:\n        old_password = graphene.String(\n            required=True, description=\"Current user password.\"\n        )\n        new_password = graphene.String(required=True, description=\"New user password.\")\n\n    class Meta:\n        description = \"Change the password of the logged in user.\"\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n        old_password = data[\"old_password\"]\n        new_password = data[\"new_password\"]\n\n        if not user.check_password(old_password):\n            raise ValidationError(\n                {\n                    \"old_password\": ValidationError(\n                        \"Old password isn't valid.\",\n                        code=AccountErrorCode.INVALID_CREDENTIALS,\n                    )\n                }\n            )\n        try:\n            password_validation.validate_password(new_password, user)\n        except ValidationError as error:\n            raise ValidationError({\"new_password\": error})\n\n        user.set_password(new_password)\n        user.save(update_fields=[\"password\", \"updated_at\"])\n        account_events.customer_password_changed_event(user=user)\n        return PasswordChange(user=user)\n\n\nclass BaseAddressUpdate(ModelMutation, I18nMixin):\n    \"\"\"Base mutation for address update used by staff and account.\"\"\"\n\n    user = graphene.Field(\n        User, description=\"A user object for which the address was edited.\"\n    )\n\n    class Arguments:\n        id = graphene.ID(description=\"ID of the address to update.\", required=True)\n        input = AddressInput(\n            description=\"Fields required to update the address.\", required=True\n        )\n\n    class Meta:\n        abstract = True\n\n    @classmethod\n    def clean_input(cls, info, instance, data):\n        # Method check_permissions cannot be used for permission check, because\n        # it doesn't have the address instance.\n        check_can_edit_address(info.context, instance)\n        return super().clean_input(info, instance, data)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        instance = cls.get_instance(info, **data)\n        cleaned_input = cls.clean_input(\n            info=info, instance=instance, data=data.get(\"input\")\n        )\n        address = cls.validate_address(cleaned_input, instance=instance)\n        cls.clean_instance(info, address)\n        cls.save(info, address, cleaned_input)\n        cls._save_m2m(info, address, cleaned_input)\n\n        user = address.user_addresses.first()\n        user.search_document = prepare_user_search_document_value(user)\n        user.save(update_fields=[\"search_document\", \"updated_at\"])\n        manager = load_plugin_manager(info.context)\n        manager.customer_updated(user)\n        address = manager.change_user_address(address, None, user)\n        manager.address_updated(address)\n\n        success_response = cls.success_response(address)\n        success_response.user = user\n        success_response.address = address\n        return success_response\n\n\nclass BaseAddressDelete(ModelDeleteMutation):\n    \"\"\"Base mutation for address delete used by staff and customers.\"\"\"\n\n    user = graphene.Field(\n        User, description=\"A user instance for which the address was deleted.\"\n    )\n\n    class Arguments:\n        id = graphene.ID(required=True, description=\"ID of the address to delete.\")\n\n    class Meta:\n        abstract = True\n\n    @classmethod\n    def clean_instance(cls, info, instance):\n        # Method check_permissions cannot be used for permission check, because\n        # it doesn't have the address instance.\n        check_can_edit_address(info.context, instance)\n        return super().clean_instance(info, instance)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        if not cls.check_permissions(info.context):\n            raise PermissionDenied()\n\n        node_id = data.get(\"id\")\n        instance = cls.get_node_or_error(info, node_id, Address)\n        if instance:\n            cls.clean_instance(info, instance)\n\n        db_id = instance.id\n\n        # Return the first user that the address is assigned to. There is M2M\n        # relation between users and addresses, but in most cases address is\n        # related to only one user.\n        user = instance.user_addresses.first()\n\n        instance.delete()\n        instance.id = db_id\n\n        # Refresh the user instance to clear the default addresses. If the\n        # deleted address was used as default, it would stay cached in the\n        # user instance and the invalid ID returned in the response might cause\n        # an error.\n        user.refresh_from_db()\n\n        user.search_document = prepare_user_search_document_value(user)\n        user.save(update_fields=[\"search_document\", \"updated_at\"])\n\n        response = cls.success_response(instance)\n\n        response.user = user\n        manager = load_plugin_manager(info.context)\n        manager.customer_updated(user)\n        manager.address_deleted(instance)\n        return response\n\n\nclass UserInput(graphene.InputObjectType):\n    first_name = graphene.String(description=\"Given name.\")\n    last_name = graphene.String(description=\"Family name.\")\n    email = graphene.String(description=\"The unique email address of the user.\")\n    is_active = graphene.Boolean(required=False, description=\"User account is active.\")\n    note = graphene.String(description=\"A note about the user.\")\n\n\nclass UserAddressInput(graphene.InputObjectType):\n    default_billing_address = AddressInput(\n        description=\"Billing address of the customer.\"\n    )\n    default_shipping_address = AddressInput(\n        description=\"Shipping address of the customer.\"\n    )\n\n\nclass CustomerInput(UserInput, UserAddressInput):\n    language_code = graphene.Field(\n        LanguageCodeEnum, required=False, description=\"User language code.\"\n    )\n\n\nclass UserCreateInput(CustomerInput):\n    redirect_url = graphene.String(\n        description=(\n            \"URL of a view where users should be redirected to \"\n            \"set the password. URL in RFC 1808 format.\"\n        )\n    )\n    channel = graphene.String(\n        description=(\n            \"Slug of a channel which will be used for notify user. Optional when \"\n            \"only one channel exists.\"\n        )\n    )\n\n\nclass BaseCustomerCreate(ModelMutation, I18nMixin):\n    \"\"\"Base mutation for customer create used by staff and account.\"\"\"\n\n    class Arguments:\n        input = UserCreateInput(\n            description=\"Fields required to create a customer.\", required=True\n        )\n\n    class Meta:\n        abstract = True\n\n    @classmethod\n    def clean_input(cls, info, instance, data):\n        shipping_address_data = data.pop(SHIPPING_ADDRESS_FIELD, None)\n        billing_address_data = data.pop(BILLING_ADDRESS_FIELD, None)\n        cleaned_input = super().clean_input(info, instance, data)\n\n        if shipping_address_data:\n            shipping_address = cls.validate_address(\n                shipping_address_data,\n                address_type=AddressType.SHIPPING,\n                instance=getattr(instance, SHIPPING_ADDRESS_FIELD),\n                info=info,\n            )\n            cleaned_input[SHIPPING_ADDRESS_FIELD] = shipping_address\n\n        if billing_address_data:\n            billing_address = cls.validate_address(\n                billing_address_data,\n                address_type=AddressType.BILLING,\n                instance=getattr(instance, BILLING_ADDRESS_FIELD),\n                info=info,\n            )\n            cleaned_input[BILLING_ADDRESS_FIELD] = billing_address\n\n        if cleaned_input.get(\"redirect_url\"):\n            try:\n                validate_storefront_url(cleaned_input.get(\"redirect_url\"))\n            except ValidationError as error:\n                raise ValidationError(\n                    {\"redirect_url\": error}, code=AccountErrorCode.INVALID\n                )\n\n        return cleaned_input\n\n    @classmethod\n    @traced_atomic_transaction()\n    def save(cls, info, instance, cleaned_input):\n        default_shipping_address = cleaned_input.get(SHIPPING_ADDRESS_FIELD)\n        manager = load_plugin_manager(info.context)\n        if default_shipping_address:\n            default_shipping_address = manager.change_user_address(\n                default_shipping_address, \"shipping\", instance\n            )\n            default_shipping_address.save()\n            instance.default_shipping_address = default_shipping_address\n        default_billing_address = cleaned_input.get(BILLING_ADDRESS_FIELD)\n        if default_billing_address:\n            default_billing_address = manager.change_user_address(\n                default_billing_address, \"billing\", instance\n            )\n            default_billing_address.save()\n            instance.default_billing_address = default_billing_address\n\n        is_creation = instance.pk is None\n        super().save(info, instance, cleaned_input)\n        if default_billing_address:\n            instance.addresses.add(default_billing_address)\n        if default_shipping_address:\n            instance.addresses.add(default_shipping_address)\n\n        instance.search_document = prepare_user_search_document_value(instance)\n        instance.save(update_fields=[\"search_document\", \"updated_at\"])\n\n        # The instance is a new object in db, create an event\n        if is_creation:\n            manager.customer_created(customer=instance)\n            account_events.customer_account_created_event(user=instance)\n        else:\n            manager.customer_updated(instance)\n\n        if cleaned_input.get(\"redirect_url\"):\n            channel_slug = cleaned_input.get(\"channel\")\n            if not instance.is_staff:\n                channel_slug = clean_channel(\n                    channel_slug, error_class=AccountErrorCode\n                ).slug\n            elif channel_slug is not None:\n                channel_slug = validate_channel(\n                    channel_slug, error_class=AccountErrorCode\n                ).slug\n            send_set_password_notification(\n                cleaned_input.get(\"redirect_url\"),\n                instance,\n                manager,\n                channel_slug,\n            )\n", "from dataclasses import dataclass\nfrom typing import Dict, List, Optional, Type\n\nimport graphene\nfrom django.core.exceptions import ValidationError\nfrom django.db import transaction\nfrom django.db.models import Model\n\nfrom ...core.permissions import MenuPermissions, SitePermissions\nfrom ...core.tracing import traced_atomic_transaction\nfrom ...menu import models\nfrom ...menu.error_codes import MenuErrorCode\nfrom ...page import models as page_models\nfrom ...product import models as product_models\nfrom ..channel import ChannelContext\nfrom ..core.mutations import BaseMutation, ModelDeleteMutation, ModelMutation\nfrom ..core.types import MenuError, NonNullList\nfrom ..core.utils import validate_slug_and_generate_if_needed\nfrom ..core.utils.reordering import perform_reordering\nfrom ..page.types import Page\nfrom ..plugins.dataloaders import load_plugin_manager\nfrom ..product.types import Category, Collection\nfrom ..site.dataloaders import load_site\nfrom .dataloaders import MenuItemsByParentMenuLoader\nfrom .enums import NavigationType\nfrom .types import Menu, MenuItem, MenuItemMoveInput\n\n\nclass MenuItemInput(graphene.InputObjectType):\n    name = graphene.String(description=\"Name of the menu item.\")\n    url = graphene.String(description=\"URL of the pointed item.\")\n    category = graphene.ID(\n        description=\"Category to which item points.\", name=\"category\"\n    )\n    collection = graphene.ID(\n        description=\"Collection to which item points.\", name=\"collection\"\n    )\n    page = graphene.ID(description=\"Page to which item points.\", name=\"page\")\n\n\nclass MenuItemCreateInput(MenuItemInput):\n    name = graphene.String(description=\"Name of the menu item.\", required=True)\n    menu = graphene.ID(\n        description=\"Menu to which item belongs.\", name=\"menu\", required=True\n    )\n    parent = graphene.ID(\n        description=\"ID of the parent menu. If empty, menu will be top level menu.\",\n        name=\"parent\",\n    )\n\n\nclass MenuCreateInput(graphene.InputObjectType):\n    name = graphene.String(description=\"Name of the menu.\", required=True)\n    slug = graphene.String(\n        description=\"Slug of the menu. Will be generated if not provided.\",\n        required=False,\n    )\n    items = NonNullList(MenuItemInput, description=\"List of menu items.\")\n\n\nclass MenuCreate(ModelMutation):\n    class Arguments:\n        input = MenuCreateInput(\n            required=True, description=\"Fields required to create a menu.\"\n        )\n\n    class Meta:\n        description = \"Creates a new Menu.\"\n        model = models.Menu\n        object_type = Menu\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def clean_input(cls, info, instance, data):\n        cleaned_input = super().clean_input(info, instance, data)\n        try:\n            cleaned_input = validate_slug_and_generate_if_needed(\n                instance, \"name\", cleaned_input\n            )\n        except ValidationError as error:\n            error.code = MenuErrorCode.REQUIRED.value\n            raise ValidationError({\"slug\": error})\n\n        items = []\n        for item in cleaned_input.get(\"items\", []):\n            category = item.get(\"category\")\n            collection = item.get(\"collection\")\n            page = item.get(\"page\")\n            url = item.get(\"url\")\n            if len([i for i in [category, collection, page, url] if i]) > 1:\n                raise ValidationError(\n                    {\n                        \"items\": ValidationError(\n                            \"More than one item provided.\",\n                            code=MenuErrorCode.TOO_MANY_MENU_ITEMS,\n                        )\n                    }\n                )\n\n            if category:\n                category = cls.get_node_or_error(\n                    info, category, field=\"items\", only_type=Category\n                )\n                item[\"category\"] = category\n            elif collection:\n                collection = cls.get_node_or_error(\n                    info, collection, field=\"items\", only_type=Collection\n                )\n                item[\"collection\"] = collection\n            elif page:\n                page = cls.get_node_or_error(info, page, field=\"items\", only_type=Page)\n                item[\"page\"] = page\n            elif not url:\n                raise ValidationError(\n                    {\n                        \"items\": ValidationError(\n                            \"No menu item provided.\",\n                            code=MenuErrorCode.NO_MENU_ITEM_PROVIDED,\n                        )\n                    }\n                )\n            items.append(item)\n        cleaned_input[\"items\"] = items\n        return cleaned_input\n\n    @classmethod\n    def _save_m2m(cls, info, instance, cleaned_data):\n        super()._save_m2m(info, instance, cleaned_data)\n        items = cleaned_data.get(\"items\", [])\n        for item in items:\n            instance.items.create(**item)\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_created(instance)\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n\nclass MenuInput(graphene.InputObjectType):\n    name = graphene.String(description=\"Name of the menu.\")\n    slug = graphene.String(description=\"Slug of the menu.\", required=False)\n\n\nclass MenuUpdate(ModelMutation):\n    class Arguments:\n        id = graphene.ID(required=True, description=\"ID of a menu to update.\")\n        input = MenuInput(\n            required=True, description=\"Fields required to update a menu.\"\n        )\n\n    class Meta:\n        description = \"Updates a menu.\"\n        model = models.Menu\n        object_type = Menu\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_updated(instance)\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n\nclass MenuDelete(ModelDeleteMutation):\n    class Arguments:\n        id = graphene.ID(required=True, description=\"ID of a menu to delete.\")\n\n    class Meta:\n        description = \"Deletes a menu.\"\n        model = models.Menu\n        object_type = Menu\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_deleted(instance)\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n\ndef _validate_menu_item_instance(\n    cleaned_input: dict, field: str, expected_model: Type[Model]\n):\n    \"\"\"Check if the value to assign as a menu item matches the expected model.\"\"\"\n    item = cleaned_input.get(field)\n    if item:\n        if not isinstance(item, expected_model):\n            msg = (\n                f\"Enter a valid {expected_model._meta.verbose_name} ID \"\n                f\"(got {item._meta.verbose_name} ID).\"\n            )\n            raise ValidationError(\n                {\n                    field: ValidationError(\n                        msg, code=MenuErrorCode.INVALID_MENU_ITEM.value\n                    )\n                }\n            )\n\n\nclass MenuItemCreate(ModelMutation):\n    class Arguments:\n        input = MenuItemCreateInput(\n            required=True,\n            description=(\n                \"Fields required to update a menu item. Only one of `url`, `category`, \"\n                \"`page`, `collection` is allowed per item.\"\n            ),\n        )\n\n    class Meta:\n        description = \"Creates a new menu item.\"\n        model = models.MenuItem\n        object_type = MenuItem\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_item_created(instance)\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n    @classmethod\n    def clean_input(cls, info, instance, data):\n        cleaned_input = super().clean_input(info, instance, data)\n\n        _validate_menu_item_instance(cleaned_input, \"page\", page_models.Page)\n        _validate_menu_item_instance(\n            cleaned_input, \"collection\", product_models.Collection\n        )\n        _validate_menu_item_instance(cleaned_input, \"category\", product_models.Category)\n\n        items = [\n            cleaned_input.get(\"page\"),\n            cleaned_input.get(\"collection\"),\n            cleaned_input.get(\"url\"),\n            cleaned_input.get(\"category\"),\n        ]\n        items = [item for item in items if item is not None]\n        if len(items) > 1:\n            raise ValidationError(\n                \"More than one item provided.\", code=MenuErrorCode.TOO_MANY_MENU_ITEMS\n            )\n        return cleaned_input\n\n\nclass MenuItemUpdate(MenuItemCreate):\n    class Arguments:\n        id = graphene.ID(required=True, description=\"ID of a menu item to update.\")\n        input = MenuItemInput(\n            required=True,\n            description=(\n                \"Fields required to update a menu item. Only one of `url`, `category`, \"\n                \"`page`, `collection` is allowed per item.\"\n            ),\n        )\n\n    class Meta:\n        description = \"Updates a menu item.\"\n        model = models.MenuItem\n        object_type = MenuItem\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def construct_instance(cls, instance, cleaned_data):\n        # Only one item can be assigned per menu item\n        instance.page = None\n        instance.collection = None\n        instance.category = None\n        instance.url = None\n        return super().construct_instance(instance, cleaned_data)\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_item_updated(instance)\n\n\nclass MenuItemDelete(ModelDeleteMutation):\n    class Arguments:\n        id = graphene.ID(required=True, description=\"ID of a menu item to delete.\")\n\n    class Meta:\n        description = \"Deletes a menu item.\"\n        model = models.MenuItem\n        object_type = MenuItem\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_item_deleted(instance)\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n\n@dataclass(frozen=True)\nclass _MenuMoveOperation:\n    menu_item: models.MenuItem\n    parent_changed: bool\n    new_parent: Optional[models.MenuItem]\n    sort_order: int\n\n\nclass MenuItemMove(BaseMutation):\n    menu = graphene.Field(Menu, description=\"Assigned menu to move within.\")\n\n    class Arguments:\n        menu = graphene.ID(required=True, description=\"ID of the menu.\")\n        moves = NonNullList(\n            MenuItemMoveInput, required=True, description=\"The menu position data.\"\n        )\n\n    class Meta:\n        description = \"Moves items of menus.\"\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n    @staticmethod\n    def clean_move(move: MenuItemMoveInput):\n        \"\"\"Validate if the given move could be possibly possible.\"\"\"\n        if move.parent_id:\n            if move.item_id == move.parent_id:\n                raise ValidationError(\n                    {\n                        \"parent_id\": ValidationError(\n                            \"Cannot assign a node to itself.\",\n                            code=MenuErrorCode.CANNOT_ASSIGN_NODE.value,\n                        )\n                    }\n                )\n\n    @staticmethod\n    def clean_operation(operation: _MenuMoveOperation):\n        \"\"\"Validate if the given move will be actually possible.\"\"\"\n\n        if operation.new_parent is not None:\n            if operation.menu_item.is_ancestor_of(operation.new_parent):\n                raise ValidationError(\n                    {\n                        \"parent_id\": ValidationError(\n                            (\n                                \"Cannot assign a node as child of \"\n                                \"one of its descendants.\"\n                            ),\n                            code=MenuErrorCode.CANNOT_ASSIGN_NODE.value,\n                        )\n                    }\n                )\n\n    @classmethod\n    def get_operation(\n        cls,\n        info,\n        menu_item_to_current_parent,\n        menu: models.Menu,\n        move: MenuItemMoveInput,\n    ) -> _MenuMoveOperation:\n        menu_item = cls.get_node_or_error(\n            info, move.item_id, field=\"item\", only_type=\"MenuItem\", qs=menu.items\n        )\n        new_parent, parent_changed = None, False\n\n        # we want to check if parent has changes in relation to previous operations\n        # as moves are performed sequentially\n        old_parent_id = (\n            menu_item_to_current_parent[menu_item.pk]\n            if menu_item.pk in menu_item_to_current_parent\n            else menu_item.parent_id\n        )\n\n        if move.parent_id is not None:\n            parent_pk = cls.get_global_id_or_error(\n                move.parent_id, only_type=MenuItem, field=\"parent_id\"\n            )\n            if int(parent_pk) != old_parent_id:\n                new_parent = cls.get_node_or_error(\n                    info,\n                    move.parent_id,\n                    field=\"parent_id\",\n                    only_type=MenuItem,\n                    qs=menu.items,\n                )\n                parent_changed = True\n        elif move.parent_id is None and old_parent_id is not None:\n            parent_changed = True\n\n        return _MenuMoveOperation(\n            menu_item=menu_item,\n            new_parent=new_parent,\n            parent_changed=parent_changed,\n            sort_order=move.sort_order,\n        )\n\n    @classmethod\n    def clean_moves(\n        cls, info, menu: models.Menu, move_operations: List[MenuItemMoveInput]\n    ) -> List[_MenuMoveOperation]:\n        operations = []\n        item_to_current_parent: Dict[int, Optional[models.MenuItem]] = {}\n        for move in move_operations:\n            cls.clean_move(move)\n            operation = cls.get_operation(info, item_to_current_parent, menu, move)\n            if operation.parent_changed:\n                cls.clean_operation(operation)\n                item_to_current_parent[operation.menu_item.id] = operation.new_parent\n            operations.append(operation)\n        return operations\n\n    @staticmethod\n    def perform_change_parent_operation(operation: _MenuMoveOperation):\n        menu_item = operation.menu_item\n\n        if not operation.parent_changed:\n            return\n\n        # we need to refresh item, as it might be changes in previous operations\n        # and in such case the parent and level values are invalid\n        menu_item.refresh_from_db()\n\n        # parent cache need to be update in case of the item parent is changed\n        # more than once\n        menu_item._mptt_meta.update_mptt_cached_fields(menu_item)\n\n        # Move the parent\n        menu_item.parent = operation.new_parent\n        menu_item.sort_order = None\n        menu_item.save()\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, **data):\n        menu: str = data[\"menu\"]\n        moves: List[MenuItemMoveInput] = data[\"moves\"]\n        qs = models.Menu.objects.prefetch_related(\"items\")\n        menu = cls.get_node_or_error(info, menu, only_type=Menu, field=\"menu\", qs=qs)\n\n        operations = cls.clean_moves(info, menu, moves)\n        manager = load_plugin_manager(info.context)\n        for operation in operations:\n            cls.perform_change_parent_operation(operation)\n\n            menu_item = operation.menu_item\n\n            if operation.sort_order:\n                perform_reordering(\n                    menu_item.get_ordering_queryset(),\n                    {menu_item.pk: operation.sort_order},\n                )\n\n            if operation.sort_order or operation.parent_changed:\n                transaction.on_commit(lambda: manager.menu_item_updated(menu_item))\n\n        menu = qs.get(pk=menu.pk)\n        MenuItemsByParentMenuLoader(info.context).clear(menu.id)\n        return MenuItemMove(menu=ChannelContext(node=menu, channel_slug=None))\n\n\nclass AssignNavigation(BaseMutation):\n    menu = graphene.Field(Menu, description=\"Assigned navigation menu.\")\n\n    class Arguments:\n        menu = graphene.ID(description=\"ID of the menu.\")\n        navigation_type = NavigationType(\n            description=\"Type of the navigation bar to assign the menu to.\",\n            required=True,\n        )\n\n    class Meta:\n        description = \"Assigns storefront's navigation menus.\"\n        permissions = (MenuPermissions.MANAGE_MENUS, SitePermissions.MANAGE_SETTINGS)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, navigation_type, menu=None):\n        site = load_site(info.context)\n        if menu is not None:\n            menu = cls.get_node_or_error(info, menu, field=\"menu\")\n\n        if navigation_type == NavigationType.MAIN:\n            site.settings.top_menu = menu\n            site.settings.save(update_fields=[\"top_menu\"])\n        elif navigation_type == NavigationType.SECONDARY:\n            site.settings.bottom_menu = menu\n            site.settings.save(update_fields=[\"bottom_menu\"])\n\n        if menu is None:\n            return AssignNavigation(menu=None)\n        return AssignNavigation(menu=ChannelContext(node=menu, channel_slug=None))\n", "from collections import defaultdict\nfrom typing import Iterable\n\nimport graphene\nfrom django.core.exceptions import ValidationError\nfrom django.db import transaction\nfrom django.db.models import Exists, OuterRef, Q, Subquery\nfrom django.db.models.fields import IntegerField\nfrom django.db.models.functions import Coalesce\nfrom graphene.types import InputObjectType\n\nfrom ....attribute import AttributeInputType\nfrom ....attribute import models as attribute_models\nfrom ....core.permissions import ProductPermissions, ProductTypePermissions\nfrom ....core.postgres import FlatConcatSearchVector\nfrom ....core.tracing import traced_atomic_transaction\nfrom ....order import events as order_events\nfrom ....order import models as order_models\nfrom ....order.tasks import recalculate_orders_task\nfrom ....product import models\nfrom ....product.error_codes import ProductErrorCode\nfrom ....product.search import (\n    prepare_product_search_vector_value,\n    update_product_search_vector,\n)\nfrom ....product.tasks import update_product_discounted_price_task\nfrom ....product.utils import delete_categories\nfrom ....product.utils.variants import generate_and_set_variant_name\nfrom ....warehouse import models as warehouse_models\nfrom ....warehouse.error_codes import StockErrorCode\nfrom ...app.dataloaders import load_app\nfrom ...channel import ChannelContext\nfrom ...channel.types import Channel\nfrom ...core.mutations import BaseMutation, ModelBulkDeleteMutation, ModelMutation\nfrom ...core.types import (\n    BulkProductError,\n    BulkStockError,\n    CollectionError,\n    NonNullList,\n    ProductError,\n    StockError,\n)\nfrom ...core.utils import get_duplicated_values\nfrom ...core.validators import validate_price_precision\nfrom ...plugins.dataloaders import load_plugin_manager\nfrom ...warehouse.dataloaders import (\n    StocksWithAvailableQuantityByProductVariantIdCountryCodeAndChannelLoader,\n)\nfrom ...warehouse.types import Warehouse\nfrom ..mutations.channels import ProductVariantChannelListingAddInput\nfrom ..mutations.products import (\n    AttributeAssignmentMixin,\n    ProductVariantCreate,\n    ProductVariantInput,\n    StockInput,\n)\nfrom ..types import (\n    Category,\n    Collection,\n    Product,\n    ProductMedia,\n    ProductType,\n    ProductVariant,\n)\nfrom ..utils import (\n    clean_variant_sku,\n    create_stocks,\n    get_draft_order_lines_data_for_variants,\n    get_used_variants_attribute_values,\n)\n\n\nclass CategoryBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID, required=True, description=\"List of category IDs to delete.\"\n        )\n\n    class Meta:\n        description = \"Deletes categories.\"\n        model = models.Category\n        object_type = Category\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = ProductError\n        error_type_field = \"product_errors\"\n\n    @classmethod\n    def bulk_action(cls, info, queryset):\n        manager = load_plugin_manager(info.context)\n        delete_categories(queryset.values_list(\"pk\", flat=True), manager)\n\n\nclass CollectionBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID, required=True, description=\"List of collection IDs to delete.\"\n        )\n\n    class Meta:\n        description = \"Deletes collections.\"\n        model = models.Collection\n        object_type = Collection\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = CollectionError\n        error_type_field = \"collection_errors\"\n\n    @classmethod\n    def bulk_action(cls, info, queryset):\n        collections_ids = queryset.values_list(\"id\", flat=True)\n        products = list(\n            models.Product.objects.prefetched_for_webhook(single_object=False)\n            .filter(collections__in=collections_ids)\n            .distinct()\n        )\n        manager = load_plugin_manager(info.context)\n        for collection in queryset.iterator():\n            manager.collection_deleted(collection)\n        queryset.delete()\n\n        for product in products:\n            manager.product_updated(product)\n\n\nclass ProductBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID, required=True, description=\"List of product IDs to delete.\"\n        )\n\n    class Meta:\n        description = \"Deletes products.\"\n        model = models.Product\n        object_type = Product\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = ProductError\n        error_type_field = \"product_errors\"\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, ids, **data):\n        try:\n            pks = cls.get_global_ids_or_error(ids, Product)\n        except ValidationError as error:\n            return 0, error\n        product_to_variant = list(\n            models.ProductVariant.objects.filter(product__pk__in=pks).values_list(\n                \"product_id\", \"id\"\n            )\n        )\n        variants_ids = [variant_id for _, variant_id in product_to_variant]\n\n        cls.delete_assigned_attribute_values(pks)\n\n        draft_order_lines_data = get_draft_order_lines_data_for_variants(variants_ids)\n\n        response = super().perform_mutation(\n            _root,\n            info,\n            ids,\n            product_to_variant=product_to_variant,\n            **data,\n        )\n\n        # delete order lines for deleted variants\n        order_models.OrderLine.objects.filter(\n            pk__in=draft_order_lines_data.line_pks\n        ).delete()\n\n        app = load_app(info.context)\n        # run order event for deleted lines\n        for order, order_lines in draft_order_lines_data.order_to_lines_mapping.items():\n            order_events.order_line_product_removed_event(\n                order, info.context.user, app, order_lines\n            )\n\n        order_pks = draft_order_lines_data.order_pks\n        if order_pks:\n            recalculate_orders_task.delay(list(order_pks))\n\n        return response\n\n    @staticmethod\n    def delete_assigned_attribute_values(instance_pks):\n        attribute_models.AttributeValue.objects.filter(\n            productassignments__product_id__in=instance_pks,\n            attribute__input_type__in=AttributeInputType.TYPES_WITH_UNIQUE_VALUES,\n        ).delete()\n\n    @classmethod\n    def bulk_action(cls, info, queryset, product_to_variant):\n        product_variant_map = defaultdict(list)\n        for product, variant in product_to_variant:\n            product_variant_map[product].append(variant)\n\n        products = [product for product in queryset]\n        queryset.delete()\n        manager = load_plugin_manager(info.context)\n        for product in products:\n            variants = product_variant_map.get(product.id, [])\n            manager.product_deleted(product, variants)\n\n\nclass BulkAttributeValueInput(InputObjectType):\n    id = graphene.ID(description=\"ID of the selected attribute.\")\n    values = NonNullList(\n        graphene.String,\n        required=False,\n        description=(\n            \"The value or slug of an attribute to resolve. \"\n            \"If the passed value is non-existent, it will be created.\"\n        ),\n    )\n    boolean = graphene.Boolean(\n        required=False,\n        description=(\n            \"The boolean value of an attribute to resolve. \"\n            \"If the passed value is non-existent, it will be created.\"\n        ),\n    )\n\n\nclass ProductVariantBulkCreateInput(ProductVariantInput):\n    attributes = NonNullList(\n        BulkAttributeValueInput,\n        required=True,\n        description=\"List of attributes specific to this variant.\",\n    )\n    stocks = NonNullList(\n        StockInput,\n        description=\"Stocks of a product available for sale.\",\n        required=False,\n    )\n    channel_listings = NonNullList(\n        ProductVariantChannelListingAddInput,\n        description=\"List of prices assigned to channels.\",\n        required=False,\n    )\n    sku = graphene.String(description=\"Stock keeping unit.\")\n\n\nclass ProductVariantBulkCreate(BaseMutation):\n    count = graphene.Int(\n        required=True,\n        default_value=0,\n        description=\"Returns how many objects were created.\",\n    )\n    product_variants = NonNullList(\n        ProductVariant,\n        required=True,\n        default_value=[],\n        description=\"List of the created variants.\",\n    )\n\n    class Arguments:\n        variants = NonNullList(\n            ProductVariantBulkCreateInput,\n            required=True,\n            description=\"Input list of product variants to create.\",\n        )\n        product_id = graphene.ID(\n            description=\"ID of the product to create the variants for.\",\n            name=\"product\",\n            required=True,\n        )\n\n    class Meta:\n        description = \"Creates product variants for a given product.\"\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = BulkProductError\n        error_type_field = \"bulk_product_errors\"\n\n    @classmethod\n    def clean_variant_input(\n        cls,\n        info,\n        instance: models.ProductVariant,\n        data: dict,\n        errors: dict,\n        variant_index: int,\n    ):\n        cleaned_input = ModelMutation.clean_input(\n            info, instance, data, input_cls=ProductVariantBulkCreateInput\n        )\n\n        attributes = cleaned_input.get(\"attributes\")\n        if attributes:\n            try:\n                cleaned_input[\"attributes\"] = ProductVariantCreate.clean_attributes(\n                    attributes, data[\"product_type\"]\n                )\n            except ValidationError as exc:\n                exc.params = {\"index\": variant_index}\n                errors[\"attributes\"] = exc\n\n        channel_listings = cleaned_input.get(\"channel_listings\")\n        if channel_listings:\n            cleaned_input[\"channel_listings\"] = cls.clean_channel_listings(\n                channel_listings, errors, data[\"product\"], variant_index\n            )\n\n        stocks = cleaned_input.get(\"stocks\")\n        if stocks:\n            cls.clean_stocks(stocks, errors, variant_index)\n\n        cleaned_input[\"sku\"] = clean_variant_sku(cleaned_input.get(\"sku\"))\n\n        preorder_settings = cleaned_input.get(\"preorder\")\n        if preorder_settings:\n            cleaned_input[\"is_preorder\"] = True\n            cleaned_input[\"preorder_global_threshold\"] = preorder_settings.get(\n                \"global_threshold\"\n            )\n            cleaned_input[\"preorder_end_date\"] = preorder_settings.get(\"end_date\")\n\n        return cleaned_input\n\n    @classmethod\n    def clean_price(\n        cls, price, field_name, currency, channel_id, variant_index, errors\n    ):\n        try:\n            validate_price_precision(price, currency)\n        except ValidationError as error:\n            error.code = ProductErrorCode.INVALID.value\n            error.params = {\n                \"channels\": [channel_id],\n                \"index\": variant_index,\n            }\n            errors[field_name].append(error)\n\n    @classmethod\n    def clean_channel_listings(cls, channels_data, errors, product, variant_index):\n        channel_ids = [\n            channel_listing[\"channel_id\"] for channel_listing in channels_data\n        ]\n        duplicates = get_duplicated_values(channel_ids)\n        if duplicates:\n            errors[\"channel_listings\"] = ValidationError(\n                \"Duplicated channel ID.\",\n                code=ProductErrorCode.DUPLICATED_INPUT_ITEM.value,\n                params={\"channels\": duplicates, \"index\": variant_index},\n            )\n            return channels_data\n        channels = cls.get_nodes_or_error(\n            channel_ids, \"channel_listings\", only_type=Channel\n        )\n        for index, channel_listing_data in enumerate(channels_data):\n            channel_listing_data[\"channel\"] = channels[index]\n\n        for channel_listing_data in channels_data:\n            price = channel_listing_data.get(\"price\")\n            cost_price = channel_listing_data.get(\"cost_price\")\n            channel_id = channel_listing_data[\"channel_id\"]\n            currency_code = channel_listing_data[\"channel\"].currency_code\n            cls.clean_price(\n                price, \"price\", currency_code, channel_id, variant_index, errors\n            )\n            cls.clean_price(\n                cost_price,\n                \"cost_price\",\n                currency_code,\n                channel_id,\n                variant_index,\n                errors,\n            )\n\n        channels_not_assigned_to_product = []\n        channels_assigned_to_product = list(\n            models.ProductChannelListing.objects.filter(product=product.id).values_list(\n                \"channel_id\", flat=True\n            )\n        )\n        for channel_listing_data in channels_data:\n            if not channel_listing_data[\"channel\"].id in channels_assigned_to_product:\n                channels_not_assigned_to_product.append(\n                    channel_listing_data[\"channel_id\"]\n                )\n        if channels_not_assigned_to_product:\n            errors[\"channel_id\"].append(\n                ValidationError(\n                    \"Product not available in channels.\",\n                    code=ProductErrorCode.PRODUCT_NOT_ASSIGNED_TO_CHANNEL.value,\n                    params={\n                        \"index\": variant_index,\n                        \"channels\": channels_not_assigned_to_product,\n                    },\n                )\n            )\n        return channels_data\n\n    @classmethod\n    def clean_stocks(cls, stocks_data, errors, variant_index):\n        warehouse_ids = [stock[\"warehouse\"] for stock in stocks_data]\n        duplicates = get_duplicated_values(warehouse_ids)\n        if duplicates:\n            errors[\"stocks\"] = ValidationError(\n                \"Duplicated warehouse ID.\",\n                code=ProductErrorCode.DUPLICATED_INPUT_ITEM.value,\n                params={\"warehouses\": duplicates, \"index\": variant_index},\n            )\n\n    @classmethod\n    def add_indexes_to_errors(cls, index, error, error_dict):\n        \"\"\"Append errors with index in params to mutation error dict.\"\"\"\n        for key, value in error.error_dict.items():\n            for e in value:\n                if e.params:\n                    e.params[\"index\"] = index\n                else:\n                    e.params = {\"index\": index}\n            error_dict[key].extend(value)\n\n    @classmethod\n    def save(cls, info, instance, cleaned_input):\n        instance.save()\n\n        attributes = cleaned_input.get(\"attributes\")\n        if attributes:\n            AttributeAssignmentMixin.save(instance, attributes)\n            if not instance.name:\n                generate_and_set_variant_name(instance, cleaned_input.get(\"sku\"))\n\n    @classmethod\n    def create_variants(cls, info, cleaned_inputs, product, errors):\n        instances = []\n        for index, cleaned_input in enumerate(cleaned_inputs):\n            if not cleaned_input:\n                continue\n            try:\n                instance = models.ProductVariant()\n                cleaned_input[\"product\"] = product\n                instance = cls.construct_instance(instance, cleaned_input)\n                cls.clean_instance(info, instance)\n                instances.append(instance)\n            except ValidationError as exc:\n                cls.add_indexes_to_errors(index, exc, errors)\n        return instances\n\n    @classmethod\n    def validate_duplicated_sku(cls, sku, index, sku_list, errors):\n        if sku in sku_list:\n            errors[\"sku\"].append(\n                ValidationError(\n                    \"Duplicated SKU.\", ProductErrorCode.UNIQUE, params={\"index\": index}\n                )\n            )\n        sku_list.append(sku)\n\n    @classmethod\n    def validate_duplicated_attribute_values(\n        cls, attributes_data, used_attribute_values, instance=None\n    ):\n        attribute_values = defaultdict(list)\n        for attr in attributes_data:\n            if \"boolean\" in attr:\n                attribute_values[attr.id] = attr[\"boolean\"]\n            else:\n                attribute_values[attr.id].extend(attr.get(\"values\", []))\n        if attribute_values in used_attribute_values:\n            raise ValidationError(\n                \"Duplicated attribute values for product variant.\",\n                ProductErrorCode.DUPLICATED_INPUT_ITEM,\n            )\n        used_attribute_values.append(attribute_values)\n\n    @classmethod\n    def clean_variants(cls, info, variants, product, errors):\n        cleaned_inputs = []\n        sku_list = []\n        used_attribute_values = get_used_variants_attribute_values(product)\n        for index, variant_data in enumerate(variants):\n            if variant_data.attributes:\n                try:\n                    cls.validate_duplicated_attribute_values(\n                        variant_data.attributes, used_attribute_values\n                    )\n                except ValidationError as exc:\n                    errors[\"attributes\"].append(\n                        ValidationError(exc.message, exc.code, params={\"index\": index})\n                    )\n\n            variant_data[\"product_type\"] = product.product_type\n            variant_data[\"product\"] = product\n            cleaned_input = cls.clean_variant_input(\n                info, None, variant_data, errors, index\n            )\n\n            cleaned_inputs.append(cleaned_input if cleaned_input else None)\n\n            if cleaned_input[\"sku\"]:\n                cls.validate_duplicated_sku(\n                    cleaned_input[\"sku\"], index, sku_list, errors\n                )\n        return cleaned_inputs\n\n    @classmethod\n    def create_variant_channel_listings(cls, variant, cleaned_input):\n        channel_listings_data = cleaned_input.get(\"channel_listings\")\n        if not channel_listings_data:\n            return\n        variant_channel_listings = []\n        for channel_listing_data in channel_listings_data:\n            channel = channel_listing_data[\"channel\"]\n            price = channel_listing_data[\"price\"]\n            cost_price = channel_listing_data.get(\"cost_price\")\n            preorder_quantity_threshold = channel_listing_data.get(\"preorder_threshold\")\n            variant_channel_listings.append(\n                models.ProductVariantChannelListing(\n                    channel=channel,\n                    variant=variant,\n                    price_amount=price,\n                    cost_price_amount=cost_price,\n                    currency=channel.currency_code,\n                    preorder_quantity_threshold=preorder_quantity_threshold,\n                )\n            )\n        models.ProductVariantChannelListing.objects.bulk_create(\n            variant_channel_listings\n        )\n\n    @classmethod\n    @traced_atomic_transaction()\n    def save_variants(cls, info, instances, product, cleaned_inputs):\n        assert len(instances) == len(\n            cleaned_inputs\n        ), \"There should be the same number of instances and cleaned inputs.\"\n        for instance, cleaned_input in zip(instances, cleaned_inputs):\n            cls.save(info, instance, cleaned_input)\n            cls.create_variant_stocks(instance, cleaned_input)\n            cls.create_variant_channel_listings(instance, cleaned_input)\n\n        if not product.default_variant:\n            product.default_variant = instances[0]\n            product.save(update_fields=[\"default_variant\", \"updated_at\"])\n\n    @classmethod\n    def create_variant_stocks(cls, variant, cleaned_input):\n        stocks = cleaned_input.get(\"stocks\")\n        if not stocks:\n            return\n        warehouse_ids = [stock[\"warehouse\"] for stock in stocks]\n        warehouses = cls.get_nodes_or_error(\n            warehouse_ids, \"warehouse\", only_type=Warehouse\n        )\n        create_stocks(variant, stocks, warehouses)\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, **data):\n        product = cls.get_node_or_error(info, data[\"product_id\"], models.Product)\n        errors = defaultdict(list)\n\n        cleaned_inputs = cls.clean_variants(info, data[\"variants\"], product, errors)\n        instances = cls.create_variants(info, cleaned_inputs, product, errors)\n        if errors:\n            raise ValidationError(errors)\n        cls.save_variants(info, instances, product, cleaned_inputs)\n\n        # Recalculate the \"discounted price\" for the parent product\n        update_product_discounted_price_task.delay(product.pk)\n\n        instances = [\n            ChannelContext(node=instance, channel_slug=None) for instance in instances\n        ]\n\n        update_product_search_vector(product)\n        manager = load_plugin_manager(info.context)\n        transaction.on_commit(\n            lambda: [\n                manager.product_variant_created(instance.node) for instance in instances\n            ]\n        )\n\n        return ProductVariantBulkCreate(\n            count=len(instances), product_variants=instances\n        )\n\n\nclass ProductVariantBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID,\n            required=True,\n            description=\"List of product variant IDs to delete.\",\n        )\n\n    class Meta:\n        description = \"Deletes product variants.\"\n        model = models.ProductVariant\n        object_type = ProductVariant\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = ProductError\n        error_type_field = \"product_errors\"\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, ids, **data):\n        try:\n            pks = cls.get_global_ids_or_error(ids, ProductVariant)\n        except ValidationError as error:\n            return 0, error\n\n        draft_order_lines_data = get_draft_order_lines_data_for_variants(pks)\n\n        product_pks = list(\n            models.Product.objects.filter(variants__in=pks)\n            .distinct()\n            .values_list(\"pk\", flat=True)\n        )\n\n        # Get cached variants with related fields to fully populate webhook payload.\n        variants = list(\n            models.ProductVariant.objects.filter(id__in=pks).prefetch_related(\n                \"channel_listings\",\n                \"attributes__values\",\n                \"variant_media\",\n            )\n        )\n\n        cls.delete_assigned_attribute_values(pks)\n        cls.delete_product_channel_listings_without_available_variants(product_pks, pks)\n        response = super().perform_mutation(_root, info, ids, **data)\n        manager = load_plugin_manager(info.context)\n        transaction.on_commit(\n            lambda: [manager.product_variant_deleted(variant) for variant in variants]\n        )\n\n        # delete order lines for deleted variants\n        order_models.OrderLine.objects.filter(\n            pk__in=draft_order_lines_data.line_pks\n        ).delete()\n\n        app = load_app(info.context)\n        # run order event for deleted lines\n        for order, order_lines in draft_order_lines_data.order_to_lines_mapping.items():\n            order_events.order_line_variant_removed_event(\n                order, info.context.user, app, order_lines\n            )\n\n        order_pks = draft_order_lines_data.order_pks\n        if order_pks:\n            recalculate_orders_task.delay(list(order_pks))\n\n        # set new product default variant if any has been removed\n        products = models.Product.objects.filter(\n            pk__in=product_pks, default_variant__isnull=True\n        )\n        for product in products:\n            product.search_vector = FlatConcatSearchVector(\n                *prepare_product_search_vector_value(product)\n            )\n            product.default_variant = product.variants.first()\n            product.save(\n                update_fields=[\n                    \"default_variant\",\n                    \"search_vector\",\n                    \"updated_at\",\n                ]\n            )\n\n        return response\n\n    @staticmethod\n    def delete_assigned_attribute_values(instance_pks):\n        attribute_models.AttributeValue.objects.filter(\n            variantassignments__variant_id__in=instance_pks,\n            attribute__input_type__in=AttributeInputType.TYPES_WITH_UNIQUE_VALUES,\n        ).delete()\n\n    @staticmethod\n    def delete_product_channel_listings_without_available_variants(\n        product_pks: Iterable[int], variant_pks: Iterable[int]\n    ):\n        \"\"\"Delete invalid channel listings.\n\n        Delete product channel listings for product and channel for which\n        the last available variant has been deleted.\n        \"\"\"\n        variants = models.ProductVariant.objects.filter(\n            product_id__in=product_pks\n        ).exclude(id__in=variant_pks)\n\n        variant_subquery = Subquery(\n            queryset=variants.filter(id=OuterRef(\"variant_id\")).values(\"product_id\"),\n            output_field=IntegerField(),\n        )\n        variant_channel_listings = models.ProductVariantChannelListing.objects.annotate(\n            product_id=Coalesce(variant_subquery, 0)\n        )\n\n        invalid_product_channel_listings = models.ProductChannelListing.objects.filter(\n            product_id__in=product_pks\n        ).exclude(\n            Exists(\n                variant_channel_listings.filter(\n                    channel_id=OuterRef(\"channel_id\"), product_id=OuterRef(\"product_id\")\n                )\n            )\n        )\n        invalid_product_channel_listings.delete()\n\n\nclass ProductVariantStocksCreate(BaseMutation):\n    product_variant = graphene.Field(\n        ProductVariant, description=\"Updated product variant.\"\n    )\n\n    class Arguments:\n        variant_id = graphene.ID(\n            required=True,\n            description=\"ID of a product variant for which stocks will be created.\",\n        )\n        stocks = NonNullList(\n            StockInput,\n            required=True,\n            description=\"Input list of stocks to create.\",\n        )\n\n    class Meta:\n        description = \"Creates stocks for product variant.\"\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = BulkStockError\n        error_type_field = \"bulk_stock_errors\"\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, **data):\n        manager = load_plugin_manager(info.context)\n        errors = defaultdict(list)\n        stocks = data[\"stocks\"]\n        variant = cls.get_node_or_error(\n            info, data[\"variant_id\"], only_type=ProductVariant\n        )\n        if stocks:\n            warehouses = cls.clean_stocks_input(variant, stocks, errors)\n            if errors:\n                raise ValidationError(errors)\n            new_stocks = create_stocks(variant, stocks, warehouses)\n\n            for stock in new_stocks:\n                transaction.on_commit(\n                    lambda: manager.product_variant_back_in_stock(stock)\n                )\n\n        StocksWithAvailableQuantityByProductVariantIdCountryCodeAndChannelLoader(\n            info.context\n        ).clear((variant.id, None, None))\n\n        variant = ChannelContext(node=variant, channel_slug=None)\n        return cls(product_variant=variant)\n\n    @classmethod\n    def clean_stocks_input(cls, variant, stocks_data, errors):\n        warehouse_ids = [stock[\"warehouse\"] for stock in stocks_data]\n        cls.check_for_duplicates(warehouse_ids, errors)\n        warehouses = cls.get_nodes_or_error(\n            warehouse_ids, \"warehouse\", only_type=Warehouse\n        )\n        existing_stocks = variant.stocks.filter(warehouse__in=warehouses).values_list(\n            \"warehouse__pk\", flat=True\n        )\n        error_msg = \"Stock for this warehouse already exists for this product variant.\"\n        indexes = []\n        for warehouse_pk in existing_stocks:\n            warehouse_id = graphene.Node.to_global_id(\"Warehouse\", warehouse_pk)\n            indexes.extend(\n                [i for i, id in enumerate(warehouse_ids) if id == warehouse_id]\n            )\n        cls.update_errors(\n            errors, error_msg, \"warehouse\", StockErrorCode.UNIQUE, indexes\n        )\n\n        return warehouses\n\n    @classmethod\n    def check_for_duplicates(cls, warehouse_ids, errors):\n        duplicates = {id for id in warehouse_ids if warehouse_ids.count(id) > 1}\n        error_msg = \"Duplicated warehouse ID.\"\n        indexes = []\n        for duplicated_id in duplicates:\n            indexes.append(\n                [i for i, id in enumerate(warehouse_ids) if id == duplicated_id][-1]\n            )\n        cls.update_errors(\n            errors, error_msg, \"warehouse\", StockErrorCode.UNIQUE, indexes\n        )\n\n    @classmethod\n    def update_errors(cls, errors, msg, field, code, indexes):\n        for index in indexes:\n            error = ValidationError(msg, code=code, params={\"index\": index})\n            errors[field].append(error)\n\n\nclass ProductVariantStocksUpdate(ProductVariantStocksCreate):\n    class Meta:\n        description = \"Update stocks for product variant.\"\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = BulkStockError\n        error_type_field = \"bulk_stock_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        errors = defaultdict(list)\n        stocks = data[\"stocks\"]\n        variant = cls.get_node_or_error(\n            info, data[\"variant_id\"], only_type=ProductVariant\n        )\n        if stocks:\n            warehouse_ids = [stock[\"warehouse\"] for stock in stocks]\n            cls.check_for_duplicates(warehouse_ids, errors)\n            if errors:\n                raise ValidationError(errors)\n            warehouses = cls.get_nodes_or_error(\n                warehouse_ids, \"warehouse\", only_type=Warehouse\n            )\n\n            manager = load_plugin_manager(info.context)\n            cls.update_or_create_variant_stocks(variant, stocks, warehouses, manager)\n\n        StocksWithAvailableQuantityByProductVariantIdCountryCodeAndChannelLoader(\n            info.context\n        ).clear((variant.id, None, None))\n\n        variant = ChannelContext(node=variant, channel_slug=None)\n        return cls(product_variant=variant)\n\n    @classmethod\n    @traced_atomic_transaction()\n    def update_or_create_variant_stocks(cls, variant, stocks_data, warehouses, manager):\n\n        stocks = []\n        for stock_data, warehouse in zip(stocks_data, warehouses):\n            stock, is_created = warehouse_models.Stock.objects.get_or_create(\n                product_variant=variant, warehouse=warehouse\n            )\n\n            if is_created or (stock.quantity <= 0 and stock_data[\"quantity\"] > 0):\n                transaction.on_commit(\n                    lambda: manager.product_variant_back_in_stock(stock)\n                )\n\n            if stock_data[\"quantity\"] <= 0:\n                transaction.on_commit(\n                    lambda: manager.product_variant_out_of_stock(stock)\n                )\n\n            stock.quantity = stock_data[\"quantity\"]\n            stocks.append(stock)\n\n        warehouse_models.Stock.objects.bulk_update(stocks, [\"quantity\"])\n\n\nclass ProductVariantStocksDelete(BaseMutation):\n    product_variant = graphene.Field(\n        ProductVariant, description=\"Updated product variant.\"\n    )\n\n    class Arguments:\n        variant_id = graphene.ID(\n            required=True,\n            description=\"ID of product variant for which stocks will be deleted.\",\n        )\n        warehouse_ids = NonNullList(graphene.ID)\n\n    class Meta:\n        description = \"Delete stocks from product variant.\"\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = StockError\n        error_type_field = \"stock_errors\"\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, **data):\n        manager = load_plugin_manager(info.context)\n        variant = cls.get_node_or_error(\n            info, data[\"variant_id\"], only_type=ProductVariant\n        )\n        warehouses_pks = cls.get_global_ids_or_error(\n            data[\"warehouse_ids\"], Warehouse, field=\"warehouse_ids\"\n        )\n        stocks_to_delete = warehouse_models.Stock.objects.filter(\n            product_variant=variant, warehouse__pk__in=warehouses_pks\n        )\n\n        for stock in stocks_to_delete:\n            transaction.on_commit(lambda: manager.product_variant_out_of_stock(stock))\n\n        stocks_to_delete.delete()\n\n        StocksWithAvailableQuantityByProductVariantIdCountryCodeAndChannelLoader(\n            info.context\n        ).clear((variant.id, None, None))\n\n        variant = ChannelContext(node=variant, channel_slug=None)\n        return cls(product_variant=variant)\n\n\nclass ProductTypeBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID,\n            required=True,\n            description=\"List of product type IDs to delete.\",\n        )\n\n    class Meta:\n        description = \"Deletes product types.\"\n        model = models.ProductType\n        object_type = ProductType\n        permissions = (ProductTypePermissions.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES,)\n        error_type_class = ProductError\n        error_type_field = \"product_errors\"\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, ids, **data):\n        try:\n            pks = cls.get_global_ids_or_error(ids, ProductType)\n        except ValidationError as error:\n            return 0, error\n        cls.delete_assigned_attribute_values(pks)\n        return super().perform_mutation(_root, info, ids, **data)\n\n    @staticmethod\n    def delete_assigned_attribute_values(instance_pks):\n        attribute_models.AttributeValue.objects.filter(\n            Q(attribute__input_type__in=AttributeInputType.TYPES_WITH_UNIQUE_VALUES)\n            & (\n                Q(productassignments__assignment__product_type_id__in=instance_pks)\n                | Q(variantassignments__assignment__product_type_id__in=instance_pks)\n            )\n        ).delete()\n\n\nclass ProductMediaBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID,\n            required=True,\n            description=\"List of product media IDs to delete.\",\n        )\n\n    class Meta:\n        description = \"Deletes product media.\"\n        model = models.ProductMedia\n        object_type = ProductMedia\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = ProductError\n        error_type_field = \"product_errors\"\n"], "fixing_code": ["import graphene\nimport jwt\nfrom django.conf import settings\nfrom django.contrib.auth import password_validation\nfrom django.core.exceptions import ValidationError\nfrom django.db import transaction\n\nfrom ....account import events as account_events\nfrom ....account import models, notifications, search, utils\nfrom ....account.error_codes import AccountErrorCode\nfrom ....account.utils import remove_the_oldest_user_address_if_address_limit_is_reached\nfrom ....checkout import AddressType\nfrom ....core.jwt import create_token, jwt_decode\nfrom ....core.permissions import AuthorizationFilters\nfrom ....core.tokens import account_delete_token_generator\nfrom ....core.tracing import traced_atomic_transaction\nfrom ....core.utils.url import validate_storefront_url\nfrom ....giftcard.utils import assign_user_gift_cards\nfrom ....order.utils import match_orders_with_new_user\nfrom ...channel.utils import clean_channel\nfrom ...core.enums import LanguageCodeEnum\nfrom ...core.mutations import BaseMutation, ModelDeleteMutation, ModelMutation\nfrom ...core.types import AccountError, NonNullList\nfrom ...meta.mutations import MetadataInput\nfrom ...plugins.dataloaders import load_plugin_manager\nfrom ..enums import AddressTypeEnum\nfrom ..i18n import I18nMixin\nfrom ..types import Address, AddressInput, User\nfrom .base import (\n    INVALID_TOKEN,\n    BaseAddressDelete,\n    BaseAddressUpdate,\n    BaseCustomerCreate,\n)\n\n\nclass AccountBaseInput(graphene.InputObjectType):\n    first_name = graphene.String(description=\"Given name.\")\n    last_name = graphene.String(description=\"Family name.\")\n    language_code = graphene.Argument(\n        LanguageCodeEnum, required=False, description=\"User language code.\"\n    )\n\n\nclass AccountRegisterInput(AccountBaseInput):\n    email = graphene.String(description=\"The email address of the user.\", required=True)\n    password = graphene.String(description=\"Password.\", required=True)\n    first_name = graphene.String(description=\"Given name.\")\n    last_name = graphene.String(description=\"Family name.\")\n    redirect_url = graphene.String(\n        description=(\n            \"Base of frontend URL that will be needed to create confirmation URL.\"\n        ),\n        required=False,\n    )\n    language_code = graphene.Argument(\n        LanguageCodeEnum, required=False, description=\"User language code.\"\n    )\n    metadata = NonNullList(\n        MetadataInput,\n        description=\"User public metadata.\",\n        required=False,\n    )\n    channel = graphene.String(\n        description=(\n            \"Slug of a channel which will be used to notify users. Optional when \"\n            \"only one channel exists.\"\n        )\n    )\n\n\nclass AccountRegister(ModelMutation):\n    class Arguments:\n        input = AccountRegisterInput(\n            description=\"Fields required to create a user.\", required=True\n        )\n\n    requires_confirmation = graphene.Boolean(\n        description=\"Informs whether users need to confirm their email address.\"\n    )\n\n    class Meta:\n        description = \"Register a new user.\"\n        exclude = [\"password\"]\n        model = models.User\n        object_type = User\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def mutate(cls, root, info, **data):\n        response = super().mutate(root, info, **data)\n        response.requires_confirmation = settings.ENABLE_ACCOUNT_CONFIRMATION_BY_EMAIL\n        return response\n\n    @classmethod\n    def clean_input(cls, info, instance, data, input_cls=None):\n        data[\"metadata\"] = {\n            item[\"key\"]: item[\"value\"] for item in data.get(\"metadata\") or []\n        }\n        if not settings.ENABLE_ACCOUNT_CONFIRMATION_BY_EMAIL:\n            return super().clean_input(info, instance, data, input_cls=None)\n        elif not data.get(\"redirect_url\"):\n            raise ValidationError(\n                {\n                    \"redirect_url\": ValidationError(\n                        \"This field is required.\", code=AccountErrorCode.REQUIRED\n                    )\n                }\n            )\n\n        try:\n            validate_storefront_url(data[\"redirect_url\"])\n        except ValidationError as error:\n            raise ValidationError(\n                {\n                    \"redirect_url\": ValidationError(\n                        error.message, code=AccountErrorCode.INVALID\n                    )\n                }\n            )\n\n        data[\"channel\"] = clean_channel(\n            data.get(\"channel\"), error_class=AccountErrorCode\n        ).slug\n\n        password = data[\"password\"]\n        try:\n            password_validation.validate_password(password, instance)\n        except ValidationError as error:\n            raise ValidationError({\"password\": error})\n\n        data[\"language_code\"] = data.get(\"language_code\", settings.LANGUAGE_CODE)\n        return super().clean_input(info, instance, data, input_cls=None)\n\n    @classmethod\n    @traced_atomic_transaction()\n    def save(cls, info, user, cleaned_input):\n        password = cleaned_input[\"password\"]\n        user.set_password(password)\n        user.search_document = search.prepare_user_search_document_value(\n            user, attach_addresses_data=False\n        )\n        manager = load_plugin_manager(info.context)\n        if settings.ENABLE_ACCOUNT_CONFIRMATION_BY_EMAIL:\n            user.is_active = False\n            user.save()\n            notifications.send_account_confirmation(\n                user,\n                cleaned_input[\"redirect_url\"],\n                manager,\n                channel_slug=cleaned_input[\"channel\"],\n            )\n        else:\n            user.save()\n\n        account_events.customer_account_created_event(user=user)\n        manager.customer_created(customer=user)\n\n\nclass AccountInput(AccountBaseInput):\n    default_billing_address = AddressInput(\n        description=\"Billing address of the customer.\"\n    )\n    default_shipping_address = AddressInput(\n        description=\"Shipping address of the customer.\"\n    )\n\n\nclass AccountUpdate(BaseCustomerCreate):\n    class Arguments:\n        input = AccountInput(\n            description=\"Fields required to update the account of the logged-in user.\",\n            required=True,\n        )\n\n    class Meta:\n        description = \"Updates the account of the logged-in user.\"\n        exclude = [\"password\"]\n        model = models.User\n        object_type = User\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def perform_mutation(cls, root, info, **data):\n        user = info.context.user\n        data[\"id\"] = graphene.Node.to_global_id(\"User\", user.id)\n        return super().perform_mutation(root, info, **data)\n\n\nclass AccountRequestDeletion(BaseMutation):\n    class Arguments:\n        redirect_url = graphene.String(\n            required=True,\n            description=(\n                \"URL of a view where users should be redirected to \"\n                \"delete their account. URL in RFC 1808 format.\"\n            ),\n        )\n        channel = graphene.String(\n            description=(\n                \"Slug of a channel which will be used to notify users. Optional when \"\n                \"only one channel exists.\"\n            )\n        )\n\n    class Meta:\n        description = (\n            \"Sends an email with the account removal link for the logged-in user.\"\n        )\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n        redirect_url = data[\"redirect_url\"]\n        try:\n            validate_storefront_url(redirect_url)\n        except ValidationError as error:\n            raise ValidationError(\n                {\"redirect_url\": error}, code=AccountErrorCode.INVALID\n            )\n        channel_slug = clean_channel(\n            data.get(\"channel\"), error_class=AccountErrorCode\n        ).slug\n        manager = load_plugin_manager(info.context)\n        notifications.send_account_delete_confirmation_notification(\n            redirect_url, user, manager, channel_slug=channel_slug\n        )\n        return AccountRequestDeletion()\n\n\nclass AccountDelete(ModelDeleteMutation):\n    class Arguments:\n        token = graphene.String(\n            description=(\n                \"A one-time token required to remove account. \"\n                \"Sent by email using AccountRequestDeletion mutation.\"\n            ),\n            required=True,\n        )\n\n    class Meta:\n        description = \"Remove user account.\"\n        model = models.User\n        object_type = User\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    def clean_instance(cls, info, instance):\n        super().clean_instance(info, instance)\n        if instance.is_staff:\n            raise ValidationError(\n                \"Cannot delete a staff account.\",\n                code=AccountErrorCode.DELETE_STAFF_ACCOUNT,\n            )\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n        cls.clean_instance(info, user)\n\n        token = data.pop(\"token\")\n        if not account_delete_token_generator.check_token(user, token):\n            raise ValidationError(\n                {\"token\": ValidationError(INVALID_TOKEN, code=AccountErrorCode.INVALID)}\n            )\n\n        db_id = user.id\n\n        user.delete()\n        # After the instance is deleted, set its ID to the original database's\n        # ID so that the success response contains ID of the deleted object.\n        user.id = db_id\n        return cls.success_response(user)\n\n\nclass AccountAddressCreate(ModelMutation, I18nMixin):\n    user = graphene.Field(\n        User, description=\"A user instance for which the address was created.\"\n    )\n\n    class Arguments:\n        input = AddressInput(\n            description=\"Fields required to create address.\", required=True\n        )\n        type = AddressTypeEnum(\n            required=False,\n            description=(\n                \"A type of address. If provided, the new address will be \"\n                \"automatically assigned as the customer's default address \"\n                \"of that type.\"\n            ),\n        )\n\n    class Meta:\n        description = \"Create a new address for the customer.\"\n        model = models.Address\n        object_type = Address\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, **data):\n        address_type = data.get(\"type\", None)\n        user = info.context.user\n        cleaned_input = cls.clean_input(\n            info=info, instance=Address(), data=data.get(\"input\")\n        )\n        address = cls.validate_address(cleaned_input, address_type=address_type)\n        cls.clean_instance(info, address)\n        cls.save(info, address, cleaned_input)\n        cls._save_m2m(info, address, cleaned_input)\n        if address_type:\n            manager = load_plugin_manager(info.context)\n            utils.change_user_default_address(user, address, address_type, manager)\n        return AccountAddressCreate(user=user, address=address)\n\n    @classmethod\n    def save(cls, info, instance, cleaned_input):\n        super().save(info, instance, cleaned_input)\n        user = info.context.user\n        remove_the_oldest_user_address_if_address_limit_is_reached(user)\n        instance.user_addresses.add(user)\n        user.search_document = search.prepare_user_search_document_value(user)\n        user.save(update_fields=[\"search_document\", \"updated_at\"])\n        transaction.on_commit(\n            lambda: cls.trigger_post_account_address_create_webhooks(\n                info, instance, user\n            )\n        )\n\n    @classmethod\n    def trigger_post_account_address_create_webhooks(cls, info, address, user):\n        manager = load_plugin_manager(info.context)\n        manager.customer_updated(user)\n        manager.address_created(address)\n\n\nclass AccountAddressUpdate(BaseAddressUpdate):\n    class Meta:\n        auto_permission_message = False\n        description = (\n            \"Updates an address of the logged-in user. Requires one of the following \"\n            \"permissions: MANAGE_USERS, IS_OWNER.\"\n        )\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        model = models.Address\n        object_type = Address\n\n\nclass AccountAddressDelete(BaseAddressDelete):\n    class Meta:\n        auto_permission_message = False\n        description = (\n            \"Delete an address of the logged-in user. Requires one of the following \"\n            \"permissions: MANAGE_USERS, IS_OWNER.\"\n        )\n        model = models.Address\n        object_type = Address\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n\nclass AccountSetDefaultAddress(BaseMutation):\n    user = graphene.Field(User, description=\"An updated user instance.\")\n\n    class Arguments:\n        id = graphene.ID(\n            required=True, description=\"ID of the address to set as default.\"\n        )\n        type = AddressTypeEnum(required=True, description=\"The type of address.\")\n\n    class Meta:\n        description = \"Sets a default address for the authenticated user.\"\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        address = cls.get_node_or_error(info, data.get(\"id\"), only_type=Address)\n        user = info.context.user\n\n        if not user.addresses.filter(pk=address.pk).exists():\n            raise ValidationError(\n                {\n                    \"id\": ValidationError(\n                        \"The address doesn't belong to that user.\",\n                        code=AccountErrorCode.INVALID,\n                    )\n                }\n            )\n\n        if data.get(\"type\") == AddressTypeEnum.BILLING.value:\n            address_type = AddressType.BILLING\n        else:\n            address_type = AddressType.SHIPPING\n        manager = load_plugin_manager(info.context)\n        utils.change_user_default_address(user, address, address_type, manager)\n        manager.customer_updated(user)\n        return cls(user=user)\n\n\nclass RequestEmailChange(BaseMutation):\n    user = graphene.Field(User, description=\"A user instance.\")\n\n    class Arguments:\n        password = graphene.String(required=True, description=\"User password.\")\n        new_email = graphene.String(required=True, description=\"New user email.\")\n        redirect_url = graphene.String(\n            required=True,\n            description=(\n                \"URL of a view where users should be redirected to \"\n                \"update the email address. URL in RFC 1808 format.\"\n            ),\n        )\n        channel = graphene.String(\n            description=(\n                \"Slug of a channel which will be used to notify users. Optional when \"\n                \"only one channel exists.\"\n            )\n        )\n\n    class Meta:\n        description = \"Request email change of the logged in user.\"\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n        password = data[\"password\"]\n        new_email = data[\"new_email\"]\n        redirect_url = data[\"redirect_url\"]\n\n        if not user.check_password(password):\n            raise ValidationError(\n                {\n                    \"password\": ValidationError(\n                        \"Password isn't valid.\",\n                        code=AccountErrorCode.INVALID_CREDENTIALS,\n                    )\n                }\n            )\n        if models.User.objects.filter(email=new_email).exists():\n            raise ValidationError(\n                {\n                    \"new_email\": ValidationError(\n                        \"Email is used by other user.\", code=AccountErrorCode.UNIQUE\n                    )\n                }\n            )\n        try:\n            validate_storefront_url(redirect_url)\n        except ValidationError as error:\n            raise ValidationError(\n                {\"redirect_url\": error}, code=AccountErrorCode.INVALID\n            )\n        channel_slug = clean_channel(\n            data.get(\"channel\"),\n            error_class=AccountErrorCode,\n        ).slug\n\n        token_payload = {\n            \"old_email\": user.email,\n            \"new_email\": new_email,\n            \"user_pk\": user.pk,\n        }\n        token = create_token(token_payload, settings.JWT_TTL_REQUEST_EMAIL_CHANGE)\n        manager = load_plugin_manager(info.context)\n        notifications.send_request_user_change_email_notification(\n            redirect_url,\n            user,\n            new_email,\n            token,\n            manager,\n            channel_slug=channel_slug,\n        )\n        return RequestEmailChange(user=user)\n\n\nclass ConfirmEmailChange(BaseMutation):\n    user = graphene.Field(User, description=\"A user instance with a new email.\")\n\n    class Arguments:\n        token = graphene.String(\n            description=\"A one-time token required to change the email.\", required=True\n        )\n        channel = graphene.String(\n            description=(\n                \"Slug of a channel which will be used to notify users. Optional when \"\n                \"only one channel exists.\"\n            )\n        )\n\n    class Meta:\n        description = \"Confirm the email change of the logged-in user.\"\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    def get_token_payload(cls, token):\n        try:\n            payload = jwt_decode(token)\n        except jwt.PyJWTError:\n            raise ValidationError(\n                {\n                    \"token\": ValidationError(\n                        \"Invalid or expired token.\",\n                        code=AccountErrorCode.JWT_INVALID_TOKEN,\n                    )\n                }\n            )\n        return payload\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n        token = data[\"token\"]\n\n        payload = cls.get_token_payload(token)\n        new_email = payload[\"new_email\"]\n        old_email = payload[\"old_email\"]\n\n        if models.User.objects.filter(email=new_email).exists():\n            raise ValidationError(\n                {\n                    \"new_email\": ValidationError(\n                        \"Email is used by other user.\", code=AccountErrorCode.UNIQUE\n                    )\n                }\n            )\n\n        user.email = new_email\n        user.search_document = search.prepare_user_search_document_value(user)\n        user.save(update_fields=[\"email\", \"search_document\", \"updated_at\"])\n\n        channel_slug = clean_channel(\n            data.get(\"channel\"), error_class=AccountErrorCode\n        ).slug\n\n        assign_user_gift_cards(user)\n        match_orders_with_new_user(user)\n        manager = load_plugin_manager(info.context)\n        notifications.send_user_change_email_notification(\n            old_email, user, manager, channel_slug=channel_slug\n        )\n        manager.customer_updated(user)\n        return ConfirmEmailChange(user=user)\n", "import graphene\nfrom django.contrib.auth import password_validation\nfrom django.contrib.auth.tokens import default_token_generator\nfrom django.core.exceptions import ObjectDoesNotExist, ValidationError\n\nfrom ....account import events as account_events\nfrom ....account import models\nfrom ....account.error_codes import AccountErrorCode\nfrom ....account.notifications import (\n    send_password_reset_notification,\n    send_set_password_notification,\n)\nfrom ....account.search import prepare_user_search_document_value\nfrom ....checkout import AddressType\nfrom ....core.exceptions import PermissionDenied\nfrom ....core.permissions import AccountPermissions, AuthorizationFilters\nfrom ....core.tracing import traced_atomic_transaction\nfrom ....core.utils.url import validate_storefront_url\nfrom ....giftcard.utils import assign_user_gift_cards\nfrom ....graphql.utils import get_user_or_app_from_context\nfrom ....order.utils import match_orders_with_new_user\nfrom ...account.i18n import I18nMixin\nfrom ...account.types import Address, AddressInput, User\nfrom ...app.dataloaders import load_app\nfrom ...channel.utils import clean_channel, validate_channel\nfrom ...core.context import set_mutation_flag_in_context\nfrom ...core.enums import LanguageCodeEnum\nfrom ...core.mutations import (\n    BaseMutation,\n    ModelDeleteMutation,\n    ModelMutation,\n    validation_error_to_error_type,\n)\nfrom ...core.types import AccountError\nfrom ...plugins.dataloaders import load_plugin_manager\nfrom .authentication import CreateToken\n\nBILLING_ADDRESS_FIELD = \"default_billing_address\"\nSHIPPING_ADDRESS_FIELD = \"default_shipping_address\"\nINVALID_TOKEN = \"Invalid or expired token.\"\n\n\ndef check_can_edit_address(context, address):\n    \"\"\"Determine whether the user or app can edit the given address.\n\n    This method assumes that an address can be edited by:\n    - apps with manage users permission\n    - staff with manage users permission\n    - customers associated to the given address.\n    \"\"\"\n    requester = get_user_or_app_from_context(context)\n    if requester.has_perm(AccountPermissions.MANAGE_USERS):\n        return True\n    app = load_app(context)\n    if not app and not context.user.is_anonymous:\n        is_owner = requester.addresses.filter(pk=address.pk).exists()\n        if is_owner:\n            return True\n    raise PermissionDenied(\n        permissions=[AccountPermissions.MANAGE_USERS, AuthorizationFilters.OWNER]\n    )\n\n\nclass SetPassword(CreateToken):\n    class Arguments:\n        token = graphene.String(\n            description=\"A one-time token required to set the password.\", required=True\n        )\n        email = graphene.String(required=True, description=\"Email of a user.\")\n        password = graphene.String(required=True, description=\"Password of a user.\")\n\n    class Meta:\n        description = (\n            \"Sets the user's password from the token sent by email \"\n            \"using the RequestPasswordReset mutation.\"\n        )\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def mutate(cls, root, info, **data):\n        set_mutation_flag_in_context(info.context)\n        manager = load_plugin_manager(info.context)\n        result = manager.perform_mutation(\n            mutation_cls=cls, root=root, info=info, data=data\n        )\n        if result is not None:\n            return result\n\n        email = data[\"email\"]\n        password = data[\"password\"]\n        token = data[\"token\"]\n\n        try:\n            cls._set_password_for_user(email, password, token)\n        except ValidationError as e:\n            errors = validation_error_to_error_type(e, AccountError)\n            return cls.handle_typed_errors(errors)\n        return super().mutate(root, info, **data)\n\n    @classmethod\n    def _set_password_for_user(cls, email, password, token):\n        try:\n            user = models.User.objects.get(email=email)\n        except ObjectDoesNotExist:\n            raise ValidationError(\n                {\n                    \"email\": ValidationError(\n                        \"User doesn't exist\", code=AccountErrorCode.NOT_FOUND\n                    )\n                }\n            )\n        if not default_token_generator.check_token(user, token):\n            raise ValidationError(\n                {\"token\": ValidationError(INVALID_TOKEN, code=AccountErrorCode.INVALID)}\n            )\n        try:\n            password_validation.validate_password(password, user)\n        except ValidationError as error:\n            raise ValidationError({\"password\": error})\n        user.set_password(password)\n        user.save(update_fields=[\"password\", \"updated_at\"])\n        account_events.customer_password_reset_event(user=user)\n\n\nclass RequestPasswordReset(BaseMutation):\n    class Arguments:\n        email = graphene.String(\n            required=True,\n            description=\"Email of the user that will be used for password recovery.\",\n        )\n        redirect_url = graphene.String(\n            required=True,\n            description=(\n                \"URL of a view where users should be redirected to \"\n                \"reset the password. URL in RFC 1808 format.\"\n            ),\n        )\n        channel = graphene.String(\n            description=(\n                \"Slug of a channel which will be used for notify user. Optional when \"\n                \"only one channel exists.\"\n            )\n        )\n\n    class Meta:\n        description = \"Sends an email with the account password modification link.\"\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def clean_user(cls, email, redirect_url):\n\n        try:\n            validate_storefront_url(redirect_url)\n        except ValidationError as error:\n            raise ValidationError(\n                {\"redirect_url\": error}, code=AccountErrorCode.INVALID\n            )\n\n        try:\n            user = models.User.objects.get(email=email)\n        except ObjectDoesNotExist:\n            raise ValidationError(\n                {\n                    \"email\": ValidationError(\n                        \"User with this email doesn't exist\",\n                        code=AccountErrorCode.NOT_FOUND,\n                    )\n                }\n            )\n        if not user.is_active:\n            raise ValidationError(\n                {\n                    \"email\": ValidationError(\n                        \"User with this email is inactive\",\n                        code=AccountErrorCode.INACTIVE,\n                    )\n                }\n            )\n        return user\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        email = data[\"email\"]\n        redirect_url = data[\"redirect_url\"]\n        channel_slug = data.get(\"channel\")\n        user = cls.clean_user(email, redirect_url)\n\n        if not user.is_staff:\n            channel_slug = clean_channel(\n                channel_slug, error_class=AccountErrorCode\n            ).slug\n        elif channel_slug is not None:\n            channel_slug = validate_channel(\n                channel_slug, error_class=AccountErrorCode\n            ).slug\n        manager = load_plugin_manager(info.context)\n        send_password_reset_notification(\n            redirect_url,\n            user,\n            manager,\n            channel_slug=channel_slug,\n            staff=user.is_staff,\n        )\n        return RequestPasswordReset()\n\n\nclass ConfirmAccount(BaseMutation):\n    user = graphene.Field(User, description=\"An activated user account.\")\n\n    class Arguments:\n        token = graphene.String(\n            description=\"A one-time token required to confirm the account.\",\n            required=True,\n        )\n        email = graphene.String(\n            description=\"E-mail of the user performing account confirmation.\",\n            required=True,\n        )\n\n    class Meta:\n        description = (\n            \"Confirm user account with token sent by email during registration.\"\n        )\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        try:\n            user = models.User.objects.get(email=data[\"email\"])\n        except ObjectDoesNotExist:\n            raise ValidationError(\n                {\n                    \"email\": ValidationError(\n                        \"User with this email doesn't exist\",\n                        code=AccountErrorCode.NOT_FOUND,\n                    )\n                }\n            )\n\n        if not default_token_generator.check_token(user, data[\"token\"]):\n            raise ValidationError(\n                {\"token\": ValidationError(INVALID_TOKEN, code=AccountErrorCode.INVALID)}\n            )\n\n        user.is_active = True\n        user.save(update_fields=[\"is_active\", \"updated_at\"])\n\n        match_orders_with_new_user(user)\n        assign_user_gift_cards(user)\n\n        return ConfirmAccount(user=user)\n\n\nclass PasswordChange(BaseMutation):\n    user = graphene.Field(User, description=\"A user instance with a new password.\")\n\n    class Arguments:\n        old_password = graphene.String(\n            required=True, description=\"Current user password.\"\n        )\n        new_password = graphene.String(required=True, description=\"New user password.\")\n\n    class Meta:\n        description = \"Change the password of the logged in user.\"\n        error_type_class = AccountError\n        error_type_field = \"account_errors\"\n        permissions = (AuthorizationFilters.AUTHENTICATED_USER,)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        user = info.context.user\n        old_password = data[\"old_password\"]\n        new_password = data[\"new_password\"]\n\n        if not user.check_password(old_password):\n            raise ValidationError(\n                {\n                    \"old_password\": ValidationError(\n                        \"Old password isn't valid.\",\n                        code=AccountErrorCode.INVALID_CREDENTIALS,\n                    )\n                }\n            )\n        try:\n            password_validation.validate_password(new_password, user)\n        except ValidationError as error:\n            raise ValidationError({\"new_password\": error})\n\n        user.set_password(new_password)\n        user.save(update_fields=[\"password\", \"updated_at\"])\n        account_events.customer_password_changed_event(user=user)\n        return PasswordChange(user=user)\n\n\nclass BaseAddressUpdate(ModelMutation, I18nMixin):\n    \"\"\"Base mutation for address update used by staff and account.\"\"\"\n\n    user = graphene.Field(\n        User, description=\"A user object for which the address was edited.\"\n    )\n\n    class Arguments:\n        id = graphene.ID(description=\"ID of the address to update.\", required=True)\n        input = AddressInput(\n            description=\"Fields required to update the address.\", required=True\n        )\n\n    class Meta:\n        abstract = True\n\n    @classmethod\n    def clean_input(cls, info, instance, data):\n        # Method check_permissions cannot be used for permission check, because\n        # it doesn't have the address instance.\n        check_can_edit_address(info.context, instance)\n        return super().clean_input(info, instance, data)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        instance = cls.get_instance(info, **data)\n        cleaned_input = cls.clean_input(\n            info=info, instance=instance, data=data.get(\"input\")\n        )\n        address = cls.validate_address(cleaned_input, instance=instance)\n        cls.clean_instance(info, address)\n        cls.save(info, address, cleaned_input)\n        cls._save_m2m(info, address, cleaned_input)\n\n        user = address.user_addresses.first()\n        user.search_document = prepare_user_search_document_value(user)\n        user.save(update_fields=[\"search_document\", \"updated_at\"])\n        manager = load_plugin_manager(info.context)\n        manager.customer_updated(user)\n        address = manager.change_user_address(address, None, user)\n        manager.address_updated(address)\n\n        success_response = cls.success_response(address)\n        success_response.user = user\n        success_response.address = address\n        return success_response\n\n\nclass BaseAddressDelete(ModelDeleteMutation):\n    \"\"\"Base mutation for address delete used by staff and customers.\"\"\"\n\n    user = graphene.Field(\n        User, description=\"A user instance for which the address was deleted.\"\n    )\n\n    class Arguments:\n        id = graphene.ID(required=True, description=\"ID of the address to delete.\")\n\n    class Meta:\n        abstract = True\n\n    @classmethod\n    def clean_instance(cls, info, instance):\n        # Method check_permissions cannot be used for permission check, because\n        # it doesn't have the address instance.\n        check_can_edit_address(info.context, instance)\n        return super().clean_instance(info, instance)\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        if not cls.check_permissions(info.context):\n            raise PermissionDenied()\n\n        node_id = data.get(\"id\")\n        instance = cls.get_node_or_error(info, node_id, only_type=Address)\n        if instance:\n            cls.clean_instance(info, instance)\n\n        db_id = instance.id\n\n        # Return the first user that the address is assigned to. There is M2M\n        # relation between users and addresses, but in most cases address is\n        # related to only one user.\n        user = instance.user_addresses.first()\n\n        instance.delete()\n        instance.id = db_id\n\n        # Refresh the user instance to clear the default addresses. If the\n        # deleted address was used as default, it would stay cached in the\n        # user instance and the invalid ID returned in the response might cause\n        # an error.\n        user.refresh_from_db()\n\n        user.search_document = prepare_user_search_document_value(user)\n        user.save(update_fields=[\"search_document\", \"updated_at\"])\n\n        response = cls.success_response(instance)\n\n        response.user = user\n        manager = load_plugin_manager(info.context)\n        manager.customer_updated(user)\n        manager.address_deleted(instance)\n        return response\n\n\nclass UserInput(graphene.InputObjectType):\n    first_name = graphene.String(description=\"Given name.\")\n    last_name = graphene.String(description=\"Family name.\")\n    email = graphene.String(description=\"The unique email address of the user.\")\n    is_active = graphene.Boolean(required=False, description=\"User account is active.\")\n    note = graphene.String(description=\"A note about the user.\")\n\n\nclass UserAddressInput(graphene.InputObjectType):\n    default_billing_address = AddressInput(\n        description=\"Billing address of the customer.\"\n    )\n    default_shipping_address = AddressInput(\n        description=\"Shipping address of the customer.\"\n    )\n\n\nclass CustomerInput(UserInput, UserAddressInput):\n    language_code = graphene.Field(\n        LanguageCodeEnum, required=False, description=\"User language code.\"\n    )\n\n\nclass UserCreateInput(CustomerInput):\n    redirect_url = graphene.String(\n        description=(\n            \"URL of a view where users should be redirected to \"\n            \"set the password. URL in RFC 1808 format.\"\n        )\n    )\n    channel = graphene.String(\n        description=(\n            \"Slug of a channel which will be used for notify user. Optional when \"\n            \"only one channel exists.\"\n        )\n    )\n\n\nclass BaseCustomerCreate(ModelMutation, I18nMixin):\n    \"\"\"Base mutation for customer create used by staff and account.\"\"\"\n\n    class Arguments:\n        input = UserCreateInput(\n            description=\"Fields required to create a customer.\", required=True\n        )\n\n    class Meta:\n        abstract = True\n\n    @classmethod\n    def clean_input(cls, info, instance, data):\n        shipping_address_data = data.pop(SHIPPING_ADDRESS_FIELD, None)\n        billing_address_data = data.pop(BILLING_ADDRESS_FIELD, None)\n        cleaned_input = super().clean_input(info, instance, data)\n\n        if shipping_address_data:\n            shipping_address = cls.validate_address(\n                shipping_address_data,\n                address_type=AddressType.SHIPPING,\n                instance=getattr(instance, SHIPPING_ADDRESS_FIELD),\n                info=info,\n            )\n            cleaned_input[SHIPPING_ADDRESS_FIELD] = shipping_address\n\n        if billing_address_data:\n            billing_address = cls.validate_address(\n                billing_address_data,\n                address_type=AddressType.BILLING,\n                instance=getattr(instance, BILLING_ADDRESS_FIELD),\n                info=info,\n            )\n            cleaned_input[BILLING_ADDRESS_FIELD] = billing_address\n\n        if cleaned_input.get(\"redirect_url\"):\n            try:\n                validate_storefront_url(cleaned_input.get(\"redirect_url\"))\n            except ValidationError as error:\n                raise ValidationError(\n                    {\"redirect_url\": error}, code=AccountErrorCode.INVALID\n                )\n\n        return cleaned_input\n\n    @classmethod\n    @traced_atomic_transaction()\n    def save(cls, info, instance, cleaned_input):\n        default_shipping_address = cleaned_input.get(SHIPPING_ADDRESS_FIELD)\n        manager = load_plugin_manager(info.context)\n        if default_shipping_address:\n            default_shipping_address = manager.change_user_address(\n                default_shipping_address, \"shipping\", instance\n            )\n            default_shipping_address.save()\n            instance.default_shipping_address = default_shipping_address\n        default_billing_address = cleaned_input.get(BILLING_ADDRESS_FIELD)\n        if default_billing_address:\n            default_billing_address = manager.change_user_address(\n                default_billing_address, \"billing\", instance\n            )\n            default_billing_address.save()\n            instance.default_billing_address = default_billing_address\n\n        is_creation = instance.pk is None\n        super().save(info, instance, cleaned_input)\n        if default_billing_address:\n            instance.addresses.add(default_billing_address)\n        if default_shipping_address:\n            instance.addresses.add(default_shipping_address)\n\n        instance.search_document = prepare_user_search_document_value(instance)\n        instance.save(update_fields=[\"search_document\", \"updated_at\"])\n\n        # The instance is a new object in db, create an event\n        if is_creation:\n            manager.customer_created(customer=instance)\n            account_events.customer_account_created_event(user=instance)\n        else:\n            manager.customer_updated(instance)\n\n        if cleaned_input.get(\"redirect_url\"):\n            channel_slug = cleaned_input.get(\"channel\")\n            if not instance.is_staff:\n                channel_slug = clean_channel(\n                    channel_slug, error_class=AccountErrorCode\n                ).slug\n            elif channel_slug is not None:\n                channel_slug = validate_channel(\n                    channel_slug, error_class=AccountErrorCode\n                ).slug\n            send_set_password_notification(\n                cleaned_input.get(\"redirect_url\"),\n                instance,\n                manager,\n                channel_slug,\n            )\n", "from dataclasses import dataclass\nfrom typing import Dict, List, Optional, Type\n\nimport graphene\nfrom django.core.exceptions import ValidationError\nfrom django.db import transaction\nfrom django.db.models import Model\n\nfrom ...core.permissions import MenuPermissions, SitePermissions\nfrom ...core.tracing import traced_atomic_transaction\nfrom ...menu import models\nfrom ...menu.error_codes import MenuErrorCode\nfrom ...page import models as page_models\nfrom ...product import models as product_models\nfrom ..channel import ChannelContext\nfrom ..core.mutations import BaseMutation, ModelDeleteMutation, ModelMutation\nfrom ..core.types import MenuError, NonNullList\nfrom ..core.utils import validate_slug_and_generate_if_needed\nfrom ..core.utils.reordering import perform_reordering\nfrom ..page.types import Page\nfrom ..plugins.dataloaders import load_plugin_manager\nfrom ..product.types import Category, Collection\nfrom ..site.dataloaders import load_site\nfrom .dataloaders import MenuItemsByParentMenuLoader\nfrom .enums import NavigationType\nfrom .types import Menu, MenuItem, MenuItemMoveInput\n\n\nclass MenuItemInput(graphene.InputObjectType):\n    name = graphene.String(description=\"Name of the menu item.\")\n    url = graphene.String(description=\"URL of the pointed item.\")\n    category = graphene.ID(\n        description=\"Category to which item points.\", name=\"category\"\n    )\n    collection = graphene.ID(\n        description=\"Collection to which item points.\", name=\"collection\"\n    )\n    page = graphene.ID(description=\"Page to which item points.\", name=\"page\")\n\n\nclass MenuItemCreateInput(MenuItemInput):\n    name = graphene.String(description=\"Name of the menu item.\", required=True)\n    menu = graphene.ID(\n        description=\"Menu to which item belongs.\", name=\"menu\", required=True\n    )\n    parent = graphene.ID(\n        description=\"ID of the parent menu. If empty, menu will be top level menu.\",\n        name=\"parent\",\n    )\n\n\nclass MenuCreateInput(graphene.InputObjectType):\n    name = graphene.String(description=\"Name of the menu.\", required=True)\n    slug = graphene.String(\n        description=\"Slug of the menu. Will be generated if not provided.\",\n        required=False,\n    )\n    items = NonNullList(MenuItemInput, description=\"List of menu items.\")\n\n\nclass MenuCreate(ModelMutation):\n    class Arguments:\n        input = MenuCreateInput(\n            required=True, description=\"Fields required to create a menu.\"\n        )\n\n    class Meta:\n        description = \"Creates a new Menu.\"\n        model = models.Menu\n        object_type = Menu\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def clean_input(cls, info, instance, data):\n        cleaned_input = super().clean_input(info, instance, data)\n        try:\n            cleaned_input = validate_slug_and_generate_if_needed(\n                instance, \"name\", cleaned_input\n            )\n        except ValidationError as error:\n            error.code = MenuErrorCode.REQUIRED.value\n            raise ValidationError({\"slug\": error})\n\n        items = []\n        for item in cleaned_input.get(\"items\", []):\n            category = item.get(\"category\")\n            collection = item.get(\"collection\")\n            page = item.get(\"page\")\n            url = item.get(\"url\")\n            if len([i for i in [category, collection, page, url] if i]) > 1:\n                raise ValidationError(\n                    {\n                        \"items\": ValidationError(\n                            \"More than one item provided.\",\n                            code=MenuErrorCode.TOO_MANY_MENU_ITEMS,\n                        )\n                    }\n                )\n\n            if category:\n                category = cls.get_node_or_error(\n                    info, category, field=\"items\", only_type=Category\n                )\n                item[\"category\"] = category\n            elif collection:\n                collection = cls.get_node_or_error(\n                    info, collection, field=\"items\", only_type=Collection\n                )\n                item[\"collection\"] = collection\n            elif page:\n                page = cls.get_node_or_error(info, page, field=\"items\", only_type=Page)\n                item[\"page\"] = page\n            elif not url:\n                raise ValidationError(\n                    {\n                        \"items\": ValidationError(\n                            \"No menu item provided.\",\n                            code=MenuErrorCode.NO_MENU_ITEM_PROVIDED,\n                        )\n                    }\n                )\n            items.append(item)\n        cleaned_input[\"items\"] = items\n        return cleaned_input\n\n    @classmethod\n    def _save_m2m(cls, info, instance, cleaned_data):\n        super()._save_m2m(info, instance, cleaned_data)\n        items = cleaned_data.get(\"items\", [])\n        for item in items:\n            instance.items.create(**item)\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_created(instance)\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n\nclass MenuInput(graphene.InputObjectType):\n    name = graphene.String(description=\"Name of the menu.\")\n    slug = graphene.String(description=\"Slug of the menu.\", required=False)\n\n\nclass MenuUpdate(ModelMutation):\n    class Arguments:\n        id = graphene.ID(required=True, description=\"ID of a menu to update.\")\n        input = MenuInput(\n            required=True, description=\"Fields required to update a menu.\"\n        )\n\n    class Meta:\n        description = \"Updates a menu.\"\n        model = models.Menu\n        object_type = Menu\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_updated(instance)\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n\nclass MenuDelete(ModelDeleteMutation):\n    class Arguments:\n        id = graphene.ID(required=True, description=\"ID of a menu to delete.\")\n\n    class Meta:\n        description = \"Deletes a menu.\"\n        model = models.Menu\n        object_type = Menu\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_deleted(instance)\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n\ndef _validate_menu_item_instance(\n    cleaned_input: dict, field: str, expected_model: Type[Model]\n):\n    \"\"\"Check if the value to assign as a menu item matches the expected model.\"\"\"\n    item = cleaned_input.get(field)\n    if item:\n        if not isinstance(item, expected_model):\n            msg = (\n                f\"Enter a valid {expected_model._meta.verbose_name} ID \"\n                f\"(got {item._meta.verbose_name} ID).\"\n            )\n            raise ValidationError(\n                {\n                    field: ValidationError(\n                        msg, code=MenuErrorCode.INVALID_MENU_ITEM.value\n                    )\n                }\n            )\n\n\nclass MenuItemCreate(ModelMutation):\n    class Arguments:\n        input = MenuItemCreateInput(\n            required=True,\n            description=(\n                \"Fields required to update a menu item. Only one of `url`, `category`, \"\n                \"`page`, `collection` is allowed per item.\"\n            ),\n        )\n\n    class Meta:\n        description = \"Creates a new menu item.\"\n        model = models.MenuItem\n        object_type = MenuItem\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_item_created(instance)\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n    @classmethod\n    def clean_input(cls, info, instance, data):\n        cleaned_input = super().clean_input(info, instance, data)\n\n        _validate_menu_item_instance(cleaned_input, \"page\", page_models.Page)\n        _validate_menu_item_instance(\n            cleaned_input, \"collection\", product_models.Collection\n        )\n        _validate_menu_item_instance(cleaned_input, \"category\", product_models.Category)\n\n        items = [\n            cleaned_input.get(\"page\"),\n            cleaned_input.get(\"collection\"),\n            cleaned_input.get(\"url\"),\n            cleaned_input.get(\"category\"),\n        ]\n        items = [item for item in items if item is not None]\n        if len(items) > 1:\n            raise ValidationError(\n                \"More than one item provided.\", code=MenuErrorCode.TOO_MANY_MENU_ITEMS\n            )\n        return cleaned_input\n\n\nclass MenuItemUpdate(MenuItemCreate):\n    class Arguments:\n        id = graphene.ID(required=True, description=\"ID of a menu item to update.\")\n        input = MenuItemInput(\n            required=True,\n            description=(\n                \"Fields required to update a menu item. Only one of `url`, `category`, \"\n                \"`page`, `collection` is allowed per item.\"\n            ),\n        )\n\n    class Meta:\n        description = \"Updates a menu item.\"\n        model = models.MenuItem\n        object_type = MenuItem\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def construct_instance(cls, instance, cleaned_data):\n        # Only one item can be assigned per menu item\n        instance.page = None\n        instance.collection = None\n        instance.category = None\n        instance.url = None\n        return super().construct_instance(instance, cleaned_data)\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_item_updated(instance)\n\n\nclass MenuItemDelete(ModelDeleteMutation):\n    class Arguments:\n        id = graphene.ID(required=True, description=\"ID of a menu item to delete.\")\n\n    class Meta:\n        description = \"Deletes a menu item.\"\n        model = models.MenuItem\n        object_type = MenuItem\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def post_save_action(cls, info, instance, cleaned_input):\n        manager = load_plugin_manager(info.context)\n        manager.menu_item_deleted(instance)\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n\n@dataclass(frozen=True)\nclass _MenuMoveOperation:\n    menu_item: models.MenuItem\n    parent_changed: bool\n    new_parent: Optional[models.MenuItem]\n    sort_order: int\n\n\nclass MenuItemMove(BaseMutation):\n    menu = graphene.Field(Menu, description=\"Assigned menu to move within.\")\n\n    class Arguments:\n        menu = graphene.ID(required=True, description=\"ID of the menu.\")\n        moves = NonNullList(\n            MenuItemMoveInput, required=True, description=\"The menu position data.\"\n        )\n\n    class Meta:\n        description = \"Moves items of menus.\"\n        permissions = (MenuPermissions.MANAGE_MENUS,)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def success_response(cls, instance):\n        instance = ChannelContext(node=instance, channel_slug=None)\n        return super().success_response(instance)\n\n    @staticmethod\n    def clean_move(move: MenuItemMoveInput):\n        \"\"\"Validate if the given move could be possibly possible.\"\"\"\n        if move.parent_id:\n            if move.item_id == move.parent_id:\n                raise ValidationError(\n                    {\n                        \"parent_id\": ValidationError(\n                            \"Cannot assign a node to itself.\",\n                            code=MenuErrorCode.CANNOT_ASSIGN_NODE.value,\n                        )\n                    }\n                )\n\n    @staticmethod\n    def clean_operation(operation: _MenuMoveOperation):\n        \"\"\"Validate if the given move will be actually possible.\"\"\"\n\n        if operation.new_parent is not None:\n            if operation.menu_item.is_ancestor_of(operation.new_parent):\n                raise ValidationError(\n                    {\n                        \"parent_id\": ValidationError(\n                            (\n                                \"Cannot assign a node as child of \"\n                                \"one of its descendants.\"\n                            ),\n                            code=MenuErrorCode.CANNOT_ASSIGN_NODE.value,\n                        )\n                    }\n                )\n\n    @classmethod\n    def get_operation(\n        cls,\n        info,\n        menu_item_to_current_parent,\n        menu: models.Menu,\n        move: MenuItemMoveInput,\n    ) -> _MenuMoveOperation:\n        menu_item = cls.get_node_or_error(\n            info, move.item_id, field=\"item\", only_type=\"MenuItem\", qs=menu.items\n        )\n        new_parent, parent_changed = None, False\n\n        # we want to check if parent has changes in relation to previous operations\n        # as moves are performed sequentially\n        old_parent_id = (\n            menu_item_to_current_parent[menu_item.pk]\n            if menu_item.pk in menu_item_to_current_parent\n            else menu_item.parent_id\n        )\n\n        if move.parent_id is not None:\n            parent_pk = cls.get_global_id_or_error(\n                move.parent_id, only_type=MenuItem, field=\"parent_id\"\n            )\n            if int(parent_pk) != old_parent_id:\n                new_parent = cls.get_node_or_error(\n                    info,\n                    move.parent_id,\n                    field=\"parent_id\",\n                    only_type=MenuItem,\n                    qs=menu.items,\n                )\n                parent_changed = True\n        elif move.parent_id is None and old_parent_id is not None:\n            parent_changed = True\n\n        return _MenuMoveOperation(\n            menu_item=menu_item,\n            new_parent=new_parent,\n            parent_changed=parent_changed,\n            sort_order=move.sort_order,\n        )\n\n    @classmethod\n    def clean_moves(\n        cls, info, menu: models.Menu, move_operations: List[MenuItemMoveInput]\n    ) -> List[_MenuMoveOperation]:\n        operations = []\n        item_to_current_parent: Dict[int, Optional[models.MenuItem]] = {}\n        for move in move_operations:\n            cls.clean_move(move)\n            operation = cls.get_operation(info, item_to_current_parent, menu, move)\n            if operation.parent_changed:\n                cls.clean_operation(operation)\n                item_to_current_parent[operation.menu_item.id] = operation.new_parent\n            operations.append(operation)\n        return operations\n\n    @staticmethod\n    def perform_change_parent_operation(operation: _MenuMoveOperation):\n        menu_item = operation.menu_item\n\n        if not operation.parent_changed:\n            return\n\n        # we need to refresh item, as it might be changes in previous operations\n        # and in such case the parent and level values are invalid\n        menu_item.refresh_from_db()\n\n        # parent cache need to be update in case of the item parent is changed\n        # more than once\n        menu_item._mptt_meta.update_mptt_cached_fields(menu_item)\n\n        # Move the parent\n        menu_item.parent = operation.new_parent\n        menu_item.sort_order = None\n        menu_item.save()\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, **data):\n        menu: str = data[\"menu\"]\n        moves: List[MenuItemMoveInput] = data[\"moves\"]\n        qs = models.Menu.objects.prefetch_related(\"items\")\n        menu = cls.get_node_or_error(info, menu, only_type=Menu, field=\"menu\", qs=qs)\n\n        operations = cls.clean_moves(info, menu, moves)\n        manager = load_plugin_manager(info.context)\n        for operation in operations:\n            cls.perform_change_parent_operation(operation)\n\n            menu_item = operation.menu_item\n\n            if operation.sort_order:\n                perform_reordering(\n                    menu_item.get_ordering_queryset(),\n                    {menu_item.pk: operation.sort_order},\n                )\n\n            if operation.sort_order or operation.parent_changed:\n                transaction.on_commit(lambda: manager.menu_item_updated(menu_item))\n\n        menu = qs.get(pk=menu.pk)\n        MenuItemsByParentMenuLoader(info.context).clear(menu.id)\n        return MenuItemMove(menu=ChannelContext(node=menu, channel_slug=None))\n\n\nclass AssignNavigation(BaseMutation):\n    menu = graphene.Field(Menu, description=\"Assigned navigation menu.\")\n\n    class Arguments:\n        menu = graphene.ID(description=\"ID of the menu.\")\n        navigation_type = NavigationType(\n            description=\"Type of the navigation bar to assign the menu to.\",\n            required=True,\n        )\n\n    class Meta:\n        description = \"Assigns storefront's navigation menus.\"\n        permissions = (MenuPermissions.MANAGE_MENUS, SitePermissions.MANAGE_SETTINGS)\n        error_type_class = MenuError\n        error_type_field = \"menu_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, navigation_type, menu=None):\n        site = load_site(info.context)\n        if menu is not None:\n            menu = cls.get_node_or_error(info, menu, field=\"menu\", only_type=Menu)\n\n        if navigation_type == NavigationType.MAIN:\n            site.settings.top_menu = menu\n            site.settings.save(update_fields=[\"top_menu\"])\n        elif navigation_type == NavigationType.SECONDARY:\n            site.settings.bottom_menu = menu\n            site.settings.save(update_fields=[\"bottom_menu\"])\n\n        if menu is None:\n            return AssignNavigation(menu=None)\n        return AssignNavigation(menu=ChannelContext(node=menu, channel_slug=None))\n", "from collections import defaultdict\nfrom typing import Iterable\n\nimport graphene\nfrom django.core.exceptions import ValidationError\nfrom django.db import transaction\nfrom django.db.models import Exists, OuterRef, Q, Subquery\nfrom django.db.models.fields import IntegerField\nfrom django.db.models.functions import Coalesce\nfrom graphene.types import InputObjectType\n\nfrom ....attribute import AttributeInputType\nfrom ....attribute import models as attribute_models\nfrom ....core.permissions import ProductPermissions, ProductTypePermissions\nfrom ....core.postgres import FlatConcatSearchVector\nfrom ....core.tracing import traced_atomic_transaction\nfrom ....order import events as order_events\nfrom ....order import models as order_models\nfrom ....order.tasks import recalculate_orders_task\nfrom ....product import models\nfrom ....product.error_codes import ProductErrorCode\nfrom ....product.search import (\n    prepare_product_search_vector_value,\n    update_product_search_vector,\n)\nfrom ....product.tasks import update_product_discounted_price_task\nfrom ....product.utils import delete_categories\nfrom ....product.utils.variants import generate_and_set_variant_name\nfrom ....warehouse import models as warehouse_models\nfrom ....warehouse.error_codes import StockErrorCode\nfrom ...app.dataloaders import load_app\nfrom ...channel import ChannelContext\nfrom ...channel.types import Channel\nfrom ...core.mutations import BaseMutation, ModelBulkDeleteMutation, ModelMutation\nfrom ...core.types import (\n    BulkProductError,\n    BulkStockError,\n    CollectionError,\n    NonNullList,\n    ProductError,\n    StockError,\n)\nfrom ...core.utils import get_duplicated_values\nfrom ...core.validators import validate_price_precision\nfrom ...plugins.dataloaders import load_plugin_manager\nfrom ...warehouse.dataloaders import (\n    StocksWithAvailableQuantityByProductVariantIdCountryCodeAndChannelLoader,\n)\nfrom ...warehouse.types import Warehouse\nfrom ..mutations.channels import ProductVariantChannelListingAddInput\nfrom ..mutations.products import (\n    AttributeAssignmentMixin,\n    ProductVariantCreate,\n    ProductVariantInput,\n    StockInput,\n)\nfrom ..types import (\n    Category,\n    Collection,\n    Product,\n    ProductMedia,\n    ProductType,\n    ProductVariant,\n)\nfrom ..utils import (\n    clean_variant_sku,\n    create_stocks,\n    get_draft_order_lines_data_for_variants,\n    get_used_variants_attribute_values,\n)\n\n\nclass CategoryBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID, required=True, description=\"List of category IDs to delete.\"\n        )\n\n    class Meta:\n        description = \"Deletes categories.\"\n        model = models.Category\n        object_type = Category\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = ProductError\n        error_type_field = \"product_errors\"\n\n    @classmethod\n    def bulk_action(cls, info, queryset):\n        manager = load_plugin_manager(info.context)\n        delete_categories(queryset.values_list(\"pk\", flat=True), manager)\n\n\nclass CollectionBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID, required=True, description=\"List of collection IDs to delete.\"\n        )\n\n    class Meta:\n        description = \"Deletes collections.\"\n        model = models.Collection\n        object_type = Collection\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = CollectionError\n        error_type_field = \"collection_errors\"\n\n    @classmethod\n    def bulk_action(cls, info, queryset):\n        collections_ids = queryset.values_list(\"id\", flat=True)\n        products = list(\n            models.Product.objects.prefetched_for_webhook(single_object=False)\n            .filter(collections__in=collections_ids)\n            .distinct()\n        )\n        manager = load_plugin_manager(info.context)\n        for collection in queryset.iterator():\n            manager.collection_deleted(collection)\n        queryset.delete()\n\n        for product in products:\n            manager.product_updated(product)\n\n\nclass ProductBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID, required=True, description=\"List of product IDs to delete.\"\n        )\n\n    class Meta:\n        description = \"Deletes products.\"\n        model = models.Product\n        object_type = Product\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = ProductError\n        error_type_field = \"product_errors\"\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, ids, **data):\n        try:\n            pks = cls.get_global_ids_or_error(ids, Product)\n        except ValidationError as error:\n            return 0, error\n        product_to_variant = list(\n            models.ProductVariant.objects.filter(product__pk__in=pks).values_list(\n                \"product_id\", \"id\"\n            )\n        )\n        variants_ids = [variant_id for _, variant_id in product_to_variant]\n\n        cls.delete_assigned_attribute_values(pks)\n\n        draft_order_lines_data = get_draft_order_lines_data_for_variants(variants_ids)\n\n        response = super().perform_mutation(\n            _root,\n            info,\n            ids,\n            product_to_variant=product_to_variant,\n            **data,\n        )\n\n        # delete order lines for deleted variants\n        order_models.OrderLine.objects.filter(\n            pk__in=draft_order_lines_data.line_pks\n        ).delete()\n\n        app = load_app(info.context)\n        # run order event for deleted lines\n        for order, order_lines in draft_order_lines_data.order_to_lines_mapping.items():\n            order_events.order_line_product_removed_event(\n                order, info.context.user, app, order_lines\n            )\n\n        order_pks = draft_order_lines_data.order_pks\n        if order_pks:\n            recalculate_orders_task.delay(list(order_pks))\n\n        return response\n\n    @staticmethod\n    def delete_assigned_attribute_values(instance_pks):\n        attribute_models.AttributeValue.objects.filter(\n            productassignments__product_id__in=instance_pks,\n            attribute__input_type__in=AttributeInputType.TYPES_WITH_UNIQUE_VALUES,\n        ).delete()\n\n    @classmethod\n    def bulk_action(cls, info, queryset, product_to_variant):\n        product_variant_map = defaultdict(list)\n        for product, variant in product_to_variant:\n            product_variant_map[product].append(variant)\n\n        products = [product for product in queryset]\n        queryset.delete()\n        manager = load_plugin_manager(info.context)\n        for product in products:\n            variants = product_variant_map.get(product.id, [])\n            manager.product_deleted(product, variants)\n\n\nclass BulkAttributeValueInput(InputObjectType):\n    id = graphene.ID(description=\"ID of the selected attribute.\")\n    values = NonNullList(\n        graphene.String,\n        required=False,\n        description=(\n            \"The value or slug of an attribute to resolve. \"\n            \"If the passed value is non-existent, it will be created.\"\n        ),\n    )\n    boolean = graphene.Boolean(\n        required=False,\n        description=(\n            \"The boolean value of an attribute to resolve. \"\n            \"If the passed value is non-existent, it will be created.\"\n        ),\n    )\n\n\nclass ProductVariantBulkCreateInput(ProductVariantInput):\n    attributes = NonNullList(\n        BulkAttributeValueInput,\n        required=True,\n        description=\"List of attributes specific to this variant.\",\n    )\n    stocks = NonNullList(\n        StockInput,\n        description=\"Stocks of a product available for sale.\",\n        required=False,\n    )\n    channel_listings = NonNullList(\n        ProductVariantChannelListingAddInput,\n        description=\"List of prices assigned to channels.\",\n        required=False,\n    )\n    sku = graphene.String(description=\"Stock keeping unit.\")\n\n\nclass ProductVariantBulkCreate(BaseMutation):\n    count = graphene.Int(\n        required=True,\n        default_value=0,\n        description=\"Returns how many objects were created.\",\n    )\n    product_variants = NonNullList(\n        ProductVariant,\n        required=True,\n        default_value=[],\n        description=\"List of the created variants.\",\n    )\n\n    class Arguments:\n        variants = NonNullList(\n            ProductVariantBulkCreateInput,\n            required=True,\n            description=\"Input list of product variants to create.\",\n        )\n        product_id = graphene.ID(\n            description=\"ID of the product to create the variants for.\",\n            name=\"product\",\n            required=True,\n        )\n\n    class Meta:\n        description = \"Creates product variants for a given product.\"\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = BulkProductError\n        error_type_field = \"bulk_product_errors\"\n\n    @classmethod\n    def clean_variant_input(\n        cls,\n        info,\n        instance: models.ProductVariant,\n        data: dict,\n        errors: dict,\n        variant_index: int,\n    ):\n        cleaned_input = ModelMutation.clean_input(\n            info, instance, data, input_cls=ProductVariantBulkCreateInput\n        )\n\n        attributes = cleaned_input.get(\"attributes\")\n        if attributes:\n            try:\n                cleaned_input[\"attributes\"] = ProductVariantCreate.clean_attributes(\n                    attributes, data[\"product_type\"]\n                )\n            except ValidationError as exc:\n                exc.params = {\"index\": variant_index}\n                errors[\"attributes\"] = exc\n\n        channel_listings = cleaned_input.get(\"channel_listings\")\n        if channel_listings:\n            cleaned_input[\"channel_listings\"] = cls.clean_channel_listings(\n                channel_listings, errors, data[\"product\"], variant_index\n            )\n\n        stocks = cleaned_input.get(\"stocks\")\n        if stocks:\n            cls.clean_stocks(stocks, errors, variant_index)\n\n        cleaned_input[\"sku\"] = clean_variant_sku(cleaned_input.get(\"sku\"))\n\n        preorder_settings = cleaned_input.get(\"preorder\")\n        if preorder_settings:\n            cleaned_input[\"is_preorder\"] = True\n            cleaned_input[\"preorder_global_threshold\"] = preorder_settings.get(\n                \"global_threshold\"\n            )\n            cleaned_input[\"preorder_end_date\"] = preorder_settings.get(\"end_date\")\n\n        return cleaned_input\n\n    @classmethod\n    def clean_price(\n        cls, price, field_name, currency, channel_id, variant_index, errors\n    ):\n        try:\n            validate_price_precision(price, currency)\n        except ValidationError as error:\n            error.code = ProductErrorCode.INVALID.value\n            error.params = {\n                \"channels\": [channel_id],\n                \"index\": variant_index,\n            }\n            errors[field_name].append(error)\n\n    @classmethod\n    def clean_channel_listings(cls, channels_data, errors, product, variant_index):\n        channel_ids = [\n            channel_listing[\"channel_id\"] for channel_listing in channels_data\n        ]\n        duplicates = get_duplicated_values(channel_ids)\n        if duplicates:\n            errors[\"channel_listings\"] = ValidationError(\n                \"Duplicated channel ID.\",\n                code=ProductErrorCode.DUPLICATED_INPUT_ITEM.value,\n                params={\"channels\": duplicates, \"index\": variant_index},\n            )\n            return channels_data\n        channels = cls.get_nodes_or_error(\n            channel_ids, \"channel_listings\", only_type=Channel\n        )\n        for index, channel_listing_data in enumerate(channels_data):\n            channel_listing_data[\"channel\"] = channels[index]\n\n        for channel_listing_data in channels_data:\n            price = channel_listing_data.get(\"price\")\n            cost_price = channel_listing_data.get(\"cost_price\")\n            channel_id = channel_listing_data[\"channel_id\"]\n            currency_code = channel_listing_data[\"channel\"].currency_code\n            cls.clean_price(\n                price, \"price\", currency_code, channel_id, variant_index, errors\n            )\n            cls.clean_price(\n                cost_price,\n                \"cost_price\",\n                currency_code,\n                channel_id,\n                variant_index,\n                errors,\n            )\n\n        channels_not_assigned_to_product = []\n        channels_assigned_to_product = list(\n            models.ProductChannelListing.objects.filter(product=product.id).values_list(\n                \"channel_id\", flat=True\n            )\n        )\n        for channel_listing_data in channels_data:\n            if not channel_listing_data[\"channel\"].id in channels_assigned_to_product:\n                channels_not_assigned_to_product.append(\n                    channel_listing_data[\"channel_id\"]\n                )\n        if channels_not_assigned_to_product:\n            errors[\"channel_id\"].append(\n                ValidationError(\n                    \"Product not available in channels.\",\n                    code=ProductErrorCode.PRODUCT_NOT_ASSIGNED_TO_CHANNEL.value,\n                    params={\n                        \"index\": variant_index,\n                        \"channels\": channels_not_assigned_to_product,\n                    },\n                )\n            )\n        return channels_data\n\n    @classmethod\n    def clean_stocks(cls, stocks_data, errors, variant_index):\n        warehouse_ids = [stock[\"warehouse\"] for stock in stocks_data]\n        duplicates = get_duplicated_values(warehouse_ids)\n        if duplicates:\n            errors[\"stocks\"] = ValidationError(\n                \"Duplicated warehouse ID.\",\n                code=ProductErrorCode.DUPLICATED_INPUT_ITEM.value,\n                params={\"warehouses\": duplicates, \"index\": variant_index},\n            )\n\n    @classmethod\n    def add_indexes_to_errors(cls, index, error, error_dict):\n        \"\"\"Append errors with index in params to mutation error dict.\"\"\"\n        for key, value in error.error_dict.items():\n            for e in value:\n                if e.params:\n                    e.params[\"index\"] = index\n                else:\n                    e.params = {\"index\": index}\n            error_dict[key].extend(value)\n\n    @classmethod\n    def save(cls, info, instance, cleaned_input):\n        instance.save()\n\n        attributes = cleaned_input.get(\"attributes\")\n        if attributes:\n            AttributeAssignmentMixin.save(instance, attributes)\n            if not instance.name:\n                generate_and_set_variant_name(instance, cleaned_input.get(\"sku\"))\n\n    @classmethod\n    def create_variants(cls, info, cleaned_inputs, product, errors):\n        instances = []\n        for index, cleaned_input in enumerate(cleaned_inputs):\n            if not cleaned_input:\n                continue\n            try:\n                instance = models.ProductVariant()\n                cleaned_input[\"product\"] = product\n                instance = cls.construct_instance(instance, cleaned_input)\n                cls.clean_instance(info, instance)\n                instances.append(instance)\n            except ValidationError as exc:\n                cls.add_indexes_to_errors(index, exc, errors)\n        return instances\n\n    @classmethod\n    def validate_duplicated_sku(cls, sku, index, sku_list, errors):\n        if sku in sku_list:\n            errors[\"sku\"].append(\n                ValidationError(\n                    \"Duplicated SKU.\", ProductErrorCode.UNIQUE, params={\"index\": index}\n                )\n            )\n        sku_list.append(sku)\n\n    @classmethod\n    def validate_duplicated_attribute_values(\n        cls, attributes_data, used_attribute_values, instance=None\n    ):\n        attribute_values = defaultdict(list)\n        for attr in attributes_data:\n            if \"boolean\" in attr:\n                attribute_values[attr.id] = attr[\"boolean\"]\n            else:\n                attribute_values[attr.id].extend(attr.get(\"values\", []))\n        if attribute_values in used_attribute_values:\n            raise ValidationError(\n                \"Duplicated attribute values for product variant.\",\n                ProductErrorCode.DUPLICATED_INPUT_ITEM,\n            )\n        used_attribute_values.append(attribute_values)\n\n    @classmethod\n    def clean_variants(cls, info, variants, product, errors):\n        cleaned_inputs = []\n        sku_list = []\n        used_attribute_values = get_used_variants_attribute_values(product)\n        for index, variant_data in enumerate(variants):\n            if variant_data.attributes:\n                try:\n                    cls.validate_duplicated_attribute_values(\n                        variant_data.attributes, used_attribute_values\n                    )\n                except ValidationError as exc:\n                    errors[\"attributes\"].append(\n                        ValidationError(exc.message, exc.code, params={\"index\": index})\n                    )\n\n            variant_data[\"product_type\"] = product.product_type\n            variant_data[\"product\"] = product\n            cleaned_input = cls.clean_variant_input(\n                info, None, variant_data, errors, index\n            )\n\n            cleaned_inputs.append(cleaned_input if cleaned_input else None)\n\n            if cleaned_input[\"sku\"]:\n                cls.validate_duplicated_sku(\n                    cleaned_input[\"sku\"], index, sku_list, errors\n                )\n        return cleaned_inputs\n\n    @classmethod\n    def create_variant_channel_listings(cls, variant, cleaned_input):\n        channel_listings_data = cleaned_input.get(\"channel_listings\")\n        if not channel_listings_data:\n            return\n        variant_channel_listings = []\n        for channel_listing_data in channel_listings_data:\n            channel = channel_listing_data[\"channel\"]\n            price = channel_listing_data[\"price\"]\n            cost_price = channel_listing_data.get(\"cost_price\")\n            preorder_quantity_threshold = channel_listing_data.get(\"preorder_threshold\")\n            variant_channel_listings.append(\n                models.ProductVariantChannelListing(\n                    channel=channel,\n                    variant=variant,\n                    price_amount=price,\n                    cost_price_amount=cost_price,\n                    currency=channel.currency_code,\n                    preorder_quantity_threshold=preorder_quantity_threshold,\n                )\n            )\n        models.ProductVariantChannelListing.objects.bulk_create(\n            variant_channel_listings\n        )\n\n    @classmethod\n    @traced_atomic_transaction()\n    def save_variants(cls, info, instances, product, cleaned_inputs):\n        assert len(instances) == len(\n            cleaned_inputs\n        ), \"There should be the same number of instances and cleaned inputs.\"\n        for instance, cleaned_input in zip(instances, cleaned_inputs):\n            cls.save(info, instance, cleaned_input)\n            cls.create_variant_stocks(instance, cleaned_input)\n            cls.create_variant_channel_listings(instance, cleaned_input)\n\n        if not product.default_variant:\n            product.default_variant = instances[0]\n            product.save(update_fields=[\"default_variant\", \"updated_at\"])\n\n    @classmethod\n    def create_variant_stocks(cls, variant, cleaned_input):\n        stocks = cleaned_input.get(\"stocks\")\n        if not stocks:\n            return\n        warehouse_ids = [stock[\"warehouse\"] for stock in stocks]\n        warehouses = cls.get_nodes_or_error(\n            warehouse_ids, \"warehouse\", only_type=Warehouse\n        )\n        create_stocks(variant, stocks, warehouses)\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, **data):\n        product = cls.get_node_or_error(info, data[\"product_id\"], only_type=\"Product\")\n        errors = defaultdict(list)\n\n        cleaned_inputs = cls.clean_variants(info, data[\"variants\"], product, errors)\n        instances = cls.create_variants(info, cleaned_inputs, product, errors)\n        if errors:\n            raise ValidationError(errors)\n        cls.save_variants(info, instances, product, cleaned_inputs)\n\n        # Recalculate the \"discounted price\" for the parent product\n        update_product_discounted_price_task.delay(product.pk)\n\n        instances = [\n            ChannelContext(node=instance, channel_slug=None) for instance in instances\n        ]\n\n        update_product_search_vector(product)\n        manager = load_plugin_manager(info.context)\n        transaction.on_commit(\n            lambda: [\n                manager.product_variant_created(instance.node) for instance in instances\n            ]\n        )\n\n        return ProductVariantBulkCreate(\n            count=len(instances), product_variants=instances\n        )\n\n\nclass ProductVariantBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID,\n            required=True,\n            description=\"List of product variant IDs to delete.\",\n        )\n\n    class Meta:\n        description = \"Deletes product variants.\"\n        model = models.ProductVariant\n        object_type = ProductVariant\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = ProductError\n        error_type_field = \"product_errors\"\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, ids, **data):\n        try:\n            pks = cls.get_global_ids_or_error(ids, ProductVariant)\n        except ValidationError as error:\n            return 0, error\n\n        draft_order_lines_data = get_draft_order_lines_data_for_variants(pks)\n\n        product_pks = list(\n            models.Product.objects.filter(variants__in=pks)\n            .distinct()\n            .values_list(\"pk\", flat=True)\n        )\n\n        # Get cached variants with related fields to fully populate webhook payload.\n        variants = list(\n            models.ProductVariant.objects.filter(id__in=pks).prefetch_related(\n                \"channel_listings\",\n                \"attributes__values\",\n                \"variant_media\",\n            )\n        )\n\n        cls.delete_assigned_attribute_values(pks)\n        cls.delete_product_channel_listings_without_available_variants(product_pks, pks)\n        response = super().perform_mutation(_root, info, ids, **data)\n        manager = load_plugin_manager(info.context)\n        transaction.on_commit(\n            lambda: [manager.product_variant_deleted(variant) for variant in variants]\n        )\n\n        # delete order lines for deleted variants\n        order_models.OrderLine.objects.filter(\n            pk__in=draft_order_lines_data.line_pks\n        ).delete()\n\n        app = load_app(info.context)\n        # run order event for deleted lines\n        for order, order_lines in draft_order_lines_data.order_to_lines_mapping.items():\n            order_events.order_line_variant_removed_event(\n                order, info.context.user, app, order_lines\n            )\n\n        order_pks = draft_order_lines_data.order_pks\n        if order_pks:\n            recalculate_orders_task.delay(list(order_pks))\n\n        # set new product default variant if any has been removed\n        products = models.Product.objects.filter(\n            pk__in=product_pks, default_variant__isnull=True\n        )\n        for product in products:\n            product.search_vector = FlatConcatSearchVector(\n                *prepare_product_search_vector_value(product)\n            )\n            product.default_variant = product.variants.first()\n            product.save(\n                update_fields=[\n                    \"default_variant\",\n                    \"search_vector\",\n                    \"updated_at\",\n                ]\n            )\n\n        return response\n\n    @staticmethod\n    def delete_assigned_attribute_values(instance_pks):\n        attribute_models.AttributeValue.objects.filter(\n            variantassignments__variant_id__in=instance_pks,\n            attribute__input_type__in=AttributeInputType.TYPES_WITH_UNIQUE_VALUES,\n        ).delete()\n\n    @staticmethod\n    def delete_product_channel_listings_without_available_variants(\n        product_pks: Iterable[int], variant_pks: Iterable[int]\n    ):\n        \"\"\"Delete invalid channel listings.\n\n        Delete product channel listings for product and channel for which\n        the last available variant has been deleted.\n        \"\"\"\n        variants = models.ProductVariant.objects.filter(\n            product_id__in=product_pks\n        ).exclude(id__in=variant_pks)\n\n        variant_subquery = Subquery(\n            queryset=variants.filter(id=OuterRef(\"variant_id\")).values(\"product_id\"),\n            output_field=IntegerField(),\n        )\n        variant_channel_listings = models.ProductVariantChannelListing.objects.annotate(\n            product_id=Coalesce(variant_subquery, 0)\n        )\n\n        invalid_product_channel_listings = models.ProductChannelListing.objects.filter(\n            product_id__in=product_pks\n        ).exclude(\n            Exists(\n                variant_channel_listings.filter(\n                    channel_id=OuterRef(\"channel_id\"), product_id=OuterRef(\"product_id\")\n                )\n            )\n        )\n        invalid_product_channel_listings.delete()\n\n\nclass ProductVariantStocksCreate(BaseMutation):\n    product_variant = graphene.Field(\n        ProductVariant, description=\"Updated product variant.\"\n    )\n\n    class Arguments:\n        variant_id = graphene.ID(\n            required=True,\n            description=\"ID of a product variant for which stocks will be created.\",\n        )\n        stocks = NonNullList(\n            StockInput,\n            required=True,\n            description=\"Input list of stocks to create.\",\n        )\n\n    class Meta:\n        description = \"Creates stocks for product variant.\"\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = BulkStockError\n        error_type_field = \"bulk_stock_errors\"\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, **data):\n        manager = load_plugin_manager(info.context)\n        errors = defaultdict(list)\n        stocks = data[\"stocks\"]\n        variant = cls.get_node_or_error(\n            info, data[\"variant_id\"], only_type=ProductVariant\n        )\n        if stocks:\n            warehouses = cls.clean_stocks_input(variant, stocks, errors)\n            if errors:\n                raise ValidationError(errors)\n            new_stocks = create_stocks(variant, stocks, warehouses)\n\n            for stock in new_stocks:\n                transaction.on_commit(\n                    lambda: manager.product_variant_back_in_stock(stock)\n                )\n\n        StocksWithAvailableQuantityByProductVariantIdCountryCodeAndChannelLoader(\n            info.context\n        ).clear((variant.id, None, None))\n\n        variant = ChannelContext(node=variant, channel_slug=None)\n        return cls(product_variant=variant)\n\n    @classmethod\n    def clean_stocks_input(cls, variant, stocks_data, errors):\n        warehouse_ids = [stock[\"warehouse\"] for stock in stocks_data]\n        cls.check_for_duplicates(warehouse_ids, errors)\n        warehouses = cls.get_nodes_or_error(\n            warehouse_ids, \"warehouse\", only_type=Warehouse\n        )\n        existing_stocks = variant.stocks.filter(warehouse__in=warehouses).values_list(\n            \"warehouse__pk\", flat=True\n        )\n        error_msg = \"Stock for this warehouse already exists for this product variant.\"\n        indexes = []\n        for warehouse_pk in existing_stocks:\n            warehouse_id = graphene.Node.to_global_id(\"Warehouse\", warehouse_pk)\n            indexes.extend(\n                [i for i, id in enumerate(warehouse_ids) if id == warehouse_id]\n            )\n        cls.update_errors(\n            errors, error_msg, \"warehouse\", StockErrorCode.UNIQUE, indexes\n        )\n\n        return warehouses\n\n    @classmethod\n    def check_for_duplicates(cls, warehouse_ids, errors):\n        duplicates = {id for id in warehouse_ids if warehouse_ids.count(id) > 1}\n        error_msg = \"Duplicated warehouse ID.\"\n        indexes = []\n        for duplicated_id in duplicates:\n            indexes.append(\n                [i for i, id in enumerate(warehouse_ids) if id == duplicated_id][-1]\n            )\n        cls.update_errors(\n            errors, error_msg, \"warehouse\", StockErrorCode.UNIQUE, indexes\n        )\n\n    @classmethod\n    def update_errors(cls, errors, msg, field, code, indexes):\n        for index in indexes:\n            error = ValidationError(msg, code=code, params={\"index\": index})\n            errors[field].append(error)\n\n\nclass ProductVariantStocksUpdate(ProductVariantStocksCreate):\n    class Meta:\n        description = \"Update stocks for product variant.\"\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = BulkStockError\n        error_type_field = \"bulk_stock_errors\"\n\n    @classmethod\n    def perform_mutation(cls, _root, info, **data):\n        errors = defaultdict(list)\n        stocks = data[\"stocks\"]\n        variant = cls.get_node_or_error(\n            info, data[\"variant_id\"], only_type=ProductVariant\n        )\n        if stocks:\n            warehouse_ids = [stock[\"warehouse\"] for stock in stocks]\n            cls.check_for_duplicates(warehouse_ids, errors)\n            if errors:\n                raise ValidationError(errors)\n            warehouses = cls.get_nodes_or_error(\n                warehouse_ids, \"warehouse\", only_type=Warehouse\n            )\n\n            manager = load_plugin_manager(info.context)\n            cls.update_or_create_variant_stocks(variant, stocks, warehouses, manager)\n\n        StocksWithAvailableQuantityByProductVariantIdCountryCodeAndChannelLoader(\n            info.context\n        ).clear((variant.id, None, None))\n\n        variant = ChannelContext(node=variant, channel_slug=None)\n        return cls(product_variant=variant)\n\n    @classmethod\n    @traced_atomic_transaction()\n    def update_or_create_variant_stocks(cls, variant, stocks_data, warehouses, manager):\n\n        stocks = []\n        for stock_data, warehouse in zip(stocks_data, warehouses):\n            stock, is_created = warehouse_models.Stock.objects.get_or_create(\n                product_variant=variant, warehouse=warehouse\n            )\n\n            if is_created or (stock.quantity <= 0 and stock_data[\"quantity\"] > 0):\n                transaction.on_commit(\n                    lambda: manager.product_variant_back_in_stock(stock)\n                )\n\n            if stock_data[\"quantity\"] <= 0:\n                transaction.on_commit(\n                    lambda: manager.product_variant_out_of_stock(stock)\n                )\n\n            stock.quantity = stock_data[\"quantity\"]\n            stocks.append(stock)\n\n        warehouse_models.Stock.objects.bulk_update(stocks, [\"quantity\"])\n\n\nclass ProductVariantStocksDelete(BaseMutation):\n    product_variant = graphene.Field(\n        ProductVariant, description=\"Updated product variant.\"\n    )\n\n    class Arguments:\n        variant_id = graphene.ID(\n            required=True,\n            description=\"ID of product variant for which stocks will be deleted.\",\n        )\n        warehouse_ids = NonNullList(graphene.ID)\n\n    class Meta:\n        description = \"Delete stocks from product variant.\"\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = StockError\n        error_type_field = \"stock_errors\"\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, **data):\n        manager = load_plugin_manager(info.context)\n        variant = cls.get_node_or_error(\n            info, data[\"variant_id\"], only_type=ProductVariant\n        )\n        warehouses_pks = cls.get_global_ids_or_error(\n            data[\"warehouse_ids\"], Warehouse, field=\"warehouse_ids\"\n        )\n        stocks_to_delete = warehouse_models.Stock.objects.filter(\n            product_variant=variant, warehouse__pk__in=warehouses_pks\n        )\n\n        for stock in stocks_to_delete:\n            transaction.on_commit(lambda: manager.product_variant_out_of_stock(stock))\n\n        stocks_to_delete.delete()\n\n        StocksWithAvailableQuantityByProductVariantIdCountryCodeAndChannelLoader(\n            info.context\n        ).clear((variant.id, None, None))\n\n        variant = ChannelContext(node=variant, channel_slug=None)\n        return cls(product_variant=variant)\n\n\nclass ProductTypeBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID,\n            required=True,\n            description=\"List of product type IDs to delete.\",\n        )\n\n    class Meta:\n        description = \"Deletes product types.\"\n        model = models.ProductType\n        object_type = ProductType\n        permissions = (ProductTypePermissions.MANAGE_PRODUCT_TYPES_AND_ATTRIBUTES,)\n        error_type_class = ProductError\n        error_type_field = \"product_errors\"\n\n    @classmethod\n    @traced_atomic_transaction()\n    def perform_mutation(cls, _root, info, ids, **data):\n        try:\n            pks = cls.get_global_ids_or_error(ids, ProductType)\n        except ValidationError as error:\n            return 0, error\n        cls.delete_assigned_attribute_values(pks)\n        return super().perform_mutation(_root, info, ids, **data)\n\n    @staticmethod\n    def delete_assigned_attribute_values(instance_pks):\n        attribute_models.AttributeValue.objects.filter(\n            Q(attribute__input_type__in=AttributeInputType.TYPES_WITH_UNIQUE_VALUES)\n            & (\n                Q(productassignments__assignment__product_type_id__in=instance_pks)\n                | Q(variantassignments__assignment__product_type_id__in=instance_pks)\n            )\n        ).delete()\n\n\nclass ProductMediaBulkDelete(ModelBulkDeleteMutation):\n    class Arguments:\n        ids = NonNullList(\n            graphene.ID,\n            required=True,\n            description=\"List of product media IDs to delete.\",\n        )\n\n    class Meta:\n        description = \"Deletes product media.\"\n        model = models.ProductMedia\n        object_type = ProductMedia\n        permissions = (ProductPermissions.MANAGE_PRODUCTS,)\n        error_type_class = ProductError\n        error_type_field = \"product_errors\"\n"], "filenames": ["saleor/graphql/account/mutations/account.py", "saleor/graphql/account/mutations/base.py", "saleor/graphql/menu/mutations.py", "saleor/graphql/product/bulk_mutations/products.py"], "buggy_code_start_loc": [391, 372, 517, 550], "buggy_code_end_loc": [392, 373, 518, 551], "fixing_code_start_loc": [391, 372, 517, 550], "fixing_code_end_loc": [392, 373, 518, 551], "type": "CWE-863", "message": "Saleor is a headless, GraphQL commerce platform. In affected versions some GraphQL mutations were not properly checking the ID type input which allowed to access database objects that the authenticated user may not be allowed to access. This vulnerability can be used to expose the following information: Estimating database row counts from tables with a sequential primary key or Exposing staff user and customer email addresses and full name through the `assignNavigation()` mutation. This issue has been patched in main and backported to multiple releases (3.7.17, 3.6.18, 3.5.23, 3.4.24, 3.3.26, 3.2.14, 3.1.24). Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-39275", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-06T18:16:17.087", "lastModified": "2023-01-23T13:52:56.227", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Saleor is a headless, GraphQL commerce platform. In affected versions some GraphQL mutations were not properly checking the ID type input which allowed to access database objects that the authenticated user may not be allowed to access. This vulnerability can be used to expose the following information: Estimating database row counts from tables with a sequential primary key or Exposing staff user and customer email addresses and full name through the `assignNavigation()` mutation. This issue has been patched in main and backported to multiple releases (3.7.17, 3.6.18, 3.5.23, 3.4.24, 3.3.26, 3.2.14, 3.1.24). Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "Saleor es una plataforma de comercio GraphQL sin cabeza. En versiones afectadas, algunas mutaciones de GraphQL no comprobaban apropiadamente la entrada del tipo de identificaci\u00f3n, lo que permit\u00eda acceder a objetos de la base de datos a los que el usuario autenticado no pod\u00eda acceder. Esta vulnerabilidad puede ser usada para exponer la siguiente informaci\u00f3n: Estimar el recuento de filas de la base de datos a partir de tablas con una clave primaria secuencial o Exponer las direcciones de correo electr\u00f3nico y el nombre completo de los usuarios y clientes mediante de la mutaci\u00f3n \"assignNavigation()\". Este problema ha sido parcheado en main y retrocedido a m\u00faltiples versiones (3.7.17, 3.6.18, 3.5.23, 3.4.24, 3.3.26, 3.2.14, 3.1.24). Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-863"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:saleor:saleor:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndExcluding": "3.1.24", "matchCriteriaId": "8909BA64-BB3D-46A1-8EE6-30254F71912A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:saleor:saleor:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2.0", "versionEndExcluding": "3.2.14", "matchCriteriaId": "8601FD43-78F0-4116-8512-B0782F57D541"}, {"vulnerable": true, "criteria": "cpe:2.3:a:saleor:saleor:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3.0", "versionEndExcluding": "3.3.26", "matchCriteriaId": "974C1CBE-BD88-4A08-8408-3DCBEE5D89A6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:saleor:saleor:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.24", "matchCriteriaId": "E3D576A0-7030-492E-8B4F-8C3E422F8AA3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:saleor:saleor:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.5.0", "versionEndExcluding": "3.5.23", "matchCriteriaId": "8199E868-BC79-4C44-A200-14D1FA713DFF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:saleor:saleor:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.6.0", "versionEndExcluding": "3.6.18", "matchCriteriaId": "6FD1469B-074B-4F27-BA62-77D6BBCBAD5B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:saleor:saleor:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.7.0", "versionEndExcluding": "3.7.17", "matchCriteriaId": "3C6E7AD5-E707-4CC3-9DCA-FE6AF5BAF83F"}]}]}], "references": [{"url": "https://github.com/saleor/saleor/commit/96e04c092ddcac17b14f2e31554aa02d9006d0ce", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/saleor/saleor/security/advisories/GHSA-xhq8-8c5v-w8ff", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/saleor/saleor/commit/96e04c092ddcac17b14f2e31554aa02d9006d0ce"}}