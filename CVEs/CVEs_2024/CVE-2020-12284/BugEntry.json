{"buggy_code": ["/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"cbs.h\"\n#include \"cbs_internal.h\"\n#include \"cbs_jpeg.h\"\n\n\n#define HEADER(name) do { \\\n        ff_cbs_trace_header(ctx, name); \\\n    } while (0)\n\n#define CHECK(call) do { \\\n        err = (call); \\\n        if (err < 0) \\\n            return err; \\\n    } while (0)\n\n#define SUBSCRIPTS(subs, ...) (subs > 0 ? ((int[subs + 1]){ subs, __VA_ARGS__ }) : NULL)\n\n#define u(width, name, range_min, range_max) \\\n    xu(width, name, range_min, range_max, 0)\n#define us(width, name, sub, range_min, range_max) \\\n    xu(width, name, range_min, range_max, 1, sub)\n\n\n#define READ\n#define READWRITE read\n#define RWContext GetBitContext\n#define FUNC(name) cbs_jpeg_read_ ## name\n\n#define xu(width, name, range_min, range_max, subs, ...) do { \\\n        uint32_t value; \\\n        CHECK(ff_cbs_read_unsigned(ctx, rw, width, #name, \\\n                                   SUBSCRIPTS(subs, __VA_ARGS__), \\\n                                   &value, range_min, range_max)); \\\n        current->name = value; \\\n    } while (0)\n\n#include \"cbs_jpeg_syntax_template.c\"\n\n#undef READ\n#undef READWRITE\n#undef RWContext\n#undef FUNC\n#undef xu\n\n#define WRITE\n#define READWRITE write\n#define RWContext PutBitContext\n#define FUNC(name) cbs_jpeg_write_ ## name\n\n#define xu(width, name, range_min, range_max, subs, ...) do { \\\n        uint32_t value = current->name; \\\n        CHECK(ff_cbs_write_unsigned(ctx, rw, width, #name, \\\n                                    SUBSCRIPTS(subs, __VA_ARGS__), \\\n                                    value, range_min, range_max)); \\\n    } while (0)\n\n\n#include \"cbs_jpeg_syntax_template.c\"\n\n#undef WRITE\n#undef READWRITE\n#undef RWContext\n#undef FUNC\n#undef xu\n\n\nstatic void cbs_jpeg_free_application_data(void *opaque, uint8_t *content)\n{\n    JPEGRawApplicationData *ad = (JPEGRawApplicationData*)content;\n    av_buffer_unref(&ad->Ap_ref);\n    av_freep(&content);\n}\n\nstatic void cbs_jpeg_free_comment(void *opaque, uint8_t *content)\n{\n    JPEGRawComment *comment = (JPEGRawComment*)content;\n    av_buffer_unref(&comment->Cm_ref);\n    av_freep(&content);\n}\n\nstatic void cbs_jpeg_free_scan(void *opaque, uint8_t *content)\n{\n    JPEGRawScan *scan = (JPEGRawScan*)content;\n    av_buffer_unref(&scan->data_ref);\n    av_freep(&content);\n}\n\nstatic int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,\n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}\n\nstatic int cbs_jpeg_read_unit(CodedBitstreamContext *ctx,\n                              CodedBitstreamUnit *unit)\n{\n    GetBitContext gbc;\n    int err;\n\n    err = init_get_bits(&gbc, unit->data, 8 * unit->data_size);\n    if (err < 0)\n        return err;\n\n    if (unit->type >= JPEG_MARKER_SOF0 &&\n        unit->type <= JPEG_MARKER_SOF3) {\n        err = ff_cbs_alloc_unit_content(ctx, unit,\n                                        sizeof(JPEGRawFrameHeader),\n                                        NULL);\n        if (err < 0)\n            return err;\n\n        err = cbs_jpeg_read_frame_header(ctx, &gbc, unit->content);\n        if (err < 0)\n            return err;\n\n    } else if (unit->type >= JPEG_MARKER_APPN &&\n               unit->type <= JPEG_MARKER_APPN + 15) {\n        err = ff_cbs_alloc_unit_content(ctx, unit,\n                                        sizeof(JPEGRawApplicationData),\n                                        &cbs_jpeg_free_application_data);\n        if (err < 0)\n            return err;\n\n        err = cbs_jpeg_read_application_data(ctx, &gbc, unit->content);\n        if (err < 0)\n            return err;\n\n    } else if (unit->type == JPEG_MARKER_SOS) {\n        JPEGRawScan *scan;\n        int pos;\n\n        err = ff_cbs_alloc_unit_content(ctx, unit,\n                                        sizeof(JPEGRawScan),\n                                        &cbs_jpeg_free_scan);\n        if (err < 0)\n            return err;\n        scan = unit->content;\n\n        err = cbs_jpeg_read_scan_header(ctx, &gbc, &scan->header);\n        if (err < 0)\n            return err;\n\n        pos = get_bits_count(&gbc);\n        av_assert0(pos % 8 == 0);\n        if (pos > 0) {\n            scan->data_size = unit->data_size - pos / 8;\n            scan->data_ref  = av_buffer_ref(unit->data_ref);\n            if (!scan->data_ref)\n                return AVERROR(ENOMEM);\n            scan->data = unit->data + pos / 8;\n        }\n\n    } else {\n        switch (unit->type) {\n#define SEGMENT(marker, type, func, free) \\\n        case JPEG_MARKER_ ## marker: \\\n            { \\\n                err = ff_cbs_alloc_unit_content(ctx, unit, \\\n                                                sizeof(type), free); \\\n                if (err < 0) \\\n                    return err; \\\n                err = cbs_jpeg_read_ ## func(ctx, &gbc, unit->content); \\\n                if (err < 0) \\\n                    return err; \\\n            } \\\n            break\n            SEGMENT(DQT, JPEGRawQuantisationTableSpecification, dqt, NULL);\n            SEGMENT(DHT, JPEGRawHuffmanTableSpecification,      dht, NULL);\n            SEGMENT(COM, JPEGRawComment,  comment, &cbs_jpeg_free_comment);\n#undef SEGMENT\n        default:\n            return AVERROR(ENOSYS);\n        }\n    }\n\n    return 0;\n}\n\nstatic int cbs_jpeg_write_scan(CodedBitstreamContext *ctx,\n                               CodedBitstreamUnit *unit,\n                               PutBitContext *pbc)\n{\n    JPEGRawScan *scan = unit->content;\n    int err;\n\n    err = cbs_jpeg_write_scan_header(ctx, pbc, &scan->header);\n    if (err < 0)\n        return err;\n\n    if (scan->data) {\n        if (scan->data_size * 8 > put_bits_left(pbc))\n            return AVERROR(ENOSPC);\n\n        av_assert0(put_bits_count(pbc) % 8 == 0);\n\n        flush_put_bits(pbc);\n\n        memcpy(put_bits_ptr(pbc), scan->data, scan->data_size);\n        skip_put_bytes(pbc, scan->data_size);\n    }\n\n    return 0;\n}\n\nstatic int cbs_jpeg_write_segment(CodedBitstreamContext *ctx,\n                                  CodedBitstreamUnit *unit,\n                                  PutBitContext *pbc)\n{\n    int err;\n\n    if (unit->type >= JPEG_MARKER_SOF0 &&\n        unit->type <= JPEG_MARKER_SOF3) {\n        err = cbs_jpeg_write_frame_header(ctx, pbc, unit->content);\n    } else if (unit->type >= JPEG_MARKER_APPN &&\n               unit->type <= JPEG_MARKER_APPN + 15) {\n        err = cbs_jpeg_write_application_data(ctx, pbc, unit->content);\n    } else {\n        switch (unit->type) {\n#define SEGMENT(marker, func) \\\n            case JPEG_MARKER_ ## marker: \\\n                err = cbs_jpeg_write_ ## func(ctx, pbc, unit->content); \\\n                break;\n            SEGMENT(DQT, dqt);\n            SEGMENT(DHT, dht);\n            SEGMENT(COM, comment);\n        default:\n            return AVERROR_PATCHWELCOME;\n        }\n    }\n\n    return err;\n}\n\nstatic int cbs_jpeg_write_unit(CodedBitstreamContext *ctx,\n                               CodedBitstreamUnit *unit,\n                               PutBitContext *pbc)\n{\n    if (unit->type == JPEG_MARKER_SOS)\n        return cbs_jpeg_write_scan   (ctx, unit, pbc);\n    else\n        return cbs_jpeg_write_segment(ctx, unit, pbc);\n}\n\nstatic int cbs_jpeg_assemble_fragment(CodedBitstreamContext *ctx,\n                                       CodedBitstreamFragment *frag)\n{\n    const CodedBitstreamUnit *unit;\n    uint8_t *data;\n    size_t size, dp, sp;\n    int i;\n\n    size = 4; // SOI + EOI.\n    for (i = 0; i < frag->nb_units; i++) {\n        unit = &frag->units[i];\n        size += 2 + unit->data_size;\n        if (unit->type == JPEG_MARKER_SOS) {\n            for (sp = 0; sp < unit->data_size; sp++) {\n                if (unit->data[sp] == 0xff)\n                    ++size;\n            }\n        }\n    }\n\n    frag->data_ref = av_buffer_alloc(size + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!frag->data_ref)\n        return AVERROR(ENOMEM);\n    data = frag->data_ref->data;\n\n    dp = 0;\n\n    data[dp++] = 0xff;\n    data[dp++] = JPEG_MARKER_SOI;\n\n    for (i = 0; i < frag->nb_units; i++) {\n        unit = &frag->units[i];\n\n        data[dp++] = 0xff;\n        data[dp++] = unit->type;\n\n        if (unit->type != JPEG_MARKER_SOS) {\n            memcpy(data + dp, unit->data, unit->data_size);\n            dp += unit->data_size;\n        } else {\n            sp = AV_RB16(unit->data);\n            av_assert0(sp <= unit->data_size);\n            memcpy(data + dp, unit->data, sp);\n            dp += sp;\n\n            for (; sp < unit->data_size; sp++) {\n                if (unit->data[sp] == 0xff) {\n                    data[dp++] = 0xff;\n                    data[dp++] = 0x00;\n                } else {\n                    data[dp++] = unit->data[sp];\n                }\n            }\n        }\n    }\n\n    data[dp++] = 0xff;\n    data[dp++] = JPEG_MARKER_EOI;\n\n    av_assert0(dp == size);\n\n    memset(data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n    frag->data      = data;\n    frag->data_size = size;\n\n    return 0;\n}\n\nconst CodedBitstreamType ff_cbs_type_jpeg = {\n    .codec_id          = AV_CODEC_ID_MJPEG,\n\n    .split_fragment    = &cbs_jpeg_split_fragment,\n    .read_unit         = &cbs_jpeg_read_unit,\n    .write_unit        = &cbs_jpeg_write_unit,\n    .assemble_fragment = &cbs_jpeg_assemble_fragment,\n};\n"], "fixing_code": ["/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"cbs.h\"\n#include \"cbs_internal.h\"\n#include \"cbs_jpeg.h\"\n\n\n#define HEADER(name) do { \\\n        ff_cbs_trace_header(ctx, name); \\\n    } while (0)\n\n#define CHECK(call) do { \\\n        err = (call); \\\n        if (err < 0) \\\n            return err; \\\n    } while (0)\n\n#define SUBSCRIPTS(subs, ...) (subs > 0 ? ((int[subs + 1]){ subs, __VA_ARGS__ }) : NULL)\n\n#define u(width, name, range_min, range_max) \\\n    xu(width, name, range_min, range_max, 0)\n#define us(width, name, sub, range_min, range_max) \\\n    xu(width, name, range_min, range_max, 1, sub)\n\n\n#define READ\n#define READWRITE read\n#define RWContext GetBitContext\n#define FUNC(name) cbs_jpeg_read_ ## name\n\n#define xu(width, name, range_min, range_max, subs, ...) do { \\\n        uint32_t value; \\\n        CHECK(ff_cbs_read_unsigned(ctx, rw, width, #name, \\\n                                   SUBSCRIPTS(subs, __VA_ARGS__), \\\n                                   &value, range_min, range_max)); \\\n        current->name = value; \\\n    } while (0)\n\n#include \"cbs_jpeg_syntax_template.c\"\n\n#undef READ\n#undef READWRITE\n#undef RWContext\n#undef FUNC\n#undef xu\n\n#define WRITE\n#define READWRITE write\n#define RWContext PutBitContext\n#define FUNC(name) cbs_jpeg_write_ ## name\n\n#define xu(width, name, range_min, range_max, subs, ...) do { \\\n        uint32_t value = current->name; \\\n        CHECK(ff_cbs_write_unsigned(ctx, rw, width, #name, \\\n                                    SUBSCRIPTS(subs, __VA_ARGS__), \\\n                                    value, range_min, range_max)); \\\n    } while (0)\n\n\n#include \"cbs_jpeg_syntax_template.c\"\n\n#undef WRITE\n#undef READWRITE\n#undef RWContext\n#undef FUNC\n#undef xu\n\n\nstatic void cbs_jpeg_free_application_data(void *opaque, uint8_t *content)\n{\n    JPEGRawApplicationData *ad = (JPEGRawApplicationData*)content;\n    av_buffer_unref(&ad->Ap_ref);\n    av_freep(&content);\n}\n\nstatic void cbs_jpeg_free_comment(void *opaque, uint8_t *content)\n{\n    JPEGRawComment *comment = (JPEGRawComment*)content;\n    av_buffer_unref(&comment->Cm_ref);\n    av_freep(&content);\n}\n\nstatic void cbs_jpeg_free_scan(void *opaque, uint8_t *content)\n{\n    JPEGRawScan *scan = (JPEGRawScan*)content;\n    av_buffer_unref(&scan->data_ref);\n    av_freep(&content);\n}\n\nstatic int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,\n                                   CodedBitstreamFragment *frag,\n                                   int header)\n{\n    AVBufferRef *data_ref;\n    uint8_t *data;\n    size_t data_size;\n    int unit, start, end, marker, next_start, next_marker;\n    int err, i, j, length;\n\n    if (frag->data_size < 4) {\n        // Definitely too short to be meaningful.\n        return AVERROR_INVALIDDATA;\n    }\n\n    for (i = 0; i + 1 < frag->data_size && frag->data[i] != 0xff; i++);\n    if (i > 0) {\n        av_log(ctx->log_ctx, AV_LOG_WARNING, \"Discarding %d bytes at \"\n               \"beginning of image.\\n\", i);\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size && frag->data[i]) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no SOI marker found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    if (marker != JPEG_MARKER_SOI) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: first \"\n               \"marker is %02x, should be SOI.\\n\", marker);\n        return AVERROR_INVALIDDATA;\n    }\n    for (++i; i + 1 < frag->data_size && frag->data[i] == 0xff; i++);\n    if (i + 1 >= frag->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n               \"no image content found.\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    marker = frag->data[i];\n    start  = i + 1;\n\n    for (unit = 0;; unit++) {\n        if (marker == JPEG_MARKER_EOI) {\n            break;\n        } else if (marker == JPEG_MARKER_SOS) {\n            for (i = start; i + 1 < frag->data_size; i++) {\n                if (frag->data[i] != 0xff)\n                    continue;\n                end = i;\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    if (frag->data[i] == 0x00)\n                        continue;\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n                break;\n            }\n        } else {\n            i = start;\n            if (i + 2 > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            length = AV_RB16(frag->data + i);\n            if (i + length > frag->data_size) {\n                av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid JPEG image: \"\n                       \"truncated at %02x marker segment.\\n\", marker);\n                return AVERROR_INVALIDDATA;\n            }\n            end = start + length;\n\n            i = end;\n            if (frag->data[i] != 0xff) {\n                next_marker = -1;\n            } else {\n                for (++i; i + 1 < frag->data_size &&\n                          frag->data[i] == 0xff; i++);\n                if (i + 1 >= frag->data_size) {\n                    next_marker = -1;\n                } else {\n                    next_marker = frag->data[i];\n                    next_start  = i + 1;\n                }\n            }\n        }\n\n        if (marker == JPEG_MARKER_SOS) {\n            length = AV_RB16(frag->data + start);\n\n            if (length > end - start)\n                return AVERROR_INVALIDDATA;\n\n            data_ref = NULL;\n            data     = av_malloc(end - start +\n                                 AV_INPUT_BUFFER_PADDING_SIZE);\n            if (!data)\n                return AVERROR(ENOMEM);\n\n            memcpy(data, frag->data + start, length);\n            for (i = start + length, j = length; i < end; i++, j++) {\n                if (frag->data[i] == 0xff) {\n                    while (frag->data[i] == 0xff)\n                        ++i;\n                    data[j] = 0xff;\n                } else {\n                    data[j] = frag->data[i];\n                }\n            }\n            data_size = j;\n\n            memset(data + data_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        } else {\n            data      = frag->data + start;\n            data_size = end - start;\n            data_ref  = frag->data_ref;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, unit, marker,\n                                      data, data_size, data_ref);\n        if (err < 0)\n            return err;\n\n        if (next_marker == -1)\n            break;\n        marker = next_marker;\n        start  = next_start;\n    }\n\n    return 0;\n}\n\nstatic int cbs_jpeg_read_unit(CodedBitstreamContext *ctx,\n                              CodedBitstreamUnit *unit)\n{\n    GetBitContext gbc;\n    int err;\n\n    err = init_get_bits(&gbc, unit->data, 8 * unit->data_size);\n    if (err < 0)\n        return err;\n\n    if (unit->type >= JPEG_MARKER_SOF0 &&\n        unit->type <= JPEG_MARKER_SOF3) {\n        err = ff_cbs_alloc_unit_content(ctx, unit,\n                                        sizeof(JPEGRawFrameHeader),\n                                        NULL);\n        if (err < 0)\n            return err;\n\n        err = cbs_jpeg_read_frame_header(ctx, &gbc, unit->content);\n        if (err < 0)\n            return err;\n\n    } else if (unit->type >= JPEG_MARKER_APPN &&\n               unit->type <= JPEG_MARKER_APPN + 15) {\n        err = ff_cbs_alloc_unit_content(ctx, unit,\n                                        sizeof(JPEGRawApplicationData),\n                                        &cbs_jpeg_free_application_data);\n        if (err < 0)\n            return err;\n\n        err = cbs_jpeg_read_application_data(ctx, &gbc, unit->content);\n        if (err < 0)\n            return err;\n\n    } else if (unit->type == JPEG_MARKER_SOS) {\n        JPEGRawScan *scan;\n        int pos;\n\n        err = ff_cbs_alloc_unit_content(ctx, unit,\n                                        sizeof(JPEGRawScan),\n                                        &cbs_jpeg_free_scan);\n        if (err < 0)\n            return err;\n        scan = unit->content;\n\n        err = cbs_jpeg_read_scan_header(ctx, &gbc, &scan->header);\n        if (err < 0)\n            return err;\n\n        pos = get_bits_count(&gbc);\n        av_assert0(pos % 8 == 0);\n        if (pos > 0) {\n            scan->data_size = unit->data_size - pos / 8;\n            scan->data_ref  = av_buffer_ref(unit->data_ref);\n            if (!scan->data_ref)\n                return AVERROR(ENOMEM);\n            scan->data = unit->data + pos / 8;\n        }\n\n    } else {\n        switch (unit->type) {\n#define SEGMENT(marker, type, func, free) \\\n        case JPEG_MARKER_ ## marker: \\\n            { \\\n                err = ff_cbs_alloc_unit_content(ctx, unit, \\\n                                                sizeof(type), free); \\\n                if (err < 0) \\\n                    return err; \\\n                err = cbs_jpeg_read_ ## func(ctx, &gbc, unit->content); \\\n                if (err < 0) \\\n                    return err; \\\n            } \\\n            break\n            SEGMENT(DQT, JPEGRawQuantisationTableSpecification, dqt, NULL);\n            SEGMENT(DHT, JPEGRawHuffmanTableSpecification,      dht, NULL);\n            SEGMENT(COM, JPEGRawComment,  comment, &cbs_jpeg_free_comment);\n#undef SEGMENT\n        default:\n            return AVERROR(ENOSYS);\n        }\n    }\n\n    return 0;\n}\n\nstatic int cbs_jpeg_write_scan(CodedBitstreamContext *ctx,\n                               CodedBitstreamUnit *unit,\n                               PutBitContext *pbc)\n{\n    JPEGRawScan *scan = unit->content;\n    int err;\n\n    err = cbs_jpeg_write_scan_header(ctx, pbc, &scan->header);\n    if (err < 0)\n        return err;\n\n    if (scan->data) {\n        if (scan->data_size * 8 > put_bits_left(pbc))\n            return AVERROR(ENOSPC);\n\n        av_assert0(put_bits_count(pbc) % 8 == 0);\n\n        flush_put_bits(pbc);\n\n        memcpy(put_bits_ptr(pbc), scan->data, scan->data_size);\n        skip_put_bytes(pbc, scan->data_size);\n    }\n\n    return 0;\n}\n\nstatic int cbs_jpeg_write_segment(CodedBitstreamContext *ctx,\n                                  CodedBitstreamUnit *unit,\n                                  PutBitContext *pbc)\n{\n    int err;\n\n    if (unit->type >= JPEG_MARKER_SOF0 &&\n        unit->type <= JPEG_MARKER_SOF3) {\n        err = cbs_jpeg_write_frame_header(ctx, pbc, unit->content);\n    } else if (unit->type >= JPEG_MARKER_APPN &&\n               unit->type <= JPEG_MARKER_APPN + 15) {\n        err = cbs_jpeg_write_application_data(ctx, pbc, unit->content);\n    } else {\n        switch (unit->type) {\n#define SEGMENT(marker, func) \\\n            case JPEG_MARKER_ ## marker: \\\n                err = cbs_jpeg_write_ ## func(ctx, pbc, unit->content); \\\n                break;\n            SEGMENT(DQT, dqt);\n            SEGMENT(DHT, dht);\n            SEGMENT(COM, comment);\n        default:\n            return AVERROR_PATCHWELCOME;\n        }\n    }\n\n    return err;\n}\n\nstatic int cbs_jpeg_write_unit(CodedBitstreamContext *ctx,\n                               CodedBitstreamUnit *unit,\n                               PutBitContext *pbc)\n{\n    if (unit->type == JPEG_MARKER_SOS)\n        return cbs_jpeg_write_scan   (ctx, unit, pbc);\n    else\n        return cbs_jpeg_write_segment(ctx, unit, pbc);\n}\n\nstatic int cbs_jpeg_assemble_fragment(CodedBitstreamContext *ctx,\n                                       CodedBitstreamFragment *frag)\n{\n    const CodedBitstreamUnit *unit;\n    uint8_t *data;\n    size_t size, dp, sp;\n    int i;\n\n    size = 4; // SOI + EOI.\n    for (i = 0; i < frag->nb_units; i++) {\n        unit = &frag->units[i];\n        size += 2 + unit->data_size;\n        if (unit->type == JPEG_MARKER_SOS) {\n            for (sp = 0; sp < unit->data_size; sp++) {\n                if (unit->data[sp] == 0xff)\n                    ++size;\n            }\n        }\n    }\n\n    frag->data_ref = av_buffer_alloc(size + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!frag->data_ref)\n        return AVERROR(ENOMEM);\n    data = frag->data_ref->data;\n\n    dp = 0;\n\n    data[dp++] = 0xff;\n    data[dp++] = JPEG_MARKER_SOI;\n\n    for (i = 0; i < frag->nb_units; i++) {\n        unit = &frag->units[i];\n\n        data[dp++] = 0xff;\n        data[dp++] = unit->type;\n\n        if (unit->type != JPEG_MARKER_SOS) {\n            memcpy(data + dp, unit->data, unit->data_size);\n            dp += unit->data_size;\n        } else {\n            sp = AV_RB16(unit->data);\n            av_assert0(sp <= unit->data_size);\n            memcpy(data + dp, unit->data, sp);\n            dp += sp;\n\n            for (; sp < unit->data_size; sp++) {\n                if (unit->data[sp] == 0xff) {\n                    data[dp++] = 0xff;\n                    data[dp++] = 0x00;\n                } else {\n                    data[dp++] = unit->data[sp];\n                }\n            }\n        }\n    }\n\n    data[dp++] = 0xff;\n    data[dp++] = JPEG_MARKER_EOI;\n\n    av_assert0(dp == size);\n\n    memset(data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n    frag->data      = data;\n    frag->data_size = size;\n\n    return 0;\n}\n\nconst CodedBitstreamType ff_cbs_type_jpeg = {\n    .codec_id          = AV_CODEC_ID_MJPEG,\n\n    .split_fragment    = &cbs_jpeg_split_fragment,\n    .read_unit         = &cbs_jpeg_read_unit,\n    .write_unit        = &cbs_jpeg_write_unit,\n    .assemble_fragment = &cbs_jpeg_assemble_fragment,\n};\n"], "filenames": ["libavcodec/cbs_jpeg.c"], "buggy_code_start_loc": [198], "buggy_code_end_loc": [198], "fixing_code_start_loc": [199], "fixing_code_end_loc": [202], "type": "CWE-787", "message": "cbs_jpeg_split_fragment in libavcodec/cbs_jpeg.c in FFmpeg 4.1 and 4.2.2 has a heap-based buffer overflow during JPEG_MARKER_SOS handling because of a missing length check.", "other": {"cve": {"id": "CVE-2020-12284", "sourceIdentifier": "cve@mitre.org", "published": "2020-04-28T06:15:10.777", "lastModified": "2022-04-29T13:25:22.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cbs_jpeg_split_fragment in libavcodec/cbs_jpeg.c in FFmpeg 4.1 and 4.2.2 has a heap-based buffer overflow during JPEG_MARKER_SOS handling because of a missing length check."}, {"lang": "es", "value": "En la funci\u00f3n cbs_jpeg_split_fragment en el archivo libavcodec/cbs_jpeg.c en FFmpeg versi\u00f3n 4.1 y versi\u00f3n 4.2.2, presenta un desbordamiento del b\u00fafer en la regi\u00f3n heap de la memoria durante el manejo de JPEG_MARKER_SOS debido a una falta de comprobaci\u00f3n de longitud"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.1:*:*:*:*:*:*:*", "matchCriteriaId": "DC791808-C7E8-4298-9FB1-C1D72C573255"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.2.2:*:*:*:*:*:*:*", "matchCriteriaId": "C7A6D7C4-3C5A-46CA-B116-4FEF592CAAE5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=19734", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/a3a3730b5456ca00587455004d40c047f7b20a99", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202007-58", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4431-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4722", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/1812352d767ccf5431aa440123e2e260a4db2726"}}