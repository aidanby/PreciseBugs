{"buggy_code": ["/*\nCopyright (c) 2013, David C Horton\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <errno.h>\n#include <stdio.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <mutex>\n#include <algorithm>\n#include <regex>\n\n#include <boost/tokenizer.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/algorithm/string/split.hpp>\n#include <boost/algorithm/string/find.hpp>\n\n#include \"drachtio.h\"\n#include \"controller.hpp\"\n\n#include <sofia-sip/url.h>\n#include <sofia-sip/nta_tport.h>\n#include <sofia-sip/tport.h>\n#include <sofia-sip/msg.h>\n#include <sofia-sip/msg_addr.h>\n#include <sofia-sip/sip_parser.h>\n#include <sofia-sip/su_string.h>\n#include <sofia-sip/su_uniqueid.h>\n#include <sofia-sip/su_addrinfo.h>\n\n\n#define MAX_LINELEN 2047\n\n#define BOOST_UUID (1)\n\nusing namespace std ;\n \nnamespace {\n    unsigned int json_allocs = 0 ;\n    unsigned int json_bytes = 0 ;\n    std::mutex  json_lock ;\n} ;\n\nnamespace drachtio {\n    \n    typedef std::unordered_map<string,tag_type_t> mapHdr2Tag ;\n\n    typedef std::unordered_set<string> setHdr ;\n\n    typedef std::unordered_map<string,sip_method_t> mapMethod2Type ;\n\n\t/* headers that are allowed to be set by the client in responses to sip requests */\n\tmapHdr2Tag m_mapHdr2Tag({\n\t\t{string(\"user_agent\"), siptag_user_agent_str}, \n        {string(\"subject\"), siptag_subject_str}, \n        {string(\"max_forwards\"), siptag_max_forwards_str}, \n        {string(\"proxy_require\"), siptag_proxy_require_str}, \n        {string(\"accept_contact\"), siptag_accept_contact_str}, \n        {string(\"reject_contact\"), siptag_reject_contact_str}, \n        {string(\"expires\"), siptag_expires_str}, \n        {string(\"date\"), siptag_date_str}, \n        {string(\"retry_after\"), siptag_retry_after_str}, \n        {string(\"timestamp\"), siptag_timestamp_str}, \n        {string(\"min_expires\"), siptag_min_expires_str}, \n        {string(\"priority\"), siptag_priority_str}, \n        {string(\"call_info\"), siptag_call_info_str}, \n        {string(\"organization\"), siptag_organization_str}, \n        {string(\"server\"), siptag_server_str}, \n        {string(\"in_reply_to\"), siptag_in_reply_to_str}, \n        {string(\"accept\"), siptag_accept_str}, \n        {string(\"accept_encoding\"), siptag_accept_encoding_str}, \n        {string(\"accept_language\"), siptag_accept_language_str}, \n        {string(\"allow\"), siptag_allow_str}, \n        {string(\"require\"), siptag_require_str}, \n        {string(\"supported\"), siptag_supported_str}, \n        {string(\"unsupported\"), siptag_unsupported_str}, \n        {string(\"event\"), siptag_event_str}, \n        {string(\"allow_events\"), siptag_allow_events_str}, \n        {string(\"subscription_state\"), siptag_subscription_state_str}, \n        {string(\"proxy_authenticate\"), siptag_proxy_authenticate_str}, \n        {string(\"proxy_authentication_info\"), siptag_proxy_authentication_info_str}, \n        {string(\"proxy_authorization\"), siptag_proxy_authorization_str}, \n        {string(\"authorization\"), siptag_authorization_str}, \n        {string(\"www_authenticate\"), siptag_www_authenticate_str}, \n        {string(\"authentication_info\"), siptag_authentication_info_str}, \n        {string(\"error_info\"), siptag_error_info_str}, \n        {string(\"warning\"), siptag_warning_str}, \n        {string(\"refer_to\"), siptag_refer_to_str}, \n        {string(\"referred_by\"), siptag_referred_by_str}, \n        {string(\"replaces\"), siptag_replaces_str}, \n        {string(\"session_expires\"), siptag_session_expires_str}, \n        {string(\"min_se\"), siptag_min_se_str}, \n        {string(\"path\"), siptag_path_str}, \n        {string(\"service_route\"), siptag_service_route_str}, \n        {string(\"reason\"), siptag_reason_str}, \n        {string(\"security_client\"), siptag_security_client_str}, \n        {string(\"security_server\"), siptag_security_server_str}, \n        {string(\"security_verify\"), siptag_security_verify_str}, \n        {string(\"privacy\"), siptag_privacy_str}, \n        {string(\"sip_etag\"), siptag_etag_str}, \n        {string(\"sip_if_match\"), siptag_if_match_str}, \n        {string(\"mime_version\"), siptag_mime_version_str}, \n        {string(\"content_type\"), siptag_content_type_str}, \n        {string(\"content_encoding\"), siptag_content_encoding_str}, \n        {string(\"content_language\"), siptag_content_language_str}, \n        {string(\"content_disposition\"), siptag_content_disposition_str}, \n        {string(\"request_disposition\"), siptag_request_disposition_str}, \n        {string(\"error\"), siptag_error_str}, \n        {string(\"refer_sub\"), siptag_refer_sub_str}, \n        {string(\"alert_info\"), siptag_alert_info_str}, \n        {string(\"reply_to\"), siptag_reply_to_str}, \n        {string(\"p_asserted_identity\"), siptag_p_asserted_identity_str}, \n        {string(\"p_preferred_identity\"), siptag_p_preferred_identity_str}, \n        {string(\"remote_party_id\"), siptag_remote_party_id_str}, \n        {string(\"payload\"), siptag_payload_str}, \n        {string(\"from\"), siptag_from_str}, \n        {string(\"to\"), siptag_to_str}, \n        {string(\"call_id\"), siptag_call_id_str}, \n        {string(\"cseq\"), siptag_cseq_str}, \n        {string(\"via\"), siptag_via_str}, \n        {string(\"route\"), siptag_route_str}, \n        {string(\"contact\"), siptag_contact_str}, \n        {string(\"from\"), siptag_from_str}, \n        {string(\"to\"), siptag_to_str}, \n        {string(\"rseq\"), siptag_rseq_str}, \n        {string(\"rack\"), siptag_rack_str}, \n        {string(\"record_route\"), siptag_record_route_str}, \n        {string(\"content_length\"), siptag_content_length_str}\n\t});\n\n\t/* headers that are not allowed to be set by the client in responses to sip requests */\n\tsetHdr m_setImmutableHdrs({\n        {string(\"via\")},\n        {string(\"route\")},\n        {string(\"rseq\")},\n        {string(\"record_route\")}, \n        {string(\"content_length\")} \n\t});\n\n   mapMethod2Type m_mapMethod2Type({\n        {string(\"INVITE\"), sip_method_invite},\n        {string(\"ACK\"), sip_method_ack},\n        {string(\"CANCEL\"), sip_method_cancel},\n        {string(\"BYE\"), sip_method_bye},\n        {string(\"OPTIONS\"), sip_method_options},\n        {string(\"REGISTER\"), sip_method_register},\n        {string(\"INFO\"), sip_method_info},\n        {string(\"PRACK\"), sip_method_prack},\n        {string(\"UPDATE\"), sip_method_update},\n        {string(\"MESSAGE\"), sip_method_message},\n        {string(\"SUBSCRIBE\"), sip_method_subscribe},\n        {string(\"NOTIFY\"), sip_method_notify},\n        {string(\"REFER\"), sip_method_refer},\n        {string(\"PUBLISH\"), sip_method_publish} \n    });\n\n\n\tbool isImmutableHdr( const string& hdr ) {\n\t\treturn m_setImmutableHdrs.end() != m_setImmutableHdrs.find( hdr ) ;\n\t}\n\n\tbool getTagTypeForHdr( const string& hdr, tag_type_t& tag ) {\n\t\tmapHdr2Tag::const_iterator it = m_mapHdr2Tag.find( hdr ) ;\n\t\tif( it != m_mapHdr2Tag.end() ) {\n\t\t    tag = it->second ;\n\t\t    return true ;\n\t\t}\t\t\n\t\treturn false ;\n\t}\n\n\tvoid getSourceAddressForMsg(msg_t *msg, string& host) {\n        char name[SU_ADDRSIZE] = \"\";\n        su_sockaddr_t const *su = msg_addr(msg);\n        su_inet_ntop(su->su_family, SU_ADDR(su), name, sizeof(name));\n        host.assign(name);\n    }\n\n    void makeUniqueSipTransactionIdentifier(sip_t* sip, string& str) {\n        str = sip->sip_call_id->i_id ;\n        str.append(\"|\") ;\n        str.append((sip->sip_request && sip_method_cancel == sip->sip_request->rq_method) ?\n          \"INVITE\" :\n          sip->sip_cseq->cs_method_name) ;\n        str.append(\"|\") ;\n        str.append( boost::lexical_cast<std::string>(sip->sip_cseq->cs_seq) ) ;\n    }\n\n\tvoid generateUuid(string& uuid) {\n#ifdef BOOST_UUID\n\t    boost::uuids::uuid id = boost::uuids::random_generator()();\n        uuid = boost::lexical_cast<string>(id) ;\n#else\n        su_guid_t guid[1];\n        char b[su_guid_strlen + 1] ;\n\n        su_guid_generate(guid);\n\n        /*\n         * Guid looks like \"NNNNNNNN-NNNN-NNNN-NNNN-XXXXXXXXXXXX\"\n         * where NNNNNNNN-NNNN-NNNN-NNNN is timestamp and XX is MAC address\n         * (but we use usually random ID for MAC because we do not have\n         *  guid generator available for all processes within node)\n         */\n        su_guid_sprintf(b, su_guid_strlen + 1, guid);\n        uuid.assign( b ) ;\n#endif\n\n    }\t\n\n    void getTransportDescription( const tport_t* tp, string& desc ) {\n        if( tp ) {\n            const tp_name_t* tn = tport_name(tp) ;\n            char name[255] ;\n            sprintf(name, TPN_FORMAT, TPN_ARGS(tn) ) ;\n            desc.assign( name ) ;            \n        }\n    }\n    bool parseTransportDescription( const string& desc, string& proto, string& host, string& port ) {\n        try {\n            std::regex re(\"^(.*)/(.*):(\\\\d+)\");\n            std::smatch mr;\n            if (std::regex_search(desc, mr, re) && mr.size() > 1) {\n                proto = mr[1] ;\n                host = mr[2] ;\n                port = mr[3] ;\n                return true ;  \n            }\n        } catch (std::regex_error& e) {\n            DR_LOG(log_error) << \"parseTransportDescription - regex error: \" << e.what();\n        }\n        return false;\n    }\n    bool parseSipUri(const string& uri, string& scheme, string& userpart, string& hostpart, string& port, \n    vector< pair<string,string> >& params) {\n\n        try {\n            std::regex re(\"^<?(sip|sips):(?:([^;]+)@)?([^;|^>|^:]+)(?::(\\\\d+))?(?:;([^>]+))?>?$\");\n            std::regex re2(\"^<?(sip|sips):(?:([^;]+)@)?(\\\\[[0-9a-fA-F:]+\\\\])(?::(\\\\d+))?(?:;([^>]+))?>?$\");\n            std::smatch mr;\n            if (std::regex_search(uri, mr, re) || std::regex_search(uri, mr, re2)) {\n                scheme = mr[1] ;\n                userpart = mr[2] ;\n                hostpart = mr[3] ;\n                port = mr[4] ; \n\n                string paramString = mr[5] ;\n                if (paramString.length() > 0) {\n                  vector<string> strs;\n                  boost::split(strs, paramString, boost::is_any_of(\";\"));\n                  for (vector<string>::iterator it = strs.begin(); it != strs.end(); ++it) {\n                    vector<string> kv ;\n                    boost::split(kv, *it, boost::is_any_of(\"=\"));\n                    std::pair<string, string> kvpair(kv[0], kv.size() == 2 ? kv[1] : \"\");\n                    params.push_back(kvpair);\n                  }\n                }\n                return true ;\n            }\n        } catch (std::regex_error& e) {\n            DR_LOG(log_error) << \"parseSipUri - regex error: \" << e.what();\n        }\n        return false;\n    }\n\n\tvoid parseGenericHeader( msg_common_t* p, string& hvalue) {\n\t\tstring str((const char*) p->h_data, p->h_len) ;\n\t\tboost::char_separator<char> sep(\": \\r\\n\") ;\n        tokenizer tok( str, sep) ;\n        if( std::distance( tok.begin(), tok.end() ) > 1 ) hvalue = *(++tok.begin() ) ;\n \t}\n\n    bool FindCSeqMethod( const string& headers, string& method ) {\n        try {\n            std::regex re(\"^CSeq:\\\\s+\\\\d+\\\\s+(\\\\w+)$\");\n            std::smatch mr;\n            if (std::regex_search(headers, mr, re) && mr.size() > 1) {\n                method = mr[1] ;\n                return true ;                \n            }\n        } catch (std::regex_error& e) {\n            DR_LOG(log_error) << \"FindCSeqMethod - regex error: \" << e.what();\n        }\n        return false;\n    }\n\n    void EncodeStackMessage( const sip_t* sip, string& encodedMessage ) {\n        encodedMessage.clear() ;\n        const sip_common_t* p = NULL ;\n        if( sip->sip_request ) {\n            sip_header_t* hdr = (sip_header_t *) sip->sip_request ;\n            p = hdr->sh_common ;\n        }\n        else if( sip->sip_status ) {\n            sip_header_t* hdr = (sip_header_t *) sip->sip_status ;\n            p = hdr->sh_common ;\n        }\n\n        while( NULL != p) {\n            if( NULL != p->h_data ) {\n                //take the original fragment if it exists since this will be more efficient\n               encodedMessage.append( (char *)p->h_data, p->h_len ) ;            \n            }\n            else {\n                //otherwise, encode the sip header \n                char buf[8192] ;\n                issize_t n = msg_header_e(buf, 8192, reinterpret_cast<const msg_header_t *>(p), 0) ;\n                encodedMessage.append( buf, n ) ;\n            }\n            p = p->h_succ->sh_common ;\n        }\n    }\n\n    bool normalizeSipUri( std::string& uri, int brackets ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n\n        // buf gets passed into sip_name_addr_d which puts NULs in various locations so the url_t members can point to their bits\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n\n        // first we decode the string\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            // no go: if we can't decode it then we have an invalid input\n            return false ;\n        }\n\n        /* we allow applications to just give us a phone number sometimes, and that ends up parsed into the host portion with no scheme */\n        if( NULL == url->url_scheme && NULL == url->url_user && NULL != url->url_host ) {\n            url->url_scheme = \"sip\" ;\n            url->url_user = url->url_host ;\n            url->url_host = \"localhost\" ;   //placeholder\n         }\n\n        // now we re-encode it\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, brackets, url, params, comment) ;\n\n        // cleanup: free the msg_params if any were allocated        \n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }\n\n    bool replaceHostInUri( std::string& uri, const char* szHost, const char* szPort ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char obuf[255] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n\n        // buf gets passed into sip_name_addr_d which puts NULs in various locations so the url_t members can point to their bits\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n\n        // first we decode the string\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            // no go: if we can't decode it then we have an invalid input\n            return false ;\n        }\n\n        // now we repoint host and port\n        url->url_host = szHost ;\n        url->url_port = szPort ;\n\n        // now we re-encode it\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, 1, url, params, comment) ;\n\n        // cleanup: free the msg_params if any were allocated        \n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }\n\n    sip_method_t methodType( const string& method ) {\n        mapMethod2Type::const_iterator it = m_mapMethod2Type.find( method ) ;\n        if( m_mapMethod2Type.end() == it ) return sip_method_unknown ;\n        return it->second ;\n    }\n \n    bool isLocalSipUri( const string& requestUri ) {\n\n        static bool initialized = false ;\n        static vector< pair<string, string> > vecLocalUris ;\n\n        DR_LOG(log_debug) << \"isLocalSipUri: checking to see if this is one of mine: \" << requestUri ;\n\n        if( !initialized ) {\n            initialized = true ;\n\n            nta_agent_t* agent = theOneAndOnlyController->getAgent() ;\n            tport_t *t = nta_agent_tports( agent ) ;\n            for (tport_t* tport = t; tport; tport = tport_next(tport) ) {\n                const tp_name_t* tpn = tport_name( tport );\n                if( 0 == strcmp( tpn->tpn_host, \"*\") ) \n                    continue ;\n\n                string localUri = tpn->tpn_host ;\n                string localPort = NULL != tpn->tpn_port ? tpn->tpn_port : \"5060\" ;\n\n                //DR_LOG(log_debug) << \"isLocalSipUri: adding local address: \" << localUri << \":\" << localPort ;\n\n\n                vecLocalUris.push_back(make_pair(localUri, localPort)) ;\n\n                if( 0 == strcmp(tpn->tpn_host,\"127.0.0.1\") ) {\n                    vecLocalUris.push_back(make_pair(\"localhost\", localPort)) ;\n                }\n            }\n\n            // add public ip addresses and dns names\n            vector< pair<string, string> > vecIps ;\n            SipTransport::getAllExternalContacts(vecIps) ;\n            for(vector< pair<string, string> >::const_iterator it = vecIps.begin(); it != vecIps.end(); ++it) {\n                vecLocalUris.push_back(*it) ;\n            }\n       }\n\n       if( 0 == requestUri.find(\"tel:\")) {\n        DR_LOG(log_debug) << \"isLocalSipUri: tel: scheme, so we are  assuming it is not local (will cause it to be carried forward in proxy request): \" << requestUri ;\n        return false;\n       }\n\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n\n        // buf gets passed into sip_name_addr_d which puts NULs in various locations so the url_t members can point to their bits\n        s = strncpy( buf, requestUri.c_str(), 255 ) ;\n\n        // first we decode the string\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            // no go: if we can't decode it then we have an invalid input\n            return false ;\n        }\n\n        // cleanup: free the msg_params if any were allocated        \n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n\n        for(vector< pair<string, string> >::const_iterator it = vecLocalUris.begin(); it != vecLocalUris.end(); ++it) {\n            string host = it->first ;\n            string port = it->second ;\n\n            if (port.empty()) port = \"5060\";\n\n            //DR_LOG(log_debug) << \"isLocalSipUri: comparing known local address: \" << host << \":\" << port ;\n\n            if ((0 == host.compare(url->url_host)) && (\n                (!url->url_port && 0 == port.compare(\"5060\")) ||\n                (url->url_port && 0 == port.compare(url->url_port)))\n            ) {\n                return true ;\n            }\n        }\n        return false ;\n    }\n\n    void* my_json_malloc( size_t bytes ) {\n        std::lock_guard<std::mutex> l( json_lock ) ;\n\n        json_allocs++ ;\n        json_bytes += bytes ;\n        //DR_LOG(log_debug) << \"my_json_malloc: alloc'ing \" << bytes << \" bytes; outstanding allocations: \" << json_allocs << \", outstanding memory size: \" << json_bytes << endl ;\n\n        /* store size at the beginnng of the block */\n        void *ptr = malloc( bytes + 8 ) ;\n        *((size_t *)ptr) = bytes ;\n \n        return (void*) ((char*) ptr + 8);\n    }\n\n    void my_json_free( void* ptr ) {\n       std::lock_guard<std::mutex> l( json_lock ) ;\n\n        size_t size;\n        ptr = (void *) ((char *) ptr - 8) ;\n        size = *((size_t *)ptr);\n\n        json_allocs-- ;\n        json_bytes -= size ;\n        //DR_LOG(log_debug) << \"my_json_free: freeing \" << size << \" bytes; outstanding allocations: \" << json_allocs << \", outstanding memory size: \" << json_bytes << endl ;\n\n        /* zero memory in debug mode */\n        memset( ptr, 0, size + 8 ) ;\n\n    }\n\n    void splitLines( const string& s, vector<string>& vec ) {\n        if( s.length() ) {\n            split( vec, s, boost::is_any_of(\"\\r\\n\"), boost::token_compress_on ); \n        }\n    }\n\n    void splitTokens( const string& s, vector<string>& vec ) {\n        split( vec, s, boost::is_any_of(\"|\") /*, boost::token_compress_on */); \n    }\n\n    void splitMsg( const string& msg, string& meta, string& startLine, string& headers, string& body ) {\n        size_t pos = msg.find( DR_CRLF ) ;\n        if( string::npos == pos ) {\n            meta = msg ;\n            return ;\n        }\n        meta = msg.substr(0, pos) ;\n        string chunk = msg.substr(pos+DR_CRLF.length()) ;\n\n        pos = chunk.find( DR_CRLF2 ) ;\n        if( string::npos != pos  ) {\n            body = chunk.substr( pos + DR_CRLF2.length() ) ;\n            chunk = chunk.substr( 0, pos ) ;\n        }\n\n        pos = chunk.find( DR_CRLF ) ;\n        if( string::npos == pos ) {\n            startLine = chunk ;\n        }\n        else {\n            startLine = chunk.substr(0, pos) ;\n            headers = chunk.substr(pos + DR_CRLF.length()) ;\n        }\n    }\n\n    sip_method_t parseStartLine( const string& startLine, string& methodName, string& requestUri ) {\n        boost::char_separator<char> sep(\" \");\n        boost::tokenizer< boost::char_separator<char> > tokens(startLine, sep);\n        int i = 0 ;\n        sip_method_t method = sip_method_invalid ;\n        BOOST_FOREACH (const string& t, tokens) {\n            switch( i++ ) {\n                case 0:\n                    methodName = t ;\n                    if( 0 == t.compare(\"INVITE\") ) method = sip_method_invite ;\n                    else if( 0 == t.compare(\"ACK\") ) method = sip_method_ack ;\n                    else if( 0 == t.compare(\"PRACK\") ) method = sip_method_prack ;\n                    else if( 0 == t.compare(\"CANCEL\") ) method = sip_method_cancel ;\n                    else if( 0 == t.compare(\"BYE\") ) method = sip_method_bye ;\n                    else if( 0 == t.compare(\"OPTIONS\") ) method = sip_method_options ;\n                    else if( 0 == t.compare(\"REGISTER\") ) method = sip_method_register ;\n                    else if( 0 == t.compare(\"INFO\") ) method = sip_method_info ;\n                    else if( 0 == t.compare(\"UPDATE\") ) method = sip_method_update ;\n                    else if( 0 == t.compare(\"MESSAGE\") ) method = sip_method_message ;\n                    else if( 0 == t.compare(\"SUBSCRIBE\") ) method = sip_method_subscribe ;\n                    else if( 0 == t.compare(\"NOTIFY\") ) method = sip_method_notify ;\n                    else if( 0 == t.compare(\"REFER\") ) method = sip_method_refer ;\n                    else if( 0 == t.compare(\"PUBLISH\") ) method = sip_method_publish ;\n                    else method = sip_method_unknown ;\n                    break ;\n\n                case 1:\n                    requestUri = t ;\n                    break ;\n\n                default:\n                break ;\n            }\n        }\n        return method ;\n    }\n\n    bool GetValueForHeader( const string& headers, const char *szHeaderName, string& headerValue ) {\n        vector<string> vec ;\n        splitLines( headers, vec ) ;\n        for( std::vector<string>::const_iterator it = vec.begin(); it != vec.end(); ++it )  {\n            string hdrName ;\n            size_t pos = (*it).find_first_of(\":\") ;\n            if( string::npos != pos ) {\n                hdrName = (*it).substr(0,pos) ;\n                boost::trim( hdrName );\n\n                if( boost::iequals( hdrName, szHeaderName ) ) {\n                    headerValue = (*it).substr(pos+1) ;\n                    boost::trim( headerValue ) ;    \n                    return true ;                \n                }\n            }\n        }\n        return false ;\n    }\n    void deleteTags( tagi_t* tags ) {\n        if (!tags) return;\n        int i = 0 ;\n        while( tags[i].t_tag != tag_null ) {\n            if( tags[i].t_value ) {\n                char *p = (char *) tags[i].t_value ;\n                delete [] p ;\n            }\n             i++ ;\n        }       \n        delete [] tags ; \n    }\n\n    tagi_t* makeSafeTags( const string&  hdrs) {\n        vector<string> vec ;\n        \n        splitLines( hdrs, vec ) ;\n        int nHdrs = vec.size() ;\n        tagi_t *tags = new tagi_t[nHdrs+1] ;\n        int i = 0; \n        for( std::vector<string>::const_iterator it = vec.begin(); it != vec.end(); ++it )  {\n            tags[i].t_tag = tag_skip ;\n            tags[i].t_value = (tag_value_t) 0 ;                     \n            bool bValid = true ;\n            string hdrName, hdrValue ;\n\n            //parse header name and value\n            size_t pos = (*it).find_first_of(\":\") ;\n            if( string::npos == pos ) {\n                bValid = false ;\n            }\n            else {\n                hdrName = (*it).substr(0,pos) ;\n                boost::trim( hdrName );\n                if( string::npos != hdrName.find_first_not_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_\") ) {\n                    bValid = false ;\n                }\n                else {\n                    hdrValue = (*it).substr(pos+1) ;\n                    boost::trim( hdrValue ) ;\n                }\n            }\n            if( !bValid ) {\n                DR_LOG(log_error) << \"makeTags - invalid header: '\" << *it << \"'\"  ;\n                i++ ;\n                continue ;\n            }\n            else if( string::npos != hdrValue.find(DR_CRLF) ) {\n                DR_LOG(log_error) << \"SipDialogController::makeTags - client supplied invalid custom header value (contains CR or LF) for header '\" << hdrName << \"'\" ;\n                i++ ;\n                continue ;\n            }\n\n            //treat well-known headers differently than custom headers \n            tag_type_t tt ;\n            string hdr = boost::to_lower_copy( boost::replace_all_copy( hdrName, \"-\", \"_\" ) );\n            if( isImmutableHdr( hdr ) ) {\n                if( 0 != hdr.compare(\"content_length\") ) {\n                    DR_LOG(log_debug) << \"makeTags - discarding header because client is not allowed to set dialog-level headers: '\" << hdrName  ;\n                }\n            }\n            else if( getTagTypeForHdr( hdr, tt ) ) {\n                //well-known header\n                \n                //replace 'localhost' in certain headers with actual sip address:port\n                if( 0 == hdr.compare(\"from\") || \n                    0 == hdr.compare(\"contact\") ||\n                    0 == hdr.compare(\"to\") ||\n                    0 == hdr.compare(\"p_asserted_identity\") ) {\n\n                    DR_LOG(log_debug) << \"makeSafeTags - hdr '\" << hdrName << \"' can not be modified\";\n                }\n                else {\n                    int len = hdrValue.length() ;\n                    char *p = new char[len+1] ;\n                    memset(p, '\\0', len+1) ;\n                    strncpy( p, hdrValue.c_str(), len ) ;\n                    tags[i].t_tag = tt;\n                    tags[i].t_value = (tag_value_t) p ;\n                    DR_LOG(log_debug) << \"makeTags - Adding well-known header '\" << hdrName << \"' with value '\" << p << \"'\"  ;\n                }\n            }\n            else {\n                //custom header\n                int len = (*it).length() ;                  \n                char *p = new char[len+1] ;\n                memset(p, '\\0', len+1) ;\n                strncpy( p, (*it).c_str(), len) ;\n\n                tags[i].t_tag = siptag_unknown_str ;\n                tags[i].t_value = (tag_value_t) p ;\n                DR_LOG(log_debug) << \"makeTags - custom header: '\" << hdrName << \"', value: \" << hdrValue  ;  \n            }\n            i++ ;\n        }\n        tags[nHdrs].t_tag = tag_null ;\n        tags[nHdrs].t_value = (tag_value_t) 0 ;       \n\n        return tags ;   //NB: caller responsible to delete after use to free memory      \n    }\n\n    tagi_t* makeTags( const string&  hdrs, const string& transport, const char* szExternalIP ) {\n        vector<string> vec ;\n        string proto, host, port, myHostport ;\n        \n        parseTransportDescription(transport, proto, host, port ) ;\n\n        if (szExternalIP) {\n            host = szExternalIP;\n            DR_LOG(log_debug) << \"makeTags - using external IP as replacement for 'localhost': \" << szExternalIP  ;\n        }\n\n        splitLines( hdrs, vec ) ;\n        int nHdrs = vec.size() ;\n        tagi_t *tags = new tagi_t[nHdrs+1] ;\n        int i = 0; \n        for( std::vector<string>::const_iterator it = vec.begin(); it != vec.end(); ++it )  {\n            tags[i].t_tag = tag_skip ;\n            tags[i].t_value = (tag_value_t) 0 ;                     \n            bool bValid = true ;\n            string hdrName, hdrValue ;\n\n            //parse header name and value\n            size_t pos = (*it).find_first_of(\":\") ;\n            if( string::npos == pos ) {\n                bValid = false ;\n            }\n            else {\n                hdrName = (*it).substr(0,pos) ;\n                boost::trim( hdrName );\n                if( string::npos != hdrName.find_first_not_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_\") ) {\n                    bValid = false ;\n                }\n                else {\n                    hdrValue = (*it).substr(pos+1) ;\n                    boost::trim( hdrValue ) ;\n                }\n            }\n            if( !bValid ) {\n                DR_LOG(log_error) << \"makeTags - invalid header: '\" << *it << \"'\"  ;\n                i++ ;\n                continue ;\n            }\n            else if( string::npos != hdrValue.find(DR_CRLF) ) {\n                DR_LOG(log_error) << \"SipDialogController::makeTags - client supplied invalid custom header value (contains CR or LF) for header '\" << hdrName << \"'\" ;\n                i++ ;\n                continue ;\n            }\n\n            //treat well-known headers differently than custom headers \n            tag_type_t tt ;\n            string hdr = boost::to_lower_copy( boost::replace_all_copy( hdrName, \"-\", \"_\" ) );\n            if( isImmutableHdr( hdr ) ) {\n                if( 0 != hdr.compare(\"content_length\") ) {\n                    DR_LOG(log_debug) << \"makeTags - discarding header because client is not allowed to set dialog-level headers: '\" << hdrName  ;\n                }\n            }\n            else if( getTagTypeForHdr( hdr, tt ) ) {\n                //well-known header\n                \n                //replace 'localhost' in certain headers with actual sip address:port\n                if( string::npos != hdrValue.find(\"@localhost\") && (0 == hdr.compare(\"from\") || \n                    0 == hdr.compare(\"contact\") ||\n                    0 == hdr.compare(\"to\") ||\n                    0 == hdr.compare(\"p_asserted_identity\") ) ) {\n\n                    DR_LOG(log_debug) << \"makeTags - hdr '\" << hdrName << \"' replacing host with \" << host;\n                    replaceHostInUri( hdrValue, host.c_str(), port.c_str() ) ;\n                }\n                int len = hdrValue.length() ;\n                char *p = new char[len+1] ;\n                memset(p, '\\0', len+1) ;\n                strncpy( p, hdrValue.c_str(), len ) ;\n                tags[i].t_tag = tt;\n                tags[i].t_value = (tag_value_t) p ;\n                DR_LOG(log_debug) << \"makeTags - Adding well-known header '\" << hdrName << \"' with value '\" << p << \"'\"  ;\n            }\n            else {\n                //custom header\n                int len = (*it).length() ;                  \n                char *p = new char[len+1] ;\n                memset(p, '\\0', len+1) ;\n                strncpy( p, (*it).c_str(), len) ;\n\n                tags[i].t_tag = siptag_unknown_str ;\n                tags[i].t_value = (tag_value_t) p ;\n                DR_LOG(log_debug) << \"makeTags - custom header: '\" << hdrName << \"', value: \" << hdrValue  ;  \n            }\n\n            i++ ;\n        }\n        tags[nHdrs].t_tag = tag_null ;\n        tags[nHdrs].t_value = (tag_value_t) 0 ;       \n\n        return tags ;   //NB: caller responsible to delete after use to free memory      \n    }\n \tbool isRfc1918(const char* szHost) {\n        string str = szHost;\n        boost::char_separator<char> sep(\".\") ;\n        tokenizer tok(str, sep) ;\n        vector<int> vec;\n        for (tokenizer::iterator it = tok.begin(); it != tok.end(); it++) {\n            try {\n                vec.push_back(boost::lexical_cast<int>(*it));\n            }\n            catch (boost::bad_lexical_cast &e) {\n                // host name was not dot decimal\n                DR_LOG(log_debug) << \"isRfc1918: hostname '\" << szHost << \"' is not dot decimal: \" << e.what();\n                return false;\n            }\n        }\n        if (vec.size() == 4) {\n\n            // class A\n            if (vec[0] == 10) return true;\n\n            // class B\n            if (vec[0] == 172 && (vec[1] > 15 || vec[1] < 32)) return true;\n\n            // class C\n            if (vec[0] == 192 && vec[1] == 168) return true;\n        }\n        return false;\n     }\n\n\tbool sipMsgHasNatEqualsYes( const sip_t* sip, bool weAreUac, bool checkContact ) {\n        if (!sip->sip_record_route && !checkContact) return false;\n\n        if (sip->sip_record_route) {\n            sip_record_route_t *r = sip->sip_record_route;\n\n            if (weAreUac) {\n                for (; r; r = r->r_next) {\n                    if (r->r_next == NULL) break ;\n                }\n            }\n            if (r && r->r_url->url_params && NULL != ::strstr(r->r_url->url_params, \"nat=yes\")) {\n                return true;\n            }\n        }\n\n        if (checkContact && !sip->sip_record_route) {\n            if (sip->sip_contact &&\n                sip->sip_contact->m_url->url_params &&\n                NULL != ::strstr(sip->sip_contact->m_url->url_params, \"nat=yes\")) {\n                \n                return true;\n            }\n        }\n        return false;\n    }\n\n    string urlencode(const string &s) {\n        static const char lookup[]= \"0123456789abcdef\";\n        std::stringstream e;\n        for(int i=0, ix=s.length(); i<ix; i++)\n        {\n            const char& c = s[i];\n            if ( (48 <= c && c <= 57) ||//0-9\n                 (65 <= c && c <= 90) ||//abc...xyz\n                 (97 <= c && c <= 122) || //ABC...XYZ\n                 (c=='-' || c=='_' || c=='.' || c=='~') \n            )\n            {\n                e << c;\n            }\n            else\n            {\n                e << '%';\n                e << lookup[ (c&0xF0)>>4 ];\n                e << lookup[ (c&0x0F) ];\n            }\n        }\n        return e.str();\n    }\n\n    SipMsgData_t::SipMsgData_t(const string& str ) {\n        boost::char_separator<char> sep(\" []//:\") ;\n        tokenizer tok( str, sep) ;\n        tokenizer::iterator it = tok.begin() ;\n\n        m_source = 0 == (*it).compare(\"recv\") ? \"network\" : \"application\" ;\n        it++ ;\n        m_bytes = *(it) ;\n        it++; it++; it++ ;\n        m_protocol = *(it) ;\n        m_address = *(++it) ;\n        m_port = *(++it) ;\n        it++ ;  \n        string t = *(++it) + \":\" + *(++it) + \":\" + *(++it) + \".\" + *(++it) ;\n        m_time = t.substr(0, t.size()-2);\n    }\n\n    SipMsgData_t::SipMsgData_t( msg_t* msg ) : m_source(\"network\") {\n        su_time_t now = su_now() ;\n        unsigned short second, minute, hour;\n        char time[64] ;\n        tport_t *tport = nta_incoming_transport(theOneAndOnlyController->getAgent(), NULL, msg) ;        \n        assert(NULL != tport) ;\n\n        second = (unsigned short)(now.tv_sec % 60);\n        minute = (unsigned short)((now.tv_sec / 60) % 60);\n        hour = (unsigned short)((now.tv_sec / 3600) % 24);\n        sprintf(time, \"%02u:%02u:%02u.%06lu\", hour, minute, second, now.tv_usec) ;\n \n        m_time.assign( time ) ;\n        if( tport_is_udp(tport ) ) m_protocol = \"udp\" ;\n        else if( tport_has_tls( tport ) ) m_protocol = \"tls\" ;\n        else if( tport_is_tcp( tport)  ) m_protocol = \"tcp\" ;\n\n        tport_unref( tport ) ;\n\n        init( msg ) ;\n    }\n    SipMsgData_t::SipMsgData_t( msg_t* msg, nta_incoming_t* irq, const char* source ) : m_source(source) {\n        su_time_t now = su_now() ;\n        unsigned short second, minute, hour;\n        char time[64] ;\n        tport_t *tport = nta_incoming_transport(theOneAndOnlyController->getAgent(), irq, msg) ;  \n\n        second = (unsigned short)(now.tv_sec % 60);\n        minute = (unsigned short)((now.tv_sec / 60) % 60);\n        hour = (unsigned short)((now.tv_sec / 3600) % 24);\n        sprintf(time, \"%02u:%02u:%02u.%06lu\", hour, minute, second, now.tv_usec) ;\n \n        m_time.assign( time ) ;\n        if( tport_is_udp(tport ) ) m_protocol = \"udp\" ;\n        else if( tport_is_tcp( tport)  ) m_protocol = \"tcp\" ;\n        else if( tport_has_tls( tport ) ) m_protocol = \"tls\" ;\n\n        tport_unref( tport ) ;\n\n        init( msg ) ;\n    }\n    SipMsgData_t::SipMsgData_t( msg_t* msg, nta_outgoing_t* orq, const char* source ) : m_source(source) {\n        su_time_t now = su_now() ;\n        unsigned short second, minute, hour;\n        char time[64] ;\n        tport_t *tport = nta_outgoing_transport( orq ) ;    //adds a a reference\n        //assert( tport ) ; //why would this ever be null?\n\n        second = (unsigned short)(now.tv_sec % 60);\n        minute = (unsigned short)((now.tv_sec / 60) % 60);\n        hour = (unsigned short)((now.tv_sec / 3600) % 24);\n        sprintf(time, \"%02u:%02u:%02u.%06lu\", hour, minute, second, now.tv_usec) ;\n \n        m_time.assign( time ) ;\n\n        if( tport_is_udp(tport ) ) m_protocol = \"udp\" ;\n        else if( tport_is_tcp( tport)  ) m_protocol = \"tcp\" ;\n        else if( tport_has_tls( tport ) ) m_protocol = \"tls\" ;\n        else m_protocol = \"unknown\";\n\n        init( msg ) ;\n\n        if( 0 == strcmp(source, \"application\") ) {\n            if( NULL != tport ) {\n                const tp_name_t* name = tport_name(tport) ;\n                m_address = name->tpn_host ;\n                m_port = name->tpn_port ;                \n            }\n            //\n            /*\n            else {\n                m_address = theOneAndOnlyController->getMyDefaultSipAddress() ;\n                m_port = theOneAndOnlyController->getMyDefaultSipPort() ;\n            }\n            */\n        }\n\n\n        tport_unref( tport ) ;\n\n    }\n    void SipMsgData_t::init( msg_t* msg ) {\n        su_sockaddr_t const *su = msg_addr(msg);\n        short port ;\n        char name[SU_ADDRSIZE] = \"\";\n        char szTmp[10] ;\n\n        su_inet_ntop(su->su_family, SU_ADDR(su), name, sizeof(name));\n\n        m_address.assign( name ) ;\n        sprintf( szTmp, \"%u\", ntohs(su->su_port) ) ;\n        m_port.assign( szTmp );\n        sprintf( szTmp, \"%u\", msg_size( msg ) ) ;\n        m_bytes.assign( szTmp ) ;\n    }\n\n     int ackResponse( msg_t* msg ) {\n        nta_agent_t* nta = theOneAndOnlyController->getAgent() ;\n        sip_t *sip = sip_object(msg);\n        msg_t *amsg = nta_msg_create(nta, 0);\n        sip_t *asip = sip_object(amsg);\n        url_string_t const *ruri;\n        nta_outgoing_t *ack = NULL, *bye = NULL;\n        sip_cseq_t *cseq;\n        sip_request_t *rq;\n        sip_route_t *route = NULL, *r, r0[1];\n        su_home_t *home = msg_home(amsg);\n        tport_t* tp_incoming = nta_incoming_transport(nta, NULL, msg);\n\n        if (asip == NULL)\n        return -1;\n\n        sip_add_tl(amsg, asip,\n            SIPTAG_TO(sip->sip_to),\n            SIPTAG_FROM(sip->sip_from),\n            SIPTAG_CALL_ID(sip->sip_call_id),\n            TAG_END());\n\n        if (sip->sip_contact && sip->sip_status->st_status > 399 ) {\n            ruri = (url_string_t const *)sip->sip_contact->m_url;\n        } else {\n            su_sockaddr_t const *su = msg_addr(msg);\n            char name[SU_ADDRSIZE] = \"\";\n            char uri[SU_ADDRSIZE+20] = \"\" ;\n            char szTmp[10] ;\n\n            su_inet_ntop(su->su_family, SU_ADDR(su), name, sizeof(name));\n            sprintf( szTmp, \"%u\", ntohs(su->su_port) ) ;\n            sprintf(uri, \"sip:%s:%s\", name, szTmp) ;\n            ruri = URL_STRING_MAKE(uri) ;\n        }\n\n        if (!(cseq = sip_cseq_create(home, sip->sip_cseq->cs_seq, SIP_METHOD_ACK)))\n            goto err;\n        else\n            msg_header_insert(amsg, (msg_pub_t *)asip, (msg_header_t *)cseq);\n\n        if (!(rq = sip_request_create(home, SIP_METHOD_ACK, ruri, NULL)))\n            goto err;\n        else\n            msg_header_insert(amsg, (msg_pub_t *)asip, (msg_header_t *)rq);\n\n        DR_LOG(log_debug) << \"ackResponse - sending ack via tport \" << std::hex << (void *) tp_incoming ;\n\n        if( nta_msg_tsend( nta, amsg, NULL, \n            NTATAG_BRANCH_KEY(sip->sip_via->v_branch),\n            NTATAG_TPORT(tp_incoming),\n            TAG_END() ) < 0 )\n \n            goto err ;\n\n         return 0;\n\n        err:\n            if( amsg ) msg_destroy(amsg);\n            return -1;\n    }\n\n    int utf8_strlen(const string& str)\n    {\n        int c,i,ix,q;\n        for (q=0, i=0, ix=str.length(); i < ix; i++, q++)\n        {\n            c = (unsigned char) str[i];\n            if      (c>=0   && c<=127) i+=0;\n            else if ((c & 0xE0) == 0xC0) i+=1;\n            else if ((c & 0xF0) == 0xE0) i+=2;\n            else if ((c & 0xF8) == 0xF0) i+=3;\n            //else if (($c & 0xFC) == 0xF8) i+=4; // 111110bb //byte 5, unnecessary in 4 byte UTF-8\n            //else if (($c & 0xFE) == 0xFC) i+=5; // 1111110b //byte 6, unnecessary in 4 byte UTF-8\n            else {\n                DR_LOG(log_error) << \"utf8_strlen - code 0x\" << std::hex << c << \" at position \" << std::dec << q << \" is not a valid UTF-8 character\";\n                DR_LOG(log_error) << \"utf8_strlen - in string: \" << str ;\n                return 0;//invalid utf8\n            }\n        }\n        return q;\n    }\n }\n\n", "/*\nCopyright (c) 2013, David C Horton\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n#include <algorithm>\n#include <regex>\n\n#include <boost/algorithm/string.hpp>\n#include <boost/algorithm/string/find.hpp>\n#include <boost/algorithm/string/replace.hpp>\n\n#include <sofia-sip/su_alloc.h>\n\nnamespace drachtio {\n    class SipDialogController ;\n}\n\n#define NTA_RELIABLE_MAGIC_T drachtio::SipDialogController\n\n#include \"controller.hpp\"\n#include \"cdr.hpp\"\n#include \"sip-dialog-controller.hpp\"\n#include \"sip-transports.hpp\"\n\nnamespace {\n\n    std::string combineCallIdAndCSeq(nta_outgoing_t* orq) {\n        string callIdAndCSeq = nta_outgoing_call_id(orq);\n        callIdAndCSeq.append(\" \");\n        callIdAndCSeq.append(boost::lexical_cast<std::string>(nta_outgoing_cseq(orq)));\n        return callIdAndCSeq;\n    }\n\n    void cloneRespondToSipRequest(su_root_magic_t* p, su_msg_r msg, void* arg ) {\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        drachtio::SipDialogController::SipMessageData* d = reinterpret_cast<drachtio::SipDialogController::SipMessageData*>( arg ) ;\n        pController->getDialogController()->doRespondToSipRequest( d ) ;\n    }\n    void cloneSendSipRequest(su_root_magic_t* p, su_msg_r msg, void* arg ) {\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        drachtio::SipDialogController::SipMessageData* d = reinterpret_cast<drachtio::SipDialogController::SipMessageData*>( arg ) ;\n        pController->getDialogController()->doSendRequestOutsideDialog( d ) ;\n    }\n    void cloneSendSipCancelRequest(su_root_magic_t* p, su_msg_r msg, void* arg ) {\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        drachtio::SipDialogController::SipMessageData* d = reinterpret_cast<drachtio::SipDialogController::SipMessageData*>( arg ) ;\n        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_IN, {{\"method\", \"CANCEL\"}})\n        pController->getDialogController()->doSendCancelRequest( d ) ;\n    }\n    int uacLegCallback( nta_leg_magic_t* p, nta_leg_t* leg, nta_incoming_t* irq, sip_t const *sip) {\n        if( sip && sip->sip_request ) STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_IN, {{\"method\", sip->sip_request->rq_method_name}})\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        return pController->getDialogController()->processRequestInsideDialog( leg, irq, sip) ;\n    }\n    int uasCancelOrAck( nta_incoming_magic_t* p, nta_incoming_t* irq, sip_t const *sip ) {\n        if( sip && sip->sip_request ) STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_IN, {{\"method\", sip->sip_request->rq_method_name}})\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        return pController->getDialogController()->processCancelOrAck( p, irq, sip) ;\n    }\n    int uasPrack( drachtio::SipDialogController *pController, nta_reliable_t *rel, nta_incoming_t *prack, sip_t const *sip) {\n        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_IN, {{\"method\", \"PRACK\"}})\n        return pController->processPrack( rel, prack, sip) ;\n    }\n   int response_to_request_outside_dialog( nta_outgoing_magic_t* p, nta_outgoing_t* request, sip_t const* sip ) {  \n        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_IN, {\n            {\"method\", sip->sip_cseq->cs_method_name},\n            {\"code\", boost::lexical_cast<std::string>(sip->sip_status->st_status)}\n        }) \n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        return pController->getDialogController()->processResponseOutsideDialog( request, sip ) ;\n    } \n   int response_to_request_inside_dialog( nta_outgoing_magic_t* p, nta_outgoing_t* request, sip_t const* sip ) {   \n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_IN, {\n            {\"method\", sip->sip_cseq->cs_method_name},\n            {\"code\", boost::lexical_cast<std::string>(sip->sip_status->st_status)}\n        }) \n        return pController->getDialogController()->processResponseInsideDialog( request, sip ) ;\n    } \n    void cloneSendSipRequestInsideDialog(su_root_magic_t* p, su_msg_r msg, void* arg ) {\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        drachtio::SipDialogController::SipMessageData* d = reinterpret_cast<drachtio::SipDialogController::SipMessageData*>( arg ) ;\n        pController->getDialogController()->doSendRequestInsideDialog( d ) ;\n    }\n    int response_to_refreshing_reinvite( nta_outgoing_magic_t* p, nta_outgoing_t* request, sip_t const* sip ) {   \n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        return pController->getDialogController()->processResponseToRefreshingReinvite( request, sip ) ;\n    }\n}\n\n\nnamespace drachtio {\n\n\tSipDialogController::SipDialogController( DrachtioController* pController, su_clone_r* pClone ) : m_pController(pController), m_pClone(pClone), \n        m_agent(pController->getAgent()), m_pClientController(pController->getClientController())  {\n\n            assert(m_agent) ;\n            assert(m_pClientController) ;\n            m_pTQM = std::make_shared<SipTimerQueueManager>( pController->getRoot() ) ;\n            m_timerDHandler.setTimerQueueManager(m_pTQM);\n\t}\n\tSipDialogController::~SipDialogController() {\n\t}\n    bool SipDialogController::sendRequestInsideDialog( const string& clientMsgId, const string& dialogId, const string& startLine, const string& headers, const string& body, string& transactionId ) {\n\n        assert( dialogId.length() > 0 ) ;\n\n        if( 0 == transactionId.length() ) { generateUuid( transactionId ) ; }\n\n        su_msg_r msg = SU_MSG_R_INIT ;\n        int rv = su_msg_create( msg, su_clone_task(*m_pClone), su_root_task(m_pController->getRoot()),  cloneSendSipRequestInsideDialog, sizeof( SipDialogController::SipMessageData ) );\n        if( rv < 0 ) {\n            m_pController->getClientController()->route_api_response( clientMsgId, \"NOK\", \"Internal server error allocating message\") ;\n            return  false;\n        }\n        void* place = su_msg_data( msg ) ;\n\n        /* we need to use placement new to allocate the object in a specific address, hence we are responsible for deleting it (below) */\n        SipMessageData* msgData = new(place) SipMessageData( clientMsgId, transactionId, \"\", dialogId, startLine, headers, body ) ;\n        rv = su_msg_send(msg);  \n        if( rv < 0 ) {\n            m_pController->getClientController()->route_api_response( clientMsgId, \"NOK\", \"Internal server error sending message\") ;\n            return  false;\n        }\n        \n        return true ;\n    }\n    ///client-initiated outgoing messages (stack thread)\n    void SipDialogController::doSendRequestInsideDialog( SipMessageData* pData ) {                \n        nta_leg_t* leg = NULL ;\n        nta_outgoing_t* orq = NULL ;\n        string myHostport ;\n        string requestUri ;\n        string name ;\n        string routeUri;\n        bool destroyOrq = false;\n        tagi_t* tags = nullptr;\n\n        DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog dialog id: \" << pData->getDialogId()  ;\n\n        sip_method_t method = parseStartLine( pData->getStartLine(), name, requestUri ) ;\n\n        std::shared_ptr<SipDialog> dlg ;\n \n        assert( pData->getDialogId() ) ;\n\n        try {\n            if (!SD_FindByDialogId(m_dialogs, pData->getDialogId(), dlg ) ) {\n                if( sip_method_ack == method ) {\n                    DR_LOG(log_debug) << \"Can't send ACK for dialog id \" << pData->getDialogId() \n                        << \"; likely because stack already ACK'ed non-success final response\" ;\n                    throw std::runtime_error(\"ACK for non-success final response is automatically generated by server\") ;\n                }\n                DR_LOG(log_debug) << \"Can't find dialog for dialog id \" << pData->getDialogId() ;\n                //assert(false) ;\n                throw std::runtime_error(\"unable to find dialog for dialog id provided\") ;\n            }\n\n            string transport ;\n            dlg->getTransportDesc(transport) ;\n            tags = makeTags( pData->getHeaders(), transport) ;\n\n            tport_t* tp = dlg->getTport() ; \n            bool forceTport = NULL != tp ;  \n\n            nta_leg_t *leg = const_cast<nta_leg_t *>(dlg->getNtaLeg());\n            if( !leg ) {\n                assert( leg ) ;\n                throw std::runtime_error(\"unable to find active leg for dialog\") ;\n            }\n\n            const sip_contact_t *target ;\n            if( (sip_method_ack == method || string::npos != requestUri.find(\"placeholder\")) && nta_leg_get_route( leg, NULL, &target ) >=0 ) {\n                char buffer[256];\n\n                if (nullptr ==target) {\n                    throw std::runtime_error(\"unable to find route for dialog when sending ACK\") ;\n                }\n                url_e( buffer, 255, target->m_url ) ;\n                requestUri = buffer ;\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - defaulting request uri to \" << requestUri  ;\n\n                // we need to check if there was a mid-call network handoff, where this client jumped networks\n                std::shared_ptr<UaInvalidData> pData = m_pController->findTportForSubscription( target->m_url->url_user, target->m_url->url_host ) ;\n                if( NULL != pData ) {\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog found cached tport for this client \" << std::hex << (void *) pData->getTport();\n                    if (pData->getTport() != tp) {\n                        DR_LOG(log_info) << \"SipDialogController::doSendRequestInsideDialog client has done a mid-call handoff; tp is now \" << std::hex << (void *) pData->getTport();\n                        tp = pData->getTport();\n                        forceTport = true ;\n                    }\n               }\n            }\n\n            if( method == sip_method_invalid || method == sip_method_unknown ) {\n                throw std::runtime_error(string(\"invalid or missing method supplied on start line: \") + pData->getStartLine() ) ;\n            }\n\n            //set content-type if not supplied and body contains SDP\n            string body = pData->getBody() ;\n            string contentType ;\n            if( body.length() && !searchForHeader( tags, siptag_content_type_str, contentType ) ) {\n                if( 0 == body.find(\"v=0\") ) {\n                    contentType = \"application/sdp\" ;\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - automatically detecting content-type as application/sdp\"  ;\n                }\n                else {\n                    throw std::runtime_error(\"missing content-type\") ;                   \n                }\n            }\n            if( sip_method_invite == method && body.length() && 0 == contentType.compare(\"application/sdp\")) {\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - updating local sdp to \" << body ;\n                dlg->setLocalSdp( body.c_str() ) ;\n                dlg->setLocalContentType(contentType);\n            }\n\n            if (dlg->getRouteUri(routeUri)) {\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - sending request to nat'ed address using route \" << routeUri ;\n            }\n\n            if( sip_method_ack == method ) {\n                if( 200 == dlg->getSipStatus() ) {\n                    char cseq[32];\n                    memset(cseq, 0, 32);\n                    uint32_t seq = dlg->getSeq();\n                    dlg->clearSeq();\n                    if (seq > 0) {\n                        snprintf(cseq, 31, \"%u ACK\", seq);\n                        DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - setting CSeq to  \" << seq ;\n                    }\n                    orq = nta_outgoing_tcreate(leg, NULL, NULL, \n                        routeUri.empty() ? NULL : URL_STRING_MAKE(routeUri.c_str()),                     \n                        method, name.c_str(),\n                        URL_STRING_MAKE(requestUri.c_str()),\n                        TAG_IF( *cseq, SIPTAG_CSEQ_STR(cseq)),\n                        TAG_IF( body.length(), SIPTAG_PAYLOAD_STR(body.c_str())),\n                        TAG_IF( contentType.length(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str())),\n                        TAG_IF(forceTport, NTATAG_TPORT(tp)),\n                        TAG_NEXT(tags) ) ;\n                    \n                    tport_t* orq_tp = nta_outgoing_transport( orq );  // takes a reference on the tport\n                    if (tport_is_dgram(orq_tp)) m_timerDHandler.addAck(orq);\n                    else if (orq_tp) destroyOrq = true;\n                    if (orq_tp) {\n                        dlg->setTport(orq_tp) ;\n                        // tport reference will be release in SipDialog dtor\n                    }\n                    else {\n                        DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - sending ACK but nta_outgoing_transport is null, delayed for DNS resolver\";\n                        dlg->setOrqAck(orq, !tport_is_dgram(orq_tp));\n                        destroyOrq = false;\n                        tport_unref(orq_tp);  // release the reference\n                    }\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - clearing IIP that we generated as uac\" ;\n                    IIP_Clear(m_invitesInProgress, leg);  \n\n                    DR_LOG(log_info) << \"SipDialogController::doSendRequestInsideDialog (ack) - created orq \" << std::hex << (void *) orq;\n\n                }\n            }\n            else if( sip_method_prack == method ) {\n                std::shared_ptr<IIP> iip;\n                if(!IIP_FindByLeg(m_invitesInProgress, leg, iip)) {\n                    throw std::runtime_error(\"unable to find IIP when sending PRACK\") ;\n                }\n                orq = nta_outgoing_prack(leg, const_cast<nta_outgoing_t *>(iip->orq()), response_to_request_inside_dialog, (nta_outgoing_magic_t*) m_pController, \n                    //NULL, \n                    routeUri.empty() ? NULL : URL_STRING_MAKE(routeUri.c_str()),\n                    NULL, TAG_NEXT(tags) ) ;\n                DR_LOG(log_info) << \"SipDialogController::doSendRequestInsideDialog (prack) - created orq \" << std::hex << (void *) orq;\n\n            }\n            else {\n                string contact ;\n                bool addContact = false ;\n                if( (method == sip_method_invite || method == sip_method_subscribe || method == sip_method_refer) && !searchForHeader( tags, siptag_contact_str, contact ) ) {\n                    contact = dlg->getLocalContactHeader();\n                    addContact = true ;\n                }\n                orq = nta_outgoing_tcreate( leg, response_to_request_inside_dialog, (nta_outgoing_magic_t*) m_pController, \n                    routeUri.empty() ? NULL : URL_STRING_MAKE(routeUri.c_str()),                     \n                    method, name.c_str()\n                    ,URL_STRING_MAKE(requestUri.c_str())\n                    ,TAG_IF( addContact, SIPTAG_CONTACT_STR( contact.c_str() ) )\n                    ,TAG_IF( body.length(), SIPTAG_PAYLOAD_STR(body.c_str()))\n                    ,TAG_IF( contentType.length(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))\n                    ,TAG_IF(forceTport, NTATAG_TPORT(tp))\n                    ,TAG_NEXT(tags) ) ;\n\n                if( orq ) {\n                    DR_LOG(log_info) << \"SipDialogController::doSendRequestInsideDialog - created orq \" << std::hex << (void *) orq << \" sending \" << nta_outgoing_method_name(orq) << \" to \" << requestUri ;\n                }\n            }\n\n            if( NULL == orq && sip_method_ack != method ) {\n                throw std::runtime_error(\"Error creating sip transaction for request\") ;               \n            }\n\n            if( sip_method_ack == method && 200 != dlg->getSipStatus() ) {\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - clearing uac dialog that had final response \" <<  dlg->getSipStatus() ;\n                SD_Clear(m_dialogs, dlg->getDialogId()) ;\n                m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"NOK\", \n                    \"ACK for non-success responses is automatically generated by the stack\" ) ;\n            }\n            else {\n                msg_t* m = nta_outgoing_getrequest(orq) ;  // adds a reference\n                sip_t* sip = sip_object( m ) ;\n\n                STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", sip->sip_request->rq_method_name}})\n\n                string encodedMessage ;\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta(m, orq) ;\n                string s ;\n                meta.toMessageFormat(s) ;\n                string data = s + \"|\" + pData->getTransactionId() + \"|Msg sent:|\" + DR_CRLF + encodedMessage ;\n\n                if( sip_method_ack == method ) {\n                    if( dlg->getSipStatus() > 200 ) {\n                        m_pClientController->removeDialog( dlg->getDialogId() ) ;\n                    }\n                }\n                else {\n                    bool clearDialogOnResponse = false ;\n                    if( sip_method_bye == method || \n                        ( !dlg->isInviteDialog() && sip_method_notify == method && NULL != sip->sip_subscription_state && NULL != sip->sip_subscription_state->ss_substate &&\n                            NULL != strstr(sip->sip_subscription_state->ss_substate, \"terminated\") ) ) {\n                        clearDialogOnResponse = true ;\n                    }\n\n                    std::shared_ptr<RIP> p = std::make_shared<RIP>( pData->getTransactionId(), pData->getDialogId(), dlg, clearDialogOnResponse ) ;\n                    addRIP( orq, p ) ;       \n                }\n                if( sip_method_invite == method ) {\n                    addOutgoingInviteTransaction( leg, orq, sip, dlg ) ;\n                }\n\n                if (sip_method_bye == method) {\n                  Cdr::postCdr( std::make_shared<CdrStop>( m, \"application\", Cdr::normal_release ) );\n                }\n     \n                msg_destroy(m) ; //releases reference\n                m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"OK\", data ) ; \n            }\n\n            if (sip_method_ack == method && dlg->getSipStatus() == 200 && dlg->isAckBye()) {\n                this->notifyTerminateStaleDialog(dlg, true);\n            }\n        } catch( std::runtime_error& err ) {\n            DR_LOG(log_error) << \"SipDialogController::doSendRequestInsideDialog - Error: \" << err.what() ;\n            string msg = string(\"Server error: \") + err.what() ;\n            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"NOK\", msg ) ;\n            m_pController->getClientController()->removeAppTransaction( pData->getTransactionId() ) ;\n        }                       \n\n        /* we must explicitly delete an object allocated with placement new */\n        pData->~SipMessageData() ;\n        if (orq && destroyOrq) nta_outgoing_destroy(orq);\n        deleteTags( tags ) ;\n    }\n\n//send request outside dialog\n    //client thread\n    bool SipDialogController::sendRequestOutsideDialog( const string& clientMsgId, const string& startLine, const string& headers, const string& body, string& transactionId, string& dialogId, string& routeUrl ) {\n        if( 0 == transactionId.length() ) { generateUuid( transactionId ) ; }\n        if( string::npos != startLine.find(\"INVITE\") ) {\n            generateUuid( dialogId ) ;\n        }\n\n        su_msg_r msg = SU_MSG_R_INIT ;\n        int rv = su_msg_create( msg, su_clone_task(*m_pClone), su_root_task(m_pController->getRoot()),  cloneSendSipRequest, sizeof( SipDialogController::SipMessageData ) );\n        if( rv < 0 ) {\n            return  false;\n        }\n        void* place = su_msg_data( msg ) ;\n\n        /* we need to use placement new to allocate the object in a specific address, hence we are responsible for deleting it (below) */\n        SipMessageData* msgData = new(place) SipMessageData( clientMsgId, transactionId, \"\", dialogId, startLine, headers, body, routeUrl ) ;\n        rv = su_msg_send(msg);  \n        if( rv < 0 ) {\n            return  false;\n        }\n        return true ;\n    }\n    //stack thread\n     void SipDialogController::doSendRequestOutsideDialog( SipMessageData* pData ) {\n        nta_leg_t* leg = NULL ;\n        nta_outgoing_t* orq = NULL ;\n        string requestUri ;\n        string name ;\n        string sipOutboundProxy ;\n        tport_t* tp = NULL ;\n        std::shared_ptr<SipTransport> pSelectedTransport ;\n        bool forceTport = false ;\n        string host, port, proto, contact, desc ;\n        tagi_t* tags = nullptr;\n\n        try {\n            bool useOutboundProxy = false ;\n            const char *szRouteUrl = pData->getRouteUrl() ;\n            if (*szRouteUrl != '\\0') {\n                useOutboundProxy = true ;\n                sipOutboundProxy.assign(szRouteUrl);\n            }\n            else {\n                useOutboundProxy = m_pController->getConfig()->getSipOutboundProxy( sipOutboundProxy ) ;\n            }\n            if (useOutboundProxy) {\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog sending request to route url: \" << sipOutboundProxy ;\n            }\n\n            sip_request_t *sip_request = sip_request_make(m_pController->getHome(), pData->getStartLine() ) ;\n            if( NULL == sip_request || \n                url_invalid == sip_request->rq_url[0].url_type || \n                url_unknown == sip_request->rq_url[0].url_type  ||\n                sip_method_invalid == sip_request->rq_method ||\n                sip_method_unknown == sip_request->rq_method  ) {\n\n                throw std::runtime_error(string(\"invalid request-uri: \") + pData->getStartLine() ) ;\n            }\n            sip_method_t method = parseStartLine( pData->getStartLine(), name, requestUri ) ;\n\n            int rc = 0 ;\n            if( (sip_method_invite == sip_request->rq_method || \n                sip_method_options == sip_request->rq_method ||\n                sip_method_notify == sip_request->rq_method ||\n                sip_method_message == sip_request->rq_method) && \n                !tport_is_dgram(tp) /*&& NULL != strstr( sip_request->rq_url->url_host, \".invalid\")*/ ) {\n\n                std::shared_ptr<UaInvalidData> pData = \n                    m_pController->findTportForSubscription( sip_request->rq_url->url_user, sip_request->rq_url->url_host ) ;\n\n                if( NULL != pData ) {\n                    forceTport = true ;\n                    tp = pData->getTport() ;\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog selecting existing secondary transport \" << std::hex << (void *) tp ;\n\n                    getTransportDescription( tp, desc ) ;\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - selected transport \" << std::hex << (void*)tp << \": \" << desc << \" for request-uri \" << requestUri  ;            \n\n                    const tp_name_t* tpn = tport_name( tport_parent( tp ) );\n                    string host = tpn->tpn_host ;\n                    string port = tpn->tpn_port ;\n                    string proto = tpn->tpn_proto ;\n\n                    contact = \"<sip:\" + host + \":\" + port + \";transport=\" + proto + \">\";\n               }\n            }\n            if( NULL == tp ) {\n                pSelectedTransport = SipTransport::findAppropriateTransport( useOutboundProxy ? sipOutboundProxy.c_str() : requestUri.c_str()) ;\n                if (!pSelectedTransport) {\n                    throw std::runtime_error(string(\"requested protocol/transport not available\"));\n                }\n\n                pSelectedTransport->getDescription(desc);\n                pSelectedTransport->getContactUri( contact, true ) ;\n                contact = \"<\" + contact + \">\" ;\n                host = pSelectedTransport->getHost() ;\n                port = pSelectedTransport->getPort() ;\n\n                tp = (tport_t *) pSelectedTransport->getTport() ;\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog selected transport \" << std::hex << (void*)tp << desc ;\n                forceTport = true ;\n            }\n            su_free( m_pController->getHome(), sip_request ) ;\n\n            if (pSelectedTransport && pSelectedTransport->hasExternalIp()) {\n                tags = makeTags( pData->getHeaders(), desc, pSelectedTransport->getExternalIp().c_str()) ;\n            }\n            else {\n                tags = makeTags( pData->getHeaders(), desc, NULL) ;\n            }\n           \n            //if user supplied all or part of the From use it\n            string from, to, callid ;\n            if( searchForHeader( tags, siptag_from_str, from ) ) {\n                if( string::npos != from.find(\"localhost\") ) {\n                    if( !replaceHostInUri( from, host.c_str(), port.c_str() ) ) {\n                        throw std::runtime_error(string(\"invalid from value provided by client: \") + from ) ;\n                    }                    \n                }\n            } \n            else {\n                from = contact ;\n            }\n\n            //default To header to request uri if not provided\n            if( !searchForHeader( tags, siptag_to_str, to ) ) {\n                to = requestUri ;\n            } \n\n            DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - from: \" << from   ;            \n            DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - to: \" << to ;            \n            DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - contact: \" << contact  ;            \n\n            // use call-id if supplied\n            if( searchForHeader( tags, siptag_call_id_str, callid ) ) {\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - using client-specified call-id: \" << callid  ;            \n            }\n\n            //set content-type if not supplied and body contains SDP\n            string body = pData->getBody() ;\n            string contentType ;\n            if( body.length() && !searchForHeader( tags, siptag_content_type_str, contentType ) ) {\n                if( 0 == body.find(\"v=0\") ) {\n                    contentType = \"application/sdp\" ;\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - automatically detecting content-type as application/sdp\"  ;\n                }\n                else {\n                    throw std::runtime_error(\"missing content-type\") ;                   \n                }\n             }\n\n            //prevent looping messages\n            normalizeSipUri( requestUri, 0 ) ;\n            if( isLocalSipUri( requestUri ) ) {\n                throw std::runtime_error(\"can not send request to myself\") ;\n            }\n\n            if( !(leg = nta_leg_tcreate( m_pController->getAgent(),\n                uacLegCallback, (nta_leg_magic_t *) m_pController,\n                SIPTAG_FROM_STR(from.c_str()),\n                SIPTAG_TO_STR(to.c_str()),\n                TAG_IF( callid.length(), SIPTAG_CALL_ID_STR(callid.c_str())),\n                TAG_IF( method == sip_method_register, NTATAG_NO_DIALOG(1)),\n                TAG_END() ) ) ) {\n\n                throw std::runtime_error(\"Error creating leg\") ;\n            }\n            nta_leg_tag( leg, NULL ) ;\n\n            orq = nta_outgoing_tcreate( leg, \n                response_to_request_outside_dialog, \n                (nta_outgoing_magic_t*) m_pController, \n                useOutboundProxy ? URL_STRING_MAKE( sipOutboundProxy.c_str() ) : NULL, \n                method, \n                name.c_str()\n                ,URL_STRING_MAKE(requestUri.c_str())\n                ,TAG_IF( (method == sip_method_invite || method == sip_method_subscribe) && \n                    !searchForHeader( tags, siptag_contact_str, contact ), SIPTAG_CONTACT_STR( contact.c_str() ) )\n                ,TAG_IF( body.length(), SIPTAG_PAYLOAD_STR(body.c_str()))\n                ,TAG_IF( contentType.length(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))\n                ,TAG_IF( forceTport, NTATAG_TPORT(tp))\n                ,TAG_NEXT(tags) ) ;\n\n            if( NULL == orq ) {\n                throw std::runtime_error(\"Error creating sip transaction for uac request\") ;               \n            }\n\n            msg_t* m = nta_outgoing_getrequest(orq) ; //adds a reference\n            sip_t* sip = sip_object( m ) ;\n\n            DR_LOG(log_info) << \"SipDialogController::doSendRequestOutsideDialog - created orq \" << std::hex << (void *) orq  <<\n                \" call-id \" << sip->sip_call_id->i_id << \" / transaction id: \" << pData->getTransactionId();\n\n            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", sip->sip_request->rq_method_name}})\n\n            if( method == sip_method_invite || method == sip_method_subscribe ) {\n                std::shared_ptr<SipDialog> dlg = std::make_shared<SipDialog>(pData->getTransactionId(), \n                    leg, orq, sip, m, desc) ;\n                string customContact ;\n                bool hasCustomContact = searchForHeader( tags, siptag_contact_str, customContact ) ;\n                dlg->setLocalContactHeader(hasCustomContact ? customContact.c_str() : contact.c_str());\n\n                addOutgoingInviteTransaction( leg, orq, sip, dlg ) ;\n                if (method == sip_method_invite) {\n                  Cdr::postCdr( std::make_shared<CdrAttempt>(m, \"application\"));\n                }\n            }\n            else {\n                std::shared_ptr<RIP> p = std::make_shared<RIP>( pData->getTransactionId(), pData->getDialogId() ) ;\n                addRIP( orq, p ) ;\n                nta_leg_destroy( leg ) ;\n            }\n\n            string encodedMessage ;\n            EncodeStackMessage( sip, encodedMessage ) ;\n            SipMsgData_t meta(m, orq) ;\n            string s ;\n            meta.toMessageFormat(s) ;\n            msg_destroy(m) ;    // releases reference\n\n            string data = s + \"|\" + pData->getTransactionId() + \"|Msg sent:|\" + DR_CRLF + encodedMessage ;\n\n            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"OK\", data ) ;\n \n        } catch( std::runtime_error& err ) {\n            DR_LOG(log_error) << \"SipDialogController::doSendRequestOutsideDialog - \" << err.what() ;\n            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"NOK\", err.what() ) ;  \n            m_pController->getClientController()->removeAppTransaction( pData->getTransactionId() ) ;\n        }                       \n\n        //N.B.: we must explicitly call the destructor of an object allocated with placement new\n        pData->~SipMessageData() ;\n\n        deleteTags(tags);\n    }\n\n    bool SipDialogController::sendCancelRequest( const string& clientMsgId, const string& transactionId, const string& startLine, const string& headers, const string& body ) {\n        su_msg_r msg = SU_MSG_R_INIT ;\n        int rv = su_msg_create( msg, su_clone_task(*m_pClone), su_root_task(m_pController->getRoot()),  cloneSendSipCancelRequest, sizeof( SipDialogController::SipMessageData ) );\n        if( rv < 0 ) {\n            return  false;\n        }\n        void* place = su_msg_data( msg ) ;\n\n        /* we need to use placement new to allocate the object in a specific address, hence we are responsible for deleting it (below) */\n        SipMessageData* msgData = new(place) SipMessageData( clientMsgId, transactionId, \"\", \"\", startLine, headers, body ) ;\n        rv = su_msg_send(msg);  \n        if( rv < 0 ) {\n            return  false;\n        }\n        return true ;\n    }\n    bool SipDialogController::respondToSipRequest( const string& clientMsgId, const string& transactionId, const string& startLine, const string& headers, const string& body ) {\n       su_msg_r msg = SU_MSG_R_INIT ;\n        int rv = su_msg_create( msg, su_clone_task(*m_pClone), su_root_task(m_pController->getRoot()),  cloneRespondToSipRequest, sizeof( SipDialogController::SipMessageData ) );\n        if( rv < 0 ) {\n            return  false ;\n        }\n        void* place = su_msg_data( msg ) ;\n\n        /* we need to use placement new to allocate the object in a specific address, hence we are responsible for deleting it (below) */\n        string rid ;\n        SipMessageData* msgData = new(place) SipMessageData( clientMsgId, transactionId, \"\", \"\", startLine, headers, body ) ;\n        rv = su_msg_send(msg);  \n        if( rv < 0 ) {\n            return  false ;\n        }\n\n        return true ;\n    }\n   \n    void SipDialogController::doSendCancelRequest( SipMessageData* pData ) {\n        string transactionId( pData->getTransactionId() ) ;\n        std::shared_ptr<IIP> iip ;\n        tagi_t* tags = nullptr;\n\n        if (IIP_FindByTransactionId(m_invitesInProgress, transactionId, iip)) {\n            iip->setCanceled();\n            tags = makeSafeTags( pData->getHeaders()) ;\n            nta_outgoing_t *cancel = nta_outgoing_tcancel(const_cast<nta_outgoing_t *>(iip->orq()), NULL, NULL, TAG_NEXT(tags));\n            if( NULL != cancel ) {\n                msg_t* m = nta_outgoing_getrequest(cancel) ;    // adds a reference\n                sip_t* sip = sip_object( m ) ;\n\n                string cancelTransactionId ;\n                generateUuid( cancelTransactionId ) ;\n\n                string encodedMessage ;\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta(m, cancel) ;\n                string s ;\n                meta.toMessageFormat(s) ;\n                string data = s + \"|\" + cancelTransactionId + \"|Msg sent:|\" + DR_CRLF + encodedMessage ;\n                msg_destroy(m) ;    // releases reference\n\n                //Note: not adding an RIP because the 200 OK to the CANCEL is not passed up to us\n\n                m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"OK\", data ) ;     \n                deleteTags(tags);\n                return ;           \n            }\n            else {\n                DR_LOG(log_error) << \"SipDialogController::doSendCancelRequest - internal server error canceling transaction id \" << \n                    transactionId << \" / orq: \" << std::hex << (void *) iip->orq();\n                m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"NOK\", \n                    string(\"internal server error canceling transaction id: \") + transactionId ) ; \n            }\n        }\n        else {\n            DR_LOG(log_error) << \"SipDialogController::doSendCancelRequest - unknown transaction id \" << transactionId ;\n            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"NOK\", \n                string(\"unable to cancel unknown transaction id: \") + transactionId ) ; \n        }\n        pData->~SipMessageData() ;\n        deleteTags(tags);\n   }\n\n    int SipDialogController::processResponseOutsideDialog( nta_outgoing_t* orq, sip_t const* sip )  {\n        DR_LOG(log_debug) << \"SipDialogController::processResponseOutsideDialog\"  ;\n        string transactionId ;\n        std::shared_ptr<SipDialog> dlg ;\n\n        string encodedMessage ;\n        bool truncated ;\n        msg_t* msg = nta_outgoing_getresponse(orq) ;    //adds a reference\n        SipMsgData_t meta( msg, orq, \"network\") ;\n\n        EncodeStackMessage( sip, encodedMessage ) ;\n\n        if( sip->sip_cseq->cs_method == sip_method_invite || sip->sip_cseq->cs_method == sip_method_subscribe ) {\n            std:shared_ptr<IIP> iip;\n\n            //check for retransmission \n            if (sip->sip_cseq->cs_method == sip_method_invite && m_timerDHandler.resendIfNeeded(orq)) {\n                DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - retransmitted ACK for callid: \" << sip->sip_call_id->i_id  <<\n                    \" for invite with orq: \" << std::hex << (void *) orq;\n                msg_destroy( msg ) ; \n                return 0;\n            }\n\n            if (!IIP_FindByOrq(m_invitesInProgress, orq, iip)) {\n                DR_LOG(log_error) << \"SipDialogController::processResponseOutsideDialog - unable to match invite response with callid: \" << sip->sip_call_id->i_id  ;\n                //TODO: do I need to destroy this transaction?\n                msg_destroy( msg ) ; \n                return -1 ; //TODO: check meaning of return value           \n            }      \n            transactionId = iip->getTransactionId() ;   \n            dlg = iip->dlg() ;   \n\n\n            //update dialog variables            \n            dlg->setSipStatus( sip->sip_status->st_status ) ;\n            if( sip->sip_payload ) {\n                iip->dlg()->setRemoteSdp( sip->sip_payload->pl_data, sip->sip_payload->pl_len ) ;\n            }\n\n            // stats\n            if (theOneAndOnlyController->getStatsCollector().enabled()) {\n                // post-dial delay\n                if (sip->sip_cseq->cs_method == sip_method_invite && dlg->getSipStatus() <= 200) {\n                    auto now = std::chrono::steady_clock::now();\n                    std::chrono::duration<double> diff = now - dlg->getArrivalTime();\n                    if (!dlg->hasAlerted()) {\n                        dlg->alerting();\n                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_PDD_OUT, diff.count())\n                    }\n                    if (200 == dlg->getSipStatus()) {\n                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_RESPONSE_TIME_OUT, diff.count())\n                    }\n                }\n            }\n\n\n            //UAC Dialog is added when we receive a final response from the network, or a reliable provisional response\n            //for non-success responses, it will subsequently be removed when we receive the ACK from the client\n\n            if( (sip->sip_cseq->cs_method == sip_method_invite && \n                    (200 == sip->sip_status->st_status || (sip->sip_status->st_status > 100 && sip->sip_status->st_status < 200 && sip->sip_rseq))) || \n                (sip->sip_cseq->cs_method == sip_method_subscribe && \n                    (202 == sip->sip_status->st_status || 200 == sip->sip_status->st_status) ) )  {\n\n                DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - adding dialog id: \" << dlg->getDialogId()  ;\n                nta_leg_t* leg = const_cast<nta_leg_t *>(iip->leg()) ;\n                nta_leg_rtag( leg, sip->sip_to->a_tag) ;\n                nta_leg_client_reroute( leg, sip->sip_record_route, sip->sip_contact, 1 );\n\n                bool nat = false;\n                const sip_route_t* route = NULL;\n                if (nta_leg_get_route(leg, &route, NULL) >= 0 && route && route->r_url->url_host && isRfc1918(route->r_url->url_host)) {\n                    DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected possible natted downstream client at RFC1918 address: \" << route->r_url->url_host  ;\n                    nat = true;\n                }\n                else if(sip->sip_cseq->cs_method == sip_method_invite && !route && sip->sip_contact && \n                    0 != strcmp(sip->sip_contact->m_url->url_host, meta.getAddress().c_str())) {\n\n                    DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected downstream client; contact ip: \" << \n                        sip->sip_contact->m_url->url_host << \" differs from recv address: \" << meta.getAddress().c_str();\n                    nat = true;\n                }\n                else if (theOneAndOnlyController->isAggressiveNatEnabled() && sipMsgHasNatEqualsYes(sip, true, true)) {\n                        DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected possible natted downstream client advertising nat=yes\";\n                    nat = true;\n                }\n\n                if (nat && theOneAndOnlyController->isNatDetectionDisabled()) {\n                    nat = false;\n                    DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected possible natted downstream client, but ignoring because disable-nat-detection is on\";\n                }\n                if (nat) {\n                    url_t const * url = nta_outgoing_route_uri(orq);\n                    string routeUri = string((url ? url->url_scheme : \"sip\")) + \":\" + meta.getAddress() + \":\" + meta.getPort();\n                    dlg->setRouteUri(routeUri);\n                    DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected nat setting route to: \" <<   routeUri;\n                }\n                else {\n                    dlg->clearRouteUri();\n                }\n                if (iip->isCanceled()) {\n                    DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - ACK/BYE race condition - received 200 OK to INVITE that was previously CANCELED\";\n                    dlg->doAckBye();\n                }\n                addDialog( dlg ) ;\n            }\n            tport_t* tp = nta_outgoing_transport(orq);\n            if (sip->sip_cseq->cs_method == sip_method_invite && sip->sip_status->st_status == 200 && tport_is_dgram(tp)) {\n                // for successful uac invites, we need to handle retransmits\n                m_timerDHandler.addInvite(orq);\n            }\n            tport_unref(tp);\n\n            if (sip->sip_cseq->cs_method == sip_method_invite && sip->sip_status->st_status == 200 && sip->sip_session_expires) {\n                DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected session timer header: \";\n                dlg->setSessionTimer( sip->sip_session_expires->x_delta, \n                    !sip->sip_session_expires->x_refresher || 0 == strcmp( sip->sip_session_expires->x_refresher, \"uac\") ? \n                    SipDialog::we_are_refresher : \n                    SipDialog::they_are_refresher) ;\n            }\n            else if (sip->sip_status->st_status > 200) {\n                IIP_Clear(m_invitesInProgress, iip);\n            }\n        }\n        else {\n            std::shared_ptr<RIP> rip ;\n            if( !findRIPByOrq( orq, rip ) ) {\n                DR_LOG(log_error) << \"SipDialogController::processResponseOutsideDialog - unable to match response with callid for a non-invite request we sent: \" << sip->sip_call_id->i_id  ;\n                //TODO: do I need to destroy this transaction?\n                return -1 ; //TODO: check meaning of return value                           \n            }\n            transactionId = rip->getTransactionId() ;\n            if( sip->sip_status->st_status >= 200 ) this->clearRIP( orq ) ;\n        }\n        \n        if( !dlg ) {\n            m_pController->getClientController()->route_response_inside_transaction( encodedMessage, meta, orq, sip, transactionId ) ;\n        }\n        else {\n            m_pController->getClientController()->route_response_inside_transaction( encodedMessage, meta, orq, sip, transactionId, dlg->getDialogId() ) ;            \n        }\n\n        if( sip->sip_cseq->cs_method == sip_method_invite) {\n          if (sip->sip_status->st_status >= 300) {\n            Cdr::postCdr( std::make_shared<CdrStop>( msg, \"network\",\n                487 == sip->sip_status->st_status ? Cdr::call_canceled : Cdr::call_rejected ) );\n          }\n          else if (sip->sip_status->st_status == 200) {\n            Cdr::postCdr( std::make_shared<CdrStart>( msg, \"network\", Cdr::uac ) );                \n          }\n        }\n        if( sip->sip_cseq->cs_method == sip_method_invite && sip->sip_status->st_status > 200 ) {\n            assert( dlg ) ;\n            m_pController->getClientController()->removeDialog( dlg->getDialogId() ) ;\n        }\n\n        msg_destroy( msg ) ;                            //releases reference\n\n        return 0 ;\n    }\n    void SipDialogController::doRespondToSipRequest( SipMessageData* pData ) {\n        string transactionId( pData->getTransactionId() );\n        string startLine( pData->getStartLine()) ;\n        string headers( pData->getHeaders() );\n        string body( pData->getBody()) ;\n        string clientMsgId( pData->getClientMsgId()) ;\n        string contentType ;\n        string dialogId ;\n        string contact, transportDesc ;\n        std::shared_ptr<SipTransport> pSelectedTransport ;\n        bool bSentOK = true ;\n        string failMsg ;\n        bool bDestroyIrq = false ;\n        bool bClearIIP = false ;\n        bool existingDialog = false;\n        bool transportGone = false;\n        tagi_t* tags = nullptr;\n\n        //decode status \n        sip_status_t* sip_status = sip_status_make( m_pController->getHome(), startLine.c_str() ) ;\n        int code = sip_status->st_status ;\n        const char* status = sip_status->st_phrase ;\n  \n        nta_incoming_t* irq = NULL ;\n        int rc = -1 ;\n        std::shared_ptr<IIP> iip;\n\n        DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest thread \" << std::this_thread::get_id() ;\n\n        /* search for requests within a dialog first */\n        irq = findAndRemoveTransactionIdForIncomingRequest( transactionId ) ;\n        if( !irq ) {\n            if (!IIP_FindByTransactionId(m_invitesInProgress, transactionId, iip)) {\n                /* could be a new incoming request that hasn't been responded to yet */\n                \n                /* we allow the app to set the local tag (ie tag on the To) */\n                string toValue;\n                string tag;\n                if (GetValueForHeader( headers, \"to\", toValue)) {\n                    std::regex re(\"tag=(.*)\");\n                    std::smatch mr;\n                    if (std::regex_search(toValue, mr, re) && mr.size() > 1) {\n                        tag = mr[1] ;\n                    }\n                }\n\n                if( m_pController->setupLegForIncomingRequest( transactionId, tag ) ) {\n                    if (!IIP_FindByTransactionId(m_invitesInProgress, transactionId, iip)) {\n                        irq = findAndRemoveTransactionIdForIncomingRequest(transactionId)  ;\n                    }\n                }\n             }\n        }\n        else {\n            existingDialog = true;\n        }\n\n        if( irq ) {\n\n            DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest found incoming transaction \" << std::hex << irq  ;\n\n            msg_t* msg = nta_incoming_getrequest( irq ) ;   //adds a reference\n            sip_t *sip = sip_object( msg );\n\n            tport_t *tp = nta_incoming_transport(m_agent, irq, msg) ; \n\n            if (!tp || tport_is_shutdown(tp)) {\n                failMsg = \"transport for response has been shutdown or closed\";\n                DR_LOG(log_error) << \"SipDialogController::doRespondToSipRequest - unable to forward response as transport has been closed or shutdown \"\n                    << sip->sip_call_id->i_id << \" \" << sip->sip_cseq->cs_seq;\n                bSentOK = false;\n                transportGone = true;\n                msg_destroy(msg);\n            }\n            else {\n                tport_t *tport = tport_parent( tp ) ;\n\n                pSelectedTransport = SipTransport::findTransport( tport ) ;\n                if (!pSelectedTransport) {\n                    bSentOK = false;\n                    failMsg = \"Unable to find transport for transaction\";\n                    DR_LOG(log_error) << \"SipDialogController::doRespondToSipRequest - unable to find transport for response to \"\n                        << sip->sip_call_id->i_id << \" \" << sip->sip_cseq->cs_seq;\n                }\n                else {\n                    pSelectedTransport->getContactUri(contact, true);\n                    contact = \"<\" + contact + \">\" ;\n\n                    pSelectedTransport->getDescription(transportDesc);\n\n                    tport_unref( tp ) ;\n            \n                    //create tags for headers\n                    tags = makeTags( headers, transportDesc ) ;\n\n                    if( body.length() && !searchForHeader( tags, siptag_content_type, contentType ) ) {\n                        if( 0 == body.find(\"v=0\") ) {\n                            contentType = \"application/sdp\" ;\n                            DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - automatically detecting content-type as application/sdp\"  ;\n                        }\n                    }\n\n                    rc = nta_incoming_treply( irq, code, status\n                        ,TAG_IF( (sip_method_invite == sip->sip_request->rq_method || sip->sip_request->rq_method == sip_method_subscribe) &&\n                            !searchForHeader( tags, siptag_contact_str, contact ), SIPTAG_CONTACT_STR(contact.c_str()) )\n                        ,TAG_IF(!body.empty(), SIPTAG_PAYLOAD_STR(body.c_str()))\n                        ,TAG_IF(!contentType.empty(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))\n                        ,TAG_NEXT(tags)\n                        ,TAG_END() ) ;\n                    if( 0 != rc ) {\n                        bSentOK = false ;\n                        failMsg = \"Unknown server error sending response\" ;\n                    }\n                }\n            }\n\n            //  we need to cache source address / port / transport for successful REGISTER or SUBSCRIBE requests from webrtc clients so we can \n            //  later send INVITEs and NOTIFYs\n            if( bSentOK && ((sip->sip_request->rq_method == sip_method_subscribe && (202 == code || 200 ==code) ) ||\n                (sip->sip_request->rq_method == sip_method_register && 200 == code) ) ) {\n\n                sip_contact_t* contact = sip->sip_contact ;\n                if( contact ) {\n                    if( !tport_is_dgram(tp) /*&& NULL != strstr( contact->m_url->url_host, \".invalid\") */) {\n                        bool add = true ;\n                        unsigned long expires = 0 ;\n\n                        msg_t *msgResponse = nta_incoming_getresponse( irq ) ;    // adds a reference\n                        if (msg) {\n                            sip_t *sipResponse = sip_object( msgResponse ) ;\n                            if (sipResponse) {\n                                if( sip->sip_request->rq_method == sip_method_subscribe ) {\n                                    if (sipResponse->sip_expires && sipResponse->sip_expires->ex_delta) {\n                                        expires = sipResponse->sip_expires->ex_delta;\n                                    }\n                                    else {\n                                        DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - 200-class response to SUBSCRIBE must include expires (rfc3265 3.1.1)\"  ;\n                                    }\n                                }\n                                else {\n                                    if( NULL != sipResponse->sip_contact && NULL != sipResponse->sip_contact->m_expires ) {\n                                        expires = ::atoi( sipResponse->sip_contact->m_expires ) ;\n                                    }\n                                    else if (NULL != sipResponse->sip_contact && sipResponse->sip_expires->ex_delta) {\n                                        expires = sipResponse->sip_expires->ex_delta;\n                                    }  \n                                }\n                                \n                                add = expires > 0 ;\n                                if( add ) {\n                                    theOneAndOnlyController->cacheTportForSubscription( contact->m_url->url_user, contact->m_url->url_host, expires, tp ) ;\n                                }\n                                else {\n                                    theOneAndOnlyController->flushTportForSubscription( contact->m_url->url_user, contact->m_url->url_host ) ;                        \n                                }\n                            }\n                            else {\n                                bSentOK = false ;\n                                failMsg = \"connection error: remote side may have closed socket\";                                \n                            }\n                            msg_destroy( msgResponse ) ;    // releases the reference                            \n                        }\n                        else {\n                            bSentOK = false ;\n                            failMsg = \"connection error: remote side may have closed socket\";\n                        }\n                    }\n                }\n            }\n\n            if (existingDialog && bSentOK) {\n                nta_leg_t* leg = nta_leg_by_call_id(m_pController->getAgent(), sip->sip_call_id->i_id);\n                if (leg) {\n                    std::shared_ptr<SipDialog> dlg ;\n                    if(findDialogByLeg( leg, dlg )) {\n                        dialogId = dlg->getDialogId();\n                        DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest retrieved dialog id for existing dialog \" << dialogId  ;\n                        if (sip->sip_request->rq_method == sip_method_invite && body.length()) {\n                            DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest updating local sdp for dialog \" << dialogId  ;\n                            dlg->setLocalSdp( body.c_str() ) ;\n                        }\n                    }\n                }\n            }\n            msg_destroy( msg ); //release the reference\n\n            DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest destroying irq \" << irq  ;\n            bDestroyIrq = true ;                        \n        }\n        else if( iip ) {\n            DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest found invite or subscribe in progress \" << std::hex << iip  ;\n           /* invite in progress */\n            nta_leg_t* leg = const_cast<nta_leg_t *>(iip->leg()) ;\n            irq = const_cast<nta_incoming_t *>(iip->irq()) ;         \n            std::shared_ptr<SipDialog> dlg = iip->dlg() ;\n\n            if (dlg->getSipStatus() >= 200) {\n                DR_LOG(log_warning) << \"SipDialogController::doRespondToSipRequest: iip \" << std::hex << iip  << \n                    \": application attempting to send final response \" << std::dec << dlg->getSipStatus() << \n                    \" when a final response has already been sent; discarding\" ;\n            }\n            else {\n                msg_t* msg = nta_incoming_getrequest( irq ) ;   //allocates a reference\n                sip_t *sip = sip_object( msg );\n\n                tport_t *tp = nta_incoming_transport(m_agent, irq, msg) ; \n                if (!tp || tport_is_shutdown(tp)) {\n                    failMsg = \"transport for response has been shutdown or closed\";\n                    DR_LOG(log_error) << \"SipDialogController::doRespondToSipRequest - unable to forward response as transport has been closed or shutdown \"\n                        << sip->sip_call_id->i_id << \" \" << sip->sip_cseq->cs_seq;\n                    bSentOK = false;\n                    transportGone = true;\n                    msg_destroy(msg);\n                }\n                else {\n                    tport_t *tport = tport_parent( tp ) ;\n\n                    pSelectedTransport = SipTransport::findTransport( tport ) ;\n                    assert(pSelectedTransport); \n\n                    pSelectedTransport->getContactUri(contact, true);\n                    contact = \"<\" + contact + \">\" ;\n\n                    pSelectedTransport->getDescription(transportDesc);\n\n                    tport_unref( tp ) ;\n            \n                    //create tags for headers\n                    tags = makeTags( headers, transportDesc ) ;\n                    string customContact ;\n                    bool hasCustomContact = searchForHeader( tags, siptag_contact_str, customContact ) ;\n                    if( hasCustomContact ) {\n                        DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - client provided contact header so we wont include our internally-generated one\"  ;\n                    }\n\n                    dlg->setLocalContactHeader(hasCustomContact ? customContact.c_str() : contact.c_str());\n\n                    dialogId = dlg->getDialogId() ;\n\n                    dlg->setSipStatus( code ) ;\n\n                    /* if the client included Require: 100rel on a provisional, send it reliably */\n                    bool bReliable = false ;\n                    if( code > 100 && code < 200 && sip->sip_request->rq_method == sip_method_invite) {\n                        int i = 0 ;\n                        while( tags[i].t_tag != tag_null ) {\n                            if( tags[i].t_tag == siptag_require_str && NULL != strstr( (const char*) tags[i].t_value, \"100rel\") ) {\n                                bReliable = true ;\n                                break ;\n                            }\n                            i++ ;\n                        }\n                    }\n\n                    /* update local sdp if provided */\n                    string strLocalSdp ;\n                    if( !body.empty()  ) {\n                        dlg->setLocalSdp( body.c_str() ) ;\n                        string strLocalContentType ;\n                        if( searchForHeader( tags, siptag_content_type_str, strLocalContentType ) ) {\n                            dlg->setLocalContentType( strLocalContentType ) ;\n                        }\n                        else {\n                            /* set content-type if we can detect it */\n                            if( 0 == body.find(\"v=0\") ) {\n                                contentType = \"application/sdp\" ;\n                                dlg->setLocalContentType( contentType ) ;\n                            }\n                        }\n                    }\n\n                    /* set session timer if required */\n                    sip_session_expires_t *sessionExpires = nullptr;\n                    if( 200 == code && sip->sip_request->rq_method == sip_method_invite ) {\n                        string strSessionExpires ;\n                        if( searchForHeader( tags, siptag_session_expires_str, strSessionExpires ) ) {\n                            sip_session_expires_t* se = sip_session_expires_make(m_pController->getHome(), strSessionExpires.c_str() );\n                            unsigned long interval = std::max((unsigned long) 90, se->x_delta);\n                            SipDialog::SessionRefresher_t who = !se->x_refresher || 0 == strcmp( se->x_refresher, \"uac\") ? SipDialog::they_are_refresher : SipDialog::we_are_refresher;\n\n                            if (who == SipDialog::we_are_refresher) {\n                                DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - per app we are refresher, interval will be \" << interval  ;\n                            }\n                            else {\n                                DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - per app UAC is refresher, interval will be \" << interval  ;\n                            }\n                            dlg->setSessionTimer(interval, who) ;\n                            su_free( m_pController->getHome(), se ) ;\n                        }\n                        else if (sip->sip_session_expires && sip->sip_session_expires->x_refresher) {\n                            sip_session_expires_t* se = sip->sip_session_expires;\n                            sessionExpires = sip_session_expires_copy(m_pController->getHome(), se);\n                            unsigned long interval = std::max((unsigned long) 90, se->x_delta);\n                            SipDialog::SessionRefresher_t who = !se->x_refresher || 0 == strcmp( se->x_refresher, \"uac\") ? SipDialog::they_are_refresher : SipDialog::we_are_refresher;\n\n                            if (who == SipDialog::we_are_refresher) {\n                                DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - UAC asked us to refresh, interval will be \" << interval  ;\n                            }\n                            else {\n                                DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - UAC is refresher, interval will be \" << interval  ;\n                            }\n                            dlg->setSessionTimer(interval, who) ;\n                        }\n                    }\n\n                    /* iterate through data.opts.headers, adding headers to the response */\n                    if( bReliable ) {\n                        DR_LOG(log_debug) << \"Sending \" << dec << code << \" response reliably\"  ;\n                        nta_reliable_t* rel = nta_reliable_treply( irq, uasPrack, this, code, status\n                            ,TAG_IF( !hasCustomContact, SIPTAG_CONTACT_STR(contact.c_str()))\n                            ,TAG_IF(!body.empty(), SIPTAG_PAYLOAD_STR(body.c_str()))\n                            ,TAG_IF(!contentType.empty(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))\n                            ,TAG_IF(sessionExpires, SIPTAG_SESSION_EXPIRES(sessionExpires))\n                            ,TAG_NEXT(tags)\n                            ,TAG_END() ) ;\n\n                        if( !rel ) {\n                            bSentOK = false ;\n                            failMsg = \"Remote endpoint does not support 100rel\" ;\n                            DR_LOG(log_error) << \"SipDialogController::doRespondToSipRequest - failed sending reliable provisional response; most likely remote endpoint does not support 100rel\"  ;\n                        } \n                        else {\n                            IIP_SetReliable(m_invitesInProgress, iip, rel);\n                        }\n                        //TODO: should probably set timer here\n                    }\n                    else {\n                        DR_LOG(log_debug) << \"Sending \" << dec << code << \" response (not reliably)  on irq \" << hex << irq  ;\n                        rc = nta_incoming_treply( irq, code, status\n                            ,TAG_IF( code >= 200 && code < 300 && !hasCustomContact, SIPTAG_CONTACT_STR(contact.c_str()))\n                            ,TAG_IF(!body.empty(), SIPTAG_PAYLOAD_STR(body.c_str()))\n                            ,TAG_IF(!contentType.empty(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))\n                            ,TAG_IF(sessionExpires, SIPTAG_SESSION_EXPIRES(sessionExpires))\n                            ,TAG_NEXT(tags)\n                            ,TAG_END() ) ; \n                        if( 0 != rc ) {\n                            DR_LOG(log_error) << \"Error \" << dec << rc << \" sending response on irq \" << hex << irq <<\n                                \" - this is usually because the application provided a syntactically-invalid header\";\n                            bSentOK = false ;\n                            failMsg = \"Unknown server error sending response\" ;\n                        }\n                        else {\n                            if( sip_method_subscribe == nta_incoming_method(irq) ) {\n                                bClearIIP = true ;\n\n                                // add dialog for SUBSCRIBE dialogs\n                                if( 202 == code || 200 == code ) {\n                                DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest: adding dialog for subscribe with dialog id \" <<  dlg->getDialogId()  ;\n                                this->addDialog( dlg ) ;\n                                }\n                            }\n\n                            // sofia handles retransmits for us for final failures, but not for success\n                            // TODO: figure out why this is\n                            if( sip_method_invite == nta_incoming_method(irq) && code == 200 ) {\n                                \n                                this->addDialog( dlg ) ;\n\n                                if (tport_is_dgram(tp)) {\n                                    // set timer G to retransmit 200 OK if we don't get ack\n                                    TimerEventHandle t = m_pTQM->addTimer(\"timerG\",\n                                        std::bind(&SipDialogController::retransmitFinalResponse, this, irq, tp, dlg), NULL, NTA_SIP_T1 ) ;\n                                    dlg->setTimerG(t) ;\n                                }\n                                // set timer H, which sets the time to stop these retransmissions\n                                TimerEventHandle t = m_pTQM->addTimer(\"timerH\",\n                                    std::bind(&SipDialogController::endRetransmitFinalResponse, this, irq, tp, dlg), NULL, TIMER_H_MSECS ) ;\n                                dlg->setTimerH(t) ;\n                            }\n\n                            // stats\n                            if (theOneAndOnlyController->getStatsCollector().enabled()) {\n            \n                                // response time to incoming INVITE request\n                                if (sip_method_invite == nta_incoming_method(irq) && code <= 200) {\n                                    auto now = std::chrono::steady_clock::now();\n                                    std::chrono::duration<double> diff = now - dlg->getArrivalTime();\n                                    if (!dlg->hasAlerted()) {\n                                        dlg->alerting();\n                                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_PDD_IN, diff.count())\n                                    }\n                                    if (code == 200) {\n                                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_RESPONSE_TIME_IN, diff.count())\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    msg_destroy( msg ); //release the reference\n                    if (sessionExpires) su_free(m_pController->getHome(), sessionExpires);\n                }\n            }\n        }\n        else {\n\n            DR_LOG(log_error) << \"SipDialogController::doRespondToSipRequest - unable to find irq or iip for transaction id \" << transactionId  ;\n\n            /* failed */\n            string strMethod ;\n            bSentOK = false ;\n            failMsg = \"Response not sent due to unknown transaction\" ;  \n\n            if( FindCSeqMethod( headers, strMethod ) ) {\n                DR_LOG(log_debug) << \"silently discarding response to \" << strMethod  ;\n\n                if( 0 == strMethod.compare(\"CANCEL\") ) {\n                    failMsg = \"200 OK to incoming CANCEL is automatically generated by the stack\" ;\n                }\n            }                     \n        }\n\n        if( bSentOK ) {\n            string encodedMessage ;\n            msg_t* msg = nta_incoming_getresponse( irq ) ;  // adds a ref\n\n            // we can get an rc=0 from nta_incoming_treply above, but have it actually fail\n            // in the case of a websocket that closed immediately after sending us a BYE\n            if (msg) {\n                sip_t *sip = sip_object( msg );\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta( msg, irq, \"application\" ) ;\n\n                STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_OUT, {\n                    {\"method\", sip->sip_cseq->cs_method_name},\n                    {\"code\", boost::lexical_cast<std::string>(code)}})\n\n                string s ;\n                meta.toMessageFormat(s) ;\n                string data = s + \"|\" + transactionId + \"|\" + dialogId + \"|\" + \"|Msg sent:|\" + DR_CRLF + encodedMessage ;\n\n                m_pController->getClientController()->route_api_response( clientMsgId, \"OK\", data) ;\n\n                if( iip && code >= 300 ) {\n                    Cdr::postCdr( std::make_shared<CdrStop>( msg, \"application\", Cdr::call_rejected ) );\n                }\n                else if (iip && code == 200) {\n                    Cdr::postCdr( std::make_shared<CdrStart>( msg, \"application\", Cdr::uas ) );                \n                }\n\n                msg_destroy(msg) ;      // release the ref                          \n            }\n            else {\n                m_pController->getClientController()->route_api_response( clientMsgId, \"NOK\", \"failed sending, possibly due to far end closing socket\") ;\n            }\n        }\n        else {\n            m_pController->getClientController()->route_api_response( clientMsgId, \"NOK\", failMsg) ;\n        }\n        /* tell client controller to flush transaction data on any final response to a non-INVITE */\n        if( sip_method_invite != nta_incoming_method(irq) && code >= 200 ) {\n            m_pController->getClientController()->removeNetTransaction( transactionId ) ;\n        }\n        else if( sip_method_invite == nta_incoming_method(irq) && code > 200 ) {\n            m_pController->getClientController()->removeNetTransaction( transactionId ) ;            \n        }\n        else if(sip_method_invite == nta_incoming_method(irq) && code == 200 && existingDialog) {\n            m_pController->getClientController()->removeNetTransaction( transactionId ) ;            \n        }\n\n        if( bClearIIP && iip) {\n            IIP_Clear(m_invitesInProgress, iip);\n        }\n\n        if( bDestroyIrq && !transportGone) nta_incoming_destroy(irq) ;    \n\n        pData->~SipMessageData() ;\n\n        deleteTags( tags );\n\n        su_free(m_pController->getHome(), sip_status);\n\n    }\n\n    int SipDialogController::processRequestInsideDialog( nta_leg_t* leg, nta_incoming_t* irq, sip_t const *sip) {\n        DR_LOG(log_debug) << \"SipDialogController::processRequestInsideDialog: \" << sip->sip_request->rq_method_name << \" irq \" << irq  ;\n        int rc = 0 ;\n        string transactionId ;\n        generateUuid( transactionId ) ;\n\n        switch (sip->sip_request->rq_method) {\n            case sip_method_ack:\n            {\n                /* ack to 200 OK comes here  */\n                std::shared_ptr<IIP> iip ;\n                std::shared_ptr<SipDialog> dlg ;       \n                if (!IIP_FindByLeg(m_invitesInProgress, leg, iip)) {\n                    \n                    /* not a new INVITE, so it should be found as an existing dialog; i.e. a reINVITE */\n                    if( !findDialogByLeg( leg, dlg ) ) {\n                        DR_LOG(log_error) << \"SipDialogController::processRequestInsideDialog - unable to find Dialog for leg\"  ;\n                        assert(0) ;\n                        return -1 ;\n                    }\n                }\n                else {\n                    transactionId = iip->getTransactionId() ;\n                    dlg = iip->dlg();\n                    IIP_Clear(m_invitesInProgress, iip);\n                    this->clearSipTimers(dlg);\n                    //addDialog( dlg ) ;  now adding when we send the 200 OK\n                }\n                string encodedMessage ;\n                msg_t* msg = nta_incoming_getrequest( irq ) ; // adds a reference\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta( msg, irq ) ;\n                msg_destroy(msg) ;      // releases the reference\n\n                m_pController->getClientController()->route_ack_request_inside_dialog(  encodedMessage, meta, irq, sip, transactionId, dlg->getTransactionId(), dlg->getDialogId() ) ;\n\n                nta_incoming_destroy(irq) ;\n                break ;\n            }\n            case sip_method_cancel:\n            {\n                // this should only happen in a race condition, where we've sent the 200 OK but not yet received an ACK \n                //  in this case, send a 481 to the CANCEL and then generate a BYE\n                std::shared_ptr<SipDialog> dlg ;\n                if( !this->findDialogByLeg( leg, dlg ) ) {\n                    DR_LOG(log_error) << \"SipDialogController::processRequestInsideDialog - unable to find Dialog for leg\"  ;\n                    return 481 ;\n                    assert(0) ;\n                    return -1;\n                }\n                DR_LOG(log_warning) << \"SipDialogController::processRequestInsideDialog - received CANCEL after 200 OK; reply 481 and tear down dialog\"  ;\n                this->clearSipTimers(dlg);\n\n                // 481 to the CANCEL\n                nta_incoming_treply( irq, SIP_481_NO_TRANSACTION, TAG_END() ) ;  \n\n                // BYE to the far end\n                nta_outgoing_t* orq = nta_outgoing_tcreate( leg, NULL, NULL,\n                                        NULL,\n                                        SIP_METHOD_BYE,\n                                        NULL,\n                                        SIPTAG_REASON_STR(\"SIP ;cause=200 ;text=\\\"CANCEL after 200 OK\\\"\"),\n                                        TAG_END() ) ;\n\n                msg_t* m = nta_outgoing_getrequest(orq) ;  // adds a reference\n                sip_t* sip = sip_object( m ) ;\n\n                DR_LOG(log_info) << \"SipDialogController::processRequestInsideDialog - (cancel) created orq \" << std::hex << (void *) orq  <<\n                    \" call-id \" << sip->sip_call_id->i_id;\n\n                string encodedMessage ;\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta(m, orq) ;\n                string s ;\n                meta.toMessageFormat(s) ;\n\n                m_pController->getClientController()->route_request_inside_dialog( encodedMessage, meta, sip, \"unsolicited\", dlg->getDialogId() ) ;\n                msg_destroy(m);      // releases the reference\n\n                nta_outgoing_destroy(orq) ;\n                SD_Clear(m_dialogs, leg ) ;\n\n            }\n            default:\n            {\n                std::shared_ptr<SipDialog> dlg ;\n                if( !this->findDialogByLeg( leg, dlg ) ) {\n                    DR_LOG(log_error) << \"SipDialogController::processRequestInsideDialog - unable to find Dialog for leg\"  ;\n                    return 481 ;\n                    assert(0) ;\n                }\n\n                if (sip_method_invite == sip->sip_request->rq_method) {\n                    nta_incoming_treply(irq, SIP_100_TRYING, TAG_END());\n                }\n\n                /* if this is a re-INVITE or an UPDATE deal with session timers */\n                if( sip_method_invite == sip->sip_request->rq_method || sip_method_update == sip->sip_request->rq_method ) {\n                    bool weAreRefresher = false;\n                    if( dlg->hasSessionTimer() ) { \n                        DR_LOG(log_info) << \"SipDialogController::processRequestInsideDialog - canceling session expires timer due to re-invite\"  ;\n                        weAreRefresher = dlg->areWeRefresher();\n                        dlg->cancelSessionTimer() ;\n                    }\n\n                    /* reject if session timer is too small */\n                    if( sip->sip_session_expires && sip->sip_session_expires->x_delta < dlg->getMinSE() ) {\n                        ostringstream o ;\n                        o << dlg->getMinSE() ;\n                        nta_incoming_treply( irq, SIP_422_SESSION_TIMER_TOO_SMALL, \n                            SIPTAG_MIN_SE_STR(o.str().c_str()),\n                            TAG_END() ) ;  \n                        return 0 ;             \n                    }\n                    if( sip->sip_session_expires ) {\n                        dlg->setSessionTimer( sip->sip_session_expires->x_delta, \n                            (!sip->sip_session_expires->x_refresher && weAreRefresher) ||(sip->sip_session_expires->x_refresher && 0 == strcmp( sip->sip_session_expires->x_refresher, \"uac\")) ? \n                            SipDialog::they_are_refresher : \n                            SipDialog::we_are_refresher) ;\n                    }\n\n                }\n\n                string encodedMessage ;\n                msg_t* msg = nta_incoming_getrequest( irq ) ;   //adds a reference\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta( msg, irq ) ;\n                msg_destroy( msg ); // release the reference\n\n                bool routed = m_pController->getClientController()->route_request_inside_dialog( encodedMessage, meta, sip, transactionId, dlg->getDialogId() ) ;\n                if (!routed && dlg->getSipStatus() < 200) {\n                    // got a request before we sent a 200 OK to the initial INVITE, treat as an out-of-dialog request\n                    switch (sip->sip_request->rq_method) {\n                        case sip_method_notify:\n                        case sip_method_options:\n                        case sip_method_info:\n                        case sip_method_message:\n                        case sip_method_publish:\n                        case sip_method_subscribe:\n                            return m_pController->processMessageStatelessly( msg, (sip_t*) sip);\n                        default:\n                        break;\n                    }\n                }\n\n                addIncomingRequestTransaction( irq, transactionId) ;\n    \n                if( sip_method_bye == sip->sip_request->rq_method || \n                    (sip_method_notify == sip->sip_request->rq_method && !dlg->isInviteDialog() &&\n                        NULL != sip->sip_subscription_state && \n                        NULL != sip->sip_subscription_state->ss_substate &&\n                        NULL != strstr(sip->sip_subscription_state->ss_substate, \"terminated\") ) \n                ) {\n\n                    this->clearSipTimers(dlg);\n\n                    //clear dialog when we send a 200 OK response to BYE\n                    SD_Clear(m_dialogs, leg ) ;\n                    if( !routed ) {\n                        nta_incoming_treply( irq, SIP_481_NO_TRANSACTION, TAG_END() ) ;                \n                    }\n                }\n\n                if (sip_method_bye == sip->sip_request->rq_method) {\n                  Cdr::postCdr( std::make_shared<CdrStop>( msg, \"network\", Cdr::normal_release ) );\n                }\n            }\n        }\n        return rc ;\n    }\n    int SipDialogController::processResponseInsideDialog( nta_outgoing_t* orq, sip_t const* sip )  {\n        DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: \"  ;\n    \tostringstream o ;\n        std::shared_ptr<RIP> rip  ;\n        sip_method_t method = sip->sip_cseq->cs_method;\n        int statusCode = sip->sip_status->st_status ;\n\n        if( findRIPByOrq( orq, rip ) ) {\n            DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: found request for \"  << sip->sip_cseq->cs_method_name << \" sip status \" << statusCode ;\n\n            string encodedMessage ;\n            bool truncated ;\n            msg_t* msg = nta_outgoing_getresponse(orq) ;  // adds a reference\n            SipMsgData_t meta( msg, orq, \"network\") ;\n            EncodeStackMessage( sip, encodedMessage ) ;\n            \n            m_pController->getClientController()->route_response_inside_transaction( encodedMessage, meta, orq, sip, rip->getTransactionId(), rip->getDialogId() ) ;            \n\n            if (method == sip_method_invite && 200 == statusCode) {\n                tport_t *tp = nta_outgoing_transport(orq) ; \n                sip_session_expires_t* se = sip_session_expires(sip) ;\n\n                // start a timerD for this successful reINVITE\n                if (tport_is_dgram(tp) )m_timerDHandler.addInvite(orq);\n                \n                /* reset session expires timer, if provided */\n                if( se ) {\n                    std::shared_ptr<SipDialog> dlg ;\n                    nta_leg_t* leg = nta_leg_by_call_id(m_pController->getAgent(), sip->sip_call_id->i_id);\n                    DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: searching for dialog by leg \" << std::hex << (void *) leg;\n                    if(leg && findDialogByLeg( leg, dlg )) {\n                        DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: (re)setting session expires timer to \" <<  se->x_delta;\n                        //TODO: if session-expires value is less than min-se ACK and then BYE with Reason header    \n                        dlg->setSessionTimer( se->x_delta, \n                            !se->x_refresher || 0 == strcmp( se->x_refresher, \"uac\") ? \n                                SipDialog::we_are_refresher : \n                                SipDialog::they_are_refresher ) ;\n                    }\n                    else {\n                        DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: unable to find dialog for leg \" << std::hex << (void *) leg;\n                    }\n                }\n                else {\n                    DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: no session expires header found\";\n                }\n            }\n            if (rip->shouldClearDialogOnResponse()) {\n                string dialogId = rip->getDialogId() ;\n                if (sip->sip_cseq->cs_method == sip_method_bye && (sip->sip_status->st_status == 407 || sip->sip_status->st_status == 401)) {\n                    DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: NOT clearing dialog after receiving 401/407 response to BYE\"  ;\n                }\n                else if( dialogId.length() > 0 ) {\n                    DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: clearing dialog after receiving response to BYE or notify w/ subscription-state terminated\"  ;\n                    SD_Clear(m_dialogs, dialogId ) ;\n                }\n                else {\n                    DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: got 200 OK to BYE but don't have dialog id\"  ;\n                    assert(false) ;\n                }\n            }\n            clearRIP( orq ) ;     \n            msg_destroy(msg) ;   // releases reference\n        }\n        else {\n            DR_LOG(log_error) << \"SipDialogController::processResponseInsideDialog: unable to find request associated with response\"  ;            \n            nta_outgoing_destroy( orq ) ;\n        }\n  \n\t\treturn 0 ;\n    }\n    int SipDialogController::processResponseToRefreshingReinvite( nta_outgoing_t* orq, sip_t const* sip ) {\n        DR_LOG(log_debug) << \"SipDialogController::processResponseToRefreshingReinvite: \"  ;\n        ostringstream o ;\n        std::shared_ptr<RIP> rip  ;\n\n        nta_leg_t* leg = nta_leg_by_call_id(m_pController->getAgent(), sip->sip_call_id->i_id);\n        assert(leg) ;\n        std::shared_ptr<SipDialog> dlg ;\n        if( !findDialogByLeg( leg, dlg ) ) {\n            assert(0) ;\n        }\n        if( findRIPByOrq( orq, rip ) ) {\n\n            if( sip->sip_status->st_status != 200 ) {\n                DR_LOG(log_info) << \"SipDialogController::processResponseToRefreshingReinvite: reinvite failed \"  ;\n                //TODO: notify client that call has failed, send BYE\n            }\n            else {\n                /* reset session expires timer, if provided */\n                sip_session_expires_t* se = sip_session_expires(sip) ;\n                if( se ) {                \n                    //TODO: if session-expires value is less than min-se ACK and then BYE with Reason header    \n                    dlg->setSessionTimer( se->x_delta, \n                        !se->x_refresher || 0 == strcmp( se->x_refresher, \"uac\") ? \n                            SipDialog::we_are_refresher : \n                            SipDialog::they_are_refresher ) ;\n                }\n             }\n\n            nta_outgoing_t* ack_request = nta_outgoing_tcreate(leg, NULL, NULL, NULL,\n                   SIP_METHOD_ACK,\n                   (url_string_t*) sip->sip_contact->m_url ,\n                   TAG_END());\n\n            nta_outgoing_destroy( ack_request ) ;\n            clearRIP( orq ) ;          \n\n            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", \"ACK\"}})\n            return 0;\n        }\n        nta_outgoing_destroy( orq ) ;\n        return 0 ;\n        \n    }\n\n    int SipDialogController::processCancelOrAck( nta_incoming_magic_t* p, nta_incoming_t* irq, sip_t const *sip ) {\n        std::shared_ptr<IIP> iip ;\n        if( !sip ) {\n            DR_LOG(log_debug) << \"SipDialogController::processCancel with null sip pointer; irq \" << \n                hex << (void*) irq << \", most probably timerH indicating end of final response retransmissions\" ;\n            //nta_incoming_destroy(irq);\n            std::shared_ptr<IIP> iip ;\n            if (!IIP_FindByIrq(m_invitesInProgress, irq, iip)) {\n                DR_LOG(log_error) << \"Unable to find invite-in-progress for irq \" << hex << (void*) irq;\n            }\n            else {\n                DR_LOG(log_debug) << \"SipDialogController::processCancelOrAck - clearing IIP for leg \" << hex << (void*) iip->leg();   ;\n                IIP_Clear(m_invitesInProgress, iip);\n            }\n            return -1 ;\n        }\n        DR_LOG(log_debug) << \"SipDialogController::processCancelOrAck: \" << sip->sip_request->rq_method_name  ;\n        string transactionId ;\n        generateUuid( transactionId ) ;\n\n        if( sip->sip_request->rq_method == sip_method_cancel ) {\n            if (!IIP_FindByIrq(m_invitesInProgress, irq, iip)) {\n                DR_LOG(log_error) << \"Unable to find invite-in-progress for CANCEL with call-id \" << sip->sip_call_id->i_id  ;\n                return 0 ;\n            }\n            std::shared_ptr<SipDialog> dlg = iip->dlg() ;\n\n            if( !dlg ) {\n                DR_LOG(log_error) << \"No dialog exists for invite-in-progress for CANCEL with call-id \" << sip->sip_call_id->i_id  ;\n                return 0 ;\n            }\n\n            DR_LOG(log_debug) << \"SipDialogController::processCancelOrAck - Received CANCEL for call-id \" << sip->sip_call_id->i_id << \", sending to client\"  ;\n\n            string encodedMessage ;\n            msg_t* msg = nta_incoming_getrequest( irq ) ;   // adds a reference\n            EncodeStackMessage( sip, encodedMessage ) ;\n            SipMsgData_t meta( msg, irq ) ;\n            Cdr::postCdr( std::make_shared<CdrStop>( msg, \"network\", Cdr::call_canceled ) );\n            msg_destroy(msg);                               // releases reference\n\n            m_pClientController->route_request_inside_invite( encodedMessage, meta, irq, sip, iip->getTransactionId(), dlg->getDialogId() ) ;\n            \n            //TODO: sofia has already sent 200 OK to cancel and 487 to INVITE.  Do we need to keep this irq around?\n            //addIncomingRequestTransaction( irq, transactionId) ;\n\n            DR_LOG(log_debug) << \"SipDialogController::processCancelOrAck - clearing IIP \"   ;\n            IIP_Clear(m_invitesInProgress, iip);\n            DR_LOG(log_debug) << \"SipDialogController::processCancelOrAck - done clearing IIP \"   ;\n\n        }\n        else if( sip->sip_request->rq_method == sip_method_ack ) {\n            if (!IIP_FindByIrq(m_invitesInProgress, irq, iip)) {\n                DR_LOG(log_error) << \"Unable to find invite-in-progress for ACK with call-id \" << sip->sip_call_id->i_id  ;\n                return 0 ;\n            }\n            std::shared_ptr<SipDialog> dlg = iip->dlg(); \n            IIP_Clear(m_invitesInProgress, iip);\n            this->clearSipTimers(dlg);\n\n            string transactionId ;\n            generateUuid( transactionId ) ;\n\n            string encodedMessage ;\n            msg_t* msg = nta_incoming_getrequest( irq ) ;  // adds a reference\n            EncodeStackMessage( sip, encodedMessage ) ;\n            SipMsgData_t meta( msg, irq ) ;\n            msg_destroy( msg ) ;    //release the reference\n\n            m_pController->getClientController()->route_ack_request_inside_dialog( encodedMessage, meta, irq, sip, transactionId, dlg->getTransactionId(), dlg->getDialogId() ) ;   \n            \n            //NB: when we get a CANCEL sofia sends the 487 response to the INVITE itself, so our latest sip status will be a provisional\n            //not sure that we need to do anything particular about that however....though it we write cdrs we would want to capture the 487 final response\n        \n            //another issue is that on any non-success response sent to an incoming INVITE the subsequent ACK is not sent to the client\n            //because there is no dialog created and thus no routing available.  Should fix this.\n        }\n        else {\n            DR_LOG(log_debug) << \"Received \" << sip->sip_request->rq_method_name << \" for call-id \" << sip->sip_call_id->i_id << \", discarding\"  ;\n        }\n        return 0 ;\n    }\n    int SipDialogController::processPrack( nta_reliable_t *rel, nta_incoming_t *prack, sip_t const *sip) {\n        DR_LOG(log_debug) << \"SipDialogController::processPrack: \"  ;\n        std::shared_ptr<IIP> iip  ;\n        if (IIP_FindByReliable(m_invitesInProgress, rel, iip)) {\n            std::string transactionId ;\n            generateUuid( transactionId ) ;\n            std::shared_ptr<SipDialog> dlg = iip->dlg() ;\n            assert( dlg ) ;\n\n            m_pClientController->addDialogForTransaction( dlg->getTransactionId(), dlg->getDialogId() ) ;  \n\n            string encodedMessage ;\n            msg_t* msg = nta_incoming_getrequest( prack ) ; // adds a reference\n            EncodeStackMessage( sip, encodedMessage ) ;\n            SipMsgData_t meta( msg, prack ) ;\n            msg_destroy(msg);                               // releases the reference\n\n            m_pClientController->route_request_inside_dialog( encodedMessage, meta, sip, transactionId, dlg->getDialogId() ) ;\n\n            iip->destroyReliable() ;\n\n            addIncomingRequestTransaction( prack, transactionId) ;\n        }\n        else {\n            assert(0) ;\n        }\n        return 0 ;\n    }\n    void SipDialogController::notifyRefreshDialog( std::shared_ptr<SipDialog> dlg ) {\n        nta_leg_t *leg = nta_leg_by_call_id( m_pController->getAgent(), dlg->getCallId().c_str() );\n        if( leg ) {\n            string strSdp = dlg->getLocalEndpoint().m_strSdp ;\n            string strContentType = dlg->getLocalEndpoint().m_strContentType ;\n\n            assert( dlg->getSessionExpiresSecs() ) ;\n            ostringstream o,v ;\n            o << dlg->getSessionExpiresSecs() << \"; refresher=uac\" ;\n            v << dlg->getMinSE() ;\n\n            nta_outgoing_t* orq = nta_outgoing_tcreate( leg,  response_to_refreshing_reinvite, (nta_outgoing_magic_t *) m_pController,\n                                            NULL,\n                                            SIP_METHOD_INVITE,\n                                            NULL,\n                                            SIPTAG_SESSION_EXPIRES_STR(o.str().c_str()),\n                                            SIPTAG_MIN_SE_STR(v.str().c_str()),\n                                            SIPTAG_CONTACT_STR( dlg->getLocalContactHeader().c_str() ),\n                                            SIPTAG_CONTENT_TYPE_STR(strContentType.c_str()),\n                                            SIPTAG_PAYLOAD_STR(strSdp.c_str()),\n                                            TAG_END() ) ;\n            \n            string transactionId ;\n            generateUuid( transactionId ) ;\n\n            std::shared_ptr<RIP> p = std::make_shared<RIP>( transactionId ) ; \n            addRIP( orq, p ) ;\n\n            DR_LOG(log_info) << \"SipDialogController::notifyRefreshDialog - created orq \" << std::hex << (void *) orq;\n\n            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", \"INVITE\"}})\n\n            //m_pClientController->route_event_inside_dialog( \"{\\\"eventName\\\": \\\"refresh\\\"}\",dlg->getTransactionId(), dlg->getDialogId() ) ;\n        }\n    }\n    void SipDialogController::notifyTerminateStaleDialog( std::shared_ptr<SipDialog> dlg, bool ackbye ) {\n        nta_leg_t* leg = const_cast<nta_leg_t *>(dlg->getNtaLeg()) ;\n        const char* reason = ackbye ? \"SIP ;cause=200 ;text=\\\"ACK-BYE due to cancel race condition\\\"\" : \"SIP ;cause=200 ;text=\\\"Session timer expired\\\"\";\n        if( leg ) {\n            nta_outgoing_t* orq = nta_outgoing_tcreate( leg, NULL, NULL,\n                                            NULL,\n                                            SIP_METHOD_BYE,\n                                            NULL,\n                                            SIPTAG_REASON_STR(reason),\n                                            TAG_END() ) ;\n            msg_t* m = nta_outgoing_getrequest(orq) ;    // adds a reference\n            sip_t* sip = sip_object( m ) ;\n\n            DR_LOG(log_info) << \"SipDialogController::notifyTerminateStaleDialog - created orq \" << std::hex << (void *) orq;\n\n            string byeTransactionId  = \"unsolicited\";\n\n            string encodedMessage ;\n            EncodeStackMessage( sip, encodedMessage ) ;\n            SipMsgData_t meta(m, orq) ;\n            string s ;\n            meta.toMessageFormat(s) ;\n            string data = s + \"|\" + byeTransactionId + \"|Msg sent:|\" + DR_CRLF + encodedMessage ;\n            msg_destroy(m) ;    // releases reference::process\n\n            // this is slightly inaccurate: we are telling the app we received a BYE when we are in fact generating it\n            // the impact is minimal though, and currently there is no message type to inform the app we generated a BYE on our own\n            bool routed = m_pController->getClientController()->route_request_inside_dialog( encodedMessage, meta, sip, byeTransactionId, dlg->getDialogId() ) ;\n\n            Cdr::postCdr( std::make_shared<CdrStop>( m, \"application\", ackbye ? Cdr::ackbye : Cdr::session_expired ) );\n            nta_outgoing_destroy(orq) ;\n\n            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", \"BYE\"}})\n        }\n        SD_Clear(m_dialogs, dlg) ;\n    }\n    void SipDialogController::notifyCancelTimeoutReachedIIP( std::shared_ptr<IIP> iip ) {\n        DR_LOG(log_info) << \"SipDialogController::notifyCancelTimeoutReachedIIP - tearing down transaction id \" << iip->getTransactionId() ;\n        m_pController->getClientController()->removeAppTransaction( iip->getTransactionId() ) ;\n        IIP_Clear(m_invitesInProgress, iip) ;\n    }\n\n    void SipDialogController::bindIrq( nta_incoming_t* irq ) {\n        nta_incoming_bind( irq, uasCancelOrAck, (nta_incoming_magic_t *) m_pController ) ;\n    }\n    bool SipDialogController::searchForHeader( tagi_t* tags, tag_type_t header, string& value ) {\n        int i = 0 ;\n        while( tags[i].t_tag != tag_null ) {\n            if( tags[i].t_tag == header ) {\n                value.assign( (const char*) tags[i].t_value );\n                return true ;\n            }\n            i++ ;\n        }\n        return false ;\n    }\n    void SipDialogController::addIncomingInviteTransaction( nta_leg_t* leg, nta_incoming_t* irq, sip_t const *sip, const string& transactionId, std::shared_ptr<SipDialog> dlg, const string& tag ) {\n        const char* a_tag = nta_incoming_tag( irq, tag.length() == 0 ? NULL : tag.c_str()) ;\n        nta_leg_tag( leg, a_tag ) ;\n        dlg->setLocalTag( a_tag ) ;\n\n        IIP_Insert(m_invitesInProgress, leg, irq, transactionId, dlg);\n\n        this->bindIrq( irq ) ;\n    }\n    void SipDialogController::addOutgoingInviteTransaction( nta_leg_t* leg, nta_outgoing_t* orq, sip_t const *sip, std::shared_ptr<SipDialog> dlg ) {\n        DR_LOG(log_debug) << \"SipDialogController::addOutgoingInviteTransaction:  adding leg \" << std::hex << leg  ;\n        IIP_Insert(m_invitesInProgress, leg, orq, dlg->getTransactionId(), dlg);\n    }\n\n    void SipDialogController::addRIP( nta_outgoing_t* orq, std::shared_ptr<RIP> rip) {\n        DR_LOG(log_debug) << \"SipDialogController::addRIP adding orq \" << std::hex << (void*) orq  ;\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        m_mapOrq2RIP.insert( mapOrq2RIP::value_type(orq,rip)) ;\n    }\n    bool SipDialogController::findRIPByOrq( nta_outgoing_t* orq, std::shared_ptr<RIP>& rip ) {\n        DR_LOG(log_debug) << \"SipDialogController::findRIPByOrq orq \" << std::hex << (void*) orq  ;\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        mapOrq2RIP::iterator it = m_mapOrq2RIP.find( orq ) ;\n        if( m_mapOrq2RIP.end() == it ) return false ;\n        rip = it->second ;\n        return true ;                       \n    }\n    void SipDialogController::clearRIP( nta_outgoing_t* orq ) {\n        DR_LOG(log_debug) << \"SipDialogController::clearRIP clearing orq \" << std::hex << (void*) orq  ;\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        mapOrq2RIP::iterator it = m_mapOrq2RIP.find( orq ) ;\n        nta_outgoing_destroy( orq ) ;\n        if( m_mapOrq2RIP.end() == it ) return  ;\n        m_mapOrq2RIP.erase( it ) ;                      \n    }\n    \n    void SipDialogController::retransmitFinalResponse( nta_incoming_t* irq, tport_t* tp, std::shared_ptr<SipDialog> dlg) {\n        DR_LOG(log_debug) << \"SipDialogController::retransmitFinalResponse irq:\" << std::hex << (void*) irq;\n        incoming_retransmit_reply(irq, tp);\n\n        // set next timer\n        uint32_t ms = dlg->bumpTimerG() ;\n        TimerEventHandle t = m_pTQM->addTimer(\"timerG\", \n            std::bind(&SipDialogController::retransmitFinalResponse, this, irq, tp, dlg), NULL, ms ) ;\n        dlg->setTimerG(t) ;\n    }\n\n    /**\n     * timer H went off.  Stop timer G (retransmits of 200 OK) and clear it and timer H\n     */\n    void SipDialogController::endRetransmitFinalResponse( nta_incoming_t* irq, tport_t* tp, std::shared_ptr<SipDialog> dlg) {\n        DR_LOG(log_error) << \"SipDialogController::endRetransmitFinalResponse - never received ACK for final response to incoming INVITE; irq:\" << \n            std::hex << (void*) irq << \" source address was \" << dlg->getSourceAddress() ;\n\n        nta_leg_t* leg = const_cast<nta_leg_t *>(dlg->getNtaLeg());\n        TimerEventHandle h = dlg->getTimerG() ;\n        if( h ) {\n            m_pTQM->removeTimer( h, \"timerG\");\n            dlg->clearTimerG();\n        }\n        h = dlg->getTimerH() ;\n        if (h) {\n            dlg->clearTimerH();\n        }\n\n        IIP_Clear(m_invitesInProgress, leg);\n\n\n        // we never got the ACK, so now we should tear down the call by sending a BYE\n        // TODO: also need to remove dialog from hash table\n        nta_outgoing_t* orq = nta_outgoing_tcreate( leg, NULL, NULL,\n                                NULL,\n                                SIP_METHOD_BYE,\n                                NULL,\n                                SIPTAG_REASON_STR(\"SIP ;cause=200 ;text=\\\"ACK timeout\\\"\"),\n                                TAG_END() ) ;\n\n        msg_t* m = nta_outgoing_getrequest(orq) ;  // adds a reference\n        sip_t* sip = sip_object( m ) ;\n\n        DR_LOG(log_info) << \"SipDialogController::endRetransmitFinalResponse - created orq \" << std::hex << (void *) orq \n            << \" for BYE on leg \" << (void *)leg;\n\n        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", \"BYE\"}})\n\n        string encodedMessage ;\n        EncodeStackMessage( sip, encodedMessage ) ;\n        SipMsgData_t meta(m, orq) ;\n        string s ;\n        meta.toMessageFormat(s) ;\n\n        m_pController->getClientController()->route_request_inside_dialog( encodedMessage, meta, sip, \"unsolicited\", dlg->getDialogId() ) ;\n\n        msg_destroy( m ); // release the reference\n\n        nta_outgoing_destroy(orq) ;\n        SD_Clear(m_dialogs, leg);\n    }\n    void SipDialogController::addIncomingRequestTransaction( nta_incoming_t* irq, const string& transactionId) {\n        DR_LOG(log_error) << \"SipDialogController::addIncomingRequestTransaction - adding transactionId \" << transactionId << \" for irq:\" << std::hex << (void*) irq;\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        m_mapTransactionId2Irq.insert( mapTransactionId2Irq::value_type(transactionId, irq)) ;\n    }\n    bool SipDialogController::findIrqByTransactionId( const string& transactionId, nta_incoming_t*& irq ) {\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        mapTransactionId2Irq::iterator it = m_mapTransactionId2Irq.find( transactionId ) ;\n        if( m_mapTransactionId2Irq.end() == it ) return false ;\n        irq = it->second ;\n        return true ;                       \n    }\n    nta_incoming_t* SipDialogController::findAndRemoveTransactionIdForIncomingRequest( const string& transactionId ) {\n        DR_LOG(log_debug) << \"SipDialogController::findAndRemoveTransactionIdForIncomingRequest - searching transactionId \" << transactionId ;\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        nta_incoming_t* irq = nullptr ;\n        mapTransactionId2Irq::iterator it = m_mapTransactionId2Irq.find( transactionId ) ;\n        if( m_mapTransactionId2Irq.end() != it ) {\n            irq = it->second ;\n            m_mapTransactionId2Irq.erase( it ) ;\n        }\n        else {\n            DR_LOG(log_debug) << \"SipDialogController::findAndRemoveTransactionIdForIncomingRequest - failed to find transactionId \" << transactionId << \n                \", most likely this is a response to an invite we sent\";\n        }\n        return irq ;\n    }\n\n    void SipDialogController::clearSipTimers(std::shared_ptr<SipDialog>& dlg) {\n        DR_LOG(log_debug) << \"SipDialogController::clearSipTimers for \" << dlg->getCallId()  ;\n        TimerEventHandle h = dlg->getTimerG() ;\n        if( h ) {\n            m_pTQM->removeTimer( h, \"timerG\");  \n            dlg->clearTimerG();\n        }\n        h = dlg->getTimerH() ;\n        if( h ) {\n            m_pTQM->removeTimer( h, \"timerH\"); \n            dlg->clearTimerH();\n        }\n    }\n\n    bool SipDialogController::stopTimerD(nta_outgoing_t* invite) {\n        return m_timerDHandler.clearTimerD(invite);\n    }\n\n    // TimerDHandler\n\n    // when we get a 200 OK to an INVITE we sent, call this to prepare handling timerD\n    void TimerDHandler::addInvite(nta_outgoing_t* invite) {\n        string callIdAndCSeq = combineCallIdAndCSeq(invite);\n        \n        // should never see this twice\n        assert(m_mapCallIdAndCSeq2Invite.end() == m_mapCallIdAndCSeq2Invite.find(callIdAndCSeq));\n\n        // we are waiting for the ACK from the app\n        m_mapCallIdAndCSeq2Invite.insert(mapCallIdAndCSeq2Invite::value_type(callIdAndCSeq, invite));\n\n        // start timerD\n        TimerEventHandle t = m_pTQM->addTimer(\"timerD\", std::bind(&TimerDHandler::timerD, this, invite, callIdAndCSeq), NULL, TIMER_D_MSECS ) ;\n\n        DR_LOG(log_info) << \"TimerDHandler::addInvite orq \" << hex << (void *)invite << \", \" << callIdAndCSeq;\n\n    }\n\n    // ..then, when the app gives us the ACK to send out, call this to save for possible retransmits\n    void TimerDHandler::addAck(nta_outgoing_t* ack) {\n        string callIdAndCSeq = combineCallIdAndCSeq(ack);\n\n        mapCallIdAndCSeq2Invite::const_iterator it = m_mapCallIdAndCSeq2Invite.find(callIdAndCSeq);\n        if (m_mapCallIdAndCSeq2Invite.end() != it) {\n            m_mapInvite2Ack.insert(mapInvite2Ack::value_type(it->second, ack));\n            m_mapCallIdAndCSeq2Invite.erase(it);\n            DR_LOG(log_info) << \"TimerDHandler::addAck \" << hex << (void *)ack << \", \" << callIdAndCSeq;\n        }\n        else {\n            DR_LOG(log_error) << \"TimerDHandler::addAck - failed to find outbound invite we sent for callid \" << nta_outgoing_call_id(ack);\n        }\n    }\n\n    // call this when we received a response to check it if is a retransmitted response\n    bool TimerDHandler::resendIfNeeded(nta_outgoing_t* invite) {\n        mapInvite2Ack::const_iterator it = m_mapInvite2Ack.find(invite);\n        if (it != m_mapInvite2Ack.end()) {\n            outgoing_retransmit(it->second) ;\n            return true;\n        }\n        else if (m_mapCallIdAndCSeq2Invite.size() > 0) {\n            string callIdAndCSeq = combineCallIdAndCSeq(invite);\n            if (m_mapCallIdAndCSeq2Invite.find(callIdAndCSeq) != m_mapCallIdAndCSeq2Invite.end()) {\n                DR_LOG(log_error) << \"TimerDHandler::resendIfNeeded - cannot retransmit ACK because app has not yet provided it \" << nta_outgoing_call_id(invite);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // this will automatically remove the transactions at the proper time, after timer D has expired\n    void TimerDHandler::timerD(nta_outgoing_t* invite, const string& callIdAndCSeq) {\n        mapCallIdAndCSeq2Invite::const_iterator it = m_mapCallIdAndCSeq2Invite.find(callIdAndCSeq);\n        if (it != m_mapCallIdAndCSeq2Invite.end()) {\n            DR_LOG(log_error) << \"TimerDHandler::timerD - app never sent ACK for successful uac INVITE\"  ;\n            m_mapCallIdAndCSeq2Invite.erase(it);\n        }\n        else {\n            mapInvite2Ack::const_iterator it = m_mapInvite2Ack.find(invite);\n            if (it != m_mapInvite2Ack.end()) {\n                DR_LOG(log_info) << \"TimerDHandler::timerD - freeing ACK orq \" << hex << (void *) it->second <<\n                    \" associated with invite orq \" << invite << \" for call-id/cseq \" << callIdAndCSeq;\n                nta_outgoing_destroy(it->second);\n                m_mapInvite2Ack.erase(it);\n            }\n        }\n    }\n\n    bool TimerDHandler::clearTimerD(nta_outgoing_t* invite) {\n        bool success = false;\n        string callIdAndCSeq = combineCallIdAndCSeq(invite);\n        mapCallIdAndCSeq2Invite::const_iterator it = m_mapCallIdAndCSeq2Invite.find(callIdAndCSeq);\n        if (it != m_mapCallIdAndCSeq2Invite.end()) {\n            DR_LOG(log_error) << \"TimerDHandler::clearTimerD - app never sent ACK for successful uac INVITE\"  ;\n            m_mapCallIdAndCSeq2Invite.erase(it);\n        }\n        else {\n            mapInvite2Ack::const_iterator it = m_mapInvite2Ack.find(invite);\n            if (it != m_mapInvite2Ack.end()) {\n                DR_LOG(log_info) << \"TimerDHandler::clearTimerD - freeing ACK orq \" << hex << (void *) it->second <<\n                    \" associated with invite orq \" << invite << \" for call-id/cseq \" << callIdAndCSeq;\n                nta_outgoing_destroy(it->second);\n                m_mapInvite2Ack.erase(it);\n                success = true;\n            }\n        }\n        return success;\n    }\n\n    // logging / metrics\n    void SipDialogController::logStorageCount(bool bDetail)  {\n\n        DR_LOG(bDetail ? log_info : log_debug) << \"SipDialogController storage counts\"  ;\n        DR_LOG(bDetail ? log_info : log_debug) << \"----------------------------------\"  ;\n        IIP_Log(m_invitesInProgress, bDetail);\n        SD_Log(m_dialogs, bDetail);\n\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        DR_LOG(bDetail ? log_info : log_debug) << \"m_mapTransactionId2Irq size:                                     \" << m_mapTransactionId2Irq.size()  ;\n        DR_LOG(bDetail ? log_info : log_debug) << \"number of outgoing transactions held for timerD:                 \" << m_timerDHandler.countTimerD()  ;\n        DR_LOG(bDetail ? log_info : log_debug) << \"number of outgoing transactions waiting for ACK from app:        \" << m_timerDHandler.countPending()  ;\n        m_pTQM->logQueueSizes() ;\n\n        // stats\n        if (theOneAndOnlyController->getStatsCollector().enabled()) {\n\n            size_t nUas = 0, nUac = 0;\n            size_t total = SD_Size(m_dialogs, nUac, nUas);\n            STATS_GAUGE_SET_NOCHECK(STATS_GAUGE_STABLE_DIALOGS, nUas, {{\"type\", \"inbound\"}})\n            STATS_GAUGE_SET_NOCHECK(STATS_GAUGE_STABLE_DIALOGS, nUac, {{\"type\", \"outbound\"}})\n        }\n    }\n\n}\n"], "fixing_code": ["/*\nCopyright (c) 2013, David C Horton\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <ifaddrs.h>\n#include <errno.h>\n#include <stdio.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <mutex>\n#include <algorithm>\n#include <regex>\n\n#include <boost/tokenizer.hpp>\n#include <boost/algorithm/string.hpp>\n#include <boost/algorithm/string/split.hpp>\n#include <boost/algorithm/string/find.hpp>\n\n#include \"drachtio.h\"\n#include \"controller.hpp\"\n\n#include <sofia-sip/url.h>\n#include <sofia-sip/nta_tport.h>\n#include <sofia-sip/tport.h>\n#include <sofia-sip/msg.h>\n#include <sofia-sip/msg_addr.h>\n#include <sofia-sip/sip_parser.h>\n#include <sofia-sip/su_string.h>\n#include <sofia-sip/su_uniqueid.h>\n#include <sofia-sip/su_addrinfo.h>\n\n\n#define MAX_LINELEN 2047\n\n#define MAX_SIP_URI_LEN (1024)\n\n#define BOOST_UUID (1)\n\nusing namespace std ;\n \nnamespace {\n    unsigned int json_allocs = 0 ;\n    unsigned int json_bytes = 0 ;\n    std::mutex  json_lock ;\n} ;\n\nnamespace drachtio {\n    \n    typedef std::unordered_map<string,tag_type_t> mapHdr2Tag ;\n\n    typedef std::unordered_set<string> setHdr ;\n\n    typedef std::unordered_map<string,sip_method_t> mapMethod2Type ;\n\n\t/* headers that are allowed to be set by the client in responses to sip requests */\n\tmapHdr2Tag m_mapHdr2Tag({\n\t\t{string(\"user_agent\"), siptag_user_agent_str}, \n        {string(\"subject\"), siptag_subject_str}, \n        {string(\"max_forwards\"), siptag_max_forwards_str}, \n        {string(\"proxy_require\"), siptag_proxy_require_str}, \n        {string(\"accept_contact\"), siptag_accept_contact_str}, \n        {string(\"reject_contact\"), siptag_reject_contact_str}, \n        {string(\"expires\"), siptag_expires_str}, \n        {string(\"date\"), siptag_date_str}, \n        {string(\"retry_after\"), siptag_retry_after_str}, \n        {string(\"timestamp\"), siptag_timestamp_str}, \n        {string(\"min_expires\"), siptag_min_expires_str}, \n        {string(\"priority\"), siptag_priority_str}, \n        {string(\"call_info\"), siptag_call_info_str}, \n        {string(\"organization\"), siptag_organization_str}, \n        {string(\"server\"), siptag_server_str}, \n        {string(\"in_reply_to\"), siptag_in_reply_to_str}, \n        {string(\"accept\"), siptag_accept_str}, \n        {string(\"accept_encoding\"), siptag_accept_encoding_str}, \n        {string(\"accept_language\"), siptag_accept_language_str}, \n        {string(\"allow\"), siptag_allow_str}, \n        {string(\"require\"), siptag_require_str}, \n        {string(\"supported\"), siptag_supported_str}, \n        {string(\"unsupported\"), siptag_unsupported_str}, \n        {string(\"event\"), siptag_event_str}, \n        {string(\"allow_events\"), siptag_allow_events_str}, \n        {string(\"subscription_state\"), siptag_subscription_state_str}, \n        {string(\"proxy_authenticate\"), siptag_proxy_authenticate_str}, \n        {string(\"proxy_authentication_info\"), siptag_proxy_authentication_info_str}, \n        {string(\"proxy_authorization\"), siptag_proxy_authorization_str}, \n        {string(\"authorization\"), siptag_authorization_str}, \n        {string(\"www_authenticate\"), siptag_www_authenticate_str}, \n        {string(\"authentication_info\"), siptag_authentication_info_str}, \n        {string(\"error_info\"), siptag_error_info_str}, \n        {string(\"warning\"), siptag_warning_str}, \n        {string(\"refer_to\"), siptag_refer_to_str}, \n        {string(\"referred_by\"), siptag_referred_by_str}, \n        {string(\"replaces\"), siptag_replaces_str}, \n        {string(\"session_expires\"), siptag_session_expires_str}, \n        {string(\"min_se\"), siptag_min_se_str}, \n        {string(\"path\"), siptag_path_str}, \n        {string(\"service_route\"), siptag_service_route_str}, \n        {string(\"reason\"), siptag_reason_str}, \n        {string(\"security_client\"), siptag_security_client_str}, \n        {string(\"security_server\"), siptag_security_server_str}, \n        {string(\"security_verify\"), siptag_security_verify_str}, \n        {string(\"privacy\"), siptag_privacy_str}, \n        {string(\"sip_etag\"), siptag_etag_str}, \n        {string(\"sip_if_match\"), siptag_if_match_str}, \n        {string(\"mime_version\"), siptag_mime_version_str}, \n        {string(\"content_type\"), siptag_content_type_str}, \n        {string(\"content_encoding\"), siptag_content_encoding_str}, \n        {string(\"content_language\"), siptag_content_language_str}, \n        {string(\"content_disposition\"), siptag_content_disposition_str}, \n        {string(\"request_disposition\"), siptag_request_disposition_str}, \n        {string(\"error\"), siptag_error_str}, \n        {string(\"refer_sub\"), siptag_refer_sub_str}, \n        {string(\"alert_info\"), siptag_alert_info_str}, \n        {string(\"reply_to\"), siptag_reply_to_str}, \n        {string(\"p_asserted_identity\"), siptag_p_asserted_identity_str}, \n        {string(\"p_preferred_identity\"), siptag_p_preferred_identity_str}, \n        {string(\"remote_party_id\"), siptag_remote_party_id_str}, \n        {string(\"payload\"), siptag_payload_str}, \n        {string(\"from\"), siptag_from_str}, \n        {string(\"to\"), siptag_to_str}, \n        {string(\"call_id\"), siptag_call_id_str}, \n        {string(\"cseq\"), siptag_cseq_str}, \n        {string(\"via\"), siptag_via_str}, \n        {string(\"route\"), siptag_route_str}, \n        {string(\"contact\"), siptag_contact_str}, \n        {string(\"from\"), siptag_from_str}, \n        {string(\"to\"), siptag_to_str}, \n        {string(\"rseq\"), siptag_rseq_str}, \n        {string(\"rack\"), siptag_rack_str}, \n        {string(\"record_route\"), siptag_record_route_str}, \n        {string(\"content_length\"), siptag_content_length_str}\n\t});\n\n\t/* headers that are not allowed to be set by the client in responses to sip requests */\n\tsetHdr m_setImmutableHdrs({\n        {string(\"via\")},\n        {string(\"route\")},\n        {string(\"rseq\")},\n        {string(\"record_route\")}, \n        {string(\"content_length\")} \n\t});\n\n   mapMethod2Type m_mapMethod2Type({\n        {string(\"INVITE\"), sip_method_invite},\n        {string(\"ACK\"), sip_method_ack},\n        {string(\"CANCEL\"), sip_method_cancel},\n        {string(\"BYE\"), sip_method_bye},\n        {string(\"OPTIONS\"), sip_method_options},\n        {string(\"REGISTER\"), sip_method_register},\n        {string(\"INFO\"), sip_method_info},\n        {string(\"PRACK\"), sip_method_prack},\n        {string(\"UPDATE\"), sip_method_update},\n        {string(\"MESSAGE\"), sip_method_message},\n        {string(\"SUBSCRIBE\"), sip_method_subscribe},\n        {string(\"NOTIFY\"), sip_method_notify},\n        {string(\"REFER\"), sip_method_refer},\n        {string(\"PUBLISH\"), sip_method_publish} \n    });\n\n\n\tbool isImmutableHdr( const string& hdr ) {\n\t\treturn m_setImmutableHdrs.end() != m_setImmutableHdrs.find( hdr ) ;\n\t}\n\n\tbool getTagTypeForHdr( const string& hdr, tag_type_t& tag ) {\n\t\tmapHdr2Tag::const_iterator it = m_mapHdr2Tag.find( hdr ) ;\n\t\tif( it != m_mapHdr2Tag.end() ) {\n\t\t    tag = it->second ;\n\t\t    return true ;\n\t\t}\t\t\n\t\treturn false ;\n\t}\n\n\tvoid getSourceAddressForMsg(msg_t *msg, string& host) {\n        char name[SU_ADDRSIZE] = \"\";\n        su_sockaddr_t const *su = msg_addr(msg);\n        su_inet_ntop(su->su_family, SU_ADDR(su), name, sizeof(name));\n        host.assign(name);\n    }\n\n    void makeUniqueSipTransactionIdentifier(sip_t* sip, string& str) {\n        str = sip->sip_call_id->i_id ;\n        str.append(\"|\") ;\n        str.append((sip->sip_request && sip_method_cancel == sip->sip_request->rq_method) ?\n          \"INVITE\" :\n          sip->sip_cseq->cs_method_name) ;\n        str.append(\"|\") ;\n        str.append( boost::lexical_cast<std::string>(sip->sip_cseq->cs_seq) ) ;\n    }\n\n\tvoid generateUuid(string& uuid) {\n#ifdef BOOST_UUID\n\t    boost::uuids::uuid id = boost::uuids::random_generator()();\n        uuid = boost::lexical_cast<string>(id) ;\n#else\n        su_guid_t guid[1];\n        char b[su_guid_strlen + 1] ;\n\n        su_guid_generate(guid);\n\n        /*\n         * Guid looks like \"NNNNNNNN-NNNN-NNNN-NNNN-XXXXXXXXXXXX\"\n         * where NNNNNNNN-NNNN-NNNN-NNNN is timestamp and XX is MAC address\n         * (but we use usually random ID for MAC because we do not have\n         *  guid generator available for all processes within node)\n         */\n        su_guid_sprintf(b, su_guid_strlen + 1, guid);\n        uuid.assign( b ) ;\n#endif\n\n    }\t\n\n    void getTransportDescription( const tport_t* tp, string& desc ) {\n        if( tp ) {\n            const tp_name_t* tn = tport_name(tp) ;\n            char name[255] ;\n            sprintf(name, TPN_FORMAT, TPN_ARGS(tn) ) ;\n            desc.assign( name ) ;            \n        }\n    }\n    bool parseTransportDescription( const string& desc, string& proto, string& host, string& port ) {\n        try {\n            std::regex re(\"^(.*)/(.*):(\\\\d+)\");\n            std::smatch mr;\n            if (std::regex_search(desc, mr, re) && mr.size() > 1) {\n                proto = mr[1] ;\n                host = mr[2] ;\n                port = mr[3] ;\n                return true ;  \n            }\n        } catch (std::regex_error& e) {\n            DR_LOG(log_error) << \"parseTransportDescription - regex error: \" << e.what();\n        }\n        return false;\n    }\n    bool parseSipUri(const string& uri, string& scheme, string& userpart, string& hostpart, string& port, \n    vector< pair<string,string> >& params) {\n\n        try {\n            std::regex re(\"^<?(sip|sips):(?:([^;]+)@)?([^;|^>|^:]+)(?::(\\\\d+))?(?:;([^>]+))?>?$\");\n            std::regex re2(\"^<?(sip|sips):(?:([^;]+)@)?(\\\\[[0-9a-fA-F:]+\\\\])(?::(\\\\d+))?(?:;([^>]+))?>?$\");\n            std::smatch mr;\n            if (std::regex_search(uri, mr, re) || std::regex_search(uri, mr, re2)) {\n                scheme = mr[1] ;\n                userpart = mr[2] ;\n                hostpart = mr[3] ;\n                port = mr[4] ; \n\n                string paramString = mr[5] ;\n                if (paramString.length() > 0) {\n                  vector<string> strs;\n                  boost::split(strs, paramString, boost::is_any_of(\";\"));\n                  for (vector<string>::iterator it = strs.begin(); it != strs.end(); ++it) {\n                    vector<string> kv ;\n                    boost::split(kv, *it, boost::is_any_of(\"=\"));\n                    std::pair<string, string> kvpair(kv[0], kv.size() == 2 ? kv[1] : \"\");\n                    params.push_back(kvpair);\n                  }\n                }\n                return true ;\n            }\n        } catch (std::regex_error& e) {\n            DR_LOG(log_error) << \"parseSipUri - regex error: \" << e.what();\n        }\n        return false;\n    }\n\n\tvoid parseGenericHeader( msg_common_t* p, string& hvalue) {\n\t\tstring str((const char*) p->h_data, p->h_len) ;\n\t\tboost::char_separator<char> sep(\": \\r\\n\") ;\n        tokenizer tok( str, sep) ;\n        if( std::distance( tok.begin(), tok.end() ) > 1 ) hvalue = *(++tok.begin() ) ;\n \t}\n\n    bool FindCSeqMethod( const string& headers, string& method ) {\n        try {\n            std::regex re(\"^CSeq:\\\\s+\\\\d+\\\\s+(\\\\w+)$\");\n            std::smatch mr;\n            if (std::regex_search(headers, mr, re) && mr.size() > 1) {\n                method = mr[1] ;\n                return true ;                \n            }\n        } catch (std::regex_error& e) {\n            DR_LOG(log_error) << \"FindCSeqMethod - regex error: \" << e.what();\n        }\n        return false;\n    }\n\n    void EncodeStackMessage( const sip_t* sip, string& encodedMessage ) {\n        encodedMessage.clear() ;\n        const sip_common_t* p = NULL ;\n        if( sip->sip_request ) {\n            sip_header_t* hdr = (sip_header_t *) sip->sip_request ;\n            p = hdr->sh_common ;\n        }\n        else if( sip->sip_status ) {\n            sip_header_t* hdr = (sip_header_t *) sip->sip_status ;\n            p = hdr->sh_common ;\n        }\n\n        while( NULL != p) {\n            if( NULL != p->h_data ) {\n                //take the original fragment if it exists since this will be more efficient\n               encodedMessage.append( (char *)p->h_data, p->h_len ) ;            \n            }\n            else {\n                //otherwise, encode the sip header \n                char buf[8192] ;\n                issize_t n = msg_header_e(buf, 8192, reinterpret_cast<const msg_header_t *>(p), 0) ;\n                encodedMessage.append( buf, n ) ;\n            }\n            p = p->h_succ->sh_common ;\n        }\n    }\n\n    bool normalizeSipUri( std::string& uri, int brackets ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[MAX_SIP_URI_LEN];\n        char obuf[MAX_SIP_URI_LEN] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n\n        // buf gets passed into sip_name_addr_d which puts NULs in various locations so the url_t members can point to their bits\n        s = strncpy( buf, uri.c_str(), MAX_SIP_URI_LEN ) ;\n\n        // first we decode the string\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            // no go: if we can't decode it then we have an invalid input\n            return false ;\n        }\n\n        /* we allow applications to just give us a phone number sometimes, and that ends up parsed into the host portion with no scheme */\n        if( NULL == url->url_scheme && NULL == url->url_user && NULL != url->url_host ) {\n            url->url_scheme = \"sip\" ;\n            url->url_user = url->url_host ;\n            url->url_host = \"localhost\" ;   //placeholder\n         }\n\n        // now we re-encode it\n        int nChars = sip_name_addr_e(obuf, 255, 0, display, brackets, url, params, comment) ;\n\n        // cleanup: free the msg_params if any were allocated        \n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return uri.length() < MAX_SIP_URI_LEN ;\n    }\n\n    bool replaceHostInUri( std::string& uri, const char* szHost, const char* szPort ) {\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[MAX_SIP_URI_LEN];\n        char obuf[MAX_SIP_URI_LEN] ;\n        char hp[64] ;\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n\n        // buf gets passed into sip_name_addr_d which puts NULs in various locations so the url_t members can point to their bits\n        s = strncpy( buf, uri.c_str(), 255 ) ;\n\n        // first we decode the string\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            // no go: if we can't decode it then we have an invalid input\n            return false ;\n        }\n\n        // now we repoint host and port\n        url->url_host = szHost ;\n        url->url_port = szPort ;\n\n        // now we re-encode it\n        int nChars = sip_name_addr_e(obuf, MAX_SIP_URI_LEN, 0, display, 1, url, params, comment) ;\n\n        // cleanup: free the msg_params if any were allocated        \n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n\n        if( nChars <= 0 ) {\n            return false ;\n        }\n        uri.assign( obuf ) ;\n        return true ;\n    }\n\n    sip_method_t methodType( const string& method ) {\n        mapMethod2Type::const_iterator it = m_mapMethod2Type.find( method ) ;\n        if( m_mapMethod2Type.end() == it ) return sip_method_unknown ;\n        return it->second ;\n    }\n \n    bool isLocalSipUri( const string& requestUri ) {\n\n        static bool initialized = false ;\n        static vector< pair<string, string> > vecLocalUris ;\n\n        DR_LOG(log_debug) << \"isLocalSipUri: checking to see if this is one of mine: \" << requestUri ;\n\n        if( !initialized ) {\n            initialized = true ;\n\n            nta_agent_t* agent = theOneAndOnlyController->getAgent() ;\n            tport_t *t = nta_agent_tports( agent ) ;\n            for (tport_t* tport = t; tport; tport = tport_next(tport) ) {\n                const tp_name_t* tpn = tport_name( tport );\n                if( 0 == strcmp( tpn->tpn_host, \"*\") ) \n                    continue ;\n\n                string localUri = tpn->tpn_host ;\n                string localPort = NULL != tpn->tpn_port ? tpn->tpn_port : \"5060\" ;\n\n                //DR_LOG(log_debug) << \"isLocalSipUri: adding local address: \" << localUri << \":\" << localPort ;\n\n\n                vecLocalUris.push_back(make_pair(localUri, localPort)) ;\n\n                if( 0 == strcmp(tpn->tpn_host,\"127.0.0.1\") ) {\n                    vecLocalUris.push_back(make_pair(\"localhost\", localPort)) ;\n                }\n            }\n\n            // add public ip addresses and dns names\n            vector< pair<string, string> > vecIps ;\n            SipTransport::getAllExternalContacts(vecIps) ;\n            for(vector< pair<string, string> >::const_iterator it = vecIps.begin(); it != vecIps.end(); ++it) {\n                vecLocalUris.push_back(*it) ;\n            }\n       }\n\n       if( 0 == requestUri.find(\"tel:\")) {\n        DR_LOG(log_debug) << \"isLocalSipUri: tel: scheme, so we are  assuming it is not local (will cause it to be carried forward in proxy request): \" << requestUri ;\n        return false;\n       }\n\n        su_home_t* home = theOneAndOnlyController->getHome() ;\n        char *s ;\n        char buf[255];\n        char const *display = NULL;\n        url_t url[1];\n        msg_param_t const *params = NULL;\n        char const *comment = NULL;\n        int rc ;\n\n        // buf gets passed into sip_name_addr_d which puts NULs in various locations so the url_t members can point to their bits\n        s = strncpy( buf, requestUri.c_str(), 255 ) ;\n\n        // first we decode the string\n        rc = sip_name_addr_d(home, &s, &display, url, &params, &comment) ;\n        if( rc < 0 ) {  \n            // no go: if we can't decode it then we have an invalid input\n            return false ;\n        }\n\n        // cleanup: free the msg_params if any were allocated        \n        if( params ) {\n            su_free(home, (void *) params) ;\n        }\n\n        for(vector< pair<string, string> >::const_iterator it = vecLocalUris.begin(); it != vecLocalUris.end(); ++it) {\n            string host = it->first ;\n            string port = it->second ;\n\n            if (port.empty()) port = \"5060\";\n\n            //DR_LOG(log_debug) << \"isLocalSipUri: comparing known local address: \" << host << \":\" << port ;\n\n            if ((0 == host.compare(url->url_host)) && (\n                (!url->url_port && 0 == port.compare(\"5060\")) ||\n                (url->url_port && 0 == port.compare(url->url_port)))\n            ) {\n                return true ;\n            }\n        }\n        return false ;\n    }\n\n    void* my_json_malloc( size_t bytes ) {\n        std::lock_guard<std::mutex> l( json_lock ) ;\n\n        json_allocs++ ;\n        json_bytes += bytes ;\n        //DR_LOG(log_debug) << \"my_json_malloc: alloc'ing \" << bytes << \" bytes; outstanding allocations: \" << json_allocs << \", outstanding memory size: \" << json_bytes << endl ;\n\n        /* store size at the beginnng of the block */\n        void *ptr = malloc( bytes + 8 ) ;\n        *((size_t *)ptr) = bytes ;\n \n        return (void*) ((char*) ptr + 8);\n    }\n\n    void my_json_free( void* ptr ) {\n       std::lock_guard<std::mutex> l( json_lock ) ;\n\n        size_t size;\n        ptr = (void *) ((char *) ptr - 8) ;\n        size = *((size_t *)ptr);\n\n        json_allocs-- ;\n        json_bytes -= size ;\n        //DR_LOG(log_debug) << \"my_json_free: freeing \" << size << \" bytes; outstanding allocations: \" << json_allocs << \", outstanding memory size: \" << json_bytes << endl ;\n\n        /* zero memory in debug mode */\n        memset( ptr, 0, size + 8 ) ;\n\n    }\n\n    void splitLines( const string& s, vector<string>& vec ) {\n        if( s.length() ) {\n            split( vec, s, boost::is_any_of(\"\\r\\n\"), boost::token_compress_on ); \n        }\n    }\n\n    void splitTokens( const string& s, vector<string>& vec ) {\n        split( vec, s, boost::is_any_of(\"|\") /*, boost::token_compress_on */); \n    }\n\n    void splitMsg( const string& msg, string& meta, string& startLine, string& headers, string& body ) {\n        size_t pos = msg.find( DR_CRLF ) ;\n        if( string::npos == pos ) {\n            meta = msg ;\n            return ;\n        }\n        meta = msg.substr(0, pos) ;\n        string chunk = msg.substr(pos+DR_CRLF.length()) ;\n\n        pos = chunk.find( DR_CRLF2 ) ;\n        if( string::npos != pos  ) {\n            body = chunk.substr( pos + DR_CRLF2.length() ) ;\n            chunk = chunk.substr( 0, pos ) ;\n        }\n\n        pos = chunk.find( DR_CRLF ) ;\n        if( string::npos == pos ) {\n            startLine = chunk ;\n        }\n        else {\n            startLine = chunk.substr(0, pos) ;\n            headers = chunk.substr(pos + DR_CRLF.length()) ;\n        }\n    }\n\n    sip_method_t parseStartLine( const string& startLine, string& methodName, string& requestUri ) {\n        boost::char_separator<char> sep(\" \");\n        boost::tokenizer< boost::char_separator<char> > tokens(startLine, sep);\n        int i = 0 ;\n        sip_method_t method = sip_method_invalid ;\n        BOOST_FOREACH (const string& t, tokens) {\n            switch( i++ ) {\n                case 0:\n                    methodName = t ;\n                    if( 0 == t.compare(\"INVITE\") ) method = sip_method_invite ;\n                    else if( 0 == t.compare(\"ACK\") ) method = sip_method_ack ;\n                    else if( 0 == t.compare(\"PRACK\") ) method = sip_method_prack ;\n                    else if( 0 == t.compare(\"CANCEL\") ) method = sip_method_cancel ;\n                    else if( 0 == t.compare(\"BYE\") ) method = sip_method_bye ;\n                    else if( 0 == t.compare(\"OPTIONS\") ) method = sip_method_options ;\n                    else if( 0 == t.compare(\"REGISTER\") ) method = sip_method_register ;\n                    else if( 0 == t.compare(\"INFO\") ) method = sip_method_info ;\n                    else if( 0 == t.compare(\"UPDATE\") ) method = sip_method_update ;\n                    else if( 0 == t.compare(\"MESSAGE\") ) method = sip_method_message ;\n                    else if( 0 == t.compare(\"SUBSCRIBE\") ) method = sip_method_subscribe ;\n                    else if( 0 == t.compare(\"NOTIFY\") ) method = sip_method_notify ;\n                    else if( 0 == t.compare(\"REFER\") ) method = sip_method_refer ;\n                    else if( 0 == t.compare(\"PUBLISH\") ) method = sip_method_publish ;\n                    else method = sip_method_unknown ;\n                    break ;\n\n                case 1:\n                    requestUri = t ;\n                    break ;\n\n                default:\n                break ;\n            }\n        }\n        return method ;\n    }\n\n    bool GetValueForHeader( const string& headers, const char *szHeaderName, string& headerValue ) {\n        vector<string> vec ;\n        splitLines( headers, vec ) ;\n        for( std::vector<string>::const_iterator it = vec.begin(); it != vec.end(); ++it )  {\n            string hdrName ;\n            size_t pos = (*it).find_first_of(\":\") ;\n            if( string::npos != pos ) {\n                hdrName = (*it).substr(0,pos) ;\n                boost::trim( hdrName );\n\n                if( boost::iequals( hdrName, szHeaderName ) ) {\n                    headerValue = (*it).substr(pos+1) ;\n                    boost::trim( headerValue ) ;    \n                    return true ;                \n                }\n            }\n        }\n        return false ;\n    }\n    void deleteTags( tagi_t* tags ) {\n        if (!tags) return;\n        int i = 0 ;\n        while( tags[i].t_tag != tag_null ) {\n            if( tags[i].t_value ) {\n                char *p = (char *) tags[i].t_value ;\n                delete [] p ;\n            }\n             i++ ;\n        }       \n        delete [] tags ; \n    }\n\n    tagi_t* makeSafeTags( const string&  hdrs) {\n        vector<string> vec ;\n        \n        splitLines( hdrs, vec ) ;\n        int nHdrs = vec.size() ;\n        tagi_t *tags = new tagi_t[nHdrs+1] ;\n        int i = 0; \n        for( std::vector<string>::const_iterator it = vec.begin(); it != vec.end(); ++it )  {\n            tags[i].t_tag = tag_skip ;\n            tags[i].t_value = (tag_value_t) 0 ;                     \n            bool bValid = true ;\n            string hdrName, hdrValue ;\n\n            //parse header name and value\n            size_t pos = (*it).find_first_of(\":\") ;\n            if( string::npos == pos ) {\n                bValid = false ;\n            }\n            else {\n                hdrName = (*it).substr(0,pos) ;\n                boost::trim( hdrName );\n                if( string::npos != hdrName.find_first_not_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_\") ) {\n                    bValid = false ;\n                }\n                else {\n                    hdrValue = (*it).substr(pos+1) ;\n                    boost::trim( hdrValue ) ;\n                }\n            }\n            if( !bValid ) {\n                DR_LOG(log_error) << \"makeTags - invalid header: '\" << *it << \"'\"  ;\n                i++ ;\n                continue ;\n            }\n            else if( string::npos != hdrValue.find(DR_CRLF) ) {\n                DR_LOG(log_error) << \"SipDialogController::makeTags - client supplied invalid custom header value (contains CR or LF) for header '\" << hdrName << \"'\" ;\n                i++ ;\n                continue ;\n            }\n\n            //treat well-known headers differently than custom headers \n            tag_type_t tt ;\n            string hdr = boost::to_lower_copy( boost::replace_all_copy( hdrName, \"-\", \"_\" ) );\n            if( isImmutableHdr( hdr ) ) {\n                if( 0 != hdr.compare(\"content_length\") ) {\n                    DR_LOG(log_debug) << \"makeTags - discarding header because client is not allowed to set dialog-level headers: '\" << hdrName  ;\n                }\n            }\n            else if( getTagTypeForHdr( hdr, tt ) ) {\n                //well-known header\n                \n                //replace 'localhost' in certain headers with actual sip address:port\n                if( 0 == hdr.compare(\"from\") || \n                    0 == hdr.compare(\"contact\") ||\n                    0 == hdr.compare(\"to\") ||\n                    0 == hdr.compare(\"p_asserted_identity\") ) {\n\n                    DR_LOG(log_debug) << \"makeSafeTags - hdr '\" << hdrName << \"' can not be modified\";\n                }\n                else {\n                    int len = hdrValue.length() ;\n                    char *p = new char[len+1] ;\n                    memset(p, '\\0', len+1) ;\n                    strncpy( p, hdrValue.c_str(), len ) ;\n                    tags[i].t_tag = tt;\n                    tags[i].t_value = (tag_value_t) p ;\n                    DR_LOG(log_debug) << \"makeTags - Adding well-known header '\" << hdrName << \"' with value '\" << p << \"'\"  ;\n                }\n            }\n            else {\n                //custom header\n                int len = (*it).length() ;                  \n                char *p = new char[len+1] ;\n                memset(p, '\\0', len+1) ;\n                strncpy( p, (*it).c_str(), len) ;\n\n                tags[i].t_tag = siptag_unknown_str ;\n                tags[i].t_value = (tag_value_t) p ;\n                DR_LOG(log_debug) << \"makeTags - custom header: '\" << hdrName << \"', value: \" << hdrValue  ;  \n            }\n            i++ ;\n        }\n        tags[nHdrs].t_tag = tag_null ;\n        tags[nHdrs].t_value = (tag_value_t) 0 ;       \n\n        return tags ;   //NB: caller responsible to delete after use to free memory      \n    }\n\n    tagi_t* makeTags( const string&  hdrs, const string& transport, const char* szExternalIP ) {\n        vector<string> vec ;\n        string proto, host, port, myHostport ;\n        \n        parseTransportDescription(transport, proto, host, port ) ;\n\n        if (szExternalIP) {\n            host = szExternalIP;\n            DR_LOG(log_debug) << \"makeTags - using external IP as replacement for 'localhost': \" << szExternalIP  ;\n        }\n\n        splitLines( hdrs, vec ) ;\n        int nHdrs = vec.size() ;\n        tagi_t *tags = new tagi_t[nHdrs+1] ;\n        int i = 0; \n        for( std::vector<string>::const_iterator it = vec.begin(); it != vec.end(); ++it )  {\n            tags[i].t_tag = tag_skip ;\n            tags[i].t_value = (tag_value_t) 0 ;                     \n            bool bValid = true ;\n            string hdrName, hdrValue ;\n\n            //parse header name and value\n            size_t pos = (*it).find_first_of(\":\") ;\n            if( string::npos == pos ) {\n                bValid = false ;\n            }\n            else {\n                hdrName = (*it).substr(0,pos) ;\n                boost::trim( hdrName );\n                if( string::npos != hdrName.find_first_not_of(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890-_\") ) {\n                    bValid = false ;\n                }\n                else {\n                    hdrValue = (*it).substr(pos+1) ;\n                    boost::trim( hdrValue ) ;\n                }\n            }\n            if( !bValid ) {\n                DR_LOG(log_error) << \"makeTags - invalid header: '\" << *it << \"'\"  ;\n                i++ ;\n                continue ;\n            }\n            else if( string::npos != hdrValue.find(DR_CRLF) ) {\n                DR_LOG(log_error) << \"SipDialogController::makeTags - client supplied invalid custom header value (contains CR or LF) for header '\" << hdrName << \"'\" ;\n                i++ ;\n                continue ;\n            }\n\n            //treat well-known headers differently than custom headers \n            tag_type_t tt ;\n            string hdr = boost::to_lower_copy( boost::replace_all_copy( hdrName, \"-\", \"_\" ) );\n            if( isImmutableHdr( hdr ) ) {\n                if( 0 != hdr.compare(\"content_length\") ) {\n                    DR_LOG(log_debug) << \"makeTags - discarding header because client is not allowed to set dialog-level headers: '\" << hdrName  ;\n                }\n            }\n            else if( getTagTypeForHdr( hdr, tt ) ) {\n                //well-known header\n                \n                //replace 'localhost' in certain headers with actual sip address:port\n                if( string::npos != hdrValue.find(\"@localhost\") && (0 == hdr.compare(\"from\") || \n                    0 == hdr.compare(\"contact\") ||\n                    0 == hdr.compare(\"to\") ||\n                    0 == hdr.compare(\"p_asserted_identity\") ) ) {\n\n                    DR_LOG(log_debug) << \"makeTags - hdr '\" << hdrName << \"' replacing host with \" << host;\n                    replaceHostInUri( hdrValue, host.c_str(), port.c_str() ) ;\n                }\n                int len = hdrValue.length() ;\n                char *p = new char[len+1] ;\n                memset(p, '\\0', len+1) ;\n                strncpy( p, hdrValue.c_str(), len ) ;\n                tags[i].t_tag = tt;\n                tags[i].t_value = (tag_value_t) p ;\n                DR_LOG(log_debug) << \"makeTags - Adding well-known header '\" << hdrName << \"' with value '\" << p << \"'\"  ;\n            }\n            else {\n                //custom header\n                int len = (*it).length() ;                  \n                char *p = new char[len+1] ;\n                memset(p, '\\0', len+1) ;\n                strncpy( p, (*it).c_str(), len) ;\n\n                tags[i].t_tag = siptag_unknown_str ;\n                tags[i].t_value = (tag_value_t) p ;\n                DR_LOG(log_debug) << \"makeTags - custom header: '\" << hdrName << \"', value: \" << hdrValue  ;  \n            }\n\n            i++ ;\n        }\n        tags[nHdrs].t_tag = tag_null ;\n        tags[nHdrs].t_value = (tag_value_t) 0 ;       \n\n        return tags ;   //NB: caller responsible to delete after use to free memory      \n    }\n \tbool isRfc1918(const char* szHost) {\n        string str = szHost;\n        boost::char_separator<char> sep(\".\") ;\n        tokenizer tok(str, sep) ;\n        vector<int> vec;\n        for (tokenizer::iterator it = tok.begin(); it != tok.end(); it++) {\n            try {\n                vec.push_back(boost::lexical_cast<int>(*it));\n            }\n            catch (boost::bad_lexical_cast &e) {\n                // host name was not dot decimal\n                DR_LOG(log_debug) << \"isRfc1918: hostname '\" << szHost << \"' is not dot decimal: \" << e.what();\n                return false;\n            }\n        }\n        if (vec.size() == 4) {\n\n            // class A\n            if (vec[0] == 10) return true;\n\n            // class B\n            if (vec[0] == 172 && (vec[1] > 15 || vec[1] < 32)) return true;\n\n            // class C\n            if (vec[0] == 192 && vec[1] == 168) return true;\n        }\n        return false;\n     }\n\n\tbool sipMsgHasNatEqualsYes( const sip_t* sip, bool weAreUac, bool checkContact ) {\n        if (!sip->sip_record_route && !checkContact) return false;\n\n        if (sip->sip_record_route) {\n            sip_record_route_t *r = sip->sip_record_route;\n\n            if (weAreUac) {\n                for (; r; r = r->r_next) {\n                    if (r->r_next == NULL) break ;\n                }\n            }\n            if (r && r->r_url->url_params && NULL != ::strstr(r->r_url->url_params, \"nat=yes\")) {\n                return true;\n            }\n        }\n\n        if (checkContact && !sip->sip_record_route) {\n            if (sip->sip_contact &&\n                sip->sip_contact->m_url->url_params &&\n                NULL != ::strstr(sip->sip_contact->m_url->url_params, \"nat=yes\")) {\n                \n                return true;\n            }\n        }\n        return false;\n    }\n\n    string urlencode(const string &s) {\n        static const char lookup[]= \"0123456789abcdef\";\n        std::stringstream e;\n        for(int i=0, ix=s.length(); i<ix; i++)\n        {\n            const char& c = s[i];\n            if ( (48 <= c && c <= 57) ||//0-9\n                 (65 <= c && c <= 90) ||//abc...xyz\n                 (97 <= c && c <= 122) || //ABC...XYZ\n                 (c=='-' || c=='_' || c=='.' || c=='~') \n            )\n            {\n                e << c;\n            }\n            else\n            {\n                e << '%';\n                e << lookup[ (c&0xF0)>>4 ];\n                e << lookup[ (c&0x0F) ];\n            }\n        }\n        return e.str();\n    }\n\n    SipMsgData_t::SipMsgData_t(const string& str ) {\n        boost::char_separator<char> sep(\" []//:\") ;\n        tokenizer tok( str, sep) ;\n        tokenizer::iterator it = tok.begin() ;\n\n        m_source = 0 == (*it).compare(\"recv\") ? \"network\" : \"application\" ;\n        it++ ;\n        m_bytes = *(it) ;\n        it++; it++; it++ ;\n        m_protocol = *(it) ;\n        m_address = *(++it) ;\n        m_port = *(++it) ;\n        it++ ;  \n        string t = *(++it) + \":\" + *(++it) + \":\" + *(++it) + \".\" + *(++it) ;\n        m_time = t.substr(0, t.size()-2);\n    }\n\n    SipMsgData_t::SipMsgData_t( msg_t* msg ) : m_source(\"network\") {\n        su_time_t now = su_now() ;\n        unsigned short second, minute, hour;\n        char time[64] ;\n        tport_t *tport = nta_incoming_transport(theOneAndOnlyController->getAgent(), NULL, msg) ;        \n        assert(NULL != tport) ;\n\n        second = (unsigned short)(now.tv_sec % 60);\n        minute = (unsigned short)((now.tv_sec / 60) % 60);\n        hour = (unsigned short)((now.tv_sec / 3600) % 24);\n        sprintf(time, \"%02u:%02u:%02u.%06lu\", hour, minute, second, now.tv_usec) ;\n \n        m_time.assign( time ) ;\n        if( tport_is_udp(tport ) ) m_protocol = \"udp\" ;\n        else if( tport_has_tls( tport ) ) m_protocol = \"tls\" ;\n        else if( tport_is_tcp( tport)  ) m_protocol = \"tcp\" ;\n\n        tport_unref( tport ) ;\n\n        init( msg ) ;\n    }\n    SipMsgData_t::SipMsgData_t( msg_t* msg, nta_incoming_t* irq, const char* source ) : m_source(source) {\n        su_time_t now = su_now() ;\n        unsigned short second, minute, hour;\n        char time[64] ;\n        tport_t *tport = nta_incoming_transport(theOneAndOnlyController->getAgent(), irq, msg) ;  \n\n        second = (unsigned short)(now.tv_sec % 60);\n        minute = (unsigned short)((now.tv_sec / 60) % 60);\n        hour = (unsigned short)((now.tv_sec / 3600) % 24);\n        sprintf(time, \"%02u:%02u:%02u.%06lu\", hour, minute, second, now.tv_usec) ;\n \n        m_time.assign( time ) ;\n        if( tport_is_udp(tport ) ) m_protocol = \"udp\" ;\n        else if( tport_is_tcp( tport)  ) m_protocol = \"tcp\" ;\n        else if( tport_has_tls( tport ) ) m_protocol = \"tls\" ;\n\n        tport_unref( tport ) ;\n\n        init( msg ) ;\n    }\n    SipMsgData_t::SipMsgData_t( msg_t* msg, nta_outgoing_t* orq, const char* source ) : m_source(source) {\n        su_time_t now = su_now() ;\n        unsigned short second, minute, hour;\n        char time[64] ;\n        tport_t *tport = nta_outgoing_transport( orq ) ;    //adds a a reference\n        //assert( tport ) ; //why would this ever be null?\n\n        second = (unsigned short)(now.tv_sec % 60);\n        minute = (unsigned short)((now.tv_sec / 60) % 60);\n        hour = (unsigned short)((now.tv_sec / 3600) % 24);\n        sprintf(time, \"%02u:%02u:%02u.%06lu\", hour, minute, second, now.tv_usec) ;\n \n        m_time.assign( time ) ;\n\n        if( tport_is_udp(tport ) ) m_protocol = \"udp\" ;\n        else if( tport_is_tcp( tport)  ) m_protocol = \"tcp\" ;\n        else if( tport_has_tls( tport ) ) m_protocol = \"tls\" ;\n        else m_protocol = \"unknown\";\n\n        init( msg ) ;\n\n        if( 0 == strcmp(source, \"application\") ) {\n            if( NULL != tport ) {\n                const tp_name_t* name = tport_name(tport) ;\n                m_address = name->tpn_host ;\n                m_port = name->tpn_port ;                \n            }\n            //\n            /*\n            else {\n                m_address = theOneAndOnlyController->getMyDefaultSipAddress() ;\n                m_port = theOneAndOnlyController->getMyDefaultSipPort() ;\n            }\n            */\n        }\n\n\n        tport_unref( tport ) ;\n\n    }\n    void SipMsgData_t::init( msg_t* msg ) {\n        su_sockaddr_t const *su = msg_addr(msg);\n        short port ;\n        char name[SU_ADDRSIZE] = \"\";\n        char szTmp[10] ;\n\n        su_inet_ntop(su->su_family, SU_ADDR(su), name, sizeof(name));\n\n        m_address.assign( name ) ;\n        sprintf( szTmp, \"%u\", ntohs(su->su_port) ) ;\n        m_port.assign( szTmp );\n        sprintf( szTmp, \"%u\", msg_size( msg ) ) ;\n        m_bytes.assign( szTmp ) ;\n    }\n\n     int ackResponse( msg_t* msg ) {\n        nta_agent_t* nta = theOneAndOnlyController->getAgent() ;\n        sip_t *sip = sip_object(msg);\n        msg_t *amsg = nta_msg_create(nta, 0);\n        sip_t *asip = sip_object(amsg);\n        url_string_t const *ruri;\n        nta_outgoing_t *ack = NULL, *bye = NULL;\n        sip_cseq_t *cseq;\n        sip_request_t *rq;\n        sip_route_t *route = NULL, *r, r0[1];\n        su_home_t *home = msg_home(amsg);\n        tport_t* tp_incoming = nta_incoming_transport(nta, NULL, msg);\n\n        if (asip == NULL)\n        return -1;\n\n        sip_add_tl(amsg, asip,\n            SIPTAG_TO(sip->sip_to),\n            SIPTAG_FROM(sip->sip_from),\n            SIPTAG_CALL_ID(sip->sip_call_id),\n            TAG_END());\n\n        if (sip->sip_contact && sip->sip_status->st_status > 399 ) {\n            ruri = (url_string_t const *)sip->sip_contact->m_url;\n        } else {\n            su_sockaddr_t const *su = msg_addr(msg);\n            char name[SU_ADDRSIZE] = \"\";\n            char uri[SU_ADDRSIZE+20] = \"\" ;\n            char szTmp[10] ;\n\n            su_inet_ntop(su->su_family, SU_ADDR(su), name, sizeof(name));\n            sprintf( szTmp, \"%u\", ntohs(su->su_port) ) ;\n            sprintf(uri, \"sip:%s:%s\", name, szTmp) ;\n            ruri = URL_STRING_MAKE(uri) ;\n        }\n\n        if (!(cseq = sip_cseq_create(home, sip->sip_cseq->cs_seq, SIP_METHOD_ACK)))\n            goto err;\n        else\n            msg_header_insert(amsg, (msg_pub_t *)asip, (msg_header_t *)cseq);\n\n        if (!(rq = sip_request_create(home, SIP_METHOD_ACK, ruri, NULL)))\n            goto err;\n        else\n            msg_header_insert(amsg, (msg_pub_t *)asip, (msg_header_t *)rq);\n\n        DR_LOG(log_debug) << \"ackResponse - sending ack via tport \" << std::hex << (void *) tp_incoming ;\n\n        if( nta_msg_tsend( nta, amsg, NULL, \n            NTATAG_BRANCH_KEY(sip->sip_via->v_branch),\n            NTATAG_TPORT(tp_incoming),\n            TAG_END() ) < 0 )\n \n            goto err ;\n\n         return 0;\n\n        err:\n            if( amsg ) msg_destroy(amsg);\n            return -1;\n    }\n\n    int utf8_strlen(const string& str)\n    {\n        int c,i,ix,q;\n        for (q=0, i=0, ix=str.length(); i < ix; i++, q++)\n        {\n            c = (unsigned char) str[i];\n            if      (c>=0   && c<=127) i+=0;\n            else if ((c & 0xE0) == 0xC0) i+=1;\n            else if ((c & 0xF0) == 0xE0) i+=2;\n            else if ((c & 0xF8) == 0xF0) i+=3;\n            //else if (($c & 0xFC) == 0xF8) i+=4; // 111110bb //byte 5, unnecessary in 4 byte UTF-8\n            //else if (($c & 0xFE) == 0xFC) i+=5; // 1111110b //byte 6, unnecessary in 4 byte UTF-8\n            else {\n                DR_LOG(log_error) << \"utf8_strlen - code 0x\" << std::hex << c << \" at position \" << std::dec << q << \" is not a valid UTF-8 character\";\n                DR_LOG(log_error) << \"utf8_strlen - in string: \" << str ;\n                return 0;//invalid utf8\n            }\n        }\n        return q;\n    }\n }\n\n", "/*\nCopyright (c) 2013, David C Horton\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n#include <algorithm>\n#include <regex>\n\n#include <boost/algorithm/string.hpp>\n#include <boost/algorithm/string/find.hpp>\n#include <boost/algorithm/string/replace.hpp>\n\n#include <sofia-sip/su_alloc.h>\n\nnamespace drachtio {\n    class SipDialogController ;\n}\n\n#define NTA_RELIABLE_MAGIC_T drachtio::SipDialogController\n\n#include \"controller.hpp\"\n#include \"cdr.hpp\"\n#include \"sip-dialog-controller.hpp\"\n#include \"sip-transports.hpp\"\n\nnamespace {\n\n    std::string combineCallIdAndCSeq(nta_outgoing_t* orq) {\n        string callIdAndCSeq = nta_outgoing_call_id(orq);\n        callIdAndCSeq.append(\" \");\n        callIdAndCSeq.append(boost::lexical_cast<std::string>(nta_outgoing_cseq(orq)));\n        return callIdAndCSeq;\n    }\n\n    void cloneRespondToSipRequest(su_root_magic_t* p, su_msg_r msg, void* arg ) {\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        drachtio::SipDialogController::SipMessageData* d = reinterpret_cast<drachtio::SipDialogController::SipMessageData*>( arg ) ;\n        pController->getDialogController()->doRespondToSipRequest( d ) ;\n    }\n    void cloneSendSipRequest(su_root_magic_t* p, su_msg_r msg, void* arg ) {\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        drachtio::SipDialogController::SipMessageData* d = reinterpret_cast<drachtio::SipDialogController::SipMessageData*>( arg ) ;\n        pController->getDialogController()->doSendRequestOutsideDialog( d ) ;\n    }\n    void cloneSendSipCancelRequest(su_root_magic_t* p, su_msg_r msg, void* arg ) {\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        drachtio::SipDialogController::SipMessageData* d = reinterpret_cast<drachtio::SipDialogController::SipMessageData*>( arg ) ;\n        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_IN, {{\"method\", \"CANCEL\"}})\n        pController->getDialogController()->doSendCancelRequest( d ) ;\n    }\n    int uacLegCallback( nta_leg_magic_t* p, nta_leg_t* leg, nta_incoming_t* irq, sip_t const *sip) {\n        if( sip && sip->sip_request ) STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_IN, {{\"method\", sip->sip_request->rq_method_name}})\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        return pController->getDialogController()->processRequestInsideDialog( leg, irq, sip) ;\n    }\n    int uasCancelOrAck( nta_incoming_magic_t* p, nta_incoming_t* irq, sip_t const *sip ) {\n        if( sip && sip->sip_request ) STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_IN, {{\"method\", sip->sip_request->rq_method_name}})\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        return pController->getDialogController()->processCancelOrAck( p, irq, sip) ;\n    }\n    int uasPrack( drachtio::SipDialogController *pController, nta_reliable_t *rel, nta_incoming_t *prack, sip_t const *sip) {\n        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_IN, {{\"method\", \"PRACK\"}})\n        return pController->processPrack( rel, prack, sip) ;\n    }\n   int response_to_request_outside_dialog( nta_outgoing_magic_t* p, nta_outgoing_t* request, sip_t const* sip ) {  \n        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_IN, {\n            {\"method\", sip->sip_cseq->cs_method_name},\n            {\"code\", boost::lexical_cast<std::string>(sip->sip_status->st_status)}\n        }) \n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        return pController->getDialogController()->processResponseOutsideDialog( request, sip ) ;\n    } \n   int response_to_request_inside_dialog( nta_outgoing_magic_t* p, nta_outgoing_t* request, sip_t const* sip ) {   \n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_IN, {\n            {\"method\", sip->sip_cseq->cs_method_name},\n            {\"code\", boost::lexical_cast<std::string>(sip->sip_status->st_status)}\n        }) \n        return pController->getDialogController()->processResponseInsideDialog( request, sip ) ;\n    } \n    void cloneSendSipRequestInsideDialog(su_root_magic_t* p, su_msg_r msg, void* arg ) {\n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        drachtio::SipDialogController::SipMessageData* d = reinterpret_cast<drachtio::SipDialogController::SipMessageData*>( arg ) ;\n        pController->getDialogController()->doSendRequestInsideDialog( d ) ;\n    }\n    int response_to_refreshing_reinvite( nta_outgoing_magic_t* p, nta_outgoing_t* request, sip_t const* sip ) {   \n        drachtio::DrachtioController* pController = reinterpret_cast<drachtio::DrachtioController*>( p ) ;\n        return pController->getDialogController()->processResponseToRefreshingReinvite( request, sip ) ;\n    }\n}\n\n\nnamespace drachtio {\n\n\tSipDialogController::SipDialogController( DrachtioController* pController, su_clone_r* pClone ) : m_pController(pController), m_pClone(pClone), \n        m_agent(pController->getAgent()), m_pClientController(pController->getClientController())  {\n\n            assert(m_agent) ;\n            assert(m_pClientController) ;\n            m_pTQM = std::make_shared<SipTimerQueueManager>( pController->getRoot() ) ;\n            m_timerDHandler.setTimerQueueManager(m_pTQM);\n\t}\n\tSipDialogController::~SipDialogController() {\n\t}\n    bool SipDialogController::sendRequestInsideDialog( const string& clientMsgId, const string& dialogId, const string& startLine, const string& headers, const string& body, string& transactionId ) {\n\n        assert( dialogId.length() > 0 ) ;\n\n        if( 0 == transactionId.length() ) { generateUuid( transactionId ) ; }\n\n        su_msg_r msg = SU_MSG_R_INIT ;\n        int rv = su_msg_create( msg, su_clone_task(*m_pClone), su_root_task(m_pController->getRoot()),  cloneSendSipRequestInsideDialog, sizeof( SipDialogController::SipMessageData ) );\n        if( rv < 0 ) {\n            m_pController->getClientController()->route_api_response( clientMsgId, \"NOK\", \"Internal server error allocating message\") ;\n            return  false;\n        }\n        void* place = su_msg_data( msg ) ;\n\n        /* we need to use placement new to allocate the object in a specific address, hence we are responsible for deleting it (below) */\n        SipMessageData* msgData = new(place) SipMessageData( clientMsgId, transactionId, \"\", dialogId, startLine, headers, body ) ;\n        rv = su_msg_send(msg);  \n        if( rv < 0 ) {\n            m_pController->getClientController()->route_api_response( clientMsgId, \"NOK\", \"Internal server error sending message\") ;\n            return  false;\n        }\n        \n        return true ;\n    }\n    ///client-initiated outgoing messages (stack thread)\n    void SipDialogController::doSendRequestInsideDialog( SipMessageData* pData ) {                \n        nta_leg_t* leg = NULL ;\n        nta_outgoing_t* orq = NULL ;\n        string myHostport ;\n        string requestUri ;\n        string name ;\n        string routeUri;\n        bool destroyOrq = false;\n        tagi_t* tags = nullptr;\n\n        DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog dialog id: \" << pData->getDialogId()  ;\n\n        sip_method_t method = parseStartLine( pData->getStartLine(), name, requestUri ) ;\n\n        std::shared_ptr<SipDialog> dlg ;\n \n        assert( pData->getDialogId() ) ;\n\n        try {\n            if (!SD_FindByDialogId(m_dialogs, pData->getDialogId(), dlg ) ) {\n                if( sip_method_ack == method ) {\n                    DR_LOG(log_debug) << \"Can't send ACK for dialog id \" << pData->getDialogId() \n                        << \"; likely because stack already ACK'ed non-success final response\" ;\n                    throw std::runtime_error(\"ACK for non-success final response is automatically generated by server\") ;\n                }\n                DR_LOG(log_debug) << \"Can't find dialog for dialog id \" << pData->getDialogId() ;\n                //assert(false) ;\n                throw std::runtime_error(\"unable to find dialog for dialog id provided\") ;\n            }\n\n            string transport ;\n            dlg->getTransportDesc(transport) ;\n            tags = makeTags( pData->getHeaders(), transport) ;\n\n            tport_t* tp = dlg->getTport() ; \n            bool forceTport = NULL != tp ;  \n\n            nta_leg_t *leg = const_cast<nta_leg_t *>(dlg->getNtaLeg());\n            if( !leg ) {\n                assert( leg ) ;\n                throw std::runtime_error(\"unable to find active leg for dialog\") ;\n            }\n\n            const sip_contact_t *target ;\n            if( (sip_method_ack == method || string::npos != requestUri.find(\"placeholder\")) && nta_leg_get_route( leg, NULL, &target ) >=0 ) {\n                char buffer[256];\n\n                if (nullptr ==target) {\n                    throw std::runtime_error(\"unable to find route for dialog when sending ACK\") ;\n                }\n                url_e( buffer, 255, target->m_url ) ;\n                requestUri = buffer ;\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - defaulting request uri to \" << requestUri  ;\n\n                // we need to check if there was a mid-call network handoff, where this client jumped networks\n                std::shared_ptr<UaInvalidData> pData = m_pController->findTportForSubscription( target->m_url->url_user, target->m_url->url_host ) ;\n                if( NULL != pData ) {\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog found cached tport for this client \" << std::hex << (void *) pData->getTport();\n                    if (pData->getTport() != tp) {\n                        DR_LOG(log_info) << \"SipDialogController::doSendRequestInsideDialog client has done a mid-call handoff; tp is now \" << std::hex << (void *) pData->getTport();\n                        tp = pData->getTport();\n                        forceTport = true ;\n                    }\n               }\n            }\n\n            if( method == sip_method_invalid || method == sip_method_unknown ) {\n                throw std::runtime_error(string(\"invalid or missing method supplied on start line: \") + pData->getStartLine() ) ;\n            }\n\n            //set content-type if not supplied and body contains SDP\n            string body = pData->getBody() ;\n            string contentType ;\n            if( body.length() && !searchForHeader( tags, siptag_content_type_str, contentType ) ) {\n                if( 0 == body.find(\"v=0\") ) {\n                    contentType = \"application/sdp\" ;\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - automatically detecting content-type as application/sdp\"  ;\n                }\n                else {\n                    throw std::runtime_error(\"missing content-type\") ;                   \n                }\n            }\n            if( sip_method_invite == method && body.length() && 0 == contentType.compare(\"application/sdp\")) {\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - updating local sdp to \" << body ;\n                dlg->setLocalSdp( body.c_str() ) ;\n                dlg->setLocalContentType(contentType);\n            }\n\n            if (dlg->getRouteUri(routeUri)) {\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - sending request to nat'ed address using route \" << routeUri ;\n            }\n\n            if( sip_method_ack == method ) {\n                if( 200 == dlg->getSipStatus() ) {\n                    char cseq[32];\n                    memset(cseq, 0, 32);\n                    uint32_t seq = dlg->getSeq();\n                    dlg->clearSeq();\n                    if (seq > 0) {\n                        snprintf(cseq, 31, \"%u ACK\", seq);\n                        DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - setting CSeq to  \" << seq ;\n                    }\n                    orq = nta_outgoing_tcreate(leg, NULL, NULL, \n                        routeUri.empty() ? NULL : URL_STRING_MAKE(routeUri.c_str()),                     \n                        method, name.c_str(),\n                        URL_STRING_MAKE(requestUri.c_str()),\n                        TAG_IF( *cseq, SIPTAG_CSEQ_STR(cseq)),\n                        TAG_IF( body.length(), SIPTAG_PAYLOAD_STR(body.c_str())),\n                        TAG_IF( contentType.length(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str())),\n                        TAG_IF(forceTport, NTATAG_TPORT(tp)),\n                        TAG_NEXT(tags) ) ;\n                    \n                    tport_t* orq_tp = nta_outgoing_transport( orq );  // takes a reference on the tport\n                    if (tport_is_dgram(orq_tp)) m_timerDHandler.addAck(orq);\n                    else if (orq_tp) destroyOrq = true;\n                    if (orq_tp) {\n                        dlg->setTport(orq_tp) ;\n                        // tport reference will be release in SipDialog dtor\n                    }\n                    else {\n                        DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - sending ACK but nta_outgoing_transport is null, delayed for DNS resolver\";\n                        dlg->setOrqAck(orq, !tport_is_dgram(orq_tp));\n                        destroyOrq = false;\n                        tport_unref(orq_tp);  // release the reference\n                    }\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - clearing IIP that we generated as uac\" ;\n                    IIP_Clear(m_invitesInProgress, leg);  \n\n                    DR_LOG(log_info) << \"SipDialogController::doSendRequestInsideDialog (ack) - created orq \" << std::hex << (void *) orq;\n\n                }\n            }\n            else if( sip_method_prack == method ) {\n                std::shared_ptr<IIP> iip;\n                if(!IIP_FindByLeg(m_invitesInProgress, leg, iip)) {\n                    throw std::runtime_error(\"unable to find IIP when sending PRACK\") ;\n                }\n                orq = nta_outgoing_prack(leg, const_cast<nta_outgoing_t *>(iip->orq()), response_to_request_inside_dialog, (nta_outgoing_magic_t*) m_pController, \n                    //NULL, \n                    routeUri.empty() ? NULL : URL_STRING_MAKE(routeUri.c_str()),\n                    NULL, TAG_NEXT(tags) ) ;\n                DR_LOG(log_info) << \"SipDialogController::doSendRequestInsideDialog (prack) - created orq \" << std::hex << (void *) orq;\n\n            }\n            else {\n                string contact ;\n                bool addContact = false ;\n                if( (method == sip_method_invite || method == sip_method_subscribe || method == sip_method_refer) && !searchForHeader( tags, siptag_contact_str, contact ) ) {\n                    contact = dlg->getLocalContactHeader();\n                    addContact = true ;\n                }\n                orq = nta_outgoing_tcreate( leg, response_to_request_inside_dialog, (nta_outgoing_magic_t*) m_pController, \n                    routeUri.empty() ? NULL : URL_STRING_MAKE(routeUri.c_str()),                     \n                    method, name.c_str()\n                    ,URL_STRING_MAKE(requestUri.c_str())\n                    ,TAG_IF( addContact, SIPTAG_CONTACT_STR( contact.c_str() ) )\n                    ,TAG_IF( body.length(), SIPTAG_PAYLOAD_STR(body.c_str()))\n                    ,TAG_IF( contentType.length(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))\n                    ,TAG_IF(forceTport, NTATAG_TPORT(tp))\n                    ,TAG_NEXT(tags) ) ;\n\n                if( orq ) {\n                    DR_LOG(log_info) << \"SipDialogController::doSendRequestInsideDialog - created orq \" << std::hex << (void *) orq << \" sending \" << nta_outgoing_method_name(orq) << \" to \" << requestUri ;\n                }\n            }\n\n            if( NULL == orq && sip_method_ack != method ) {\n                throw std::runtime_error(\"Error creating sip transaction for request\") ;               \n            }\n\n            if( sip_method_ack == method && 200 != dlg->getSipStatus() ) {\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestInsideDialog - clearing uac dialog that had final response \" <<  dlg->getSipStatus() ;\n                SD_Clear(m_dialogs, dlg->getDialogId()) ;\n                m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"NOK\", \n                    \"ACK for non-success responses is automatically generated by the stack\" ) ;\n            }\n            else {\n                msg_t* m = nta_outgoing_getrequest(orq) ;  // adds a reference\n                sip_t* sip = sip_object( m ) ;\n\n                STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", sip->sip_request->rq_method_name}})\n\n                string encodedMessage ;\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta(m, orq) ;\n                string s ;\n                meta.toMessageFormat(s) ;\n                string data = s + \"|\" + pData->getTransactionId() + \"|Msg sent:|\" + DR_CRLF + encodedMessage ;\n\n                if( sip_method_ack == method ) {\n                    if( dlg->getSipStatus() > 200 ) {\n                        m_pClientController->removeDialog( dlg->getDialogId() ) ;\n                    }\n                }\n                else {\n                    bool clearDialogOnResponse = false ;\n                    if( sip_method_bye == method || \n                        ( !dlg->isInviteDialog() && sip_method_notify == method && NULL != sip->sip_subscription_state && NULL != sip->sip_subscription_state->ss_substate &&\n                            NULL != strstr(sip->sip_subscription_state->ss_substate, \"terminated\") ) ) {\n                        clearDialogOnResponse = true ;\n                    }\n\n                    std::shared_ptr<RIP> p = std::make_shared<RIP>( pData->getTransactionId(), pData->getDialogId(), dlg, clearDialogOnResponse ) ;\n                    addRIP( orq, p ) ;       \n                }\n                if( sip_method_invite == method ) {\n                    addOutgoingInviteTransaction( leg, orq, sip, dlg ) ;\n                }\n\n                if (sip_method_bye == method) {\n                  Cdr::postCdr( std::make_shared<CdrStop>( m, \"application\", Cdr::normal_release ) );\n                }\n     \n                msg_destroy(m) ; //releases reference\n                m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"OK\", data ) ; \n            }\n\n            if (sip_method_ack == method && dlg->getSipStatus() == 200 && dlg->isAckBye()) {\n                this->notifyTerminateStaleDialog(dlg, true);\n            }\n        } catch( std::runtime_error& err ) {\n            DR_LOG(log_error) << \"SipDialogController::doSendRequestInsideDialog - Error: \" << err.what() ;\n            string msg = string(\"Server error: \") + err.what() ;\n            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"NOK\", msg ) ;\n            m_pController->getClientController()->removeAppTransaction( pData->getTransactionId() ) ;\n        }                       \n\n        /* we must explicitly delete an object allocated with placement new */\n        pData->~SipMessageData() ;\n        if (orq && destroyOrq) nta_outgoing_destroy(orq);\n        deleteTags( tags ) ;\n    }\n\n//send request outside dialog\n    //client thread\n    bool SipDialogController::sendRequestOutsideDialog( const string& clientMsgId, const string& startLine, const string& headers, const string& body, string& transactionId, string& dialogId, string& routeUrl ) {\n        if( 0 == transactionId.length() ) { generateUuid( transactionId ) ; }\n        if( string::npos != startLine.find(\"INVITE\") ) {\n            generateUuid( dialogId ) ;\n        }\n\n        su_msg_r msg = SU_MSG_R_INIT ;\n        int rv = su_msg_create( msg, su_clone_task(*m_pClone), su_root_task(m_pController->getRoot()),  cloneSendSipRequest, sizeof( SipDialogController::SipMessageData ) );\n        if( rv < 0 ) {\n            return  false;\n        }\n        void* place = su_msg_data( msg ) ;\n\n        /* we need to use placement new to allocate the object in a specific address, hence we are responsible for deleting it (below) */\n        SipMessageData* msgData = new(place) SipMessageData( clientMsgId, transactionId, \"\", dialogId, startLine, headers, body, routeUrl ) ;\n        rv = su_msg_send(msg);  \n        if( rv < 0 ) {\n            return  false;\n        }\n        return true ;\n    }\n    //stack thread\n     void SipDialogController::doSendRequestOutsideDialog( SipMessageData* pData ) {\n        nta_leg_t* leg = NULL ;\n        nta_outgoing_t* orq = NULL ;\n        string requestUri ;\n        string name ;\n        string sipOutboundProxy ;\n        tport_t* tp = NULL ;\n        std::shared_ptr<SipTransport> pSelectedTransport ;\n        bool forceTport = false ;\n        string host, port, proto, contact, desc ;\n        tagi_t* tags = nullptr;\n\n        try {\n            bool useOutboundProxy = false ;\n            const char *szRouteUrl = pData->getRouteUrl() ;\n            if (*szRouteUrl != '\\0') {\n                useOutboundProxy = true ;\n                sipOutboundProxy.assign(szRouteUrl);\n            }\n            else {\n                useOutboundProxy = m_pController->getConfig()->getSipOutboundProxy( sipOutboundProxy ) ;\n            }\n            if (useOutboundProxy) {\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog sending request to route url: \" << sipOutboundProxy ;\n            }\n\n            sip_request_t *sip_request = sip_request_make(m_pController->getHome(), pData->getStartLine() ) ;\n            if( NULL == sip_request || \n                url_invalid == sip_request->rq_url[0].url_type || \n                url_unknown == sip_request->rq_url[0].url_type  ||\n                sip_method_invalid == sip_request->rq_method ||\n                sip_method_unknown == sip_request->rq_method  ) {\n\n                throw std::runtime_error(string(\"invalid request-uri: \") + pData->getStartLine() ) ;\n            }\n            sip_method_t method = parseStartLine( pData->getStartLine(), name, requestUri ) ;\n\n            int rc = 0 ;\n            if( (sip_method_invite == sip_request->rq_method || \n                sip_method_options == sip_request->rq_method ||\n                sip_method_notify == sip_request->rq_method ||\n                sip_method_message == sip_request->rq_method) && \n                !tport_is_dgram(tp) /*&& NULL != strstr( sip_request->rq_url->url_host, \".invalid\")*/ ) {\n\n                std::shared_ptr<UaInvalidData> pData = \n                    m_pController->findTportForSubscription( sip_request->rq_url->url_user, sip_request->rq_url->url_host ) ;\n\n                if( NULL != pData ) {\n                    forceTport = true ;\n                    tp = pData->getTport() ;\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog selecting existing secondary transport \" << std::hex << (void *) tp ;\n\n                    getTransportDescription( tp, desc ) ;\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - selected transport \" << std::hex << (void*)tp << \": \" << desc << \" for request-uri \" << requestUri  ;            \n\n                    const tp_name_t* tpn = tport_name( tport_parent( tp ) );\n                    string host = tpn->tpn_host ;\n                    string port = tpn->tpn_port ;\n                    string proto = tpn->tpn_proto ;\n\n                    contact = \"<sip:\" + host + \":\" + port + \";transport=\" + proto + \">\";\n               }\n            }\n            if( NULL == tp ) {\n                pSelectedTransport = SipTransport::findAppropriateTransport( useOutboundProxy ? sipOutboundProxy.c_str() : requestUri.c_str()) ;\n                if (!pSelectedTransport) {\n                    throw std::runtime_error(string(\"requested protocol/transport not available\"));\n                }\n\n                pSelectedTransport->getDescription(desc);\n                pSelectedTransport->getContactUri( contact, true ) ;\n                contact = \"<\" + contact + \">\" ;\n                host = pSelectedTransport->getHost() ;\n                port = pSelectedTransport->getPort() ;\n\n                tp = (tport_t *) pSelectedTransport->getTport() ;\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog selected transport \" << std::hex << (void*)tp << desc ;\n                forceTport = true ;\n            }\n            su_free( m_pController->getHome(), sip_request ) ;\n\n            if (pSelectedTransport && pSelectedTransport->hasExternalIp()) {\n                tags = makeTags( pData->getHeaders(), desc, pSelectedTransport->getExternalIp().c_str()) ;\n            }\n            else {\n                tags = makeTags( pData->getHeaders(), desc, NULL) ;\n            }\n           \n            //if user supplied all or part of the From use it\n            string from, to, callid ;\n            if( searchForHeader( tags, siptag_from_str, from ) ) {\n                if( string::npos != from.find(\"localhost\") ) {\n                    if( !replaceHostInUri( from, host.c_str(), port.c_str() ) ) {\n                        throw std::runtime_error(string(\"invalid from value provided by client: \") + from ) ;\n                    }                    \n                }\n            } \n            else {\n                from = contact ;\n            }\n\n            //default To header to request uri if not provided\n            if( !searchForHeader( tags, siptag_to_str, to ) ) {\n                to = requestUri ;\n            } \n\n            DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - from: \" << from   ;            \n            DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - to: \" << to ;            \n            DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - contact: \" << contact  ;            \n\n            // use call-id if supplied\n            if( searchForHeader( tags, siptag_call_id_str, callid ) ) {\n                DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - using client-specified call-id: \" << callid  ;            \n            }\n\n            //set content-type if not supplied and body contains SDP\n            string body = pData->getBody() ;\n            string contentType ;\n            if( body.length() && !searchForHeader( tags, siptag_content_type_str, contentType ) ) {\n                if( 0 == body.find(\"v=0\") ) {\n                    contentType = \"application/sdp\" ;\n                    DR_LOG(log_debug) << \"SipDialogController::doSendRequestOutsideDialog - automatically detecting content-type as application/sdp\"  ;\n                }\n                else {\n                    throw std::runtime_error(\"missing content-type\") ;                   \n                }\n             }\n\n            //prevent looping messages\n            if (!normalizeSipUri( requestUri, 0 )) {\n                throw std::runtime_error(string(\"invalid request-uri: \") + requestUri ) ;\n            }\n            if( isLocalSipUri( requestUri ) ) {\n                throw std::runtime_error(\"can not send request to myself\") ;\n            }\n\n            if( !(leg = nta_leg_tcreate( m_pController->getAgent(),\n                uacLegCallback, (nta_leg_magic_t *) m_pController,\n                SIPTAG_FROM_STR(from.c_str()),\n                SIPTAG_TO_STR(to.c_str()),\n                TAG_IF( callid.length(), SIPTAG_CALL_ID_STR(callid.c_str())),\n                TAG_IF( method == sip_method_register, NTATAG_NO_DIALOG(1)),\n                TAG_END() ) ) ) {\n\n                throw std::runtime_error(\"Error creating leg\") ;\n            }\n            nta_leg_tag( leg, NULL ) ;\n\n            orq = nta_outgoing_tcreate( leg, \n                response_to_request_outside_dialog, \n                (nta_outgoing_magic_t*) m_pController, \n                useOutboundProxy ? URL_STRING_MAKE( sipOutboundProxy.c_str() ) : NULL, \n                method, \n                name.c_str()\n                ,URL_STRING_MAKE(requestUri.c_str())\n                ,TAG_IF( (method == sip_method_invite || method == sip_method_subscribe) && \n                    !searchForHeader( tags, siptag_contact_str, contact ), SIPTAG_CONTACT_STR( contact.c_str() ) )\n                ,TAG_IF( body.length(), SIPTAG_PAYLOAD_STR(body.c_str()))\n                ,TAG_IF( contentType.length(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))\n                ,TAG_IF( forceTport, NTATAG_TPORT(tp))\n                ,TAG_NEXT(tags) ) ;\n\n            if( NULL == orq ) {\n                throw std::runtime_error(\"Error creating sip transaction for uac request\") ;               \n            }\n\n            msg_t* m = nta_outgoing_getrequest(orq) ; //adds a reference\n            sip_t* sip = sip_object( m ) ;\n\n            DR_LOG(log_info) << \"SipDialogController::doSendRequestOutsideDialog - created orq \" << std::hex << (void *) orq  <<\n                \" call-id \" << sip->sip_call_id->i_id << \" / transaction id: \" << pData->getTransactionId();\n\n            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", sip->sip_request->rq_method_name}})\n\n            if( method == sip_method_invite || method == sip_method_subscribe ) {\n                std::shared_ptr<SipDialog> dlg = std::make_shared<SipDialog>(pData->getTransactionId(), \n                    leg, orq, sip, m, desc) ;\n                string customContact ;\n                bool hasCustomContact = searchForHeader( tags, siptag_contact_str, customContact ) ;\n                dlg->setLocalContactHeader(hasCustomContact ? customContact.c_str() : contact.c_str());\n\n                addOutgoingInviteTransaction( leg, orq, sip, dlg ) ;\n                if (method == sip_method_invite) {\n                  Cdr::postCdr( std::make_shared<CdrAttempt>(m, \"application\"));\n                }\n            }\n            else {\n                std::shared_ptr<RIP> p = std::make_shared<RIP>( pData->getTransactionId(), pData->getDialogId() ) ;\n                addRIP( orq, p ) ;\n                nta_leg_destroy( leg ) ;\n            }\n\n            string encodedMessage ;\n            EncodeStackMessage( sip, encodedMessage ) ;\n            SipMsgData_t meta(m, orq) ;\n            string s ;\n            meta.toMessageFormat(s) ;\n            msg_destroy(m) ;    // releases reference\n\n            string data = s + \"|\" + pData->getTransactionId() + \"|Msg sent:|\" + DR_CRLF + encodedMessage ;\n\n            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"OK\", data ) ;\n \n        } catch( std::runtime_error& err ) {\n            DR_LOG(log_error) << \"SipDialogController::doSendRequestOutsideDialog - \" << err.what() ;\n            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"NOK\", err.what() ) ;  \n            m_pController->getClientController()->removeAppTransaction( pData->getTransactionId() ) ;\n        }                       \n\n        //N.B.: we must explicitly call the destructor of an object allocated with placement new\n        pData->~SipMessageData() ;\n\n        deleteTags(tags);\n    }\n\n    bool SipDialogController::sendCancelRequest( const string& clientMsgId, const string& transactionId, const string& startLine, const string& headers, const string& body ) {\n        su_msg_r msg = SU_MSG_R_INIT ;\n        int rv = su_msg_create( msg, su_clone_task(*m_pClone), su_root_task(m_pController->getRoot()),  cloneSendSipCancelRequest, sizeof( SipDialogController::SipMessageData ) );\n        if( rv < 0 ) {\n            return  false;\n        }\n        void* place = su_msg_data( msg ) ;\n\n        /* we need to use placement new to allocate the object in a specific address, hence we are responsible for deleting it (below) */\n        SipMessageData* msgData = new(place) SipMessageData( clientMsgId, transactionId, \"\", \"\", startLine, headers, body ) ;\n        rv = su_msg_send(msg);  \n        if( rv < 0 ) {\n            return  false;\n        }\n        return true ;\n    }\n    bool SipDialogController::respondToSipRequest( const string& clientMsgId, const string& transactionId, const string& startLine, const string& headers, const string& body ) {\n       su_msg_r msg = SU_MSG_R_INIT ;\n        int rv = su_msg_create( msg, su_clone_task(*m_pClone), su_root_task(m_pController->getRoot()),  cloneRespondToSipRequest, sizeof( SipDialogController::SipMessageData ) );\n        if( rv < 0 ) {\n            return  false ;\n        }\n        void* place = su_msg_data( msg ) ;\n\n        /* we need to use placement new to allocate the object in a specific address, hence we are responsible for deleting it (below) */\n        string rid ;\n        SipMessageData* msgData = new(place) SipMessageData( clientMsgId, transactionId, \"\", \"\", startLine, headers, body ) ;\n        rv = su_msg_send(msg);  \n        if( rv < 0 ) {\n            return  false ;\n        }\n\n        return true ;\n    }\n   \n    void SipDialogController::doSendCancelRequest( SipMessageData* pData ) {\n        string transactionId( pData->getTransactionId() ) ;\n        std::shared_ptr<IIP> iip ;\n        tagi_t* tags = nullptr;\n\n        if (IIP_FindByTransactionId(m_invitesInProgress, transactionId, iip)) {\n            iip->setCanceled();\n            tags = makeSafeTags( pData->getHeaders()) ;\n            nta_outgoing_t *cancel = nta_outgoing_tcancel(const_cast<nta_outgoing_t *>(iip->orq()), NULL, NULL, TAG_NEXT(tags));\n            if( NULL != cancel ) {\n                msg_t* m = nta_outgoing_getrequest(cancel) ;    // adds a reference\n                sip_t* sip = sip_object( m ) ;\n\n                string cancelTransactionId ;\n                generateUuid( cancelTransactionId ) ;\n\n                string encodedMessage ;\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta(m, cancel) ;\n                string s ;\n                meta.toMessageFormat(s) ;\n                string data = s + \"|\" + cancelTransactionId + \"|Msg sent:|\" + DR_CRLF + encodedMessage ;\n                msg_destroy(m) ;    // releases reference\n\n                //Note: not adding an RIP because the 200 OK to the CANCEL is not passed up to us\n\n                m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"OK\", data ) ;     \n                deleteTags(tags);\n                return ;           \n            }\n            else {\n                DR_LOG(log_error) << \"SipDialogController::doSendCancelRequest - internal server error canceling transaction id \" << \n                    transactionId << \" / orq: \" << std::hex << (void *) iip->orq();\n                m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"NOK\", \n                    string(\"internal server error canceling transaction id: \") + transactionId ) ; \n            }\n        }\n        else {\n            DR_LOG(log_error) << \"SipDialogController::doSendCancelRequest - unknown transaction id \" << transactionId ;\n            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), \"NOK\", \n                string(\"unable to cancel unknown transaction id: \") + transactionId ) ; \n        }\n        pData->~SipMessageData() ;\n        deleteTags(tags);\n   }\n\n    int SipDialogController::processResponseOutsideDialog( nta_outgoing_t* orq, sip_t const* sip )  {\n        DR_LOG(log_debug) << \"SipDialogController::processResponseOutsideDialog\"  ;\n        string transactionId ;\n        std::shared_ptr<SipDialog> dlg ;\n\n        string encodedMessage ;\n        bool truncated ;\n        msg_t* msg = nta_outgoing_getresponse(orq) ;    //adds a reference\n        SipMsgData_t meta( msg, orq, \"network\") ;\n\n        EncodeStackMessage( sip, encodedMessage ) ;\n\n        if( sip->sip_cseq->cs_method == sip_method_invite || sip->sip_cseq->cs_method == sip_method_subscribe ) {\n            std:shared_ptr<IIP> iip;\n\n            //check for retransmission \n            if (sip->sip_cseq->cs_method == sip_method_invite && m_timerDHandler.resendIfNeeded(orq)) {\n                DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - retransmitted ACK for callid: \" << sip->sip_call_id->i_id  <<\n                    \" for invite with orq: \" << std::hex << (void *) orq;\n                msg_destroy( msg ) ; \n                return 0;\n            }\n\n            if (!IIP_FindByOrq(m_invitesInProgress, orq, iip)) {\n                DR_LOG(log_error) << \"SipDialogController::processResponseOutsideDialog - unable to match invite response with callid: \" << sip->sip_call_id->i_id  ;\n                //TODO: do I need to destroy this transaction?\n                msg_destroy( msg ) ; \n                return -1 ; //TODO: check meaning of return value           \n            }      \n            transactionId = iip->getTransactionId() ;   \n            dlg = iip->dlg() ;   \n\n\n            //update dialog variables            \n            dlg->setSipStatus( sip->sip_status->st_status ) ;\n            if( sip->sip_payload ) {\n                iip->dlg()->setRemoteSdp( sip->sip_payload->pl_data, sip->sip_payload->pl_len ) ;\n            }\n\n            // stats\n            if (theOneAndOnlyController->getStatsCollector().enabled()) {\n                // post-dial delay\n                if (sip->sip_cseq->cs_method == sip_method_invite && dlg->getSipStatus() <= 200) {\n                    auto now = std::chrono::steady_clock::now();\n                    std::chrono::duration<double> diff = now - dlg->getArrivalTime();\n                    if (!dlg->hasAlerted()) {\n                        dlg->alerting();\n                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_PDD_OUT, diff.count())\n                    }\n                    if (200 == dlg->getSipStatus()) {\n                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_RESPONSE_TIME_OUT, diff.count())\n                    }\n                }\n            }\n\n\n            //UAC Dialog is added when we receive a final response from the network, or a reliable provisional response\n            //for non-success responses, it will subsequently be removed when we receive the ACK from the client\n\n            if( (sip->sip_cseq->cs_method == sip_method_invite && \n                    (200 == sip->sip_status->st_status || (sip->sip_status->st_status > 100 && sip->sip_status->st_status < 200 && sip->sip_rseq))) || \n                (sip->sip_cseq->cs_method == sip_method_subscribe && \n                    (202 == sip->sip_status->st_status || 200 == sip->sip_status->st_status) ) )  {\n\n                DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - adding dialog id: \" << dlg->getDialogId()  ;\n                nta_leg_t* leg = const_cast<nta_leg_t *>(iip->leg()) ;\n                nta_leg_rtag( leg, sip->sip_to->a_tag) ;\n                nta_leg_client_reroute( leg, sip->sip_record_route, sip->sip_contact, 1 );\n\n                bool nat = false;\n                const sip_route_t* route = NULL;\n                if (nta_leg_get_route(leg, &route, NULL) >= 0 && route && route->r_url->url_host && isRfc1918(route->r_url->url_host)) {\n                    DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected possible natted downstream client at RFC1918 address: \" << route->r_url->url_host  ;\n                    nat = true;\n                }\n                else if(sip->sip_cseq->cs_method == sip_method_invite && !route && sip->sip_contact && \n                    0 != strcmp(sip->sip_contact->m_url->url_host, meta.getAddress().c_str())) {\n\n                    DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected downstream client; contact ip: \" << \n                        sip->sip_contact->m_url->url_host << \" differs from recv address: \" << meta.getAddress().c_str();\n                    nat = true;\n                }\n                else if (theOneAndOnlyController->isAggressiveNatEnabled() && sipMsgHasNatEqualsYes(sip, true, true)) {\n                        DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected possible natted downstream client advertising nat=yes\";\n                    nat = true;\n                }\n\n                if (nat && theOneAndOnlyController->isNatDetectionDisabled()) {\n                    nat = false;\n                    DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected possible natted downstream client, but ignoring because disable-nat-detection is on\";\n                }\n                if (nat) {\n                    url_t const * url = nta_outgoing_route_uri(orq);\n                    string routeUri = string((url ? url->url_scheme : \"sip\")) + \":\" + meta.getAddress() + \":\" + meta.getPort();\n                    dlg->setRouteUri(routeUri);\n                    DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected nat setting route to: \" <<   routeUri;\n                }\n                else {\n                    dlg->clearRouteUri();\n                }\n                if (iip->isCanceled()) {\n                    DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - ACK/BYE race condition - received 200 OK to INVITE that was previously CANCELED\";\n                    dlg->doAckBye();\n                }\n                addDialog( dlg ) ;\n            }\n            tport_t* tp = nta_outgoing_transport(orq);\n            if (sip->sip_cseq->cs_method == sip_method_invite && sip->sip_status->st_status == 200 && tport_is_dgram(tp)) {\n                // for successful uac invites, we need to handle retransmits\n                m_timerDHandler.addInvite(orq);\n            }\n            tport_unref(tp);\n\n            if (sip->sip_cseq->cs_method == sip_method_invite && sip->sip_status->st_status == 200 && sip->sip_session_expires) {\n                DR_LOG(log_info) << \"SipDialogController::processResponseOutsideDialog - (UAC) detected session timer header: \";\n                dlg->setSessionTimer( sip->sip_session_expires->x_delta, \n                    !sip->sip_session_expires->x_refresher || 0 == strcmp( sip->sip_session_expires->x_refresher, \"uac\") ? \n                    SipDialog::we_are_refresher : \n                    SipDialog::they_are_refresher) ;\n            }\n            else if (sip->sip_status->st_status > 200) {\n                IIP_Clear(m_invitesInProgress, iip);\n            }\n        }\n        else {\n            std::shared_ptr<RIP> rip ;\n            if( !findRIPByOrq( orq, rip ) ) {\n                DR_LOG(log_error) << \"SipDialogController::processResponseOutsideDialog - unable to match response with callid for a non-invite request we sent: \" << sip->sip_call_id->i_id  ;\n                //TODO: do I need to destroy this transaction?\n                return -1 ; //TODO: check meaning of return value                           \n            }\n            transactionId = rip->getTransactionId() ;\n            if( sip->sip_status->st_status >= 200 ) this->clearRIP( orq ) ;\n        }\n        \n        if( !dlg ) {\n            m_pController->getClientController()->route_response_inside_transaction( encodedMessage, meta, orq, sip, transactionId ) ;\n        }\n        else {\n            m_pController->getClientController()->route_response_inside_transaction( encodedMessage, meta, orq, sip, transactionId, dlg->getDialogId() ) ;            \n        }\n\n        if( sip->sip_cseq->cs_method == sip_method_invite) {\n          if (sip->sip_status->st_status >= 300) {\n            Cdr::postCdr( std::make_shared<CdrStop>( msg, \"network\",\n                487 == sip->sip_status->st_status ? Cdr::call_canceled : Cdr::call_rejected ) );\n          }\n          else if (sip->sip_status->st_status == 200) {\n            Cdr::postCdr( std::make_shared<CdrStart>( msg, \"network\", Cdr::uac ) );                \n          }\n        }\n        if( sip->sip_cseq->cs_method == sip_method_invite && sip->sip_status->st_status > 200 ) {\n            assert( dlg ) ;\n            m_pController->getClientController()->removeDialog( dlg->getDialogId() ) ;\n        }\n\n        msg_destroy( msg ) ;                            //releases reference\n\n        return 0 ;\n    }\n    void SipDialogController::doRespondToSipRequest( SipMessageData* pData ) {\n        string transactionId( pData->getTransactionId() );\n        string startLine( pData->getStartLine()) ;\n        string headers( pData->getHeaders() );\n        string body( pData->getBody()) ;\n        string clientMsgId( pData->getClientMsgId()) ;\n        string contentType ;\n        string dialogId ;\n        string contact, transportDesc ;\n        std::shared_ptr<SipTransport> pSelectedTransport ;\n        bool bSentOK = true ;\n        string failMsg ;\n        bool bDestroyIrq = false ;\n        bool bClearIIP = false ;\n        bool existingDialog = false;\n        bool transportGone = false;\n        tagi_t* tags = nullptr;\n\n        //decode status \n        sip_status_t* sip_status = sip_status_make( m_pController->getHome(), startLine.c_str() ) ;\n        int code = sip_status->st_status ;\n        const char* status = sip_status->st_phrase ;\n  \n        nta_incoming_t* irq = NULL ;\n        int rc = -1 ;\n        std::shared_ptr<IIP> iip;\n\n        DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest thread \" << std::this_thread::get_id() ;\n\n        /* search for requests within a dialog first */\n        irq = findAndRemoveTransactionIdForIncomingRequest( transactionId ) ;\n        if( !irq ) {\n            if (!IIP_FindByTransactionId(m_invitesInProgress, transactionId, iip)) {\n                /* could be a new incoming request that hasn't been responded to yet */\n                \n                /* we allow the app to set the local tag (ie tag on the To) */\n                string toValue;\n                string tag;\n                if (GetValueForHeader( headers, \"to\", toValue)) {\n                    std::regex re(\"tag=(.*)\");\n                    std::smatch mr;\n                    if (std::regex_search(toValue, mr, re) && mr.size() > 1) {\n                        tag = mr[1] ;\n                    }\n                }\n\n                if( m_pController->setupLegForIncomingRequest( transactionId, tag ) ) {\n                    if (!IIP_FindByTransactionId(m_invitesInProgress, transactionId, iip)) {\n                        irq = findAndRemoveTransactionIdForIncomingRequest(transactionId)  ;\n                    }\n                }\n             }\n        }\n        else {\n            existingDialog = true;\n        }\n\n        if( irq ) {\n\n            DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest found incoming transaction \" << std::hex << irq  ;\n\n            msg_t* msg = nta_incoming_getrequest( irq ) ;   //adds a reference\n            sip_t *sip = sip_object( msg );\n\n            tport_t *tp = nta_incoming_transport(m_agent, irq, msg) ; \n\n            if (!tp || tport_is_shutdown(tp)) {\n                failMsg = \"transport for response has been shutdown or closed\";\n                DR_LOG(log_error) << \"SipDialogController::doRespondToSipRequest - unable to forward response as transport has been closed or shutdown \"\n                    << sip->sip_call_id->i_id << \" \" << sip->sip_cseq->cs_seq;\n                bSentOK = false;\n                transportGone = true;\n                msg_destroy(msg);\n            }\n            else {\n                tport_t *tport = tport_parent( tp ) ;\n\n                pSelectedTransport = SipTransport::findTransport( tport ) ;\n                if (!pSelectedTransport) {\n                    bSentOK = false;\n                    failMsg = \"Unable to find transport for transaction\";\n                    DR_LOG(log_error) << \"SipDialogController::doRespondToSipRequest - unable to find transport for response to \"\n                        << sip->sip_call_id->i_id << \" \" << sip->sip_cseq->cs_seq;\n                }\n                else {\n                    pSelectedTransport->getContactUri(contact, true);\n                    contact = \"<\" + contact + \">\" ;\n\n                    pSelectedTransport->getDescription(transportDesc);\n\n                    tport_unref( tp ) ;\n            \n                    //create tags for headers\n                    tags = makeTags( headers, transportDesc ) ;\n\n                    if( body.length() && !searchForHeader( tags, siptag_content_type, contentType ) ) {\n                        if( 0 == body.find(\"v=0\") ) {\n                            contentType = \"application/sdp\" ;\n                            DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - automatically detecting content-type as application/sdp\"  ;\n                        }\n                    }\n\n                    rc = nta_incoming_treply( irq, code, status\n                        ,TAG_IF( (sip_method_invite == sip->sip_request->rq_method || sip->sip_request->rq_method == sip_method_subscribe) &&\n                            !searchForHeader( tags, siptag_contact_str, contact ), SIPTAG_CONTACT_STR(contact.c_str()) )\n                        ,TAG_IF(!body.empty(), SIPTAG_PAYLOAD_STR(body.c_str()))\n                        ,TAG_IF(!contentType.empty(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))\n                        ,TAG_NEXT(tags)\n                        ,TAG_END() ) ;\n                    if( 0 != rc ) {\n                        bSentOK = false ;\n                        failMsg = \"Unknown server error sending response\" ;\n                    }\n                }\n            }\n\n            //  we need to cache source address / port / transport for successful REGISTER or SUBSCRIBE requests from webrtc clients so we can \n            //  later send INVITEs and NOTIFYs\n            if( bSentOK && ((sip->sip_request->rq_method == sip_method_subscribe && (202 == code || 200 ==code) ) ||\n                (sip->sip_request->rq_method == sip_method_register && 200 == code) ) ) {\n\n                sip_contact_t* contact = sip->sip_contact ;\n                if( contact ) {\n                    if( !tport_is_dgram(tp) /*&& NULL != strstr( contact->m_url->url_host, \".invalid\") */) {\n                        bool add = true ;\n                        unsigned long expires = 0 ;\n\n                        msg_t *msgResponse = nta_incoming_getresponse( irq ) ;    // adds a reference\n                        if (msg) {\n                            sip_t *sipResponse = sip_object( msgResponse ) ;\n                            if (sipResponse) {\n                                if( sip->sip_request->rq_method == sip_method_subscribe ) {\n                                    if (sipResponse->sip_expires && sipResponse->sip_expires->ex_delta) {\n                                        expires = sipResponse->sip_expires->ex_delta;\n                                    }\n                                    else {\n                                        DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - 200-class response to SUBSCRIBE must include expires (rfc3265 3.1.1)\"  ;\n                                    }\n                                }\n                                else {\n                                    if( NULL != sipResponse->sip_contact && NULL != sipResponse->sip_contact->m_expires ) {\n                                        expires = ::atoi( sipResponse->sip_contact->m_expires ) ;\n                                    }\n                                    else if (NULL != sipResponse->sip_contact && sipResponse->sip_expires->ex_delta) {\n                                        expires = sipResponse->sip_expires->ex_delta;\n                                    }  \n                                }\n                                \n                                add = expires > 0 ;\n                                if( add ) {\n                                    theOneAndOnlyController->cacheTportForSubscription( contact->m_url->url_user, contact->m_url->url_host, expires, tp ) ;\n                                }\n                                else {\n                                    theOneAndOnlyController->flushTportForSubscription( contact->m_url->url_user, contact->m_url->url_host ) ;                        \n                                }\n                            }\n                            else {\n                                bSentOK = false ;\n                                failMsg = \"connection error: remote side may have closed socket\";                                \n                            }\n                            msg_destroy( msgResponse ) ;    // releases the reference                            \n                        }\n                        else {\n                            bSentOK = false ;\n                            failMsg = \"connection error: remote side may have closed socket\";\n                        }\n                    }\n                }\n            }\n\n            if (existingDialog && bSentOK) {\n                nta_leg_t* leg = nta_leg_by_call_id(m_pController->getAgent(), sip->sip_call_id->i_id);\n                if (leg) {\n                    std::shared_ptr<SipDialog> dlg ;\n                    if(findDialogByLeg( leg, dlg )) {\n                        dialogId = dlg->getDialogId();\n                        DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest retrieved dialog id for existing dialog \" << dialogId  ;\n                        if (sip->sip_request->rq_method == sip_method_invite && body.length()) {\n                            DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest updating local sdp for dialog \" << dialogId  ;\n                            dlg->setLocalSdp( body.c_str() ) ;\n                        }\n                    }\n                }\n            }\n            msg_destroy( msg ); //release the reference\n\n            DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest destroying irq \" << irq  ;\n            bDestroyIrq = true ;                        \n        }\n        else if( iip ) {\n            DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest found invite or subscribe in progress \" << std::hex << iip  ;\n           /* invite in progress */\n            nta_leg_t* leg = const_cast<nta_leg_t *>(iip->leg()) ;\n            irq = const_cast<nta_incoming_t *>(iip->irq()) ;         \n            std::shared_ptr<SipDialog> dlg = iip->dlg() ;\n\n            if (dlg->getSipStatus() >= 200) {\n                DR_LOG(log_warning) << \"SipDialogController::doRespondToSipRequest: iip \" << std::hex << iip  << \n                    \": application attempting to send final response \" << std::dec << dlg->getSipStatus() << \n                    \" when a final response has already been sent; discarding\" ;\n            }\n            else {\n                msg_t* msg = nta_incoming_getrequest( irq ) ;   //allocates a reference\n                sip_t *sip = sip_object( msg );\n\n                tport_t *tp = nta_incoming_transport(m_agent, irq, msg) ; \n                if (!tp || tport_is_shutdown(tp)) {\n                    failMsg = \"transport for response has been shutdown or closed\";\n                    DR_LOG(log_error) << \"SipDialogController::doRespondToSipRequest - unable to forward response as transport has been closed or shutdown \"\n                        << sip->sip_call_id->i_id << \" \" << sip->sip_cseq->cs_seq;\n                    bSentOK = false;\n                    transportGone = true;\n                    msg_destroy(msg);\n                }\n                else {\n                    tport_t *tport = tport_parent( tp ) ;\n\n                    pSelectedTransport = SipTransport::findTransport( tport ) ;\n                    assert(pSelectedTransport); \n\n                    pSelectedTransport->getContactUri(contact, true);\n                    contact = \"<\" + contact + \">\" ;\n\n                    pSelectedTransport->getDescription(transportDesc);\n\n                    tport_unref( tp ) ;\n            \n                    //create tags for headers\n                    tags = makeTags( headers, transportDesc ) ;\n                    string customContact ;\n                    bool hasCustomContact = searchForHeader( tags, siptag_contact_str, customContact ) ;\n                    if( hasCustomContact ) {\n                        DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - client provided contact header so we wont include our internally-generated one\"  ;\n                    }\n\n                    dlg->setLocalContactHeader(hasCustomContact ? customContact.c_str() : contact.c_str());\n\n                    dialogId = dlg->getDialogId() ;\n\n                    dlg->setSipStatus( code ) ;\n\n                    /* if the client included Require: 100rel on a provisional, send it reliably */\n                    bool bReliable = false ;\n                    if( code > 100 && code < 200 && sip->sip_request->rq_method == sip_method_invite) {\n                        int i = 0 ;\n                        while( tags[i].t_tag != tag_null ) {\n                            if( tags[i].t_tag == siptag_require_str && NULL != strstr( (const char*) tags[i].t_value, \"100rel\") ) {\n                                bReliable = true ;\n                                break ;\n                            }\n                            i++ ;\n                        }\n                    }\n\n                    /* update local sdp if provided */\n                    string strLocalSdp ;\n                    if( !body.empty()  ) {\n                        dlg->setLocalSdp( body.c_str() ) ;\n                        string strLocalContentType ;\n                        if( searchForHeader( tags, siptag_content_type_str, strLocalContentType ) ) {\n                            dlg->setLocalContentType( strLocalContentType ) ;\n                        }\n                        else {\n                            /* set content-type if we can detect it */\n                            if( 0 == body.find(\"v=0\") ) {\n                                contentType = \"application/sdp\" ;\n                                dlg->setLocalContentType( contentType ) ;\n                            }\n                        }\n                    }\n\n                    /* set session timer if required */\n                    sip_session_expires_t *sessionExpires = nullptr;\n                    if( 200 == code && sip->sip_request->rq_method == sip_method_invite ) {\n                        string strSessionExpires ;\n                        if( searchForHeader( tags, siptag_session_expires_str, strSessionExpires ) ) {\n                            sip_session_expires_t* se = sip_session_expires_make(m_pController->getHome(), strSessionExpires.c_str() );\n                            unsigned long interval = std::max((unsigned long) 90, se->x_delta);\n                            SipDialog::SessionRefresher_t who = !se->x_refresher || 0 == strcmp( se->x_refresher, \"uac\") ? SipDialog::they_are_refresher : SipDialog::we_are_refresher;\n\n                            if (who == SipDialog::we_are_refresher) {\n                                DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - per app we are refresher, interval will be \" << interval  ;\n                            }\n                            else {\n                                DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - per app UAC is refresher, interval will be \" << interval  ;\n                            }\n                            dlg->setSessionTimer(interval, who) ;\n                            su_free( m_pController->getHome(), se ) ;\n                        }\n                        else if (sip->sip_session_expires && sip->sip_session_expires->x_refresher) {\n                            sip_session_expires_t* se = sip->sip_session_expires;\n                            sessionExpires = sip_session_expires_copy(m_pController->getHome(), se);\n                            unsigned long interval = std::max((unsigned long) 90, se->x_delta);\n                            SipDialog::SessionRefresher_t who = !se->x_refresher || 0 == strcmp( se->x_refresher, \"uac\") ? SipDialog::they_are_refresher : SipDialog::we_are_refresher;\n\n                            if (who == SipDialog::we_are_refresher) {\n                                DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - UAC asked us to refresh, interval will be \" << interval  ;\n                            }\n                            else {\n                                DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest - UAC is refresher, interval will be \" << interval  ;\n                            }\n                            dlg->setSessionTimer(interval, who) ;\n                        }\n                    }\n\n                    /* iterate through data.opts.headers, adding headers to the response */\n                    if( bReliable ) {\n                        DR_LOG(log_debug) << \"Sending \" << dec << code << \" response reliably\"  ;\n                        nta_reliable_t* rel = nta_reliable_treply( irq, uasPrack, this, code, status\n                            ,TAG_IF( !hasCustomContact, SIPTAG_CONTACT_STR(contact.c_str()))\n                            ,TAG_IF(!body.empty(), SIPTAG_PAYLOAD_STR(body.c_str()))\n                            ,TAG_IF(!contentType.empty(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))\n                            ,TAG_IF(sessionExpires, SIPTAG_SESSION_EXPIRES(sessionExpires))\n                            ,TAG_NEXT(tags)\n                            ,TAG_END() ) ;\n\n                        if( !rel ) {\n                            bSentOK = false ;\n                            failMsg = \"Remote endpoint does not support 100rel\" ;\n                            DR_LOG(log_error) << \"SipDialogController::doRespondToSipRequest - failed sending reliable provisional response; most likely remote endpoint does not support 100rel\"  ;\n                        } \n                        else {\n                            IIP_SetReliable(m_invitesInProgress, iip, rel);\n                        }\n                        //TODO: should probably set timer here\n                    }\n                    else {\n                        DR_LOG(log_debug) << \"Sending \" << dec << code << \" response (not reliably)  on irq \" << hex << irq  ;\n                        rc = nta_incoming_treply( irq, code, status\n                            ,TAG_IF( code >= 200 && code < 300 && !hasCustomContact, SIPTAG_CONTACT_STR(contact.c_str()))\n                            ,TAG_IF(!body.empty(), SIPTAG_PAYLOAD_STR(body.c_str()))\n                            ,TAG_IF(!contentType.empty(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))\n                            ,TAG_IF(sessionExpires, SIPTAG_SESSION_EXPIRES(sessionExpires))\n                            ,TAG_NEXT(tags)\n                            ,TAG_END() ) ; \n                        if( 0 != rc ) {\n                            DR_LOG(log_error) << \"Error \" << dec << rc << \" sending response on irq \" << hex << irq <<\n                                \" - this is usually because the application provided a syntactically-invalid header\";\n                            bSentOK = false ;\n                            failMsg = \"Unknown server error sending response\" ;\n                        }\n                        else {\n                            if( sip_method_subscribe == nta_incoming_method(irq) ) {\n                                bClearIIP = true ;\n\n                                // add dialog for SUBSCRIBE dialogs\n                                if( 202 == code || 200 == code ) {\n                                DR_LOG(log_debug) << \"SipDialogController::doRespondToSipRequest: adding dialog for subscribe with dialog id \" <<  dlg->getDialogId()  ;\n                                this->addDialog( dlg ) ;\n                                }\n                            }\n\n                            // sofia handles retransmits for us for final failures, but not for success\n                            // TODO: figure out why this is\n                            if( sip_method_invite == nta_incoming_method(irq) && code == 200 ) {\n                                \n                                this->addDialog( dlg ) ;\n\n                                if (tport_is_dgram(tp)) {\n                                    // set timer G to retransmit 200 OK if we don't get ack\n                                    TimerEventHandle t = m_pTQM->addTimer(\"timerG\",\n                                        std::bind(&SipDialogController::retransmitFinalResponse, this, irq, tp, dlg), NULL, NTA_SIP_T1 ) ;\n                                    dlg->setTimerG(t) ;\n                                }\n                                // set timer H, which sets the time to stop these retransmissions\n                                TimerEventHandle t = m_pTQM->addTimer(\"timerH\",\n                                    std::bind(&SipDialogController::endRetransmitFinalResponse, this, irq, tp, dlg), NULL, TIMER_H_MSECS ) ;\n                                dlg->setTimerH(t) ;\n                            }\n\n                            // stats\n                            if (theOneAndOnlyController->getStatsCollector().enabled()) {\n            \n                                // response time to incoming INVITE request\n                                if (sip_method_invite == nta_incoming_method(irq) && code <= 200) {\n                                    auto now = std::chrono::steady_clock::now();\n                                    std::chrono::duration<double> diff = now - dlg->getArrivalTime();\n                                    if (!dlg->hasAlerted()) {\n                                        dlg->alerting();\n                                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_PDD_IN, diff.count())\n                                    }\n                                    if (code == 200) {\n                                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_RESPONSE_TIME_IN, diff.count())\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    msg_destroy( msg ); //release the reference\n                    if (sessionExpires) su_free(m_pController->getHome(), sessionExpires);\n                }\n            }\n        }\n        else {\n\n            DR_LOG(log_error) << \"SipDialogController::doRespondToSipRequest - unable to find irq or iip for transaction id \" << transactionId  ;\n\n            /* failed */\n            string strMethod ;\n            bSentOK = false ;\n            failMsg = \"Response not sent due to unknown transaction\" ;  \n\n            if( FindCSeqMethod( headers, strMethod ) ) {\n                DR_LOG(log_debug) << \"silently discarding response to \" << strMethod  ;\n\n                if( 0 == strMethod.compare(\"CANCEL\") ) {\n                    failMsg = \"200 OK to incoming CANCEL is automatically generated by the stack\" ;\n                }\n            }                     \n        }\n\n        if( bSentOK ) {\n            string encodedMessage ;\n            msg_t* msg = nta_incoming_getresponse( irq ) ;  // adds a ref\n\n            // we can get an rc=0 from nta_incoming_treply above, but have it actually fail\n            // in the case of a websocket that closed immediately after sending us a BYE\n            if (msg) {\n                sip_t *sip = sip_object( msg );\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta( msg, irq, \"application\" ) ;\n\n                STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_OUT, {\n                    {\"method\", sip->sip_cseq->cs_method_name},\n                    {\"code\", boost::lexical_cast<std::string>(code)}})\n\n                string s ;\n                meta.toMessageFormat(s) ;\n                string data = s + \"|\" + transactionId + \"|\" + dialogId + \"|\" + \"|Msg sent:|\" + DR_CRLF + encodedMessage ;\n\n                m_pController->getClientController()->route_api_response( clientMsgId, \"OK\", data) ;\n\n                if( iip && code >= 300 ) {\n                    Cdr::postCdr( std::make_shared<CdrStop>( msg, \"application\", Cdr::call_rejected ) );\n                }\n                else if (iip && code == 200) {\n                    Cdr::postCdr( std::make_shared<CdrStart>( msg, \"application\", Cdr::uas ) );                \n                }\n\n                msg_destroy(msg) ;      // release the ref                          \n            }\n            else {\n                m_pController->getClientController()->route_api_response( clientMsgId, \"NOK\", \"failed sending, possibly due to far end closing socket\") ;\n            }\n        }\n        else {\n            m_pController->getClientController()->route_api_response( clientMsgId, \"NOK\", failMsg) ;\n        }\n        /* tell client controller to flush transaction data on any final response to a non-INVITE */\n        if( sip_method_invite != nta_incoming_method(irq) && code >= 200 ) {\n            m_pController->getClientController()->removeNetTransaction( transactionId ) ;\n        }\n        else if( sip_method_invite == nta_incoming_method(irq) && code > 200 ) {\n            m_pController->getClientController()->removeNetTransaction( transactionId ) ;            \n        }\n        else if(sip_method_invite == nta_incoming_method(irq) && code == 200 && existingDialog) {\n            m_pController->getClientController()->removeNetTransaction( transactionId ) ;            \n        }\n\n        if( bClearIIP && iip) {\n            IIP_Clear(m_invitesInProgress, iip);\n        }\n\n        if( bDestroyIrq && !transportGone) nta_incoming_destroy(irq) ;    \n\n        pData->~SipMessageData() ;\n\n        deleteTags( tags );\n\n        su_free(m_pController->getHome(), sip_status);\n\n    }\n\n    int SipDialogController::processRequestInsideDialog( nta_leg_t* leg, nta_incoming_t* irq, sip_t const *sip) {\n        DR_LOG(log_debug) << \"SipDialogController::processRequestInsideDialog: \" << sip->sip_request->rq_method_name << \" irq \" << irq  ;\n        int rc = 0 ;\n        string transactionId ;\n        generateUuid( transactionId ) ;\n\n        switch (sip->sip_request->rq_method) {\n            case sip_method_ack:\n            {\n                /* ack to 200 OK comes here  */\n                std::shared_ptr<IIP> iip ;\n                std::shared_ptr<SipDialog> dlg ;       \n                if (!IIP_FindByLeg(m_invitesInProgress, leg, iip)) {\n                    \n                    /* not a new INVITE, so it should be found as an existing dialog; i.e. a reINVITE */\n                    if( !findDialogByLeg( leg, dlg ) ) {\n                        DR_LOG(log_error) << \"SipDialogController::processRequestInsideDialog - unable to find Dialog for leg\"  ;\n                        assert(0) ;\n                        return -1 ;\n                    }\n                }\n                else {\n                    transactionId = iip->getTransactionId() ;\n                    dlg = iip->dlg();\n                    IIP_Clear(m_invitesInProgress, iip);\n                    this->clearSipTimers(dlg);\n                    //addDialog( dlg ) ;  now adding when we send the 200 OK\n                }\n                string encodedMessage ;\n                msg_t* msg = nta_incoming_getrequest( irq ) ; // adds a reference\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta( msg, irq ) ;\n                msg_destroy(msg) ;      // releases the reference\n\n                m_pController->getClientController()->route_ack_request_inside_dialog(  encodedMessage, meta, irq, sip, transactionId, dlg->getTransactionId(), dlg->getDialogId() ) ;\n\n                nta_incoming_destroy(irq) ;\n                break ;\n            }\n            case sip_method_cancel:\n            {\n                // this should only happen in a race condition, where we've sent the 200 OK but not yet received an ACK \n                //  in this case, send a 481 to the CANCEL and then generate a BYE\n                std::shared_ptr<SipDialog> dlg ;\n                if( !this->findDialogByLeg( leg, dlg ) ) {\n                    DR_LOG(log_error) << \"SipDialogController::processRequestInsideDialog - unable to find Dialog for leg\"  ;\n                    return 481 ;\n                    assert(0) ;\n                    return -1;\n                }\n                DR_LOG(log_warning) << \"SipDialogController::processRequestInsideDialog - received CANCEL after 200 OK; reply 481 and tear down dialog\"  ;\n                this->clearSipTimers(dlg);\n\n                // 481 to the CANCEL\n                nta_incoming_treply( irq, SIP_481_NO_TRANSACTION, TAG_END() ) ;  \n\n                // BYE to the far end\n                nta_outgoing_t* orq = nta_outgoing_tcreate( leg, NULL, NULL,\n                                        NULL,\n                                        SIP_METHOD_BYE,\n                                        NULL,\n                                        SIPTAG_REASON_STR(\"SIP ;cause=200 ;text=\\\"CANCEL after 200 OK\\\"\"),\n                                        TAG_END() ) ;\n\n                msg_t* m = nta_outgoing_getrequest(orq) ;  // adds a reference\n                sip_t* sip = sip_object( m ) ;\n\n                DR_LOG(log_info) << \"SipDialogController::processRequestInsideDialog - (cancel) created orq \" << std::hex << (void *) orq  <<\n                    \" call-id \" << sip->sip_call_id->i_id;\n\n                string encodedMessage ;\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta(m, orq) ;\n                string s ;\n                meta.toMessageFormat(s) ;\n\n                m_pController->getClientController()->route_request_inside_dialog( encodedMessage, meta, sip, \"unsolicited\", dlg->getDialogId() ) ;\n                msg_destroy(m);      // releases the reference\n\n                nta_outgoing_destroy(orq) ;\n                SD_Clear(m_dialogs, leg ) ;\n\n            }\n            default:\n            {\n                std::shared_ptr<SipDialog> dlg ;\n                if( !this->findDialogByLeg( leg, dlg ) ) {\n                    DR_LOG(log_error) << \"SipDialogController::processRequestInsideDialog - unable to find Dialog for leg\"  ;\n                    return 481 ;\n                    assert(0) ;\n                }\n\n                if (sip_method_invite == sip->sip_request->rq_method) {\n                    nta_incoming_treply(irq, SIP_100_TRYING, TAG_END());\n                }\n\n                /* if this is a re-INVITE or an UPDATE deal with session timers */\n                if( sip_method_invite == sip->sip_request->rq_method || sip_method_update == sip->sip_request->rq_method ) {\n                    bool weAreRefresher = false;\n                    if( dlg->hasSessionTimer() ) { \n                        DR_LOG(log_info) << \"SipDialogController::processRequestInsideDialog - canceling session expires timer due to re-invite\"  ;\n                        weAreRefresher = dlg->areWeRefresher();\n                        dlg->cancelSessionTimer() ;\n                    }\n\n                    /* reject if session timer is too small */\n                    if( sip->sip_session_expires && sip->sip_session_expires->x_delta < dlg->getMinSE() ) {\n                        ostringstream o ;\n                        o << dlg->getMinSE() ;\n                        nta_incoming_treply( irq, SIP_422_SESSION_TIMER_TOO_SMALL, \n                            SIPTAG_MIN_SE_STR(o.str().c_str()),\n                            TAG_END() ) ;  \n                        return 0 ;             \n                    }\n                    if( sip->sip_session_expires ) {\n                        dlg->setSessionTimer( sip->sip_session_expires->x_delta, \n                            (!sip->sip_session_expires->x_refresher && weAreRefresher) ||(sip->sip_session_expires->x_refresher && 0 == strcmp( sip->sip_session_expires->x_refresher, \"uac\")) ? \n                            SipDialog::they_are_refresher : \n                            SipDialog::we_are_refresher) ;\n                    }\n\n                }\n\n                string encodedMessage ;\n                msg_t* msg = nta_incoming_getrequest( irq ) ;   //adds a reference\n                EncodeStackMessage( sip, encodedMessage ) ;\n                SipMsgData_t meta( msg, irq ) ;\n                msg_destroy( msg ); // release the reference\n\n                bool routed = m_pController->getClientController()->route_request_inside_dialog( encodedMessage, meta, sip, transactionId, dlg->getDialogId() ) ;\n                if (!routed && dlg->getSipStatus() < 200) {\n                    // got a request before we sent a 200 OK to the initial INVITE, treat as an out-of-dialog request\n                    switch (sip->sip_request->rq_method) {\n                        case sip_method_notify:\n                        case sip_method_options:\n                        case sip_method_info:\n                        case sip_method_message:\n                        case sip_method_publish:\n                        case sip_method_subscribe:\n                            return m_pController->processMessageStatelessly( msg, (sip_t*) sip);\n                        default:\n                        break;\n                    }\n                }\n\n                addIncomingRequestTransaction( irq, transactionId) ;\n    \n                if( sip_method_bye == sip->sip_request->rq_method || \n                    (sip_method_notify == sip->sip_request->rq_method && !dlg->isInviteDialog() &&\n                        NULL != sip->sip_subscription_state && \n                        NULL != sip->sip_subscription_state->ss_substate &&\n                        NULL != strstr(sip->sip_subscription_state->ss_substate, \"terminated\") ) \n                ) {\n\n                    this->clearSipTimers(dlg);\n\n                    //clear dialog when we send a 200 OK response to BYE\n                    SD_Clear(m_dialogs, leg ) ;\n                    if( !routed ) {\n                        nta_incoming_treply( irq, SIP_481_NO_TRANSACTION, TAG_END() ) ;                \n                    }\n                }\n\n                if (sip_method_bye == sip->sip_request->rq_method) {\n                  Cdr::postCdr( std::make_shared<CdrStop>( msg, \"network\", Cdr::normal_release ) );\n                }\n            }\n        }\n        return rc ;\n    }\n    int SipDialogController::processResponseInsideDialog( nta_outgoing_t* orq, sip_t const* sip )  {\n        DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: \"  ;\n    \tostringstream o ;\n        std::shared_ptr<RIP> rip  ;\n        sip_method_t method = sip->sip_cseq->cs_method;\n        int statusCode = sip->sip_status->st_status ;\n\n        if( findRIPByOrq( orq, rip ) ) {\n            DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: found request for \"  << sip->sip_cseq->cs_method_name << \" sip status \" << statusCode ;\n\n            string encodedMessage ;\n            bool truncated ;\n            msg_t* msg = nta_outgoing_getresponse(orq) ;  // adds a reference\n            SipMsgData_t meta( msg, orq, \"network\") ;\n            EncodeStackMessage( sip, encodedMessage ) ;\n            \n            m_pController->getClientController()->route_response_inside_transaction( encodedMessage, meta, orq, sip, rip->getTransactionId(), rip->getDialogId() ) ;            \n\n            if (method == sip_method_invite && 200 == statusCode) {\n                tport_t *tp = nta_outgoing_transport(orq) ; \n                sip_session_expires_t* se = sip_session_expires(sip) ;\n\n                // start a timerD for this successful reINVITE\n                if (tport_is_dgram(tp) )m_timerDHandler.addInvite(orq);\n                \n                /* reset session expires timer, if provided */\n                if( se ) {\n                    std::shared_ptr<SipDialog> dlg ;\n                    nta_leg_t* leg = nta_leg_by_call_id(m_pController->getAgent(), sip->sip_call_id->i_id);\n                    DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: searching for dialog by leg \" << std::hex << (void *) leg;\n                    if(leg && findDialogByLeg( leg, dlg )) {\n                        DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: (re)setting session expires timer to \" <<  se->x_delta;\n                        //TODO: if session-expires value is less than min-se ACK and then BYE with Reason header    \n                        dlg->setSessionTimer( se->x_delta, \n                            !se->x_refresher || 0 == strcmp( se->x_refresher, \"uac\") ? \n                                SipDialog::we_are_refresher : \n                                SipDialog::they_are_refresher ) ;\n                    }\n                    else {\n                        DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: unable to find dialog for leg \" << std::hex << (void *) leg;\n                    }\n                }\n                else {\n                    DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: no session expires header found\";\n                }\n            }\n            if (rip->shouldClearDialogOnResponse()) {\n                string dialogId = rip->getDialogId() ;\n                if (sip->sip_cseq->cs_method == sip_method_bye && (sip->sip_status->st_status == 407 || sip->sip_status->st_status == 401)) {\n                    DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: NOT clearing dialog after receiving 401/407 response to BYE\"  ;\n                }\n                else if( dialogId.length() > 0 ) {\n                    DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: clearing dialog after receiving response to BYE or notify w/ subscription-state terminated\"  ;\n                    SD_Clear(m_dialogs, dialogId ) ;\n                }\n                else {\n                    DR_LOG(log_debug) << \"SipDialogController::processResponseInsideDialog: got 200 OK to BYE but don't have dialog id\"  ;\n                    assert(false) ;\n                }\n            }\n            clearRIP( orq ) ;     \n            msg_destroy(msg) ;   // releases reference\n        }\n        else {\n            DR_LOG(log_error) << \"SipDialogController::processResponseInsideDialog: unable to find request associated with response\"  ;            \n            nta_outgoing_destroy( orq ) ;\n        }\n  \n\t\treturn 0 ;\n    }\n    int SipDialogController::processResponseToRefreshingReinvite( nta_outgoing_t* orq, sip_t const* sip ) {\n        DR_LOG(log_debug) << \"SipDialogController::processResponseToRefreshingReinvite: \"  ;\n        ostringstream o ;\n        std::shared_ptr<RIP> rip  ;\n\n        nta_leg_t* leg = nta_leg_by_call_id(m_pController->getAgent(), sip->sip_call_id->i_id);\n        assert(leg) ;\n        std::shared_ptr<SipDialog> dlg ;\n        if( !findDialogByLeg( leg, dlg ) ) {\n            assert(0) ;\n        }\n        if( findRIPByOrq( orq, rip ) ) {\n\n            if( sip->sip_status->st_status != 200 ) {\n                DR_LOG(log_info) << \"SipDialogController::processResponseToRefreshingReinvite: reinvite failed \"  ;\n                //TODO: notify client that call has failed, send BYE\n            }\n            else {\n                /* reset session expires timer, if provided */\n                sip_session_expires_t* se = sip_session_expires(sip) ;\n                if( se ) {                \n                    //TODO: if session-expires value is less than min-se ACK and then BYE with Reason header    \n                    dlg->setSessionTimer( se->x_delta, \n                        !se->x_refresher || 0 == strcmp( se->x_refresher, \"uac\") ? \n                            SipDialog::we_are_refresher : \n                            SipDialog::they_are_refresher ) ;\n                }\n             }\n\n            nta_outgoing_t* ack_request = nta_outgoing_tcreate(leg, NULL, NULL, NULL,\n                   SIP_METHOD_ACK,\n                   (url_string_t*) sip->sip_contact->m_url ,\n                   TAG_END());\n\n            nta_outgoing_destroy( ack_request ) ;\n            clearRIP( orq ) ;          \n\n            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", \"ACK\"}})\n            return 0;\n        }\n        nta_outgoing_destroy( orq ) ;\n        return 0 ;\n        \n    }\n\n    int SipDialogController::processCancelOrAck( nta_incoming_magic_t* p, nta_incoming_t* irq, sip_t const *sip ) {\n        std::shared_ptr<IIP> iip ;\n        if( !sip ) {\n            DR_LOG(log_debug) << \"SipDialogController::processCancel with null sip pointer; irq \" << \n                hex << (void*) irq << \", most probably timerH indicating end of final response retransmissions\" ;\n            //nta_incoming_destroy(irq);\n            std::shared_ptr<IIP> iip ;\n            if (!IIP_FindByIrq(m_invitesInProgress, irq, iip)) {\n                DR_LOG(log_error) << \"Unable to find invite-in-progress for irq \" << hex << (void*) irq;\n            }\n            else {\n                DR_LOG(log_debug) << \"SipDialogController::processCancelOrAck - clearing IIP for leg \" << hex << (void*) iip->leg();   ;\n                IIP_Clear(m_invitesInProgress, iip);\n            }\n            return -1 ;\n        }\n        DR_LOG(log_debug) << \"SipDialogController::processCancelOrAck: \" << sip->sip_request->rq_method_name  ;\n        string transactionId ;\n        generateUuid( transactionId ) ;\n\n        if( sip->sip_request->rq_method == sip_method_cancel ) {\n            if (!IIP_FindByIrq(m_invitesInProgress, irq, iip)) {\n                DR_LOG(log_error) << \"Unable to find invite-in-progress for CANCEL with call-id \" << sip->sip_call_id->i_id  ;\n                return 0 ;\n            }\n            std::shared_ptr<SipDialog> dlg = iip->dlg() ;\n\n            if( !dlg ) {\n                DR_LOG(log_error) << \"No dialog exists for invite-in-progress for CANCEL with call-id \" << sip->sip_call_id->i_id  ;\n                return 0 ;\n            }\n\n            DR_LOG(log_debug) << \"SipDialogController::processCancelOrAck - Received CANCEL for call-id \" << sip->sip_call_id->i_id << \", sending to client\"  ;\n\n            string encodedMessage ;\n            msg_t* msg = nta_incoming_getrequest( irq ) ;   // adds a reference\n            EncodeStackMessage( sip, encodedMessage ) ;\n            SipMsgData_t meta( msg, irq ) ;\n            Cdr::postCdr( std::make_shared<CdrStop>( msg, \"network\", Cdr::call_canceled ) );\n            msg_destroy(msg);                               // releases reference\n\n            m_pClientController->route_request_inside_invite( encodedMessage, meta, irq, sip, iip->getTransactionId(), dlg->getDialogId() ) ;\n            \n            //TODO: sofia has already sent 200 OK to cancel and 487 to INVITE.  Do we need to keep this irq around?\n            //addIncomingRequestTransaction( irq, transactionId) ;\n\n            DR_LOG(log_debug) << \"SipDialogController::processCancelOrAck - clearing IIP \"   ;\n            IIP_Clear(m_invitesInProgress, iip);\n            DR_LOG(log_debug) << \"SipDialogController::processCancelOrAck - done clearing IIP \"   ;\n\n        }\n        else if( sip->sip_request->rq_method == sip_method_ack ) {\n            if (!IIP_FindByIrq(m_invitesInProgress, irq, iip)) {\n                DR_LOG(log_error) << \"Unable to find invite-in-progress for ACK with call-id \" << sip->sip_call_id->i_id  ;\n                return 0 ;\n            }\n            std::shared_ptr<SipDialog> dlg = iip->dlg(); \n            IIP_Clear(m_invitesInProgress, iip);\n            this->clearSipTimers(dlg);\n\n            string transactionId ;\n            generateUuid( transactionId ) ;\n\n            string encodedMessage ;\n            msg_t* msg = nta_incoming_getrequest( irq ) ;  // adds a reference\n            EncodeStackMessage( sip, encodedMessage ) ;\n            SipMsgData_t meta( msg, irq ) ;\n            msg_destroy( msg ) ;    //release the reference\n\n            m_pController->getClientController()->route_ack_request_inside_dialog( encodedMessage, meta, irq, sip, transactionId, dlg->getTransactionId(), dlg->getDialogId() ) ;   \n            \n            //NB: when we get a CANCEL sofia sends the 487 response to the INVITE itself, so our latest sip status will be a provisional\n            //not sure that we need to do anything particular about that however....though it we write cdrs we would want to capture the 487 final response\n        \n            //another issue is that on any non-success response sent to an incoming INVITE the subsequent ACK is not sent to the client\n            //because there is no dialog created and thus no routing available.  Should fix this.\n        }\n        else {\n            DR_LOG(log_debug) << \"Received \" << sip->sip_request->rq_method_name << \" for call-id \" << sip->sip_call_id->i_id << \", discarding\"  ;\n        }\n        return 0 ;\n    }\n    int SipDialogController::processPrack( nta_reliable_t *rel, nta_incoming_t *prack, sip_t const *sip) {\n        DR_LOG(log_debug) << \"SipDialogController::processPrack: \"  ;\n        std::shared_ptr<IIP> iip  ;\n        if (IIP_FindByReliable(m_invitesInProgress, rel, iip)) {\n            std::string transactionId ;\n            generateUuid( transactionId ) ;\n            std::shared_ptr<SipDialog> dlg = iip->dlg() ;\n            assert( dlg ) ;\n\n            m_pClientController->addDialogForTransaction( dlg->getTransactionId(), dlg->getDialogId() ) ;  \n\n            string encodedMessage ;\n            msg_t* msg = nta_incoming_getrequest( prack ) ; // adds a reference\n            EncodeStackMessage( sip, encodedMessage ) ;\n            SipMsgData_t meta( msg, prack ) ;\n            msg_destroy(msg);                               // releases the reference\n\n            m_pClientController->route_request_inside_dialog( encodedMessage, meta, sip, transactionId, dlg->getDialogId() ) ;\n\n            iip->destroyReliable() ;\n\n            addIncomingRequestTransaction( prack, transactionId) ;\n        }\n        else {\n            assert(0) ;\n        }\n        return 0 ;\n    }\n    void SipDialogController::notifyRefreshDialog( std::shared_ptr<SipDialog> dlg ) {\n        nta_leg_t *leg = nta_leg_by_call_id( m_pController->getAgent(), dlg->getCallId().c_str() );\n        if( leg ) {\n            string strSdp = dlg->getLocalEndpoint().m_strSdp ;\n            string strContentType = dlg->getLocalEndpoint().m_strContentType ;\n\n            assert( dlg->getSessionExpiresSecs() ) ;\n            ostringstream o,v ;\n            o << dlg->getSessionExpiresSecs() << \"; refresher=uac\" ;\n            v << dlg->getMinSE() ;\n\n            nta_outgoing_t* orq = nta_outgoing_tcreate( leg,  response_to_refreshing_reinvite, (nta_outgoing_magic_t *) m_pController,\n                                            NULL,\n                                            SIP_METHOD_INVITE,\n                                            NULL,\n                                            SIPTAG_SESSION_EXPIRES_STR(o.str().c_str()),\n                                            SIPTAG_MIN_SE_STR(v.str().c_str()),\n                                            SIPTAG_CONTACT_STR( dlg->getLocalContactHeader().c_str() ),\n                                            SIPTAG_CONTENT_TYPE_STR(strContentType.c_str()),\n                                            SIPTAG_PAYLOAD_STR(strSdp.c_str()),\n                                            TAG_END() ) ;\n            \n            string transactionId ;\n            generateUuid( transactionId ) ;\n\n            std::shared_ptr<RIP> p = std::make_shared<RIP>( transactionId ) ; \n            addRIP( orq, p ) ;\n\n            DR_LOG(log_info) << \"SipDialogController::notifyRefreshDialog - created orq \" << std::hex << (void *) orq;\n\n            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", \"INVITE\"}})\n\n            //m_pClientController->route_event_inside_dialog( \"{\\\"eventName\\\": \\\"refresh\\\"}\",dlg->getTransactionId(), dlg->getDialogId() ) ;\n        }\n    }\n    void SipDialogController::notifyTerminateStaleDialog( std::shared_ptr<SipDialog> dlg, bool ackbye ) {\n        nta_leg_t* leg = const_cast<nta_leg_t *>(dlg->getNtaLeg()) ;\n        const char* reason = ackbye ? \"SIP ;cause=200 ;text=\\\"ACK-BYE due to cancel race condition\\\"\" : \"SIP ;cause=200 ;text=\\\"Session timer expired\\\"\";\n        if( leg ) {\n            nta_outgoing_t* orq = nta_outgoing_tcreate( leg, NULL, NULL,\n                                            NULL,\n                                            SIP_METHOD_BYE,\n                                            NULL,\n                                            SIPTAG_REASON_STR(reason),\n                                            TAG_END() ) ;\n            msg_t* m = nta_outgoing_getrequest(orq) ;    // adds a reference\n            sip_t* sip = sip_object( m ) ;\n\n            DR_LOG(log_info) << \"SipDialogController::notifyTerminateStaleDialog - created orq \" << std::hex << (void *) orq;\n\n            string byeTransactionId  = \"unsolicited\";\n\n            string encodedMessage ;\n            EncodeStackMessage( sip, encodedMessage ) ;\n            SipMsgData_t meta(m, orq) ;\n            string s ;\n            meta.toMessageFormat(s) ;\n            string data = s + \"|\" + byeTransactionId + \"|Msg sent:|\" + DR_CRLF + encodedMessage ;\n            msg_destroy(m) ;    // releases reference::process\n\n            // this is slightly inaccurate: we are telling the app we received a BYE when we are in fact generating it\n            // the impact is minimal though, and currently there is no message type to inform the app we generated a BYE on our own\n            bool routed = m_pController->getClientController()->route_request_inside_dialog( encodedMessage, meta, sip, byeTransactionId, dlg->getDialogId() ) ;\n\n            Cdr::postCdr( std::make_shared<CdrStop>( m, \"application\", ackbye ? Cdr::ackbye : Cdr::session_expired ) );\n            nta_outgoing_destroy(orq) ;\n\n            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", \"BYE\"}})\n        }\n        SD_Clear(m_dialogs, dlg) ;\n    }\n    void SipDialogController::notifyCancelTimeoutReachedIIP( std::shared_ptr<IIP> iip ) {\n        DR_LOG(log_info) << \"SipDialogController::notifyCancelTimeoutReachedIIP - tearing down transaction id \" << iip->getTransactionId() ;\n        m_pController->getClientController()->removeAppTransaction( iip->getTransactionId() ) ;\n        IIP_Clear(m_invitesInProgress, iip) ;\n    }\n\n    void SipDialogController::bindIrq( nta_incoming_t* irq ) {\n        nta_incoming_bind( irq, uasCancelOrAck, (nta_incoming_magic_t *) m_pController ) ;\n    }\n    bool SipDialogController::searchForHeader( tagi_t* tags, tag_type_t header, string& value ) {\n        int i = 0 ;\n        while( tags[i].t_tag != tag_null ) {\n            if( tags[i].t_tag == header ) {\n                value.assign( (const char*) tags[i].t_value );\n                return true ;\n            }\n            i++ ;\n        }\n        return false ;\n    }\n    void SipDialogController::addIncomingInviteTransaction( nta_leg_t* leg, nta_incoming_t* irq, sip_t const *sip, const string& transactionId, std::shared_ptr<SipDialog> dlg, const string& tag ) {\n        const char* a_tag = nta_incoming_tag( irq, tag.length() == 0 ? NULL : tag.c_str()) ;\n        nta_leg_tag( leg, a_tag ) ;\n        dlg->setLocalTag( a_tag ) ;\n\n        IIP_Insert(m_invitesInProgress, leg, irq, transactionId, dlg);\n\n        this->bindIrq( irq ) ;\n    }\n    void SipDialogController::addOutgoingInviteTransaction( nta_leg_t* leg, nta_outgoing_t* orq, sip_t const *sip, std::shared_ptr<SipDialog> dlg ) {\n        DR_LOG(log_debug) << \"SipDialogController::addOutgoingInviteTransaction:  adding leg \" << std::hex << leg  ;\n        IIP_Insert(m_invitesInProgress, leg, orq, dlg->getTransactionId(), dlg);\n    }\n\n    void SipDialogController::addRIP( nta_outgoing_t* orq, std::shared_ptr<RIP> rip) {\n        DR_LOG(log_debug) << \"SipDialogController::addRIP adding orq \" << std::hex << (void*) orq  ;\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        m_mapOrq2RIP.insert( mapOrq2RIP::value_type(orq,rip)) ;\n    }\n    bool SipDialogController::findRIPByOrq( nta_outgoing_t* orq, std::shared_ptr<RIP>& rip ) {\n        DR_LOG(log_debug) << \"SipDialogController::findRIPByOrq orq \" << std::hex << (void*) orq  ;\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        mapOrq2RIP::iterator it = m_mapOrq2RIP.find( orq ) ;\n        if( m_mapOrq2RIP.end() == it ) return false ;\n        rip = it->second ;\n        return true ;                       \n    }\n    void SipDialogController::clearRIP( nta_outgoing_t* orq ) {\n        DR_LOG(log_debug) << \"SipDialogController::clearRIP clearing orq \" << std::hex << (void*) orq  ;\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        mapOrq2RIP::iterator it = m_mapOrq2RIP.find( orq ) ;\n        nta_outgoing_destroy( orq ) ;\n        if( m_mapOrq2RIP.end() == it ) return  ;\n        m_mapOrq2RIP.erase( it ) ;                      \n    }\n    \n    void SipDialogController::retransmitFinalResponse( nta_incoming_t* irq, tport_t* tp, std::shared_ptr<SipDialog> dlg) {\n        DR_LOG(log_debug) << \"SipDialogController::retransmitFinalResponse irq:\" << std::hex << (void*) irq;\n        incoming_retransmit_reply(irq, tp);\n\n        // set next timer\n        uint32_t ms = dlg->bumpTimerG() ;\n        TimerEventHandle t = m_pTQM->addTimer(\"timerG\", \n            std::bind(&SipDialogController::retransmitFinalResponse, this, irq, tp, dlg), NULL, ms ) ;\n        dlg->setTimerG(t) ;\n    }\n\n    /**\n     * timer H went off.  Stop timer G (retransmits of 200 OK) and clear it and timer H\n     */\n    void SipDialogController::endRetransmitFinalResponse( nta_incoming_t* irq, tport_t* tp, std::shared_ptr<SipDialog> dlg) {\n        DR_LOG(log_error) << \"SipDialogController::endRetransmitFinalResponse - never received ACK for final response to incoming INVITE; irq:\" << \n            std::hex << (void*) irq << \" source address was \" << dlg->getSourceAddress() ;\n\n        nta_leg_t* leg = const_cast<nta_leg_t *>(dlg->getNtaLeg());\n        TimerEventHandle h = dlg->getTimerG() ;\n        if( h ) {\n            m_pTQM->removeTimer( h, \"timerG\");\n            dlg->clearTimerG();\n        }\n        h = dlg->getTimerH() ;\n        if (h) {\n            dlg->clearTimerH();\n        }\n\n        IIP_Clear(m_invitesInProgress, leg);\n\n\n        // we never got the ACK, so now we should tear down the call by sending a BYE\n        // TODO: also need to remove dialog from hash table\n        nta_outgoing_t* orq = nta_outgoing_tcreate( leg, NULL, NULL,\n                                NULL,\n                                SIP_METHOD_BYE,\n                                NULL,\n                                SIPTAG_REASON_STR(\"SIP ;cause=200 ;text=\\\"ACK timeout\\\"\"),\n                                TAG_END() ) ;\n\n        msg_t* m = nta_outgoing_getrequest(orq) ;  // adds a reference\n        sip_t* sip = sip_object( m ) ;\n\n        DR_LOG(log_info) << \"SipDialogController::endRetransmitFinalResponse - created orq \" << std::hex << (void *) orq \n            << \" for BYE on leg \" << (void *)leg;\n\n        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{\"method\", \"BYE\"}})\n\n        string encodedMessage ;\n        EncodeStackMessage( sip, encodedMessage ) ;\n        SipMsgData_t meta(m, orq) ;\n        string s ;\n        meta.toMessageFormat(s) ;\n\n        m_pController->getClientController()->route_request_inside_dialog( encodedMessage, meta, sip, \"unsolicited\", dlg->getDialogId() ) ;\n\n        msg_destroy( m ); // release the reference\n\n        nta_outgoing_destroy(orq) ;\n        SD_Clear(m_dialogs, leg);\n    }\n    void SipDialogController::addIncomingRequestTransaction( nta_incoming_t* irq, const string& transactionId) {\n        DR_LOG(log_error) << \"SipDialogController::addIncomingRequestTransaction - adding transactionId \" << transactionId << \" for irq:\" << std::hex << (void*) irq;\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        m_mapTransactionId2Irq.insert( mapTransactionId2Irq::value_type(transactionId, irq)) ;\n    }\n    bool SipDialogController::findIrqByTransactionId( const string& transactionId, nta_incoming_t*& irq ) {\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        mapTransactionId2Irq::iterator it = m_mapTransactionId2Irq.find( transactionId ) ;\n        if( m_mapTransactionId2Irq.end() == it ) return false ;\n        irq = it->second ;\n        return true ;                       \n    }\n    nta_incoming_t* SipDialogController::findAndRemoveTransactionIdForIncomingRequest( const string& transactionId ) {\n        DR_LOG(log_debug) << \"SipDialogController::findAndRemoveTransactionIdForIncomingRequest - searching transactionId \" << transactionId ;\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        nta_incoming_t* irq = nullptr ;\n        mapTransactionId2Irq::iterator it = m_mapTransactionId2Irq.find( transactionId ) ;\n        if( m_mapTransactionId2Irq.end() != it ) {\n            irq = it->second ;\n            m_mapTransactionId2Irq.erase( it ) ;\n        }\n        else {\n            DR_LOG(log_debug) << \"SipDialogController::findAndRemoveTransactionIdForIncomingRequest - failed to find transactionId \" << transactionId << \n                \", most likely this is a response to an invite we sent\";\n        }\n        return irq ;\n    }\n\n    void SipDialogController::clearSipTimers(std::shared_ptr<SipDialog>& dlg) {\n        DR_LOG(log_debug) << \"SipDialogController::clearSipTimers for \" << dlg->getCallId()  ;\n        TimerEventHandle h = dlg->getTimerG() ;\n        if( h ) {\n            m_pTQM->removeTimer( h, \"timerG\");  \n            dlg->clearTimerG();\n        }\n        h = dlg->getTimerH() ;\n        if( h ) {\n            m_pTQM->removeTimer( h, \"timerH\"); \n            dlg->clearTimerH();\n        }\n    }\n\n    bool SipDialogController::stopTimerD(nta_outgoing_t* invite) {\n        return m_timerDHandler.clearTimerD(invite);\n    }\n\n    // TimerDHandler\n\n    // when we get a 200 OK to an INVITE we sent, call this to prepare handling timerD\n    void TimerDHandler::addInvite(nta_outgoing_t* invite) {\n        string callIdAndCSeq = combineCallIdAndCSeq(invite);\n        \n        // should never see this twice\n        assert(m_mapCallIdAndCSeq2Invite.end() == m_mapCallIdAndCSeq2Invite.find(callIdAndCSeq));\n\n        // we are waiting for the ACK from the app\n        m_mapCallIdAndCSeq2Invite.insert(mapCallIdAndCSeq2Invite::value_type(callIdAndCSeq, invite));\n\n        // start timerD\n        TimerEventHandle t = m_pTQM->addTimer(\"timerD\", std::bind(&TimerDHandler::timerD, this, invite, callIdAndCSeq), NULL, TIMER_D_MSECS ) ;\n\n        DR_LOG(log_info) << \"TimerDHandler::addInvite orq \" << hex << (void *)invite << \", \" << callIdAndCSeq;\n\n    }\n\n    // ..then, when the app gives us the ACK to send out, call this to save for possible retransmits\n    void TimerDHandler::addAck(nta_outgoing_t* ack) {\n        string callIdAndCSeq = combineCallIdAndCSeq(ack);\n\n        mapCallIdAndCSeq2Invite::const_iterator it = m_mapCallIdAndCSeq2Invite.find(callIdAndCSeq);\n        if (m_mapCallIdAndCSeq2Invite.end() != it) {\n            m_mapInvite2Ack.insert(mapInvite2Ack::value_type(it->second, ack));\n            m_mapCallIdAndCSeq2Invite.erase(it);\n            DR_LOG(log_info) << \"TimerDHandler::addAck \" << hex << (void *)ack << \", \" << callIdAndCSeq;\n        }\n        else {\n            DR_LOG(log_error) << \"TimerDHandler::addAck - failed to find outbound invite we sent for callid \" << nta_outgoing_call_id(ack);\n        }\n    }\n\n    // call this when we received a response to check it if is a retransmitted response\n    bool TimerDHandler::resendIfNeeded(nta_outgoing_t* invite) {\n        mapInvite2Ack::const_iterator it = m_mapInvite2Ack.find(invite);\n        if (it != m_mapInvite2Ack.end()) {\n            outgoing_retransmit(it->second) ;\n            return true;\n        }\n        else if (m_mapCallIdAndCSeq2Invite.size() > 0) {\n            string callIdAndCSeq = combineCallIdAndCSeq(invite);\n            if (m_mapCallIdAndCSeq2Invite.find(callIdAndCSeq) != m_mapCallIdAndCSeq2Invite.end()) {\n                DR_LOG(log_error) << \"TimerDHandler::resendIfNeeded - cannot retransmit ACK because app has not yet provided it \" << nta_outgoing_call_id(invite);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    // this will automatically remove the transactions at the proper time, after timer D has expired\n    void TimerDHandler::timerD(nta_outgoing_t* invite, const string& callIdAndCSeq) {\n        mapCallIdAndCSeq2Invite::const_iterator it = m_mapCallIdAndCSeq2Invite.find(callIdAndCSeq);\n        if (it != m_mapCallIdAndCSeq2Invite.end()) {\n            DR_LOG(log_error) << \"TimerDHandler::timerD - app never sent ACK for successful uac INVITE\"  ;\n            m_mapCallIdAndCSeq2Invite.erase(it);\n        }\n        else {\n            mapInvite2Ack::const_iterator it = m_mapInvite2Ack.find(invite);\n            if (it != m_mapInvite2Ack.end()) {\n                DR_LOG(log_info) << \"TimerDHandler::timerD - freeing ACK orq \" << hex << (void *) it->second <<\n                    \" associated with invite orq \" << invite << \" for call-id/cseq \" << callIdAndCSeq;\n                nta_outgoing_destroy(it->second);\n                m_mapInvite2Ack.erase(it);\n            }\n        }\n    }\n\n    bool TimerDHandler::clearTimerD(nta_outgoing_t* invite) {\n        bool success = false;\n        string callIdAndCSeq = combineCallIdAndCSeq(invite);\n        mapCallIdAndCSeq2Invite::const_iterator it = m_mapCallIdAndCSeq2Invite.find(callIdAndCSeq);\n        if (it != m_mapCallIdAndCSeq2Invite.end()) {\n            DR_LOG(log_error) << \"TimerDHandler::clearTimerD - app never sent ACK for successful uac INVITE\"  ;\n            m_mapCallIdAndCSeq2Invite.erase(it);\n        }\n        else {\n            mapInvite2Ack::const_iterator it = m_mapInvite2Ack.find(invite);\n            if (it != m_mapInvite2Ack.end()) {\n                DR_LOG(log_info) << \"TimerDHandler::clearTimerD - freeing ACK orq \" << hex << (void *) it->second <<\n                    \" associated with invite orq \" << invite << \" for call-id/cseq \" << callIdAndCSeq;\n                nta_outgoing_destroy(it->second);\n                m_mapInvite2Ack.erase(it);\n                success = true;\n            }\n        }\n        return success;\n    }\n\n    // logging / metrics\n    void SipDialogController::logStorageCount(bool bDetail)  {\n\n        DR_LOG(bDetail ? log_info : log_debug) << \"SipDialogController storage counts\"  ;\n        DR_LOG(bDetail ? log_info : log_debug) << \"----------------------------------\"  ;\n        IIP_Log(m_invitesInProgress, bDetail);\n        SD_Log(m_dialogs, bDetail);\n\n        std::lock_guard<std::mutex> lock(m_mutex) ;\n        DR_LOG(bDetail ? log_info : log_debug) << \"m_mapTransactionId2Irq size:                                     \" << m_mapTransactionId2Irq.size()  ;\n        DR_LOG(bDetail ? log_info : log_debug) << \"number of outgoing transactions held for timerD:                 \" << m_timerDHandler.countTimerD()  ;\n        DR_LOG(bDetail ? log_info : log_debug) << \"number of outgoing transactions waiting for ACK from app:        \" << m_timerDHandler.countPending()  ;\n        m_pTQM->logQueueSizes() ;\n\n        // stats\n        if (theOneAndOnlyController->getStatsCollector().enabled()) {\n\n            size_t nUas = 0, nUac = 0;\n            size_t total = SD_Size(m_dialogs, nUac, nUas);\n            STATS_GAUGE_SET_NOCHECK(STATS_GAUGE_STABLE_DIALOGS, nUas, {{\"type\", \"inbound\"}})\n            STATS_GAUGE_SET_NOCHECK(STATS_GAUGE_STABLE_DIALOGS, nUac, {{\"type\", \"outbound\"}})\n        }\n    }\n\n}\n"], "filenames": ["src/drachtio.cpp", "src/sip-dialog-controller.cpp"], "buggy_code_start_loc": [55, 532], "buggy_code_end_loc": [408, 533], "fixing_code_start_loc": [56, 532], "fixing_code_end_loc": [410, 535], "type": "CWE-125", "message": "drachtio-server before 0.8.19 has a heap-based buffer over-read via a long Request-URI in an INVITE request.", "other": {"cve": {"id": "CVE-2022-45909", "sourceIdentifier": "cve@mitre.org", "published": "2022-11-26T03:15:10.633", "lastModified": "2023-02-01T15:26:24.213", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "drachtio-server before 0.8.19 has a heap-based buffer over-read via a long Request-URI in an INVITE request."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:drachtio:drachtio-server:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8.19", "matchCriteriaId": "24320D84-70B3-4A0E-AE01-D5DCF0AD5848"}]}]}], "references": [{"url": "https://github.com/drachtio/drachtio-server/commit/a63d01854987d9fd846cdc9265af38ee9eb72490", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/drachtio/drachtio-server/compare/v0.8.18...v0.8.19", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/drachtio/drachtio-server/pull/238", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/drachtio/drachtio-server/commit/a63d01854987d9fd846cdc9265af38ee9eb72490"}}