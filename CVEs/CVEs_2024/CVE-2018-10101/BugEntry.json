{"buggy_code": ["<?php\n/**\n * Core HTTP Request API\n *\n * Standardizes the HTTP requests for WordPress. Handles cookies, gzip encoding and decoding, chunk\n * decoding, if HTTP 1.1 and various other difficult HTTP protocol implementations.\n *\n * @package WordPress\n * @subpackage HTTP\n */\n\n/**\n * Returns the initialized WP_Http Object\n *\n * @since 2.7.0\n * @access private\n *\n * @staticvar WP_Http $http\n *\n * @return WP_Http HTTP Transport object.\n */\nfunction _wp_http_get_object() {\n\tstatic $http = null;\n\n\tif ( is_null( $http ) ) {\n\t\t$http = new WP_Http();\n\t}\n\treturn $http;\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_request( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->request( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the GET method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_get( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->get( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the POST method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_post( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->post( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the HEAD method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url Site URL to retrieve.\n * @param array $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_head( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->head( $url, $args );\n}\n\n/**\n * Retrieve the raw response from the HTTP request.\n *\n * The array structure is a little complex:\n *\n *     $res = array(\n *         'headers'  => array(),\n *         'response' => array(\n *             'code'    => int,\n *             'message' => string\n *         )\n *     );\n *\n * All of the headers in $res['headers'] are with the name as the key and the\n * value as the value. So to get the User-Agent, you would do the following.\n *\n *     $user_agent = $res['headers']['user-agent'];\n *\n * The body is the raw response content and can be retrieved from $res['body'].\n *\n * This function is called first to make the request and there are other API\n * functions to abstract out the above convoluted setup.\n *\n * Request method defaults for helper functions:\n *  - Default 'GET'  for wp_remote_get()\n *  - Default 'POST' for wp_remote_post()\n *  - Default 'HEAD' for wp_remote_head()\n *\n * @since 2.7.0\n *\n * @see WP_Http::request() For additional information on default arguments.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_request( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->request( $url, $args );\n}\n\n/**\n * Retrieve the raw response from the HTTP request using the GET method.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_get( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->get( $url, $args );\n}\n\n/**\n * Retrieve the raw response from the HTTP request using the POST method.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_post( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->post( $url, $args );\n}\n\n/**\n * Retrieve the raw response from the HTTP request using the HEAD method.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_head( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->head( $url, $args );\n}\n\n/**\n * Retrieve only the headers from the raw response.\n *\n * @since 2.7.0\n * @since 4.6.0 Return value changed from an array to an Requests_Utility_CaseInsensitiveDictionary instance.\n *\n * @see \\Requests_Utility_CaseInsensitiveDictionary\n *\n * @param array $response HTTP response.\n * @return array|\\Requests_Utility_CaseInsensitiveDictionary The headers of the response. Empty array if incorrect parameter given.\n */\nfunction wp_remote_retrieve_headers( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['headers'] ) ) {\n\t\treturn array();\n\t}\n\n\treturn $response['headers'];\n}\n\n/**\n * Retrieve a single header by name from the raw response.\n *\n * @since 2.7.0\n *\n * @param array  $response\n * @param string $header Header name to retrieve value from.\n * @return string The header value. Empty string on if incorrect parameter given, or if the header doesn't exist.\n */\nfunction wp_remote_retrieve_header( $response, $header ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['headers'] ) ) {\n\t\treturn '';\n\t}\n\n\tif ( isset( $response['headers'][ $header ] ) ) {\n\t\treturn $response['headers'][ $header ];\n\t}\n\n\treturn '';\n}\n\n/**\n * Retrieve only the response code from the raw response.\n *\n * Will return an empty array if incorrect parameter value is given.\n *\n * @since 2.7.0\n *\n * @param array $response HTTP response.\n * @return int|string The response code as an integer. Empty string on incorrect parameter given.\n */\nfunction wp_remote_retrieve_response_code( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['response'] ) || ! is_array( $response['response'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['response']['code'];\n}\n\n/**\n * Retrieve only the response message from the raw response.\n *\n * Will return an empty array if incorrect parameter value is given.\n *\n * @since 2.7.0\n *\n * @param array $response HTTP response.\n * @return string The response message. Empty string on incorrect parameter given.\n */\nfunction wp_remote_retrieve_response_message( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['response'] ) || ! is_array( $response['response'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['response']['message'];\n}\n\n/**\n * Retrieve only the body from the raw response.\n *\n * @since 2.7.0\n *\n * @param array $response HTTP response.\n * @return string The body of the response. Empty string if no body or incorrect parameter given.\n */\nfunction wp_remote_retrieve_body( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['body'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['body'];\n}\n\n/**\n * Retrieve only the cookies from the raw response.\n *\n * @since 4.4.0\n *\n * @param array $response HTTP response.\n * @return array An array of `WP_Http_Cookie` objects from the response. Empty array if there are none, or the response is a WP_Error.\n */\nfunction wp_remote_retrieve_cookies( $response ) {\n\tif ( is_wp_error( $response ) || empty( $response['cookies'] ) ) {\n\t\treturn array();\n\t}\n\n\treturn $response['cookies'];\n}\n\n/**\n * Retrieve a single cookie by name from the raw response.\n *\n * @since 4.4.0\n *\n * @param array  $response HTTP response.\n * @param string $name     The name of the cookie to retrieve.\n * @return WP_Http_Cookie|string The `WP_Http_Cookie` object. Empty string if the cookie isn't present in the response.\n */\nfunction wp_remote_retrieve_cookie( $response, $name ) {\n\t$cookies = wp_remote_retrieve_cookies( $response );\n\n\tif ( empty( $cookies ) ) {\n\t\treturn '';\n\t}\n\n\tforeach ( $cookies as $cookie ) {\n\t\tif ( $cookie->name === $name ) {\n\t\t\treturn $cookie;\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Retrieve a single cookie's value by name from the raw response.\n *\n * @since 4.4.0\n *\n * @param array  $response HTTP response.\n * @param string $name     The name of the cookie to retrieve.\n * @return string The value of the cookie. Empty string if the cookie isn't present in the response.\n */\nfunction wp_remote_retrieve_cookie_value( $response, $name ) {\n\t$cookie = wp_remote_retrieve_cookie( $response, $name );\n\n\tif ( ! is_a( $cookie, 'WP_Http_Cookie' ) ) {\n\t\treturn '';\n\t}\n\n\treturn $cookie->value;\n}\n\n/**\n * Determines if there is an HTTP Transport that can process this request.\n *\n * @since 3.2.0\n *\n * @param array  $capabilities Array of capabilities to test or a wp_remote_request() $args array.\n * @param string $url          Optional. If given, will check if the URL requires SSL and adds\n *                             that requirement to the capabilities array.\n *\n * @return bool\n */\nfunction wp_http_supports( $capabilities = array(), $url = null ) {\n\t$http = _wp_http_get_object();\n\n\t$capabilities = wp_parse_args( $capabilities );\n\n\t$count = count( $capabilities );\n\n\t// If we have a numeric $capabilities array, spoof a wp_remote_request() associative $args array\n\tif ( $count && count( array_filter( array_keys( $capabilities ), 'is_numeric' ) ) == $count ) {\n\t\t$capabilities = array_combine( array_values( $capabilities ), array_fill( 0, $count, true ) );\n\t}\n\n\tif ( $url && ! isset( $capabilities['ssl'] ) ) {\n\t\t$scheme = parse_url( $url, PHP_URL_SCHEME );\n\t\tif ( 'https' == $scheme || 'ssl' == $scheme ) {\n\t\t\t$capabilities['ssl'] = true;\n\t\t}\n\t}\n\n\treturn (bool) $http->_get_first_available_transport( $capabilities );\n}\n\n/**\n * Get the HTTP Origin of the current request.\n *\n * @since 3.4.0\n *\n * @return string URL of the origin. Empty string if no origin.\n */\nfunction get_http_origin() {\n\t$origin = '';\n\tif ( ! empty( $_SERVER['HTTP_ORIGIN'] ) ) {\n\t\t$origin = $_SERVER['HTTP_ORIGIN'];\n\t}\n\n\t/**\n\t * Change the origin of an HTTP request.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param string $origin The original origin for the request.\n\t */\n\treturn apply_filters( 'http_origin', $origin );\n}\n\n/**\n * Retrieve list of allowed HTTP origins.\n *\n * @since 3.4.0\n *\n * @return array Array of origin URLs.\n */\nfunction get_allowed_http_origins() {\n\t$admin_origin = parse_url( admin_url() );\n\t$home_origin  = parse_url( home_url() );\n\n\t// @todo preserve port?\n\t$allowed_origins = array_unique(\n\t\tarray(\n\t\t\t'http://' . $admin_origin['host'],\n\t\t\t'https://' . $admin_origin['host'],\n\t\t\t'http://' . $home_origin['host'],\n\t\t\t'https://' . $home_origin['host'],\n\t\t)\n\t);\n\n\t/**\n\t * Change the origin types allowed for HTTP requests.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param array $allowed_origins {\n\t *     Default allowed HTTP origins.\n\t *     @type string Non-secure URL for admin origin.\n\t *     @type string Secure URL for admin origin.\n\t *     @type string Non-secure URL for home origin.\n\t *     @type string Secure URL for home origin.\n\t * }\n\t */\n\treturn apply_filters( 'allowed_http_origins', $allowed_origins );\n}\n\n/**\n * Determines if the HTTP origin is an authorized one.\n *\n * @since 3.4.0\n *\n * @param null|string $origin Origin URL. If not provided, the value of get_http_origin() is used.\n * @return string Origin URL if allowed, empty string if not.\n */\nfunction is_allowed_http_origin( $origin = null ) {\n\t$origin_arg = $origin;\n\n\tif ( null === $origin ) {\n\t\t$origin = get_http_origin();\n\t}\n\n\tif ( $origin && ! in_array( $origin, get_allowed_http_origins() ) ) {\n\t\t$origin = '';\n\t}\n\n\t/**\n\t * Change the allowed HTTP origin result.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param string $origin     Origin URL if allowed, empty string if not.\n\t * @param string $origin_arg Original origin string passed into is_allowed_http_origin function.\n\t */\n\treturn apply_filters( 'allowed_http_origin', $origin, $origin_arg );\n}\n\n/**\n * Send Access-Control-Allow-Origin and related headers if the current request\n * is from an allowed origin.\n *\n * If the request is an OPTIONS request, the script exits with either access\n * control headers sent, or a 403 response if the origin is not allowed. For\n * other request methods, you will receive a return value.\n *\n * @since 3.4.0\n *\n * @return string|false Returns the origin URL if headers are sent. Returns false\n *                      if headers are not sent.\n */\nfunction send_origin_headers() {\n\t$origin = get_http_origin();\n\n\tif ( is_allowed_http_origin( $origin ) ) {\n\t\t@header( 'Access-Control-Allow-Origin: ' . $origin );\n\t\t@header( 'Access-Control-Allow-Credentials: true' );\n\t\tif ( 'OPTIONS' === $_SERVER['REQUEST_METHOD'] ) {\n\t\t\texit;\n\t\t}\n\t\treturn $origin;\n\t}\n\n\tif ( 'OPTIONS' === $_SERVER['REQUEST_METHOD'] ) {\n\t\tstatus_header( 403 );\n\t\texit;\n\t}\n\n\treturn false;\n}\n\n/**\n * Validate a URL for safe use in the HTTP API.\n *\n * @since 3.5.2\n *\n * @param string $url\n * @return false|string URL or false on failure.\n */\nfunction wp_http_validate_url( $url ) {\n\t$original_url = $url;\n\t$url          = wp_kses_bad_protocol( $url, array( 'http', 'https' ) );\n\tif ( ! $url || strtolower( $url ) !== strtolower( $original_url ) ) {\n\t\treturn false;\n\t}\n\n\t$parsed_url = @parse_url( $url );\n\tif ( ! $parsed_url || empty( $parsed_url['host'] ) ) {\n\t\treturn false;\n\t}\n\n\tif ( isset( $parsed_url['user'] ) || isset( $parsed_url['pass'] ) ) {\n\t\treturn false;\n\t}\n\n\tif ( false !== strpbrk( $parsed_url['host'], ':#?[]' ) ) {\n\t\treturn false;\n\t}\n\n\t$parsed_home = @parse_url( get_option( 'home' ) );\n\n\tif ( isset( $parsed_home['host'] ) ) {\n\t\t$same_host = ( strtolower( $parsed_home['host'] ) === strtolower( $parsed_url['host'] ) || 'localhost' === strtolower( $parsed_url['host'] ) );\n\t} else {\n\t\t$same_host = false;\n\t}\n\n\tif ( ! $same_host ) {\n\t\t$host = trim( $parsed_url['host'], '.' );\n\t\tif ( preg_match( '#^(([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)\\.){3}([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)$#', $host ) ) {\n\t\t\t$ip = $host;\n\t\t} else {\n\t\t\t$ip = gethostbyname( $host );\n\t\t\tif ( $ip === $host ) { // Error condition for gethostbyname()\n\t\t\t\t$ip = false;\n\t\t\t}\n\t\t}\n\t\tif ( $ip ) {\n\t\t\t$parts = array_map( 'intval', explode( '.', $ip ) );\n\t\t\tif ( 127 === $parts[0] || 10 === $parts[0] || 0 === $parts[0]\n\t\t\t\t|| ( 172 === $parts[0] && 16 <= $parts[1] && 31 >= $parts[1] )\n\t\t\t\t|| ( 192 === $parts[0] && 168 === $parts[1] )\n\t\t\t) {\n\t\t\t\t// If host appears local, reject unless specifically allowed.\n\t\t\t\t/**\n\t\t\t\t * Check if HTTP request is external or not.\n\t\t\t\t *\n\t\t\t\t * Allows to change and allow external requests for the HTTP request.\n\t\t\t\t *\n\t\t\t\t * @since 3.6.0\n\t\t\t\t *\n\t\t\t\t * @param bool   false Whether HTTP request is external or not.\n\t\t\t\t * @param string $host IP of the requested host.\n\t\t\t\t * @param string $url  URL of the requested host.\n\t\t\t\t */\n\t\t\t\tif ( ! apply_filters( 'http_request_host_is_external', false, $host, $url ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( empty( $parsed_url['port'] ) ) {\n\t\treturn $url;\n\t}\n\n\t$port = $parsed_url['port'];\n\tif ( 80 === $port || 443 === $port || 8080 === $port ) {\n\t\treturn $url;\n\t}\n\n\tif ( $parsed_home && $same_host && isset( $parsed_home['port'] ) && $parsed_home['port'] === $port ) {\n\t\treturn $url;\n\t}\n\n\treturn false;\n}\n\n/**\n * Whitelists allowed redirect hosts for safe HTTP requests as well.\n *\n * Attached to the {@see 'http_request_host_is_external'} filter.\n *\n * @since 3.6.0\n *\n * @param bool   $is_external\n * @param string $host\n * @return bool\n */\nfunction allowed_http_request_hosts( $is_external, $host ) {\n\tif ( ! $is_external && wp_validate_redirect( 'http://' . $host ) ) {\n\t\t$is_external = true;\n\t}\n\treturn $is_external;\n}\n\n/**\n * Whitelists any domain in a multisite installation for safe HTTP requests.\n *\n * Attached to the {@see 'http_request_host_is_external'} filter.\n *\n * @since 3.6.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n * @staticvar array $queried\n *\n * @param bool   $is_external\n * @param string $host\n * @return bool\n */\nfunction ms_allowed_http_request_hosts( $is_external, $host ) {\n\tglobal $wpdb;\n\tstatic $queried = array();\n\tif ( $is_external ) {\n\t\treturn $is_external;\n\t}\n\tif ( $host === get_network()->domain ) {\n\t\treturn true;\n\t}\n\tif ( isset( $queried[ $host ] ) ) {\n\t\treturn $queried[ $host ];\n\t}\n\t$queried[ $host ] = (bool) $wpdb->get_var( $wpdb->prepare( \"SELECT domain FROM $wpdb->blogs WHERE domain = %s LIMIT 1\", $host ) );\n\treturn $queried[ $host ];\n}\n\n/**\n * A wrapper for PHP's parse_url() function that handles consistency in the return\n * values across PHP versions.\n *\n * PHP 5.4.7 expanded parse_url()'s ability to handle non-absolute url's, including\n * schemeless and relative url's with :// in the path. This function works around\n * those limitations providing a standard output on PHP 5.2~5.4+.\n *\n * Secondly, across various PHP versions, schemeless URLs starting containing a \":\"\n * in the query are being handled inconsistently. This function works around those\n * differences as well.\n *\n * Error suppression is used as prior to PHP 5.3.3, an E_WARNING would be generated\n * when URL parsing failed.\n *\n * @since 4.4.0\n * @since 4.7.0 The `$component` parameter was added for parity with PHP's `parse_url()`.\n *\n * @link https://secure.php.net/manual/en/function.parse-url.php\n *\n * @param string $url       The URL to parse.\n * @param int    $component The specific component to retrieve. Use one of the PHP\n *                          predefined constants to specify which one.\n *                          Defaults to -1 (= return all parts as an array).\n * @return mixed False on parse failure; Array of URL components on success;\n *               When a specific component has been requested: null if the component\n *               doesn't exist in the given URL; a string or - in the case of\n *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n */\nfunction wp_parse_url( $url, $component = -1 ) {\n\t$to_unset = array();\n\t$url      = strval( $url );\n\n\tif ( '//' === substr( $url, 0, 2 ) ) {\n\t\t$to_unset[] = 'scheme';\n\t\t$url        = 'placeholder:' . $url;\n\t} elseif ( '/' === substr( $url, 0, 1 ) ) {\n\t\t$to_unset[] = 'scheme';\n\t\t$to_unset[] = 'host';\n\t\t$url        = 'placeholder://placeholder' . $url;\n\t}\n\n\t$parts = @parse_url( $url );\n\n\tif ( false === $parts ) {\n\t\t// Parsing failure.\n\t\treturn $parts;\n\t}\n\n\t// Remove the placeholder values.\n\tforeach ( $to_unset as $key ) {\n\t\tunset( $parts[ $key ] );\n\t}\n\n\treturn _get_component_from_parsed_url_array( $parts, $component );\n}\n\n/**\n * Retrieve a specific component from a parsed URL array.\n *\n * @internal\n *\n * @since 4.7.0\n * @access private\n *\n * @link https://secure.php.net/manual/en/function.parse-url.php\n *\n * @param array|false $url_parts The parsed URL. Can be false if the URL failed to parse.\n * @param int    $component The specific component to retrieve. Use one of the PHP\n *                          predefined constants to specify which one.\n *                          Defaults to -1 (= return all parts as an array).\n * @return mixed False on parse failure; Array of URL components on success;\n *               When a specific component has been requested: null if the component\n *               doesn't exist in the given URL; a string or - in the case of\n *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n */\nfunction _get_component_from_parsed_url_array( $url_parts, $component = -1 ) {\n\tif ( -1 === $component ) {\n\t\treturn $url_parts;\n\t}\n\n\t$key = _wp_translate_php_url_constant_to_key( $component );\n\tif ( false !== $key && is_array( $url_parts ) && isset( $url_parts[ $key ] ) ) {\n\t\treturn $url_parts[ $key ];\n\t} else {\n\t\treturn null;\n\t}\n}\n\n/**\n * Translate a PHP_URL_* constant to the named array keys PHP uses.\n *\n * @internal\n *\n * @since 4.7.0\n * @access private\n *\n * @link https://secure.php.net/manual/en/url.constants.php\n *\n * @param int $constant PHP_URL_* constant.\n * @return string|bool The named key or false.\n */\nfunction _wp_translate_php_url_constant_to_key( $constant ) {\n\t$translation = array(\n\t\tPHP_URL_SCHEME   => 'scheme',\n\t\tPHP_URL_HOST     => 'host',\n\t\tPHP_URL_PORT     => 'port',\n\t\tPHP_URL_USER     => 'user',\n\t\tPHP_URL_PASS     => 'pass',\n\t\tPHP_URL_PATH     => 'path',\n\t\tPHP_URL_QUERY    => 'query',\n\t\tPHP_URL_FRAGMENT => 'fragment',\n\t);\n\n\tif ( isset( $translation[ $constant ] ) ) {\n\t\treturn $translation[ $constant ];\n\t} else {\n\t\treturn false;\n\t}\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.0-alpha-42893';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 42836;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4607-20180123';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "fixing_code": ["<?php\n/**\n * Core HTTP Request API\n *\n * Standardizes the HTTP requests for WordPress. Handles cookies, gzip encoding and decoding, chunk\n * decoding, if HTTP 1.1 and various other difficult HTTP protocol implementations.\n *\n * @package WordPress\n * @subpackage HTTP\n */\n\n/**\n * Returns the initialized WP_Http Object\n *\n * @since 2.7.0\n * @access private\n *\n * @staticvar WP_Http $http\n *\n * @return WP_Http HTTP Transport object.\n */\nfunction _wp_http_get_object() {\n\tstatic $http = null;\n\n\tif ( is_null( $http ) ) {\n\t\t$http = new WP_Http();\n\t}\n\treturn $http;\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_request( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->request( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the GET method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_get( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->get( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the POST method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_post( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->post( $url, $args );\n}\n\n/**\n * Retrieve the raw response from a safe HTTP request using the HEAD method.\n *\n * This function is ideal when the HTTP request is being made to an arbitrary\n * URL. The URL is validated to avoid redirection and request forgery attacks.\n *\n * @since 3.6.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url Site URL to retrieve.\n * @param array $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_safe_remote_head( $url, $args = array() ) {\n\t$args['reject_unsafe_urls'] = true;\n\t$http                       = _wp_http_get_object();\n\treturn $http->head( $url, $args );\n}\n\n/**\n * Retrieve the raw response from the HTTP request.\n *\n * The array structure is a little complex:\n *\n *     $res = array(\n *         'headers'  => array(),\n *         'response' => array(\n *             'code'    => int,\n *             'message' => string\n *         )\n *     );\n *\n * All of the headers in $res['headers'] are with the name as the key and the\n * value as the value. So to get the User-Agent, you would do the following.\n *\n *     $user_agent = $res['headers']['user-agent'];\n *\n * The body is the raw response content and can be retrieved from $res['body'].\n *\n * This function is called first to make the request and there are other API\n * functions to abstract out the above convoluted setup.\n *\n * Request method defaults for helper functions:\n *  - Default 'GET'  for wp_remote_get()\n *  - Default 'POST' for wp_remote_post()\n *  - Default 'HEAD' for wp_remote_head()\n *\n * @since 2.7.0\n *\n * @see WP_Http::request() For additional information on default arguments.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_request( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->request( $url, $args );\n}\n\n/**\n * Retrieve the raw response from the HTTP request using the GET method.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_get( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->get( $url, $args );\n}\n\n/**\n * Retrieve the raw response from the HTTP request using the POST method.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_post( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->post( $url, $args );\n}\n\n/**\n * Retrieve the raw response from the HTTP request using the HEAD method.\n *\n * @since 2.7.0\n *\n * @see wp_remote_request() For more information on the response array format.\n * @see WP_Http::request() For default arguments information.\n *\n * @param string $url  Site URL to retrieve.\n * @param array  $args Optional. Request arguments. Default empty array.\n * @return WP_Error|array The response or WP_Error on failure.\n */\nfunction wp_remote_head( $url, $args = array() ) {\n\t$http = _wp_http_get_object();\n\treturn $http->head( $url, $args );\n}\n\n/**\n * Retrieve only the headers from the raw response.\n *\n * @since 2.7.0\n * @since 4.6.0 Return value changed from an array to an Requests_Utility_CaseInsensitiveDictionary instance.\n *\n * @see \\Requests_Utility_CaseInsensitiveDictionary\n *\n * @param array $response HTTP response.\n * @return array|\\Requests_Utility_CaseInsensitiveDictionary The headers of the response. Empty array if incorrect parameter given.\n */\nfunction wp_remote_retrieve_headers( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['headers'] ) ) {\n\t\treturn array();\n\t}\n\n\treturn $response['headers'];\n}\n\n/**\n * Retrieve a single header by name from the raw response.\n *\n * @since 2.7.0\n *\n * @param array  $response\n * @param string $header Header name to retrieve value from.\n * @return string The header value. Empty string on if incorrect parameter given, or if the header doesn't exist.\n */\nfunction wp_remote_retrieve_header( $response, $header ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['headers'] ) ) {\n\t\treturn '';\n\t}\n\n\tif ( isset( $response['headers'][ $header ] ) ) {\n\t\treturn $response['headers'][ $header ];\n\t}\n\n\treturn '';\n}\n\n/**\n * Retrieve only the response code from the raw response.\n *\n * Will return an empty array if incorrect parameter value is given.\n *\n * @since 2.7.0\n *\n * @param array $response HTTP response.\n * @return int|string The response code as an integer. Empty string on incorrect parameter given.\n */\nfunction wp_remote_retrieve_response_code( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['response'] ) || ! is_array( $response['response'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['response']['code'];\n}\n\n/**\n * Retrieve only the response message from the raw response.\n *\n * Will return an empty array if incorrect parameter value is given.\n *\n * @since 2.7.0\n *\n * @param array $response HTTP response.\n * @return string The response message. Empty string on incorrect parameter given.\n */\nfunction wp_remote_retrieve_response_message( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['response'] ) || ! is_array( $response['response'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['response']['message'];\n}\n\n/**\n * Retrieve only the body from the raw response.\n *\n * @since 2.7.0\n *\n * @param array $response HTTP response.\n * @return string The body of the response. Empty string if no body or incorrect parameter given.\n */\nfunction wp_remote_retrieve_body( $response ) {\n\tif ( is_wp_error( $response ) || ! isset( $response['body'] ) ) {\n\t\treturn '';\n\t}\n\n\treturn $response['body'];\n}\n\n/**\n * Retrieve only the cookies from the raw response.\n *\n * @since 4.4.0\n *\n * @param array $response HTTP response.\n * @return array An array of `WP_Http_Cookie` objects from the response. Empty array if there are none, or the response is a WP_Error.\n */\nfunction wp_remote_retrieve_cookies( $response ) {\n\tif ( is_wp_error( $response ) || empty( $response['cookies'] ) ) {\n\t\treturn array();\n\t}\n\n\treturn $response['cookies'];\n}\n\n/**\n * Retrieve a single cookie by name from the raw response.\n *\n * @since 4.4.0\n *\n * @param array  $response HTTP response.\n * @param string $name     The name of the cookie to retrieve.\n * @return WP_Http_Cookie|string The `WP_Http_Cookie` object. Empty string if the cookie isn't present in the response.\n */\nfunction wp_remote_retrieve_cookie( $response, $name ) {\n\t$cookies = wp_remote_retrieve_cookies( $response );\n\n\tif ( empty( $cookies ) ) {\n\t\treturn '';\n\t}\n\n\tforeach ( $cookies as $cookie ) {\n\t\tif ( $cookie->name === $name ) {\n\t\t\treturn $cookie;\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Retrieve a single cookie's value by name from the raw response.\n *\n * @since 4.4.0\n *\n * @param array  $response HTTP response.\n * @param string $name     The name of the cookie to retrieve.\n * @return string The value of the cookie. Empty string if the cookie isn't present in the response.\n */\nfunction wp_remote_retrieve_cookie_value( $response, $name ) {\n\t$cookie = wp_remote_retrieve_cookie( $response, $name );\n\n\tif ( ! is_a( $cookie, 'WP_Http_Cookie' ) ) {\n\t\treturn '';\n\t}\n\n\treturn $cookie->value;\n}\n\n/**\n * Determines if there is an HTTP Transport that can process this request.\n *\n * @since 3.2.0\n *\n * @param array  $capabilities Array of capabilities to test or a wp_remote_request() $args array.\n * @param string $url          Optional. If given, will check if the URL requires SSL and adds\n *                             that requirement to the capabilities array.\n *\n * @return bool\n */\nfunction wp_http_supports( $capabilities = array(), $url = null ) {\n\t$http = _wp_http_get_object();\n\n\t$capabilities = wp_parse_args( $capabilities );\n\n\t$count = count( $capabilities );\n\n\t// If we have a numeric $capabilities array, spoof a wp_remote_request() associative $args array\n\tif ( $count && count( array_filter( array_keys( $capabilities ), 'is_numeric' ) ) == $count ) {\n\t\t$capabilities = array_combine( array_values( $capabilities ), array_fill( 0, $count, true ) );\n\t}\n\n\tif ( $url && ! isset( $capabilities['ssl'] ) ) {\n\t\t$scheme = parse_url( $url, PHP_URL_SCHEME );\n\t\tif ( 'https' == $scheme || 'ssl' == $scheme ) {\n\t\t\t$capabilities['ssl'] = true;\n\t\t}\n\t}\n\n\treturn (bool) $http->_get_first_available_transport( $capabilities );\n}\n\n/**\n * Get the HTTP Origin of the current request.\n *\n * @since 3.4.0\n *\n * @return string URL of the origin. Empty string if no origin.\n */\nfunction get_http_origin() {\n\t$origin = '';\n\tif ( ! empty( $_SERVER['HTTP_ORIGIN'] ) ) {\n\t\t$origin = $_SERVER['HTTP_ORIGIN'];\n\t}\n\n\t/**\n\t * Change the origin of an HTTP request.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param string $origin The original origin for the request.\n\t */\n\treturn apply_filters( 'http_origin', $origin );\n}\n\n/**\n * Retrieve list of allowed HTTP origins.\n *\n * @since 3.4.0\n *\n * @return array Array of origin URLs.\n */\nfunction get_allowed_http_origins() {\n\t$admin_origin = parse_url( admin_url() );\n\t$home_origin  = parse_url( home_url() );\n\n\t// @todo preserve port?\n\t$allowed_origins = array_unique(\n\t\tarray(\n\t\t\t'http://' . $admin_origin['host'],\n\t\t\t'https://' . $admin_origin['host'],\n\t\t\t'http://' . $home_origin['host'],\n\t\t\t'https://' . $home_origin['host'],\n\t\t)\n\t);\n\n\t/**\n\t * Change the origin types allowed for HTTP requests.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param array $allowed_origins {\n\t *     Default allowed HTTP origins.\n\t *     @type string Non-secure URL for admin origin.\n\t *     @type string Secure URL for admin origin.\n\t *     @type string Non-secure URL for home origin.\n\t *     @type string Secure URL for home origin.\n\t * }\n\t */\n\treturn apply_filters( 'allowed_http_origins', $allowed_origins );\n}\n\n/**\n * Determines if the HTTP origin is an authorized one.\n *\n * @since 3.4.0\n *\n * @param null|string $origin Origin URL. If not provided, the value of get_http_origin() is used.\n * @return string Origin URL if allowed, empty string if not.\n */\nfunction is_allowed_http_origin( $origin = null ) {\n\t$origin_arg = $origin;\n\n\tif ( null === $origin ) {\n\t\t$origin = get_http_origin();\n\t}\n\n\tif ( $origin && ! in_array( $origin, get_allowed_http_origins() ) ) {\n\t\t$origin = '';\n\t}\n\n\t/**\n\t * Change the allowed HTTP origin result.\n\t *\n\t * @since 3.4.0\n\t *\n\t * @param string $origin     Origin URL if allowed, empty string if not.\n\t * @param string $origin_arg Original origin string passed into is_allowed_http_origin function.\n\t */\n\treturn apply_filters( 'allowed_http_origin', $origin, $origin_arg );\n}\n\n/**\n * Send Access-Control-Allow-Origin and related headers if the current request\n * is from an allowed origin.\n *\n * If the request is an OPTIONS request, the script exits with either access\n * control headers sent, or a 403 response if the origin is not allowed. For\n * other request methods, you will receive a return value.\n *\n * @since 3.4.0\n *\n * @return string|false Returns the origin URL if headers are sent. Returns false\n *                      if headers are not sent.\n */\nfunction send_origin_headers() {\n\t$origin = get_http_origin();\n\n\tif ( is_allowed_http_origin( $origin ) ) {\n\t\t@header( 'Access-Control-Allow-Origin: ' . $origin );\n\t\t@header( 'Access-Control-Allow-Credentials: true' );\n\t\tif ( 'OPTIONS' === $_SERVER['REQUEST_METHOD'] ) {\n\t\t\texit;\n\t\t}\n\t\treturn $origin;\n\t}\n\n\tif ( 'OPTIONS' === $_SERVER['REQUEST_METHOD'] ) {\n\t\tstatus_header( 403 );\n\t\texit;\n\t}\n\n\treturn false;\n}\n\n/**\n * Validate a URL for safe use in the HTTP API.\n *\n * @since 3.5.2\n *\n * @param string $url\n * @return false|string URL or false on failure.\n */\nfunction wp_http_validate_url( $url ) {\n\t$original_url = $url;\n\t$url          = wp_kses_bad_protocol( $url, array( 'http', 'https' ) );\n\tif ( ! $url || strtolower( $url ) !== strtolower( $original_url ) ) {\n\t\treturn false;\n\t}\n\n\t$parsed_url = @parse_url( $url );\n\tif ( ! $parsed_url || empty( $parsed_url['host'] ) ) {\n\t\treturn false;\n\t}\n\n\tif ( isset( $parsed_url['user'] ) || isset( $parsed_url['pass'] ) ) {\n\t\treturn false;\n\t}\n\n\tif ( false !== strpbrk( $parsed_url['host'], ':#?[]' ) ) {\n\t\treturn false;\n\t}\n\n\t$parsed_home = @parse_url( get_option( 'home' ) );\n\n\tif ( isset( $parsed_home['host'] ) ) {\n\t\t$same_host = strtolower( $parsed_home['host'] ) === strtolower( $parsed_url['host'] );\n\t} else {\n\t\t$same_host = false;\n\t}\n\n\tif ( ! $same_host ) {\n\t\t$host = trim( $parsed_url['host'], '.' );\n\t\tif ( preg_match( '#^(([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)\\.){3}([1-9]?\\d|1\\d\\d|25[0-5]|2[0-4]\\d)$#', $host ) ) {\n\t\t\t$ip = $host;\n\t\t} else {\n\t\t\t$ip = gethostbyname( $host );\n\t\t\tif ( $ip === $host ) { // Error condition for gethostbyname()\n\t\t\t\t$ip = false;\n\t\t\t}\n\t\t}\n\t\tif ( $ip ) {\n\t\t\t$parts = array_map( 'intval', explode( '.', $ip ) );\n\t\t\tif ( 127 === $parts[0] || 10 === $parts[0] || 0 === $parts[0]\n\t\t\t\t|| ( 172 === $parts[0] && 16 <= $parts[1] && 31 >= $parts[1] )\n\t\t\t\t|| ( 192 === $parts[0] && 168 === $parts[1] )\n\t\t\t) {\n\t\t\t\t// If host appears local, reject unless specifically allowed.\n\t\t\t\t/**\n\t\t\t\t * Check if HTTP request is external or not.\n\t\t\t\t *\n\t\t\t\t * Allows to change and allow external requests for the HTTP request.\n\t\t\t\t *\n\t\t\t\t * @since 3.6.0\n\t\t\t\t *\n\t\t\t\t * @param bool   false Whether HTTP request is external or not.\n\t\t\t\t * @param string $host IP of the requested host.\n\t\t\t\t * @param string $url  URL of the requested host.\n\t\t\t\t */\n\t\t\t\tif ( ! apply_filters( 'http_request_host_is_external', false, $host, $url ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( empty( $parsed_url['port'] ) ) {\n\t\treturn $url;\n\t}\n\n\t$port = $parsed_url['port'];\n\tif ( 80 === $port || 443 === $port || 8080 === $port ) {\n\t\treturn $url;\n\t}\n\n\tif ( $parsed_home && $same_host && isset( $parsed_home['port'] ) && $parsed_home['port'] === $port ) {\n\t\treturn $url;\n\t}\n\n\treturn false;\n}\n\n/**\n * Whitelists allowed redirect hosts for safe HTTP requests as well.\n *\n * Attached to the {@see 'http_request_host_is_external'} filter.\n *\n * @since 3.6.0\n *\n * @param bool   $is_external\n * @param string $host\n * @return bool\n */\nfunction allowed_http_request_hosts( $is_external, $host ) {\n\tif ( ! $is_external && wp_validate_redirect( 'http://' . $host ) ) {\n\t\t$is_external = true;\n\t}\n\treturn $is_external;\n}\n\n/**\n * Whitelists any domain in a multisite installation for safe HTTP requests.\n *\n * Attached to the {@see 'http_request_host_is_external'} filter.\n *\n * @since 3.6.0\n *\n * @global wpdb $wpdb WordPress database abstraction object.\n * @staticvar array $queried\n *\n * @param bool   $is_external\n * @param string $host\n * @return bool\n */\nfunction ms_allowed_http_request_hosts( $is_external, $host ) {\n\tglobal $wpdb;\n\tstatic $queried = array();\n\tif ( $is_external ) {\n\t\treturn $is_external;\n\t}\n\tif ( $host === get_network()->domain ) {\n\t\treturn true;\n\t}\n\tif ( isset( $queried[ $host ] ) ) {\n\t\treturn $queried[ $host ];\n\t}\n\t$queried[ $host ] = (bool) $wpdb->get_var( $wpdb->prepare( \"SELECT domain FROM $wpdb->blogs WHERE domain = %s LIMIT 1\", $host ) );\n\treturn $queried[ $host ];\n}\n\n/**\n * A wrapper for PHP's parse_url() function that handles consistency in the return\n * values across PHP versions.\n *\n * PHP 5.4.7 expanded parse_url()'s ability to handle non-absolute url's, including\n * schemeless and relative url's with :// in the path. This function works around\n * those limitations providing a standard output on PHP 5.2~5.4+.\n *\n * Secondly, across various PHP versions, schemeless URLs starting containing a \":\"\n * in the query are being handled inconsistently. This function works around those\n * differences as well.\n *\n * Error suppression is used as prior to PHP 5.3.3, an E_WARNING would be generated\n * when URL parsing failed.\n *\n * @since 4.4.0\n * @since 4.7.0 The `$component` parameter was added for parity with PHP's `parse_url()`.\n *\n * @link https://secure.php.net/manual/en/function.parse-url.php\n *\n * @param string $url       The URL to parse.\n * @param int    $component The specific component to retrieve. Use one of the PHP\n *                          predefined constants to specify which one.\n *                          Defaults to -1 (= return all parts as an array).\n * @return mixed False on parse failure; Array of URL components on success;\n *               When a specific component has been requested: null if the component\n *               doesn't exist in the given URL; a string or - in the case of\n *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n */\nfunction wp_parse_url( $url, $component = -1 ) {\n\t$to_unset = array();\n\t$url      = strval( $url );\n\n\tif ( '//' === substr( $url, 0, 2 ) ) {\n\t\t$to_unset[] = 'scheme';\n\t\t$url        = 'placeholder:' . $url;\n\t} elseif ( '/' === substr( $url, 0, 1 ) ) {\n\t\t$to_unset[] = 'scheme';\n\t\t$to_unset[] = 'host';\n\t\t$url        = 'placeholder://placeholder' . $url;\n\t}\n\n\t$parts = @parse_url( $url );\n\n\tif ( false === $parts ) {\n\t\t// Parsing failure.\n\t\treturn $parts;\n\t}\n\n\t// Remove the placeholder values.\n\tforeach ( $to_unset as $key ) {\n\t\tunset( $parts[ $key ] );\n\t}\n\n\treturn _get_component_from_parsed_url_array( $parts, $component );\n}\n\n/**\n * Retrieve a specific component from a parsed URL array.\n *\n * @internal\n *\n * @since 4.7.0\n * @access private\n *\n * @link https://secure.php.net/manual/en/function.parse-url.php\n *\n * @param array|false $url_parts The parsed URL. Can be false if the URL failed to parse.\n * @param int    $component The specific component to retrieve. Use one of the PHP\n *                          predefined constants to specify which one.\n *                          Defaults to -1 (= return all parts as an array).\n * @return mixed False on parse failure; Array of URL components on success;\n *               When a specific component has been requested: null if the component\n *               doesn't exist in the given URL; a string or - in the case of\n *               PHP_URL_PORT - integer when it does. See parse_url()'s return values.\n */\nfunction _get_component_from_parsed_url_array( $url_parts, $component = -1 ) {\n\tif ( -1 === $component ) {\n\t\treturn $url_parts;\n\t}\n\n\t$key = _wp_translate_php_url_constant_to_key( $component );\n\tif ( false !== $key && is_array( $url_parts ) && isset( $url_parts[ $key ] ) ) {\n\t\treturn $url_parts[ $key ];\n\t} else {\n\t\treturn null;\n\t}\n}\n\n/**\n * Translate a PHP_URL_* constant to the named array keys PHP uses.\n *\n * @internal\n *\n * @since 4.7.0\n * @access private\n *\n * @link https://secure.php.net/manual/en/url.constants.php\n *\n * @param int $constant PHP_URL_* constant.\n * @return string|bool The named key or false.\n */\nfunction _wp_translate_php_url_constant_to_key( $constant ) {\n\t$translation = array(\n\t\tPHP_URL_SCHEME   => 'scheme',\n\t\tPHP_URL_HOST     => 'host',\n\t\tPHP_URL_PORT     => 'port',\n\t\tPHP_URL_USER     => 'user',\n\t\tPHP_URL_PASS     => 'pass',\n\t\tPHP_URL_PATH     => 'path',\n\t\tPHP_URL_QUERY    => 'query',\n\t\tPHP_URL_FRAGMENT => 'fragment',\n\t);\n\n\tif ( isset( $translation[ $constant ] ) ) {\n\t\treturn $translation[ $constant ];\n\t} else {\n\t\treturn false;\n\t}\n}\n", "<?php\n/**\n * The WordPress version string\n *\n * @global string $wp_version\n */\n$wp_version = '5.0-alpha-42894';\n\n/**\n * Holds the WordPress DB revision, increments when changes are made to the WordPress DB schema.\n *\n * @global int $wp_db_version\n */\n$wp_db_version = 42836;\n\n/**\n * Holds the TinyMCE version\n *\n * @global string $tinymce_version\n */\n$tinymce_version = '4607-20180123';\n\n/**\n * Holds the required PHP version\n *\n * @global string $required_php_version\n */\n$required_php_version = '5.2.4';\n\n/**\n * Holds the required MySQL version\n *\n * @global string $required_mysql_version\n */\n$required_mysql_version = '5.0';\n"], "filenames": ["wp-includes/http.php", "wp-includes/version.php"], "buggy_code_start_loc": [546, 7], "buggy_code_end_loc": [547, 8], "fixing_code_start_loc": [546, 7], "fixing_code_end_loc": [547, 8], "type": "CWE-601", "message": "Before WordPress 4.9.5, the URL validator assumed URLs with the hostname localhost were on the same host as the WordPress server.", "other": {"cve": {"id": "CVE-2018-10101", "sourceIdentifier": "cve@mitre.org", "published": "2018-04-16T09:58:09.620", "lastModified": "2019-03-07T18:56:24.850", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Before WordPress 4.9.5, the URL validator assumed URLs with the hostname localhost were on the same host as the WordPress server."}, {"lang": "es", "value": "En versiones anteriores a la 4.9.5 de WordPress, el validador de URL asum\u00eda URL con el nombre de host del localhost en el mismo host que el servidor de WordPress."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-601"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wordpress:wordpress:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.9.5", "matchCriteriaId": "8F03A691-0741-487D-A951-523B04170F4E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/104350", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.securitytracker.com/id/1040836", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://codex.wordpress.org/Version_4.9.5", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://core.trac.wordpress.org/changeset/42894", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/WordPress/WordPress/commit/804363859602d4050d9a38a21f5a65d9aec18216", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://wordpress.org/news/2018/04/wordpress-4-9-5-security-and-maintenance-release/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://wpvulndb.com/vulnerabilities/9053", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4193", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/WordPress/WordPress/commit/804363859602d4050d9a38a21f5a65d9aec18216"}}