{"buggy_code": ["/*\n *\tLinux NET3:\tInternet Group Management Protocol  [IGMP]\n *\n *\tThis code implements the IGMP protocol as defined in RFC1112. There has\n *\tbeen a further revision of this protocol since which is now supported.\n *\n *\tIf you have trouble with this module be careful what gcc you have used,\n *\tthe older version didn't come out right using gcc 2.5.8, the newer one\n *\tseems to fall out with gcc 2.6.2.\n *\n *\tAuthors:\n *\t\tAlan Cox <alan@lxorguk.ukuu.org.uk>\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n *\n *\tFixes:\n *\n *\t\tAlan Cox\t:\tAdded lots of __inline__ to optimise\n *\t\t\t\t\tthe memory usage of all the tiny little\n *\t\t\t\t\tfunctions.\n *\t\tAlan Cox\t:\tDumped the header building experiment.\n *\t\tAlan Cox\t:\tMinor tweaks ready for multicast routing\n *\t\t\t\t\tand extended IGMP protocol.\n *\t\tAlan Cox\t:\tRemoved a load of inline directives. Gcc 2.5.8\n *\t\t\t\t\twrites utterly bogus code otherwise (sigh)\n *\t\t\t\t\tfixed IGMP loopback to behave in the manner\n *\t\t\t\t\tdesired by mrouted, fixed the fact it has been\n *\t\t\t\t\tbroken since 1.3.6 and cleaned up a few minor\n *\t\t\t\t\tpoints.\n *\n *\t\tChih-Jen Chang\t:\tTried to revise IGMP to Version 2\n *\t\tTsu-Sheng Tsao\t\tE-mail: chihjenc@scf.usc.edu and tsusheng@scf.usc.edu\n *\t\t\t\t\tThe enhancements are mainly based on Steve Deering's\n * \t\t\t\t\tipmulti-3.5 source code.\n *\t\tChih-Jen Chang\t:\tAdded the igmp_get_mrouter_info and\n *\t\tTsu-Sheng Tsao\t\tigmp_set_mrouter_info to keep track of\n *\t\t\t\t\tthe mrouted version on that device.\n *\t\tChih-Jen Chang\t:\tAdded the max_resp_time parameter to\n *\t\tTsu-Sheng Tsao\t\tigmp_heard_query(). Using this parameter\n *\t\t\t\t\tto identify the multicast router version\n *\t\t\t\t\tand do what the IGMP version 2 specified.\n *\t\tChih-Jen Chang\t:\tAdded a timer to revert to IGMP V2 router\n *\t\tTsu-Sheng Tsao\t\tif the specified time expired.\n *\t\tAlan Cox\t:\tStop IGMP from 0.0.0.0 being accepted.\n *\t\tAlan Cox\t:\tUse GFP_ATOMIC in the right places.\n *\t\tChristian Daudt :\tigmp timer wasn't set for local group\n *\t\t\t\t\tmemberships but was being deleted,\n *\t\t\t\t\twhich caused a \"del_timer() called\n *\t\t\t\t\tfrom %p with timer not initialized\\n\"\n *\t\t\t\t\tmessage (960131).\n *\t\tChristian Daudt :\tremoved del_timer from\n *\t\t\t\t\tigmp_timer_expire function (960205).\n *             Christian Daudt :       igmp_heard_report now only calls\n *                                     igmp_timer_expire if tm->running is\n *                                     true (960216).\n *\t\tMalcolm Beattie :\tttl comparison wrong in igmp_rcv made\n *\t\t\t\t\tigmp_heard_query never trigger. Expiry\n *\t\t\t\t\tmiscalculation fixed in igmp_heard_query\n *\t\t\t\t\tand random() made to return unsigned to\n *\t\t\t\t\tprevent negative expiry times.\n *\t\tAlexey Kuznetsov:\tWrong group leaving behaviour, backport\n *\t\t\t\t\tfix from pending 2.1.x patches.\n *\t\tAlan Cox:\t\tForget to enable FDDI support earlier.\n *\t\tAlexey Kuznetsov:\tFixed leaving groups on device down.\n *\t\tAlexey Kuznetsov:\tAccordance to igmp-v2-06 draft.\n *\t\tDavid L Stevens:\tIGMPv3 support, with help from\n *\t\t\t\t\tVinay Kulkarni\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/uaccess.h>\n#include <asm/system.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/if_arp.h>\n#include <linux/rtnetlink.h>\n#include <linux/times.h>\n\n#include <net/net_namespace.h>\n#include <net/arp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/route.h>\n#include <net/sock.h>\n#include <net/checksum.h>\n#include <linux/netfilter_ipv4.h>\n#ifdef CONFIG_IP_MROUTE\n#include <linux/mroute.h>\n#endif\n#ifdef CONFIG_PROC_FS\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#endif\n\n#define IP_MAX_MEMBERSHIPS\t20\n#define IP_MAX_MSF\t\t10\n\n#ifdef CONFIG_IP_MULTICAST\n/* Parameter names and values are taken from igmp-v2-06 draft */\n\n#define IGMP_V1_Router_Present_Timeout\t\t(400*HZ)\n#define IGMP_V2_Router_Present_Timeout\t\t(400*HZ)\n#define IGMP_Unsolicited_Report_Interval\t(10*HZ)\n#define IGMP_Query_Response_Interval\t\t(10*HZ)\n#define IGMP_Unsolicited_Report_Count\t\t2\n\n\n#define IGMP_Initial_Report_Delay\t\t(1)\n\n/* IGMP_Initial_Report_Delay is not from IGMP specs!\n * IGMP specs require to report membership immediately after\n * joining a group, but we delay the first report by a\n * small interval. It seems more natural and still does not\n * contradict to specs provided this delay is small enough.\n */\n\n#define IGMP_V1_SEEN(in_dev) \\\n\t(IPV4_DEVCONF_ALL(dev_net(in_dev->dev), FORCE_IGMP_VERSION) == 1 || \\\n\t IN_DEV_CONF_GET((in_dev), FORCE_IGMP_VERSION) == 1 || \\\n\t ((in_dev)->mr_v1_seen && \\\n\t  time_before(jiffies, (in_dev)->mr_v1_seen)))\n#define IGMP_V2_SEEN(in_dev) \\\n\t(IPV4_DEVCONF_ALL(dev_net(in_dev->dev), FORCE_IGMP_VERSION) == 2 || \\\n\t IN_DEV_CONF_GET((in_dev), FORCE_IGMP_VERSION) == 2 || \\\n\t ((in_dev)->mr_v2_seen && \\\n\t  time_before(jiffies, (in_dev)->mr_v2_seen)))\n\nstatic void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im);\nstatic void igmpv3_del_delrec(struct in_device *in_dev, __be32 multiaddr);\nstatic void igmpv3_clear_delrec(struct in_device *in_dev);\nstatic int sf_setstate(struct ip_mc_list *pmc);\nstatic void sf_markstate(struct ip_mc_list *pmc);\n#endif\nstatic void ip_mc_clear_src(struct ip_mc_list *pmc);\nstatic int ip_mc_add_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\n\t\t\t int sfcount, __be32 *psfsrc, int delta);\n\nstatic void ip_ma_put(struct ip_mc_list *im)\n{\n\tif (atomic_dec_and_test(&im->refcnt)) {\n\t\tin_dev_put(im->interface);\n\t\tkfree_rcu(im, rcu);\n\t}\n}\n\n#define for_each_pmc_rcu(in_dev, pmc)\t\t\t\t\\\n\tfor (pmc = rcu_dereference(in_dev->mc_list);\t\t\\\n\t     pmc != NULL;\t\t\t\t\t\\\n\t     pmc = rcu_dereference(pmc->next_rcu))\n\n#define for_each_pmc_rtnl(in_dev, pmc)\t\t\t\t\\\n\tfor (pmc = rtnl_dereference(in_dev->mc_list);\t\t\\\n\t     pmc != NULL;\t\t\t\t\t\\\n\t     pmc = rtnl_dereference(pmc->next_rcu))\n\n#ifdef CONFIG_IP_MULTICAST\n\n/*\n *\tTimer management\n */\n\nstatic void igmp_stop_timer(struct ip_mc_list *im)\n{\n\tspin_lock_bh(&im->lock);\n\tif (del_timer(&im->timer))\n\t\tatomic_dec(&im->refcnt);\n\tim->tm_running = 0;\n\tim->reporter = 0;\n\tim->unsolicit_count = 0;\n\tspin_unlock_bh(&im->lock);\n}\n\n/* It must be called with locked im->lock */\nstatic void igmp_start_timer(struct ip_mc_list *im, int max_delay)\n{\n\tint tv = net_random() % max_delay;\n\n\tim->tm_running = 1;\n\tif (!mod_timer(&im->timer, jiffies+tv+2))\n\t\tatomic_inc(&im->refcnt);\n}\n\nstatic void igmp_gq_start_timer(struct in_device *in_dev)\n{\n\tint tv = net_random() % in_dev->mr_maxdelay;\n\n\tin_dev->mr_gq_running = 1;\n\tif (!mod_timer(&in_dev->mr_gq_timer, jiffies+tv+2))\n\t\tin_dev_hold(in_dev);\n}\n\nstatic void igmp_ifc_start_timer(struct in_device *in_dev, int delay)\n{\n\tint tv = net_random() % delay;\n\n\tif (!mod_timer(&in_dev->mr_ifc_timer, jiffies+tv+2))\n\t\tin_dev_hold(in_dev);\n}\n\nstatic void igmp_mod_timer(struct ip_mc_list *im, int max_delay)\n{\n\tspin_lock_bh(&im->lock);\n\tim->unsolicit_count = 0;\n\tif (del_timer(&im->timer)) {\n\t\tif ((long)(im->timer.expires-jiffies) < max_delay) {\n\t\t\tadd_timer(&im->timer);\n\t\t\tim->tm_running = 1;\n\t\t\tspin_unlock_bh(&im->lock);\n\t\t\treturn;\n\t\t}\n\t\tatomic_dec(&im->refcnt);\n\t}\n\tigmp_start_timer(im, max_delay);\n\tspin_unlock_bh(&im->lock);\n}\n\n\n/*\n *\tSend an IGMP report.\n */\n\n#define IGMP_SIZE (sizeof(struct igmphdr)+sizeof(struct iphdr)+4)\n\n\nstatic int is_in(struct ip_mc_list *pmc, struct ip_sf_list *psf, int type,\n\tint gdeleted, int sdeleted)\n{\n\tswitch (type) {\n\tcase IGMPV3_MODE_IS_INCLUDE:\n\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn 0;\n\t\tif (!(pmc->gsquery && !psf->sf_gsresp)) {\n\t\t\tif (pmc->sfmode == MCAST_INCLUDE)\n\t\t\t\treturn 1;\n\t\t\t/* don't include if this source is excluded\n\t\t\t * in all filters\n\t\t\t */\n\t\t\tif (psf->sf_count[MCAST_INCLUDE])\n\t\t\t\treturn type == IGMPV3_MODE_IS_INCLUDE;\n\t\t\treturn pmc->sfcount[MCAST_EXCLUDE] ==\n\t\t\t\tpsf->sf_count[MCAST_EXCLUDE];\n\t\t}\n\t\treturn 0;\n\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn 0;\n\t\treturn psf->sf_count[MCAST_INCLUDE] != 0;\n\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn 0;\n\t\tif (pmc->sfcount[MCAST_EXCLUDE] == 0 ||\n\t\t    psf->sf_count[MCAST_INCLUDE])\n\t\t\treturn 0;\n\t\treturn pmc->sfcount[MCAST_EXCLUDE] ==\n\t\t\tpsf->sf_count[MCAST_EXCLUDE];\n\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\tif (gdeleted || !psf->sf_crcount)\n\t\t\treturn 0;\n\t\treturn (pmc->sfmode == MCAST_INCLUDE) ^ sdeleted;\n\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\tif (pmc->sfmode == MCAST_INCLUDE)\n\t\t\treturn gdeleted || (psf->sf_crcount && sdeleted);\n\t\treturn psf->sf_crcount && !gdeleted && !sdeleted;\n\t}\n\treturn 0;\n}\n\nstatic int\nigmp_scount(struct ip_mc_list *pmc, int type, int gdeleted, int sdeleted)\n{\n\tstruct ip_sf_list *psf;\n\tint scount = 0;\n\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (!is_in(pmc, psf, type, gdeleted, sdeleted))\n\t\t\tcontinue;\n\t\tscount++;\n\t}\n\treturn scount;\n}\n\n#define igmp_skb_size(skb) (*(unsigned int *)((skb)->cb))\n\nstatic struct sk_buff *igmpv3_newpack(struct net_device *dev, int size)\n{\n\tstruct sk_buff *skb;\n\tstruct rtable *rt;\n\tstruct iphdr *pip;\n\tstruct igmpv3_report *pig;\n\tstruct net *net = dev_net(dev);\n\tstruct flowi4 fl4;\n\n\twhile (1) {\n\t\tskb = alloc_skb(size + LL_ALLOCATED_SPACE(dev),\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tsize >>= 1;\n\t\tif (size < 256)\n\t\t\treturn NULL;\n\t}\n\tigmp_skb_size(skb) = size;\n\n\trt = ip_route_output_ports(net, &fl4, NULL, IGMPV3_ALL_MCR, 0,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_IGMP, 0, dev->ifindex);\n\tif (IS_ERR(rt)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n\tskb->dev = dev;\n\n\tskb_reserve(skb, LL_RESERVED_SPACE(dev));\n\n\tskb_reset_network_header(skb);\n\tpip = ip_hdr(skb);\n\tskb_put(skb, sizeof(struct iphdr) + 4);\n\n\tpip->version  = 4;\n\tpip->ihl      = (sizeof(struct iphdr)+4)>>2;\n\tpip->tos      = 0xc0;\n\tpip->frag_off = htons(IP_DF);\n\tpip->ttl      = 1;\n\tpip->daddr    = fl4.daddr;\n\tpip->saddr    = fl4.saddr;\n\tpip->protocol = IPPROTO_IGMP;\n\tpip->tot_len  = 0;\t/* filled in later */\n\tip_select_ident(pip, &rt->dst, NULL);\n\t((u8*)&pip[1])[0] = IPOPT_RA;\n\t((u8*)&pip[1])[1] = 4;\n\t((u8*)&pip[1])[2] = 0;\n\t((u8*)&pip[1])[3] = 0;\n\n\tskb->transport_header = skb->network_header + sizeof(struct iphdr) + 4;\n\tskb_put(skb, sizeof(*pig));\n\tpig = igmpv3_report_hdr(skb);\n\tpig->type = IGMPV3_HOST_MEMBERSHIP_REPORT;\n\tpig->resv1 = 0;\n\tpig->csum = 0;\n\tpig->resv2 = 0;\n\tpig->ngrec = 0;\n\treturn skb;\n}\n\nstatic int igmpv3_sendpack(struct sk_buff *skb)\n{\n\tstruct igmphdr *pig = igmp_hdr(skb);\n\tconst int igmplen = skb->tail - skb->transport_header;\n\n\tpig->csum = ip_compute_csum(igmp_hdr(skb), igmplen);\n\n\treturn ip_local_out(skb);\n}\n\nstatic int grec_size(struct ip_mc_list *pmc, int type, int gdel, int sdel)\n{\n\treturn sizeof(struct igmpv3_grec) + 4*igmp_scount(pmc, type, gdel, sdel);\n}\n\nstatic struct sk_buff *add_grhead(struct sk_buff *skb, struct ip_mc_list *pmc,\n\tint type, struct igmpv3_grec **ppgr)\n{\n\tstruct net_device *dev = pmc->interface->dev;\n\tstruct igmpv3_report *pih;\n\tstruct igmpv3_grec *pgr;\n\n\tif (!skb)\n\t\tskb = igmpv3_newpack(dev, dev->mtu);\n\tif (!skb)\n\t\treturn NULL;\n\tpgr = (struct igmpv3_grec *)skb_put(skb, sizeof(struct igmpv3_grec));\n\tpgr->grec_type = type;\n\tpgr->grec_auxwords = 0;\n\tpgr->grec_nsrcs = 0;\n\tpgr->grec_mca = pmc->multiaddr;\n\tpih = igmpv3_report_hdr(skb);\n\tpih->ngrec = htons(ntohs(pih->ngrec)+1);\n\t*ppgr = pgr;\n\treturn skb;\n}\n\n#define AVAILABLE(skb) ((skb) ? ((skb)->dev ? igmp_skb_size(skb) - (skb)->len : \\\n\tskb_tailroom(skb)) : 0)\n\nstatic struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,\n\tint type, int gdeleted, int sdeleted)\n{\n\tstruct net_device *dev = pmc->interface->dev;\n\tstruct igmpv3_report *pih;\n\tstruct igmpv3_grec *pgr = NULL;\n\tstruct ip_sf_list *psf, *psf_next, *psf_prev, **psf_list;\n\tint scount, stotal, first, isquery, truncate;\n\n\tif (pmc->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn skb;\n\n\tisquery = type == IGMPV3_MODE_IS_INCLUDE ||\n\t\t  type == IGMPV3_MODE_IS_EXCLUDE;\n\ttruncate = type == IGMPV3_MODE_IS_EXCLUDE ||\n\t\t    type == IGMPV3_CHANGE_TO_EXCLUDE;\n\n\tstotal = scount = 0;\n\n\tpsf_list = sdeleted ? &pmc->tomb : &pmc->sources;\n\n\tif (!*psf_list)\n\t\tgoto empty_source;\n\n\tpih = skb ? igmpv3_report_hdr(skb) : NULL;\n\n\t/* EX and TO_EX get a fresh packet, if needed */\n\tif (truncate) {\n\t\tif (pih && pih->ngrec &&\n\t\t    AVAILABLE(skb) < grec_size(pmc, type, gdeleted, sdeleted)) {\n\t\t\tif (skb)\n\t\t\t\tigmpv3_sendpack(skb);\n\t\t\tskb = igmpv3_newpack(dev, dev->mtu);\n\t\t}\n\t}\n\tfirst = 1;\n\tpsf_prev = NULL;\n\tfor (psf=*psf_list; psf; psf=psf_next) {\n\t\t__be32 *psrc;\n\n\t\tpsf_next = psf->sf_next;\n\n\t\tif (!is_in(pmc, psf, type, gdeleted, sdeleted)) {\n\t\t\tpsf_prev = psf;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* clear marks on query responses */\n\t\tif (isquery)\n\t\t\tpsf->sf_gsresp = 0;\n\n\t\tif (AVAILABLE(skb) < sizeof(__be32) +\n\t\t    first*sizeof(struct igmpv3_grec)) {\n\t\t\tif (truncate && !first)\n\t\t\t\tbreak;\t /* truncate these */\n\t\t\tif (pgr)\n\t\t\t\tpgr->grec_nsrcs = htons(scount);\n\t\t\tif (skb)\n\t\t\t\tigmpv3_sendpack(skb);\n\t\t\tskb = igmpv3_newpack(dev, dev->mtu);\n\t\t\tfirst = 1;\n\t\t\tscount = 0;\n\t\t}\n\t\tif (first) {\n\t\t\tskb = add_grhead(skb, pmc, type, &pgr);\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t\tpsrc = (__be32 *)skb_put(skb, sizeof(__be32));\n\t\t*psrc = psf->sf_inaddr;\n\t\tscount++; stotal++;\n\t\tif ((type == IGMPV3_ALLOW_NEW_SOURCES ||\n\t\t     type == IGMPV3_BLOCK_OLD_SOURCES) && psf->sf_crcount) {\n\t\t\tpsf->sf_crcount--;\n\t\t\tif ((sdeleted || gdeleted) && psf->sf_crcount == 0) {\n\t\t\t\tif (psf_prev)\n\t\t\t\t\tpsf_prev->sf_next = psf->sf_next;\n\t\t\t\telse\n\t\t\t\t\t*psf_list = psf->sf_next;\n\t\t\t\tkfree(psf);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tpsf_prev = psf;\n\t}\n\nempty_source:\n\tif (!stotal) {\n\t\tif (type == IGMPV3_ALLOW_NEW_SOURCES ||\n\t\t    type == IGMPV3_BLOCK_OLD_SOURCES)\n\t\t\treturn skb;\n\t\tif (pmc->crcount || isquery) {\n\t\t\t/* make sure we have room for group header */\n\t\t\tif (skb && AVAILABLE(skb)<sizeof(struct igmpv3_grec)) {\n\t\t\t\tigmpv3_sendpack(skb);\n\t\t\t\tskb = NULL; /* add_grhead will get a new one */\n\t\t\t}\n\t\t\tskb = add_grhead(skb, pmc, type, &pgr);\n\t\t}\n\t}\n\tif (pgr)\n\t\tpgr->grec_nsrcs = htons(scount);\n\n\tif (isquery)\n\t\tpmc->gsquery = 0;\t/* clear query state on report */\n\treturn skb;\n}\n\nstatic int igmpv3_send_report(struct in_device *in_dev, struct ip_mc_list *pmc)\n{\n\tstruct sk_buff *skb = NULL;\n\tint type;\n\n\tif (!pmc) {\n\t\trcu_read_lock();\n\t\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\t\tif (pmc->multiaddr == IGMP_ALL_HOSTS)\n\t\t\t\tcontinue;\n\t\t\tspin_lock_bh(&pmc->lock);\n\t\t\tif (pmc->sfcount[MCAST_EXCLUDE])\n\t\t\t\ttype = IGMPV3_MODE_IS_EXCLUDE;\n\t\t\telse\n\t\t\t\ttype = IGMPV3_MODE_IS_INCLUDE;\n\t\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\t\tspin_unlock_bh(&pmc->lock);\n\t\t}\n\t\trcu_read_unlock();\n\t} else {\n\t\tspin_lock_bh(&pmc->lock);\n\t\tif (pmc->sfcount[MCAST_EXCLUDE])\n\t\t\ttype = IGMPV3_MODE_IS_EXCLUDE;\n\t\telse\n\t\t\ttype = IGMPV3_MODE_IS_INCLUDE;\n\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\tspin_unlock_bh(&pmc->lock);\n\t}\n\tif (!skb)\n\t\treturn 0;\n\treturn igmpv3_sendpack(skb);\n}\n\n/*\n * remove zero-count source records from a source filter list\n */\nstatic void igmpv3_clear_zeros(struct ip_sf_list **ppsf)\n{\n\tstruct ip_sf_list *psf_prev, *psf_next, *psf;\n\n\tpsf_prev = NULL;\n\tfor (psf=*ppsf; psf; psf = psf_next) {\n\t\tpsf_next = psf->sf_next;\n\t\tif (psf->sf_crcount == 0) {\n\t\t\tif (psf_prev)\n\t\t\t\tpsf_prev->sf_next = psf->sf_next;\n\t\t\telse\n\t\t\t\t*ppsf = psf->sf_next;\n\t\t\tkfree(psf);\n\t\t} else\n\t\t\tpsf_prev = psf;\n\t}\n}\n\nstatic void igmpv3_send_cr(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc, *pmc_prev, *pmc_next;\n\tstruct sk_buff *skb = NULL;\n\tint type, dtype;\n\n\trcu_read_lock();\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\n\t/* deleted MCA's */\n\tpmc_prev = NULL;\n\tfor (pmc=in_dev->mc_tomb; pmc; pmc=pmc_next) {\n\t\tpmc_next = pmc->next;\n\t\tif (pmc->sfmode == MCAST_INCLUDE) {\n\t\t\ttype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t\tdtype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t\tskb = add_grec(skb, pmc, type, 1, 0);\n\t\t\tskb = add_grec(skb, pmc, dtype, 1, 1);\n\t\t}\n\t\tif (pmc->crcount) {\n\t\t\tif (pmc->sfmode == MCAST_EXCLUDE) {\n\t\t\t\ttype = IGMPV3_CHANGE_TO_INCLUDE;\n\t\t\t\tskb = add_grec(skb, pmc, type, 1, 0);\n\t\t\t}\n\t\t\tpmc->crcount--;\n\t\t\tif (pmc->crcount == 0) {\n\t\t\t\tigmpv3_clear_zeros(&pmc->tomb);\n\t\t\t\tigmpv3_clear_zeros(&pmc->sources);\n\t\t\t}\n\t\t}\n\t\tif (pmc->crcount == 0 && !pmc->tomb && !pmc->sources) {\n\t\t\tif (pmc_prev)\n\t\t\t\tpmc_prev->next = pmc_next;\n\t\t\telse\n\t\t\t\tin_dev->mc_tomb = pmc_next;\n\t\t\tin_dev_put(pmc->interface);\n\t\t\tkfree(pmc);\n\t\t} else\n\t\t\tpmc_prev = pmc;\n\t}\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n\n\t/* change recs */\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tspin_lock_bh(&pmc->lock);\n\t\tif (pmc->sfcount[MCAST_EXCLUDE]) {\n\t\t\ttype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t\tdtype = IGMPV3_ALLOW_NEW_SOURCES;\n\t\t} else {\n\t\t\ttype = IGMPV3_ALLOW_NEW_SOURCES;\n\t\t\tdtype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t}\n\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\tskb = add_grec(skb, pmc, dtype, 0, 1);\t/* deleted sources */\n\n\t\t/* filter mode changes */\n\t\tif (pmc->crcount) {\n\t\t\tif (pmc->sfmode == MCAST_EXCLUDE)\n\t\t\t\ttype = IGMPV3_CHANGE_TO_EXCLUDE;\n\t\t\telse\n\t\t\t\ttype = IGMPV3_CHANGE_TO_INCLUDE;\n\t\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\t\tpmc->crcount--;\n\t\t}\n\t\tspin_unlock_bh(&pmc->lock);\n\t}\n\trcu_read_unlock();\n\n\tif (!skb)\n\t\treturn;\n\t(void) igmpv3_sendpack(skb);\n}\n\nstatic int igmp_send_report(struct in_device *in_dev, struct ip_mc_list *pmc,\n\tint type)\n{\n\tstruct sk_buff *skb;\n\tstruct iphdr *iph;\n\tstruct igmphdr *ih;\n\tstruct rtable *rt;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct net *net = dev_net(dev);\n\t__be32\tgroup = pmc ? pmc->multiaddr : 0;\n\tstruct flowi4 fl4;\n\t__be32\tdst;\n\n\tif (type == IGMPV3_HOST_MEMBERSHIP_REPORT)\n\t\treturn igmpv3_send_report(in_dev, pmc);\n\telse if (type == IGMP_HOST_LEAVE_MESSAGE)\n\t\tdst = IGMP_ALL_ROUTER;\n\telse\n\t\tdst = group;\n\n\trt = ip_route_output_ports(net, &fl4, NULL, dst, 0,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_IGMP, 0, dev->ifindex);\n\tif (IS_ERR(rt))\n\t\treturn -1;\n\n\tskb = alloc_skb(IGMP_SIZE+LL_ALLOCATED_SPACE(dev), GFP_ATOMIC);\n\tif (skb == NULL) {\n\t\tip_rt_put(rt);\n\t\treturn -1;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n\n\tskb_reserve(skb, LL_RESERVED_SPACE(dev));\n\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tskb_put(skb, sizeof(struct iphdr) + 4);\n\n\tiph->version  = 4;\n\tiph->ihl      = (sizeof(struct iphdr)+4)>>2;\n\tiph->tos      = 0xc0;\n\tiph->frag_off = htons(IP_DF);\n\tiph->ttl      = 1;\n\tiph->daddr    = dst;\n\tiph->saddr    = fl4.saddr;\n\tiph->protocol = IPPROTO_IGMP;\n\tip_select_ident(iph, &rt->dst, NULL);\n\t((u8*)&iph[1])[0] = IPOPT_RA;\n\t((u8*)&iph[1])[1] = 4;\n\t((u8*)&iph[1])[2] = 0;\n\t((u8*)&iph[1])[3] = 0;\n\n\tih = (struct igmphdr *)skb_put(skb, sizeof(struct igmphdr));\n\tih->type = type;\n\tih->code = 0;\n\tih->csum = 0;\n\tih->group = group;\n\tih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\n\n\treturn ip_local_out(skb);\n}\n\nstatic void igmp_gq_timer_expire(unsigned long data)\n{\n\tstruct in_device *in_dev = (struct in_device *)data;\n\n\tin_dev->mr_gq_running = 0;\n\tigmpv3_send_report(in_dev, NULL);\n\t__in_dev_put(in_dev);\n}\n\nstatic void igmp_ifc_timer_expire(unsigned long data)\n{\n\tstruct in_device *in_dev = (struct in_device *)data;\n\n\tigmpv3_send_cr(in_dev);\n\tif (in_dev->mr_ifc_count) {\n\t\tin_dev->mr_ifc_count--;\n\t\tigmp_ifc_start_timer(in_dev, IGMP_Unsolicited_Report_Interval);\n\t}\n\t__in_dev_put(in_dev);\n}\n\nstatic void igmp_ifc_event(struct in_device *in_dev)\n{\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev))\n\t\treturn;\n\tin_dev->mr_ifc_count = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\tIGMP_Unsolicited_Report_Count;\n\tigmp_ifc_start_timer(in_dev, 1);\n}\n\n\nstatic void igmp_timer_expire(unsigned long data)\n{\n\tstruct ip_mc_list *im=(struct ip_mc_list *)data;\n\tstruct in_device *in_dev = im->interface;\n\n\tspin_lock(&im->lock);\n\tim->tm_running = 0;\n\n\tif (im->unsolicit_count) {\n\t\tim->unsolicit_count--;\n\t\tigmp_start_timer(im, IGMP_Unsolicited_Report_Interval);\n\t}\n\tim->reporter = 1;\n\tspin_unlock(&im->lock);\n\n\tif (IGMP_V1_SEEN(in_dev))\n\t\tigmp_send_report(in_dev, im, IGMP_HOST_MEMBERSHIP_REPORT);\n\telse if (IGMP_V2_SEEN(in_dev))\n\t\tigmp_send_report(in_dev, im, IGMPV2_HOST_MEMBERSHIP_REPORT);\n\telse\n\t\tigmp_send_report(in_dev, im, IGMPV3_HOST_MEMBERSHIP_REPORT);\n\n\tip_ma_put(im);\n}\n\n/* mark EXCLUDE-mode sources */\nstatic int igmp_xmarksources(struct ip_mc_list *pmc, int nsrcs, __be32 *srcs)\n{\n\tstruct ip_sf_list *psf;\n\tint i, scount;\n\n\tscount = 0;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (scount == nsrcs)\n\t\t\tbreak;\n\t\tfor (i=0; i<nsrcs; i++) {\n\t\t\t/* skip inactive filters */\n\t\t\tif (psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t    pmc->sfcount[MCAST_EXCLUDE] !=\n\t\t\t    psf->sf_count[MCAST_EXCLUDE])\n\t\t\t\tcontinue;\n\t\t\tif (srcs[i] == psf->sf_inaddr) {\n\t\t\t\tscount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpmc->gsquery = 0;\n\tif (scount == nsrcs)\t/* all sources excluded */\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int igmp_marksources(struct ip_mc_list *pmc, int nsrcs, __be32 *srcs)\n{\n\tstruct ip_sf_list *psf;\n\tint i, scount;\n\n\tif (pmc->sfmode == MCAST_EXCLUDE)\n\t\treturn igmp_xmarksources(pmc, nsrcs, srcs);\n\n\t/* mark INCLUDE-mode sources */\n\tscount = 0;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (scount == nsrcs)\n\t\t\tbreak;\n\t\tfor (i=0; i<nsrcs; i++)\n\t\t\tif (srcs[i] == psf->sf_inaddr) {\n\t\t\t\tpsf->sf_gsresp = 1;\n\t\t\t\tscount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif (!scount) {\n\t\tpmc->gsquery = 0;\n\t\treturn 0;\n\t}\n\tpmc->gsquery = 1;\n\treturn 1;\n}\n\nstatic void igmp_heard_report(struct in_device *in_dev, __be32 group)\n{\n\tstruct ip_mc_list *im;\n\n\t/* Timers are only set for non-local groups */\n\n\tif (group == IGMP_ALL_HOSTS)\n\t\treturn;\n\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tif (im->multiaddr == group) {\n\t\t\tigmp_stop_timer(im);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic void igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb,\n\tint len)\n{\n\tstruct igmphdr \t\t*ih = igmp_hdr(skb);\n\tstruct igmpv3_query *ih3 = igmpv3_query_hdr(skb);\n\tstruct ip_mc_list\t*im;\n\t__be32\t\t\tgroup = ih->group;\n\tint\t\t\tmax_delay;\n\tint\t\t\tmark = 0;\n\n\n\tif (len == 8) {\n\t\tif (ih->code == 0) {\n\t\t\t/* Alas, old v1 router presents here. */\n\n\t\t\tmax_delay = IGMP_Query_Response_Interval;\n\t\t\tin_dev->mr_v1_seen = jiffies +\n\t\t\t\tIGMP_V1_Router_Present_Timeout;\n\t\t\tgroup = 0;\n\t\t} else {\n\t\t\t/* v2 router present */\n\t\t\tmax_delay = ih->code*(HZ/IGMP_TIMER_SCALE);\n\t\t\tin_dev->mr_v2_seen = jiffies +\n\t\t\t\tIGMP_V2_Router_Present_Timeout;\n\t\t}\n\t\t/* cancel the interface change timer */\n\t\tin_dev->mr_ifc_count = 0;\n\t\tif (del_timer(&in_dev->mr_ifc_timer))\n\t\t\t__in_dev_put(in_dev);\n\t\t/* clear deleted report items */\n\t\tigmpv3_clear_delrec(in_dev);\n\t} else if (len < 12) {\n\t\treturn;\t/* ignore bogus packet; freed by caller */\n\t} else if (IGMP_V1_SEEN(in_dev)) {\n\t\t/* This is a v3 query with v1 queriers present */\n\t\tmax_delay = IGMP_Query_Response_Interval;\n\t\tgroup = 0;\n\t} else if (IGMP_V2_SEEN(in_dev)) {\n\t\t/* this is a v3 query with v2 queriers present;\n\t\t * Interpretation of the max_delay code is problematic here.\n\t\t * A real v2 host would use ih_code directly, while v3 has a\n\t\t * different encoding. We use the v3 encoding as more likely\n\t\t * to be intended in a v3 query.\n\t\t */\n\t\tmax_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);\n\t} else { /* v3 */\n\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))\n\t\t\treturn;\n\n\t\tih3 = igmpv3_query_hdr(skb);\n\t\tif (ih3->nsrcs) {\n\t\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)\n\t\t\t\t\t   + ntohs(ih3->nsrcs)*sizeof(__be32)))\n\t\t\t\treturn;\n\t\t\tih3 = igmpv3_query_hdr(skb);\n\t\t}\n\n\t\tmax_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);\n\t\tif (!max_delay)\n\t\t\tmax_delay = 1;\t/* can't mod w/ 0 */\n\t\tin_dev->mr_maxdelay = max_delay;\n\t\tif (ih3->qrv)\n\t\t\tin_dev->mr_qrv = ih3->qrv;\n\t\tif (!group) { /* general query */\n\t\t\tif (ih3->nsrcs)\n\t\t\t\treturn;\t/* no sources allowed */\n\t\t\tigmp_gq_start_timer(in_dev);\n\t\t\treturn;\n\t\t}\n\t\t/* mark sources to include, if group & source-specific */\n\t\tmark = ih3->nsrcs != 0;\n\t}\n\n\t/*\n\t * - Start the timers in all of our membership records\n\t *   that the query applies to for the interface on\n\t *   which the query arrived excl. those that belong\n\t *   to a \"local\" group (224.0.0.X)\n\t * - For timers already running check if they need to\n\t *   be reset.\n\t * - Use the igmp->igmp_code field as the maximum\n\t *   delay possible\n\t */\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tint changed;\n\n\t\tif (group && group != im->multiaddr)\n\t\t\tcontinue;\n\t\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\t\tcontinue;\n\t\tspin_lock_bh(&im->lock);\n\t\tif (im->tm_running)\n\t\t\tim->gsquery = im->gsquery && mark;\n\t\telse\n\t\t\tim->gsquery = mark;\n\t\tchanged = !im->gsquery ||\n\t\t\tigmp_marksources(im, ntohs(ih3->nsrcs), ih3->srcs);\n\t\tspin_unlock_bh(&im->lock);\n\t\tif (changed)\n\t\t\tigmp_mod_timer(im, max_delay);\n\t}\n\trcu_read_unlock();\n}\n\n/* called in rcu_read_lock() section */\nint igmp_rcv(struct sk_buff *skb)\n{\n\t/* This basically follows the spec line by line -- see RFC1112 */\n\tstruct igmphdr *ih;\n\tstruct in_device *in_dev = __in_dev_get_rcu(skb->dev);\n\tint len = skb->len;\n\n\tif (in_dev == NULL)\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, sizeof(struct igmphdr)))\n\t\tgoto drop;\n\n\tswitch (skb->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_fold(skb->csum))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase CHECKSUM_NONE:\n\t\tskb->csum = 0;\n\t\tif (__skb_checksum_complete(skb))\n\t\t\tgoto drop;\n\t}\n\n\tih = igmp_hdr(skb);\n\tswitch (ih->type) {\n\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\tigmp_heard_query(in_dev, skb, len);\n\t\tbreak;\n\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\t/* Is it our report looped back? */\n\t\tif (rt_is_output_route(skb_rtable(skb)))\n\t\t\tbreak;\n\t\t/* don't rely on MC router hearing unicast reports */\n\t\tif (skb->pkt_type == PACKET_MULTICAST ||\n\t\t    skb->pkt_type == PACKET_BROADCAST)\n\t\t\tigmp_heard_report(in_dev, ih->group);\n\t\tbreak;\n\tcase IGMP_PIM:\n#ifdef CONFIG_IP_PIMSM_V1\n\t\treturn pim_rcv_v1(skb);\n#endif\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\tcase IGMP_DVMRP:\n\tcase IGMP_TRACE:\n\tcase IGMP_HOST_LEAVE_MESSAGE:\n\tcase IGMP_MTRACE:\n\tcase IGMP_MTRACE_RESP:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n#endif\n\n\n/*\n *\tAdd a filter to a device\n */\n\nstatic void ip_mc_filter_add(struct in_device *in_dev, __be32 addr)\n{\n\tchar buf[MAX_ADDR_LEN];\n\tstruct net_device *dev = in_dev->dev;\n\n\t/* Checking for IFF_MULTICAST here is WRONG-WRONG-WRONG.\n\t   We will get multicast token leakage, when IFF_MULTICAST\n\t   is changed. This check should be done in ndo_set_rx_mode\n\t   routine. Something sort of:\n\t   if (dev->mc_list && dev->flags&IFF_MULTICAST) { do it; }\n\t   --ANK\n\t   */\n\tif (arp_mc_map(addr, buf, dev, 0) == 0)\n\t\tdev_mc_add(dev, buf);\n}\n\n/*\n *\tRemove a filter from a device\n */\n\nstatic void ip_mc_filter_del(struct in_device *in_dev, __be32 addr)\n{\n\tchar buf[MAX_ADDR_LEN];\n\tstruct net_device *dev = in_dev->dev;\n\n\tif (arp_mc_map(addr, buf, dev, 0) == 0)\n\t\tdev_mc_del(dev, buf);\n}\n\n#ifdef CONFIG_IP_MULTICAST\n/*\n * deleted ip_mc_list manipulation\n */\nstatic void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im)\n{\n\tstruct ip_mc_list *pmc;\n\n\t/* this is an \"ip_mc_list\" for convenience; only the fields below\n\t * are actually used. In particular, the refcnt and users are not\n\t * used for management of the delete list. Using the same structure\n\t * for deleted items allows change reports to use common code with\n\t * non-deleted or query-response MCA's.\n\t */\n\tpmc = kzalloc(sizeof(*pmc), GFP_KERNEL);\n\tif (!pmc)\n\t\treturn;\n\tspin_lock_bh(&im->lock);\n\tpmc->interface = im->interface;\n\tin_dev_hold(in_dev);\n\tpmc->multiaddr = im->multiaddr;\n\tpmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\tIGMP_Unsolicited_Report_Count;\n\tpmc->sfmode = im->sfmode;\n\tif (pmc->sfmode == MCAST_INCLUDE) {\n\t\tstruct ip_sf_list *psf;\n\n\t\tpmc->tomb = im->tomb;\n\t\tpmc->sources = im->sources;\n\t\tim->tomb = im->sources = NULL;\n\t\tfor (psf=pmc->sources; psf; psf=psf->sf_next)\n\t\t\tpsf->sf_crcount = pmc->crcount;\n\t}\n\tspin_unlock_bh(&im->lock);\n\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\tpmc->next = in_dev->mc_tomb;\n\tin_dev->mc_tomb = pmc;\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n}\n\nstatic void igmpv3_del_delrec(struct in_device *in_dev, __be32 multiaddr)\n{\n\tstruct ip_mc_list *pmc, *pmc_prev;\n\tstruct ip_sf_list *psf, *psf_next;\n\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\tpmc_prev = NULL;\n\tfor (pmc=in_dev->mc_tomb; pmc; pmc=pmc->next) {\n\t\tif (pmc->multiaddr == multiaddr)\n\t\t\tbreak;\n\t\tpmc_prev = pmc;\n\t}\n\tif (pmc) {\n\t\tif (pmc_prev)\n\t\t\tpmc_prev->next = pmc->next;\n\t\telse\n\t\t\tin_dev->mc_tomb = pmc->next;\n\t}\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n\tif (pmc) {\n\t\tfor (psf=pmc->tomb; psf; psf=psf_next) {\n\t\t\tpsf_next = psf->sf_next;\n\t\t\tkfree(psf);\n\t\t}\n\t\tin_dev_put(pmc->interface);\n\t\tkfree(pmc);\n\t}\n}\n\nstatic void igmpv3_clear_delrec(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc, *nextpmc;\n\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\tpmc = in_dev->mc_tomb;\n\tin_dev->mc_tomb = NULL;\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n\n\tfor (; pmc; pmc = nextpmc) {\n\t\tnextpmc = pmc->next;\n\t\tip_mc_clear_src(pmc);\n\t\tin_dev_put(pmc->interface);\n\t\tkfree(pmc);\n\t}\n\t/* clear dead sources, too */\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tstruct ip_sf_list *psf, *psf_next;\n\n\t\tspin_lock_bh(&pmc->lock);\n\t\tpsf = pmc->tomb;\n\t\tpmc->tomb = NULL;\n\t\tspin_unlock_bh(&pmc->lock);\n\t\tfor (; psf; psf=psf_next) {\n\t\t\tpsf_next = psf->sf_next;\n\t\t\tkfree(psf);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n#endif\n\nstatic void igmp_group_dropped(struct ip_mc_list *im)\n{\n\tstruct in_device *in_dev = im->interface;\n#ifdef CONFIG_IP_MULTICAST\n\tint reporter;\n#endif\n\n\tif (im->loaded) {\n\t\tim->loaded = 0;\n\t\tip_mc_filter_del(in_dev, im->multiaddr);\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn;\n\n\treporter = im->reporter;\n\tigmp_stop_timer(im);\n\n\tif (!in_dev->dead) {\n\t\tif (IGMP_V1_SEEN(in_dev))\n\t\t\treturn;\n\t\tif (IGMP_V2_SEEN(in_dev)) {\n\t\t\tif (reporter)\n\t\t\t\tigmp_send_report(in_dev, im, IGMP_HOST_LEAVE_MESSAGE);\n\t\t\treturn;\n\t\t}\n\t\t/* IGMPv3 */\n\t\tigmpv3_add_delrec(in_dev, im);\n\n\t\tigmp_ifc_event(in_dev);\n\t}\n#endif\n}\n\nstatic void igmp_group_added(struct ip_mc_list *im)\n{\n\tstruct in_device *in_dev = im->interface;\n\n\tif (im->loaded == 0) {\n\t\tim->loaded = 1;\n\t\tip_mc_filter_add(in_dev, im->multiaddr);\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn;\n\n\tif (in_dev->dead)\n\t\treturn;\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev)) {\n\t\tspin_lock_bh(&im->lock);\n\t\tigmp_start_timer(im, IGMP_Initial_Report_Delay);\n\t\tspin_unlock_bh(&im->lock);\n\t\treturn;\n\t}\n\t/* else, v3 */\n\n\tim->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\tIGMP_Unsolicited_Report_Count;\n\tigmp_ifc_event(in_dev);\n#endif\n}\n\n\n/*\n *\tMulticast list managers\n */\n\n\n/*\n *\tA socket has joined a multicast group on device dev.\n */\n\nvoid ip_mc_inc_group(struct in_device *in_dev, __be32 addr)\n{\n\tstruct ip_mc_list *im;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, im) {\n\t\tif (im->multiaddr == addr) {\n\t\t\tim->users++;\n\t\t\tip_mc_add_src(in_dev, &addr, MCAST_EXCLUDE, 0, NULL, 0);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tim = kzalloc(sizeof(*im), GFP_KERNEL);\n\tif (!im)\n\t\tgoto out;\n\n\tim->users = 1;\n\tim->interface = in_dev;\n\tin_dev_hold(in_dev);\n\tim->multiaddr = addr;\n\t/* initial mode is (EX, empty) */\n\tim->sfmode = MCAST_EXCLUDE;\n\tim->sfcount[MCAST_EXCLUDE] = 1;\n\tatomic_set(&im->refcnt, 1);\n\tspin_lock_init(&im->lock);\n#ifdef CONFIG_IP_MULTICAST\n\tsetup_timer(&im->timer, &igmp_timer_expire, (unsigned long)im);\n\tim->unsolicit_count = IGMP_Unsolicited_Report_Count;\n#endif\n\n\tim->next_rcu = in_dev->mc_list;\n\tin_dev->mc_count++;\n\tRCU_INIT_POINTER(in_dev->mc_list, im);\n\n#ifdef CONFIG_IP_MULTICAST\n\tigmpv3_del_delrec(in_dev, im->multiaddr);\n#endif\n\tigmp_group_added(im);\n\tif (!in_dev->dead)\n\t\tip_rt_multicast_event(in_dev);\nout:\n\treturn;\n}\nEXPORT_SYMBOL(ip_mc_inc_group);\n\n/*\n *\tResend IGMP JOIN report; used for bonding.\n *\tCalled with rcu_read_lock()\n */\nvoid ip_mc_rejoin_groups(struct in_device *in_dev)\n{\n#ifdef CONFIG_IP_MULTICAST\n\tstruct ip_mc_list *im;\n\tint type;\n\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\t\tcontinue;\n\n\t\t/* a failover is happening and switches\n\t\t * must be notified immediately\n\t\t */\n\t\tif (IGMP_V1_SEEN(in_dev))\n\t\t\ttype = IGMP_HOST_MEMBERSHIP_REPORT;\n\t\telse if (IGMP_V2_SEEN(in_dev))\n\t\t\ttype = IGMPV2_HOST_MEMBERSHIP_REPORT;\n\t\telse\n\t\t\ttype = IGMPV3_HOST_MEMBERSHIP_REPORT;\n\t\tigmp_send_report(in_dev, im, type);\n\t}\n#endif\n}\nEXPORT_SYMBOL(ip_mc_rejoin_groups);\n\n/*\n *\tA socket has left a multicast group on device dev\n */\n\nvoid ip_mc_dec_group(struct in_device *in_dev, __be32 addr)\n{\n\tstruct ip_mc_list *i;\n\tstruct ip_mc_list __rcu **ip;\n\n\tASSERT_RTNL();\n\n\tfor (ip = &in_dev->mc_list;\n\t     (i = rtnl_dereference(*ip)) != NULL;\n\t     ip = &i->next_rcu) {\n\t\tif (i->multiaddr == addr) {\n\t\t\tif (--i->users == 0) {\n\t\t\t\t*ip = i->next_rcu;\n\t\t\t\tin_dev->mc_count--;\n\t\t\t\tigmp_group_dropped(i);\n\t\t\t\tip_mc_clear_src(i);\n\n\t\t\t\tif (!in_dev->dead)\n\t\t\t\t\tip_rt_multicast_event(in_dev);\n\n\t\t\t\tip_ma_put(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(ip_mc_dec_group);\n\n/* Device changing type */\n\nvoid ip_mc_unmap(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, pmc)\n\t\tigmp_group_dropped(pmc);\n}\n\nvoid ip_mc_remap(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, pmc)\n\t\tigmp_group_added(pmc);\n}\n\n/* Device going down */\n\nvoid ip_mc_down(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, pmc)\n\t\tigmp_group_dropped(pmc);\n\n#ifdef CONFIG_IP_MULTICAST\n\tin_dev->mr_ifc_count = 0;\n\tif (del_timer(&in_dev->mr_ifc_timer))\n\t\t__in_dev_put(in_dev);\n\tin_dev->mr_gq_running = 0;\n\tif (del_timer(&in_dev->mr_gq_timer))\n\t\t__in_dev_put(in_dev);\n\tigmpv3_clear_delrec(in_dev);\n#endif\n\n\tip_mc_dec_group(in_dev, IGMP_ALL_HOSTS);\n}\n\nvoid ip_mc_init_dev(struct in_device *in_dev)\n{\n\tASSERT_RTNL();\n\n\tin_dev->mc_tomb = NULL;\n#ifdef CONFIG_IP_MULTICAST\n\tin_dev->mr_gq_running = 0;\n\tsetup_timer(&in_dev->mr_gq_timer, igmp_gq_timer_expire,\n\t\t\t(unsigned long)in_dev);\n\tin_dev->mr_ifc_count = 0;\n\tin_dev->mc_count     = 0;\n\tsetup_timer(&in_dev->mr_ifc_timer, igmp_ifc_timer_expire,\n\t\t\t(unsigned long)in_dev);\n\tin_dev->mr_qrv = IGMP_Unsolicited_Report_Count;\n#endif\n\n\tspin_lock_init(&in_dev->mc_tomb_lock);\n}\n\n/* Device going up */\n\nvoid ip_mc_up(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tip_mc_inc_group(in_dev, IGMP_ALL_HOSTS);\n\n\tfor_each_pmc_rtnl(in_dev, pmc)\n\t\tigmp_group_added(pmc);\n}\n\n/*\n *\tDevice is about to be destroyed: clean up.\n */\n\nvoid ip_mc_destroy_dev(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *i;\n\n\tASSERT_RTNL();\n\n\t/* Deactivate timers */\n\tip_mc_down(in_dev);\n\n\twhile ((i = rtnl_dereference(in_dev->mc_list)) != NULL) {\n\t\tin_dev->mc_list = i->next_rcu;\n\t\tin_dev->mc_count--;\n\n\t\t/* We've dropped the groups in ip_mc_down already */\n\t\tip_mc_clear_src(i);\n\t\tip_ma_put(i);\n\t}\n}\n\n/* RTNL is locked */\nstatic struct in_device *ip_mc_find_dev(struct net *net, struct ip_mreqn *imr)\n{\n\tstruct net_device *dev = NULL;\n\tstruct in_device *idev = NULL;\n\n\tif (imr->imr_ifindex) {\n\t\tidev = inetdev_by_index(net, imr->imr_ifindex);\n\t\treturn idev;\n\t}\n\tif (imr->imr_address.s_addr) {\n\t\tdev = __ip_dev_find(net, imr->imr_address.s_addr, false);\n\t\tif (!dev)\n\t\t\treturn NULL;\n\t}\n\n\tif (!dev) {\n\t\tstruct rtable *rt = ip_route_output(net,\n\t\t\t\t\t\t    imr->imr_multiaddr.s_addr,\n\t\t\t\t\t\t    0, 0, 0);\n\t\tif (!IS_ERR(rt)) {\n\t\t\tdev = rt->dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\t}\n\tif (dev) {\n\t\timr->imr_ifindex = dev->ifindex;\n\t\tidev = __in_dev_get_rtnl(dev);\n\t}\n\treturn idev;\n}\n\n/*\n *\tJoin a socket to a group\n */\nint sysctl_igmp_max_memberships __read_mostly = IP_MAX_MEMBERSHIPS;\nint sysctl_igmp_max_msf __read_mostly = IP_MAX_MSF;\n\n\nstatic int ip_mc_del1_src(struct ip_mc_list *pmc, int sfmode,\n\t__be32 *psfsrc)\n{\n\tstruct ip_sf_list *psf, *psf_prev;\n\tint rv = 0;\n\n\tpsf_prev = NULL;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (psf->sf_inaddr == *psfsrc)\n\t\t\tbreak;\n\t\tpsf_prev = psf;\n\t}\n\tif (!psf || psf->sf_count[sfmode] == 0) {\n\t\t/* source filter not found, or count wrong =>  bug */\n\t\treturn -ESRCH;\n\t}\n\tpsf->sf_count[sfmode]--;\n\tif (psf->sf_count[sfmode] == 0) {\n\t\tip_rt_multicast_event(pmc->interface);\n\t}\n\tif (!psf->sf_count[MCAST_INCLUDE] && !psf->sf_count[MCAST_EXCLUDE]) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tstruct in_device *in_dev = pmc->interface;\n#endif\n\n\t\t/* no more filters for this source */\n\t\tif (psf_prev)\n\t\t\tpsf_prev->sf_next = psf->sf_next;\n\t\telse\n\t\t\tpmc->sources = psf->sf_next;\n#ifdef CONFIG_IP_MULTICAST\n\t\tif (psf->sf_oldin &&\n\t\t    !IGMP_V1_SEEN(in_dev) && !IGMP_V2_SEEN(in_dev)) {\n\t\t\tpsf->sf_crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\t\t\tIGMP_Unsolicited_Report_Count;\n\t\t\tpsf->sf_next = pmc->tomb;\n\t\t\tpmc->tomb = psf;\n\t\t\trv = 1;\n\t\t} else\n#endif\n\t\t\tkfree(psf);\n\t}\n\treturn rv;\n}\n\n#ifndef CONFIG_IP_MULTICAST\n#define igmp_ifc_event(x)\tdo { } while (0)\n#endif\n\nstatic int ip_mc_del_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\n\t\t\t int sfcount, __be32 *psfsrc, int delta)\n{\n\tstruct ip_mc_list *pmc;\n\tint\tchangerec = 0;\n\tint\ti, err;\n\n\tif (!in_dev)\n\t\treturn -ENODEV;\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tif (*pmca == pmc->multiaddr)\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\n\t\t/* MCA not found?? bug */\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tspin_lock_bh(&pmc->lock);\n\trcu_read_unlock();\n#ifdef CONFIG_IP_MULTICAST\n\tsf_markstate(pmc);\n#endif\n\tif (!delta) {\n\t\terr = -EINVAL;\n\t\tif (!pmc->sfcount[sfmode])\n\t\t\tgoto out_unlock;\n\t\tpmc->sfcount[sfmode]--;\n\t}\n\terr = 0;\n\tfor (i=0; i<sfcount; i++) {\n\t\tint rv = ip_mc_del1_src(pmc, sfmode, &psfsrc[i]);\n\n\t\tchangerec |= rv > 0;\n\t\tif (!err && rv < 0)\n\t\t\terr = rv;\n\t}\n\tif (pmc->sfmode == MCAST_EXCLUDE &&\n\t    pmc->sfcount[MCAST_EXCLUDE] == 0 &&\n\t    pmc->sfcount[MCAST_INCLUDE]) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tstruct ip_sf_list *psf;\n#endif\n\n\t\t/* filter mode change */\n\t\tpmc->sfmode = MCAST_INCLUDE;\n#ifdef CONFIG_IP_MULTICAST\n\t\tpmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\t\tIGMP_Unsolicited_Report_Count;\n\t\tin_dev->mr_ifc_count = pmc->crcount;\n\t\tfor (psf=pmc->sources; psf; psf = psf->sf_next)\n\t\t\tpsf->sf_crcount = 0;\n\t\tigmp_ifc_event(pmc->interface);\n\t} else if (sf_setstate(pmc) || changerec) {\n\t\tigmp_ifc_event(pmc->interface);\n#endif\n\t}\nout_unlock:\n\tspin_unlock_bh(&pmc->lock);\n\treturn err;\n}\n\n/*\n * Add multicast single-source filter to the interface list\n */\nstatic int ip_mc_add1_src(struct ip_mc_list *pmc, int sfmode,\n\t__be32 *psfsrc, int delta)\n{\n\tstruct ip_sf_list *psf, *psf_prev;\n\n\tpsf_prev = NULL;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (psf->sf_inaddr == *psfsrc)\n\t\t\tbreak;\n\t\tpsf_prev = psf;\n\t}\n\tif (!psf) {\n\t\tpsf = kzalloc(sizeof(*psf), GFP_ATOMIC);\n\t\tif (!psf)\n\t\t\treturn -ENOBUFS;\n\t\tpsf->sf_inaddr = *psfsrc;\n\t\tif (psf_prev) {\n\t\t\tpsf_prev->sf_next = psf;\n\t\t} else\n\t\t\tpmc->sources = psf;\n\t}\n\tpsf->sf_count[sfmode]++;\n\tif (psf->sf_count[sfmode] == 1) {\n\t\tip_rt_multicast_event(pmc->interface);\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_IP_MULTICAST\nstatic void sf_markstate(struct ip_mc_list *pmc)\n{\n\tstruct ip_sf_list *psf;\n\tint mca_xcount = pmc->sfcount[MCAST_EXCLUDE];\n\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next)\n\t\tif (pmc->sfcount[MCAST_EXCLUDE]) {\n\t\t\tpsf->sf_oldin = mca_xcount ==\n\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] &&\n\t\t\t\t!psf->sf_count[MCAST_INCLUDE];\n\t\t} else\n\t\t\tpsf->sf_oldin = psf->sf_count[MCAST_INCLUDE] != 0;\n}\n\nstatic int sf_setstate(struct ip_mc_list *pmc)\n{\n\tstruct ip_sf_list *psf, *dpsf;\n\tint mca_xcount = pmc->sfcount[MCAST_EXCLUDE];\n\tint qrv = pmc->interface->mr_qrv;\n\tint new_in, rv;\n\n\trv = 0;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (pmc->sfcount[MCAST_EXCLUDE]) {\n\t\t\tnew_in = mca_xcount == psf->sf_count[MCAST_EXCLUDE] &&\n\t\t\t\t!psf->sf_count[MCAST_INCLUDE];\n\t\t} else\n\t\t\tnew_in = psf->sf_count[MCAST_INCLUDE] != 0;\n\t\tif (new_in) {\n\t\t\tif (!psf->sf_oldin) {\n\t\t\t\tstruct ip_sf_list *prev = NULL;\n\n\t\t\t\tfor (dpsf=pmc->tomb; dpsf; dpsf=dpsf->sf_next) {\n\t\t\t\t\tif (dpsf->sf_inaddr == psf->sf_inaddr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprev = dpsf;\n\t\t\t\t}\n\t\t\t\tif (dpsf) {\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\tprev->sf_next = dpsf->sf_next;\n\t\t\t\t\telse\n\t\t\t\t\t\tpmc->tomb = dpsf->sf_next;\n\t\t\t\t\tkfree(dpsf);\n\t\t\t\t}\n\t\t\t\tpsf->sf_crcount = qrv;\n\t\t\t\trv++;\n\t\t\t}\n\t\t} else if (psf->sf_oldin) {\n\n\t\t\tpsf->sf_crcount = 0;\n\t\t\t/*\n\t\t\t * add or update \"delete\" records if an active filter\n\t\t\t * is now inactive\n\t\t\t */\n\t\t\tfor (dpsf=pmc->tomb; dpsf; dpsf=dpsf->sf_next)\n\t\t\t\tif (dpsf->sf_inaddr == psf->sf_inaddr)\n\t\t\t\t\tbreak;\n\t\t\tif (!dpsf) {\n\t\t\t\tdpsf = kmalloc(sizeof(*dpsf), GFP_ATOMIC);\n\t\t\t\tif (!dpsf)\n\t\t\t\t\tcontinue;\n\t\t\t\t*dpsf = *psf;\n\t\t\t\t/* pmc->lock held by callers */\n\t\t\t\tdpsf->sf_next = pmc->tomb;\n\t\t\t\tpmc->tomb = dpsf;\n\t\t\t}\n\t\t\tdpsf->sf_crcount = qrv;\n\t\t\trv++;\n\t\t}\n\t}\n\treturn rv;\n}\n#endif\n\n/*\n * Add multicast source filter list to the interface list\n */\nstatic int ip_mc_add_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\n\t\t\t int sfcount, __be32 *psfsrc, int delta)\n{\n\tstruct ip_mc_list *pmc;\n\tint\tisexclude;\n\tint\ti, err;\n\n\tif (!in_dev)\n\t\treturn -ENODEV;\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tif (*pmca == pmc->multiaddr)\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\n\t\t/* MCA not found?? bug */\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tspin_lock_bh(&pmc->lock);\n\trcu_read_unlock();\n\n#ifdef CONFIG_IP_MULTICAST\n\tsf_markstate(pmc);\n#endif\n\tisexclude = pmc->sfmode == MCAST_EXCLUDE;\n\tif (!delta)\n\t\tpmc->sfcount[sfmode]++;\n\terr = 0;\n\tfor (i=0; i<sfcount; i++) {\n\t\terr = ip_mc_add1_src(pmc, sfmode, &psfsrc[i], delta);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (err) {\n\t\tint j;\n\n\t\tif (!delta)\n\t\t\tpmc->sfcount[sfmode]--;\n\t\tfor (j=0; j<i; j++)\n\t\t\t(void) ip_mc_del1_src(pmc, sfmode, &psfsrc[j]);\n\t} else if (isexclude != (pmc->sfcount[MCAST_EXCLUDE] != 0)) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tstruct ip_sf_list *psf;\n\t\tin_dev = pmc->interface;\n#endif\n\n\t\t/* filter mode change */\n\t\tif (pmc->sfcount[MCAST_EXCLUDE])\n\t\t\tpmc->sfmode = MCAST_EXCLUDE;\n\t\telse if (pmc->sfcount[MCAST_INCLUDE])\n\t\t\tpmc->sfmode = MCAST_INCLUDE;\n#ifdef CONFIG_IP_MULTICAST\n\t\t/* else no filters; keep old mode for reports */\n\n\t\tpmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\t\tIGMP_Unsolicited_Report_Count;\n\t\tin_dev->mr_ifc_count = pmc->crcount;\n\t\tfor (psf=pmc->sources; psf; psf = psf->sf_next)\n\t\t\tpsf->sf_crcount = 0;\n\t\tigmp_ifc_event(in_dev);\n\t} else if (sf_setstate(pmc)) {\n\t\tigmp_ifc_event(in_dev);\n#endif\n\t}\n\tspin_unlock_bh(&pmc->lock);\n\treturn err;\n}\n\nstatic void ip_mc_clear_src(struct ip_mc_list *pmc)\n{\n\tstruct ip_sf_list *psf, *nextpsf;\n\n\tfor (psf=pmc->tomb; psf; psf=nextpsf) {\n\t\tnextpsf = psf->sf_next;\n\t\tkfree(psf);\n\t}\n\tpmc->tomb = NULL;\n\tfor (psf=pmc->sources; psf; psf=nextpsf) {\n\t\tnextpsf = psf->sf_next;\n\t\tkfree(psf);\n\t}\n\tpmc->sources = NULL;\n\tpmc->sfmode = MCAST_EXCLUDE;\n\tpmc->sfcount[MCAST_INCLUDE] = 0;\n\tpmc->sfcount[MCAST_EXCLUDE] = 1;\n}\n\n\n/*\n * Join a multicast group\n */\nint ip_mc_join_group(struct sock *sk , struct ip_mreqn *imr)\n{\n\tint err;\n\t__be32 addr = imr->imr_multiaddr.s_addr;\n\tstruct ip_mc_socklist *iml = NULL, *i;\n\tstruct in_device *in_dev;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint ifindex;\n\tint count = 0;\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\tin_dev = ip_mc_find_dev(net, imr);\n\n\tif (!in_dev) {\n\t\timl = NULL;\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\n\terr = -EADDRINUSE;\n\tifindex = imr->imr_ifindex;\n\tfor_each_pmc_rtnl(inet, i) {\n\t\tif (i->multi.imr_multiaddr.s_addr == addr &&\n\t\t    i->multi.imr_ifindex == ifindex)\n\t\t\tgoto done;\n\t\tcount++;\n\t}\n\terr = -ENOBUFS;\n\tif (count >= sysctl_igmp_max_memberships)\n\t\tgoto done;\n\timl = sock_kmalloc(sk, sizeof(*iml), GFP_KERNEL);\n\tif (iml == NULL)\n\t\tgoto done;\n\n\tmemcpy(&iml->multi, imr, sizeof(*imr));\n\timl->next_rcu = inet->mc_list;\n\timl->sflist = NULL;\n\timl->sfmode = MCAST_EXCLUDE;\n\tRCU_INIT_POINTER(inet->mc_list, iml);\n\tip_mc_inc_group(in_dev, addr);\n\terr = 0;\ndone:\n\trtnl_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(ip_mc_join_group);\n\nstatic int ip_mc_leave_src(struct sock *sk, struct ip_mc_socklist *iml,\n\t\t\t   struct in_device *in_dev)\n{\n\tstruct ip_sf_socklist *psf = rtnl_dereference(iml->sflist);\n\tint err;\n\n\tif (psf == NULL) {\n\t\t/* any-source empty exclude case */\n\t\treturn ip_mc_del_src(in_dev, &iml->multi.imr_multiaddr.s_addr,\n\t\t\timl->sfmode, 0, NULL, 0);\n\t}\n\terr = ip_mc_del_src(in_dev, &iml->multi.imr_multiaddr.s_addr,\n\t\t\timl->sfmode, psf->sl_count, psf->sl_addr, 0);\n\tRCU_INIT_POINTER(iml->sflist, NULL);\n\t/* decrease mem now to avoid the memleak warning */\n\tatomic_sub(IP_SFLSIZE(psf->sl_max), &sk->sk_omem_alloc);\n\tkfree_rcu(psf, rcu);\n\treturn err;\n}\n\n/*\n *\tAsk a socket to leave a group.\n */\n\nint ip_mc_leave_group(struct sock *sk, struct ip_mreqn *imr)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_mc_socklist *iml;\n\tstruct ip_mc_socklist __rcu **imlp;\n\tstruct in_device *in_dev;\n\tstruct net *net = sock_net(sk);\n\t__be32 group = imr->imr_multiaddr.s_addr;\n\tu32 ifindex;\n\tint ret = -EADDRNOTAVAIL;\n\n\trtnl_lock();\n\tin_dev = ip_mc_find_dev(net, imr);\n\tifindex = imr->imr_ifindex;\n\tfor (imlp = &inet->mc_list;\n\t     (iml = rtnl_dereference(*imlp)) != NULL;\n\t     imlp = &iml->next_rcu) {\n\t\tif (iml->multi.imr_multiaddr.s_addr != group)\n\t\t\tcontinue;\n\t\tif (ifindex) {\n\t\t\tif (iml->multi.imr_ifindex != ifindex)\n\t\t\t\tcontinue;\n\t\t} else if (imr->imr_address.s_addr && imr->imr_address.s_addr !=\n\t\t\t\timl->multi.imr_address.s_addr)\n\t\t\tcontinue;\n\n\t\t(void) ip_mc_leave_src(sk, iml, in_dev);\n\n\t\t*imlp = iml->next_rcu;\n\n\t\tif (in_dev)\n\t\t\tip_mc_dec_group(in_dev, group);\n\t\trtnl_unlock();\n\t\t/* decrease mem now to avoid the memleak warning */\n\t\tatomic_sub(sizeof(*iml), &sk->sk_omem_alloc);\n\t\tkfree_rcu(iml, rcu);\n\t\treturn 0;\n\t}\n\tif (!in_dev)\n\t\tret = -ENODEV;\n\trtnl_unlock();\n\treturn ret;\n}\n\nint ip_mc_source(int add, int omode, struct sock *sk, struct\n\tip_mreq_source *mreqs, int ifindex)\n{\n\tint err;\n\tstruct ip_mreqn imr;\n\t__be32 addr = mreqs->imr_multiaddr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct in_device *in_dev = NULL;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *psl;\n\tstruct net *net = sock_net(sk);\n\tint leavegroup = 0;\n\tint i, j, rv;\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\timr.imr_multiaddr.s_addr = mreqs->imr_multiaddr;\n\timr.imr_address.s_addr = mreqs->imr_interface;\n\timr.imr_ifindex = ifindex;\n\tin_dev = ip_mc_find_dev(net, &imr);\n\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\terr = -EADDRNOTAVAIL;\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif ((pmc->multi.imr_multiaddr.s_addr ==\n\t\t     imr.imr_multiaddr.s_addr) &&\n\t\t    (pmc->multi.imr_ifindex == imr.imr_ifindex))\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\t\t/* must have a prior join */\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\t/* if a source filter was set, must be the same mode as before */\n\tif (pmc->sflist) {\n\t\tif (pmc->sfmode != omode) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t} else if (pmc->sfmode != omode) {\n\t\t/* allow mode switches for empty-set filters */\n\t\tip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 0, NULL, 0);\n\t\tip_mc_del_src(in_dev, &mreqs->imr_multiaddr, pmc->sfmode, 0,\n\t\t\tNULL, 0);\n\t\tpmc->sfmode = omode;\n\t}\n\n\tpsl = rtnl_dereference(pmc->sflist);\n\tif (!add) {\n\t\tif (!psl)\n\t\t\tgoto done;\t/* err = -EADDRNOTAVAIL */\n\t\trv = !0;\n\t\tfor (i=0; i<psl->sl_count; i++) {\n\t\t\trv = memcmp(&psl->sl_addr[i], &mreqs->imr_sourceaddr,\n\t\t\t\tsizeof(__be32));\n\t\t\tif (rv == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (rv)\t\t/* source not found */\n\t\t\tgoto done;\t/* err = -EADDRNOTAVAIL */\n\n\t\t/* special case - (INCLUDE, empty) == LEAVE_GROUP */\n\t\tif (psl->sl_count == 1 && omode == MCAST_INCLUDE) {\n\t\t\tleavegroup = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* update the interface filter */\n\t\tip_mc_del_src(in_dev, &mreqs->imr_multiaddr, omode, 1,\n\t\t\t&mreqs->imr_sourceaddr, 1);\n\n\t\tfor (j=i+1; j<psl->sl_count; j++)\n\t\t\tpsl->sl_addr[j-1] = psl->sl_addr[j];\n\t\tpsl->sl_count--;\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\t/* else, add a new source to the filter */\n\n\tif (psl && psl->sl_count >= sysctl_igmp_max_msf) {\n\t\terr = -ENOBUFS;\n\t\tgoto done;\n\t}\n\tif (!psl || psl->sl_count == psl->sl_max) {\n\t\tstruct ip_sf_socklist *newpsl;\n\t\tint count = IP_SFBLOCK;\n\n\t\tif (psl)\n\t\t\tcount += psl->sl_max;\n\t\tnewpsl = sock_kmalloc(sk, IP_SFLSIZE(count), GFP_KERNEL);\n\t\tif (!newpsl) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto done;\n\t\t}\n\t\tnewpsl->sl_max = count;\n\t\tnewpsl->sl_count = count - IP_SFBLOCK;\n\t\tif (psl) {\n\t\t\tfor (i=0; i<psl->sl_count; i++)\n\t\t\t\tnewpsl->sl_addr[i] = psl->sl_addr[i];\n\t\t\t/* decrease mem now to avoid the memleak warning */\n\t\t\tatomic_sub(IP_SFLSIZE(psl->sl_max), &sk->sk_omem_alloc);\n\t\t\tkfree_rcu(psl, rcu);\n\t\t}\n\t\tRCU_INIT_POINTER(pmc->sflist, newpsl);\n\t\tpsl = newpsl;\n\t}\n\trv = 1;\t/* > 0 for insert logic below if sl_count is 0 */\n\tfor (i=0; i<psl->sl_count; i++) {\n\t\trv = memcmp(&psl->sl_addr[i], &mreqs->imr_sourceaddr,\n\t\t\tsizeof(__be32));\n\t\tif (rv == 0)\n\t\t\tbreak;\n\t}\n\tif (rv == 0)\t\t/* address already there is an error */\n\t\tgoto done;\n\tfor (j=psl->sl_count-1; j>=i; j--)\n\t\tpsl->sl_addr[j+1] = psl->sl_addr[j];\n\tpsl->sl_addr[i] = mreqs->imr_sourceaddr;\n\tpsl->sl_count++;\n\terr = 0;\n\t/* update the interface list */\n\tip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 1,\n\t\t&mreqs->imr_sourceaddr, 1);\ndone:\n\trtnl_unlock();\n\tif (leavegroup)\n\t\treturn ip_mc_leave_group(sk, &imr);\n\treturn err;\n}\n\nint ip_mc_msfilter(struct sock *sk, struct ip_msfilter *msf, int ifindex)\n{\n\tint err = 0;\n\tstruct ip_mreqn\timr;\n\t__be32 addr = msf->imsf_multiaddr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct in_device *in_dev;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *newpsl, *psl;\n\tstruct net *net = sock_net(sk);\n\tint leavegroup = 0;\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\tif (msf->imsf_fmode != MCAST_INCLUDE &&\n\t    msf->imsf_fmode != MCAST_EXCLUDE)\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\timr.imr_multiaddr.s_addr = msf->imsf_multiaddr;\n\timr.imr_address.s_addr = msf->imsf_interface;\n\timr.imr_ifindex = ifindex;\n\tin_dev = ip_mc_find_dev(net, &imr);\n\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\n\t/* special case - (INCLUDE, empty) == LEAVE_GROUP */\n\tif (msf->imsf_fmode == MCAST_INCLUDE && msf->imsf_numsrc == 0) {\n\t\tleavegroup = 1;\n\t\tgoto done;\n\t}\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == msf->imsf_multiaddr &&\n\t\t    pmc->multi.imr_ifindex == imr.imr_ifindex)\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\t\t/* must have a prior join */\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (msf->imsf_numsrc) {\n\t\tnewpsl = sock_kmalloc(sk, IP_SFLSIZE(msf->imsf_numsrc),\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!newpsl) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto done;\n\t\t}\n\t\tnewpsl->sl_max = newpsl->sl_count = msf->imsf_numsrc;\n\t\tmemcpy(newpsl->sl_addr, msf->imsf_slist,\n\t\t\tmsf->imsf_numsrc * sizeof(msf->imsf_slist[0]));\n\t\terr = ip_mc_add_src(in_dev, &msf->imsf_multiaddr,\n\t\t\tmsf->imsf_fmode, newpsl->sl_count, newpsl->sl_addr, 0);\n\t\tif (err) {\n\t\t\tsock_kfree_s(sk, newpsl, IP_SFLSIZE(newpsl->sl_max));\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tnewpsl = NULL;\n\t\t(void) ip_mc_add_src(in_dev, &msf->imsf_multiaddr,\n\t\t\t\t     msf->imsf_fmode, 0, NULL, 0);\n\t}\n\tpsl = rtnl_dereference(pmc->sflist);\n\tif (psl) {\n\t\t(void) ip_mc_del_src(in_dev, &msf->imsf_multiaddr, pmc->sfmode,\n\t\t\tpsl->sl_count, psl->sl_addr, 0);\n\t\t/* decrease mem now to avoid the memleak warning */\n\t\tatomic_sub(IP_SFLSIZE(psl->sl_max), &sk->sk_omem_alloc);\n\t\tkfree_rcu(psl, rcu);\n\t} else\n\t\t(void) ip_mc_del_src(in_dev, &msf->imsf_multiaddr, pmc->sfmode,\n\t\t\t0, NULL, 0);\n\tRCU_INIT_POINTER(pmc->sflist, newpsl);\n\tpmc->sfmode = msf->imsf_fmode;\n\terr = 0;\ndone:\n\trtnl_unlock();\n\tif (leavegroup)\n\t\terr = ip_mc_leave_group(sk, &imr);\n\treturn err;\n}\n\nint ip_mc_msfget(struct sock *sk, struct ip_msfilter *msf,\n\tstruct ip_msfilter __user *optval, int __user *optlen)\n{\n\tint err, len, count, copycount;\n\tstruct ip_mreqn\timr;\n\t__be32 addr = msf->imsf_multiaddr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct in_device *in_dev;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *psl;\n\tstruct net *net = sock_net(sk);\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\timr.imr_multiaddr.s_addr = msf->imsf_multiaddr;\n\timr.imr_address.s_addr = msf->imsf_interface;\n\timr.imr_ifindex = 0;\n\tin_dev = ip_mc_find_dev(net, &imr);\n\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\terr = -EADDRNOTAVAIL;\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == msf->imsf_multiaddr &&\n\t\t    pmc->multi.imr_ifindex == imr.imr_ifindex)\n\t\t\tbreak;\n\t}\n\tif (!pmc)\t\t/* must have a prior join */\n\t\tgoto done;\n\tmsf->imsf_fmode = pmc->sfmode;\n\tpsl = rtnl_dereference(pmc->sflist);\n\trtnl_unlock();\n\tif (!psl) {\n\t\tlen = 0;\n\t\tcount = 0;\n\t} else {\n\t\tcount = psl->sl_count;\n\t}\n\tcopycount = count < msf->imsf_numsrc ? count : msf->imsf_numsrc;\n\tlen = copycount * sizeof(psl->sl_addr[0]);\n\tmsf->imsf_numsrc = count;\n\tif (put_user(IP_MSFILTER_SIZE(copycount), optlen) ||\n\t    copy_to_user(optval, msf, IP_MSFILTER_SIZE(0))) {\n\t\treturn -EFAULT;\n\t}\n\tif (len &&\n\t    copy_to_user(&optval->imsf_slist[0], psl->sl_addr, len))\n\t\treturn -EFAULT;\n\treturn 0;\ndone:\n\trtnl_unlock();\n\treturn err;\n}\n\nint ip_mc_gsfget(struct sock *sk, struct group_filter *gsf,\n\tstruct group_filter __user *optval, int __user *optlen)\n{\n\tint err, i, count, copycount;\n\tstruct sockaddr_in *psin;\n\t__be32 addr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *psl;\n\n\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\tif (psin->sin_family != AF_INET)\n\t\treturn -EINVAL;\n\taddr = psin->sin_addr.s_addr;\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\terr = -EADDRNOTAVAIL;\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == addr &&\n\t\t    pmc->multi.imr_ifindex == gsf->gf_interface)\n\t\t\tbreak;\n\t}\n\tif (!pmc)\t\t/* must have a prior join */\n\t\tgoto done;\n\tgsf->gf_fmode = pmc->sfmode;\n\tpsl = rtnl_dereference(pmc->sflist);\n\trtnl_unlock();\n\tcount = psl ? psl->sl_count : 0;\n\tcopycount = count < gsf->gf_numsrc ? count : gsf->gf_numsrc;\n\tgsf->gf_numsrc = count;\n\tif (put_user(GROUP_FILTER_SIZE(copycount), optlen) ||\n\t    copy_to_user(optval, gsf, GROUP_FILTER_SIZE(0))) {\n\t\treturn -EFAULT;\n\t}\n\tfor (i=0; i<copycount; i++) {\n\t\tstruct sockaddr_storage ss;\n\n\t\tpsin = (struct sockaddr_in *)&ss;\n\t\tmemset(&ss, 0, sizeof(ss));\n\t\tpsin->sin_family = AF_INET;\n\t\tpsin->sin_addr.s_addr = psl->sl_addr[i];\n\t\tif (copy_to_user(&optval->gf_slist[i], &ss, sizeof(ss)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\ndone:\n\trtnl_unlock();\n\treturn err;\n}\n\n/*\n * check if a multicast source filter allows delivery for a given <src,dst,intf>\n */\nint ip_mc_sf_allow(struct sock *sk, __be32 loc_addr, __be32 rmt_addr, int dif)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_mc_socklist *pmc;\n\tstruct ip_sf_socklist *psl;\n\tint i;\n\tint ret;\n\n\tret = 1;\n\tif (!ipv4_is_multicast(loc_addr))\n\t\tgoto out;\n\n\trcu_read_lock();\n\tfor_each_pmc_rcu(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == loc_addr &&\n\t\t    pmc->multi.imr_ifindex == dif)\n\t\t\tbreak;\n\t}\n\tret = inet->mc_all;\n\tif (!pmc)\n\t\tgoto unlock;\n\tpsl = rcu_dereference(pmc->sflist);\n\tret = (pmc->sfmode == MCAST_EXCLUDE);\n\tif (!psl)\n\t\tgoto unlock;\n\n\tfor (i=0; i<psl->sl_count; i++) {\n\t\tif (psl->sl_addr[i] == rmt_addr)\n\t\t\tbreak;\n\t}\n\tret = 0;\n\tif (pmc->sfmode == MCAST_INCLUDE && i >= psl->sl_count)\n\t\tgoto unlock;\n\tif (pmc->sfmode == MCAST_EXCLUDE && i < psl->sl_count)\n\t\tgoto unlock;\n\tret = 1;\nunlock:\n\trcu_read_unlock();\nout:\n\treturn ret;\n}\n\n/*\n *\tA socket is closing.\n */\n\nvoid ip_mc_drop_socket(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_mc_socklist *iml;\n\tstruct net *net = sock_net(sk);\n\n\tif (inet->mc_list == NULL)\n\t\treturn;\n\n\trtnl_lock();\n\twhile ((iml = rtnl_dereference(inet->mc_list)) != NULL) {\n\t\tstruct in_device *in_dev;\n\n\t\tinet->mc_list = iml->next_rcu;\n\t\tin_dev = inetdev_by_index(net, iml->multi.imr_ifindex);\n\t\t(void) ip_mc_leave_src(sk, iml, in_dev);\n\t\tif (in_dev != NULL)\n\t\t\tip_mc_dec_group(in_dev, iml->multi.imr_multiaddr.s_addr);\n\t\t/* decrease mem now to avoid the memleak warning */\n\t\tatomic_sub(sizeof(*iml), &sk->sk_omem_alloc);\n\t\tkfree_rcu(iml, rcu);\n\t}\n\trtnl_unlock();\n}\n\n/* called with rcu_read_lock() */\nint ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u16 proto)\n{\n\tstruct ip_mc_list *im;\n\tstruct ip_sf_list *psf;\n\tint rv = 0;\n\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tif (im->multiaddr == mc_addr)\n\t\t\tbreak;\n\t}\n\tif (im && proto == IPPROTO_IGMP) {\n\t\trv = 1;\n\t} else if (im) {\n\t\tif (src_addr) {\n\t\t\tfor (psf=im->sources; psf; psf=psf->sf_next) {\n\t\t\t\tif (psf->sf_inaddr == src_addr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (psf)\n\t\t\t\trv = psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] !=\n\t\t\t\t\tim->sfcount[MCAST_EXCLUDE];\n\t\t\telse\n\t\t\t\trv = im->sfcount[MCAST_EXCLUDE] != 0;\n\t\t} else\n\t\t\trv = 1; /* unspecified source; tentatively allow */\n\t}\n\treturn rv;\n}\n\n#if defined(CONFIG_PROC_FS)\nstruct igmp_mc_iter_state {\n\tstruct seq_net_private p;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n};\n\n#define\tigmp_mc_seq_private(seq)\t((struct igmp_mc_iter_state *)(seq)->private)\n\nstatic inline struct ip_mc_list *igmp_mc_get_first(struct seq_file *seq)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct ip_mc_list *im = NULL;\n\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\n\tstate->in_dev = NULL;\n\tfor_each_netdev_rcu(net, state->dev) {\n\t\tstruct in_device *in_dev;\n\n\t\tin_dev = __in_dev_get_rcu(state->dev);\n\t\tif (!in_dev)\n\t\t\tcontinue;\n\t\tim = rcu_dereference(in_dev->mc_list);\n\t\tif (im) {\n\t\t\tstate->in_dev = in_dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn im;\n}\n\nstatic struct ip_mc_list *igmp_mc_get_next(struct seq_file *seq, struct ip_mc_list *im)\n{\n\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\n\tim = rcu_dereference(im->next_rcu);\n\twhile (!im) {\n\t\tstate->dev = next_net_device_rcu(state->dev);\n\t\tif (!state->dev) {\n\t\t\tstate->in_dev = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tstate->in_dev = __in_dev_get_rcu(state->dev);\n\t\tif (!state->in_dev)\n\t\t\tcontinue;\n\t\tim = rcu_dereference(state->in_dev->mc_list);\n\t}\n\treturn im;\n}\n\nstatic struct ip_mc_list *igmp_mc_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct ip_mc_list *im = igmp_mc_get_first(seq);\n\tif (im)\n\t\twhile (pos && (im = igmp_mc_get_next(seq, im)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : im;\n}\n\nstatic void *igmp_mc_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn *pos ? igmp_mc_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *igmp_mc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ip_mc_list *im;\n\tif (v == SEQ_START_TOKEN)\n\t\tim = igmp_mc_get_first(seq);\n\telse\n\t\tim = igmp_mc_get_next(seq, v);\n\t++*pos;\n\treturn im;\n}\n\nstatic void igmp_mc_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\n\tstate->in_dev = NULL;\n\tstate->dev = NULL;\n\trcu_read_unlock();\n}\n\nstatic int igmp_mc_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"Idx\\tDevice    : Count Querier\\tGroup    Users Timer\\tReporter\\n\");\n\telse {\n\t\tstruct ip_mc_list *im = (struct ip_mc_list *)v;\n\t\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\t\tchar   *querier;\n#ifdef CONFIG_IP_MULTICAST\n\t\tquerier = IGMP_V1_SEEN(state->in_dev) ? \"V1\" :\n\t\t\t  IGMP_V2_SEEN(state->in_dev) ? \"V2\" :\n\t\t\t  \"V3\";\n#else\n\t\tquerier = \"NONE\";\n#endif\n\n\t\tif (rcu_dereference(state->in_dev->mc_list) == im) {\n\t\t\tseq_printf(seq, \"%d\\t%-10s: %5d %7s\\n\",\n\t\t\t\t   state->dev->ifindex, state->dev->name, state->in_dev->mc_count, querier);\n\t\t}\n\n\t\tseq_printf(seq,\n\t\t\t   \"\\t\\t\\t\\t%08X %5d %d:%08lX\\t\\t%d\\n\",\n\t\t\t   im->multiaddr, im->users,\n\t\t\t   im->tm_running, im->tm_running ?\n\t\t\t   jiffies_to_clock_t(im->timer.expires-jiffies) : 0,\n\t\t\t   im->reporter);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations igmp_mc_seq_ops = {\n\t.start\t=\tigmp_mc_seq_start,\n\t.next\t=\tigmp_mc_seq_next,\n\t.stop\t=\tigmp_mc_seq_stop,\n\t.show\t=\tigmp_mc_seq_show,\n};\n\nstatic int igmp_mc_seq_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &igmp_mc_seq_ops,\n\t\t\tsizeof(struct igmp_mc_iter_state));\n}\n\nstatic const struct file_operations igmp_mc_seq_fops = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tigmp_mc_seq_open,\n\t.read\t\t=\tseq_read,\n\t.llseek\t\t=\tseq_lseek,\n\t.release\t=\tseq_release_net,\n};\n\nstruct igmp_mcf_iter_state {\n\tstruct seq_net_private p;\n\tstruct net_device *dev;\n\tstruct in_device *idev;\n\tstruct ip_mc_list *im;\n};\n\n#define igmp_mcf_seq_private(seq)\t((struct igmp_mcf_iter_state *)(seq)->private)\n\nstatic inline struct ip_sf_list *igmp_mcf_get_first(struct seq_file *seq)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct ip_sf_list *psf = NULL;\n\tstruct ip_mc_list *im = NULL;\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\n\tstate->idev = NULL;\n\tstate->im = NULL;\n\tfor_each_netdev_rcu(net, state->dev) {\n\t\tstruct in_device *idev;\n\t\tidev = __in_dev_get_rcu(state->dev);\n\t\tif (unlikely(idev == NULL))\n\t\t\tcontinue;\n\t\tim = rcu_dereference(idev->mc_list);\n\t\tif (likely(im != NULL)) {\n\t\t\tspin_lock_bh(&im->lock);\n\t\t\tpsf = im->sources;\n\t\t\tif (likely(psf != NULL)) {\n\t\t\t\tstate->im = im;\n\t\t\t\tstate->idev = idev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_bh(&im->lock);\n\t\t}\n\t}\n\treturn psf;\n}\n\nstatic struct ip_sf_list *igmp_mcf_get_next(struct seq_file *seq, struct ip_sf_list *psf)\n{\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\n\tpsf = psf->sf_next;\n\twhile (!psf) {\n\t\tspin_unlock_bh(&state->im->lock);\n\t\tstate->im = state->im->next;\n\t\twhile (!state->im) {\n\t\t\tstate->dev = next_net_device_rcu(state->dev);\n\t\t\tif (!state->dev) {\n\t\t\t\tstate->idev = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstate->idev = __in_dev_get_rcu(state->dev);\n\t\t\tif (!state->idev)\n\t\t\t\tcontinue;\n\t\t\tstate->im = rcu_dereference(state->idev->mc_list);\n\t\t}\n\t\tif (!state->im)\n\t\t\tbreak;\n\t\tspin_lock_bh(&state->im->lock);\n\t\tpsf = state->im->sources;\n\t}\nout:\n\treturn psf;\n}\n\nstatic struct ip_sf_list *igmp_mcf_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct ip_sf_list *psf = igmp_mcf_get_first(seq);\n\tif (psf)\n\t\twhile (pos && (psf = igmp_mcf_get_next(seq, psf)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : psf;\n}\n\nstatic void *igmp_mcf_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn *pos ? igmp_mcf_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *igmp_mcf_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ip_sf_list *psf;\n\tif (v == SEQ_START_TOKEN)\n\t\tpsf = igmp_mcf_get_first(seq);\n\telse\n\t\tpsf = igmp_mcf_get_next(seq, v);\n\t++*pos;\n\treturn psf;\n}\n\nstatic void igmp_mcf_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\tif (likely(state->im != NULL)) {\n\t\tspin_unlock_bh(&state->im->lock);\n\t\tstate->im = NULL;\n\t}\n\tstate->idev = NULL;\n\tstate->dev = NULL;\n\trcu_read_unlock();\n}\n\nstatic int igmp_mcf_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct ip_sf_list *psf = (struct ip_sf_list *)v;\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq,\n\t\t\t   \"%3s %6s \"\n\t\t\t   \"%10s %10s %6s %6s\\n\", \"Idx\",\n\t\t\t   \"Device\", \"MCA\",\n\t\t\t   \"SRC\", \"INC\", \"EXC\");\n\t} else {\n\t\tseq_printf(seq,\n\t\t\t   \"%3d %6.6s 0x%08x \"\n\t\t\t   \"0x%08x %6lu %6lu\\n\",\n\t\t\t   state->dev->ifindex, state->dev->name,\n\t\t\t   ntohl(state->im->multiaddr),\n\t\t\t   ntohl(psf->sf_inaddr),\n\t\t\t   psf->sf_count[MCAST_INCLUDE],\n\t\t\t   psf->sf_count[MCAST_EXCLUDE]);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations igmp_mcf_seq_ops = {\n\t.start\t=\tigmp_mcf_seq_start,\n\t.next\t=\tigmp_mcf_seq_next,\n\t.stop\t=\tigmp_mcf_seq_stop,\n\t.show\t=\tigmp_mcf_seq_show,\n};\n\nstatic int igmp_mcf_seq_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &igmp_mcf_seq_ops,\n\t\t\tsizeof(struct igmp_mcf_iter_state));\n}\n\nstatic const struct file_operations igmp_mcf_seq_fops = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tigmp_mcf_seq_open,\n\t.read\t\t=\tseq_read,\n\t.llseek\t\t=\tseq_lseek,\n\t.release\t=\tseq_release_net,\n};\n\nstatic int __net_init igmp_net_init(struct net *net)\n{\n\tstruct proc_dir_entry *pde;\n\n\tpde = proc_net_fops_create(net, \"igmp\", S_IRUGO, &igmp_mc_seq_fops);\n\tif (!pde)\n\t\tgoto out_igmp;\n\tpde = proc_net_fops_create(net, \"mcfilter\", S_IRUGO, &igmp_mcf_seq_fops);\n\tif (!pde)\n\t\tgoto out_mcfilter;\n\treturn 0;\n\nout_mcfilter:\n\tproc_net_remove(net, \"igmp\");\nout_igmp:\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit igmp_net_exit(struct net *net)\n{\n\tproc_net_remove(net, \"mcfilter\");\n\tproc_net_remove(net, \"igmp\");\n}\n\nstatic struct pernet_operations igmp_net_ops = {\n\t.init = igmp_net_init,\n\t.exit = igmp_net_exit,\n};\n\nint __init igmp_mc_proc_init(void)\n{\n\treturn register_pernet_subsys(&igmp_net_ops);\n}\n#endif\n"], "fixing_code": ["/*\n *\tLinux NET3:\tInternet Group Management Protocol  [IGMP]\n *\n *\tThis code implements the IGMP protocol as defined in RFC1112. There has\n *\tbeen a further revision of this protocol since which is now supported.\n *\n *\tIf you have trouble with this module be careful what gcc you have used,\n *\tthe older version didn't come out right using gcc 2.5.8, the newer one\n *\tseems to fall out with gcc 2.6.2.\n *\n *\tAuthors:\n *\t\tAlan Cox <alan@lxorguk.ukuu.org.uk>\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License\n *\tas published by the Free Software Foundation; either version\n *\t2 of the License, or (at your option) any later version.\n *\n *\tFixes:\n *\n *\t\tAlan Cox\t:\tAdded lots of __inline__ to optimise\n *\t\t\t\t\tthe memory usage of all the tiny little\n *\t\t\t\t\tfunctions.\n *\t\tAlan Cox\t:\tDumped the header building experiment.\n *\t\tAlan Cox\t:\tMinor tweaks ready for multicast routing\n *\t\t\t\t\tand extended IGMP protocol.\n *\t\tAlan Cox\t:\tRemoved a load of inline directives. Gcc 2.5.8\n *\t\t\t\t\twrites utterly bogus code otherwise (sigh)\n *\t\t\t\t\tfixed IGMP loopback to behave in the manner\n *\t\t\t\t\tdesired by mrouted, fixed the fact it has been\n *\t\t\t\t\tbroken since 1.3.6 and cleaned up a few minor\n *\t\t\t\t\tpoints.\n *\n *\t\tChih-Jen Chang\t:\tTried to revise IGMP to Version 2\n *\t\tTsu-Sheng Tsao\t\tE-mail: chihjenc@scf.usc.edu and tsusheng@scf.usc.edu\n *\t\t\t\t\tThe enhancements are mainly based on Steve Deering's\n * \t\t\t\t\tipmulti-3.5 source code.\n *\t\tChih-Jen Chang\t:\tAdded the igmp_get_mrouter_info and\n *\t\tTsu-Sheng Tsao\t\tigmp_set_mrouter_info to keep track of\n *\t\t\t\t\tthe mrouted version on that device.\n *\t\tChih-Jen Chang\t:\tAdded the max_resp_time parameter to\n *\t\tTsu-Sheng Tsao\t\tigmp_heard_query(). Using this parameter\n *\t\t\t\t\tto identify the multicast router version\n *\t\t\t\t\tand do what the IGMP version 2 specified.\n *\t\tChih-Jen Chang\t:\tAdded a timer to revert to IGMP V2 router\n *\t\tTsu-Sheng Tsao\t\tif the specified time expired.\n *\t\tAlan Cox\t:\tStop IGMP from 0.0.0.0 being accepted.\n *\t\tAlan Cox\t:\tUse GFP_ATOMIC in the right places.\n *\t\tChristian Daudt :\tigmp timer wasn't set for local group\n *\t\t\t\t\tmemberships but was being deleted,\n *\t\t\t\t\twhich caused a \"del_timer() called\n *\t\t\t\t\tfrom %p with timer not initialized\\n\"\n *\t\t\t\t\tmessage (960131).\n *\t\tChristian Daudt :\tremoved del_timer from\n *\t\t\t\t\tigmp_timer_expire function (960205).\n *             Christian Daudt :       igmp_heard_report now only calls\n *                                     igmp_timer_expire if tm->running is\n *                                     true (960216).\n *\t\tMalcolm Beattie :\tttl comparison wrong in igmp_rcv made\n *\t\t\t\t\tigmp_heard_query never trigger. Expiry\n *\t\t\t\t\tmiscalculation fixed in igmp_heard_query\n *\t\t\t\t\tand random() made to return unsigned to\n *\t\t\t\t\tprevent negative expiry times.\n *\t\tAlexey Kuznetsov:\tWrong group leaving behaviour, backport\n *\t\t\t\t\tfix from pending 2.1.x patches.\n *\t\tAlan Cox:\t\tForget to enable FDDI support earlier.\n *\t\tAlexey Kuznetsov:\tFixed leaving groups on device down.\n *\t\tAlexey Kuznetsov:\tAccordance to igmp-v2-06 draft.\n *\t\tDavid L Stevens:\tIGMPv3 support, with help from\n *\t\t\t\t\tVinay Kulkarni\n */\n\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <asm/uaccess.h>\n#include <asm/system.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n#include <linux/jiffies.h>\n#include <linux/string.h>\n#include <linux/socket.h>\n#include <linux/sockios.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/skbuff.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/if_arp.h>\n#include <linux/rtnetlink.h>\n#include <linux/times.h>\n\n#include <net/net_namespace.h>\n#include <net/arp.h>\n#include <net/ip.h>\n#include <net/protocol.h>\n#include <net/route.h>\n#include <net/sock.h>\n#include <net/checksum.h>\n#include <linux/netfilter_ipv4.h>\n#ifdef CONFIG_IP_MROUTE\n#include <linux/mroute.h>\n#endif\n#ifdef CONFIG_PROC_FS\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#endif\n\n#define IP_MAX_MEMBERSHIPS\t20\n#define IP_MAX_MSF\t\t10\n\n#ifdef CONFIG_IP_MULTICAST\n/* Parameter names and values are taken from igmp-v2-06 draft */\n\n#define IGMP_V1_Router_Present_Timeout\t\t(400*HZ)\n#define IGMP_V2_Router_Present_Timeout\t\t(400*HZ)\n#define IGMP_Unsolicited_Report_Interval\t(10*HZ)\n#define IGMP_Query_Response_Interval\t\t(10*HZ)\n#define IGMP_Unsolicited_Report_Count\t\t2\n\n\n#define IGMP_Initial_Report_Delay\t\t(1)\n\n/* IGMP_Initial_Report_Delay is not from IGMP specs!\n * IGMP specs require to report membership immediately after\n * joining a group, but we delay the first report by a\n * small interval. It seems more natural and still does not\n * contradict to specs provided this delay is small enough.\n */\n\n#define IGMP_V1_SEEN(in_dev) \\\n\t(IPV4_DEVCONF_ALL(dev_net(in_dev->dev), FORCE_IGMP_VERSION) == 1 || \\\n\t IN_DEV_CONF_GET((in_dev), FORCE_IGMP_VERSION) == 1 || \\\n\t ((in_dev)->mr_v1_seen && \\\n\t  time_before(jiffies, (in_dev)->mr_v1_seen)))\n#define IGMP_V2_SEEN(in_dev) \\\n\t(IPV4_DEVCONF_ALL(dev_net(in_dev->dev), FORCE_IGMP_VERSION) == 2 || \\\n\t IN_DEV_CONF_GET((in_dev), FORCE_IGMP_VERSION) == 2 || \\\n\t ((in_dev)->mr_v2_seen && \\\n\t  time_before(jiffies, (in_dev)->mr_v2_seen)))\n\nstatic void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im);\nstatic void igmpv3_del_delrec(struct in_device *in_dev, __be32 multiaddr);\nstatic void igmpv3_clear_delrec(struct in_device *in_dev);\nstatic int sf_setstate(struct ip_mc_list *pmc);\nstatic void sf_markstate(struct ip_mc_list *pmc);\n#endif\nstatic void ip_mc_clear_src(struct ip_mc_list *pmc);\nstatic int ip_mc_add_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\n\t\t\t int sfcount, __be32 *psfsrc, int delta);\n\nstatic void ip_ma_put(struct ip_mc_list *im)\n{\n\tif (atomic_dec_and_test(&im->refcnt)) {\n\t\tin_dev_put(im->interface);\n\t\tkfree_rcu(im, rcu);\n\t}\n}\n\n#define for_each_pmc_rcu(in_dev, pmc)\t\t\t\t\\\n\tfor (pmc = rcu_dereference(in_dev->mc_list);\t\t\\\n\t     pmc != NULL;\t\t\t\t\t\\\n\t     pmc = rcu_dereference(pmc->next_rcu))\n\n#define for_each_pmc_rtnl(in_dev, pmc)\t\t\t\t\\\n\tfor (pmc = rtnl_dereference(in_dev->mc_list);\t\t\\\n\t     pmc != NULL;\t\t\t\t\t\\\n\t     pmc = rtnl_dereference(pmc->next_rcu))\n\n#ifdef CONFIG_IP_MULTICAST\n\n/*\n *\tTimer management\n */\n\nstatic void igmp_stop_timer(struct ip_mc_list *im)\n{\n\tspin_lock_bh(&im->lock);\n\tif (del_timer(&im->timer))\n\t\tatomic_dec(&im->refcnt);\n\tim->tm_running = 0;\n\tim->reporter = 0;\n\tim->unsolicit_count = 0;\n\tspin_unlock_bh(&im->lock);\n}\n\n/* It must be called with locked im->lock */\nstatic void igmp_start_timer(struct ip_mc_list *im, int max_delay)\n{\n\tint tv = net_random() % max_delay;\n\n\tim->tm_running = 1;\n\tif (!mod_timer(&im->timer, jiffies+tv+2))\n\t\tatomic_inc(&im->refcnt);\n}\n\nstatic void igmp_gq_start_timer(struct in_device *in_dev)\n{\n\tint tv = net_random() % in_dev->mr_maxdelay;\n\n\tin_dev->mr_gq_running = 1;\n\tif (!mod_timer(&in_dev->mr_gq_timer, jiffies+tv+2))\n\t\tin_dev_hold(in_dev);\n}\n\nstatic void igmp_ifc_start_timer(struct in_device *in_dev, int delay)\n{\n\tint tv = net_random() % delay;\n\n\tif (!mod_timer(&in_dev->mr_ifc_timer, jiffies+tv+2))\n\t\tin_dev_hold(in_dev);\n}\n\nstatic void igmp_mod_timer(struct ip_mc_list *im, int max_delay)\n{\n\tspin_lock_bh(&im->lock);\n\tim->unsolicit_count = 0;\n\tif (del_timer(&im->timer)) {\n\t\tif ((long)(im->timer.expires-jiffies) < max_delay) {\n\t\t\tadd_timer(&im->timer);\n\t\t\tim->tm_running = 1;\n\t\t\tspin_unlock_bh(&im->lock);\n\t\t\treturn;\n\t\t}\n\t\tatomic_dec(&im->refcnt);\n\t}\n\tigmp_start_timer(im, max_delay);\n\tspin_unlock_bh(&im->lock);\n}\n\n\n/*\n *\tSend an IGMP report.\n */\n\n#define IGMP_SIZE (sizeof(struct igmphdr)+sizeof(struct iphdr)+4)\n\n\nstatic int is_in(struct ip_mc_list *pmc, struct ip_sf_list *psf, int type,\n\tint gdeleted, int sdeleted)\n{\n\tswitch (type) {\n\tcase IGMPV3_MODE_IS_INCLUDE:\n\tcase IGMPV3_MODE_IS_EXCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn 0;\n\t\tif (!(pmc->gsquery && !psf->sf_gsresp)) {\n\t\t\tif (pmc->sfmode == MCAST_INCLUDE)\n\t\t\t\treturn 1;\n\t\t\t/* don't include if this source is excluded\n\t\t\t * in all filters\n\t\t\t */\n\t\t\tif (psf->sf_count[MCAST_INCLUDE])\n\t\t\t\treturn type == IGMPV3_MODE_IS_INCLUDE;\n\t\t\treturn pmc->sfcount[MCAST_EXCLUDE] ==\n\t\t\t\tpsf->sf_count[MCAST_EXCLUDE];\n\t\t}\n\t\treturn 0;\n\tcase IGMPV3_CHANGE_TO_INCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn 0;\n\t\treturn psf->sf_count[MCAST_INCLUDE] != 0;\n\tcase IGMPV3_CHANGE_TO_EXCLUDE:\n\t\tif (gdeleted || sdeleted)\n\t\t\treturn 0;\n\t\tif (pmc->sfcount[MCAST_EXCLUDE] == 0 ||\n\t\t    psf->sf_count[MCAST_INCLUDE])\n\t\t\treturn 0;\n\t\treturn pmc->sfcount[MCAST_EXCLUDE] ==\n\t\t\tpsf->sf_count[MCAST_EXCLUDE];\n\tcase IGMPV3_ALLOW_NEW_SOURCES:\n\t\tif (gdeleted || !psf->sf_crcount)\n\t\t\treturn 0;\n\t\treturn (pmc->sfmode == MCAST_INCLUDE) ^ sdeleted;\n\tcase IGMPV3_BLOCK_OLD_SOURCES:\n\t\tif (pmc->sfmode == MCAST_INCLUDE)\n\t\t\treturn gdeleted || (psf->sf_crcount && sdeleted);\n\t\treturn psf->sf_crcount && !gdeleted && !sdeleted;\n\t}\n\treturn 0;\n}\n\nstatic int\nigmp_scount(struct ip_mc_list *pmc, int type, int gdeleted, int sdeleted)\n{\n\tstruct ip_sf_list *psf;\n\tint scount = 0;\n\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (!is_in(pmc, psf, type, gdeleted, sdeleted))\n\t\t\tcontinue;\n\t\tscount++;\n\t}\n\treturn scount;\n}\n\n#define igmp_skb_size(skb) (*(unsigned int *)((skb)->cb))\n\nstatic struct sk_buff *igmpv3_newpack(struct net_device *dev, int size)\n{\n\tstruct sk_buff *skb;\n\tstruct rtable *rt;\n\tstruct iphdr *pip;\n\tstruct igmpv3_report *pig;\n\tstruct net *net = dev_net(dev);\n\tstruct flowi4 fl4;\n\n\twhile (1) {\n\t\tskb = alloc_skb(size + LL_ALLOCATED_SPACE(dev),\n\t\t\t\tGFP_ATOMIC | __GFP_NOWARN);\n\t\tif (skb)\n\t\t\tbreak;\n\t\tsize >>= 1;\n\t\tif (size < 256)\n\t\t\treturn NULL;\n\t}\n\tigmp_skb_size(skb) = size;\n\n\trt = ip_route_output_ports(net, &fl4, NULL, IGMPV3_ALL_MCR, 0,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_IGMP, 0, dev->ifindex);\n\tif (IS_ERR(rt)) {\n\t\tkfree_skb(skb);\n\t\treturn NULL;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n\tskb->dev = dev;\n\n\tskb_reserve(skb, LL_RESERVED_SPACE(dev));\n\n\tskb_reset_network_header(skb);\n\tpip = ip_hdr(skb);\n\tskb_put(skb, sizeof(struct iphdr) + 4);\n\n\tpip->version  = 4;\n\tpip->ihl      = (sizeof(struct iphdr)+4)>>2;\n\tpip->tos      = 0xc0;\n\tpip->frag_off = htons(IP_DF);\n\tpip->ttl      = 1;\n\tpip->daddr    = fl4.daddr;\n\tpip->saddr    = fl4.saddr;\n\tpip->protocol = IPPROTO_IGMP;\n\tpip->tot_len  = 0;\t/* filled in later */\n\tip_select_ident(pip, &rt->dst, NULL);\n\t((u8*)&pip[1])[0] = IPOPT_RA;\n\t((u8*)&pip[1])[1] = 4;\n\t((u8*)&pip[1])[2] = 0;\n\t((u8*)&pip[1])[3] = 0;\n\n\tskb->transport_header = skb->network_header + sizeof(struct iphdr) + 4;\n\tskb_put(skb, sizeof(*pig));\n\tpig = igmpv3_report_hdr(skb);\n\tpig->type = IGMPV3_HOST_MEMBERSHIP_REPORT;\n\tpig->resv1 = 0;\n\tpig->csum = 0;\n\tpig->resv2 = 0;\n\tpig->ngrec = 0;\n\treturn skb;\n}\n\nstatic int igmpv3_sendpack(struct sk_buff *skb)\n{\n\tstruct igmphdr *pig = igmp_hdr(skb);\n\tconst int igmplen = skb->tail - skb->transport_header;\n\n\tpig->csum = ip_compute_csum(igmp_hdr(skb), igmplen);\n\n\treturn ip_local_out(skb);\n}\n\nstatic int grec_size(struct ip_mc_list *pmc, int type, int gdel, int sdel)\n{\n\treturn sizeof(struct igmpv3_grec) + 4*igmp_scount(pmc, type, gdel, sdel);\n}\n\nstatic struct sk_buff *add_grhead(struct sk_buff *skb, struct ip_mc_list *pmc,\n\tint type, struct igmpv3_grec **ppgr)\n{\n\tstruct net_device *dev = pmc->interface->dev;\n\tstruct igmpv3_report *pih;\n\tstruct igmpv3_grec *pgr;\n\n\tif (!skb)\n\t\tskb = igmpv3_newpack(dev, dev->mtu);\n\tif (!skb)\n\t\treturn NULL;\n\tpgr = (struct igmpv3_grec *)skb_put(skb, sizeof(struct igmpv3_grec));\n\tpgr->grec_type = type;\n\tpgr->grec_auxwords = 0;\n\tpgr->grec_nsrcs = 0;\n\tpgr->grec_mca = pmc->multiaddr;\n\tpih = igmpv3_report_hdr(skb);\n\tpih->ngrec = htons(ntohs(pih->ngrec)+1);\n\t*ppgr = pgr;\n\treturn skb;\n}\n\n#define AVAILABLE(skb) ((skb) ? ((skb)->dev ? igmp_skb_size(skb) - (skb)->len : \\\n\tskb_tailroom(skb)) : 0)\n\nstatic struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,\n\tint type, int gdeleted, int sdeleted)\n{\n\tstruct net_device *dev = pmc->interface->dev;\n\tstruct igmpv3_report *pih;\n\tstruct igmpv3_grec *pgr = NULL;\n\tstruct ip_sf_list *psf, *psf_next, *psf_prev, **psf_list;\n\tint scount, stotal, first, isquery, truncate;\n\n\tif (pmc->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn skb;\n\n\tisquery = type == IGMPV3_MODE_IS_INCLUDE ||\n\t\t  type == IGMPV3_MODE_IS_EXCLUDE;\n\ttruncate = type == IGMPV3_MODE_IS_EXCLUDE ||\n\t\t    type == IGMPV3_CHANGE_TO_EXCLUDE;\n\n\tstotal = scount = 0;\n\n\tpsf_list = sdeleted ? &pmc->tomb : &pmc->sources;\n\n\tif (!*psf_list)\n\t\tgoto empty_source;\n\n\tpih = skb ? igmpv3_report_hdr(skb) : NULL;\n\n\t/* EX and TO_EX get a fresh packet, if needed */\n\tif (truncate) {\n\t\tif (pih && pih->ngrec &&\n\t\t    AVAILABLE(skb) < grec_size(pmc, type, gdeleted, sdeleted)) {\n\t\t\tif (skb)\n\t\t\t\tigmpv3_sendpack(skb);\n\t\t\tskb = igmpv3_newpack(dev, dev->mtu);\n\t\t}\n\t}\n\tfirst = 1;\n\tpsf_prev = NULL;\n\tfor (psf=*psf_list; psf; psf=psf_next) {\n\t\t__be32 *psrc;\n\n\t\tpsf_next = psf->sf_next;\n\n\t\tif (!is_in(pmc, psf, type, gdeleted, sdeleted)) {\n\t\t\tpsf_prev = psf;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* clear marks on query responses */\n\t\tif (isquery)\n\t\t\tpsf->sf_gsresp = 0;\n\n\t\tif (AVAILABLE(skb) < sizeof(__be32) +\n\t\t    first*sizeof(struct igmpv3_grec)) {\n\t\t\tif (truncate && !first)\n\t\t\t\tbreak;\t /* truncate these */\n\t\t\tif (pgr)\n\t\t\t\tpgr->grec_nsrcs = htons(scount);\n\t\t\tif (skb)\n\t\t\t\tigmpv3_sendpack(skb);\n\t\t\tskb = igmpv3_newpack(dev, dev->mtu);\n\t\t\tfirst = 1;\n\t\t\tscount = 0;\n\t\t}\n\t\tif (first) {\n\t\t\tskb = add_grhead(skb, pmc, type, &pgr);\n\t\t\tfirst = 0;\n\t\t}\n\t\tif (!skb)\n\t\t\treturn NULL;\n\t\tpsrc = (__be32 *)skb_put(skb, sizeof(__be32));\n\t\t*psrc = psf->sf_inaddr;\n\t\tscount++; stotal++;\n\t\tif ((type == IGMPV3_ALLOW_NEW_SOURCES ||\n\t\t     type == IGMPV3_BLOCK_OLD_SOURCES) && psf->sf_crcount) {\n\t\t\tpsf->sf_crcount--;\n\t\t\tif ((sdeleted || gdeleted) && psf->sf_crcount == 0) {\n\t\t\t\tif (psf_prev)\n\t\t\t\t\tpsf_prev->sf_next = psf->sf_next;\n\t\t\t\telse\n\t\t\t\t\t*psf_list = psf->sf_next;\n\t\t\t\tkfree(psf);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tpsf_prev = psf;\n\t}\n\nempty_source:\n\tif (!stotal) {\n\t\tif (type == IGMPV3_ALLOW_NEW_SOURCES ||\n\t\t    type == IGMPV3_BLOCK_OLD_SOURCES)\n\t\t\treturn skb;\n\t\tif (pmc->crcount || isquery) {\n\t\t\t/* make sure we have room for group header */\n\t\t\tif (skb && AVAILABLE(skb)<sizeof(struct igmpv3_grec)) {\n\t\t\t\tigmpv3_sendpack(skb);\n\t\t\t\tskb = NULL; /* add_grhead will get a new one */\n\t\t\t}\n\t\t\tskb = add_grhead(skb, pmc, type, &pgr);\n\t\t}\n\t}\n\tif (pgr)\n\t\tpgr->grec_nsrcs = htons(scount);\n\n\tif (isquery)\n\t\tpmc->gsquery = 0;\t/* clear query state on report */\n\treturn skb;\n}\n\nstatic int igmpv3_send_report(struct in_device *in_dev, struct ip_mc_list *pmc)\n{\n\tstruct sk_buff *skb = NULL;\n\tint type;\n\n\tif (!pmc) {\n\t\trcu_read_lock();\n\t\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\t\tif (pmc->multiaddr == IGMP_ALL_HOSTS)\n\t\t\t\tcontinue;\n\t\t\tspin_lock_bh(&pmc->lock);\n\t\t\tif (pmc->sfcount[MCAST_EXCLUDE])\n\t\t\t\ttype = IGMPV3_MODE_IS_EXCLUDE;\n\t\t\telse\n\t\t\t\ttype = IGMPV3_MODE_IS_INCLUDE;\n\t\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\t\tspin_unlock_bh(&pmc->lock);\n\t\t}\n\t\trcu_read_unlock();\n\t} else {\n\t\tspin_lock_bh(&pmc->lock);\n\t\tif (pmc->sfcount[MCAST_EXCLUDE])\n\t\t\ttype = IGMPV3_MODE_IS_EXCLUDE;\n\t\telse\n\t\t\ttype = IGMPV3_MODE_IS_INCLUDE;\n\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\tspin_unlock_bh(&pmc->lock);\n\t}\n\tif (!skb)\n\t\treturn 0;\n\treturn igmpv3_sendpack(skb);\n}\n\n/*\n * remove zero-count source records from a source filter list\n */\nstatic void igmpv3_clear_zeros(struct ip_sf_list **ppsf)\n{\n\tstruct ip_sf_list *psf_prev, *psf_next, *psf;\n\n\tpsf_prev = NULL;\n\tfor (psf=*ppsf; psf; psf = psf_next) {\n\t\tpsf_next = psf->sf_next;\n\t\tif (psf->sf_crcount == 0) {\n\t\t\tif (psf_prev)\n\t\t\t\tpsf_prev->sf_next = psf->sf_next;\n\t\t\telse\n\t\t\t\t*ppsf = psf->sf_next;\n\t\t\tkfree(psf);\n\t\t} else\n\t\t\tpsf_prev = psf;\n\t}\n}\n\nstatic void igmpv3_send_cr(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc, *pmc_prev, *pmc_next;\n\tstruct sk_buff *skb = NULL;\n\tint type, dtype;\n\n\trcu_read_lock();\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\n\t/* deleted MCA's */\n\tpmc_prev = NULL;\n\tfor (pmc=in_dev->mc_tomb; pmc; pmc=pmc_next) {\n\t\tpmc_next = pmc->next;\n\t\tif (pmc->sfmode == MCAST_INCLUDE) {\n\t\t\ttype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t\tdtype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t\tskb = add_grec(skb, pmc, type, 1, 0);\n\t\t\tskb = add_grec(skb, pmc, dtype, 1, 1);\n\t\t}\n\t\tif (pmc->crcount) {\n\t\t\tif (pmc->sfmode == MCAST_EXCLUDE) {\n\t\t\t\ttype = IGMPV3_CHANGE_TO_INCLUDE;\n\t\t\t\tskb = add_grec(skb, pmc, type, 1, 0);\n\t\t\t}\n\t\t\tpmc->crcount--;\n\t\t\tif (pmc->crcount == 0) {\n\t\t\t\tigmpv3_clear_zeros(&pmc->tomb);\n\t\t\t\tigmpv3_clear_zeros(&pmc->sources);\n\t\t\t}\n\t\t}\n\t\tif (pmc->crcount == 0 && !pmc->tomb && !pmc->sources) {\n\t\t\tif (pmc_prev)\n\t\t\t\tpmc_prev->next = pmc_next;\n\t\t\telse\n\t\t\t\tin_dev->mc_tomb = pmc_next;\n\t\t\tin_dev_put(pmc->interface);\n\t\t\tkfree(pmc);\n\t\t} else\n\t\t\tpmc_prev = pmc;\n\t}\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n\n\t/* change recs */\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tspin_lock_bh(&pmc->lock);\n\t\tif (pmc->sfcount[MCAST_EXCLUDE]) {\n\t\t\ttype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t\tdtype = IGMPV3_ALLOW_NEW_SOURCES;\n\t\t} else {\n\t\t\ttype = IGMPV3_ALLOW_NEW_SOURCES;\n\t\t\tdtype = IGMPV3_BLOCK_OLD_SOURCES;\n\t\t}\n\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\tskb = add_grec(skb, pmc, dtype, 0, 1);\t/* deleted sources */\n\n\t\t/* filter mode changes */\n\t\tif (pmc->crcount) {\n\t\t\tif (pmc->sfmode == MCAST_EXCLUDE)\n\t\t\t\ttype = IGMPV3_CHANGE_TO_EXCLUDE;\n\t\t\telse\n\t\t\t\ttype = IGMPV3_CHANGE_TO_INCLUDE;\n\t\t\tskb = add_grec(skb, pmc, type, 0, 0);\n\t\t\tpmc->crcount--;\n\t\t}\n\t\tspin_unlock_bh(&pmc->lock);\n\t}\n\trcu_read_unlock();\n\n\tif (!skb)\n\t\treturn;\n\t(void) igmpv3_sendpack(skb);\n}\n\nstatic int igmp_send_report(struct in_device *in_dev, struct ip_mc_list *pmc,\n\tint type)\n{\n\tstruct sk_buff *skb;\n\tstruct iphdr *iph;\n\tstruct igmphdr *ih;\n\tstruct rtable *rt;\n\tstruct net_device *dev = in_dev->dev;\n\tstruct net *net = dev_net(dev);\n\t__be32\tgroup = pmc ? pmc->multiaddr : 0;\n\tstruct flowi4 fl4;\n\t__be32\tdst;\n\n\tif (type == IGMPV3_HOST_MEMBERSHIP_REPORT)\n\t\treturn igmpv3_send_report(in_dev, pmc);\n\telse if (type == IGMP_HOST_LEAVE_MESSAGE)\n\t\tdst = IGMP_ALL_ROUTER;\n\telse\n\t\tdst = group;\n\n\trt = ip_route_output_ports(net, &fl4, NULL, dst, 0,\n\t\t\t\t   0, 0,\n\t\t\t\t   IPPROTO_IGMP, 0, dev->ifindex);\n\tif (IS_ERR(rt))\n\t\treturn -1;\n\n\tskb = alloc_skb(IGMP_SIZE+LL_ALLOCATED_SPACE(dev), GFP_ATOMIC);\n\tif (skb == NULL) {\n\t\tip_rt_put(rt);\n\t\treturn -1;\n\t}\n\n\tskb_dst_set(skb, &rt->dst);\n\n\tskb_reserve(skb, LL_RESERVED_SPACE(dev));\n\n\tskb_reset_network_header(skb);\n\tiph = ip_hdr(skb);\n\tskb_put(skb, sizeof(struct iphdr) + 4);\n\n\tiph->version  = 4;\n\tiph->ihl      = (sizeof(struct iphdr)+4)>>2;\n\tiph->tos      = 0xc0;\n\tiph->frag_off = htons(IP_DF);\n\tiph->ttl      = 1;\n\tiph->daddr    = dst;\n\tiph->saddr    = fl4.saddr;\n\tiph->protocol = IPPROTO_IGMP;\n\tip_select_ident(iph, &rt->dst, NULL);\n\t((u8*)&iph[1])[0] = IPOPT_RA;\n\t((u8*)&iph[1])[1] = 4;\n\t((u8*)&iph[1])[2] = 0;\n\t((u8*)&iph[1])[3] = 0;\n\n\tih = (struct igmphdr *)skb_put(skb, sizeof(struct igmphdr));\n\tih->type = type;\n\tih->code = 0;\n\tih->csum = 0;\n\tih->group = group;\n\tih->csum = ip_compute_csum((void *)ih, sizeof(struct igmphdr));\n\n\treturn ip_local_out(skb);\n}\n\nstatic void igmp_gq_timer_expire(unsigned long data)\n{\n\tstruct in_device *in_dev = (struct in_device *)data;\n\n\tin_dev->mr_gq_running = 0;\n\tigmpv3_send_report(in_dev, NULL);\n\t__in_dev_put(in_dev);\n}\n\nstatic void igmp_ifc_timer_expire(unsigned long data)\n{\n\tstruct in_device *in_dev = (struct in_device *)data;\n\n\tigmpv3_send_cr(in_dev);\n\tif (in_dev->mr_ifc_count) {\n\t\tin_dev->mr_ifc_count--;\n\t\tigmp_ifc_start_timer(in_dev, IGMP_Unsolicited_Report_Interval);\n\t}\n\t__in_dev_put(in_dev);\n}\n\nstatic void igmp_ifc_event(struct in_device *in_dev)\n{\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev))\n\t\treturn;\n\tin_dev->mr_ifc_count = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\tIGMP_Unsolicited_Report_Count;\n\tigmp_ifc_start_timer(in_dev, 1);\n}\n\n\nstatic void igmp_timer_expire(unsigned long data)\n{\n\tstruct ip_mc_list *im=(struct ip_mc_list *)data;\n\tstruct in_device *in_dev = im->interface;\n\n\tspin_lock(&im->lock);\n\tim->tm_running = 0;\n\n\tif (im->unsolicit_count) {\n\t\tim->unsolicit_count--;\n\t\tigmp_start_timer(im, IGMP_Unsolicited_Report_Interval);\n\t}\n\tim->reporter = 1;\n\tspin_unlock(&im->lock);\n\n\tif (IGMP_V1_SEEN(in_dev))\n\t\tigmp_send_report(in_dev, im, IGMP_HOST_MEMBERSHIP_REPORT);\n\telse if (IGMP_V2_SEEN(in_dev))\n\t\tigmp_send_report(in_dev, im, IGMPV2_HOST_MEMBERSHIP_REPORT);\n\telse\n\t\tigmp_send_report(in_dev, im, IGMPV3_HOST_MEMBERSHIP_REPORT);\n\n\tip_ma_put(im);\n}\n\n/* mark EXCLUDE-mode sources */\nstatic int igmp_xmarksources(struct ip_mc_list *pmc, int nsrcs, __be32 *srcs)\n{\n\tstruct ip_sf_list *psf;\n\tint i, scount;\n\n\tscount = 0;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (scount == nsrcs)\n\t\t\tbreak;\n\t\tfor (i=0; i<nsrcs; i++) {\n\t\t\t/* skip inactive filters */\n\t\t\tif (psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t    pmc->sfcount[MCAST_EXCLUDE] !=\n\t\t\t    psf->sf_count[MCAST_EXCLUDE])\n\t\t\t\tcontinue;\n\t\t\tif (srcs[i] == psf->sf_inaddr) {\n\t\t\t\tscount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpmc->gsquery = 0;\n\tif (scount == nsrcs)\t/* all sources excluded */\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int igmp_marksources(struct ip_mc_list *pmc, int nsrcs, __be32 *srcs)\n{\n\tstruct ip_sf_list *psf;\n\tint i, scount;\n\n\tif (pmc->sfmode == MCAST_EXCLUDE)\n\t\treturn igmp_xmarksources(pmc, nsrcs, srcs);\n\n\t/* mark INCLUDE-mode sources */\n\tscount = 0;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (scount == nsrcs)\n\t\t\tbreak;\n\t\tfor (i=0; i<nsrcs; i++)\n\t\t\tif (srcs[i] == psf->sf_inaddr) {\n\t\t\t\tpsf->sf_gsresp = 1;\n\t\t\t\tscount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tif (!scount) {\n\t\tpmc->gsquery = 0;\n\t\treturn 0;\n\t}\n\tpmc->gsquery = 1;\n\treturn 1;\n}\n\nstatic void igmp_heard_report(struct in_device *in_dev, __be32 group)\n{\n\tstruct ip_mc_list *im;\n\n\t/* Timers are only set for non-local groups */\n\n\tif (group == IGMP_ALL_HOSTS)\n\t\treturn;\n\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tif (im->multiaddr == group) {\n\t\t\tigmp_stop_timer(im);\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n\nstatic void igmp_heard_query(struct in_device *in_dev, struct sk_buff *skb,\n\tint len)\n{\n\tstruct igmphdr \t\t*ih = igmp_hdr(skb);\n\tstruct igmpv3_query *ih3 = igmpv3_query_hdr(skb);\n\tstruct ip_mc_list\t*im;\n\t__be32\t\t\tgroup = ih->group;\n\tint\t\t\tmax_delay;\n\tint\t\t\tmark = 0;\n\n\n\tif (len == 8) {\n\t\tif (ih->code == 0) {\n\t\t\t/* Alas, old v1 router presents here. */\n\n\t\t\tmax_delay = IGMP_Query_Response_Interval;\n\t\t\tin_dev->mr_v1_seen = jiffies +\n\t\t\t\tIGMP_V1_Router_Present_Timeout;\n\t\t\tgroup = 0;\n\t\t} else {\n\t\t\t/* v2 router present */\n\t\t\tmax_delay = ih->code*(HZ/IGMP_TIMER_SCALE);\n\t\t\tin_dev->mr_v2_seen = jiffies +\n\t\t\t\tIGMP_V2_Router_Present_Timeout;\n\t\t}\n\t\t/* cancel the interface change timer */\n\t\tin_dev->mr_ifc_count = 0;\n\t\tif (del_timer(&in_dev->mr_ifc_timer))\n\t\t\t__in_dev_put(in_dev);\n\t\t/* clear deleted report items */\n\t\tigmpv3_clear_delrec(in_dev);\n\t} else if (len < 12) {\n\t\treturn;\t/* ignore bogus packet; freed by caller */\n\t} else if (IGMP_V1_SEEN(in_dev)) {\n\t\t/* This is a v3 query with v1 queriers present */\n\t\tmax_delay = IGMP_Query_Response_Interval;\n\t\tgroup = 0;\n\t} else if (IGMP_V2_SEEN(in_dev)) {\n\t\t/* this is a v3 query with v2 queriers present;\n\t\t * Interpretation of the max_delay code is problematic here.\n\t\t * A real v2 host would use ih_code directly, while v3 has a\n\t\t * different encoding. We use the v3 encoding as more likely\n\t\t * to be intended in a v3 query.\n\t\t */\n\t\tmax_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);\n\t\tif (!max_delay)\n\t\t\tmax_delay = 1;\t/* can't mod w/ 0 */\n\t} else { /* v3 */\n\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)))\n\t\t\treturn;\n\n\t\tih3 = igmpv3_query_hdr(skb);\n\t\tif (ih3->nsrcs) {\n\t\t\tif (!pskb_may_pull(skb, sizeof(struct igmpv3_query)\n\t\t\t\t\t   + ntohs(ih3->nsrcs)*sizeof(__be32)))\n\t\t\t\treturn;\n\t\t\tih3 = igmpv3_query_hdr(skb);\n\t\t}\n\n\t\tmax_delay = IGMPV3_MRC(ih3->code)*(HZ/IGMP_TIMER_SCALE);\n\t\tif (!max_delay)\n\t\t\tmax_delay = 1;\t/* can't mod w/ 0 */\n\t\tin_dev->mr_maxdelay = max_delay;\n\t\tif (ih3->qrv)\n\t\t\tin_dev->mr_qrv = ih3->qrv;\n\t\tif (!group) { /* general query */\n\t\t\tif (ih3->nsrcs)\n\t\t\t\treturn;\t/* no sources allowed */\n\t\t\tigmp_gq_start_timer(in_dev);\n\t\t\treturn;\n\t\t}\n\t\t/* mark sources to include, if group & source-specific */\n\t\tmark = ih3->nsrcs != 0;\n\t}\n\n\t/*\n\t * - Start the timers in all of our membership records\n\t *   that the query applies to for the interface on\n\t *   which the query arrived excl. those that belong\n\t *   to a \"local\" group (224.0.0.X)\n\t * - For timers already running check if they need to\n\t *   be reset.\n\t * - Use the igmp->igmp_code field as the maximum\n\t *   delay possible\n\t */\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tint changed;\n\n\t\tif (group && group != im->multiaddr)\n\t\t\tcontinue;\n\t\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\t\tcontinue;\n\t\tspin_lock_bh(&im->lock);\n\t\tif (im->tm_running)\n\t\t\tim->gsquery = im->gsquery && mark;\n\t\telse\n\t\t\tim->gsquery = mark;\n\t\tchanged = !im->gsquery ||\n\t\t\tigmp_marksources(im, ntohs(ih3->nsrcs), ih3->srcs);\n\t\tspin_unlock_bh(&im->lock);\n\t\tif (changed)\n\t\t\tigmp_mod_timer(im, max_delay);\n\t}\n\trcu_read_unlock();\n}\n\n/* called in rcu_read_lock() section */\nint igmp_rcv(struct sk_buff *skb)\n{\n\t/* This basically follows the spec line by line -- see RFC1112 */\n\tstruct igmphdr *ih;\n\tstruct in_device *in_dev = __in_dev_get_rcu(skb->dev);\n\tint len = skb->len;\n\n\tif (in_dev == NULL)\n\t\tgoto drop;\n\n\tif (!pskb_may_pull(skb, sizeof(struct igmphdr)))\n\t\tgoto drop;\n\n\tswitch (skb->ip_summed) {\n\tcase CHECKSUM_COMPLETE:\n\t\tif (!csum_fold(skb->csum))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase CHECKSUM_NONE:\n\t\tskb->csum = 0;\n\t\tif (__skb_checksum_complete(skb))\n\t\t\tgoto drop;\n\t}\n\n\tih = igmp_hdr(skb);\n\tswitch (ih->type) {\n\tcase IGMP_HOST_MEMBERSHIP_QUERY:\n\t\tigmp_heard_query(in_dev, skb, len);\n\t\tbreak;\n\tcase IGMP_HOST_MEMBERSHIP_REPORT:\n\tcase IGMPV2_HOST_MEMBERSHIP_REPORT:\n\t\t/* Is it our report looped back? */\n\t\tif (rt_is_output_route(skb_rtable(skb)))\n\t\t\tbreak;\n\t\t/* don't rely on MC router hearing unicast reports */\n\t\tif (skb->pkt_type == PACKET_MULTICAST ||\n\t\t    skb->pkt_type == PACKET_BROADCAST)\n\t\t\tigmp_heard_report(in_dev, ih->group);\n\t\tbreak;\n\tcase IGMP_PIM:\n#ifdef CONFIG_IP_PIMSM_V1\n\t\treturn pim_rcv_v1(skb);\n#endif\n\tcase IGMPV3_HOST_MEMBERSHIP_REPORT:\n\tcase IGMP_DVMRP:\n\tcase IGMP_TRACE:\n\tcase IGMP_HOST_LEAVE_MESSAGE:\n\tcase IGMP_MTRACE:\n\tcase IGMP_MTRACE_RESP:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\ndrop:\n\tkfree_skb(skb);\n\treturn 0;\n}\n\n#endif\n\n\n/*\n *\tAdd a filter to a device\n */\n\nstatic void ip_mc_filter_add(struct in_device *in_dev, __be32 addr)\n{\n\tchar buf[MAX_ADDR_LEN];\n\tstruct net_device *dev = in_dev->dev;\n\n\t/* Checking for IFF_MULTICAST here is WRONG-WRONG-WRONG.\n\t   We will get multicast token leakage, when IFF_MULTICAST\n\t   is changed. This check should be done in ndo_set_rx_mode\n\t   routine. Something sort of:\n\t   if (dev->mc_list && dev->flags&IFF_MULTICAST) { do it; }\n\t   --ANK\n\t   */\n\tif (arp_mc_map(addr, buf, dev, 0) == 0)\n\t\tdev_mc_add(dev, buf);\n}\n\n/*\n *\tRemove a filter from a device\n */\n\nstatic void ip_mc_filter_del(struct in_device *in_dev, __be32 addr)\n{\n\tchar buf[MAX_ADDR_LEN];\n\tstruct net_device *dev = in_dev->dev;\n\n\tif (arp_mc_map(addr, buf, dev, 0) == 0)\n\t\tdev_mc_del(dev, buf);\n}\n\n#ifdef CONFIG_IP_MULTICAST\n/*\n * deleted ip_mc_list manipulation\n */\nstatic void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im)\n{\n\tstruct ip_mc_list *pmc;\n\n\t/* this is an \"ip_mc_list\" for convenience; only the fields below\n\t * are actually used. In particular, the refcnt and users are not\n\t * used for management of the delete list. Using the same structure\n\t * for deleted items allows change reports to use common code with\n\t * non-deleted or query-response MCA's.\n\t */\n\tpmc = kzalloc(sizeof(*pmc), GFP_KERNEL);\n\tif (!pmc)\n\t\treturn;\n\tspin_lock_bh(&im->lock);\n\tpmc->interface = im->interface;\n\tin_dev_hold(in_dev);\n\tpmc->multiaddr = im->multiaddr;\n\tpmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\tIGMP_Unsolicited_Report_Count;\n\tpmc->sfmode = im->sfmode;\n\tif (pmc->sfmode == MCAST_INCLUDE) {\n\t\tstruct ip_sf_list *psf;\n\n\t\tpmc->tomb = im->tomb;\n\t\tpmc->sources = im->sources;\n\t\tim->tomb = im->sources = NULL;\n\t\tfor (psf=pmc->sources; psf; psf=psf->sf_next)\n\t\t\tpsf->sf_crcount = pmc->crcount;\n\t}\n\tspin_unlock_bh(&im->lock);\n\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\tpmc->next = in_dev->mc_tomb;\n\tin_dev->mc_tomb = pmc;\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n}\n\nstatic void igmpv3_del_delrec(struct in_device *in_dev, __be32 multiaddr)\n{\n\tstruct ip_mc_list *pmc, *pmc_prev;\n\tstruct ip_sf_list *psf, *psf_next;\n\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\tpmc_prev = NULL;\n\tfor (pmc=in_dev->mc_tomb; pmc; pmc=pmc->next) {\n\t\tif (pmc->multiaddr == multiaddr)\n\t\t\tbreak;\n\t\tpmc_prev = pmc;\n\t}\n\tif (pmc) {\n\t\tif (pmc_prev)\n\t\t\tpmc_prev->next = pmc->next;\n\t\telse\n\t\t\tin_dev->mc_tomb = pmc->next;\n\t}\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n\tif (pmc) {\n\t\tfor (psf=pmc->tomb; psf; psf=psf_next) {\n\t\t\tpsf_next = psf->sf_next;\n\t\t\tkfree(psf);\n\t\t}\n\t\tin_dev_put(pmc->interface);\n\t\tkfree(pmc);\n\t}\n}\n\nstatic void igmpv3_clear_delrec(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc, *nextpmc;\n\n\tspin_lock_bh(&in_dev->mc_tomb_lock);\n\tpmc = in_dev->mc_tomb;\n\tin_dev->mc_tomb = NULL;\n\tspin_unlock_bh(&in_dev->mc_tomb_lock);\n\n\tfor (; pmc; pmc = nextpmc) {\n\t\tnextpmc = pmc->next;\n\t\tip_mc_clear_src(pmc);\n\t\tin_dev_put(pmc->interface);\n\t\tkfree(pmc);\n\t}\n\t/* clear dead sources, too */\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tstruct ip_sf_list *psf, *psf_next;\n\n\t\tspin_lock_bh(&pmc->lock);\n\t\tpsf = pmc->tomb;\n\t\tpmc->tomb = NULL;\n\t\tspin_unlock_bh(&pmc->lock);\n\t\tfor (; psf; psf=psf_next) {\n\t\t\tpsf_next = psf->sf_next;\n\t\t\tkfree(psf);\n\t\t}\n\t}\n\trcu_read_unlock();\n}\n#endif\n\nstatic void igmp_group_dropped(struct ip_mc_list *im)\n{\n\tstruct in_device *in_dev = im->interface;\n#ifdef CONFIG_IP_MULTICAST\n\tint reporter;\n#endif\n\n\tif (im->loaded) {\n\t\tim->loaded = 0;\n\t\tip_mc_filter_del(in_dev, im->multiaddr);\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn;\n\n\treporter = im->reporter;\n\tigmp_stop_timer(im);\n\n\tif (!in_dev->dead) {\n\t\tif (IGMP_V1_SEEN(in_dev))\n\t\t\treturn;\n\t\tif (IGMP_V2_SEEN(in_dev)) {\n\t\t\tif (reporter)\n\t\t\t\tigmp_send_report(in_dev, im, IGMP_HOST_LEAVE_MESSAGE);\n\t\t\treturn;\n\t\t}\n\t\t/* IGMPv3 */\n\t\tigmpv3_add_delrec(in_dev, im);\n\n\t\tigmp_ifc_event(in_dev);\n\t}\n#endif\n}\n\nstatic void igmp_group_added(struct ip_mc_list *im)\n{\n\tstruct in_device *in_dev = im->interface;\n\n\tif (im->loaded == 0) {\n\t\tim->loaded = 1;\n\t\tip_mc_filter_add(in_dev, im->multiaddr);\n\t}\n\n#ifdef CONFIG_IP_MULTICAST\n\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\treturn;\n\n\tif (in_dev->dead)\n\t\treturn;\n\tif (IGMP_V1_SEEN(in_dev) || IGMP_V2_SEEN(in_dev)) {\n\t\tspin_lock_bh(&im->lock);\n\t\tigmp_start_timer(im, IGMP_Initial_Report_Delay);\n\t\tspin_unlock_bh(&im->lock);\n\t\treturn;\n\t}\n\t/* else, v3 */\n\n\tim->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\tIGMP_Unsolicited_Report_Count;\n\tigmp_ifc_event(in_dev);\n#endif\n}\n\n\n/*\n *\tMulticast list managers\n */\n\n\n/*\n *\tA socket has joined a multicast group on device dev.\n */\n\nvoid ip_mc_inc_group(struct in_device *in_dev, __be32 addr)\n{\n\tstruct ip_mc_list *im;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, im) {\n\t\tif (im->multiaddr == addr) {\n\t\t\tim->users++;\n\t\t\tip_mc_add_src(in_dev, &addr, MCAST_EXCLUDE, 0, NULL, 0);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tim = kzalloc(sizeof(*im), GFP_KERNEL);\n\tif (!im)\n\t\tgoto out;\n\n\tim->users = 1;\n\tim->interface = in_dev;\n\tin_dev_hold(in_dev);\n\tim->multiaddr = addr;\n\t/* initial mode is (EX, empty) */\n\tim->sfmode = MCAST_EXCLUDE;\n\tim->sfcount[MCAST_EXCLUDE] = 1;\n\tatomic_set(&im->refcnt, 1);\n\tspin_lock_init(&im->lock);\n#ifdef CONFIG_IP_MULTICAST\n\tsetup_timer(&im->timer, &igmp_timer_expire, (unsigned long)im);\n\tim->unsolicit_count = IGMP_Unsolicited_Report_Count;\n#endif\n\n\tim->next_rcu = in_dev->mc_list;\n\tin_dev->mc_count++;\n\tRCU_INIT_POINTER(in_dev->mc_list, im);\n\n#ifdef CONFIG_IP_MULTICAST\n\tigmpv3_del_delrec(in_dev, im->multiaddr);\n#endif\n\tigmp_group_added(im);\n\tif (!in_dev->dead)\n\t\tip_rt_multicast_event(in_dev);\nout:\n\treturn;\n}\nEXPORT_SYMBOL(ip_mc_inc_group);\n\n/*\n *\tResend IGMP JOIN report; used for bonding.\n *\tCalled with rcu_read_lock()\n */\nvoid ip_mc_rejoin_groups(struct in_device *in_dev)\n{\n#ifdef CONFIG_IP_MULTICAST\n\tstruct ip_mc_list *im;\n\tint type;\n\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tif (im->multiaddr == IGMP_ALL_HOSTS)\n\t\t\tcontinue;\n\n\t\t/* a failover is happening and switches\n\t\t * must be notified immediately\n\t\t */\n\t\tif (IGMP_V1_SEEN(in_dev))\n\t\t\ttype = IGMP_HOST_MEMBERSHIP_REPORT;\n\t\telse if (IGMP_V2_SEEN(in_dev))\n\t\t\ttype = IGMPV2_HOST_MEMBERSHIP_REPORT;\n\t\telse\n\t\t\ttype = IGMPV3_HOST_MEMBERSHIP_REPORT;\n\t\tigmp_send_report(in_dev, im, type);\n\t}\n#endif\n}\nEXPORT_SYMBOL(ip_mc_rejoin_groups);\n\n/*\n *\tA socket has left a multicast group on device dev\n */\n\nvoid ip_mc_dec_group(struct in_device *in_dev, __be32 addr)\n{\n\tstruct ip_mc_list *i;\n\tstruct ip_mc_list __rcu **ip;\n\n\tASSERT_RTNL();\n\n\tfor (ip = &in_dev->mc_list;\n\t     (i = rtnl_dereference(*ip)) != NULL;\n\t     ip = &i->next_rcu) {\n\t\tif (i->multiaddr == addr) {\n\t\t\tif (--i->users == 0) {\n\t\t\t\t*ip = i->next_rcu;\n\t\t\t\tin_dev->mc_count--;\n\t\t\t\tigmp_group_dropped(i);\n\t\t\t\tip_mc_clear_src(i);\n\n\t\t\t\tif (!in_dev->dead)\n\t\t\t\t\tip_rt_multicast_event(in_dev);\n\n\t\t\t\tip_ma_put(i);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\nEXPORT_SYMBOL(ip_mc_dec_group);\n\n/* Device changing type */\n\nvoid ip_mc_unmap(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, pmc)\n\t\tigmp_group_dropped(pmc);\n}\n\nvoid ip_mc_remap(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, pmc)\n\t\tigmp_group_added(pmc);\n}\n\n/* Device going down */\n\nvoid ip_mc_down(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tfor_each_pmc_rtnl(in_dev, pmc)\n\t\tigmp_group_dropped(pmc);\n\n#ifdef CONFIG_IP_MULTICAST\n\tin_dev->mr_ifc_count = 0;\n\tif (del_timer(&in_dev->mr_ifc_timer))\n\t\t__in_dev_put(in_dev);\n\tin_dev->mr_gq_running = 0;\n\tif (del_timer(&in_dev->mr_gq_timer))\n\t\t__in_dev_put(in_dev);\n\tigmpv3_clear_delrec(in_dev);\n#endif\n\n\tip_mc_dec_group(in_dev, IGMP_ALL_HOSTS);\n}\n\nvoid ip_mc_init_dev(struct in_device *in_dev)\n{\n\tASSERT_RTNL();\n\n\tin_dev->mc_tomb = NULL;\n#ifdef CONFIG_IP_MULTICAST\n\tin_dev->mr_gq_running = 0;\n\tsetup_timer(&in_dev->mr_gq_timer, igmp_gq_timer_expire,\n\t\t\t(unsigned long)in_dev);\n\tin_dev->mr_ifc_count = 0;\n\tin_dev->mc_count     = 0;\n\tsetup_timer(&in_dev->mr_ifc_timer, igmp_ifc_timer_expire,\n\t\t\t(unsigned long)in_dev);\n\tin_dev->mr_qrv = IGMP_Unsolicited_Report_Count;\n#endif\n\n\tspin_lock_init(&in_dev->mc_tomb_lock);\n}\n\n/* Device going up */\n\nvoid ip_mc_up(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *pmc;\n\n\tASSERT_RTNL();\n\n\tip_mc_inc_group(in_dev, IGMP_ALL_HOSTS);\n\n\tfor_each_pmc_rtnl(in_dev, pmc)\n\t\tigmp_group_added(pmc);\n}\n\n/*\n *\tDevice is about to be destroyed: clean up.\n */\n\nvoid ip_mc_destroy_dev(struct in_device *in_dev)\n{\n\tstruct ip_mc_list *i;\n\n\tASSERT_RTNL();\n\n\t/* Deactivate timers */\n\tip_mc_down(in_dev);\n\n\twhile ((i = rtnl_dereference(in_dev->mc_list)) != NULL) {\n\t\tin_dev->mc_list = i->next_rcu;\n\t\tin_dev->mc_count--;\n\n\t\t/* We've dropped the groups in ip_mc_down already */\n\t\tip_mc_clear_src(i);\n\t\tip_ma_put(i);\n\t}\n}\n\n/* RTNL is locked */\nstatic struct in_device *ip_mc_find_dev(struct net *net, struct ip_mreqn *imr)\n{\n\tstruct net_device *dev = NULL;\n\tstruct in_device *idev = NULL;\n\n\tif (imr->imr_ifindex) {\n\t\tidev = inetdev_by_index(net, imr->imr_ifindex);\n\t\treturn idev;\n\t}\n\tif (imr->imr_address.s_addr) {\n\t\tdev = __ip_dev_find(net, imr->imr_address.s_addr, false);\n\t\tif (!dev)\n\t\t\treturn NULL;\n\t}\n\n\tif (!dev) {\n\t\tstruct rtable *rt = ip_route_output(net,\n\t\t\t\t\t\t    imr->imr_multiaddr.s_addr,\n\t\t\t\t\t\t    0, 0, 0);\n\t\tif (!IS_ERR(rt)) {\n\t\t\tdev = rt->dst.dev;\n\t\t\tip_rt_put(rt);\n\t\t}\n\t}\n\tif (dev) {\n\t\timr->imr_ifindex = dev->ifindex;\n\t\tidev = __in_dev_get_rtnl(dev);\n\t}\n\treturn idev;\n}\n\n/*\n *\tJoin a socket to a group\n */\nint sysctl_igmp_max_memberships __read_mostly = IP_MAX_MEMBERSHIPS;\nint sysctl_igmp_max_msf __read_mostly = IP_MAX_MSF;\n\n\nstatic int ip_mc_del1_src(struct ip_mc_list *pmc, int sfmode,\n\t__be32 *psfsrc)\n{\n\tstruct ip_sf_list *psf, *psf_prev;\n\tint rv = 0;\n\n\tpsf_prev = NULL;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (psf->sf_inaddr == *psfsrc)\n\t\t\tbreak;\n\t\tpsf_prev = psf;\n\t}\n\tif (!psf || psf->sf_count[sfmode] == 0) {\n\t\t/* source filter not found, or count wrong =>  bug */\n\t\treturn -ESRCH;\n\t}\n\tpsf->sf_count[sfmode]--;\n\tif (psf->sf_count[sfmode] == 0) {\n\t\tip_rt_multicast_event(pmc->interface);\n\t}\n\tif (!psf->sf_count[MCAST_INCLUDE] && !psf->sf_count[MCAST_EXCLUDE]) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tstruct in_device *in_dev = pmc->interface;\n#endif\n\n\t\t/* no more filters for this source */\n\t\tif (psf_prev)\n\t\t\tpsf_prev->sf_next = psf->sf_next;\n\t\telse\n\t\t\tpmc->sources = psf->sf_next;\n#ifdef CONFIG_IP_MULTICAST\n\t\tif (psf->sf_oldin &&\n\t\t    !IGMP_V1_SEEN(in_dev) && !IGMP_V2_SEEN(in_dev)) {\n\t\t\tpsf->sf_crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\t\t\tIGMP_Unsolicited_Report_Count;\n\t\t\tpsf->sf_next = pmc->tomb;\n\t\t\tpmc->tomb = psf;\n\t\t\trv = 1;\n\t\t} else\n#endif\n\t\t\tkfree(psf);\n\t}\n\treturn rv;\n}\n\n#ifndef CONFIG_IP_MULTICAST\n#define igmp_ifc_event(x)\tdo { } while (0)\n#endif\n\nstatic int ip_mc_del_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\n\t\t\t int sfcount, __be32 *psfsrc, int delta)\n{\n\tstruct ip_mc_list *pmc;\n\tint\tchangerec = 0;\n\tint\ti, err;\n\n\tif (!in_dev)\n\t\treturn -ENODEV;\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tif (*pmca == pmc->multiaddr)\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\n\t\t/* MCA not found?? bug */\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tspin_lock_bh(&pmc->lock);\n\trcu_read_unlock();\n#ifdef CONFIG_IP_MULTICAST\n\tsf_markstate(pmc);\n#endif\n\tif (!delta) {\n\t\terr = -EINVAL;\n\t\tif (!pmc->sfcount[sfmode])\n\t\t\tgoto out_unlock;\n\t\tpmc->sfcount[sfmode]--;\n\t}\n\terr = 0;\n\tfor (i=0; i<sfcount; i++) {\n\t\tint rv = ip_mc_del1_src(pmc, sfmode, &psfsrc[i]);\n\n\t\tchangerec |= rv > 0;\n\t\tif (!err && rv < 0)\n\t\t\terr = rv;\n\t}\n\tif (pmc->sfmode == MCAST_EXCLUDE &&\n\t    pmc->sfcount[MCAST_EXCLUDE] == 0 &&\n\t    pmc->sfcount[MCAST_INCLUDE]) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tstruct ip_sf_list *psf;\n#endif\n\n\t\t/* filter mode change */\n\t\tpmc->sfmode = MCAST_INCLUDE;\n#ifdef CONFIG_IP_MULTICAST\n\t\tpmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\t\tIGMP_Unsolicited_Report_Count;\n\t\tin_dev->mr_ifc_count = pmc->crcount;\n\t\tfor (psf=pmc->sources; psf; psf = psf->sf_next)\n\t\t\tpsf->sf_crcount = 0;\n\t\tigmp_ifc_event(pmc->interface);\n\t} else if (sf_setstate(pmc) || changerec) {\n\t\tigmp_ifc_event(pmc->interface);\n#endif\n\t}\nout_unlock:\n\tspin_unlock_bh(&pmc->lock);\n\treturn err;\n}\n\n/*\n * Add multicast single-source filter to the interface list\n */\nstatic int ip_mc_add1_src(struct ip_mc_list *pmc, int sfmode,\n\t__be32 *psfsrc, int delta)\n{\n\tstruct ip_sf_list *psf, *psf_prev;\n\n\tpsf_prev = NULL;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (psf->sf_inaddr == *psfsrc)\n\t\t\tbreak;\n\t\tpsf_prev = psf;\n\t}\n\tif (!psf) {\n\t\tpsf = kzalloc(sizeof(*psf), GFP_ATOMIC);\n\t\tif (!psf)\n\t\t\treturn -ENOBUFS;\n\t\tpsf->sf_inaddr = *psfsrc;\n\t\tif (psf_prev) {\n\t\t\tpsf_prev->sf_next = psf;\n\t\t} else\n\t\t\tpmc->sources = psf;\n\t}\n\tpsf->sf_count[sfmode]++;\n\tif (psf->sf_count[sfmode] == 1) {\n\t\tip_rt_multicast_event(pmc->interface);\n\t}\n\treturn 0;\n}\n\n#ifdef CONFIG_IP_MULTICAST\nstatic void sf_markstate(struct ip_mc_list *pmc)\n{\n\tstruct ip_sf_list *psf;\n\tint mca_xcount = pmc->sfcount[MCAST_EXCLUDE];\n\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next)\n\t\tif (pmc->sfcount[MCAST_EXCLUDE]) {\n\t\t\tpsf->sf_oldin = mca_xcount ==\n\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] &&\n\t\t\t\t!psf->sf_count[MCAST_INCLUDE];\n\t\t} else\n\t\t\tpsf->sf_oldin = psf->sf_count[MCAST_INCLUDE] != 0;\n}\n\nstatic int sf_setstate(struct ip_mc_list *pmc)\n{\n\tstruct ip_sf_list *psf, *dpsf;\n\tint mca_xcount = pmc->sfcount[MCAST_EXCLUDE];\n\tint qrv = pmc->interface->mr_qrv;\n\tint new_in, rv;\n\n\trv = 0;\n\tfor (psf=pmc->sources; psf; psf=psf->sf_next) {\n\t\tif (pmc->sfcount[MCAST_EXCLUDE]) {\n\t\t\tnew_in = mca_xcount == psf->sf_count[MCAST_EXCLUDE] &&\n\t\t\t\t!psf->sf_count[MCAST_INCLUDE];\n\t\t} else\n\t\t\tnew_in = psf->sf_count[MCAST_INCLUDE] != 0;\n\t\tif (new_in) {\n\t\t\tif (!psf->sf_oldin) {\n\t\t\t\tstruct ip_sf_list *prev = NULL;\n\n\t\t\t\tfor (dpsf=pmc->tomb; dpsf; dpsf=dpsf->sf_next) {\n\t\t\t\t\tif (dpsf->sf_inaddr == psf->sf_inaddr)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tprev = dpsf;\n\t\t\t\t}\n\t\t\t\tif (dpsf) {\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\tprev->sf_next = dpsf->sf_next;\n\t\t\t\t\telse\n\t\t\t\t\t\tpmc->tomb = dpsf->sf_next;\n\t\t\t\t\tkfree(dpsf);\n\t\t\t\t}\n\t\t\t\tpsf->sf_crcount = qrv;\n\t\t\t\trv++;\n\t\t\t}\n\t\t} else if (psf->sf_oldin) {\n\n\t\t\tpsf->sf_crcount = 0;\n\t\t\t/*\n\t\t\t * add or update \"delete\" records if an active filter\n\t\t\t * is now inactive\n\t\t\t */\n\t\t\tfor (dpsf=pmc->tomb; dpsf; dpsf=dpsf->sf_next)\n\t\t\t\tif (dpsf->sf_inaddr == psf->sf_inaddr)\n\t\t\t\t\tbreak;\n\t\t\tif (!dpsf) {\n\t\t\t\tdpsf = kmalloc(sizeof(*dpsf), GFP_ATOMIC);\n\t\t\t\tif (!dpsf)\n\t\t\t\t\tcontinue;\n\t\t\t\t*dpsf = *psf;\n\t\t\t\t/* pmc->lock held by callers */\n\t\t\t\tdpsf->sf_next = pmc->tomb;\n\t\t\t\tpmc->tomb = dpsf;\n\t\t\t}\n\t\t\tdpsf->sf_crcount = qrv;\n\t\t\trv++;\n\t\t}\n\t}\n\treturn rv;\n}\n#endif\n\n/*\n * Add multicast source filter list to the interface list\n */\nstatic int ip_mc_add_src(struct in_device *in_dev, __be32 *pmca, int sfmode,\n\t\t\t int sfcount, __be32 *psfsrc, int delta)\n{\n\tstruct ip_mc_list *pmc;\n\tint\tisexclude;\n\tint\ti, err;\n\n\tif (!in_dev)\n\t\treturn -ENODEV;\n\trcu_read_lock();\n\tfor_each_pmc_rcu(in_dev, pmc) {\n\t\tif (*pmca == pmc->multiaddr)\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\n\t\t/* MCA not found?? bug */\n\t\trcu_read_unlock();\n\t\treturn -ESRCH;\n\t}\n\tspin_lock_bh(&pmc->lock);\n\trcu_read_unlock();\n\n#ifdef CONFIG_IP_MULTICAST\n\tsf_markstate(pmc);\n#endif\n\tisexclude = pmc->sfmode == MCAST_EXCLUDE;\n\tif (!delta)\n\t\tpmc->sfcount[sfmode]++;\n\terr = 0;\n\tfor (i=0; i<sfcount; i++) {\n\t\terr = ip_mc_add1_src(pmc, sfmode, &psfsrc[i], delta);\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\tif (err) {\n\t\tint j;\n\n\t\tif (!delta)\n\t\t\tpmc->sfcount[sfmode]--;\n\t\tfor (j=0; j<i; j++)\n\t\t\t(void) ip_mc_del1_src(pmc, sfmode, &psfsrc[j]);\n\t} else if (isexclude != (pmc->sfcount[MCAST_EXCLUDE] != 0)) {\n#ifdef CONFIG_IP_MULTICAST\n\t\tstruct ip_sf_list *psf;\n\t\tin_dev = pmc->interface;\n#endif\n\n\t\t/* filter mode change */\n\t\tif (pmc->sfcount[MCAST_EXCLUDE])\n\t\t\tpmc->sfmode = MCAST_EXCLUDE;\n\t\telse if (pmc->sfcount[MCAST_INCLUDE])\n\t\t\tpmc->sfmode = MCAST_INCLUDE;\n#ifdef CONFIG_IP_MULTICAST\n\t\t/* else no filters; keep old mode for reports */\n\n\t\tpmc->crcount = in_dev->mr_qrv ? in_dev->mr_qrv :\n\t\t\tIGMP_Unsolicited_Report_Count;\n\t\tin_dev->mr_ifc_count = pmc->crcount;\n\t\tfor (psf=pmc->sources; psf; psf = psf->sf_next)\n\t\t\tpsf->sf_crcount = 0;\n\t\tigmp_ifc_event(in_dev);\n\t} else if (sf_setstate(pmc)) {\n\t\tigmp_ifc_event(in_dev);\n#endif\n\t}\n\tspin_unlock_bh(&pmc->lock);\n\treturn err;\n}\n\nstatic void ip_mc_clear_src(struct ip_mc_list *pmc)\n{\n\tstruct ip_sf_list *psf, *nextpsf;\n\n\tfor (psf=pmc->tomb; psf; psf=nextpsf) {\n\t\tnextpsf = psf->sf_next;\n\t\tkfree(psf);\n\t}\n\tpmc->tomb = NULL;\n\tfor (psf=pmc->sources; psf; psf=nextpsf) {\n\t\tnextpsf = psf->sf_next;\n\t\tkfree(psf);\n\t}\n\tpmc->sources = NULL;\n\tpmc->sfmode = MCAST_EXCLUDE;\n\tpmc->sfcount[MCAST_INCLUDE] = 0;\n\tpmc->sfcount[MCAST_EXCLUDE] = 1;\n}\n\n\n/*\n * Join a multicast group\n */\nint ip_mc_join_group(struct sock *sk , struct ip_mreqn *imr)\n{\n\tint err;\n\t__be32 addr = imr->imr_multiaddr.s_addr;\n\tstruct ip_mc_socklist *iml = NULL, *i;\n\tstruct in_device *in_dev;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct net *net = sock_net(sk);\n\tint ifindex;\n\tint count = 0;\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\tin_dev = ip_mc_find_dev(net, imr);\n\n\tif (!in_dev) {\n\t\timl = NULL;\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\n\terr = -EADDRINUSE;\n\tifindex = imr->imr_ifindex;\n\tfor_each_pmc_rtnl(inet, i) {\n\t\tif (i->multi.imr_multiaddr.s_addr == addr &&\n\t\t    i->multi.imr_ifindex == ifindex)\n\t\t\tgoto done;\n\t\tcount++;\n\t}\n\terr = -ENOBUFS;\n\tif (count >= sysctl_igmp_max_memberships)\n\t\tgoto done;\n\timl = sock_kmalloc(sk, sizeof(*iml), GFP_KERNEL);\n\tif (iml == NULL)\n\t\tgoto done;\n\n\tmemcpy(&iml->multi, imr, sizeof(*imr));\n\timl->next_rcu = inet->mc_list;\n\timl->sflist = NULL;\n\timl->sfmode = MCAST_EXCLUDE;\n\tRCU_INIT_POINTER(inet->mc_list, iml);\n\tip_mc_inc_group(in_dev, addr);\n\terr = 0;\ndone:\n\trtnl_unlock();\n\treturn err;\n}\nEXPORT_SYMBOL(ip_mc_join_group);\n\nstatic int ip_mc_leave_src(struct sock *sk, struct ip_mc_socklist *iml,\n\t\t\t   struct in_device *in_dev)\n{\n\tstruct ip_sf_socklist *psf = rtnl_dereference(iml->sflist);\n\tint err;\n\n\tif (psf == NULL) {\n\t\t/* any-source empty exclude case */\n\t\treturn ip_mc_del_src(in_dev, &iml->multi.imr_multiaddr.s_addr,\n\t\t\timl->sfmode, 0, NULL, 0);\n\t}\n\terr = ip_mc_del_src(in_dev, &iml->multi.imr_multiaddr.s_addr,\n\t\t\timl->sfmode, psf->sl_count, psf->sl_addr, 0);\n\tRCU_INIT_POINTER(iml->sflist, NULL);\n\t/* decrease mem now to avoid the memleak warning */\n\tatomic_sub(IP_SFLSIZE(psf->sl_max), &sk->sk_omem_alloc);\n\tkfree_rcu(psf, rcu);\n\treturn err;\n}\n\n/*\n *\tAsk a socket to leave a group.\n */\n\nint ip_mc_leave_group(struct sock *sk, struct ip_mreqn *imr)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_mc_socklist *iml;\n\tstruct ip_mc_socklist __rcu **imlp;\n\tstruct in_device *in_dev;\n\tstruct net *net = sock_net(sk);\n\t__be32 group = imr->imr_multiaddr.s_addr;\n\tu32 ifindex;\n\tint ret = -EADDRNOTAVAIL;\n\n\trtnl_lock();\n\tin_dev = ip_mc_find_dev(net, imr);\n\tifindex = imr->imr_ifindex;\n\tfor (imlp = &inet->mc_list;\n\t     (iml = rtnl_dereference(*imlp)) != NULL;\n\t     imlp = &iml->next_rcu) {\n\t\tif (iml->multi.imr_multiaddr.s_addr != group)\n\t\t\tcontinue;\n\t\tif (ifindex) {\n\t\t\tif (iml->multi.imr_ifindex != ifindex)\n\t\t\t\tcontinue;\n\t\t} else if (imr->imr_address.s_addr && imr->imr_address.s_addr !=\n\t\t\t\timl->multi.imr_address.s_addr)\n\t\t\tcontinue;\n\n\t\t(void) ip_mc_leave_src(sk, iml, in_dev);\n\n\t\t*imlp = iml->next_rcu;\n\n\t\tif (in_dev)\n\t\t\tip_mc_dec_group(in_dev, group);\n\t\trtnl_unlock();\n\t\t/* decrease mem now to avoid the memleak warning */\n\t\tatomic_sub(sizeof(*iml), &sk->sk_omem_alloc);\n\t\tkfree_rcu(iml, rcu);\n\t\treturn 0;\n\t}\n\tif (!in_dev)\n\t\tret = -ENODEV;\n\trtnl_unlock();\n\treturn ret;\n}\n\nint ip_mc_source(int add, int omode, struct sock *sk, struct\n\tip_mreq_source *mreqs, int ifindex)\n{\n\tint err;\n\tstruct ip_mreqn imr;\n\t__be32 addr = mreqs->imr_multiaddr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct in_device *in_dev = NULL;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *psl;\n\tstruct net *net = sock_net(sk);\n\tint leavegroup = 0;\n\tint i, j, rv;\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\timr.imr_multiaddr.s_addr = mreqs->imr_multiaddr;\n\timr.imr_address.s_addr = mreqs->imr_interface;\n\timr.imr_ifindex = ifindex;\n\tin_dev = ip_mc_find_dev(net, &imr);\n\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\terr = -EADDRNOTAVAIL;\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif ((pmc->multi.imr_multiaddr.s_addr ==\n\t\t     imr.imr_multiaddr.s_addr) &&\n\t\t    (pmc->multi.imr_ifindex == imr.imr_ifindex))\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\t\t/* must have a prior join */\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\t/* if a source filter was set, must be the same mode as before */\n\tif (pmc->sflist) {\n\t\tif (pmc->sfmode != omode) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto done;\n\t\t}\n\t} else if (pmc->sfmode != omode) {\n\t\t/* allow mode switches for empty-set filters */\n\t\tip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 0, NULL, 0);\n\t\tip_mc_del_src(in_dev, &mreqs->imr_multiaddr, pmc->sfmode, 0,\n\t\t\tNULL, 0);\n\t\tpmc->sfmode = omode;\n\t}\n\n\tpsl = rtnl_dereference(pmc->sflist);\n\tif (!add) {\n\t\tif (!psl)\n\t\t\tgoto done;\t/* err = -EADDRNOTAVAIL */\n\t\trv = !0;\n\t\tfor (i=0; i<psl->sl_count; i++) {\n\t\t\trv = memcmp(&psl->sl_addr[i], &mreqs->imr_sourceaddr,\n\t\t\t\tsizeof(__be32));\n\t\t\tif (rv == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (rv)\t\t/* source not found */\n\t\t\tgoto done;\t/* err = -EADDRNOTAVAIL */\n\n\t\t/* special case - (INCLUDE, empty) == LEAVE_GROUP */\n\t\tif (psl->sl_count == 1 && omode == MCAST_INCLUDE) {\n\t\t\tleavegroup = 1;\n\t\t\tgoto done;\n\t\t}\n\n\t\t/* update the interface filter */\n\t\tip_mc_del_src(in_dev, &mreqs->imr_multiaddr, omode, 1,\n\t\t\t&mreqs->imr_sourceaddr, 1);\n\n\t\tfor (j=i+1; j<psl->sl_count; j++)\n\t\t\tpsl->sl_addr[j-1] = psl->sl_addr[j];\n\t\tpsl->sl_count--;\n\t\terr = 0;\n\t\tgoto done;\n\t}\n\t/* else, add a new source to the filter */\n\n\tif (psl && psl->sl_count >= sysctl_igmp_max_msf) {\n\t\terr = -ENOBUFS;\n\t\tgoto done;\n\t}\n\tif (!psl || psl->sl_count == psl->sl_max) {\n\t\tstruct ip_sf_socklist *newpsl;\n\t\tint count = IP_SFBLOCK;\n\n\t\tif (psl)\n\t\t\tcount += psl->sl_max;\n\t\tnewpsl = sock_kmalloc(sk, IP_SFLSIZE(count), GFP_KERNEL);\n\t\tif (!newpsl) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto done;\n\t\t}\n\t\tnewpsl->sl_max = count;\n\t\tnewpsl->sl_count = count - IP_SFBLOCK;\n\t\tif (psl) {\n\t\t\tfor (i=0; i<psl->sl_count; i++)\n\t\t\t\tnewpsl->sl_addr[i] = psl->sl_addr[i];\n\t\t\t/* decrease mem now to avoid the memleak warning */\n\t\t\tatomic_sub(IP_SFLSIZE(psl->sl_max), &sk->sk_omem_alloc);\n\t\t\tkfree_rcu(psl, rcu);\n\t\t}\n\t\tRCU_INIT_POINTER(pmc->sflist, newpsl);\n\t\tpsl = newpsl;\n\t}\n\trv = 1;\t/* > 0 for insert logic below if sl_count is 0 */\n\tfor (i=0; i<psl->sl_count; i++) {\n\t\trv = memcmp(&psl->sl_addr[i], &mreqs->imr_sourceaddr,\n\t\t\tsizeof(__be32));\n\t\tif (rv == 0)\n\t\t\tbreak;\n\t}\n\tif (rv == 0)\t\t/* address already there is an error */\n\t\tgoto done;\n\tfor (j=psl->sl_count-1; j>=i; j--)\n\t\tpsl->sl_addr[j+1] = psl->sl_addr[j];\n\tpsl->sl_addr[i] = mreqs->imr_sourceaddr;\n\tpsl->sl_count++;\n\terr = 0;\n\t/* update the interface list */\n\tip_mc_add_src(in_dev, &mreqs->imr_multiaddr, omode, 1,\n\t\t&mreqs->imr_sourceaddr, 1);\ndone:\n\trtnl_unlock();\n\tif (leavegroup)\n\t\treturn ip_mc_leave_group(sk, &imr);\n\treturn err;\n}\n\nint ip_mc_msfilter(struct sock *sk, struct ip_msfilter *msf, int ifindex)\n{\n\tint err = 0;\n\tstruct ip_mreqn\timr;\n\t__be32 addr = msf->imsf_multiaddr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct in_device *in_dev;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *newpsl, *psl;\n\tstruct net *net = sock_net(sk);\n\tint leavegroup = 0;\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\tif (msf->imsf_fmode != MCAST_INCLUDE &&\n\t    msf->imsf_fmode != MCAST_EXCLUDE)\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\timr.imr_multiaddr.s_addr = msf->imsf_multiaddr;\n\timr.imr_address.s_addr = msf->imsf_interface;\n\timr.imr_ifindex = ifindex;\n\tin_dev = ip_mc_find_dev(net, &imr);\n\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\n\t/* special case - (INCLUDE, empty) == LEAVE_GROUP */\n\tif (msf->imsf_fmode == MCAST_INCLUDE && msf->imsf_numsrc == 0) {\n\t\tleavegroup = 1;\n\t\tgoto done;\n\t}\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == msf->imsf_multiaddr &&\n\t\t    pmc->multi.imr_ifindex == imr.imr_ifindex)\n\t\t\tbreak;\n\t}\n\tif (!pmc) {\t\t/* must have a prior join */\n\t\terr = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (msf->imsf_numsrc) {\n\t\tnewpsl = sock_kmalloc(sk, IP_SFLSIZE(msf->imsf_numsrc),\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!newpsl) {\n\t\t\terr = -ENOBUFS;\n\t\t\tgoto done;\n\t\t}\n\t\tnewpsl->sl_max = newpsl->sl_count = msf->imsf_numsrc;\n\t\tmemcpy(newpsl->sl_addr, msf->imsf_slist,\n\t\t\tmsf->imsf_numsrc * sizeof(msf->imsf_slist[0]));\n\t\terr = ip_mc_add_src(in_dev, &msf->imsf_multiaddr,\n\t\t\tmsf->imsf_fmode, newpsl->sl_count, newpsl->sl_addr, 0);\n\t\tif (err) {\n\t\t\tsock_kfree_s(sk, newpsl, IP_SFLSIZE(newpsl->sl_max));\n\t\t\tgoto done;\n\t\t}\n\t} else {\n\t\tnewpsl = NULL;\n\t\t(void) ip_mc_add_src(in_dev, &msf->imsf_multiaddr,\n\t\t\t\t     msf->imsf_fmode, 0, NULL, 0);\n\t}\n\tpsl = rtnl_dereference(pmc->sflist);\n\tif (psl) {\n\t\t(void) ip_mc_del_src(in_dev, &msf->imsf_multiaddr, pmc->sfmode,\n\t\t\tpsl->sl_count, psl->sl_addr, 0);\n\t\t/* decrease mem now to avoid the memleak warning */\n\t\tatomic_sub(IP_SFLSIZE(psl->sl_max), &sk->sk_omem_alloc);\n\t\tkfree_rcu(psl, rcu);\n\t} else\n\t\t(void) ip_mc_del_src(in_dev, &msf->imsf_multiaddr, pmc->sfmode,\n\t\t\t0, NULL, 0);\n\tRCU_INIT_POINTER(pmc->sflist, newpsl);\n\tpmc->sfmode = msf->imsf_fmode;\n\terr = 0;\ndone:\n\trtnl_unlock();\n\tif (leavegroup)\n\t\terr = ip_mc_leave_group(sk, &imr);\n\treturn err;\n}\n\nint ip_mc_msfget(struct sock *sk, struct ip_msfilter *msf,\n\tstruct ip_msfilter __user *optval, int __user *optlen)\n{\n\tint err, len, count, copycount;\n\tstruct ip_mreqn\timr;\n\t__be32 addr = msf->imsf_multiaddr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct in_device *in_dev;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *psl;\n\tstruct net *net = sock_net(sk);\n\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\timr.imr_multiaddr.s_addr = msf->imsf_multiaddr;\n\timr.imr_address.s_addr = msf->imsf_interface;\n\timr.imr_ifindex = 0;\n\tin_dev = ip_mc_find_dev(net, &imr);\n\n\tif (!in_dev) {\n\t\terr = -ENODEV;\n\t\tgoto done;\n\t}\n\terr = -EADDRNOTAVAIL;\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == msf->imsf_multiaddr &&\n\t\t    pmc->multi.imr_ifindex == imr.imr_ifindex)\n\t\t\tbreak;\n\t}\n\tif (!pmc)\t\t/* must have a prior join */\n\t\tgoto done;\n\tmsf->imsf_fmode = pmc->sfmode;\n\tpsl = rtnl_dereference(pmc->sflist);\n\trtnl_unlock();\n\tif (!psl) {\n\t\tlen = 0;\n\t\tcount = 0;\n\t} else {\n\t\tcount = psl->sl_count;\n\t}\n\tcopycount = count < msf->imsf_numsrc ? count : msf->imsf_numsrc;\n\tlen = copycount * sizeof(psl->sl_addr[0]);\n\tmsf->imsf_numsrc = count;\n\tif (put_user(IP_MSFILTER_SIZE(copycount), optlen) ||\n\t    copy_to_user(optval, msf, IP_MSFILTER_SIZE(0))) {\n\t\treturn -EFAULT;\n\t}\n\tif (len &&\n\t    copy_to_user(&optval->imsf_slist[0], psl->sl_addr, len))\n\t\treturn -EFAULT;\n\treturn 0;\ndone:\n\trtnl_unlock();\n\treturn err;\n}\n\nint ip_mc_gsfget(struct sock *sk, struct group_filter *gsf,\n\tstruct group_filter __user *optval, int __user *optlen)\n{\n\tint err, i, count, copycount;\n\tstruct sockaddr_in *psin;\n\t__be32 addr;\n\tstruct ip_mc_socklist *pmc;\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_sf_socklist *psl;\n\n\tpsin = (struct sockaddr_in *)&gsf->gf_group;\n\tif (psin->sin_family != AF_INET)\n\t\treturn -EINVAL;\n\taddr = psin->sin_addr.s_addr;\n\tif (!ipv4_is_multicast(addr))\n\t\treturn -EINVAL;\n\n\trtnl_lock();\n\n\terr = -EADDRNOTAVAIL;\n\n\tfor_each_pmc_rtnl(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == addr &&\n\t\t    pmc->multi.imr_ifindex == gsf->gf_interface)\n\t\t\tbreak;\n\t}\n\tif (!pmc)\t\t/* must have a prior join */\n\t\tgoto done;\n\tgsf->gf_fmode = pmc->sfmode;\n\tpsl = rtnl_dereference(pmc->sflist);\n\trtnl_unlock();\n\tcount = psl ? psl->sl_count : 0;\n\tcopycount = count < gsf->gf_numsrc ? count : gsf->gf_numsrc;\n\tgsf->gf_numsrc = count;\n\tif (put_user(GROUP_FILTER_SIZE(copycount), optlen) ||\n\t    copy_to_user(optval, gsf, GROUP_FILTER_SIZE(0))) {\n\t\treturn -EFAULT;\n\t}\n\tfor (i=0; i<copycount; i++) {\n\t\tstruct sockaddr_storage ss;\n\n\t\tpsin = (struct sockaddr_in *)&ss;\n\t\tmemset(&ss, 0, sizeof(ss));\n\t\tpsin->sin_family = AF_INET;\n\t\tpsin->sin_addr.s_addr = psl->sl_addr[i];\n\t\tif (copy_to_user(&optval->gf_slist[i], &ss, sizeof(ss)))\n\t\t\treturn -EFAULT;\n\t}\n\treturn 0;\ndone:\n\trtnl_unlock();\n\treturn err;\n}\n\n/*\n * check if a multicast source filter allows delivery for a given <src,dst,intf>\n */\nint ip_mc_sf_allow(struct sock *sk, __be32 loc_addr, __be32 rmt_addr, int dif)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_mc_socklist *pmc;\n\tstruct ip_sf_socklist *psl;\n\tint i;\n\tint ret;\n\n\tret = 1;\n\tif (!ipv4_is_multicast(loc_addr))\n\t\tgoto out;\n\n\trcu_read_lock();\n\tfor_each_pmc_rcu(inet, pmc) {\n\t\tif (pmc->multi.imr_multiaddr.s_addr == loc_addr &&\n\t\t    pmc->multi.imr_ifindex == dif)\n\t\t\tbreak;\n\t}\n\tret = inet->mc_all;\n\tif (!pmc)\n\t\tgoto unlock;\n\tpsl = rcu_dereference(pmc->sflist);\n\tret = (pmc->sfmode == MCAST_EXCLUDE);\n\tif (!psl)\n\t\tgoto unlock;\n\n\tfor (i=0; i<psl->sl_count; i++) {\n\t\tif (psl->sl_addr[i] == rmt_addr)\n\t\t\tbreak;\n\t}\n\tret = 0;\n\tif (pmc->sfmode == MCAST_INCLUDE && i >= psl->sl_count)\n\t\tgoto unlock;\n\tif (pmc->sfmode == MCAST_EXCLUDE && i < psl->sl_count)\n\t\tgoto unlock;\n\tret = 1;\nunlock:\n\trcu_read_unlock();\nout:\n\treturn ret;\n}\n\n/*\n *\tA socket is closing.\n */\n\nvoid ip_mc_drop_socket(struct sock *sk)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct ip_mc_socklist *iml;\n\tstruct net *net = sock_net(sk);\n\n\tif (inet->mc_list == NULL)\n\t\treturn;\n\n\trtnl_lock();\n\twhile ((iml = rtnl_dereference(inet->mc_list)) != NULL) {\n\t\tstruct in_device *in_dev;\n\n\t\tinet->mc_list = iml->next_rcu;\n\t\tin_dev = inetdev_by_index(net, iml->multi.imr_ifindex);\n\t\t(void) ip_mc_leave_src(sk, iml, in_dev);\n\t\tif (in_dev != NULL)\n\t\t\tip_mc_dec_group(in_dev, iml->multi.imr_multiaddr.s_addr);\n\t\t/* decrease mem now to avoid the memleak warning */\n\t\tatomic_sub(sizeof(*iml), &sk->sk_omem_alloc);\n\t\tkfree_rcu(iml, rcu);\n\t}\n\trtnl_unlock();\n}\n\n/* called with rcu_read_lock() */\nint ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u16 proto)\n{\n\tstruct ip_mc_list *im;\n\tstruct ip_sf_list *psf;\n\tint rv = 0;\n\n\tfor_each_pmc_rcu(in_dev, im) {\n\t\tif (im->multiaddr == mc_addr)\n\t\t\tbreak;\n\t}\n\tif (im && proto == IPPROTO_IGMP) {\n\t\trv = 1;\n\t} else if (im) {\n\t\tif (src_addr) {\n\t\t\tfor (psf=im->sources; psf; psf=psf->sf_next) {\n\t\t\t\tif (psf->sf_inaddr == src_addr)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (psf)\n\t\t\t\trv = psf->sf_count[MCAST_INCLUDE] ||\n\t\t\t\t\tpsf->sf_count[MCAST_EXCLUDE] !=\n\t\t\t\t\tim->sfcount[MCAST_EXCLUDE];\n\t\t\telse\n\t\t\t\trv = im->sfcount[MCAST_EXCLUDE] != 0;\n\t\t} else\n\t\t\trv = 1; /* unspecified source; tentatively allow */\n\t}\n\treturn rv;\n}\n\n#if defined(CONFIG_PROC_FS)\nstruct igmp_mc_iter_state {\n\tstruct seq_net_private p;\n\tstruct net_device *dev;\n\tstruct in_device *in_dev;\n};\n\n#define\tigmp_mc_seq_private(seq)\t((struct igmp_mc_iter_state *)(seq)->private)\n\nstatic inline struct ip_mc_list *igmp_mc_get_first(struct seq_file *seq)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct ip_mc_list *im = NULL;\n\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\n\tstate->in_dev = NULL;\n\tfor_each_netdev_rcu(net, state->dev) {\n\t\tstruct in_device *in_dev;\n\n\t\tin_dev = __in_dev_get_rcu(state->dev);\n\t\tif (!in_dev)\n\t\t\tcontinue;\n\t\tim = rcu_dereference(in_dev->mc_list);\n\t\tif (im) {\n\t\t\tstate->in_dev = in_dev;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn im;\n}\n\nstatic struct ip_mc_list *igmp_mc_get_next(struct seq_file *seq, struct ip_mc_list *im)\n{\n\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\n\tim = rcu_dereference(im->next_rcu);\n\twhile (!im) {\n\t\tstate->dev = next_net_device_rcu(state->dev);\n\t\tif (!state->dev) {\n\t\t\tstate->in_dev = NULL;\n\t\t\tbreak;\n\t\t}\n\t\tstate->in_dev = __in_dev_get_rcu(state->dev);\n\t\tif (!state->in_dev)\n\t\t\tcontinue;\n\t\tim = rcu_dereference(state->in_dev->mc_list);\n\t}\n\treturn im;\n}\n\nstatic struct ip_mc_list *igmp_mc_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct ip_mc_list *im = igmp_mc_get_first(seq);\n\tif (im)\n\t\twhile (pos && (im = igmp_mc_get_next(seq, im)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : im;\n}\n\nstatic void *igmp_mc_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn *pos ? igmp_mc_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *igmp_mc_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ip_mc_list *im;\n\tif (v == SEQ_START_TOKEN)\n\t\tim = igmp_mc_get_first(seq);\n\telse\n\t\tim = igmp_mc_get_next(seq, v);\n\t++*pos;\n\treturn im;\n}\n\nstatic void igmp_mc_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\n\tstate->in_dev = NULL;\n\tstate->dev = NULL;\n\trcu_read_unlock();\n}\n\nstatic int igmp_mc_seq_show(struct seq_file *seq, void *v)\n{\n\tif (v == SEQ_START_TOKEN)\n\t\tseq_puts(seq,\n\t\t\t \"Idx\\tDevice    : Count Querier\\tGroup    Users Timer\\tReporter\\n\");\n\telse {\n\t\tstruct ip_mc_list *im = (struct ip_mc_list *)v;\n\t\tstruct igmp_mc_iter_state *state = igmp_mc_seq_private(seq);\n\t\tchar   *querier;\n#ifdef CONFIG_IP_MULTICAST\n\t\tquerier = IGMP_V1_SEEN(state->in_dev) ? \"V1\" :\n\t\t\t  IGMP_V2_SEEN(state->in_dev) ? \"V2\" :\n\t\t\t  \"V3\";\n#else\n\t\tquerier = \"NONE\";\n#endif\n\n\t\tif (rcu_dereference(state->in_dev->mc_list) == im) {\n\t\t\tseq_printf(seq, \"%d\\t%-10s: %5d %7s\\n\",\n\t\t\t\t   state->dev->ifindex, state->dev->name, state->in_dev->mc_count, querier);\n\t\t}\n\n\t\tseq_printf(seq,\n\t\t\t   \"\\t\\t\\t\\t%08X %5d %d:%08lX\\t\\t%d\\n\",\n\t\t\t   im->multiaddr, im->users,\n\t\t\t   im->tm_running, im->tm_running ?\n\t\t\t   jiffies_to_clock_t(im->timer.expires-jiffies) : 0,\n\t\t\t   im->reporter);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations igmp_mc_seq_ops = {\n\t.start\t=\tigmp_mc_seq_start,\n\t.next\t=\tigmp_mc_seq_next,\n\t.stop\t=\tigmp_mc_seq_stop,\n\t.show\t=\tigmp_mc_seq_show,\n};\n\nstatic int igmp_mc_seq_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &igmp_mc_seq_ops,\n\t\t\tsizeof(struct igmp_mc_iter_state));\n}\n\nstatic const struct file_operations igmp_mc_seq_fops = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tigmp_mc_seq_open,\n\t.read\t\t=\tseq_read,\n\t.llseek\t\t=\tseq_lseek,\n\t.release\t=\tseq_release_net,\n};\n\nstruct igmp_mcf_iter_state {\n\tstruct seq_net_private p;\n\tstruct net_device *dev;\n\tstruct in_device *idev;\n\tstruct ip_mc_list *im;\n};\n\n#define igmp_mcf_seq_private(seq)\t((struct igmp_mcf_iter_state *)(seq)->private)\n\nstatic inline struct ip_sf_list *igmp_mcf_get_first(struct seq_file *seq)\n{\n\tstruct net *net = seq_file_net(seq);\n\tstruct ip_sf_list *psf = NULL;\n\tstruct ip_mc_list *im = NULL;\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\n\tstate->idev = NULL;\n\tstate->im = NULL;\n\tfor_each_netdev_rcu(net, state->dev) {\n\t\tstruct in_device *idev;\n\t\tidev = __in_dev_get_rcu(state->dev);\n\t\tif (unlikely(idev == NULL))\n\t\t\tcontinue;\n\t\tim = rcu_dereference(idev->mc_list);\n\t\tif (likely(im != NULL)) {\n\t\t\tspin_lock_bh(&im->lock);\n\t\t\tpsf = im->sources;\n\t\t\tif (likely(psf != NULL)) {\n\t\t\t\tstate->im = im;\n\t\t\t\tstate->idev = idev;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tspin_unlock_bh(&im->lock);\n\t\t}\n\t}\n\treturn psf;\n}\n\nstatic struct ip_sf_list *igmp_mcf_get_next(struct seq_file *seq, struct ip_sf_list *psf)\n{\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\n\tpsf = psf->sf_next;\n\twhile (!psf) {\n\t\tspin_unlock_bh(&state->im->lock);\n\t\tstate->im = state->im->next;\n\t\twhile (!state->im) {\n\t\t\tstate->dev = next_net_device_rcu(state->dev);\n\t\t\tif (!state->dev) {\n\t\t\t\tstate->idev = NULL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tstate->idev = __in_dev_get_rcu(state->dev);\n\t\t\tif (!state->idev)\n\t\t\t\tcontinue;\n\t\t\tstate->im = rcu_dereference(state->idev->mc_list);\n\t\t}\n\t\tif (!state->im)\n\t\t\tbreak;\n\t\tspin_lock_bh(&state->im->lock);\n\t\tpsf = state->im->sources;\n\t}\nout:\n\treturn psf;\n}\n\nstatic struct ip_sf_list *igmp_mcf_get_idx(struct seq_file *seq, loff_t pos)\n{\n\tstruct ip_sf_list *psf = igmp_mcf_get_first(seq);\n\tif (psf)\n\t\twhile (pos && (psf = igmp_mcf_get_next(seq, psf)) != NULL)\n\t\t\t--pos;\n\treturn pos ? NULL : psf;\n}\n\nstatic void *igmp_mcf_seq_start(struct seq_file *seq, loff_t *pos)\n\t__acquires(rcu)\n{\n\trcu_read_lock();\n\treturn *pos ? igmp_mcf_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;\n}\n\nstatic void *igmp_mcf_seq_next(struct seq_file *seq, void *v, loff_t *pos)\n{\n\tstruct ip_sf_list *psf;\n\tif (v == SEQ_START_TOKEN)\n\t\tpsf = igmp_mcf_get_first(seq);\n\telse\n\t\tpsf = igmp_mcf_get_next(seq, v);\n\t++*pos;\n\treturn psf;\n}\n\nstatic void igmp_mcf_seq_stop(struct seq_file *seq, void *v)\n\t__releases(rcu)\n{\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\tif (likely(state->im != NULL)) {\n\t\tspin_unlock_bh(&state->im->lock);\n\t\tstate->im = NULL;\n\t}\n\tstate->idev = NULL;\n\tstate->dev = NULL;\n\trcu_read_unlock();\n}\n\nstatic int igmp_mcf_seq_show(struct seq_file *seq, void *v)\n{\n\tstruct ip_sf_list *psf = (struct ip_sf_list *)v;\n\tstruct igmp_mcf_iter_state *state = igmp_mcf_seq_private(seq);\n\n\tif (v == SEQ_START_TOKEN) {\n\t\tseq_printf(seq,\n\t\t\t   \"%3s %6s \"\n\t\t\t   \"%10s %10s %6s %6s\\n\", \"Idx\",\n\t\t\t   \"Device\", \"MCA\",\n\t\t\t   \"SRC\", \"INC\", \"EXC\");\n\t} else {\n\t\tseq_printf(seq,\n\t\t\t   \"%3d %6.6s 0x%08x \"\n\t\t\t   \"0x%08x %6lu %6lu\\n\",\n\t\t\t   state->dev->ifindex, state->dev->name,\n\t\t\t   ntohl(state->im->multiaddr),\n\t\t\t   ntohl(psf->sf_inaddr),\n\t\t\t   psf->sf_count[MCAST_INCLUDE],\n\t\t\t   psf->sf_count[MCAST_EXCLUDE]);\n\t}\n\treturn 0;\n}\n\nstatic const struct seq_operations igmp_mcf_seq_ops = {\n\t.start\t=\tigmp_mcf_seq_start,\n\t.next\t=\tigmp_mcf_seq_next,\n\t.stop\t=\tigmp_mcf_seq_stop,\n\t.show\t=\tigmp_mcf_seq_show,\n};\n\nstatic int igmp_mcf_seq_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open_net(inode, file, &igmp_mcf_seq_ops,\n\t\t\tsizeof(struct igmp_mcf_iter_state));\n}\n\nstatic const struct file_operations igmp_mcf_seq_fops = {\n\t.owner\t\t=\tTHIS_MODULE,\n\t.open\t\t=\tigmp_mcf_seq_open,\n\t.read\t\t=\tseq_read,\n\t.llseek\t\t=\tseq_lseek,\n\t.release\t=\tseq_release_net,\n};\n\nstatic int __net_init igmp_net_init(struct net *net)\n{\n\tstruct proc_dir_entry *pde;\n\n\tpde = proc_net_fops_create(net, \"igmp\", S_IRUGO, &igmp_mc_seq_fops);\n\tif (!pde)\n\t\tgoto out_igmp;\n\tpde = proc_net_fops_create(net, \"mcfilter\", S_IRUGO, &igmp_mcf_seq_fops);\n\tif (!pde)\n\t\tgoto out_mcfilter;\n\treturn 0;\n\nout_mcfilter:\n\tproc_net_remove(net, \"igmp\");\nout_igmp:\n\treturn -ENOMEM;\n}\n\nstatic void __net_exit igmp_net_exit(struct net *net)\n{\n\tproc_net_remove(net, \"mcfilter\");\n\tproc_net_remove(net, \"igmp\");\n}\n\nstatic struct pernet_operations igmp_net_ops = {\n\t.init = igmp_net_init,\n\t.exit = igmp_net_exit,\n};\n\nint __init igmp_mc_proc_init(void)\n{\n\treturn register_pernet_subsys(&igmp_net_ops);\n}\n#endif\n"], "filenames": ["net/ipv4/igmp.c"], "buggy_code_start_loc": [877], "buggy_code_end_loc": [877], "fixing_code_start_loc": [878], "fixing_code_end_loc": [880], "type": "CWE-369", "message": "The igmp_heard_query function in net/ipv4/igmp.c in the Linux kernel before 3.2.1 allows remote attackers to cause a denial of service (divide-by-zero error and panic) via IGMP packets.", "other": {"cve": {"id": "CVE-2012-0207", "sourceIdentifier": "security@debian.org", "published": "2012-05-17T11:00:36.617", "lastModified": "2023-01-17T21:31:09.670", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The igmp_heard_query function in net/ipv4/igmp.c in the Linux kernel before 3.2.1 allows remote attackers to cause a denial of service (divide-by-zero error and panic) via IGMP packets."}, {"lang": "es", "value": "La funci\u00f3n de igmp_heard_query net/ipv4/igmp.c en el kernel de Linux en versiones anteriores a la v3.2.1 permite a atacantes remotos causar una denegaci\u00f3n de servicio (error de divisi\u00f3n por cero y el \"kernel panic\") a trav\u00e9s de paquetes IGMP."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.0.17", "matchCriteriaId": "F24C14F0-9C07-48BD-9DE9-DDDCB2020217"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.1", "versionEndExcluding": "3.1.9", "matchCriteriaId": "A5CAB3C0-5A93-497E-AE01-9B544D838350"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.2", "versionEndExcluding": "3.2.1", "matchCriteriaId": "E1D67D09-E7BB-4138-91FD-10D3400EB2D7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:redhat:enterprise_linux_eus:5.6:*:*:*:*:*:*:*", "matchCriteriaId": "903512FC-0017-4564-9B89-7E64FFB14B11"}]}]}], "references": [{"url": "http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=654876", "source": "security@debian.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}, {"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commit;h=a8c1f65c79cbbb2f7da782d4c9d15639a9b94b27", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.2.1", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2012/01/10/5", "source": "security@debian.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=772867", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/25c413ad0029ea86008234be28aee33456e53e5b", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/a8c1f65c79cbbb2f7da782d4c9d15639a9b94b27", "source": "security@debian.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/25c413ad0029ea86008234be28aee33456e53e5b"}}