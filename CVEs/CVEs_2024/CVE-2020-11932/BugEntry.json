{"buggy_code": ["# Copyright 2015 Canonical, Ltd.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as\n# published by the Free Software Foundation, either version 3 of the\n# License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom abc import ABC, abstractmethod\nimport attr\nimport collections\nimport enum\nimport fnmatch\nimport itertools\nimport logging\nimport math\nimport os\nimport pathlib\nimport platform\n\nfrom curtin import storage_config\nfrom curtin.util import human2bytes\n\nfrom probert.storage import StorageInfo\n\nlog = logging.getLogger('subiquity.models.filesystem')\n\n\ndef _set_backlinks(obj):\n    for field in attr.fields(type(obj)):\n        backlink = field.metadata.get('backlink')\n        if backlink is None:\n            continue\n        v = getattr(obj, field.name)\n        if v is None:\n            continue\n        if not isinstance(v, (list, set)):\n            v = [v]\n        for vv in v:\n            b = getattr(vv, backlink, None)\n            if isinstance(b, list):\n                b.append(obj)\n            elif isinstance(b, set):\n                b.add(obj)\n            else:\n                setattr(vv, backlink, obj)\n\n\ndef _remove_backlinks(obj):\n    for field in attr.fields(type(obj)):\n        backlink = field.metadata.get('backlink')\n        if backlink is None:\n            continue\n        v = getattr(obj, field.name)\n        if v is None:\n            continue\n        if not isinstance(v, (list, set)):\n            v = [v]\n        for vv in v:\n            b = getattr(vv, backlink, None)\n            if isinstance(b, list):\n                b.remove(obj)\n            elif isinstance(b, set):\n                b.remove(obj)\n            else:\n                setattr(vv, backlink, None)\n\n\n_type_to_cls = {}\n\n\ndef fsobj__repr(obj):\n    args = []\n    for f in attr.fields(type(obj)):\n        if f.name.startswith(\"_\"):\n            continue\n        v = getattr(obj, f.name)\n        if v is f.default:\n            continue\n        if f.metadata.get('ref', False):\n            v = v.id\n        elif f.metadata.get('reflist', False):\n            if isinstance(v, set):\n                delims = \"{}\"\n            else:\n                delims = \"[]\"\n            v = delims[0] + \", \".join(vv.id for vv in v) + delims[1]\n        elif f.metadata.get('redact', False):\n            v = \"<REDACTED>\"\n        else:\n            v = repr(v)\n        args.append(\"{}={}\".format(f.name, v))\n    return \"{}({})\".format(type(obj).__name__, \", \".join(args))\n\n\ndef fsobj(typ):\n    def wrapper(c):\n        c.__attrs_post_init__ = _set_backlinks\n        c.type = attributes.const(typ)\n        c.id = attributes.idfield(typ)\n        c._m = attr.ib(repr=None, default=None)\n        c = attr.s(cmp=False, repr=False)(c)\n        c.__repr__ = fsobj__repr\n        _type_to_cls[typ] = c\n        return c\n    return wrapper\n\n\ndef dependencies(obj):\n    for f in attr.fields(type(obj)):\n        v = getattr(obj, f.name)\n        if not v:\n            continue\n        elif f.metadata.get('ref', False):\n            yield v\n        elif f.metadata.get('reflist', False):\n            yield from v\n\n\ndef reverse_dependencies(obj):\n    for f in attr.fields(type(obj)):\n        if not f.metadata.get('is_backlink', False):\n            continue\n        v = getattr(obj, f.name)\n        if isinstance(v, (list, set)):\n            yield from v\n        elif v is not None:\n            yield v\n\n\n@attr.s(cmp=False)\nclass RaidLevel:\n    name = attr.ib()\n    value = attr.ib()\n    min_devices = attr.ib()\n    supports_spares = attr.ib(default=True)\n\n\nraidlevels = [\n    RaidLevel(_(\"0 (striped)\"),  \"raid0\",  2, False),\n    RaidLevel(_(\"1 (mirrored)\"), \"raid1\",  2),\n    RaidLevel(_(\"5\"),            \"raid5\",  3),\n    RaidLevel(_(\"6\"),            \"raid6\",  4),\n    RaidLevel(_(\"10\"),           \"raid10\", 4),\n    ]\n\n\ndef _raidlevels_by_value():\n    r = {level.value: level for level in raidlevels}\n    for n in 0, 1, 5, 6, 10:\n        r[str(n)] = r[n] = r[\"raid\"+str(n)]\n    r[\"stripe\"] = r[\"raid0\"]\n    r[\"mirror\"] = r[\"raid1\"]\n    return r\n\n\nraidlevels_by_value = _raidlevels_by_value()\n\nHUMAN_UNITS = ['B', 'K', 'M', 'G', 'T', 'P']\n\n\ndef humanize_size(size):\n    if size == 0:\n        return \"0B\"\n    p = int(math.floor(math.log(size, 2) / 10))\n    # We want to truncate the non-integral part, not round to nearest.\n    s = \"{:.17f}\".format(size / 2 ** (10 * p))\n    i = s.index('.')\n    s = s[:i + 4]\n    return s + HUMAN_UNITS[int(p)]\n\n\ndef dehumanize_size(size):\n    # convert human 'size' to integer\n    size_in = size\n\n    if not size:\n        raise ValueError(\"input cannot be empty\")\n\n    if not size[-1].isdigit():\n        suffix = size[-1].upper()\n        size = size[:-1]\n    else:\n        suffix = None\n\n    parts = size.split('.')\n    if len(parts) > 2:\n        raise ValueError(_(\"{!r} is not valid input\").format(size_in))\n    elif len(parts) == 2:\n        div = 10 ** len(parts[1])\n        size = parts[0] + parts[1]\n    else:\n        div = 1\n\n    try:\n        num = int(size)\n    except ValueError:\n        raise ValueError(_(\"{!r} is not valid input\").format(size_in))\n\n    if suffix is not None:\n        if suffix not in HUMAN_UNITS:\n            raise ValueError(\n                \"unrecognized suffix {!r} in {!r}\".format(size_in[-1],\n                                                          size_in))\n        mult = 2 ** (10 * HUMAN_UNITS.index(suffix))\n    else:\n        mult = 1\n\n    if num < 0:\n        raise ValueError(\"{!r}: cannot be negative\".format(size_in))\n\n    return num * mult // div\n\n\nDEFAULT_CHUNK = 512\n\n\n# The calculation of how much of a device mdadm uses for raid is more than a\n# touch ridiculous. What follows is a translation of the code at:\n# https://git.kernel.org/pub/scm/utils/mdadm/mdadm.git/tree/super1.c,\n# specifically choose_bm_space and the end of validate_geometry1. Note that\n# that calculations are in terms of 512-byte sectors.\n#\n# We make some assumptions about the defaults mdadm uses but mostly that the\n# default metadata version is 1.2, and other formats use less space.\n#\n# Note that data_offset is computed for the first disk mdadm examines and then\n# used for all devices, so the order matters! (Well, if the size of the\n# devices vary, which is not normal but also not something we prevent).\n#\n# All this is tested against reality in ./scripts/get-raid-sizes.py\ndef calculate_data_offset_bytes(devsize):\n    # Convert to sectors to make it easier to compare this code to mdadm's (we\n    # convert back at the end)\n    devsize >>= 9\n\n    devsize = align_down(devsize, DEFAULT_CHUNK)\n\n    # conversion of choose_bm_space:\n    if devsize < 64*2:\n        bmspace = 0\n    elif devsize - 64*2 >= 200*1024*1024*2:\n        bmspace = 128*2\n    elif devsize - 4*2 > 8*1024*1024*2:\n        bmspace = 64*2\n    else:\n        bmspace = 4*2\n\n    # From the end of validate_geometry1, assuming metadata 1.2.\n    headroom = 128*1024*2\n    while (headroom << 10) > devsize and headroom / 2 >= DEFAULT_CHUNK*2*2:\n        headroom >>= 1\n\n    data_offset = 12*2 + bmspace + headroom\n    log.debug(\n        \"get_raid_size: adjusting for %s sectors of overhead\", data_offset)\n    data_offset = align_up(data_offset, 2*1024)\n\n    # convert back to bytes\n    return data_offset << 9\n\n\ndef raid_device_sort(devices):\n    # Because the device order matters to mdadm, we sort consistently but\n    # arbitrarily when computing the size and when rendering the config (so\n    # curtin passes the devices to mdadm in the order we calculate the size\n    # for)\n    return sorted(devices, key=lambda d: d.id)\n\n\ndef get_raid_size(level, devices):\n    if len(devices) == 0:\n        return 0\n    devices = raid_device_sort(devices)\n    data_offset = calculate_data_offset_bytes(devices[0].size)\n    sizes = [align_down(dev.size - data_offset) for dev in devices]\n    min_size = min(sizes)\n    if min_size <= 0:\n        return 0\n    if level == \"raid0\":\n        return sum(sizes)\n    elif level == \"raid1\":\n        return min_size\n    elif level == \"raid5\":\n        return min_size * (len(devices) - 1)\n    elif level == \"raid6\":\n        return min_size * (len(devices) - 2)\n    elif level == \"raid10\":\n        return min_size * (len(devices) // 2)\n    else:\n        raise ValueError(\"unknown raid level %s\" % level)\n\n\n# These are only defaults but curtin does not let you change/specify\n# them at this time.\nLVM_OVERHEAD = (1 << 20)\nLVM_CHUNK_SIZE = 4 * (1 << 20)\n\n\ndef get_lvm_size(devices, size_overrides={}):\n    r = 0\n    for d in devices:\n        r += align_down(\n            size_overrides.get(d, d.size) - LVM_OVERHEAD,\n            LVM_CHUNK_SIZE)\n    return r\n\n\ndef _conv_size(s):\n    if isinstance(s, str):\n        if '%' in s:\n            return s\n        return int(human2bytes(s))\n    return s\n\n\nclass attributes:\n    # Just a namespace to hang our wrappers around attr.ib() off.\n\n    @staticmethod\n    def idfield(base):\n        i = 0\n\n        def factory():\n            nonlocal i\n            r = \"%s-%s\" % (base, i)\n            i += 1\n            return r\n        return attr.ib(default=attr.Factory(factory))\n\n    @staticmethod\n    def ref(*, backlink=None):\n        metadata = {'ref': True}\n        if backlink:\n            metadata['backlink'] = backlink\n        return attr.ib(metadata=metadata)\n\n    @staticmethod\n    def reflist(*, backlink=None, default=attr.NOTHING):\n        metadata = {'reflist': True}\n        if backlink:\n            metadata['backlink'] = backlink\n        return attr.ib(metadata=metadata, default=default)\n\n    @staticmethod\n    def backlink(*, default=None):\n        return attr.ib(\n            init=False, default=default, metadata={'is_backlink': True})\n\n    @staticmethod\n    def const(value):\n        return attr.ib(default=value)\n\n    @staticmethod\n    def size():\n        return attr.ib(converter=_conv_size)\n\n    @staticmethod\n    def ptable():\n\n        def conv(val):\n            if val == \"dos\":\n                val = \"msdos\"\n            return val\n        return attr.ib(default=None, converter=conv)\n\n\ndef asdict(inst):\n    r = collections.OrderedDict()\n    for field in attr.fields(type(inst)):\n        if field.name.startswith('_'):\n            continue\n        m = getattr(inst, 'serialize_' + field.name, None)\n        if m:\n            r.update(m())\n        else:\n            v = getattr(inst, field.name)\n            if v is not None:\n                if field.metadata.get('ref', False):\n                    r[field.name] = v.id\n                elif field.metadata.get('reflist', False):\n                    r[field.name] = [elem.id for elem in v]\n                else:\n                    r[field.name] = v\n    return r\n\n\n# This code is not going to make much sense unless you have read\n# http://curtin.readthedocs.io/en/latest/topics/storage.html. The\n# Disk, Partition etc classes correspond to entries in curtin's\n# storage config list. They are mostly 'dumb data', all the logic is\n# in the FilesystemModel or FilesystemController classes.\n\n\nclass DeviceAction(enum.Enum):\n    INFO = _(\"Info\")\n    EDIT = _(\"Edit\")\n    REFORMAT = _(\"Reformat\")\n    PARTITION = _(\"Add Partition\")\n    CREATE_LV = _(\"Create Logical Volume\")\n    FORMAT = _(\"Format\")\n    REMOVE = _(\"Remove from RAID/LVM\")\n    DELETE = _(\"Delete\")\n    TOGGLE_BOOT = _(\"Make Boot Device\")\n\n\ndef _generic_can_EDIT(obj):\n    cd = obj.constructed_device()\n    if cd is None:\n        return True\n    return _(\n        \"Cannot edit {selflabel} as it is part of the {cdtype} \"\n        \"{cdname}.\").format(\n            selflabel=obj.label,\n            cdtype=cd.desc(),\n            cdname=cd.label)\n\n\ndef _generic_can_REMOVE(obj):\n    cd = obj.constructed_device()\n    if cd is None:\n        return False\n    if cd.preserve:\n        return _(\"Cannot remove {selflabel} from pre-existing {cdtype} \"\n                 \"{cdlabel}.\").format(\n                    selflabel=obj.label,\n                    cdtype=cd.desc(),\n                    cdlabel=cd.label)\n    if isinstance(cd, Raid):\n        if obj in cd.spare_devices:\n            return True\n        min_devices = raidlevels_by_value[cd.raidlevel].min_devices\n        if len(cd.devices) == min_devices:\n            return _(\n                \"Removing {selflabel} would leave the {cdtype} {cdlabel} with \"\n                \"less than {min_devices} devices.\").format(\n                    selflabel=obj.label,\n                    cdtype=cd.desc(),\n                    cdlabel=cd.label,\n                    min_devices=min_devices)\n    elif isinstance(cd, LVM_VolGroup):\n        if len(cd.devices) == 1:\n            return _(\n                \"Removing {selflabel} would leave the {cdtype} {cdlabel} with \"\n                \"no devices.\").format(\n                    selflabel=obj.label,\n                    cdtype=cd.desc(),\n                    cdlabel=cd.label)\n    return True\n\n\ndef _generic_can_DELETE(obj):\n    cd = obj.constructed_device()\n    if cd is None:\n        return True\n    return _(\n        \"Cannot delete {selflabel} as it is part of the {cdtype} \"\n        \"{cdname}.\").format(\n            selflabel=obj.label,\n            cdtype=cd.desc(),\n            cdname=cd.label)\n\n\n@attr.s(cmp=False)\nclass _Formattable(ABC):\n    # Base class for anything that can be formatted and mounted,\n    # e.g. a disk or a RAID or a partition.\n\n    @property\n    @abstractmethod\n    def label(self):\n        pass\n\n    @property\n    def annotations(self):\n        preserve = getattr(self, 'preserve', None)\n        if preserve is None:\n            return []\n        elif preserve:\n            return [_(\"existing\")]\n        else:\n            return [_(\"new\")]\n\n    # Filesystem\n    _fs = attributes.backlink()\n    # Raid or LVM_VolGroup for now, but one day ZPool, BCache...\n    _constructed_device = attributes.backlink()\n\n    def usage_labels(self):\n        cd = self.constructed_device()\n        if cd is not None:\n            return [\n                _(\"{component_name} of {desc} {name}\").format(\n                    component_name=cd.component_name,\n                    desc=cd.desc(),\n                    name=cd.name),\n                ]\n        fs = self.fs()\n        if fs is not None:\n            if fs.preserve:\n                format_desc = _(\"already formatted as {fstype}\")\n            elif self.original_fstype() is not None:\n                format_desc = _(\"to be reformatted as {fstype}\")\n            else:\n                format_desc = _(\"to be formatted as {fstype}\")\n            r = [format_desc.format(fstype=fs.fstype)]\n            if self._m.is_mounted_filesystem(fs.fstype):\n                m = fs.mount()\n                if m:\n                    r.append(_(\"mounted at {path}\").format(path=m.path))\n                elif getattr(self, 'flag', None) != \"boot\":\n                    r.append(_(\"not mounted\"))\n            elif fs.preserve:\n                if fs.mount() is None:\n                    r.append(_(\"unused\"))\n                else:\n                    r.append(_(\"used\"))\n            return r\n        else:\n            return [_(\"unused\")]\n\n    def _is_entirely_used(self):\n        return self._fs is not None or self._constructed_device is not None\n\n    def fs(self):\n        return self._fs\n\n    def original_fstype(self):\n        for action in self._m._orig_config:\n            if action['type'] == 'format' and action['volume'] == self.id:\n                return action['fstype']\n        for action in self._m._orig_config:\n            if action['id'] == self.id and action.get('flag') == 'swap':\n                return 'swap'\n        return None\n\n    def constructed_device(self, skip_dm_crypt=True):\n        cd = self._constructed_device\n        if cd is None:\n            return None\n        elif cd.type == \"dm_crypt\" and skip_dm_crypt:\n            return cd._constructed_device\n        else:\n            return cd\n\n    @property\n    @abstractmethod\n    def supported_actions(self):\n        pass\n\n    def action_possible(self, action):\n        assert action in self.supported_actions\n        r = getattr(self, \"_can_\" + action.name)\n        if isinstance(r, bool):\n            return r, None\n        elif isinstance(r, str):\n            return False, r\n        else:\n            return r\n\n    @property\n    @abstractmethod\n    def ok_for_raid(self):\n        pass\n\n    @property\n    @abstractmethod\n    def ok_for_lvm_vg(self):\n        pass\n\n\n# Nothing is put in the first and last megabytes of the disk to allow\n# space for the GPT data.\nGPT_OVERHEAD = 2 * (1 << 20)\n\n\n@attr.s(cmp=False)\nclass _Device(_Formattable, ABC):\n    # Anything that can have partitions, e.g. a disk or a RAID.\n\n    @property\n    @abstractmethod\n    def size(self):\n        pass\n\n    # [Partition]\n    _partitions = attributes.backlink(default=attr.Factory(list))\n\n    def dasd(self):\n        return None\n\n    def ptable_for_new_partition(self):\n        if self.ptable is not None:\n            return self.ptable\n        for action in self._m._orig_config:\n            if action['id'] == self.id:\n                if action.get('ptable') == 'vtoc':\n                    return action['ptable']\n        if self.dasd() is not None:\n            return 'vtoc'\n        return 'gpt'\n\n    def partitions(self):\n        return self._partitions\n\n    @property\n    def used(self):\n        if self._is_entirely_used():\n            return self.size\n        r = 0\n        for p in self._partitions:\n            if p.flag == \"extended\":\n                continue\n            r += p.size\n        return r\n\n    @property\n    def empty(self):\n        return self.used == 0\n\n    @property\n    def available_for_partitions(self):\n        return self.size - GPT_OVERHEAD\n\n    @property\n    def free_for_partitions(self):\n        return self.available_for_partitions - self.used\n\n    def available(self):\n        # A _Device is available if:\n        # 1) it is not part of a device like a RAID or LVM or zpool or ...\n        # 2) if it is formatted, it is available if it is formatted with fs\n        #    that needs to be mounted and is not mounted\n        # 3) if it is not formatted, it is available if it has free\n        #    space OR at least one partition is not formatted or is formatted\n        #    with a fs that needs to be mounted and is not mounted\n        if self._constructed_device is not None:\n            return False\n        if self._fs is not None:\n            return self._fs._available()\n        if self.free_for_partitions > 0:\n            if not self._has_preexisting_partition():\n                return True\n        for p in self._partitions:\n            if p.available():\n                return True\n        return False\n\n    def has_unavailable_partition(self):\n        for p in self._partitions:\n            if not p.available():\n                return True\n        return False\n\n    def _has_preexisting_partition(self):\n        for p in self._partitions:\n            if p.preserve:\n                return True\n        else:\n            return False\n\n    @property\n    def _can_DELETE(self):\n        mounted_partitions = 0\n        for p in self._partitions:\n            if p.fs() and p.fs().mount():\n                mounted_partitions += 1\n            elif p.constructed_device():\n                cd = p.constructed_device()\n                return _(\n                    \"Cannot delete {selflabel} as partition {partnum} is part \"\n                    \"of the {cdtype} {cdname}.\").format(\n                        selflabel=self.label,\n                        partnum=p._number,\n                        cdtype=cd.desc(),\n                        cdname=cd.label,\n                        )\n        if mounted_partitions > 1:\n            return _(\n                \"Cannot delete {selflabel} because it has {count} mounted \"\n                \"partitions.\").format(\n                    selflabel=self.label,\n                    count=mounted_partitions)\n        elif mounted_partitions == 1:\n            return _(\n                \"Cannot delete {selflabel} because it has 1 mounted partition.\"\n                ).format(selflabel=self.label)\n        else:\n            return _generic_can_DELETE(self)\n\n\n@fsobj(\"dasd\")\nclass Dasd:\n    device_id = attr.ib()\n    blocksize = attr.ib()\n    disk_layout = attr.ib()\n    label = attr.ib(default=None)\n    mode = attr.ib(default=None)\n    preserve = attr.ib(default=False)\n\n\n@fsobj(\"disk\")\nclass Disk(_Device):\n    ptable = attributes.ptable()\n    serial = attr.ib(default=None)\n    wwn = attr.ib(default=None)\n    multipath = attr.ib(default=None)\n    path = attr.ib(default=None)\n    model = attr.ib(default=None)\n    wipe = attr.ib(default=None)\n    preserve = attr.ib(default=False)\n    name = attr.ib(default=\"\")\n    grub_device = attr.ib(default=False)\n    device_id = attr.ib(default=None)\n\n    _info = attr.ib(default=None)\n\n    def info_for_display(self):\n        bus = self._info.raw.get('ID_BUS', None)\n        major = self._info.raw.get('MAJOR', None)\n        if bus is None and major == '253':\n            bus = 'virtio'\n\n        devpath = self._info.raw.get('DEVPATH', self.path)\n        # XXX probert should be doing this!!\n        rotational = '1'\n        try:\n            dev = os.path.basename(devpath)\n            rfile = '/sys/class/block/{}/queue/rotational'.format(dev)\n            rotational = open(rfile, 'r').read().strip()\n        except (PermissionError, FileNotFoundError, IOError):\n            log.exception('WARNING: Failed to read file {}'.format(rfile))\n            pass\n\n        dinfo = {\n            'bus': bus,\n            'devname': self.path,\n            'devpath': devpath,\n            'model': self.model or 'unknown',\n            'serial': self.serial or 'unknown',\n            'wwn': self.wwn or 'unknown',\n            'multipath': self.multipath or 'unknown',\n            'size': self.size,\n            'humansize': humanize_size(self.size),\n            'vendor': self._info.vendor or 'unknown',\n            'rotational': 'true' if rotational == '1' else 'false',\n        }\n        return dinfo\n\n    @property\n    def size(self):\n        return align_down(self._info.size)\n\n    @property\n    def annotations(self):\n        return []\n\n    def desc(self):\n        if self.multipath:\n            return _(\"multipath device\")\n        return _(\"local disk\")\n\n    @property\n    def label(self):\n        if self.multipath:\n            return self.wwn\n        return self.serial or self.path\n\n    def dasd(self):\n        return self._m._one(type='dasd', device_id=self.device_id)\n\n    def _can_be_boot_disk(self):\n        bl = self._m.bootloader\n        if self._has_preexisting_partition():\n            if bl == Bootloader.BIOS:\n                if self.ptable == \"msdos\":\n                    return True\n                else:\n                    return self._partitions[0].flag == \"bios_grub\"\n            else:\n                flag = {Bootloader.UEFI: \"boot\", Bootloader.PREP: \"prep\"}[bl]\n                for p in self._partitions:\n                    if p.flag == flag:\n                        return True\n                return False\n        else:\n            return True\n\n    @property\n    def supported_actions(self):\n        actions = [\n            DeviceAction.INFO,\n            DeviceAction.REFORMAT,\n            DeviceAction.PARTITION,\n            DeviceAction.FORMAT,\n            DeviceAction.REMOVE,\n            ]\n        if self._m.bootloader != Bootloader.NONE:\n            actions.append(DeviceAction.TOGGLE_BOOT)\n        return actions\n\n    _can_INFO = True\n\n    @property\n    def _can_REFORMAT(self):\n        if len(self._partitions) == 0:\n            return False\n        for p in self._partitions:\n            if p._constructed_device is not None:\n                return False\n        return True\n\n    @property\n    def _can_PARTITION(self):\n        if self._has_preexisting_partition():\n            return False\n        if self.free_for_partitions <= 0:\n            return False\n        if self.ptable == 'vtoc' and len(self._partitions) >= 3:\n            return False\n        return True\n\n    _can_FORMAT = property(\n        lambda self: len(self._partitions) == 0 and\n        self._constructed_device is None)\n    _can_REMOVE = property(_generic_can_REMOVE)\n\n    def _is_boot_device(self):\n        bl = self._m.bootloader\n        if bl == Bootloader.NONE:\n            return False\n        elif bl == Bootloader.BIOS:\n            return self.grub_device\n        elif bl in [Bootloader.PREP, Bootloader.UEFI]:\n            for p in self._partitions:\n                if p.grub_device:\n                    return True\n            return False\n\n    @property\n    def _can_TOGGLE_BOOT(self):\n        if self._is_boot_device():\n            for disk in self._m.all_disks():\n                if disk is not self and disk._is_boot_device():\n                    return True\n            return False\n        elif self._fs is not None or self._constructed_device is not None:\n            return False\n        else:\n            return self._can_be_boot_disk()\n\n    @property\n    def ok_for_raid(self):\n        if self._fs is not None:\n            if self._fs.preserve:\n                return self._fs._mount is None\n            return False\n        if self._constructed_device is not None:\n            return False\n        if len(self._partitions) > 0:\n            return False\n        return True\n\n    ok_for_lvm_vg = ok_for_raid\n\n\n@fsobj(\"partition\")\nclass Partition(_Formattable):\n    device = attributes.ref(backlink=\"_partitions\")  # Disk\n    size = attributes.size()\n\n    wipe = attr.ib(default=None)\n    flag = attr.ib(default=None)\n    number = attr.ib(default=None)\n    preserve = attr.ib(default=False)\n    grub_device = attr.ib(default=False)\n\n    @property\n    def annotations(self):\n        r = super().annotations\n        if self.flag == \"prep\":\n            r.append(\"PReP\")\n            if self.preserve:\n                if self.grub_device:\n                    r.append(_(\"configured\"))\n                else:\n                    r.append(_(\"unconfigured\"))\n        elif self.flag == \"boot\":\n            if self.fs() and self.fs().mount():\n                r.append(_(\"primary ESP\"))\n            elif self.grub_device:\n                r.append(_(\"backup ESP\"))\n            else:\n                r.append(_(\"unused ESP\"))\n        elif self.flag == \"bios_grub\":\n            if self.preserve:\n                if self.device.grub_device:\n                    r.append(_(\"configured\"))\n                else:\n                    r.append(_(\"unconfigured\"))\n            r.append(\"bios_grub\")\n        elif self.flag == \"extended\":\n            r.append(_(\"extended\"))\n        elif self.flag == \"logical\":\n            r.append(_(\"logical\"))\n        return r\n\n    def usage_labels(self):\n        if self.flag == \"prep\" or self.flag == \"bios_grub\":\n            return []\n        return super().usage_labels()\n\n    def desc(self):\n        return _(\"partition of {device}\").format(device=self.device.desc())\n\n    @property\n    def label(self):\n        return _(\"partition {number} of {device}\").format(\n            number=self._number, device=self.device.label)\n\n    @property\n    def short_label(self):\n        return _(\"partition {number}\").format(number=self._number)\n\n    def available(self):\n        if self.flag in ['bios_grub', 'prep'] or self.grub_device:\n            return False\n        if self._constructed_device is not None:\n            return False\n        if self._fs is None:\n            return True\n        return self._fs._available()\n\n    def serialize_number(self):\n        return {'number': self._number}\n\n    @property\n    def _number(self):\n        if self.preserve:\n            return self.number\n        else:\n            return self.device._partitions.index(self) + 1\n\n    supported_actions = [\n        DeviceAction.EDIT,\n        DeviceAction.REMOVE,\n        DeviceAction.DELETE,\n        ]\n\n    _can_EDIT = property(_generic_can_EDIT)\n\n    _can_REMOVE = property(_generic_can_REMOVE)\n\n    @property\n    def _can_DELETE(self):\n        if self.device._has_preexisting_partition():\n            return _(\"Cannot delete a single partition from a device that \"\n                     \"already has partitions.\")\n        if self.flag in ('boot', 'bios_grub', 'prep'):\n            return _(\"Cannot delete required bootloader partition\")\n        return _generic_can_DELETE(self)\n\n    @property\n    def ok_for_raid(self):\n        if self.flag in ('boot', 'bios_grub', 'prep'):\n            return False\n        if self._fs is not None:\n            if self._fs.preserve:\n                return self._fs._mount is None\n            return False\n        if self._constructed_device is not None:\n            return False\n        return True\n\n    ok_for_lvm_vg = ok_for_raid\n\n\n@fsobj(\"raid\")\nclass Raid(_Device):\n    name = attr.ib()\n    raidlevel = attr.ib(converter=lambda x: raidlevels_by_value[x].value)\n    devices = attributes.reflist(backlink=\"_constructed_device\")\n\n    def serialize_devices(self):\n        # Surprisingly, the order of devices passed to mdadm --create\n        # matters (see get_raid_size) so we sort devices here the same\n        # way get_raid_size does.\n        return {'devices': [d.id for d in raid_device_sort(self.devices)]}\n\n    spare_devices = attributes.reflist(\n        backlink=\"_constructed_device\", default=attr.Factory(set))\n\n    preserve = attr.ib(default=False)\n    ptable = attributes.ptable()\n\n    @property\n    def size(self):\n        return get_raid_size(self.raidlevel, self.devices)\n\n    @property\n    def available_for_partitions(self):\n        # For some reason, the overhead on RAID devices seems to be\n        # higher (may be related to alignment of underlying\n        # partitions)\n        return self.size - 2*GPT_OVERHEAD\n\n    @property\n    def label(self):\n        return self.name\n\n    def desc(self):\n        return _(\"software RAID {level}\").format(level=self.raidlevel[4:])\n\n    supported_actions = [\n        DeviceAction.EDIT,\n        DeviceAction.PARTITION,\n        DeviceAction.FORMAT,\n        DeviceAction.REMOVE,\n        DeviceAction.DELETE,\n        DeviceAction.REFORMAT,\n        ]\n\n    @property\n    def _can_EDIT(self):\n        if self.preserve:\n            return _(\"Cannot edit pre-existing RAIDs.\")\n        elif len(self._partitions) > 0:\n            return _(\n                \"Cannot edit {selflabel} because it has partitions.\").format(\n                    selflabel=self.label)\n        else:\n            return _generic_can_EDIT(self)\n\n    _can_PARTITION = Disk._can_PARTITION\n    _can_REFORMAT = Disk._can_REFORMAT\n    _can_FORMAT = property(\n        lambda self: len(self._partitions) == 0 and\n        self._constructed_device is None)\n    _can_REMOVE = property(_generic_can_REMOVE)\n\n    @property\n    def ok_for_raid(self):\n        if self._fs is not None:\n            if self._fs.preserve:\n                return self._fs._mount is None\n            return False\n        if self._constructed_device is not None:\n            return False\n        if len(self._partitions) > 0:\n            return False\n        return True\n\n    ok_for_lvm_vg = ok_for_raid\n\n    # What is a device that makes up this device referred to as?\n    component_name = \"component\"\n\n\n@fsobj(\"lvm_volgroup\")\nclass LVM_VolGroup(_Device):\n    name = attr.ib()\n    devices = attributes.reflist(backlink=\"_constructed_device\")\n\n    preserve = attr.ib(default=False)\n\n    @property\n    def size(self):\n        # Should probably query actual size somehow for an existing VG!\n        return get_lvm_size(self.devices)\n\n    @property\n    def available_for_partitions(self):\n        return self.size\n\n    @property\n    def annotations(self):\n        r = super().annotations\n        member = next(iter(self.devices))\n        if member.type == \"dm_crypt\":\n            r.append(_(\"encrypted\"))\n        return r\n\n    @property\n    def label(self):\n        return self.name\n\n    def desc(self):\n        return _(\"LVM volume group\")\n\n    supported_actions = [\n        DeviceAction.EDIT,\n        DeviceAction.CREATE_LV,\n        DeviceAction.DELETE,\n        ]\n\n    @property\n    def _can_EDIT(self):\n        if self.preserve:\n            return _(\"Cannot edit pre-existing volume groups.\")\n        elif len(self._partitions) > 0:\n            return _(\n                \"Cannot edit {selflabel} because it has logical \"\n                \"volumes.\").format(\n                    selflabel=self.label)\n        else:\n            return _generic_can_EDIT(self)\n\n    _can_CREATE_LV = property(\n        lambda self: not self.preserve and self.free_for_partitions > 0)\n\n    ok_for_raid = False\n    ok_for_lvm_vg = False\n\n    # What is a device that makes up this device referred to as?\n    component_name = \"PV\"\n\n\n@fsobj(\"lvm_partition\")\nclass LVM_LogicalVolume(_Formattable):\n    name = attr.ib()\n    volgroup = attributes.ref(backlink=\"_partitions\")  # LVM_VolGroup\n    size = attributes.size()\n\n    preserve = attr.ib(default=False)\n\n    def serialize_size(self):\n        return {'size': \"{}B\".format(self.size)}\n\n    def available(self):\n        if self._constructed_device is not None:\n            return False\n        if self._fs is None:\n            return True\n        return self._fs._available()\n\n    @property\n    def flag(self):\n        return None  # hack!\n\n    def desc(self):\n        return _(\"LVM logical volume\")\n\n    @property\n    def short_label(self):\n        return self.name\n\n    label = short_label\n\n    supported_actions = [\n        DeviceAction.EDIT,\n        DeviceAction.DELETE,\n        ]\n\n    _can_EDIT = True\n\n    @property\n    def _can_DELETE(self):\n        if self.volgroup._has_preexisting_partition():\n            return _(\"Cannot delete a single logical volume from a volume \"\n                     \"group that already has logical volumes.\")\n        return True\n\n    ok_for_raid = False\n    ok_for_lvm_vg = False\n\n\nLUKS_OVERHEAD = 16*(2**20)\n\n\n@fsobj(\"dm_crypt\")\nclass DM_Crypt:\n    volume = attributes.ref(backlink=\"_constructed_device\")  # _Formattable\n    key = attr.ib(metadata={'redact': True})\n\n    dm_name = attr.ib(default=None)\n    preserve = attr.ib(default=False)\n\n    _constructed_device = attributes.backlink()\n\n    def constructed_device(self):\n        return self._constructed_device\n\n    @property\n    def size(self):\n        return self.volume.size - LUKS_OVERHEAD\n\n\n@fsobj(\"format\")\nclass Filesystem:\n    fstype = attr.ib()\n    volume = attributes.ref(backlink=\"_fs\")  # _Formattable\n\n    label = attr.ib(default=None)\n    uuid = attr.ib(default=None)\n    preserve = attr.ib(default=False)\n\n    _mount = attributes.backlink()\n\n    def mount(self):\n        return self._mount\n\n    def _available(self):\n        # False if mounted or if fs does not require a mount, True otherwise.\n        if self._mount is None:\n            if self.preserve:\n                return True\n            else:\n                return FilesystemModel.is_mounted_filesystem(self.fstype)\n        else:\n            return False\n\n\n@fsobj(\"mount\")\nclass Mount:\n    device = attributes.ref(backlink=\"_mount\")  # Filesystem\n    path = attr.ib()\n\n    def can_delete(self):\n        # Can't delete mount of /boot/efi or swap, anything else is fine.\n        if not self.path:\n            # swap mount\n            return False\n        if not isinstance(self.device.volume, Partition):\n            # Can't be /boot/efi if volume is not a partition\n            return True\n        if self.device.volume.flag == \"boot\":\n            # /boot/efi\n            return False\n        return True\n\n\ndef align_up(size, block_size=1 << 20):\n    return (size + block_size - 1) & ~(block_size - 1)\n\n\ndef align_down(size, block_size=1 << 20):\n    return size & ~(block_size - 1)\n\n\nclass Bootloader(enum.Enum):\n    NONE = \"NONE\"  # a system where the bootloader is external, e.g. s390x\n    BIOS = \"BIOS\"  # BIOS, where the bootloader dd-ed to the start of a device\n    UEFI = \"UEFI\"  # UEFI, ESPs and /boot/efi and all that (amd64 and arm64)\n    PREP = \"PREP\"  # ppc64el, which puts grub on a PReP partition\n\n\nclass FilesystemModel(object):\n\n    lower_size_limit = 128 * (1 << 20)\n\n    target = None\n\n    @classmethod\n    def is_mounted_filesystem(self, fstype):\n        if fstype in [None, 'swap']:\n            return False\n        else:\n            return True\n\n    def _probe_bootloader(self):\n        # This will at some point change to return a list so that we can\n        # configure BIOS _and_ UEFI on amd64 systems.\n        if os.path.exists('/sys/firmware/efi'):\n            return Bootloader.UEFI\n        elif platform.machine().startswith(\"ppc64\"):\n            return Bootloader.PREP\n        elif platform.machine() == \"s390x\":\n            return Bootloader.NONE\n        else:\n            return Bootloader.BIOS\n\n    def __init__(self):\n        self.bootloader = self._probe_bootloader()\n        self._probe_data = None\n        self.reset()\n\n    def reset(self):\n        if self._probe_data is not None:\n            self._orig_config = storage_config.extract_storage_config(\n                self._probe_data)[\"storage\"][\"config\"]\n            self._actions = self._actions_from_config(\n                self._orig_config, self._probe_data['blockdev'])\n        else:\n            self._orig_config = []\n            self._actions = []\n        self.swap = None\n        self.grub = None\n\n    def _make_matchers(self, match):\n        matchers = []\n\n        def match_serial(disk):\n            if disk.serial is not None:\n                return fnmatch.fnmatchcase(disk.serial, match['serial'])\n\n        def match_model(disk):\n            if disk.model is not None:\n                return fnmatch.fnmatchcase(disk.model, match['model'])\n\n        def match_path(disk):\n            if disk.path is not None:\n                return fnmatch.fnmatchcase(disk.path, match['path'])\n\n        def match_ssd(disk):\n            is_ssd = disk.info_for_display()['rotational'] == 'false'\n            return is_ssd == match['ssd']\n\n        if 'serial' in match:\n            matchers.append(match_serial)\n        if 'model' in match:\n            matchers.append(match_model)\n        if 'path' in match:\n            matchers.append(match_path)\n        if 'ssd' in match:\n            matchers.append(match_ssd)\n\n        return matchers\n\n    def disk_for_match(self, disks, match):\n        matchers = self._make_matchers(match)\n        candidates = []\n        for candidate in disks:\n            for matcher in matchers:\n                if not matcher(candidate):\n                    break\n            else:\n                candidates.append(candidate)\n        if match.get('size') == 'largest':\n            candidates.sort(key=lambda d: d.size, reverse=True)\n        if candidates:\n            return candidates[0]\n        return None\n\n    def apply_autoinstall_config(self, ai_config):\n        disks = self.all_disks()\n        for action in ai_config:\n            if action['type'] == 'disk':\n                disk = None\n                if 'serial' in action:\n                    disk = self._one(type='disk', serial=action['serial'])\n                elif 'path' in action:\n                    disk = self._one(type='disk', path=action['path'])\n                else:\n                    match = action.pop('match', {})\n                    disk = self.disk_for_match(disks, match)\n                    if disk is None:\n                        action['match'] = match\n                if disk is None:\n                    raise Exception(\"{} matched no disk\".format(action))\n                if disk not in disks:\n                    raise Exception(\n                        \"{} matched {} which was already used\".format(\n                            action, disk))\n                disks.remove(disk)\n                action['path'] = disk.path\n                action['serial'] = disk.serial\n        self._actions = self._actions_from_config(\n            ai_config, self._probe_data['blockdev'], is_autoinstall=True)\n        for p in self._all(type=\"partition\") + self._all(type=\"lvm_partition\"):\n            [parent] = list(dependencies(p))\n            if isinstance(p.size, int):\n                if p.size < 0:\n                    if p is not parent.partitions()[-1]:\n                        raise Exception(\n                            \"{} has negative size but is not final partition \"\n                            \"of {}\".format(p, parent))\n                    p.size = 0\n                    p.size = parent.free_for_partitions\n            elif isinstance(p.size, str):\n                if p.size.endswith(\"%\"):\n                    percentage = int(p.size[:-1])\n                    p.size = align_down(\n                        parent.available_for_partitions*percentage//100)\n                else:\n                    p.size = dehumanize_size(p.size)\n\n    def _actions_from_config(self, config, blockdevs, is_autoinstall=False):\n        \"\"\"Convert curtin storage config into action instances.\n\n        curtin represents storage \"actions\" as defined in\n        https://curtin.readthedocs.io/en/latest/topics/storage.html.  We\n        convert each action (that we know about) into an instance of\n        Disk, Partition, RAID, etc (unknown actions, e.g. bcache, are\n        just ignored).\n\n        We also filter out anything that can be reached from a currently\n        mounted device. The motivation here is only to exclude the media\n        subiquity is mounted from, so this might be a bit excessive but\n        hey it works.\n\n        Perhaps surprisingly the order of the returned actions matters.\n        The devices are presented in the filesystem view in the reverse\n        of the order they appear in _actions, which means that e.g. a\n        RAID appears higher up the list than the disks is is composed\n        of. This is quite important as it makes \"unpeeling\" existing\n        compound structures easy, you just delete the top device until\n        you only have disks left.\n        \"\"\"\n        byid = {}\n        objs = []\n        exclusions = set()\n        seen_multipaths = set()\n        for action in config:\n            if not is_autoinstall and action['type'] == 'mount':\n                if not action['path'].startswith(self.target):\n                    # Completely ignore mounts under /target, they are\n                    # probably leftovers from a previous install\n                    # attempt.\n                    exclusions.add(byid[action['device']])\n                continue\n            c = _type_to_cls.get(action['type'], None)\n            if c is None:\n                # Ignore any action we do not know how to process yet\n                # (e.g. bcache)\n                continue\n            kw = {}\n            for f in attr.fields(c):\n                n = f.name\n                if n not in action:\n                    continue\n                v = action[n]\n                try:\n                    if f.metadata.get('ref', False):\n                        kw[n] = byid[v]\n                    elif f.metadata.get('reflist', False):\n                        kw[n] = [byid[id] for id in v]\n                    else:\n                        kw[n] = v\n                except KeyError:\n                    # If a dependency of the current action has been\n                    # ignored, we need to ignore the current action too\n                    # (e.g. a bcache's filesystem).\n                    continue\n            if kw['type'] == 'disk':\n                path = kw['path']\n                kw['info'] = StorageInfo({path: blockdevs[path]})\n            if not is_autoinstall:\n                kw['preserve'] = True\n            obj = byid[action['id']] = c(m=self, **kw)\n            multipath = kw.get('multipath')\n            if multipath:\n                if multipath in seen_multipaths:\n                    exclusions.add(obj)\n                else:\n                    seen_multipaths.add(multipath)\n            objs.append(obj)\n\n        while True:\n            next_exclusions = exclusions.copy()\n            for e in exclusions:\n                next_exclusions.update(itertools.chain(\n                    dependencies(e), reverse_dependencies(e)))\n            if len(exclusions) == len(next_exclusions):\n                break\n            exclusions = next_exclusions\n\n        log.debug(\"exclusions %s\", {e.id for e in exclusions})\n\n        objs = [o for o in objs if o not in exclusions]\n\n        if not is_autoinstall:\n            for o in objs:\n                if o.type == \"partition\" and o.flag == \"swap\":\n                    if o._fs is None:\n                        objs.append(Filesystem(\n                            m=self, fstype=\"swap\", volume=o, preserve=True))\n\n        return objs\n\n    def _render_actions(self):\n        # The curtin storage config has the constraint that an action must be\n        # preceded by all the things that it depends on.  We handle this by\n        # repeatedly iterating over all actions and checking if we can emit\n        # each action by checking if all of the actions it depends on have been\n        # emitted.  Eventually this will either emit all actions or stop making\n        # progress -- which means there is a cycle in the definitions,\n        # something the UI should have prevented <wink>.\n        r = []\n        emitted_ids = set()\n\n        def emit(obj):\n            if isinstance(obj, Raid):\n                log.debug(\n                    \"FilesystemModel: estimated size of %s %s is %s\",\n                    obj.raidlevel, obj.name, obj.size)\n            r.append(asdict(obj))\n            emitted_ids.add(obj.id)\n\n        def ensure_partitions(dev):\n            for part in dev.partitions():\n                if part.id not in emitted_ids:\n                    if part not in work and part not in next_work:\n                        next_work.append(part)\n\n        def can_emit(obj):\n            if obj.type == \"partition\":\n                ensure_partitions(obj.device)\n                for p in obj.device.partitions():\n                    if p._number < obj._number and p.id not in emitted_ids:\n                        return False\n            for dep in dependencies(obj):\n                if dep.id not in emitted_ids:\n                    if dep not in work and dep not in next_work:\n                        next_work.append(dep)\n                        if dep.type in ['disk', 'raid']:\n                            ensure_partitions(dep)\n                    return False\n            if isinstance(obj, Mount):\n                # Any mount actions for a parent of this one have to be emitted\n                # first.\n                for parent in pathlib.Path(obj.path).parents:\n                    parent = str(parent)\n                    if parent in mountpoints:\n                        if mountpoints[parent] not in emitted_ids:\n                            log.debug(\n                                \"cannot emit action to mount %s until that \"\n                                \"for %s is emitted\", obj.path, parent)\n                            return False\n            return True\n\n        mountpoints = {m.path: m.id for m in self.all_mounts()}\n        log.debug('mountpoints %s', mountpoints)\n\n        work = [\n            a for a in self._actions\n            if not getattr(a, 'preserve', False)\n            ]\n\n        while work:\n            next_work = []\n            for obj in work:\n                if can_emit(obj):\n                    emit(obj)\n                else:\n                    next_work.append(obj)\n            if {a.id for a in next_work} == {a.id for a in work}:\n                msg = [\"rendering block devices made no progress processing:\"]\n                for w in work:\n                    msg.append(\" - \" + str(w))\n                raise Exception(\"\\n\".join(msg))\n            work = next_work\n\n        return r\n\n    def render(self):\n        config = {\n            'storage': {\n                'version': 1,\n                'config': self._render_actions(),\n                },\n            }\n        if self.swap is not None:\n            config['swap'] = self.swap\n        if self.grub is not None:\n            config['grub'] = self.grub\n        return config\n\n    def load_probe_data(self, probe_data):\n        self._probe_data = probe_data\n        self.reset()\n\n    def _matcher(self, type, kw):\n        for a in self._actions:\n            if a.type != type:\n                continue\n            for k, v in kw.items():\n                if getattr(a, k) != v:\n                    break\n            else:\n                yield a\n\n    def _one(self, *, type, **kw):\n        try:\n            return next(self._matcher(type, kw))\n        except StopIteration:\n            return None\n\n    def _all(self, *, type, **kw):\n        return list(self._matcher(type, kw))\n\n    def all_mounts(self):\n        return self._all(type='mount')\n\n    def all_devices(self):\n        # return:\n        #  compound devices, newest first\n        #  disk devices, sorted by label\n        disks = []\n        compounds = []\n        for a in self._actions:\n            if a.type == 'disk':\n                disks.append(a)\n            elif isinstance(a, _Device):\n                compounds.append(a)\n        compounds.reverse()\n        disks.sort(key=lambda x: x.label)\n        return compounds + disks\n\n    def all_disks(self):\n        return sorted(self._all(type='disk'), key=lambda x: x.label)\n\n    def all_raids(self):\n        return self._all(type='raid')\n\n    def all_volgroups(self):\n        return self._all(type='lvm_volgroup')\n\n    def _remove(self, obj):\n        _remove_backlinks(obj)\n        self._actions.remove(obj)\n\n    def add_partition(self, device, size, flag=\"\", wipe=None,\n                      grub_device=None):\n        if size > device.free_for_partitions:\n            raise Exception(\"%s > %s\", size, device.free_for_partitions)\n        real_size = align_up(size)\n        log.debug(\"add_partition: rounded size from %s to %s\", size, real_size)\n        if device._fs is not None:\n            raise Exception(\"%s is already formatted\" % (device.label,))\n        p = Partition(\n            m=self, device=device, size=real_size, flag=flag, wipe=wipe,\n            grub_device=grub_device)\n        if flag in (\"boot\", \"bios_grub\", \"prep\"):\n            device._partitions.insert(0, device._partitions.pop())\n        device.ptable = device.ptable_for_new_partition()\n        dasd = device.dasd()\n        if dasd is not None:\n            dasd.device_layout = 'cdl'\n            dasd.preserve = False\n        self._actions.append(p)\n        return p\n\n    def remove_partition(self, part):\n        if part._fs or part._constructed_device:\n            raise Exception(\"can only remove empty partition\")\n        self._remove(part)\n        if len(part.device._partitions) == 0:\n            part.device.ptable = None\n\n    def add_raid(self, name, raidlevel, devices, spare_devices):\n        r = Raid(\n            m=self,\n            name=name,\n            raidlevel=raidlevel,\n            devices=devices,\n            spare_devices=spare_devices)\n        self._actions.append(r)\n        return r\n\n    def remove_raid(self, raid):\n        if raid._fs or raid._constructed_device or len(raid.partitions()):\n            raise Exception(\"can only remove empty RAID\")\n        self._remove(raid)\n\n    def add_volgroup(self, name, devices):\n        vg = LVM_VolGroup(m=self, name=name, devices=devices)\n        self._actions.append(vg)\n        return vg\n\n    def remove_volgroup(self, vg):\n        if len(vg._partitions):\n            raise Exception(\"can only remove empty VG\")\n        self._remove(vg)\n\n    def add_logical_volume(self, vg, name, size):\n        lv = LVM_LogicalVolume(m=self, volgroup=vg, name=name, size=size)\n        self._actions.append(lv)\n        return lv\n\n    def remove_logical_volume(self, lv):\n        if lv._fs:\n            raise Exception(\"can only remove empty LV\")\n        self._remove(lv)\n\n    def add_dm_crypt(self, volume, key):\n        if not volume.available:\n            raise Exception(\"{} is not available\".format(volume))\n        dm_crypt = DM_Crypt(volume=volume, key=key)\n        self._actions.append(dm_crypt)\n        return dm_crypt\n\n    def remove_dm_crypt(self, dm_crypt):\n        self._remove(dm_crypt)\n\n    def add_filesystem(self, volume, fstype, preserve=False):\n        log.debug(\"adding %s to %s\", fstype, volume)\n        if not volume.available:\n            if not isinstance(volume, Partition):\n                if (volume.flag == 'prep' or (\n                        volume.flag == 'bios_grub' and fstype == 'fat32')):\n                    raise Exception(\"{} is not available\".format(volume))\n        if volume._fs is not None:\n            raise Exception(\"%s is already formatted\")\n        fs = Filesystem(\n            m=self, volume=volume, fstype=fstype, preserve=preserve)\n        self._actions.append(fs)\n        return fs\n\n    def remove_filesystem(self, fs):\n        if fs._mount:\n            raise Exception(\"can only remove unmounted filesystem\")\n        self._remove(fs)\n\n    def add_mount(self, fs, path):\n        if fs._mount is not None:\n            raise Exception(\"%s is already mounted\")\n        m = Mount(m=self, device=fs, path=path)\n        self._actions.append(m)\n        # Adding a swap partition or mounting btrfs at / suppresses\n        # the swapfile.\n        if not self._should_add_swapfile():\n            self.swap = {'swap': 0}\n        return m\n\n    def remove_mount(self, mount):\n        self._remove(mount)\n        # Removing a mount might make it ok to add a swapfile again.\n        if self._should_add_swapfile():\n            self.swap = None\n\n    def needs_bootloader_partition(self):\n        '''true if no disk have a boot partition, and one is needed'''\n        # s390x has no such thing\n        if self.bootloader == Bootloader.NONE:\n            return False\n        elif self.bootloader == Bootloader.BIOS:\n            return self._one(type='disk', grub_device=True) is None\n        elif self.bootloader == Bootloader.UEFI:\n            for esp in self._all(type='partition', grub_device=True):\n                if esp.fs() and esp.fs().mount():\n                    if esp.fs().mount().path == '/boot/efi':\n                        return False\n            return True\n        elif self.bootloader == Bootloader.PREP:\n            return self._one(type='partition', grub_device=True) is None\n        else:\n            raise AssertionError(\n                \"unknown bootloader type {}\".format(self.bootloader))\n\n    def _mount_for_path(self, path):\n        return self._one(type='mount', path=path)\n\n    def is_root_mounted(self):\n        return self._mount_for_path('/') is not None\n\n    def can_install(self):\n        return (self.is_root_mounted()\n                and not self.needs_bootloader_partition())\n\n    def _should_add_swapfile(self):\n        mount = self._mount_for_path('/')\n        if mount is not None and mount.device.fstype == 'btrfs':\n            return False\n        for swap in self._all(type='format', fstype='swap'):\n            if swap.mount():\n                return False\n        return True\n"], "fixing_code": ["# Copyright 2015 Canonical, Ltd.\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Affero General Public License as\n# published by the Free Software Foundation, either version 3 of the\n# License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Affero General Public License for more details.\n#\n# You should have received a copy of the GNU Affero General Public License\n# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nfrom abc import ABC, abstractmethod\nimport attr\nimport collections\nimport enum\nimport fnmatch\nimport itertools\nimport logging\nimport math\nimport os\nimport pathlib\nimport platform\nimport tempfile\n\nfrom curtin import storage_config\nfrom curtin.util import human2bytes\n\nfrom probert.storage import StorageInfo\n\nlog = logging.getLogger('subiquity.models.filesystem')\n\n\ndef _set_backlinks(obj):\n    for field in attr.fields(type(obj)):\n        backlink = field.metadata.get('backlink')\n        if backlink is None:\n            continue\n        v = getattr(obj, field.name)\n        if v is None:\n            continue\n        if not isinstance(v, (list, set)):\n            v = [v]\n        for vv in v:\n            b = getattr(vv, backlink, None)\n            if isinstance(b, list):\n                b.append(obj)\n            elif isinstance(b, set):\n                b.add(obj)\n            else:\n                setattr(vv, backlink, obj)\n\n\ndef _remove_backlinks(obj):\n    for field in attr.fields(type(obj)):\n        backlink = field.metadata.get('backlink')\n        if backlink is None:\n            continue\n        v = getattr(obj, field.name)\n        if v is None:\n            continue\n        if not isinstance(v, (list, set)):\n            v = [v]\n        for vv in v:\n            b = getattr(vv, backlink, None)\n            if isinstance(b, list):\n                b.remove(obj)\n            elif isinstance(b, set):\n                b.remove(obj)\n            else:\n                setattr(vv, backlink, None)\n\n\n_type_to_cls = {}\n\n\ndef fsobj__repr(obj):\n    args = []\n    for f in attr.fields(type(obj)):\n        if f.name.startswith(\"_\"):\n            continue\n        v = getattr(obj, f.name)\n        if v is f.default:\n            continue\n        if f.metadata.get('ref', False):\n            v = v.id\n        elif f.metadata.get('reflist', False):\n            if isinstance(v, set):\n                delims = \"{}\"\n            else:\n                delims = \"[]\"\n            v = delims[0] + \", \".join(vv.id for vv in v) + delims[1]\n        elif f.metadata.get('redact', False):\n            v = \"<REDACTED>\"\n        else:\n            v = repr(v)\n        args.append(\"{}={}\".format(f.name, v))\n    return \"{}({})\".format(type(obj).__name__, \", \".join(args))\n\n\ndef fsobj(typ):\n    def wrapper(c):\n        c.__attrs_post_init__ = _set_backlinks\n        c.type = attributes.const(typ)\n        c.id = attributes.idfield(typ)\n        c._m = attr.ib(repr=None, default=None)\n        c = attr.s(cmp=False, repr=False)(c)\n        c.__repr__ = fsobj__repr\n        _type_to_cls[typ] = c\n        return c\n    return wrapper\n\n\ndef dependencies(obj):\n    for f in attr.fields(type(obj)):\n        v = getattr(obj, f.name)\n        if not v:\n            continue\n        elif f.metadata.get('ref', False):\n            yield v\n        elif f.metadata.get('reflist', False):\n            yield from v\n\n\ndef reverse_dependencies(obj):\n    for f in attr.fields(type(obj)):\n        if not f.metadata.get('is_backlink', False):\n            continue\n        v = getattr(obj, f.name)\n        if isinstance(v, (list, set)):\n            yield from v\n        elif v is not None:\n            yield v\n\n\n@attr.s(cmp=False)\nclass RaidLevel:\n    name = attr.ib()\n    value = attr.ib()\n    min_devices = attr.ib()\n    supports_spares = attr.ib(default=True)\n\n\nraidlevels = [\n    RaidLevel(_(\"0 (striped)\"),  \"raid0\",  2, False),\n    RaidLevel(_(\"1 (mirrored)\"), \"raid1\",  2),\n    RaidLevel(_(\"5\"),            \"raid5\",  3),\n    RaidLevel(_(\"6\"),            \"raid6\",  4),\n    RaidLevel(_(\"10\"),           \"raid10\", 4),\n    ]\n\n\ndef _raidlevels_by_value():\n    r = {level.value: level for level in raidlevels}\n    for n in 0, 1, 5, 6, 10:\n        r[str(n)] = r[n] = r[\"raid\"+str(n)]\n    r[\"stripe\"] = r[\"raid0\"]\n    r[\"mirror\"] = r[\"raid1\"]\n    return r\n\n\nraidlevels_by_value = _raidlevels_by_value()\n\nHUMAN_UNITS = ['B', 'K', 'M', 'G', 'T', 'P']\n\n\ndef humanize_size(size):\n    if size == 0:\n        return \"0B\"\n    p = int(math.floor(math.log(size, 2) / 10))\n    # We want to truncate the non-integral part, not round to nearest.\n    s = \"{:.17f}\".format(size / 2 ** (10 * p))\n    i = s.index('.')\n    s = s[:i + 4]\n    return s + HUMAN_UNITS[int(p)]\n\n\ndef dehumanize_size(size):\n    # convert human 'size' to integer\n    size_in = size\n\n    if not size:\n        raise ValueError(\"input cannot be empty\")\n\n    if not size[-1].isdigit():\n        suffix = size[-1].upper()\n        size = size[:-1]\n    else:\n        suffix = None\n\n    parts = size.split('.')\n    if len(parts) > 2:\n        raise ValueError(_(\"{!r} is not valid input\").format(size_in))\n    elif len(parts) == 2:\n        div = 10 ** len(parts[1])\n        size = parts[0] + parts[1]\n    else:\n        div = 1\n\n    try:\n        num = int(size)\n    except ValueError:\n        raise ValueError(_(\"{!r} is not valid input\").format(size_in))\n\n    if suffix is not None:\n        if suffix not in HUMAN_UNITS:\n            raise ValueError(\n                \"unrecognized suffix {!r} in {!r}\".format(size_in[-1],\n                                                          size_in))\n        mult = 2 ** (10 * HUMAN_UNITS.index(suffix))\n    else:\n        mult = 1\n\n    if num < 0:\n        raise ValueError(\"{!r}: cannot be negative\".format(size_in))\n\n    return num * mult // div\n\n\nDEFAULT_CHUNK = 512\n\n\n# The calculation of how much of a device mdadm uses for raid is more than a\n# touch ridiculous. What follows is a translation of the code at:\n# https://git.kernel.org/pub/scm/utils/mdadm/mdadm.git/tree/super1.c,\n# specifically choose_bm_space and the end of validate_geometry1. Note that\n# that calculations are in terms of 512-byte sectors.\n#\n# We make some assumptions about the defaults mdadm uses but mostly that the\n# default metadata version is 1.2, and other formats use less space.\n#\n# Note that data_offset is computed for the first disk mdadm examines and then\n# used for all devices, so the order matters! (Well, if the size of the\n# devices vary, which is not normal but also not something we prevent).\n#\n# All this is tested against reality in ./scripts/get-raid-sizes.py\ndef calculate_data_offset_bytes(devsize):\n    # Convert to sectors to make it easier to compare this code to mdadm's (we\n    # convert back at the end)\n    devsize >>= 9\n\n    devsize = align_down(devsize, DEFAULT_CHUNK)\n\n    # conversion of choose_bm_space:\n    if devsize < 64*2:\n        bmspace = 0\n    elif devsize - 64*2 >= 200*1024*1024*2:\n        bmspace = 128*2\n    elif devsize - 4*2 > 8*1024*1024*2:\n        bmspace = 64*2\n    else:\n        bmspace = 4*2\n\n    # From the end of validate_geometry1, assuming metadata 1.2.\n    headroom = 128*1024*2\n    while (headroom << 10) > devsize and headroom / 2 >= DEFAULT_CHUNK*2*2:\n        headroom >>= 1\n\n    data_offset = 12*2 + bmspace + headroom\n    log.debug(\n        \"get_raid_size: adjusting for %s sectors of overhead\", data_offset)\n    data_offset = align_up(data_offset, 2*1024)\n\n    # convert back to bytes\n    return data_offset << 9\n\n\ndef raid_device_sort(devices):\n    # Because the device order matters to mdadm, we sort consistently but\n    # arbitrarily when computing the size and when rendering the config (so\n    # curtin passes the devices to mdadm in the order we calculate the size\n    # for)\n    return sorted(devices, key=lambda d: d.id)\n\n\ndef get_raid_size(level, devices):\n    if len(devices) == 0:\n        return 0\n    devices = raid_device_sort(devices)\n    data_offset = calculate_data_offset_bytes(devices[0].size)\n    sizes = [align_down(dev.size - data_offset) for dev in devices]\n    min_size = min(sizes)\n    if min_size <= 0:\n        return 0\n    if level == \"raid0\":\n        return sum(sizes)\n    elif level == \"raid1\":\n        return min_size\n    elif level == \"raid5\":\n        return min_size * (len(devices) - 1)\n    elif level == \"raid6\":\n        return min_size * (len(devices) - 2)\n    elif level == \"raid10\":\n        return min_size * (len(devices) // 2)\n    else:\n        raise ValueError(\"unknown raid level %s\" % level)\n\n\n# These are only defaults but curtin does not let you change/specify\n# them at this time.\nLVM_OVERHEAD = (1 << 20)\nLVM_CHUNK_SIZE = 4 * (1 << 20)\n\n\ndef get_lvm_size(devices, size_overrides={}):\n    r = 0\n    for d in devices:\n        r += align_down(\n            size_overrides.get(d, d.size) - LVM_OVERHEAD,\n            LVM_CHUNK_SIZE)\n    return r\n\n\ndef _conv_size(s):\n    if isinstance(s, str):\n        if '%' in s:\n            return s\n        return int(human2bytes(s))\n    return s\n\n\nclass attributes:\n    # Just a namespace to hang our wrappers around attr.ib() off.\n\n    @staticmethod\n    def idfield(base):\n        i = 0\n\n        def factory():\n            nonlocal i\n            r = \"%s-%s\" % (base, i)\n            i += 1\n            return r\n        return attr.ib(default=attr.Factory(factory))\n\n    @staticmethod\n    def ref(*, backlink=None):\n        metadata = {'ref': True}\n        if backlink:\n            metadata['backlink'] = backlink\n        return attr.ib(metadata=metadata)\n\n    @staticmethod\n    def reflist(*, backlink=None, default=attr.NOTHING):\n        metadata = {'reflist': True}\n        if backlink:\n            metadata['backlink'] = backlink\n        return attr.ib(metadata=metadata, default=default)\n\n    @staticmethod\n    def backlink(*, default=None):\n        return attr.ib(\n            init=False, default=default, metadata={'is_backlink': True})\n\n    @staticmethod\n    def const(value):\n        return attr.ib(default=value)\n\n    @staticmethod\n    def size():\n        return attr.ib(converter=_conv_size)\n\n    @staticmethod\n    def ptable():\n\n        def conv(val):\n            if val == \"dos\":\n                val = \"msdos\"\n            return val\n        return attr.ib(default=None, converter=conv)\n\n\ndef asdict(inst):\n    r = collections.OrderedDict()\n    for field in attr.fields(type(inst)):\n        if field.name.startswith('_'):\n            continue\n        m = getattr(inst, 'serialize_' + field.name, None)\n        if m:\n            r.update(m())\n        else:\n            v = getattr(inst, field.name)\n            if v is not None:\n                if field.metadata.get('ref', False):\n                    r[field.name] = v.id\n                elif field.metadata.get('reflist', False):\n                    r[field.name] = [elem.id for elem in v]\n                else:\n                    r[field.name] = v\n    return r\n\n\n# This code is not going to make much sense unless you have read\n# http://curtin.readthedocs.io/en/latest/topics/storage.html. The\n# Disk, Partition etc classes correspond to entries in curtin's\n# storage config list. They are mostly 'dumb data', all the logic is\n# in the FilesystemModel or FilesystemController classes.\n\n\nclass DeviceAction(enum.Enum):\n    INFO = _(\"Info\")\n    EDIT = _(\"Edit\")\n    REFORMAT = _(\"Reformat\")\n    PARTITION = _(\"Add Partition\")\n    CREATE_LV = _(\"Create Logical Volume\")\n    FORMAT = _(\"Format\")\n    REMOVE = _(\"Remove from RAID/LVM\")\n    DELETE = _(\"Delete\")\n    TOGGLE_BOOT = _(\"Make Boot Device\")\n\n\ndef _generic_can_EDIT(obj):\n    cd = obj.constructed_device()\n    if cd is None:\n        return True\n    return _(\n        \"Cannot edit {selflabel} as it is part of the {cdtype} \"\n        \"{cdname}.\").format(\n            selflabel=obj.label,\n            cdtype=cd.desc(),\n            cdname=cd.label)\n\n\ndef _generic_can_REMOVE(obj):\n    cd = obj.constructed_device()\n    if cd is None:\n        return False\n    if cd.preserve:\n        return _(\"Cannot remove {selflabel} from pre-existing {cdtype} \"\n                 \"{cdlabel}.\").format(\n                    selflabel=obj.label,\n                    cdtype=cd.desc(),\n                    cdlabel=cd.label)\n    if isinstance(cd, Raid):\n        if obj in cd.spare_devices:\n            return True\n        min_devices = raidlevels_by_value[cd.raidlevel].min_devices\n        if len(cd.devices) == min_devices:\n            return _(\n                \"Removing {selflabel} would leave the {cdtype} {cdlabel} with \"\n                \"less than {min_devices} devices.\").format(\n                    selflabel=obj.label,\n                    cdtype=cd.desc(),\n                    cdlabel=cd.label,\n                    min_devices=min_devices)\n    elif isinstance(cd, LVM_VolGroup):\n        if len(cd.devices) == 1:\n            return _(\n                \"Removing {selflabel} would leave the {cdtype} {cdlabel} with \"\n                \"no devices.\").format(\n                    selflabel=obj.label,\n                    cdtype=cd.desc(),\n                    cdlabel=cd.label)\n    return True\n\n\ndef _generic_can_DELETE(obj):\n    cd = obj.constructed_device()\n    if cd is None:\n        return True\n    return _(\n        \"Cannot delete {selflabel} as it is part of the {cdtype} \"\n        \"{cdname}.\").format(\n            selflabel=obj.label,\n            cdtype=cd.desc(),\n            cdname=cd.label)\n\n\n@attr.s(cmp=False)\nclass _Formattable(ABC):\n    # Base class for anything that can be formatted and mounted,\n    # e.g. a disk or a RAID or a partition.\n\n    @property\n    @abstractmethod\n    def label(self):\n        pass\n\n    @property\n    def annotations(self):\n        preserve = getattr(self, 'preserve', None)\n        if preserve is None:\n            return []\n        elif preserve:\n            return [_(\"existing\")]\n        else:\n            return [_(\"new\")]\n\n    # Filesystem\n    _fs = attributes.backlink()\n    # Raid or LVM_VolGroup for now, but one day ZPool, BCache...\n    _constructed_device = attributes.backlink()\n\n    def usage_labels(self):\n        cd = self.constructed_device()\n        if cd is not None:\n            return [\n                _(\"{component_name} of {desc} {name}\").format(\n                    component_name=cd.component_name,\n                    desc=cd.desc(),\n                    name=cd.name),\n                ]\n        fs = self.fs()\n        if fs is not None:\n            if fs.preserve:\n                format_desc = _(\"already formatted as {fstype}\")\n            elif self.original_fstype() is not None:\n                format_desc = _(\"to be reformatted as {fstype}\")\n            else:\n                format_desc = _(\"to be formatted as {fstype}\")\n            r = [format_desc.format(fstype=fs.fstype)]\n            if self._m.is_mounted_filesystem(fs.fstype):\n                m = fs.mount()\n                if m:\n                    r.append(_(\"mounted at {path}\").format(path=m.path))\n                elif getattr(self, 'flag', None) != \"boot\":\n                    r.append(_(\"not mounted\"))\n            elif fs.preserve:\n                if fs.mount() is None:\n                    r.append(_(\"unused\"))\n                else:\n                    r.append(_(\"used\"))\n            return r\n        else:\n            return [_(\"unused\")]\n\n    def _is_entirely_used(self):\n        return self._fs is not None or self._constructed_device is not None\n\n    def fs(self):\n        return self._fs\n\n    def original_fstype(self):\n        for action in self._m._orig_config:\n            if action['type'] == 'format' and action['volume'] == self.id:\n                return action['fstype']\n        for action in self._m._orig_config:\n            if action['id'] == self.id and action.get('flag') == 'swap':\n                return 'swap'\n        return None\n\n    def constructed_device(self, skip_dm_crypt=True):\n        cd = self._constructed_device\n        if cd is None:\n            return None\n        elif cd.type == \"dm_crypt\" and skip_dm_crypt:\n            return cd._constructed_device\n        else:\n            return cd\n\n    @property\n    @abstractmethod\n    def supported_actions(self):\n        pass\n\n    def action_possible(self, action):\n        assert action in self.supported_actions\n        r = getattr(self, \"_can_\" + action.name)\n        if isinstance(r, bool):\n            return r, None\n        elif isinstance(r, str):\n            return False, r\n        else:\n            return r\n\n    @property\n    @abstractmethod\n    def ok_for_raid(self):\n        pass\n\n    @property\n    @abstractmethod\n    def ok_for_lvm_vg(self):\n        pass\n\n\n# Nothing is put in the first and last megabytes of the disk to allow\n# space for the GPT data.\nGPT_OVERHEAD = 2 * (1 << 20)\n\n\n@attr.s(cmp=False)\nclass _Device(_Formattable, ABC):\n    # Anything that can have partitions, e.g. a disk or a RAID.\n\n    @property\n    @abstractmethod\n    def size(self):\n        pass\n\n    # [Partition]\n    _partitions = attributes.backlink(default=attr.Factory(list))\n\n    def dasd(self):\n        return None\n\n    def ptable_for_new_partition(self):\n        if self.ptable is not None:\n            return self.ptable\n        for action in self._m._orig_config:\n            if action['id'] == self.id:\n                if action.get('ptable') == 'vtoc':\n                    return action['ptable']\n        if self.dasd() is not None:\n            return 'vtoc'\n        return 'gpt'\n\n    def partitions(self):\n        return self._partitions\n\n    @property\n    def used(self):\n        if self._is_entirely_used():\n            return self.size\n        r = 0\n        for p in self._partitions:\n            if p.flag == \"extended\":\n                continue\n            r += p.size\n        return r\n\n    @property\n    def empty(self):\n        return self.used == 0\n\n    @property\n    def available_for_partitions(self):\n        return self.size - GPT_OVERHEAD\n\n    @property\n    def free_for_partitions(self):\n        return self.available_for_partitions - self.used\n\n    def available(self):\n        # A _Device is available if:\n        # 1) it is not part of a device like a RAID or LVM or zpool or ...\n        # 2) if it is formatted, it is available if it is formatted with fs\n        #    that needs to be mounted and is not mounted\n        # 3) if it is not formatted, it is available if it has free\n        #    space OR at least one partition is not formatted or is formatted\n        #    with a fs that needs to be mounted and is not mounted\n        if self._constructed_device is not None:\n            return False\n        if self._fs is not None:\n            return self._fs._available()\n        if self.free_for_partitions > 0:\n            if not self._has_preexisting_partition():\n                return True\n        for p in self._partitions:\n            if p.available():\n                return True\n        return False\n\n    def has_unavailable_partition(self):\n        for p in self._partitions:\n            if not p.available():\n                return True\n        return False\n\n    def _has_preexisting_partition(self):\n        for p in self._partitions:\n            if p.preserve:\n                return True\n        else:\n            return False\n\n    @property\n    def _can_DELETE(self):\n        mounted_partitions = 0\n        for p in self._partitions:\n            if p.fs() and p.fs().mount():\n                mounted_partitions += 1\n            elif p.constructed_device():\n                cd = p.constructed_device()\n                return _(\n                    \"Cannot delete {selflabel} as partition {partnum} is part \"\n                    \"of the {cdtype} {cdname}.\").format(\n                        selflabel=self.label,\n                        partnum=p._number,\n                        cdtype=cd.desc(),\n                        cdname=cd.label,\n                        )\n        if mounted_partitions > 1:\n            return _(\n                \"Cannot delete {selflabel} because it has {count} mounted \"\n                \"partitions.\").format(\n                    selflabel=self.label,\n                    count=mounted_partitions)\n        elif mounted_partitions == 1:\n            return _(\n                \"Cannot delete {selflabel} because it has 1 mounted partition.\"\n                ).format(selflabel=self.label)\n        else:\n            return _generic_can_DELETE(self)\n\n\n@fsobj(\"dasd\")\nclass Dasd:\n    device_id = attr.ib()\n    blocksize = attr.ib()\n    disk_layout = attr.ib()\n    label = attr.ib(default=None)\n    mode = attr.ib(default=None)\n    preserve = attr.ib(default=False)\n\n\n@fsobj(\"disk\")\nclass Disk(_Device):\n    ptable = attributes.ptable()\n    serial = attr.ib(default=None)\n    wwn = attr.ib(default=None)\n    multipath = attr.ib(default=None)\n    path = attr.ib(default=None)\n    model = attr.ib(default=None)\n    wipe = attr.ib(default=None)\n    preserve = attr.ib(default=False)\n    name = attr.ib(default=\"\")\n    grub_device = attr.ib(default=False)\n    device_id = attr.ib(default=None)\n\n    _info = attr.ib(default=None)\n\n    def info_for_display(self):\n        bus = self._info.raw.get('ID_BUS', None)\n        major = self._info.raw.get('MAJOR', None)\n        if bus is None and major == '253':\n            bus = 'virtio'\n\n        devpath = self._info.raw.get('DEVPATH', self.path)\n        # XXX probert should be doing this!!\n        rotational = '1'\n        try:\n            dev = os.path.basename(devpath)\n            rfile = '/sys/class/block/{}/queue/rotational'.format(dev)\n            rotational = open(rfile, 'r').read().strip()\n        except (PermissionError, FileNotFoundError, IOError):\n            log.exception('WARNING: Failed to read file {}'.format(rfile))\n            pass\n\n        dinfo = {\n            'bus': bus,\n            'devname': self.path,\n            'devpath': devpath,\n            'model': self.model or 'unknown',\n            'serial': self.serial or 'unknown',\n            'wwn': self.wwn or 'unknown',\n            'multipath': self.multipath or 'unknown',\n            'size': self.size,\n            'humansize': humanize_size(self.size),\n            'vendor': self._info.vendor or 'unknown',\n            'rotational': 'true' if rotational == '1' else 'false',\n        }\n        return dinfo\n\n    @property\n    def size(self):\n        return align_down(self._info.size)\n\n    @property\n    def annotations(self):\n        return []\n\n    def desc(self):\n        if self.multipath:\n            return _(\"multipath device\")\n        return _(\"local disk\")\n\n    @property\n    def label(self):\n        if self.multipath:\n            return self.wwn\n        return self.serial or self.path\n\n    def dasd(self):\n        return self._m._one(type='dasd', device_id=self.device_id)\n\n    def _can_be_boot_disk(self):\n        bl = self._m.bootloader\n        if self._has_preexisting_partition():\n            if bl == Bootloader.BIOS:\n                if self.ptable == \"msdos\":\n                    return True\n                else:\n                    return self._partitions[0].flag == \"bios_grub\"\n            else:\n                flag = {Bootloader.UEFI: \"boot\", Bootloader.PREP: \"prep\"}[bl]\n                for p in self._partitions:\n                    if p.flag == flag:\n                        return True\n                return False\n        else:\n            return True\n\n    @property\n    def supported_actions(self):\n        actions = [\n            DeviceAction.INFO,\n            DeviceAction.REFORMAT,\n            DeviceAction.PARTITION,\n            DeviceAction.FORMAT,\n            DeviceAction.REMOVE,\n            ]\n        if self._m.bootloader != Bootloader.NONE:\n            actions.append(DeviceAction.TOGGLE_BOOT)\n        return actions\n\n    _can_INFO = True\n\n    @property\n    def _can_REFORMAT(self):\n        if len(self._partitions) == 0:\n            return False\n        for p in self._partitions:\n            if p._constructed_device is not None:\n                return False\n        return True\n\n    @property\n    def _can_PARTITION(self):\n        if self._has_preexisting_partition():\n            return False\n        if self.free_for_partitions <= 0:\n            return False\n        if self.ptable == 'vtoc' and len(self._partitions) >= 3:\n            return False\n        return True\n\n    _can_FORMAT = property(\n        lambda self: len(self._partitions) == 0 and\n        self._constructed_device is None)\n    _can_REMOVE = property(_generic_can_REMOVE)\n\n    def _is_boot_device(self):\n        bl = self._m.bootloader\n        if bl == Bootloader.NONE:\n            return False\n        elif bl == Bootloader.BIOS:\n            return self.grub_device\n        elif bl in [Bootloader.PREP, Bootloader.UEFI]:\n            for p in self._partitions:\n                if p.grub_device:\n                    return True\n            return False\n\n    @property\n    def _can_TOGGLE_BOOT(self):\n        if self._is_boot_device():\n            for disk in self._m.all_disks():\n                if disk is not self and disk._is_boot_device():\n                    return True\n            return False\n        elif self._fs is not None or self._constructed_device is not None:\n            return False\n        else:\n            return self._can_be_boot_disk()\n\n    @property\n    def ok_for_raid(self):\n        if self._fs is not None:\n            if self._fs.preserve:\n                return self._fs._mount is None\n            return False\n        if self._constructed_device is not None:\n            return False\n        if len(self._partitions) > 0:\n            return False\n        return True\n\n    ok_for_lvm_vg = ok_for_raid\n\n\n@fsobj(\"partition\")\nclass Partition(_Formattable):\n    device = attributes.ref(backlink=\"_partitions\")  # Disk\n    size = attributes.size()\n\n    wipe = attr.ib(default=None)\n    flag = attr.ib(default=None)\n    number = attr.ib(default=None)\n    preserve = attr.ib(default=False)\n    grub_device = attr.ib(default=False)\n\n    @property\n    def annotations(self):\n        r = super().annotations\n        if self.flag == \"prep\":\n            r.append(\"PReP\")\n            if self.preserve:\n                if self.grub_device:\n                    r.append(_(\"configured\"))\n                else:\n                    r.append(_(\"unconfigured\"))\n        elif self.flag == \"boot\":\n            if self.fs() and self.fs().mount():\n                r.append(_(\"primary ESP\"))\n            elif self.grub_device:\n                r.append(_(\"backup ESP\"))\n            else:\n                r.append(_(\"unused ESP\"))\n        elif self.flag == \"bios_grub\":\n            if self.preserve:\n                if self.device.grub_device:\n                    r.append(_(\"configured\"))\n                else:\n                    r.append(_(\"unconfigured\"))\n            r.append(\"bios_grub\")\n        elif self.flag == \"extended\":\n            r.append(_(\"extended\"))\n        elif self.flag == \"logical\":\n            r.append(_(\"logical\"))\n        return r\n\n    def usage_labels(self):\n        if self.flag == \"prep\" or self.flag == \"bios_grub\":\n            return []\n        return super().usage_labels()\n\n    def desc(self):\n        return _(\"partition of {device}\").format(device=self.device.desc())\n\n    @property\n    def label(self):\n        return _(\"partition {number} of {device}\").format(\n            number=self._number, device=self.device.label)\n\n    @property\n    def short_label(self):\n        return _(\"partition {number}\").format(number=self._number)\n\n    def available(self):\n        if self.flag in ['bios_grub', 'prep'] or self.grub_device:\n            return False\n        if self._constructed_device is not None:\n            return False\n        if self._fs is None:\n            return True\n        return self._fs._available()\n\n    def serialize_number(self):\n        return {'number': self._number}\n\n    @property\n    def _number(self):\n        if self.preserve:\n            return self.number\n        else:\n            return self.device._partitions.index(self) + 1\n\n    supported_actions = [\n        DeviceAction.EDIT,\n        DeviceAction.REMOVE,\n        DeviceAction.DELETE,\n        ]\n\n    _can_EDIT = property(_generic_can_EDIT)\n\n    _can_REMOVE = property(_generic_can_REMOVE)\n\n    @property\n    def _can_DELETE(self):\n        if self.device._has_preexisting_partition():\n            return _(\"Cannot delete a single partition from a device that \"\n                     \"already has partitions.\")\n        if self.flag in ('boot', 'bios_grub', 'prep'):\n            return _(\"Cannot delete required bootloader partition\")\n        return _generic_can_DELETE(self)\n\n    @property\n    def ok_for_raid(self):\n        if self.flag in ('boot', 'bios_grub', 'prep'):\n            return False\n        if self._fs is not None:\n            if self._fs.preserve:\n                return self._fs._mount is None\n            return False\n        if self._constructed_device is not None:\n            return False\n        return True\n\n    ok_for_lvm_vg = ok_for_raid\n\n\n@fsobj(\"raid\")\nclass Raid(_Device):\n    name = attr.ib()\n    raidlevel = attr.ib(converter=lambda x: raidlevels_by_value[x].value)\n    devices = attributes.reflist(backlink=\"_constructed_device\")\n\n    def serialize_devices(self):\n        # Surprisingly, the order of devices passed to mdadm --create\n        # matters (see get_raid_size) so we sort devices here the same\n        # way get_raid_size does.\n        return {'devices': [d.id for d in raid_device_sort(self.devices)]}\n\n    spare_devices = attributes.reflist(\n        backlink=\"_constructed_device\", default=attr.Factory(set))\n\n    preserve = attr.ib(default=False)\n    ptable = attributes.ptable()\n\n    @property\n    def size(self):\n        return get_raid_size(self.raidlevel, self.devices)\n\n    @property\n    def available_for_partitions(self):\n        # For some reason, the overhead on RAID devices seems to be\n        # higher (may be related to alignment of underlying\n        # partitions)\n        return self.size - 2*GPT_OVERHEAD\n\n    @property\n    def label(self):\n        return self.name\n\n    def desc(self):\n        return _(\"software RAID {level}\").format(level=self.raidlevel[4:])\n\n    supported_actions = [\n        DeviceAction.EDIT,\n        DeviceAction.PARTITION,\n        DeviceAction.FORMAT,\n        DeviceAction.REMOVE,\n        DeviceAction.DELETE,\n        DeviceAction.REFORMAT,\n        ]\n\n    @property\n    def _can_EDIT(self):\n        if self.preserve:\n            return _(\"Cannot edit pre-existing RAIDs.\")\n        elif len(self._partitions) > 0:\n            return _(\n                \"Cannot edit {selflabel} because it has partitions.\").format(\n                    selflabel=self.label)\n        else:\n            return _generic_can_EDIT(self)\n\n    _can_PARTITION = Disk._can_PARTITION\n    _can_REFORMAT = Disk._can_REFORMAT\n    _can_FORMAT = property(\n        lambda self: len(self._partitions) == 0 and\n        self._constructed_device is None)\n    _can_REMOVE = property(_generic_can_REMOVE)\n\n    @property\n    def ok_for_raid(self):\n        if self._fs is not None:\n            if self._fs.preserve:\n                return self._fs._mount is None\n            return False\n        if self._constructed_device is not None:\n            return False\n        if len(self._partitions) > 0:\n            return False\n        return True\n\n    ok_for_lvm_vg = ok_for_raid\n\n    # What is a device that makes up this device referred to as?\n    component_name = \"component\"\n\n\n@fsobj(\"lvm_volgroup\")\nclass LVM_VolGroup(_Device):\n    name = attr.ib()\n    devices = attributes.reflist(backlink=\"_constructed_device\")\n\n    preserve = attr.ib(default=False)\n\n    @property\n    def size(self):\n        # Should probably query actual size somehow for an existing VG!\n        return get_lvm_size(self.devices)\n\n    @property\n    def available_for_partitions(self):\n        return self.size\n\n    @property\n    def annotations(self):\n        r = super().annotations\n        member = next(iter(self.devices))\n        if member.type == \"dm_crypt\":\n            r.append(_(\"encrypted\"))\n        return r\n\n    @property\n    def label(self):\n        return self.name\n\n    def desc(self):\n        return _(\"LVM volume group\")\n\n    supported_actions = [\n        DeviceAction.EDIT,\n        DeviceAction.CREATE_LV,\n        DeviceAction.DELETE,\n        ]\n\n    @property\n    def _can_EDIT(self):\n        if self.preserve:\n            return _(\"Cannot edit pre-existing volume groups.\")\n        elif len(self._partitions) > 0:\n            return _(\n                \"Cannot edit {selflabel} because it has logical \"\n                \"volumes.\").format(\n                    selflabel=self.label)\n        else:\n            return _generic_can_EDIT(self)\n\n    _can_CREATE_LV = property(\n        lambda self: not self.preserve and self.free_for_partitions > 0)\n\n    ok_for_raid = False\n    ok_for_lvm_vg = False\n\n    # What is a device that makes up this device referred to as?\n    component_name = \"PV\"\n\n\n@fsobj(\"lvm_partition\")\nclass LVM_LogicalVolume(_Formattable):\n    name = attr.ib()\n    volgroup = attributes.ref(backlink=\"_partitions\")  # LVM_VolGroup\n    size = attributes.size()\n\n    preserve = attr.ib(default=False)\n\n    def serialize_size(self):\n        return {'size': \"{}B\".format(self.size)}\n\n    def available(self):\n        if self._constructed_device is not None:\n            return False\n        if self._fs is None:\n            return True\n        return self._fs._available()\n\n    @property\n    def flag(self):\n        return None  # hack!\n\n    def desc(self):\n        return _(\"LVM logical volume\")\n\n    @property\n    def short_label(self):\n        return self.name\n\n    label = short_label\n\n    supported_actions = [\n        DeviceAction.EDIT,\n        DeviceAction.DELETE,\n        ]\n\n    _can_EDIT = True\n\n    @property\n    def _can_DELETE(self):\n        if self.volgroup._has_preexisting_partition():\n            return _(\"Cannot delete a single logical volume from a volume \"\n                     \"group that already has logical volumes.\")\n        return True\n\n    ok_for_raid = False\n    ok_for_lvm_vg = False\n\n\nLUKS_OVERHEAD = 16*(2**20)\n\n\n@fsobj(\"dm_crypt\")\nclass DM_Crypt:\n    volume = attributes.ref(backlink=\"_constructed_device\")  # _Formattable\n    key = attr.ib(metadata={'redact': True})\n\n    def serialize_key(self):\n        if self.key:\n            f = tempfile.NamedTemporaryFile(\n                prefix='luks-key-', mode='w', delete=False)\n            f.write(self.key)\n            f.close()\n            return {'keyfile': f.name}\n        else:\n            return {}\n\n    dm_name = attr.ib(default=None)\n    preserve = attr.ib(default=False)\n\n    _constructed_device = attributes.backlink()\n\n    def constructed_device(self):\n        return self._constructed_device\n\n    @property\n    def size(self):\n        return self.volume.size - LUKS_OVERHEAD\n\n\n@fsobj(\"format\")\nclass Filesystem:\n    fstype = attr.ib()\n    volume = attributes.ref(backlink=\"_fs\")  # _Formattable\n\n    label = attr.ib(default=None)\n    uuid = attr.ib(default=None)\n    preserve = attr.ib(default=False)\n\n    _mount = attributes.backlink()\n\n    def mount(self):\n        return self._mount\n\n    def _available(self):\n        # False if mounted or if fs does not require a mount, True otherwise.\n        if self._mount is None:\n            if self.preserve:\n                return True\n            else:\n                return FilesystemModel.is_mounted_filesystem(self.fstype)\n        else:\n            return False\n\n\n@fsobj(\"mount\")\nclass Mount:\n    device = attributes.ref(backlink=\"_mount\")  # Filesystem\n    path = attr.ib()\n\n    def can_delete(self):\n        # Can't delete mount of /boot/efi or swap, anything else is fine.\n        if not self.path:\n            # swap mount\n            return False\n        if not isinstance(self.device.volume, Partition):\n            # Can't be /boot/efi if volume is not a partition\n            return True\n        if self.device.volume.flag == \"boot\":\n            # /boot/efi\n            return False\n        return True\n\n\ndef align_up(size, block_size=1 << 20):\n    return (size + block_size - 1) & ~(block_size - 1)\n\n\ndef align_down(size, block_size=1 << 20):\n    return size & ~(block_size - 1)\n\n\nclass Bootloader(enum.Enum):\n    NONE = \"NONE\"  # a system where the bootloader is external, e.g. s390x\n    BIOS = \"BIOS\"  # BIOS, where the bootloader dd-ed to the start of a device\n    UEFI = \"UEFI\"  # UEFI, ESPs and /boot/efi and all that (amd64 and arm64)\n    PREP = \"PREP\"  # ppc64el, which puts grub on a PReP partition\n\n\nclass FilesystemModel(object):\n\n    lower_size_limit = 128 * (1 << 20)\n\n    target = None\n\n    @classmethod\n    def is_mounted_filesystem(self, fstype):\n        if fstype in [None, 'swap']:\n            return False\n        else:\n            return True\n\n    def _probe_bootloader(self):\n        # This will at some point change to return a list so that we can\n        # configure BIOS _and_ UEFI on amd64 systems.\n        if os.path.exists('/sys/firmware/efi'):\n            return Bootloader.UEFI\n        elif platform.machine().startswith(\"ppc64\"):\n            return Bootloader.PREP\n        elif platform.machine() == \"s390x\":\n            return Bootloader.NONE\n        else:\n            return Bootloader.BIOS\n\n    def __init__(self):\n        self.bootloader = self._probe_bootloader()\n        self._probe_data = None\n        self.reset()\n\n    def reset(self):\n        if self._probe_data is not None:\n            self._orig_config = storage_config.extract_storage_config(\n                self._probe_data)[\"storage\"][\"config\"]\n            self._actions = self._actions_from_config(\n                self._orig_config, self._probe_data['blockdev'])\n        else:\n            self._orig_config = []\n            self._actions = []\n        self.swap = None\n        self.grub = None\n\n    def _make_matchers(self, match):\n        matchers = []\n\n        def match_serial(disk):\n            if disk.serial is not None:\n                return fnmatch.fnmatchcase(disk.serial, match['serial'])\n\n        def match_model(disk):\n            if disk.model is not None:\n                return fnmatch.fnmatchcase(disk.model, match['model'])\n\n        def match_path(disk):\n            if disk.path is not None:\n                return fnmatch.fnmatchcase(disk.path, match['path'])\n\n        def match_ssd(disk):\n            is_ssd = disk.info_for_display()['rotational'] == 'false'\n            return is_ssd == match['ssd']\n\n        if 'serial' in match:\n            matchers.append(match_serial)\n        if 'model' in match:\n            matchers.append(match_model)\n        if 'path' in match:\n            matchers.append(match_path)\n        if 'ssd' in match:\n            matchers.append(match_ssd)\n\n        return matchers\n\n    def disk_for_match(self, disks, match):\n        matchers = self._make_matchers(match)\n        candidates = []\n        for candidate in disks:\n            for matcher in matchers:\n                if not matcher(candidate):\n                    break\n            else:\n                candidates.append(candidate)\n        if match.get('size') == 'largest':\n            candidates.sort(key=lambda d: d.size, reverse=True)\n        if candidates:\n            return candidates[0]\n        return None\n\n    def apply_autoinstall_config(self, ai_config):\n        disks = self.all_disks()\n        for action in ai_config:\n            if action['type'] == 'disk':\n                disk = None\n                if 'serial' in action:\n                    disk = self._one(type='disk', serial=action['serial'])\n                elif 'path' in action:\n                    disk = self._one(type='disk', path=action['path'])\n                else:\n                    match = action.pop('match', {})\n                    disk = self.disk_for_match(disks, match)\n                    if disk is None:\n                        action['match'] = match\n                if disk is None:\n                    raise Exception(\"{} matched no disk\".format(action))\n                if disk not in disks:\n                    raise Exception(\n                        \"{} matched {} which was already used\".format(\n                            action, disk))\n                disks.remove(disk)\n                action['path'] = disk.path\n                action['serial'] = disk.serial\n        self._actions = self._actions_from_config(\n            ai_config, self._probe_data['blockdev'], is_autoinstall=True)\n        for p in self._all(type=\"partition\") + self._all(type=\"lvm_partition\"):\n            [parent] = list(dependencies(p))\n            if isinstance(p.size, int):\n                if p.size < 0:\n                    if p is not parent.partitions()[-1]:\n                        raise Exception(\n                            \"{} has negative size but is not final partition \"\n                            \"of {}\".format(p, parent))\n                    p.size = 0\n                    p.size = parent.free_for_partitions\n            elif isinstance(p.size, str):\n                if p.size.endswith(\"%\"):\n                    percentage = int(p.size[:-1])\n                    p.size = align_down(\n                        parent.available_for_partitions*percentage//100)\n                else:\n                    p.size = dehumanize_size(p.size)\n\n    def _actions_from_config(self, config, blockdevs, is_autoinstall=False):\n        \"\"\"Convert curtin storage config into action instances.\n\n        curtin represents storage \"actions\" as defined in\n        https://curtin.readthedocs.io/en/latest/topics/storage.html.  We\n        convert each action (that we know about) into an instance of\n        Disk, Partition, RAID, etc (unknown actions, e.g. bcache, are\n        just ignored).\n\n        We also filter out anything that can be reached from a currently\n        mounted device. The motivation here is only to exclude the media\n        subiquity is mounted from, so this might be a bit excessive but\n        hey it works.\n\n        Perhaps surprisingly the order of the returned actions matters.\n        The devices are presented in the filesystem view in the reverse\n        of the order they appear in _actions, which means that e.g. a\n        RAID appears higher up the list than the disks is is composed\n        of. This is quite important as it makes \"unpeeling\" existing\n        compound structures easy, you just delete the top device until\n        you only have disks left.\n        \"\"\"\n        byid = {}\n        objs = []\n        exclusions = set()\n        seen_multipaths = set()\n        for action in config:\n            if not is_autoinstall and action['type'] == 'mount':\n                if not action['path'].startswith(self.target):\n                    # Completely ignore mounts under /target, they are\n                    # probably leftovers from a previous install\n                    # attempt.\n                    exclusions.add(byid[action['device']])\n                continue\n            c = _type_to_cls.get(action['type'], None)\n            if c is None:\n                # Ignore any action we do not know how to process yet\n                # (e.g. bcache)\n                continue\n            kw = {}\n            for f in attr.fields(c):\n                n = f.name\n                if n not in action:\n                    continue\n                v = action[n]\n                try:\n                    if f.metadata.get('ref', False):\n                        kw[n] = byid[v]\n                    elif f.metadata.get('reflist', False):\n                        kw[n] = [byid[id] for id in v]\n                    else:\n                        kw[n] = v\n                except KeyError:\n                    # If a dependency of the current action has been\n                    # ignored, we need to ignore the current action too\n                    # (e.g. a bcache's filesystem).\n                    continue\n            if kw['type'] == 'disk':\n                path = kw['path']\n                kw['info'] = StorageInfo({path: blockdevs[path]})\n            if not is_autoinstall:\n                kw['preserve'] = True\n            obj = byid[action['id']] = c(m=self, **kw)\n            multipath = kw.get('multipath')\n            if multipath:\n                if multipath in seen_multipaths:\n                    exclusions.add(obj)\n                else:\n                    seen_multipaths.add(multipath)\n            objs.append(obj)\n\n        while True:\n            next_exclusions = exclusions.copy()\n            for e in exclusions:\n                next_exclusions.update(itertools.chain(\n                    dependencies(e), reverse_dependencies(e)))\n            if len(exclusions) == len(next_exclusions):\n                break\n            exclusions = next_exclusions\n\n        log.debug(\"exclusions %s\", {e.id for e in exclusions})\n\n        objs = [o for o in objs if o not in exclusions]\n\n        if not is_autoinstall:\n            for o in objs:\n                if o.type == \"partition\" and o.flag == \"swap\":\n                    if o._fs is None:\n                        objs.append(Filesystem(\n                            m=self, fstype=\"swap\", volume=o, preserve=True))\n\n        return objs\n\n    def _render_actions(self):\n        # The curtin storage config has the constraint that an action must be\n        # preceded by all the things that it depends on.  We handle this by\n        # repeatedly iterating over all actions and checking if we can emit\n        # each action by checking if all of the actions it depends on have been\n        # emitted.  Eventually this will either emit all actions or stop making\n        # progress -- which means there is a cycle in the definitions,\n        # something the UI should have prevented <wink>.\n        r = []\n        emitted_ids = set()\n\n        def emit(obj):\n            if isinstance(obj, Raid):\n                log.debug(\n                    \"FilesystemModel: estimated size of %s %s is %s\",\n                    obj.raidlevel, obj.name, obj.size)\n            r.append(asdict(obj))\n            emitted_ids.add(obj.id)\n\n        def ensure_partitions(dev):\n            for part in dev.partitions():\n                if part.id not in emitted_ids:\n                    if part not in work and part not in next_work:\n                        next_work.append(part)\n\n        def can_emit(obj):\n            if obj.type == \"partition\":\n                ensure_partitions(obj.device)\n                for p in obj.device.partitions():\n                    if p._number < obj._number and p.id not in emitted_ids:\n                        return False\n            for dep in dependencies(obj):\n                if dep.id not in emitted_ids:\n                    if dep not in work and dep not in next_work:\n                        next_work.append(dep)\n                        if dep.type in ['disk', 'raid']:\n                            ensure_partitions(dep)\n                    return False\n            if isinstance(obj, Mount):\n                # Any mount actions for a parent of this one have to be emitted\n                # first.\n                for parent in pathlib.Path(obj.path).parents:\n                    parent = str(parent)\n                    if parent in mountpoints:\n                        if mountpoints[parent] not in emitted_ids:\n                            log.debug(\n                                \"cannot emit action to mount %s until that \"\n                                \"for %s is emitted\", obj.path, parent)\n                            return False\n            return True\n\n        mountpoints = {m.path: m.id for m in self.all_mounts()}\n        log.debug('mountpoints %s', mountpoints)\n\n        work = [\n            a for a in self._actions\n            if not getattr(a, 'preserve', False)\n            ]\n\n        while work:\n            next_work = []\n            for obj in work:\n                if can_emit(obj):\n                    emit(obj)\n                else:\n                    next_work.append(obj)\n            if {a.id for a in next_work} == {a.id for a in work}:\n                msg = [\"rendering block devices made no progress processing:\"]\n                for w in work:\n                    msg.append(\" - \" + str(w))\n                raise Exception(\"\\n\".join(msg))\n            work = next_work\n\n        return r\n\n    def render(self):\n        config = {\n            'storage': {\n                'version': 1,\n                'config': self._render_actions(),\n                },\n            }\n        if self.swap is not None:\n            config['swap'] = self.swap\n        if self.grub is not None:\n            config['grub'] = self.grub\n        return config\n\n    def load_probe_data(self, probe_data):\n        self._probe_data = probe_data\n        self.reset()\n\n    def _matcher(self, type, kw):\n        for a in self._actions:\n            if a.type != type:\n                continue\n            for k, v in kw.items():\n                if getattr(a, k) != v:\n                    break\n            else:\n                yield a\n\n    def _one(self, *, type, **kw):\n        try:\n            return next(self._matcher(type, kw))\n        except StopIteration:\n            return None\n\n    def _all(self, *, type, **kw):\n        return list(self._matcher(type, kw))\n\n    def all_mounts(self):\n        return self._all(type='mount')\n\n    def all_devices(self):\n        # return:\n        #  compound devices, newest first\n        #  disk devices, sorted by label\n        disks = []\n        compounds = []\n        for a in self._actions:\n            if a.type == 'disk':\n                disks.append(a)\n            elif isinstance(a, _Device):\n                compounds.append(a)\n        compounds.reverse()\n        disks.sort(key=lambda x: x.label)\n        return compounds + disks\n\n    def all_disks(self):\n        return sorted(self._all(type='disk'), key=lambda x: x.label)\n\n    def all_raids(self):\n        return self._all(type='raid')\n\n    def all_volgroups(self):\n        return self._all(type='lvm_volgroup')\n\n    def _remove(self, obj):\n        _remove_backlinks(obj)\n        self._actions.remove(obj)\n\n    def add_partition(self, device, size, flag=\"\", wipe=None,\n                      grub_device=None):\n        if size > device.free_for_partitions:\n            raise Exception(\"%s > %s\", size, device.free_for_partitions)\n        real_size = align_up(size)\n        log.debug(\"add_partition: rounded size from %s to %s\", size, real_size)\n        if device._fs is not None:\n            raise Exception(\"%s is already formatted\" % (device.label,))\n        p = Partition(\n            m=self, device=device, size=real_size, flag=flag, wipe=wipe,\n            grub_device=grub_device)\n        if flag in (\"boot\", \"bios_grub\", \"prep\"):\n            device._partitions.insert(0, device._partitions.pop())\n        device.ptable = device.ptable_for_new_partition()\n        dasd = device.dasd()\n        if dasd is not None:\n            dasd.device_layout = 'cdl'\n            dasd.preserve = False\n        self._actions.append(p)\n        return p\n\n    def remove_partition(self, part):\n        if part._fs or part._constructed_device:\n            raise Exception(\"can only remove empty partition\")\n        self._remove(part)\n        if len(part.device._partitions) == 0:\n            part.device.ptable = None\n\n    def add_raid(self, name, raidlevel, devices, spare_devices):\n        r = Raid(\n            m=self,\n            name=name,\n            raidlevel=raidlevel,\n            devices=devices,\n            spare_devices=spare_devices)\n        self._actions.append(r)\n        return r\n\n    def remove_raid(self, raid):\n        if raid._fs or raid._constructed_device or len(raid.partitions()):\n            raise Exception(\"can only remove empty RAID\")\n        self._remove(raid)\n\n    def add_volgroup(self, name, devices):\n        vg = LVM_VolGroup(m=self, name=name, devices=devices)\n        self._actions.append(vg)\n        return vg\n\n    def remove_volgroup(self, vg):\n        if len(vg._partitions):\n            raise Exception(\"can only remove empty VG\")\n        self._remove(vg)\n\n    def add_logical_volume(self, vg, name, size):\n        lv = LVM_LogicalVolume(m=self, volgroup=vg, name=name, size=size)\n        self._actions.append(lv)\n        return lv\n\n    def remove_logical_volume(self, lv):\n        if lv._fs:\n            raise Exception(\"can only remove empty LV\")\n        self._remove(lv)\n\n    def add_dm_crypt(self, volume, key):\n        if not volume.available:\n            raise Exception(\"{} is not available\".format(volume))\n        dm_crypt = DM_Crypt(volume=volume, key=key)\n        self._actions.append(dm_crypt)\n        return dm_crypt\n\n    def remove_dm_crypt(self, dm_crypt):\n        self._remove(dm_crypt)\n\n    def add_filesystem(self, volume, fstype, preserve=False):\n        log.debug(\"adding %s to %s\", fstype, volume)\n        if not volume.available:\n            if not isinstance(volume, Partition):\n                if (volume.flag == 'prep' or (\n                        volume.flag == 'bios_grub' and fstype == 'fat32')):\n                    raise Exception(\"{} is not available\".format(volume))\n        if volume._fs is not None:\n            raise Exception(\"%s is already formatted\")\n        fs = Filesystem(\n            m=self, volume=volume, fstype=fstype, preserve=preserve)\n        self._actions.append(fs)\n        return fs\n\n    def remove_filesystem(self, fs):\n        if fs._mount:\n            raise Exception(\"can only remove unmounted filesystem\")\n        self._remove(fs)\n\n    def add_mount(self, fs, path):\n        if fs._mount is not None:\n            raise Exception(\"%s is already mounted\")\n        m = Mount(m=self, device=fs, path=path)\n        self._actions.append(m)\n        # Adding a swap partition or mounting btrfs at / suppresses\n        # the swapfile.\n        if not self._should_add_swapfile():\n            self.swap = {'swap': 0}\n        return m\n\n    def remove_mount(self, mount):\n        self._remove(mount)\n        # Removing a mount might make it ok to add a swapfile again.\n        if self._should_add_swapfile():\n            self.swap = None\n\n    def needs_bootloader_partition(self):\n        '''true if no disk have a boot partition, and one is needed'''\n        # s390x has no such thing\n        if self.bootloader == Bootloader.NONE:\n            return False\n        elif self.bootloader == Bootloader.BIOS:\n            return self._one(type='disk', grub_device=True) is None\n        elif self.bootloader == Bootloader.UEFI:\n            for esp in self._all(type='partition', grub_device=True):\n                if esp.fs() and esp.fs().mount():\n                    if esp.fs().mount().path == '/boot/efi':\n                        return False\n            return True\n        elif self.bootloader == Bootloader.PREP:\n            return self._one(type='partition', grub_device=True) is None\n        else:\n            raise AssertionError(\n                \"unknown bootloader type {}\".format(self.bootloader))\n\n    def _mount_for_path(self, path):\n        return self._one(type='mount', path=path)\n\n    def is_root_mounted(self):\n        return self._mount_for_path('/') is not None\n\n    def can_install(self):\n        return (self.is_root_mounted()\n                and not self.needs_bootloader_partition())\n\n    def _should_add_swapfile(self):\n        mount = self._mount_for_path('/')\n        if mount is not None and mount.device.fstype == 'btrfs':\n            return False\n        for swap in self._all(type='format', fstype='swap'):\n            if swap.mount():\n                return False\n        return True\n"], "filenames": ["subiquity/models/filesystem.py"], "buggy_code_start_loc": [26], "buggy_code_end_loc": [1180], "fixing_code_start_loc": [27], "fixing_code_end_loc": [1192], "type": "CWE-532", "message": "It was discovered that the Subiquity installer for Ubuntu Server logged the LUKS full disk encryption password if one was entered.", "other": {"cve": {"id": "CVE-2020-11932", "sourceIdentifier": "security@ubuntu.com", "published": "2020-05-13T01:15:12.130", "lastModified": "2020-08-03T18:15:11.710", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "It was discovered that the Subiquity installer for Ubuntu Server logged the LUKS full disk encryption password if one was entered."}, {"lang": "es", "value": "Se detect\u00f3 que el instalador de Subiquity para Ubuntu Server, registraba la contrase\u00f1a completa de cifrado de disco de LUKS si una era ingresada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.3, "baseSeverity": "LOW"}, "exploitabilityScore": 0.8, "impactScore": 1.4}, {"source": "security@ubuntu.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.3, "baseSeverity": "LOW"}, "exploitabilityScore": 0.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}, {"source": "security@ubuntu.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-532"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:canonical:subiquity:*:*:*:*:*:*:*:*", "versionEndExcluding": "20.05.2", "matchCriteriaId": "5285647F-F58C-4842-B180-1A04D602212A"}]}]}], "references": [{"url": "https://aliceandbob.company/the-human-factor-in-an-economy-of-scale/", "source": "security@ubuntu.com"}, {"url": "https://github.com/CanonicalLtd/subiquity/commit/7db70650feaf513d7fb6f1ca07f2d670a0890613", "source": "security@ubuntu.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CanonicalLtd/subiquity/commit/7db70650feaf513d7fb6f1ca07f2d670a0890613"}}