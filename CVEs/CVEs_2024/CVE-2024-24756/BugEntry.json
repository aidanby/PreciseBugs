{"buggy_code": ["var helpers = require(\"../helpers\");\nvar config = require(\"../../config\");\nvar skins = require(\"../skins\");\nvar cache = require(\"../cache\");\nvar path = require(\"path\");\nvar url = require(\"url\");\n\n// handle the appropriate 'default=' response\n// uses either mhf_steve or mhf_alex (based on +userId+) if no +def+ given\n// callback: response object\nfunction handle_default(img_status, userId, size, def, req, err, callback) {\n  def = def || skins.default_skin(userId);\n  var defname = def.toLowerCase();\n  if (defname !== \"steve\" && defname !== \"mhf_steve\" && defname !== \"alex\" && defname !== \"mhf_alex\") {\n    if (helpers.id_valid(def)) {\n      // clean up the old URL to match new image\n      var parsed = req.url;\n      delete parsed.query.default;\n      delete parsed.search;\n      parsed.path_list[1] = def;\n      parsed.pathname = \"/\" + parsed.path_list.join(\"/\");\n      var newUrl = url.format(parsed);\n      callback({\n        status: img_status,\n        redirect: newUrl,\n        err: err,\n      });\n    } else {\n      callback({\n        status: img_status,\n        redirect: def,\n        err: err,\n      });\n    }\n  } else {\n    // handle steve and alex\n    def = defname;\n    if (def.substr(0, 4) !== \"mhf_\") {\n      def = \"mhf_\" + def;\n    }\n    skins.resize_img(path.join(__dirname, \"..\", \"public\", \"images\", def + \".png\"), size, function(resize_err, image) {\n      callback({\n        status: img_status,\n        body: image,\n        type: \"image/png\",\n        hash: def,\n        err: resize_err || err,\n      });\n    });\n  }\n}\n\n// GET avatar request\nmodule.exports = function(req, callback) {\n  var userId = (req.url.path_list[1] || \"\").split(\".\")[0];\n  var size = parseInt(req.url.query.size) || config.avatars.default_size;\n  var def = req.url.query.default;\n  var overlay = Object.prototype.hasOwnProperty.call(req.url.query, \"overlay\") || Object.prototype.hasOwnProperty.call(req.url.query, \"helm\");\n\n  // check for extra paths\n  if (req.url.path_list.length > 2) {\n    callback({\n      status: -2,\n      body: \"Invalid Path\",\n      code: 404,\n    });\n    return;\n  }\n\n  // strip dashes\n  userId = userId.replace(/-/g, \"\");\n\n  // Prevent app from crashing/freezing\n  if (size < config.avatars.min_size || size > config.avatars.max_size) {\n    // \"Unprocessable Entity\", valid request, but semantically erroneous:\n    // https://tools.ietf.org/html/rfc4918#page-78\n    callback({\n      status: -2,\n      body: \"Invalid Size\",\n    });\n    return;\n  } else if (!helpers.id_valid(userId)) {\n    callback({\n      status: -2,\n      body: \"Invalid UUID\",\n    });\n    return;\n  }\n\n  try {\n    helpers.get_avatar(req.id, userId, overlay, size, function(err, status, image, hash) {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          // no such file\n          cache.remove_hash(req.id, userId);\n        }\n      }\n      if (image) {\n        callback({\n          status: status,\n          body: image,\n          type: \"image/png\",\n          err: err,\n          hash: hash,\n        });\n      } else {\n        handle_default(status, userId, size, def, req, err, callback);\n      }\n    });\n  } catch (e) {\n    handle_default(-1, userId, size, def, req, e, callback);\n  }\n};", "var helpers = require(\"../helpers\");\nvar cache = require(\"../cache\");\n\n// GET cape request\nmodule.exports = function(req, callback) {\n  var userId = (req.url.path_list[1] || \"\").split(\".\")[0];\n  var def = req.url.query.default;\n  var rid = req.id;\n\n  // check for extra paths\n  if (req.url.path_list.length > 2) {\n    callback({\n      status: -2,\n      body: \"Invalid Path\",\n      code: 404\n    });\n    return;\n  }\n\n  // strip dashes\n  userId = userId.replace(/-/g, \"\");\n  if (!helpers.id_valid(userId)) {\n    callback({\n      status: -2,\n      body: \"Invalid UUID\"\n    });\n    return;\n  }\n\n  try {\n    helpers.get_cape(rid, userId, function(err, hash, status, image) {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          // no such file\n          cache.remove_hash(rid, userId);\n        }\n      }\n      callback({\n        status: status,\n        body: image,\n        type: image ? \"image/png\" : undefined,\n        redirect: image ? undefined : def,\n        hash: hash,\n        err: err\n      });\n    });\n  } catch(e) {\n    callback({\n      status: -1,\n      err: e\n    });\n  }\n};", "var logging = require(\"../logging\");\nvar helpers = require(\"../helpers\");\nvar renders = require(\"../renders\");\nvar config = require(\"../../config\");\nvar cache = require(\"../cache\");\nvar skins = require(\"../skins\");\nvar path = require(\"path\");\nvar url = require(\"url\");\nvar fs = require(\"fs\");\n\n// handle the appropriate 'default=' response\n// uses either mhf_steve or mhf_alex (based on +userId+) if no +def+ given\n// callback: response object\nfunction handle_default(rid, scale, overlay, body, img_status, userId, size, def, req, err, callback) {\n  def = def || skins.default_skin(userId);\n  var defname = def.toLowerCase();\n  if (defname !== \"steve\" && defname !== \"mhf_steve\" && defname !== \"alex\" && defname !== \"mhf_alex\") {\n    if (helpers.id_valid(def)) {\n      // clean up the old URL to match new image\n      var parsed = req.url;\n      delete parsed.query.default;\n      delete parsed.search;\n      parsed.path_list[2] = def;\n      parsed.pathname = \"/\" + parsed.path_list.join(\"/\");\n      var newUrl = url.format(parsed);\n      callback({\n        status: img_status,\n        redirect: newUrl,\n        err: err\n      });\n    } else {\n      callback({\n        status: img_status,\n        redirect: def,\n        err: err\n      });\n    }\n  } else {\n    // handle steve and alex\n    def = defname;\n    if (def.substr(0, 4) !== \"mhf_\") {\n      def = \"mhf_\" + def;\n    }\n    fs.readFile(path.join(__dirname, \"..\", \"public\", \"images\", def + \"_skin.png\"), function(fs_err, buf) {\n      // we render the default skins, but not custom images\n      renders.draw_model(rid, buf, scale, overlay, body, def === \"mhf_alex\", function(render_err, def_img) {\n        callback({\n          status: img_status,\n          body: def_img,\n          type: \"image/png\",\n          hash: def,\n          err: render_err || fs_err || err\n        });\n      });\n    });\n  }\n}\n\n// GET render request\nmodule.exports = function(req, callback) {\n  var raw_type = req.url.path_list[1] || \"\";\n  var rid = req.id;\n  var body = raw_type === \"body\";\n  var userId = (req.url.path_list[2] || \"\").split(\".\")[0];\n  var def = req.url.query.default;\n  var scale = parseInt(req.url.query.scale) || config.renders.default_scale;\n  var overlay = Object.prototype.hasOwnProperty.call(req.url.query, \"overlay\") || Object.prototype.hasOwnProperty.call(req.url.query, \"helm\");\n\n  // check for extra paths\n  if (req.url.path_list.length > 3) {\n    callback({\n      status: -2,\n      body: \"Invalid Path\",\n      code: 404\n    });\n    return;\n  }\n\n  // validate type\n  if (raw_type !== \"body\" && raw_type !== \"head\") {\n    callback({\n      status: -2,\n      body: \"Invalid Render Type\"\n    });\n    return;\n  }\n\n  // strip dashes\n  userId = userId.replace(/-/g, \"\");\n\n  if (scale < config.renders.min_scale || scale > config.renders.max_scale) {\n    callback({\n      status: -2,\n      body: \"Invalid Scale\"\n    });\n    return;\n  } else if (!helpers.id_valid(userId)) {\n    callback({\n      status: -2,\n      body: \"Invalid UUID\"\n    });\n    return;\n  }\n\n  try {\n    helpers.get_render(rid, userId, scale, overlay, body, function(err, status, hash, image) {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          // no such file\n          cache.remove_hash(rid, userId);\n        }\n      }\n      if (image) {\n        callback({\n          status: status,\n          body: image,\n          type: \"image/png\",\n          hash: hash,\n          err: err\n        });\n      } else {\n        logging.debug(rid, \"image not found, using default.\");\n        handle_default(rid, scale, overlay, body, status, userId, scale, def, req, err, callback);\n      }\n    });\n  } catch(e) {\n    handle_default(rid, scale, overlay, body, -1, userId, scale, def, req, e, callback);\n  }\n};", "var helpers = require(\"../helpers\");\nvar skins = require(\"../skins\");\nvar cache = require(\"../cache\");\nvar path = require(\"path\");\nvar lwip = require(\"@randy.tarampi/lwip\");\nvar url = require(\"url\");\n\n// handle the appropriate 'default=' response\n// uses either mhf_steve or mhf_alex (based on +userId+) if no +def+ given\n// callback: response object\nfunction handle_default(img_status, userId, def, req, err, callback) {\n  def = def || skins.default_skin(userId);\n  var defname = def.toLowerCase();\n  if (defname !== \"steve\" && defname !== \"mhf_steve\" && defname !== \"alex\" && defname !== \"mhf_alex\") {\n    if (helpers.id_valid(def)) {\n      // clean up the old URL to match new image\n      var parsed = req.url;\n      delete parsed.query.default;\n      delete parsed.search;\n      parsed.path_list[1] = def;\n      parsed.pathname = \"/\" + parsed.path_list.join(\"/\");\n      var newUrl = url.format(parsed);\n      callback({\n        status: img_status,\n        redirect: newUrl,\n        err: err\n      });\n    } else {\n      callback({\n        status: img_status,\n        redirect: def,\n        err: err\n      });\n    }\n  } else {\n    // handle steve and alex\n    def = defname;\n    if (def.substr(0, 4) !== \"mhf_\") {\n      def = \"mhf_\" + def;\n    }\n    lwip.open(path.join(__dirname, \"..\", \"public\", \"images\", def + \"_skin.png\"), function(lwip_err, image) {\n      if (image) {\n        image.toBuffer(\"png\", function(buf_err, buffer) {\n          callback({\n            status: img_status,\n            body: buffer,\n            type: \"image/png\",\n            hash: def,\n            err: buf_err || lwip_err || err\n          });\n        });\n      } else {\n        callback({\n          status: -1,\n          err: lwip_err || err\n        });\n      }\n    });\n  }\n}\n\n// GET skin request\nmodule.exports = function(req, callback) {\n  var userId = (req.url.path_list[1] || \"\").split(\".\")[0];\n  var def = req.url.query.default;\n  var rid = req.id;\n\n  // check for extra paths\n  if (req.url.path_list.length > 2) {\n    callback({\n      status: -2,\n      body: \"Invalid Path\",\n      code: 404\n    });\n    return;\n  }\n\n  // strip dashes\n  userId = userId.replace(/-/g, \"\");\n  if (!helpers.id_valid(userId)) {\n    callback({\n      status: -2,\n      body: \"Invalid UUID\"\n    });\n    return;\n  }\n\n  try {\n    helpers.get_skin(rid, userId, function(err, hash, status, image, slim) {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          // no such file\n          cache.remove_hash(req.id, userId);\n        }\n      }\n      if (image) {\n        callback({\n          status: status,\n          body: image,\n          type: \"image/png\",\n          hash: hash,\n          err: err\n        });\n      } else {\n        handle_default(2, userId, def, req, err, callback);\n      }\n    });\n  } catch(e) {\n    handle_default(-1, userId, def, req, e, callback);\n  }\n};", "#!/usr/bin/env node\nvar querystring = require(\"querystring\");\nvar response = require(\"./response\");\nvar helpers = require(\"./helpers.js\");\nvar toobusy = require(\"toobusy-js\");\nvar logging = require(\"./logging\");\nvar config = require(\"../config\");\nvar http = require(\"http\");\nvar mime = require(\"mime\");\nvar path = require(\"path\");\nvar url = require(\"url\");\nvar fs = require(\"fs\");\nvar server = null;\n\nvar routes = {\n  index: require(\"./routes/index\"),\n  avatars: require(\"./routes/avatars\"),\n  skins: require(\"./routes/skins\"),\n  renders: require(\"./routes/renders\"),\n  capes: require(\"./routes/capes\"),\n};\n\n// serves assets from lib/public\nfunction asset_request(req, callback) {\n  var filename = path.join(__dirname, \"public\", req.url.path_list.join(\"/\"));\n  fs.access(filename, function(fs_err) {\n    if (!fs_err) {\n      fs.readFile(filename, function(err, data) {\n        callback({\n          body: data,\n          type: mime.getType(filename),\n          err: err,\n        });\n      });\n    } else {\n      callback({\n        body: \"Not found\",\n        status: -2,\n        code: 404,\n      });\n    }\n  });\n}\n\n// generates a 12 character random string\nfunction request_id() {\n  return Math.random().toString(36).substring(2, 14);\n}\n\n// splits a URL path into an Array\n// the path is resolved and decoded\nfunction path_list(pathname) {\n  // remove double and trailing slashes\n  pathname = pathname.replace(/\\/\\/+/g, \"/\").replace(/(.)\\/$/, \"$1\");\n  var list = pathname.split(\"/\");\n  list.shift();\n  for (var i = 0; i < list.length; i++) {\n    // URL decode\n    list[i] = querystring.unescape(list[i]);\n  }\n  return list;\n}\n\n// handles the +req+ by routing to the request to the appropriate module\nfunction requestHandler(req, res) {\n  req.url = url.parse(req.url, true);\n  req.url.query = req.url.query || {};\n  req.url.path_list = path_list(req.url.pathname);\n\n  req.id = request_id();\n  req.start = Date.now();\n\n  var local_path = req.url.path_list[0];\n  logging.debug(req.id, req.method, req.url.href);\n\n  toobusy.maxLag(200);\n  if (toobusy() && !process.env.TRAVIS) {\n    response(req, res, {\n      status: -1,\n      body: \"Server is over capacity :/\",\n      err: \"Too busy\",\n      code: 503,\n    });\n    return;\n  }\n\n  if (req.method === \"GET\" || req.method === \"HEAD\") {\n    try {\n      switch (local_path) {\n      case \"\":\n        routes.index(req, function(result) {\n          response(req, res, result);\n        });\n        break;\n      case \"avatars\":\n        routes.avatars(req, function(result) {\n          response(req, res, result);\n        });\n        break;\n      case \"skins\":\n        routes.skins(req, function(result) {\n          response(req, res, result);\n        });\n        break;\n      case \"renders\":\n        routes.renders(req, function(result) {\n          response(req, res, result);\n        });\n        break;\n      case \"capes\":\n        routes.capes(req, function(result) {\n          response(req, res, result);\n        });\n        break;\n      default:\n        asset_request(req, function(result) {\n          response(req, res, result);\n        });\n      }\n    } catch(e) {\n      var error = JSON.stringify(req.headers) + \"\\n\" + e.stack;\n      response(req, res, {\n        status: -1,\n        body: config.server.debug_enabled ? error : \"Internal Server Error\",\n        err: error,\n      });\n    }\n  } else {\n    response(req, res, {\n      status: -2,\n      body: \"Method Not Allowed\",\n      code: 405,\n    });\n  }\n}\n\nvar exp = {};\n\n// Start the server\nexp.boot = function(callback) {\n  var port = config.server.port;\n  var bind_ip = config.server.bind;\n  server = http.createServer(requestHandler).listen(port, bind_ip, function() {\n    logging.log(\"Server running on http://\" + bind_ip + \":\" + port + \"/\");\n    if (callback) {\n      callback();\n    }\n  });\n\n  // stop accepting new connections,\n  // wait for established connections to finish (30s max),\n  // then exit\n  process.on(\"SIGTERM\", function() {\n    logging.warn(\"Got SIGTERM, no longer accepting new connections!\");\n\n    setTimeout(function() {\n      logging.error(\"Dropping connections after 30s. Force quit.\");\n      process.exit(1);\n    }, 30000);\n\n    server.close(function() {\n      logging.log(\"All connections closed, shutting down.\");\n      process.exit();\n    });\n  });\n};\n\n// Close the server\nexp.close = function(callback) {\n  helpers.stoplog();\n  server.close(callback);\n};\n\nmodule.exports = exp;\n\nif (require.main === module) {\n  logging.error(\"Please use 'npm start' or 'www.js'\");\n  process.exit(1);\n}", "/* globals describe, it, before, after */\n/* eslint no-loop-func:0 guard-for-in:0 */\n\n// no spam\nvar logging = require(\"../lib/logging\");\nif (process.env.VERBOSE_TEST !== \"true\") {\n  logging.log = logging.debug = logging.warn = logging.error = function() {};\n}\n\nvar networking = require(\"../lib/networking\");\nvar helpers = require(\"../lib/helpers\");\nvar request = require(\"request\");\nvar config = require(\"../config\");\nvar server = require(\"../lib/server\");\nvar assert = require(\"assert\");\nvar skins = require(\"../lib/skins\");\nvar cache = require(\"../lib/cache\");\nvar crc = require(\"crc\").crc32;\nvar fs = require(\"fs\");\n\n// we don't want tests to fail because of slow internet\nconfig.server.http_timeout *= 3;\n\nvar uuids = fs.readFileSync(\"test/uuids.txt\").toString().split(/\\r?\\n/);\n\n// Get a random UUIDto prevent rate limiting\nvar uuid = uuids[Math.round(Math.random() * (uuids.length - 1))];\n\n\n// Let's hope these will never be assigned\nvar steve_ids = [\n  \"fffffff0\" + \"fffffff0\" + \"fffffff0\" + \"fffffff0\",\n  \"fffffff0\" + \"fffffff0\" + \"fffffff1\" + \"fffffff1\",\n  \"fffffff0\" + \"fffffff1\" + \"fffffff0\" + \"fffffff1\",\n  \"fffffff0\" + \"fffffff1\" + \"fffffff1\" + \"fffffff0\",\n  \"fffffff1\" + \"fffffff0\" + \"fffffff0\" + \"fffffff1\",\n  \"fffffff1\" + \"fffffff0\" + \"fffffff1\" + \"fffffff0\",\n  \"fffffff1\" + \"fffffff1\" + \"fffffff0\" + \"fffffff0\",\n  \"fffffff1\" + \"fffffff1\" + \"fffffff1\" + \"fffffff1\",\n];\n// Let's hope these will never be assigned\nvar alex_ids = [\n  \"fffffff0\" + \"fffffff0\" + \"fffffff0\" + \"fffffff1\",\n  \"fffffff0\" + \"fffffff0\" + \"fffffff1\" + \"fffffff0\",\n  \"fffffff0\" + \"fffffff1\" + \"fffffff0\" + \"fffffff0\",\n  \"fffffff0\" + \"fffffff1\" + \"fffffff1\" + \"fffffff1\",\n  \"fffffff1\" + \"fffffff0\" + \"fffffff0\" + \"fffffff0\",\n  \"fffffff1\" + \"fffffff0\" + \"fffffff1\" + \"fffffff1\",\n  \"fffffff1\" + \"fffffff1\" + \"fffffff0\" + \"fffffff1\",\n  \"fffffff1\" + \"fffffff1\" + \"fffffff1\" + \"fffffff0\",\n];\n\n// generates a 12 character random string\nfunction rid() {\n  return Math.random().toString(36).substring(2, 14);\n}\n\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\ndescribe(\"Crafatar\", function() {\n  // we might have to make 2 HTTP requests\n  this.timeout(config.server.http_timeout * 2 + 50);\n\n  before(function(done) {\n    console.log(\"Flushing and waiting for redis ...\");\n    cache.get_redis().flushall(function() {\n      console.log(\"Redis flushed!\");\n      done();\n    });\n  });\n\n  describe(\"UUID/username\", function() {\n    it(\"non-hex uuid is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"g098cb60fa8e427cb299793cbd302c9a\"), false);\n      done();\n    });\n    it(\"empty id is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"\"), false);\n      done();\n    });\n    it(\"lowercase uuid is valid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"0098cb60fa8e427cb299793cbd302c9a\"), true);\n      done();\n    });\n    it(\"uppercase uuid is valid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"1DCEF164FF0A47F2B9A691385C774EE7\"), true);\n      done();\n    });\n    it(\"dashed uuid is not valid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"0098cb60-fa8e-427c-b299-793cbd302c9a\"), false);\n      done();\n    });\n    it(\"username is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"__niceUs3rname__\"), false);\n      done();\n    });\n    it(\"username alex is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"alex\"), false);\n      done();\n    });\n    it(\"username mhf_alex is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"mhf_alex\"), false);\n      done();\n    });\n    it(\"username steve is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"steve\"), false);\n      done();\n    });\n    it(\"username mhf_steve is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"mhf_steve\"), false);\n      done();\n    });\n    it(\">16 length username is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"ThisNameIsTooLong\"), false);\n      done();\n    });\n    it(\"should not exist (uuid)\", function(done) {\n      var number = getRandomInt(0, 9).toString();\n      networking.get_profile(rid(), Array(33).join(number), function(err, profile) {\n        assert.ifError(err);\n        assert.strictEqual(profile, null);\n        done();\n      });\n    });\n  });\n  describe(\"Avatar\", function() {\n    for (var a in alex_ids) {\n      var alexid = alex_ids[a];\n      (function(alex_id) {\n        it(\"UUID \" + alex_id + \" should default to MHF_Alex\", function(done) {\n          assert.strictEqual(skins.default_skin(alex_id), \"mhf_alex\");\n          done();\n        });\n      }(alexid));\n    }\n    for (var s in steve_ids) {\n      var steveid = steve_ids[s];\n      (function(steve_id) {\n        it(\"UUID \" + steve_id + \" should default to MHF_Steve\", function(done) {\n          assert.strictEqual(skins.default_skin(steve_id), \"mhf_steve\");\n          done();\n        });\n      }(steveid));\n    }\n  });\n  describe(\"Errors\", function() {\n    it(\"should time out on uuid info download\", function(done) {\n      var original_timeout = config.server.http_timeout;\n      config.server.http_timeout = 1;\n      networking.get_profile(rid(), \"069a79f444e94726a5befca90e38aaf5\", function(err, profile) {\n        assert.notStrictEqual([\"ETIMEDOUT\", \"ESOCKETTIMEDOUT\"].indexOf(err.code), -1);\n        config.server.http_timeout = original_timeout;\n        done();\n      });\n    });\n    it(\"should time out on skin download\", function(done) {\n      var original_timeout = config.http_timeout;\n      config.server.http_timeout = 1;\n      networking.get_from(rid(), \"http://textures.minecraft.net/texture/477be35554684c28bdeee4cf11c591d3c88afb77e0b98da893fd7bc318c65184\", function(body, res, error) {\n        assert.notStrictEqual([\"ETIMEDOUT\", \"ESOCKETTIMEDOUT\"].indexOf(error.code), -1);\n        config.server.http_timeout = original_timeout;\n        done();\n      });\n    });\n    it(\"should not find the skin\", function(done) {\n      assert.doesNotThrow(function() {\n        networking.get_from(rid(), \"http://textures.minecraft.net/texture/this-does-not-exist\", function(img, response, err) {\n          assert.strictEqual(err, null); // no error here, but it shouldn't throw exceptions\n          done();\n        });\n      });\n    });\n    it(\"should not find the file\", function(done) {\n      skins.open_skin(rid(), \"non/existent/path\", function(err, img) {\n        assert(err);\n        done();\n      });\n    });\n  });\n\n  describe(\"Server\", function() {\n    // throws Exception when default headers are not in res.headers\n    function assert_headers(res) {\n      assert(res.headers[\"content-type\"]);\n      assert(\"\" + res.headers[\"response-time\"]);\n      assert(res.headers[\"x-request-id\"]);\n      assert.equal(res.headers[\"access-control-allow-origin\"], \"*\");\n      assert.equal(res.headers[\"cache-control\"], \"max-age=\" + config.caching.browser);\n    }\n\n    // throws Exception when +url+ is requested with +etag+\n    // and it does not return 304 without a body\n    function assert_cache(url, etag, callback) {\n      request.get(url, {\n        headers: {\n          \"If-None-Match\": etag,\n        },\n      }, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(body, '');\n        assert.equal(res.statusCode, 304);\n        assert_headers(res);\n        callback();\n      });\n    }\n\n    before(function(done) {\n      server.boot(function() {\n        done();\n      });\n    });\n\n    it(\"should return 405 Method Not Allowed for POST\", function(done) {\n      request.post(\"http://localhost:3000\", function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 405);\n        done();\n      });\n    });\n\n    it(\"should return correct HTTP response for home page\", function(done) {\n      var url = \"http://localhost:3000\";\n      request.get(url, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 200);\n        assert_headers(res);\n        assert(res.headers.etag);\n        assert.strictEqual(res.headers[\"content-type\"], \"text/html; charset=utf-8\");\n        assert.strictEqual(res.headers.etag, '\"' + crc(body) + '\"');\n        assert(body);\n\n        assert_cache(url, res.headers.etag, function() {\n          done();\n        });\n      });\n    });\n\n    it(\"should return correct HTTP response for assets\", function(done) {\n      var url = \"http://localhost:3000/stylesheets/style.css\";\n      request.get(url, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 200);\n        assert_headers(res);\n        assert(res.headers.etag);\n        assert.strictEqual(res.headers[\"content-type\"], \"text/css\");\n        assert.strictEqual(res.headers.etag, '\"' + crc(body) + '\"');\n        assert(body);\n\n        assert_cache(url, res.headers.etag, function() {\n          done();\n        });\n      });\n    });\n\n    it(\"should return correct HTTP response for URL encoded URLs\", function(done) {\n      var url = \"http://localhost:3000/%61%76%61%74%61%72%73/%61%65%37%39%35%61%61%38%36%33%32%37%34%30%38%65%39%32%61%62%32%35%63%38%61%35%39%66%33%62%61%31\"; // avatars/ae795aa86327408e92ab25c8a59f3ba1\n      request.get(url, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 200);\n        assert_headers(res);\n        assert(res.headers.etag);\n        assert.strictEqual(res.headers[\"content-type\"], \"image/png\");\n        assert(body);\n        done();\n      });\n    });\n\n    it(\"should not fail on simultaneous requests\", function(done) {\n      var url = \"http://localhost:3000/avatars/696a82ce41f44b51aa31b8709b8686f0\";\n      // 10 requests at once\n      var requests = 10;\n      var finished = 0;\n      function partDone() {\n        finished++;\n        if (requests === finished) {\n          done();\n        }\n      }\n      function req() {\n        request.get(url, function(error, res, body) {\n          assert.ifError(error);\n          assert.strictEqual(res.statusCode, 200);\n          assert_headers(res);\n          assert(res.headers.etag);\n          assert.strictEqual(res.headers[\"content-type\"], \"image/png\");\n          assert(body);\n          partDone();\n        });\n      }\n      // make simultanous requests\n      for (var k = 0; k < requests; k++) {\n        req(k);\n      }\n  });\n\n    var server_tests = {\n      \"avatar with existing uuid\": {\n        url: \"http://localhost:3000/avatars/853c80ef3c3749fdaa49938b674adae6?size=16\",\n        crc32: [4264176600],\n      },\n      \"avatar with existing dashed uuid\": {\n        url: \"http://localhost:3000/avatars/853c80ef-3c37-49fd-aa49938b674adae6?size=16\",\n        crc32: [4264176600],\n      },\n      \"avatar with non-existent uuid\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16\",\n        crc32: [3348154329],\n      },\n      \"avatar with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&default=mhf_alex\",\n        crc32: [73899130],\n      },\n      \"avatar with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"/avatars/853c80ef3c3749fdaa49938b674adae6?size=16\",\n      },\n      \"avatar with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"overlay avatar with existing uuid\": {\n        url: \"http://localhost:3000/avatars/853c80ef3c3749fdaa49938b674adae6?size=16&overlay\",\n        crc32: [575355728],\n      },\n      \"overlay avatar with non-existent uuid\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&overlay\",\n        crc32: [3348154329],\n      },\n      \"overlay avatar with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&overlay&default=mhf_alex\",\n        crc32: [73899130],\n      },\n      \"overlay avatar with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"/avatars/853c80ef3c3749fdaa49938b674adae6?size=16\",\n      },\n      \"overlay avatar with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&overlay&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"cape with existing uuid\": {\n        url: \"http://localhost:3000/capes/853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [985789174],\n      },\n      \"cape with non-existent uuid\": {\n        url: \"http://localhost:3000/capes/00000000000000000000000000000000\",\n        crc32: [0],\n      },\n      \"cape with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/capes/00000000000000000000000000000000?default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"skin with existing uuid\": {\n        url: \"http://localhost:3000/skins/853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [1759176487],\n      },\n      \"skin with non-existent uuid\": {\n        url: \"http://localhost:3000/skins/00000000000000000000000000000000\",\n        crc32: [1853029228],\n      },\n      \"skin with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/skins/00000000000000000000000000000000?default=mhf_alex\",\n        crc32: [427506205],\n      },\n      \"skin with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/skins/00000000000000000000000000000000?size=16&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"/skins/853c80ef3c3749fdaa49938b674adae6?size=16\",\n      },\n      \"skin with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/skins/00000000000000000000000000000000?default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"head render with existing uuid\": {\n        url: \"http://localhost:3000/renders/head/853c80ef3c3749fdaa49938b674adae6?scale=2\",\n        crc32: [1168786201],\n      },\n      \"head render with non-existent uuid\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2\",\n        crc32: [3800926063],\n      },\n      \"head render with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&default=mhf_alex\",\n        crc32: [4027858557],\n      },\n      \"head render with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"/renders/head/853c80ef3c3749fdaa49938b674adae6?scale=2\",\n      },\n      \"head render with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"overlay head render with existing uuid\": {\n        url: \"http://localhost:3000/renders/head/853c80ef3c3749fdaa49938b674adae6?scale=2&overlay\",\n        crc32: [2880579826],\n      },\n      \"overlay head render with non-existent uuid\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&overlay\",\n        crc32: [3800926063],\n      },\n      \"overlay head render with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&overlay&default=mhf_alex\",\n        crc32: [4027858557],\n      },\n      \"overlay head with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&overlay&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"/renders/head/853c80ef3c3749fdaa49938b674adae6?scale=2&overlay=\",\n      },\n      \"overlay head render with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&overlay&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"body render with existing uuid\": {\n        url: \"http://localhost:3000/renders/body/853c80ef3c3749fdaa49938b674adae6?scale=2\",\n        crc32: [1144887125],\n      },\n      \"body render with non-existent uuid\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2\",\n        crc32: [996962526],\n      },\n      \"body render with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&default=mhf_alex\",\n        crc32: [4280894468],\n      },\n      \"body render with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"/renders/body/853c80ef3c3749fdaa49938b674adae6?scale=2\",\n      },\n      \"body render with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"overlay body render with existing uuid\": {\n        url: \"http://localhost:3000/renders/body/853c80ef3c3749fdaa49938b674adae6?scale=2&overlay\",\n        crc32: [1107696668],\n      },\n      \"overlay body render with non-existent uuid\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&overlay\",\n        crc32: [996962526],\n      },\n      \"overlay body render with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&overlay&default=mhf_alex\",\n        crc32: [4280894468],\n      },\n      \"overlay body render with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&overlay&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n    };\n\n    for (var description in server_tests) {\n      var loc = server_tests[description];\n      (function(location) {\n        it(\"should return correct HTTP response for \" + description, function(done) {\n          request.get(location.url, {followRedirect: false, encoding: null}, function(error, res, body) {\n            assert.ifError(error);\n            assert_headers(res);\n            assert(res.headers[\"x-storage-type\"]);\n            var hash = crc(body);\n            var matches = false;\n            for (var c = 0; c < location.crc32.length; c++) {\n              if (location.crc32[c] === hash) {\n                matches = true;\n                break;\n              }\n            }\n            try {\n              assert(matches);\n            } catch(e) {\n              throw new Error(hash + \" != \" + location.crc32 + \" | \" + body.toString(\"base64\"));\n            }\n            assert.strictEqual(res.headers.location, location.redirect);\n            if (location.crc32[0] === 0) {\n              assert.strictEqual(res.statusCode, location.redirect ? 307 : 404);\n              assert.ifError(res.headers.etag); // etag must not be present on non-200\n              assert.strictEqual(res.headers[\"content-type\"], \"text/plain\");\n              done();\n            } else {\n              assert.strictEqual(res.headers[\"content-type\"], \"image/png\");\n              assert.strictEqual(res.statusCode, 200);\n              assert(res.headers.etag);\n              assert.strictEqual(res.headers.etag, '\"' + hash + '\"');\n              assert_cache(location.url, res.headers.etag, function() {\n                done();\n              });\n            }\n          });\n        });\n      }(loc));\n    }\n\n    it(\"should return 304 on server error\", function(done) {\n      var original_debug = config.server.debug_enabled;\n      var original_timeout = config.server.http_timeout;\n      config.server.debug_enabled = false;\n      config.server.http_timeout = 1;\n      request.get({url: \"http://localhost:3000/avatars/0000000000000000000000000000000f\", headers: {\"If-None-Match\": '\"some-etag\"'}}, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(body, '');\n        assert.strictEqual(res.statusCode, 304);\n        config.server.debug_enabled = original_debug;\n        config.server.http_timeout = original_timeout;\n        done();\n      });\n    });\n\n    it(\"should return a 422 (invalid size)\", function(done) {\n      var size = config.avatars.max_size + 1;\n      request.get(\"http://localhost:3000/avatars/2d5aa9cdaeb049189930461fc9b91cc5?size=\" + size, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 422);\n        done();\n      });\n    });\n\n    it(\"should return a 422 (invalid scale)\", function(done) {\n      var scale = config.renders.max_scale + 1;\n      request.get(\"http://localhost:3000/renders/head/2d5aa9cdaeb049189930461fc9b91cc5?scale=\" + scale, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 422);\n        done();\n      });\n    });\n\n    it(\"should return a 422 (invalid render type)\", function(done) {\n      request.get(\"http://localhost:3000/renders/invalid/2d5aa9cdaeb049189930461fc9b91cc5\", function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 422);\n        done();\n      });\n    });\n\n    // testing all paths for Invalid UUID\n    var locations = [\"avatars\", \"skins\", \"capes\", \"renders/body\", \"renders/head\"];\n    for (var l in locations) {\n      loc = locations[l];\n      (function(location) {\n        it(\"should return a 422 (invalid uuid \" + location + \")\", function(done) {\n          request.get(\"http://localhost:3000/\" + location + \"/thisisaninvaliduuid\", function(error, res, body) {\n            assert.ifError(error);\n            assert.strictEqual(res.statusCode, 422);\n            done();\n          });\n        });\n\n        it(\"should return a 404 (invalid path \" + location + \")\", function(done) {\n          request.get(\"http://localhost:3000/\" + location + \"/853c80ef3c3749fdaa49938b674adae6/invalid\", function(error, res, body) {\n            assert.ifError(error);\n            assert.strictEqual(res.statusCode, 404);\n            done();\n          });\n        });\n      }(loc));\n    }\n  });\n\n  // we have to make sure that we test both a 32x64 and 64x64 skin\n  describe(\"Networking: Render\", function() {\n    it(\"should not fail (uuid, 32x64 skin)\", function(done) {\n      helpers.get_render(rid(), \"af74a02d19cb445bb07f6866a861f783\", 6, true, true, function(err, hash, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n    it(\"should not fail (uuid, 64x64 skin)\", function(done) {\n      helpers.get_render(rid(), \"2d5aa9cdaeb049189930461fc9b91cc5\", 6, true, true, function(err, hash, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n  });\n\n  describe(\"Networking: Cape\", function() {\n    it(\"should not fail (guaranteed cape)\", function(done) {\n      helpers.get_cape(rid(), \"61699b2ed3274a019f1e0ea8c3f06bc6\", function(err, hash, status, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n    it(\"should already exist\", function(done) {\n      before(function() {\n        cache.get_redis().flushall();\n      });\n      helpers.get_cape(rid(), \"61699b2ed3274a019f1e0ea8c3f06bc6\", function(err, hash, status, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n    it(\"should not be found\", function(done) {\n      helpers.get_cape(rid(), \"2d5aa9cdaeb049189930461fc9b91cc5\", function(err, hash, status, img) {\n        assert.ifError(err);\n        assert.strictEqual(img, null);\n        done();\n      });\n    });\n  });\n\n  describe(\"Networking: Skin\", function() {\n    it(\"should not fail\", function(done) {\n      helpers.get_cape(rid(), \"2d5aa9cdaeb049189930461fc9b91cc5\", function(err, hash, status, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n    it(\"should already exist\", function(done) {\n      before(function() {\n        cache.get_redis().flushall();\n      });\n      helpers.get_cape(rid(), \"2d5aa9cdaeb049189930461fc9b91cc5\", function(err, hash, status, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n  });\n\n\n\n  describe(\"Networking: Avatar\", function() {\n    before(function() {\n      cache.get_redis().flushall();\n    });\n    it(\"should be downloaded\", function(done) {\n      helpers.get_avatar(rid(), uuid, false, 160, function(err, status, image) {\n        assert.ifError(err);\n        assert.strictEqual(status, 2);\n        done();\n      });\n    });\n    it(\"should be cached\", function(done) {\n      helpers.get_avatar(rid(), uuid, false, 160, function(err, status, image) {\n        assert.ifError(err);\n        assert.strictEqual(status === 0 || status === 1, true);\n        done();\n      });\n    });\n  });\n\n  describe(\"Networking: Skin\", function() {\n    it(\"should not fail (uuid)\", function(done) {\n      helpers.get_skin(rid(), uuid, function(err, hash, status, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n  });\n\n  describe(\"Networking: Render\", function() {\n    it(\"should not fail (full body)\", function(done) {\n      helpers.get_render(rid(), uuid, 6, true, true, function(err, hash, img) {\n        assert.ifError(err);\n        done();\n      });\n    });\n    it(\"should not fail (only head)\", function(done) {\n      helpers.get_render(rid(), uuid, 6, true, false, function(err, hash, img) {\n        assert.ifError(err);\n        done();\n      });\n    });\n  });\n\n  describe(\"Networking: Cape\", function() {\n    it(\"should not fail (possible cape)\", function(done) {\n      helpers.get_cape(rid(), uuid, function(err, hash, status, img) {\n        assert.ifError(err);\n        done();\n      });\n    });\n  });\n\n\n  describe(\"Errors\", function() {\n      before(function() {\n      cache.get_redis().flushall();\n    });\n\n    // Mojang has changed its rate limiting, so we no longer expect to hit the rate limit\n    // it(\"uuid SHOULD be rate limited\", function(done) {\n    //   networking.get_profile(rid(), uuid, function() {\n    //     networking.get_profile(rid(), uuid, function(err, profile) {\n    //       assert.strictEqual(err.toString(), \"HTTP: 429\");\n    //       assert.strictEqual(profile, null);\n    //       done();\n    //     });\n    //   });\n    // });\n\n    it(\"CloudFront rate limit is handled\", function(done) {\n      var original_rate_limit = config.server.sessions_rate_limit;\n      config.server.sessions_rate_limit = 1;\n      networking.get_profile(rid(), uuid, function() {\n        networking.get_profile(rid(), uuid, function(err, profile) {\n          assert.strictEqual(err.code, \"RATELIMIT\");\n          config.server.sessions_rate_limit = original_rate_limit;\n          done();\n        });\n      });\n    });\n  });\n\n  after(function(done) {\n    server.close(function() {\n      cache.get_redis().quit();\n      done();\n    });\n  });\n});"], "fixing_code": ["var helpers = require(\"../helpers\");\nvar config = require(\"../../config\");\nvar skins = require(\"../skins\");\nvar cache = require(\"../cache\");\nvar path = require(\"path\");\nvar url = require(\"url\");\n\n// handle the appropriate 'default=' response\n// uses either mhf_steve or mhf_alex (based on +userId+) if no +def+ given\n// callback: response object\nfunction handle_default(img_status, userId, size, def, req, err, callback) {\n  def = def || skins.default_skin(userId);\n  var defname = def.toLowerCase();\n  if (defname !== \"steve\" && defname !== \"mhf_steve\" && defname !== \"alex\" && defname !== \"mhf_alex\") {\n    if (helpers.id_valid(def)) {\n      // clean up the old URL to match new image\n      req.url.searchParams.delete('default');\n      req.url.path_list[1] = def;\n      req.url.pathname = req.url.path_list.join('/');\n      var newUrl = req.url.toString();\n      callback({\n        status: img_status,\n        redirect: newUrl,\n        err: err,\n      });\n    } else {\n      callback({\n        status: img_status,\n        redirect: def,\n        err: err,\n      });\n    }\n  } else {\n    // handle steve and alex\n    def = defname;\n    if (def.substr(0, 4) !== \"mhf_\") {\n      def = \"mhf_\" + def;\n    }\n    skins.resize_img(path.join(__dirname, \"..\", \"public\", \"images\", def + \".png\"), size, function(resize_err, image) {\n      callback({\n        status: img_status,\n        body: image,\n        type: \"image/png\",\n        hash: def,\n        err: resize_err || err,\n      });\n    });\n  }\n}\n\n// GET avatar request\nmodule.exports = function(req, callback) {\n  var userId = (req.url.path_list[1] || \"\").split(\".\")[0];\n  var size = parseInt(req.url.searchParams.get(\"size\")) || config.avatars.default_size;\n  var def = req.url.searchParams.get(\"default\");\n  var overlay = req.url.searchParams.has(\"overlay\") || req.url.searchParams.has(\"helm\");\n\n  // check for extra paths\n  if (req.url.path_list.length > 2) {\n    callback({\n      status: -2,\n      body: \"Invalid Path\",\n      code: 404,\n    });\n    return;\n  }\n\n  // strip dashes\n  userId = userId.replace(/-/g, \"\");\n\n  // Prevent app from crashing/freezing\n  if (size < config.avatars.min_size || size > config.avatars.max_size) {\n    // \"Unprocessable Entity\", valid request, but semantically erroneous:\n    // https://tools.ietf.org/html/rfc4918#page-78\n    callback({\n      status: -2,\n      body: \"Invalid Size\",\n    });\n    return;\n  } else if (!helpers.id_valid(userId)) {\n    callback({\n      status: -2,\n      body: \"Invalid UUID\",\n    });\n    return;\n  }\n\n  try {\n    helpers.get_avatar(req.id, userId, overlay, size, function(err, status, image, hash) {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          // no such file\n          cache.remove_hash(req.id, userId);\n        }\n      }\n      if (image) {\n        callback({\n          status: status,\n          body: image,\n          type: \"image/png\",\n          err: err,\n          hash: hash,\n        });\n      } else {\n        handle_default(status, userId, size, def, req, err, callback);\n      }\n    });\n  } catch (e) {\n    handle_default(-1, userId, size, def, req, e, callback);\n  }\n};", "var helpers = require(\"../helpers\");\nvar cache = require(\"../cache\");\n\n// GET cape request\nmodule.exports = function(req, callback) {\n  var userId = (req.url.path_list[1] || \"\").split(\".\")[0];\n  var def = req.url.searchParams.get('default');\n  var rid = req.id;\n\n  // check for extra paths\n  if (req.url.path_list.length > 2) {\n    callback({\n      status: -2,\n      body: \"Invalid Path\",\n      code: 404\n    });\n    return;\n  }\n\n  // strip dashes\n  userId = userId.replace(/-/g, \"\");\n  if (!helpers.id_valid(userId)) {\n    callback({\n      status: -2,\n      body: \"Invalid UUID\"\n    });\n    return;\n  }\n\n  try {\n    helpers.get_cape(rid, userId, function(err, hash, status, image) {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          // no such file\n          cache.remove_hash(rid, userId);\n        }\n      }\n      callback({\n        status: status,\n        body: image,\n        type: image ? \"image/png\" : undefined,\n        redirect: image ? undefined : def,\n        hash: hash,\n        err: err\n      });\n    });\n  } catch(e) {\n    callback({\n      status: -1,\n      err: e\n    });\n  }\n};", "var logging = require(\"../logging\");\nvar helpers = require(\"../helpers\");\nvar renders = require(\"../renders\");\nvar config = require(\"../../config\");\nvar cache = require(\"../cache\");\nvar skins = require(\"../skins\");\nvar path = require(\"path\");\nvar url = require(\"url\");\nvar fs = require(\"fs\");\n\n// handle the appropriate 'default=' response\n// uses either mhf_steve or mhf_alex (based on +userId+) if no +def+ given\n// callback: response object\nfunction handle_default(rid, scale, overlay, body, img_status, userId, size, def, req, err, callback) {\n  def = def || skins.default_skin(userId);\n  var defname = def.toLowerCase();\n  if (defname !== \"steve\" && defname !== \"mhf_steve\" && defname !== \"alex\" && defname !== \"mhf_alex\") {\n    if (helpers.id_valid(def)) {\n      // clean up the old URL to match new image\n      req.url.searchParams.delete('default');\n      req.url.path_list[2] = def;\n      req.url.pathname = req.url.path_list.join('/');\n      var newUrl = req.url.toString();\n      callback({\n        status: img_status,\n        redirect: newUrl,\n        err: err\n      });\n    } else {\n      callback({\n        status: img_status,\n        redirect: def,\n        err: err\n      });\n    }\n  } else {\n    // handle steve and alex\n    def = defname;\n    if (def.substr(0, 4) !== \"mhf_\") {\n      def = \"mhf_\" + def;\n    }\n    fs.readFile(path.join(__dirname, \"..\", \"public\", \"images\", def + \"_skin.png\"), function(fs_err, buf) {\n      // we render the default skins, but not custom images\n      renders.draw_model(rid, buf, scale, overlay, body, def === \"mhf_alex\", function(render_err, def_img) {\n        callback({\n          status: img_status,\n          body: def_img,\n          type: \"image/png\",\n          hash: def,\n          err: render_err || fs_err || err\n        });\n      });\n    });\n  }\n}\n\n// GET render request\nmodule.exports = function(req, callback) {\n  var raw_type = req.url.path_list[1] || \"\";\n  var rid = req.id;\n  var body = raw_type === \"body\";\n  var userId = (req.url.path_list[2] || \"\").split(\".\")[0];\n  var def = req.url.searchParams.get(\"default\");\n  var scale = parseInt(req.url.searchParams.get(\"scale\")) || config.renders.default_scale;\n  var overlay = req.url.searchParams.has(\"overlay\") || req.url.searchParams.has(\"helm\");\n\n  // check for extra paths\n  if (req.url.path_list.length > 3) {\n    callback({\n      status: -2,\n      body: \"Invalid Path\",\n      code: 404\n    });\n    return;\n  }\n\n  // validate type\n  if (raw_type !== \"body\" && raw_type !== \"head\") {\n    callback({\n      status: -2,\n      body: \"Invalid Render Type\"\n    });\n    return;\n  }\n\n  // strip dashes\n  userId = userId.replace(/-/g, \"\");\n\n  if (scale < config.renders.min_scale || scale > config.renders.max_scale) {\n    callback({\n      status: -2,\n      body: \"Invalid Scale\"\n    });\n    return;\n  } else if (!helpers.id_valid(userId)) {\n    callback({\n      status: -2,\n      body: \"Invalid UUID\"\n    });\n    return;\n  }\n\n  try {\n    helpers.get_render(rid, userId, scale, overlay, body, function(err, status, hash, image) {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          // no such file\n          cache.remove_hash(rid, userId);\n        }\n      }\n      if (image) {\n        callback({\n          status: status,\n          body: image,\n          type: \"image/png\",\n          hash: hash,\n          err: err\n        });\n      } else {\n        logging.debug(rid, \"image not found, using default.\");\n        handle_default(rid, scale, overlay, body, status, userId, scale, def, req, err, callback);\n      }\n    });\n  } catch(e) {\n    handle_default(rid, scale, overlay, body, -1, userId, scale, def, req, e, callback);\n  }\n};", "var helpers = require(\"../helpers\");\nvar skins = require(\"../skins\");\nvar cache = require(\"../cache\");\nvar path = require(\"path\");\nvar lwip = require(\"@randy.tarampi/lwip\");\nvar url = require(\"url\");\n\n// handle the appropriate 'default=' response\n// uses either mhf_steve or mhf_alex (based on +userId+) if no +def+ given\n// callback: response object\nfunction handle_default(img_status, userId, def, req, err, callback) {\n  def = def || skins.default_skin(userId);\n  var defname = def.toLowerCase();\n  if (defname !== \"steve\" && defname !== \"mhf_steve\" && defname !== \"alex\" && defname !== \"mhf_alex\") {\n    if (helpers.id_valid(def)) {\n      // clean up the old URL to match new image\n      req.url.searchParams.delete('default');\n      req.url.path_list[1] = def;\n      req.url.pathname = req.url.path_list.join('/');\n      var newUrl = req.url.toString();\n      callback({\n        status: img_status,\n        redirect: newUrl,\n        err: err\n      });\n    } else {\n      callback({\n        status: img_status,\n        redirect: def,\n        err: err\n      });\n    }\n  } else {\n    // handle steve and alex\n    def = defname;\n    if (def.substr(0, 4) !== \"mhf_\") {\n      def = \"mhf_\" + def;\n    }\n    lwip.open(path.join(__dirname, \"..\", \"public\", \"images\", def + \"_skin.png\"), function(lwip_err, image) {\n      if (image) {\n        image.toBuffer(\"png\", function(buf_err, buffer) {\n          callback({\n            status: img_status,\n            body: buffer,\n            type: \"image/png\",\n            hash: def,\n            err: buf_err || lwip_err || err\n          });\n        });\n      } else {\n        callback({\n          status: -1,\n          err: lwip_err || err\n        });\n      }\n    });\n  }\n}\n\n// GET skin request\nmodule.exports = function(req, callback) {\n  var userId = (req.url.path_list[1] || \"\").split(\".\")[0];\n  var def = req.url.searchParams.get(\"default\");\n  var rid = req.id;\n\n  // check for extra paths\n  if (req.url.path_list.length > 2) {\n    callback({\n      status: -2,\n      body: \"Invalid Path\",\n      code: 404\n    });\n    return;\n  }\n\n  // strip dashes\n  userId = userId.replace(/-/g, \"\");\n  if (!helpers.id_valid(userId)) {\n    callback({\n      status: -2,\n      body: \"Invalid UUID\"\n    });\n    return;\n  }\n\n  try {\n    helpers.get_skin(rid, userId, function(err, hash, status, image, slim) {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          // no such file\n          cache.remove_hash(req.id, userId);\n        }\n      }\n      if (image) {\n        callback({\n          status: status,\n          body: image,\n          type: \"image/png\",\n          hash: hash,\n          err: err\n        });\n      } else {\n        handle_default(2, userId, def, req, err, callback);\n      }\n    });\n  } catch(e) {\n    handle_default(-1, userId, def, req, e, callback);\n  }\n};", "#!/usr/bin/env node\nvar querystring = require(\"querystring\");\nvar response = require(\"./response\");\nvar helpers = require(\"./helpers.js\");\nvar toobusy = require(\"toobusy-js\");\nvar logging = require(\"./logging\");\nvar config = require(\"../config\");\nvar http = require(\"http\");\nvar mime = require(\"mime\");\nvar path = require(\"path\");\nvar url = require(\"url\");\nvar fs = require(\"fs\");\nvar server = null;\n\nvar routes = {\n  index: require(\"./routes/index\"),\n  avatars: require(\"./routes/avatars\"),\n  skins: require(\"./routes/skins\"),\n  renders: require(\"./routes/renders\"),\n  capes: require(\"./routes/capes\"),\n};\n\n// serves assets from lib/public\nfunction asset_request(req, callback) {\n  const filename = path.join(__dirname, \"public\", ...req.url.path_list);\n  const relative = path.relative(path.join(__dirname, \"public\"), filename);\n  if (relative && !relative.startsWith('..') && !path.isAbsolute(relative)) {\n    fs.access(filename, function(fs_err) {\n      if (!fs_err) {\n        fs.readFile(filename, function(err, data) {\n          callback({\n            body: data,\n            type: mime.getType(filename),\n            err: err,\n          });\n        });\n      } else {\n        callback({\n          body: \"Not found\",\n          status: -2,\n          code: 404,\n        });\n      }\n    });\n  } else {\n    callback({\n      body: \"Forbidden\",\n      status: -2,\n      code: 403,\n    });\n  }\n}\n\n// generates a 12 character random string\nfunction request_id() {\n  return Math.random().toString(36).substring(2, 14);\n}\n\n// splits decoded URL path into an Array\nfunction path_list(pathname) {\n  var list = pathname.split(\"/\");\n  list.shift();\n  return list;\n}\n\n// handles the +req+ by routing to the request to the appropriate module\nfunction requestHandler(req, res) {\n  req.url = new URL(decodeURI(req.url), 'http://' + req.headers.host);\n  req.url.pathname = path.resolve('/', req.url.pathname);\n  req.url.path_list = path_list(req.url.pathname);\n  req.id = request_id();\n  req.start = Date.now();\n\n  var local_path = req.url.path_list[0];\n  logging.debug(req.id, req.method, req.url.href);\n\n  toobusy.maxLag(200);\n  if (toobusy() && !process.env.TRAVIS) {\n    response(req, res, {\n      status: -1,\n      body: \"Server is over capacity :/\",\n      err: \"Too busy\",\n      code: 503,\n    });\n    return;\n  }\n\n  if (req.method === \"GET\" || req.method === \"HEAD\") {\n    try {\n      switch (local_path) {\n      case \"\":\n        routes.index(req, function(result) {\n          response(req, res, result);\n        });\n        break;\n      case \"avatars\":\n        routes.avatars(req, function(result) {\n          response(req, res, result);\n        });\n        break;\n      case \"skins\":\n        routes.skins(req, function(result) {\n          response(req, res, result);\n        });\n        break;\n      case \"renders\":\n        routes.renders(req, function(result) {\n          response(req, res, result);\n        });\n        break;\n      case \"capes\":\n        routes.capes(req, function(result) {\n          response(req, res, result);\n        });\n        break;\n      default:\n        asset_request(req, function(result) {\n          response(req, res, result);\n        });\n      }\n    } catch(e) {\n      var error = JSON.stringify(req.headers) + \"\\n\" + e.stack;\n      response(req, res, {\n        status: -1,\n        body: config.server.debug_enabled ? error : \"Internal Server Error\",\n        err: error,\n      });\n    }\n  } else {\n    response(req, res, {\n      status: -2,\n      body: \"Method Not Allowed\",\n      code: 405,\n    });\n  }\n}\n\nvar exp = {};\n\n// Start the server\nexp.boot = function(callback) {\n  var port = config.server.port;\n  var bind_ip = config.server.bind;\n  server = http.createServer(requestHandler).listen(port, bind_ip, function() {\n    logging.log(\"Server running on http://\" + bind_ip + \":\" + port + \"/\");\n    if (callback) {\n      callback();\n    }\n  });\n\n  // stop accepting new connections,\n  // wait for established connections to finish (30s max),\n  // then exit\n  process.on(\"SIGTERM\", function() {\n    logging.warn(\"Got SIGTERM, no longer accepting new connections!\");\n\n    setTimeout(function() {\n      logging.error(\"Dropping connections after 30s. Force quit.\");\n      process.exit(1);\n    }, 30000);\n\n    server.close(function() {\n      logging.log(\"All connections closed, shutting down.\");\n      process.exit();\n    });\n  });\n};\n\n// Close the server\nexp.close = function(callback) {\n  helpers.stoplog();\n  server.close(callback);\n};\n\nmodule.exports = exp;\n\nif (require.main === module) {\n  logging.error(\"Please use 'npm start' or 'www.js'\");\n  process.exit(1);\n}", "/* globals describe, it, before, after */\n/* eslint no-loop-func:0 guard-for-in:0 */\n\n// no spam\nvar logging = require(\"../lib/logging\");\nif (process.env.VERBOSE_TEST !== \"true\") {\n  logging.log = logging.debug = logging.warn = logging.error = function() {};\n}\n\nvar networking = require(\"../lib/networking\");\nvar helpers = require(\"../lib/helpers\");\nvar request = require(\"request\");\nvar config = require(\"../config\");\nvar server = require(\"../lib/server\");\nvar assert = require(\"assert\");\nvar skins = require(\"../lib/skins\");\nvar cache = require(\"../lib/cache\");\nvar crc = require(\"crc\").crc32;\nvar fs = require(\"fs\");\n\n// we don't want tests to fail because of slow internet\nconfig.server.http_timeout *= 3;\n\nvar uuids = fs.readFileSync(\"test/uuids.txt\").toString().split(/\\r?\\n/);\n\n// Get a random UUIDto prevent rate limiting\nvar uuid = uuids[Math.round(Math.random() * (uuids.length - 1))];\n\n\n// Let's hope these will never be assigned\nvar steve_ids = [\n  \"fffffff0\" + \"fffffff0\" + \"fffffff0\" + \"fffffff0\",\n  \"fffffff0\" + \"fffffff0\" + \"fffffff1\" + \"fffffff1\",\n  \"fffffff0\" + \"fffffff1\" + \"fffffff0\" + \"fffffff1\",\n  \"fffffff0\" + \"fffffff1\" + \"fffffff1\" + \"fffffff0\",\n  \"fffffff1\" + \"fffffff0\" + \"fffffff0\" + \"fffffff1\",\n  \"fffffff1\" + \"fffffff0\" + \"fffffff1\" + \"fffffff0\",\n  \"fffffff1\" + \"fffffff1\" + \"fffffff0\" + \"fffffff0\",\n  \"fffffff1\" + \"fffffff1\" + \"fffffff1\" + \"fffffff1\",\n];\n// Let's hope these will never be assigned\nvar alex_ids = [\n  \"fffffff0\" + \"fffffff0\" + \"fffffff0\" + \"fffffff1\",\n  \"fffffff0\" + \"fffffff0\" + \"fffffff1\" + \"fffffff0\",\n  \"fffffff0\" + \"fffffff1\" + \"fffffff0\" + \"fffffff0\",\n  \"fffffff0\" + \"fffffff1\" + \"fffffff1\" + \"fffffff1\",\n  \"fffffff1\" + \"fffffff0\" + \"fffffff0\" + \"fffffff0\",\n  \"fffffff1\" + \"fffffff0\" + \"fffffff1\" + \"fffffff1\",\n  \"fffffff1\" + \"fffffff1\" + \"fffffff0\" + \"fffffff1\",\n  \"fffffff1\" + \"fffffff1\" + \"fffffff1\" + \"fffffff0\",\n];\n\n// generates a 12 character random string\nfunction rid() {\n  return Math.random().toString(36).substring(2, 14);\n}\n\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\ndescribe(\"Crafatar\", function() {\n  // we might have to make 2 HTTP requests\n  this.timeout(config.server.http_timeout * 2 + 50);\n\n  before(function(done) {\n    console.log(\"Flushing and waiting for redis ...\");\n    cache.get_redis().flushall(function() {\n      console.log(\"Redis flushed!\");\n      done();\n    });\n  });\n\n  describe(\"UUID/username\", function() {\n    it(\"non-hex uuid is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"g098cb60fa8e427cb299793cbd302c9a\"), false);\n      done();\n    });\n    it(\"empty id is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"\"), false);\n      done();\n    });\n    it(\"lowercase uuid is valid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"0098cb60fa8e427cb299793cbd302c9a\"), true);\n      done();\n    });\n    it(\"uppercase uuid is valid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"1DCEF164FF0A47F2B9A691385C774EE7\"), true);\n      done();\n    });\n    it(\"dashed uuid is not valid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"0098cb60-fa8e-427c-b299-793cbd302c9a\"), false);\n      done();\n    });\n    it(\"username is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"__niceUs3rname__\"), false);\n      done();\n    });\n    it(\"username alex is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"alex\"), false);\n      done();\n    });\n    it(\"username mhf_alex is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"mhf_alex\"), false);\n      done();\n    });\n    it(\"username steve is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"steve\"), false);\n      done();\n    });\n    it(\"username mhf_steve is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"mhf_steve\"), false);\n      done();\n    });\n    it(\">16 length username is invalid\", function(done) {\n      assert.strictEqual(helpers.id_valid(\"ThisNameIsTooLong\"), false);\n      done();\n    });\n    it(\"should not exist (uuid)\", function(done) {\n      var number = getRandomInt(0, 9).toString();\n      networking.get_profile(rid(), Array(33).join(number), function(err, profile) {\n        assert.ifError(err);\n        assert.strictEqual(profile, null);\n        done();\n      });\n    });\n  });\n  describe(\"Avatar\", function() {\n    for (var a in alex_ids) {\n      var alexid = alex_ids[a];\n      (function(alex_id) {\n        it(\"UUID \" + alex_id + \" should default to MHF_Alex\", function(done) {\n          assert.strictEqual(skins.default_skin(alex_id), \"mhf_alex\");\n          done();\n        });\n      }(alexid));\n    }\n    for (var s in steve_ids) {\n      var steveid = steve_ids[s];\n      (function(steve_id) {\n        it(\"UUID \" + steve_id + \" should default to MHF_Steve\", function(done) {\n          assert.strictEqual(skins.default_skin(steve_id), \"mhf_steve\");\n          done();\n        });\n      }(steveid));\n    }\n  });\n  describe(\"Errors\", function() {\n    it(\"should time out on uuid info download\", function(done) {\n      var original_timeout = config.server.http_timeout;\n      config.server.http_timeout = 1;\n      networking.get_profile(rid(), \"069a79f444e94726a5befca90e38aaf5\", function(err, profile) {\n        assert.notStrictEqual([\"ETIMEDOUT\", \"ESOCKETTIMEDOUT\"].indexOf(err.code), -1);\n        config.server.http_timeout = original_timeout;\n        done();\n      });\n    });\n    it(\"should time out on skin download\", function(done) {\n      var original_timeout = config.http_timeout;\n      config.server.http_timeout = 1;\n      networking.get_from(rid(), \"http://textures.minecraft.net/texture/477be35554684c28bdeee4cf11c591d3c88afb77e0b98da893fd7bc318c65184\", function(body, res, error) {\n        assert.notStrictEqual([\"ETIMEDOUT\", \"ESOCKETTIMEDOUT\"].indexOf(error.code), -1);\n        config.server.http_timeout = original_timeout;\n        done();\n      });\n    });\n    it(\"should not find the skin\", function(done) {\n      assert.doesNotThrow(function() {\n        networking.get_from(rid(), \"http://textures.minecraft.net/texture/this-does-not-exist\", function(img, response, err) {\n          assert.strictEqual(err, null); // no error here, but it shouldn't throw exceptions\n          done();\n        });\n      });\n    });\n    it(\"should not find the file\", function(done) {\n      skins.open_skin(rid(), \"non/existent/path\", function(err, img) {\n        assert(err);\n        done();\n      });\n    });\n  });\n\n  describe(\"Server\", function() {\n    // throws Exception when default headers are not in res.headers\n    function assert_headers(res) {\n      assert(res.headers[\"content-type\"]);\n      assert(\"\" + res.headers[\"response-time\"]);\n      assert(res.headers[\"x-request-id\"]);\n      assert.equal(res.headers[\"access-control-allow-origin\"], \"*\");\n      assert.equal(res.headers[\"cache-control\"], \"max-age=\" + config.caching.browser);\n    }\n\n    // throws Exception when +url+ is requested with +etag+\n    // and it does not return 304 without a body\n    function assert_cache(url, etag, callback) {\n      request.get(url, {\n        headers: {\n          \"If-None-Match\": etag,\n        },\n      }, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(body, '');\n        assert.equal(res.statusCode, 304);\n        assert_headers(res);\n        callback();\n      });\n    }\n\n    before(function(done) {\n      server.boot(function() {\n        done();\n      });\n    });\n\n    it(\"should return 405 Method Not Allowed for POST\", function(done) {\n      request.post(\"http://localhost:3000\", function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 405);\n        done();\n      });\n    });\n\n    it(\"should return correct HTTP response for home page\", function(done) {\n      var url = \"http://localhost:3000\";\n      request.get(url, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 200);\n        assert_headers(res);\n        assert(res.headers.etag);\n        assert.strictEqual(res.headers[\"content-type\"], \"text/html; charset=utf-8\");\n        assert.strictEqual(res.headers.etag, '\"' + crc(body) + '\"');\n        assert(body);\n\n        assert_cache(url, res.headers.etag, function() {\n          done();\n        });\n      });\n    });\n\n    it(\"should return correct HTTP response for assets\", function(done) {\n      var url = \"http://localhost:3000/stylesheets/style.css\";\n      request.get(url, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 200);\n        assert_headers(res);\n        assert(res.headers.etag);\n        assert.strictEqual(res.headers[\"content-type\"], \"text/css\");\n        assert.strictEqual(res.headers.etag, '\"' + crc(body) + '\"');\n        assert(body);\n\n        assert_cache(url, res.headers.etag, function() {\n          done();\n        });\n      });\n    });\n\n    it(\"should return correct HTTP response for URL encoded URLs\", function(done) {\n      var url = \"http://localhost:3000/%61%76%61%74%61%72%73/%61%65%37%39%35%61%61%38%36%33%32%37%34%30%38%65%39%32%61%62%32%35%63%38%61%35%39%66%33%62%61%31\"; // avatars/ae795aa86327408e92ab25c8a59f3ba1\n      request.get(url, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 200);\n        assert_headers(res);\n        assert(res.headers.etag);\n        assert.strictEqual(res.headers[\"content-type\"], \"image/png\");\n        assert(body);\n        done();\n      });\n    });\n\n    it(\"should not fail on simultaneous requests\", function(done) {\n      var url = \"http://localhost:3000/avatars/696a82ce41f44b51aa31b8709b8686f0\";\n      // 10 requests at once\n      var requests = 10;\n      var finished = 0;\n      function partDone() {\n        finished++;\n        if (requests === finished) {\n          done();\n        }\n      }\n      function req() {\n        request.get(url, function(error, res, body) {\n          assert.ifError(error);\n          assert.strictEqual(res.statusCode, 200);\n          assert_headers(res);\n          assert(res.headers.etag);\n          assert.strictEqual(res.headers[\"content-type\"], \"image/png\");\n          assert(body);\n          partDone();\n        });\n      }\n      // make simultanous requests\n      for (var k = 0; k < requests; k++) {\n        req(k);\n      }\n  });\n\n    var server_tests = {\n      \"avatar with existing uuid\": {\n        url: \"http://localhost:3000/avatars/853c80ef3c3749fdaa49938b674adae6?size=16\",\n        crc32: [4264176600],\n      },\n      \"avatar with existing dashed uuid\": {\n        url: \"http://localhost:3000/avatars/853c80ef-3c37-49fd-aa49938b674adae6?size=16\",\n        crc32: [4264176600],\n      },\n      \"avatar with non-existent uuid\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16\",\n        crc32: [3348154329],\n      },\n      \"avatar with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&default=mhf_alex\",\n        crc32: [73899130],\n      },\n      \"avatar with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"http://localhost:3000/avatars/853c80ef3c3749fdaa49938b674adae6?size=16\",\n      },\n      \"avatar with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"overlay avatar with existing uuid\": {\n        url: \"http://localhost:3000/avatars/853c80ef3c3749fdaa49938b674adae6?size=16&overlay\",\n        crc32: [575355728],\n      },\n      \"overlay avatar with non-existent uuid\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&overlay\",\n        crc32: [3348154329],\n      },\n      \"overlay avatar with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&overlay&default=mhf_alex\",\n        crc32: [73899130],\n      },\n      \"overlay avatar with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"http://localhost:3000/avatars/853c80ef3c3749fdaa49938b674adae6?size=16\",\n      },\n      \"overlay avatar with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/avatars/00000000000000000000000000000000?size=16&overlay&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"cape with existing uuid\": {\n        url: \"http://localhost:3000/capes/853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [985789174],\n      },\n      \"cape with non-existent uuid\": {\n        url: \"http://localhost:3000/capes/00000000000000000000000000000000\",\n        crc32: [0],\n      },\n      \"cape with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/capes/00000000000000000000000000000000?default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"skin with existing uuid\": {\n        url: \"http://localhost:3000/skins/853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [1759176487],\n      },\n      \"skin with non-existent uuid\": {\n        url: \"http://localhost:3000/skins/00000000000000000000000000000000\",\n        crc32: [1853029228],\n      },\n      \"skin with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/skins/00000000000000000000000000000000?default=mhf_alex\",\n        crc32: [427506205],\n      },\n      \"skin with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/skins/00000000000000000000000000000000?size=16&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"http://localhost:3000/skins/853c80ef3c3749fdaa49938b674adae6?size=16\",\n      },\n      \"skin with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/skins/00000000000000000000000000000000?default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"head render with existing uuid\": {\n        url: \"http://localhost:3000/renders/head/853c80ef3c3749fdaa49938b674adae6?scale=2\",\n        crc32: [1168786201],\n      },\n      \"head render with non-existent uuid\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2\",\n        crc32: [3800926063],\n      },\n      \"head render with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&default=mhf_alex\",\n        crc32: [4027858557],\n      },\n      \"head render with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"http://localhost:3000/renders/head/853c80ef3c3749fdaa49938b674adae6?scale=2\",\n      },\n      \"head render with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"overlay head render with existing uuid\": {\n        url: \"http://localhost:3000/renders/head/853c80ef3c3749fdaa49938b674adae6?scale=2&overlay\",\n        crc32: [2880579826],\n      },\n      \"overlay head render with non-existent uuid\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&overlay\",\n        crc32: [3800926063],\n      },\n      \"overlay head render with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&overlay&default=mhf_alex\",\n        crc32: [4027858557],\n      },\n      \"overlay head with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&overlay&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"http://localhost:3000/renders/head/853c80ef3c3749fdaa49938b674adae6?scale=2&overlay=\",\n      },\n      \"overlay head render with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/renders/head/00000000000000000000000000000000?scale=2&overlay&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"body render with existing uuid\": {\n        url: \"http://localhost:3000/renders/body/853c80ef3c3749fdaa49938b674adae6?scale=2\",\n        crc32: [1144887125],\n      },\n      \"body render with non-existent uuid\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2\",\n        crc32: [996962526],\n      },\n      \"body render with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&default=mhf_alex\",\n        crc32: [4280894468],\n      },\n      \"body render with non-existent uuid defaulting to uuid\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&default=853c80ef3c3749fdaa49938b674adae6\",\n        crc32: [0],\n        redirect: \"http://localhost:3000/renders/body/853c80ef3c3749fdaa49938b674adae6?scale=2\",\n      },\n      \"body render with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n      \"overlay body render with existing uuid\": {\n        url: \"http://localhost:3000/renders/body/853c80ef3c3749fdaa49938b674adae6?scale=2&overlay\",\n        crc32: [1107696668],\n      },\n      \"overlay body render with non-existent uuid\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&overlay\",\n        crc32: [996962526],\n      },\n      \"overlay body render with non-existent uuid defaulting to mhf_alex\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&overlay&default=mhf_alex\",\n        crc32: [4280894468],\n      },\n      \"overlay body render with non-existent uuid defaulting to url\": {\n        url: \"http://localhost:3000/renders/body/00000000000000000000000000000000?scale=2&overlay&default=http%3A%2F%2Fexample.com%2FCaseSensitive\",\n        crc32: [0],\n        redirect: \"http://example.com/CaseSensitive\",\n      },\n    };\n\n    for (var description in server_tests) {\n      var loc = server_tests[description];\n      (function(location) {\n        it(\"should return correct HTTP response for \" + description, function(done) {\n          request.get(location.url, {followRedirect: false, encoding: null}, function(error, res, body) {\n            assert.ifError(error);\n            assert_headers(res);\n            assert(res.headers[\"x-storage-type\"]);\n            var hash = crc(body);\n            var matches = false;\n            for (var c = 0; c < location.crc32.length; c++) {\n              if (location.crc32[c] === hash) {\n                matches = true;\n                break;\n              }\n            }\n            try {\n              assert(matches);\n            } catch(e) {\n              throw new Error(hash + \" != \" + location.crc32 + \" | \" + body.toString(\"base64\"));\n            }\n            assert.strictEqual(res.headers.location, location.redirect);\n            if (location.crc32[0] === 0) {\n              assert.strictEqual(res.statusCode, location.redirect ? 307 : 404);\n              assert.ifError(res.headers.etag); // etag must not be present on non-200\n              assert.strictEqual(res.headers[\"content-type\"], \"text/plain\");\n              done();\n            } else {\n              assert.strictEqual(res.headers[\"content-type\"], \"image/png\");\n              assert.strictEqual(res.statusCode, 200);\n              assert(res.headers.etag);\n              assert.strictEqual(res.headers.etag, '\"' + hash + '\"');\n              assert_cache(location.url, res.headers.etag, function() {\n                done();\n              });\n            }\n          });\n        });\n      }(loc));\n    }\n\n    it(\"should return 304 on server error\", function(done) {\n      var original_debug = config.server.debug_enabled;\n      var original_timeout = config.server.http_timeout;\n      config.server.debug_enabled = false;\n      config.server.http_timeout = 1;\n      request.get({url: \"http://localhost:3000/avatars/0000000000000000000000000000000f\", headers: {\"If-None-Match\": '\"some-etag\"'}}, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(body, '');\n        assert.strictEqual(res.statusCode, 304);\n        config.server.debug_enabled = original_debug;\n        config.server.http_timeout = original_timeout;\n        done();\n      });\n    });\n\n    it(\"should return a 422 (invalid size)\", function(done) {\n      var size = config.avatars.max_size + 1;\n      request.get(\"http://localhost:3000/avatars/2d5aa9cdaeb049189930461fc9b91cc5?size=\" + size, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 422);\n        done();\n      });\n    });\n\n    it(\"should return a 422 (invalid scale)\", function(done) {\n      var scale = config.renders.max_scale + 1;\n      request.get(\"http://localhost:3000/renders/head/2d5aa9cdaeb049189930461fc9b91cc5?scale=\" + scale, function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 422);\n        done();\n      });\n    });\n\n    it(\"should return a 422 (invalid render type)\", function(done) {\n      request.get(\"http://localhost:3000/renders/invalid/2d5aa9cdaeb049189930461fc9b91cc5\", function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 422);\n        done();\n      });\n    });\n\n    // testing all paths for Invalid UUID\n    var locations = [\"avatars\", \"skins\", \"capes\", \"renders/body\", \"renders/head\"];\n    for (var l in locations) {\n      loc = locations[l];\n      (function(location) {\n        it(\"should return a 422 (invalid uuid \" + location + \")\", function(done) {\n          request.get(\"http://localhost:3000/\" + location + \"/thisisaninvaliduuid\", function(error, res, body) {\n            assert.ifError(error);\n            assert.strictEqual(res.statusCode, 422);\n            done();\n          });\n        });\n\n        it(\"should return a 404 (invalid path \" + location + \")\", function(done) {\n          request.get(\"http://localhost:3000/\" + location + \"/853c80ef3c3749fdaa49938b674adae6/invalid\", function(error, res, body) {\n            assert.ifError(error);\n            assert.strictEqual(res.statusCode, 404);\n            done();\n          });\n        });\n      }(loc));\n    }\n\n    it(\"should return /public resources\", function(done) {\n      request.get(\"http://localhost:3000/javascript/crafatar.js\", function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 200);\n        done();\n      });\n    });\n\n    it(\"should not allow path traversal on /public\", function(done) {\n      request.get(\"http://localhost:3000/../server.js\", function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 404);\n        done();\n      });\n    });\n\n    it(\"should not allow encoded path traversal on /public\", function(done) {\n      request.get(\"http://localhost:3000/%2E%2E/server.js\", function(error, res, body) {\n        assert.ifError(error);\n        assert.strictEqual(res.statusCode, 404);\n        done();\n      });\n    });\n  });\n\n  // we have to make sure that we test both a 32x64 and 64x64 skin\n  describe(\"Networking: Render\", function() {\n    it(\"should not fail (uuid, 32x64 skin)\", function(done) {\n      helpers.get_render(rid(), \"af74a02d19cb445bb07f6866a861f783\", 6, true, true, function(err, hash, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n    it(\"should not fail (uuid, 64x64 skin)\", function(done) {\n      helpers.get_render(rid(), \"2d5aa9cdaeb049189930461fc9b91cc5\", 6, true, true, function(err, hash, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n  });\n\n  describe(\"Networking: Cape\", function() {\n    it(\"should not fail (guaranteed cape)\", function(done) {\n      helpers.get_cape(rid(), \"61699b2ed3274a019f1e0ea8c3f06bc6\", function(err, hash, status, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n    it(\"should already exist\", function(done) {\n      before(function() {\n        cache.get_redis().flushall();\n      });\n      helpers.get_cape(rid(), \"61699b2ed3274a019f1e0ea8c3f06bc6\", function(err, hash, status, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n    it(\"should not be found\", function(done) {\n      helpers.get_cape(rid(), \"2d5aa9cdaeb049189930461fc9b91cc5\", function(err, hash, status, img) {\n        assert.ifError(err);\n        assert.strictEqual(img, null);\n        done();\n      });\n    });\n  });\n\n  describe(\"Networking: Skin\", function() {\n    it(\"should not fail\", function(done) {\n      helpers.get_cape(rid(), \"2d5aa9cdaeb049189930461fc9b91cc5\", function(err, hash, status, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n    it(\"should already exist\", function(done) {\n      before(function() {\n        cache.get_redis().flushall();\n      });\n      helpers.get_cape(rid(), \"2d5aa9cdaeb049189930461fc9b91cc5\", function(err, hash, status, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n  });\n\n\n\n  describe(\"Networking: Avatar\", function() {\n    before(function() {\n      cache.get_redis().flushall();\n    });\n    it(\"should be downloaded\", function(done) {\n      helpers.get_avatar(rid(), uuid, false, 160, function(err, status, image) {\n        assert.ifError(err);\n        assert.strictEqual(status, 2);\n        done();\n      });\n    });\n    it(\"should be cached\", function(done) {\n      helpers.get_avatar(rid(), uuid, false, 160, function(err, status, image) {\n        assert.ifError(err);\n        assert.strictEqual(status === 0 || status === 1, true);\n        done();\n      });\n    });\n  });\n\n  describe(\"Networking: Skin\", function() {\n    it(\"should not fail (uuid)\", function(done) {\n      helpers.get_skin(rid(), uuid, function(err, hash, status, img) {\n        assert.strictEqual(err, null);\n        done();\n      });\n    });\n  });\n\n  describe(\"Networking: Render\", function() {\n    it(\"should not fail (full body)\", function(done) {\n      helpers.get_render(rid(), uuid, 6, true, true, function(err, hash, img) {\n        assert.ifError(err);\n        done();\n      });\n    });\n    it(\"should not fail (only head)\", function(done) {\n      helpers.get_render(rid(), uuid, 6, true, false, function(err, hash, img) {\n        assert.ifError(err);\n        done();\n      });\n    });\n  });\n\n  describe(\"Networking: Cape\", function() {\n    it(\"should not fail (possible cape)\", function(done) {\n      helpers.get_cape(rid(), uuid, function(err, hash, status, img) {\n        assert.ifError(err);\n        done();\n      });\n    });\n  });\n\n\n  describe(\"Errors\", function() {\n      before(function() {\n      cache.get_redis().flushall();\n    });\n\n    // Mojang has changed its rate limiting, so we no longer expect to hit the rate limit\n    // it(\"uuid SHOULD be rate limited\", function(done) {\n    //   networking.get_profile(rid(), uuid, function() {\n    //     networking.get_profile(rid(), uuid, function(err, profile) {\n    //       assert.strictEqual(err.toString(), \"HTTP: 429\");\n    //       assert.strictEqual(profile, null);\n    //       done();\n    //     });\n    //   });\n    // });\n\n    it(\"CloudFront rate limit is handled\", function(done) {\n      var original_rate_limit = config.server.sessions_rate_limit;\n      config.server.sessions_rate_limit = 1;\n      networking.get_profile(rid(), uuid, function() {\n        networking.get_profile(rid(), uuid, function(err, profile) {\n          assert.strictEqual(err.code, \"RATELIMIT\");\n          config.server.sessions_rate_limit = original_rate_limit;\n          done();\n        });\n      });\n    });\n  });\n\n  after(function(done) {\n    server.close(function() {\n      cache.get_redis().quit();\n      done();\n    });\n  });\n});"], "filenames": ["lib/routes/avatars.js", "lib/routes/capes.js", "lib/routes/renders.js", "lib/routes/skins.js", "lib/server.js", "test/test.js"], "buggy_code_start_loc": [17, 7, 20, 17, 25, 318], "buggy_code_end_loc": [59, 8, 68, 66, 70, 570], "fixing_code_start_loc": [17, 7, 20, 17, 25, 318], "fixing_code_end_loc": [57, 8, 66, 64, 70, 595], "type": "CWE-22", "message": "Crafatar serves Minecraft avatars based on the skin for use in external applications. Files outside of the `lib/public/` directory can be requested from the server. Instances running behind Cloudflare (including crafatar.com) are not affected. Instances using the Docker container as shown in the README are affected, but only files within the container can be read. By default, all of the files within the container can also be found in this repository and are not confidential. This vulnerability is patched in 2.1.5.", "other": {"cve": {"id": "CVE-2024-24756", "sourceIdentifier": "security-advisories@github.com", "published": "2024-02-01T23:15:11.210", "lastModified": "2024-02-09T19:47:10.213", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Crafatar serves Minecraft avatars based on the skin for use in external applications. Files outside of the `lib/public/` directory can be requested from the server. Instances running behind Cloudflare (including crafatar.com) are not affected. Instances using the Docker container as shown in the README are affected, but only files within the container can be read. By default, all of the files within the container can also be found in this repository and are not confidential. This vulnerability is patched in 2.1.5."}, {"lang": "es", "value": "Crafatar ofrece avatares de Minecraft basados en la apariencia para su uso en aplicaciones externas. Los archivos fuera del directorio `lib/public/` se pueden solicitar desde el servidor. Las instancias que se ejecutan detr\u00e1s de Cloudflare (incluido crafatar.com) no se ven afectadas. Las instancias que utilizan el contenedor Docker como se muestra en el archivo README se ven afectadas, pero solo se pueden leer los archivos dentro del contenedor. De forma predeterminada, todos los archivos del contenedor tambi\u00e9n se pueden encontrar en este repositorio y no son confidenciales. Esta vulnerabilidad est\u00e1 parcheada en 2.1.5."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:crafatar:crafatar:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.5", "matchCriteriaId": "CBFA1552-D4BE-4660-8B70-260EA05E6D56"}]}]}], "references": [{"url": "https://github.com/crafatar/crafatar/blob/e0233f2899a3206a817d2dd3b80da83d51c7a726/lib/server.js#L64-L67", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/crafatar/crafatar/commit/bba004acc725b362a5d2d5dfe30cf60e7365a373", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/crafatar/crafatar/security/advisories/GHSA-5cxq-25mp-q5f2", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/crafatar/crafatar/commit/bba004acc725b362a5d2d5dfe30cf60e7365a373"}}