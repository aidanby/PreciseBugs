{"buggy_code": ["var jsReleases = require('node-releases/data/processed/envs.json')\nvar agents = require('caniuse-lite/dist/unpacker/agents').agents\nvar jsEOL = require('node-releases/data/release-schedule/release-schedule.json')\nvar path = require('path')\nvar e2c = require('electron-to-chromium/versions')\n\nvar BrowserslistError = require('./error')\nvar env = require('./node') // Will load browser.js in webpack\n\nvar YEAR = 365.259641 * 24 * 60 * 60 * 1000\nvar ANDROID_EVERGREEN_FIRST = 37\n\nvar QUERY_OR = 1\nvar QUERY_AND = 2\n\nfunction isVersionsMatch (versionA, versionB) {\n  return (versionA + '.').indexOf(versionB + '.') === 0\n}\n\nfunction isEolReleased (name) {\n  var version = name.slice(1)\n  return jsReleases.some(function (i) {\n    return isVersionsMatch(i.version, version)\n  })\n}\n\nfunction normalize (versions) {\n  return versions.filter(function (version) {\n    return typeof version === 'string'\n  })\n}\n\nfunction normalizeElectron (version) {\n  var versionToUse = version\n  if (version.split('.').length === 3) {\n    versionToUse = version\n      .split('.')\n      .slice(0, -1)\n      .join('.')\n  }\n  return versionToUse\n}\n\nfunction nameMapper (name) {\n  return function mapName (version) {\n    return name + ' ' + version\n  }\n}\n\nfunction getMajor (version) {\n  return parseInt(version.split('.')[0])\n}\n\nfunction getMajorVersions (released, number) {\n  if (released.length === 0) return []\n  var majorVersions = uniq(released.map(getMajor))\n  var minimum = majorVersions[majorVersions.length - number]\n  if (!minimum) {\n    return released\n  }\n  var selected = []\n  for (var i = released.length - 1; i >= 0; i--) {\n    if (minimum > getMajor(released[i])) break\n    selected.unshift(released[i])\n  }\n  return selected\n}\n\nfunction uniq (array) {\n  var filtered = []\n  for (var i = 0; i < array.length; i++) {\n    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i])\n  }\n  return filtered\n}\n\n// Helpers\n\nfunction fillUsage (result, name, data) {\n  for (var i in data) {\n    result[name + ' ' + i] = data[i]\n  }\n}\n\nfunction generateFilter (sign, version) {\n  version = parseFloat(version)\n  if (sign === '>') {\n    return function (v) {\n      return parseFloat(v) > version\n    }\n  } else if (sign === '>=') {\n    return function (v) {\n      return parseFloat(v) >= version\n    }\n  } else if (sign === '<') {\n    return function (v) {\n      return parseFloat(v) < version\n    }\n  } else {\n    return function (v) {\n      return parseFloat(v) <= version\n    }\n  }\n}\n\nfunction generateSemverFilter (sign, version) {\n  version = version.split('.').map(parseSimpleInt)\n  version[1] = version[1] || 0\n  version[2] = version[2] || 0\n  if (sign === '>') {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(v, version) > 0\n    }\n  } else if (sign === '>=') {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(v, version) >= 0\n    }\n  } else if (sign === '<') {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(version, v) > 0\n    }\n  } else {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(version, v) >= 0\n    }\n  }\n}\n\nfunction parseSimpleInt (x) {\n  return parseInt(x)\n}\n\nfunction compare (a, b) {\n  if (a < b) return -1\n  if (a > b) return +1\n  return 0\n}\n\nfunction compareSemver (a, b) {\n  return (\n    compare(parseInt(a[0]), parseInt(b[0])) ||\n    compare(parseInt(a[1] || '0'), parseInt(b[1] || '0')) ||\n    compare(parseInt(a[2] || '0'), parseInt(b[2] || '0'))\n  )\n}\n\n// this follows the npm-like semver behavior\nfunction semverFilterLoose (operator, range) {\n  range = range.split('.').map(parseSimpleInt)\n  if (typeof range[1] === 'undefined') {\n    range[1] = 'x'\n  }\n  // ignore any patch version because we only return minor versions\n  // range[2] = 'x'\n  switch (operator) {\n    case '<=':\n      return function (version) {\n        version = version.split('.').map(parseSimpleInt)\n        return compareSemverLoose(version, range) <= 0\n      }\n    default:\n    case '>=':\n      return function (version) {\n        version = version.split('.').map(parseSimpleInt)\n        return compareSemverLoose(version, range) >= 0\n      }\n  }\n}\n\n// this follows the npm-like semver behavior\nfunction compareSemverLoose (version, range) {\n  if (version[0] !== range[0]) {\n    return version[0] < range[0] ? -1 : +1\n  }\n  if (range[1] === 'x') {\n    return 0\n  }\n  if (version[1] !== range[1]) {\n    return version[1] < range[1] ? -1 : +1\n  }\n  return 0\n}\n\nfunction resolveVersion (data, version) {\n  if (data.versions.indexOf(version) !== -1) {\n    return version\n  } else if (browserslist.versionAliases[data.name][version]) {\n    return browserslist.versionAliases[data.name][version]\n  } else {\n    return false\n  }\n}\n\nfunction normalizeVersion (data, version) {\n  var resolved = resolveVersion(data, version)\n  if (resolved) {\n    return resolved\n  } else if (data.versions.length === 1) {\n    return data.versions[0]\n  } else {\n    return false\n  }\n}\n\nfunction filterByYear (since, context) {\n  since = since / 1000\n  return Object.keys(agents).reduce(function (selected, name) {\n    var data = byName(name, context)\n    if (!data) return selected\n    var versions = Object.keys(data.releaseDate).filter(function (v) {\n      return data.releaseDate[v] >= since\n    })\n    return selected.concat(versions.map(nameMapper(data.name)))\n  }, [])\n}\n\nfunction cloneData (data) {\n  return {\n    name: data.name,\n    versions: data.versions,\n    released: data.released,\n    releaseDate: data.releaseDate\n  }\n}\n\nfunction mapVersions (data, map) {\n  data.versions = data.versions.map(function (i) {\n    return map[i] || i\n  })\n  data.released = data.versions.map(function (i) {\n    return map[i] || i\n  })\n  var fixedDate = { }\n  for (var i in data.releaseDate) {\n    fixedDate[map[i] || i] = data.releaseDate[i]\n  }\n  data.releaseDate = fixedDate\n  return data\n}\n\nfunction byName (name, context) {\n  name = name.toLowerCase()\n  name = browserslist.aliases[name] || name\n  if (context.mobileToDesktop && browserslist.desktopNames[name]) {\n    var desktop = browserslist.data[browserslist.desktopNames[name]]\n    if (name === 'android') {\n      return normalizeAndroidData(cloneData(browserslist.data[name]), desktop)\n    } else {\n      var cloned = cloneData(desktop)\n      cloned.name = name\n      if (name === 'op_mob') {\n        cloned = mapVersions(cloned, { '10.0-10.1': '10' })\n      }\n      return cloned\n    }\n  }\n  return browserslist.data[name]\n}\n\nfunction normalizeAndroidVersions (androidVersions, chromeVersions) {\n  var firstEvergreen = ANDROID_EVERGREEN_FIRST\n  var last = chromeVersions[chromeVersions.length - 1]\n  return androidVersions\n    .filter(function (version) { return /^(?:[2-4]\\.|[34]$)/.test(version) })\n    .concat(chromeVersions.slice(firstEvergreen - last - 1))\n}\n\nfunction normalizeAndroidData (android, chrome) {\n  android.released = normalizeAndroidVersions(android.released, chrome.released)\n  android.versions = normalizeAndroidVersions(android.versions, chrome.versions)\n  return android\n}\n\nfunction checkName (name, context) {\n  var data = byName(name, context)\n  if (!data) throw new BrowserslistError('Unknown browser ' + name)\n  return data\n}\n\nfunction unknownQuery (query) {\n  return new BrowserslistError(\n    'Unknown browser query `' + query + '`. ' +\n    'Maybe you are using old Browserslist or made typo in query.'\n  )\n}\n\nfunction filterAndroid (list, versions, context) {\n  if (context.mobileToDesktop) return list\n  var released = browserslist.data.android.released\n  var last = released[released.length - 1]\n  var diff = last - ANDROID_EVERGREEN_FIRST - versions\n  if (diff > 0) {\n    return list.slice(-1)\n  } else {\n    return list.slice(diff - 1)\n  }\n}\n\n/**\n * Resolves queries into a browser list.\n * @param {string|string[]} queries Queries to combine.\n * Either an array of queries or a long string of queries.\n * @param {object} [context] Optional arguments to\n * the select function in `queries`.\n * @returns {string[]} A list of browsers\n */\nfunction resolve (queries, context) {\n  if (Array.isArray(queries)) {\n    queries = flatten(queries.map(parse))\n  } else {\n    queries = parse(queries)\n  }\n\n  return queries.reduce(function (result, query, index) {\n    var selection = query.queryString\n\n    var isExclude = selection.indexOf('not ') === 0\n    if (isExclude) {\n      if (index === 0) {\n        throw new BrowserslistError(\n          'Write any browsers query (for instance, `defaults`) ' +\n          'before `' + selection + '`')\n      }\n      selection = selection.slice(4)\n    }\n\n    for (var i = 0; i < QUERIES.length; i++) {\n      var type = QUERIES[i]\n      var match = selection.match(type.regexp)\n      if (match) {\n        var args = [context].concat(match.slice(1))\n        var array = type.select.apply(browserslist, args).map(function (j) {\n          var parts = j.split(' ')\n          if (parts[1] === '0') {\n            return parts[0] + ' ' + byName(parts[0], context).versions[0]\n          } else {\n            return j\n          }\n        })\n\n        switch (query.type) {\n          case QUERY_AND:\n            if (isExclude) {\n              return result.filter(function (j) {\n                return array.indexOf(j) === -1\n              })\n            } else {\n              return result.filter(function (j) {\n                return array.indexOf(j) !== -1\n              })\n            }\n          case QUERY_OR:\n          default:\n            if (isExclude) {\n              var filter = { }\n              array.forEach(function (j) {\n                filter[j] = true\n              })\n              return result.filter(function (j) {\n                return !filter[j]\n              })\n            }\n            return result.concat(array)\n        }\n      }\n    }\n\n    throw unknownQuery(selection)\n  }, [])\n}\n\nvar cache = { }\n\n/**\n * Return array of browsers by selection queries.\n *\n * @param {(string|string[])} [queries=browserslist.defaults] Browser queries.\n * @param {object} [opts] Options.\n * @param {string} [opts.path=\".\"] Path to processed file.\n *                                 It will be used to find config files.\n * @param {string} [opts.env=\"production\"] Processing environment.\n *                                         It will be used to take right\n *                                         queries from config file.\n * @param {string} [opts.config] Path to config file with queries.\n * @param {object} [opts.stats] Custom browser usage statistics\n *                              for \"> 1% in my stats\" query.\n * @param {boolean} [opts.ignoreUnknownVersions=false] Do not throw on unknown\n *                                                     version in direct query.\n * @param {boolean} [opts.dangerousExtend] Disable security checks\n *                                         for extend query.\n * @param {boolean} [opts.mobileToDesktop] Alias mobile browsers to the desktop\n *                                         version when Can I Use doesn't have\n *                                         data about the specified version.\n * @returns {string[]} Array with browser names in Can I Use.\n *\n * @example\n * browserslist('IE >= 10, IE 8') //=> ['ie 11', 'ie 10', 'ie 8']\n */\nfunction browserslist (queries, opts) {\n  if (typeof opts === 'undefined') opts = { }\n\n  if (typeof opts.path === 'undefined') {\n    opts.path = path.resolve ? path.resolve('.') : '.'\n  }\n\n  if (typeof queries === 'undefined' || queries === null) {\n    var config = browserslist.loadConfig(opts)\n    if (config) {\n      queries = config\n    } else {\n      queries = browserslist.defaults\n    }\n  }\n\n  if (!(typeof queries === 'string' || Array.isArray(queries))) {\n    throw new BrowserslistError(\n      'Browser queries must be an array or string. Got ' + typeof queries + '.')\n  }\n\n  var context = {\n    ignoreUnknownVersions: opts.ignoreUnknownVersions,\n    dangerousExtend: opts.dangerousExtend,\n    mobileToDesktop: opts.mobileToDesktop,\n    path: opts.path,\n    env: opts.env\n  }\n\n  env.oldDataWarning(browserslist.data)\n  var stats = env.getStat(opts, browserslist.data)\n  if (stats) {\n    context.customUsage = { }\n    for (var browser in stats) {\n      fillUsage(context.customUsage, browser, stats[browser])\n    }\n  }\n\n  var cacheKey = JSON.stringify([queries, context])\n  if (cache[cacheKey]) return cache[cacheKey]\n\n  var result = uniq(resolve(queries, context)).sort(function (name1, name2) {\n    name1 = name1.split(' ')\n    name2 = name2.split(' ')\n    if (name1[0] === name2[0]) {\n      // assumptions on caniuse data\n      // 1) version ranges never overlaps\n      // 2) if version is not a range, it never contains `-`\n      var version1 = name1[1].split('-')[0]\n      var version2 = name2[1].split('-')[0]\n      return compareSemver(version2.split('.'), version1.split('.'))\n    } else {\n      return compare(name1[0], name2[0])\n    }\n  })\n  if (!process.env.BROWSERSLIST_DISABLE_CACHE) {\n    cache[cacheKey] = result\n  }\n  return result\n}\n\nfunction parse (queries) {\n  var qs = []\n  do {\n    queries = doMatch(queries, qs)\n  } while (queries)\n  return qs\n}\n\nfunction doMatch (string, qs) {\n  var or = /^(?:,\\s*|\\s+or\\s+)(.*)/i\n  var and = /^\\s+and\\s+(.*)/i\n\n  return find(string, function (parsed, n, max) {\n    if (and.test(parsed)) {\n      qs.unshift({ type: QUERY_AND, queryString: parsed.match(and)[1] })\n      return true\n    } else if (or.test(parsed)) {\n      qs.unshift({ type: QUERY_OR, queryString: parsed.match(or)[1] })\n      return true\n    } else if (n === max) {\n      qs.unshift({ type: QUERY_OR, queryString: parsed.trim() })\n      return true\n    }\n    return false\n  })\n}\n\nfunction find (string, predicate) {\n  for (var n = 1, max = string.length; n <= max; n++) {\n    var parsed = string.substr(-n, n)\n    if (predicate(parsed, n, max)) {\n      return string.slice(0, -n)\n    }\n  }\n  return ''\n}\n\nfunction flatten (array) {\n  if (!Array.isArray(array)) return [array]\n  return array.reduce(function (a, b) {\n    return a.concat(flatten(b))\n  }, [])\n}\n\n// Will be filled by Can I Use data below\nbrowserslist.cache = { }\nbrowserslist.data = { }\nbrowserslist.usage = {\n  global: { },\n  custom: null\n}\n\n// Default browsers query\nbrowserslist.defaults = [\n  '> 0.5%',\n  'last 2 versions',\n  'Firefox ESR',\n  'not dead'\n]\n\n// Browser names aliases\nbrowserslist.aliases = {\n  fx: 'firefox',\n  ff: 'firefox',\n  ios: 'ios_saf',\n  explorer: 'ie',\n  blackberry: 'bb',\n  explorermobile: 'ie_mob',\n  operamini: 'op_mini',\n  operamobile: 'op_mob',\n  chromeandroid: 'and_chr',\n  firefoxandroid: 'and_ff',\n  ucandroid: 'and_uc',\n  qqandroid: 'and_qq'\n}\n\n// Can I Use only provides a few versions for some browsers (e.g. and_chr).\n// Fallback to a similar browser for unknown versions\nbrowserslist.desktopNames = {\n  and_chr: 'chrome',\n  and_ff: 'firefox',\n  ie_mob: 'ie',\n  op_mob: 'opera',\n  android: 'chrome' // has extra processing logic\n}\n\n// Aliases to work with joined versions like `ios_saf 7.0-7.1`\nbrowserslist.versionAliases = { }\n\nbrowserslist.clearCaches = env.clearCaches\nbrowserslist.parseConfig = env.parseConfig\nbrowserslist.readConfig = env.readConfig\nbrowserslist.findConfig = env.findConfig\nbrowserslist.loadConfig = env.loadConfig\n\n/**\n * Return browsers market coverage.\n *\n * @param {string[]} browsers Browsers names in Can I Use.\n * @param {string|object} [stats=\"global\"] Which statistics should be used.\n *                                         Country code or custom statistics.\n *                                         Pass `\"my stats\"` to load statistics\n *                                         from Browserslist files.\n *\n * @return {number} Total market coverage for all selected browsers.\n *\n * @example\n * browserslist.coverage(browserslist('> 1% in US'), 'US') //=> 83.1\n */\nbrowserslist.coverage = function (browsers, stats) {\n  var data\n  if (typeof stats === 'undefined') {\n    data = browserslist.usage.global\n  } else if (stats === 'my stats') {\n    var opts = {}\n    opts.path = path.resolve ? path.resolve('.') : '.'\n    var customStats = env.getStat(opts)\n    if (!customStats) {\n      throw new BrowserslistError('Custom usage statistics was not provided')\n    }\n    data = {}\n    for (var browser in customStats) {\n      fillUsage(data, browser, customStats[browser])\n    }\n  } else if (typeof stats === 'string') {\n    if (stats.length > 2) {\n      stats = stats.toLowerCase()\n    } else {\n      stats = stats.toUpperCase()\n    }\n    env.loadCountry(browserslist.usage, stats, browserslist.data)\n    data = browserslist.usage[stats]\n  } else {\n    if ('dataByBrowser' in stats) {\n      stats = stats.dataByBrowser\n    }\n    data = { }\n    for (var name in stats) {\n      for (var version in stats[name]) {\n        data[name + ' ' + version] = stats[name][version]\n      }\n    }\n  }\n\n  return browsers.reduce(function (all, i) {\n    var usage = data[i]\n    if (usage === undefined) {\n      usage = data[i.replace(/ \\S+$/, ' 0')]\n    }\n    return all + (usage || 0)\n  }, 0)\n}\n\nvar QUERIES = [\n  {\n    regexp: /^last\\s+(\\d+)\\s+major\\s+versions?$/i,\n    select: function (context, versions) {\n      return Object.keys(agents).reduce(function (selected, name) {\n        var data = byName(name, context)\n        if (!data) return selected\n        var list = getMajorVersions(data.released, versions)\n        list = list.map(nameMapper(data.name))\n        if (data.name === 'android') {\n          list = filterAndroid(list, versions, context)\n        }\n        return selected.concat(list)\n      }, [])\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d+)\\s+versions?$/i,\n    select: function (context, versions) {\n      return Object.keys(agents).reduce(function (selected, name) {\n        var data = byName(name, context)\n        if (!data) return selected\n        var list = data.released.slice(-versions)\n        list = list.map(nameMapper(data.name))\n        if (data.name === 'android') {\n          list = filterAndroid(list, versions, context)\n        }\n        return selected.concat(list)\n      }, [])\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d+)\\s+electron\\s+major\\s+versions?$/i,\n    select: function (context, versions) {\n      var validVersions = getMajorVersions(Object.keys(e2c), versions)\n      return validVersions.map(function (i) {\n        return 'chrome ' + e2c[i]\n      })\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d+)\\s+(\\w+)\\s+major\\s+versions?$/i,\n    select: function (context, versions, name) {\n      var data = checkName(name, context)\n      var validVersions = getMajorVersions(data.released, versions)\n      var list = validVersions.map(nameMapper(data.name))\n      if (data.name === 'android') {\n        list = filterAndroid(list, versions, context)\n      }\n      return list\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d+)\\s+electron\\s+versions?$/i,\n    select: function (context, versions) {\n      return Object.keys(e2c).slice(-versions).map(function (i) {\n        return 'chrome ' + e2c[i]\n      })\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d+)\\s+(\\w+)\\s+versions?$/i,\n    select: function (context, versions, name) {\n      var data = checkName(name, context)\n      var list = data.released.slice(-versions).map(nameMapper(data.name))\n      if (data.name === 'android') {\n        list = filterAndroid(list, versions, context)\n      }\n      return list\n    }\n  },\n  {\n    regexp: /^unreleased\\s+versions$/i,\n    select: function (context) {\n      return Object.keys(agents).reduce(function (selected, name) {\n        var data = byName(name, context)\n        if (!data) return selected\n        var list = data.versions.filter(function (v) {\n          return data.released.indexOf(v) === -1\n        })\n        list = list.map(nameMapper(data.name))\n        return selected.concat(list)\n      }, [])\n    }\n  },\n  {\n    regexp: /^unreleased\\s+electron\\s+versions?$/i,\n    select: function () {\n      return []\n    }\n  },\n  {\n    regexp: /^unreleased\\s+(\\w+)\\s+versions?$/i,\n    select: function (context, name) {\n      var data = checkName(name, context)\n      return data.versions.filter(function (v) {\n        return data.released.indexOf(v) === -1\n      }).map(nameMapper(data.name))\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d*.?\\d+)\\s+years?$/i,\n    select: function (context, years) {\n      return filterByYear(Date.now() - YEAR * years, context)\n    }\n  },\n  {\n    regexp: /^since (\\d+)(?:-(\\d+))?(?:-(\\d+))?$/i,\n    select: function (context, year, month, date) {\n      year = parseInt(year)\n      month = parseInt(month || '01') - 1\n      date = parseInt(date || '01')\n      return filterByYear(Date.UTC(year, month, date, 0, 0, 0), context)\n    }\n  },\n  {\n    regexp: /^(>=?|<=?)\\s*(\\d*\\.?\\d+)%$/,\n    select: function (context, sign, popularity) {\n      popularity = parseFloat(popularity)\n      var usage = browserslist.usage.global\n      return Object.keys(usage).reduce(function (result, version) {\n        if (sign === '>') {\n          if (usage[version] > popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<') {\n          if (usage[version] < popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<=') {\n          if (usage[version] <= popularity) {\n            result.push(version)\n          }\n        } else if (usage[version] >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  {\n    regexp: /^(>=?|<=?)\\s*(\\d*\\.?\\d+)%\\s+in\\s+my\\s+stats$/,\n    select: function (context, sign, popularity) {\n      popularity = parseFloat(popularity)\n      if (!context.customUsage) {\n        throw new BrowserslistError('Custom usage statistics was not provided')\n      }\n      var usage = context.customUsage\n      return Object.keys(usage).reduce(function (result, version) {\n        if (sign === '>') {\n          if (usage[version] > popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<') {\n          if (usage[version] < popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<=') {\n          if (usage[version] <= popularity) {\n            result.push(version)\n          }\n        } else if (usage[version] >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  {\n    regexp: /^(>=?|<=?)\\s*(\\d*\\.?\\d+)%\\s+in\\s+(\\S+)\\s+stats$/,\n    select: function (context, sign, popularity, name) {\n      popularity = parseFloat(popularity)\n      var stats = env.loadStat(context, name, browserslist.data)\n      if (stats) {\n        context.customUsage = { }\n        for (var browser in stats) {\n          fillUsage(context.customUsage, browser, stats[browser])\n        }\n      }\n      if (!context.customUsage) {\n        throw new BrowserslistError('Custom usage statistics was not provided')\n      }\n      var usage = context.customUsage\n      return Object.keys(usage).reduce(function (result, version) {\n        if (sign === '>') {\n          if (usage[version] > popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<') {\n          if (usage[version] < popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<=') {\n          if (usage[version] <= popularity) {\n            result.push(version)\n          }\n        } else if (usage[version] >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  {\n    regexp: /^(>=?|<=?)\\s*(\\d*\\.?\\d+)%\\s+in\\s+((alt-)?\\w\\w)$/,\n    select: function (context, sign, popularity, place) {\n      popularity = parseFloat(popularity)\n      if (place.length === 2) {\n        place = place.toUpperCase()\n      } else {\n        place = place.toLowerCase()\n      }\n      env.loadCountry(browserslist.usage, place, browserslist.data)\n      var usage = browserslist.usage[place]\n      return Object.keys(usage).reduce(function (result, version) {\n        if (sign === '>') {\n          if (usage[version] > popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<') {\n          if (usage[version] < popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<=') {\n          if (usage[version] <= popularity) {\n            result.push(version)\n          }\n        } else if (usage[version] >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  {\n    regexp: /^cover\\s+(\\d*\\.?\\d+)%(\\s+in\\s+(my\\s+stats|(alt-)?\\w\\w))?$/,\n    select: function (context, coverage, statMode) {\n      coverage = parseFloat(coverage)\n      var usage = browserslist.usage.global\n      if (statMode) {\n        if (statMode.match(/^\\s+in\\s+my\\s+stats$/)) {\n          if (!context.customUsage) {\n            throw new BrowserslistError(\n              'Custom usage statistics was not provided'\n            )\n          }\n          usage = context.customUsage\n        } else {\n          var match = statMode.match(/\\s+in\\s+((alt-)?\\w\\w)/)\n          var place = match[1]\n          if (place.length === 2) {\n            place = place.toUpperCase()\n          } else {\n            place = place.toLowerCase()\n          }\n          env.loadCountry(browserslist.usage, place, browserslist.data)\n          usage = browserslist.usage[place]\n        }\n      }\n      var versions = Object.keys(usage).sort(function (a, b) {\n        return usage[b] - usage[a]\n      })\n      var coveraged = 0\n      var result = []\n      var version\n      for (var i = 0; i <= versions.length; i++) {\n        version = versions[i]\n        if (usage[version] === 0) break\n        coveraged += usage[version]\n        result.push(version)\n        if (coveraged >= coverage) break\n      }\n      return result\n    }\n  },\n  {\n    regexp: /^supports\\s+([\\w-]+)$/,\n    select: function (context, feature) {\n      env.loadFeature(browserslist.cache, feature)\n      var features = browserslist.cache[feature]\n      return Object.keys(features).reduce(function (result, version) {\n        var flags = features[version]\n        if (flags.indexOf('y') >= 0 || flags.indexOf('a') >= 0) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  {\n    regexp: /^electron\\s+([\\d.]+)\\s*-\\s*([\\d.]+)$/i,\n    select: function (context, from, to) {\n      var fromToUse = normalizeElectron(from)\n      var toToUse = normalizeElectron(to)\n      if (!e2c[fromToUse]) {\n        throw new BrowserslistError('Unknown version ' + from + ' of electron')\n      }\n      if (!e2c[toToUse]) {\n        throw new BrowserslistError('Unknown version ' + to + ' of electron')\n      }\n      from = parseFloat(from)\n      to = parseFloat(to)\n      return Object.keys(e2c).filter(function (i) {\n        var parsed = parseFloat(i)\n        return parsed >= from && parsed <= to\n      }).map(function (i) {\n        return 'chrome ' + e2c[i]\n      })\n    }\n  },\n  {\n    regexp: /^node\\s+([\\d.]+)\\s*-\\s*([\\d.]+)$/i,\n    select: function (context, from, to) {\n      var nodeVersions = jsReleases.filter(function (i) {\n        return i.name === 'nodejs'\n      }).map(function (i) {\n        return i.version\n      })\n      var semverRegExp = /^(0|[1-9]\\d*)(\\.(0|[1-9]\\d*)){0,2}$/\n      if (!semverRegExp.test(from)) {\n        throw new BrowserslistError(\n          'Unknown version ' + from + ' of Node.js')\n      }\n      if (!semverRegExp.test(to)) {\n        throw new BrowserslistError(\n          'Unknown version ' + to + ' of Node.js')\n      }\n      return nodeVersions\n        .filter(semverFilterLoose('>=', from))\n        .filter(semverFilterLoose('<=', to))\n        .map(function (v) {\n          return 'node ' + v\n        })\n    }\n  },\n  {\n    regexp: /^(\\w+)\\s+([\\d.]+)\\s*-\\s*([\\d.]+)$/i,\n    select: function (context, name, from, to) {\n      var data = checkName(name, context)\n      from = parseFloat(normalizeVersion(data, from) || from)\n      to = parseFloat(normalizeVersion(data, to) || to)\n      function filter (v) {\n        var parsed = parseFloat(v)\n        return parsed >= from && parsed <= to\n      }\n      return data.released.filter(filter).map(nameMapper(data.name))\n    }\n  },\n  {\n    regexp: /^electron\\s*(>=?|<=?)\\s*([\\d.]+)$/i,\n    select: function (context, sign, version) {\n      var versionToUse = normalizeElectron(version)\n      return Object.keys(e2c)\n        .filter(generateFilter(sign, versionToUse))\n        .map(function (i) {\n          return 'chrome ' + e2c[i]\n        })\n    }\n  },\n  {\n    regexp: /^node\\s*(>=?|<=?)\\s*([\\d.]+)$/i,\n    select: function (context, sign, version) {\n      var nodeVersions = jsReleases.filter(function (i) {\n        return i.name === 'nodejs'\n      }).map(function (i) {\n        return i.version\n      })\n      return nodeVersions\n        .filter(generateSemverFilter(sign, version))\n        .map(function (v) {\n          return 'node ' + v\n        })\n    }\n  },\n  {\n    regexp: /^(\\w+)\\s*(>=?|<=?)\\s*([\\d.]+)$/,\n    select: function (context, name, sign, version) {\n      var data = checkName(name, context)\n      var alias = browserslist.versionAliases[data.name][version]\n      if (alias) {\n        version = alias\n      }\n      return data.released\n        .filter(generateFilter(sign, version))\n        .map(function (v) {\n          return data.name + ' ' + v\n        })\n    }\n  },\n  {\n    regexp: /^(firefox|ff|fx)\\s+esr$/i,\n    select: function () {\n      return ['firefox 78']\n    }\n  },\n  {\n    regexp: /(operamini|op_mini)\\s+all/i,\n    select: function () {\n      return ['op_mini all']\n    }\n  },\n  {\n    regexp: /^electron\\s+([\\d.]+)$/i,\n    select: function (context, version) {\n      var versionToUse = normalizeElectron(version)\n      var chrome = e2c[versionToUse]\n      if (!chrome) {\n        throw new BrowserslistError(\n          'Unknown version ' + version + ' of electron')\n      }\n      return ['chrome ' + chrome]\n    }\n  },\n  {\n    regexp: /^node\\s+(\\d+(\\.\\d+)?(\\.\\d+)?)$/i,\n    select: function (context, version) {\n      var nodeReleases = jsReleases.filter(function (i) {\n        return i.name === 'nodejs'\n      })\n      var matched = nodeReleases.filter(function (i) {\n        return isVersionsMatch(i.version, version)\n      })\n      if (matched.length === 0) {\n        if (context.ignoreUnknownVersions) {\n          return []\n        } else {\n          throw new BrowserslistError(\n            'Unknown version ' + version + ' of Node.js')\n        }\n      }\n      return ['node ' + matched[matched.length - 1].version]\n    }\n  },\n  {\n    regexp: /^current\\s+node$/i,\n    select: function (context) {\n      return [env.currentNode(resolve, context)]\n    }\n  },\n  {\n    regexp: /^maintained\\s+node\\s+versions$/i,\n    select: function (context) {\n      var now = Date.now()\n      var queries = Object.keys(jsEOL).filter(function (key) {\n        return now < Date.parse(jsEOL[key].end) &&\n          now > Date.parse(jsEOL[key].start) &&\n          isEolReleased(key)\n      }).map(function (key) {\n        return 'node ' + key.slice(1)\n      })\n      return resolve(queries, context)\n    }\n  },\n  {\n    regexp: /^phantomjs\\s+1.9$/i,\n    select: function () {\n      return ['safari 5']\n    }\n  },\n  {\n    regexp: /^phantomjs\\s+2.1$/i,\n    select: function () {\n      return ['safari 6']\n    }\n  },\n  {\n    regexp: /^(\\w+)\\s+(tp|[\\d.]+)$/i,\n    select: function (context, name, version) {\n      if (/^tp$/i.test(version)) version = 'TP'\n      var data = checkName(name, context)\n      var alias = normalizeVersion(data, version)\n      if (alias) {\n        version = alias\n      } else {\n        if (version.indexOf('.') === -1) {\n          alias = version + '.0'\n        } else {\n          alias = version.replace(/\\.0$/, '')\n        }\n        alias = normalizeVersion(data, alias)\n        if (alias) {\n          version = alias\n        } else if (context.ignoreUnknownVersions) {\n          return []\n        } else {\n          throw new BrowserslistError(\n            'Unknown version ' + version + ' of ' + name)\n        }\n      }\n      return [data.name + ' ' + version]\n    }\n  },\n  {\n    regexp: /^browserslist config$/i,\n    select: function (context) {\n      return browserslist(undefined, context)\n    }\n  },\n  {\n    regexp: /^extends (.+)$/i,\n    select: function (context, name) {\n      return resolve(env.loadQueries(context, name), context)\n    }\n  },\n  {\n    regexp: /^defaults$/i,\n    select: function (context) {\n      return resolve(browserslist.defaults, context)\n    }\n  },\n  {\n    regexp: /^dead$/i,\n    select: function (context) {\n      var dead = [\n        'ie <= 10',\n        'ie_mob <= 11',\n        'bb <= 10',\n        'op_mob <= 12.1',\n        'samsung 4'\n      ]\n      return resolve(dead, context)\n    }\n  },\n  {\n    regexp: /^(\\w+)$/i,\n    select: function (context, name) {\n      if (byName(name, context)) {\n        throw new BrowserslistError(\n          'Specify versions in Browserslist query for browser ' + name)\n      } else {\n        throw unknownQuery(name)\n      }\n    }\n  }\n];\n\n// Get and convert Can I Use data\n\n(function () {\n  for (var name in agents) {\n    var browser = agents[name]\n    browserslist.data[name] = {\n      name: name,\n      versions: normalize(agents[name].versions),\n      released: normalize(agents[name].versions.slice(0, -3)),\n      releaseDate: agents[name].release_date\n    }\n    fillUsage(browserslist.usage.global, name, browser.usage_global)\n\n    browserslist.versionAliases[name] = { }\n    for (var i = 0; i < browser.versions.length; i++) {\n      var full = browser.versions[i]\n      if (!full) continue\n\n      if (full.indexOf('-') !== -1) {\n        var interval = full.split('-')\n        for (var j = 0; j < interval.length; j++) {\n          browserslist.versionAliases[name][interval[j]] = full\n        }\n      }\n    }\n  }\n\n  browserslist.versionAliases.op_mob['59'] = '58'\n}())\n\nmodule.exports = browserslist\n", "{\n  \"name\": \"browserslist\",\n  \"version\": \"4.16.3\",\n  \"description\": \"Share target browsers between different front-end tools, like Autoprefixer, Stylelint and babel-env-preset\",\n  \"keywords\": [\n    \"caniuse\",\n    \"browsers\",\n    \"target\"\n  ],\n  \"funding\": {\n    \"type\": \"opencollective\",\n    \"url\": \"https://opencollective.com/browserslist\"\n  },\n  \"author\": \"Andrey Sitnik <andrey@sitnik.ru>\",\n  \"license\": \"MIT\",\n  \"repository\": \"browserslist/browserslist\",\n  \"scripts\": {\n    \"test\": \"jest --coverage && eslint . && check-dts && size-limit && yaspeller *.md\"\n  },\n  \"dependencies\": {\n    \"caniuse-lite\": \"^1.0.30001207\",\n    \"colorette\": \"^1.2.2\",\n    \"electron-to-chromium\": \"^1.3.710\",\n    \"escalade\": \"^3.1.1\",\n    \"node-releases\": \"^1.1.71\"\n  },\n  \"engines\": {\n    \"node\": \"^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7\"\n  },\n  \"bin\": {\n    \"browserslist\": \"cli.js\"\n  },\n  \"types\": \"./index.d.ts\",\n  \"devDependencies\": {\n    \"@logux/eslint-config\": \"^35.0.4\",\n    \"@logux/sharec-config\": \"^0.5.7\",\n    \"@size-limit/preset-small-lib\": \"^4.10.2\",\n    \"@types/cross-spawn\": \"^6.0.2\",\n    \"@types/fs-extra\": \"^9.0.10\",\n    \"@types/jest\": \"^26.0.22\",\n    \"check-dts\": \"^0.4.4\",\n    \"clean-publish\": \"^2.1.1\",\n    \"cross-spawn\": \"^7.0.3\",\n    \"eslint\": \"^6.8.0\",\n    \"eslint-config-standard\": \"^14.1.1\",\n    \"eslint-plugin-es5\": \"^1.5.0\",\n    \"eslint-plugin-import\": \"^2.22.1\",\n    \"eslint-plugin-jest\": \"^23.18.0\",\n    \"eslint-plugin-node\": \"^11.1.0\",\n    \"eslint-plugin-prefer-let\": \"^1.1.0\",\n    \"eslint-plugin-promise\": \"^4.2.1\",\n    \"eslint-plugin-security\": \"^1.4.0\",\n    \"eslint-plugin-standard\": \"^4.0.2\",\n    \"eslint-plugin-unicorn\": \"^16.1.1\",\n    \"fs-extra\": \"^8.1.0\",\n    \"jest\": \"^25.5.4\",\n    \"lint-staged\": \"^10.5.4\",\n    \"nanoid\": \"^3.1.22\",\n    \"simple-git-hooks\": \"^2.3.1\",\n    \"size-limit\": \"^4.10.2\",\n    \"ts-jest\": \"^25.5.1\",\n    \"typescript\": \"^3.9.4\",\n    \"yaspeller\": \"^7.0.0\"\n  },\n  \"browser\": {\n    \"./node.js\": \"./browser.js\",\n    \"path\": false\n  },\n  \"simple-git-hooks\": {\n    \"pre-commit\": \"npx lint-staged\"\n  },\n  \"jest\": {\n    \"preset\": \"ts-jest\",\n    \"testEnvironment\": \"node\",\n    \"coverageThreshold\": {\n      \"global\": {\n        \"statements\": 100\n      }\n    },\n    \"modulePathIgnorePatterns\": [\n      \"<rootDir>/test/fixtures\"\n    ]\n  },\n  \"size-limit\": [\n    {\n      \"path\": \"index.js\",\n      \"limit\": \"14 KB\"\n    }\n  ],\n  \"lint-staged\": {\n    \"*.md\": \"yaspeller\",\n    \"*.js\": \"eslint\"\n  },\n  \"eslintConfig\": {\n    \"extends\": \"@logux/eslint-config/browser\",\n    \"rules\": {\n      \"security/detect-unsafe-regex\": \"off\",\n      \"global-require\": \"off\"\n    }\n  },\n  \"eslintIgnore\": [\n    \"test/fixtures\"\n  ],\n  \"yaspeller\": {\n    \"lang\": \"en\",\n    \"ignoreCapitalization\": true,\n    \"ignoreText\": [\n      \" \\\\(by [^)]+\\\\).\"\n    ],\n    \"dictionary\": [\n      \"albiventris\",\n      \"algirus\",\n      \"amurensis\",\n      \"Atelerix\",\n      \"Autoprefixer\",\n      \"Baidu\",\n      \"Browserify\",\n      \"Browserslist\",\n      \"Browserslist\u2019s\",\n      \"BrowserStack\",\n      \"CLI\",\n      \"compat\",\n      \"configs\",\n      \"Configs\",\n      \"DynJS\",\n      \"env\",\n      \"Erinaceus\",\n      \"eslint\",\n      \"ESR\",\n      \"frontalis\",\n      \"GitHub\",\n      \"iOS\",\n      \"JS\",\n      \"js\",\n      \"JSDoc\",\n      \"jspm\",\n      \"KaiOS\",\n      \"npm\",\n      \"postcss\",\n      \"QQ\",\n      \"RegExp\",\n      \"sclateri\",\n      \"stylelint\",\n      \"symlink\",\n      \"Tidelift\",\n      \"TP\",\n      \"UC\",\n      \"unreleased\",\n      \"useragent\",\n      \"Versioning\",\n      \"webpack\",\n      \"WebView\",\n      \"browserslist\",\n      \"PhantomJS\",\n      \"maintainers\",\n      \"ES\",\n      \"deduplication\",\n      \"pnpm\",\n      \"VS\"\n    ]\n  },\n  \"sharec\": {\n    \"config\": \"@logux/sharec-config\",\n    \"version\": \"0.5.7\"\n  }\n}\n", "import browserslist from '../'\n\nit('selects Node.js version', () => {\n  expect(browserslist('node 7.5.0')).toEqual(['node 7.5.0'])\n})\n\nit('supports case insensitive Node.js name', () => {\n  expect(browserslist('Node 7.5.0')).toEqual(['node 7.5.0'])\n})\n\nit('throws on unknown Node.js version', () => {\n  expect(() => {\n    browserslist('node 3')\n  }).toThrow(/Unknown version/)\n})\n\nit('throws on malformed Node.js version', () => {\n  expect(() => {\n    browserslist('node 8.a')\n  }).toThrow(/Unknown/)\n  expect(() => {\n    browserslist('node 8.8.8.8')\n  }).toThrow(/Unknown/)\n  expect(() => {\n    browserslist('node 8.01')\n  }).toThrow(/Unknown/)\n  expect(() => {\n    browserslist('node 6 - 8.a')\n  }).toThrow(/Unknown/)\n  expect(() => {\n    browserslist('node 6.6.6.6 - 8')\n  }).toThrow(/Unknown/)\n  expect(() => {\n    browserslist('node 6 - 8.01')\n  }).toThrow(/Unknown/)\n})\n\nit('return empty array on unknown Node.js version with special flag', () => {\n  expect(browserslist('node 3', { ignoreUnknownVersions: true })).toEqual([])\n})\n\nit('supports selection of Node.js version by major.minor query', () => {\n  expect(browserslist('node 5.1')).toEqual(['node 5.1.0'])\n})\n\nit('supports selection of Node.js version by major version only', () => {\n  expect(browserslist('node 5')).toEqual(['node 5.12.0'])\n})\n\nit('selects maintained Node.js versions', () => {\n  expect(Array.isArray(browserslist('maintained node versions'))).toBe(true)\n})\n\nit('supports case insensitive query for maintained Node.js versions', () => {\n  expect(Array.isArray(browserslist('maintained Node versions'))).toBe(true)\n})\n\nit('supports current node version', () => {\n  let versions = browserslist('current node')\n  expect(versions).toHaveLength(1)\n  expect(versions[0]).toMatch(/node \\d+\\.\\d+\\.\\d+/)\n})\n\nit('supports comparison operator', () => {\n  expect(browserslist('node <= 5')).toEqual([\n    'node 5.0.0',\n\n    'node 4.9.0',\n    'node 4.8.0',\n    'node 4.7.0',\n    'node 4.6.0',\n    'node 4.5.0',\n    'node 4.4.0',\n    'node 4.3.0',\n    'node 4.2.0',\n    'node 4.1.0',\n    'node 4.0.0',\n\n    'node 0.12.0',\n    'node 0.11.0',\n    'node 0.10.0',\n    'node 0.9.0',\n    'node 0.8.0',\n    'node 0.7.0',\n    'node 0.6.0',\n    'node 0.5.0',\n    'node 0.4.0',\n    'node 0.3.0',\n    'node 0.2.0'\n  ])\n\n  expect(browserslist('node < 5')).toEqual([\n    'node 4.9.0',\n    'node 4.8.0',\n    'node 4.7.0',\n    'node 4.6.0',\n    'node 4.5.0',\n    'node 4.4.0',\n    'node 4.3.0',\n    'node 4.2.0',\n    'node 4.1.0',\n    'node 4.0.0',\n\n    'node 0.12.0',\n    'node 0.11.0',\n    'node 0.10.0',\n    'node 0.9.0',\n    'node 0.8.0',\n    'node 0.7.0',\n    'node 0.6.0',\n    'node 0.5.0',\n    'node 0.4.0',\n    'node 0.3.0',\n    'node 0.2.0'\n  ])\n\n  expect(browserslist('Node <= 5')).toHaveLength(22)\n\n  expect(browserslist('node >= 9')).toEqual(expect.arrayContaining([\n    'node 9.0.0',\n    'node 9.1.0',\n    'node 9.2.0',\n    'node 9.3.0',\n    'node 9.4.0',\n    'node 9.5.0',\n    'node 9.6.0',\n    'node 9.7.0',\n    'node 9.8.0',\n    'node 9.9.0',\n    'node 9.10.0',\n    'node 9.11.0',\n\n    'node 10.0.0',\n    'node 10.1.0',\n    'node 10.2.0',\n    'node 10.3.0',\n    'node 10.4.0',\n    'node 10.5.0',\n    'node 10.6.0',\n    'node 10.7.0',\n    'node 10.8.0',\n    'node 10.9.0',\n    'node 10.10.0',\n    'node 10.11.0',\n    'node 10.12.0',\n    'node 10.13.0',\n    'node 10.14.0',\n    'node 10.15.0',\n\n    'node 11.0.0',\n    'node 11.1.0',\n    'node 11.2.0',\n    'node 11.3.0',\n    'node 11.4.0',\n    'node 11.5.0',\n    'node 11.6.0',\n    'node 11.7.0',\n    'node 11.8.0',\n    'node 11.9.0',\n    'node 11.10.0'\n  ]))\n\n  expect(browserslist('node > 9')).toEqual(expect.arrayContaining([\n    'node 9.1.0',\n    'node 9.2.0',\n    'node 9.3.0',\n    'node 9.4.0',\n    'node 9.5.0',\n    'node 9.6.0',\n    'node 9.7.0',\n    'node 9.8.0',\n    'node 9.9.0',\n    'node 9.10.0',\n    'node 9.11.0',\n\n    'node 10.0.0',\n    'node 10.1.0',\n    'node 10.2.0',\n    'node 10.3.0',\n    'node 10.4.0',\n    'node 10.5.0',\n    'node 10.6.0',\n    'node 10.7.0',\n    'node 10.8.0',\n    'node 10.9.0',\n    'node 10.10.0',\n    'node 10.11.0',\n    'node 10.12.0',\n    'node 10.13.0',\n    'node 10.14.0',\n    'node 10.15.0',\n\n    'node 11.0.0',\n    'node 11.1.0',\n    'node 11.2.0',\n    'node 11.3.0',\n    'node 11.4.0',\n    'node 11.5.0',\n    'node 11.6.0',\n    'node 11.7.0',\n    'node 11.8.0',\n    'node 11.9.0',\n    'node 11.10.0'\n  ]))\n})\n\nit('supports range selection', () => {\n  expect(browserslist('node 4-6')).toEqual([\n    'node 6.17.0',\n    'node 6.16.0',\n    'node 6.15.0',\n    'node 6.14.0',\n    'node 6.13.0',\n    'node 6.12.0',\n    'node 6.11.0',\n    'node 6.10.0',\n    'node 6.9.0',\n    'node 6.8.0',\n    'node 6.7.0',\n    'node 6.6.0',\n    'node 6.5.0',\n    'node 6.4.0',\n    'node 6.3.0',\n    'node 6.2.0',\n    'node 6.1.0',\n    'node 6.0.0',\n\n    'node 5.12.0',\n    'node 5.11.0',\n    'node 5.10.0',\n    'node 5.9.0',\n    'node 5.8.0',\n    'node 5.7.0',\n    'node 5.6.0',\n    'node 5.5.0',\n    'node 5.4.0',\n    'node 5.3.0',\n    'node 5.2.0',\n    'node 5.1.0',\n    'node 5.0.0',\n\n    'node 4.9.0',\n    'node 4.8.0',\n    'node 4.7.0',\n    'node 4.6.0',\n    'node 4.5.0',\n    'node 4.4.0',\n    'node 4.3.0',\n    'node 4.2.0',\n    'node 4.1.0',\n    'node 4.0.0'\n  ])\n\n  expect(browserslist('node 4-6.0.0')).toEqual([\n    'node 6.0.0',\n\n    'node 5.12.0',\n    'node 5.11.0',\n    'node 5.10.0',\n    'node 5.9.0',\n    'node 5.8.0',\n    'node 5.7.0',\n    'node 5.6.0',\n    'node 5.5.0',\n    'node 5.4.0',\n    'node 5.3.0',\n    'node 5.2.0',\n    'node 5.1.0',\n    'node 5.0.0',\n\n    'node 4.9.0',\n    'node 4.8.0',\n    'node 4.7.0',\n    'node 4.6.0',\n    'node 4.5.0',\n    'node 4.4.0',\n    'node 4.3.0',\n    'node 4.2.0',\n    'node 4.1.0',\n    'node 4.0.0'\n  ])\n\n  expect(browserslist('node 6.5-7.5')).toEqual([\n    'node 7.5.0',\n    'node 7.4.0',\n    'node 7.3.0',\n    'node 7.2.0',\n    'node 7.1.0',\n    'node 7.0.0',\n\n    'node 6.17.0',\n    'node 6.16.0',\n    'node 6.15.0',\n    'node 6.14.0',\n    'node 6.13.0',\n    'node 6.12.0',\n    'node 6.11.0',\n    'node 6.10.0',\n    'node 6.9.0',\n    'node 6.8.0',\n    'node 6.7.0',\n    'node 6.6.0',\n    'node 6.5.0'\n  ])\n\n  expect(browserslist('node 6.6.4-7.7.5')).toEqual([\n    'node 7.7.0',\n    'node 7.6.0',\n    'node 7.5.0',\n    'node 7.4.0',\n    'node 7.3.0',\n    'node 7.2.0',\n    'node 7.1.0',\n    'node 7.0.0',\n\n    'node 6.17.0',\n    'node 6.16.0',\n    'node 6.15.0',\n    'node 6.14.0',\n    'node 6.13.0',\n    'node 6.12.0',\n    'node 6.11.0',\n    'node 6.10.0',\n    'node 6.9.0',\n    'node 6.8.0',\n    'node 6.7.0',\n    // include 6.6.0 as patch versions are ignored\n    'node 6.6.0'\n  ])\n})\n"], "fixing_code": ["var jsReleases = require('node-releases/data/processed/envs.json')\nvar agents = require('caniuse-lite/dist/unpacker/agents').agents\nvar jsEOL = require('node-releases/data/release-schedule/release-schedule.json')\nvar path = require('path')\nvar e2c = require('electron-to-chromium/versions')\n\nvar BrowserslistError = require('./error')\nvar env = require('./node') // Will load browser.js in webpack\n\nvar YEAR = 365.259641 * 24 * 60 * 60 * 1000\nvar ANDROID_EVERGREEN_FIRST = 37\n\nvar QUERY_OR = 1\nvar QUERY_AND = 2\n\nfunction isVersionsMatch (versionA, versionB) {\n  return (versionA + '.').indexOf(versionB + '.') === 0\n}\n\nfunction isEolReleased (name) {\n  var version = name.slice(1)\n  return jsReleases.some(function (i) {\n    return isVersionsMatch(i.version, version)\n  })\n}\n\nfunction normalize (versions) {\n  return versions.filter(function (version) {\n    return typeof version === 'string'\n  })\n}\n\nfunction normalizeElectron (version) {\n  var versionToUse = version\n  if (version.split('.').length === 3) {\n    versionToUse = version\n      .split('.')\n      .slice(0, -1)\n      .join('.')\n  }\n  return versionToUse\n}\n\nfunction nameMapper (name) {\n  return function mapName (version) {\n    return name + ' ' + version\n  }\n}\n\nfunction getMajor (version) {\n  return parseInt(version.split('.')[0])\n}\n\nfunction getMajorVersions (released, number) {\n  if (released.length === 0) return []\n  var majorVersions = uniq(released.map(getMajor))\n  var minimum = majorVersions[majorVersions.length - number]\n  if (!minimum) {\n    return released\n  }\n  var selected = []\n  for (var i = released.length - 1; i >= 0; i--) {\n    if (minimum > getMajor(released[i])) break\n    selected.unshift(released[i])\n  }\n  return selected\n}\n\nfunction uniq (array) {\n  var filtered = []\n  for (var i = 0; i < array.length; i++) {\n    if (filtered.indexOf(array[i]) === -1) filtered.push(array[i])\n  }\n  return filtered\n}\n\n// Helpers\n\nfunction fillUsage (result, name, data) {\n  for (var i in data) {\n    result[name + ' ' + i] = data[i]\n  }\n}\n\nfunction generateFilter (sign, version) {\n  version = parseFloat(version)\n  if (sign === '>') {\n    return function (v) {\n      return parseFloat(v) > version\n    }\n  } else if (sign === '>=') {\n    return function (v) {\n      return parseFloat(v) >= version\n    }\n  } else if (sign === '<') {\n    return function (v) {\n      return parseFloat(v) < version\n    }\n  } else {\n    return function (v) {\n      return parseFloat(v) <= version\n    }\n  }\n}\n\nfunction generateSemverFilter (sign, version) {\n  version = version.split('.').map(parseSimpleInt)\n  version[1] = version[1] || 0\n  version[2] = version[2] || 0\n  if (sign === '>') {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(v, version) > 0\n    }\n  } else if (sign === '>=') {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(v, version) >= 0\n    }\n  } else if (sign === '<') {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(version, v) > 0\n    }\n  } else {\n    return function (v) {\n      v = v.split('.').map(parseSimpleInt)\n      return compareSemver(version, v) >= 0\n    }\n  }\n}\n\nfunction parseSimpleInt (x) {\n  return parseInt(x)\n}\n\nfunction compare (a, b) {\n  if (a < b) return -1\n  if (a > b) return +1\n  return 0\n}\n\nfunction compareSemver (a, b) {\n  return (\n    compare(parseInt(a[0]), parseInt(b[0])) ||\n    compare(parseInt(a[1] || '0'), parseInt(b[1] || '0')) ||\n    compare(parseInt(a[2] || '0'), parseInt(b[2] || '0'))\n  )\n}\n\n// this follows the npm-like semver behavior\nfunction semverFilterLoose (operator, range) {\n  range = range.split('.').map(parseSimpleInt)\n  if (typeof range[1] === 'undefined') {\n    range[1] = 'x'\n  }\n  // ignore any patch version because we only return minor versions\n  // range[2] = 'x'\n  switch (operator) {\n    case '<=':\n      return function (version) {\n        version = version.split('.').map(parseSimpleInt)\n        return compareSemverLoose(version, range) <= 0\n      }\n    default:\n    case '>=':\n      return function (version) {\n        version = version.split('.').map(parseSimpleInt)\n        return compareSemverLoose(version, range) >= 0\n      }\n  }\n}\n\n// this follows the npm-like semver behavior\nfunction compareSemverLoose (version, range) {\n  if (version[0] !== range[0]) {\n    return version[0] < range[0] ? -1 : +1\n  }\n  if (range[1] === 'x') {\n    return 0\n  }\n  if (version[1] !== range[1]) {\n    return version[1] < range[1] ? -1 : +1\n  }\n  return 0\n}\n\nfunction resolveVersion (data, version) {\n  if (data.versions.indexOf(version) !== -1) {\n    return version\n  } else if (browserslist.versionAliases[data.name][version]) {\n    return browserslist.versionAliases[data.name][version]\n  } else {\n    return false\n  }\n}\n\nfunction normalizeVersion (data, version) {\n  var resolved = resolveVersion(data, version)\n  if (resolved) {\n    return resolved\n  } else if (data.versions.length === 1) {\n    return data.versions[0]\n  } else {\n    return false\n  }\n}\n\nfunction filterByYear (since, context) {\n  since = since / 1000\n  return Object.keys(agents).reduce(function (selected, name) {\n    var data = byName(name, context)\n    if (!data) return selected\n    var versions = Object.keys(data.releaseDate).filter(function (v) {\n      return data.releaseDate[v] >= since\n    })\n    return selected.concat(versions.map(nameMapper(data.name)))\n  }, [])\n}\n\nfunction cloneData (data) {\n  return {\n    name: data.name,\n    versions: data.versions,\n    released: data.released,\n    releaseDate: data.releaseDate\n  }\n}\n\nfunction mapVersions (data, map) {\n  data.versions = data.versions.map(function (i) {\n    return map[i] || i\n  })\n  data.released = data.versions.map(function (i) {\n    return map[i] || i\n  })\n  var fixedDate = { }\n  for (var i in data.releaseDate) {\n    fixedDate[map[i] || i] = data.releaseDate[i]\n  }\n  data.releaseDate = fixedDate\n  return data\n}\n\nfunction byName (name, context) {\n  name = name.toLowerCase()\n  name = browserslist.aliases[name] || name\n  if (context.mobileToDesktop && browserslist.desktopNames[name]) {\n    var desktop = browserslist.data[browserslist.desktopNames[name]]\n    if (name === 'android') {\n      return normalizeAndroidData(cloneData(browserslist.data[name]), desktop)\n    } else {\n      var cloned = cloneData(desktop)\n      cloned.name = name\n      if (name === 'op_mob') {\n        cloned = mapVersions(cloned, { '10.0-10.1': '10' })\n      }\n      return cloned\n    }\n  }\n  return browserslist.data[name]\n}\n\nfunction normalizeAndroidVersions (androidVersions, chromeVersions) {\n  var firstEvergreen = ANDROID_EVERGREEN_FIRST\n  var last = chromeVersions[chromeVersions.length - 1]\n  return androidVersions\n    .filter(function (version) { return /^(?:[2-4]\\.|[34]$)/.test(version) })\n    .concat(chromeVersions.slice(firstEvergreen - last - 1))\n}\n\nfunction normalizeAndroidData (android, chrome) {\n  android.released = normalizeAndroidVersions(android.released, chrome.released)\n  android.versions = normalizeAndroidVersions(android.versions, chrome.versions)\n  return android\n}\n\nfunction checkName (name, context) {\n  var data = byName(name, context)\n  if (!data) throw new BrowserslistError('Unknown browser ' + name)\n  return data\n}\n\nfunction unknownQuery (query) {\n  return new BrowserslistError(\n    'Unknown browser query `' + query + '`. ' +\n    'Maybe you are using old Browserslist or made typo in query.'\n  )\n}\n\nfunction filterAndroid (list, versions, context) {\n  if (context.mobileToDesktop) return list\n  var released = browserslist.data.android.released\n  var last = released[released.length - 1]\n  var diff = last - ANDROID_EVERGREEN_FIRST - versions\n  if (diff > 0) {\n    return list.slice(-1)\n  } else {\n    return list.slice(diff - 1)\n  }\n}\n\n/**\n * Resolves queries into a browser list.\n * @param {string|string[]} queries Queries to combine.\n * Either an array of queries or a long string of queries.\n * @param {object} [context] Optional arguments to\n * the select function in `queries`.\n * @returns {string[]} A list of browsers\n */\nfunction resolve (queries, context) {\n  if (Array.isArray(queries)) {\n    queries = flatten(queries.map(parse))\n  } else {\n    queries = parse(queries)\n  }\n\n  return queries.reduce(function (result, query, index) {\n    var selection = query.queryString\n\n    var isExclude = selection.indexOf('not ') === 0\n    if (isExclude) {\n      if (index === 0) {\n        throw new BrowserslistError(\n          'Write any browsers query (for instance, `defaults`) ' +\n          'before `' + selection + '`')\n      }\n      selection = selection.slice(4)\n    }\n\n    for (var i = 0; i < QUERIES.length; i++) {\n      var type = QUERIES[i]\n      var match = selection.match(type.regexp)\n      if (match) {\n        var args = [context].concat(match.slice(1))\n        var array = type.select.apply(browserslist, args).map(function (j) {\n          var parts = j.split(' ')\n          if (parts[1] === '0') {\n            return parts[0] + ' ' + byName(parts[0], context).versions[0]\n          } else {\n            return j\n          }\n        })\n\n        switch (query.type) {\n          case QUERY_AND:\n            if (isExclude) {\n              return result.filter(function (j) {\n                return array.indexOf(j) === -1\n              })\n            } else {\n              return result.filter(function (j) {\n                return array.indexOf(j) !== -1\n              })\n            }\n          case QUERY_OR:\n          default:\n            if (isExclude) {\n              var filter = { }\n              array.forEach(function (j) {\n                filter[j] = true\n              })\n              return result.filter(function (j) {\n                return !filter[j]\n              })\n            }\n            return result.concat(array)\n        }\n      }\n    }\n\n    throw unknownQuery(selection)\n  }, [])\n}\n\nvar cache = { }\n\n/**\n * Return array of browsers by selection queries.\n *\n * @param {(string|string[])} [queries=browserslist.defaults] Browser queries.\n * @param {object} [opts] Options.\n * @param {string} [opts.path=\".\"] Path to processed file.\n *                                 It will be used to find config files.\n * @param {string} [opts.env=\"production\"] Processing environment.\n *                                         It will be used to take right\n *                                         queries from config file.\n * @param {string} [opts.config] Path to config file with queries.\n * @param {object} [opts.stats] Custom browser usage statistics\n *                              for \"> 1% in my stats\" query.\n * @param {boolean} [opts.ignoreUnknownVersions=false] Do not throw on unknown\n *                                                     version in direct query.\n * @param {boolean} [opts.dangerousExtend] Disable security checks\n *                                         for extend query.\n * @param {boolean} [opts.mobileToDesktop] Alias mobile browsers to the desktop\n *                                         version when Can I Use doesn't have\n *                                         data about the specified version.\n * @returns {string[]} Array with browser names in Can I Use.\n *\n * @example\n * browserslist('IE >= 10, IE 8') //=> ['ie 11', 'ie 10', 'ie 8']\n */\nfunction browserslist (queries, opts) {\n  if (typeof opts === 'undefined') opts = { }\n\n  if (typeof opts.path === 'undefined') {\n    opts.path = path.resolve ? path.resolve('.') : '.'\n  }\n\n  if (typeof queries === 'undefined' || queries === null) {\n    var config = browserslist.loadConfig(opts)\n    if (config) {\n      queries = config\n    } else {\n      queries = browserslist.defaults\n    }\n  }\n\n  if (!(typeof queries === 'string' || Array.isArray(queries))) {\n    throw new BrowserslistError(\n      'Browser queries must be an array or string. Got ' + typeof queries + '.')\n  }\n\n  var context = {\n    ignoreUnknownVersions: opts.ignoreUnknownVersions,\n    dangerousExtend: opts.dangerousExtend,\n    mobileToDesktop: opts.mobileToDesktop,\n    path: opts.path,\n    env: opts.env\n  }\n\n  env.oldDataWarning(browserslist.data)\n  var stats = env.getStat(opts, browserslist.data)\n  if (stats) {\n    context.customUsage = { }\n    for (var browser in stats) {\n      fillUsage(context.customUsage, browser, stats[browser])\n    }\n  }\n\n  var cacheKey = JSON.stringify([queries, context])\n  if (cache[cacheKey]) return cache[cacheKey]\n\n  var result = uniq(resolve(queries, context)).sort(function (name1, name2) {\n    name1 = name1.split(' ')\n    name2 = name2.split(' ')\n    if (name1[0] === name2[0]) {\n      // assumptions on caniuse data\n      // 1) version ranges never overlaps\n      // 2) if version is not a range, it never contains `-`\n      var version1 = name1[1].split('-')[0]\n      var version2 = name2[1].split('-')[0]\n      return compareSemver(version2.split('.'), version1.split('.'))\n    } else {\n      return compare(name1[0], name2[0])\n    }\n  })\n  if (!process.env.BROWSERSLIST_DISABLE_CACHE) {\n    cache[cacheKey] = result\n  }\n  return result\n}\n\nfunction parse (queries) {\n  var qs = []\n  do {\n    queries = doMatch(queries, qs)\n  } while (queries)\n  return qs\n}\n\nfunction doMatch (string, qs) {\n  var or = /^(?:,\\s*|\\s+or\\s+)(.*)/i\n  var and = /^\\s+and\\s+(.*)/i\n\n  return find(string, function (parsed, n, max) {\n    if (and.test(parsed)) {\n      qs.unshift({ type: QUERY_AND, queryString: parsed.match(and)[1] })\n      return true\n    } else if (or.test(parsed)) {\n      qs.unshift({ type: QUERY_OR, queryString: parsed.match(or)[1] })\n      return true\n    } else if (n === max) {\n      qs.unshift({ type: QUERY_OR, queryString: parsed.trim() })\n      return true\n    }\n    return false\n  })\n}\n\nfunction find (string, predicate) {\n  for (var n = 1, max = string.length; n <= max; n++) {\n    var parsed = string.substr(-n, n)\n    if (predicate(parsed, n, max)) {\n      return string.slice(0, -n)\n    }\n  }\n  return ''\n}\n\nfunction flatten (array) {\n  if (!Array.isArray(array)) return [array]\n  return array.reduce(function (a, b) {\n    return a.concat(flatten(b))\n  }, [])\n}\n\n// Will be filled by Can I Use data below\nbrowserslist.cache = { }\nbrowserslist.data = { }\nbrowserslist.usage = {\n  global: { },\n  custom: null\n}\n\n// Default browsers query\nbrowserslist.defaults = [\n  '> 0.5%',\n  'last 2 versions',\n  'Firefox ESR',\n  'not dead'\n]\n\n// Browser names aliases\nbrowserslist.aliases = {\n  fx: 'firefox',\n  ff: 'firefox',\n  ios: 'ios_saf',\n  explorer: 'ie',\n  blackberry: 'bb',\n  explorermobile: 'ie_mob',\n  operamini: 'op_mini',\n  operamobile: 'op_mob',\n  chromeandroid: 'and_chr',\n  firefoxandroid: 'and_ff',\n  ucandroid: 'and_uc',\n  qqandroid: 'and_qq'\n}\n\n// Can I Use only provides a few versions for some browsers (e.g. and_chr).\n// Fallback to a similar browser for unknown versions\nbrowserslist.desktopNames = {\n  and_chr: 'chrome',\n  and_ff: 'firefox',\n  ie_mob: 'ie',\n  op_mob: 'opera',\n  android: 'chrome' // has extra processing logic\n}\n\n// Aliases to work with joined versions like `ios_saf 7.0-7.1`\nbrowserslist.versionAliases = { }\n\nbrowserslist.clearCaches = env.clearCaches\nbrowserslist.parseConfig = env.parseConfig\nbrowserslist.readConfig = env.readConfig\nbrowserslist.findConfig = env.findConfig\nbrowserslist.loadConfig = env.loadConfig\n\n/**\n * Return browsers market coverage.\n *\n * @param {string[]} browsers Browsers names in Can I Use.\n * @param {string|object} [stats=\"global\"] Which statistics should be used.\n *                                         Country code or custom statistics.\n *                                         Pass `\"my stats\"` to load statistics\n *                                         from Browserslist files.\n *\n * @return {number} Total market coverage for all selected browsers.\n *\n * @example\n * browserslist.coverage(browserslist('> 1% in US'), 'US') //=> 83.1\n */\nbrowserslist.coverage = function (browsers, stats) {\n  var data\n  if (typeof stats === 'undefined') {\n    data = browserslist.usage.global\n  } else if (stats === 'my stats') {\n    var opts = {}\n    opts.path = path.resolve ? path.resolve('.') : '.'\n    var customStats = env.getStat(opts)\n    if (!customStats) {\n      throw new BrowserslistError('Custom usage statistics was not provided')\n    }\n    data = {}\n    for (var browser in customStats) {\n      fillUsage(data, browser, customStats[browser])\n    }\n  } else if (typeof stats === 'string') {\n    if (stats.length > 2) {\n      stats = stats.toLowerCase()\n    } else {\n      stats = stats.toUpperCase()\n    }\n    env.loadCountry(browserslist.usage, stats, browserslist.data)\n    data = browserslist.usage[stats]\n  } else {\n    if ('dataByBrowser' in stats) {\n      stats = stats.dataByBrowser\n    }\n    data = { }\n    for (var name in stats) {\n      for (var version in stats[name]) {\n        data[name + ' ' + version] = stats[name][version]\n      }\n    }\n  }\n\n  return browsers.reduce(function (all, i) {\n    var usage = data[i]\n    if (usage === undefined) {\n      usage = data[i.replace(/ \\S+$/, ' 0')]\n    }\n    return all + (usage || 0)\n  }, 0)\n}\n\nfunction nodeQuery (context, version) {\n  var nodeReleases = jsReleases.filter(function (i) {\n    return i.name === 'nodejs'\n  })\n  var matched = nodeReleases.filter(function (i) {\n    return isVersionsMatch(i.version, version)\n  })\n  if (matched.length === 0) {\n    if (context.ignoreUnknownVersions) {\n      return []\n    } else {\n      throw new BrowserslistError('Unknown version ' + version + ' of Node.js')\n    }\n  }\n  return ['node ' + matched[matched.length - 1].version]\n}\n\nfunction sinceQuery (context, year, month, date) {\n  year = parseInt(year)\n  month = parseInt(month || '01') - 1\n  date = parseInt(date || '01')\n  return filterByYear(Date.UTC(year, month, date, 0, 0, 0), context)\n}\n\nfunction coverQuery (context, coverage, statMode) {\n  coverage = parseFloat(coverage)\n  var usage = browserslist.usage.global\n  if (statMode) {\n    if (statMode.match(/^my\\s+stats$/)) {\n      if (!context.customUsage) {\n        throw new BrowserslistError(\n          'Custom usage statistics was not provided'\n        )\n      }\n      usage = context.customUsage\n    } else {\n      var place\n      if (statMode.length === 2) {\n        place = statMode.toUpperCase()\n      } else {\n        place = statMode.toLowerCase()\n      }\n      env.loadCountry(browserslist.usage, place, browserslist.data)\n      usage = browserslist.usage[place]\n    }\n  }\n  var versions = Object.keys(usage).sort(function (a, b) {\n    return usage[b] - usage[a]\n  })\n  var coveraged = 0\n  var result = []\n  var version\n  for (var i = 0; i <= versions.length; i++) {\n    version = versions[i]\n    if (usage[version] === 0) break\n    coveraged += usage[version]\n    result.push(version)\n    if (coveraged >= coverage) break\n  }\n  return result\n}\n\nvar QUERIES = [\n  {\n    regexp: /^last\\s+(\\d+)\\s+major\\s+versions?$/i,\n    select: function (context, versions) {\n      return Object.keys(agents).reduce(function (selected, name) {\n        var data = byName(name, context)\n        if (!data) return selected\n        var list = getMajorVersions(data.released, versions)\n        list = list.map(nameMapper(data.name))\n        if (data.name === 'android') {\n          list = filterAndroid(list, versions, context)\n        }\n        return selected.concat(list)\n      }, [])\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d+)\\s+versions?$/i,\n    select: function (context, versions) {\n      return Object.keys(agents).reduce(function (selected, name) {\n        var data = byName(name, context)\n        if (!data) return selected\n        var list = data.released.slice(-versions)\n        list = list.map(nameMapper(data.name))\n        if (data.name === 'android') {\n          list = filterAndroid(list, versions, context)\n        }\n        return selected.concat(list)\n      }, [])\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d+)\\s+electron\\s+major\\s+versions?$/i,\n    select: function (context, versions) {\n      var validVersions = getMajorVersions(Object.keys(e2c), versions)\n      return validVersions.map(function (i) {\n        return 'chrome ' + e2c[i]\n      })\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d+)\\s+(\\w+)\\s+major\\s+versions?$/i,\n    select: function (context, versions, name) {\n      var data = checkName(name, context)\n      var validVersions = getMajorVersions(data.released, versions)\n      var list = validVersions.map(nameMapper(data.name))\n      if (data.name === 'android') {\n        list = filterAndroid(list, versions, context)\n      }\n      return list\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d+)\\s+electron\\s+versions?$/i,\n    select: function (context, versions) {\n      return Object.keys(e2c)\n        .slice(-versions)\n        .map(function (i) {\n          return 'chrome ' + e2c[i]\n        })\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d+)\\s+(\\w+)\\s+versions?$/i,\n    select: function (context, versions, name) {\n      var data = checkName(name, context)\n      var list = data.released.slice(-versions).map(nameMapper(data.name))\n      if (data.name === 'android') {\n        list = filterAndroid(list, versions, context)\n      }\n      return list\n    }\n  },\n  {\n    regexp: /^unreleased\\s+versions$/i,\n    select: function (context) {\n      return Object.keys(agents).reduce(function (selected, name) {\n        var data = byName(name, context)\n        if (!data) return selected\n        var list = data.versions.filter(function (v) {\n          return data.released.indexOf(v) === -1\n        })\n        list = list.map(nameMapper(data.name))\n        return selected.concat(list)\n      }, [])\n    }\n  },\n  {\n    regexp: /^unreleased\\s+electron\\s+versions?$/i,\n    select: function () {\n      return []\n    }\n  },\n  {\n    regexp: /^unreleased\\s+(\\w+)\\s+versions?$/i,\n    select: function (context, name) {\n      var data = checkName(name, context)\n      return data.versions\n        .filter(function (v) {\n          return data.released.indexOf(v) === -1\n        })\n        .map(nameMapper(data.name))\n    }\n  },\n  {\n    regexp: /^last\\s+(\\d*.?\\d+)\\s+years?$/i,\n    select: function (context, years) {\n      return filterByYear(Date.now() - YEAR * years, context)\n    }\n  },\n  {\n    regexp: /^since (\\d+)$/i,\n    select: sinceQuery\n  },\n  {\n    regexp: /^since (\\d+)-(\\d+)$/i,\n    select: sinceQuery\n  },\n  {\n    regexp: /^since (\\d+)-(\\d+)-(\\d+)$/i,\n    select: sinceQuery\n  },\n  {\n    regexp: /^(>=?|<=?)\\s*(\\d*\\.?\\d+)%$/,\n    select: function (context, sign, popularity) {\n      popularity = parseFloat(popularity)\n      var usage = browserslist.usage.global\n      return Object.keys(usage).reduce(function (result, version) {\n        if (sign === '>') {\n          if (usage[version] > popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<') {\n          if (usage[version] < popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<=') {\n          if (usage[version] <= popularity) {\n            result.push(version)\n          }\n        } else if (usage[version] >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  {\n    regexp: /^(>=?|<=?)\\s*(\\d*\\.?\\d+)%\\s+in\\s+my\\s+stats$/,\n    select: function (context, sign, popularity) {\n      popularity = parseFloat(popularity)\n      if (!context.customUsage) {\n        throw new BrowserslistError('Custom usage statistics was not provided')\n      }\n      var usage = context.customUsage\n      return Object.keys(usage).reduce(function (result, version) {\n        if (sign === '>') {\n          if (usage[version] > popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<') {\n          if (usage[version] < popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<=') {\n          if (usage[version] <= popularity) {\n            result.push(version)\n          }\n        } else if (usage[version] >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  {\n    regexp: /^(>=?|<=?)\\s*(\\d*\\.?\\d+)%\\s+in\\s+(\\S+)\\s+stats$/,\n    select: function (context, sign, popularity, name) {\n      popularity = parseFloat(popularity)\n      var stats = env.loadStat(context, name, browserslist.data)\n      if (stats) {\n        context.customUsage = { }\n        for (var browser in stats) {\n          fillUsage(context.customUsage, browser, stats[browser])\n        }\n      }\n      if (!context.customUsage) {\n        throw new BrowserslistError('Custom usage statistics was not provided')\n      }\n      var usage = context.customUsage\n      return Object.keys(usage).reduce(function (result, version) {\n        if (sign === '>') {\n          if (usage[version] > popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<') {\n          if (usage[version] < popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<=') {\n          if (usage[version] <= popularity) {\n            result.push(version)\n          }\n        } else if (usage[version] >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  {\n    regexp: /^(>=?|<=?)\\s*(\\d*\\.?\\d+)%\\s+in\\s+((alt-)?\\w\\w)$/,\n    select: function (context, sign, popularity, place) {\n      popularity = parseFloat(popularity)\n      if (place.length === 2) {\n        place = place.toUpperCase()\n      } else {\n        place = place.toLowerCase()\n      }\n      env.loadCountry(browserslist.usage, place, browserslist.data)\n      var usage = browserslist.usage[place]\n      return Object.keys(usage).reduce(function (result, version) {\n        if (sign === '>') {\n          if (usage[version] > popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<') {\n          if (usage[version] < popularity) {\n            result.push(version)\n          }\n        } else if (sign === '<=') {\n          if (usage[version] <= popularity) {\n            result.push(version)\n          }\n        } else if (usage[version] >= popularity) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  {\n    regexp: /^cover\\s+(\\d*\\.?\\d+)%$/,\n    select: coverQuery\n  },\n  {\n    regexp: /^cover\\s+(\\d*\\.?\\d+)%\\s+in\\s+(my\\s+stats|(alt-)?\\w\\w)$/,\n    select: coverQuery\n  },\n  {\n    regexp: /^supports\\s+([\\w-]+)$/,\n    select: function (context, feature) {\n      env.loadFeature(browserslist.cache, feature)\n      var features = browserslist.cache[feature]\n      return Object.keys(features).reduce(function (result, version) {\n        var flags = features[version]\n        if (flags.indexOf('y') >= 0 || flags.indexOf('a') >= 0) {\n          result.push(version)\n        }\n        return result\n      }, [])\n    }\n  },\n  {\n    regexp: /^electron\\s+([\\d.]+)\\s*-\\s*([\\d.]+)$/i,\n    select: function (context, from, to) {\n      var fromToUse = normalizeElectron(from)\n      var toToUse = normalizeElectron(to)\n      if (!e2c[fromToUse]) {\n        throw new BrowserslistError('Unknown version ' + from + ' of electron')\n      }\n      if (!e2c[toToUse]) {\n        throw new BrowserslistError('Unknown version ' + to + ' of electron')\n      }\n      from = parseFloat(from)\n      to = parseFloat(to)\n      return Object.keys(e2c)\n        .filter(function (i) {\n          var parsed = parseFloat(i)\n          return parsed >= from && parsed <= to\n        })\n        .map(function (i) {\n          return 'chrome ' + e2c[i]\n        })\n    }\n  },\n  {\n    regexp: /^node\\s+([\\d.]+)\\s*-\\s*([\\d.]+)$/i,\n    select: function (context, from, to) {\n      var nodeVersions = jsReleases\n        .filter(function (i) {\n          return i.name === 'nodejs'\n        })\n        .map(function (i) {\n          return i.version\n        })\n      return nodeVersions\n        .filter(semverFilterLoose('>=', from))\n        .filter(semverFilterLoose('<=', to))\n        .map(function (v) {\n          return 'node ' + v\n        })\n    }\n  },\n  {\n    regexp: /^(\\w+)\\s+([\\d.]+)\\s*-\\s*([\\d.]+)$/i,\n    select: function (context, name, from, to) {\n      var data = checkName(name, context)\n      from = parseFloat(normalizeVersion(data, from) || from)\n      to = parseFloat(normalizeVersion(data, to) || to)\n      function filter (v) {\n        var parsed = parseFloat(v)\n        return parsed >= from && parsed <= to\n      }\n      return data.released.filter(filter).map(nameMapper(data.name))\n    }\n  },\n  {\n    regexp: /^electron\\s*(>=?|<=?)\\s*([\\d.]+)$/i,\n    select: function (context, sign, version) {\n      var versionToUse = normalizeElectron(version)\n      return Object.keys(e2c)\n        .filter(generateFilter(sign, versionToUse))\n        .map(function (i) {\n          return 'chrome ' + e2c[i]\n        })\n    }\n  },\n  {\n    regexp: /^node\\s*(>=?|<=?)\\s*([\\d.]+)$/i,\n    select: function (context, sign, version) {\n      var nodeVersions = jsReleases\n        .filter(function (i) {\n          return i.name === 'nodejs'\n        })\n        .map(function (i) {\n          return i.version\n        })\n      return nodeVersions\n        .filter(generateSemverFilter(sign, version))\n        .map(function (v) {\n          return 'node ' + v\n        })\n    }\n  },\n  {\n    regexp: /^(\\w+)\\s*(>=?|<=?)\\s*([\\d.]+)$/,\n    select: function (context, name, sign, version) {\n      var data = checkName(name, context)\n      var alias = browserslist.versionAliases[data.name][version]\n      if (alias) {\n        version = alias\n      }\n      return data.released\n        .filter(generateFilter(sign, version))\n        .map(function (v) {\n          return data.name + ' ' + v\n        })\n    }\n  },\n  {\n    regexp: /^(firefox|ff|fx)\\s+esr$/i,\n    select: function () {\n      return ['firefox 78']\n    }\n  },\n  {\n    regexp: /(operamini|op_mini)\\s+all/i,\n    select: function () {\n      return ['op_mini all']\n    }\n  },\n  {\n    regexp: /^electron\\s+([\\d.]+)$/i,\n    select: function (context, version) {\n      var versionToUse = normalizeElectron(version)\n      var chrome = e2c[versionToUse]\n      if (!chrome) {\n        throw new BrowserslistError(\n          'Unknown version ' + version + ' of electron'\n        )\n      }\n      return ['chrome ' + chrome]\n    }\n  },\n  {\n    regexp: /^node\\s+(\\d+)$/i,\n    select: nodeQuery\n  },\n  {\n    regexp: /^node\\s+(\\d+\\.\\d+)$/i,\n    select: nodeQuery\n  },\n  {\n    regexp: /^node\\s+(\\d+\\.\\d+\\.\\d+)$/i,\n    select: nodeQuery\n  },\n  {\n    regexp: /^current\\s+node$/i,\n    select: function (context) {\n      return [env.currentNode(resolve, context)]\n    }\n  },\n  {\n    regexp: /^maintained\\s+node\\s+versions$/i,\n    select: function (context) {\n      var now = Date.now()\n      var queries = Object.keys(jsEOL)\n        .filter(function (key) {\n          return (\n            now < Date.parse(jsEOL[key].end) &&\n            now > Date.parse(jsEOL[key].start) &&\n            isEolReleased(key)\n          )\n        })\n        .map(function (key) {\n          return 'node ' + key.slice(1)\n        })\n      return resolve(queries, context)\n    }\n  },\n  {\n    regexp: /^phantomjs\\s+1.9$/i,\n    select: function () {\n      return ['safari 5']\n    }\n  },\n  {\n    regexp: /^phantomjs\\s+2.1$/i,\n    select: function () {\n      return ['safari 6']\n    }\n  },\n  {\n    regexp: /^(\\w+)\\s+(tp|[\\d.]+)$/i,\n    select: function (context, name, version) {\n      if (/^tp$/i.test(version)) version = 'TP'\n      var data = checkName(name, context)\n      var alias = normalizeVersion(data, version)\n      if (alias) {\n        version = alias\n      } else {\n        if (version.indexOf('.') === -1) {\n          alias = version + '.0'\n        } else {\n          alias = version.replace(/\\.0$/, '')\n        }\n        alias = normalizeVersion(data, alias)\n        if (alias) {\n          version = alias\n        } else if (context.ignoreUnknownVersions) {\n          return []\n        } else {\n          throw new BrowserslistError(\n            'Unknown version ' + version + ' of ' + name\n          )\n        }\n      }\n      return [data.name + ' ' + version]\n    }\n  },\n  {\n    regexp: /^browserslist config$/i,\n    select: function (context) {\n      return browserslist(undefined, context)\n    }\n  },\n  {\n    regexp: /^extends (.+)$/i,\n    select: function (context, name) {\n      return resolve(env.loadQueries(context, name), context)\n    }\n  },\n  {\n    regexp: /^defaults$/i,\n    select: function (context) {\n      return resolve(browserslist.defaults, context)\n    }\n  },\n  {\n    regexp: /^dead$/i,\n    select: function (context) {\n      var dead = [\n        'ie <= 10',\n        'ie_mob <= 11',\n        'bb <= 10',\n        'op_mob <= 12.1',\n        'samsung 4'\n      ]\n      return resolve(dead, context)\n    }\n  },\n  {\n    regexp: /^(\\w+)$/i,\n    select: function (context, name) {\n      if (byName(name, context)) {\n        throw new BrowserslistError(\n          'Specify versions in Browserslist query for browser ' + name\n        )\n      } else {\n        throw unknownQuery(name)\n      }\n    }\n  }\n];\n\n// Get and convert Can I Use data\n\n(function () {\n  for (var name in agents) {\n    var browser = agents[name]\n    browserslist.data[name] = {\n      name: name,\n      versions: normalize(agents[name].versions),\n      released: normalize(agents[name].versions.slice(0, -3)),\n      releaseDate: agents[name].release_date\n    }\n    fillUsage(browserslist.usage.global, name, browser.usage_global)\n\n    browserslist.versionAliases[name] = { }\n    for (var i = 0; i < browser.versions.length; i++) {\n      var full = browser.versions[i]\n      if (!full) continue\n\n      if (full.indexOf('-') !== -1) {\n        var interval = full.split('-')\n        for (var j = 0; j < interval.length; j++) {\n          browserslist.versionAliases[name][interval[j]] = full\n        }\n      }\n    }\n  }\n\n  browserslist.versionAliases.op_mob['59'] = '58'\n}())\n\nmodule.exports = browserslist\n", "{\n  \"name\": \"browserslist\",\n  \"version\": \"4.16.3\",\n  \"description\": \"Share target browsers between different front-end tools, like Autoprefixer, Stylelint and babel-env-preset\",\n  \"keywords\": [\n    \"caniuse\",\n    \"browsers\",\n    \"target\"\n  ],\n  \"funding\": {\n    \"type\": \"opencollective\",\n    \"url\": \"https://opencollective.com/browserslist\"\n  },\n  \"author\": \"Andrey Sitnik <andrey@sitnik.ru>\",\n  \"license\": \"MIT\",\n  \"repository\": \"browserslist/browserslist\",\n  \"scripts\": {\n    \"test\": \"jest --coverage && eslint . && check-dts && size-limit && yaspeller *.md\"\n  },\n  \"dependencies\": {\n    \"caniuse-lite\": \"^1.0.30001207\",\n    \"colorette\": \"^1.2.2\",\n    \"electron-to-chromium\": \"^1.3.710\",\n    \"escalade\": \"^3.1.1\",\n    \"node-releases\": \"^1.1.71\"\n  },\n  \"engines\": {\n    \"node\": \"^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7\"\n  },\n  \"bin\": {\n    \"browserslist\": \"cli.js\"\n  },\n  \"types\": \"./index.d.ts\",\n  \"devDependencies\": {\n    \"@logux/eslint-config\": \"^35.0.4\",\n    \"@logux/sharec-config\": \"^0.5.7\",\n    \"@size-limit/preset-small-lib\": \"^4.10.2\",\n    \"@types/cross-spawn\": \"^6.0.2\",\n    \"@types/fs-extra\": \"^9.0.10\",\n    \"@types/jest\": \"^26.0.22\",\n    \"check-dts\": \"^0.4.4\",\n    \"clean-publish\": \"^2.1.1\",\n    \"cross-spawn\": \"^7.0.3\",\n    \"eslint\": \"^6.8.0\",\n    \"eslint-config-standard\": \"^14.1.1\",\n    \"eslint-plugin-es5\": \"^1.5.0\",\n    \"eslint-plugin-import\": \"^2.22.1\",\n    \"eslint-plugin-jest\": \"^23.18.0\",\n    \"eslint-plugin-node\": \"^11.1.0\",\n    \"eslint-plugin-prefer-let\": \"^1.1.0\",\n    \"eslint-plugin-promise\": \"^4.2.1\",\n    \"eslint-plugin-security\": \"^1.4.0\",\n    \"eslint-plugin-standard\": \"^4.0.2\",\n    \"eslint-plugin-unicorn\": \"^16.1.1\",\n    \"fs-extra\": \"^8.1.0\",\n    \"jest\": \"^25.5.4\",\n    \"lint-staged\": \"^10.5.4\",\n    \"nanoid\": \"^3.1.22\",\n    \"simple-git-hooks\": \"^2.3.1\",\n    \"size-limit\": \"^4.10.2\",\n    \"ts-jest\": \"^25.5.1\",\n    \"typescript\": \"^3.9.4\",\n    \"yaspeller\": \"^7.0.0\"\n  },\n  \"browser\": {\n    \"./node.js\": \"./browser.js\",\n    \"path\": false\n  },\n  \"simple-git-hooks\": {\n    \"pre-commit\": \"npx lint-staged\"\n  },\n  \"jest\": {\n    \"preset\": \"ts-jest\",\n    \"testEnvironment\": \"node\",\n    \"coverageThreshold\": {\n      \"global\": {\n        \"statements\": 100\n      }\n    },\n    \"modulePathIgnorePatterns\": [\n      \"<rootDir>/test/fixtures\"\n    ]\n  },\n  \"size-limit\": [\n    {\n      \"path\": \"index.js\",\n      \"limit\": \"14 KB\"\n    }\n  ],\n  \"lint-staged\": {\n    \"*.md\": \"yaspeller\",\n    \"*.js\": \"eslint\"\n  },\n  \"eslintConfig\": {\n    \"extends\": \"@logux/eslint-config/browser\",\n    \"rules\": {\n      \"global-require\": \"off\"\n    },\n    \"overrides\": [\n      {\n        \"files\": \"test/**/*\",\n        \"rules\": {\n          \"security/detect-unsafe-regex\": \"off\"\n        }\n      }\n    ]\n  },\n  \"eslintIgnore\": [\n    \"test/fixtures\"\n  ],\n  \"yaspeller\": {\n    \"lang\": \"en\",\n    \"ignoreCapitalization\": true,\n    \"ignoreText\": [\n      \" \\\\(by [^)]+\\\\).\"\n    ],\n    \"dictionary\": [\n      \"albiventris\",\n      \"algirus\",\n      \"amurensis\",\n      \"Atelerix\",\n      \"Autoprefixer\",\n      \"Baidu\",\n      \"Browserify\",\n      \"Browserslist\",\n      \"Browserslist\u2019s\",\n      \"BrowserStack\",\n      \"CLI\",\n      \"compat\",\n      \"configs\",\n      \"Configs\",\n      \"DynJS\",\n      \"env\",\n      \"Erinaceus\",\n      \"eslint\",\n      \"ESR\",\n      \"frontalis\",\n      \"GitHub\",\n      \"iOS\",\n      \"JS\",\n      \"js\",\n      \"JSDoc\",\n      \"jspm\",\n      \"KaiOS\",\n      \"npm\",\n      \"postcss\",\n      \"QQ\",\n      \"RegExp\",\n      \"sclateri\",\n      \"stylelint\",\n      \"symlink\",\n      \"Tidelift\",\n      \"TP\",\n      \"UC\",\n      \"unreleased\",\n      \"useragent\",\n      \"Versioning\",\n      \"webpack\",\n      \"WebView\",\n      \"browserslist\",\n      \"PhantomJS\",\n      \"maintainers\",\n      \"ES\",\n      \"deduplication\",\n      \"pnpm\",\n      \"VS\"\n    ]\n  },\n  \"sharec\": {\n    \"config\": \"@logux/sharec-config\",\n    \"version\": \"0.5.7\"\n  }\n}\n", "import browserslist from '../'\n\nit('selects Node.js version', () => {\n  expect(browserslist('node 7.5.0')).toEqual(['node 7.5.0'])\n})\n\nit('supports case insensitive Node.js name', () => {\n  expect(browserslist('Node 7.5.0')).toEqual(['node 7.5.0'])\n})\n\nit('throws on unknown Node.js version', () => {\n  expect(() => {\n    browserslist('node 3')\n  }).toThrow(/Unknown version/)\n})\n\nit('throws on malformed Node.js version', () => {\n  expect(() => {\n    browserslist('node 8.a')\n  }).toThrow(/Unknown/)\n  expect(() => {\n    browserslist('node 8.8.8.8')\n  }).toThrow(/Unknown/)\n  expect(() => {\n    browserslist('node 8.01')\n  }).toThrow(/Unknown/)\n  expect(() => {\n    browserslist(\"node 6 - 8.a\");\n  }).toThrow(/Unknown/);\n})\n\nit('return empty array on unknown Node.js version with special flag', () => {\n  expect(browserslist('node 3', { ignoreUnknownVersions: true })).toEqual([])\n})\n\nit('supports selection of Node.js version by major.minor query', () => {\n  expect(browserslist('node 5.1')).toEqual(['node 5.1.0'])\n})\n\nit('supports selection of Node.js version by major version only', () => {\n  expect(browserslist('node 5')).toEqual(['node 5.12.0'])\n})\n\nit('selects maintained Node.js versions', () => {\n  expect(Array.isArray(browserslist('maintained node versions'))).toBe(true)\n})\n\nit('supports case insensitive query for maintained Node.js versions', () => {\n  expect(Array.isArray(browserslist('maintained Node versions'))).toBe(true)\n})\n\nit('supports current node version', () => {\n  let versions = browserslist('current node')\n  expect(versions).toHaveLength(1)\n  expect(versions[0]).toMatch(/node \\d+\\.\\d+\\.\\d+/)\n})\n\nit('supports comparison operator', () => {\n  expect(browserslist('node <= 5')).toEqual([\n    'node 5.0.0',\n\n    'node 4.9.0',\n    'node 4.8.0',\n    'node 4.7.0',\n    'node 4.6.0',\n    'node 4.5.0',\n    'node 4.4.0',\n    'node 4.3.0',\n    'node 4.2.0',\n    'node 4.1.0',\n    'node 4.0.0',\n\n    'node 0.12.0',\n    'node 0.11.0',\n    'node 0.10.0',\n    'node 0.9.0',\n    'node 0.8.0',\n    'node 0.7.0',\n    'node 0.6.0',\n    'node 0.5.0',\n    'node 0.4.0',\n    'node 0.3.0',\n    'node 0.2.0'\n  ])\n\n  expect(browserslist('node < 5')).toEqual([\n    'node 4.9.0',\n    'node 4.8.0',\n    'node 4.7.0',\n    'node 4.6.0',\n    'node 4.5.0',\n    'node 4.4.0',\n    'node 4.3.0',\n    'node 4.2.0',\n    'node 4.1.0',\n    'node 4.0.0',\n\n    'node 0.12.0',\n    'node 0.11.0',\n    'node 0.10.0',\n    'node 0.9.0',\n    'node 0.8.0',\n    'node 0.7.0',\n    'node 0.6.0',\n    'node 0.5.0',\n    'node 0.4.0',\n    'node 0.3.0',\n    'node 0.2.0'\n  ])\n\n  expect(browserslist('Node <= 5')).toHaveLength(22)\n\n  expect(browserslist('node >= 9')).toEqual(expect.arrayContaining([\n    'node 9.0.0',\n    'node 9.1.0',\n    'node 9.2.0',\n    'node 9.3.0',\n    'node 9.4.0',\n    'node 9.5.0',\n    'node 9.6.0',\n    'node 9.7.0',\n    'node 9.8.0',\n    'node 9.9.0',\n    'node 9.10.0',\n    'node 9.11.0',\n\n    'node 10.0.0',\n    'node 10.1.0',\n    'node 10.2.0',\n    'node 10.3.0',\n    'node 10.4.0',\n    'node 10.5.0',\n    'node 10.6.0',\n    'node 10.7.0',\n    'node 10.8.0',\n    'node 10.9.0',\n    'node 10.10.0',\n    'node 10.11.0',\n    'node 10.12.0',\n    'node 10.13.0',\n    'node 10.14.0',\n    'node 10.15.0',\n\n    'node 11.0.0',\n    'node 11.1.0',\n    'node 11.2.0',\n    'node 11.3.0',\n    'node 11.4.0',\n    'node 11.5.0',\n    'node 11.6.0',\n    'node 11.7.0',\n    'node 11.8.0',\n    'node 11.9.0',\n    'node 11.10.0'\n  ]))\n\n  expect(browserslist('node > 9')).toEqual(expect.arrayContaining([\n    'node 9.1.0',\n    'node 9.2.0',\n    'node 9.3.0',\n    'node 9.4.0',\n    'node 9.5.0',\n    'node 9.6.0',\n    'node 9.7.0',\n    'node 9.8.0',\n    'node 9.9.0',\n    'node 9.10.0',\n    'node 9.11.0',\n\n    'node 10.0.0',\n    'node 10.1.0',\n    'node 10.2.0',\n    'node 10.3.0',\n    'node 10.4.0',\n    'node 10.5.0',\n    'node 10.6.0',\n    'node 10.7.0',\n    'node 10.8.0',\n    'node 10.9.0',\n    'node 10.10.0',\n    'node 10.11.0',\n    'node 10.12.0',\n    'node 10.13.0',\n    'node 10.14.0',\n    'node 10.15.0',\n\n    'node 11.0.0',\n    'node 11.1.0',\n    'node 11.2.0',\n    'node 11.3.0',\n    'node 11.4.0',\n    'node 11.5.0',\n    'node 11.6.0',\n    'node 11.7.0',\n    'node 11.8.0',\n    'node 11.9.0',\n    'node 11.10.0'\n  ]))\n})\n\nit('supports range selection', () => {\n  expect(browserslist('node 4-6')).toEqual([\n    'node 6.17.0',\n    'node 6.16.0',\n    'node 6.15.0',\n    'node 6.14.0',\n    'node 6.13.0',\n    'node 6.12.0',\n    'node 6.11.0',\n    'node 6.10.0',\n    'node 6.9.0',\n    'node 6.8.0',\n    'node 6.7.0',\n    'node 6.6.0',\n    'node 6.5.0',\n    'node 6.4.0',\n    'node 6.3.0',\n    'node 6.2.0',\n    'node 6.1.0',\n    'node 6.0.0',\n\n    'node 5.12.0',\n    'node 5.11.0',\n    'node 5.10.0',\n    'node 5.9.0',\n    'node 5.8.0',\n    'node 5.7.0',\n    'node 5.6.0',\n    'node 5.5.0',\n    'node 5.4.0',\n    'node 5.3.0',\n    'node 5.2.0',\n    'node 5.1.0',\n    'node 5.0.0',\n\n    'node 4.9.0',\n    'node 4.8.0',\n    'node 4.7.0',\n    'node 4.6.0',\n    'node 4.5.0',\n    'node 4.4.0',\n    'node 4.3.0',\n    'node 4.2.0',\n    'node 4.1.0',\n    'node 4.0.0'\n  ])\n\n  expect(browserslist('node 4-6.0.0')).toEqual([\n    'node 6.0.0',\n\n    'node 5.12.0',\n    'node 5.11.0',\n    'node 5.10.0',\n    'node 5.9.0',\n    'node 5.8.0',\n    'node 5.7.0',\n    'node 5.6.0',\n    'node 5.5.0',\n    'node 5.4.0',\n    'node 5.3.0',\n    'node 5.2.0',\n    'node 5.1.0',\n    'node 5.0.0',\n\n    'node 4.9.0',\n    'node 4.8.0',\n    'node 4.7.0',\n    'node 4.6.0',\n    'node 4.5.0',\n    'node 4.4.0',\n    'node 4.3.0',\n    'node 4.2.0',\n    'node 4.1.0',\n    'node 4.0.0'\n  ])\n\n  expect(browserslist('node 6.5-7.5')).toEqual([\n    'node 7.5.0',\n    'node 7.4.0',\n    'node 7.3.0',\n    'node 7.2.0',\n    'node 7.1.0',\n    'node 7.0.0',\n\n    'node 6.17.0',\n    'node 6.16.0',\n    'node 6.15.0',\n    'node 6.14.0',\n    'node 6.13.0',\n    'node 6.12.0',\n    'node 6.11.0',\n    'node 6.10.0',\n    'node 6.9.0',\n    'node 6.8.0',\n    'node 6.7.0',\n    'node 6.6.0',\n    'node 6.5.0'\n  ])\n\n  expect(browserslist('node 6.6.4-7.7.5')).toEqual([\n    'node 7.7.0',\n    'node 7.6.0',\n    'node 7.5.0',\n    'node 7.4.0',\n    'node 7.3.0',\n    'node 7.2.0',\n    'node 7.1.0',\n    'node 7.0.0',\n\n    'node 6.17.0',\n    'node 6.16.0',\n    'node 6.15.0',\n    'node 6.14.0',\n    'node 6.13.0',\n    'node 6.12.0',\n    'node 6.11.0',\n    'node 6.10.0',\n    'node 6.9.0',\n    'node 6.8.0',\n    'node 6.7.0',\n    // include 6.6.0 as patch versions are ignored\n    'node 6.6.0'\n  ])\n})\n"], "filenames": ["index.js", "package.json", "test/node.test.ts"], "buggy_code_start_loc": [616, 97, 28], "buggy_code_end_loc": [1146, 100, 36], "fixing_code_start_loc": [617, 96, 28], "fixing_code_end_loc": [1178, 107, 30], "type": "NVD-CWE-Other", "message": "The package browserslist from 4.0.0 and before 4.16.5 are vulnerable to Regular Expression Denial of Service (ReDoS) during parsing of queries.", "other": {"cve": {"id": "CVE-2021-23364", "sourceIdentifier": "report@snyk.io", "published": "2021-04-28T16:15:08.133", "lastModified": "2021-05-05T20:15:33.980", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package browserslist from 4.0.0 and before 4.16.5 are vulnerable to Regular Expression Denial of Service (ReDoS) during parsing of queries."}, {"lang": "es", "value": "El paquete browserslist de versiones 4.0.0 y anteriores hasta 4.16.5, son vulnerables a una Denegaci\u00f3n de Servicio de Expresi\u00f3n Regular (ReDoS) durante el an\u00e1lisis de consultas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:browserslist_project:browserslist:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.16.5", "matchCriteriaId": "650A2A7E-03A0-4CD7-A5C9-389ADDFDCB79"}]}]}], "references": [{"url": "https://github.com/browserslist/browserslist/blob/e82f32d1d4100d6bc79ea0b6b6a2d281a561e33c/index.js%23L472-L474", "source": "report@snyk.io", "tags": ["Broken Link"]}, {"url": "https://github.com/browserslist/browserslist/commit/c091916910dfe0b5fd61caad96083c6709b02d98", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/browserslist/browserslist/pull/593", "source": "report@snyk.io", "tags": ["Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JAVA-ORGWEBJARSNPM-1277182", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://snyk.io/vuln/SNYK-JS-BROWSERSLIST-1090194", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/browserslist/browserslist/commit/c091916910dfe0b5fd61caad96083c6709b02d98"}}