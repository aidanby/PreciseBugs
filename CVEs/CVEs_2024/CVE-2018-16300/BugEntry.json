{"buggy_code": ["/*\n * Copyright (C) 1999 WIDE Project.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * Extensively modified by Hannes Gredler (hannes@gredler.at) for more\n * complete BGP support.\n */\n\n/* \\summary: Border Gateway Protocol (BGP) printer */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <netdissect-stdinc.h>\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"netdissect.h\"\n#include \"addrtoname.h\"\n#include \"extract.h\"\n#include \"af.h\"\n#include \"l2vpn.h\"\n\nstatic const char tstr[] = \"[|BGP]\";\n\nstruct bgp {\n\tuint8_t bgp_marker[16];\n\tuint16_t bgp_len;\n\tuint8_t bgp_type;\n};\n#define BGP_SIZE\t\t19\t/* unaligned */\n\n#define BGP_OPEN\t\t1\n#define BGP_UPDATE\t\t2\n#define BGP_NOTIFICATION\t3\n#define BGP_KEEPALIVE\t\t4\n#define BGP_ROUTE_REFRESH       5\n\nstatic const struct tok bgp_msg_values[] = {\n    { BGP_OPEN,                 \"Open\"},\n    { BGP_UPDATE,               \"Update\"},\n    { BGP_NOTIFICATION,         \"Notification\"},\n    { BGP_KEEPALIVE,            \"Keepalive\"},\n    { BGP_ROUTE_REFRESH,        \"Route Refresh\"},\n    { 0, NULL}\n};\n\nstruct bgp_open {\n\tuint8_t bgpo_marker[16];\n\tuint16_t bgpo_len;\n\tuint8_t bgpo_type;\n\tuint8_t bgpo_version;\n\tuint16_t bgpo_myas;\n\tuint16_t bgpo_holdtime;\n\tuint32_t bgpo_id;\n\tuint8_t bgpo_optlen;\n\t/* options should follow */\n};\n#define BGP_OPEN_SIZE\t\t29\t/* unaligned */\n\nstruct bgp_opt {\n\tuint8_t bgpopt_type;\n\tuint8_t bgpopt_len;\n\t/* variable length */\n};\n#define BGP_OPT_SIZE\t\t2\t/* some compilers may pad to 4 bytes */\n#define BGP_CAP_HEADER_SIZE\t2\t/* some compilers may pad to 4 bytes */\n\nstruct bgp_notification {\n\tuint8_t bgpn_marker[16];\n\tuint16_t bgpn_len;\n\tuint8_t bgpn_type;\n\tuint8_t bgpn_major;\n\tuint8_t bgpn_minor;\n};\n#define BGP_NOTIFICATION_SIZE\t\t21\t/* unaligned */\n\nstruct bgp_route_refresh {\n    uint8_t  bgp_marker[16];\n    uint16_t len;\n    uint8_t  type;\n    uint8_t  afi[2]; /* the compiler messes this structure up               */\n    uint8_t  res;    /* when doing misaligned sequences of int8 and int16   */\n    uint8_t  safi;   /* afi should be int16 - so we have to access it using */\n};                    /* EXTRACT_16BITS(&bgp_route_refresh->afi) (sigh)      */\n#define BGP_ROUTE_REFRESH_SIZE          23\n\n#define bgp_attr_lenlen(flags, p) \\\n\t(((flags) & 0x10) ? 2 : 1)\n#define bgp_attr_len(flags, p) \\\n\t(((flags) & 0x10) ? EXTRACT_16BITS(p) : *(p))\n\n#define BGPTYPE_ORIGIN\t\t\t1\n#define BGPTYPE_AS_PATH\t\t\t2\n#define BGPTYPE_NEXT_HOP\t\t3\n#define BGPTYPE_MULTI_EXIT_DISC\t\t4\n#define BGPTYPE_LOCAL_PREF\t\t5\n#define BGPTYPE_ATOMIC_AGGREGATE\t6\n#define BGPTYPE_AGGREGATOR\t\t7\n#define\tBGPTYPE_COMMUNITIES\t\t8\t/* RFC1997 */\n#define\tBGPTYPE_ORIGINATOR_ID\t\t9\t/* RFC4456 */\n#define\tBGPTYPE_CLUSTER_LIST\t\t10\t/* RFC4456 */\n#define\tBGPTYPE_DPA\t\t\t11\t/* deprecated, draft-ietf-idr-bgp-dpa */\n#define\tBGPTYPE_ADVERTISERS\t\t12\t/* deprecated RFC1863 */\n#define\tBGPTYPE_RCID_PATH\t\t13\t/* deprecated RFC1863 */\n#define BGPTYPE_MP_REACH_NLRI\t\t14\t/* RFC4760 */\n#define BGPTYPE_MP_UNREACH_NLRI\t\t15\t/* RFC4760 */\n#define BGPTYPE_EXTD_COMMUNITIES        16      /* RFC4360 */\n#define BGPTYPE_AS4_PATH\t        17      /* RFC6793 */\n#define BGPTYPE_AGGREGATOR4\t\t18      /* RFC6793 */\n#define BGPTYPE_PMSI_TUNNEL             22      /* RFC6514 */\n#define BGPTYPE_TUNNEL_ENCAP            23      /* RFC5512 */\n#define BGPTYPE_TRAFFIC_ENG             24      /* RFC5543 */\n#define BGPTYPE_IPV6_EXTD_COMMUNITIES   25      /* RFC5701 */\n#define BGPTYPE_AIGP                    26      /* RFC7311 */\n#define BGPTYPE_PE_DISTINGUISHER_LABEL  27      /* RFC6514 */\n#define BGPTYPE_ENTROPY_LABEL           28      /* RFC6790 */\n#define BGPTYPE_LARGE_COMMUNITY\t\t32\t/* draft-ietf-idr-large-community-05 */\n#define BGPTYPE_ATTR_SET               128      /* RFC6368 */\n\n#define BGP_MP_NLRI_MINSIZE              3       /* End of RIB Marker detection */\n\nstatic const struct tok bgp_attr_values[] = {\n    { BGPTYPE_ORIGIN,           \"Origin\"},\n    { BGPTYPE_AS_PATH,          \"AS Path\"},\n    { BGPTYPE_AS4_PATH,         \"AS4 Path\"},\n    { BGPTYPE_NEXT_HOP,         \"Next Hop\"},\n    { BGPTYPE_MULTI_EXIT_DISC,  \"Multi Exit Discriminator\"},\n    { BGPTYPE_LOCAL_PREF,       \"Local Preference\"},\n    { BGPTYPE_ATOMIC_AGGREGATE, \"Atomic Aggregate\"},\n    { BGPTYPE_AGGREGATOR,       \"Aggregator\"},\n    { BGPTYPE_AGGREGATOR4,      \"Aggregator4\"},\n    { BGPTYPE_COMMUNITIES,      \"Community\"},\n    { BGPTYPE_ORIGINATOR_ID,    \"Originator ID\"},\n    { BGPTYPE_CLUSTER_LIST,     \"Cluster List\"},\n    { BGPTYPE_DPA,              \"DPA\"},\n    { BGPTYPE_ADVERTISERS,      \"Advertisers\"},\n    { BGPTYPE_RCID_PATH,        \"RCID Path / Cluster ID\"},\n    { BGPTYPE_MP_REACH_NLRI,    \"Multi-Protocol Reach NLRI\"},\n    { BGPTYPE_MP_UNREACH_NLRI,  \"Multi-Protocol Unreach NLRI\"},\n    { BGPTYPE_EXTD_COMMUNITIES, \"Extended Community\"},\n    { BGPTYPE_PMSI_TUNNEL,      \"PMSI Tunnel\"},\n    { BGPTYPE_TUNNEL_ENCAP,     \"Tunnel Encapsulation\"},\n    { BGPTYPE_TRAFFIC_ENG,      \"Traffic Engineering\"},\n    { BGPTYPE_IPV6_EXTD_COMMUNITIES, \"IPv6 Extended Community\"},\n    { BGPTYPE_AIGP,             \"Accumulated IGP Metric\"},\n    { BGPTYPE_PE_DISTINGUISHER_LABEL, \"PE Distinguisher Label\"},\n    { BGPTYPE_ENTROPY_LABEL,    \"Entropy Label\"},\n    { BGPTYPE_LARGE_COMMUNITY,  \"Large Community\"},\n    { BGPTYPE_ATTR_SET,         \"Attribute Set\"},\n    { 255,                      \"Reserved for development\"},\n    { 0, NULL}\n};\n\n#define BGP_AS_SET             1\n#define BGP_AS_SEQUENCE        2\n#define BGP_CONFED_AS_SEQUENCE 3 /* draft-ietf-idr-rfc3065bis-01 */\n#define BGP_CONFED_AS_SET      4 /* draft-ietf-idr-rfc3065bis-01  */\n\n#define BGP_AS_SEG_TYPE_MIN    BGP_AS_SET\n#define BGP_AS_SEG_TYPE_MAX    BGP_CONFED_AS_SET\n\nstatic const struct tok bgp_as_path_segment_open_values[] = {\n    { BGP_AS_SEQUENCE,         \"\"},\n    { BGP_AS_SET,              \"{ \"},\n    { BGP_CONFED_AS_SEQUENCE,  \"( \"},\n    { BGP_CONFED_AS_SET,       \"({ \"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_as_path_segment_close_values[] = {\n    { BGP_AS_SEQUENCE,         \"\"},\n    { BGP_AS_SET,              \"}\"},\n    { BGP_CONFED_AS_SEQUENCE,  \")\"},\n    { BGP_CONFED_AS_SET,       \"})\"},\n    { 0, NULL}\n};\n\n#define BGP_OPT_AUTH                    1\n#define BGP_OPT_CAP                     2\n\nstatic const struct tok bgp_opt_values[] = {\n    { BGP_OPT_AUTH,             \"Authentication Information\"},\n    { BGP_OPT_CAP,              \"Capabilities Advertisement\"},\n    { 0, NULL}\n};\n\n#define BGP_CAPCODE_MP                  1 /* RFC2858 */\n#define BGP_CAPCODE_RR                  2 /* RFC2918 */\n#define BGP_CAPCODE_ORF                 3 /* RFC5291 */\n#define BGP_CAPCODE_MR                  4 /* RFC3107 */\n#define BGP_CAPCODE_EXT_NH              5 /* RFC5549 */\n#define BGP_CAPCODE_RESTART            64 /* RFC4724  */\n#define BGP_CAPCODE_AS_NEW             65 /* RFC6793 */\n#define BGP_CAPCODE_DYN_CAP            67 /* draft-ietf-idr-dynamic-cap */\n#define BGP_CAPCODE_MULTISESS          68 /* draft-ietf-idr-bgp-multisession */\n#define BGP_CAPCODE_ADD_PATH           69 /* RFC7911 */\n#define BGP_CAPCODE_ENH_RR             70 /* draft-keyur-bgp-enhanced-route-refresh */\n#define BGP_CAPCODE_RR_CISCO          128\n\nstatic const struct tok bgp_capcode_values[] = {\n    { BGP_CAPCODE_MP,           \"Multiprotocol Extensions\"},\n    { BGP_CAPCODE_RR,           \"Route Refresh\"},\n    { BGP_CAPCODE_ORF,          \"Cooperative Route Filtering\"},\n    { BGP_CAPCODE_MR,           \"Multiple Routes to a Destination\"},\n    { BGP_CAPCODE_EXT_NH,       \"Extended Next Hop Encoding\"},\n    { BGP_CAPCODE_RESTART,      \"Graceful Restart\"},\n    { BGP_CAPCODE_AS_NEW,       \"32-Bit AS Number\"},\n    { BGP_CAPCODE_DYN_CAP,      \"Dynamic Capability\"},\n    { BGP_CAPCODE_MULTISESS,    \"Multisession BGP\"},\n    { BGP_CAPCODE_ADD_PATH,     \"Multiple Paths\"},\n    { BGP_CAPCODE_ENH_RR,       \"Enhanced Route Refresh\"},\n    { BGP_CAPCODE_RR_CISCO,     \"Route Refresh (Cisco)\"},\n    { 0, NULL}\n};\n\n#define BGP_NOTIFY_MAJOR_MSG            1\n#define BGP_NOTIFY_MAJOR_OPEN           2\n#define BGP_NOTIFY_MAJOR_UPDATE         3\n#define BGP_NOTIFY_MAJOR_HOLDTIME       4\n#define BGP_NOTIFY_MAJOR_FSM            5\n#define BGP_NOTIFY_MAJOR_CEASE          6\n#define BGP_NOTIFY_MAJOR_CAP            7\n\nstatic const struct tok bgp_notify_major_values[] = {\n    { BGP_NOTIFY_MAJOR_MSG,     \"Message Header Error\"},\n    { BGP_NOTIFY_MAJOR_OPEN,    \"OPEN Message Error\"},\n    { BGP_NOTIFY_MAJOR_UPDATE,  \"UPDATE Message Error\"},\n    { BGP_NOTIFY_MAJOR_HOLDTIME,\"Hold Timer Expired\"},\n    { BGP_NOTIFY_MAJOR_FSM,     \"Finite State Machine Error\"},\n    { BGP_NOTIFY_MAJOR_CEASE,   \"Cease\"},\n    { BGP_NOTIFY_MAJOR_CAP,     \"Capability Message Error\"},\n    { 0, NULL}\n};\n\n/* draft-ietf-idr-cease-subcode-02 */\n#define BGP_NOTIFY_MINOR_CEASE_MAXPRFX  1\nstatic const struct tok bgp_notify_minor_cease_values[] = {\n    { BGP_NOTIFY_MINOR_CEASE_MAXPRFX, \"Maximum Number of Prefixes Reached\"},\n    { 2,                        \"Administratively Shutdown\"},\n    { 3,                        \"Peer Unconfigured\"},\n    { 4,                        \"Administratively Reset\"},\n    { 5,                        \"Connection Rejected\"},\n    { 6,                        \"Other Configuration Change\"},\n    { 7,                        \"Connection Collision Resolution\"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_notify_minor_msg_values[] = {\n    { 1,                        \"Connection Not Synchronized\"},\n    { 2,                        \"Bad Message Length\"},\n    { 3,                        \"Bad Message Type\"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_notify_minor_open_values[] = {\n    { 1,                        \"Unsupported Version Number\"},\n    { 2,                        \"Bad Peer AS\"},\n    { 3,                        \"Bad BGP Identifier\"},\n    { 4,                        \"Unsupported Optional Parameter\"},\n    { 5,                        \"Authentication Failure\"},\n    { 6,                        \"Unacceptable Hold Time\"},\n    { 7,                        \"Capability Message Error\"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_notify_minor_update_values[] = {\n    { 1,                        \"Malformed Attribute List\"},\n    { 2,                        \"Unrecognized Well-known Attribute\"},\n    { 3,                        \"Missing Well-known Attribute\"},\n    { 4,                        \"Attribute Flags Error\"},\n    { 5,                        \"Attribute Length Error\"},\n    { 6,                        \"Invalid ORIGIN Attribute\"},\n    { 7,                        \"AS Routing Loop\"},\n    { 8,                        \"Invalid NEXT_HOP Attribute\"},\n    { 9,                        \"Optional Attribute Error\"},\n    { 10,                       \"Invalid Network Field\"},\n    { 11,                       \"Malformed AS_PATH\"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_notify_minor_fsm_values[] = {\n    { 1,                        \"In OpenSent State\"},\n    { 2,                        \"In OpenConfirm State\"},\n    { 3,                        \"In Established State\"},\n    { 0, NULL }\n};\n\nstatic const struct tok bgp_notify_minor_cap_values[] = {\n    { 1,                        \"Invalid Action Value\" },\n    { 2,                        \"Invalid Capability Length\" },\n    { 3,                        \"Malformed Capability Value\" },\n    { 4,                        \"Unsupported Capability Code\" },\n    { 0, NULL }\n};\n\nstatic const struct tok bgp_origin_values[] = {\n    { 0,                        \"IGP\"},\n    { 1,                        \"EGP\"},\n    { 2,                        \"Incomplete\"},\n    { 0, NULL}\n};\n\n#define BGP_PMSI_TUNNEL_RSVP_P2MP 1\n#define BGP_PMSI_TUNNEL_LDP_P2MP  2\n#define BGP_PMSI_TUNNEL_PIM_SSM   3\n#define BGP_PMSI_TUNNEL_PIM_SM    4\n#define BGP_PMSI_TUNNEL_PIM_BIDIR 5\n#define BGP_PMSI_TUNNEL_INGRESS   6\n#define BGP_PMSI_TUNNEL_LDP_MP2MP 7\n\nstatic const struct tok bgp_pmsi_tunnel_values[] = {\n    { BGP_PMSI_TUNNEL_RSVP_P2MP, \"RSVP-TE P2MP LSP\"},\n    { BGP_PMSI_TUNNEL_LDP_P2MP, \"LDP P2MP LSP\"},\n    { BGP_PMSI_TUNNEL_PIM_SSM, \"PIM-SSM Tree\"},\n    { BGP_PMSI_TUNNEL_PIM_SM, \"PIM-SM Tree\"},\n    { BGP_PMSI_TUNNEL_PIM_BIDIR, \"PIM-Bidir Tree\"},\n    { BGP_PMSI_TUNNEL_INGRESS, \"Ingress Replication\"},\n    { BGP_PMSI_TUNNEL_LDP_MP2MP, \"LDP MP2MP LSP\"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_pmsi_flag_values[] = {\n    { 0x01, \"Leaf Information required\"},\n    { 0, NULL}\n};\n\n#define BGP_AIGP_TLV 1\n\nstatic const struct tok bgp_aigp_values[] = {\n    { BGP_AIGP_TLV, \"AIGP\"},\n    { 0, NULL}\n};\n\n/* Subsequent address family identifier, RFC2283 section 7 */\n#define SAFNUM_RES                      0\n#define SAFNUM_UNICAST                  1\n#define SAFNUM_MULTICAST                2\n#define SAFNUM_UNIMULTICAST             3       /* deprecated now */\n/* labeled BGP RFC3107 */\n#define SAFNUM_LABUNICAST               4\n/* RFC6514 */\n#define SAFNUM_MULTICAST_VPN            5\n/* draft-nalawade-kapoor-tunnel-safi */\n#define SAFNUM_TUNNEL                   64\n/* RFC4761 */\n#define SAFNUM_VPLS                     65\n/* RFC6037 */\n#define SAFNUM_MDT                      66\n/* RFC4364 */\n#define SAFNUM_VPNUNICAST               128\n/* RFC6513 */\n#define SAFNUM_VPNMULTICAST             129\n#define SAFNUM_VPNUNIMULTICAST          130     /* deprecated now */\n/* RFC4684 */\n#define SAFNUM_RT_ROUTING_INFO          132\n\n#define BGP_VPN_RD_LEN                  8\n\nstatic const struct tok bgp_safi_values[] = {\n    { SAFNUM_RES,               \"Reserved\"},\n    { SAFNUM_UNICAST,           \"Unicast\"},\n    { SAFNUM_MULTICAST,         \"Multicast\"},\n    { SAFNUM_UNIMULTICAST,      \"Unicast+Multicast\"},\n    { SAFNUM_LABUNICAST,        \"labeled Unicast\"},\n    { SAFNUM_TUNNEL,            \"Tunnel\"},\n    { SAFNUM_VPLS,              \"VPLS\"},\n    { SAFNUM_MDT,               \"MDT\"},\n    { SAFNUM_VPNUNICAST,        \"labeled VPN Unicast\"},\n    { SAFNUM_VPNMULTICAST,      \"labeled VPN Multicast\"},\n    { SAFNUM_VPNUNIMULTICAST,   \"labeled VPN Unicast+Multicast\"},\n    { SAFNUM_RT_ROUTING_INFO,   \"Route Target Routing Information\"},\n    { SAFNUM_MULTICAST_VPN,     \"Multicast VPN\"},\n    { 0, NULL }\n};\n\n/* well-known community */\n#define BGP_COMMUNITY_NO_EXPORT\t\t\t0xffffff01\n#define BGP_COMMUNITY_NO_ADVERT\t\t\t0xffffff02\n#define BGP_COMMUNITY_NO_EXPORT_SUBCONFED\t0xffffff03\n\n/* Extended community type - draft-ietf-idr-bgp-ext-communities-05 */\n#define BGP_EXT_COM_RT_0        0x0002  /* Route Target,Format AS(2bytes):AN(4bytes) */\n#define BGP_EXT_COM_RT_1        0x0102  /* Route Target,Format IP address:AN(2bytes) */\n#define BGP_EXT_COM_RT_2        0x0202  /* Route Target,Format AN(4bytes):local(2bytes) */\n#define BGP_EXT_COM_RO_0        0x0003  /* Route Origin,Format AS(2bytes):AN(4bytes) */\n#define BGP_EXT_COM_RO_1        0x0103  /* Route Origin,Format IP address:AN(2bytes) */\n#define BGP_EXT_COM_RO_2        0x0203  /* Route Origin,Format AN(4bytes):local(2bytes) */\n#define BGP_EXT_COM_LINKBAND    0x4004  /* Link Bandwidth,Format AS(2B):Bandwidth(4B) */\n                                        /* rfc2547 bgp-mpls-vpns */\n#define BGP_EXT_COM_VPN_ORIGIN  0x0005  /* OSPF Domain ID / VPN of Origin  - draft-rosen-vpns-ospf-bgp-mpls */\n#define BGP_EXT_COM_VPN_ORIGIN2 0x0105  /* duplicate - keep for backwards compatability */\n#define BGP_EXT_COM_VPN_ORIGIN3 0x0205  /* duplicate - keep for backwards compatability */\n#define BGP_EXT_COM_VPN_ORIGIN4 0x8005  /* duplicate - keep for backwards compatability */\n\n#define BGP_EXT_COM_OSPF_RTYPE  0x0306  /* OSPF Route Type,Format Area(4B):RouteType(1B):Options(1B) */\n#define BGP_EXT_COM_OSPF_RTYPE2 0x8000  /* duplicate - keep for backwards compatability */\n\n#define BGP_EXT_COM_OSPF_RID    0x0107  /* OSPF Router ID,Format RouterID(4B):Unused(2B) */\n#define BGP_EXT_COM_OSPF_RID2   0x8001  /* duplicate - keep for backwards compatability */\n\n#define BGP_EXT_COM_L2INFO      0x800a  /* draft-kompella-ppvpn-l2vpn */\n\n#define BGP_EXT_COM_SOURCE_AS   0x0009  /* RFC-ietf-l3vpn-2547bis-mcast-bgp-08.txt */\n#define BGP_EXT_COM_VRF_RT_IMP  0x010b  /* RFC-ietf-l3vpn-2547bis-mcast-bgp-08.txt */\n#define BGP_EXT_COM_L2VPN_RT_0  0x000a  /* L2VPN Identifier,Format AS(2bytes):AN(4bytes) */\n#define BGP_EXT_COM_L2VPN_RT_1  0xF10a  /* L2VPN Identifier,Format IP address:AN(2bytes) */\n\n/* http://www.cisco.com/en/US/tech/tk436/tk428/technologies_tech_note09186a00801eb09a.shtml  */\n#define BGP_EXT_COM_EIGRP_GEN   0x8800\n#define BGP_EXT_COM_EIGRP_METRIC_AS_DELAY  0x8801\n#define BGP_EXT_COM_EIGRP_METRIC_REL_NH_BW 0x8802\n#define BGP_EXT_COM_EIGRP_METRIC_LOAD_MTU  0x8803\n#define BGP_EXT_COM_EIGRP_EXT_REMAS_REMID  0x8804\n#define BGP_EXT_COM_EIGRP_EXT_REMPROTO_REMMETRIC 0x8805\n\nstatic const struct tok bgp_extd_comm_flag_values[] = {\n    { 0x8000,                  \"vendor-specific\"},\n    { 0x4000,                  \"non-transitive\"},\n    { 0, NULL},\n};\n\nstatic const struct tok bgp_extd_comm_subtype_values[] = {\n    { BGP_EXT_COM_RT_0,        \"target\"},\n    { BGP_EXT_COM_RT_1,        \"target\"},\n    { BGP_EXT_COM_RT_2,        \"target\"},\n    { BGP_EXT_COM_RO_0,        \"origin\"},\n    { BGP_EXT_COM_RO_1,        \"origin\"},\n    { BGP_EXT_COM_RO_2,        \"origin\"},\n    { BGP_EXT_COM_LINKBAND,    \"link-BW\"},\n    { BGP_EXT_COM_VPN_ORIGIN,  \"ospf-domain\"},\n    { BGP_EXT_COM_VPN_ORIGIN2, \"ospf-domain\"},\n    { BGP_EXT_COM_VPN_ORIGIN3, \"ospf-domain\"},\n    { BGP_EXT_COM_VPN_ORIGIN4, \"ospf-domain\"},\n    { BGP_EXT_COM_OSPF_RTYPE,  \"ospf-route-type\"},\n    { BGP_EXT_COM_OSPF_RTYPE2, \"ospf-route-type\"},\n    { BGP_EXT_COM_OSPF_RID,    \"ospf-router-id\"},\n    { BGP_EXT_COM_OSPF_RID2,   \"ospf-router-id\"},\n    { BGP_EXT_COM_L2INFO,      \"layer2-info\"},\n    { BGP_EXT_COM_EIGRP_GEN , \"eigrp-general-route (flag, tag)\" },\n    { BGP_EXT_COM_EIGRP_METRIC_AS_DELAY , \"eigrp-route-metric (AS, delay)\" },\n    { BGP_EXT_COM_EIGRP_METRIC_REL_NH_BW , \"eigrp-route-metric (reliability, nexthop, bandwidth)\" },\n    { BGP_EXT_COM_EIGRP_METRIC_LOAD_MTU , \"eigrp-route-metric (load, MTU)\" },\n    { BGP_EXT_COM_EIGRP_EXT_REMAS_REMID , \"eigrp-external-route (remote-AS, remote-ID)\" },\n    { BGP_EXT_COM_EIGRP_EXT_REMPROTO_REMMETRIC , \"eigrp-external-route (remote-proto, remote-metric)\" },\n    { BGP_EXT_COM_SOURCE_AS, \"source-AS\" },\n    { BGP_EXT_COM_VRF_RT_IMP, \"vrf-route-import\"},\n    { BGP_EXT_COM_L2VPN_RT_0, \"l2vpn-id\"},\n    { BGP_EXT_COM_L2VPN_RT_1, \"l2vpn-id\"},\n    { 0, NULL},\n};\n\n/* OSPF codes for  BGP_EXT_COM_OSPF_RTYPE draft-rosen-vpns-ospf-bgp-mpls  */\n#define BGP_OSPF_RTYPE_RTR      1 /* OSPF Router LSA */\n#define BGP_OSPF_RTYPE_NET      2 /* OSPF Network LSA */\n#define BGP_OSPF_RTYPE_SUM      3 /* OSPF Summary LSA */\n#define BGP_OSPF_RTYPE_EXT      5 /* OSPF External LSA, note that ASBR doesn't apply to MPLS-VPN */\n#define BGP_OSPF_RTYPE_NSSA     7 /* OSPF NSSA External*/\n#define BGP_OSPF_RTYPE_SHAM     129 /* OSPF-MPLS-VPN Sham link */\n#define BGP_OSPF_RTYPE_METRIC_TYPE 0x1 /* LSB of RTYPE Options Field */\n\nstatic const struct tok bgp_extd_comm_ospf_rtype_values[] = {\n  { BGP_OSPF_RTYPE_RTR, \"Router\" },\n  { BGP_OSPF_RTYPE_NET, \"Network\" },\n  { BGP_OSPF_RTYPE_SUM, \"Summary\" },\n  { BGP_OSPF_RTYPE_EXT, \"External\" },\n  { BGP_OSPF_RTYPE_NSSA,\"NSSA External\" },\n  { BGP_OSPF_RTYPE_SHAM,\"MPLS-VPN Sham\" },\n  { 0, NULL },\n};\n\n/* ADD-PATH Send/Receive field values */\nstatic const struct tok bgp_add_path_recvsend[] = {\n  { 1, \"Receive\" },\n  { 2, \"Send\" },\n  { 3, \"Both\" },\n  { 0, NULL },\n};\n\nstatic char astostr[20];\n\n/*\n * as_printf\n *\n * Convert an AS number into a string and return string pointer.\n *\n * Depending on bflag is set or not, AS number is converted into ASDOT notation\n * or plain number notation.\n *\n */\nstatic char *\nas_printf(netdissect_options *ndo,\n          char *str, int size, u_int asnum)\n{\n\tif (!ndo->ndo_bflag || asnum <= 0xFFFF) {\n\t\tsnprintf(str, size, \"%u\", asnum);\n\t} else {\n\t\tsnprintf(str, size, \"%u.%u\", asnum >> 16, asnum & 0xFFFF);\n\t}\n\treturn str;\n}\n\n#define ITEMCHECK(minlen) if (itemlen < minlen) goto badtlv;\n\nint\ndecode_prefix4(netdissect_options *ndo,\n               const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in_addr addr;\n\tu_int plen, plenbytes;\n\n\tND_TCHECK(pptr[0]);\n\tITEMCHECK(1);\n\tplen = pptr[0];\n\tif (32 < plen)\n\t\treturn -1;\n\titemlen -= 1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[1], plenbytes);\n\tITEMCHECK(plenbytes);\n\tmemcpy(&addr, &pptr[1], plenbytes);\n\tif (plen % 8) {\n\t\t((u_char *)&addr)[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d\", ipaddr_string(ndo, &addr), plen);\n\treturn 1 + plenbytes;\n\ntrunc:\n\treturn -2;\n\nbadtlv:\n\treturn -3;\n}\n\nstatic int\ndecode_labeled_prefix4(netdissect_options *ndo,\n                       const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in_addr addr;\n\tu_int plen, plenbytes;\n\n\t/* prefix length and label = 4 bytes */\n\tND_TCHECK2(pptr[0], 4);\n\tITEMCHECK(4);\n\tplen = pptr[0];   /* get prefix length */\n\n        /* this is one of the weirdnesses of rfc3107\n           the label length (actually the label + COS bits)\n           is added to the prefix length;\n           we also do only read out just one label -\n           there is no real application for advertisement of\n           stacked labels in a single BGP message\n        */\n\n\tif (24 > plen)\n\t\treturn -1;\n\n        plen-=24; /* adjust prefixlen - labellength */\n\n\tif (32 < plen)\n\t\treturn -1;\n\titemlen -= 4;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[4], plenbytes);\n\tITEMCHECK(plenbytes);\n\tmemcpy(&addr, &pptr[4], plenbytes);\n\tif (plen % 8) {\n\t\t((u_char *)&addr)[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n        /* the label may get offsetted by 4 bits so lets shift it right */\n\tsnprintf(buf, buflen, \"%s/%d, label:%u %s\",\n                 ipaddr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\n\treturn 4 + plenbytes;\n\ntrunc:\n\treturn -2;\n\nbadtlv:\n\treturn -3;\n}\n\n/*\n * bgp_vpn_ip_print\n *\n * print an ipv4 or ipv6 address into a buffer dependend on address length.\n */\nstatic char *\nbgp_vpn_ip_print(netdissect_options *ndo,\n                 const u_char *pptr, u_int addr_length)\n{\n\n    /* worst case string is s fully formatted v6 address */\n    static char addr[sizeof(\"1234:5678:89ab:cdef:1234:5678:89ab:cdef\")];\n    char *pos = addr;\n\n    switch(addr_length) {\n    case (sizeof(struct in_addr) << 3): /* 32 */\n        ND_TCHECK2(pptr[0], sizeof(struct in_addr));\n        snprintf(pos, sizeof(addr), \"%s\", ipaddr_string(ndo, pptr));\n        break;\n    case (sizeof(struct in6_addr) << 3): /* 128 */\n        ND_TCHECK2(pptr[0], sizeof(struct in6_addr));\n        snprintf(pos, sizeof(addr), \"%s\", ip6addr_string(ndo, pptr));\n        break;\n    default:\n        snprintf(pos, sizeof(addr), \"bogus address length %u\", addr_length);\n        break;\n    }\n    pos += strlen(pos);\n\ntrunc:\n    *(pos) = '\\0';\n    return (addr);\n}\n\n/*\n * bgp_vpn_sg_print\n *\n * print an multicast s,g entry into a buffer.\n * the s,g entry is encoded like this.\n *\n * +-----------------------------------+\n * | Multicast Source Length (1 octet) |\n * +-----------------------------------+\n * |   Multicast Source (Variable)     |\n * +-----------------------------------+\n * |  Multicast Group Length (1 octet) |\n * +-----------------------------------+\n * |  Multicast Group   (Variable)     |\n * +-----------------------------------+\n *\n * return the number of bytes read from the wire.\n */\nstatic int\nbgp_vpn_sg_print(netdissect_options *ndo,\n                 const u_char *pptr, char *buf, u_int buflen)\n{\n    uint8_t addr_length;\n    u_int total_length, offset;\n\n    total_length = 0;\n\n    /* Source address length, encoded in bits */\n    ND_TCHECK2(pptr[0], 1);\n    addr_length =  *pptr++;\n\n    /* Source address */\n    ND_TCHECK2(pptr[0], (addr_length >> 3));\n    total_length += (addr_length >> 3) + 1;\n    offset = strlen(buf);\n    if (addr_length) {\n        snprintf(buf + offset, buflen - offset, \", Source %s\",\n                 bgp_vpn_ip_print(ndo, pptr, addr_length));\n        pptr += (addr_length >> 3);\n    }\n\n    /* Group address length, encoded in bits */\n    ND_TCHECK2(pptr[0], 1);\n    addr_length =  *pptr++;\n\n    /* Group address */\n    ND_TCHECK2(pptr[0], (addr_length >> 3));\n    total_length += (addr_length >> 3) + 1;\n    offset = strlen(buf);\n    if (addr_length) {\n        snprintf(buf + offset, buflen - offset, \", Group %s\",\n                 bgp_vpn_ip_print(ndo, pptr, addr_length));\n        pptr += (addr_length >> 3);\n    }\n\ntrunc:\n    return (total_length);\n}\n\n/* RDs and RTs share the same semantics\n * we use bgp_vpn_rd_print for\n * printing route targets inside a NLRI */\nchar *\nbgp_vpn_rd_print(netdissect_options *ndo,\n                 const u_char *pptr)\n{\n   /* allocate space for the largest possible string */\n    static char rd[sizeof(\"xxxxxxxxxx:xxxxx (xxx.xxx.xxx.xxx:xxxxx)\")];\n    char *pos = rd;\n\n    /* ok lets load the RD format */\n    switch (EXTRACT_16BITS(pptr)) {\n\n        /* 2-byte-AS:number fmt*/\n    case 0:\n        snprintf(pos, sizeof(rd) - (pos - rd), \"%u:%u (= %u.%u.%u.%u)\",\n                 EXTRACT_16BITS(pptr+2),\n                 EXTRACT_32BITS(pptr+4),\n                 *(pptr+4), *(pptr+5), *(pptr+6), *(pptr+7));\n        break;\n        /* IP-address:AS fmt*/\n\n    case 1:\n        snprintf(pos, sizeof(rd) - (pos - rd), \"%u.%u.%u.%u:%u\",\n            *(pptr+2), *(pptr+3), *(pptr+4), *(pptr+5), EXTRACT_16BITS(pptr+6));\n        break;\n\n        /* 4-byte-AS:number fmt*/\n    case 2:\n\tsnprintf(pos, sizeof(rd) - (pos - rd), \"%s:%u (%u.%u.%u.%u:%u)\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+2)),\n\t    EXTRACT_16BITS(pptr+6), *(pptr+2), *(pptr+3), *(pptr+4),\n\t    *(pptr+5), EXTRACT_16BITS(pptr+6));\n        break;\n    default:\n        snprintf(pos, sizeof(rd) - (pos - rd), \"unknown RD format\");\n        break;\n    }\n    pos += strlen(pos);\n    *(pos) = '\\0';\n    return (rd);\n}\n\nstatic int\ndecode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\tchar asbuf[sizeof(astostr)]; /* bgp_vpn_rd_print() overwrites astostr */\n\n\t/* NLRI \"prefix length\" from RFC 2858 Section 4. */\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\t/* NLRI \"prefix\" (ibid), valid lengths are { 0, 32, 33, ..., 96 } bits.\n\t * RFC 4684 Section 4 defines the layout of \"origin AS\" and \"route\n\t * target\" fields inside the \"prefix\" depending on its length.\n\t */\n\tif (0 == plen) {\n\t\t/* Without \"origin AS\", without \"route target\". */\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\n\tif (32 > plen)\n\t\treturn -1;\n\n\t/* With at least \"origin AS\", possibly with \"route target\". */\n\tND_TCHECK_32BITS(pptr + 1);\n\tas_printf(ndo, asbuf, sizeof(asbuf), EXTRACT_32BITS(pptr + 1));\n\n        plen-=32; /* adjust prefix length */\n\n\tif (64 < plen)\n\t\treturn -1;\n\n\t/* From now on (plen + 7) / 8 evaluates to { 0, 1, 2, ..., 8 }\n\t * and gives the number of octets in the variable-length \"route\n\t * target\" field inside this NLRI \"prefix\". Look for it.\n\t */\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[5], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[5], (plen + 7) / 8);\n\t/* Which specification says to do this? */\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    asbuf,\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\n\treturn 5 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n\nstatic int\ndecode_labeled_vpn_prefix4(netdissect_options *ndo,\n                           const u_char *pptr, char *buf, u_int buflen)\n{\n\tstruct in_addr addr;\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif ((24+64) > plen)\n\t\treturn -1;\n\n        plen-=(24+64); /* adjust prefixlen - labellength - RD len*/\n\n\tif (32 < plen)\n\t\treturn -1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&addr)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n        /* the label may get offsetted by 4 bits so lets shift it right */\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 ipaddr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\n\treturn 12 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n\n/*\n * +-------------------------------+\n * |                               |\n * |  RD:IPv4-address (12 octets)  |\n * |                               |\n * +-------------------------------+\n * |  MDT Group-address (4 octets) |\n * +-------------------------------+\n */\n\n#define MDT_VPN_NLRI_LEN 16\n\nstatic int\ndecode_mdt_vpn_nlri(netdissect_options *ndo,\n                    const u_char *pptr, char *buf, u_int buflen)\n{\n\n    const u_char *rd;\n    const u_char *vpn_ip;\n\n    ND_TCHECK(pptr[0]);\n\n    /* if the NLRI is not predefined length, quit.*/\n    if (*pptr != MDT_VPN_NLRI_LEN * 8)\n\treturn -1;\n    pptr++;\n\n    /* RD */\n    ND_TCHECK2(pptr[0], 8);\n    rd = pptr;\n    pptr+=8;\n\n    /* IPv4 address */\n    ND_TCHECK2(pptr[0], sizeof(struct in_addr));\n    vpn_ip = pptr;\n    pptr+=sizeof(struct in_addr);\n\n    /* MDT Group Address */\n    ND_TCHECK2(pptr[0], sizeof(struct in_addr));\n\n    snprintf(buf, buflen, \"RD: %s, VPN IP Address: %s, MC Group Address: %s\",\n\t     bgp_vpn_rd_print(ndo, rd), ipaddr_string(ndo, vpn_ip), ipaddr_string(ndo, pptr));\n\n    return MDT_VPN_NLRI_LEN + 1;\n\n trunc:\n\nreturn -2;\n}\n\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI   1\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI   2\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI            3\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF 4\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE     5\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN  6\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN  7\n\nstatic const struct tok bgp_multicast_vpn_route_type_values[] = {\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI, \"Intra-AS I-PMSI\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI, \"Inter-AS I-PMSI\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI, \"S-PMSI\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF, \"Intra-AS Segment-Leaf\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE, \"Source-Active\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN, \"Shared Tree Join\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN, \"Source Tree Join\"},\n    { 0, NULL}\n};\n\nstatic int\ndecode_multicast_vpn(netdissect_options *ndo,\n                     const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t route_type, route_length, addr_length, sg_length;\n        u_int offset;\n\n\tND_TCHECK2(pptr[0], 2);\n        route_type = *pptr++;\n        route_length = *pptr++;\n\n        snprintf(buf, buflen, \"Route-Type: %s (%u), length: %u\",\n                 tok2str(bgp_multicast_vpn_route_type_values,\n                         \"Unknown\", route_type),\n                 route_type, route_length);\n\n        switch(route_type) {\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s, Originator %s\",\n                     bgp_vpn_rd_print(ndo, pptr),\n                     bgp_vpn_ip_print(ndo, pptr + BGP_VPN_RD_LEN,\n                                      (route_length - BGP_VPN_RD_LEN) << 3));\n            break;\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            sg_length = bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            addr_length =  route_length - sg_length;\n\n            ND_TCHECK2(pptr[0], addr_length);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", Originator %s\",\n                     bgp_vpn_ip_print(ndo, pptr, addr_length << 3));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: /* fall through */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN + 4;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            /*\n             * no per route-type printing yet.\n             */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF:\n        default:\n            break;\n        }\n\n        return route_length + 2;\n\ntrunc:\n\treturn -2;\n}\n\n/*\n * As I remember, some versions of systems have an snprintf() that\n * returns -1 if the buffer would have overflowed.  If the return\n * value is negative, set buflen to 0, to indicate that we've filled\n * the buffer up.\n *\n * If the return value is greater than buflen, that means that\n * the buffer would have overflowed; again, set buflen to 0 in\n * that case.\n */\n#define UPDATE_BUF_BUFLEN(buf, buflen, stringlen) \\\n    if (stringlen<0) \\\n        buflen=0; \\\n    else if ((u_int)stringlen>buflen) \\\n        buflen=0; \\\n    else { \\\n        buflen-=stringlen; \\\n\tbuf+=stringlen; \\\n    }\n\nstatic int\ndecode_labeled_vpn_l2(netdissect_options *ndo,\n                      const u_char *pptr, char *buf, u_int buflen)\n{\n        int plen,tlen,stringlen,tlv_type,tlv_len,ttlv_len;\n\n\tND_TCHECK2(pptr[0], 2);\n        plen=EXTRACT_16BITS(pptr);\n        tlen=plen;\n        pptr+=2;\n\t/* Old and new L2VPN NLRI share AFI/SAFI\n         *   -> Assume a 12 Byte-length NLRI is auto-discovery-only\n         *      and > 17 as old format. Complain for the middle case\n         */\n        if (plen==12) {\n\t    /* assume AD-only with RD, BGPNH */\n\t    ND_TCHECK2(pptr[0],12);\n\t    buf[0]='\\0';\n\t    stringlen=snprintf(buf, buflen, \"RD: %s, BGPNH: %s\",\n\t\t\t       bgp_vpn_rd_print(ndo, pptr),\n\t\t\t       ipaddr_string(ndo, pptr+8)\n\t\t\t       );\n\t    UPDATE_BUF_BUFLEN(buf, buflen, stringlen);\n\t    pptr+=12;\n\t    tlen-=12;\n\t    return plen;\n        } else if (plen>17) {\n\t    /* assume old format */\n\t    /* RD, ID, LBLKOFF, LBLBASE */\n\n\t    ND_TCHECK2(pptr[0],15);\n\t    buf[0]='\\0';\n\t    stringlen=snprintf(buf, buflen, \"RD: %s, CE-ID: %u, Label-Block Offset: %u, Label Base %u\",\n\t\t\t       bgp_vpn_rd_print(ndo, pptr),\n\t\t\t       EXTRACT_16BITS(pptr+8),\n\t\t\t       EXTRACT_16BITS(pptr+10),\n\t\t\t       EXTRACT_24BITS(pptr+12)>>4); /* the label is offsetted by 4 bits so lets shift it right */\n\t    UPDATE_BUF_BUFLEN(buf, buflen, stringlen);\n\t    pptr+=15;\n\t    tlen-=15;\n\n\t    /* ok now the variable part - lets read out TLVs*/\n\t    while (tlen>0) {\n\t\tif (tlen < 3)\n\t\t    return -1;\n\t\tND_TCHECK2(pptr[0], 3);\n\t\ttlv_type=*pptr++;\n\t\ttlv_len=EXTRACT_16BITS(pptr);\n\t\tttlv_len=tlv_len;\n\t\tpptr+=2;\n\n\t\tswitch(tlv_type) {\n\t\tcase 1:\n\t\t    if (buflen!=0) {\n\t\t\tstringlen=snprintf(buf,buflen, \"\\n\\t\\tcircuit status vector (%u) length: %u: 0x\",\n\t\t\t\t\t   tlv_type,\n\t\t\t\t\t   tlv_len);\n\t\t\tUPDATE_BUF_BUFLEN(buf, buflen, stringlen);\n\t\t    }\n\t\t    ttlv_len=ttlv_len/8+1; /* how many bytes do we need to read ? */\n\t\t    while (ttlv_len>0) {\n\t\t\tND_TCHECK(pptr[0]);\n\t\t\tif (buflen!=0) {\n\t\t\t    stringlen=snprintf(buf,buflen, \"%02x\",*pptr++);\n\t\t\t    UPDATE_BUF_BUFLEN(buf, buflen, stringlen);\n\t\t\t}\n\t\t\tttlv_len--;\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    if (buflen!=0) {\n\t\t\tstringlen=snprintf(buf,buflen, \"\\n\\t\\tunknown TLV #%u, length: %u\",\n\t\t\t\t\t   tlv_type,\n\t\t\t\t\t   tlv_len);\n\t\t\tUPDATE_BUF_BUFLEN(buf, buflen, stringlen);\n\t\t    }\n\t\t    break;\n\t\t}\n\t\ttlen-=(tlv_len<<3); /* the tlv-length is expressed in bits so lets shift it right */\n\t    }\n\t    return plen+2;\n\n        } else {\n\t    /* complain bitterly ? */\n\t    /* fall through */\n            goto trunc;\n        }\n\ntrunc:\n        return -2;\n}\n\nint\ndecode_prefix6(netdissect_options *ndo,\n               const u_char *pd, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen, plenbytes;\n\n\tND_TCHECK(pd[0]);\n\tITEMCHECK(1);\n\tplen = pd[0];\n\tif (128 < plen)\n\t\treturn -1;\n\titemlen -= 1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pd[1], plenbytes);\n\tITEMCHECK(plenbytes);\n\tmemcpy(&addr, &pd[1], plenbytes);\n\tif (plen % 8) {\n\t\taddr.s6_addr[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d\", ip6addr_string(ndo, &addr), plen);\n\treturn 1 + plenbytes;\n\ntrunc:\n\treturn -2;\n\nbadtlv:\n\treturn -3;\n}\n\nstatic int\ndecode_labeled_prefix6(netdissect_options *ndo,\n                       const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen, plenbytes;\n\n\t/* prefix length and label = 4 bytes */\n\tND_TCHECK2(pptr[0], 4);\n\tITEMCHECK(4);\n\tplen = pptr[0]; /* get prefix length */\n\n\tif (24 > plen)\n\t\treturn -1;\n\n        plen-=24; /* adjust prefixlen - labellength */\n\n\tif (128 < plen)\n\t\treturn -1;\n\titemlen -= 4;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[4], plenbytes);\n\tmemcpy(&addr, &pptr[4], plenbytes);\n\tif (plen % 8) {\n\t\taddr.s6_addr[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n        /* the label may get offsetted by 4 bits so lets shift it right */\n\tsnprintf(buf, buflen, \"%s/%d, label:%u %s\",\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\n\treturn 4 + plenbytes;\n\ntrunc:\n\treturn -2;\n\nbadtlv:\n\treturn -3;\n}\n\nstatic int\ndecode_labeled_vpn_prefix6(netdissect_options *ndo,\n                           const u_char *pptr, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif ((24+64) > plen)\n\t\treturn -1;\n\n        plen-=(24+64); /* adjust prefixlen - labellength - RD len*/\n\n\tif (128 < plen)\n\t\treturn -1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr.s6_addr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n        /* the label may get offsetted by 4 bits so lets shift it right */\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\n\treturn 12 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n\nstatic int\ndecode_clnp_prefix(netdissect_options *ndo,\n                   const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t addr[19];\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0]; /* get prefix length */\n\n\tif (152 < plen)\n\t\treturn -1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[4], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[4], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d\",\n                 isonsap_string(ndo, addr,(plen + 7) / 8),\n                 plen);\n\n\treturn 1 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n\nstatic int\ndecode_labeled_vpn_clnp_prefix(netdissect_options *ndo,\n                               const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t addr[19];\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif ((24+64) > plen)\n\t\treturn -1;\n\n        plen-=(24+64); /* adjust prefixlen - labellength - RD len*/\n\n\tif (152 < plen)\n\t\treturn -1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n        /* the label may get offsetted by 4 bits so lets shift it right */\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 isonsap_string(ndo, addr,(plen + 7) / 8),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\n\treturn 12 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n\n/*\n * bgp_attr_get_as_size\n *\n * Try to find the size of the ASs encoded in an as-path. It is not obvious, as\n * both Old speakers that do not support 4 byte AS, and the new speakers that do\n * support, exchange AS-Path with the same path-attribute type value 0x02.\n */\nstatic int\nbgp_attr_get_as_size(netdissect_options *ndo,\n                     uint8_t bgpa_type, const u_char *pptr, int len)\n{\n    const u_char *tptr = pptr;\n\n    /*\n     * If the path attribute is the optional AS4 path type, then we already\n     * know, that ASs must be encoded in 4 byte format.\n     */\n    if (bgpa_type == BGPTYPE_AS4_PATH) {\n        return 4;\n    }\n\n    /*\n     * Let us assume that ASs are of 2 bytes in size, and check if the AS-Path\n     * TLV is good. If not, ask the caller to try with AS encoded as 4 bytes\n     * each.\n     */\n    while (tptr < pptr + len) {\n        ND_TCHECK(tptr[0]);\n\n        /*\n         * If we do not find a valid segment type, our guess might be wrong.\n         */\n        if (tptr[0] < BGP_AS_SEG_TYPE_MIN || tptr[0] > BGP_AS_SEG_TYPE_MAX) {\n            goto trunc;\n        }\n        ND_TCHECK(tptr[1]);\n        tptr += 2 + tptr[1] * 2;\n    }\n\n    /*\n     * If we correctly reached end of the AS path attribute data content,\n     * then most likely ASs were indeed encoded as 2 bytes.\n     */\n    if (tptr == pptr + len) {\n        return 2;\n    }\n\ntrunc:\n\n    /*\n     * We can come here, either we did not have enough data, or if we\n     * try to decode 4 byte ASs in 2 byte format. Either way, return 4,\n     * so that calller can try to decode each AS as of 4 bytes. If indeed\n     * there was not enough data, it will crib and end the parse anyways.\n     */\n   return 4;\n}\n\nstatic int\nbgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (tlen == BGP_VPN_RD_LEN + 4 + sizeof(struct in_addr)\n                                    && EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (tlen == BGP_VPN_RD_LEN + 3 + sizeof(struct in6_addr)\n                                         && EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                ND_TCHECK2(tptr[0], 5);\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* FIXME check for recursion */\n                    if (!bgp_attr_print(ndo, atype, tptr, alen))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n\nstatic void\nbgp_capabilities_print(netdissect_options *ndo,\n                       const u_char *opt, int caps_len)\n{\n\tint cap_type, cap_len, tcap_len, cap_offset;\n        int i = 0;\n\n        while (i < caps_len) {\n                ND_TCHECK2(opt[i], BGP_CAP_HEADER_SIZE);\n                cap_type=opt[i];\n                cap_len=opt[i+1];\n                tcap_len=cap_len;\n                ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                       tok2str(bgp_capcode_values, \"Unknown\",\n                                  cap_type),\n                       cap_type,\n                       cap_len));\n                ND_TCHECK2(opt[i+2], cap_len);\n                switch (cap_type) {\n                case BGP_CAPCODE_MP:\n                    /* AFI (16 bits), Reserved (8 bits), SAFI (8 bits) */\n                    ND_TCHECK_8BITS(opt + i + 5);\n                    ND_PRINT((ndo, \"\\n\\t\\tAFI %s (%u), SAFI %s (%u)\",\n                           tok2str(af_values, \"Unknown\",\n                                      EXTRACT_16BITS(opt+i+2)),\n                           EXTRACT_16BITS(opt+i+2),\n                           tok2str(bgp_safi_values, \"Unknown\",\n                                      opt[i+5]),\n                           opt[i+5]));\n                    break;\n                case BGP_CAPCODE_RESTART:\n                    /* Restart Flags (4 bits), Restart Time in seconds (12 bits) */\n                    ND_TCHECK_16BITS(opt + i + 2);\n                    ND_PRINT((ndo, \"\\n\\t\\tRestart Flags: [%s], Restart Time %us\",\n                           ((opt[i+2])&0x80) ? \"R\" : \"none\",\n                           EXTRACT_16BITS(opt+i+2)&0xfff));\n                    tcap_len-=2;\n                    cap_offset=4;\n                    while(tcap_len>=4) {\n                        ND_TCHECK_8BITS(opt + i + cap_offset + 3);\n                        ND_PRINT((ndo, \"\\n\\t\\t  AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %s\",\n                               tok2str(af_values,\"Unknown\",\n                                          EXTRACT_16BITS(opt+i+cap_offset)),\n                               EXTRACT_16BITS(opt+i+cap_offset),\n                               tok2str(bgp_safi_values,\"Unknown\",\n                                          opt[i+cap_offset+2]),\n                               opt[i+cap_offset+2],\n                               ((opt[i+cap_offset+3])&0x80) ? \"yes\" : \"no\" ));\n                        tcap_len-=4;\n                        cap_offset+=4;\n                    }\n                    break;\n                case BGP_CAPCODE_RR:\n                case BGP_CAPCODE_RR_CISCO:\n                    break;\n                case BGP_CAPCODE_AS_NEW:\n\n                    /*\n                     * Extract the 4 byte AS number encoded.\n                     */\n                    if (cap_len == 4) {\n                        ND_PRINT((ndo, \"\\n\\t\\t 4 Byte AS %s\",\n                            as_printf(ndo, astostr, sizeof(astostr),\n                            EXTRACT_32BITS(opt + i + 2))));\n                    }\n                    break;\n                case BGP_CAPCODE_ADD_PATH:\n                    cap_offset=2;\n                    if (tcap_len == 0) {\n                        ND_PRINT((ndo, \" (bogus)\")); /* length */\n                        break;\n                    }\n                    while (tcap_len > 0) {\n                        if (tcap_len < 4) {\n                            ND_PRINT((ndo, \"\\n\\t\\t(invalid)\"));\n                            break;\n                        }\n                        ND_PRINT((ndo, \"\\n\\t\\tAFI %s (%u), SAFI %s (%u), Send/Receive: %s\",\n                                  tok2str(af_values,\"Unknown\",EXTRACT_16BITS(opt+i+cap_offset)),\n                                  EXTRACT_16BITS(opt+i+cap_offset),\n                                  tok2str(bgp_safi_values,\"Unknown\",opt[i+cap_offset+2]),\n                                  opt[i+cap_offset+2],\n                                  tok2str(bgp_add_path_recvsend,\"Bogus (0x%02x)\",opt[i+cap_offset+3])\n                        ));\n                        tcap_len-=4;\n                        cap_offset+=4;\n                    }\n                    break;\n                default:\n                    ND_PRINT((ndo, \"\\n\\t\\tno decoder for Capability %u\",\n                           cap_type));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, &opt[i+2], \"\\n\\t\\t\", cap_len);\n                    break;\n                }\n                if (ndo->ndo_vflag > 1 && cap_len > 0) {\n                    print_unknown_data(ndo, &opt[i+2], \"\\n\\t\\t\", cap_len);\n                }\n                i += BGP_CAP_HEADER_SIZE + cap_len;\n        }\n        return;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nbgp_open_print(netdissect_options *ndo,\n               const u_char *dat, int length)\n{\n\tstruct bgp_open bgpo;\n\tstruct bgp_opt bgpopt;\n\tconst u_char *opt;\n\tint i;\n\n\tND_TCHECK2(dat[0], BGP_OPEN_SIZE);\n\tmemcpy(&bgpo, dat, BGP_OPEN_SIZE);\n\n\tND_PRINT((ndo, \"\\n\\t  Version %d, \", bgpo.bgpo_version));\n\tND_PRINT((ndo, \"my AS %s, \",\n\t    as_printf(ndo, astostr, sizeof(astostr), ntohs(bgpo.bgpo_myas))));\n\tND_PRINT((ndo, \"Holdtime %us, \", ntohs(bgpo.bgpo_holdtime)));\n\tND_PRINT((ndo, \"ID %s\", ipaddr_string(ndo, &bgpo.bgpo_id)));\n\tND_PRINT((ndo, \"\\n\\t  Optional parameters, length: %u\", bgpo.bgpo_optlen));\n\n        /* some little sanity checking */\n        if (length < bgpo.bgpo_optlen+BGP_OPEN_SIZE)\n            return;\n\n\t/* ugly! */\n\topt = &((const struct bgp_open *)dat)->bgpo_optlen;\n\topt++;\n\n\ti = 0;\n\twhile (i < bgpo.bgpo_optlen) {\n\t\tND_TCHECK2(opt[i], BGP_OPT_SIZE);\n\t\tmemcpy(&bgpopt, &opt[i], BGP_OPT_SIZE);\n\t\tif (i + 2 + bgpopt.bgpopt_len > bgpo.bgpo_optlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t     Option %d, length: %u\", bgpopt.bgpopt_type, bgpopt.bgpopt_len));\n\t\t\tbreak;\n\t\t}\n\n\t\tND_PRINT((ndo, \"\\n\\t    Option %s (%u), length: %u\",\n\t\t       tok2str(bgp_opt_values,\"Unknown\",\n\t\t\t\t  bgpopt.bgpopt_type),\n\t\t       bgpopt.bgpopt_type,\n\t\t       bgpopt.bgpopt_len));\n\n\t\t/* now let's decode the options we know*/\n\t\tswitch(bgpopt.bgpopt_type) {\n\n\t\tcase BGP_OPT_CAP:\n\t\t\tbgp_capabilities_print(ndo, &opt[i+BGP_OPT_SIZE],\n\t\t\t    bgpopt.bgpopt_len);\n\t\t\tbreak;\n\n\t\tcase BGP_OPT_AUTH:\n\t\tdefault:\n\t\t       ND_PRINT((ndo, \"\\n\\t      no decoder for option %u\",\n\t\t\t   bgpopt.bgpopt_type));\n\t\t       break;\n\t\t}\n\t\ti += BGP_OPT_SIZE + bgpopt.bgpopt_len;\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nbgp_update_print(netdissect_options *ndo,\n                 const u_char *dat, int length)\n{\n\tstruct bgp bgp;\n\tconst u_char *p;\n\tint withdrawn_routes_len;\n\tint len;\n\tint i;\n\n\tND_TCHECK2(dat[0], BGP_SIZE);\n\tif (length < BGP_SIZE)\n\t\tgoto trunc;\n\tmemcpy(&bgp, dat, BGP_SIZE);\n\tp = dat + BGP_SIZE;\t/*XXX*/\n\tlength -= BGP_SIZE;\n\n\t/* Unfeasible routes */\n\tND_TCHECK2(p[0], 2);\n\tif (length < 2)\n\t\tgoto trunc;\n\twithdrawn_routes_len = EXTRACT_16BITS(p);\n\tp += 2;\n\tlength -= 2;\n\tif (withdrawn_routes_len) {\n\t\t/*\n\t\t * Without keeping state from the original NLRI message,\n\t\t * it's not possible to tell if this a v4 or v6 route,\n\t\t * so only try to decode it if we're not v6 enabled.\n\t         */\n\t\tND_TCHECK2(p[0], withdrawn_routes_len);\n\t\tif (length < withdrawn_routes_len)\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t  Withdrawn routes: %d bytes\", withdrawn_routes_len));\n\t\tp += withdrawn_routes_len;\n\t\tlength -= withdrawn_routes_len;\n\t}\n\n\tND_TCHECK2(p[0], 2);\n\tif (length < 2)\n\t\tgoto trunc;\n\tlen = EXTRACT_16BITS(p);\n\tp += 2;\n\tlength -= 2;\n\n        if (withdrawn_routes_len == 0 && len == 0 && length == 0) {\n            /* No withdrawn routes, no path attributes, no NLRI */\n            ND_PRINT((ndo, \"\\n\\t  End-of-Rib Marker (empty NLRI)\"));\n            return;\n        }\n\n\tif (len) {\n\t\t/* do something more useful!*/\n\t\twhile (len) {\n\t\t\tint aflags, atype, alenlen, alen;\n\n\t\t\tND_TCHECK2(p[0], 2);\n\t\t\tif (len < 2)\n\t\t\t    goto trunc;\n\t\t\tif (length < 2)\n\t\t\t    goto trunc;\n\t\t\taflags = *p;\n\t\t\tatype = *(p + 1);\n\t\t\tp += 2;\n\t\t\tlen -= 2;\n\t\t\tlength -= 2;\n\t\t\talenlen = bgp_attr_lenlen(aflags, p);\n\t\t\tND_TCHECK2(p[0], alenlen);\n\t\t\tif (len < alenlen)\n\t\t\t    goto trunc;\n\t\t\tif (length < alenlen)\n\t\t\t    goto trunc;\n\t\t\talen = bgp_attr_len(aflags, p);\n\t\t\tp += alenlen;\n\t\t\tlen -= alenlen;\n\t\t\tlength -= alenlen;\n\n\t\t\tND_PRINT((ndo, \"\\n\\t  %s (%u), length: %u\",\n                              tok2str(bgp_attr_values, \"Unknown Attribute\",\n\t\t\t\t\t atype),\n                              atype,\n                              alen));\n\n\t\t\tif (aflags) {\n\t\t\t\tND_PRINT((ndo, \", Flags [%s%s%s%s\",\n\t\t\t\t\taflags & 0x80 ? \"O\" : \"\",\n\t\t\t\t\taflags & 0x40 ? \"T\" : \"\",\n\t\t\t\t\taflags & 0x20 ? \"P\" : \"\",\n\t\t\t\t\taflags & 0x10 ? \"E\" : \"\"));\n\t\t\t\tif (aflags & 0xf)\n\t\t\t\t\tND_PRINT((ndo, \"+%x\", aflags & 0xf));\n\t\t\t\tND_PRINT((ndo, \"]: \"));\n\t\t\t}\n\t\t\tif (len < alen)\n\t\t\t\tgoto trunc;\n\t\t\tif (length < alen)\n\t\t\t\tgoto trunc;\n\t\t\tif (!bgp_attr_print(ndo, atype, p, alen))\n\t\t\t\tgoto trunc;\n\t\t\tp += alen;\n\t\t\tlen -= alen;\n\t\t\tlength -= alen;\n\t\t}\n\t}\n\n\tif (length) {\n\t\t/*\n\t\t * XXX - what if they're using the \"Advertisement of\n\t\t * Multiple Paths in BGP\" feature:\n\t\t *\n\t\t * https://datatracker.ietf.org/doc/draft-ietf-idr-add-paths/\n\t\t *\n\t\t * http://tools.ietf.org/html/draft-ietf-idr-add-paths-06\n\t\t */\n\t\tND_PRINT((ndo, \"\\n\\t  Updated routes:\"));\n\t\twhile (length) {\n\t\t\tchar buf[MAXHOSTNAMELEN + 100];\n\t\t\ti = decode_prefix4(ndo, p, length, buf, sizeof(buf));\n\t\t\tif (i == -1) {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n\t\t\t\tbreak;\n\t\t\t} else if (i == -2)\n\t\t\t\tgoto trunc;\n\t\t\telse if (i == -3)\n\t\t\t\tgoto trunc; /* bytes left, but not enough */\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", buf));\n\t\t\t\tp += i;\n\t\t\t\tlength -= i;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nbgp_notification_print(netdissect_options *ndo,\n                       const u_char *dat, int length)\n{\n\tstruct bgp_notification bgpn;\n\tconst u_char *tptr;\n\n\tND_TCHECK2(dat[0], BGP_NOTIFICATION_SIZE);\n\tmemcpy(&bgpn, dat, BGP_NOTIFICATION_SIZE);\n\n        /* some little sanity checking */\n        if (length<BGP_NOTIFICATION_SIZE)\n            return;\n\n\tND_PRINT((ndo, \", %s (%u)\",\n\t       tok2str(bgp_notify_major_values, \"Unknown Error\",\n\t\t\t  bgpn.bgpn_major),\n\t       bgpn.bgpn_major));\n\n        switch (bgpn.bgpn_major) {\n\n        case BGP_NOTIFY_MAJOR_MSG:\n            ND_PRINT((ndo, \", subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_msg_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n            break;\n        case BGP_NOTIFY_MAJOR_OPEN:\n            ND_PRINT((ndo, \", subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_open_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n            break;\n        case BGP_NOTIFY_MAJOR_UPDATE:\n            ND_PRINT((ndo, \", subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_update_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n            break;\n        case BGP_NOTIFY_MAJOR_FSM:\n            ND_PRINT((ndo, \" subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_fsm_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n            break;\n        case BGP_NOTIFY_MAJOR_CAP:\n            ND_PRINT((ndo, \" subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_cap_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n            break;\n        case BGP_NOTIFY_MAJOR_CEASE:\n            ND_PRINT((ndo, \", subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_cease_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n\n\t    /* draft-ietf-idr-cease-subcode-02 mentions optionally 7 bytes\n             * for the maxprefix subtype, which may contain AFI, SAFI and MAXPREFIXES\n             */\n\t    if(bgpn.bgpn_minor == BGP_NOTIFY_MINOR_CEASE_MAXPRFX && length >= BGP_NOTIFICATION_SIZE + 7) {\n\t\ttptr = dat + BGP_NOTIFICATION_SIZE;\n\t\tND_TCHECK2(*tptr, 7);\n\t\tND_PRINT((ndo, \", AFI %s (%u), SAFI %s (%u), Max Prefixes: %u\",\n\t\t       tok2str(af_values, \"Unknown\",\n\t\t\t\t  EXTRACT_16BITS(tptr)),\n\t\t       EXTRACT_16BITS(tptr),\n\t\t       tok2str(bgp_safi_values, \"Unknown\", *(tptr+2)),\n\t\t       *(tptr+2),\n\t\t       EXTRACT_32BITS(tptr+3)));\n\t    }\n            break;\n        default:\n            break;\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nbgp_route_refresh_print(netdissect_options *ndo,\n                        const u_char *pptr, int len)\n{\n        const struct bgp_route_refresh *bgp_route_refresh_header;\n\n\tND_TCHECK2(pptr[0], BGP_ROUTE_REFRESH_SIZE);\n\n        /* some little sanity checking */\n        if (len<BGP_ROUTE_REFRESH_SIZE)\n            return;\n\n        bgp_route_refresh_header = (const struct bgp_route_refresh *)pptr;\n\n        ND_PRINT((ndo, \"\\n\\t  AFI %s (%u), SAFI %s (%u)\",\n               tok2str(af_values,\"Unknown\",\n\t\t\t  /* this stinks but the compiler pads the structure\n\t\t\t   * weird */\n\t\t\t  EXTRACT_16BITS(&bgp_route_refresh_header->afi)),\n               EXTRACT_16BITS(&bgp_route_refresh_header->afi),\n               tok2str(bgp_safi_values,\"Unknown\",\n\t\t\t  bgp_route_refresh_header->safi),\n               bgp_route_refresh_header->safi));\n\n        if (ndo->ndo_vflag > 1) {\n            ND_TCHECK2(*pptr, len);\n            print_unknown_data(ndo, pptr, \"\\n\\t  \", len);\n        }\n\n        return;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic int\nbgp_header_print(netdissect_options *ndo,\n                 const u_char *dat, int length)\n{\n\tstruct bgp bgp;\n\n\tND_TCHECK2(dat[0], BGP_SIZE);\n\tmemcpy(&bgp, dat, BGP_SIZE);\n\tND_PRINT((ndo, \"\\n\\t%s Message (%u), length: %u\",\n               tok2str(bgp_msg_values, \"Unknown\", bgp.bgp_type),\n               bgp.bgp_type,\n               length));\n\n\tswitch (bgp.bgp_type) {\n\tcase BGP_OPEN:\n\t\tbgp_open_print(ndo, dat, length);\n\t\tbreak;\n\tcase BGP_UPDATE:\n\t\tbgp_update_print(ndo, dat, length);\n\t\tbreak;\n\tcase BGP_NOTIFICATION:\n\t\tbgp_notification_print(ndo, dat, length);\n\t\tbreak;\n        case BGP_KEEPALIVE:\n                break;\n        case BGP_ROUTE_REFRESH:\n                bgp_route_refresh_print(ndo, dat, length);\n                break;\n        default:\n                /* we have no decoder for the BGP message */\n                ND_TCHECK2(*dat, length);\n                ND_PRINT((ndo, \"\\n\\t  no Message %u decoder\", bgp.bgp_type));\n                print_unknown_data(ndo, dat, \"\\n\\t  \", length);\n                break;\n\t}\n\treturn 1;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n\treturn 0;\n}\n\nvoid\nbgp_print(netdissect_options *ndo,\n          const u_char *dat, int length)\n{\n\tconst u_char *p;\n\tconst u_char *ep;\n\tconst u_char *start;\n\tconst u_char marker[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t};\n\tstruct bgp bgp;\n\tuint16_t hlen;\n\n\tep = dat + length;\n\tif (ndo->ndo_snapend < dat + length)\n\t\tep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \": BGP\"));\n\n        if (ndo->ndo_vflag < 1) /* lets be less chatty */\n                return;\n\n\tp = dat;\n\tstart = p;\n\twhile (p < ep) {\n\t\tif (!ND_TTEST2(p[0], 1))\n\t\t\tbreak;\n\t\tif (p[0] != 0xff) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ND_TTEST2(p[0], sizeof(marker)))\n\t\t\tbreak;\n\t\tif (memcmp(p, marker, sizeof(marker)) != 0) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* found BGP header */\n\t\tND_TCHECK2(p[0], BGP_SIZE);\t/*XXX*/\n\t\tmemcpy(&bgp, p, BGP_SIZE);\n\n\t\tif (start != p)\n\t\t\tND_PRINT((ndo, \" %s\", tstr));\n\n\t\thlen = ntohs(bgp.bgp_len);\n\t\tif (hlen < BGP_SIZE) {\n\t\t\tND_PRINT((ndo, \"\\n[|BGP Bogus header length %u < %u]\", hlen,\n\t\t\t    BGP_SIZE));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ND_TTEST2(p[0], hlen)) {\n\t\t\tif (!bgp_header_print(ndo, p, hlen))\n\t\t\t\treturn;\n\t\t\tp += hlen;\n\t\t\tstart = p;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"\\n[|BGP %s]\",\n\t\t\t       tok2str(bgp_msg_values,\n\t\t\t\t\t  \"Unknown Message Type\",\n\t\t\t\t\t  bgp.bgp_type)));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\n/*\n * Local Variables:\n * c-style: whitesmith\n * c-basic-offset: 4\n * End:\n */\n"], "fixing_code": ["/*\n * Copyright (C) 1999 WIDE Project.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the project nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n *\n * Extensively modified by Hannes Gredler (hannes@gredler.at) for more\n * complete BGP support.\n */\n\n/* \\summary: Border Gateway Protocol (BGP) printer */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <netdissect-stdinc.h>\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"netdissect.h\"\n#include \"addrtoname.h\"\n#include \"extract.h\"\n#include \"af.h\"\n#include \"l2vpn.h\"\n\nstatic const char tstr[] = \"[|BGP]\";\n\nstruct bgp {\n\tuint8_t bgp_marker[16];\n\tuint16_t bgp_len;\n\tuint8_t bgp_type;\n};\n#define BGP_SIZE\t\t19\t/* unaligned */\n\n#define BGP_OPEN\t\t1\n#define BGP_UPDATE\t\t2\n#define BGP_NOTIFICATION\t3\n#define BGP_KEEPALIVE\t\t4\n#define BGP_ROUTE_REFRESH       5\n\nstatic const struct tok bgp_msg_values[] = {\n    { BGP_OPEN,                 \"Open\"},\n    { BGP_UPDATE,               \"Update\"},\n    { BGP_NOTIFICATION,         \"Notification\"},\n    { BGP_KEEPALIVE,            \"Keepalive\"},\n    { BGP_ROUTE_REFRESH,        \"Route Refresh\"},\n    { 0, NULL}\n};\n\nstruct bgp_open {\n\tuint8_t bgpo_marker[16];\n\tuint16_t bgpo_len;\n\tuint8_t bgpo_type;\n\tuint8_t bgpo_version;\n\tuint16_t bgpo_myas;\n\tuint16_t bgpo_holdtime;\n\tuint32_t bgpo_id;\n\tuint8_t bgpo_optlen;\n\t/* options should follow */\n};\n#define BGP_OPEN_SIZE\t\t29\t/* unaligned */\n\nstruct bgp_opt {\n\tuint8_t bgpopt_type;\n\tuint8_t bgpopt_len;\n\t/* variable length */\n};\n#define BGP_OPT_SIZE\t\t2\t/* some compilers may pad to 4 bytes */\n#define BGP_CAP_HEADER_SIZE\t2\t/* some compilers may pad to 4 bytes */\n\nstruct bgp_notification {\n\tuint8_t bgpn_marker[16];\n\tuint16_t bgpn_len;\n\tuint8_t bgpn_type;\n\tuint8_t bgpn_major;\n\tuint8_t bgpn_minor;\n};\n#define BGP_NOTIFICATION_SIZE\t\t21\t/* unaligned */\n\nstruct bgp_route_refresh {\n    uint8_t  bgp_marker[16];\n    uint16_t len;\n    uint8_t  type;\n    uint8_t  afi[2]; /* the compiler messes this structure up               */\n    uint8_t  res;    /* when doing misaligned sequences of int8 and int16   */\n    uint8_t  safi;   /* afi should be int16 - so we have to access it using */\n};                    /* EXTRACT_16BITS(&bgp_route_refresh->afi) (sigh)      */\n#define BGP_ROUTE_REFRESH_SIZE          23\n\n#define bgp_attr_lenlen(flags, p) \\\n\t(((flags) & 0x10) ? 2 : 1)\n#define bgp_attr_len(flags, p) \\\n\t(((flags) & 0x10) ? EXTRACT_16BITS(p) : *(p))\n\n#define BGPTYPE_ORIGIN\t\t\t1\n#define BGPTYPE_AS_PATH\t\t\t2\n#define BGPTYPE_NEXT_HOP\t\t3\n#define BGPTYPE_MULTI_EXIT_DISC\t\t4\n#define BGPTYPE_LOCAL_PREF\t\t5\n#define BGPTYPE_ATOMIC_AGGREGATE\t6\n#define BGPTYPE_AGGREGATOR\t\t7\n#define\tBGPTYPE_COMMUNITIES\t\t8\t/* RFC1997 */\n#define\tBGPTYPE_ORIGINATOR_ID\t\t9\t/* RFC4456 */\n#define\tBGPTYPE_CLUSTER_LIST\t\t10\t/* RFC4456 */\n#define\tBGPTYPE_DPA\t\t\t11\t/* deprecated, draft-ietf-idr-bgp-dpa */\n#define\tBGPTYPE_ADVERTISERS\t\t12\t/* deprecated RFC1863 */\n#define\tBGPTYPE_RCID_PATH\t\t13\t/* deprecated RFC1863 */\n#define BGPTYPE_MP_REACH_NLRI\t\t14\t/* RFC4760 */\n#define BGPTYPE_MP_UNREACH_NLRI\t\t15\t/* RFC4760 */\n#define BGPTYPE_EXTD_COMMUNITIES        16      /* RFC4360 */\n#define BGPTYPE_AS4_PATH\t        17      /* RFC6793 */\n#define BGPTYPE_AGGREGATOR4\t\t18      /* RFC6793 */\n#define BGPTYPE_PMSI_TUNNEL             22      /* RFC6514 */\n#define BGPTYPE_TUNNEL_ENCAP            23      /* RFC5512 */\n#define BGPTYPE_TRAFFIC_ENG             24      /* RFC5543 */\n#define BGPTYPE_IPV6_EXTD_COMMUNITIES   25      /* RFC5701 */\n#define BGPTYPE_AIGP                    26      /* RFC7311 */\n#define BGPTYPE_PE_DISTINGUISHER_LABEL  27      /* RFC6514 */\n#define BGPTYPE_ENTROPY_LABEL           28      /* RFC6790 */\n#define BGPTYPE_LARGE_COMMUNITY\t\t32\t/* draft-ietf-idr-large-community-05 */\n#define BGPTYPE_ATTR_SET               128      /* RFC6368 */\n\n#define BGP_MP_NLRI_MINSIZE              3       /* End of RIB Marker detection */\n\nstatic const struct tok bgp_attr_values[] = {\n    { BGPTYPE_ORIGIN,           \"Origin\"},\n    { BGPTYPE_AS_PATH,          \"AS Path\"},\n    { BGPTYPE_AS4_PATH,         \"AS4 Path\"},\n    { BGPTYPE_NEXT_HOP,         \"Next Hop\"},\n    { BGPTYPE_MULTI_EXIT_DISC,  \"Multi Exit Discriminator\"},\n    { BGPTYPE_LOCAL_PREF,       \"Local Preference\"},\n    { BGPTYPE_ATOMIC_AGGREGATE, \"Atomic Aggregate\"},\n    { BGPTYPE_AGGREGATOR,       \"Aggregator\"},\n    { BGPTYPE_AGGREGATOR4,      \"Aggregator4\"},\n    { BGPTYPE_COMMUNITIES,      \"Community\"},\n    { BGPTYPE_ORIGINATOR_ID,    \"Originator ID\"},\n    { BGPTYPE_CLUSTER_LIST,     \"Cluster List\"},\n    { BGPTYPE_DPA,              \"DPA\"},\n    { BGPTYPE_ADVERTISERS,      \"Advertisers\"},\n    { BGPTYPE_RCID_PATH,        \"RCID Path / Cluster ID\"},\n    { BGPTYPE_MP_REACH_NLRI,    \"Multi-Protocol Reach NLRI\"},\n    { BGPTYPE_MP_UNREACH_NLRI,  \"Multi-Protocol Unreach NLRI\"},\n    { BGPTYPE_EXTD_COMMUNITIES, \"Extended Community\"},\n    { BGPTYPE_PMSI_TUNNEL,      \"PMSI Tunnel\"},\n    { BGPTYPE_TUNNEL_ENCAP,     \"Tunnel Encapsulation\"},\n    { BGPTYPE_TRAFFIC_ENG,      \"Traffic Engineering\"},\n    { BGPTYPE_IPV6_EXTD_COMMUNITIES, \"IPv6 Extended Community\"},\n    { BGPTYPE_AIGP,             \"Accumulated IGP Metric\"},\n    { BGPTYPE_PE_DISTINGUISHER_LABEL, \"PE Distinguisher Label\"},\n    { BGPTYPE_ENTROPY_LABEL,    \"Entropy Label\"},\n    { BGPTYPE_LARGE_COMMUNITY,  \"Large Community\"},\n    { BGPTYPE_ATTR_SET,         \"Attribute Set\"},\n    { 255,                      \"Reserved for development\"},\n    { 0, NULL}\n};\n\n#define BGP_AS_SET             1\n#define BGP_AS_SEQUENCE        2\n#define BGP_CONFED_AS_SEQUENCE 3 /* draft-ietf-idr-rfc3065bis-01 */\n#define BGP_CONFED_AS_SET      4 /* draft-ietf-idr-rfc3065bis-01  */\n\n#define BGP_AS_SEG_TYPE_MIN    BGP_AS_SET\n#define BGP_AS_SEG_TYPE_MAX    BGP_CONFED_AS_SET\n\nstatic const struct tok bgp_as_path_segment_open_values[] = {\n    { BGP_AS_SEQUENCE,         \"\"},\n    { BGP_AS_SET,              \"{ \"},\n    { BGP_CONFED_AS_SEQUENCE,  \"( \"},\n    { BGP_CONFED_AS_SET,       \"({ \"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_as_path_segment_close_values[] = {\n    { BGP_AS_SEQUENCE,         \"\"},\n    { BGP_AS_SET,              \"}\"},\n    { BGP_CONFED_AS_SEQUENCE,  \")\"},\n    { BGP_CONFED_AS_SET,       \"})\"},\n    { 0, NULL}\n};\n\n#define BGP_OPT_AUTH                    1\n#define BGP_OPT_CAP                     2\n\nstatic const struct tok bgp_opt_values[] = {\n    { BGP_OPT_AUTH,             \"Authentication Information\"},\n    { BGP_OPT_CAP,              \"Capabilities Advertisement\"},\n    { 0, NULL}\n};\n\n#define BGP_CAPCODE_MP                  1 /* RFC2858 */\n#define BGP_CAPCODE_RR                  2 /* RFC2918 */\n#define BGP_CAPCODE_ORF                 3 /* RFC5291 */\n#define BGP_CAPCODE_MR                  4 /* RFC3107 */\n#define BGP_CAPCODE_EXT_NH              5 /* RFC5549 */\n#define BGP_CAPCODE_RESTART            64 /* RFC4724  */\n#define BGP_CAPCODE_AS_NEW             65 /* RFC6793 */\n#define BGP_CAPCODE_DYN_CAP            67 /* draft-ietf-idr-dynamic-cap */\n#define BGP_CAPCODE_MULTISESS          68 /* draft-ietf-idr-bgp-multisession */\n#define BGP_CAPCODE_ADD_PATH           69 /* RFC7911 */\n#define BGP_CAPCODE_ENH_RR             70 /* draft-keyur-bgp-enhanced-route-refresh */\n#define BGP_CAPCODE_RR_CISCO          128\n\nstatic const struct tok bgp_capcode_values[] = {\n    { BGP_CAPCODE_MP,           \"Multiprotocol Extensions\"},\n    { BGP_CAPCODE_RR,           \"Route Refresh\"},\n    { BGP_CAPCODE_ORF,          \"Cooperative Route Filtering\"},\n    { BGP_CAPCODE_MR,           \"Multiple Routes to a Destination\"},\n    { BGP_CAPCODE_EXT_NH,       \"Extended Next Hop Encoding\"},\n    { BGP_CAPCODE_RESTART,      \"Graceful Restart\"},\n    { BGP_CAPCODE_AS_NEW,       \"32-Bit AS Number\"},\n    { BGP_CAPCODE_DYN_CAP,      \"Dynamic Capability\"},\n    { BGP_CAPCODE_MULTISESS,    \"Multisession BGP\"},\n    { BGP_CAPCODE_ADD_PATH,     \"Multiple Paths\"},\n    { BGP_CAPCODE_ENH_RR,       \"Enhanced Route Refresh\"},\n    { BGP_CAPCODE_RR_CISCO,     \"Route Refresh (Cisco)\"},\n    { 0, NULL}\n};\n\n#define BGP_NOTIFY_MAJOR_MSG            1\n#define BGP_NOTIFY_MAJOR_OPEN           2\n#define BGP_NOTIFY_MAJOR_UPDATE         3\n#define BGP_NOTIFY_MAJOR_HOLDTIME       4\n#define BGP_NOTIFY_MAJOR_FSM            5\n#define BGP_NOTIFY_MAJOR_CEASE          6\n#define BGP_NOTIFY_MAJOR_CAP            7\n\nstatic const struct tok bgp_notify_major_values[] = {\n    { BGP_NOTIFY_MAJOR_MSG,     \"Message Header Error\"},\n    { BGP_NOTIFY_MAJOR_OPEN,    \"OPEN Message Error\"},\n    { BGP_NOTIFY_MAJOR_UPDATE,  \"UPDATE Message Error\"},\n    { BGP_NOTIFY_MAJOR_HOLDTIME,\"Hold Timer Expired\"},\n    { BGP_NOTIFY_MAJOR_FSM,     \"Finite State Machine Error\"},\n    { BGP_NOTIFY_MAJOR_CEASE,   \"Cease\"},\n    { BGP_NOTIFY_MAJOR_CAP,     \"Capability Message Error\"},\n    { 0, NULL}\n};\n\n/* draft-ietf-idr-cease-subcode-02 */\n#define BGP_NOTIFY_MINOR_CEASE_MAXPRFX  1\nstatic const struct tok bgp_notify_minor_cease_values[] = {\n    { BGP_NOTIFY_MINOR_CEASE_MAXPRFX, \"Maximum Number of Prefixes Reached\"},\n    { 2,                        \"Administratively Shutdown\"},\n    { 3,                        \"Peer Unconfigured\"},\n    { 4,                        \"Administratively Reset\"},\n    { 5,                        \"Connection Rejected\"},\n    { 6,                        \"Other Configuration Change\"},\n    { 7,                        \"Connection Collision Resolution\"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_notify_minor_msg_values[] = {\n    { 1,                        \"Connection Not Synchronized\"},\n    { 2,                        \"Bad Message Length\"},\n    { 3,                        \"Bad Message Type\"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_notify_minor_open_values[] = {\n    { 1,                        \"Unsupported Version Number\"},\n    { 2,                        \"Bad Peer AS\"},\n    { 3,                        \"Bad BGP Identifier\"},\n    { 4,                        \"Unsupported Optional Parameter\"},\n    { 5,                        \"Authentication Failure\"},\n    { 6,                        \"Unacceptable Hold Time\"},\n    { 7,                        \"Capability Message Error\"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_notify_minor_update_values[] = {\n    { 1,                        \"Malformed Attribute List\"},\n    { 2,                        \"Unrecognized Well-known Attribute\"},\n    { 3,                        \"Missing Well-known Attribute\"},\n    { 4,                        \"Attribute Flags Error\"},\n    { 5,                        \"Attribute Length Error\"},\n    { 6,                        \"Invalid ORIGIN Attribute\"},\n    { 7,                        \"AS Routing Loop\"},\n    { 8,                        \"Invalid NEXT_HOP Attribute\"},\n    { 9,                        \"Optional Attribute Error\"},\n    { 10,                       \"Invalid Network Field\"},\n    { 11,                       \"Malformed AS_PATH\"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_notify_minor_fsm_values[] = {\n    { 1,                        \"In OpenSent State\"},\n    { 2,                        \"In OpenConfirm State\"},\n    { 3,                        \"In Established State\"},\n    { 0, NULL }\n};\n\nstatic const struct tok bgp_notify_minor_cap_values[] = {\n    { 1,                        \"Invalid Action Value\" },\n    { 2,                        \"Invalid Capability Length\" },\n    { 3,                        \"Malformed Capability Value\" },\n    { 4,                        \"Unsupported Capability Code\" },\n    { 0, NULL }\n};\n\nstatic const struct tok bgp_origin_values[] = {\n    { 0,                        \"IGP\"},\n    { 1,                        \"EGP\"},\n    { 2,                        \"Incomplete\"},\n    { 0, NULL}\n};\n\n#define BGP_PMSI_TUNNEL_RSVP_P2MP 1\n#define BGP_PMSI_TUNNEL_LDP_P2MP  2\n#define BGP_PMSI_TUNNEL_PIM_SSM   3\n#define BGP_PMSI_TUNNEL_PIM_SM    4\n#define BGP_PMSI_TUNNEL_PIM_BIDIR 5\n#define BGP_PMSI_TUNNEL_INGRESS   6\n#define BGP_PMSI_TUNNEL_LDP_MP2MP 7\n\nstatic const struct tok bgp_pmsi_tunnel_values[] = {\n    { BGP_PMSI_TUNNEL_RSVP_P2MP, \"RSVP-TE P2MP LSP\"},\n    { BGP_PMSI_TUNNEL_LDP_P2MP, \"LDP P2MP LSP\"},\n    { BGP_PMSI_TUNNEL_PIM_SSM, \"PIM-SSM Tree\"},\n    { BGP_PMSI_TUNNEL_PIM_SM, \"PIM-SM Tree\"},\n    { BGP_PMSI_TUNNEL_PIM_BIDIR, \"PIM-Bidir Tree\"},\n    { BGP_PMSI_TUNNEL_INGRESS, \"Ingress Replication\"},\n    { BGP_PMSI_TUNNEL_LDP_MP2MP, \"LDP MP2MP LSP\"},\n    { 0, NULL}\n};\n\nstatic const struct tok bgp_pmsi_flag_values[] = {\n    { 0x01, \"Leaf Information required\"},\n    { 0, NULL}\n};\n\n#define BGP_AIGP_TLV 1\n\nstatic const struct tok bgp_aigp_values[] = {\n    { BGP_AIGP_TLV, \"AIGP\"},\n    { 0, NULL}\n};\n\n/* Subsequent address family identifier, RFC2283 section 7 */\n#define SAFNUM_RES                      0\n#define SAFNUM_UNICAST                  1\n#define SAFNUM_MULTICAST                2\n#define SAFNUM_UNIMULTICAST             3       /* deprecated now */\n/* labeled BGP RFC3107 */\n#define SAFNUM_LABUNICAST               4\n/* RFC6514 */\n#define SAFNUM_MULTICAST_VPN            5\n/* draft-nalawade-kapoor-tunnel-safi */\n#define SAFNUM_TUNNEL                   64\n/* RFC4761 */\n#define SAFNUM_VPLS                     65\n/* RFC6037 */\n#define SAFNUM_MDT                      66\n/* RFC4364 */\n#define SAFNUM_VPNUNICAST               128\n/* RFC6513 */\n#define SAFNUM_VPNMULTICAST             129\n#define SAFNUM_VPNUNIMULTICAST          130     /* deprecated now */\n/* RFC4684 */\n#define SAFNUM_RT_ROUTING_INFO          132\n\n#define BGP_VPN_RD_LEN                  8\n\nstatic const struct tok bgp_safi_values[] = {\n    { SAFNUM_RES,               \"Reserved\"},\n    { SAFNUM_UNICAST,           \"Unicast\"},\n    { SAFNUM_MULTICAST,         \"Multicast\"},\n    { SAFNUM_UNIMULTICAST,      \"Unicast+Multicast\"},\n    { SAFNUM_LABUNICAST,        \"labeled Unicast\"},\n    { SAFNUM_TUNNEL,            \"Tunnel\"},\n    { SAFNUM_VPLS,              \"VPLS\"},\n    { SAFNUM_MDT,               \"MDT\"},\n    { SAFNUM_VPNUNICAST,        \"labeled VPN Unicast\"},\n    { SAFNUM_VPNMULTICAST,      \"labeled VPN Multicast\"},\n    { SAFNUM_VPNUNIMULTICAST,   \"labeled VPN Unicast+Multicast\"},\n    { SAFNUM_RT_ROUTING_INFO,   \"Route Target Routing Information\"},\n    { SAFNUM_MULTICAST_VPN,     \"Multicast VPN\"},\n    { 0, NULL }\n};\n\n/* well-known community */\n#define BGP_COMMUNITY_NO_EXPORT\t\t\t0xffffff01\n#define BGP_COMMUNITY_NO_ADVERT\t\t\t0xffffff02\n#define BGP_COMMUNITY_NO_EXPORT_SUBCONFED\t0xffffff03\n\n/* Extended community type - draft-ietf-idr-bgp-ext-communities-05 */\n#define BGP_EXT_COM_RT_0        0x0002  /* Route Target,Format AS(2bytes):AN(4bytes) */\n#define BGP_EXT_COM_RT_1        0x0102  /* Route Target,Format IP address:AN(2bytes) */\n#define BGP_EXT_COM_RT_2        0x0202  /* Route Target,Format AN(4bytes):local(2bytes) */\n#define BGP_EXT_COM_RO_0        0x0003  /* Route Origin,Format AS(2bytes):AN(4bytes) */\n#define BGP_EXT_COM_RO_1        0x0103  /* Route Origin,Format IP address:AN(2bytes) */\n#define BGP_EXT_COM_RO_2        0x0203  /* Route Origin,Format AN(4bytes):local(2bytes) */\n#define BGP_EXT_COM_LINKBAND    0x4004  /* Link Bandwidth,Format AS(2B):Bandwidth(4B) */\n                                        /* rfc2547 bgp-mpls-vpns */\n#define BGP_EXT_COM_VPN_ORIGIN  0x0005  /* OSPF Domain ID / VPN of Origin  - draft-rosen-vpns-ospf-bgp-mpls */\n#define BGP_EXT_COM_VPN_ORIGIN2 0x0105  /* duplicate - keep for backwards compatability */\n#define BGP_EXT_COM_VPN_ORIGIN3 0x0205  /* duplicate - keep for backwards compatability */\n#define BGP_EXT_COM_VPN_ORIGIN4 0x8005  /* duplicate - keep for backwards compatability */\n\n#define BGP_EXT_COM_OSPF_RTYPE  0x0306  /* OSPF Route Type,Format Area(4B):RouteType(1B):Options(1B) */\n#define BGP_EXT_COM_OSPF_RTYPE2 0x8000  /* duplicate - keep for backwards compatability */\n\n#define BGP_EXT_COM_OSPF_RID    0x0107  /* OSPF Router ID,Format RouterID(4B):Unused(2B) */\n#define BGP_EXT_COM_OSPF_RID2   0x8001  /* duplicate - keep for backwards compatability */\n\n#define BGP_EXT_COM_L2INFO      0x800a  /* draft-kompella-ppvpn-l2vpn */\n\n#define BGP_EXT_COM_SOURCE_AS   0x0009  /* RFC-ietf-l3vpn-2547bis-mcast-bgp-08.txt */\n#define BGP_EXT_COM_VRF_RT_IMP  0x010b  /* RFC-ietf-l3vpn-2547bis-mcast-bgp-08.txt */\n#define BGP_EXT_COM_L2VPN_RT_0  0x000a  /* L2VPN Identifier,Format AS(2bytes):AN(4bytes) */\n#define BGP_EXT_COM_L2VPN_RT_1  0xF10a  /* L2VPN Identifier,Format IP address:AN(2bytes) */\n\n/* http://www.cisco.com/en/US/tech/tk436/tk428/technologies_tech_note09186a00801eb09a.shtml  */\n#define BGP_EXT_COM_EIGRP_GEN   0x8800\n#define BGP_EXT_COM_EIGRP_METRIC_AS_DELAY  0x8801\n#define BGP_EXT_COM_EIGRP_METRIC_REL_NH_BW 0x8802\n#define BGP_EXT_COM_EIGRP_METRIC_LOAD_MTU  0x8803\n#define BGP_EXT_COM_EIGRP_EXT_REMAS_REMID  0x8804\n#define BGP_EXT_COM_EIGRP_EXT_REMPROTO_REMMETRIC 0x8805\n\nstatic const struct tok bgp_extd_comm_flag_values[] = {\n    { 0x8000,                  \"vendor-specific\"},\n    { 0x4000,                  \"non-transitive\"},\n    { 0, NULL},\n};\n\nstatic const struct tok bgp_extd_comm_subtype_values[] = {\n    { BGP_EXT_COM_RT_0,        \"target\"},\n    { BGP_EXT_COM_RT_1,        \"target\"},\n    { BGP_EXT_COM_RT_2,        \"target\"},\n    { BGP_EXT_COM_RO_0,        \"origin\"},\n    { BGP_EXT_COM_RO_1,        \"origin\"},\n    { BGP_EXT_COM_RO_2,        \"origin\"},\n    { BGP_EXT_COM_LINKBAND,    \"link-BW\"},\n    { BGP_EXT_COM_VPN_ORIGIN,  \"ospf-domain\"},\n    { BGP_EXT_COM_VPN_ORIGIN2, \"ospf-domain\"},\n    { BGP_EXT_COM_VPN_ORIGIN3, \"ospf-domain\"},\n    { BGP_EXT_COM_VPN_ORIGIN4, \"ospf-domain\"},\n    { BGP_EXT_COM_OSPF_RTYPE,  \"ospf-route-type\"},\n    { BGP_EXT_COM_OSPF_RTYPE2, \"ospf-route-type\"},\n    { BGP_EXT_COM_OSPF_RID,    \"ospf-router-id\"},\n    { BGP_EXT_COM_OSPF_RID2,   \"ospf-router-id\"},\n    { BGP_EXT_COM_L2INFO,      \"layer2-info\"},\n    { BGP_EXT_COM_EIGRP_GEN , \"eigrp-general-route (flag, tag)\" },\n    { BGP_EXT_COM_EIGRP_METRIC_AS_DELAY , \"eigrp-route-metric (AS, delay)\" },\n    { BGP_EXT_COM_EIGRP_METRIC_REL_NH_BW , \"eigrp-route-metric (reliability, nexthop, bandwidth)\" },\n    { BGP_EXT_COM_EIGRP_METRIC_LOAD_MTU , \"eigrp-route-metric (load, MTU)\" },\n    { BGP_EXT_COM_EIGRP_EXT_REMAS_REMID , \"eigrp-external-route (remote-AS, remote-ID)\" },\n    { BGP_EXT_COM_EIGRP_EXT_REMPROTO_REMMETRIC , \"eigrp-external-route (remote-proto, remote-metric)\" },\n    { BGP_EXT_COM_SOURCE_AS, \"source-AS\" },\n    { BGP_EXT_COM_VRF_RT_IMP, \"vrf-route-import\"},\n    { BGP_EXT_COM_L2VPN_RT_0, \"l2vpn-id\"},\n    { BGP_EXT_COM_L2VPN_RT_1, \"l2vpn-id\"},\n    { 0, NULL},\n};\n\n/* OSPF codes for  BGP_EXT_COM_OSPF_RTYPE draft-rosen-vpns-ospf-bgp-mpls  */\n#define BGP_OSPF_RTYPE_RTR      1 /* OSPF Router LSA */\n#define BGP_OSPF_RTYPE_NET      2 /* OSPF Network LSA */\n#define BGP_OSPF_RTYPE_SUM      3 /* OSPF Summary LSA */\n#define BGP_OSPF_RTYPE_EXT      5 /* OSPF External LSA, note that ASBR doesn't apply to MPLS-VPN */\n#define BGP_OSPF_RTYPE_NSSA     7 /* OSPF NSSA External*/\n#define BGP_OSPF_RTYPE_SHAM     129 /* OSPF-MPLS-VPN Sham link */\n#define BGP_OSPF_RTYPE_METRIC_TYPE 0x1 /* LSB of RTYPE Options Field */\n\nstatic const struct tok bgp_extd_comm_ospf_rtype_values[] = {\n  { BGP_OSPF_RTYPE_RTR, \"Router\" },\n  { BGP_OSPF_RTYPE_NET, \"Network\" },\n  { BGP_OSPF_RTYPE_SUM, \"Summary\" },\n  { BGP_OSPF_RTYPE_EXT, \"External\" },\n  { BGP_OSPF_RTYPE_NSSA,\"NSSA External\" },\n  { BGP_OSPF_RTYPE_SHAM,\"MPLS-VPN Sham\" },\n  { 0, NULL },\n};\n\n/* ADD-PATH Send/Receive field values */\nstatic const struct tok bgp_add_path_recvsend[] = {\n  { 1, \"Receive\" },\n  { 2, \"Send\" },\n  { 3, \"Both\" },\n  { 0, NULL },\n};\n\nstatic char astostr[20];\n\n/*\n * as_printf\n *\n * Convert an AS number into a string and return string pointer.\n *\n * Depending on bflag is set or not, AS number is converted into ASDOT notation\n * or plain number notation.\n *\n */\nstatic char *\nas_printf(netdissect_options *ndo,\n          char *str, int size, u_int asnum)\n{\n\tif (!ndo->ndo_bflag || asnum <= 0xFFFF) {\n\t\tsnprintf(str, size, \"%u\", asnum);\n\t} else {\n\t\tsnprintf(str, size, \"%u.%u\", asnum >> 16, asnum & 0xFFFF);\n\t}\n\treturn str;\n}\n\n#define ITEMCHECK(minlen) if (itemlen < minlen) goto badtlv;\n\nint\ndecode_prefix4(netdissect_options *ndo,\n               const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in_addr addr;\n\tu_int plen, plenbytes;\n\n\tND_TCHECK(pptr[0]);\n\tITEMCHECK(1);\n\tplen = pptr[0];\n\tif (32 < plen)\n\t\treturn -1;\n\titemlen -= 1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[1], plenbytes);\n\tITEMCHECK(plenbytes);\n\tmemcpy(&addr, &pptr[1], plenbytes);\n\tif (plen % 8) {\n\t\t((u_char *)&addr)[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d\", ipaddr_string(ndo, &addr), plen);\n\treturn 1 + plenbytes;\n\ntrunc:\n\treturn -2;\n\nbadtlv:\n\treturn -3;\n}\n\nstatic int\ndecode_labeled_prefix4(netdissect_options *ndo,\n                       const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in_addr addr;\n\tu_int plen, plenbytes;\n\n\t/* prefix length and label = 4 bytes */\n\tND_TCHECK2(pptr[0], 4);\n\tITEMCHECK(4);\n\tplen = pptr[0];   /* get prefix length */\n\n        /* this is one of the weirdnesses of rfc3107\n           the label length (actually the label + COS bits)\n           is added to the prefix length;\n           we also do only read out just one label -\n           there is no real application for advertisement of\n           stacked labels in a single BGP message\n        */\n\n\tif (24 > plen)\n\t\treturn -1;\n\n        plen-=24; /* adjust prefixlen - labellength */\n\n\tif (32 < plen)\n\t\treturn -1;\n\titemlen -= 4;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[4], plenbytes);\n\tITEMCHECK(plenbytes);\n\tmemcpy(&addr, &pptr[4], plenbytes);\n\tif (plen % 8) {\n\t\t((u_char *)&addr)[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n        /* the label may get offsetted by 4 bits so lets shift it right */\n\tsnprintf(buf, buflen, \"%s/%d, label:%u %s\",\n                 ipaddr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\n\treturn 4 + plenbytes;\n\ntrunc:\n\treturn -2;\n\nbadtlv:\n\treturn -3;\n}\n\n/*\n * bgp_vpn_ip_print\n *\n * print an ipv4 or ipv6 address into a buffer dependend on address length.\n */\nstatic char *\nbgp_vpn_ip_print(netdissect_options *ndo,\n                 const u_char *pptr, u_int addr_length)\n{\n\n    /* worst case string is s fully formatted v6 address */\n    static char addr[sizeof(\"1234:5678:89ab:cdef:1234:5678:89ab:cdef\")];\n    char *pos = addr;\n\n    switch(addr_length) {\n    case (sizeof(struct in_addr) << 3): /* 32 */\n        ND_TCHECK2(pptr[0], sizeof(struct in_addr));\n        snprintf(pos, sizeof(addr), \"%s\", ipaddr_string(ndo, pptr));\n        break;\n    case (sizeof(struct in6_addr) << 3): /* 128 */\n        ND_TCHECK2(pptr[0], sizeof(struct in6_addr));\n        snprintf(pos, sizeof(addr), \"%s\", ip6addr_string(ndo, pptr));\n        break;\n    default:\n        snprintf(pos, sizeof(addr), \"bogus address length %u\", addr_length);\n        break;\n    }\n    pos += strlen(pos);\n\ntrunc:\n    *(pos) = '\\0';\n    return (addr);\n}\n\n/*\n * bgp_vpn_sg_print\n *\n * print an multicast s,g entry into a buffer.\n * the s,g entry is encoded like this.\n *\n * +-----------------------------------+\n * | Multicast Source Length (1 octet) |\n * +-----------------------------------+\n * |   Multicast Source (Variable)     |\n * +-----------------------------------+\n * |  Multicast Group Length (1 octet) |\n * +-----------------------------------+\n * |  Multicast Group   (Variable)     |\n * +-----------------------------------+\n *\n * return the number of bytes read from the wire.\n */\nstatic int\nbgp_vpn_sg_print(netdissect_options *ndo,\n                 const u_char *pptr, char *buf, u_int buflen)\n{\n    uint8_t addr_length;\n    u_int total_length, offset;\n\n    total_length = 0;\n\n    /* Source address length, encoded in bits */\n    ND_TCHECK2(pptr[0], 1);\n    addr_length =  *pptr++;\n\n    /* Source address */\n    ND_TCHECK2(pptr[0], (addr_length >> 3));\n    total_length += (addr_length >> 3) + 1;\n    offset = strlen(buf);\n    if (addr_length) {\n        snprintf(buf + offset, buflen - offset, \", Source %s\",\n                 bgp_vpn_ip_print(ndo, pptr, addr_length));\n        pptr += (addr_length >> 3);\n    }\n\n    /* Group address length, encoded in bits */\n    ND_TCHECK2(pptr[0], 1);\n    addr_length =  *pptr++;\n\n    /* Group address */\n    ND_TCHECK2(pptr[0], (addr_length >> 3));\n    total_length += (addr_length >> 3) + 1;\n    offset = strlen(buf);\n    if (addr_length) {\n        snprintf(buf + offset, buflen - offset, \", Group %s\",\n                 bgp_vpn_ip_print(ndo, pptr, addr_length));\n        pptr += (addr_length >> 3);\n    }\n\ntrunc:\n    return (total_length);\n}\n\n/* RDs and RTs share the same semantics\n * we use bgp_vpn_rd_print for\n * printing route targets inside a NLRI */\nchar *\nbgp_vpn_rd_print(netdissect_options *ndo,\n                 const u_char *pptr)\n{\n   /* allocate space for the largest possible string */\n    static char rd[sizeof(\"xxxxxxxxxx:xxxxx (xxx.xxx.xxx.xxx:xxxxx)\")];\n    char *pos = rd;\n\n    /* ok lets load the RD format */\n    switch (EXTRACT_16BITS(pptr)) {\n\n        /* 2-byte-AS:number fmt*/\n    case 0:\n        snprintf(pos, sizeof(rd) - (pos - rd), \"%u:%u (= %u.%u.%u.%u)\",\n                 EXTRACT_16BITS(pptr+2),\n                 EXTRACT_32BITS(pptr+4),\n                 *(pptr+4), *(pptr+5), *(pptr+6), *(pptr+7));\n        break;\n        /* IP-address:AS fmt*/\n\n    case 1:\n        snprintf(pos, sizeof(rd) - (pos - rd), \"%u.%u.%u.%u:%u\",\n            *(pptr+2), *(pptr+3), *(pptr+4), *(pptr+5), EXTRACT_16BITS(pptr+6));\n        break;\n\n        /* 4-byte-AS:number fmt*/\n    case 2:\n\tsnprintf(pos, sizeof(rd) - (pos - rd), \"%s:%u (%u.%u.%u.%u:%u)\",\n\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(pptr+2)),\n\t    EXTRACT_16BITS(pptr+6), *(pptr+2), *(pptr+3), *(pptr+4),\n\t    *(pptr+5), EXTRACT_16BITS(pptr+6));\n        break;\n    default:\n        snprintf(pos, sizeof(rd) - (pos - rd), \"unknown RD format\");\n        break;\n    }\n    pos += strlen(pos);\n    *(pos) = '\\0';\n    return (rd);\n}\n\nstatic int\ndecode_rt_routing_info(netdissect_options *ndo,\n                       const u_char *pptr, char *buf, u_int buflen)\n{\n\tuint8_t route_target[8];\n\tu_int plen;\n\tchar asbuf[sizeof(astostr)]; /* bgp_vpn_rd_print() overwrites astostr */\n\n\t/* NLRI \"prefix length\" from RFC 2858 Section 4. */\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\t/* NLRI \"prefix\" (ibid), valid lengths are { 0, 32, 33, ..., 96 } bits.\n\t * RFC 4684 Section 4 defines the layout of \"origin AS\" and \"route\n\t * target\" fields inside the \"prefix\" depending on its length.\n\t */\n\tif (0 == plen) {\n\t\t/* Without \"origin AS\", without \"route target\". */\n\t\tsnprintf(buf, buflen, \"default route target\");\n\t\treturn 1;\n\t}\n\n\tif (32 > plen)\n\t\treturn -1;\n\n\t/* With at least \"origin AS\", possibly with \"route target\". */\n\tND_TCHECK_32BITS(pptr + 1);\n\tas_printf(ndo, asbuf, sizeof(asbuf), EXTRACT_32BITS(pptr + 1));\n\n        plen-=32; /* adjust prefix length */\n\n\tif (64 < plen)\n\t\treturn -1;\n\n\t/* From now on (plen + 7) / 8 evaluates to { 0, 1, 2, ..., 8 }\n\t * and gives the number of octets in the variable-length \"route\n\t * target\" field inside this NLRI \"prefix\". Look for it.\n\t */\n\tmemset(&route_target, 0, sizeof(route_target));\n\tND_TCHECK2(pptr[5], (plen + 7) / 8);\n\tmemcpy(&route_target, &pptr[5], (plen + 7) / 8);\n\t/* Which specification says to do this? */\n\tif (plen % 8) {\n\t\t((u_char *)&route_target)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"origin AS: %s, route target %s\",\n\t    asbuf,\n\t    bgp_vpn_rd_print(ndo, (u_char *)&route_target));\n\n\treturn 5 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n\nstatic int\ndecode_labeled_vpn_prefix4(netdissect_options *ndo,\n                           const u_char *pptr, char *buf, u_int buflen)\n{\n\tstruct in_addr addr;\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif ((24+64) > plen)\n\t\treturn -1;\n\n        plen-=(24+64); /* adjust prefixlen - labellength - RD len*/\n\n\tif (32 < plen)\n\t\treturn -1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\t((u_char *)&addr)[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n        /* the label may get offsetted by 4 bits so lets shift it right */\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 ipaddr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\n\treturn 12 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n\n/*\n * +-------------------------------+\n * |                               |\n * |  RD:IPv4-address (12 octets)  |\n * |                               |\n * +-------------------------------+\n * |  MDT Group-address (4 octets) |\n * +-------------------------------+\n */\n\n#define MDT_VPN_NLRI_LEN 16\n\nstatic int\ndecode_mdt_vpn_nlri(netdissect_options *ndo,\n                    const u_char *pptr, char *buf, u_int buflen)\n{\n\n    const u_char *rd;\n    const u_char *vpn_ip;\n\n    ND_TCHECK(pptr[0]);\n\n    /* if the NLRI is not predefined length, quit.*/\n    if (*pptr != MDT_VPN_NLRI_LEN * 8)\n\treturn -1;\n    pptr++;\n\n    /* RD */\n    ND_TCHECK2(pptr[0], 8);\n    rd = pptr;\n    pptr+=8;\n\n    /* IPv4 address */\n    ND_TCHECK2(pptr[0], sizeof(struct in_addr));\n    vpn_ip = pptr;\n    pptr+=sizeof(struct in_addr);\n\n    /* MDT Group Address */\n    ND_TCHECK2(pptr[0], sizeof(struct in_addr));\n\n    snprintf(buf, buflen, \"RD: %s, VPN IP Address: %s, MC Group Address: %s\",\n\t     bgp_vpn_rd_print(ndo, rd), ipaddr_string(ndo, vpn_ip), ipaddr_string(ndo, pptr));\n\n    return MDT_VPN_NLRI_LEN + 1;\n\n trunc:\n\nreturn -2;\n}\n\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI   1\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI   2\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI            3\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF 4\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE     5\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN  6\n#define BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN  7\n\nstatic const struct tok bgp_multicast_vpn_route_type_values[] = {\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI, \"Intra-AS I-PMSI\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI, \"Inter-AS I-PMSI\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI, \"S-PMSI\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF, \"Intra-AS Segment-Leaf\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE, \"Source-Active\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN, \"Shared Tree Join\"},\n    { BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN, \"Source Tree Join\"},\n    { 0, NULL}\n};\n\nstatic int\ndecode_multicast_vpn(netdissect_options *ndo,\n                     const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t route_type, route_length, addr_length, sg_length;\n        u_int offset;\n\n\tND_TCHECK2(pptr[0], 2);\n        route_type = *pptr++;\n        route_length = *pptr++;\n\n        snprintf(buf, buflen, \"Route-Type: %s (%u), length: %u\",\n                 tok2str(bgp_multicast_vpn_route_type_values,\n                         \"Unknown\", route_type),\n                 route_type, route_length);\n\n        switch(route_type) {\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s, Originator %s\",\n                     bgp_vpn_rd_print(ndo, pptr),\n                     bgp_vpn_ip_print(ndo, pptr + BGP_VPN_RD_LEN,\n                                      (route_length - BGP_VPN_RD_LEN) << 3));\n            break;\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTER_AS_I_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_S_PMSI:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            sg_length = bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            addr_length =  route_length - sg_length;\n\n            ND_TCHECK2(pptr[0], addr_length);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", Originator %s\",\n                     bgp_vpn_ip_print(ndo, pptr, addr_length << 3));\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_ACTIVE:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN);\n            offset = strlen(buf);\n            snprintf(buf + offset, buflen - offset, \", RD: %s\",\n                     bgp_vpn_rd_print(ndo, pptr));\n            pptr += BGP_VPN_RD_LEN;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SHARED_TREE_JOIN: /* fall through */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_SOURCE_TREE_JOIN:\n            ND_TCHECK2(pptr[0], BGP_VPN_RD_LEN + 4);\n            offset = strlen(buf);\n\t    snprintf(buf + offset, buflen - offset, \", RD: %s, Source-AS %s\",\n\t\tbgp_vpn_rd_print(ndo, pptr),\n\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\tEXTRACT_32BITS(pptr + BGP_VPN_RD_LEN)));\n            pptr += BGP_VPN_RD_LEN + 4;\n\n            bgp_vpn_sg_print(ndo, pptr, buf, buflen);\n            break;\n\n            /*\n             * no per route-type printing yet.\n             */\n        case BGP_MULTICAST_VPN_ROUTE_TYPE_INTRA_AS_SEG_LEAF:\n        default:\n            break;\n        }\n\n        return route_length + 2;\n\ntrunc:\n\treturn -2;\n}\n\n/*\n * As I remember, some versions of systems have an snprintf() that\n * returns -1 if the buffer would have overflowed.  If the return\n * value is negative, set buflen to 0, to indicate that we've filled\n * the buffer up.\n *\n * If the return value is greater than buflen, that means that\n * the buffer would have overflowed; again, set buflen to 0 in\n * that case.\n */\n#define UPDATE_BUF_BUFLEN(buf, buflen, stringlen) \\\n    if (stringlen<0) \\\n        buflen=0; \\\n    else if ((u_int)stringlen>buflen) \\\n        buflen=0; \\\n    else { \\\n        buflen-=stringlen; \\\n\tbuf+=stringlen; \\\n    }\n\nstatic int\ndecode_labeled_vpn_l2(netdissect_options *ndo,\n                      const u_char *pptr, char *buf, u_int buflen)\n{\n        int plen,tlen,stringlen,tlv_type,tlv_len,ttlv_len;\n\n\tND_TCHECK2(pptr[0], 2);\n        plen=EXTRACT_16BITS(pptr);\n        tlen=plen;\n        pptr+=2;\n\t/* Old and new L2VPN NLRI share AFI/SAFI\n         *   -> Assume a 12 Byte-length NLRI is auto-discovery-only\n         *      and > 17 as old format. Complain for the middle case\n         */\n        if (plen==12) {\n\t    /* assume AD-only with RD, BGPNH */\n\t    ND_TCHECK2(pptr[0],12);\n\t    buf[0]='\\0';\n\t    stringlen=snprintf(buf, buflen, \"RD: %s, BGPNH: %s\",\n\t\t\t       bgp_vpn_rd_print(ndo, pptr),\n\t\t\t       ipaddr_string(ndo, pptr+8)\n\t\t\t       );\n\t    UPDATE_BUF_BUFLEN(buf, buflen, stringlen);\n\t    pptr+=12;\n\t    tlen-=12;\n\t    return plen;\n        } else if (plen>17) {\n\t    /* assume old format */\n\t    /* RD, ID, LBLKOFF, LBLBASE */\n\n\t    ND_TCHECK2(pptr[0],15);\n\t    buf[0]='\\0';\n\t    stringlen=snprintf(buf, buflen, \"RD: %s, CE-ID: %u, Label-Block Offset: %u, Label Base %u\",\n\t\t\t       bgp_vpn_rd_print(ndo, pptr),\n\t\t\t       EXTRACT_16BITS(pptr+8),\n\t\t\t       EXTRACT_16BITS(pptr+10),\n\t\t\t       EXTRACT_24BITS(pptr+12)>>4); /* the label is offsetted by 4 bits so lets shift it right */\n\t    UPDATE_BUF_BUFLEN(buf, buflen, stringlen);\n\t    pptr+=15;\n\t    tlen-=15;\n\n\t    /* ok now the variable part - lets read out TLVs*/\n\t    while (tlen>0) {\n\t\tif (tlen < 3)\n\t\t    return -1;\n\t\tND_TCHECK2(pptr[0], 3);\n\t\ttlv_type=*pptr++;\n\t\ttlv_len=EXTRACT_16BITS(pptr);\n\t\tttlv_len=tlv_len;\n\t\tpptr+=2;\n\n\t\tswitch(tlv_type) {\n\t\tcase 1:\n\t\t    if (buflen!=0) {\n\t\t\tstringlen=snprintf(buf,buflen, \"\\n\\t\\tcircuit status vector (%u) length: %u: 0x\",\n\t\t\t\t\t   tlv_type,\n\t\t\t\t\t   tlv_len);\n\t\t\tUPDATE_BUF_BUFLEN(buf, buflen, stringlen);\n\t\t    }\n\t\t    ttlv_len=ttlv_len/8+1; /* how many bytes do we need to read ? */\n\t\t    while (ttlv_len>0) {\n\t\t\tND_TCHECK(pptr[0]);\n\t\t\tif (buflen!=0) {\n\t\t\t    stringlen=snprintf(buf,buflen, \"%02x\",*pptr++);\n\t\t\t    UPDATE_BUF_BUFLEN(buf, buflen, stringlen);\n\t\t\t}\n\t\t\tttlv_len--;\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    if (buflen!=0) {\n\t\t\tstringlen=snprintf(buf,buflen, \"\\n\\t\\tunknown TLV #%u, length: %u\",\n\t\t\t\t\t   tlv_type,\n\t\t\t\t\t   tlv_len);\n\t\t\tUPDATE_BUF_BUFLEN(buf, buflen, stringlen);\n\t\t    }\n\t\t    break;\n\t\t}\n\t\ttlen-=(tlv_len<<3); /* the tlv-length is expressed in bits so lets shift it right */\n\t    }\n\t    return plen+2;\n\n        } else {\n\t    /* complain bitterly ? */\n\t    /* fall through */\n            goto trunc;\n        }\n\ntrunc:\n        return -2;\n}\n\nint\ndecode_prefix6(netdissect_options *ndo,\n               const u_char *pd, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen, plenbytes;\n\n\tND_TCHECK(pd[0]);\n\tITEMCHECK(1);\n\tplen = pd[0];\n\tif (128 < plen)\n\t\treturn -1;\n\titemlen -= 1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pd[1], plenbytes);\n\tITEMCHECK(plenbytes);\n\tmemcpy(&addr, &pd[1], plenbytes);\n\tif (plen % 8) {\n\t\taddr.s6_addr[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d\", ip6addr_string(ndo, &addr), plen);\n\treturn 1 + plenbytes;\n\ntrunc:\n\treturn -2;\n\nbadtlv:\n\treturn -3;\n}\n\nstatic int\ndecode_labeled_prefix6(netdissect_options *ndo,\n                       const u_char *pptr, u_int itemlen, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen, plenbytes;\n\n\t/* prefix length and label = 4 bytes */\n\tND_TCHECK2(pptr[0], 4);\n\tITEMCHECK(4);\n\tplen = pptr[0]; /* get prefix length */\n\n\tif (24 > plen)\n\t\treturn -1;\n\n        plen-=24; /* adjust prefixlen - labellength */\n\n\tif (128 < plen)\n\t\treturn -1;\n\titemlen -= 4;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tplenbytes = (plen + 7) / 8;\n\tND_TCHECK2(pptr[4], plenbytes);\n\tmemcpy(&addr, &pptr[4], plenbytes);\n\tif (plen % 8) {\n\t\taddr.s6_addr[plenbytes - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n        /* the label may get offsetted by 4 bits so lets shift it right */\n\tsnprintf(buf, buflen, \"%s/%d, label:%u %s\",\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\n\treturn 4 + plenbytes;\n\ntrunc:\n\treturn -2;\n\nbadtlv:\n\treturn -3;\n}\n\nstatic int\ndecode_labeled_vpn_prefix6(netdissect_options *ndo,\n                           const u_char *pptr, char *buf, u_int buflen)\n{\n\tstruct in6_addr addr;\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif ((24+64) > plen)\n\t\treturn -1;\n\n        plen-=(24+64); /* adjust prefixlen - labellength - RD len*/\n\n\tif (128 < plen)\n\t\treturn -1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr.s6_addr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n        /* the label may get offsetted by 4 bits so lets shift it right */\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 ip6addr_string(ndo, &addr),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\n\treturn 12 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n\nstatic int\ndecode_clnp_prefix(netdissect_options *ndo,\n                   const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t addr[19];\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0]; /* get prefix length */\n\n\tif (152 < plen)\n\t\treturn -1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[4], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[4], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n\tsnprintf(buf, buflen, \"%s/%d\",\n                 isonsap_string(ndo, addr,(plen + 7) / 8),\n                 plen);\n\n\treturn 1 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n\nstatic int\ndecode_labeled_vpn_clnp_prefix(netdissect_options *ndo,\n                               const u_char *pptr, char *buf, u_int buflen)\n{\n        uint8_t addr[19];\n\tu_int plen;\n\n\tND_TCHECK(pptr[0]);\n\tplen = pptr[0];   /* get prefix length */\n\n\tif ((24+64) > plen)\n\t\treturn -1;\n\n        plen-=(24+64); /* adjust prefixlen - labellength - RD len*/\n\n\tif (152 < plen)\n\t\treturn -1;\n\n\tmemset(&addr, 0, sizeof(addr));\n\tND_TCHECK2(pptr[12], (plen + 7) / 8);\n\tmemcpy(&addr, &pptr[12], (plen + 7) / 8);\n\tif (plen % 8) {\n\t\taddr[(plen + 7) / 8 - 1] &=\n\t\t\t((0xff00 >> (plen % 8)) & 0xff);\n\t}\n        /* the label may get offsetted by 4 bits so lets shift it right */\n\tsnprintf(buf, buflen, \"RD: %s, %s/%d, label:%u %s\",\n                 bgp_vpn_rd_print(ndo, pptr+4),\n                 isonsap_string(ndo, addr,(plen + 7) / 8),\n                 plen,\n                 EXTRACT_24BITS(pptr+1)>>4,\n                 ((pptr[3]&1)==0) ? \"(BOGUS: Bottom of Stack NOT set!)\" : \"(bottom)\" );\n\n\treturn 12 + (plen + 7) / 8;\n\ntrunc:\n\treturn -2;\n}\n\n/*\n * bgp_attr_get_as_size\n *\n * Try to find the size of the ASs encoded in an as-path. It is not obvious, as\n * both Old speakers that do not support 4 byte AS, and the new speakers that do\n * support, exchange AS-Path with the same path-attribute type value 0x02.\n */\nstatic int\nbgp_attr_get_as_size(netdissect_options *ndo,\n                     uint8_t bgpa_type, const u_char *pptr, int len)\n{\n    const u_char *tptr = pptr;\n\n    /*\n     * If the path attribute is the optional AS4 path type, then we already\n     * know, that ASs must be encoded in 4 byte format.\n     */\n    if (bgpa_type == BGPTYPE_AS4_PATH) {\n        return 4;\n    }\n\n    /*\n     * Let us assume that ASs are of 2 bytes in size, and check if the AS-Path\n     * TLV is good. If not, ask the caller to try with AS encoded as 4 bytes\n     * each.\n     */\n    while (tptr < pptr + len) {\n        ND_TCHECK(tptr[0]);\n\n        /*\n         * If we do not find a valid segment type, our guess might be wrong.\n         */\n        if (tptr[0] < BGP_AS_SEG_TYPE_MIN || tptr[0] > BGP_AS_SEG_TYPE_MAX) {\n            goto trunc;\n        }\n        ND_TCHECK(tptr[1]);\n        tptr += 2 + tptr[1] * 2;\n    }\n\n    /*\n     * If we correctly reached end of the AS path attribute data content,\n     * then most likely ASs were indeed encoded as 2 bytes.\n     */\n    if (tptr == pptr + len) {\n        return 2;\n    }\n\ntrunc:\n\n    /*\n     * We can come here, either we did not have enough data, or if we\n     * try to decode 4 byte ASs in 2 byte format. Either way, return 4,\n     * so that calller can try to decode each AS as of 4 bytes. If indeed\n     * there was not enough data, it will crib and end the parse anyways.\n     */\n   return 4;\n}\n\nstatic int\nbgp_attr_print(netdissect_options *ndo,\n               u_int atype, const u_char *pptr, u_int len, const unsigned attr_set_level)\n{\n\tint i;\n\tuint16_t af;\n\tuint8_t safi, snpa, nhlen;\n        union { /* copy buffer for bandwidth values */\n            float f;\n            uint32_t i;\n        } bw;\n\tint advance;\n\tu_int tlen;\n\tconst u_char *tptr;\n\tchar buf[MAXHOSTNAMELEN + 100];\n        int  as_size;\n\n        tptr = pptr;\n        tlen=len;\n\n\tswitch (atype) {\n\tcase BGPTYPE_ORIGIN:\n\t\tif (len != 1)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK(*tptr);\n\t\t\tND_PRINT((ndo, \"%s\", tok2str(bgp_origin_values,\n\t\t\t\t\t\t\"Unknown Origin Typecode\",\n\t\t\t\t\t\ttptr[0])));\n\t\t}\n\t\tbreak;\n\n        /*\n         * Process AS4 byte path and AS2 byte path attributes here.\n         */\n\tcase BGPTYPE_AS4_PATH:\n\tcase BGPTYPE_AS_PATH:\n\t\tif (len % 2) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                if (!len) {\n\t\t\tND_PRINT((ndo, \"empty\"));\n\t\t\tbreak;\n                }\n\n                /*\n                 * BGP updates exchanged between New speakers that support 4\n                 * byte AS, ASs are always encoded in 4 bytes. There is no\n                 * definitive way to find this, just by the packet's\n                 * contents. So, check for packet's TLV's sanity assuming\n                 * 2 bytes first, and it does not pass, assume that ASs are\n                 * encoded in 4 bytes format and move on.\n                 */\n                as_size = bgp_attr_get_as_size(ndo, atype, pptr, len);\n\n\t\twhile (tptr < pptr + len) {\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_open_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n\t\t\tND_TCHECK(tptr[1]);\n                        for (i = 0; i < tptr[1] * as_size; i += as_size) {\n                            ND_TCHECK2(tptr[2 + i], as_size);\n\t\t\t    ND_PRINT((ndo, \"%s \",\n\t\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\t\tas_size == 2 ?\n\t\t\t\tEXTRACT_16BITS(&tptr[2 + i]) :\n\t\t\t\tEXTRACT_32BITS(&tptr[2 + i]))));\n                        }\n\t\t\tND_TCHECK(tptr[0]);\n                        ND_PRINT((ndo, \"%s\", tok2str(bgp_as_path_segment_close_values,\n\t\t\t\t\t\t\"?\", tptr[0])));\n                        ND_TCHECK(tptr[1]);\n                        tptr += 2 + tptr[1] * as_size;\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_NEXT_HOP:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_MULTI_EXIT_DISC:\n\tcase BGPTYPE_LOCAL_PREF:\n\t\tif (len != 4)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\telse {\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tND_PRINT((ndo, \"%u\", EXTRACT_32BITS(tptr)));\n\t\t}\n\t\tbreak;\n\tcase BGPTYPE_ATOMIC_AGGREGATE:\n\t\tif (len != 0)\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\tbreak;\n        case BGPTYPE_AGGREGATOR:\n\n                /*\n                 * Depending on the AS encoded is of 2 bytes or of 4 bytes,\n                 * the length of this PA can be either 6 bytes or 8 bytes.\n                 */\n                if (len != 6 && len != 8) {\n                    ND_PRINT((ndo, \"invalid len\"));\n                    break;\n                }\n                ND_TCHECK2(tptr[0], len);\n                if (len == 6) {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr), EXTRACT_16BITS(tptr)),\n\t\t\tipaddr_string(ndo, tptr + 2)));\n                } else {\n\t\t    ND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t\tas_printf(ndo, astostr, sizeof(astostr),\n\t\t\tEXTRACT_32BITS(tptr)), ipaddr_string(ndo, tptr + 4)));\n                }\n                break;\n\tcase BGPTYPE_AGGREGATOR4:\n\t\tif (len != 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 8);\n\t\tND_PRINT((ndo, \" AS #%s, origin %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr)),\n\t\t    ipaddr_string(ndo, tptr + 4)));\n\t\tbreak;\n\tcase BGPTYPE_COMMUNITIES:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\twhile (tlen>0) {\n\t\t\tuint32_t comm;\n\t\t\tND_TCHECK2(tptr[0], 4);\n\t\t\tcomm = EXTRACT_32BITS(tptr);\n\t\t\tswitch (comm) {\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_ADVERT:\n\t\t\t\tND_PRINT((ndo, \" NO_ADVERTISE\"));\n\t\t\t\tbreak;\n\t\t\tcase BGP_COMMUNITY_NO_EXPORT_SUBCONFED:\n\t\t\t\tND_PRINT((ndo, \" NO_EXPORT_SUBCONFED\"));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tND_PRINT((ndo, \"%u:%u%s\",\n                                       (comm >> 16) & 0xffff,\n                                       comm & 0xffff,\n                                       (tlen>4) ? \", \" : \"\"));\n\t\t\t\tbreak;\n\t\t\t}\n                        tlen -=4;\n                        tptr +=4;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_ORIGINATOR_ID:\n\t\tif (len != 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_TCHECK2(tptr[0], 4);\n                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                break;\n        case BGPTYPE_CLUSTER_LIST:\n\t\tif (len % 4) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n\t\t\tND_TCHECK2(tptr[0], 4);\n                        ND_PRINT((ndo, \"%s%s\",\n                               ipaddr_string(ndo, tptr),\n                                (tlen>4) ? \", \" : \"\"));\n                        tlen -=4;\n                        tptr +=4;\n                }\n                break;\n\tcase BGPTYPE_MP_REACH_NLRI:\n\t\tND_TCHECK2(tptr[0], 3);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                switch(af<<8 | safi) {\n                case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n\t\tcase (AFNUM_INET<<8 | SAFNUM_MDT):\n                case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    break;\n                default:\n                    ND_TCHECK2(tptr[0], tlen);\n                    ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                    goto done;\n                    break;\n                }\n\n                tptr +=3;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tnhlen = tptr[0];\n                tlen = nhlen;\n                tptr++;\n\n\t\tif (tlen) {\n                    int nnh = 0;\n                    ND_PRINT((ndo, \"\\n\\t    nexthop: \"));\n                    while (tlen > 0) {\n                        if ( nnh++ > 0 ) {\n                            ND_PRINT((ndo,  \", \" ));\n                        }\n                        switch(af<<8 | safi) {\n                        case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN):\n                        case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t\t    if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\",ipaddr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in_addr);\n                                tptr += sizeof(struct in_addr);\n                            }\n                            break;\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                            if (tlen < (int)sizeof(struct in6_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr));\n                                ND_PRINT((ndo, \"%s\", ip6addr_string(ndo, tptr)));\n                                tlen -= sizeof(struct in6_addr);\n                                tptr += sizeof(struct in6_addr);\n                            }\n                            break;\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)(sizeof(struct in6_addr)+BGP_VPN_RD_LEN)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN)));\n                                tlen -= (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                                tptr += (sizeof(struct in6_addr)+BGP_VPN_RD_LEN);\n                            }\n                            break;\n                        case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < (int)sizeof(struct in_addr)) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], sizeof(struct in_addr));\n                                ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr)));\n                                tlen -= (sizeof(struct in_addr));\n                                tptr += (sizeof(struct in_addr));\n                            }\n                            break;\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"%s\", isonsap_string(ndo, tptr, tlen)));\n                            tptr += tlen;\n                            tlen = 0;\n                            break;\n\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                        case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                            if (tlen < BGP_VPN_RD_LEN+1) {\n                                ND_PRINT((ndo, \"invalid len\"));\n                                tlen = 0;\n                            } else {\n                                ND_TCHECK2(tptr[0], tlen);\n                                ND_PRINT((ndo, \"RD: %s, %s\",\n                                       bgp_vpn_rd_print(ndo, tptr),\n                                       isonsap_string(ndo, tptr+BGP_VPN_RD_LEN,tlen-BGP_VPN_RD_LEN)));\n                                /* rfc986 mapped IPv4 address ? */\n                                if (tlen == BGP_VPN_RD_LEN + 4 + sizeof(struct in_addr)\n                                    && EXTRACT_32BITS(tptr+BGP_VPN_RD_LEN) ==  0x47000601)\n                                    ND_PRINT((ndo, \" = %s\", ipaddr_string(ndo, tptr+BGP_VPN_RD_LEN+4)));\n                                /* rfc1888 mapped IPv6 address ? */\n                                else if (tlen == BGP_VPN_RD_LEN + 3 + sizeof(struct in6_addr)\n                                         && EXTRACT_24BITS(tptr+BGP_VPN_RD_LEN) ==  0x350000)\n                                    ND_PRINT((ndo, \" = %s\", ip6addr_string(ndo, tptr+BGP_VPN_RD_LEN+3)));\n                                tptr += tlen;\n                                tlen = 0;\n                            }\n                            break;\n                        default:\n                            ND_TCHECK2(tptr[0], tlen);\n                            ND_PRINT((ndo, \"no AFI %u/SAFI %u decoder\", af, safi));\n                            if (ndo->ndo_vflag <= 1)\n                                print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                            tptr += tlen;\n                            tlen = 0;\n                            goto done;\n                            break;\n                        }\n                    }\n\t\t}\n\t\tND_PRINT((ndo, \", nh-length: %u\", nhlen));\n\t\ttptr += tlen;\n\n\t\tND_TCHECK(tptr[0]);\n\t\tsnpa = tptr[0];\n\t\ttptr++;\n\n\t\tif (snpa) {\n\t\t\tND_PRINT((ndo, \"\\n\\t    %u SNPA\", snpa));\n\t\t\tfor (/*nothing*/; snpa > 0; snpa--) {\n\t\t\t\tND_TCHECK(tptr[0]);\n\t\t\t\tND_PRINT((ndo, \"\\n\\t      %d bytes\", tptr[0]));\n\t\t\t\ttptr += tptr[0] + 1;\n\t\t\t}\n\t\t} else {\n\t\t\tND_PRINT((ndo, \", no SNPA\"));\n                }\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_RT_ROUTING_INFO):\n                        advance = decode_rt_routing_info(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,tlen);\n                        ND_PRINT((ndo, \"\\n\\t    no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n        done:\n\t\tbreak;\n\n\tcase BGPTYPE_MP_UNREACH_NLRI:\n\t\tND_TCHECK2(tptr[0], BGP_MP_NLRI_MINSIZE);\n\t\taf = EXTRACT_16BITS(tptr);\n\t\tsafi = tptr[2];\n\n                ND_PRINT((ndo, \"\\n\\t    AFI: %s (%u), %sSAFI: %s (%u)\",\n                       tok2str(af_values, \"Unknown AFI\", af),\n                       af,\n                       (safi>128) ? \"vendor specific \" : \"\", /* 128 is meanwhile wellknown */\n                       tok2str(bgp_safi_values, \"Unknown SAFI\", safi),\n                       safi));\n\n                if (len == BGP_MP_NLRI_MINSIZE)\n                    ND_PRINT((ndo, \"\\n\\t      End-of-Rib Marker (empty NLRI)\"));\n\n\t\ttptr += 3;\n\n\t\twhile (tptr < pptr + len) {\n                    switch (af<<8 | safi) {\n                    case (AFNUM_INET<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix4(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix4(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_LABUNICAST):\n                        advance = decode_labeled_prefix6(ndo, tptr, len, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else if (advance == -3)\n                            break; /* bytes left, but not enough */\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_INET6<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_prefix6(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_VPLS<<8 | SAFNUM_VPLS):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_L2VPN<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_l2(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_MULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_UNIMULTICAST):\n                        advance = decode_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNMULTICAST):\n                    case (AFNUM_NSAP<<8 | SAFNUM_VPNUNIMULTICAST):\n                        advance = decode_labeled_vpn_clnp_prefix(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n\t\t    case (AFNUM_INET<<8 | SAFNUM_MDT):\n\t\t      advance = decode_mdt_vpn_nlri(ndo, tptr, buf, sizeof(buf));\n\t\t      if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n\t\t       break;\n                    case (AFNUM_INET<<8 | SAFNUM_MULTICAST_VPN): /* fall through */\n                    case (AFNUM_INET6<<8 | SAFNUM_MULTICAST_VPN):\n                        advance = decode_multicast_vpn(ndo, tptr, buf, sizeof(buf));\n                        if (advance == -1)\n                            ND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n                        else if (advance == -2)\n                            goto trunc;\n                        else\n                            ND_PRINT((ndo, \"\\n\\t      %s\", buf));\n                        break;\n                    default:\n                        ND_TCHECK2(*(tptr-3),tlen);\n                        ND_PRINT((ndo, \"no AFI %u / SAFI %u decoder\", af, safi));\n                        if (ndo->ndo_vflag <= 1)\n                            print_unknown_data(ndo, tptr-3, \"\\n\\t    \", tlen);\n                        advance = 0;\n                        tptr = pptr + len;\n                        break;\n                    }\n                    if (advance < 0)\n                        break;\n                    tptr += advance;\n\t\t}\n\t\tbreak;\n        case BGPTYPE_EXTD_COMMUNITIES:\n\t\tif (len % 8) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n                while (tlen>0) {\n                    uint16_t extd_comm;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    extd_comm=EXTRACT_16BITS(tptr);\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s (0x%04x), Flags [%s]\",\n\t\t\t   tok2str(bgp_extd_comm_subtype_values,\n\t\t\t\t      \"unknown extd community typecode\",\n\t\t\t\t      extd_comm),\n\t\t\t   extd_comm,\n\t\t\t   bittok2str(bgp_extd_comm_flag_values, \"none\", extd_comm)));\n\n                    ND_TCHECK2(*(tptr+2), 6);\n                    switch(extd_comm) {\n                    case BGP_EXT_COM_RT_0:\n                    case BGP_EXT_COM_RO_0:\n                    case BGP_EXT_COM_L2VPN_RT_0:\n                        ND_PRINT((ndo, \": %u:%u (= %s)\",\n                               EXTRACT_16BITS(tptr+2),\n                               EXTRACT_32BITS(tptr+4),\n                               ipaddr_string(ndo, tptr+4)));\n                        break;\n                    case BGP_EXT_COM_RT_1:\n                    case BGP_EXT_COM_RO_1:\n                    case BGP_EXT_COM_L2VPN_RT_1:\n                    case BGP_EXT_COM_VRF_RT_IMP:\n                        ND_PRINT((ndo, \": %s:%u\",\n                               ipaddr_string(ndo, tptr+2),\n                               EXTRACT_16BITS(tptr+6)));\n                        break;\n                    case BGP_EXT_COM_RT_2:\n                    case BGP_EXT_COM_RO_2:\n\t\t\tND_PRINT((ndo, \": %s:%u\",\n\t\t\t    as_printf(ndo, astostr, sizeof(astostr),\n\t\t\t    EXTRACT_32BITS(tptr+2)), EXTRACT_16BITS(tptr+6)));\n\t\t\tbreak;\n                    case BGP_EXT_COM_LINKBAND:\n\t\t        bw.i = EXTRACT_32BITS(tptr+2);\n                        ND_PRINT((ndo, \": bandwidth: %.3f Mbps\",\n                               bw.f*8/1000000));\n                        break;\n                    case BGP_EXT_COM_VPN_ORIGIN:\n                    case BGP_EXT_COM_VPN_ORIGIN2:\n                    case BGP_EXT_COM_VPN_ORIGIN3:\n                    case BGP_EXT_COM_VPN_ORIGIN4:\n                    case BGP_EXT_COM_OSPF_RID:\n                    case BGP_EXT_COM_OSPF_RID2:\n                        ND_PRINT((ndo, \"%s\", ipaddr_string(ndo, tptr+2)));\n                        break;\n                    case BGP_EXT_COM_OSPF_RTYPE:\n                    case BGP_EXT_COM_OSPF_RTYPE2:\n                        ND_PRINT((ndo, \": area:%s, router-type:%s, metric-type:%s%s\",\n                               ipaddr_string(ndo, tptr+2),\n                               tok2str(bgp_extd_comm_ospf_rtype_values,\n\t\t\t\t\t  \"unknown (0x%02x)\",\n\t\t\t\t\t  *(tptr+6)),\n                               (*(tptr+7) &  BGP_OSPF_RTYPE_METRIC_TYPE) ? \"E2\" : \"\",\n                               ((*(tptr+6) == BGP_OSPF_RTYPE_EXT) || (*(tptr+6) == BGP_OSPF_RTYPE_NSSA)) ? \"E1\" : \"\"));\n                        break;\n                    case BGP_EXT_COM_L2INFO:\n                        ND_PRINT((ndo, \": %s Control Flags [0x%02x]:MTU %u\",\n                               tok2str(l2vpn_encaps_values,\n\t\t\t\t\t  \"unknown encaps\",\n\t\t\t\t\t  *(tptr+2)),\n                                       *(tptr+3),\n                               EXTRACT_16BITS(tptr+4)));\n                        break;\n                    case BGP_EXT_COM_SOURCE_AS:\n                        ND_PRINT((ndo, \": AS %u\", EXTRACT_16BITS(tptr+2)));\n                        break;\n                    default:\n                        ND_TCHECK2(*tptr,8);\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", 8);\n                        break;\n                    }\n                    tlen -=8;\n                    tptr +=8;\n                }\n                break;\n\n        case BGPTYPE_PMSI_TUNNEL:\n        {\n                uint8_t tunnel_type, flags;\n\n                ND_TCHECK2(tptr[0], 5);\n                tunnel_type = *(tptr+1);\n                flags = *tptr;\n                tlen = len;\n\n                ND_PRINT((ndo, \"\\n\\t    Tunnel-type %s (%u), Flags [%s], MPLS Label %u\",\n                       tok2str(bgp_pmsi_tunnel_values, \"Unknown\", tunnel_type),\n                       tunnel_type,\n                       bittok2str(bgp_pmsi_flag_values, \"none\", flags),\n                       EXTRACT_24BITS(tptr+2)>>4));\n\n                tptr +=5;\n                tlen -= 5;\n\n                switch (tunnel_type) {\n                case BGP_PMSI_TUNNEL_PIM_SM: /* fall through */\n                case BGP_PMSI_TUNNEL_PIM_BIDIR:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Sender %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n\n                case BGP_PMSI_TUNNEL_PIM_SSM:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, P-Group %s\",\n                           ipaddr_string(ndo, tptr),\n                           ipaddr_string(ndo, tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_INGRESS:\n                    ND_TCHECK2(tptr[0], 4);\n                    ND_PRINT((ndo, \"\\n\\t      Tunnel-Endpoint %s\",\n                           ipaddr_string(ndo, tptr)));\n                    break;\n                case BGP_PMSI_TUNNEL_LDP_P2MP: /* fall through */\n                case BGP_PMSI_TUNNEL_LDP_MP2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Root-Node %s, LSP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                case BGP_PMSI_TUNNEL_RSVP_P2MP:\n                    ND_TCHECK2(tptr[0], 8);\n                    ND_PRINT((ndo, \"\\n\\t      Extended-Tunnel-ID %s, P2MP-ID 0x%08x\",\n                           ipaddr_string(ndo, tptr),\n                           EXTRACT_32BITS(tptr+4)));\n                    break;\n                default:\n                    if (ndo->ndo_vflag <= 1) {\n                        print_unknown_data(ndo, tptr, \"\\n\\t      \", tlen);\n                    }\n                }\n                break;\n        }\n\tcase BGPTYPE_AIGP:\n\t{\n\t\tuint8_t type;\n\t\tuint16_t length;\n\n\t\ttlen = len;\n\n\t\twhile (tlen >= 3) {\n\n\t\t    ND_TCHECK2(tptr[0], 3);\n\n\t\t    type = *tptr;\n\t\t    length = EXTRACT_16BITS(tptr+1);\n\t\t    tptr += 3;\n\t\t    tlen -= 3;\n\n\t\t    ND_PRINT((ndo, \"\\n\\t    %s TLV (%u), length %u\",\n\t\t\t      tok2str(bgp_aigp_values, \"Unknown\", type),\n\t\t\t      type, length));\n\n\t\t    if (length < 3)\n\t\t\tgoto trunc;\n\t\t    length -= 3;\n\n\t\t    /*\n\t\t     * Check if we can read the TLV data.\n\t\t     */\n\t\t    ND_TCHECK2(tptr[3], length);\n\n\t\t    switch (type) {\n\n\t\t    case BGP_AIGP_TLV:\n\t\t        if (length < 8)\n\t\t            goto trunc;\n\t\t\tND_PRINT((ndo, \", metric %\" PRIu64,\n\t\t\t\t  EXTRACT_64BITS(tptr)));\n\t\t\tbreak;\n\n\t\t    default:\n\t\t\tif (ndo->ndo_vflag <= 1) {\n\t\t\t    print_unknown_data(ndo, tptr,\"\\n\\t      \", length);\n\t\t\t}\n\t\t    }\n\n\t\t    tptr += length;\n\t\t    tlen -= length;\n\t\t}\n\t\tbreak;\n\t}\n        case BGPTYPE_ATTR_SET:\n                ND_TCHECK2(tptr[0], 4);\n                if (len < 4)\n                \tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t    Origin AS: %s\",\n\t\t    as_printf(ndo, astostr, sizeof(astostr), EXTRACT_32BITS(tptr))));\n\t\ttptr+=4;\n                len -=4;\n\n                while (len) {\n                    u_int aflags, alenlen, alen;\n\n                    ND_TCHECK2(tptr[0], 2);\n                    if (len < 2)\n                        goto trunc;\n                    aflags = *tptr;\n                    atype = *(tptr + 1);\n                    tptr += 2;\n                    len -= 2;\n                    alenlen = bgp_attr_lenlen(aflags, tptr);\n                    ND_TCHECK2(tptr[0], alenlen);\n                    if (len < alenlen)\n                        goto trunc;\n                    alen = bgp_attr_len(aflags, tptr);\n                    tptr += alenlen;\n                    len -= alenlen;\n\n                    ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                           tok2str(bgp_attr_values,\n                                      \"Unknown Attribute\", atype),\n                           atype,\n                           alen));\n\n                    if (aflags) {\n                        ND_PRINT((ndo, \", Flags [%s%s%s%s\",\n                               aflags & 0x80 ? \"O\" : \"\",\n                               aflags & 0x40 ? \"T\" : \"\",\n                               aflags & 0x20 ? \"P\" : \"\",\n                               aflags & 0x10 ? \"E\" : \"\"));\n                        if (aflags & 0xf)\n                            ND_PRINT((ndo, \"+%x\", aflags & 0xf));\n                        ND_PRINT((ndo, \"]: \"));\n                    }\n                    /* The protocol encoding per se allows ATTR_SET to be nested as many times\n                     * as the message can accommodate. This printer used to be able to recurse\n                     * into ATTR_SET contents until the stack exhaustion, but now there is a\n                     * limit on that (if live protocol exchange goes that many levels deep,\n                     * something is probably wrong anyway). Feel free to refine this value if\n                     * you can find the spec with respective normative text.\n                     */\n                    if (attr_set_level == 10)\n                        ND_PRINT((ndo, \"(too many nested levels, not recursing)\"));\n                    else if (!bgp_attr_print(ndo, atype, tptr, alen, attr_set_level + 1))\n                        return 0;\n                    tptr += alen;\n                    len -= alen;\n\t\t}\n                break;\n\n\tcase BGPTYPE_LARGE_COMMUNITY:\n\t\tif (len == 0 || len % 12) {\n\t\t\tND_PRINT((ndo, \"invalid len\"));\n\t\t\tbreak;\n\t\t}\n\t\tND_PRINT((ndo, \"\\n\\t    \"));\n\t\twhile (len > 0) {\n\t\t\tND_TCHECK2(*tptr, 12);\n\t\t\tND_PRINT((ndo, \"%u:%u:%u%s\",\n\t\t\t\t EXTRACT_32BITS(tptr),\n\t\t\t\t EXTRACT_32BITS(tptr + 4),\n\t\t\t\t EXTRACT_32BITS(tptr + 8),\n\t\t\t\t (len > 12) ? \", \" : \"\"));\n                        tptr += 12;\n                        len -= 12;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t    ND_TCHECK2(*pptr,len);\n            ND_PRINT((ndo, \"\\n\\t    no Attribute %u decoder\", atype)); /* we have no decoder for the attribute */\n            if (ndo->ndo_vflag <= 1)\n                print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n            break;\n\t}\n        if (ndo->ndo_vflag > 1 && len) { /* omit zero length attributes*/\n            ND_TCHECK2(*pptr,len);\n            print_unknown_data(ndo, pptr, \"\\n\\t    \", len);\n        }\n        return 1;\n\ntrunc:\n        return 0;\n}\n\nstatic void\nbgp_capabilities_print(netdissect_options *ndo,\n                       const u_char *opt, int caps_len)\n{\n\tint cap_type, cap_len, tcap_len, cap_offset;\n        int i = 0;\n\n        while (i < caps_len) {\n                ND_TCHECK2(opt[i], BGP_CAP_HEADER_SIZE);\n                cap_type=opt[i];\n                cap_len=opt[i+1];\n                tcap_len=cap_len;\n                ND_PRINT((ndo, \"\\n\\t      %s (%u), length: %u\",\n                       tok2str(bgp_capcode_values, \"Unknown\",\n                                  cap_type),\n                       cap_type,\n                       cap_len));\n                ND_TCHECK2(opt[i+2], cap_len);\n                switch (cap_type) {\n                case BGP_CAPCODE_MP:\n                    /* AFI (16 bits), Reserved (8 bits), SAFI (8 bits) */\n                    ND_TCHECK_8BITS(opt + i + 5);\n                    ND_PRINT((ndo, \"\\n\\t\\tAFI %s (%u), SAFI %s (%u)\",\n                           tok2str(af_values, \"Unknown\",\n                                      EXTRACT_16BITS(opt+i+2)),\n                           EXTRACT_16BITS(opt+i+2),\n                           tok2str(bgp_safi_values, \"Unknown\",\n                                      opt[i+5]),\n                           opt[i+5]));\n                    break;\n                case BGP_CAPCODE_RESTART:\n                    /* Restart Flags (4 bits), Restart Time in seconds (12 bits) */\n                    ND_TCHECK_16BITS(opt + i + 2);\n                    ND_PRINT((ndo, \"\\n\\t\\tRestart Flags: [%s], Restart Time %us\",\n                           ((opt[i+2])&0x80) ? \"R\" : \"none\",\n                           EXTRACT_16BITS(opt+i+2)&0xfff));\n                    tcap_len-=2;\n                    cap_offset=4;\n                    while(tcap_len>=4) {\n                        ND_TCHECK_8BITS(opt + i + cap_offset + 3);\n                        ND_PRINT((ndo, \"\\n\\t\\t  AFI %s (%u), SAFI %s (%u), Forwarding state preserved: %s\",\n                               tok2str(af_values,\"Unknown\",\n                                          EXTRACT_16BITS(opt+i+cap_offset)),\n                               EXTRACT_16BITS(opt+i+cap_offset),\n                               tok2str(bgp_safi_values,\"Unknown\",\n                                          opt[i+cap_offset+2]),\n                               opt[i+cap_offset+2],\n                               ((opt[i+cap_offset+3])&0x80) ? \"yes\" : \"no\" ));\n                        tcap_len-=4;\n                        cap_offset+=4;\n                    }\n                    break;\n                case BGP_CAPCODE_RR:\n                case BGP_CAPCODE_RR_CISCO:\n                    break;\n                case BGP_CAPCODE_AS_NEW:\n\n                    /*\n                     * Extract the 4 byte AS number encoded.\n                     */\n                    if (cap_len == 4) {\n                        ND_PRINT((ndo, \"\\n\\t\\t 4 Byte AS %s\",\n                            as_printf(ndo, astostr, sizeof(astostr),\n                            EXTRACT_32BITS(opt + i + 2))));\n                    }\n                    break;\n                case BGP_CAPCODE_ADD_PATH:\n                    cap_offset=2;\n                    if (tcap_len == 0) {\n                        ND_PRINT((ndo, \" (bogus)\")); /* length */\n                        break;\n                    }\n                    while (tcap_len > 0) {\n                        if (tcap_len < 4) {\n                            ND_PRINT((ndo, \"\\n\\t\\t(invalid)\"));\n                            break;\n                        }\n                        ND_PRINT((ndo, \"\\n\\t\\tAFI %s (%u), SAFI %s (%u), Send/Receive: %s\",\n                                  tok2str(af_values,\"Unknown\",EXTRACT_16BITS(opt+i+cap_offset)),\n                                  EXTRACT_16BITS(opt+i+cap_offset),\n                                  tok2str(bgp_safi_values,\"Unknown\",opt[i+cap_offset+2]),\n                                  opt[i+cap_offset+2],\n                                  tok2str(bgp_add_path_recvsend,\"Bogus (0x%02x)\",opt[i+cap_offset+3])\n                        ));\n                        tcap_len-=4;\n                        cap_offset+=4;\n                    }\n                    break;\n                default:\n                    ND_PRINT((ndo, \"\\n\\t\\tno decoder for Capability %u\",\n                           cap_type));\n                    if (ndo->ndo_vflag <= 1)\n                        print_unknown_data(ndo, &opt[i+2], \"\\n\\t\\t\", cap_len);\n                    break;\n                }\n                if (ndo->ndo_vflag > 1 && cap_len > 0) {\n                    print_unknown_data(ndo, &opt[i+2], \"\\n\\t\\t\", cap_len);\n                }\n                i += BGP_CAP_HEADER_SIZE + cap_len;\n        }\n        return;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nbgp_open_print(netdissect_options *ndo,\n               const u_char *dat, int length)\n{\n\tstruct bgp_open bgpo;\n\tstruct bgp_opt bgpopt;\n\tconst u_char *opt;\n\tint i;\n\n\tND_TCHECK2(dat[0], BGP_OPEN_SIZE);\n\tmemcpy(&bgpo, dat, BGP_OPEN_SIZE);\n\n\tND_PRINT((ndo, \"\\n\\t  Version %d, \", bgpo.bgpo_version));\n\tND_PRINT((ndo, \"my AS %s, \",\n\t    as_printf(ndo, astostr, sizeof(astostr), ntohs(bgpo.bgpo_myas))));\n\tND_PRINT((ndo, \"Holdtime %us, \", ntohs(bgpo.bgpo_holdtime)));\n\tND_PRINT((ndo, \"ID %s\", ipaddr_string(ndo, &bgpo.bgpo_id)));\n\tND_PRINT((ndo, \"\\n\\t  Optional parameters, length: %u\", bgpo.bgpo_optlen));\n\n        /* some little sanity checking */\n        if (length < bgpo.bgpo_optlen+BGP_OPEN_SIZE)\n            return;\n\n\t/* ugly! */\n\topt = &((const struct bgp_open *)dat)->bgpo_optlen;\n\topt++;\n\n\ti = 0;\n\twhile (i < bgpo.bgpo_optlen) {\n\t\tND_TCHECK2(opt[i], BGP_OPT_SIZE);\n\t\tmemcpy(&bgpopt, &opt[i], BGP_OPT_SIZE);\n\t\tif (i + 2 + bgpopt.bgpopt_len > bgpo.bgpo_optlen) {\n\t\t\tND_PRINT((ndo, \"\\n\\t     Option %d, length: %u\", bgpopt.bgpopt_type, bgpopt.bgpopt_len));\n\t\t\tbreak;\n\t\t}\n\n\t\tND_PRINT((ndo, \"\\n\\t    Option %s (%u), length: %u\",\n\t\t       tok2str(bgp_opt_values,\"Unknown\",\n\t\t\t\t  bgpopt.bgpopt_type),\n\t\t       bgpopt.bgpopt_type,\n\t\t       bgpopt.bgpopt_len));\n\n\t\t/* now let's decode the options we know*/\n\t\tswitch(bgpopt.bgpopt_type) {\n\n\t\tcase BGP_OPT_CAP:\n\t\t\tbgp_capabilities_print(ndo, &opt[i+BGP_OPT_SIZE],\n\t\t\t    bgpopt.bgpopt_len);\n\t\t\tbreak;\n\n\t\tcase BGP_OPT_AUTH:\n\t\tdefault:\n\t\t       ND_PRINT((ndo, \"\\n\\t      no decoder for option %u\",\n\t\t\t   bgpopt.bgpopt_type));\n\t\t       break;\n\t\t}\n\t\ti += BGP_OPT_SIZE + bgpopt.bgpopt_len;\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nbgp_update_print(netdissect_options *ndo,\n                 const u_char *dat, int length)\n{\n\tstruct bgp bgp;\n\tconst u_char *p;\n\tint withdrawn_routes_len;\n\tint len;\n\tint i;\n\n\tND_TCHECK2(dat[0], BGP_SIZE);\n\tif (length < BGP_SIZE)\n\t\tgoto trunc;\n\tmemcpy(&bgp, dat, BGP_SIZE);\n\tp = dat + BGP_SIZE;\t/*XXX*/\n\tlength -= BGP_SIZE;\n\n\t/* Unfeasible routes */\n\tND_TCHECK2(p[0], 2);\n\tif (length < 2)\n\t\tgoto trunc;\n\twithdrawn_routes_len = EXTRACT_16BITS(p);\n\tp += 2;\n\tlength -= 2;\n\tif (withdrawn_routes_len) {\n\t\t/*\n\t\t * Without keeping state from the original NLRI message,\n\t\t * it's not possible to tell if this a v4 or v6 route,\n\t\t * so only try to decode it if we're not v6 enabled.\n\t         */\n\t\tND_TCHECK2(p[0], withdrawn_routes_len);\n\t\tif (length < withdrawn_routes_len)\n\t\t\tgoto trunc;\n\t\tND_PRINT((ndo, \"\\n\\t  Withdrawn routes: %d bytes\", withdrawn_routes_len));\n\t\tp += withdrawn_routes_len;\n\t\tlength -= withdrawn_routes_len;\n\t}\n\n\tND_TCHECK2(p[0], 2);\n\tif (length < 2)\n\t\tgoto trunc;\n\tlen = EXTRACT_16BITS(p);\n\tp += 2;\n\tlength -= 2;\n\n        if (withdrawn_routes_len == 0 && len == 0 && length == 0) {\n            /* No withdrawn routes, no path attributes, no NLRI */\n            ND_PRINT((ndo, \"\\n\\t  End-of-Rib Marker (empty NLRI)\"));\n            return;\n        }\n\n\tif (len) {\n\t\t/* do something more useful!*/\n\t\twhile (len) {\n\t\t\tint aflags, atype, alenlen, alen;\n\n\t\t\tND_TCHECK2(p[0], 2);\n\t\t\tif (len < 2)\n\t\t\t    goto trunc;\n\t\t\tif (length < 2)\n\t\t\t    goto trunc;\n\t\t\taflags = *p;\n\t\t\tatype = *(p + 1);\n\t\t\tp += 2;\n\t\t\tlen -= 2;\n\t\t\tlength -= 2;\n\t\t\talenlen = bgp_attr_lenlen(aflags, p);\n\t\t\tND_TCHECK2(p[0], alenlen);\n\t\t\tif (len < alenlen)\n\t\t\t    goto trunc;\n\t\t\tif (length < alenlen)\n\t\t\t    goto trunc;\n\t\t\talen = bgp_attr_len(aflags, p);\n\t\t\tp += alenlen;\n\t\t\tlen -= alenlen;\n\t\t\tlength -= alenlen;\n\n\t\t\tND_PRINT((ndo, \"\\n\\t  %s (%u), length: %u\",\n                              tok2str(bgp_attr_values, \"Unknown Attribute\",\n\t\t\t\t\t atype),\n                              atype,\n                              alen));\n\n\t\t\tif (aflags) {\n\t\t\t\tND_PRINT((ndo, \", Flags [%s%s%s%s\",\n\t\t\t\t\taflags & 0x80 ? \"O\" : \"\",\n\t\t\t\t\taflags & 0x40 ? \"T\" : \"\",\n\t\t\t\t\taflags & 0x20 ? \"P\" : \"\",\n\t\t\t\t\taflags & 0x10 ? \"E\" : \"\"));\n\t\t\t\tif (aflags & 0xf)\n\t\t\t\t\tND_PRINT((ndo, \"+%x\", aflags & 0xf));\n\t\t\t\tND_PRINT((ndo, \"]: \"));\n\t\t\t}\n\t\t\tif (len < alen)\n\t\t\t\tgoto trunc;\n\t\t\tif (length < alen)\n\t\t\t\tgoto trunc;\n\t\t\tif (!bgp_attr_print(ndo, atype, p, alen, 0))\n\t\t\t\tgoto trunc;\n\t\t\tp += alen;\n\t\t\tlen -= alen;\n\t\t\tlength -= alen;\n\t\t}\n\t}\n\n\tif (length) {\n\t\t/*\n\t\t * XXX - what if they're using the \"Advertisement of\n\t\t * Multiple Paths in BGP\" feature:\n\t\t *\n\t\t * https://datatracker.ietf.org/doc/draft-ietf-idr-add-paths/\n\t\t *\n\t\t * http://tools.ietf.org/html/draft-ietf-idr-add-paths-06\n\t\t */\n\t\tND_PRINT((ndo, \"\\n\\t  Updated routes:\"));\n\t\twhile (length) {\n\t\t\tchar buf[MAXHOSTNAMELEN + 100];\n\t\t\ti = decode_prefix4(ndo, p, length, buf, sizeof(buf));\n\t\t\tif (i == -1) {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    (illegal prefix length)\"));\n\t\t\t\tbreak;\n\t\t\t} else if (i == -2)\n\t\t\t\tgoto trunc;\n\t\t\telse if (i == -3)\n\t\t\t\tgoto trunc; /* bytes left, but not enough */\n\t\t\telse {\n\t\t\t\tND_PRINT((ndo, \"\\n\\t    %s\", buf));\n\t\t\t\tp += i;\n\t\t\t\tlength -= i;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nbgp_notification_print(netdissect_options *ndo,\n                       const u_char *dat, int length)\n{\n\tstruct bgp_notification bgpn;\n\tconst u_char *tptr;\n\n\tND_TCHECK2(dat[0], BGP_NOTIFICATION_SIZE);\n\tmemcpy(&bgpn, dat, BGP_NOTIFICATION_SIZE);\n\n        /* some little sanity checking */\n        if (length<BGP_NOTIFICATION_SIZE)\n            return;\n\n\tND_PRINT((ndo, \", %s (%u)\",\n\t       tok2str(bgp_notify_major_values, \"Unknown Error\",\n\t\t\t  bgpn.bgpn_major),\n\t       bgpn.bgpn_major));\n\n        switch (bgpn.bgpn_major) {\n\n        case BGP_NOTIFY_MAJOR_MSG:\n            ND_PRINT((ndo, \", subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_msg_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n            break;\n        case BGP_NOTIFY_MAJOR_OPEN:\n            ND_PRINT((ndo, \", subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_open_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n            break;\n        case BGP_NOTIFY_MAJOR_UPDATE:\n            ND_PRINT((ndo, \", subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_update_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n            break;\n        case BGP_NOTIFY_MAJOR_FSM:\n            ND_PRINT((ndo, \" subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_fsm_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n            break;\n        case BGP_NOTIFY_MAJOR_CAP:\n            ND_PRINT((ndo, \" subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_cap_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n            break;\n        case BGP_NOTIFY_MAJOR_CEASE:\n            ND_PRINT((ndo, \", subcode %s (%u)\",\n\t\t   tok2str(bgp_notify_minor_cease_values, \"Unknown\",\n\t\t\t      bgpn.bgpn_minor),\n\t\t   bgpn.bgpn_minor));\n\n\t    /* draft-ietf-idr-cease-subcode-02 mentions optionally 7 bytes\n             * for the maxprefix subtype, which may contain AFI, SAFI and MAXPREFIXES\n             */\n\t    if(bgpn.bgpn_minor == BGP_NOTIFY_MINOR_CEASE_MAXPRFX && length >= BGP_NOTIFICATION_SIZE + 7) {\n\t\ttptr = dat + BGP_NOTIFICATION_SIZE;\n\t\tND_TCHECK2(*tptr, 7);\n\t\tND_PRINT((ndo, \", AFI %s (%u), SAFI %s (%u), Max Prefixes: %u\",\n\t\t       tok2str(af_values, \"Unknown\",\n\t\t\t\t  EXTRACT_16BITS(tptr)),\n\t\t       EXTRACT_16BITS(tptr),\n\t\t       tok2str(bgp_safi_values, \"Unknown\", *(tptr+2)),\n\t\t       *(tptr+2),\n\t\t       EXTRACT_32BITS(tptr+3)));\n\t    }\n            break;\n        default:\n            break;\n        }\n\n\treturn;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic void\nbgp_route_refresh_print(netdissect_options *ndo,\n                        const u_char *pptr, int len)\n{\n        const struct bgp_route_refresh *bgp_route_refresh_header;\n\n\tND_TCHECK2(pptr[0], BGP_ROUTE_REFRESH_SIZE);\n\n        /* some little sanity checking */\n        if (len<BGP_ROUTE_REFRESH_SIZE)\n            return;\n\n        bgp_route_refresh_header = (const struct bgp_route_refresh *)pptr;\n\n        ND_PRINT((ndo, \"\\n\\t  AFI %s (%u), SAFI %s (%u)\",\n               tok2str(af_values,\"Unknown\",\n\t\t\t  /* this stinks but the compiler pads the structure\n\t\t\t   * weird */\n\t\t\t  EXTRACT_16BITS(&bgp_route_refresh_header->afi)),\n               EXTRACT_16BITS(&bgp_route_refresh_header->afi),\n               tok2str(bgp_safi_values,\"Unknown\",\n\t\t\t  bgp_route_refresh_header->safi),\n               bgp_route_refresh_header->safi));\n\n        if (ndo->ndo_vflag > 1) {\n            ND_TCHECK2(*pptr, len);\n            print_unknown_data(ndo, pptr, \"\\n\\t  \", len);\n        }\n\n        return;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\nstatic int\nbgp_header_print(netdissect_options *ndo,\n                 const u_char *dat, int length)\n{\n\tstruct bgp bgp;\n\n\tND_TCHECK2(dat[0], BGP_SIZE);\n\tmemcpy(&bgp, dat, BGP_SIZE);\n\tND_PRINT((ndo, \"\\n\\t%s Message (%u), length: %u\",\n               tok2str(bgp_msg_values, \"Unknown\", bgp.bgp_type),\n               bgp.bgp_type,\n               length));\n\n\tswitch (bgp.bgp_type) {\n\tcase BGP_OPEN:\n\t\tbgp_open_print(ndo, dat, length);\n\t\tbreak;\n\tcase BGP_UPDATE:\n\t\tbgp_update_print(ndo, dat, length);\n\t\tbreak;\n\tcase BGP_NOTIFICATION:\n\t\tbgp_notification_print(ndo, dat, length);\n\t\tbreak;\n        case BGP_KEEPALIVE:\n                break;\n        case BGP_ROUTE_REFRESH:\n                bgp_route_refresh_print(ndo, dat, length);\n                break;\n        default:\n                /* we have no decoder for the BGP message */\n                ND_TCHECK2(*dat, length);\n                ND_PRINT((ndo, \"\\n\\t  no Message %u decoder\", bgp.bgp_type));\n                print_unknown_data(ndo, dat, \"\\n\\t  \", length);\n                break;\n\t}\n\treturn 1;\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n\treturn 0;\n}\n\nvoid\nbgp_print(netdissect_options *ndo,\n          const u_char *dat, int length)\n{\n\tconst u_char *p;\n\tconst u_char *ep;\n\tconst u_char *start;\n\tconst u_char marker[] = {\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t};\n\tstruct bgp bgp;\n\tuint16_t hlen;\n\n\tep = dat + length;\n\tif (ndo->ndo_snapend < dat + length)\n\t\tep = ndo->ndo_snapend;\n\n\tND_PRINT((ndo, \": BGP\"));\n\n        if (ndo->ndo_vflag < 1) /* lets be less chatty */\n                return;\n\n\tp = dat;\n\tstart = p;\n\twhile (p < ep) {\n\t\tif (!ND_TTEST2(p[0], 1))\n\t\t\tbreak;\n\t\tif (p[0] != 0xff) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!ND_TTEST2(p[0], sizeof(marker)))\n\t\t\tbreak;\n\t\tif (memcmp(p, marker, sizeof(marker)) != 0) {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* found BGP header */\n\t\tND_TCHECK2(p[0], BGP_SIZE);\t/*XXX*/\n\t\tmemcpy(&bgp, p, BGP_SIZE);\n\n\t\tif (start != p)\n\t\t\tND_PRINT((ndo, \" %s\", tstr));\n\n\t\thlen = ntohs(bgp.bgp_len);\n\t\tif (hlen < BGP_SIZE) {\n\t\t\tND_PRINT((ndo, \"\\n[|BGP Bogus header length %u < %u]\", hlen,\n\t\t\t    BGP_SIZE));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ND_TTEST2(p[0], hlen)) {\n\t\t\tif (!bgp_header_print(ndo, p, hlen))\n\t\t\t\treturn;\n\t\t\tp += hlen;\n\t\t\tstart = p;\n\t\t} else {\n\t\t\tND_PRINT((ndo, \"\\n[|BGP %s]\",\n\t\t\t       tok2str(bgp_msg_values,\n\t\t\t\t\t  \"Unknown Message Type\",\n\t\t\t\t\t  bgp.bgp_type)));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn;\n\ntrunc:\n\tND_PRINT((ndo, \"%s\", tstr));\n}\n\n/*\n * Local Variables:\n * c-style: whitesmith\n * c-basic-offset: 4\n * End:\n */\n"], "filenames": ["print-bgp.c"], "buggy_code_start_loc": [1364], "buggy_code_end_loc": [2596], "fixing_code_start_loc": [1364], "fixing_code_end_loc": [2604], "type": "CWE-674", "message": "The BGP parser in tcpdump before 4.9.3 allows stack consumption in print-bgp.c:bgp_attr_print() because of unlimited recursion.", "other": {"cve": {"id": "CVE-2018-16300", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-03T16:15:12.633", "lastModified": "2019-10-11T23:15:12.917", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The BGP parser in tcpdump before 4.9.3 allows stack consumption in print-bgp.c:bgp_attr_print() because of unlimited recursion."}, {"lang": "es", "value": "El analizador BGP en tcpdump versiones anteriores a 4.9.3, permite el consumo de pila en print-bgp.c:bgp_attr_print() debido a una recursividad ilimitada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-674"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcpdump:tcpdump:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.9.3", "matchCriteriaId": "CA59BD9C-6C0C-4584-A8CC-8C652E9D36AF"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00050.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00053.html", "source": "cve@mitre.org"}, {"url": "http://seclists.org/fulldisclosure/2019/Dec/26", "source": "cve@mitre.org"}, {"url": "https://github.com/the-tcpdump-group/tcpdump/blob/tcpdump-4.9/CHANGES", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/the-tcpdump-group/tcpdump/commit/af2cf04a9394c1a56227c2289ae8da262828294a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00015.html", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/62XY42U6HY3H2APR5EHNWCZ7SAQNMMJN/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNYXF3IY2X65IOD422SA6EQUULSGW7FN/", "source": "cve@mitre.org"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/R2UDPOSGVJQIYC33SQBXMDXHH4QDSDMU/", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Dec/23", "source": "cve@mitre.org"}, {"url": "https://seclists.org/bugtraq/2019/Oct/28", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20200120-0001/", "source": "cve@mitre.org"}, {"url": "https://support.apple.com/kb/HT210788", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4252-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4252-2/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4547", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/the-tcpdump-group/tcpdump/commit/af2cf04a9394c1a56227c2289ae8da262828294a"}}