{"buggy_code": ["// Copyright 2022 Redpanda Data, Inc.\n//\n// Use of this software is governed by the Business Source License\n// included in the file licenses/BSL.md\n//\n// As of the Change Date specified in that file, in accordance with\n// the Business Source License, use of this software will be governed\n// by the Apache License, Version 2.0\n\n//go:build linux\n\npackage debug\n\nimport (\n\t\"archive/zip\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/avast/retry-go\"\n\t\"github.com/beevik/ntp\"\n\t\"github.com/docker/go-units\"\n\t\"github.com/hashicorp/go-multierror\"\n\t\"github.com/redpanda-data/redpanda/src/go/rpk/pkg/api/admin\"\n\t\"github.com/redpanda-data/redpanda/src/go/rpk/pkg/config\"\n\tosutil \"github.com/redpanda-data/redpanda/src/go/rpk/pkg/os\"\n\t\"github.com/redpanda-data/redpanda/src/go/rpk/pkg/system\"\n\t\"github.com/redpanda-data/redpanda/src/go/rpk/pkg/system/syslog\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/afero\"\n\t\"github.com/twmb/franz-go/pkg/kadm\"\n\t\"github.com/twmb/franz-go/pkg/kgo\"\n\t\"gopkg.in/yaml.v3\"\n)\n\nfunc executeBundle(\n\tctx context.Context,\n\tfs afero.Fs,\n\tconf *config.Config,\n\tcl *kgo.Client,\n\tadmin *admin.AdminAPI,\n\tlogsSince, logsUntil string,\n\tlogsLimitBytes int,\n\ttimeout time.Duration,\n) error {\n\tmode := os.FileMode(0o755)\n\ttimestamp := time.Now().Unix()\n\tfilename := fmt.Sprintf(\"%d-bundle.zip\", timestamp)\n\tf, err := fs.OpenFile(\n\t\tfilename,\n\t\tos.O_CREATE|os.O_WRONLY,\n\t\tmode,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"couldn't create bundle file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\tgrp := multierror.Group{}\n\n\tw := zip.NewWriter(f)\n\tdefer w.Close()\n\n\tps := &stepParams{\n\t\tfs:      fs,\n\t\tw:       w,\n\t\ttimeout: timeout,\n\t}\n\n\tsteps := []step{\n\t\tsaveKafkaMetadata(ctx, ps, cl),\n\t\tsaveDataDirStructure(ps, conf),\n\t\tsaveConfig(ps, conf),\n\t\tsaveCPUInfo(ps),\n\t\tsaveInterrupts(ps),\n\t\tsaveResourceUsageData(ps, conf),\n\t\tsaveNTPDrift(ps),\n\t\tsaveSyslog(ps),\n\t\tsavePrometheusMetrics(ctx, ps, admin),\n\t\tsaveDNSData(ctx, ps),\n\t\tsaveDiskUsage(ctx, ps, conf),\n\t\tsaveLogs(ctx, ps, logsSince, logsUntil, logsLimitBytes),\n\t\tsaveSocketData(ctx, ps),\n\t\tsaveTopOutput(ctx, ps),\n\t\tsaveVmstat(ctx, ps),\n\t\tsaveIP(ctx, ps),\n\t\tsaveLspci(ctx, ps),\n\t\tsaveDmidecode(ctx, ps),\n\t}\n\n\tfor _, s := range steps {\n\t\tgrp.Go(s)\n\t}\n\n\terrs := grp.Wait()\n\tif errs != nil {\n\t\terr := writeFileToZip(ps, \"errors.txt\", []byte(errs.Error()))\n\t\tif err != nil {\n\t\t\terrs = multierror.Append(errs, err)\n\t\t}\n\t\tlog.Info(errs.Error())\n\t}\n\n\tlog.Infof(\"Debug bundle saved to '%s'\", filename)\n\treturn nil\n}\n\ntype step func() error\n\ntype stepParams struct {\n\tfs      afero.Fs\n\tm       sync.Mutex\n\tw       *zip.Writer\n\ttimeout time.Duration\n}\n\ntype fileInfo struct {\n\tSize     string `json:\"size\"`\n\tMode     string `json:\"mode\"`\n\tSymlink  string `json:\"symlink,omitempty\"`\n\tError    string `json:\"error,omitempty\"`\n\tModified string `json:\"modified\"`\n\tUser     string `json:\"user\"`\n\tGroup    string `json:\"group\"`\n}\n\ntype limitedWriter struct {\n\tw          io.Writer\n\tlimitBytes int\n\taccumBytes int\n}\n\nfunc (l *limitedWriter) Write(p []byte) (int, error) {\n\tlimitReached := false\n\tif l.accumBytes+len(p) > l.limitBytes {\n\t\tp = p[:l.limitBytes-l.accumBytes]\n\t\tlimitReached = true\n\t}\n\n\tn, err := l.w.Write(p)\n\tif err != nil {\n\t\treturn n, err\n\t}\n\n\tl.accumBytes += n\n\n\tif limitReached {\n\t\treturn n, errors.New(\"output size limit reached\")\n\t}\n\treturn n, nil\n}\n\n// Creates a file in the zip writer with name 'filename' and writes 'contents' to it.\nfunc writeFileToZip(ps *stepParams, filename string, contents []byte) error {\n\tps.m.Lock()\n\tdefer ps.m.Unlock()\n\n\twr, err := ps.w.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = wr.Write(contents)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"couldn't save '%s': %w\", filename, err)\n\t}\n\treturn nil\n}\n\n// Runs a command and pipes its output to a new file in the zip writer.\nfunc writeCommandOutputToZipLimit(\n\trootCtx context.Context,\n\tps *stepParams,\n\tfilename string,\n\toutputLimitBytes int,\n\tcommand string,\n\targs ...string,\n) error {\n\tps.m.Lock()\n\tdefer ps.m.Unlock()\n\n\tctx, cancel := context.WithTimeout(rootCtx, ps.timeout)\n\tdefer cancel()\n\tcmd := exec.CommandContext(ctx, command, args...)\n\n\t// Strip any non-default library path\n\tcmd.Env = osutil.SystemLdPathEnv()\n\n\twr, err := ps.w.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif outputLimitBytes > 0 {\n\t\twr = &limitedWriter{\n\t\t\tw:          wr,\n\t\t\tlimitBytes: outputLimitBytes,\n\t\t}\n\t}\n\n\tcmd.Stdout = wr\n\tcmd.Stderr = wr\n\n\terr = cmd.Start()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = cmd.Wait()\n\tif err != nil {\n\t\tif !strings.Contains(err.Error(), \"broken pipe\") {\n\t\t\treturn fmt.Errorf(\"couldn't save '%s': %w\", filename, err)\n\t\t}\n\t\tlog.Debugf(\n\t\t\t\"Got '%v' while running '%s'. This is probably due to the\"+\n\t\t\t\t\" command's output exceeding its limit in bytes.\",\n\t\t\terr,\n\t\t\tcmd,\n\t\t)\n\t}\n\treturn nil\n}\n\n// Runs a command and pipes its output to a new file in the zip writer.\nfunc writeCommandOutputToZip(\n\tctx context.Context, ps *stepParams, filename, command string, args ...string,\n) error {\n\treturn writeCommandOutputToZipLimit(ctx, ps, filename, -1, command, args...)\n}\n\n// Parses an error return from kadm, and if the return is a shard errors,\n// returns a list of each individual error.\nfunc stringifyKadmErr(err error) []string {\n\tvar ae *kadm.AuthError\n\tvar se *kadm.ShardErrors\n\tswitch {\n\tcase err == nil:\n\t\treturn nil\n\n\tcase errors.As(err, &se):\n\t\tvar errs []string\n\t\tfor _, err := range se.Errs {\n\t\t\terrs = append(errs, fmt.Sprintf(\"%s to %s (%d) failed: %s\",\n\t\t\t\tse.Name,\n\t\t\t\tnet.JoinHostPort(err.Broker.Host, strconv.Itoa(int(err.Broker.Port))),\n\t\t\t\terr.Broker.NodeID,\n\t\t\t\terr.Err,\n\t\t\t))\n\t\t}\n\t\treturn errs\n\n\tcase errors.As(err, &ae):\n\t\treturn []string{fmt.Sprintf(\"authorization error: %s\", err)}\n\n\tdefault:\n\t\treturn []string{err.Error()}\n\t}\n}\n\nfunc saveKafkaMetadata(rootCtx context.Context, ps *stepParams, cl *kgo.Client) step {\n\treturn func() error {\n\t\tlog.Debug(\"Reading Kafka information\")\n\n\t\tctx, cancel := context.WithTimeout(rootCtx, 10*time.Second)\n\t\tdefer cancel()\n\n\t\ttype resp struct {\n\t\t\tName     string      // the request the response is for\n\t\t\tResponse interface{} // a raw response from kadm\n\t\t\tError    []string    // no error, or one error, or potentially many shard errors\n\t\t}\n\t\tvar resps []resp\n\n\t\tadm := kadm.NewClient(cl)\n\n\t\tmeta, err := adm.Metadata(ctx)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"metadata\",\n\t\t\tResponse: meta,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\ttcs, err := adm.DescribeTopicConfigs(ctx, meta.Topics.Names()...)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"topic_configs\",\n\t\t\tResponse: tcs,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\tbcs, err := adm.DescribeBrokerConfigs(ctx, meta.Brokers.NodeIDs()...)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"broker_configs\",\n\t\t\tResponse: bcs,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\tostart, err := adm.ListStartOffsets(ctx)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"log_start_offsets\",\n\t\t\tResponse: ostart,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\tocommitted, err := adm.ListCommittedOffsets(ctx)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"last_stable_offsets\",\n\t\t\tResponse: ocommitted,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\toend, err := adm.ListEndOffsets(ctx)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"high_watermarks\",\n\t\t\tResponse: oend,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\tgroups, err := adm.DescribeGroups(ctx)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"groups\",\n\t\t\tResponse: groups,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\tfetched := adm.FetchManyOffsets(ctx, groups.Names()...)\n\t\tfor _, fetch := range fetched {\n\t\t\tresps = append(resps, resp{\n\t\t\t\tName:     fmt.Sprintf(\"group_commits_%s\", fetch.Group),\n\t\t\t\tResponse: fetch.Fetched,\n\t\t\t\tError:    stringifyKadmErr(fetch.Err),\n\t\t\t})\n\t\t}\n\n\t\tmarshal, err := json.Marshal(resps)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to encode kafka admin responses: %v\", err)\n\t\t}\n\n\t\treturn writeFileToZip(ps, \"kafka.json\", marshal)\n\t}\n}\n\n// Walks the redpanda data directory recursively, and saves to the bundle\n// a JSON map where the keys are the file/ dir paths, and the values are\n// objects containing their data: size, mode, the file or dir it points to\n// if the current file is a symlink, the time it was modified, its owner and\n// its group, as well as an error message if reading that specific file failed.\nfunc saveDataDirStructure(ps *stepParams, conf *config.Config) step {\n\treturn func() error {\n\t\tfiles := make(map[string]*fileInfo)\n\t\terr := walkDir(conf.Redpanda.Directory, files)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't walk '%s': %w\", conf.Redpanda.Directory, err)\n\t\t}\n\t\tbs, err := json.Marshal(files)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"couldn't encode the '%s' directory structure as JSON: %w\",\n\t\t\t\tconf.Redpanda.Directory,\n\t\t\t\terr,\n\t\t\t)\n\t\t}\n\t\treturn writeFileToZip(ps, \"data-dir.txt\", bs)\n\t}\n}\n\n// Writes the config file to the bundle, redacting SASL credentials.\nfunc saveConfig(ps *stepParams, conf *config.Config) step {\n\treturn func() error {\n\t\t// Redact SASL credentials\n\t\tredacted := \"(REDACTED)\"\n\t\tif conf.Rpk.KafkaAPI.SASL != nil {\n\t\t\tconf.Rpk.KafkaAPI.SASL.User = redacted\n\t\t\tconf.Rpk.KafkaAPI.SASL.Password = redacted\n\t\t}\n\t\tif conf.Rpk.SASL != nil {\n\t\t\tconf.Rpk.SASL.User = redacted\n\t\t\tconf.Rpk.SASL.Password = redacted\n\t\t}\n\t\t// We want to redact any blindly decoded parameters.\n\t\tredactOtherMap(conf.Other)\n\t\tredactOtherMap(conf.Redpanda.Other)\n\t\tredactServerTLSSlice(conf.Redpanda.RPCServerTLS)\n\t\tredactServerTLSSlice(conf.Redpanda.KafkaAPITLS)\n\t\tredactServerTLSSlice(conf.Redpanda.AdminAPITLS)\n\t\tif conf.SchemaRegistry != nil {\n\t\t\tfor _, server := range conf.SchemaRegistry.SchemaRegistryAPITLS {\n\t\t\t\tredactOtherMap(server.Other)\n\t\t\t}\n\t\t}\n\t\tif conf.Pandaproxy != nil {\n\t\t\tredactOtherMap(conf.Pandaproxy.Other)\n\t\t\tredactServerTLSSlice(conf.Pandaproxy.PandaproxyAPITLS)\n\t\t}\n\t\tif conf.PandaproxyClient != nil {\n\t\t\tredactOtherMap(conf.PandaproxyClient.Other)\n\t\t}\n\t\tif conf.SchemaRegistryClient != nil {\n\t\t\tredactOtherMap(conf.SchemaRegistryClient.Other)\n\t\t}\n\n\t\tbs, err := yaml.Marshal(conf)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't encode the redpanda config as YAML: %w\", err)\n\t\t}\n\t\treturn writeFileToZip(ps, \"redpanda.yaml\", bs)\n\t}\n}\n\nfunc redactServerTLSSlice(servers []config.ServerTLS) {\n\tfor _, server := range servers {\n\t\tredactOtherMap(server.Other)\n\t}\n}\n\nfunc redactOtherMap(other map[string]interface{}) {\n\tfor k := range other {\n\t\tother[k] = \"(REDACTED)\"\n\t}\n}\n\n// Saves the contents of '/proc/cpuinfo'.\nfunc saveCPUInfo(ps *stepParams) step {\n\treturn func() error {\n\t\tbs, err := afero.ReadFile(ps.fs, \"/proc/cpuinfo\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn writeFileToZip(ps, \"proc/cpuinfo\", bs)\n\t}\n}\n\n// Saves the contents of '/proc/interrupts'.\nfunc saveInterrupts(ps *stepParams) step {\n\treturn func() error {\n\t\tbs, err := afero.ReadFile(ps.fs, \"/proc/interrupts\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn writeFileToZip(ps, \"proc/interrupts\", bs)\n\t}\n}\n\n// Writes a file containing memory, disk & CPU usage metrics for a local\n// redpanda process.\nfunc saveResourceUsageData(ps *stepParams, conf *config.Config) step {\n\treturn func() error {\n\t\tres, err := system.GatherMetrics(ps.fs, ps.timeout, *conf)\n\t\tif system.IsErrRedpandaDown(err) {\n\t\t\treturn fmt.Errorf(\"omitting resource usage metrics: %w\", err)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error gathering resource usage metrics: %w\", err)\n\t\t}\n\t\tbs, err := json.Marshal(res)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't encode resource usage metrics: %w\", err)\n\t\t}\n\t\treturn writeFileToZip(ps, \"resource-usage.json\", bs)\n\t}\n}\n\n// Queries 'pool.ntp.org' and writes a file with the reported RTT, time & precision.\nfunc saveNTPDrift(ps *stepParams) step {\n\treturn func() error {\n\t\tconst (\n\t\t\thost    = \"pool.ntp.org\"\n\t\t\tretries = 3\n\t\t)\n\n\t\tvar (\n\t\t\tresponse  *ntp.Response\n\t\t\tlocalTime time.Time\n\t\t\terr       error\n\t\t)\n\n\t\tqueryNTP := func() error {\n\t\t\tlocalTime = time.Now()\n\t\t\tresponse, err = ntp.Query(host)\n\t\t\treturn err\n\t\t}\n\n\t\terr = retry.Do(\n\t\t\tqueryNTP,\n\t\t\tretry.Attempts(retries),\n\t\t\tretry.DelayType(retry.FixedDelay),\n\t\t\tretry.Delay(1*time.Second),\n\t\t\tretry.LastErrorOnly(true),\n\t\t\tretry.OnRetry(func(n uint, err error) {\n\t\t\t\tlog.Debugf(\"Couldn't retrieve NTP data from %s: %v\", host, err)\n\t\t\t\tlog.Debugf(\"Retrying (%d retries left)\", retries-n)\n\t\t\t}),\n\t\t)\n\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error querying '%s': %w\", host, err)\n\t\t}\n\n\t\tresult := struct {\n\t\t\tHost            string        `json:\"host\"`\n\t\t\tRoundTripTimeMs int64         `json:\"roundTripTimeMs\"`\n\t\t\tRemoteTimeUTC   time.Time     `json:\"remoteTimeUTC\"`\n\t\t\tLocalTimeUTC    time.Time     `json:\"localTimeUTC\"`\n\t\t\tPrecisionMs     int64         `json:\"precisionMs\"`\n\t\t\tOffset          time.Duration `json:\"offset\"`\n\t\t}{\n\t\t\tHost:            host,\n\t\t\tRoundTripTimeMs: response.RTT.Milliseconds(),\n\t\t\tRemoteTimeUTC:   response.Time.UTC(),\n\t\t\tLocalTimeUTC:    localTime.UTC(),\n\t\t\tPrecisionMs:     response.Precision.Milliseconds(),\n\t\t\tOffset:          response.ClockOffset,\n\t\t}\n\n\t\tmarshalled, err := json.Marshal(result)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't marshal the NTP response: %w\", err)\n\t\t}\n\n\t\treturn writeFileToZip(\n\t\t\tps,\n\t\t\t\"ntp.txt\",\n\t\t\tmarshalled,\n\t\t)\n\t}\n}\n\nfunc saveSyslog(ps *stepParams) step {\n\treturn func() error {\n\t\tentries, err := syslog.ReadAll()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn writeFileToZip(ps, \"syslog.txt\", entries)\n\t}\n}\n\n// Queries the given admin API address for prometheus metrics.\nfunc savePrometheusMetrics(ctx context.Context, ps *stepParams, admin *admin.AdminAPI) step {\n\treturn func() error {\n\t\traw, err := admin.PrometheusMetrics(ctx)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to fetch metrics from the admin API: %w\", err)\n\t\t}\n\t\treturn writeFileToZip(ps, \"prometheus-metrics.txt\", raw)\n\t}\n}\n\n// Saves the output of `dig`.\nfunc saveDNSData(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(ctx, ps, \"dig.txt\", \"dig\")\n\t}\n}\n\n// Saves the disk usage total within redpanda's data directory.\nfunc saveDiskUsage(ctx context.Context, ps *stepParams, conf *config.Config) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"du.txt\",\n\t\t\t\"du\", \"-h\", conf.Redpanda.Directory,\n\t\t)\n\t}\n}\n\n// TODO: What if running inside a container/ k8s?\n// Writes the journald redpanda logs, if available, to the bundle.\nfunc saveLogs(ctx context.Context, ps *stepParams, since, until string, logsLimitBytes int) step {\n\treturn func() error {\n\t\targs := []string{\"--no-pager\", \"-u\", \"redpanda\"}\n\t\tif since != \"\" {\n\t\t\targs = append(args, \"--since\", since)\n\t\t}\n\t\tif until != \"\" {\n\t\t\targs = append(args, \"--until\", until)\n\t\t}\n\t\treturn writeCommandOutputToZipLimit(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"redpanda.log\",\n\t\t\tlogsLimitBytes,\n\t\t\t\"journalctl\",\n\t\t\targs...,\n\t\t)\n\t}\n}\n\n// Saves the output of `ss`.\nfunc saveSocketData(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(ctx, ps, \"ss.txt\", \"ss\")\n\t}\n}\n\n// Saves the output of `top`.\nfunc saveTopOutput(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"top.txt\",\n\t\t\t\"top\", \"-b\", \"-n\", \"10\", \"-H\", \"-d\", \"1\",\n\t\t)\n\t}\n}\n\n// Saves the output of `vmstat`.\nfunc saveVmstat(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"vmstat.txt\",\n\t\t\t\"vmstat\", \"-w\", \"1\", \"10\",\n\t\t)\n\t}\n}\n\n// Saves the output of `ip addr`.\nfunc saveIP(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"ip.txt\",\n\t\t\t\"ip\", \"addr\",\n\t\t)\n\t}\n}\n\n// Saves the output of `lspci`.\nfunc saveLspci(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"lspci.txt\",\n\t\t\t\"lspci\",\n\t\t)\n\t}\n}\n\n// Saves the output of `dmidecode`.\nfunc saveDmidecode(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"dmidecode.txt\",\n\t\t\t\"dmidecode\",\n\t\t)\n\t}\n}\n\nfunc walkDir(root string, files map[string]*fileInfo) error {\n\treturn filepath.WalkDir(\n\t\troot,\n\t\tfunc(path string, d fs.DirEntry, readErr error) error {\n\t\t\t// Prevent infinite loops.\n\t\t\tif _, exists := files[path]; exists {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\ti := new(fileInfo)\n\t\t\tfiles[path] = i\n\n\t\t\t// If the directory's contents couldn't be read, skip it.\n\t\t\tif readErr != nil {\n\t\t\t\ti.Error = readErr.Error()\n\t\t\t\treturn fs.SkipDir\n\t\t\t}\n\n\t\t\tinfo, err := d.Info()\n\t\t\tif err != nil {\n\t\t\t\ti.Error = err.Error()\n\t\t\t\t// If reading a directory failed, then skip it altogether.\n\t\t\t\tif d.IsDir() {\n\t\t\t\t\treturn fs.SkipDir\n\t\t\t\t}\n\t\t\t\t// If it's just a file, just return and move to the\n\t\t\t\t// next entry.\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\ti.Size = units.HumanSize(float64(info.Size()))\n\t\t\ti.Mode = info.Mode().String()\n\t\t\ti.Modified = info.ModTime().String()\n\n\t\t\t// The user and group are only available through the\n\t\t\t// underlying syscall object.\n\t\t\tsys, ok := info.Sys().(*syscall.Stat_t)\n\t\t\tif ok {\n\t\t\t\tu, err := user.LookupId(fmt.Sprint(sys.Uid))\n\t\t\t\tif err == nil {\n\t\t\t\t\ti.User = u.Name\n\t\t\t\t} else {\n\t\t\t\t\ti.User = fmt.Sprintf(\"user lookup failed for UID %d: %v\", sys.Uid, err)\n\t\t\t\t}\n\t\t\t\tg, err := user.LookupGroupId(fmt.Sprint(sys.Gid))\n\t\t\t\tif err == nil {\n\t\t\t\t\ti.Group = g.Name\n\t\t\t\t} else {\n\t\t\t\t\ti.Group = fmt.Sprintf(\"group lookup failed for GID %d: %v\", sys.Gid, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If it's a symlink, save the dir or file it points to.\n\t\t\t// If the file it points to is a directory, follow it and then\n\t\t\t// call `walk` using it as the root.\n\t\t\tisSymlink := info.Mode().Type()&fs.ModeSymlink != 0\n\t\t\tif !isSymlink {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tdest, err := os.Readlink(path)\n\t\t\tif err != nil {\n\t\t\t\ti.Symlink = \"unresolvable\"\n\t\t\t\ti.Error = err.Error()\n\t\t\t}\n\t\t\ti.Symlink = dest\n\n\t\t\tfInfo, err := os.Stat(dest)\n\t\t\tif err != nil {\n\t\t\t\tfiles[dest] = &fileInfo{Error: err.Error()}\n\t\t\t} else if fInfo.IsDir() {\n\t\t\t\treturn walkDir(dest, files)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t)\n}\n", "// Copyright 2020 Redpanda Data, Inc.\n//\n// Use of this software is governed by the Business Source License\n// included in the file licenses/BSL.md\n//\n// As of the Change Date specified in that file, in accordance with\n// the Business Source License, use of this software will be governed\n// by the Apache License, Version 2.0\n\npackage config\n\nimport (\n\t\"crypto/tls\"\n\t\"path\"\n\n\t\"github.com/spf13/afero\"\n\t\"github.com/twmb/tlscfg\"\n)\n\ntype Config struct {\n\tfile         *Config\n\tfileLocation string\n\n\tNodeUUID             string             `yaml:\"node_uuid,omitempty\" json:\"node_uuid\"`\n\tOrganization         string             `yaml:\"organization,omitempty\" json:\"organization\"`\n\tLicenseKey           string             `yaml:\"license_key,omitempty\" json:\"license_key\"`\n\tClusterID            string             `yaml:\"cluster_id,omitempty\" json:\"cluster_id\"`\n\tRedpanda             RedpandaNodeConfig `yaml:\"redpanda,omitempty\" json:\"redpanda\"`\n\tRpk                  RpkConfig          `yaml:\"rpk,omitempty\" json:\"rpk\"`\n\tPandaproxy           *Pandaproxy        `yaml:\"pandaproxy,omitempty\" json:\"pandaproxy,omitempty\"`\n\tPandaproxyClient     *KafkaClient       `yaml:\"pandaproxy_client,omitempty\" json:\"pandaproxy_client,omitempty\"`\n\tSchemaRegistry       *SchemaRegistry    `yaml:\"schema_registry,omitempty\" json:\"schema_registry,omitempty\"`\n\tSchemaRegistryClient *KafkaClient       `yaml:\"schema_registry_client,omitempty\" json:\"schema_registry_client,omitempty\"`\n\n\tOther map[string]interface{} `yaml:\",inline\"`\n}\n\n// File returns the configuration as read from a file, with no defaults\n// pre-deserializing and no overrides applied after. If the return is nil,\n// no file was read.\nfunc (c *Config) File() *Config {\n\treturn c.file\n}\n\n// FileLocation returns the loaded file location; this is the path that\n// rpk uses for write operations.\nfunc (c *Config) FileLocation() string {\n\treturn c.fileLocation\n}\n\n// RedpandaNodeConfig is the source of truth for Redpanda node configuration.\n//\n// Cluster properties must NOT be enlisted in this struct. Adding a cluster\n// property here would cause the dependent libraries (e.g. operator) to wrongly\n// consider it a node property.\ntype RedpandaNodeConfig struct {\n\tDirectory                  string                    `yaml:\"data_directory,omitempty\" json:\"data_directory\"`\n\tID                         int                       `yaml:\"node_id\" json:\"node_id\"`\n\tRack                       string                    `yaml:\"rack,omitempty\" json:\"rack\"`\n\tSeedServers                []SeedServer              `yaml:\"seed_servers\" json:\"seed_servers\"`\n\tRPCServer                  SocketAddress             `yaml:\"rpc_server,omitempty\" json:\"rpc_server\"`\n\tRPCServerTLS               []ServerTLS               `yaml:\"rpc_server_tls,omitempty\" json:\"rpc_server_tls\"`\n\tKafkaAPI                   []NamedAuthNSocketAddress `yaml:\"kafka_api,omitempty\" json:\"kafka_api\"`\n\tKafkaAPITLS                []ServerTLS               `yaml:\"kafka_api_tls,omitempty\" json:\"kafka_api_tls\"`\n\tAdminAPI                   []NamedSocketAddress      `yaml:\"admin,omitempty\" json:\"admin\"`\n\tAdminAPITLS                []ServerTLS               `yaml:\"admin_api_tls,omitempty\" json:\"admin_api_tls\"`\n\tCoprocSupervisorServer     SocketAddress             `yaml:\"coproc_supervisor_server,omitempty\" json:\"coproc_supervisor_server\"`\n\tAdminAPIDocDir             string                    `yaml:\"admin_api_doc_dir,omitempty\" json:\"admin_api_doc_dir\"`\n\tDashboardDir               string                    `yaml:\"dashboard_dir,omitempty\" json:\"dashboard_dir\"`\n\tCloudStorageCacheDirectory string                    `yaml:\"cloud_storage_cache_directory,omitempty\" json:\"cloud_storage_cache_directory\"`\n\tAdvertisedRPCAPI           *SocketAddress            `yaml:\"advertised_rpc_api,omitempty\" json:\"advertised_rpc_api,omitempty\"`\n\tAdvertisedKafkaAPI         []NamedSocketAddress      `yaml:\"advertised_kafka_api,omitempty\" json:\"advertised_kafka_api,omitempty\"`\n\tDeveloperMode              bool                      `yaml:\"developer_mode,omitempty\" json:\"developer_mode\"`\n\tOther                      map[string]interface{}    `yaml:\",inline\"`\n}\n\ntype Pandaproxy struct {\n\tPandaproxyAPI           []NamedSocketAddress   `yaml:\"pandaproxy_api,omitempty\" json:\"pandaproxy_api,omitempty\"`\n\tPandaproxyAPITLS        []ServerTLS            `yaml:\"pandaproxy_api_tls,omitempty\" json:\"pandaproxy_api_tls,omitempty\"`\n\tAdvertisedPandaproxyAPI []NamedSocketAddress   `yaml:\"advertised_pandaproxy_api,omitempty\" json:\"advertised_pandaproxy_api,omitempty\"`\n\tOther                   map[string]interface{} `yaml:\",inline\"`\n}\n\ntype SchemaRegistry struct {\n\tSchemaRegistryAPI               []NamedSocketAddress `yaml:\"schema_registry_api,omitempty\" json:\"schema_registry_api,omitempty\"`\n\tSchemaRegistryAPITLS            []ServerTLS          `yaml:\"schema_registry_api_tls,omitempty\" json:\"schema_registry_api_tls,omitempty\"`\n\tSchemaRegistryReplicationFactor *int                 `yaml:\"schema_registry_replication_factor,omitempty\" json:\"schema_registry_replication_factor,omitempty\"`\n}\n\ntype KafkaClient struct {\n\tBrokers       []SocketAddress        `yaml:\"brokers,omitempty\" json:\"brokers,omitempty\"`\n\tBrokerTLS     ServerTLS              `yaml:\"broker_tls,omitempty\" json:\"broker_tls,omitempty\"`\n\tSASLMechanism *string                `yaml:\"sasl_mechanism,omitempty\" json:\"sasl_mechanism,omitempty\"`\n\tSCRAMUsername *string                `yaml:\"scram_username,omitempty\" json:\"scram_username,omitempty\"`\n\tSCRAMPassword *string                `yaml:\"scram_password,omitempty\" json:\"scram_password,omitempty\"`\n\tOther         map[string]interface{} `yaml:\",inline\"`\n}\n\ntype SeedServer struct {\n\tHost SocketAddress `yaml:\"host,omitempty\" json:\"host\"`\n}\n\ntype SocketAddress struct {\n\tAddress string `yaml:\"address\" json:\"address\"`\n\tPort    int    `yaml:\"port,omitempty\" json:\"port\"`\n}\n\ntype NamedSocketAddress struct {\n\tAddress string `yaml:\"address\" json:\"address\"`\n\tPort    int    `yaml:\"port,omitempty\" json:\"port\"`\n\tName    string `yaml:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\ntype NamedAuthNSocketAddress struct {\n\tAddress string  `yaml:\"address,omitempty\" json:\"address\"`\n\tPort    int     `yaml:\"port,omitempty\" json:\"port\"`\n\tName    string  `yaml:\"name,omitempty\" json:\"name,omitempty\"`\n\tAuthN   *string `yaml:\"authentication_method,omitempty\" json:\"authentication_method,omitempty\"`\n}\n\ntype TLS struct {\n\tKeyFile        string `yaml:\"key_file,omitempty\" json:\"key_file\"`\n\tCertFile       string `yaml:\"cert_file,omitempty\" json:\"cert_file\"`\n\tTruststoreFile string `yaml:\"truststore_file,omitempty\" json:\"truststore_file\"`\n}\n\nfunc (t *TLS) Config(fs afero.Fs) (*tls.Config, error) {\n\tif t == nil {\n\t\treturn nil, nil\n\t}\n\treturn tlscfg.New(\n\t\ttlscfg.WithFS(\n\t\t\ttlscfg.FuncFS(func(path string) ([]byte, error) {\n\t\t\t\treturn afero.ReadFile(fs, path)\n\t\t\t}),\n\t\t),\n\t\ttlscfg.MaybeWithDiskCA(\n\t\t\tt.TruststoreFile,\n\t\t\ttlscfg.ForClient,\n\t\t),\n\t\ttlscfg.MaybeWithDiskKeyPair(\n\t\t\tt.CertFile,\n\t\t\tt.KeyFile,\n\t\t),\n\t)\n}\n\ntype ServerTLS struct {\n\tName              string                 `yaml:\"name,omitempty\" json:\"name\"`\n\tKeyFile           string                 `yaml:\"key_file,omitempty\" json:\"key_file\"`\n\tCertFile          string                 `yaml:\"cert_file,omitempty\" json:\"cert_file\"`\n\tTruststoreFile    string                 `yaml:\"truststore_file,omitempty\" json:\"truststore_file\"`\n\tEnabled           bool                   `yaml:\"enabled,omitempty\" json:\"enabled\"`\n\tRequireClientAuth bool                   `yaml:\"require_client_auth,omitempty\" json:\"require_client_auth\"`\n\tOther             map[string]interface{} `yaml:\",inline\" `\n}\n\ntype RpkConfig struct {\n\t// Deprecated 2021-07-1\n\tTLS *TLS `yaml:\"tls,omitempty\" json:\"tls\"`\n\t// Deprecated 2021-07-1\n\tSASL *SASL `yaml:\"sasl,omitempty\" json:\"sasl,omitempty\"`\n\n\tKafkaAPI                 RpkKafkaAPI `yaml:\"kafka_api,omitempty\" json:\"kafka_api\"`\n\tAdminAPI                 RpkAdminAPI `yaml:\"admin_api,omitempty\" json:\"admin_api\"`\n\tAdditionalStartFlags     []string    `yaml:\"additional_start_flags,omitempty\"  json:\"additional_start_flags\"`\n\tEnableUsageStats         bool        `yaml:\"enable_usage_stats,omitempty\" json:\"enable_usage_stats\"`\n\tTuneNetwork              bool        `yaml:\"tune_network,omitempty\" json:\"tune_network\"`\n\tTuneDiskScheduler        bool        `yaml:\"tune_disk_scheduler,omitempty\" json:\"tune_disk_scheduler\"`\n\tTuneNomerges             bool        `yaml:\"tune_disk_nomerges,omitempty\" json:\"tune_disk_nomerges\"`\n\tTuneDiskWriteCache       bool        `yaml:\"tune_disk_write_cache,omitempty\" json:\"tune_disk_write_cache\"`\n\tTuneDiskIrq              bool        `yaml:\"tune_disk_irq,omitempty\" json:\"tune_disk_irq\"`\n\tTuneFstrim               bool        `yaml:\"tune_fstrim,omitempty\" json:\"tune_fstrim\"`\n\tTuneCPU                  bool        `yaml:\"tune_cpu,omitempty\" json:\"tune_cpu\"`\n\tTuneAioEvents            bool        `yaml:\"tune_aio_events,omitempty\" json:\"tune_aio_events\"`\n\tTuneClocksource          bool        `yaml:\"tune_clocksource,omitempty\" json:\"tune_clocksource\"`\n\tTuneSwappiness           bool        `yaml:\"tune_swappiness,omitempty\" json:\"tune_swappiness\"`\n\tTuneTransparentHugePages bool        `yaml:\"tune_transparent_hugepages,omitempty\" json:\"tune_transparent_hugepages\"`\n\tEnableMemoryLocking      bool        `yaml:\"enable_memory_locking,omitempty\" json:\"enable_memory_locking\"`\n\tTuneCoredump             bool        `yaml:\"tune_coredump,omitempty\" json:\"tune_coredump\"`\n\tCoredumpDir              string      `yaml:\"coredump_dir,omitempty\" json:\"coredump_dir\"`\n\tTuneBallastFile          bool        `yaml:\"tune_ballast_file,omitempty\" json:\"tune_ballast_file\"`\n\tBallastFilePath          string      `yaml:\"ballast_file_path,omitempty\" json:\"ballast_file_path\"`\n\tBallastFileSize          string      `yaml:\"ballast_file_size,omitempty\" json:\"ballast_file_size\"`\n\tWellKnownIo              string      `yaml:\"well_known_io,omitempty\" json:\"well_known_io\"`\n\tOverprovisioned          bool        `yaml:\"overprovisioned,omitempty\" json:\"overprovisioned\"`\n\tSMP                      *int        `yaml:\"smp,omitempty\" json:\"smp,omitempty\"`\n}\n\ntype RpkKafkaAPI struct {\n\tBrokers []string `yaml:\"brokers,omitempty\" json:\"brokers\"`\n\tTLS     *TLS     `yaml:\"tls,omitempty\" json:\"tls\"`\n\tSASL    *SASL    `yaml:\"sasl,omitempty\" json:\"sasl,omitempty\"`\n}\n\ntype RpkAdminAPI struct {\n\tAddresses []string `yaml:\"addresses,omitempty\" json:\"addresses\"`\n\tTLS       *TLS     `yaml:\"tls,omitempty\" json:\"tls\"`\n}\n\ntype SASL struct {\n\tUser      string `yaml:\"user,omitempty\" json:\"user,omitempty\"`\n\tPassword  string `yaml:\"password,omitempty\" json:\"password,omitempty\"`\n\tMechanism string `yaml:\"type,omitempty\" json:\"type,omitempty\"`\n}\n\nfunc (c *Config) PIDFile() string {\n\treturn path.Join(c.Redpanda.Directory, \"pid.lock\")\n}\n", "// Copyright 2020 Redpanda Data, Inc.\n//\n// Use of this software is governed by the Business Source License\n// included in the file licenses/BSL.md\n//\n// As of the Change Date specified in that file, in accordance with\n// the Business Source License, use of this software will be governed\n// by the Apache License, Version 2.0\n\npackage config\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\n\t\"gopkg.in/yaml.v3\"\n)\n\n// This file contains weak params type, including basic types support (bool,\n// int, and string) and one_or_many support for different types.\n//\n// The use of this file is to support our transition to a strongly typed\n// config file and our migration away from viper and mapstructure.\n// TODO: Print deprecation warning when using weak types https://github.com/redpanda-data/redpanda/issues/5262\n\n// weakBool is an intermediary boolean type to be used during our transition\n// to strictly typed configuration parameters. This will allow us to support\n// weakly typed parsing:\n//\n//   - int to bool (true if value != 0)\n//   - string to bool (accepts: 1, t, T, TRUE, true, True, 0, f, F, FALSE,\n//     false, False. Anything else is an error)\ntype weakBool bool\n\nfunc (wb *weakBool) UnmarshalYAML(n *yaml.Node) error {\n\tswitch n.Tag {\n\tcase \"!!bool\":\n\t\tb, err := strconv.ParseBool(n.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*wb = weakBool(b)\n\t\treturn nil\n\tcase \"!!int\":\n\t\tni, err := strconv.Atoi(n.Value)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as bool: %s\", n.Value, err)\n\t\t}\n\t\t*wb = ni != 0\n\t\treturn nil\n\tcase \"!!str\":\n\t\t// it accepts 1, t, T, TRUE, true, True, 0, f, F\n\t\tnb, err := strconv.ParseBool(n.Value)\n\t\tif err == nil {\n\t\t\t*wb = weakBool(nb)\n\t\t\treturn nil\n\t\t} else if n.Value == \"\" {\n\t\t\t*wb = false\n\t\t\treturn nil\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as bool: %s\", n.Value, err)\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"type %s not supported as a boolean\", n.Tag)\n\t}\n}\n\n// weakInt is an intermediary integer type to be used during our transition to\n// strictly typed configuration parameters. This will allow us to support\n// weakly typed parsing:\n//\n//   - strings to int/uint (base implied by prefix)\n//   - bools to int/uint (true = 1, false = 0)\ntype weakInt int\n\nfunc (wi *weakInt) UnmarshalYAML(n *yaml.Node) error {\n\tswitch n.Tag {\n\tcase \"!!int\":\n\t\tni, err := strconv.Atoi(n.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*wi = weakInt(ni)\n\t\treturn nil\n\tcase \"!!str\":\n\t\tstr := n.Value\n\t\tif str == \"\" {\n\t\t\tstr = \"0\"\n\t\t}\n\t\tni, err := strconv.Atoi(str)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as an integer: %s\", str, err)\n\t\t}\n\t\t*wi = weakInt(ni)\n\t\treturn nil\n\tcase \"!!bool\":\n\t\tnb, err := strconv.ParseBool(n.Value)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as an integer: %s\", n.Value, err)\n\t\t}\n\t\tif nb {\n\t\t\t*wi = 1\n\t\t\treturn nil\n\t\t}\n\t\t*wi = 0\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"type %s not supported as an integer\", n.Tag)\n\t}\n}\n\n// weakString is an intermediary string type to be used during our transition to\n// strictly typed configuration parameters. This will allow us to support\n// weakly typed parsing:\n//\n//   - bools to string (true = \"1\", false = \"0\")\n//   - numbers to string (base 10)\ntype weakString string\n\nfunc (ws *weakString) UnmarshalYAML(n *yaml.Node) error {\n\tswitch n.Tag {\n\tcase \"!!str\":\n\t\t*ws = weakString(n.Value)\n\t\treturn nil\n\tcase \"!!bool\":\n\t\tnb, err := strconv.ParseBool(n.Value)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as a boolean: %s\", n.Value, err)\n\t\t}\n\t\tif nb {\n\t\t\t*ws = \"1\"\n\t\t\treturn nil\n\t\t}\n\t\t*ws = \"0\"\n\t\treturn nil\n\tcase \"!!int\", \"!!float\":\n\t\t*ws = weakString(n.Value)\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"type %s not supported as a string\", n.Tag)\n\t}\n}\n\n// weakStringArray is an intermediary one_or_many type to be used\n// during our transition to strictly typed configuration parameters.\n// This type will:\n//   - parse an array of strings\n//   - parse a single string to an array.\ntype weakStringArray []string\n\nfunc (wsa *weakStringArray) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []weakString\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\ts := make([]string, len(multi))\n\t\tfor i, v := range multi {\n\t\t\ts[i] = string(v)\n\t\t}\n\t\t*wsa = s\n\t\treturn nil\n\t}\n\n\tvar single weakString\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*wsa = []string{string(single)}\n\treturn nil\n}\n\n// socketAddresses is an intermediary one_or_many type to be used\n// during our transition to strictly typed configuration parameters.\n// This type will:\n//   - parse an array of SocketAddress\n//   - parse a single SocketAddress to an array.\ntype socketAddresses []SocketAddress\n\nfunc (s *socketAddresses) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []SocketAddress\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\t*s = multi\n\t\treturn nil\n\t}\n\n\tvar single SocketAddress\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*s = []SocketAddress{single}\n\treturn nil\n}\n\n// namedSocketAddresses is an intermediary one_or_many type to be used\n// during our transition to strictly typed configuration parameters.\n// This type will:\n//   - parse an array of NamedSocketAddress\n//   - parse a single NamedSocketAddress to an array.\ntype namedSocketAddresses []NamedSocketAddress\n\nfunc (nsa *namedSocketAddresses) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []NamedSocketAddress\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\t*nsa = multi\n\t\treturn nil\n\t}\n\n\tvar single NamedSocketAddress\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*nsa = []NamedSocketAddress{single}\n\treturn nil\n}\n\n// namedAuthNSocketAddresses is an intermediary one_or_many type to be used\n// during our transition to strictly typed configuration parameters.\n// This type will:\n//   - parse an array of NamedAuthNSocketAddress\n//   - parse a single NamedAuthNSocketAddress to an array.\ntype namedAuthNSocketAddresses []NamedAuthNSocketAddress\n\nfunc (nsa *namedAuthNSocketAddresses) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []NamedAuthNSocketAddress\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\t*nsa = multi\n\t\treturn nil\n\t}\n\n\tvar single NamedAuthNSocketAddress\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*nsa = []NamedAuthNSocketAddress{single}\n\treturn nil\n}\n\n// serverTLSArray is an intermediary one_or_many type to be used during our\n// transition to strictly typed configuration parameters. This type will:\n//   - parse an array of ServerTLS\n//   - parse a single ServerTLS to an array.\ntype serverTLSArray []ServerTLS\n\nfunc (s *serverTLSArray) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []ServerTLS\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\t*s = multi\n\t\treturn nil\n\t}\n\n\tvar single ServerTLS\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// do not log serverTLS because the Other field may contain a secret\n\t*s = []ServerTLS{single}\n\treturn nil\n}\n\n// seedServers is an intermediary one_or_many type to be used during our\n// transition to strictly typed configuration parameters. This type will:\n//   - parse an array of SeedServer\n//   - parse a single SeedServer to an array.\ntype seedServers []SeedServer\n\nfunc (ss *seedServers) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []SeedServer\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\t*ss = multi\n\t\treturn nil\n\t}\n\n\tvar single SeedServer\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*ss = []SeedServer{single}\n\treturn nil\n}\n\n// Custom unmarshallers for all the config related types.\n\nfunc (c *Config) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tNodeUUID             weakString         `yaml:\"node_uuid\"`\n\t\tOrganization         weakString         `yaml:\"organization\"`\n\t\tLicenseKey           weakString         `yaml:\"license_key\"`\n\t\tClusterID            weakString         `yaml:\"cluster_id\"`\n\t\tRedpanda             RedpandaNodeConfig `yaml:\"redpanda\"`\n\t\tRpk                  RpkConfig          `yaml:\"rpk\"`\n\t\tPandaproxy           *Pandaproxy        `yaml:\"pandaproxy\"`\n\t\tPandaproxyClient     *KafkaClient       `yaml:\"pandaproxy_client\"`\n\t\tSchemaRegistry       *SchemaRegistry    `yaml:\"schema_registry\"`\n\t\tSchemaRegistryClient *KafkaClient       `yaml:\"schema_registry_client\"`\n\n\t\tOther map[string]interface{} `yaml:\",inline\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tc.NodeUUID = string(internal.NodeUUID)\n\tc.Organization = string(internal.Organization)\n\tc.LicenseKey = string(internal.LicenseKey)\n\tc.ClusterID = string(internal.ClusterID)\n\tc.Redpanda = internal.Redpanda\n\tc.Rpk = internal.Rpk\n\tc.Pandaproxy = internal.Pandaproxy\n\tc.PandaproxyClient = internal.PandaproxyClient\n\tc.SchemaRegistry = internal.SchemaRegistry\n\tc.SchemaRegistryClient = internal.SchemaRegistryClient\n\tc.Other = internal.Other\n\n\treturn nil\n}\n\nfunc (rpc *RedpandaNodeConfig) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tDirectory                  weakString                `yaml:\"data_directory\"`\n\t\tID                         weakInt                   `yaml:\"node_id\" `\n\t\tRack                       weakString                `yaml:\"rack\"`\n\t\tSeedServers                seedServers               `yaml:\"seed_servers\"`\n\t\tRPCServer                  SocketAddress             `yaml:\"rpc_server\"`\n\t\tRPCServerTLS               serverTLSArray            `yaml:\"rpc_server_tls\"`\n\t\tKafkaAPI                   namedAuthNSocketAddresses `yaml:\"kafka_api\"`\n\t\tKafkaAPITLS                serverTLSArray            `yaml:\"kafka_api_tls\"`\n\t\tAdminAPI                   namedSocketAddresses      `yaml:\"admin\"`\n\t\tAdminAPITLS                serverTLSArray            `yaml:\"admin_api_tls\"`\n\t\tCoprocSupervisorServer     SocketAddress             `yaml:\"coproc_supervisor_server\"`\n\t\tAdminAPIDocDir             weakString                `yaml:\"admin_api_doc_dir\"`\n\t\tDashboardDir               weakString                `yaml:\"dashboard_dir\"`\n\t\tCloudStorageCacheDirectory weakString                `yaml:\"cloud_storage_cache_directory\"`\n\t\tAdvertisedRPCAPI           *SocketAddress            `yaml:\"advertised_rpc_api\"`\n\t\tAdvertisedKafkaAPI         namedSocketAddresses      `yaml:\"advertised_kafka_api\"`\n\t\tDeveloperMode              weakBool                  `yaml:\"developer_mode\"`\n\t\tOther                      map[string]interface{}    `yaml:\",inline\"`\n\t}\n\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\trpc.Directory = string(internal.Directory)\n\trpc.ID = int(internal.ID)\n\trpc.Rack = string(internal.Rack)\n\trpc.SeedServers = internal.SeedServers\n\trpc.RPCServer = internal.RPCServer\n\trpc.RPCServerTLS = internal.RPCServerTLS\n\trpc.KafkaAPI = internal.KafkaAPI\n\trpc.KafkaAPITLS = internal.KafkaAPITLS\n\trpc.AdminAPI = internal.AdminAPI\n\trpc.AdminAPITLS = internal.AdminAPITLS\n\trpc.CoprocSupervisorServer = internal.CoprocSupervisorServer\n\trpc.AdminAPIDocDir = string(internal.AdminAPIDocDir)\n\trpc.DashboardDir = string(internal.DashboardDir)\n\trpc.CloudStorageCacheDirectory = string(internal.CloudStorageCacheDirectory)\n\trpc.AdvertisedRPCAPI = internal.AdvertisedRPCAPI\n\trpc.AdvertisedKafkaAPI = internal.AdvertisedKafkaAPI\n\trpc.DeveloperMode = bool(internal.DeveloperMode)\n\trpc.Other = internal.Other\n\treturn nil\n}\n\nfunc (rpkc *RpkConfig) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\t// Deprecated 2021-07-1\n\t\tTLS *TLS `yaml:\"tls\"`\n\t\t// Deprecated 2021-07-1\n\t\tSASL *SASL `yaml:\"sasl\"`\n\n\t\tKafkaAPI                 RpkKafkaAPI     `yaml:\"kafka_api\"`\n\t\tAdminAPI                 RpkAdminAPI     `yaml:\"admin_api\"`\n\t\tAdditionalStartFlags     weakStringArray `yaml:\"additional_start_flags\"`\n\t\tEnableUsageStats         weakBool        `yaml:\"enable_usage_stats\"`\n\t\tTuneNetwork              weakBool        `yaml:\"tune_network\"`\n\t\tTuneDiskScheduler        weakBool        `yaml:\"tune_disk_scheduler\"`\n\t\tTuneNomerges             weakBool        `yaml:\"tune_disk_nomerges\"`\n\t\tTuneDiskWriteCache       weakBool        `yaml:\"tune_disk_write_cache\"`\n\t\tTuneDiskIrq              weakBool        `yaml:\"tune_disk_irq\"`\n\t\tTuneFstrim               weakBool        `yaml:\"tune_fstrim\"`\n\t\tTuneCPU                  weakBool        `yaml:\"tune_cpu\"`\n\t\tTuneAioEvents            weakBool        `yaml:\"tune_aio_events\"`\n\t\tTuneClocksource          weakBool        `yaml:\"tune_clocksource\"`\n\t\tTuneSwappiness           weakBool        `yaml:\"tune_swappiness\"`\n\t\tTuneTransparentHugePages weakBool        `yaml:\"tune_transparent_hugepages\"`\n\t\tEnableMemoryLocking      weakBool        `yaml:\"enable_memory_locking\"`\n\t\tTuneCoredump             weakBool        `yaml:\"tune_coredump\"`\n\t\tCoredumpDir              weakString      `yaml:\"coredump_dir\"`\n\t\tTuneBallastFile          weakBool        `yaml:\"tune_ballast_file\"`\n\t\tBallastFilePath          weakString      `yaml:\"ballast_file_path\"`\n\t\tBallastFileSize          weakString      `yaml:\"ballast_file_size\"`\n\t\tWellKnownIo              weakString      `yaml:\"well_known_io\"`\n\t\tOverprovisioned          weakBool        `yaml:\"overprovisioned\"`\n\t\tSMP                      *weakInt        `yaml:\"smp\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\n\trpkc.TLS = internal.TLS\n\trpkc.SASL = internal.SASL\n\trpkc.KafkaAPI = internal.KafkaAPI\n\trpkc.AdminAPI = internal.AdminAPI\n\trpkc.AdditionalStartFlags = internal.AdditionalStartFlags\n\trpkc.EnableUsageStats = bool(internal.EnableUsageStats)\n\trpkc.TuneNetwork = bool(internal.TuneNetwork)\n\trpkc.TuneDiskScheduler = bool(internal.TuneDiskScheduler)\n\trpkc.TuneNomerges = bool(internal.TuneNomerges)\n\trpkc.TuneDiskWriteCache = bool(internal.TuneDiskWriteCache)\n\trpkc.TuneDiskIrq = bool(internal.TuneDiskIrq)\n\trpkc.TuneFstrim = bool(internal.TuneFstrim)\n\trpkc.TuneCPU = bool(internal.TuneCPU)\n\trpkc.TuneAioEvents = bool(internal.TuneAioEvents)\n\trpkc.TuneClocksource = bool(internal.TuneClocksource)\n\trpkc.TuneSwappiness = bool(internal.TuneSwappiness)\n\trpkc.TuneTransparentHugePages = bool(internal.TuneTransparentHugePages)\n\trpkc.EnableMemoryLocking = bool(internal.EnableMemoryLocking)\n\trpkc.TuneCoredump = bool(internal.TuneCoredump)\n\trpkc.CoredumpDir = string(internal.CoredumpDir)\n\trpkc.TuneBallastFile = bool(internal.TuneBallastFile)\n\trpkc.BallastFilePath = string(internal.BallastFilePath)\n\trpkc.BallastFileSize = string(internal.BallastFileSize)\n\trpkc.WellKnownIo = string(internal.WellKnownIo)\n\trpkc.Overprovisioned = bool(internal.Overprovisioned)\n\trpkc.SMP = (*int)(internal.SMP)\n\treturn nil\n}\n\nfunc (r *RpkKafkaAPI) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tBrokers weakStringArray `yaml:\"brokers\"`\n\t\tTLS     *TLS            `yaml:\"tls\"`\n\t\tSASL    *SASL           `yaml:\"sasl\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tr.Brokers = internal.Brokers\n\tr.TLS = internal.TLS\n\tr.SASL = internal.SASL\n\treturn nil\n}\n\nfunc (r *RpkAdminAPI) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tAddresses weakStringArray `yaml:\"addresses\"`\n\t\tTLS       *TLS            `yaml:\"tls\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tr.Addresses = internal.Addresses\n\tr.TLS = internal.TLS\n\treturn nil\n}\n\nfunc (p *Pandaproxy) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tPandaproxyAPI           namedSocketAddresses   `yaml:\"pandaproxy_api\"`\n\t\tPandaproxyAPITLS        serverTLSArray         `yaml:\"pandaproxy_api_tls\"`\n\t\tAdvertisedPandaproxyAPI namedSocketAddresses   `yaml:\"advertised_pandaproxy_api\"`\n\t\tOther                   map[string]interface{} `yaml:\",inline\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tp.PandaproxyAPI = internal.PandaproxyAPI\n\tp.PandaproxyAPITLS = internal.PandaproxyAPITLS\n\tp.AdvertisedPandaproxyAPI = internal.AdvertisedPandaproxyAPI\n\tp.Other = internal.Other\n\treturn nil\n}\n\nfunc (k *KafkaClient) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tBrokers       socketAddresses        `yaml:\"brokers\"`\n\t\tBrokerTLS     ServerTLS              `yaml:\"broker_tls\"`\n\t\tSASLMechanism *weakString            `yaml:\"sasl_mechanism\"`\n\t\tSCRAMUsername *weakString            `yaml:\"scram_username\"`\n\t\tSCRAMPassword *weakString            `yaml:\"scram_password\"`\n\t\tOther         map[string]interface{} `yaml:\",inline\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tk.Brokers = internal.Brokers\n\tk.BrokerTLS = internal.BrokerTLS\n\tk.SASLMechanism = (*string)(internal.SASLMechanism)\n\tk.SCRAMUsername = (*string)(internal.SCRAMUsername)\n\tk.SCRAMPassword = (*string)(internal.SCRAMPassword)\n\tk.Other = internal.Other\n\treturn nil\n}\n\nfunc (s *SchemaRegistry) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tSchemaRegistryAPI               namedSocketAddresses `yaml:\"schema_registry_api\"`\n\t\tSchemaRegistryAPITLS            serverTLSArray       `yaml:\"schema_registry_api_tls\"`\n\t\tSchemaRegistryReplicationFactor *weakInt             `yaml:\"schema_registry_replication_factor\"`\n\t}\n\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\ts.SchemaRegistryAPI = internal.SchemaRegistryAPI\n\ts.SchemaRegistryAPITLS = internal.SchemaRegistryAPITLS\n\ts.SchemaRegistryReplicationFactor = (*int)(internal.SchemaRegistryReplicationFactor)\n\treturn nil\n}\n\nfunc (s *ServerTLS) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tName              weakString             `yaml:\"name\"`\n\t\tKeyFile           weakString             `yaml:\"key_file\"`\n\t\tCertFile          weakString             `yaml:\"cert_file\"`\n\t\tTruststoreFile    weakString             `yaml:\"truststore_file\"`\n\t\tEnabled           weakBool               `yaml:\"enabled\"`\n\t\tRequireClientAuth weakBool               `yaml:\"require_client_auth\"`\n\t\tOther             map[string]interface{} `yaml:\",inline\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\ts.Name = string(internal.Name)\n\ts.KeyFile = string(internal.KeyFile)\n\ts.CertFile = string(internal.CertFile)\n\ts.TruststoreFile = string(internal.TruststoreFile)\n\ts.Enabled = bool(internal.Enabled)\n\ts.RequireClientAuth = bool(internal.RequireClientAuth)\n\ts.Other = internal.Other\n\treturn nil\n}\n\nfunc (ss *SeedServer) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\t// New schema should only contain Address and Port, but we will\n\t\t// support this under Host also.\n\t\tAddress weakString    `yaml:\"address\"`\n\t\tPort    weakInt       `yaml:\"port\"`\n\t\tHost    SocketAddress `yaml:\"host\"`\n\t\t// deprecated\n\t\tNodeID *weakInt `yaml:\"node_id\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tif internal.NodeID != nil {\n\t\tfmt.Println(\"redpanda yaml: redpanda.seed_server.node_id is deprecated and unused\")\n\t}\n\n\tif internal.Address != \"\" || internal.Port != 0 {\n\t\tembedded := SocketAddress{string(internal.Address), int(internal.Port)}\n\t\tnested := internal.Host\n\n\t\tembeddedZero := reflect.DeepEqual(embedded, SocketAddress{})\n\t\tnestedZero := reflect.DeepEqual(nested, SocketAddress{})\n\n\t\tif !embeddedZero && !nestedZero && !reflect.DeepEqual(embedded, nested) {\n\t\t\treturn errors.New(\"redpanda.yaml redpanda.seed_server: nested host differs from address and port fields; only one must be set\")\n\t\t}\n\n\t\tss.Host = embedded\n\t\tif embeddedZero {\n\t\t\tss.Host = nested\n\t\t}\n\t\treturn nil\n\t}\n\n\tss.Host = internal.Host\n\treturn nil\n}\n\nfunc (sa *SocketAddress) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tAddress weakString `yaml:\"address\"`\n\t\tPort    weakInt    `yaml:\"port\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tsa.Address = string(internal.Address)\n\tsa.Port = int(internal.Port)\n\treturn nil\n}\n\nfunc (nsa *NamedSocketAddress) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tName    weakString `yaml:\"name\"`\n\t\tAddress weakString `yaml:\"address\"`\n\t\tPort    weakInt    `yaml:\"port\"`\n\t}\n\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\n\tnsa.Name = string(internal.Name)\n\tnsa.Address = string(internal.Address)\n\tnsa.Port = int(internal.Port)\n\treturn nil\n}\n\nfunc (nsa *NamedAuthNSocketAddress) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tName    weakString  `yaml:\"name\"`\n\t\tAddress weakString  `yaml:\"address\" mapstructure:\"address\"`\n\t\tPort    weakInt     `yaml:\"port\" mapstructure:\"port\"`\n\t\tAuthN   *weakString `yaml:\"authentication_method\" mapstructure:\"authentication_method\"`\n\t}\n\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\n\tnsa.Name = string(internal.Name)\n\tnsa.Address = string(internal.Address)\n\tnsa.Port = int(internal.Port)\n\tnsa.AuthN = (*string)(internal.AuthN)\n\treturn nil\n}\n\nfunc (t *TLS) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tKeyFile        weakString `yaml:\"key_file\"`\n\t\tCertFile       weakString `yaml:\"cert_file\"`\n\t\tTruststoreFile weakString `yaml:\"truststore_file\"`\n\t}\n\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tt.KeyFile = string(internal.KeyFile)\n\tt.CertFile = string(internal.CertFile)\n\tt.TruststoreFile = string(internal.TruststoreFile)\n\treturn nil\n}\n\nfunc (s *SASL) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tUser      weakString `yaml:\"user\"`\n\t\tPassword  weakString `yaml:\"password\"`\n\t\tMechanism weakString `yaml:\"type\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\ts.User = string(internal.User)\n\ts.Password = string(internal.Password)\n\ts.Mechanism = string(internal.Mechanism)\n\n\treturn nil\n}\n", "package config\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"gopkg.in/yaml.v3\"\n)\n\nfunc TestWeakBool(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    bool\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"boolean:true\",\n\t\t\tdata: \"wb: true\",\n\t\t\texp:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"boolean:false\",\n\t\t\tdata: \"wb: false\",\n\t\t\texp:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"int:0\",\n\t\t\tdata: \"wb: 0\",\n\t\t\texp:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"non-zero int\",\n\t\t\tdata: \"wb: 12\",\n\t\t\texp:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"string:true\",\n\t\t\tdata: `wb: \"true\"`,\n\t\t\texp:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"string:false\",\n\t\t\tdata: `wb: \"false\"`,\n\t\t\texp:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\tdata: `wb: \"\"`,\n\t\t\texp:  false,\n\t\t},\n\t\t{\n\t\t\tname:   \"error with unsupported string\",\n\t\t\tdata:   `wb: \"falsity\"`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"error with float type\",\n\t\t\tdata:   `wb: 123.123`,\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tWb weakBool `yaml:\"wb\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif bool(ts.Wb) != test.exp {\n\t\t\t\tt.Errorf(\"input %q: got %v, expected %v\",\n\t\t\t\t\ttest.data, ts.Wb, test.exp)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWeakInt(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    int\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"normal int types\",\n\t\t\tdata: \"wi: 1231\",\n\t\t\texp:  1231,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string as 0\",\n\t\t\tdata: `wi: \"\"`,\n\t\t\texp:  0,\n\t\t},\n\t\t{\n\t\t\tname: \"string:-23414\",\n\t\t\tdata: `wi: \"-23414\"`,\n\t\t\texp:  -23414,\n\t\t},\n\t\t{\n\t\t\tname: \"string:231231\",\n\t\t\tdata: `wi: \"231231\"`,\n\t\t\texp:  231231,\n\t\t},\n\t\t{\n\t\t\tname: \"bool:true\",\n\t\t\tdata: `wi: true`,\n\t\t\texp:  1,\n\t\t},\n\t\t{\n\t\t\tname: \"bool:false\",\n\t\t\tdata: `wi: false`,\n\t\t\texp:  0,\n\t\t},\n\t\t{\n\t\t\tname:   \"error with non-numeric strings\",\n\t\t\tdata:   `wi: \"123foo234\"`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"error with float numbers\",\n\t\t\tdata:   `wi: 123.234`,\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tWi weakInt `yaml:\"wi\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif int(ts.Wi) != test.exp {\n\t\t\t\tt.Errorf(\"input %q: got %v, expected %v\",\n\t\t\t\t\ttest.data, ts.Wi, test.exp)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWeakString(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    string\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"normal string\",\n\t\t\tdata: `ws: \"hello world\"`,\n\t\t\texp:  \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"bool:true\",\n\t\t\tdata: \"ws: true\",\n\t\t\texp:  \"1\",\n\t\t},\n\t\t{\n\t\t\tname: \"bool:false\",\n\t\t\tdata: \"ws: false\",\n\t\t\texp:  \"0\",\n\t\t},\n\t\t{\n\t\t\tname: \"base10 number\",\n\t\t\tdata: \"ws: 231231\",\n\t\t\texp:  \"231231\",\n\t\t},\n\t\t{\n\t\t\tname: \"float number\",\n\t\t\tdata: \"ws: 231.231\",\n\t\t\texp:  \"231.231\",\n\t\t},\n\t\t{\n\t\t\tname:   \"should error with unsupported types\",\n\t\t\tdata:   \"ws: \\n  - 231.231\",\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tWs weakString `yaml:\"ws\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif string(ts.Ws) != test.exp {\n\t\t\t\tt.Errorf(\"input %q: got %v, expected %v\",\n\t\t\t\t\ttest.data, ts.Ws, test.exp)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWeakStringArray(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []string\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single weak string\",\n\t\t\tdata: `test_array:\n  12`,\n\t\t\texp: []string{\"12\"},\n\t\t},\n\t\t{\n\t\t\tname: \"list of weak string\",\n\t\t\tdata: `test_array:\n  - 12\n  - 12.3\n  - \"hello\"\n  - true\n`,\n\t\t\texp: []string{\"12\", \"12.3\", \"hello\", \"1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"inline weak string\",\n\t\t\tdata: `test_array: 12`,\n\t\t\texp:  []string{\"12\"},\n\t\t},\n\t\t{\n\t\t\tname: \"array of weak strings\",\n\t\t\tdata: `test_array: [12, true]`,\n\t\t\texp:  []string{\"12\", \"1\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"array with unsupported weak string\",\n\t\t\tdata:   `test_array: [12, {true}]`,\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tWsArr weakStringArray `yaml:\"test_array\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.Equal(t, weakStringArray(test.exp), ts.WsArr)\n\t\t})\n\t}\n}\n\nfunc TestNamedSocketAddresses(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []SocketAddress\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single namedSocketAddress\",\n\t\t\tdata: \"test_api:\\n  address: 0.0.0.0\\n  port: 80\\n\",\n\t\t\texp:  []SocketAddress{{Address: \"0.0.0.0\", Port: 80}},\n\t\t},\n\t\t{\n\t\t\tname: \"list of 1 namedSocketAddress\",\n\t\t\tdata: \"test_api:\\n  - address: 0.0.0.0\\n    port: 80\\n\",\n\t\t\texp:  []SocketAddress{{Address: \"0.0.0.0\", Port: 80}},\n\t\t},\n\t\t{\n\t\t\tname: \"list of namedSocketAddress\",\n\t\t\tdata: `test_api:\n  - address: 0.0.0.0\n    port: 80\n  - address: 0.0.0.1\n    port: 81`,\n\t\t\texp: []SocketAddress{\n\t\t\t\t{\n\t\t\t\t\tAddress: \"0.0.0.0\", Port: 80,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tAddress: \"0.0.0.1\", Port: 81,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"unsupported types\",\n\t\t\tdata:   \"test_api:\\n  - address: 0.0.0.0\\n    port: [80]\\n\",\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tSockets socketAddresses `yaml:\"test_api\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, socketAddresses(test.exp), ts.Sockets)\n\t\t})\n\t}\n}\n\nfunc TestNamedSocketAddressArray(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []NamedSocketAddress\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single namedSocketAddress\",\n\t\t\tdata: \"test_api:\\n  address: 0.0.0.0\\n  port: 80\\n  name: socket\\n\",\n\t\t\texp: []NamedSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of 1 namedSocketAddress\",\n\t\t\tdata: \"test_api:\\n  - name: socket\\n    address: 0.0.0.0\\n    port: 80\\n\",\n\t\t\texp: []NamedSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of namedSocketAddress\",\n\t\t\tdata: `test_api:\n  - name: socket\n    address: 0.0.0.0\n    port: 80\n  - name: socket2\n    address: 0.0.0.1\n    port: 81`,\n\t\t\texp: []NamedSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket2\",\n\t\t\t\t\tAddress: \"0.0.0.1\",\n\t\t\t\t\tPort:    81,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"unsupported types\",\n\t\t\tdata:   \"test_api:\\n  address: [0.0.0.0]\\n  port: 80\\n  name: socket\\n\",\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tSockets namedSocketAddresses `yaml:\"test_api\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, namedSocketAddresses(test.exp), ts.Sockets)\n\t\t})\n\t}\n}\n\nfunc TestNamedAuthNSocketAddressArray(t *testing.T) {\n\tauthNMtlsIdentity := \"mtls_identity\"\n\tauthNSasl := \"sasl\"\n\tauthNNOne := \"none\"\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []NamedAuthNSocketAddress\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single namedAuthNSocketAddress\",\n\t\t\tdata: \"test_api:\\n  address: 0.0.0.0\\n  port: 80\\n  name: socket\\n  authentication_method: mtls_identity\\n\",\n\t\t\texp: []NamedAuthNSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t\tAuthN:   &authNMtlsIdentity,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of 1 namedSocketAddress\",\n\t\t\tdata: \"test_api:\\n  - name: socket\\n    address: 0.0.0.0\\n    port: 80\\n    authentication_method: sasl\\n\",\n\t\t\texp: []NamedAuthNSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t\tAuthN:   &authNSasl,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of namedSocketAddress\",\n\t\t\tdata: `test_api:\n  - name: socket\n    address: 0.0.0.0\n    port: 80\n    authentication_method: mtls_identity\n  - name: socket2\n    address: 0.0.0.1\n    port: 81\n    authentication_method: sasl\n  - name: socket3\n    address: 0.0.0.2\n    port: 81\n    authentication_method: none\n  - name: socket4\n    address: 0.0.0.3\n    port: 81`,\n\t\t\texp: []NamedAuthNSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t\tAuthN:   &authNMtlsIdentity,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket2\",\n\t\t\t\t\tAddress: \"0.0.0.1\",\n\t\t\t\t\tPort:    81,\n\t\t\t\t\tAuthN:   &authNSasl,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket3\",\n\t\t\t\t\tAddress: \"0.0.0.2\",\n\t\t\t\t\tPort:    81,\n\t\t\t\t\tAuthN:   &authNNOne,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket4\",\n\t\t\t\t\tAddress: \"0.0.0.3\",\n\t\t\t\t\tPort:    81,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"unsupported types\",\n\t\t\tdata:   \"test_api:\\n  address: [0.0.0.0]\\n  port: 80\\n  name: socket\\n\",\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tSockets namedAuthNSocketAddresses `yaml:\"test_api\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, namedAuthNSocketAddresses(test.exp), ts.Sockets)\n\t\t})\n\t}\n}\n\nfunc TestServerTLSArray(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []ServerTLS\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single serverTLS\",\n\t\t\tdata: `test_api:\n  name: server\n  key_file: \"/etc/certs/cert.key\"\n  truststore_file: \"/etc/certs/ca.crt\"\n  cert_file: \"/etc/certs/cert.crt\"\n  enabled: true\n  require_client_auth: true\n`,\n\t\t\texp: []ServerTLS{\n\t\t\t\t{\n\t\t\t\t\tName:              \"server\",\n\t\t\t\t\tKeyFile:           \"/etc/certs/cert.key\",\n\t\t\t\t\tTruststoreFile:    \"/etc/certs/ca.crt\",\n\t\t\t\t\tCertFile:          \"/etc/certs/cert.crt\",\n\t\t\t\t\tEnabled:           true,\n\t\t\t\t\tRequireClientAuth: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of 1 serverTLS\",\n\t\t\tdata: `test_api:\n  - name: server\n    key_file: \"/etc/certs/cert.key\"\n    truststore_file: \"/etc/certs/ca.crt\"\n    cert_file: \"/etc/certs/cert.crt\"\n    enabled: true\n    require_client_auth: true\n`,\n\t\t\texp: []ServerTLS{\n\t\t\t\t{\n\t\t\t\t\tName:              \"server\",\n\t\t\t\t\tKeyFile:           \"/etc/certs/cert.key\",\n\t\t\t\t\tTruststoreFile:    \"/etc/certs/ca.crt\",\n\t\t\t\t\tCertFile:          \"/etc/certs/cert.crt\",\n\t\t\t\t\tEnabled:           true,\n\t\t\t\t\tRequireClientAuth: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of serverTLS\",\n\t\t\tdata: `test_api:\n  - name: server\n    key_file: \"/etc/certs/cert.key\"\n    truststore_file: \"/etc/certs/ca.crt\"\n    cert_file: \"/etc/certs/cert.crt\"\n    enabled: true\n    require_client_auth: true\n  - name: server2\n    key_file: \"/etc/certs/cert2.key\"\n    truststore_file: \"/etc/certs/ca2.crt\"\n    cert_file: \"/etc/certs/cert2.crt\"\n    enabled: false\n    require_client_auth: true\n`,\n\t\t\texp: []ServerTLS{\n\t\t\t\t{\n\t\t\t\t\tName:              \"server\",\n\t\t\t\t\tKeyFile:           \"/etc/certs/cert.key\",\n\t\t\t\t\tTruststoreFile:    \"/etc/certs/ca.crt\",\n\t\t\t\t\tCertFile:          \"/etc/certs/cert.crt\",\n\t\t\t\t\tEnabled:           true,\n\t\t\t\t\tRequireClientAuth: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:              \"server2\",\n\t\t\t\t\tKeyFile:           \"/etc/certs/cert2.key\",\n\t\t\t\t\tTruststoreFile:    \"/etc/certs/ca2.crt\",\n\t\t\t\t\tCertFile:          \"/etc/certs/cert2.crt\",\n\t\t\t\t\tEnabled:           false,\n\t\t\t\t\tRequireClientAuth: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unsupported types\",\n\t\t\tdata: `test_api:\n  name: server\n  enabled: [true]\n`,\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tServers serverTLSArray `yaml:\"test_api\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, serverTLSArray(test.exp), ts.Servers)\n\t\t})\n\t}\n}\n\nfunc TestSeedServers(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []SeedServer\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single seed server\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n    port: 80\n`,\n\t\t\texp: []SeedServer{\n\t\t\t\t{SocketAddress{\"0.0.0.1\", 80}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of seed server\",\n\t\t\tdata: `test_server:\n  - host:\n      address: \"0.0.0.1\"\n      port: 80\n  - host:\n      address: \"0.0.0.2\"\n      port: 90\n`,\n\t\t\texp: []SeedServer{\n\t\t\t\t{SocketAddress{\"0.0.0.1\", 80}},\n\t\t\t\t{SocketAddress{\"0.0.0.2\", 90}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unsupported types\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n    port: [80]\n`,\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tSs seedServers `yaml:\"test_server\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, seedServers(test.exp), ts.Ss)\n\t\t})\n\t}\n}\n\nfunc TestSeedServer(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    SeedServer\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"with node_id\",\n\t\t\tdata: `test_server:\n  node_id: 1\n  host:\n    address: 192.168.10.1\n    port: 33145\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{\"192.168.10.1\", 33145},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"with host\",\n\t\t\tdata: `test_server:\n    host:\n        address: \"0.0.0.1\"\n        port: 80\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{\"0.0.0.1\", 80},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"address and port\",\n\t\t\tdata: `test_server:\n    address: \"1.0.0.1\"\n    port: 80\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{\"1.0.0.1\", 80},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"equal host and address & port\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n    port: 80\n  address: \"0.0.0.1\"\n  port: 80\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{\"0.0.0.1\", 80},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"host.address and port\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n  port: 80\n`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"address and host.port\",\n\t\t\tdata: `test_server:\n  host:\n    port: 80\n  address: \"0.0.0.1\"\n`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"address different from host.address\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n    port: 80\n  address: \"0.2.0.1\"\n  port: 80\n`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"port different from host.port\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n    port: 82\n  address: \"0.0.0.1\"\n  port: 80\n`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"equal host.address and address\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n  address: \"0.0.0.1\"\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{Address: \"0.0.0.1\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"equal host.port and port\",\n\t\t\tdata: `test_server:\n  host:\n    port: 82\n  port: 82\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{Port: 82},\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tSs SeedServer `yaml:\"test_server\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, test.exp, ts.Ss)\n\t\t})\n\t}\n}\n\nfunc TestConfig_UnmarshalYAML(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    *Config\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Config file with normal types\",\n\t\t\tdata: `organization: \"my_organization\"\ncluster_id: \"cluster_id\"\nnode_uuid: \"node_uuid\"\nredpanda:\n  data_directory: \"var/lib/redpanda/data\"\n  node_id: 1\n  enable_admin_api: true\n  admin_api_doc_dir: \"/usr/share/redpanda/admin-api-doc\"\n  admin:\n  - address: \"0.0.0.0\"\n    port: 9644\n    name: admin\n  admin_api_tls:\n  - enabled: false\n    cert_file: \"certs/tls-cert.pem\"\n  rpc_server:\n    address: \"0.0.0.0\"\n    port: 33145\n  rpc_server_tls:\n  - require_client_auth: false\n    truststore_file: \"certs/tls-ca.pem\"\n  advertised_rpc_api:\n    address: \"0.0.0.0\"\n    port: 33145\n  kafka_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: 9092\n  - address: \"0.0.0.0\"\n    name: external\n    port: 9093\n  kafka_api_tls:\n  - name: \"external\"\n    key_file: \"certs/tls-key.pem\"\n  - name: \"internal\"\n    enabled: false\n  advertised_kafka_api:\n  - address: 0.0.0.0\n    name: internal\n    port: 9092\n  - address: redpanda-0.my.domain.com.\n    name: external\n    port: 9093\n  seed_servers:\n  - address: 192.168.0.1\n    port: 33145\n  rack: \"rack-id\"\npandaproxy:\n  pandaproxy_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: 8082\n  - address: \"0.0.0.0\"\n    name: external\n    port: 8083\n  pandaproxy_api_tls:\n  - name: external\n    enabled: false\n    truststore_file: \"truststore_file\"\n  - name: internal\n    enabled: false\n  advertised_pandaproxy_api:\n  - address: 0.0.0.0\n    name: internal\n    port: 8082\n  - address: \"redpanda-rest-0.my.domain.com.\"\n    name: external\n    port: 8083\n  consumer_instance_timeout_ms: 60000\npandaproxy_client:\n  brokers:\n  - address: \"127.0.0.1\"\n    port: 9092\n  broker_tls:\n    require_client_auth: false\n    cert_file: \"certfile\"\n  retries: 5\n  retry_base_backoff_ms: 100\n  sasl_mechanism: \"mechanism\"\nschema_registry:\n  schema_registry_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: 8081\n  - address: \"0.0.0.0\"\n    name: external\n    port: 18081\n  schema_registry_replication_factor: 3\n  schema_registry_api_tls:\n  - name: external\n    enabled: false\n  - name: internal\n    enabled: false\nrpk:\n  tls:\n    key_file: ~/certs/key.pem\n  sasl:\n    user: user\n    password: pass\n  additional_start_flags:\n    - \"--overprovisioned\"\n  kafka_api:\n    brokers:\n    - 192.168.72.34:9092\n    - 192.168.72.35:9092\n    tls:\n      key_file: ~/certs/key.pem\n    sasl:\n      user: user\n      password: pass\n  admin_api:\n    addresses:\n    - 192.168.72.34:9644\n    - 192.168.72.35:9644\n    tls:\n      cert_file: ~/certs/admin-cert.pem\n      truststore_file: ~/certs/admin-ca.pem\n  tune_network: false\n  tune_disk_scheduler: false\n  tune_cpu: true\n  tune_aio_events: false\n  tune_clocksource: true\n`,\n\t\t\texp: &Config{\n\t\t\t\tOrganization: \"my_organization\",\n\t\t\t\tClusterID:    \"cluster_id\",\n\t\t\t\tNodeUUID:     \"node_uuid\",\n\t\t\t\tRedpanda: RedpandaNodeConfig{\n\t\t\t\t\tDirectory:      \"var/lib/redpanda/data\",\n\t\t\t\t\tID:             1,\n\t\t\t\t\tAdminAPIDocDir: \"/usr/share/redpanda/admin-api-doc\",\n\t\t\t\t\tRack:           \"rack-id\",\n\t\t\t\t\tAdminAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9644, \"admin\"},\n\t\t\t\t\t},\n\t\t\t\t\tAdminAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Enabled: false, CertFile: \"certs/tls-cert.pem\"},\n\t\t\t\t\t},\n\t\t\t\t\tRPCServer: SocketAddress{\"0.0.0.0\", 33145},\n\t\t\t\t\tRPCServerTLS: []ServerTLS{\n\t\t\t\t\t\t{RequireClientAuth: false, TruststoreFile: \"certs/tls-ca.pem\"},\n\t\t\t\t\t},\n\t\t\t\t\tAdvertisedRPCAPI: &SocketAddress{\"0.0.0.0\", 33145},\n\t\t\t\t\tKafkaAPI: []NamedAuthNSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9092, \"internal\", nil},\n\t\t\t\t\t\t{\"0.0.0.0\", 9093, \"external\", nil},\n\t\t\t\t\t},\n\t\t\t\t\tKafkaAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", KeyFile: \"certs/tls-key.pem\"},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tAdvertisedKafkaAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9092, \"internal\"},\n\t\t\t\t\t\t{\"redpanda-0.my.domain.com.\", 9093, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tSeedServers: []SeedServer{\n\t\t\t\t\t\t{SocketAddress{\"192.168.0.1\", 33145}},\n\t\t\t\t\t},\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"enable_admin_api\": true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPandaproxy: &Pandaproxy{\n\t\t\t\t\tPandaproxyAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8082, \"internal\"},\n\t\t\t\t\t\t{\"0.0.0.0\", 8083, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tPandaproxyAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", Enabled: false, TruststoreFile: \"truststore_file\"},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tAdvertisedPandaproxyAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8082, \"internal\"},\n\t\t\t\t\t\t{\"redpanda-rest-0.my.domain.com.\", 8083, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"consumer_instance_timeout_ms\": 60000,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPandaproxyClient: &KafkaClient{\n\t\t\t\t\tBrokers: []SocketAddress{\n\t\t\t\t\t\t{\"127.0.0.1\", 9092},\n\t\t\t\t\t},\n\t\t\t\t\tBrokerTLS: ServerTLS{\n\t\t\t\t\t\tRequireClientAuth: false, CertFile: \"certfile\",\n\t\t\t\t\t},\n\t\t\t\t\tSASLMechanism: func() *string { s := \"mechanism\"; return &s }(),\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"retries\":               5,\n\t\t\t\t\t\t\"retry_base_backoff_ms\": 100,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSchemaRegistry: &SchemaRegistry{\n\t\t\t\t\tSchemaRegistryAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8081, \"internal\"},\n\t\t\t\t\t\t{\"0.0.0.0\", 18081, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tSchemaRegistryAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", Enabled: false},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tSchemaRegistryReplicationFactor: func() *int { i := 3; return &i }(),\n\t\t\t\t},\n\t\t\t\tRpk: RpkConfig{\n\t\t\t\t\tTLS:                  &TLS{KeyFile: \"~/certs/key.pem\"},\n\t\t\t\t\tSASL:                 &SASL{User: \"user\", Password: \"pass\"},\n\t\t\t\t\tAdditionalStartFlags: []string{\"--overprovisioned\"},\n\t\t\t\t\tKafkaAPI: RpkKafkaAPI{\n\t\t\t\t\t\tBrokers: []string{\"192.168.72.34:9092\", \"192.168.72.35:9092\"},\n\t\t\t\t\t\tTLS:     &TLS{KeyFile: \"~/certs/key.pem\"},\n\t\t\t\t\t\tSASL:    &SASL{User: \"user\", Password: \"pass\"},\n\t\t\t\t\t},\n\t\t\t\t\tAdminAPI: RpkAdminAPI{\n\t\t\t\t\t\tAddresses: []string{\"192.168.72.34:9644\", \"192.168.72.35:9644\"},\n\t\t\t\t\t\tTLS:       &TLS{CertFile: \"~/certs/admin-cert.pem\", TruststoreFile: \"~/certs/admin-ca.pem\"},\n\t\t\t\t\t},\n\t\t\t\t\tTuneNetwork:       false,\n\t\t\t\t\tTuneDiskScheduler: false,\n\t\t\t\t\tTuneCPU:           true,\n\t\t\t\t\tTuneAioEvents:     false,\n\t\t\t\t\tTuneClocksource:   true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Config file with weak types\",\n\t\t\tdata: `organization: true\ncluster_id: \"cluster_id\"\nnode_uuid: 124.42\nredpanda:\n  data_directory: \"var/lib/redpanda/data\"\n  node_id: 1\n  enable_admin_api: true\n  admin_api_doc_dir: \"/usr/share/redpanda/admin-api-doc\"\n  admin:\n    address: \"0.0.0.0\"\n    port: 9644\n    name: admin\n  admin_api_tls:\n    enabled: false\n    cert_file: \"certs/tls-cert.pem\"\n  rpc_server:\n    address: \"0.0.0.0\"\n    port: 33145\n  rpc_server_tls:\n    require_client_auth: false\n    truststore_file: \"certs/tls-ca.pem\"\n  advertised_rpc_api:\n    address: \"0.0.0.0\"\n    port: 33145\n  kafka_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: \"9092\"\n  - address: \"0.0.0.0\"\n    name: external\n    port: \"9093\"\n  kafka_api_tls:\n  - name: \"external\"\n    key_file: \"certs/tls-key.pem\"\n  - name: \"internal\"\n    enabled: false\n  advertised_kafka_api:\n  - address: 0.0.0.0\n    name: internal\n    port: 9092\n  - address: redpanda-0.my.domain.com.\n    name: external\n    port: 9093\n  seed_servers:\n  - host:\n      address: 192.168.0.1\n      port: 33145\n  - node_id: \"0\"\n    host:\n      address: 192.168.0.1\n      port: 33145\n  - address: 192.168.0.1\n    port: 33145\n  rack: \"rack-id\"\npandaproxy:\n  pandaproxy_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: 8082\n  - address: \"0.0.0.0\"\n    name: external\n    port: 8083\n  pandaproxy_api_tls:\n  - name: external\n    enabled: 0\n    truststore_file: \"truststore_file\"\n  - name: internal\n    enabled: 0\n  advertised_pandaproxy_api:\n  - address: 0.0.0.0\n    name: internal\n    port: 8082\n  - address: \"redpanda-rest-0.my.domain.com.\"\n    name: external\n    port: 8083\n  consumer_instance_timeout_ms: 60000\npandaproxy_client:\n  brokers:\n  - address: \"127.0.0.1\"\n    port: 9092\n  broker_tls:\n    require_client_auth: false\n    cert_file: \"certfile\"\n  retries: 5\n  retry_base_backoff_ms: 100\n  sasl_mechanism: \"mechanism\"\nschema_registry:\n  schema_registry_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: 8081\n  - address: \"0.0.0.0\"\n    name: external\n    port: 18081\n  schema_registry_replication_factor: 3\n  schema_registry_api_tls:\n  - name: external\n    enabled: false\n  - name: internal\n    enabled: false\nrpk:\n  tls:\n    key_file: ~/certs/key.pem\n  sasl:\n    user: user\n    password: pass\n  additional_start_flags: \"--overprovisioned\"\n  kafka_api:\n    brokers:\n    - 192.168.72.34:9092\n    - 192.168.72.35:9092\n    tls:\n      key_file: ~/certs/key.pem\n    sasl:\n      user: user\n      password: pass\n  admin_api:\n    addresses:\n    - 192.168.72.34:9644\n    - 192.168.72.35:9644\n    tls:\n      cert_file: ~/certs/admin-cert.pem\n      truststore_file: ~/certs/admin-ca.pem\n  tune_network: false\n  tune_disk_scheduler: false\n  tune_cpu: 1\n  tune_aio_events: false\n  tune_clocksource: 1\n`,\n\t\t\texp: &Config{\n\t\t\t\tOrganization: \"1\",\n\t\t\t\tClusterID:    \"cluster_id\",\n\t\t\t\tNodeUUID:     \"124.42\",\n\t\t\t\tRedpanda: RedpandaNodeConfig{\n\t\t\t\t\tDirectory:      \"var/lib/redpanda/data\",\n\t\t\t\t\tID:             1,\n\t\t\t\t\tAdminAPIDocDir: \"/usr/share/redpanda/admin-api-doc\",\n\t\t\t\t\tRack:           \"rack-id\",\n\t\t\t\t\tAdminAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9644, \"admin\"},\n\t\t\t\t\t},\n\t\t\t\t\tAdminAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Enabled: false, CertFile: \"certs/tls-cert.pem\"},\n\t\t\t\t\t},\n\t\t\t\t\tRPCServer: SocketAddress{\"0.0.0.0\", 33145},\n\t\t\t\t\tRPCServerTLS: []ServerTLS{\n\t\t\t\t\t\t{RequireClientAuth: false, TruststoreFile: \"certs/tls-ca.pem\"},\n\t\t\t\t\t},\n\t\t\t\t\tAdvertisedRPCAPI: &SocketAddress{\"0.0.0.0\", 33145},\n\t\t\t\t\tKafkaAPI: []NamedAuthNSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9092, \"internal\", nil},\n\t\t\t\t\t\t{\"0.0.0.0\", 9093, \"external\", nil},\n\t\t\t\t\t},\n\t\t\t\t\tKafkaAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", KeyFile: \"certs/tls-key.pem\"},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tAdvertisedKafkaAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9092, \"internal\"},\n\t\t\t\t\t\t{\"redpanda-0.my.domain.com.\", 9093, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tSeedServers: []SeedServer{\n\t\t\t\t\t\t{SocketAddress{\"192.168.0.1\", 33145}},\n\t\t\t\t\t\t{SocketAddress{\"192.168.0.1\", 33145}},\n\t\t\t\t\t\t{SocketAddress{\"192.168.0.1\", 33145}},\n\t\t\t\t\t},\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"enable_admin_api\": true,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPandaproxy: &Pandaproxy{\n\t\t\t\t\tPandaproxyAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8082, \"internal\"},\n\t\t\t\t\t\t{\"0.0.0.0\", 8083, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tPandaproxyAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", Enabled: false, TruststoreFile: \"truststore_file\"},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tAdvertisedPandaproxyAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8082, \"internal\"},\n\t\t\t\t\t\t{\"redpanda-rest-0.my.domain.com.\", 8083, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"consumer_instance_timeout_ms\": 60000,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPandaproxyClient: &KafkaClient{\n\t\t\t\t\tBrokers: []SocketAddress{\n\t\t\t\t\t\t{\"127.0.0.1\", 9092},\n\t\t\t\t\t},\n\t\t\t\t\tBrokerTLS: ServerTLS{\n\t\t\t\t\t\tRequireClientAuth: false, CertFile: \"certfile\",\n\t\t\t\t\t},\n\t\t\t\t\tSASLMechanism: func() *string { s := \"mechanism\"; return &s }(),\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"retries\":               5,\n\t\t\t\t\t\t\"retry_base_backoff_ms\": 100,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSchemaRegistry: &SchemaRegistry{\n\t\t\t\t\tSchemaRegistryAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8081, \"internal\"},\n\t\t\t\t\t\t{\"0.0.0.0\", 18081, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tSchemaRegistryAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", Enabled: false},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tSchemaRegistryReplicationFactor: func() *int { i := 3; return &i }(),\n\t\t\t\t},\n\t\t\t\tRpk: RpkConfig{\n\t\t\t\t\tTLS:                  &TLS{KeyFile: \"~/certs/key.pem\"},\n\t\t\t\t\tSASL:                 &SASL{User: \"user\", Password: \"pass\"},\n\t\t\t\t\tAdditionalStartFlags: []string{\"--overprovisioned\"},\n\t\t\t\t\tKafkaAPI: RpkKafkaAPI{\n\t\t\t\t\t\tBrokers: []string{\"192.168.72.34:9092\", \"192.168.72.35:9092\"},\n\t\t\t\t\t\tTLS:     &TLS{KeyFile: \"~/certs/key.pem\"},\n\t\t\t\t\t\tSASL:    &SASL{User: \"user\", Password: \"pass\"},\n\t\t\t\t\t},\n\t\t\t\t\tAdminAPI: RpkAdminAPI{\n\t\t\t\t\t\tAddresses: []string{\"192.168.72.34:9644\", \"192.168.72.35:9644\"},\n\t\t\t\t\t\tTLS:       &TLS{CertFile: \"~/certs/admin-cert.pem\", TruststoreFile: \"~/certs/admin-ca.pem\"},\n\t\t\t\t\t},\n\t\t\t\t\tTuneNetwork:       false,\n\t\t\t\t\tTuneDiskScheduler: false,\n\t\t\t\t\tTuneCPU:           true,\n\t\t\t\t\tTuneAioEvents:     false,\n\t\t\t\t\tTuneClocksource:   true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tConfig *Config `yaml:\",inline\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, test.exp, ts.Config)\n\t\t})\n\t}\n}\n"], "fixing_code": ["// Copyright 2022 Redpanda Data, Inc.\n//\n// Use of this software is governed by the Business Source License\n// included in the file licenses/BSL.md\n//\n// As of the Change Date specified in that file, in accordance with\n// the Business Source License, use of this software will be governed\n// by the Apache License, Version 2.0\n\n//go:build linux\n\npackage debug\n\nimport (\n\t\"archive/zip\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/avast/retry-go\"\n\t\"github.com/beevik/ntp\"\n\t\"github.com/docker/go-units\"\n\t\"github.com/hashicorp/go-multierror\"\n\t\"github.com/redpanda-data/redpanda/src/go/rpk/pkg/api/admin\"\n\t\"github.com/redpanda-data/redpanda/src/go/rpk/pkg/config\"\n\tosutil \"github.com/redpanda-data/redpanda/src/go/rpk/pkg/os\"\n\t\"github.com/redpanda-data/redpanda/src/go/rpk/pkg/system\"\n\t\"github.com/redpanda-data/redpanda/src/go/rpk/pkg/system/syslog\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/spf13/afero\"\n\t\"github.com/twmb/franz-go/pkg/kadm\"\n\t\"github.com/twmb/franz-go/pkg/kgo\"\n\t\"gopkg.in/yaml.v3\"\n)\n\nfunc executeBundle(\n\tctx context.Context,\n\tfs afero.Fs,\n\tconf *config.Config,\n\tcl *kgo.Client,\n\tadmin *admin.AdminAPI,\n\tlogsSince, logsUntil string,\n\tlogsLimitBytes int,\n\ttimeout time.Duration,\n) error {\n\tmode := os.FileMode(0o755)\n\ttimestamp := time.Now().Unix()\n\tfilename := fmt.Sprintf(\"%d-bundle.zip\", timestamp)\n\tf, err := fs.OpenFile(\n\t\tfilename,\n\t\tos.O_CREATE|os.O_WRONLY,\n\t\tmode,\n\t)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"couldn't create bundle file: %w\", err)\n\t}\n\tdefer f.Close()\n\n\tgrp := multierror.Group{}\n\n\tw := zip.NewWriter(f)\n\tdefer w.Close()\n\n\tps := &stepParams{\n\t\tfs:      fs,\n\t\tw:       w,\n\t\ttimeout: timeout,\n\t}\n\n\tsteps := []step{\n\t\tsaveKafkaMetadata(ctx, ps, cl),\n\t\tsaveDataDirStructure(ps, conf),\n\t\tsaveConfig(ps, conf),\n\t\tsaveCPUInfo(ps),\n\t\tsaveInterrupts(ps),\n\t\tsaveResourceUsageData(ps, conf),\n\t\tsaveNTPDrift(ps),\n\t\tsaveSyslog(ps),\n\t\tsavePrometheusMetrics(ctx, ps, admin),\n\t\tsaveDNSData(ctx, ps),\n\t\tsaveDiskUsage(ctx, ps, conf),\n\t\tsaveLogs(ctx, ps, logsSince, logsUntil, logsLimitBytes),\n\t\tsaveSocketData(ctx, ps),\n\t\tsaveTopOutput(ctx, ps),\n\t\tsaveVmstat(ctx, ps),\n\t\tsaveIP(ctx, ps),\n\t\tsaveLspci(ctx, ps),\n\t\tsaveDmidecode(ctx, ps),\n\t}\n\n\tfor _, s := range steps {\n\t\tgrp.Go(s)\n\t}\n\n\terrs := grp.Wait()\n\tif errs != nil {\n\t\terr := writeFileToZip(ps, \"errors.txt\", []byte(errs.Error()))\n\t\tif err != nil {\n\t\t\terrs = multierror.Append(errs, err)\n\t\t}\n\t\tlog.Info(errs.Error())\n\t}\n\n\tlog.Infof(\"Debug bundle saved to '%s'\", filename)\n\treturn nil\n}\n\ntype step func() error\n\ntype stepParams struct {\n\tfs      afero.Fs\n\tm       sync.Mutex\n\tw       *zip.Writer\n\ttimeout time.Duration\n}\n\ntype fileInfo struct {\n\tSize     string `json:\"size\"`\n\tMode     string `json:\"mode\"`\n\tSymlink  string `json:\"symlink,omitempty\"`\n\tError    string `json:\"error,omitempty\"`\n\tModified string `json:\"modified\"`\n\tUser     string `json:\"user\"`\n\tGroup    string `json:\"group\"`\n}\n\ntype limitedWriter struct {\n\tw          io.Writer\n\tlimitBytes int\n\taccumBytes int\n}\n\nfunc (l *limitedWriter) Write(p []byte) (int, error) {\n\tlimitReached := false\n\tif l.accumBytes+len(p) > l.limitBytes {\n\t\tp = p[:l.limitBytes-l.accumBytes]\n\t\tlimitReached = true\n\t}\n\n\tn, err := l.w.Write(p)\n\tif err != nil {\n\t\treturn n, err\n\t}\n\n\tl.accumBytes += n\n\n\tif limitReached {\n\t\treturn n, errors.New(\"output size limit reached\")\n\t}\n\treturn n, nil\n}\n\n// Creates a file in the zip writer with name 'filename' and writes 'contents' to it.\nfunc writeFileToZip(ps *stepParams, filename string, contents []byte) error {\n\tps.m.Lock()\n\tdefer ps.m.Unlock()\n\n\twr, err := ps.w.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = wr.Write(contents)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"couldn't save '%s': %w\", filename, err)\n\t}\n\treturn nil\n}\n\n// Runs a command and pipes its output to a new file in the zip writer.\nfunc writeCommandOutputToZipLimit(\n\trootCtx context.Context,\n\tps *stepParams,\n\tfilename string,\n\toutputLimitBytes int,\n\tcommand string,\n\targs ...string,\n) error {\n\tps.m.Lock()\n\tdefer ps.m.Unlock()\n\n\tctx, cancel := context.WithTimeout(rootCtx, ps.timeout)\n\tdefer cancel()\n\tcmd := exec.CommandContext(ctx, command, args...)\n\n\t// Strip any non-default library path\n\tcmd.Env = osutil.SystemLdPathEnv()\n\n\twr, err := ps.w.Create(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif outputLimitBytes > 0 {\n\t\twr = &limitedWriter{\n\t\t\tw:          wr,\n\t\t\tlimitBytes: outputLimitBytes,\n\t\t}\n\t}\n\n\tcmd.Stdout = wr\n\tcmd.Stderr = wr\n\n\terr = cmd.Start()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = cmd.Wait()\n\tif err != nil {\n\t\tif !strings.Contains(err.Error(), \"broken pipe\") {\n\t\t\treturn fmt.Errorf(\"couldn't save '%s': %w\", filename, err)\n\t\t}\n\t\tlog.Debugf(\n\t\t\t\"Got '%v' while running '%s'. This is probably due to the\"+\n\t\t\t\t\" command's output exceeding its limit in bytes.\",\n\t\t\terr,\n\t\t\tcmd,\n\t\t)\n\t}\n\treturn nil\n}\n\n// Runs a command and pipes its output to a new file in the zip writer.\nfunc writeCommandOutputToZip(\n\tctx context.Context, ps *stepParams, filename, command string, args ...string,\n) error {\n\treturn writeCommandOutputToZipLimit(ctx, ps, filename, -1, command, args...)\n}\n\n// Parses an error return from kadm, and if the return is a shard errors,\n// returns a list of each individual error.\nfunc stringifyKadmErr(err error) []string {\n\tvar ae *kadm.AuthError\n\tvar se *kadm.ShardErrors\n\tswitch {\n\tcase err == nil:\n\t\treturn nil\n\n\tcase errors.As(err, &se):\n\t\tvar errs []string\n\t\tfor _, err := range se.Errs {\n\t\t\terrs = append(errs, fmt.Sprintf(\"%s to %s (%d) failed: %s\",\n\t\t\t\tse.Name,\n\t\t\t\tnet.JoinHostPort(err.Broker.Host, strconv.Itoa(int(err.Broker.Port))),\n\t\t\t\terr.Broker.NodeID,\n\t\t\t\terr.Err,\n\t\t\t))\n\t\t}\n\t\treturn errs\n\n\tcase errors.As(err, &ae):\n\t\treturn []string{fmt.Sprintf(\"authorization error: %s\", err)}\n\n\tdefault:\n\t\treturn []string{err.Error()}\n\t}\n}\n\nfunc saveKafkaMetadata(rootCtx context.Context, ps *stepParams, cl *kgo.Client) step {\n\treturn func() error {\n\t\tlog.Debug(\"Reading Kafka information\")\n\n\t\tctx, cancel := context.WithTimeout(rootCtx, 10*time.Second)\n\t\tdefer cancel()\n\n\t\ttype resp struct {\n\t\t\tName     string      // the request the response is for\n\t\t\tResponse interface{} // a raw response from kadm\n\t\t\tError    []string    // no error, or one error, or potentially many shard errors\n\t\t}\n\t\tvar resps []resp\n\n\t\tadm := kadm.NewClient(cl)\n\n\t\tmeta, err := adm.Metadata(ctx)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"metadata\",\n\t\t\tResponse: meta,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\ttcs, err := adm.DescribeTopicConfigs(ctx, meta.Topics.Names()...)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"topic_configs\",\n\t\t\tResponse: tcs,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\tbcs, err := adm.DescribeBrokerConfigs(ctx, meta.Brokers.NodeIDs()...)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"broker_configs\",\n\t\t\tResponse: bcs,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\tostart, err := adm.ListStartOffsets(ctx)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"log_start_offsets\",\n\t\t\tResponse: ostart,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\tocommitted, err := adm.ListCommittedOffsets(ctx)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"last_stable_offsets\",\n\t\t\tResponse: ocommitted,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\toend, err := adm.ListEndOffsets(ctx)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"high_watermarks\",\n\t\t\tResponse: oend,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\tgroups, err := adm.DescribeGroups(ctx)\n\t\tresps = append(resps, resp{\n\t\t\tName:     \"groups\",\n\t\t\tResponse: groups,\n\t\t\tError:    stringifyKadmErr(err),\n\t\t})\n\n\t\tfetched := adm.FetchManyOffsets(ctx, groups.Names()...)\n\t\tfor _, fetch := range fetched {\n\t\t\tresps = append(resps, resp{\n\t\t\t\tName:     fmt.Sprintf(\"group_commits_%s\", fetch.Group),\n\t\t\t\tResponse: fetch.Fetched,\n\t\t\t\tError:    stringifyKadmErr(fetch.Err),\n\t\t\t})\n\t\t}\n\n\t\tmarshal, err := json.Marshal(resps)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to encode kafka admin responses: %v\", err)\n\t\t}\n\n\t\treturn writeFileToZip(ps, \"kafka.json\", marshal)\n\t}\n}\n\n// Walks the redpanda data directory recursively, and saves to the bundle\n// a JSON map where the keys are the file/ dir paths, and the values are\n// objects containing their data: size, mode, the file or dir it points to\n// if the current file is a symlink, the time it was modified, its owner and\n// its group, as well as an error message if reading that specific file failed.\nfunc saveDataDirStructure(ps *stepParams, conf *config.Config) step {\n\treturn func() error {\n\t\tfiles := make(map[string]*fileInfo)\n\t\terr := walkDir(conf.Redpanda.Directory, files)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't walk '%s': %w\", conf.Redpanda.Directory, err)\n\t\t}\n\t\tbs, err := json.Marshal(files)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\n\t\t\t\t\"couldn't encode the '%s' directory structure as JSON: %w\",\n\t\t\t\tconf.Redpanda.Directory,\n\t\t\t\terr,\n\t\t\t)\n\t\t}\n\t\treturn writeFileToZip(ps, \"data-dir.txt\", bs)\n\t}\n}\n\n// Writes the config file to the bundle, redacting SASL credentials.\nfunc saveConfig(ps *stepParams, conf *config.Config) step {\n\treturn func() error {\n\t\t// Redact SASL credentials\n\t\tredacted := \"(REDACTED)\"\n\t\tif conf.Rpk.KafkaAPI.SASL != nil {\n\t\t\tconf.Rpk.KafkaAPI.SASL.User = redacted\n\t\t\tconf.Rpk.KafkaAPI.SASL.Password = redacted\n\t\t}\n\t\tif conf.Rpk.SASL != nil {\n\t\t\tconf.Rpk.SASL.User = redacted\n\t\t\tconf.Rpk.SASL.Password = redacted\n\t\t}\n\t\t// We want to redact any blindly decoded parameters.\n\t\tredactOtherMap(conf.Other)\n\t\tredactOtherMap(conf.Redpanda.Other)\n\t\tredactServerTLSSlice(conf.Redpanda.KafkaAPITLS)\n\t\tredactServerTLSSlice(conf.Redpanda.AdminAPITLS)\n\t\tif conf.SchemaRegistry != nil {\n\t\t\tfor _, server := range conf.SchemaRegistry.SchemaRegistryAPITLS {\n\t\t\t\tredactOtherMap(server.Other)\n\t\t\t}\n\t\t}\n\t\tif conf.Pandaproxy != nil {\n\t\t\tredactOtherMap(conf.Pandaproxy.Other)\n\t\t\tredactServerTLSSlice(conf.Pandaproxy.PandaproxyAPITLS)\n\t\t}\n\t\tif conf.PandaproxyClient != nil {\n\t\t\tredactOtherMap(conf.PandaproxyClient.Other)\n\t\t}\n\t\tif conf.SchemaRegistryClient != nil {\n\t\t\tredactOtherMap(conf.SchemaRegistryClient.Other)\n\t\t}\n\n\t\tbs, err := yaml.Marshal(conf)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't encode the redpanda config as YAML: %w\", err)\n\t\t}\n\t\treturn writeFileToZip(ps, \"redpanda.yaml\", bs)\n\t}\n}\n\nfunc redactServerTLSSlice(servers []config.ServerTLS) {\n\tfor _, server := range servers {\n\t\tredactOtherMap(server.Other)\n\t}\n}\n\nfunc redactOtherMap(other map[string]interface{}) {\n\tfor k := range other {\n\t\tother[k] = \"(REDACTED)\"\n\t}\n}\n\n// Saves the contents of '/proc/cpuinfo'.\nfunc saveCPUInfo(ps *stepParams) step {\n\treturn func() error {\n\t\tbs, err := afero.ReadFile(ps.fs, \"/proc/cpuinfo\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn writeFileToZip(ps, \"proc/cpuinfo\", bs)\n\t}\n}\n\n// Saves the contents of '/proc/interrupts'.\nfunc saveInterrupts(ps *stepParams) step {\n\treturn func() error {\n\t\tbs, err := afero.ReadFile(ps.fs, \"/proc/interrupts\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn writeFileToZip(ps, \"proc/interrupts\", bs)\n\t}\n}\n\n// Writes a file containing memory, disk & CPU usage metrics for a local\n// redpanda process.\nfunc saveResourceUsageData(ps *stepParams, conf *config.Config) step {\n\treturn func() error {\n\t\tres, err := system.GatherMetrics(ps.fs, ps.timeout, *conf)\n\t\tif system.IsErrRedpandaDown(err) {\n\t\t\treturn fmt.Errorf(\"omitting resource usage metrics: %w\", err)\n\t\t}\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error gathering resource usage metrics: %w\", err)\n\t\t}\n\t\tbs, err := json.Marshal(res)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't encode resource usage metrics: %w\", err)\n\t\t}\n\t\treturn writeFileToZip(ps, \"resource-usage.json\", bs)\n\t}\n}\n\n// Queries 'pool.ntp.org' and writes a file with the reported RTT, time & precision.\nfunc saveNTPDrift(ps *stepParams) step {\n\treturn func() error {\n\t\tconst (\n\t\t\thost    = \"pool.ntp.org\"\n\t\t\tretries = 3\n\t\t)\n\n\t\tvar (\n\t\t\tresponse  *ntp.Response\n\t\t\tlocalTime time.Time\n\t\t\terr       error\n\t\t)\n\n\t\tqueryNTP := func() error {\n\t\t\tlocalTime = time.Now()\n\t\t\tresponse, err = ntp.Query(host)\n\t\t\treturn err\n\t\t}\n\n\t\terr = retry.Do(\n\t\t\tqueryNTP,\n\t\t\tretry.Attempts(retries),\n\t\t\tretry.DelayType(retry.FixedDelay),\n\t\t\tretry.Delay(1*time.Second),\n\t\t\tretry.LastErrorOnly(true),\n\t\t\tretry.OnRetry(func(n uint, err error) {\n\t\t\t\tlog.Debugf(\"Couldn't retrieve NTP data from %s: %v\", host, err)\n\t\t\t\tlog.Debugf(\"Retrying (%d retries left)\", retries-n)\n\t\t\t}),\n\t\t)\n\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error querying '%s': %w\", host, err)\n\t\t}\n\n\t\tresult := struct {\n\t\t\tHost            string        `json:\"host\"`\n\t\t\tRoundTripTimeMs int64         `json:\"roundTripTimeMs\"`\n\t\t\tRemoteTimeUTC   time.Time     `json:\"remoteTimeUTC\"`\n\t\t\tLocalTimeUTC    time.Time     `json:\"localTimeUTC\"`\n\t\t\tPrecisionMs     int64         `json:\"precisionMs\"`\n\t\t\tOffset          time.Duration `json:\"offset\"`\n\t\t}{\n\t\t\tHost:            host,\n\t\t\tRoundTripTimeMs: response.RTT.Milliseconds(),\n\t\t\tRemoteTimeUTC:   response.Time.UTC(),\n\t\t\tLocalTimeUTC:    localTime.UTC(),\n\t\t\tPrecisionMs:     response.Precision.Milliseconds(),\n\t\t\tOffset:          response.ClockOffset,\n\t\t}\n\n\t\tmarshalled, err := json.Marshal(result)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"couldn't marshal the NTP response: %w\", err)\n\t\t}\n\n\t\treturn writeFileToZip(\n\t\t\tps,\n\t\t\t\"ntp.txt\",\n\t\t\tmarshalled,\n\t\t)\n\t}\n}\n\nfunc saveSyslog(ps *stepParams) step {\n\treturn func() error {\n\t\tentries, err := syslog.ReadAll()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn writeFileToZip(ps, \"syslog.txt\", entries)\n\t}\n}\n\n// Queries the given admin API address for prometheus metrics.\nfunc savePrometheusMetrics(ctx context.Context, ps *stepParams, admin *admin.AdminAPI) step {\n\treturn func() error {\n\t\traw, err := admin.PrometheusMetrics(ctx)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"unable to fetch metrics from the admin API: %w\", err)\n\t\t}\n\t\treturn writeFileToZip(ps, \"prometheus-metrics.txt\", raw)\n\t}\n}\n\n// Saves the output of `dig`.\nfunc saveDNSData(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(ctx, ps, \"dig.txt\", \"dig\")\n\t}\n}\n\n// Saves the disk usage total within redpanda's data directory.\nfunc saveDiskUsage(ctx context.Context, ps *stepParams, conf *config.Config) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"du.txt\",\n\t\t\t\"du\", \"-h\", conf.Redpanda.Directory,\n\t\t)\n\t}\n}\n\n// TODO: What if running inside a container/ k8s?\n// Writes the journald redpanda logs, if available, to the bundle.\nfunc saveLogs(ctx context.Context, ps *stepParams, since, until string, logsLimitBytes int) step {\n\treturn func() error {\n\t\targs := []string{\"--no-pager\", \"-u\", \"redpanda\"}\n\t\tif since != \"\" {\n\t\t\targs = append(args, \"--since\", since)\n\t\t}\n\t\tif until != \"\" {\n\t\t\targs = append(args, \"--until\", until)\n\t\t}\n\t\treturn writeCommandOutputToZipLimit(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"redpanda.log\",\n\t\t\tlogsLimitBytes,\n\t\t\t\"journalctl\",\n\t\t\targs...,\n\t\t)\n\t}\n}\n\n// Saves the output of `ss`.\nfunc saveSocketData(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(ctx, ps, \"ss.txt\", \"ss\")\n\t}\n}\n\n// Saves the output of `top`.\nfunc saveTopOutput(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"top.txt\",\n\t\t\t\"top\", \"-b\", \"-n\", \"10\", \"-H\", \"-d\", \"1\",\n\t\t)\n\t}\n}\n\n// Saves the output of `vmstat`.\nfunc saveVmstat(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"vmstat.txt\",\n\t\t\t\"vmstat\", \"-w\", \"1\", \"10\",\n\t\t)\n\t}\n}\n\n// Saves the output of `ip addr`.\nfunc saveIP(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"ip.txt\",\n\t\t\t\"ip\", \"addr\",\n\t\t)\n\t}\n}\n\n// Saves the output of `lspci`.\nfunc saveLspci(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"lspci.txt\",\n\t\t\t\"lspci\",\n\t\t)\n\t}\n}\n\n// Saves the output of `dmidecode`.\nfunc saveDmidecode(ctx context.Context, ps *stepParams) step {\n\treturn func() error {\n\t\treturn writeCommandOutputToZip(\n\t\t\tctx,\n\t\t\tps,\n\t\t\t\"dmidecode.txt\",\n\t\t\t\"dmidecode\",\n\t\t)\n\t}\n}\n\nfunc walkDir(root string, files map[string]*fileInfo) error {\n\treturn filepath.WalkDir(\n\t\troot,\n\t\tfunc(path string, d fs.DirEntry, readErr error) error {\n\t\t\t// Prevent infinite loops.\n\t\t\tif _, exists := files[path]; exists {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\ti := new(fileInfo)\n\t\t\tfiles[path] = i\n\n\t\t\t// If the directory's contents couldn't be read, skip it.\n\t\t\tif readErr != nil {\n\t\t\t\ti.Error = readErr.Error()\n\t\t\t\treturn fs.SkipDir\n\t\t\t}\n\n\t\t\tinfo, err := d.Info()\n\t\t\tif err != nil {\n\t\t\t\ti.Error = err.Error()\n\t\t\t\t// If reading a directory failed, then skip it altogether.\n\t\t\t\tif d.IsDir() {\n\t\t\t\t\treturn fs.SkipDir\n\t\t\t\t}\n\t\t\t\t// If it's just a file, just return and move to the\n\t\t\t\t// next entry.\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\ti.Size = units.HumanSize(float64(info.Size()))\n\t\t\ti.Mode = info.Mode().String()\n\t\t\ti.Modified = info.ModTime().String()\n\n\t\t\t// The user and group are only available through the\n\t\t\t// underlying syscall object.\n\t\t\tsys, ok := info.Sys().(*syscall.Stat_t)\n\t\t\tif ok {\n\t\t\t\tu, err := user.LookupId(fmt.Sprint(sys.Uid))\n\t\t\t\tif err == nil {\n\t\t\t\t\ti.User = u.Name\n\t\t\t\t} else {\n\t\t\t\t\ti.User = fmt.Sprintf(\"user lookup failed for UID %d: %v\", sys.Uid, err)\n\t\t\t\t}\n\t\t\t\tg, err := user.LookupGroupId(fmt.Sprint(sys.Gid))\n\t\t\t\tif err == nil {\n\t\t\t\t\ti.Group = g.Name\n\t\t\t\t} else {\n\t\t\t\t\ti.Group = fmt.Sprintf(\"group lookup failed for GID %d: %v\", sys.Gid, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If it's a symlink, save the dir or file it points to.\n\t\t\t// If the file it points to is a directory, follow it and then\n\t\t\t// call `walk` using it as the root.\n\t\t\tisSymlink := info.Mode().Type()&fs.ModeSymlink != 0\n\t\t\tif !isSymlink {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\tdest, err := os.Readlink(path)\n\t\t\tif err != nil {\n\t\t\t\ti.Symlink = \"unresolvable\"\n\t\t\t\ti.Error = err.Error()\n\t\t\t}\n\t\t\ti.Symlink = dest\n\n\t\t\tfInfo, err := os.Stat(dest)\n\t\t\tif err != nil {\n\t\t\t\tfiles[dest] = &fileInfo{Error: err.Error()}\n\t\t\t} else if fInfo.IsDir() {\n\t\t\t\treturn walkDir(dest, files)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t)\n}\n", "// Copyright 2020 Redpanda Data, Inc.\n//\n// Use of this software is governed by the Business Source License\n// included in the file licenses/BSL.md\n//\n// As of the Change Date specified in that file, in accordance with\n// the Business Source License, use of this software will be governed\n// by the Apache License, Version 2.0\n\npackage config\n\nimport (\n\t\"crypto/tls\"\n\t\"path\"\n\n\t\"github.com/spf13/afero\"\n\t\"github.com/twmb/tlscfg\"\n)\n\ntype Config struct {\n\tfile         *Config\n\tfileLocation string\n\n\tNodeUUID             string             `yaml:\"node_uuid,omitempty\" json:\"node_uuid\"`\n\tOrganization         string             `yaml:\"organization,omitempty\" json:\"organization\"`\n\tLicenseKey           string             `yaml:\"license_key,omitempty\" json:\"license_key\"`\n\tClusterID            string             `yaml:\"cluster_id,omitempty\" json:\"cluster_id\"`\n\tRedpanda             RedpandaNodeConfig `yaml:\"redpanda,omitempty\" json:\"redpanda\"`\n\tRpk                  RpkConfig          `yaml:\"rpk,omitempty\" json:\"rpk\"`\n\tPandaproxy           *Pandaproxy        `yaml:\"pandaproxy,omitempty\" json:\"pandaproxy,omitempty\"`\n\tPandaproxyClient     *KafkaClient       `yaml:\"pandaproxy_client,omitempty\" json:\"pandaproxy_client,omitempty\"`\n\tSchemaRegistry       *SchemaRegistry    `yaml:\"schema_registry,omitempty\" json:\"schema_registry,omitempty\"`\n\tSchemaRegistryClient *KafkaClient       `yaml:\"schema_registry_client,omitempty\" json:\"schema_registry_client,omitempty\"`\n\n\tOther map[string]interface{} `yaml:\",inline\"`\n}\n\n// File returns the configuration as read from a file, with no defaults\n// pre-deserializing and no overrides applied after. If the return is nil,\n// no file was read.\nfunc (c *Config) File() *Config {\n\treturn c.file\n}\n\n// FileLocation returns the loaded file location; this is the path that\n// rpk uses for write operations.\nfunc (c *Config) FileLocation() string {\n\treturn c.fileLocation\n}\n\n// RedpandaNodeConfig is the source of truth for Redpanda node configuration.\n//\n// Cluster properties must NOT be enlisted in this struct. Adding a cluster\n// property here would cause the dependent libraries (e.g. operator) to wrongly\n// consider it a node property.\ntype RedpandaNodeConfig struct {\n\tDirectory                  string                    `yaml:\"data_directory,omitempty\" json:\"data_directory\"`\n\tID                         int                       `yaml:\"node_id\" json:\"node_id\"`\n\tRack                       string                    `yaml:\"rack,omitempty\" json:\"rack\"`\n\tSeedServers                []SeedServer              `yaml:\"seed_servers\" json:\"seed_servers\"`\n\tRPCServer                  SocketAddress             `yaml:\"rpc_server,omitempty\" json:\"rpc_server\"`\n\tKafkaAPI                   []NamedAuthNSocketAddress `yaml:\"kafka_api,omitempty\" json:\"kafka_api\"`\n\tKafkaAPITLS                []ServerTLS               `yaml:\"kafka_api_tls,omitempty\" json:\"kafka_api_tls\"`\n\tAdminAPI                   []NamedSocketAddress      `yaml:\"admin,omitempty\" json:\"admin\"`\n\tAdminAPITLS                []ServerTLS               `yaml:\"admin_api_tls,omitempty\" json:\"admin_api_tls\"`\n\tCoprocSupervisorServer     SocketAddress             `yaml:\"coproc_supervisor_server,omitempty\" json:\"coproc_supervisor_server\"`\n\tAdminAPIDocDir             string                    `yaml:\"admin_api_doc_dir,omitempty\" json:\"admin_api_doc_dir\"`\n\tDashboardDir               string                    `yaml:\"dashboard_dir,omitempty\" json:\"dashboard_dir\"`\n\tCloudStorageCacheDirectory string                    `yaml:\"cloud_storage_cache_directory,omitempty\" json:\"cloud_storage_cache_directory\"`\n\tAdvertisedRPCAPI           *SocketAddress            `yaml:\"advertised_rpc_api,omitempty\" json:\"advertised_rpc_api,omitempty\"`\n\tAdvertisedKafkaAPI         []NamedSocketAddress      `yaml:\"advertised_kafka_api,omitempty\" json:\"advertised_kafka_api,omitempty\"`\n\tDeveloperMode              bool                      `yaml:\"developer_mode,omitempty\" json:\"developer_mode\"`\n\tOther                      map[string]interface{}    `yaml:\",inline\"`\n}\n\ntype Pandaproxy struct {\n\tPandaproxyAPI           []NamedSocketAddress   `yaml:\"pandaproxy_api,omitempty\" json:\"pandaproxy_api,omitempty\"`\n\tPandaproxyAPITLS        []ServerTLS            `yaml:\"pandaproxy_api_tls,omitempty\" json:\"pandaproxy_api_tls,omitempty\"`\n\tAdvertisedPandaproxyAPI []NamedSocketAddress   `yaml:\"advertised_pandaproxy_api,omitempty\" json:\"advertised_pandaproxy_api,omitempty\"`\n\tOther                   map[string]interface{} `yaml:\",inline\"`\n}\n\ntype SchemaRegistry struct {\n\tSchemaRegistryAPI               []NamedSocketAddress `yaml:\"schema_registry_api,omitempty\" json:\"schema_registry_api,omitempty\"`\n\tSchemaRegistryAPITLS            []ServerTLS          `yaml:\"schema_registry_api_tls,omitempty\" json:\"schema_registry_api_tls,omitempty\"`\n\tSchemaRegistryReplicationFactor *int                 `yaml:\"schema_registry_replication_factor,omitempty\" json:\"schema_registry_replication_factor,omitempty\"`\n}\n\ntype KafkaClient struct {\n\tBrokers       []SocketAddress        `yaml:\"brokers,omitempty\" json:\"brokers,omitempty\"`\n\tBrokerTLS     ServerTLS              `yaml:\"broker_tls,omitempty\" json:\"broker_tls,omitempty\"`\n\tSASLMechanism *string                `yaml:\"sasl_mechanism,omitempty\" json:\"sasl_mechanism,omitempty\"`\n\tSCRAMUsername *string                `yaml:\"scram_username,omitempty\" json:\"scram_username,omitempty\"`\n\tSCRAMPassword *string                `yaml:\"scram_password,omitempty\" json:\"scram_password,omitempty\"`\n\tOther         map[string]interface{} `yaml:\",inline\"`\n}\n\ntype SeedServer struct {\n\tHost SocketAddress `yaml:\"host,omitempty\" json:\"host\"`\n}\n\ntype SocketAddress struct {\n\tAddress string `yaml:\"address\" json:\"address\"`\n\tPort    int    `yaml:\"port,omitempty\" json:\"port\"`\n}\n\ntype NamedSocketAddress struct {\n\tAddress string `yaml:\"address\" json:\"address\"`\n\tPort    int    `yaml:\"port,omitempty\" json:\"port\"`\n\tName    string `yaml:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\ntype NamedAuthNSocketAddress struct {\n\tAddress string  `yaml:\"address,omitempty\" json:\"address\"`\n\tPort    int     `yaml:\"port,omitempty\" json:\"port\"`\n\tName    string  `yaml:\"name,omitempty\" json:\"name,omitempty\"`\n\tAuthN   *string `yaml:\"authentication_method,omitempty\" json:\"authentication_method,omitempty\"`\n}\n\ntype TLS struct {\n\tKeyFile        string `yaml:\"key_file,omitempty\" json:\"key_file\"`\n\tCertFile       string `yaml:\"cert_file,omitempty\" json:\"cert_file\"`\n\tTruststoreFile string `yaml:\"truststore_file,omitempty\" json:\"truststore_file\"`\n}\n\nfunc (t *TLS) Config(fs afero.Fs) (*tls.Config, error) {\n\tif t == nil {\n\t\treturn nil, nil\n\t}\n\treturn tlscfg.New(\n\t\ttlscfg.WithFS(\n\t\t\ttlscfg.FuncFS(func(path string) ([]byte, error) {\n\t\t\t\treturn afero.ReadFile(fs, path)\n\t\t\t}),\n\t\t),\n\t\ttlscfg.MaybeWithDiskCA(\n\t\t\tt.TruststoreFile,\n\t\t\ttlscfg.ForClient,\n\t\t),\n\t\ttlscfg.MaybeWithDiskKeyPair(\n\t\t\tt.CertFile,\n\t\t\tt.KeyFile,\n\t\t),\n\t)\n}\n\ntype ServerTLS struct {\n\tName              string                 `yaml:\"name,omitempty\" json:\"name\"`\n\tKeyFile           string                 `yaml:\"key_file,omitempty\" json:\"key_file\"`\n\tCertFile          string                 `yaml:\"cert_file,omitempty\" json:\"cert_file\"`\n\tTruststoreFile    string                 `yaml:\"truststore_file,omitempty\" json:\"truststore_file\"`\n\tEnabled           bool                   `yaml:\"enabled,omitempty\" json:\"enabled\"`\n\tRequireClientAuth bool                   `yaml:\"require_client_auth,omitempty\" json:\"require_client_auth\"`\n\tOther             map[string]interface{} `yaml:\",inline\" `\n}\n\ntype RpkConfig struct {\n\t// Deprecated 2021-07-1\n\tTLS *TLS `yaml:\"tls,omitempty\" json:\"tls\"`\n\t// Deprecated 2021-07-1\n\tSASL *SASL `yaml:\"sasl,omitempty\" json:\"sasl,omitempty\"`\n\n\tKafkaAPI                 RpkKafkaAPI `yaml:\"kafka_api,omitempty\" json:\"kafka_api\"`\n\tAdminAPI                 RpkAdminAPI `yaml:\"admin_api,omitempty\" json:\"admin_api\"`\n\tAdditionalStartFlags     []string    `yaml:\"additional_start_flags,omitempty\"  json:\"additional_start_flags\"`\n\tEnableUsageStats         bool        `yaml:\"enable_usage_stats,omitempty\" json:\"enable_usage_stats\"`\n\tTuneNetwork              bool        `yaml:\"tune_network,omitempty\" json:\"tune_network\"`\n\tTuneDiskScheduler        bool        `yaml:\"tune_disk_scheduler,omitempty\" json:\"tune_disk_scheduler\"`\n\tTuneNomerges             bool        `yaml:\"tune_disk_nomerges,omitempty\" json:\"tune_disk_nomerges\"`\n\tTuneDiskWriteCache       bool        `yaml:\"tune_disk_write_cache,omitempty\" json:\"tune_disk_write_cache\"`\n\tTuneDiskIrq              bool        `yaml:\"tune_disk_irq,omitempty\" json:\"tune_disk_irq\"`\n\tTuneFstrim               bool        `yaml:\"tune_fstrim,omitempty\" json:\"tune_fstrim\"`\n\tTuneCPU                  bool        `yaml:\"tune_cpu,omitempty\" json:\"tune_cpu\"`\n\tTuneAioEvents            bool        `yaml:\"tune_aio_events,omitempty\" json:\"tune_aio_events\"`\n\tTuneClocksource          bool        `yaml:\"tune_clocksource,omitempty\" json:\"tune_clocksource\"`\n\tTuneSwappiness           bool        `yaml:\"tune_swappiness,omitempty\" json:\"tune_swappiness\"`\n\tTuneTransparentHugePages bool        `yaml:\"tune_transparent_hugepages,omitempty\" json:\"tune_transparent_hugepages\"`\n\tEnableMemoryLocking      bool        `yaml:\"enable_memory_locking,omitempty\" json:\"enable_memory_locking\"`\n\tTuneCoredump             bool        `yaml:\"tune_coredump,omitempty\" json:\"tune_coredump\"`\n\tCoredumpDir              string      `yaml:\"coredump_dir,omitempty\" json:\"coredump_dir\"`\n\tTuneBallastFile          bool        `yaml:\"tune_ballast_file,omitempty\" json:\"tune_ballast_file\"`\n\tBallastFilePath          string      `yaml:\"ballast_file_path,omitempty\" json:\"ballast_file_path\"`\n\tBallastFileSize          string      `yaml:\"ballast_file_size,omitempty\" json:\"ballast_file_size\"`\n\tWellKnownIo              string      `yaml:\"well_known_io,omitempty\" json:\"well_known_io\"`\n\tOverprovisioned          bool        `yaml:\"overprovisioned,omitempty\" json:\"overprovisioned\"`\n\tSMP                      *int        `yaml:\"smp,omitempty\" json:\"smp,omitempty\"`\n}\n\ntype RpkKafkaAPI struct {\n\tBrokers []string `yaml:\"brokers,omitempty\" json:\"brokers\"`\n\tTLS     *TLS     `yaml:\"tls,omitempty\" json:\"tls\"`\n\tSASL    *SASL    `yaml:\"sasl,omitempty\" json:\"sasl,omitempty\"`\n}\n\ntype RpkAdminAPI struct {\n\tAddresses []string `yaml:\"addresses,omitempty\" json:\"addresses\"`\n\tTLS       *TLS     `yaml:\"tls,omitempty\" json:\"tls\"`\n}\n\ntype SASL struct {\n\tUser      string `yaml:\"user,omitempty\" json:\"user,omitempty\"`\n\tPassword  string `yaml:\"password,omitempty\" json:\"password,omitempty\"`\n\tMechanism string `yaml:\"type,omitempty\" json:\"type,omitempty\"`\n}\n\nfunc (c *Config) PIDFile() string {\n\treturn path.Join(c.Redpanda.Directory, \"pid.lock\")\n}\n", "// Copyright 2020 Redpanda Data, Inc.\n//\n// Use of this software is governed by the Business Source License\n// included in the file licenses/BSL.md\n//\n// As of the Change Date specified in that file, in accordance with\n// the Business Source License, use of this software will be governed\n// by the Apache License, Version 2.0\n\npackage config\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"sync\"\n\n\t\"gopkg.in/yaml.v3\"\n)\n\n// This file contains weak params type, including basic types support (bool,\n// int, and string) and one_or_many support for different types.\n//\n// The use of this file is to support our transition to a strongly typed\n// config file and our migration away from viper and mapstructure.\n// TODO: Print deprecation warning when using weak types https://github.com/redpanda-data/redpanda/issues/5262\n\n// weakBool is an intermediary boolean type to be used during our transition\n// to strictly typed configuration parameters. This will allow us to support\n// weakly typed parsing:\n//\n//   - int to bool (true if value != 0)\n//   - string to bool (accepts: 1, t, T, TRUE, true, True, 0, f, F, FALSE,\n//     false, False. Anything else is an error)\ntype weakBool bool\n\nfunc (wb *weakBool) UnmarshalYAML(n *yaml.Node) error {\n\tswitch n.Tag {\n\tcase \"!!bool\":\n\t\tb, err := strconv.ParseBool(n.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*wb = weakBool(b)\n\t\treturn nil\n\tcase \"!!int\":\n\t\tni, err := strconv.Atoi(n.Value)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as bool: %s\", n.Value, err)\n\t\t}\n\t\t*wb = ni != 0\n\t\treturn nil\n\tcase \"!!str\":\n\t\t// it accepts 1, t, T, TRUE, true, True, 0, f, F\n\t\tnb, err := strconv.ParseBool(n.Value)\n\t\tif err == nil {\n\t\t\t*wb = weakBool(nb)\n\t\t\treturn nil\n\t\t} else if n.Value == \"\" {\n\t\t\t*wb = false\n\t\t\treturn nil\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as bool: %s\", n.Value, err)\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"type %s not supported as a boolean\", n.Tag)\n\t}\n}\n\n// weakInt is an intermediary integer type to be used during our transition to\n// strictly typed configuration parameters. This will allow us to support\n// weakly typed parsing:\n//\n//   - strings to int/uint (base implied by prefix)\n//   - bools to int/uint (true = 1, false = 0)\ntype weakInt int\n\nfunc (wi *weakInt) UnmarshalYAML(n *yaml.Node) error {\n\tswitch n.Tag {\n\tcase \"!!int\":\n\t\tni, err := strconv.Atoi(n.Value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*wi = weakInt(ni)\n\t\treturn nil\n\tcase \"!!str\":\n\t\tstr := n.Value\n\t\tif str == \"\" {\n\t\t\tstr = \"0\"\n\t\t}\n\t\tni, err := strconv.Atoi(str)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as an integer: %s\", str, err)\n\t\t}\n\t\t*wi = weakInt(ni)\n\t\treturn nil\n\tcase \"!!bool\":\n\t\tnb, err := strconv.ParseBool(n.Value)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as an integer: %s\", n.Value, err)\n\t\t}\n\t\tif nb {\n\t\t\t*wi = 1\n\t\t\treturn nil\n\t\t}\n\t\t*wi = 0\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"type %s not supported as an integer\", n.Tag)\n\t}\n}\n\n// weakString is an intermediary string type to be used during our transition to\n// strictly typed configuration parameters. This will allow us to support\n// weakly typed parsing:\n//\n//   - bools to string (true = \"1\", false = \"0\")\n//   - numbers to string (base 10)\ntype weakString string\n\nfunc (ws *weakString) UnmarshalYAML(n *yaml.Node) error {\n\tswitch n.Tag {\n\tcase \"!!str\":\n\t\t*ws = weakString(n.Value)\n\t\treturn nil\n\tcase \"!!bool\":\n\t\tnb, err := strconv.ParseBool(n.Value)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"cannot parse '%s' as a boolean: %s\", n.Value, err)\n\t\t}\n\t\tif nb {\n\t\t\t*ws = \"1\"\n\t\t\treturn nil\n\t\t}\n\t\t*ws = \"0\"\n\t\treturn nil\n\tcase \"!!int\", \"!!float\":\n\t\t*ws = weakString(n.Value)\n\t\treturn nil\n\tdefault:\n\t\treturn fmt.Errorf(\"type %s not supported as a string\", n.Tag)\n\t}\n}\n\n// weakStringArray is an intermediary one_or_many type to be used\n// during our transition to strictly typed configuration parameters.\n// This type will:\n//   - parse an array of strings\n//   - parse a single string to an array.\ntype weakStringArray []string\n\nfunc (wsa *weakStringArray) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []weakString\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\ts := make([]string, len(multi))\n\t\tfor i, v := range multi {\n\t\t\ts[i] = string(v)\n\t\t}\n\t\t*wsa = s\n\t\treturn nil\n\t}\n\n\tvar single weakString\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*wsa = []string{string(single)}\n\treturn nil\n}\n\n// socketAddresses is an intermediary one_or_many type to be used\n// during our transition to strictly typed configuration parameters.\n// This type will:\n//   - parse an array of SocketAddress\n//   - parse a single SocketAddress to an array.\ntype socketAddresses []SocketAddress\n\nfunc (s *socketAddresses) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []SocketAddress\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\t*s = multi\n\t\treturn nil\n\t}\n\n\tvar single SocketAddress\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*s = []SocketAddress{single}\n\treturn nil\n}\n\n// namedSocketAddresses is an intermediary one_or_many type to be used\n// during our transition to strictly typed configuration parameters.\n// This type will:\n//   - parse an array of NamedSocketAddress\n//   - parse a single NamedSocketAddress to an array.\ntype namedSocketAddresses []NamedSocketAddress\n\nfunc (nsa *namedSocketAddresses) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []NamedSocketAddress\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\t*nsa = multi\n\t\treturn nil\n\t}\n\n\tvar single NamedSocketAddress\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*nsa = []NamedSocketAddress{single}\n\treturn nil\n}\n\n// namedAuthNSocketAddresses is an intermediary one_or_many type to be used\n// during our transition to strictly typed configuration parameters.\n// This type will:\n//   - parse an array of NamedAuthNSocketAddress\n//   - parse a single NamedAuthNSocketAddress to an array.\ntype namedAuthNSocketAddresses []NamedAuthNSocketAddress\n\nfunc (nsa *namedAuthNSocketAddresses) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []NamedAuthNSocketAddress\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\t*nsa = multi\n\t\treturn nil\n\t}\n\n\tvar single NamedAuthNSocketAddress\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*nsa = []NamedAuthNSocketAddress{single}\n\treturn nil\n}\n\n// serverTLSArray is an intermediary one_or_many type to be used during our\n// transition to strictly typed configuration parameters. This type will:\n//   - parse an array of ServerTLS\n//   - parse a single ServerTLS to an array.\ntype serverTLSArray []ServerTLS\n\nfunc (s *serverTLSArray) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []ServerTLS\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\t*s = multi\n\t\treturn nil\n\t}\n\n\tvar single ServerTLS\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t// do not log serverTLS because the Other field may contain a secret\n\t*s = []ServerTLS{single}\n\treturn nil\n}\n\n// seedServers is an intermediary one_or_many type to be used during our\n// transition to strictly typed configuration parameters. This type will:\n//   - parse an array of SeedServer\n//   - parse a single SeedServer to an array.\ntype seedServers []SeedServer\n\nfunc (ss *seedServers) UnmarshalYAML(n *yaml.Node) error {\n\tvar multi []SeedServer\n\terr := n.Decode(&multi)\n\tif err == nil {\n\t\t*ss = multi\n\t\treturn nil\n\t}\n\n\tvar single SeedServer\n\terr = n.Decode(&single)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*ss = []SeedServer{single}\n\treturn nil\n}\n\n// Custom unmarshallers for all the config related types.\n\nfunc (c *Config) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tNodeUUID             weakString         `yaml:\"node_uuid\"`\n\t\tOrganization         weakString         `yaml:\"organization\"`\n\t\tLicenseKey           weakString         `yaml:\"license_key\"`\n\t\tClusterID            weakString         `yaml:\"cluster_id\"`\n\t\tRedpanda             RedpandaNodeConfig `yaml:\"redpanda\"`\n\t\tRpk                  RpkConfig          `yaml:\"rpk\"`\n\t\tPandaproxy           *Pandaproxy        `yaml:\"pandaproxy\"`\n\t\tPandaproxyClient     *KafkaClient       `yaml:\"pandaproxy_client\"`\n\t\tSchemaRegistry       *SchemaRegistry    `yaml:\"schema_registry\"`\n\t\tSchemaRegistryClient *KafkaClient       `yaml:\"schema_registry_client\"`\n\n\t\tOther map[string]interface{} `yaml:\",inline\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tc.NodeUUID = string(internal.NodeUUID)\n\tc.Organization = string(internal.Organization)\n\tc.LicenseKey = string(internal.LicenseKey)\n\tc.ClusterID = string(internal.ClusterID)\n\tc.Redpanda = internal.Redpanda\n\tc.Rpk = internal.Rpk\n\tc.Pandaproxy = internal.Pandaproxy\n\tc.PandaproxyClient = internal.PandaproxyClient\n\tc.SchemaRegistry = internal.SchemaRegistry\n\tc.SchemaRegistryClient = internal.SchemaRegistryClient\n\tc.Other = internal.Other\n\n\treturn nil\n}\n\n// once is used to ensure that we only print the rpc_server_tls bug warning once.\nvar once sync.Once\n\nfunc (rpc *RedpandaNodeConfig) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tDirectory                  weakString                `yaml:\"data_directory\"`\n\t\tID                         weakInt                   `yaml:\"node_id\" `\n\t\tRack                       weakString                `yaml:\"rack\"`\n\t\tSeedServers                seedServers               `yaml:\"seed_servers\"`\n\t\tRPCServer                  SocketAddress             `yaml:\"rpc_server\"`\n\t\tKafkaAPI                   namedAuthNSocketAddresses `yaml:\"kafka_api\"`\n\t\tKafkaAPITLS                serverTLSArray            `yaml:\"kafka_api_tls\"`\n\t\tAdminAPI                   namedSocketAddresses      `yaml:\"admin\"`\n\t\tAdminAPITLS                serverTLSArray            `yaml:\"admin_api_tls\"`\n\t\tCoprocSupervisorServer     SocketAddress             `yaml:\"coproc_supervisor_server\"`\n\t\tAdminAPIDocDir             weakString                `yaml:\"admin_api_doc_dir\"`\n\t\tDashboardDir               weakString                `yaml:\"dashboard_dir\"`\n\t\tCloudStorageCacheDirectory weakString                `yaml:\"cloud_storage_cache_directory\"`\n\t\tAdvertisedRPCAPI           *SocketAddress            `yaml:\"advertised_rpc_api\"`\n\t\tAdvertisedKafkaAPI         namedSocketAddresses      `yaml:\"advertised_kafka_api\"`\n\t\tDeveloperMode              weakBool                  `yaml:\"developer_mode\"`\n\t\tOther                      map[string]interface{}    `yaml:\",inline\"`\n\t}\n\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\n\t// redpanda won't recognize rpc_server_tls if is a list.\n\tv := reflect.ValueOf(internal.Other[\"rpc_server_tls\"])\n\tif v.Kind() == reflect.Slice {\n\t\tonce.Do(func() {\n\t\t\tfmt.Fprintf(os.Stderr, \"WARNING: Due to an old rpk bug, your redpanda.yaml's redpanda.rpc_server_tls property is an array, and redpanda reads the field as a struct. rpk cannot automatically fix this: brokers would not be able to rejoin the cluster during a rolling upgrade. To enable TLS on broker RPC ports, you must turn off your cluster, switch the redpanda.rpc_server_tls field to a struct, and then turn your cluster back on. To switch from a list to a struct, replace the single dash under redpanda.rpc_server_tls with a space. This message will continue to appear while redpanda.rpc_server_tls exists and is an array\\n\")\n\t\t})\n\t}\n\n\trpc.Directory = string(internal.Directory)\n\trpc.ID = int(internal.ID)\n\trpc.Rack = string(internal.Rack)\n\trpc.SeedServers = internal.SeedServers\n\trpc.RPCServer = internal.RPCServer\n\trpc.KafkaAPI = internal.KafkaAPI\n\trpc.KafkaAPITLS = internal.KafkaAPITLS\n\trpc.AdminAPI = internal.AdminAPI\n\trpc.AdminAPITLS = internal.AdminAPITLS\n\trpc.CoprocSupervisorServer = internal.CoprocSupervisorServer\n\trpc.AdminAPIDocDir = string(internal.AdminAPIDocDir)\n\trpc.DashboardDir = string(internal.DashboardDir)\n\trpc.CloudStorageCacheDirectory = string(internal.CloudStorageCacheDirectory)\n\trpc.AdvertisedRPCAPI = internal.AdvertisedRPCAPI\n\trpc.AdvertisedKafkaAPI = internal.AdvertisedKafkaAPI\n\trpc.DeveloperMode = bool(internal.DeveloperMode)\n\trpc.Other = internal.Other\n\treturn nil\n}\n\nfunc (rpkc *RpkConfig) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\t// Deprecated 2021-07-1\n\t\tTLS *TLS `yaml:\"tls\"`\n\t\t// Deprecated 2021-07-1\n\t\tSASL *SASL `yaml:\"sasl\"`\n\n\t\tKafkaAPI                 RpkKafkaAPI     `yaml:\"kafka_api\"`\n\t\tAdminAPI                 RpkAdminAPI     `yaml:\"admin_api\"`\n\t\tAdditionalStartFlags     weakStringArray `yaml:\"additional_start_flags\"`\n\t\tEnableUsageStats         weakBool        `yaml:\"enable_usage_stats\"`\n\t\tTuneNetwork              weakBool        `yaml:\"tune_network\"`\n\t\tTuneDiskScheduler        weakBool        `yaml:\"tune_disk_scheduler\"`\n\t\tTuneNomerges             weakBool        `yaml:\"tune_disk_nomerges\"`\n\t\tTuneDiskWriteCache       weakBool        `yaml:\"tune_disk_write_cache\"`\n\t\tTuneDiskIrq              weakBool        `yaml:\"tune_disk_irq\"`\n\t\tTuneFstrim               weakBool        `yaml:\"tune_fstrim\"`\n\t\tTuneCPU                  weakBool        `yaml:\"tune_cpu\"`\n\t\tTuneAioEvents            weakBool        `yaml:\"tune_aio_events\"`\n\t\tTuneClocksource          weakBool        `yaml:\"tune_clocksource\"`\n\t\tTuneSwappiness           weakBool        `yaml:\"tune_swappiness\"`\n\t\tTuneTransparentHugePages weakBool        `yaml:\"tune_transparent_hugepages\"`\n\t\tEnableMemoryLocking      weakBool        `yaml:\"enable_memory_locking\"`\n\t\tTuneCoredump             weakBool        `yaml:\"tune_coredump\"`\n\t\tCoredumpDir              weakString      `yaml:\"coredump_dir\"`\n\t\tTuneBallastFile          weakBool        `yaml:\"tune_ballast_file\"`\n\t\tBallastFilePath          weakString      `yaml:\"ballast_file_path\"`\n\t\tBallastFileSize          weakString      `yaml:\"ballast_file_size\"`\n\t\tWellKnownIo              weakString      `yaml:\"well_known_io\"`\n\t\tOverprovisioned          weakBool        `yaml:\"overprovisioned\"`\n\t\tSMP                      *weakInt        `yaml:\"smp\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\n\trpkc.TLS = internal.TLS\n\trpkc.SASL = internal.SASL\n\trpkc.KafkaAPI = internal.KafkaAPI\n\trpkc.AdminAPI = internal.AdminAPI\n\trpkc.AdditionalStartFlags = internal.AdditionalStartFlags\n\trpkc.EnableUsageStats = bool(internal.EnableUsageStats)\n\trpkc.TuneNetwork = bool(internal.TuneNetwork)\n\trpkc.TuneDiskScheduler = bool(internal.TuneDiskScheduler)\n\trpkc.TuneNomerges = bool(internal.TuneNomerges)\n\trpkc.TuneDiskWriteCache = bool(internal.TuneDiskWriteCache)\n\trpkc.TuneDiskIrq = bool(internal.TuneDiskIrq)\n\trpkc.TuneFstrim = bool(internal.TuneFstrim)\n\trpkc.TuneCPU = bool(internal.TuneCPU)\n\trpkc.TuneAioEvents = bool(internal.TuneAioEvents)\n\trpkc.TuneClocksource = bool(internal.TuneClocksource)\n\trpkc.TuneSwappiness = bool(internal.TuneSwappiness)\n\trpkc.TuneTransparentHugePages = bool(internal.TuneTransparentHugePages)\n\trpkc.EnableMemoryLocking = bool(internal.EnableMemoryLocking)\n\trpkc.TuneCoredump = bool(internal.TuneCoredump)\n\trpkc.CoredumpDir = string(internal.CoredumpDir)\n\trpkc.TuneBallastFile = bool(internal.TuneBallastFile)\n\trpkc.BallastFilePath = string(internal.BallastFilePath)\n\trpkc.BallastFileSize = string(internal.BallastFileSize)\n\trpkc.WellKnownIo = string(internal.WellKnownIo)\n\trpkc.Overprovisioned = bool(internal.Overprovisioned)\n\trpkc.SMP = (*int)(internal.SMP)\n\treturn nil\n}\n\nfunc (r *RpkKafkaAPI) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tBrokers weakStringArray `yaml:\"brokers\"`\n\t\tTLS     *TLS            `yaml:\"tls\"`\n\t\tSASL    *SASL           `yaml:\"sasl\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tr.Brokers = internal.Brokers\n\tr.TLS = internal.TLS\n\tr.SASL = internal.SASL\n\treturn nil\n}\n\nfunc (r *RpkAdminAPI) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tAddresses weakStringArray `yaml:\"addresses\"`\n\t\tTLS       *TLS            `yaml:\"tls\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tr.Addresses = internal.Addresses\n\tr.TLS = internal.TLS\n\treturn nil\n}\n\nfunc (p *Pandaproxy) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tPandaproxyAPI           namedSocketAddresses   `yaml:\"pandaproxy_api\"`\n\t\tPandaproxyAPITLS        serverTLSArray         `yaml:\"pandaproxy_api_tls\"`\n\t\tAdvertisedPandaproxyAPI namedSocketAddresses   `yaml:\"advertised_pandaproxy_api\"`\n\t\tOther                   map[string]interface{} `yaml:\",inline\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tp.PandaproxyAPI = internal.PandaproxyAPI\n\tp.PandaproxyAPITLS = internal.PandaproxyAPITLS\n\tp.AdvertisedPandaproxyAPI = internal.AdvertisedPandaproxyAPI\n\tp.Other = internal.Other\n\treturn nil\n}\n\nfunc (k *KafkaClient) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tBrokers       socketAddresses        `yaml:\"brokers\"`\n\t\tBrokerTLS     ServerTLS              `yaml:\"broker_tls\"`\n\t\tSASLMechanism *weakString            `yaml:\"sasl_mechanism\"`\n\t\tSCRAMUsername *weakString            `yaml:\"scram_username\"`\n\t\tSCRAMPassword *weakString            `yaml:\"scram_password\"`\n\t\tOther         map[string]interface{} `yaml:\",inline\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tk.Brokers = internal.Brokers\n\tk.BrokerTLS = internal.BrokerTLS\n\tk.SASLMechanism = (*string)(internal.SASLMechanism)\n\tk.SCRAMUsername = (*string)(internal.SCRAMUsername)\n\tk.SCRAMPassword = (*string)(internal.SCRAMPassword)\n\tk.Other = internal.Other\n\treturn nil\n}\n\nfunc (s *SchemaRegistry) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tSchemaRegistryAPI               namedSocketAddresses `yaml:\"schema_registry_api\"`\n\t\tSchemaRegistryAPITLS            serverTLSArray       `yaml:\"schema_registry_api_tls\"`\n\t\tSchemaRegistryReplicationFactor *weakInt             `yaml:\"schema_registry_replication_factor\"`\n\t}\n\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\ts.SchemaRegistryAPI = internal.SchemaRegistryAPI\n\ts.SchemaRegistryAPITLS = internal.SchemaRegistryAPITLS\n\ts.SchemaRegistryReplicationFactor = (*int)(internal.SchemaRegistryReplicationFactor)\n\treturn nil\n}\n\nfunc (s *ServerTLS) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tName              weakString             `yaml:\"name\"`\n\t\tKeyFile           weakString             `yaml:\"key_file\"`\n\t\tCertFile          weakString             `yaml:\"cert_file\"`\n\t\tTruststoreFile    weakString             `yaml:\"truststore_file\"`\n\t\tEnabled           weakBool               `yaml:\"enabled\"`\n\t\tRequireClientAuth weakBool               `yaml:\"require_client_auth\"`\n\t\tOther             map[string]interface{} `yaml:\",inline\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\ts.Name = string(internal.Name)\n\ts.KeyFile = string(internal.KeyFile)\n\ts.CertFile = string(internal.CertFile)\n\ts.TruststoreFile = string(internal.TruststoreFile)\n\ts.Enabled = bool(internal.Enabled)\n\ts.RequireClientAuth = bool(internal.RequireClientAuth)\n\ts.Other = internal.Other\n\treturn nil\n}\n\nfunc (ss *SeedServer) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\t// New schema should only contain Address and Port, but we will\n\t\t// support this under Host also.\n\t\tAddress weakString    `yaml:\"address\"`\n\t\tPort    weakInt       `yaml:\"port\"`\n\t\tHost    SocketAddress `yaml:\"host\"`\n\t\t// deprecated\n\t\tNodeID *weakInt `yaml:\"node_id\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tif internal.NodeID != nil {\n\t\tfmt.Println(\"redpanda yaml: redpanda.seed_server.node_id is deprecated and unused\")\n\t}\n\n\tif internal.Address != \"\" || internal.Port != 0 {\n\t\tembedded := SocketAddress{string(internal.Address), int(internal.Port)}\n\t\tnested := internal.Host\n\n\t\tembeddedZero := reflect.DeepEqual(embedded, SocketAddress{})\n\t\tnestedZero := reflect.DeepEqual(nested, SocketAddress{})\n\n\t\tif !embeddedZero && !nestedZero && !reflect.DeepEqual(embedded, nested) {\n\t\t\treturn errors.New(\"redpanda.yaml redpanda.seed_server: nested host differs from address and port fields; only one must be set\")\n\t\t}\n\n\t\tss.Host = embedded\n\t\tif embeddedZero {\n\t\t\tss.Host = nested\n\t\t}\n\t\treturn nil\n\t}\n\n\tss.Host = internal.Host\n\treturn nil\n}\n\nfunc (sa *SocketAddress) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tAddress weakString `yaml:\"address\"`\n\t\tPort    weakInt    `yaml:\"port\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tsa.Address = string(internal.Address)\n\tsa.Port = int(internal.Port)\n\treturn nil\n}\n\nfunc (nsa *NamedSocketAddress) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tName    weakString `yaml:\"name\"`\n\t\tAddress weakString `yaml:\"address\"`\n\t\tPort    weakInt    `yaml:\"port\"`\n\t}\n\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\n\tnsa.Name = string(internal.Name)\n\tnsa.Address = string(internal.Address)\n\tnsa.Port = int(internal.Port)\n\treturn nil\n}\n\nfunc (nsa *NamedAuthNSocketAddress) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tName    weakString  `yaml:\"name\"`\n\t\tAddress weakString  `yaml:\"address\" mapstructure:\"address\"`\n\t\tPort    weakInt     `yaml:\"port\" mapstructure:\"port\"`\n\t\tAuthN   *weakString `yaml:\"authentication_method\" mapstructure:\"authentication_method\"`\n\t}\n\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\n\tnsa.Name = string(internal.Name)\n\tnsa.Address = string(internal.Address)\n\tnsa.Port = int(internal.Port)\n\tnsa.AuthN = (*string)(internal.AuthN)\n\treturn nil\n}\n\nfunc (t *TLS) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tKeyFile        weakString `yaml:\"key_file\"`\n\t\tCertFile       weakString `yaml:\"cert_file\"`\n\t\tTruststoreFile weakString `yaml:\"truststore_file\"`\n\t}\n\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\tt.KeyFile = string(internal.KeyFile)\n\tt.CertFile = string(internal.CertFile)\n\tt.TruststoreFile = string(internal.TruststoreFile)\n\treturn nil\n}\n\nfunc (s *SASL) UnmarshalYAML(n *yaml.Node) error {\n\tvar internal struct {\n\t\tUser      weakString `yaml:\"user\"`\n\t\tPassword  weakString `yaml:\"password\"`\n\t\tMechanism weakString `yaml:\"type\"`\n\t}\n\tif err := n.Decode(&internal); err != nil {\n\t\treturn err\n\t}\n\ts.User = string(internal.User)\n\ts.Password = string(internal.Password)\n\ts.Mechanism = string(internal.Mechanism)\n\n\treturn nil\n}\n", "package config\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"gopkg.in/yaml.v3\"\n)\n\nfunc TestWeakBool(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    bool\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"boolean:true\",\n\t\t\tdata: \"wb: true\",\n\t\t\texp:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"boolean:false\",\n\t\t\tdata: \"wb: false\",\n\t\t\texp:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"int:0\",\n\t\t\tdata: \"wb: 0\",\n\t\t\texp:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"non-zero int\",\n\t\t\tdata: \"wb: 12\",\n\t\t\texp:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"string:true\",\n\t\t\tdata: `wb: \"true\"`,\n\t\t\texp:  true,\n\t\t},\n\t\t{\n\t\t\tname: \"string:false\",\n\t\t\tdata: `wb: \"false\"`,\n\t\t\texp:  false,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string\",\n\t\t\tdata: `wb: \"\"`,\n\t\t\texp:  false,\n\t\t},\n\t\t{\n\t\t\tname:   \"error with unsupported string\",\n\t\t\tdata:   `wb: \"falsity\"`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"error with float type\",\n\t\t\tdata:   `wb: 123.123`,\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tWb weakBool `yaml:\"wb\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif bool(ts.Wb) != test.exp {\n\t\t\t\tt.Errorf(\"input %q: got %v, expected %v\",\n\t\t\t\t\ttest.data, ts.Wb, test.exp)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWeakInt(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    int\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"normal int types\",\n\t\t\tdata: \"wi: 1231\",\n\t\t\texp:  1231,\n\t\t},\n\t\t{\n\t\t\tname: \"empty string as 0\",\n\t\t\tdata: `wi: \"\"`,\n\t\t\texp:  0,\n\t\t},\n\t\t{\n\t\t\tname: \"string:-23414\",\n\t\t\tdata: `wi: \"-23414\"`,\n\t\t\texp:  -23414,\n\t\t},\n\t\t{\n\t\t\tname: \"string:231231\",\n\t\t\tdata: `wi: \"231231\"`,\n\t\t\texp:  231231,\n\t\t},\n\t\t{\n\t\t\tname: \"bool:true\",\n\t\t\tdata: `wi: true`,\n\t\t\texp:  1,\n\t\t},\n\t\t{\n\t\t\tname: \"bool:false\",\n\t\t\tdata: `wi: false`,\n\t\t\texp:  0,\n\t\t},\n\t\t{\n\t\t\tname:   \"error with non-numeric strings\",\n\t\t\tdata:   `wi: \"123foo234\"`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname:   \"error with float numbers\",\n\t\t\tdata:   `wi: 123.234`,\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tWi weakInt `yaml:\"wi\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif int(ts.Wi) != test.exp {\n\t\t\t\tt.Errorf(\"input %q: got %v, expected %v\",\n\t\t\t\t\ttest.data, ts.Wi, test.exp)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWeakString(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    string\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"normal string\",\n\t\t\tdata: `ws: \"hello world\"`,\n\t\t\texp:  \"hello world\",\n\t\t},\n\t\t{\n\t\t\tname: \"bool:true\",\n\t\t\tdata: \"ws: true\",\n\t\t\texp:  \"1\",\n\t\t},\n\t\t{\n\t\t\tname: \"bool:false\",\n\t\t\tdata: \"ws: false\",\n\t\t\texp:  \"0\",\n\t\t},\n\t\t{\n\t\t\tname: \"base10 number\",\n\t\t\tdata: \"ws: 231231\",\n\t\t\texp:  \"231231\",\n\t\t},\n\t\t{\n\t\t\tname: \"float number\",\n\t\t\tdata: \"ws: 231.231\",\n\t\t\texp:  \"231.231\",\n\t\t},\n\t\t{\n\t\t\tname:   \"should error with unsupported types\",\n\t\t\tdata:   \"ws: \\n  - 231.231\",\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tWs weakString `yaml:\"ws\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif string(ts.Ws) != test.exp {\n\t\t\t\tt.Errorf(\"input %q: got %v, expected %v\",\n\t\t\t\t\ttest.data, ts.Ws, test.exp)\n\t\t\t\treturn\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestWeakStringArray(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []string\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single weak string\",\n\t\t\tdata: `test_array:\n  12`,\n\t\t\texp: []string{\"12\"},\n\t\t},\n\t\t{\n\t\t\tname: \"list of weak string\",\n\t\t\tdata: `test_array:\n  - 12\n  - 12.3\n  - \"hello\"\n  - true\n`,\n\t\t\texp: []string{\"12\", \"12.3\", \"hello\", \"1\"},\n\t\t},\n\t\t{\n\t\t\tname: \"inline weak string\",\n\t\t\tdata: `test_array: 12`,\n\t\t\texp:  []string{\"12\"},\n\t\t},\n\t\t{\n\t\t\tname: \"array of weak strings\",\n\t\t\tdata: `test_array: [12, true]`,\n\t\t\texp:  []string{\"12\", \"1\"},\n\t\t},\n\t\t{\n\t\t\tname:   \"array with unsupported weak string\",\n\t\t\tdata:   `test_array: [12, {true}]`,\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tWsArr weakStringArray `yaml:\"test_array\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trequire.Equal(t, weakStringArray(test.exp), ts.WsArr)\n\t\t})\n\t}\n}\n\nfunc TestNamedSocketAddresses(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []SocketAddress\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single namedSocketAddress\",\n\t\t\tdata: \"test_api:\\n  address: 0.0.0.0\\n  port: 80\\n\",\n\t\t\texp:  []SocketAddress{{Address: \"0.0.0.0\", Port: 80}},\n\t\t},\n\t\t{\n\t\t\tname: \"list of 1 namedSocketAddress\",\n\t\t\tdata: \"test_api:\\n  - address: 0.0.0.0\\n    port: 80\\n\",\n\t\t\texp:  []SocketAddress{{Address: \"0.0.0.0\", Port: 80}},\n\t\t},\n\t\t{\n\t\t\tname: \"list of namedSocketAddress\",\n\t\t\tdata: `test_api:\n  - address: 0.0.0.0\n    port: 80\n  - address: 0.0.0.1\n    port: 81`,\n\t\t\texp: []SocketAddress{\n\t\t\t\t{\n\t\t\t\t\tAddress: \"0.0.0.0\", Port: 80,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tAddress: \"0.0.0.1\", Port: 81,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"unsupported types\",\n\t\t\tdata:   \"test_api:\\n  - address: 0.0.0.0\\n    port: [80]\\n\",\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tSockets socketAddresses `yaml:\"test_api\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, socketAddresses(test.exp), ts.Sockets)\n\t\t})\n\t}\n}\n\nfunc TestNamedSocketAddressArray(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []NamedSocketAddress\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single namedSocketAddress\",\n\t\t\tdata: \"test_api:\\n  address: 0.0.0.0\\n  port: 80\\n  name: socket\\n\",\n\t\t\texp: []NamedSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of 1 namedSocketAddress\",\n\t\t\tdata: \"test_api:\\n  - name: socket\\n    address: 0.0.0.0\\n    port: 80\\n\",\n\t\t\texp: []NamedSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of namedSocketAddress\",\n\t\t\tdata: `test_api:\n  - name: socket\n    address: 0.0.0.0\n    port: 80\n  - name: socket2\n    address: 0.0.0.1\n    port: 81`,\n\t\t\texp: []NamedSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket2\",\n\t\t\t\t\tAddress: \"0.0.0.1\",\n\t\t\t\t\tPort:    81,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"unsupported types\",\n\t\t\tdata:   \"test_api:\\n  address: [0.0.0.0]\\n  port: 80\\n  name: socket\\n\",\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tSockets namedSocketAddresses `yaml:\"test_api\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, namedSocketAddresses(test.exp), ts.Sockets)\n\t\t})\n\t}\n}\n\nfunc TestNamedAuthNSocketAddressArray(t *testing.T) {\n\tauthNMtlsIdentity := \"mtls_identity\"\n\tauthNSasl := \"sasl\"\n\tauthNNOne := \"none\"\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []NamedAuthNSocketAddress\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single namedAuthNSocketAddress\",\n\t\t\tdata: \"test_api:\\n  address: 0.0.0.0\\n  port: 80\\n  name: socket\\n  authentication_method: mtls_identity\\n\",\n\t\t\texp: []NamedAuthNSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t\tAuthN:   &authNMtlsIdentity,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of 1 namedSocketAddress\",\n\t\t\tdata: \"test_api:\\n  - name: socket\\n    address: 0.0.0.0\\n    port: 80\\n    authentication_method: sasl\\n\",\n\t\t\texp: []NamedAuthNSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t\tAuthN:   &authNSasl,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of namedSocketAddress\",\n\t\t\tdata: `test_api:\n  - name: socket\n    address: 0.0.0.0\n    port: 80\n    authentication_method: mtls_identity\n  - name: socket2\n    address: 0.0.0.1\n    port: 81\n    authentication_method: sasl\n  - name: socket3\n    address: 0.0.0.2\n    port: 81\n    authentication_method: none\n  - name: socket4\n    address: 0.0.0.3\n    port: 81`,\n\t\t\texp: []NamedAuthNSocketAddress{\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket\",\n\t\t\t\t\tAddress: \"0.0.0.0\",\n\t\t\t\t\tPort:    80,\n\t\t\t\t\tAuthN:   &authNMtlsIdentity,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket2\",\n\t\t\t\t\tAddress: \"0.0.0.1\",\n\t\t\t\t\tPort:    81,\n\t\t\t\t\tAuthN:   &authNSasl,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket3\",\n\t\t\t\t\tAddress: \"0.0.0.2\",\n\t\t\t\t\tPort:    81,\n\t\t\t\t\tAuthN:   &authNNOne,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:    \"socket4\",\n\t\t\t\t\tAddress: \"0.0.0.3\",\n\t\t\t\t\tPort:    81,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname:   \"unsupported types\",\n\t\t\tdata:   \"test_api:\\n  address: [0.0.0.0]\\n  port: 80\\n  name: socket\\n\",\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tSockets namedAuthNSocketAddresses `yaml:\"test_api\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, namedAuthNSocketAddresses(test.exp), ts.Sockets)\n\t\t})\n\t}\n}\n\nfunc TestServerTLSArray(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []ServerTLS\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single serverTLS\",\n\t\t\tdata: `test_api:\n  name: server\n  key_file: \"/etc/certs/cert.key\"\n  truststore_file: \"/etc/certs/ca.crt\"\n  cert_file: \"/etc/certs/cert.crt\"\n  enabled: true\n  require_client_auth: true\n`,\n\t\t\texp: []ServerTLS{\n\t\t\t\t{\n\t\t\t\t\tName:              \"server\",\n\t\t\t\t\tKeyFile:           \"/etc/certs/cert.key\",\n\t\t\t\t\tTruststoreFile:    \"/etc/certs/ca.crt\",\n\t\t\t\t\tCertFile:          \"/etc/certs/cert.crt\",\n\t\t\t\t\tEnabled:           true,\n\t\t\t\t\tRequireClientAuth: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of 1 serverTLS\",\n\t\t\tdata: `test_api:\n  - name: server\n    key_file: \"/etc/certs/cert.key\"\n    truststore_file: \"/etc/certs/ca.crt\"\n    cert_file: \"/etc/certs/cert.crt\"\n    enabled: true\n    require_client_auth: true\n`,\n\t\t\texp: []ServerTLS{\n\t\t\t\t{\n\t\t\t\t\tName:              \"server\",\n\t\t\t\t\tKeyFile:           \"/etc/certs/cert.key\",\n\t\t\t\t\tTruststoreFile:    \"/etc/certs/ca.crt\",\n\t\t\t\t\tCertFile:          \"/etc/certs/cert.crt\",\n\t\t\t\t\tEnabled:           true,\n\t\t\t\t\tRequireClientAuth: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of serverTLS\",\n\t\t\tdata: `test_api:\n  - name: server\n    key_file: \"/etc/certs/cert.key\"\n    truststore_file: \"/etc/certs/ca.crt\"\n    cert_file: \"/etc/certs/cert.crt\"\n    enabled: true\n    require_client_auth: true\n  - name: server2\n    key_file: \"/etc/certs/cert2.key\"\n    truststore_file: \"/etc/certs/ca2.crt\"\n    cert_file: \"/etc/certs/cert2.crt\"\n    enabled: false\n    require_client_auth: true\n`,\n\t\t\texp: []ServerTLS{\n\t\t\t\t{\n\t\t\t\t\tName:              \"server\",\n\t\t\t\t\tKeyFile:           \"/etc/certs/cert.key\",\n\t\t\t\t\tTruststoreFile:    \"/etc/certs/ca.crt\",\n\t\t\t\t\tCertFile:          \"/etc/certs/cert.crt\",\n\t\t\t\t\tEnabled:           true,\n\t\t\t\t\tRequireClientAuth: true,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName:              \"server2\",\n\t\t\t\t\tKeyFile:           \"/etc/certs/cert2.key\",\n\t\t\t\t\tTruststoreFile:    \"/etc/certs/ca2.crt\",\n\t\t\t\t\tCertFile:          \"/etc/certs/cert2.crt\",\n\t\t\t\t\tEnabled:           false,\n\t\t\t\t\tRequireClientAuth: true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unsupported types\",\n\t\t\tdata: `test_api:\n  name: server\n  enabled: [true]\n`,\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tServers serverTLSArray `yaml:\"test_api\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, serverTLSArray(test.exp), ts.Servers)\n\t\t})\n\t}\n}\n\nfunc TestSeedServers(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    []SeedServer\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"single seed server\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n    port: 80\n`,\n\t\t\texp: []SeedServer{\n\t\t\t\t{SocketAddress{\"0.0.0.1\", 80}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"list of seed server\",\n\t\t\tdata: `test_server:\n  - host:\n      address: \"0.0.0.1\"\n      port: 80\n  - host:\n      address: \"0.0.0.2\"\n      port: 90\n`,\n\t\t\texp: []SeedServer{\n\t\t\t\t{SocketAddress{\"0.0.0.1\", 80}},\n\t\t\t\t{SocketAddress{\"0.0.0.2\", 90}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"unsupported types\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n    port: [80]\n`,\n\t\t\texpErr: true,\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tSs seedServers `yaml:\"test_server\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, seedServers(test.exp), ts.Ss)\n\t\t})\n\t}\n}\n\nfunc TestSeedServer(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    SeedServer\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"with node_id\",\n\t\t\tdata: `test_server:\n  node_id: 1\n  host:\n    address: 192.168.10.1\n    port: 33145\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{\"192.168.10.1\", 33145},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"with host\",\n\t\t\tdata: `test_server:\n    host:\n        address: \"0.0.0.1\"\n        port: 80\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{\"0.0.0.1\", 80},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"address and port\",\n\t\t\tdata: `test_server:\n    address: \"1.0.0.1\"\n    port: 80\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{\"1.0.0.1\", 80},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"equal host and address & port\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n    port: 80\n  address: \"0.0.0.1\"\n  port: 80\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{\"0.0.0.1\", 80},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"host.address and port\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n  port: 80\n`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"address and host.port\",\n\t\t\tdata: `test_server:\n  host:\n    port: 80\n  address: \"0.0.0.1\"\n`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"address different from host.address\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n    port: 80\n  address: \"0.2.0.1\"\n  port: 80\n`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"port different from host.port\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n    port: 82\n  address: \"0.0.0.1\"\n  port: 80\n`,\n\t\t\texpErr: true,\n\t\t},\n\t\t{\n\t\t\tname: \"equal host.address and address\",\n\t\t\tdata: `test_server:\n  host:\n    address: \"0.0.0.1\"\n  address: \"0.0.0.1\"\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{Address: \"0.0.0.1\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"equal host.port and port\",\n\t\t\tdata: `test_server:\n  host:\n    port: 82\n  port: 82\n`,\n\t\t\texp: SeedServer{\n\t\t\t\tSocketAddress{Port: 82},\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tSs SeedServer `yaml:\"test_server\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, test.exp, ts.Ss)\n\t\t})\n\t}\n}\n\nfunc TestConfig_UnmarshalYAML(t *testing.T) {\n\tfor _, test := range []struct {\n\t\tname   string\n\t\tdata   string\n\t\texp    *Config\n\t\texpErr bool\n\t}{\n\t\t{\n\t\t\tname: \"Config file with normal types\",\n\t\t\tdata: `organization: \"my_organization\"\ncluster_id: \"cluster_id\"\nnode_uuid: \"node_uuid\"\nredpanda:\n  data_directory: \"var/lib/redpanda/data\"\n  node_id: 1\n  enable_admin_api: true\n  admin_api_doc_dir: \"/usr/share/redpanda/admin-api-doc\"\n  admin:\n  - address: \"0.0.0.0\"\n    port: 9644\n    name: admin\n  admin_api_tls:\n  - enabled: false\n    cert_file: \"certs/tls-cert.pem\"\n  rpc_server:\n    address: \"0.0.0.0\"\n    port: 33145\n  rpc_server_tls:\n  - require_client_auth: false\n    truststore_file: \"certs/tls-ca.pem\"\n  advertised_rpc_api:\n    address: \"0.0.0.0\"\n    port: 33145\n  kafka_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: 9092\n  - address: \"0.0.0.0\"\n    name: external\n    port: 9093\n  kafka_api_tls:\n  - name: \"external\"\n    key_file: \"certs/tls-key.pem\"\n  - name: \"internal\"\n    enabled: false\n  advertised_kafka_api:\n  - address: 0.0.0.0\n    name: internal\n    port: 9092\n  - address: redpanda-0.my.domain.com.\n    name: external\n    port: 9093\n  seed_servers:\n  - address: 192.168.0.1\n    port: 33145\n  rack: \"rack-id\"\npandaproxy:\n  pandaproxy_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: 8082\n  - address: \"0.0.0.0\"\n    name: external\n    port: 8083\n  pandaproxy_api_tls:\n  - name: external\n    enabled: false\n    truststore_file: \"truststore_file\"\n  - name: internal\n    enabled: false\n  advertised_pandaproxy_api:\n  - address: 0.0.0.0\n    name: internal\n    port: 8082\n  - address: \"redpanda-rest-0.my.domain.com.\"\n    name: external\n    port: 8083\n  consumer_instance_timeout_ms: 60000\npandaproxy_client:\n  brokers:\n  - address: \"127.0.0.1\"\n    port: 9092\n  broker_tls:\n    require_client_auth: false\n    cert_file: \"certfile\"\n  retries: 5\n  retry_base_backoff_ms: 100\n  sasl_mechanism: \"mechanism\"\nschema_registry:\n  schema_registry_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: 8081\n  - address: \"0.0.0.0\"\n    name: external\n    port: 18081\n  schema_registry_replication_factor: 3\n  schema_registry_api_tls:\n  - name: external\n    enabled: false\n  - name: internal\n    enabled: false\nrpk:\n  tls:\n    key_file: ~/certs/key.pem\n  sasl:\n    user: user\n    password: pass\n  additional_start_flags:\n    - \"--overprovisioned\"\n  kafka_api:\n    brokers:\n    - 192.168.72.34:9092\n    - 192.168.72.35:9092\n    tls:\n      key_file: ~/certs/key.pem\n    sasl:\n      user: user\n      password: pass\n  admin_api:\n    addresses:\n    - 192.168.72.34:9644\n    - 192.168.72.35:9644\n    tls:\n      cert_file: ~/certs/admin-cert.pem\n      truststore_file: ~/certs/admin-ca.pem\n  tune_network: false\n  tune_disk_scheduler: false\n  tune_cpu: true\n  tune_aio_events: false\n  tune_clocksource: true\n`,\n\t\t\texp: &Config{\n\t\t\t\tOrganization: \"my_organization\",\n\t\t\t\tClusterID:    \"cluster_id\",\n\t\t\t\tNodeUUID:     \"node_uuid\",\n\t\t\t\tRedpanda: RedpandaNodeConfig{\n\t\t\t\t\tDirectory:      \"var/lib/redpanda/data\",\n\t\t\t\t\tID:             1,\n\t\t\t\t\tAdminAPIDocDir: \"/usr/share/redpanda/admin-api-doc\",\n\t\t\t\t\tRack:           \"rack-id\",\n\t\t\t\t\tAdminAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9644, \"admin\"},\n\t\t\t\t\t},\n\t\t\t\t\tAdminAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Enabled: false, CertFile: \"certs/tls-cert.pem\"},\n\t\t\t\t\t},\n\t\t\t\t\tRPCServer:        SocketAddress{\"0.0.0.0\", 33145},\n\t\t\t\t\tAdvertisedRPCAPI: &SocketAddress{\"0.0.0.0\", 33145},\n\t\t\t\t\tKafkaAPI: []NamedAuthNSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9092, \"internal\", nil},\n\t\t\t\t\t\t{\"0.0.0.0\", 9093, \"external\", nil},\n\t\t\t\t\t},\n\t\t\t\t\tKafkaAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", KeyFile: \"certs/tls-key.pem\"},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tAdvertisedKafkaAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9092, \"internal\"},\n\t\t\t\t\t\t{\"redpanda-0.my.domain.com.\", 9093, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tSeedServers: []SeedServer{\n\t\t\t\t\t\t{SocketAddress{\"192.168.0.1\", 33145}},\n\t\t\t\t\t},\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"enable_admin_api\": true,\n\t\t\t\t\t\t// This one is a slice\n\t\t\t\t\t\t\"rpc_server_tls\": []interface{}{\n\t\t\t\t\t\t\tmap[string]interface{}{\n\t\t\t\t\t\t\t\t\"require_client_auth\": false,\n\t\t\t\t\t\t\t\t\"truststore_file\":     \"certs/tls-ca.pem\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPandaproxy: &Pandaproxy{\n\t\t\t\t\tPandaproxyAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8082, \"internal\"},\n\t\t\t\t\t\t{\"0.0.0.0\", 8083, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tPandaproxyAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", Enabled: false, TruststoreFile: \"truststore_file\"},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tAdvertisedPandaproxyAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8082, \"internal\"},\n\t\t\t\t\t\t{\"redpanda-rest-0.my.domain.com.\", 8083, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"consumer_instance_timeout_ms\": 60000,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPandaproxyClient: &KafkaClient{\n\t\t\t\t\tBrokers: []SocketAddress{\n\t\t\t\t\t\t{\"127.0.0.1\", 9092},\n\t\t\t\t\t},\n\t\t\t\t\tBrokerTLS: ServerTLS{\n\t\t\t\t\t\tRequireClientAuth: false, CertFile: \"certfile\",\n\t\t\t\t\t},\n\t\t\t\t\tSASLMechanism: func() *string { s := \"mechanism\"; return &s }(),\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"retries\":               5,\n\t\t\t\t\t\t\"retry_base_backoff_ms\": 100,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSchemaRegistry: &SchemaRegistry{\n\t\t\t\t\tSchemaRegistryAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8081, \"internal\"},\n\t\t\t\t\t\t{\"0.0.0.0\", 18081, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tSchemaRegistryAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", Enabled: false},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tSchemaRegistryReplicationFactor: func() *int { i := 3; return &i }(),\n\t\t\t\t},\n\t\t\t\tRpk: RpkConfig{\n\t\t\t\t\tTLS:                  &TLS{KeyFile: \"~/certs/key.pem\"},\n\t\t\t\t\tSASL:                 &SASL{User: \"user\", Password: \"pass\"},\n\t\t\t\t\tAdditionalStartFlags: []string{\"--overprovisioned\"},\n\t\t\t\t\tKafkaAPI: RpkKafkaAPI{\n\t\t\t\t\t\tBrokers: []string{\"192.168.72.34:9092\", \"192.168.72.35:9092\"},\n\t\t\t\t\t\tTLS:     &TLS{KeyFile: \"~/certs/key.pem\"},\n\t\t\t\t\t\tSASL:    &SASL{User: \"user\", Password: \"pass\"},\n\t\t\t\t\t},\n\t\t\t\t\tAdminAPI: RpkAdminAPI{\n\t\t\t\t\t\tAddresses: []string{\"192.168.72.34:9644\", \"192.168.72.35:9644\"},\n\t\t\t\t\t\tTLS:       &TLS{CertFile: \"~/certs/admin-cert.pem\", TruststoreFile: \"~/certs/admin-ca.pem\"},\n\t\t\t\t\t},\n\t\t\t\t\tTuneNetwork:       false,\n\t\t\t\t\tTuneDiskScheduler: false,\n\t\t\t\t\tTuneCPU:           true,\n\t\t\t\t\tTuneAioEvents:     false,\n\t\t\t\t\tTuneClocksource:   true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tname: \"Config file with weak types\",\n\t\t\tdata: `organization: true\ncluster_id: \"cluster_id\"\nnode_uuid: 124.42\nredpanda:\n  data_directory: \"var/lib/redpanda/data\"\n  node_id: 1\n  enable_admin_api: true\n  admin_api_doc_dir: \"/usr/share/redpanda/admin-api-doc\"\n  admin:\n    address: \"0.0.0.0\"\n    port: 9644\n    name: admin\n  admin_api_tls:\n    enabled: false\n    cert_file: \"certs/tls-cert.pem\"\n  rpc_server:\n    address: \"0.0.0.0\"\n    port: 33145\n  rpc_server_tls:\n    require_client_auth: false\n    truststore_file: \"certs/tls-ca.pem\"\n  advertised_rpc_api:\n    address: \"0.0.0.0\"\n    port: 33145\n  kafka_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: \"9092\"\n  - address: \"0.0.0.0\"\n    name: external\n    port: \"9093\"\n  kafka_api_tls:\n  - name: \"external\"\n    key_file: \"certs/tls-key.pem\"\n  - name: \"internal\"\n    enabled: false\n  advertised_kafka_api:\n  - address: 0.0.0.0\n    name: internal\n    port: 9092\n  - address: redpanda-0.my.domain.com.\n    name: external\n    port: 9093\n  seed_servers:\n  - host:\n      address: 192.168.0.1\n      port: 33145\n  - node_id: \"0\"\n    host:\n      address: 192.168.0.1\n      port: 33145\n  - address: 192.168.0.1\n    port: 33145\n  rack: \"rack-id\"\npandaproxy:\n  pandaproxy_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: 8082\n  - address: \"0.0.0.0\"\n    name: external\n    port: 8083\n  pandaproxy_api_tls:\n  - name: external\n    enabled: 0\n    truststore_file: \"truststore_file\"\n  - name: internal\n    enabled: 0\n  advertised_pandaproxy_api:\n  - address: 0.0.0.0\n    name: internal\n    port: 8082\n  - address: \"redpanda-rest-0.my.domain.com.\"\n    name: external\n    port: 8083\n  consumer_instance_timeout_ms: 60000\npandaproxy_client:\n  brokers:\n  - address: \"127.0.0.1\"\n    port: 9092\n  broker_tls:\n    require_client_auth: false\n    cert_file: \"certfile\"\n  retries: 5\n  retry_base_backoff_ms: 100\n  sasl_mechanism: \"mechanism\"\nschema_registry:\n  schema_registry_api:\n  - address: \"0.0.0.0\"\n    name: internal\n    port: 8081\n  - address: \"0.0.0.0\"\n    name: external\n    port: 18081\n  schema_registry_replication_factor: 3\n  schema_registry_api_tls:\n  - name: external\n    enabled: false\n  - name: internal\n    enabled: false\nrpk:\n  tls:\n    key_file: ~/certs/key.pem\n  sasl:\n    user: user\n    password: pass\n  additional_start_flags: \"--overprovisioned\"\n  kafka_api:\n    brokers:\n    - 192.168.72.34:9092\n    - 192.168.72.35:9092\n    tls:\n      key_file: ~/certs/key.pem\n    sasl:\n      user: user\n      password: pass\n  admin_api:\n    addresses:\n    - 192.168.72.34:9644\n    - 192.168.72.35:9644\n    tls:\n      cert_file: ~/certs/admin-cert.pem\n      truststore_file: ~/certs/admin-ca.pem\n  tune_network: false\n  tune_disk_scheduler: false\n  tune_cpu: 1\n  tune_aio_events: false\n  tune_clocksource: 1\n`,\n\t\t\texp: &Config{\n\t\t\t\tOrganization: \"1\",\n\t\t\t\tClusterID:    \"cluster_id\",\n\t\t\t\tNodeUUID:     \"124.42\",\n\t\t\t\tRedpanda: RedpandaNodeConfig{\n\t\t\t\t\tDirectory:      \"var/lib/redpanda/data\",\n\t\t\t\t\tID:             1,\n\t\t\t\t\tAdminAPIDocDir: \"/usr/share/redpanda/admin-api-doc\",\n\t\t\t\t\tRack:           \"rack-id\",\n\t\t\t\t\tAdminAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9644, \"admin\"},\n\t\t\t\t\t},\n\t\t\t\t\tAdminAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Enabled: false, CertFile: \"certs/tls-cert.pem\"},\n\t\t\t\t\t},\n\t\t\t\t\tRPCServer:        SocketAddress{\"0.0.0.0\", 33145},\n\t\t\t\t\tAdvertisedRPCAPI: &SocketAddress{\"0.0.0.0\", 33145},\n\t\t\t\t\tKafkaAPI: []NamedAuthNSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9092, \"internal\", nil},\n\t\t\t\t\t\t{\"0.0.0.0\", 9093, \"external\", nil},\n\t\t\t\t\t},\n\t\t\t\t\tKafkaAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", KeyFile: \"certs/tls-key.pem\"},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tAdvertisedKafkaAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 9092, \"internal\"},\n\t\t\t\t\t\t{\"redpanda-0.my.domain.com.\", 9093, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tSeedServers: []SeedServer{\n\t\t\t\t\t\t{SocketAddress{\"192.168.0.1\", 33145}},\n\t\t\t\t\t\t{SocketAddress{\"192.168.0.1\", 33145}},\n\t\t\t\t\t\t{SocketAddress{\"192.168.0.1\", 33145}},\n\t\t\t\t\t},\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"enable_admin_api\": true,\n\t\t\t\t\t\t\"rpc_server_tls\": map[string]interface{}{\n\t\t\t\t\t\t\t\"require_client_auth\": false,\n\t\t\t\t\t\t\t\"truststore_file\":     \"certs/tls-ca.pem\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPandaproxy: &Pandaproxy{\n\t\t\t\t\tPandaproxyAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8082, \"internal\"},\n\t\t\t\t\t\t{\"0.0.0.0\", 8083, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tPandaproxyAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", Enabled: false, TruststoreFile: \"truststore_file\"},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tAdvertisedPandaproxyAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8082, \"internal\"},\n\t\t\t\t\t\t{\"redpanda-rest-0.my.domain.com.\", 8083, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"consumer_instance_timeout_ms\": 60000,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tPandaproxyClient: &KafkaClient{\n\t\t\t\t\tBrokers: []SocketAddress{\n\t\t\t\t\t\t{\"127.0.0.1\", 9092},\n\t\t\t\t\t},\n\t\t\t\t\tBrokerTLS: ServerTLS{\n\t\t\t\t\t\tRequireClientAuth: false, CertFile: \"certfile\",\n\t\t\t\t\t},\n\t\t\t\t\tSASLMechanism: func() *string { s := \"mechanism\"; return &s }(),\n\t\t\t\t\tOther: map[string]interface{}{\n\t\t\t\t\t\t\"retries\":               5,\n\t\t\t\t\t\t\"retry_base_backoff_ms\": 100,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSchemaRegistry: &SchemaRegistry{\n\t\t\t\t\tSchemaRegistryAPI: []NamedSocketAddress{\n\t\t\t\t\t\t{\"0.0.0.0\", 8081, \"internal\"},\n\t\t\t\t\t\t{\"0.0.0.0\", 18081, \"external\"},\n\t\t\t\t\t},\n\t\t\t\t\tSchemaRegistryAPITLS: []ServerTLS{\n\t\t\t\t\t\t{Name: \"external\", Enabled: false},\n\t\t\t\t\t\t{Name: \"internal\", Enabled: false},\n\t\t\t\t\t},\n\t\t\t\t\tSchemaRegistryReplicationFactor: func() *int { i := 3; return &i }(),\n\t\t\t\t},\n\t\t\t\tRpk: RpkConfig{\n\t\t\t\t\tTLS:                  &TLS{KeyFile: \"~/certs/key.pem\"},\n\t\t\t\t\tSASL:                 &SASL{User: \"user\", Password: \"pass\"},\n\t\t\t\t\tAdditionalStartFlags: []string{\"--overprovisioned\"},\n\t\t\t\t\tKafkaAPI: RpkKafkaAPI{\n\t\t\t\t\t\tBrokers: []string{\"192.168.72.34:9092\", \"192.168.72.35:9092\"},\n\t\t\t\t\t\tTLS:     &TLS{KeyFile: \"~/certs/key.pem\"},\n\t\t\t\t\t\tSASL:    &SASL{User: \"user\", Password: \"pass\"},\n\t\t\t\t\t},\n\t\t\t\t\tAdminAPI: RpkAdminAPI{\n\t\t\t\t\t\tAddresses: []string{\"192.168.72.34:9644\", \"192.168.72.35:9644\"},\n\t\t\t\t\t\tTLS:       &TLS{CertFile: \"~/certs/admin-cert.pem\", TruststoreFile: \"~/certs/admin-ca.pem\"},\n\t\t\t\t\t},\n\t\t\t\t\tTuneNetwork:       false,\n\t\t\t\t\tTuneDiskScheduler: false,\n\t\t\t\t\tTuneCPU:           true,\n\t\t\t\t\tTuneAioEvents:     false,\n\t\t\t\t\tTuneClocksource:   true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t} {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tvar ts struct {\n\t\t\t\tConfig *Config `yaml:\",inline\"`\n\t\t\t}\n\t\t\terr := yaml.Unmarshal([]byte(test.data), &ts)\n\n\t\t\tgotErr := err != nil\n\t\t\tif gotErr != test.expErr {\n\t\t\t\tt.Errorf(\"input %q: got err? %v, exp err? %v; error: %v\",\n\t\t\t\t\ttest.data, gotErr, test.expErr, err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif test.expErr {\n\t\t\t\treturn\n\t\t\t}\n\t\t\trequire.Equal(t, test.exp, ts.Config)\n\t\t})\n\t}\n}\n"], "filenames": ["src/go/rpk/pkg/cli/cmd/debug/bundle_linux.go", "src/go/rpk/pkg/config/schema.go", "src/go/rpk/pkg/config/weak.go", "src/go/rpk/pkg/config/weak_test.go"], "buggy_code_start_loc": [395, 62, 14, 983], "buggy_code_end_loc": [396, 63, 359, 1238], "fixing_code_start_loc": [394, 61, 15, 983], "fixing_code_end_loc": [394, 61, 370, 1244], "type": "NVD-CWE-Other", "message": "rpk in Redpanda before 23.1.2 mishandles the redpanda.rpc_server_tls field, leading to (for example) situations in which there is a data type mismatch that cannot be automatically fixed by rpk, and instead a user must reconfigure (while a cluster is turned off) in order to have TLS on broker RPC ports. NOTE: the fix was also backported to the 22.2 and 22.3 branches.", "other": {"cve": {"id": "CVE-2023-30450", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-08T23:15:06.930", "lastModified": "2023-04-17T14:19:02.327", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "rpk in Redpanda before 23.1.2 mishandles the redpanda.rpc_server_tls field, leading to (for example) situations in which there is a data type mismatch that cannot be automatically fixed by rpk, and instead a user must reconfigure (while a cluster is turned off) in order to have TLS on broker RPC ports. NOTE: the fix was also backported to the 22.2 and 22.3 branches."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-Other"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redpanda:redpanda:*:*:*:*:*:*:*:*", "versionEndExcluding": "23.1.2", "matchCriteriaId": "540412CA-F1CE-41B4-BC8A-7E13F9BD95AB"}]}]}], "references": [{"url": "https://github.com/redpanda-data/redpanda/commit/58795aa07e88e0a63cebf4e1d9fcc717ceef0557", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/redpanda-data/redpanda/commit/a839056381ea7cd71e68495854e388daf7a08ba7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/redpanda-data/redpanda/commit/cf82b99457e2434d3674e424ab560fe201e6c365", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/redpanda-data/redpanda/compare/v23.1.1...v23.1.2", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/redpanda-data/redpanda/pull/7719", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/redpanda-data/redpanda/commit/58795aa07e88e0a63cebf4e1d9fcc717ceef0557"}}