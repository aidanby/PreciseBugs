{"buggy_code": ["/* Copyright (c) 2021, Red Hat, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <config.h>\n#include <stdlib.h>\n\n#include \"openvswitch/shash.h\"\n#include \"db-ctl-base.h\"\n#include \"smap.h\"\n#include \"lib/ovn-nb-idl.h\"\n#include \"lib/copp.h\"\n\nstatic char *copp_proto_names[COPP_PROTO_MAX] = {\n    [COPP_ARP]           = \"arp\",\n    [COPP_ARP_RESOLVE]   = \"arp-resolve\",\n    [COPP_DHCPV4_OPTS]   = \"dhcpv4-opts\",\n    [COPP_DHCPV6_OPTS]   = \"dhcpv6-opts\",\n    [COPP_DNS]           = \"dns\",\n    [COPP_EVENT_ELB]     = \"event-elb\",\n    [COPP_ICMP4_ERR]     = \"icmp4-error\",\n    [COPP_ICMP6_ERR]     = \"icmp6-error\",\n    [COPP_IGMP]          = \"igmp\",\n    [COPP_ND_NA]         = \"nd-na\",\n    [COPP_ND_NS]         = \"nd-ns\",\n    [COPP_ND_NS_RESOLVE] = \"nd-ns-resolve\",\n    [COPP_ND_RA_OPTS]    = \"nd-ra-opts\",\n    [COPP_TCP_RESET]     = \"tcp-reset\",\n    [COPP_REJECT]        = \"reject\",\n    [COPP_BFD]           = \"bfd\",\n};\n\nstatic const char *\ncopp_proto_get_name(enum copp_proto proto)\n{\n    if (proto >= COPP_PROTO_MAX) {\n        return \"<Invalid control protocol ID>\";\n    }\n    return copp_proto_names[proto];\n}\n\nconst char *\ncopp_meter_get(enum copp_proto proto, const struct nbrec_copp *copp,\n               const struct shash *meter_groups)\n{\n    if (!copp || proto >= COPP_PROTO_MAX) {\n        return NULL;\n    }\n\n    const char *meter = smap_get(&copp->meters, copp_proto_names[proto]);\n\n    if (meter && shash_find(meter_groups, meter)) {\n        return meter;\n    }\n\n    return NULL;\n}\n\nvoid\ncopp_meter_list(struct ctl_context *ctx, const struct nbrec_copp *copp)\n{\n    if (!copp) {\n        return;\n    }\n\n    struct smap_node *node;\n\n    SMAP_FOR_EACH (node, &copp->meters) {\n        ds_put_format(&ctx->output, \"%s: %s\\n\", node->key, node->value);\n    }\n}\n\nconst struct nbrec_copp *\ncopp_meter_add(struct ctl_context *ctx, const struct nbrec_copp *copp,\n               const char *proto_name, const char *meter)\n{\n    if (!copp) {\n        copp = nbrec_copp_insert(ctx->txn);\n    }\n\n    struct smap meters;\n    smap_init(&meters);\n    smap_clone(&meters, &copp->meters);\n    smap_replace(&meters, proto_name, meter);\n    nbrec_copp_set_meters(copp, &meters);\n    smap_destroy(&meters);\n\n    return copp;\n}\n\nvoid\ncopp_meter_del(const struct nbrec_copp *copp, const char *proto_name)\n{\n    if (!copp) {\n        return;\n    }\n\n    if (proto_name) {\n        if (smap_get(&copp->meters, proto_name)) {\n            struct smap meters;\n            smap_init(&meters);\n            smap_clone(&meters, &copp->meters);\n            smap_remove(&meters, proto_name);\n            nbrec_copp_set_meters(copp, &meters);\n            smap_destroy(&meters);\n        }\n        if (smap_is_empty(&copp->meters)) {\n            nbrec_copp_delete(copp);\n        }\n    } else {\n        nbrec_copp_delete(copp);\n    }\n}\n\nchar *\ncopp_proto_validate(const char *proto_name)\n{\n    for (size_t i = COPP_PROTO_FIRST; i < COPP_PROTO_MAX; i++) {\n        if (!strcmp(proto_name, copp_proto_get_name(i))) {\n            return NULL;\n        }\n    }\n\n    struct ds usage = DS_EMPTY_INITIALIZER;\n\n    ds_put_cstr(&usage, \"Invalid control protocol. Allowed values: \");\n    for (size_t i = COPP_PROTO_FIRST; i < COPP_PROTO_MAX; i++) {\n        ds_put_format(&usage, \"%s, \", copp_proto_get_name(i));\n    }\n    ds_chomp(&usage, ' ');\n    ds_chomp(&usage, ',');\n    ds_put_cstr(&usage, \".\");\n\n    return ds_steal_cstr(&usage);\n}\n\nchar * OVS_WARN_UNUSED_RESULT\ncopp_by_name_or_uuid(struct ctl_context *ctx, const char *id, bool must_exist,\n                     const struct nbrec_copp **copp_p)\n{\n    const struct nbrec_copp *copp = NULL;\n    struct uuid uuid;\n    bool is_uuid = uuid_from_string(&uuid, id);\n\n    *copp_p = NULL;\n    if (is_uuid) {\n        copp = nbrec_copp_get_for_uuid(ctx->idl, &uuid);\n    }\n\n    if (!copp) {\n        const struct nbrec_copp *iter;\n        NBREC_COPP_FOR_EACH (iter, ctx->idl) {\n            if (!strcmp(iter->name, id)) {\n                copp = iter;\n                break;\n            }\n        }\n    }\n\n    if (!copp && must_exist) {\n        return xasprintf(\"%s: copp %s not found\",\n                         id, is_uuid ? \"UUID\" : \"name\");\n    }\n\n    *copp_p = copp;\n    return NULL;\n}\n", "/* Copyright (c) 2021, Red Hat, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef OVN_COPP_H\n#define OVN_COPP_H 1\n\n/*\n * Control plane protection - metered actions.\n */\nenum copp_proto {\n    COPP_PROTO_FIRST,\n    COPP_ARP = COPP_PROTO_FIRST,\n    COPP_ARP_RESOLVE,\n    COPP_DHCPV4_OPTS,\n    COPP_DHCPV6_OPTS,\n    COPP_DNS,\n    COPP_EVENT_ELB,\n    COPP_ICMP4_ERR,\n    COPP_ICMP6_ERR,\n    COPP_IGMP,\n    COPP_ND_NA,\n    COPP_ND_NS,\n    COPP_ND_NS_RESOLVE,\n    COPP_ND_RA_OPTS,\n    COPP_TCP_RESET,\n    COPP_BFD,\n    COPP_REJECT,\n    COPP_PROTO_MAX,\n    COPP_PROTO_INVALID = COPP_PROTO_MAX,\n};\n\nstruct nbrec_copp;\nstruct ctl_context;\n\nconst char *copp_meter_get(enum copp_proto proto,\n                           const struct nbrec_copp *copp,\n                           const struct shash *meter_groups);\n\nvoid copp_meter_list(struct ctl_context *ctx, const struct nbrec_copp *copp);\nconst struct nbrec_copp *\ncopp_meter_add(struct ctl_context *ctx, const struct nbrec_copp *copp,\n               const char *proto_name, const char *meter);\nvoid\ncopp_meter_del(const struct nbrec_copp *copp, const char *proto_name);\nchar * copp_proto_validate(const char *proto_name);\nchar * OVS_WARN_UNUSED_RESULT\ncopp_by_name_or_uuid(struct ctl_context *ctx, const char *id, bool must_exist,\n                     const struct nbrec_copp **copp_p);\n\n#endif /* lib/copp.h */\n", "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"dirs.h\"\n#include \"ipam.h\"\n#include \"openvswitch/dynamic-string.h\"\n#include \"hash.h\"\n#include \"hmapx.h\"\n#include \"openvswitch/hmap.h\"\n#include \"openvswitch/json.h\"\n#include \"ovn/lex.h\"\n#include \"lib/chassis-index.h\"\n#include \"lib/ip-mcast-index.h\"\n#include \"lib/static-mac-binding-index.h\"\n#include \"lib/copp.h\"\n#include \"lib/mcast-group-index.h\"\n#include \"lib/ovn-l7.h\"\n#include \"lib/ovn-nb-idl.h\"\n#include \"lib/ovn-sb-idl.h\"\n#include \"lib/ovn-util.h\"\n#include \"lib/lb.h\"\n#include \"memory.h\"\n#include \"northd.h\"\n#include \"lib/ovn-parallel-hmap.h\"\n#include \"ovn/actions.h\"\n#include \"ovn/features.h\"\n#include \"ovn/logical-fields.h\"\n#include \"packets.h\"\n#include \"simap.h\"\n#include \"smap.h\"\n#include \"sset.h\"\n#include \"svec.h\"\n#include \"stopwatch.h\"\n#include \"lib/stopwatch-names.h\"\n#include \"stream.h\"\n#include \"timeval.h\"\n#include \"util.h\"\n#include \"uuid.h\"\n#include \"ovs-thread.h\"\n#include \"openvswitch/vlog.h\"\n\nVLOG_DEFINE_THIS_MODULE(northd);\n\nstatic bool controller_event_en;\nstatic bool lflow_hash_lock_initialized = false;\n\nstatic bool check_lsp_is_up;\n\nstatic bool install_ls_lb_from_router;\n\n/* MAC allocated for service monitor usage. Just one mac is allocated\n * for this purpose and ovn-controller's on each chassis will make use\n * of this mac when sending out the packets to monitor the services\n * defined in Service_Monitor Southbound table. Since these packets\n * all locally handled, having just one mac is good enough. */\nstatic char svc_monitor_mac[ETH_ADDR_STRLEN + 1];\nstatic struct eth_addr svc_monitor_mac_ea;\n\n/* If this option is 'true' northd will make use of ct.inv match fields.\n * Otherwise, it will avoid using it.  The default is true. */\nstatic bool use_ct_inv_match = true;\n\n/* If this option is 'true' northd will implicitly add a lowest-priority\n * drop rule in the ACL stage of logical switches that have at least one\n * ACL.\n */\nstatic bool default_acl_drop;\n\n#define MAX_OVN_TAGS 4096\n\f\n/* Pipeline stages. */\n\n/* The two purposes for which ovn-northd uses OVN logical datapaths. */\nenum ovn_datapath_type {\n    DP_SWITCH,                  /* OVN logical switch. */\n    DP_ROUTER                   /* OVN logical router. */\n};\n\n/* Returns an \"enum ovn_stage\" built from the arguments.\n *\n * (It's better to use ovn_stage_build() for type-safety reasons, but inline\n * functions can't be used in enums or switch cases.) */\n#define OVN_STAGE_BUILD(DP_TYPE, PIPELINE, TABLE) \\\n    (((DP_TYPE) << 9) | ((PIPELINE) << 8) | (TABLE))\n\n/* A stage within an OVN logical switch or router.\n *\n * An \"enum ovn_stage\" indicates whether the stage is part of a logical switch\n * or router, whether the stage is part of the ingress or egress pipeline, and\n * the table within that pipeline.  The first three components are combined to\n * form the stage's full name, e.g. S_SWITCH_IN_PORT_SEC_L2,\n * S_ROUTER_OUT_DELIVERY. */\nenum ovn_stage {\n#define PIPELINE_STAGES                                                   \\\n    /* Logical switch ingress stages. */                                  \\\n    PIPELINE_STAGE(SWITCH, IN,  CHECK_PORT_SEC, 0, \"ls_in_check_port_sec\")   \\\n    PIPELINE_STAGE(SWITCH, IN,  APPLY_PORT_SEC, 1, \"ls_in_apply_port_sec\")   \\\n    PIPELINE_STAGE(SWITCH, IN,  LOOKUP_FDB ,    2, \"ls_in_lookup_fdb\")    \\\n    PIPELINE_STAGE(SWITCH, IN,  PUT_FDB,        3, \"ls_in_put_fdb\")       \\\n    PIPELINE_STAGE(SWITCH, IN,  PRE_ACL,        4, \"ls_in_pre_acl\")       \\\n    PIPELINE_STAGE(SWITCH, IN,  PRE_LB,         5, \"ls_in_pre_lb\")        \\\n    PIPELINE_STAGE(SWITCH, IN,  PRE_STATEFUL,   6, \"ls_in_pre_stateful\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  ACL_HINT,       7, \"ls_in_acl_hint\")      \\\n    PIPELINE_STAGE(SWITCH, IN,  ACL,            8, \"ls_in_acl\")           \\\n    PIPELINE_STAGE(SWITCH, IN,  QOS_MARK,       9, \"ls_in_qos_mark\")      \\\n    PIPELINE_STAGE(SWITCH, IN,  QOS_METER,     10, \"ls_in_qos_meter\")     \\\n    PIPELINE_STAGE(SWITCH, IN,  LB_AFF_CHECK,  11, \"ls_in_lb_aff_check\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  LB,            12, \"ls_in_lb\")            \\\n    PIPELINE_STAGE(SWITCH, IN,  LB_AFF_LEARN,  13, \"ls_in_lb_aff_learn\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  PRE_HAIRPIN,   14, \"ls_in_pre_hairpin\")   \\\n    PIPELINE_STAGE(SWITCH, IN,  NAT_HAIRPIN,   15, \"ls_in_nat_hairpin\")   \\\n    PIPELINE_STAGE(SWITCH, IN,  HAIRPIN,       16, \"ls_in_hairpin\")       \\\n    PIPELINE_STAGE(SWITCH, IN,  ACL_AFTER_LB,  17, \"ls_in_acl_after_lb\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  STATEFUL,      18, \"ls_in_stateful\")      \\\n    PIPELINE_STAGE(SWITCH, IN,  ARP_ND_RSP,    19, \"ls_in_arp_rsp\")       \\\n    PIPELINE_STAGE(SWITCH, IN,  DHCP_OPTIONS,  20, \"ls_in_dhcp_options\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  DHCP_RESPONSE, 21, \"ls_in_dhcp_response\") \\\n    PIPELINE_STAGE(SWITCH, IN,  DNS_LOOKUP,    22, \"ls_in_dns_lookup\")    \\\n    PIPELINE_STAGE(SWITCH, IN,  DNS_RESPONSE,  23, \"ls_in_dns_response\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  EXTERNAL_PORT, 24, \"ls_in_external_port\") \\\n    PIPELINE_STAGE(SWITCH, IN,  L2_LKUP,       25, \"ls_in_l2_lkup\")       \\\n    PIPELINE_STAGE(SWITCH, IN,  L2_UNKNOWN,    26, \"ls_in_l2_unknown\")    \\\n                                                                          \\\n    /* Logical switch egress stages. */                                   \\\n    PIPELINE_STAGE(SWITCH, OUT, PRE_ACL,      0, \"ls_out_pre_acl\")        \\\n    PIPELINE_STAGE(SWITCH, OUT, PRE_LB,       1, \"ls_out_pre_lb\")         \\\n    PIPELINE_STAGE(SWITCH, OUT, PRE_STATEFUL, 2, \"ls_out_pre_stateful\")   \\\n    PIPELINE_STAGE(SWITCH, OUT, ACL_HINT,     3, \"ls_out_acl_hint\")       \\\n    PIPELINE_STAGE(SWITCH, OUT, ACL,          4, \"ls_out_acl\")            \\\n    PIPELINE_STAGE(SWITCH, OUT, QOS_MARK,     5, \"ls_out_qos_mark\")       \\\n    PIPELINE_STAGE(SWITCH, OUT, QOS_METER,    6, \"ls_out_qos_meter\")      \\\n    PIPELINE_STAGE(SWITCH, OUT, STATEFUL,     7, \"ls_out_stateful\")       \\\n    PIPELINE_STAGE(SWITCH, OUT, CHECK_PORT_SEC,  8, \"ls_out_check_port_sec\") \\\n    PIPELINE_STAGE(SWITCH, OUT, APPLY_PORT_SEC,  9, \"ls_out_apply_port_sec\") \\\n                                                                      \\\n    /* Logical router ingress stages. */                              \\\n    PIPELINE_STAGE(ROUTER, IN,  ADMISSION,       0, \"lr_in_admission\")    \\\n    PIPELINE_STAGE(ROUTER, IN,  LOOKUP_NEIGHBOR, 1, \"lr_in_lookup_neighbor\") \\\n    PIPELINE_STAGE(ROUTER, IN,  LEARN_NEIGHBOR,  2, \"lr_in_learn_neighbor\") \\\n    PIPELINE_STAGE(ROUTER, IN,  IP_INPUT,        3, \"lr_in_ip_input\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  UNSNAT,          4, \"lr_in_unsnat\")       \\\n    PIPELINE_STAGE(ROUTER, IN,  DEFRAG,          5, \"lr_in_defrag\")       \\\n    PIPELINE_STAGE(ROUTER, IN,  LB_AFF_CHECK,    6, \"lr_in_lb_aff_check\") \\\n    PIPELINE_STAGE(ROUTER, IN,  DNAT,            7, \"lr_in_dnat\")         \\\n    PIPELINE_STAGE(ROUTER, IN,  LB_AFF_LEARN,    8, \"lr_in_lb_aff_learn\") \\\n    PIPELINE_STAGE(ROUTER, IN,  ECMP_STATEFUL,   9, \"lr_in_ecmp_stateful\") \\\n    PIPELINE_STAGE(ROUTER, IN,  ND_RA_OPTIONS,   10, \"lr_in_nd_ra_options\") \\\n    PIPELINE_STAGE(ROUTER, IN,  ND_RA_RESPONSE,  11, \"lr_in_nd_ra_response\") \\\n    PIPELINE_STAGE(ROUTER, IN,  IP_ROUTING_PRE,  12, \"lr_in_ip_routing_pre\")  \\\n    PIPELINE_STAGE(ROUTER, IN,  IP_ROUTING,      13, \"lr_in_ip_routing\")      \\\n    PIPELINE_STAGE(ROUTER, IN,  IP_ROUTING_ECMP, 14, \"lr_in_ip_routing_ecmp\") \\\n    PIPELINE_STAGE(ROUTER, IN,  POLICY,          15, \"lr_in_policy\")          \\\n    PIPELINE_STAGE(ROUTER, IN,  POLICY_ECMP,     16, \"lr_in_policy_ecmp\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  ARP_RESOLVE,     17, \"lr_in_arp_resolve\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  CHK_PKT_LEN,     18, \"lr_in_chk_pkt_len\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  LARGER_PKTS,     19, \"lr_in_larger_pkts\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  GW_REDIRECT,     20, \"lr_in_gw_redirect\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  ARP_REQUEST,     21, \"lr_in_arp_request\")     \\\n                                                                      \\\n    /* Logical router egress stages. */                               \\\n    PIPELINE_STAGE(ROUTER, OUT, CHECK_DNAT_LOCAL,   0,                       \\\n                   \"lr_out_chk_dnat_local\")                                  \\\n    PIPELINE_STAGE(ROUTER, OUT, UNDNAT,             1, \"lr_out_undnat\")      \\\n    PIPELINE_STAGE(ROUTER, OUT, POST_UNDNAT,        2, \"lr_out_post_undnat\") \\\n    PIPELINE_STAGE(ROUTER, OUT, SNAT,               3, \"lr_out_snat\")        \\\n    PIPELINE_STAGE(ROUTER, OUT, POST_SNAT,          4, \"lr_out_post_snat\")   \\\n    PIPELINE_STAGE(ROUTER, OUT, EGR_LOOP,           5, \"lr_out_egr_loop\")    \\\n    PIPELINE_STAGE(ROUTER, OUT, DELIVERY,           6, \"lr_out_delivery\")\n\n#define PIPELINE_STAGE(DP_TYPE, PIPELINE, STAGE, TABLE, NAME)   \\\n    S_##DP_TYPE##_##PIPELINE##_##STAGE                          \\\n        = OVN_STAGE_BUILD(DP_##DP_TYPE, P_##PIPELINE, TABLE),\n    PIPELINE_STAGES\n#undef PIPELINE_STAGE\n};\n\n/* Due to various hard-coded priorities need to implement ACLs, the\n * northbound database supports a smaller range of ACL priorities than\n * are available to logical flows.  This value is added to an ACL\n * priority to determine the ACL's logical flow priority. */\n#define OVN_ACL_PRI_OFFSET 1000\n\n/* Register definitions specific to switches. */\n#define REGBIT_CONNTRACK_DEFRAG   \"reg0[0]\"\n#define REGBIT_CONNTRACK_COMMIT   \"reg0[1]\"\n#define REGBIT_CONNTRACK_NAT      \"reg0[2]\"\n#define REGBIT_DHCP_OPTS_RESULT   \"reg0[3]\"\n#define REGBIT_DNS_LOOKUP_RESULT  \"reg0[4]\"\n#define REGBIT_ND_RA_OPTS_RESULT  \"reg0[5]\"\n#define REGBIT_HAIRPIN            \"reg0[6]\"\n#define REGBIT_ACL_HINT_ALLOW_NEW \"reg0[7]\"\n#define REGBIT_ACL_HINT_ALLOW     \"reg0[8]\"\n#define REGBIT_ACL_HINT_DROP      \"reg0[9]\"\n#define REGBIT_ACL_HINT_BLOCK     \"reg0[10]\"\n#define REGBIT_LKUP_FDB           \"reg0[11]\"\n#define REGBIT_HAIRPIN_REPLY      \"reg0[12]\"\n#define REGBIT_ACL_LABEL          \"reg0[13]\"\n#define REGBIT_FROM_RAMP          \"reg0[14]\"\n#define REGBIT_PORT_SEC_DROP      \"reg0[15]\"\n#define REGBIT_ACL_STATELESS      \"reg0[16]\"\n#define REGBIT_ACL_HINT_ALLOW_REL \"reg0[17]\"\n\n#define REG_ORIG_DIP_IPV4         \"reg1\"\n#define REG_ORIG_DIP_IPV6         \"xxreg1\"\n#define REG_ORIG_TP_DPORT         \"reg2[0..15]\"\n\n/* Register used to store backend ipv6 address\n * for load balancer affinity. */\n#define REG_LB_L2_AFF_BACKEND_IP6 \"xxreg0\"\n\n/* Register definitions for switches and routers. */\n\n/* Register used to store backend ipv4 address\n * for load balancer affinity. */\n#define REG_LB_AFF_BACKEND_IP4  \"reg4\"\n#define REG_LB_AFF_MATCH_PORT   \"reg8[0..15]\"\n\n/* Indicate that this packet has been recirculated using egress\n * loopback.  This allows certain checks to be bypassed, such as a\n * logical router dropping packets with source IP address equals\n * one of the logical router's own IP addresses. */\n#define REGBIT_EGRESS_LOOPBACK  \"reg9[0]\"\n/* Register to store the result of check_pkt_larger action. */\n/* This register is also used by ovn-controller in\n * OFTABLE_OUTPUT_LARGE_PKT_DETECT table, for a similar goal. */\n#define REGBIT_PKT_LARGER        \"reg9[1]\"\n#define REGBIT_LOOKUP_NEIGHBOR_RESULT \"reg9[2]\"\n#define REGBIT_LOOKUP_NEIGHBOR_IP_RESULT \"reg9[3]\"\n#define REGBIT_DST_NAT_IP_LOCAL \"reg9[4]\"\n#define REGBIT_KNOWN_ECMP_NH    \"reg9[5]\"\n#define REGBIT_KNOWN_LB_SESSION \"reg9[6]\"\n\n/* Register to store the eth address associated to a router port for packets\n * received in S_ROUTER_IN_ADMISSION.\n */\n#define REG_INPORT_ETH_ADDR \"xreg0[0..47]\"\n\n/* Register for ECMP bucket selection. */\n#define REG_ECMP_GROUP_ID       \"reg8[0..15]\"\n#define REG_ECMP_MEMBER_ID      \"reg8[16..31]\"\n\n/* Registers used for routing. */\n#define REG_NEXT_HOP_IPV4 \"reg0\"\n#define REG_NEXT_HOP_IPV6 \"xxreg0\"\n#define REG_SRC_IPV4 \"reg1\"\n#define REG_SRC_IPV6 \"xxreg1\"\n#define REG_ROUTE_TABLE_ID \"reg7\"\n\n/* Register used to store backend ipv6 address\n * for load balancer affinity. */\n#define REG_LB_L3_AFF_BACKEND_IP6  \"xxreg1\"\n\n#define REG_ORIG_TP_DPORT_ROUTER   \"reg9[16..31]\"\n\n/* Register used for setting a label for ACLs in a Logical Switch. */\n#define REG_LABEL \"reg3\"\n\n/* Register used for temporarily store ECMP eth.src to avoid masked ct_label\n * access. It doesn't really occupy registers because the content of the\n * register is saved to stack and then restored in the same flow.\n * Note: the bits must match ct_label.ecmp_reply_eth defined in\n * logical-fields.c */\n#define REG_ECMP_ETH_FULL \"xxreg1\"\n#define REG_ECMP_ETH_FIELD REG_ECMP_ETH_FULL \"[\" \\\n    OVN_CT_STR(OVN_CT_ECMP_ETH_1ST_BIT) \\\n    \"..\" \\\n    OVN_CT_STR(OVN_CT_ECMP_ETH_END_BIT) \"]\"\n\n#define FLAGBIT_NOT_VXLAN \"flags[1] == 0\"\n\n/*\n * OVS register usage:\n *\n * Logical Switch pipeline:\n * +----+----------------------------------------------+---+-----------------------------------+\n * | R0 |     REGBIT_{CONNTRACK/DHCP/DNS}              |   |                                   |\n * |    |     REGBIT_{HAIRPIN/HAIRPIN_REPLY}           |   |                                   |\n * |    | REGBIT_ACL_HINT_{ALLOW_NEW/ALLOW/DROP/BLOCK} |   |                                   |\n * |    |     REGBIT_ACL_{LABEL/STATELESS}             | X |                                   |\n * +----+----------------------------------------------+ X |                                   |\n * | R5 |                   UNUSED                     | X |       LB_L2_AFF_BACKEND_IP6       |\n * | R1 |         ORIG_DIP_IPV4 (>= IN_PRE_STATEFUL)   | R |                                   |\n * +----+----------------------------------------------+ E |                                   |\n * | R2 |         ORIG_TP_DPORT (>= IN_PRE_STATEFUL)   | G |                                   |\n * +----+----------------------------------------------+ 0 |                                   |\n * | R3 |                  ACL LABEL                   |   |                                   |\n * +----+----------------------------------------------+---+-----------------------------------+\n * | R4 |            REG_LB_AFF_BACKEND_IP4            |   |                                   |\n * +----+----------------------------------------------+ X |                                   |\n * | R5 |                   UNUSED                     | X | ORIG_DIP_IPV6(>= IN_PRE_STATEFUL) |\n * +----+----------------------------------------------+ R |                                   |\n * | R6 |                   UNUSED                     | E |                                   |\n * +----+----------------------------------------------+ G |                                   |\n * | R7 |                   UNUSED                     | 1 |                                   |\n * +----+----------------------------------------------+---+-----------------------------------+\n * | R8 |              LB_AFF_MATCH_PORT               |\n * +----+----------------------------------------------+\n * | R9 |                   UNUSED                     |\n * +----+----------------------------------------------+\n *\n * Logical Router pipeline:\n * +-----+---------------------------+---+-----------------+---+------------------------------------+\n * | R0  | REGBIT_ND_RA_OPTS_RESULT  |   |                 |   |                                    |\n * |     |   (= IN_ND_RA_OPTIONS)    | X |                 |   |                                    |\n * |     |      NEXT_HOP_IPV4        | R |                 |   |                                    |\n * |     |      (>= IP_INPUT)        | E | INPORT_ETH_ADDR | X |                                    |\n * +-----+---------------------------+ G |   (< IP_INPUT)  | X |                                    |\n * | R1  |   SRC_IPV4 for ARP-REQ    | 0 |                 | R |                                    |\n * |     |      (>= IP_INPUT)        |   |                 | E |     NEXT_HOP_IPV6 (>= DEFRAG )     |\n * +-----+---------------------------+---+-----------------+ G |                                    |\n * | R2  |        UNUSED             | X |                 | 0 |                                    |\n * |     |                           | R |                 |   |                                    |\n * +-----+---------------------------+ E |     UNUSED      |   |                                    |\n * | R3  |        UNUSED             | G |                 |   |                                    |\n * |     |                           | 1 |                 |   |                                    |\n * +-----+---------------------------+---+-----------------+---+------------------------------------+\n * | R4  |  REG_LB_AFF_BACKEND_IP4   | X |                 |   |                                    |\n * |     |                           | R |                 |   |                                    |\n * +-----+---------------------------+ E |     UNUSED      | X |                                    |\n * | R5  |        UNUSED             | G |                 | X |                                    |\n * |     |                           | 2 |                 | R |        LB_L3_AFF_BACKEND_IP6       |\n * +-----+---------------------------+---+-----------------+ E |           (<= IN_DNAT)             |\n * | R6  |        UNUSED             | X |                 | G |                                    |\n * |     |                           | R |                 | 1 |                                    |\n * +-----+---------------------------+ E |     UNUSED      |   |                                    |\n * | R7  |      ROUTE_TABLE_ID       | G |                 |   |                                    |\n * |     | (>= IN_IP_ROUTING_PRE &&  | 3 |                 |   |                                    |\n * |     |  <= IN_IP_ROUTING)        |   |                 |   |                                    |\n * +-----+---------------------------+---+-----------------+---+------------------------------------+\n * | R8  |     ECMP_GROUP_ID         |   |                 |\n * |     |     ECMP_MEMBER_ID        |   |                 |\n * |     |    LB_AFF_MATCH_PORT      | X |                 |\n * +-----+---------------------------+ R |                 |\n * |     | REGBIT_{                  | E |                 |\n * |     |   EGRESS_LOOPBACK/        | G |     UNUSED      |\n * | R9  |   PKT_LARGER/             | 4 |                 |\n * |     |   LOOKUP_NEIGHBOR_RESULT/ |   |                 |\n * |     |   SKIP_LOOKUP_NEIGHBOR/   |   |                 |\n * |     |   KNOWN_ECMP_NH}          |   |                 |\n * |     |                           |   |                 |\n * |     | REG_ORIG_TP_DPORT_ROUTER  |   |                 |\n * |     |                           |   |                 |\n * +-----+---------------------------+---+-----------------+\n *\n */\n\n/*\n * Route offsets implement logic to prioritize traffic for routes with\n * same ip_prefix values:\n *  -  connected route overrides static one;\n *  -  static route overrides connected route. */\n#define ROUTE_PRIO_OFFSET_MULTIPLIER 3\n#define ROUTE_PRIO_OFFSET_STATIC 1\n#define ROUTE_PRIO_OFFSET_CONNECTED 2\n\n/* Returns an \"enum ovn_stage\" built from the arguments. */\nstatic enum ovn_stage\novn_stage_build(enum ovn_datapath_type dp_type, enum ovn_pipeline pipeline,\n                uint8_t table)\n{\n    return OVN_STAGE_BUILD(dp_type, pipeline, table);\n}\n\n/* Returns the pipeline to which 'stage' belongs. */\nstatic enum ovn_pipeline\novn_stage_get_pipeline(enum ovn_stage stage)\n{\n    return (stage >> 8) & 1;\n}\n\n/* Returns the pipeline name to which 'stage' belongs. */\nstatic const char *\novn_stage_get_pipeline_name(enum ovn_stage stage)\n{\n    return ovn_stage_get_pipeline(stage) == P_IN ? \"ingress\" : \"egress\";\n}\n\n/* Returns the table to which 'stage' belongs. */\nstatic uint8_t\novn_stage_get_table(enum ovn_stage stage)\n{\n    return stage & 0xff;\n}\n\n/* Returns a string name for 'stage'. */\nstatic const char *\novn_stage_to_str(enum ovn_stage stage)\n{\n    switch (stage) {\n#define PIPELINE_STAGE(DP_TYPE, PIPELINE, STAGE, TABLE, NAME)       \\\n        case S_##DP_TYPE##_##PIPELINE##_##STAGE: return NAME;\n    PIPELINE_STAGES\n#undef PIPELINE_STAGE\n        default: return \"<unknown>\";\n    }\n}\n\n/* Returns the type of the datapath to which a flow with the given 'stage' may\n * be added. */\nstatic enum ovn_datapath_type\novn_stage_to_datapath_type(enum ovn_stage stage)\n{\n    switch (stage) {\n#define PIPELINE_STAGE(DP_TYPE, PIPELINE, STAGE, TABLE, NAME)       \\\n        case S_##DP_TYPE##_##PIPELINE##_##STAGE: return DP_##DP_TYPE;\n    PIPELINE_STAGES\n#undef PIPELINE_STAGE\n    default: OVS_NOT_REACHED();\n    }\n}\n\f\nstatic void\nbuild_chassis_features(const struct northd_input *input_data,\n                       struct chassis_features *chassis_features)\n{\n    const struct sbrec_chassis *chassis;\n\n    SBREC_CHASSIS_TABLE_FOR_EACH (chassis, input_data->sbrec_chassis) {\n        /* Only consider local AZ chassis.  Remote ones don't install\n         * flows generated by the local northd.\n         */\n        if (smap_get_bool(&chassis->other_config, \"is-remote\", false)) {\n            continue;\n        }\n\n        bool ct_no_masked_label =\n            smap_get_bool(&chassis->other_config,\n                          OVN_FEATURE_CT_NO_MASKED_LABEL,\n                          false);\n        if (!ct_no_masked_label && chassis_features->ct_no_masked_label) {\n            chassis_features->ct_no_masked_label = false;\n        }\n\n        bool mac_binding_timestamp =\n            smap_get_bool(&chassis->other_config,\n                          OVN_FEATURE_MAC_BINDING_TIMESTAMP,\n                          false);\n        if (!mac_binding_timestamp &&\n            chassis_features->mac_binding_timestamp) {\n            chassis_features->mac_binding_timestamp = false;\n        }\n\n        bool ct_lb_related =\n            smap_get_bool(&chassis->other_config,\n                          OVN_FEATURE_CT_LB_RELATED,\n                          false);\n        if (!ct_lb_related &&\n            chassis_features->ct_lb_related) {\n            chassis_features->ct_lb_related = false;\n        }\n    }\n}\n\f\nstruct ovn_chassis_qdisc_queues {\n    struct hmap_node key_node;\n    uint32_t queue_id;\n    struct uuid chassis_uuid;\n};\n\nstatic uint32_t\nhash_chassis_queue(const struct uuid *chassis_uuid, uint32_t queue_id)\n{\n    return hash_2words(uuid_hash(chassis_uuid), queue_id);\n}\n\nstatic void\ndestroy_chassis_queues(struct hmap *set)\n{\n    struct ovn_chassis_qdisc_queues *node;\n    HMAP_FOR_EACH_POP (node, key_node, set) {\n        free(node);\n    }\n    hmap_destroy(set);\n}\n\nstatic void\nadd_chassis_queue(struct hmap *set, const struct uuid *chassis_uuid,\n                  uint32_t queue_id)\n{\n    struct ovn_chassis_qdisc_queues *node = xmalloc(sizeof *node);\n    node->queue_id = queue_id;\n    node->chassis_uuid = *chassis_uuid;\n    hmap_insert(set, &node->key_node,\n                hash_chassis_queue(chassis_uuid, queue_id));\n}\n\nstatic bool\nchassis_queueid_in_use(const struct hmap *set, const struct uuid *chassis_uuid,\n                       uint32_t queue_id)\n{\n    const struct ovn_chassis_qdisc_queues *node;\n    HMAP_FOR_EACH_WITH_HASH (node, key_node,\n                             hash_chassis_queue(chassis_uuid, queue_id), set) {\n        if (uuid_equals(chassis_uuid, &node->chassis_uuid)\n            && node->queue_id == queue_id) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic uint32_t\nallocate_chassis_queueid(struct hmap *set, const struct uuid *uuid, char *name)\n{\n    if (!uuid) {\n        return 0;\n    }\n\n    for (uint32_t queue_id = QDISC_MIN_QUEUE_ID + 1;\n         queue_id <= QDISC_MAX_QUEUE_ID;\n         queue_id++) {\n        if (!chassis_queueid_in_use(set, uuid, queue_id)) {\n            add_chassis_queue(set, uuid, queue_id);\n            return queue_id;\n        }\n    }\n\n    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n    VLOG_WARN_RL(&rl, \"all %s queue ids exhausted\", name);\n    return 0;\n}\n\nstatic void\nfree_chassis_queueid(struct hmap *set, const struct uuid *uuid,\n                     uint32_t queue_id)\n{\n    if (!uuid) {\n        return;\n    }\n\n    struct ovn_chassis_qdisc_queues *node;\n    HMAP_FOR_EACH_WITH_HASH (node, key_node,\n                             hash_chassis_queue(uuid, queue_id), set) {\n        if (uuid_equals(uuid, &node->chassis_uuid)\n            && node->queue_id == queue_id) {\n            hmap_remove(set, &node->key_node);\n            free(node);\n            break;\n        }\n    }\n}\n\nstatic inline bool\nport_has_qos_params(const struct smap *opts)\n{\n    return (smap_get(opts, \"qos_max_rate\") || smap_get(opts, \"qos_min_rate\") ||\n            smap_get(opts, \"qos_burst\"));\n}\n\f\n\nstatic void\ninit_mcast_port_info(struct mcast_port_info *mcast_info,\n                     const struct nbrec_logical_switch_port *nbsp,\n                     const struct nbrec_logical_router_port *nbrp)\n{\n    if (nbsp) {\n        mcast_info->flood =\n            smap_get_bool(&nbsp->options, \"mcast_flood\", false);\n        mcast_info->flood_reports =\n            smap_get_bool(&nbsp->options, \"mcast_flood_reports\",\n                          false);\n    } else if (nbrp) {\n        /* We don't process multicast reports in any special way on logical\n         * routers so just treat them as regular multicast traffic.\n         */\n        mcast_info->flood =\n            smap_get_bool(&nbrp->options, \"mcast_flood\", false);\n        mcast_info->flood_reports = mcast_info->flood;\n    }\n}\n\nstatic uint32_t\novn_mcast_group_allocate_key(struct mcast_info *mcast_info)\n{\n    return ovn_allocate_tnlid(&mcast_info->group_tnlids, \"multicast group\",\n                              OVN_MIN_IP_MULTICAST, OVN_MAX_IP_MULTICAST,\n                              &mcast_info->group_tnlid_hint);\n}\n\n/* Contains a NAT entry with the external addresses pre-parsed. */\nstruct ovn_nat {\n    const struct nbrec_nat *nb;\n    struct lport_addresses ext_addrs;\n    struct ovs_list ext_addr_list_node; /* Linkage in the per-external IP\n                                         * list of nat entries. Currently\n                                         * only used for SNAT.\n                                         */\n};\n\n/* Stores the list of SNAT entries referencing a unique SNAT IP address.\n * The 'snat_entries' list will be empty if the SNAT IP is used only for\n * dnat_force_snat_ip or lb_force_snat_ip.\n */\nstruct ovn_snat_ip {\n    struct ovs_list snat_entries;\n};\n\nstatic bool\nget_force_snat_ip(struct ovn_datapath *od, const char *key_type,\n                  struct lport_addresses *laddrs);\n\n/* Returns true if a 'nat_entry' is valid, i.e.:\n * - parsing was successful.\n * - the string yielded exactly one IPv4 address or exactly one IPv6 address.\n */\nstatic bool\nnat_entry_is_valid(const struct ovn_nat *nat_entry)\n{\n    const struct lport_addresses *ext_addrs = &nat_entry->ext_addrs;\n\n    return (ext_addrs->n_ipv4_addrs == 1 && ext_addrs->n_ipv6_addrs == 0) ||\n        (ext_addrs->n_ipv4_addrs == 0 && ext_addrs->n_ipv6_addrs == 1);\n}\n\nstatic bool\nnat_entry_is_v6(const struct ovn_nat *nat_entry)\n{\n    return nat_entry->ext_addrs.n_ipv6_addrs > 0;\n}\n\nstatic void\nsnat_ip_add(struct ovn_datapath *od, const char *ip, struct ovn_nat *nat_entry)\n{\n    struct ovn_snat_ip *snat_ip = shash_find_data(&od->snat_ips, ip);\n\n    if (!snat_ip) {\n        snat_ip = xzalloc(sizeof *snat_ip);\n        ovs_list_init(&snat_ip->snat_entries);\n        shash_add(&od->snat_ips, ip, snat_ip);\n    }\n\n    if (nat_entry) {\n        ovs_list_push_back(&snat_ip->snat_entries,\n                           &nat_entry->ext_addr_list_node);\n    }\n}\n\nstatic void\ninit_nat_entries(struct ovn_datapath *od)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    shash_init(&od->snat_ips);\n    if (get_force_snat_ip(od, \"dnat\", &od->dnat_force_snat_addrs)) {\n        if (od->dnat_force_snat_addrs.n_ipv4_addrs) {\n            snat_ip_add(od, od->dnat_force_snat_addrs.ipv4_addrs[0].addr_s,\n                        NULL);\n        }\n        if (od->dnat_force_snat_addrs.n_ipv6_addrs) {\n            snat_ip_add(od, od->dnat_force_snat_addrs.ipv6_addrs[0].addr_s,\n                        NULL);\n        }\n    }\n\n    /* Check if 'lb_force_snat_ip' is configured with 'router_ip'. */\n    const char *lb_force_snat =\n        smap_get(&od->nbr->options, \"lb_force_snat_ip\");\n    if (lb_force_snat && !strcmp(lb_force_snat, \"router_ip\")\n            && smap_get(&od->nbr->options, \"chassis\")) {\n        /* Set it to true only if its gateway router and\n         * options:lb_force_snat_ip=router_ip. */\n        od->lb_force_snat_router_ip = true;\n    } else {\n        od->lb_force_snat_router_ip = false;\n\n        /* Check if 'lb_force_snat_ip' is configured with a set of\n         * IP address(es). */\n        if (get_force_snat_ip(od, \"lb\", &od->lb_force_snat_addrs)) {\n            if (od->lb_force_snat_addrs.n_ipv4_addrs) {\n                snat_ip_add(od, od->lb_force_snat_addrs.ipv4_addrs[0].addr_s,\n                            NULL);\n            }\n            if (od->lb_force_snat_addrs.n_ipv6_addrs) {\n                snat_ip_add(od, od->lb_force_snat_addrs.ipv6_addrs[0].addr_s,\n                            NULL);\n            }\n        }\n    }\n\n    if (!od->nbr->n_nat) {\n        return;\n    }\n\n    od->nat_entries = xmalloc(od->nbr->n_nat * sizeof *od->nat_entries);\n\n    for (size_t i = 0; i < od->nbr->n_nat; i++) {\n        const struct nbrec_nat *nat = od->nbr->nat[i];\n        struct ovn_nat *nat_entry = &od->nat_entries[i];\n\n        nat_entry->nb = nat;\n        if (!extract_ip_addresses(nat->external_ip,\n                                  &nat_entry->ext_addrs) ||\n                !nat_entry_is_valid(nat_entry)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n\n            VLOG_WARN_RL(&rl,\n                         \"Bad ip address %s in nat configuration \"\n                         \"for router %s\", nat->external_ip, od->nbr->name);\n            continue;\n        }\n\n        /* If this is a SNAT rule add the IP to the set of unique SNAT IPs. */\n        if (!strcmp(nat->type, \"snat\")) {\n            if (!nat_entry_is_v6(nat_entry)) {\n                snat_ip_add(od, nat_entry->ext_addrs.ipv4_addrs[0].addr_s,\n                            nat_entry);\n            } else {\n                snat_ip_add(od, nat_entry->ext_addrs.ipv6_addrs[0].addr_s,\n                            nat_entry);\n            }\n        }\n\n        if (!strcmp(nat->type, \"dnat_and_snat\")\n            && nat->logical_port && nat->external_mac) {\n            od->has_distributed_nat = true;\n        }\n    }\n    od->n_nat_entries = od->nbr->n_nat;\n}\n\nstatic void\ndestroy_nat_entries(struct ovn_datapath *od)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    shash_destroy_free_data(&od->snat_ips);\n    destroy_lport_addresses(&od->dnat_force_snat_addrs);\n    destroy_lport_addresses(&od->lb_force_snat_addrs);\n\n    for (size_t i = 0; i < od->n_nat_entries; i++) {\n        destroy_lport_addresses(&od->nat_entries[i].ext_addrs);\n    }\n}\n\nstatic void\ninit_router_external_ips(struct ovn_datapath *od)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    sset_init(&od->external_ips);\n    for (size_t i = 0; i < od->nbr->n_nat; i++) {\n        sset_add(&od->external_ips, od->nbr->nat[i]->external_ip);\n    }\n}\n\nstatic void\ndestroy_router_external_ips(struct ovn_datapath *od)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    sset_destroy(&od->external_ips);\n}\n\nstatic bool\nlb_has_vip(const struct nbrec_load_balancer *lb)\n{\n    return !smap_is_empty(&lb->vips);\n}\n\nstatic bool\nlb_group_has_vip(const struct nbrec_load_balancer_group *lb_group)\n{\n    for (size_t i = 0; i < lb_group->n_load_balancer; i++) {\n        if (lb_has_vip(lb_group->load_balancer[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic bool\nls_has_lb_vip(struct ovn_datapath *od)\n{\n    for (size_t i = 0; i < od->nbs->n_load_balancer; i++) {\n        if (lb_has_vip(od->nbs->load_balancer[i])) {\n            return true;\n        }\n    }\n\n    for (size_t i = 0; i < od->nbs->n_load_balancer_group; i++) {\n        if (lb_group_has_vip(od->nbs->load_balancer_group[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic bool\nlr_has_lb_vip(struct ovn_datapath *od)\n{\n    for (size_t i = 0; i < od->nbr->n_load_balancer; i++) {\n        if (lb_has_vip(od->nbr->load_balancer[i])) {\n            return true;\n        }\n    }\n\n    for (size_t i = 0; i < od->nbr->n_load_balancer_group; i++) {\n        if (lb_group_has_vip(od->nbr->load_balancer_group[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic void\ninit_lb_for_datapath(struct ovn_datapath *od)\n{\n    if (od->nbs) {\n        od->has_lb_vip = ls_has_lb_vip(od);\n    } else {\n        od->has_lb_vip = lr_has_lb_vip(od);\n    }\n}\n\nstatic void\ndestroy_lb_for_datapath(struct ovn_datapath *od)\n{\n    ovn_lb_ip_set_destroy(od->lb_ips);\n    od->lb_ips = NULL;\n\n    if (!od->nbs && !od->nbr) {\n        return;\n    }\n}\n\n/* A group of logical router datapaths which are connected - either\n * directly or indirectly.\n * Each logical router can belong to only one group. */\nstruct lrouter_group {\n    struct ovn_datapath **router_dps;\n    int n_router_dps;\n    /* Set of ha_chassis_groups which are associated with the router dps. */\n    struct sset ha_chassis_groups;\n    /* Temporary storage for chassis references while computing HA groups. */\n    struct hmapx tmp_ha_chassis;\n};\n\nstatic struct ovn_datapath *\novn_datapath_create(struct hmap *datapaths, const struct uuid *key,\n                    const struct nbrec_logical_switch *nbs,\n                    const struct nbrec_logical_router *nbr,\n                    const struct sbrec_datapath_binding *sb)\n{\n    struct ovn_datapath *od = xzalloc(sizeof *od);\n    od->key = *key;\n    od->sb = sb;\n    od->nbs = nbs;\n    od->nbr = nbr;\n    hmap_init(&od->port_tnlids);\n    hmap_init(&od->nb_pgs);\n    od->port_key_hint = 0;\n    hmap_insert(datapaths, &od->key_node, uuid_hash(&od->key));\n    od->lr_group = NULL;\n    ovs_list_init(&od->port_list);\n    return od;\n}\n\nstatic void ovn_ls_port_group_destroy(struct hmap *nb_pgs);\nstatic void destroy_mcast_info_for_datapath(struct ovn_datapath *od);\n\nstatic void\novn_datapath_destroy(struct hmap *datapaths, struct ovn_datapath *od)\n{\n    if (od) {\n        /* Don't remove od->list.  It is used within build_datapaths() as a\n         * private list and once we've exited that function it is not safe to\n         * use it. */\n        hmap_remove(datapaths, &od->key_node);\n        ovn_destroy_tnlids(&od->port_tnlids);\n        destroy_ipam_info(&od->ipam_info);\n        free(od->router_ports);\n        free(od->ls_peers);\n        destroy_nat_entries(od);\n        destroy_router_external_ips(od);\n        destroy_lb_for_datapath(od);\n        free(od->nat_entries);\n        free(od->localnet_ports);\n        free(od->l3dgw_ports);\n        ovn_ls_port_group_destroy(&od->nb_pgs);\n        destroy_mcast_info_for_datapath(od);\n\n        free(od);\n    }\n}\n\n/* Returns 'od''s datapath type. */\nstatic enum ovn_datapath_type\novn_datapath_get_type(const struct ovn_datapath *od)\n{\n    return od->nbs ? DP_SWITCH : DP_ROUTER;\n}\n\nstatic struct ovn_datapath *\novn_datapath_find(const struct hmap *datapaths,\n                  const struct uuid *uuid)\n{\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH_WITH_HASH (od, key_node, uuid_hash(uuid), datapaths) {\n        if (uuid_equals(uuid, &od->key)) {\n            return od;\n        }\n    }\n    return NULL;\n}\n\nstatic struct ovn_datapath *\novn_datapath_find_by_key(struct hmap *datapaths, uint32_t dp_key)\n{\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (od->tunnel_key == dp_key) {\n            return od;\n        }\n    }\n\n    return NULL;\n}\n\nstatic bool\novn_datapath_is_stale(const struct ovn_datapath *od)\n{\n    return !od->nbr && !od->nbs;\n}\n\nstatic struct ovn_datapath *\novn_datapath_from_sbrec(const struct hmap *datapaths,\n                        const struct sbrec_datapath_binding *sb)\n{\n    struct uuid key;\n\n    if (!smap_get_uuid(&sb->external_ids, \"logical-switch\", &key) &&\n        !smap_get_uuid(&sb->external_ids, \"logical-router\", &key)) {\n        return NULL;\n    }\n    struct ovn_datapath *od = ovn_datapath_find(datapaths, &key);\n    if (od && (od->sb == sb)) {\n        return od;\n    }\n\n    return NULL;\n}\n\nstatic void\novn_datapath_add_router_port(struct ovn_datapath *od, struct ovn_port *op)\n{\n    if (od->n_router_ports == od->n_allocated_router_ports) {\n        od->router_ports = x2nrealloc(od->router_ports,\n                                      &od->n_allocated_router_ports,\n                                      sizeof *od->router_ports);\n    }\n    od->router_ports[od->n_router_ports++] = op;\n}\n\nstatic void\novn_datapath_add_ls_peer(struct ovn_datapath *od, struct ovn_datapath *peer)\n{\n    if (od->n_ls_peers == od->n_allocated_ls_peers) {\n        od->ls_peers = x2nrealloc(od->ls_peers, &od->n_allocated_ls_peers,\n                                  sizeof *od->ls_peers);\n    }\n    od->ls_peers[od->n_ls_peers++] = peer;\n}\n\nstatic bool\nlrouter_is_enabled(const struct nbrec_logical_router *lrouter)\n{\n    return !lrouter->enabled || *lrouter->enabled;\n}\n\nstatic void\ninit_ipam_info_for_datapath(struct ovn_datapath *od)\n{\n    if (!od->nbs) {\n        return;\n    }\n\n    char uuid_s[UUID_LEN + 1];\n    sprintf(uuid_s, UUID_FMT, UUID_ARGS(&od->key));\n    init_ipam_info(&od->ipam_info, &od->nbs->other_config, uuid_s);\n}\n\nstatic void\ninit_mcast_info_for_router_datapath(struct ovn_datapath *od)\n{\n    struct mcast_router_info *mcast_rtr_info = &od->mcast_info.rtr;\n\n    mcast_rtr_info->relay = smap_get_bool(&od->nbr->options, \"mcast_relay\",\n                                          false);\n}\n\nstatic void\ninit_mcast_info_for_switch_datapath(struct ovn_datapath *od)\n{\n    struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n    mcast_sw_info->enabled =\n        smap_get_bool(&od->nbs->other_config, \"mcast_snoop\", false);\n    mcast_sw_info->querier =\n        smap_get_bool(&od->nbs->other_config, \"mcast_querier\", true);\n    mcast_sw_info->flood_unregistered =\n        smap_get_bool(&od->nbs->other_config, \"mcast_flood_unregistered\",\n                      false);\n\n    mcast_sw_info->table_size =\n        smap_get_ullong(&od->nbs->other_config, \"mcast_table_size\",\n                        OVN_MCAST_DEFAULT_MAX_ENTRIES);\n\n    uint32_t idle_timeout =\n        smap_get_ullong(&od->nbs->other_config, \"mcast_idle_timeout\",\n                        OVN_MCAST_DEFAULT_IDLE_TIMEOUT_S);\n    if (idle_timeout < OVN_MCAST_MIN_IDLE_TIMEOUT_S) {\n        idle_timeout = OVN_MCAST_MIN_IDLE_TIMEOUT_S;\n    } else if (idle_timeout > OVN_MCAST_MAX_IDLE_TIMEOUT_S) {\n        idle_timeout = OVN_MCAST_MAX_IDLE_TIMEOUT_S;\n    }\n    mcast_sw_info->idle_timeout = idle_timeout;\n\n    uint32_t query_interval =\n        smap_get_ullong(&od->nbs->other_config, \"mcast_query_interval\",\n                        mcast_sw_info->idle_timeout / 2);\n    if (query_interval < OVN_MCAST_MIN_QUERY_INTERVAL_S) {\n        query_interval = OVN_MCAST_MIN_QUERY_INTERVAL_S;\n    } else if (query_interval > OVN_MCAST_MAX_QUERY_INTERVAL_S) {\n        query_interval = OVN_MCAST_MAX_QUERY_INTERVAL_S;\n    }\n    mcast_sw_info->query_interval = query_interval;\n\n    mcast_sw_info->eth_src =\n        nullable_xstrdup(smap_get(&od->nbs->other_config, \"mcast_eth_src\"));\n    mcast_sw_info->ipv4_src =\n        nullable_xstrdup(smap_get(&od->nbs->other_config, \"mcast_ip4_src\"));\n    mcast_sw_info->ipv6_src =\n        nullable_xstrdup(smap_get(&od->nbs->other_config, \"mcast_ip6_src\"));\n\n    mcast_sw_info->query_max_response =\n        smap_get_ullong(&od->nbs->other_config, \"mcast_query_max_response\",\n                        OVN_MCAST_DEFAULT_QUERY_MAX_RESPONSE_S);\n}\n\nstatic void\ninit_mcast_flow_count(struct ovn_datapath *od)\n{\n    if (od->nbr) {\n        return;\n    }\n\n    struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n    mcast_sw_info->active_v4_flows = ATOMIC_VAR_INIT(0);\n    mcast_sw_info->active_v6_flows = ATOMIC_VAR_INIT(0);\n}\n\nstatic void\ninit_mcast_info_for_datapath(struct ovn_datapath *od)\n{\n    if (!od->nbr && !od->nbs) {\n        return;\n    }\n\n    hmap_init(&od->mcast_info.group_tnlids);\n    od->mcast_info.group_tnlid_hint = OVN_MIN_IP_MULTICAST;\n    ovs_list_init(&od->mcast_info.groups);\n\n    if (od->nbs) {\n        init_mcast_info_for_switch_datapath(od);\n    } else {\n        init_mcast_info_for_router_datapath(od);\n    }\n}\n\nstatic void\ndestroy_mcast_info_for_switch_datapath(struct ovn_datapath *od)\n{\n    struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n    free(mcast_sw_info->eth_src);\n    free(mcast_sw_info->ipv4_src);\n    free(mcast_sw_info->ipv6_src);\n}\n\nstatic void\ndestroy_mcast_info_for_datapath(struct ovn_datapath *od)\n{\n    if (!od->nbr && !od->nbs) {\n        return;\n    }\n\n    if (od->nbs) {\n        destroy_mcast_info_for_switch_datapath(od);\n    }\n\n    ovn_destroy_tnlids(&od->mcast_info.group_tnlids);\n}\n\nstatic void\nstore_mcast_info_for_switch_datapath(const struct sbrec_ip_multicast *sb,\n                                     struct ovn_datapath *od)\n{\n    struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n    sbrec_ip_multicast_set_datapath(sb, od->sb);\n    sbrec_ip_multicast_set_enabled(sb, &mcast_sw_info->enabled, 1);\n    sbrec_ip_multicast_set_querier(sb, &mcast_sw_info->querier, 1);\n    sbrec_ip_multicast_set_table_size(sb, &mcast_sw_info->table_size, 1);\n    sbrec_ip_multicast_set_idle_timeout(sb, &mcast_sw_info->idle_timeout, 1);\n    sbrec_ip_multicast_set_query_interval(sb,\n                                          &mcast_sw_info->query_interval, 1);\n    sbrec_ip_multicast_set_query_max_resp(sb,\n                                          &mcast_sw_info->query_max_response,\n                                          1);\n\n    if (mcast_sw_info->eth_src) {\n        sbrec_ip_multicast_set_eth_src(sb, mcast_sw_info->eth_src);\n    }\n\n    if (mcast_sw_info->ipv4_src) {\n        sbrec_ip_multicast_set_ip4_src(sb, mcast_sw_info->ipv4_src);\n    }\n\n    if (mcast_sw_info->ipv6_src) {\n        sbrec_ip_multicast_set_ip6_src(sb, mcast_sw_info->ipv6_src);\n    }\n}\n\nstatic void\novn_datapath_update_external_ids(struct ovn_datapath *od)\n{\n    /* Get the logical-switch or logical-router UUID to set in\n     * external-ids. */\n    char uuid_s[UUID_LEN + 1];\n    sprintf(uuid_s, UUID_FMT, UUID_ARGS(&od->key));\n    const char *key = od->nbs ? \"logical-switch\" : \"logical-router\";\n\n    /* Get names to set in external-ids. */\n    const char *name = od->nbs ? od->nbs->name : od->nbr->name;\n    const char *name2 = (od->nbs\n                         ? smap_get(&od->nbs->external_ids,\n                                    \"neutron:network_name\")\n                         : smap_get(&od->nbr->external_ids,\n                                    \"neutron:router_name\"));\n\n    /* Set external-ids. */\n    struct smap ids = SMAP_INITIALIZER(&ids);\n    smap_add(&ids, key, uuid_s);\n    smap_add(&ids, \"name\", name);\n    if (name2 && name2[0]) {\n        smap_add(&ids, \"name2\", name2);\n    }\n\n    /* Set interconn-ts. */\n    if (od->nbs) {\n        const char *ts = smap_get(&od->nbs->other_config, \"interconn-ts\");\n        if (ts) {\n            smap_add(&ids, \"interconn-ts\", ts);\n        }\n    }\n\n    /* Set snat-ct-zone */\n    if (od->nbr) {\n        int nat_default_ct = smap_get_int(&od->nbr->options,\n                                           \"snat-ct-zone\", -1);\n        if (nat_default_ct >= 0) {\n            smap_add_format(&ids, \"snat-ct-zone\", \"%d\", nat_default_ct);\n        }\n\n        bool learn_from_arp_request =\n            smap_get_bool(&od->nbr->options, \"always_learn_from_arp_request\",\n                          true);\n        if (!learn_from_arp_request) {\n            smap_add(&ids, \"always_learn_from_arp_request\", \"false\");\n        }\n    }\n\n    sbrec_datapath_binding_set_external_ids(od->sb, &ids);\n    smap_destroy(&ids);\n}\n\nstatic void\njoin_datapaths(struct northd_input *input_data,\n               struct ovsdb_idl_txn *ovnsb_txn,\n               struct hmap *datapaths, struct ovs_list *sb_only,\n               struct ovs_list *nb_only, struct ovs_list *both,\n               struct ovs_list *lr_list)\n{\n    ovs_list_init(sb_only);\n    ovs_list_init(nb_only);\n    ovs_list_init(both);\n\n    const struct sbrec_datapath_binding *sb;\n    SBREC_DATAPATH_BINDING_TABLE_FOR_EACH_SAFE (sb,\n                            input_data->sbrec_datapath_binding_table) {\n        struct uuid key;\n        if (!smap_get_uuid(&sb->external_ids, \"logical-switch\", &key) &&\n            !smap_get_uuid(&sb->external_ids, \"logical-router\", &key)) {\n            ovsdb_idl_txn_add_comment(\n                ovnsb_txn,\n                \"deleting Datapath_Binding \"UUID_FMT\" that lacks \"\n                \"external-ids:logical-switch and \"\n                \"external-ids:logical-router\",\n                UUID_ARGS(&sb->header_.uuid));\n            sbrec_datapath_binding_delete(sb);\n            continue;\n        }\n\n        if (ovn_datapath_find(datapaths, &key)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_INFO_RL(\n                &rl, \"deleting Datapath_Binding \"UUID_FMT\" with \"\n                \"duplicate external-ids:logical-switch/router \"UUID_FMT,\n                UUID_ARGS(&sb->header_.uuid), UUID_ARGS(&key));\n            sbrec_datapath_binding_delete(sb);\n            continue;\n        }\n\n        struct ovn_datapath *od = ovn_datapath_create(datapaths, &key,\n                                                      NULL, NULL, sb);\n        ovs_list_push_back(sb_only, &od->list);\n    }\n\n    const struct nbrec_logical_switch *nbs;\n    NBREC_LOGICAL_SWITCH_TABLE_FOR_EACH (nbs,\n                              input_data->nbrec_logical_switch) {\n        struct ovn_datapath *od = ovn_datapath_find(datapaths,\n                                                    &nbs->header_.uuid);\n        if (od) {\n            od->nbs = nbs;\n            ovs_list_remove(&od->list);\n            ovs_list_push_back(both, &od->list);\n            ovn_datapath_update_external_ids(od);\n        } else {\n            od = ovn_datapath_create(datapaths, &nbs->header_.uuid,\n                                     nbs, NULL, NULL);\n            ovs_list_push_back(nb_only, &od->list);\n        }\n\n        init_ipam_info_for_datapath(od);\n        init_mcast_info_for_datapath(od);\n        init_lb_for_datapath(od);\n    }\n\n    const struct nbrec_logical_router *nbr;\n    NBREC_LOGICAL_ROUTER_TABLE_FOR_EACH (nbr,\n                               input_data->nbrec_logical_router) {\n        if (!lrouter_is_enabled(nbr)) {\n            continue;\n        }\n\n        struct ovn_datapath *od = ovn_datapath_find(datapaths,\n                                                    &nbr->header_.uuid);\n        if (od) {\n            if (!od->nbs) {\n                od->nbr = nbr;\n                ovs_list_remove(&od->list);\n                ovs_list_push_back(both, &od->list);\n                ovn_datapath_update_external_ids(od);\n            } else {\n                /* Can't happen! */\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n                VLOG_WARN_RL(&rl,\n                             \"duplicate UUID \"UUID_FMT\" in OVN_Northbound\",\n                             UUID_ARGS(&nbr->header_.uuid));\n                continue;\n            }\n        } else {\n            od = ovn_datapath_create(datapaths, &nbr->header_.uuid,\n                                     NULL, nbr, NULL);\n            ovs_list_push_back(nb_only, &od->list);\n        }\n        init_mcast_info_for_datapath(od);\n        init_nat_entries(od);\n        init_router_external_ips(od);\n        init_lb_for_datapath(od);\n        if (smap_get(&od->nbr->options, \"chassis\")) {\n            od->is_gw_router = true;\n        }\n        ovs_list_push_back(lr_list, &od->lr_list);\n    }\n}\n\nstatic bool\nis_vxlan_mode(struct northd_input *input_data)\n{\n    const struct sbrec_chassis *chassis;\n    SBREC_CHASSIS_TABLE_FOR_EACH (chassis, input_data->sbrec_chassis) {\n        for (int i = 0; i < chassis->n_encaps; i++) {\n            if (!strcmp(chassis->encaps[i]->type, \"vxlan\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nstatic uint32_t\nget_ovn_max_dp_key_local(struct northd_input *input_data)\n{\n    if (is_vxlan_mode(input_data)) {\n        /* OVN_MAX_DP_GLOBAL_NUM doesn't apply for vxlan mode. */\n        return OVN_MAX_DP_VXLAN_KEY;\n    }\n    return OVN_MAX_DP_KEY - OVN_MAX_DP_GLOBAL_NUM;\n}\n\nstatic void\novn_datapath_allocate_key(struct northd_input *input_data,\n                          struct hmap *datapaths, struct hmap *dp_tnlids,\n                          struct ovn_datapath *od, uint32_t *hint)\n{\n    if (!od->tunnel_key) {\n        od->tunnel_key = ovn_allocate_tnlid(dp_tnlids, \"datapath\",\n                                    OVN_MIN_DP_KEY_LOCAL,\n                                    get_ovn_max_dp_key_local(input_data),\n                                    hint);\n        if (!od->tunnel_key) {\n            if (od->sb) {\n                sbrec_datapath_binding_delete(od->sb);\n            }\n            ovs_list_remove(&od->list);\n            ovn_datapath_destroy(datapaths, od);\n        }\n    }\n}\n\nstatic void\novn_datapath_assign_requested_tnl_id(struct northd_input *input_data,\n                                     struct hmap *dp_tnlids,\n                                     struct ovn_datapath *od)\n{\n    const struct smap *other_config = (od->nbs\n                                       ? &od->nbs->other_config\n                                       : &od->nbr->options);\n    uint32_t tunnel_key = smap_get_int(other_config, \"requested-tnl-key\", 0);\n    if (tunnel_key) {\n        const char *interconn_ts = smap_get(other_config, \"interconn-ts\");\n        if (!interconn_ts && is_vxlan_mode(input_data) &&\n            tunnel_key >= 1 << 12) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"Tunnel key %\"PRIu32\" for datapath %s is \"\n                         \"incompatible with VXLAN\", tunnel_key,\n                         od->nbs ? od->nbs->name : od->nbr->name);\n            return;\n        }\n        if (ovn_add_tnlid(dp_tnlids, tunnel_key)) {\n            od->tunnel_key = tunnel_key;\n        } else {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"Logical %s %s requests same tunnel key \"\n                         \"%\"PRIu32\" as another logical switch or router\",\n                         od->nbs ? \"switch\" : \"router\",\n                         od->nbs ? od->nbs->name : od->nbr->name, tunnel_key);\n        }\n    }\n}\n\n/* Array of all datapaths, with 'od->index' being their index in the array. */\nstatic struct ovn_datapath **datapaths_array = NULL;\nstatic size_t n_datapaths = 0; /* Size of the 'datapaths_array'. */\n\n/* Updates the southbound Datapath_Binding table so that it contains the\n * logical switches and routers specified by the northbound database.\n *\n * Initializes 'datapaths' to contain a \"struct ovn_datapath\" for every logical\n * switch and router. */\nstatic void\nbuild_datapaths(struct northd_input *input_data,\n                struct ovsdb_idl_txn *ovnsb_txn,\n                struct hmap *datapaths,\n                struct ovs_list *lr_list)\n{\n    struct ovs_list sb_only, nb_only, both;\n\n    join_datapaths(input_data, ovnsb_txn,\n                   datapaths, &sb_only, &nb_only, &both, lr_list);\n\n    /* Assign explicitly requested tunnel ids first. */\n    struct hmap dp_tnlids = HMAP_INITIALIZER(&dp_tnlids);\n    struct ovn_datapath *od;\n    LIST_FOR_EACH (od, list, &both) {\n        ovn_datapath_assign_requested_tnl_id(input_data, &dp_tnlids, od);\n    }\n    LIST_FOR_EACH (od, list, &nb_only) {\n        ovn_datapath_assign_requested_tnl_id(input_data, &dp_tnlids, od);\n    }\n\n    /* Keep nonconflicting tunnel IDs that are already assigned. */\n    LIST_FOR_EACH (od, list, &both) {\n        if (!od->tunnel_key && ovn_add_tnlid(&dp_tnlids, od->sb->tunnel_key)) {\n            od->tunnel_key = od->sb->tunnel_key;\n        }\n    }\n\n    /* Assign new tunnel ids where needed. */\n    uint32_t hint = 0;\n    LIST_FOR_EACH_SAFE (od, list, &both) {\n        ovn_datapath_allocate_key(input_data,\n                                  datapaths, &dp_tnlids, od, &hint);\n    }\n    LIST_FOR_EACH_SAFE (od, list, &nb_only) {\n        ovn_datapath_allocate_key(input_data,\n                                  datapaths, &dp_tnlids, od, &hint);\n    }\n\n    /* Sync tunnel ids from nb to sb. */\n    LIST_FOR_EACH (od, list, &both) {\n        if (od->sb->tunnel_key != od->tunnel_key) {\n            sbrec_datapath_binding_set_tunnel_key(od->sb, od->tunnel_key);\n        }\n        ovn_datapath_update_external_ids(od);\n    }\n    LIST_FOR_EACH (od, list, &nb_only) {\n        od->sb = sbrec_datapath_binding_insert(ovnsb_txn);\n        ovn_datapath_update_external_ids(od);\n        sbrec_datapath_binding_set_tunnel_key(od->sb, od->tunnel_key);\n    }\n    ovn_destroy_tnlids(&dp_tnlids);\n\n    /* Delete southbound records without northbound matches. */\n    LIST_FOR_EACH_SAFE (od, list, &sb_only) {\n        ovs_list_remove(&od->list);\n        sbrec_datapath_binding_delete(od->sb);\n        ovn_datapath_destroy(datapaths, od);\n    }\n\n    /* Assign unique sequential indexes to all datapaths.  These are not\n     * visible outside of the northd loop, so, unlike the tunnel keys, it\n     * doesn't matter if they are different on every iteration. */\n    size_t index = 0;\n\n    n_datapaths = hmap_count(datapaths);\n    datapaths_array = xrealloc(datapaths_array,\n                               n_datapaths * sizeof *datapaths_array);\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        od->index = index;\n        datapaths_array[index++] = od;\n    }\n}\n\n/* Structure representing logical router port\n * routable addresses. This includes DNAT and Load Balancer\n * addresses. This structure will only be filled in if the\n * router port is a gateway router port. Otherwise, all pointers\n * will be NULL and n_addrs will be 0.\n */\nstruct ovn_port_routable_addresses {\n    /* The parsed routable addresses */\n    struct lport_addresses *laddrs;\n    /* Number of items in the laddrs array */\n    size_t n_addrs;\n};\n\n/* A logical switch port or logical router port.\n *\n * In steady state, an ovn_port points to a northbound Logical_Switch_Port\n * record (via 'nbsp') *or* a Logical_Router_Port record (via 'nbrp'), and to a\n * southbound Port_Binding record (via 'sb').  As the state of the system\n * changes, join_logical_ports() may determine that there is a new LSP or LRP\n * that has no corresponding Port_Binding record (in which case build_ports())\n * will create the missing Port_Binding) or that a Port_Binding record exists\n * that has no coresponding LSP (in which case build_ports() will delete the\n * spurious Port_Binding).  Thus, after build_ports() runs, any given ovn_port\n * will have 'sb' nonnull, and 'nbsp' xor 'nbrp' nonnull.\n *\n * Ordinarily there is only one ovn_port that points to a given LSP or LRP (but\n * distributed gateway ports point a \"derived\" ovn_port to a duplicate LRP).\n */\nstruct ovn_port {\n    /* Port name aka key.\n     *\n     * This is ordinarily the same as nbsp->name or nbrp->name and\n     * sb->logical_port.  (A distributed gateway port creates a \"derived\"\n     * ovn_port with key \"cr-%s\" % nbrp->name.) */\n    struct hmap_node key_node;  /* Index on 'key'. */\n    char *key;                  /* nbsp->name, nbrp->name, sb->logical_port. */\n    char *json_key;             /* 'key', quoted for use in JSON. */\n\n    const struct sbrec_port_binding *sb;         /* May be NULL. */\n\n    uint32_t tunnel_key;\n\n    /* Logical switch port data. */\n    const struct nbrec_logical_switch_port *nbsp; /* May be NULL. */\n\n    struct lport_addresses *lsp_addrs;  /* Logical switch port addresses. */\n    unsigned int n_lsp_addrs;  /* Total length of lsp_addrs. */\n    unsigned int n_lsp_non_router_addrs; /* Number of elements from the\n                                          * beginning of 'lsp_addrs' extracted\n                                          * directly from LSP 'addresses'. */\n\n    struct lport_addresses *ps_addrs;   /* Port security addresses. */\n    unsigned int n_ps_addrs;\n\n    /* Logical router port data. */\n    const struct nbrec_logical_router_port *nbrp; /* May be NULL. */\n\n    struct lport_addresses lrp_networks;\n\n    struct ovn_port_routable_addresses routables;\n\n    /* Logical port multicast data. */\n    struct mcast_port_info mcast_info;\n\n    /* At most one of l3dgw_port and cr_port can be not NULL. */\n\n    /* This is set to a distributed gateway port if and only if this ovn_port\n     * is \"derived\" from it. Otherwise this is set to NULL. The derived\n     * ovn_port represents the instance of distributed gateway port on the\n     * gateway chassis.*/\n    struct ovn_port *l3dgw_port;\n\n    /* This is set to the \"derived\" chassis-redirect port of this port if and\n     * only if this port is a distributed gateway port. Otherwise this is set\n     * to NULL. */\n    struct ovn_port *cr_port;\n\n    bool has_unknown; /* If the addresses have 'unknown' defined. */\n\n    bool has_bfd;\n\n    /* The port's peer:\n     *\n     *     - A switch port S of type \"router\" has a router port R as a peer,\n     *       and R in turn has S has its peer.\n     *\n     *     - Two connected logical router ports have each other as peer.\n     *\n     *     - Other kinds of ports have no peer. */\n    struct ovn_port *peer;\n\n    struct ovn_datapath *od;\n\n    struct ovs_list list;       /* In list of similar records. */\n\n    struct ovs_list dp_node;\n};\n\nstatic bool\nis_l3dgw_port(const struct ovn_port *op)\n{\n    return op->cr_port;\n}\n\nstatic bool\nis_cr_port(const struct ovn_port *op)\n{\n    return op->l3dgw_port;\n}\n\nstatic void\ndestroy_routable_addresses(struct ovn_port_routable_addresses *ra)\n{\n    for (size_t i = 0; i < ra->n_addrs; i++) {\n        destroy_lport_addresses(&ra->laddrs[i]);\n    }\n    free(ra->laddrs);\n}\n\nstatic char **get_nat_addresses(const struct ovn_port *op, size_t *n,\n                                bool routable_only, bool include_lb_ips);\n\nstatic void\nassign_routable_addresses(struct ovn_port *op)\n{\n    size_t n;\n    char **nats = get_nat_addresses(op, &n, true, true);\n\n    if (!nats) {\n        return;\n    }\n\n    struct lport_addresses *laddrs = xcalloc(n, sizeof(*laddrs));\n    size_t n_addrs = 0;\n    for (size_t i = 0; i < n; i++) {\n        int ofs;\n        if (!extract_addresses(nats[i], &laddrs[n_addrs], &ofs)) {\n            free(nats[i]);\n            continue;\n        }\n        n_addrs++;\n        free(nats[i]);\n    }\n    free(nats);\n\n    /* Everything seems to have worked out */\n    op->routables.laddrs = laddrs;\n    op->routables.n_addrs = n_addrs;\n}\n\n\nstatic void\novn_port_set_nb(struct ovn_port *op,\n                const struct nbrec_logical_switch_port *nbsp,\n                const struct nbrec_logical_router_port *nbrp)\n{\n    op->nbsp = nbsp;\n    op->nbrp = nbrp;\n    init_mcast_port_info(&op->mcast_info, op->nbsp, op->nbrp);\n}\n\nstatic struct ovn_port *\novn_port_create(struct hmap *ports, const char *key,\n                const struct nbrec_logical_switch_port *nbsp,\n                const struct nbrec_logical_router_port *nbrp,\n                const struct sbrec_port_binding *sb)\n{\n    struct ovn_port *op = xzalloc(sizeof *op);\n\n    struct ds json_key = DS_EMPTY_INITIALIZER;\n    json_string_escape(key, &json_key);\n    op->json_key = ds_steal_cstr(&json_key);\n\n    op->key = xstrdup(key);\n    op->sb = sb;\n    ovn_port_set_nb(op, nbsp, nbrp);\n    op->l3dgw_port = op->cr_port = NULL;\n    hmap_insert(ports, &op->key_node, hash_string(op->key, 0));\n    return op;\n}\n\nstatic void\novn_port_destroy(struct hmap *ports, struct ovn_port *port)\n{\n    if (port) {\n        /* Don't remove port->list.  It is used within build_ports() as a\n         * private list and once we've exited that function it is not safe to\n         * use it. */\n        hmap_remove(ports, &port->key_node);\n\n        if (port->peer) {\n            port->peer->peer = NULL;\n        }\n\n        for (int i = 0; i < port->n_lsp_addrs; i++) {\n            destroy_lport_addresses(&port->lsp_addrs[i]);\n        }\n        free(port->lsp_addrs);\n\n        for (int i = 0; i < port->n_ps_addrs; i++) {\n            destroy_lport_addresses(&port->ps_addrs[i]);\n        }\n        free(port->ps_addrs);\n\n        destroy_routable_addresses(&port->routables);\n\n        destroy_lport_addresses(&port->lrp_networks);\n        free(port->json_key);\n        free(port->key);\n        free(port);\n    }\n}\n\n/* Returns the ovn_port that matches 'name'.  If 'prefer_bound' is true and\n * multiple ports share the same name, gives precendence to ports bound to\n * an ovn_datapath.\n */\nstatic struct ovn_port *\novn_port_find__(const struct hmap *ports, const char *name,\n                bool prefer_bound)\n{\n    struct ovn_port *matched_op = NULL;\n    struct ovn_port *op;\n\n    HMAP_FOR_EACH_WITH_HASH (op, key_node, hash_string(name, 0), ports) {\n        if (!strcmp(op->key, name)) {\n            matched_op = op;\n            if (!prefer_bound || op->od) {\n                return op;\n            }\n        }\n    }\n    return matched_op;\n}\n\nstatic struct ovn_port *\novn_port_find(const struct hmap *ports, const char *name)\n{\n    return ovn_port_find__(ports, name, false);\n}\n\nstatic struct ovn_port *\novn_port_find_bound(const struct hmap *ports, const char *name)\n{\n    return ovn_port_find__(ports, name, true);\n}\n\n/* Returns true if the logical switch port 'enabled' column is empty or\n * set to true.  Otherwise, returns false. */\nstatic bool\nlsp_is_enabled(const struct nbrec_logical_switch_port *lsp)\n{\n    return !lsp->n_enabled || *lsp->enabled;\n}\n\n/* Returns true only if the logical switch port 'up' column is set to true.\n * Otherwise, if the column is not set or set to false, returns false. */\nstatic bool\nlsp_is_up(const struct nbrec_logical_switch_port *lsp)\n{\n    return lsp->n_up && *lsp->up;\n}\n\nstatic bool\nlsp_is_external(const struct nbrec_logical_switch_port *nbsp)\n{\n    return !strcmp(nbsp->type, \"external\");\n}\n\nstatic bool\nlsp_is_router(const struct nbrec_logical_switch_port *nbsp)\n{\n    return !strcmp(nbsp->type, \"router\");\n}\n\nstatic bool\nlsp_is_remote(const struct nbrec_logical_switch_port *nbsp)\n{\n    return !strcmp(nbsp->type, \"remote\");\n}\n\nstatic bool\nlsp_is_localnet(const struct nbrec_logical_switch_port *nbsp)\n{\n    return !strcmp(nbsp->type, \"localnet\");\n}\n\nstatic bool\nlsp_is_vtep(const struct nbrec_logical_switch_port *nbsp)\n{\n    return !strcmp(nbsp->type, \"vtep\");\n}\n\nstatic bool\nlocalnet_can_learn_mac(const struct nbrec_logical_switch_port *nbsp)\n{\n    return smap_get_bool(&nbsp->options, \"localnet_learn_fdb\", false);\n}\n\nstatic bool\nlsp_is_type_changed(const struct sbrec_port_binding *sb,\n                const struct nbrec_logical_switch_port *nbsp,\n                bool *update_sbrec)\n{\n    *update_sbrec = false;\n    if (!sb || !nbsp) {\n        return false;\n    }\n\n    if (!sb->type[0] && !nbsp->type[0]) {\n        /* Two \"VIF's\" interface make sure both have parent_port\n         * set or both have parent_port unset, otherwisre they are\n         * different ports type.\n         */\n        if ((!sb->parent_port && nbsp->parent_name) ||\n                        (sb->parent_port && !nbsp->parent_name)) {\n            *update_sbrec = true;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /* Cover cases where port changed to/from virtual port */\n    if (!strcmp(sb->type, \"virtual\") ||\n                !strcmp(nbsp->type, \"virtual\")) {\n        *update_sbrec = true;\n    }\n\n    /* Both lports are not \"VIF's\" it is safe to use strcmp. */\n    if (sb->type[0] && nbsp->type[0]) {\n        return strcmp(sb->type, nbsp->type);\n    }\n\n    return true;\n}\n\nstatic bool\nlrport_is_enabled(const struct nbrec_logical_router_port *lrport)\n{\n    return !lrport->enabled || *lrport->enabled;\n}\n\nstatic struct ovn_port *\novn_port_get_peer(const struct hmap *ports, struct ovn_port *op)\n{\n    if (!op->nbsp || !lsp_is_router(op->nbsp) || op->l3dgw_port) {\n        return NULL;\n    }\n\n    if (op->peer) {\n        return op->peer;\n    }\n\n    const char *peer_name = smap_get(&op->nbsp->options, \"router-port\");\n    if (!peer_name) {\n        return NULL;\n    }\n\n    return ovn_port_find(ports, peer_name);\n}\n\nstatic void\nipam_insert_ip_for_datapath(struct ovn_datapath *od, uint32_t ip)\n{\n    if (!od) {\n        return;\n    }\n\n    ipam_insert_ip(&od->ipam_info, ip);\n}\n\nstatic void\nipam_insert_lsp_addresses(struct ovn_datapath *od,\n                          struct lport_addresses *laddrs)\n{\n    ipam_insert_mac(&laddrs->ea, true);\n\n    /* IP is only added to IPAM if the switch's subnet option\n     * is set, whereas MAC is always added to MACAM. */\n    if (!od->ipam_info.allocated_ipv4s) {\n        return;\n    }\n\n    for (size_t j = 0; j < laddrs->n_ipv4_addrs; j++) {\n        uint32_t ip = ntohl(laddrs->ipv4_addrs[j].addr);\n        ipam_insert_ip_for_datapath(od, ip);\n    }\n}\n\nstatic void\nipam_add_port_addresses(struct ovn_datapath *od, struct ovn_port *op)\n{\n    if (!od || !op) {\n        return;\n    }\n\n    if (op->n_lsp_non_router_addrs) {\n        /* Add all the port's addresses to address data structures. */\n        for (size_t i = 0; i < op->n_lsp_non_router_addrs; i++) {\n            ipam_insert_lsp_addresses(od, &op->lsp_addrs[i]);\n        }\n    } else if (op->lrp_networks.ea_s[0]) {\n        ipam_insert_mac(&op->lrp_networks.ea, true);\n\n        if (!op->peer || !op->peer->nbsp || !op->peer->od || !op->peer->od->nbs\n            || !smap_get(&op->peer->od->nbs->other_config, \"subnet\")) {\n            return;\n        }\n\n        for (size_t i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            uint32_t ip = ntohl(op->lrp_networks.ipv4_addrs[i].addr);\n            /* If the router has the first IP address of the subnet, don't add\n             * it to IPAM. We already added this when we initialized IPAM for\n             * the datapath. This will just result in an erroneous message\n             * about a duplicate IP address.\n             */\n            if (ip != op->peer->od->ipam_info.start_ipv4) {\n                ipam_insert_ip_for_datapath(op->peer->od, ip);\n            }\n        }\n    }\n}\n\nstatic const char *find_lrp_member_ip(const struct ovn_port *op,\n                                      const char *ip_s);\n\n/* Returns true if the given router port 'op' (assumed to be a distributed\n * gateway port) is the relevant DGP where the NAT rule of the router needs to\n * be applied. */\nstatic bool\nis_nat_gateway_port(const struct nbrec_nat *nat, const struct ovn_port *op)\n{\n    if (op->od->n_l3dgw_ports > 1\n        && ((!nat->gateway_port && !find_lrp_member_ip(op, nat->external_ip))\n            || (nat->gateway_port && nat->gateway_port != op->nbrp))) {\n        return false;\n    }\n    return true;\n}\n\nenum dynamic_update_type {\n    NONE,    /* No change to the address */\n    REMOVE,  /* Address is no longer dynamic */\n    STATIC,  /* Use static address (MAC only) */\n    DYNAMIC, /* Assign a new dynamic address */\n};\n\nstruct dynamic_address_update {\n    struct ovs_list node;       /* In build_ipam()'s list of updates. */\n\n    struct ovn_datapath *od;\n    struct ovn_port *op;\n\n    struct lport_addresses current_addresses;\n    struct eth_addr static_mac;\n    ovs_be32 static_ip;\n    struct in6_addr static_ipv6;\n    enum dynamic_update_type mac;\n    enum dynamic_update_type ipv4;\n    enum dynamic_update_type ipv6;\n};\n\nstatic enum dynamic_update_type\ndynamic_mac_changed(const char *lsp_addresses,\n                    struct dynamic_address_update *update)\n{\n   struct eth_addr ea;\n\n   if (ovs_scan(lsp_addresses, ETH_ADDR_SCAN_FMT, ETH_ADDR_SCAN_ARGS(ea))) {\n       if (eth_addr_equals(ea, update->current_addresses.ea)) {\n           return NONE;\n       } else {\n           /* MAC is still static, but it has changed */\n           update->static_mac = ea;\n           return STATIC;\n       }\n   }\n\n   uint64_t mac64 = eth_addr_to_uint64(update->current_addresses.ea);\n   uint64_t prefix = eth_addr_to_uint64(get_mac_prefix());\n\n   if ((mac64 ^ prefix) >> 24) {\n       return DYNAMIC;\n   } else {\n       return NONE;\n   }\n}\n\nstatic enum dynamic_update_type\ndynamic_ip4_changed(const char *lsp_addrs,\n                    struct dynamic_address_update *update)\n{\n    const struct ipam_info *ipam = &update->op->od->ipam_info;\n    const struct lport_addresses *cur_addresses = &update->current_addresses;\n    bool dynamic_ip4 = ipam->allocated_ipv4s != NULL;\n\n    if (!dynamic_ip4) {\n        if (update->current_addresses.n_ipv4_addrs) {\n            return REMOVE;\n        } else {\n            return NONE;\n        }\n    }\n\n    if (!cur_addresses->n_ipv4_addrs) {\n        /* IPv4 was previously static but now is dynamic */\n        return DYNAMIC;\n    }\n\n    uint32_t ip4 = ntohl(cur_addresses->ipv4_addrs[0].addr);\n    if (ip4 < ipam->start_ipv4) {\n        return DYNAMIC;\n    }\n\n    uint32_t index = ip4 - ipam->start_ipv4;\n    if (index >= ipam->total_ipv4s - 1 ||\n        bitmap_is_set(ipam->allocated_ipv4s, index)) {\n        /* Previously assigned dynamic IPv4 address can no longer be used.\n         * It's either outside the subnet, conflicts with an excluded IP,\n         * or conflicts with a statically-assigned address on the switch\n         */\n        return DYNAMIC;\n    } else {\n        char ipv6_s[IPV6_SCAN_LEN + 1];\n        ovs_be32 new_ip;\n        int n = 0;\n\n        if ((ovs_scan(lsp_addrs, \"dynamic \"IP_SCAN_FMT\"%n\",\n                     IP_SCAN_ARGS(&new_ip), &n)\n             && lsp_addrs[n] == '\\0') ||\n            (ovs_scan(lsp_addrs, \"dynamic \"IP_SCAN_FMT\" \"IPV6_SCAN_FMT\"%n\",\n                      IP_SCAN_ARGS(&new_ip), ipv6_s, &n)\n             && lsp_addrs[n] == '\\0')) {\n            index = ntohl(new_ip) - ipam->start_ipv4;\n            if (ntohl(new_ip) < ipam->start_ipv4 ||\n                index > ipam->total_ipv4s ||\n                bitmap_is_set(ipam->allocated_ipv4s, index)) {\n                /* new static ip is not valid */\n                return DYNAMIC;\n            } else if (cur_addresses->ipv4_addrs[0].addr != new_ip) {\n                update->ipv4 = STATIC;\n                update->static_ip = new_ip;\n                return STATIC;\n            }\n        }\n        return NONE;\n    }\n}\n\nstatic enum dynamic_update_type\ndynamic_ip6_changed(const char *lsp_addrs,\n                    struct dynamic_address_update *update)\n{\n    bool dynamic_ip6 = update->op->od->ipam_info.ipv6_prefix_set;\n    struct eth_addr ea;\n\n    if (!dynamic_ip6) {\n        if (update->current_addresses.n_ipv6_addrs) {\n            /* IPv6 was dynamic but now is not */\n            return REMOVE;\n        } else {\n            /* IPv6 has never been dynamic */\n            return NONE;\n        }\n    }\n\n    if (!update->current_addresses.n_ipv6_addrs ||\n        ovs_scan(lsp_addrs, ETH_ADDR_SCAN_FMT, ETH_ADDR_SCAN_ARGS(ea))) {\n        /* IPv6 was previously static but now is dynamic */\n        return DYNAMIC;\n    }\n\n    const struct lport_addresses *cur_addresses;\n    char ipv6_s[IPV6_SCAN_LEN + 1];\n    ovs_be32 new_ip;\n    int n = 0;\n\n    if ((ovs_scan(lsp_addrs, \"dynamic \"IPV6_SCAN_FMT\"%n\",\n                  ipv6_s, &n) && lsp_addrs[n] == '\\0') ||\n        (ovs_scan(lsp_addrs, \"dynamic \"IP_SCAN_FMT\" \"IPV6_SCAN_FMT\"%n\",\n                  IP_SCAN_ARGS(&new_ip), ipv6_s, &n)\n         && lsp_addrs[n] == '\\0')) {\n        struct in6_addr ipv6;\n\n        if (!ipv6_parse(ipv6_s, &ipv6)) {\n            return DYNAMIC;\n        }\n\n        struct in6_addr masked = ipv6_addr_bitand(&ipv6,\n                &update->op->od->ipam_info.ipv6_prefix);\n        if (!IN6_ARE_ADDR_EQUAL(&masked,\n                                &update->op->od->ipam_info.ipv6_prefix)) {\n            return DYNAMIC;\n        }\n\n        cur_addresses = &update->current_addresses;\n\n        if (!IN6_ARE_ADDR_EQUAL(&cur_addresses->ipv6_addrs[0].addr,\n                                &ipv6)) {\n            update->static_ipv6 = ipv6;\n            return STATIC;\n        }\n    } else if (update->mac != NONE) {\n        return DYNAMIC;\n    }\n\n    return NONE;\n}\n\n/* Check previously assigned dynamic addresses for validity. This will\n * check if the assigned addresses need to change.\n *\n * Returns true if any changes to dynamic addresses are required\n */\nstatic bool\ndynamic_addresses_check_for_updates(const char *lsp_addrs,\n                                    struct dynamic_address_update *update)\n{\n    update->mac = dynamic_mac_changed(lsp_addrs, update);\n    update->ipv4 = dynamic_ip4_changed(lsp_addrs, update);\n    update->ipv6 = dynamic_ip6_changed(lsp_addrs, update);\n    if (update->mac == NONE &&\n        update->ipv4 == NONE &&\n        update->ipv6 == NONE) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n/* For addresses that do not need to be updated, go ahead and insert them\n * into IPAM. This way, their addresses will be claimed and cannot be assigned\n * elsewhere later.\n */\nstatic void\nupdate_unchanged_dynamic_addresses(struct dynamic_address_update *update)\n{\n    if (update->mac == NONE) {\n        ipam_insert_mac(&update->current_addresses.ea, false);\n    }\n    if (update->ipv4 == NONE && update->current_addresses.n_ipv4_addrs) {\n        ipam_insert_ip_for_datapath(update->op->od,\n                       ntohl(update->current_addresses.ipv4_addrs[0].addr));\n    }\n}\n\nstatic void\nset_lsp_dynamic_addresses(const char *dynamic_addresses, struct ovn_port *op)\n{\n    extract_lsp_addresses(dynamic_addresses, &op->lsp_addrs[op->n_lsp_addrs]);\n    op->n_lsp_addrs++;\n}\n\n/* Determines which components (MAC, IPv4, and IPv6) of dynamic\n * addresses need to be assigned. This is used exclusively for\n * ports that do not have dynamic addresses already assigned.\n */\nstatic void\nset_dynamic_updates(const char *addrspec,\n                    struct dynamic_address_update *update)\n{\n    bool has_ipv4 = false, has_ipv6 = false;\n    char ipv6_s[IPV6_SCAN_LEN + 1];\n    struct eth_addr mac;\n    ovs_be32 ip;\n    int n = 0;\n    if (ovs_scan(addrspec, ETH_ADDR_SCAN_FMT\" dynamic%n\",\n                 ETH_ADDR_SCAN_ARGS(mac), &n)\n        && addrspec[n] == '\\0') {\n        update->mac = STATIC;\n        update->static_mac = mac;\n    } else {\n        update->mac = DYNAMIC;\n    }\n\n    if ((ovs_scan(addrspec, \"dynamic \"IP_SCAN_FMT\"%n\",\n                 IP_SCAN_ARGS(&ip), &n) && addrspec[n] == '\\0')) {\n        has_ipv4 = true;\n    } else if ((ovs_scan(addrspec, \"dynamic \"IPV6_SCAN_FMT\"%n\",\n                         ipv6_s, &n) && addrspec[n] == '\\0')) {\n        has_ipv6 = true;\n    } else if ((ovs_scan(addrspec, \"dynamic \"IP_SCAN_FMT\" \"IPV6_SCAN_FMT\"%n\",\n                         IP_SCAN_ARGS(&ip), ipv6_s, &n)\n               && addrspec[n] == '\\0')) {\n        has_ipv4 = has_ipv6 = true;\n    }\n\n    if (has_ipv4) {\n        update->ipv4 = STATIC;\n        update->static_ip = ip;\n    } else if (update->op->od->ipam_info.allocated_ipv4s) {\n        update->ipv4 = DYNAMIC;\n    } else {\n        update->ipv4 = NONE;\n    }\n\n    if (has_ipv6 && ipv6_parse(ipv6_s, &update->static_ipv6)) {\n        update->ipv6 = STATIC;\n    } else if (update->op->od->ipam_info.ipv6_prefix_set) {\n        update->ipv6 = DYNAMIC;\n    } else {\n        update->ipv6 = NONE;\n    }\n}\n\nstatic void\nupdate_dynamic_addresses(struct dynamic_address_update *update)\n{\n    ovs_be32 ip4 = 0;\n    switch (update->ipv4) {\n    case NONE:\n        if (update->current_addresses.n_ipv4_addrs) {\n            ip4 = update->current_addresses.ipv4_addrs[0].addr;\n        }\n        break;\n    case REMOVE:\n        break;\n    case STATIC:\n        ip4 = update->static_ip;\n        break;\n    case DYNAMIC:\n        ip4 = htonl(ipam_get_unused_ip(&update->od->ipam_info));\n        VLOG_INFO(\"Assigned dynamic IPv4 address '\"IP_FMT\"' to port '%s'\",\n                  IP_ARGS(ip4), update->op->nbsp->name);\n    }\n\n    struct eth_addr mac;\n    switch (update->mac) {\n    case NONE:\n        mac = update->current_addresses.ea;\n        break;\n    case REMOVE:\n        OVS_NOT_REACHED();\n    case STATIC:\n        mac = update->static_mac;\n        break;\n    case DYNAMIC:\n        eth_addr_from_uint64(ipam_get_unused_mac(ip4), &mac);\n        VLOG_INFO(\"Assigned dynamic MAC address '\"ETH_ADDR_FMT\"' to port '%s'\",\n                  ETH_ADDR_ARGS(mac), update->op->nbsp->name);\n        break;\n    }\n\n    struct in6_addr ip6 = in6addr_any;\n    switch (update->ipv6) {\n    case NONE:\n        if (update->current_addresses.n_ipv6_addrs) {\n            ip6 = update->current_addresses.ipv6_addrs[0].addr;\n        }\n        break;\n    case REMOVE:\n        break;\n    case STATIC:\n        ip6 = update->static_ipv6;\n        break;\n    case DYNAMIC:\n        in6_generate_eui64(mac, &update->od->ipam_info.ipv6_prefix, &ip6);\n        struct ds ip6_ds = DS_EMPTY_INITIALIZER;\n        ipv6_format_addr(&ip6, &ip6_ds);\n        VLOG_INFO(\"Assigned dynamic IPv6 address '%s' to port '%s'\",\n                  ip6_ds.string, update->op->nbsp->name);\n        ds_destroy(&ip6_ds);\n        break;\n    }\n\n    struct ds new_addr = DS_EMPTY_INITIALIZER;\n    ds_put_format(&new_addr, ETH_ADDR_FMT, ETH_ADDR_ARGS(mac));\n    ipam_insert_mac(&mac, true);\n\n    if (ip4) {\n        ipam_insert_ip_for_datapath(update->od, ntohl(ip4));\n        ds_put_format(&new_addr, \" \"IP_FMT, IP_ARGS(ip4));\n    }\n    if (!IN6_ARE_ADDR_EQUAL(&ip6, &in6addr_any)) {\n        char ip6_s[INET6_ADDRSTRLEN + 1];\n        ipv6_string_mapped(ip6_s, &ip6);\n        ds_put_format(&new_addr, \" %s\", ip6_s);\n    }\n    nbrec_logical_switch_port_set_dynamic_addresses(update->op->nbsp,\n                                                    ds_cstr(&new_addr));\n    set_lsp_dynamic_addresses(ds_cstr(&new_addr), update->op);\n    ds_destroy(&new_addr);\n}\n\nstatic void\nbuild_ipam(struct hmap *datapaths, struct hmap *ports)\n{\n    /* IPAM generally stands for IP address management.  In non-virtualized\n     * world, MAC addresses come with the hardware.  But, with virtualized\n     * workloads, they need to be assigned and managed.  This function\n     * does both IP address management (ipam) and MAC address management\n     * (macam). */\n\n    /* If the switch's other_config:subnet is set, allocate new addresses for\n     * ports that have the \"dynamic\" keyword in their addresses column. */\n    struct ovn_datapath *od;\n    struct ovs_list updates;\n\n    ovs_list_init(&updates);\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs) {\n            continue;\n        }\n\n        for (size_t i = 0; i < od->nbs->n_ports; i++) {\n            const struct nbrec_logical_switch_port *nbsp = od->nbs->ports[i];\n\n            if (!od->ipam_info.allocated_ipv4s &&\n                !od->ipam_info.ipv6_prefix_set &&\n                !od->ipam_info.mac_only) {\n                if (nbsp->dynamic_addresses) {\n                    nbrec_logical_switch_port_set_dynamic_addresses(nbsp,\n                                                                    NULL);\n                }\n                continue;\n            }\n\n            struct ovn_port *op = ovn_port_find(ports, nbsp->name);\n            if (!op || op->nbsp != nbsp || op->peer) {\n                /* Do not allocate addresses for logical switch ports that\n                 * have a peer. */\n                continue;\n            }\n\n            int num_dynamic_addresses = 0;\n            for (size_t j = 0; j < nbsp->n_addresses; j++) {\n                if (!is_dynamic_lsp_address(nbsp->addresses[j])) {\n                    continue;\n                }\n                if (num_dynamic_addresses) {\n                    static struct vlog_rate_limit rl\n                        = VLOG_RATE_LIMIT_INIT(1, 1);\n                    VLOG_WARN_RL(&rl, \"More than one dynamic address \"\n                                 \"configured for logical switch port '%s'\",\n                                 nbsp->name);\n                    continue;\n                }\n                num_dynamic_addresses++;\n                struct dynamic_address_update *update\n                    = xzalloc(sizeof *update);\n                update->op = op;\n                update->od = od;\n                if (nbsp->dynamic_addresses) {\n                    bool any_changed;\n                    extract_lsp_addresses(nbsp->dynamic_addresses,\n                                          &update->current_addresses);\n                    any_changed = dynamic_addresses_check_for_updates(\n                        nbsp->addresses[j], update);\n                    update_unchanged_dynamic_addresses(update);\n                    if (any_changed) {\n                        ovs_list_push_back(&updates, &update->node);\n                    } else {\n                        /* No changes to dynamic addresses */\n                        set_lsp_dynamic_addresses(nbsp->dynamic_addresses, op);\n                        destroy_lport_addresses(&update->current_addresses);\n                        free(update);\n                    }\n                } else {\n                    set_dynamic_updates(nbsp->addresses[j], update);\n                    ovs_list_push_back(&updates, &update->node);\n                }\n            }\n\n            if (!num_dynamic_addresses && nbsp->dynamic_addresses) {\n                nbrec_logical_switch_port_set_dynamic_addresses(nbsp, NULL);\n            }\n        }\n\n    }\n\n    /* After retaining all unchanged dynamic addresses, now assign\n     * new ones.\n     */\n    struct dynamic_address_update *update;\n    LIST_FOR_EACH_POP (update, node, &updates) {\n        update_dynamic_addresses(update);\n        destroy_lport_addresses(&update->current_addresses);\n        free(update);\n    }\n}\n\f\n/* Tag allocation for nested containers.\n *\n * For a logical switch port with 'parent_name' and a request to allocate tags,\n * keeps a track of all allocated tags. */\nstruct tag_alloc_node {\n    struct hmap_node hmap_node;\n    char *parent_name;\n    unsigned long *allocated_tags;  /* A bitmap to track allocated tags. */\n};\n\nstatic void\ntag_alloc_destroy(struct hmap *tag_alloc_table)\n{\n    struct tag_alloc_node *node;\n    HMAP_FOR_EACH_POP (node, hmap_node, tag_alloc_table) {\n        bitmap_free(node->allocated_tags);\n        free(node->parent_name);\n        free(node);\n    }\n    hmap_destroy(tag_alloc_table);\n}\n\nstatic struct tag_alloc_node *\ntag_alloc_get_node(struct hmap *tag_alloc_table, const char *parent_name)\n{\n    /* If a node for the 'parent_name' exists, return it. */\n    struct tag_alloc_node *tag_alloc_node;\n    HMAP_FOR_EACH_WITH_HASH (tag_alloc_node, hmap_node,\n                             hash_string(parent_name, 0),\n                             tag_alloc_table) {\n        if (!strcmp(tag_alloc_node->parent_name, parent_name)) {\n            return tag_alloc_node;\n        }\n    }\n\n    /* Create a new node. */\n    tag_alloc_node = xmalloc(sizeof *tag_alloc_node);\n    tag_alloc_node->parent_name = xstrdup(parent_name);\n    tag_alloc_node->allocated_tags = bitmap_allocate(MAX_OVN_TAGS);\n    /* Tag 0 is invalid for nested containers. */\n    bitmap_set1(tag_alloc_node->allocated_tags, 0);\n    hmap_insert(tag_alloc_table, &tag_alloc_node->hmap_node,\n                hash_string(parent_name, 0));\n\n    return tag_alloc_node;\n}\n\nstatic void\ntag_alloc_add_existing_tags(struct hmap *tag_alloc_table,\n                            const struct nbrec_logical_switch_port *nbsp)\n{\n    /* Add the tags of already existing nested containers.  If there is no\n     * 'nbsp->parent_name' or no 'nbsp->tag' set, there is nothing to do. */\n    if (!nbsp->parent_name || !nbsp->parent_name[0] || !nbsp->tag) {\n        return;\n    }\n\n    struct tag_alloc_node *tag_alloc_node;\n    tag_alloc_node = tag_alloc_get_node(tag_alloc_table, nbsp->parent_name);\n    bitmap_set1(tag_alloc_node->allocated_tags, *nbsp->tag);\n}\n\nstatic void\ntag_alloc_create_new_tag(struct hmap *tag_alloc_table,\n                         const struct nbrec_logical_switch_port *nbsp)\n{\n    if (!nbsp->tag_request) {\n        return;\n    }\n\n    if (nbsp->parent_name && nbsp->parent_name[0]\n        && *nbsp->tag_request == 0) {\n        /* For nested containers that need allocation, do the allocation. */\n\n        if (nbsp->tag) {\n            /* This has already been allocated. */\n            return;\n        }\n\n        struct tag_alloc_node *tag_alloc_node;\n        int64_t tag;\n        tag_alloc_node = tag_alloc_get_node(tag_alloc_table,\n                                            nbsp->parent_name);\n        tag = bitmap_scan(tag_alloc_node->allocated_tags, 0, 1, MAX_OVN_TAGS);\n        if (tag == MAX_OVN_TAGS) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_ERR_RL(&rl, \"out of vlans for logical switch ports with \"\n                        \"parent %s\", nbsp->parent_name);\n            return;\n        }\n        bitmap_set1(tag_alloc_node->allocated_tags, tag);\n        nbrec_logical_switch_port_set_tag(nbsp, &tag, 1);\n    } else if (*nbsp->tag_request != 0) {\n        /* For everything else, copy the contents of 'tag_request' to 'tag'. */\n        nbrec_logical_switch_port_set_tag(nbsp, nbsp->tag_request, 1);\n    }\n}\n\f\n\nstatic void\njoin_logical_ports(struct northd_input *input_data,\n                   struct hmap *datapaths, struct hmap *ports,\n                   struct hmap *chassis_qdisc_queues,\n                   struct hmap *tag_alloc_table, struct ovs_list *sb_only,\n                   struct ovs_list *nb_only, struct ovs_list *both)\n{\n    ovs_list_init(sb_only);\n    ovs_list_init(nb_only);\n    ovs_list_init(both);\n\n    const struct sbrec_port_binding *sb;\n    SBREC_PORT_BINDING_TABLE_FOR_EACH (sb,\n                                 input_data->sbrec_port_binding_table) {\n        struct ovn_port *op = ovn_port_create(ports, sb->logical_port,\n                                              NULL, NULL, sb);\n        ovs_list_push_back(sb_only, &op->list);\n    }\n\n    struct ovn_datapath *od;\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (od->nbs) {\n            size_t n_allocated_localnet_ports = 0;\n            for (size_t i = 0; i < od->nbs->n_ports; i++) {\n                const struct nbrec_logical_switch_port *nbsp\n                    = od->nbs->ports[i];\n                struct ovn_port *op = ovn_port_find_bound(ports, nbsp->name);\n                if (op && (op->od || op->nbsp || op->nbrp)) {\n                    static struct vlog_rate_limit rl\n                        = VLOG_RATE_LIMIT_INIT(5, 1);\n                    VLOG_WARN_RL(&rl, \"duplicate logical port %s\", nbsp->name);\n                    continue;\n                } else if (op && (!op->sb || op->sb->datapath == od->sb)) {\n                    /*\n                     * Handle cases where lport type was explicitly changed\n                     * in the NBDB, in such cases:\n                     * 1. remove the current sbrec of the affected lport from\n                     *    the port_binding table.\n                     *\n                     * 2. create a new sbrec with the same logical_port as the\n                     *    deleted lport and add it to the nb_only list which\n                     *    will make the northd handle this lport as a new\n                     *    created one and recompute everything that is needed\n                     *    for this lport.\n                     *\n                     * This change will affect container/virtual lport type\n                     * changes only for now, this change is needed in\n                     * contaier/virtual lport cases to avoid port type\n                     * conflicts in the ovn-controller when the user clears\n                     * the parent_port field in the container lport or updated\n                     * the lport type.\n                     *\n                     */\n                    bool update_sbrec = false;\n                    if (op->sb && lsp_is_type_changed(op->sb, nbsp,\n                                                      &update_sbrec)\n                                   && update_sbrec) {\n                        ovs_list_remove(&op->list);\n                        sbrec_port_binding_delete(op->sb);\n                        ovn_port_destroy(ports, op);\n                        op = ovn_port_create(ports, nbsp->name, nbsp,\n                                             NULL, NULL);\n                        ovs_list_push_back(nb_only, &op->list);\n                    } else {\n                        ovn_port_set_nb(op, nbsp, NULL);\n                        ovs_list_remove(&op->list);\n\n                        uint32_t queue_id = smap_get_int(&op->sb->options,\n                                                         \"qdisc_queue_id\", 0);\n                        if (queue_id && op->sb->chassis) {\n                            add_chassis_queue(\n                                 chassis_qdisc_queues,\n                                 &op->sb->chassis->header_.uuid,\n                                 queue_id);\n                        }\n\n                        ovs_list_push_back(both, &op->list);\n\n                        /* This port exists due to a SB binding, but should\n                         * not have been initialized fully. */\n                        ovs_assert(!op->n_lsp_addrs && !op->n_ps_addrs);\n                    }\n                } else {\n                    op = ovn_port_create(ports, nbsp->name, nbsp, NULL, NULL);\n                    ovs_list_push_back(nb_only, &op->list);\n                }\n\n                if (lsp_is_localnet(nbsp)) {\n                   if (od->n_localnet_ports >= n_allocated_localnet_ports) {\n                       od->localnet_ports = x2nrealloc(\n                           od->localnet_ports, &n_allocated_localnet_ports,\n                           sizeof *od->localnet_ports);\n                   }\n                   od->localnet_ports[od->n_localnet_ports++] = op;\n                }\n\n                if (lsp_is_vtep(nbsp)) {\n                    od->has_vtep_lports = true;\n                }\n\n                op->lsp_addrs\n                    = xmalloc(sizeof *op->lsp_addrs * nbsp->n_addresses);\n                for (size_t j = 0; j < nbsp->n_addresses; j++) {\n                    if (!strcmp(nbsp->addresses[j], \"unknown\")) {\n                        op->has_unknown = true;\n                        continue;\n                    }\n                    if (!strcmp(nbsp->addresses[j], \"router\")) {\n                        continue;\n                    }\n                    if (is_dynamic_lsp_address(nbsp->addresses[j])) {\n                        continue;\n                    } else if (!extract_lsp_addresses(nbsp->addresses[j],\n                                           &op->lsp_addrs[op->n_lsp_addrs])) {\n                        static struct vlog_rate_limit rl\n                            = VLOG_RATE_LIMIT_INIT(1, 1);\n                        VLOG_INFO_RL(&rl, \"invalid syntax '%s' in logical \"\n                                          \"switch port addresses. No MAC \"\n                                          \"address found\",\n                                          op->nbsp->addresses[j]);\n                        continue;\n                    }\n                    op->n_lsp_addrs++;\n                }\n                op->n_lsp_non_router_addrs = op->n_lsp_addrs;\n\n                op->ps_addrs\n                    = xmalloc(sizeof *op->ps_addrs * nbsp->n_port_security);\n                for (size_t j = 0; j < nbsp->n_port_security; j++) {\n                    if (!extract_lsp_addresses(nbsp->port_security[j],\n                                               &op->ps_addrs[op->n_ps_addrs])) {\n                        static struct vlog_rate_limit rl\n                            = VLOG_RATE_LIMIT_INIT(1, 1);\n                        VLOG_INFO_RL(&rl, \"invalid syntax '%s' in port \"\n                                          \"security. No MAC address found\",\n                                          op->nbsp->port_security[j]);\n                        continue;\n                    }\n                    op->n_ps_addrs++;\n                }\n\n                op->od = od;\n                ovs_list_push_back(&od->port_list, &op->dp_node);\n                tag_alloc_add_existing_tags(tag_alloc_table, nbsp);\n            }\n        } else {\n            size_t n_allocated_l3dgw_ports = 0;\n            for (size_t i = 0; i < od->nbr->n_ports; i++) {\n                const struct nbrec_logical_router_port *nbrp\n                    = od->nbr->ports[i];\n\n                struct lport_addresses lrp_networks;\n                if (!extract_lrp_networks(nbrp, &lrp_networks)) {\n                    static struct vlog_rate_limit rl\n                        = VLOG_RATE_LIMIT_INIT(5, 1);\n                    VLOG_WARN_RL(&rl, \"bad 'mac' %s\", nbrp->mac);\n                    continue;\n                }\n\n                if (!lrp_networks.n_ipv4_addrs && !lrp_networks.n_ipv6_addrs) {\n                    continue;\n                }\n\n                struct ovn_port *op = ovn_port_find_bound(ports, nbrp->name);\n                if (op && (op->od || op->nbsp || op->nbrp)) {\n                    static struct vlog_rate_limit rl\n                        = VLOG_RATE_LIMIT_INIT(5, 1);\n                    VLOG_WARN_RL(&rl, \"duplicate logical router port %s\",\n                                 nbrp->name);\n                    destroy_lport_addresses(&lrp_networks);\n                    continue;\n                } else if (op && (!op->sb || op->sb->datapath == od->sb)) {\n                    ovn_port_set_nb(op, NULL, nbrp);\n                    ovs_list_remove(&op->list);\n                    ovs_list_push_back(both, &op->list);\n\n                    /* This port exists but should not have been\n                     * initialized fully. */\n                    ovs_assert(!op->lrp_networks.n_ipv4_addrs\n                               && !op->lrp_networks.n_ipv6_addrs);\n                } else {\n                    op = ovn_port_create(ports, nbrp->name, NULL, nbrp, NULL);\n                    ovs_list_push_back(nb_only, &op->list);\n                }\n\n                op->lrp_networks = lrp_networks;\n                op->od = od;\n                ovs_list_push_back(&od->port_list, &op->dp_node);\n\n                if (!od->redirect_bridged) {\n                    const char *redirect_type =\n                        smap_get(&nbrp->options, \"redirect-type\");\n                    od->redirect_bridged =\n                        redirect_type && !strcasecmp(redirect_type, \"bridged\");\n                }\n\n                if (op->nbrp->ha_chassis_group ||\n                    op->nbrp->n_gateway_chassis) {\n                    /* Additional \"derived\" ovn_port crp represents the\n                     * instance of op on the gateway chassis. */\n                    const char *gw_chassis = smap_get(&op->od->nbr->options,\n                                                   \"chassis\");\n                    if (gw_chassis) {\n                        static struct vlog_rate_limit rl\n                            = VLOG_RATE_LIMIT_INIT(1, 1);\n                        VLOG_WARN_RL(&rl, \"Bad configuration: distributed \"\n                                     \"gateway port configured on port %s \"\n                                     \"on L3 gateway router\", nbrp->name);\n                        continue;\n                    }\n\n                    char *redirect_name =\n                        ovn_chassis_redirect_name(nbrp->name);\n                    struct ovn_port *crp = ovn_port_find(ports, redirect_name);\n                    if (crp && crp->sb && crp->sb->datapath == od->sb) {\n                        ovn_port_set_nb(crp, NULL, nbrp);\n                        ovs_list_remove(&crp->list);\n                        ovs_list_push_back(both, &crp->list);\n                    } else {\n                        crp = ovn_port_create(ports, redirect_name,\n                                              NULL, nbrp, NULL);\n                        ovs_list_push_back(nb_only, &crp->list);\n                    }\n                    crp->l3dgw_port = op;\n                    op->cr_port = crp;\n                    crp->od = od;\n                    free(redirect_name);\n\n                    /* Add to l3dgw_ports in od, for later use during flow\n                     * creation. */\n                    if (od->n_l3dgw_ports == n_allocated_l3dgw_ports) {\n                        od->l3dgw_ports = x2nrealloc(od->l3dgw_ports,\n                                                     &n_allocated_l3dgw_ports,\n                                                     sizeof *od->l3dgw_ports);\n                    }\n                    od->l3dgw_ports[od->n_l3dgw_ports++] = op;\n\n                    assign_routable_addresses(op);\n                }\n            }\n        }\n    }\n\n    /* Connect logical router ports, and logical switch ports of type \"router\",\n     * to their peers. */\n    struct ovn_port *op;\n    HMAP_FOR_EACH (op, key_node, ports) {\n        if (op->nbsp && lsp_is_router(op->nbsp) && !op->l3dgw_port) {\n            struct ovn_port *peer = ovn_port_get_peer(ports, op);\n            if (!peer || !peer->nbrp) {\n                continue;\n            }\n\n            ovn_datapath_add_router_port(op->od, op);\n            ovn_datapath_add_ls_peer(peer->od, op->od);\n            peer->peer = op;\n            op->peer = peer;\n\n            /* Fill op->lsp_addrs for op->nbsp->addresses[] with\n             * contents \"router\", which was skipped in the loop above. */\n            for (size_t j = 0; j < op->nbsp->n_addresses; j++) {\n                if (!strcmp(op->nbsp->addresses[j], \"router\")) {\n                    if (extract_lrp_networks(peer->nbrp,\n                                            &op->lsp_addrs[op->n_lsp_addrs])) {\n                        op->n_lsp_addrs++;\n                    }\n                    break;\n                }\n            }\n\n            /* If the router is multicast enabled then set relay on the switch\n             * datapath.\n             */\n            if (peer->od && peer->od->mcast_info.rtr.relay) {\n                op->od->mcast_info.sw.flood_relay = true;\n            }\n        } else if (op->nbrp && op->nbrp->peer && !op->l3dgw_port) {\n            struct ovn_port *peer = ovn_port_find(ports, op->nbrp->peer);\n            if (peer) {\n                if (peer->nbrp) {\n                    op->peer = peer;\n                } else if (peer->nbsp) {\n                    /* An ovn_port for a switch port of type \"router\" does have\n                     * a router port as its peer (see the case above for\n                     * \"router\" ports), but this is set via options:router-port\n                     * in Logical_Switch_Port and does not involve the\n                     * Logical_Router_Port's 'peer' column. */\n                    static struct vlog_rate_limit rl =\n                            VLOG_RATE_LIMIT_INIT(5, 1);\n                    VLOG_WARN_RL(&rl, \"Bad configuration: The peer of router \"\n                                 \"port %s is a switch port\", op->key);\n                }\n            }\n        }\n    }\n\n    /* Wait until all ports have been connected to add to IPAM since\n     * it relies on proper peers to be set\n     */\n    HMAP_FOR_EACH (op, key_node, ports) {\n        ipam_add_port_addresses(op->od, op);\n    }\n}\n\n/* Returns an array of strings, each consisting of a MAC address followed\n * by one or more IP addresses, and if the port is a distributed gateway\n * port, followed by 'is_chassis_resident(\"LPORT_NAME\")', where the\n * LPORT_NAME is the name of the L3 redirect port or the name of the\n * logical_port specified in a NAT rule. These strings include the\n * external IP addresses of NAT rules defined on that router whose\n * gateway_port is router port 'op', and all of the IP addresses used in\n * load balancer VIPs defined on that router.\n *\n * The caller must free each of the n returned strings with free(),\n * and must free the returned array when it is no longer needed. */\nstatic char **\nget_nat_addresses(const struct ovn_port *op, size_t *n, bool routable_only,\n                  bool include_lb_ips)\n{\n    size_t n_nats = 0;\n    struct eth_addr mac;\n    if (!op || !op->nbrp || !op->od || !op->od->nbr\n        || (!op->od->nbr->n_nat && !op->od->has_lb_vip)\n        || !eth_addr_from_string(op->nbrp->mac, &mac)) {\n        *n = n_nats;\n        return NULL;\n    }\n\n    struct ds c_addresses = DS_EMPTY_INITIALIZER;\n    ds_put_format(&c_addresses, ETH_ADDR_FMT, ETH_ADDR_ARGS(mac));\n    bool central_ip_address = false;\n\n    char **addresses;\n    addresses = xmalloc(sizeof *addresses * (op->od->nbr->n_nat + 1));\n\n    /* Get NAT IP addresses. */\n    for (size_t i = 0; i < op->od->nbr->n_nat; i++) {\n        const struct nbrec_nat *nat = op->od->nbr->nat[i];\n        ovs_be32 ip, mask;\n\n        if (routable_only &&\n            (!strcmp(nat->type, \"snat\") ||\n             !smap_get_bool(&nat->options, \"add_route\", false))) {\n            continue;\n        }\n\n        char *error = ip_parse_masked(nat->external_ip, &ip, &mask);\n        if (error || mask != OVS_BE32_MAX) {\n            free(error);\n            continue;\n        }\n\n        /* Not including external IP of NAT rules whose gateway_port is\n         * not 'op'. */\n        if (!is_nat_gateway_port(nat, op)) {\n            continue;\n        }\n\n        /* Determine whether this NAT rule satisfies the conditions for\n         * distributed NAT processing. */\n        if (op->od->n_l3dgw_ports && !strcmp(nat->type, \"dnat_and_snat\")\n            && nat->logical_port && nat->external_mac) {\n            /* Distributed NAT rule. */\n            if (eth_addr_from_string(nat->external_mac, &mac)) {\n                struct ds address = DS_EMPTY_INITIALIZER;\n                ds_put_format(&address, ETH_ADDR_FMT, ETH_ADDR_ARGS(mac));\n                ds_put_format(&address, \" %s\", nat->external_ip);\n                ds_put_format(&address, \" is_chassis_resident(\\\"%s\\\")\",\n                              nat->logical_port);\n                addresses[n_nats++] = ds_steal_cstr(&address);\n            }\n        } else {\n            /* Centralized NAT rule, either on gateway router or distributed\n             * router.\n             * Check if external_ip is same as router ip. If so, then there\n             * is no need to add this to the nat_addresses. The router IPs\n             * will be added separately. */\n            bool is_router_ip = false;\n            for (size_t j = 0; j < op->lrp_networks.n_ipv4_addrs; j++) {\n                if (!strcmp(nat->external_ip,\n                            op->lrp_networks.ipv4_addrs[j].addr_s)) {\n                    is_router_ip = true;\n                    break;\n                }\n            }\n            if (!is_router_ip) {\n                for (size_t j = 0; j < op->lrp_networks.n_ipv6_addrs; j++) {\n                    if (!strcmp(nat->external_ip,\n                                op->lrp_networks.ipv6_addrs[j].addr_s)) {\n                        is_router_ip = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!is_router_ip) {\n                ds_put_format(&c_addresses, \" %s\", nat->external_ip);\n                central_ip_address = true;\n            }\n        }\n    }\n\n    if (include_lb_ips) {\n        const char *ip_address;\n        if (routable_only) {\n            SSET_FOR_EACH (ip_address, &op->od->lb_ips->ips_v4_routable) {\n                ds_put_format(&c_addresses, \" %s\", ip_address);\n                central_ip_address = true;\n            }\n            SSET_FOR_EACH (ip_address, &op->od->lb_ips->ips_v6_routable) {\n                ds_put_format(&c_addresses, \" %s\", ip_address);\n                central_ip_address = true;\n            }\n        } else {\n            SSET_FOR_EACH (ip_address, &op->od->lb_ips->ips_v4) {\n                ds_put_format(&c_addresses, \" %s\", ip_address);\n                central_ip_address = true;\n            }\n            SSET_FOR_EACH (ip_address, &op->od->lb_ips->ips_v6) {\n                ds_put_format(&c_addresses, \" %s\", ip_address);\n                central_ip_address = true;\n            }\n        }\n    }\n\n    if (central_ip_address) {\n        /* Gratuitous ARP for centralized NAT rules on distributed gateway\n         * ports should be restricted to the gateway chassis. */\n        if (is_l3dgw_port(op)) {\n            ds_put_format(&c_addresses, \" is_chassis_resident(%s)\",\n                          op->cr_port->json_key);\n        }\n\n        addresses[n_nats++] = ds_steal_cstr(&c_addresses);\n    }\n\n    *n = n_nats;\n    ds_destroy(&c_addresses);\n\n    return addresses;\n}\n\nstatic bool\nsbpb_gw_chassis_needs_update(\n    const struct sbrec_port_binding *pb,\n    const struct nbrec_logical_router_port *lrp,\n    struct ovsdb_idl_index *sbrec_chassis_by_name)\n{\n    if (!lrp || !pb) {\n        return false;\n    }\n\n    if (lrp->n_gateway_chassis && !pb->ha_chassis_group) {\n        /* If there are gateway chassis in the NB DB, but there is\n         * no corresponding HA chassis group in SB DB we need to\n         * create the HA chassis group in SB DB for this lrp. */\n        return true;\n    }\n\n    if (strcmp(pb->ha_chassis_group->name, lrp->name)) {\n        /* Name doesn't match. */\n        return true;\n    }\n\n    if (lrp->n_gateway_chassis != pb->ha_chassis_group->n_ha_chassis) {\n        return true;\n    }\n\n    for (size_t i = 0; i < lrp->n_gateway_chassis; i++) {\n        struct nbrec_gateway_chassis *nbgw_ch = lrp->gateway_chassis[i];\n        bool found = false;\n        for (size_t j = 0; j < pb->ha_chassis_group->n_ha_chassis; j++) {\n            struct sbrec_ha_chassis *sbha_ch =\n                pb->ha_chassis_group->ha_chassis[j];\n            const char *chassis_name = smap_get(&sbha_ch->external_ids,\n                                                \"chassis-name\");\n            if (!chassis_name) {\n                return true;\n            }\n\n            if (strcmp(chassis_name, nbgw_ch->chassis_name)) {\n                continue;\n            }\n\n            found = true;\n\n            if (nbgw_ch->priority != sbha_ch->priority) {\n                return true;\n            }\n\n            if (sbha_ch->chassis &&\n                strcmp(nbgw_ch->chassis_name, sbha_ch->chassis->name)) {\n                /* sbha_ch->chassis's name is different from the one\n                 * in sbha_ch->external_ids:chassis-name. */\n                return true;\n            }\n\n            if (!sbha_ch->chassis &&\n                chassis_lookup_by_name(sbrec_chassis_by_name,\n                                       nbgw_ch->chassis_name)) {\n                /* sbha_ch->chassis is NULL, but the chassis is\n                 * present in Chassis table. */\n                return true;\n            }\n        }\n\n        if (!found) {\n            return true;\n        }\n    }\n\n    /* No need to update SB DB. Its in sync. */\n    return false;\n}\n\nstatic struct sbrec_ha_chassis *\ncreate_sb_ha_chassis(struct ovsdb_idl_txn *ovnsb_txn,\n                     const struct sbrec_chassis *chassis,\n                     const char *chassis_name, int priority)\n{\n    struct sbrec_ha_chassis *sb_ha_chassis =\n        sbrec_ha_chassis_insert(ovnsb_txn);\n    sbrec_ha_chassis_set_chassis(sb_ha_chassis, chassis);\n    sbrec_ha_chassis_set_priority(sb_ha_chassis, priority);\n    /* Store the chassis_name in external_ids. If the chassis\n     * entry doesn't exist in the Chassis table then we can\n     * figure out the chassis to which this ha_chassis\n     * maps to. */\n    const struct smap external_ids =\n        SMAP_CONST1(&external_ids, \"chassis-name\", chassis_name);\n    sbrec_ha_chassis_set_external_ids(sb_ha_chassis, &external_ids);\n    return sb_ha_chassis;\n}\n\nstatic bool\nchassis_group_list_changed(\n    const struct nbrec_ha_chassis_group *nb_ha_grp,\n    const struct sbrec_ha_chassis_group *sb_ha_grp,\n    struct ovsdb_idl_index *sbrec_chassis_by_name)\n{\n    if (nb_ha_grp->n_ha_chassis != sb_ha_grp->n_ha_chassis) {\n        return true;\n    }\n\n    struct shash nb_ha_chassis_list = SHASH_INITIALIZER(&nb_ha_chassis_list);\n    for (size_t i = 0; i < nb_ha_grp->n_ha_chassis; i++) {\n        shash_add(&nb_ha_chassis_list,\n                  nb_ha_grp->ha_chassis[i]->chassis_name,\n                  nb_ha_grp->ha_chassis[i]);\n    }\n\n    bool changed = false;\n    const struct sbrec_ha_chassis *sb_ha_chassis;\n    const struct nbrec_ha_chassis *nb_ha_chassis;\n    for (size_t i = 0; i < sb_ha_grp->n_ha_chassis; i++) {\n        sb_ha_chassis = sb_ha_grp->ha_chassis[i];\n        const char *chassis_name = smap_get(&sb_ha_chassis->external_ids,\n                                            \"chassis-name\");\n\n        if (!chassis_name) {\n            changed = true;\n            break;\n        }\n\n        nb_ha_chassis = shash_find_and_delete(&nb_ha_chassis_list,\n                                              chassis_name);\n        if (!nb_ha_chassis ||\n            nb_ha_chassis->priority != sb_ha_chassis->priority) {\n            changed = true;\n            break;\n        }\n\n        if (sb_ha_chassis->chassis &&\n            strcmp(sb_ha_chassis->chassis->name, chassis_name)) {\n            /* sb_ha_chassis->chassis's name is different from the one\n             * in sb_ha_chassis->external_ids:chassis-name. */\n            changed = true;\n            break;\n        }\n\n        if (!sb_ha_chassis->chassis &&\n            chassis_lookup_by_name(sbrec_chassis_by_name,\n                                   chassis_name)) {\n            /* sb_ha_chassis->chassis is NULL, but the chassis is\n             * present in Chassis table. */\n            changed = true;\n            break;\n        }\n    }\n\n    struct shash_node *node;\n    SHASH_FOR_EACH_SAFE (node, &nb_ha_chassis_list) {\n        shash_delete(&nb_ha_chassis_list, node);\n        changed = true;\n    }\n    shash_destroy(&nb_ha_chassis_list);\n\n    return changed;\n}\n\nstatic void\nsync_ha_chassis_group_for_sbpb(struct northd_input *input_data,\n                               struct ovsdb_idl_txn *ovnsb_txn,\n                               const struct nbrec_ha_chassis_group *nb_ha_grp,\n                               struct ovsdb_idl_index *sbrec_chassis_by_name,\n                               const struct sbrec_port_binding *pb)\n{\n    bool new_sb_chassis_group = false;\n    const struct sbrec_ha_chassis_group *sb_ha_grp =\n        ha_chassis_group_lookup_by_name(\n            input_data->sbrec_ha_chassis_grp_by_name, nb_ha_grp->name);\n\n    if (!sb_ha_grp) {\n        sb_ha_grp = sbrec_ha_chassis_group_insert(ovnsb_txn);\n        sbrec_ha_chassis_group_set_name(sb_ha_grp, nb_ha_grp->name);\n        new_sb_chassis_group = true;\n    }\n\n    if (new_sb_chassis_group ||\n        chassis_group_list_changed(nb_ha_grp, sb_ha_grp,\n                                   sbrec_chassis_by_name)) {\n        struct sbrec_ha_chassis **sb_ha_chassis = NULL;\n        size_t n_ha_chassis = nb_ha_grp->n_ha_chassis;\n        sb_ha_chassis = xcalloc(n_ha_chassis, sizeof *sb_ha_chassis);\n        for (size_t i = 0; i < nb_ha_grp->n_ha_chassis; i++) {\n            const struct nbrec_ha_chassis *nb_ha_chassis\n                = nb_ha_grp->ha_chassis[i];\n            const struct sbrec_chassis *chassis =\n                chassis_lookup_by_name(sbrec_chassis_by_name,\n                                       nb_ha_chassis->chassis_name);\n            sb_ha_chassis[i] = sbrec_ha_chassis_insert(ovnsb_txn);\n            /* It's perfectly ok if the chassis is NULL. This could\n             * happen when ovn-controller exits and removes its row\n             * from the chassis table in OVN SB DB. */\n            sbrec_ha_chassis_set_chassis(sb_ha_chassis[i], chassis);\n            sbrec_ha_chassis_set_priority(sb_ha_chassis[i],\n                                          nb_ha_chassis->priority);\n            const struct smap external_ids =\n                SMAP_CONST1(&external_ids, \"chassis-name\",\n                            nb_ha_chassis->chassis_name);\n            sbrec_ha_chassis_set_external_ids(sb_ha_chassis[i], &external_ids);\n        }\n        sbrec_ha_chassis_group_set_ha_chassis(sb_ha_grp, sb_ha_chassis,\n                                              n_ha_chassis);\n        free(sb_ha_chassis);\n    }\n\n    sbrec_port_binding_set_ha_chassis_group(pb, sb_ha_grp);\n}\n\n/* This functions translates the gw chassis on the nb database\n * to HA chassis group in the sb database entries.\n */\nstatic void\ncopy_gw_chassis_from_nbrp_to_sbpb(\n        struct northd_input *input_data,\n        struct ovsdb_idl_txn *ovnsb_txn,\n        struct ovsdb_idl_index *sbrec_chassis_by_name,\n        const struct nbrec_logical_router_port *lrp,\n        const struct sbrec_port_binding *port_binding)\n{\n\n    /* Make use of the new HA chassis group table to support HA\n     * for the distributed gateway router port. */\n    const struct sbrec_ha_chassis_group *sb_ha_chassis_group =\n        ha_chassis_group_lookup_by_name(\n            input_data->sbrec_ha_chassis_grp_by_name, lrp->name);\n    if (!sb_ha_chassis_group) {\n        sb_ha_chassis_group = sbrec_ha_chassis_group_insert(ovnsb_txn);\n        sbrec_ha_chassis_group_set_name(sb_ha_chassis_group, lrp->name);\n    }\n\n    struct sbrec_ha_chassis **sb_ha_chassis = xcalloc(lrp->n_gateway_chassis,\n                                                      sizeof *sb_ha_chassis);\n    size_t n_sb_ha_ch = 0;\n    for (size_t n = 0; n < lrp->n_gateway_chassis; n++) {\n        struct nbrec_gateway_chassis *lrp_gwc = lrp->gateway_chassis[n];\n        if (!lrp_gwc->chassis_name) {\n            continue;\n        }\n\n        const struct sbrec_chassis *chassis =\n            chassis_lookup_by_name(sbrec_chassis_by_name,\n                                   lrp_gwc->chassis_name);\n\n        sb_ha_chassis[n_sb_ha_ch] =\n            create_sb_ha_chassis(ovnsb_txn, chassis, lrp_gwc->chassis_name,\n                                 lrp_gwc->priority);\n        n_sb_ha_ch++;\n    }\n\n    sbrec_ha_chassis_group_set_ha_chassis(sb_ha_chassis_group,\n                                          sb_ha_chassis, n_sb_ha_ch);\n    sbrec_port_binding_set_ha_chassis_group(port_binding, sb_ha_chassis_group);\n    free(sb_ha_chassis);\n}\n\nstatic const char*\nop_get_name(const struct ovn_port *op)\n{\n    ovs_assert(op->nbsp || op->nbrp);\n    const char *name = op->nbsp ? op->nbsp->name\n                                : op->nbrp->name;\n    return name;\n}\n\nstatic void\novn_update_ipv6_prefix(struct hmap *ports)\n{\n    const struct ovn_port *op;\n    HMAP_FOR_EACH (op, key_node, ports) {\n        if (!op->nbrp) {\n            continue;\n        }\n\n        if (!smap_get_bool(&op->nbrp->options, \"prefix\", false)) {\n            continue;\n        }\n\n        char prefix[IPV6_SCAN_LEN + 6];\n        unsigned aid;\n        const char *ipv6_pd_list = smap_get(&op->sb->options,\n                                            \"ipv6_ra_pd_list\");\n        if (!ipv6_pd_list ||\n            !ovs_scan(ipv6_pd_list, \"%u:%s\", &aid, prefix)) {\n            continue;\n        }\n\n        const char *prefix_ptr = prefix;\n        nbrec_logical_router_port_set_ipv6_prefix(op->nbrp, &prefix_ptr, 1);\n    }\n}\n\nstatic const struct sbrec_chassis *\nchassis_lookup(struct ovsdb_idl_index *sbrec_chassis_by_name,\n               struct ovsdb_idl_index *sbrec_chassis_by_hostname,\n               const char *name_or_hostname)\n{\n    const struct sbrec_chassis *chassis; /* May be NULL. */\n    chassis = chassis_lookup_by_name(sbrec_chassis_by_name,\n                                     name_or_hostname);\n    return chassis ? chassis : chassis_lookup_by_hostname(\n                    sbrec_chassis_by_hostname, name_or_hostname);\n}\n\nstatic void\novn_port_update_sbrec_chassis(\n        struct ovsdb_idl_index *sbrec_chassis_by_name,\n        struct ovsdb_idl_index *sbrec_chassis_by_hostname,\n        const struct ovn_port *op)\n{\n    const char *requested_chassis; /* May be NULL. */\n\n    size_t n_requested_chassis = 0;\n    struct sbrec_chassis **requested_chassis_sb = xcalloc(\n        n_requested_chassis, sizeof *requested_chassis_sb);\n\n    requested_chassis = smap_get(&op->nbsp->options,\n                                 \"requested-chassis\");\n    if (requested_chassis) {\n        char *tokstr = xstrdup(requested_chassis);\n        char *save_ptr = NULL;\n        char *chassis;\n        for (chassis = strtok_r(tokstr, \",\", &save_ptr); chassis != NULL;\n             chassis = strtok_r(NULL, \",\", &save_ptr)) {\n            const struct sbrec_chassis *chassis_sb = chassis_lookup(\n                sbrec_chassis_by_name, sbrec_chassis_by_hostname, chassis);\n            if (chassis_sb) {\n                requested_chassis_sb = xrealloc(\n                    requested_chassis_sb,\n                    ++n_requested_chassis * (sizeof *requested_chassis_sb));\n                requested_chassis_sb[n_requested_chassis - 1] = (\n                    (struct sbrec_chassis *) chassis_sb);\n            } else {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(\n                    1, 1);\n                VLOG_WARN_RL(\n                    &rl,\n                    \"Unknown chassis '%s' set in \"\n                    \"options:requested-chassis on LSP '%s'.\",\n                    chassis, op->nbsp->name);\n            }\n        }\n        free(tokstr);\n    }\n\n    if (n_requested_chassis > 0) {\n        sbrec_port_binding_set_requested_chassis(op->sb,\n                                                 *requested_chassis_sb);\n    } else {\n        sbrec_port_binding_set_requested_chassis(op->sb, NULL);\n    }\n    if (n_requested_chassis > 1) {\n        sbrec_port_binding_set_requested_additional_chassis(\n            op->sb, &requested_chassis_sb[1], n_requested_chassis - 1);\n    } else {\n        sbrec_port_binding_set_requested_additional_chassis(op->sb, NULL, 0);\n    }\n    free(requested_chassis_sb);\n}\n\nstatic void\ncheck_and_do_sb_mirror_deletion(const struct ovn_port *op)\n{\n    size_t i = 0;\n    struct shash nb_mirror_rules = SHASH_INITIALIZER(&nb_mirror_rules);\n\n    for (i = 0; i < op->nbsp->n_mirror_rules; i++) {\n        shash_add(&nb_mirror_rules,\n                  op->nbsp->mirror_rules[i]->name,\n                  op->nbsp->mirror_rules[i]);\n    }\n\n    for (i = 0; i < op->sb->n_mirror_rules; i++) {\n        if (!shash_find(&nb_mirror_rules,\n                        op->sb->mirror_rules[i]->name)) {\n            /* Delete from SB since its not present in NB*/\n            sbrec_port_binding_update_mirror_rules_delvalue(op->sb,\n                                             op->sb->mirror_rules[i]);\n        }\n    }\n\n    struct shash_node *node, *next;\n    SHASH_FOR_EACH_SAFE (node, next, &nb_mirror_rules) {\n        shash_delete(&nb_mirror_rules, node);\n    }\n    shash_destroy(&nb_mirror_rules);\n}\n\nstatic void\ncheck_and_do_sb_mirror_addition(struct northd_input *input_data,\n                                const struct ovn_port *op)\n{\n    for (size_t i = 0; i < op->nbsp->n_mirror_rules; i++) {\n        const struct sbrec_mirror *sb_mirror;\n        SBREC_MIRROR_TABLE_FOR_EACH (sb_mirror,\n                                     input_data->sbrec_mirror_table) {\n            if (!strcmp(sb_mirror->name,\n                        op->nbsp->mirror_rules[i]->name)) {\n                /* Add the value to SB */\n                sbrec_port_binding_update_mirror_rules_addvalue(op->sb,\n                                                                sb_mirror);\n            }\n        }\n    }\n}\n\nstatic void\nsbrec_port_binding_update_mirror_rules(struct northd_input *input_data,\n                                       const struct ovn_port *op)\n{\n    check_and_do_sb_mirror_deletion(op);\n    check_and_do_sb_mirror_addition(input_data, op);\n}\n\n/* Return true if given ovn_port has peer and this peer's ovn_datapath\n * has_vtep_lports set to true. False otherwise. */\nstatic bool\nl3dgw_port_has_associated_vtep_lports(const struct ovn_port *op)\n{\n    return op->peer && op->peer->od->has_vtep_lports;\n}\n\nstatic void\novn_port_update_sbrec(struct northd_input *input_data,\n                      struct ovsdb_idl_txn *ovnsb_txn,\n                      struct ovsdb_idl_index *sbrec_chassis_by_name,\n                      struct ovsdb_idl_index *sbrec_chassis_by_hostname,\n                      const struct ovn_port *op,\n                      struct hmap *chassis_qdisc_queues,\n                      struct sset *active_ha_chassis_grps)\n{\n    sbrec_port_binding_set_datapath(op->sb, op->od->sb);\n    if (op->nbrp) {\n        /* If the router is for l3 gateway, it resides on a chassis\n         * and its port type is \"l3gateway\". */\n        const char *chassis_name = smap_get(&op->od->nbr->options, \"chassis\");\n        if (is_cr_port(op)) {\n            sbrec_port_binding_set_type(op->sb, \"chassisredirect\");\n        } else if (chassis_name) {\n            sbrec_port_binding_set_type(op->sb, \"l3gateway\");\n        } else {\n            sbrec_port_binding_set_type(op->sb, \"patch\");\n        }\n\n        struct smap new;\n        smap_init(&new);\n        if (is_cr_port(op)) {\n            const char *redirect_type = smap_get(&op->nbrp->options,\n                                                 \"redirect-type\");\n\n            if (op->nbrp->ha_chassis_group) {\n                if (op->nbrp->n_gateway_chassis) {\n                    static struct vlog_rate_limit rl\n                        = VLOG_RATE_LIMIT_INIT(1, 1);\n                    VLOG_WARN_RL(&rl, \"Both ha_chassis_group and \"\n                                 \"gateway_chassis configured on port %s; \"\n                                 \"ignoring the latter.\", op->nbrp->name);\n                }\n\n                /* HA Chassis group is set. Ignore 'gateway_chassis'. */\n                sync_ha_chassis_group_for_sbpb(input_data, ovnsb_txn,\n                                               op->nbrp->ha_chassis_group,\n                                               sbrec_chassis_by_name, op->sb);\n                sset_add(active_ha_chassis_grps,\n                         op->nbrp->ha_chassis_group->name);\n            } else if (op->nbrp->n_gateway_chassis) {\n                /* Legacy gateway_chassis support.\n                 * Create ha_chassis_group for the Northbound gateway_chassis\n                 * associated with the lrp. */\n                if (sbpb_gw_chassis_needs_update(op->sb, op->nbrp,\n                                                 sbrec_chassis_by_name)) {\n                    copy_gw_chassis_from_nbrp_to_sbpb(input_data,\n                                                      ovnsb_txn,\n                                                      sbrec_chassis_by_name,\n                                                      op->nbrp, op->sb);\n                }\n\n                sset_add(active_ha_chassis_grps, op->nbrp->name);\n            } else {\n                /* Nothing is set. Clear ha_chassis_group  from pb. */\n                if (op->sb->ha_chassis_group) {\n                    sbrec_port_binding_set_ha_chassis_group(op->sb, NULL);\n                }\n            }\n\n            if (op->sb->n_gateway_chassis) {\n                /* Delete the legacy gateway_chassis from the pb. */\n                sbrec_port_binding_set_gateway_chassis(op->sb, NULL, 0);\n            }\n            smap_add(&new, \"distributed-port\", op->nbrp->name);\n\n            bool always_redirect =\n                !op->od->has_distributed_nat &&\n                !l3dgw_port_has_associated_vtep_lports(op->l3dgw_port);\n\n            if (redirect_type) {\n                smap_add(&new, \"redirect-type\", redirect_type);\n                /* XXX Why can't we enable always-redirect when redirect-type\n                 * is bridged? */\n                if (!strcmp(redirect_type, \"bridged\")) {\n                    always_redirect = false;\n                }\n            }\n\n            if (always_redirect) {\n                smap_add(&new, \"always-redirect\", \"true\");\n            }\n        } else {\n            if (op->peer) {\n                smap_add(&new, \"peer\", op->peer->key);\n                if (op->nbrp->ha_chassis_group ||\n                    op->nbrp->n_gateway_chassis) {\n                    char *redirect_name =\n                        ovn_chassis_redirect_name(op->nbrp->name);\n                    smap_add(&new, \"chassis-redirect-port\", redirect_name);\n                    free(redirect_name);\n                }\n            }\n            if (chassis_name) {\n                smap_add(&new, \"l3gateway-chassis\", chassis_name);\n            }\n        }\n\n        const char *ipv6_pd_list = smap_get(&op->sb->options,\n                                            \"ipv6_ra_pd_list\");\n        if (ipv6_pd_list) {\n            smap_add(&new, \"ipv6_ra_pd_list\", ipv6_pd_list);\n        }\n\n        sbrec_port_binding_set_options(op->sb, &new);\n        smap_destroy(&new);\n\n        sbrec_port_binding_set_parent_port(op->sb, NULL);\n        sbrec_port_binding_set_tag(op->sb, NULL, 0);\n\n        struct ds s = DS_EMPTY_INITIALIZER;\n        ds_put_cstr(&s, op->nbrp->mac);\n        for (int i = 0; i < op->nbrp->n_networks; ++i) {\n            ds_put_format(&s, \" %s\", op->nbrp->networks[i]);\n        }\n        const char *addresses = ds_cstr(&s);\n        sbrec_port_binding_set_mac(op->sb, &addresses, 1);\n        ds_destroy(&s);\n\n        sbrec_port_binding_set_external_ids(op->sb, &op->nbrp->external_ids);\n\n        sbrec_port_binding_set_nat_addresses(op->sb, NULL, 0);\n    } else {\n        if (!lsp_is_router(op->nbsp)) {\n            uint32_t queue_id = smap_get_int(\n                    &op->sb->options, \"qdisc_queue_id\", 0);\n            bool has_qos = port_has_qos_params(&op->nbsp->options);\n            const struct uuid *uuid = NULL;\n            struct smap options;\n            char *name = \"\";\n\n            if (lsp_is_localnet(op->nbsp)) {\n                uuid = &op->sb->header_.uuid;\n                name = \"localnet\";\n            } else if (op->sb->chassis) {\n                uuid = &op->sb->chassis->header_.uuid;\n                name = op->sb->chassis->name;\n            }\n\n            if (has_qos && !queue_id) {\n                queue_id = allocate_chassis_queueid(chassis_qdisc_queues,\n                                                    uuid, name);\n            } else if (!has_qos && queue_id) {\n                free_chassis_queueid(chassis_qdisc_queues, uuid, queue_id);\n                queue_id = 0;\n            }\n\n            smap_clone(&options, &op->nbsp->options);\n            if (queue_id) {\n                smap_add_format(&options,\n                                \"qdisc_queue_id\", \"%d\", queue_id);\n            }\n\n            if (smap_get_bool(&op->od->nbs->other_config, \"vlan-passthru\", false)) {\n                smap_add(&options, \"vlan-passthru\", \"true\");\n            }\n\n            /* Retain activated chassis flags. */\n            if (op->sb->requested_additional_chassis) {\n                const char *activated_str = smap_get(\n                    &op->sb->options, \"additional-chassis-activated\");\n                if (activated_str) {\n                    smap_add(&options, \"additional-chassis-activated\",\n                             activated_str);\n                }\n            }\n\n            sbrec_port_binding_set_options(op->sb, &options);\n            smap_destroy(&options);\n            if (ovn_is_known_nb_lsp_type(op->nbsp->type)) {\n                sbrec_port_binding_set_type(op->sb, op->nbsp->type);\n            } else {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n                VLOG_WARN_RL(\n                    &rl, \"Unknown port type '%s' set on logical switch '%s'.\",\n                    op->nbsp->type, op->nbsp->name);\n            }\n\n            sbrec_port_binding_set_nat_addresses(op->sb, NULL, 0);\n\n            if (!strcmp(op->nbsp->type, \"external\")) {\n                if (op->nbsp->ha_chassis_group) {\n                    sync_ha_chassis_group_for_sbpb(\n                        input_data,\n                        ovnsb_txn, op->nbsp->ha_chassis_group,\n                        sbrec_chassis_by_name, op->sb);\n                    sset_add(active_ha_chassis_grps,\n                             op->nbsp->ha_chassis_group->name);\n                } else {\n                    sbrec_port_binding_set_ha_chassis_group(op->sb, NULL);\n                }\n            } else if (op->sb->ha_chassis_group) {\n                /* Clear the port bindings ha_chassis_group if the type is\n                 * not external and if this column is set.  This can happen\n                 * when an external port is reset to type normal and\n                 * ha_chassis_group cleared in the same transaction. */\n                sbrec_port_binding_set_ha_chassis_group(op->sb, NULL);\n            }\n\n            ovn_port_update_sbrec_chassis(sbrec_chassis_by_name,\n                                          sbrec_chassis_by_hostname, op);\n        } else {\n            const char *chassis = NULL;\n            if (op->peer && op->peer->od && op->peer->od->nbr) {\n                chassis = smap_get(&op->peer->od->nbr->options, \"chassis\");\n            }\n\n            /* A switch port connected to a gateway router is also of\n             * type \"l3gateway\". */\n            if (chassis) {\n                sbrec_port_binding_set_type(op->sb, \"l3gateway\");\n            } else {\n                sbrec_port_binding_set_type(op->sb, \"patch\");\n            }\n\n            const char *router_port = smap_get(&op->nbsp->options,\n                                               \"router-port\");\n            if (router_port || chassis) {\n                struct smap new;\n                smap_init(&new);\n                if (router_port) {\n                    smap_add(&new, \"peer\", router_port);\n                }\n                if (chassis) {\n                    smap_add(&new, \"l3gateway-chassis\", chassis);\n                }\n                sbrec_port_binding_set_options(op->sb, &new);\n                smap_destroy(&new);\n            } else {\n                sbrec_port_binding_set_options(op->sb, NULL);\n            }\n            const char *nat_addresses = smap_get(&op->nbsp->options,\n                                           \"nat-addresses\");\n            size_t n_nats = 0;\n            char **nats = NULL;\n            bool l3dgw_ports = op->peer && op->peer->od &&\n                               op->peer->od->n_l3dgw_ports;\n            if (nat_addresses && !strcmp(nat_addresses, \"router\")) {\n                if (op->peer && op->peer->od\n                    && (chassis || op->peer->od->n_l3dgw_ports)) {\n                    bool exclude_lb_vips = smap_get_bool(&op->nbsp->options,\n                            \"exclude-lb-vips-from-garp\", false);\n                    nats = get_nat_addresses(op->peer, &n_nats, false,\n                                             !exclude_lb_vips);\n                }\n            } else if (nat_addresses && (chassis || l3dgw_ports)) {\n                struct lport_addresses laddrs;\n                if (!extract_lsp_addresses(nat_addresses, &laddrs)) {\n                    static struct vlog_rate_limit rl =\n                        VLOG_RATE_LIMIT_INIT(1, 1);\n                    VLOG_WARN_RL(&rl, \"Error extracting nat-addresses.\");\n                } else {\n                    destroy_lport_addresses(&laddrs);\n                    n_nats = 1;\n                    nats = xcalloc(1, sizeof *nats);\n                    struct ds nat_addr = DS_EMPTY_INITIALIZER;\n                    ds_put_format(&nat_addr, \"%s\", nat_addresses);\n                    if (l3dgw_ports) {\n                        const struct ovn_port *l3dgw_port = (\n                            is_l3dgw_port(op->peer)\n                            ? op->peer\n                            : op->peer->od->l3dgw_ports[0]);\n                        ds_put_format(&nat_addr, \" is_chassis_resident(%s)\",\n                            l3dgw_port->cr_port->json_key);\n                    }\n                    nats[0] = xstrdup(ds_cstr(&nat_addr));\n                    ds_destroy(&nat_addr);\n                }\n            }\n\n            /* Add the router mac and IPv4 addresses to\n             * Port_Binding.nat_addresses so that GARP is sent for these\n             * IPs by the ovn-controller on which the distributed gateway\n             * router port resides if:\n             *\n             * -  op->peer has 'reside-on-redirect-chassis' set and the\n             *    the logical router datapath has distributed router port.\n             *\n             * -  op->peer is distributed gateway router port.\n             *\n             * -  op->peer's router is a gateway router and op has a localnet\n             *    port.\n             *\n             * Note: Port_Binding.nat_addresses column is also used for\n             * sending the GARPs for the router port IPs.\n             * */\n            bool add_router_port_garp = false;\n            if (op->peer && op->peer->nbrp && op->peer->od->n_l3dgw_ports) {\n                if (is_l3dgw_port(op->peer)) {\n                    add_router_port_garp = true;\n                } else if (smap_get_bool(&op->peer->nbrp->options,\n                               \"reside-on-redirect-chassis\", false)) {\n                    if (op->peer->od->n_l3dgw_ports == 1) {\n                        add_router_port_garp = true;\n                    } else {\n                        static struct vlog_rate_limit rl =\n                            VLOG_RATE_LIMIT_INIT(1, 1);\n                        VLOG_WARN_RL(&rl, \"\\\"reside-on-redirect-chassis\\\" is \"\n                                     \"set on logical router port %s, which \"\n                                     \"is on logical router %s, which has %\"\n                                     PRIuSIZE\" distributed gateway ports. This\"\n                                     \"option can only be used when there is \"\n                                     \"a single distributed gateway port.\",\n                                     op->peer->key, op->peer->od->nbr->name,\n                                     op->peer->od->n_l3dgw_ports);\n                    }\n                }\n            } else if (chassis && op->od->n_localnet_ports) {\n                add_router_port_garp = true;\n            }\n\n            if (add_router_port_garp) {\n                struct ds garp_info = DS_EMPTY_INITIALIZER;\n                ds_put_format(&garp_info, \"%s\", op->peer->lrp_networks.ea_s);\n\n                for (size_t i = 0; i < op->peer->lrp_networks.n_ipv4_addrs;\n                     i++) {\n                    ds_put_format(&garp_info, \" %s\",\n                                  op->peer->lrp_networks.ipv4_addrs[i].addr_s);\n                }\n\n                if (op->peer->od->n_l3dgw_ports) {\n                    const struct ovn_port *l3dgw_port = (\n                        is_l3dgw_port(op->peer)\n                        ? op->peer\n                        : op->peer->od->l3dgw_ports[0]);\n                    ds_put_format(&garp_info, \" is_chassis_resident(%s)\",\n                                  l3dgw_port->cr_port->json_key);\n                }\n\n                n_nats++;\n                nats = xrealloc(nats, (n_nats * sizeof *nats));\n                nats[n_nats - 1] = ds_steal_cstr(&garp_info);\n                ds_destroy(&garp_info);\n            }\n            sbrec_port_binding_set_nat_addresses(op->sb,\n                                                 (const char **) nats, n_nats);\n            for (size_t i = 0; i < n_nats; i++) {\n                free(nats[i]);\n            }\n            free(nats);\n        }\n\n        sbrec_port_binding_set_parent_port(op->sb, op->nbsp->parent_name);\n        sbrec_port_binding_set_tag(op->sb, op->nbsp->tag, op->nbsp->n_tag);\n        sbrec_port_binding_set_mac(op->sb, (const char **) op->nbsp->addresses,\n                                   op->nbsp->n_addresses);\n        sbrec_port_binding_set_port_security(\n            op->sb, (const char **) op->nbsp->port_security,\n            op->nbsp->n_port_security);\n\n        struct smap ids = SMAP_INITIALIZER(&ids);\n        smap_clone(&ids, &op->nbsp->external_ids);\n        const char *name = smap_get(&ids, \"neutron:port_name\");\n        if (name && name[0]) {\n            smap_add(&ids, \"name\", name);\n        }\n        sbrec_port_binding_set_external_ids(op->sb, &ids);\n        smap_destroy(&ids);\n\n        if (!op->nbsp->n_mirror_rules) {\n            /* Nothing is set. Clear mirror_rules from pb. */\n            sbrec_port_binding_set_mirror_rules(op->sb, NULL, 0);\n        } else {\n            /* Check if SB DB update needed */\n            sbrec_port_binding_update_mirror_rules(input_data, op);\n        }\n\n    }\n    if (op->tunnel_key != op->sb->tunnel_key) {\n        sbrec_port_binding_set_tunnel_key(op->sb, op->tunnel_key);\n    }\n\n    /* ovn-controller will update 'Port_Binding.up' only if it was explicitly\n     * set to 'false'.\n     */\n    if (!op->sb->n_up) {\n        bool up = false;\n        sbrec_port_binding_set_up(op->sb, &up, 1);\n    }\n}\n\n/* Remove mac_binding entries that refer to logical_ports which are\n * deleted. */\nstatic void\ncleanup_mac_bindings(struct northd_input *input_data,\n                     struct hmap *datapaths,\n                     struct hmap *ports)\n{\n    const struct sbrec_mac_binding *b;\n    SBREC_MAC_BINDING_TABLE_FOR_EACH_SAFE (b,\n                             input_data->sbrec_mac_binding_table) {\n        const struct ovn_datapath *od =\n            ovn_datapath_from_sbrec(datapaths, b->datapath);\n\n        if (!od || ovn_datapath_is_stale(od) ||\n                !ovn_port_find(ports, b->logical_port)) {\n            sbrec_mac_binding_delete(b);\n        }\n    }\n}\n\nstatic void\ncleanup_sb_ha_chassis_groups(struct northd_input *input_data,\n                             struct sset *active_ha_chassis_groups)\n{\n    const struct sbrec_ha_chassis_group *b;\n    SBREC_HA_CHASSIS_GROUP_TABLE_FOR_EACH_SAFE (b,\n                                input_data->sbrec_ha_chassis_group_table) {\n        if (!sset_contains(active_ha_chassis_groups, b->name)) {\n            sbrec_ha_chassis_group_delete(b);\n        }\n    }\n}\n\nstatic void\ncleanup_stale_fdb_entries(struct northd_input *input_data,\n                          struct hmap *datapaths)\n{\n    const struct sbrec_fdb *fdb_e;\n    SBREC_FDB_TABLE_FOR_EACH_SAFE (fdb_e,\n                         input_data->sbrec_fdb_table) {\n        bool delete = true;\n        struct ovn_datapath *od\n            = ovn_datapath_find_by_key(datapaths, fdb_e->dp_key);\n        if (od) {\n            if (ovn_tnlid_present(&od->port_tnlids, fdb_e->port_key)) {\n                delete = false;\n            }\n        }\n\n        if (delete) {\n            sbrec_fdb_delete(fdb_e);\n        }\n    }\n}\n\nstruct service_monitor_info {\n    struct hmap_node hmap_node;\n    const struct sbrec_service_monitor *sbrec_mon;\n    bool required;\n};\n\n\nstatic struct service_monitor_info *\ncreate_or_get_service_mon(struct ovsdb_idl_txn *ovnsb_txn,\n                          struct hmap *monitor_map,\n                          const char *ip, const char *logical_port,\n                          uint16_t service_port, const char *protocol)\n{\n    uint32_t hash = service_port;\n    hash = hash_string(ip, hash);\n    hash = hash_string(logical_port, hash);\n    struct service_monitor_info *mon_info;\n\n    HMAP_FOR_EACH_WITH_HASH (mon_info, hmap_node, hash, monitor_map) {\n        if (mon_info->sbrec_mon->port == service_port &&\n            !strcmp(mon_info->sbrec_mon->ip, ip) &&\n            !strcmp(mon_info->sbrec_mon->protocol, protocol) &&\n            !strcmp(mon_info->sbrec_mon->logical_port, logical_port)) {\n            return mon_info;\n        }\n    }\n\n    struct sbrec_service_monitor *sbrec_mon =\n        sbrec_service_monitor_insert(ovnsb_txn);\n    sbrec_service_monitor_set_ip(sbrec_mon, ip);\n    sbrec_service_monitor_set_port(sbrec_mon, service_port);\n    sbrec_service_monitor_set_logical_port(sbrec_mon, logical_port);\n    sbrec_service_monitor_set_protocol(sbrec_mon, protocol);\n    mon_info = xzalloc(sizeof *mon_info);\n    mon_info->sbrec_mon = sbrec_mon;\n    hmap_insert(monitor_map, &mon_info->hmap_node, hash);\n    return mon_info;\n}\n\nstatic void\novn_lb_svc_create(struct ovsdb_idl_txn *ovnsb_txn, struct ovn_northd_lb *lb,\n                  struct hmap *monitor_map, struct hmap *ports)\n{\n    if (lb->template) {\n        return;\n    }\n\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n        struct ovn_northd_lb_vip *lb_vip_nb = &lb->vips_nb[i];\n\n        for (size_t j = 0; j < lb_vip->n_backends; j++) {\n            struct ovn_lb_backend *backend = &lb_vip->backends[j];\n            struct ovn_northd_lb_backend *backend_nb =\n                &lb_vip_nb->backends_nb[j];\n\n            struct ovn_port *op = NULL;\n            char *svc_mon_src_ip = NULL;\n\n            struct ds key = DS_EMPTY_INITIALIZER;\n            ds_put_format(&key,\n                          IN6_IS_ADDR_V4MAPPED(&lb_vip->vip)\n                          ? \"%s\" : \"[%s]\", backend->ip_str);\n\n            const char *s = smap_get(&lb->nlb->ip_port_mappings,\n                                     ds_cstr(&key));\n            if (s) {\n                char *port_name = xstrdup(s);\n                char *p = strstr(port_name, \":\");\n                if (p) {\n                    *p = 0;\n                    p++;\n                    op = ovn_port_find(ports, port_name);\n                    struct sockaddr_storage svc_mon_src_addr;\n                    if (!inet_parse_address(p, &svc_mon_src_addr)) {\n                        static struct vlog_rate_limit rl =\n                            VLOG_RATE_LIMIT_INIT(5, 1);\n                        VLOG_WARN_RL(&rl, \"Invalid svc mon src IP %s\", p);\n                    } else {\n                        struct ds src_ip_s = DS_EMPTY_INITIALIZER;\n                        ss_format_address_nobracks(&svc_mon_src_addr,\n                                                   &src_ip_s);\n                        svc_mon_src_ip = ds_steal_cstr(&src_ip_s);\n                    }\n                }\n                free(port_name);\n            }\n            ds_destroy(&key);\n\n            backend_nb->op = op;\n            backend_nb->svc_mon_src_ip = svc_mon_src_ip;\n\n            if (!lb_vip_nb->lb_health_check || !op || !svc_mon_src_ip ||\n                !lsp_is_enabled(op->nbsp)) {\n                continue;\n            }\n\n            const char *protocol = lb->nlb->protocol;\n            if (!protocol || !protocol[0]) {\n                protocol = \"tcp\";\n            }\n            backend_nb->health_check = true;\n            struct service_monitor_info *mon_info =\n                create_or_get_service_mon(ovnsb_txn, monitor_map,\n                                          backend->ip_str,\n                                          backend_nb->op->nbsp->name,\n                                          backend->port,\n                                          protocol);\n            ovs_assert(mon_info);\n            sbrec_service_monitor_set_options(\n                mon_info->sbrec_mon, &lb_vip_nb->lb_health_check->options);\n            struct eth_addr ea;\n            if (!mon_info->sbrec_mon->src_mac ||\n                !eth_addr_from_string(mon_info->sbrec_mon->src_mac, &ea) ||\n                !eth_addr_equals(ea, svc_monitor_mac_ea)) {\n                sbrec_service_monitor_set_src_mac(mon_info->sbrec_mon,\n                                                  svc_monitor_mac);\n            }\n\n            if (!mon_info->sbrec_mon->src_ip ||\n                strcmp(mon_info->sbrec_mon->src_ip,\n                       backend_nb->svc_mon_src_ip)) {\n                sbrec_service_monitor_set_src_ip(\n                    mon_info->sbrec_mon,\n                    backend_nb->svc_mon_src_ip);\n            }\n\n            if ((!op->sb->n_up || !op->sb->up[0])\n                && mon_info->sbrec_mon->status\n                && !strcmp(mon_info->sbrec_mon->status, \"online\")) {\n                sbrec_service_monitor_set_status(mon_info->sbrec_mon,\n                                                 \"offline\");\n            }\n\n            backend_nb->sbrec_monitor = mon_info->sbrec_mon;\n            mon_info->required = true;\n        }\n    }\n}\n\nstatic bool\nbuild_lb_vip_actions(struct ovn_lb_vip *lb_vip,\n                     struct ovn_northd_lb_vip *lb_vip_nb,\n                     struct ds *action, char *selection_fields,\n                     struct ds *skip_snat_action, struct ds *force_snat_action,\n                     bool ls_dp, const struct chassis_features *features)\n{\n    const char *ct_lb_action =\n        features->ct_no_masked_label ? \"ct_lb_mark\" : \"ct_lb\";\n    bool reject = !lb_vip->n_backends && lb_vip->empty_backend_rej;\n    bool drop = !lb_vip->n_backends && !lb_vip->empty_backend_rej;\n\n    if (lb_vip_nb->lb_health_check) {\n        ds_put_format(action, \"%s(backends=\", ct_lb_action);\n\n        size_t n_active_backends = 0;\n        for (size_t i = 0; i < lb_vip->n_backends; i++) {\n            struct ovn_lb_backend *backend = &lb_vip->backends[i];\n            struct ovn_northd_lb_backend *backend_nb =\n                &lb_vip_nb->backends_nb[i];\n            if (!backend_nb->health_check ||\n                (backend_nb->health_check && backend_nb->sbrec_monitor &&\n                 backend_nb->sbrec_monitor->status &&\n                 strcmp(backend_nb->sbrec_monitor->status, \"online\"))) {\n                continue;\n            }\n\n            n_active_backends++;\n            bool ipv6 = !IN6_IS_ADDR_V4MAPPED(&backend->ip);\n            ds_put_format(action, ipv6 ? \"[%s]:%\"PRIu16\",\" : \"%s:%\"PRIu16\",\",\n                          backend->ip_str, backend->port);\n        }\n        ds_chomp(action, ',');\n\n        drop = !n_active_backends && !lb_vip->empty_backend_rej;\n        reject = !n_active_backends && lb_vip->empty_backend_rej;\n    } else {\n        ds_put_format(action, \"%s(backends=%s\", ct_lb_action,\n                      lb_vip_nb->backend_ips);\n    }\n\n    if (reject) {\n        int stage = ls_dp ? ovn_stage_get_table(S_SWITCH_OUT_QOS_MARK)\n                          : ovn_stage_get_table(S_ROUTER_OUT_SNAT);\n        ds_clear(action);\n        ds_put_format(action, \"reg0 = 0; reject { outport <-> inport; \"\n                              \"next(pipeline=egress,table=%d);};\", stage);\n    } else if (drop) {\n        ds_clear(action);\n        ds_put_cstr(action, debug_drop_action());\n    } else if (selection_fields && selection_fields[0]) {\n        ds_put_format(action, \"; hash_fields=\\\"%s\\\"\", selection_fields);\n    }\n\n    bool is_lb_action = !(reject || drop);\n    const char *enclose = is_lb_action ? \");\" : \"\";\n\n    if (!ls_dp) {\n        bool flag_supported = is_lb_action && features->ct_lb_related;\n        ds_put_format(skip_snat_action, \"flags.skip_snat_for_lb = 1; %s%s\",\n                      ds_cstr(action),\n                      flag_supported ? \"; skip_snat);\" : enclose);\n        ds_put_format(force_snat_action, \"flags.force_snat_for_lb = 1; %s%s\",\n                      ds_cstr(action),\n                      flag_supported ? \"; force_snat);\" : enclose);\n    }\n\n    ds_put_cstr(action, enclose);\n\n    return reject;\n}\n\nstatic void\nbuild_lrouter_lb_ips(struct ovn_lb_ip_set *lb_ips,\n                     const struct ovn_northd_lb *lb)\n{\n    const char *ip_address;\n\n    SSET_FOR_EACH (ip_address, &lb->ips_v4) {\n        sset_add(&lb_ips->ips_v4, ip_address);\n        if (lb->routable) {\n            sset_add(&lb_ips->ips_v4_routable, ip_address);\n        }\n    }\n    SSET_FOR_EACH (ip_address, &lb->ips_v6) {\n        sset_add(&lb_ips->ips_v6, ip_address);\n        if (lb->routable) {\n            sset_add(&lb_ips->ips_v6_routable, ip_address);\n        }\n    }\n}\n\nstatic void\nbuild_lbs(struct northd_input *input_data, struct hmap *datapaths,\n          struct hmap *lbs, struct hmap *lb_groups)\n{\n    const struct nbrec_load_balancer_group *nbrec_lb_group;\n    struct ovn_lb_group *lb_group;\n    struct ovn_northd_lb *lb;\n\n    hmap_init(lbs);\n    hmap_init(lb_groups);\n\n    const struct nbrec_load_balancer *nbrec_lb;\n    NBREC_LOAD_BALANCER_TABLE_FOR_EACH (nbrec_lb,\n                               input_data->nbrec_load_balancer_table) {\n        struct ovn_northd_lb *lb_nb = ovn_northd_lb_create(nbrec_lb,\n                                                           n_datapaths);\n        hmap_insert(lbs, &lb_nb->hmap_node,\n                    uuid_hash(&nbrec_lb->header_.uuid));\n    }\n\n    NBREC_LOAD_BALANCER_GROUP_TABLE_FOR_EACH (nbrec_lb_group,\n                               input_data->nbrec_load_balancer_group_table) {\n        lb_group = ovn_lb_group_create(nbrec_lb_group, lbs,\n                                       hmap_count(datapaths));\n\n        for (size_t i = 0; i < lb_group->n_lbs; i++) {\n            build_lrouter_lb_ips(lb_group->lb_ips, lb_group->lbs[i]);\n        }\n\n        hmap_insert(lb_groups, &lb_group->hmap_node,\n                    uuid_hash(&lb_group->uuid));\n    }\n\n    struct ovn_datapath *od;\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs) {\n            continue;\n        }\n\n        for (size_t i = 0; i < od->nbs->n_load_balancer; i++) {\n            const struct uuid *lb_uuid =\n                &od->nbs->load_balancer[i]->header_.uuid;\n            lb = ovn_northd_lb_find(lbs, lb_uuid);\n            ovn_northd_lb_add_ls(lb, 1, &od);\n        }\n\n        for (size_t i = 0; i < od->nbs->n_load_balancer_group; i++) {\n            nbrec_lb_group = od->nbs->load_balancer_group[i];\n            lb_group = ovn_lb_group_find(lb_groups,\n                                         &nbrec_lb_group->header_.uuid);\n            ovn_lb_group_add_ls(lb_group, 1, &od);\n        }\n    }\n\n    HMAP_FOR_EACH (lb_group, hmap_node, lb_groups) {\n        for (size_t j = 0; j < lb_group->n_lbs; j++) {\n            ovn_northd_lb_add_ls(lb_group->lbs[j], lb_group->n_ls,\n                                 lb_group->ls);\n        }\n    }\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbr) {\n            continue;\n        }\n\n        /* Checking load balancer groups first, starting from the largest one,\n         * to more efficiently copy IP sets. */\n        size_t largest_group = 0;\n\n        for (size_t i = 1; i < od->nbr->n_load_balancer_group; i++) {\n            if (od->nbr->load_balancer_group[i]->n_load_balancer >\n                od->nbr->load_balancer_group[largest_group]->n_load_balancer) {\n                largest_group = i;\n            }\n        }\n\n        for (size_t i = 0; i < od->nbr->n_load_balancer_group; i++) {\n            size_t idx = (i + largest_group) % od->nbr->n_load_balancer_group;\n\n            nbrec_lb_group = od->nbr->load_balancer_group[idx];\n            lb_group = ovn_lb_group_find(lb_groups,\n                                         &nbrec_lb_group->header_.uuid);\n            ovn_lb_group_add_lr(lb_group, od);\n\n            if (!od->lb_ips) {\n                od->lb_ips = ovn_lb_ip_set_clone(lb_group->lb_ips);\n            } else {\n                for (size_t j = 0; j < lb_group->n_lbs; j++) {\n                    build_lrouter_lb_ips(od->lb_ips, lb_group->lbs[j]);\n                }\n            }\n        }\n\n        if (!od->lb_ips) {\n            od->lb_ips = ovn_lb_ip_set_create();\n        }\n\n        for (size_t i = 0; i < od->nbr->n_load_balancer; i++) {\n            const struct uuid *lb_uuid =\n                &od->nbr->load_balancer[i]->header_.uuid;\n            lb = ovn_northd_lb_find(lbs, lb_uuid);\n            ovn_northd_lb_add_lr(lb, 1, &od);\n            build_lrouter_lb_ips(od->lb_ips, lb);\n        }\n    }\n\n    HMAP_FOR_EACH (lb_group, hmap_node, lb_groups) {\n        for (size_t j = 0; j < lb_group->n_lbs; j++) {\n            ovn_northd_lb_add_lr(lb_group->lbs[j], lb_group->n_lr,\n                                 lb_group->lr);\n        }\n    }\n}\n\nstatic void\nbuild_lb_svcs(struct northd_input *input_data,\n              struct ovsdb_idl_txn *ovnsb_txn,\n              struct hmap *ports,\n              struct hmap *lbs)\n{\n    struct hmap monitor_map = HMAP_INITIALIZER(&monitor_map);\n\n    const struct sbrec_service_monitor *sbrec_mon;\n    SBREC_SERVICE_MONITOR_TABLE_FOR_EACH (sbrec_mon,\n                            input_data->sbrec_service_monitor_table) {\n        uint32_t hash = sbrec_mon->port;\n        hash = hash_string(sbrec_mon->ip, hash);\n        hash = hash_string(sbrec_mon->logical_port, hash);\n        struct service_monitor_info *mon_info = xzalloc(sizeof *mon_info);\n        mon_info->sbrec_mon = sbrec_mon;\n        mon_info->required = false;\n        hmap_insert(&monitor_map, &mon_info->hmap_node, hash);\n    }\n\n    struct ovn_northd_lb *lb;\n    HMAP_FOR_EACH (lb, hmap_node, lbs) {\n        ovn_lb_svc_create(ovnsb_txn, lb, &monitor_map, ports);\n    }\n\n    struct service_monitor_info *mon_info;\n    HMAP_FOR_EACH_POP (mon_info, hmap_node, &monitor_map) {\n        if (!mon_info->required) {\n            sbrec_service_monitor_delete(mon_info->sbrec_mon);\n        }\n\n        free(mon_info);\n    }\n    hmap_destroy(&monitor_map);\n}\n\nstatic bool lrouter_port_ipv4_reachable(const struct ovn_port *op,\n                                        ovs_be32 addr);\nstatic bool lrouter_port_ipv6_reachable(const struct ovn_port *op,\n                                        const struct in6_addr *addr);\nstatic void\nbuild_lrouter_lb_reachable_ips(struct ovn_datapath *od,\n                               const struct ovn_northd_lb *lb)\n{\n    /* If configured to not reply to any neighbor requests for all VIPs\n     * return early.\n     */\n    if (lb->neigh_mode == LB_NEIGH_RESPOND_NONE) {\n        return;\n    }\n\n    /* If configured to reply to neighbor requests for all VIPs force them\n     * all to be considered \"reachable\".\n     */\n    if (lb->neigh_mode == LB_NEIGH_RESPOND_ALL) {\n        for (size_t i = 0; i < lb->n_vips; i++) {\n            if (lb->vips[i].address_family == AF_INET) {\n                sset_add(&od->lb_ips->ips_v4_reachable, lb->vips[i].vip_str);\n            } else {\n                sset_add(&od->lb_ips->ips_v6_reachable, lb->vips[i].vip_str);\n            }\n        }\n        return;\n    }\n\n    /* Otherwise, a VIP is reachable if there's at least one router\n     * subnet that includes it.\n     */\n    ovs_assert(lb->neigh_mode == LB_NEIGH_RESPOND_REACHABLE);\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        if (lb->vips[i].address_family == AF_INET) {\n            ovs_be32 vip_ip4 = in6_addr_get_mapped_ipv4(&lb->vips[i].vip);\n            struct ovn_port *op;\n\n            LIST_FOR_EACH (op, dp_node, &od->port_list) {\n                if (lrouter_port_ipv4_reachable(op, vip_ip4)) {\n                    sset_add(&od->lb_ips->ips_v4_reachable,\n                             lb->vips[i].vip_str);\n                    break;\n                }\n            }\n        } else {\n            struct ovn_port *op;\n\n            LIST_FOR_EACH (op, dp_node, &od->port_list) {\n                if (lrouter_port_ipv6_reachable(op, &lb->vips[i].vip)) {\n                    sset_add(&od->lb_ips->ips_v6_reachable,\n                             lb->vips[i].vip_str);\n                    break;\n                }\n            }\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_lbs_check(const struct hmap *datapaths)\n{\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbr) {\n            continue;\n        }\n\n        if (od->has_lb_vip && od->n_l3dgw_ports > 1\n                && !smap_get(&od->nbr->options, \"chassis\")) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"Load-balancers are configured on logical \"\n                         \"router %s, which has %\"PRIuSIZE\" distributed \"\n                         \"gateway ports. Load-balancer is not supported \"\n                         \"yet when there is more than one distributed \"\n                         \"gateway port on the router.\",\n                         od->nbr->name, od->n_l3dgw_ports);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_lbs_reachable_ips(struct hmap *datapaths, struct hmap *lbs,\n                                struct hmap *lb_groups)\n{\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbr) {\n            continue;\n        }\n\n        for (size_t i = 0; i < od->nbr->n_load_balancer; i++) {\n            struct ovn_northd_lb *lb =\n                ovn_northd_lb_find(lbs,\n                                   &od->nbr->load_balancer[i]->header_.uuid);\n            build_lrouter_lb_reachable_ips(od, lb);\n        }\n\n        for (size_t i = 0; i < od->nbr->n_load_balancer_group; i++) {\n            const struct nbrec_load_balancer_group *nbrec_lb_group =\n                od->nbr->load_balancer_group[i];\n            struct ovn_lb_group *lb_group;\n\n            lb_group = ovn_lb_group_find(lb_groups,\n                                         &nbrec_lb_group->header_.uuid);\n            for (size_t j = 0; j < lb_group->n_lbs; j++) {\n                build_lrouter_lb_reachable_ips(od, lb_group->lbs[j]);\n            }\n        }\n    }\n}\n\nstatic void\nbuild_lswitch_lbs_from_lrouter(struct hmap *lbs, struct hmap *lb_groups)\n{\n    if (!install_ls_lb_from_router) {\n        return;\n    }\n\n    struct ovn_northd_lb *lb;\n    size_t index;\n\n    HMAP_FOR_EACH (lb, hmap_node, lbs) {\n        BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {\n            struct ovn_datapath *od = datapaths_array[index];\n            ovn_northd_lb_add_ls(lb, od->n_ls_peers, od->ls_peers);\n        }\n    }\n\n    struct ovn_lb_group *lb_group;\n    HMAP_FOR_EACH (lb_group, hmap_node, lb_groups) {\n        for (size_t i = 0; i < lb_group->n_lr; i++) {\n            struct ovn_datapath *od = lb_group->lr[i];\n            ovn_lb_group_add_ls(lb_group, od->n_ls_peers, od->ls_peers);\n            for (size_t j = 0; j < lb_group->n_lbs; j++) {\n                ovn_northd_lb_add_ls(lb_group->lbs[j], od->n_ls_peers,\n                                     od->ls_peers);\n            }\n        }\n    }\n}\n\nstatic void\nbuild_lb_count_dps(struct hmap *lbs)\n{\n    struct ovn_northd_lb *lb;\n\n    HMAP_FOR_EACH (lb, hmap_node, lbs) {\n        lb->n_nb_lr = bitmap_count1(lb->nb_lr_map, n_datapaths);\n        lb->n_nb_ls = bitmap_count1(lb->nb_ls_map, n_datapaths);\n    }\n}\n\n/* This must be called after all ports have been processed, i.e., after\n * build_ports() because the reachability check requires the router ports\n * networks to have been parsed.\n */\nstatic void\nbuild_lb_port_related_data(struct hmap *datapaths, struct hmap *ports,\n                           struct hmap *lbs, struct hmap *lb_groups,\n                           struct northd_input *input_data,\n                           struct ovsdb_idl_txn *ovnsb_txn)\n{\n    build_lrouter_lbs_check(datapaths);\n    build_lrouter_lbs_reachable_ips(datapaths, lbs, lb_groups);\n    build_lb_svcs(input_data, ovnsb_txn, ports, lbs);\n    build_lswitch_lbs_from_lrouter(lbs, lb_groups);\n}\n\n\nstruct ovn_dp_group {\n    unsigned long *bitmap;\n    struct sbrec_logical_dp_group *dp_group;\n    struct hmap_node node;\n};\n\nstatic struct ovn_dp_group *\novn_dp_group_find(const struct hmap *dp_groups,\n                  const unsigned long *dpg_bitmap, uint32_t hash)\n{\n    struct ovn_dp_group *dpg;\n\n    HMAP_FOR_EACH_WITH_HASH (dpg, node, hash, dp_groups) {\n        if (bitmap_equal(dpg->bitmap, dpg_bitmap, n_datapaths)) {\n            return dpg;\n        }\n    }\n    return NULL;\n}\n\nstatic struct sbrec_logical_dp_group *\novn_sb_insert_logical_dp_group(struct ovsdb_idl_txn *ovnsb_txn,\n                               const unsigned long *dpg_bitmap)\n{\n    struct sbrec_logical_dp_group *dp_group;\n    const struct sbrec_datapath_binding **sb;\n    size_t n = 0, index;\n\n    sb = xmalloc(bitmap_count1(dpg_bitmap, n_datapaths) * sizeof *sb);\n    BITMAP_FOR_EACH_1 (index, n_datapaths, dpg_bitmap) {\n        sb[n++] = datapaths_array[index]->sb;\n    }\n    dp_group = sbrec_logical_dp_group_insert(ovnsb_txn);\n    sbrec_logical_dp_group_set_datapaths(\n        dp_group, (struct sbrec_datapath_binding **) sb, n);\n    free(sb);\n\n    return dp_group;\n}\n\n/* Syncs relevant load balancers (applied to logical switches) to the\n * Southbound database.\n */\nstatic void\nsync_lbs(struct northd_input *input_data, struct ovsdb_idl_txn *ovnsb_txn,\n         struct hmap *datapaths, struct hmap *lbs)\n{\n    struct hmap dp_groups = HMAP_INITIALIZER(&dp_groups);\n    struct ovn_northd_lb *lb;\n\n    /* Delete any stale SB load balancer rows and collect existing valid\n     * datapath groups. */\n    struct hmapx existing_sb_dp_groups =\n        HMAPX_INITIALIZER(&existing_sb_dp_groups);\n    struct hmapx existing_lbs = HMAPX_INITIALIZER(&existing_lbs);\n    const struct sbrec_load_balancer *sbrec_lb;\n    SBREC_LOAD_BALANCER_TABLE_FOR_EACH_SAFE (sbrec_lb,\n                            input_data->sbrec_load_balancer_table) {\n        const char *nb_lb_uuid = smap_get(&sbrec_lb->external_ids, \"lb_id\");\n        struct uuid lb_uuid;\n        if (!nb_lb_uuid || !uuid_from_string(&lb_uuid, nb_lb_uuid)) {\n            sbrec_load_balancer_delete(sbrec_lb);\n            continue;\n        }\n\n        /* Delete any SB load balancer entries that refer to NB load balancers\n         * that don't exist anymore or are not applied to switches anymore.\n         *\n         * There is also a special case in which duplicate LBs might be created\n         * in the SB, e.g., due to the fact that OVSDB only ensures\n         * \"at-least-once\" consistency for clustered database tables that\n         * are not indexed in any way.\n         */\n        lb = ovn_northd_lb_find(lbs, &lb_uuid);\n        if (!lb || !lb->n_nb_ls || !hmapx_add(&existing_lbs, lb)) {\n            sbrec_load_balancer_delete(sbrec_lb);\n            continue;\n        }\n\n        lb->slb = sbrec_lb;\n\n        /* Collect the datapath group. */\n        struct sbrec_logical_dp_group *dp_group = sbrec_lb->datapath_group;\n\n        if (!dp_group || !hmapx_add(&existing_sb_dp_groups, dp_group)) {\n            continue;\n        }\n\n        struct ovn_dp_group *dpg = xzalloc(sizeof *dpg);\n        size_t i, n = 0;\n\n        dpg->bitmap = bitmap_allocate(n_datapaths);\n        for (i = 0; i < dp_group->n_datapaths; i++) {\n            struct ovn_datapath *datapath_od;\n\n            datapath_od = ovn_datapath_from_sbrec(datapaths,\n                                                  dp_group->datapaths[i]);\n            if (!datapath_od || ovn_datapath_is_stale(datapath_od)) {\n                break;\n            }\n            bitmap_set1(dpg->bitmap, datapath_od->index);\n            n++;\n        }\n        if (i == dp_group->n_datapaths) {\n            uint32_t hash = hash_int(n, 0);\n\n            if (!ovn_dp_group_find(&dp_groups, dpg->bitmap, hash)) {\n                dpg->dp_group = dp_group;\n                hmap_insert(&dp_groups, &dpg->node, hash);\n                continue;\n            }\n        }\n        bitmap_free(dpg->bitmap);\n        free(dpg);\n    }\n    hmapx_destroy(&existing_lbs);\n    hmapx_destroy(&existing_sb_dp_groups);\n\n    /* Create SB Load balancer records if not present and sync\n     * the SB load balancer columns. */\n    HMAP_FOR_EACH (lb, hmap_node, lbs) {\n\n        if (!lb->n_nb_ls) {\n            continue;\n        }\n\n        /* Store the fact that northd provides the original (destination IP +\n         * transport port) tuple.\n         */\n        struct smap options;\n        smap_clone(&options, &lb->nlb->options);\n        smap_replace(&options, \"hairpin_orig_tuple\", \"true\");\n\n        if (!lb->slb) {\n            sbrec_lb = sbrec_load_balancer_insert(ovnsb_txn);\n            lb->slb = sbrec_lb;\n            char *lb_id = xasprintf(\n                UUID_FMT, UUID_ARGS(&lb->nlb->header_.uuid));\n            const struct smap external_ids =\n                SMAP_CONST1(&external_ids, \"lb_id\", lb_id);\n            sbrec_load_balancer_set_external_ids(sbrec_lb, &external_ids);\n            free(lb_id);\n        }\n\n        /* Find datapath group for this load balancer. */\n        struct ovn_dp_group *dpg;\n        uint32_t hash;\n\n        hash = hash_int(lb->n_nb_ls, 0);\n        dpg = ovn_dp_group_find(&dp_groups, lb->nb_ls_map, hash);\n        if (!dpg) {\n            dpg = xzalloc(sizeof *dpg);\n            dpg->dp_group = ovn_sb_insert_logical_dp_group(ovnsb_txn,\n                                                           lb->nb_ls_map);\n            dpg->bitmap = bitmap_clone(lb->nb_ls_map, n_datapaths);\n            hmap_insert(&dp_groups, &dpg->node, hash);\n        }\n\n        /* Update columns. */\n        sbrec_load_balancer_set_name(lb->slb, lb->nlb->name);\n        sbrec_load_balancer_set_vips(lb->slb, ovn_northd_lb_get_vips(lb));\n        sbrec_load_balancer_set_protocol(lb->slb, lb->nlb->protocol);\n        sbrec_load_balancer_set_datapath_group(lb->slb, dpg->dp_group);\n        sbrec_load_balancer_set_options(lb->slb, &options);\n        /* Clearing 'datapaths' column, since 'dp_group' is in use. */\n        sbrec_load_balancer_set_datapaths(lb->slb, NULL, 0);\n        smap_destroy(&options);\n    }\n\n    struct ovn_dp_group *dpg;\n    HMAP_FOR_EACH_POP (dpg, node, &dp_groups) {\n        bitmap_free(dpg->bitmap);\n        free(dpg);\n    }\n    hmap_destroy(&dp_groups);\n\n    /* Datapath_Binding.load_balancers is not used anymore, it's still in the\n     * schema for compatibility reasons.  Reset it to empty, just in case.\n     */\n    struct ovn_datapath *od;\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs) {\n            continue;\n        }\n\n        if (od->sb->n_load_balancers) {\n            sbrec_datapath_binding_set_load_balancers(od->sb, NULL, 0);\n        }\n    }\n}\n\nstatic bool\novn_port_add_tnlid(struct ovn_port *op, uint32_t tunnel_key)\n{\n    bool added = ovn_add_tnlid(&op->od->port_tnlids, tunnel_key);\n    if (added) {\n        op->tunnel_key = tunnel_key;\n        if (tunnel_key > op->od->port_key_hint) {\n            op->od->port_key_hint = tunnel_key;\n        }\n    }\n    return added;\n}\n\nstatic void\novn_port_assign_requested_tnl_id(struct northd_input *input_data,\n                                 struct ovn_port *op)\n{\n    const struct smap *options = (op->nbsp\n                                  ? &op->nbsp->options\n                                  : &op->nbrp->options);\n    uint32_t tunnel_key = smap_get_int(options, \"requested-tnl-key\", 0);\n    if (tunnel_key) {\n        if (is_vxlan_mode(input_data) &&\n                tunnel_key >= OVN_VXLAN_MIN_MULTICAST) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"Tunnel key %\"PRIu32\" for port %s \"\n                         \"is incompatible with VXLAN\",\n                         tunnel_key, op_get_name(op));\n            return;\n        }\n        if (!ovn_port_add_tnlid(op, tunnel_key)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"Logical %s port %s requests same tunnel key \"\n                         \"%\"PRIu32\" as another LSP or LRP\",\n                         op->nbsp ? \"switch\" : \"router\",\n                         op_get_name(op), tunnel_key);\n        }\n    }\n}\n\nstatic void\novn_port_allocate_key(struct northd_input *input_data,\n                      struct hmap *ports,\n                      struct ovn_port *op)\n{\n    if (!op->tunnel_key) {\n        uint8_t key_bits = is_vxlan_mode(input_data)? 12 : 16;\n        op->tunnel_key = ovn_allocate_tnlid(&op->od->port_tnlids, \"port\",\n                                            1, (1u << (key_bits - 1)) - 1,\n                                            &op->od->port_key_hint);\n        if (!op->tunnel_key) {\n            if (op->sb) {\n                sbrec_port_binding_delete(op->sb);\n            }\n            ovs_list_remove(&op->list);\n            ovn_port_destroy(ports, op);\n        }\n    }\n}\n\n/* Updates the southbound Port_Binding table so that it contains the logical\n * switch ports specified by the northbound database.\n *\n * Initializes 'ports' to contain a \"struct ovn_port\" for every logical port,\n * using the \"struct ovn_datapath\"s in 'datapaths' to look up logical\n * datapaths. */\nstatic void\nbuild_ports(struct northd_input *input_data,\n            struct ovsdb_idl_txn *ovnsb_txn,\n            struct ovsdb_idl_index *sbrec_chassis_by_name,\n            struct ovsdb_idl_index *sbrec_chassis_by_hostname,\n            struct hmap *datapaths, struct hmap *ports)\n{\n    struct ovs_list sb_only, nb_only, both;\n    struct hmap tag_alloc_table = HMAP_INITIALIZER(&tag_alloc_table);\n    struct hmap chassis_qdisc_queues = HMAP_INITIALIZER(&chassis_qdisc_queues);\n\n    /* sset which stores the set of ha chassis group names used. */\n    struct sset active_ha_chassis_grps =\n        SSET_INITIALIZER(&active_ha_chassis_grps);\n\n    join_logical_ports(input_data,\n                       datapaths, ports, &chassis_qdisc_queues,\n                       &tag_alloc_table, &sb_only, &nb_only, &both);\n\n    /* Purge stale Mac_Bindings if ports are deleted. */\n    bool remove_mac_bindings = !ovs_list_is_empty(&sb_only);\n\n    /* Assign explicitly requested tunnel ids first. */\n    struct ovn_port *op;\n    LIST_FOR_EACH (op, list, &both) {\n        ovn_port_assign_requested_tnl_id(input_data, op);\n    }\n    LIST_FOR_EACH (op, list, &nb_only) {\n        ovn_port_assign_requested_tnl_id(input_data, op);\n    }\n\n    /* Keep nonconflicting tunnel IDs that are already assigned. */\n    LIST_FOR_EACH (op, list, &both) {\n        if (!op->tunnel_key) {\n            ovn_port_add_tnlid(op, op->sb->tunnel_key);\n        }\n    }\n\n    /* Assign new tunnel ids where needed. */\n    LIST_FOR_EACH_SAFE (op, list, &both) {\n        ovn_port_allocate_key(input_data, ports, op);\n    }\n    LIST_FOR_EACH_SAFE (op, list, &nb_only) {\n        ovn_port_allocate_key(input_data, ports, op);\n    }\n\n    /* For logical ports that are in both databases, update the southbound\n     * record based on northbound data.\n     * For logical ports that are in NB database, do any tag allocation\n     * needed. */\n    LIST_FOR_EACH_SAFE (op, list, &both) {\n        /* When reusing stale Port_Bindings, make sure that stale\n         * Mac_Bindings are purged.\n         */\n        if (op->od->sb != op->sb->datapath) {\n            remove_mac_bindings = true;\n        }\n        if (op->nbsp) {\n            tag_alloc_create_new_tag(&tag_alloc_table, op->nbsp);\n        }\n        ovn_port_update_sbrec(input_data,\n                              ovnsb_txn, sbrec_chassis_by_name,\n                              sbrec_chassis_by_hostname,\n                              op, &chassis_qdisc_queues,\n                              &active_ha_chassis_grps);\n    }\n\n    /* Add southbound record for each unmatched northbound record. */\n    LIST_FOR_EACH_SAFE (op, list, &nb_only) {\n        op->sb = sbrec_port_binding_insert(ovnsb_txn);\n        ovn_port_update_sbrec(input_data,\n                              ovnsb_txn, sbrec_chassis_by_name,\n                              sbrec_chassis_by_hostname, op,\n                              &chassis_qdisc_queues,\n                              &active_ha_chassis_grps);\n        sbrec_port_binding_set_logical_port(op->sb, op->key);\n    }\n\n    /* Delete southbound records without northbound matches. */\n    if (!ovs_list_is_empty(&sb_only)) {\n        LIST_FOR_EACH_SAFE (op, list, &sb_only) {\n            ovs_list_remove(&op->list);\n            sbrec_port_binding_delete(op->sb);\n            ovn_port_destroy(ports, op);\n        }\n    }\n    if (remove_mac_bindings) {\n        cleanup_mac_bindings(input_data, datapaths, ports);\n    }\n\n    tag_alloc_destroy(&tag_alloc_table);\n    destroy_chassis_queues(&chassis_qdisc_queues);\n    cleanup_sb_ha_chassis_groups(input_data, &active_ha_chassis_grps);\n    sset_destroy(&active_ha_chassis_grps);\n}\n\nstruct multicast_group {\n    const char *name;\n    uint16_t key;               /* OVN_MIN_MULTICAST...OVN_MAX_MULTICAST. */\n};\n\n#define MC_FLOOD \"_MC_flood\"\nstatic const struct multicast_group mc_flood =\n    { MC_FLOOD, OVN_MCAST_FLOOD_TUNNEL_KEY };\n\n#define MC_MROUTER_FLOOD \"_MC_mrouter_flood\"\nstatic const struct multicast_group mc_mrouter_flood =\n    { MC_MROUTER_FLOOD, OVN_MCAST_MROUTER_FLOOD_TUNNEL_KEY };\n\n#define MC_STATIC \"_MC_static\"\nstatic const struct multicast_group mc_static =\n    { MC_STATIC, OVN_MCAST_STATIC_TUNNEL_KEY };\n\n#define MC_UNKNOWN \"_MC_unknown\"\nstatic const struct multicast_group mc_unknown =\n    { MC_UNKNOWN, OVN_MCAST_UNKNOWN_TUNNEL_KEY };\n\n#define MC_FLOOD_L2 \"_MC_flood_l2\"\nstatic const struct multicast_group mc_flood_l2 =\n    { MC_FLOOD_L2, OVN_MCAST_FLOOD_L2_TUNNEL_KEY };\n\nstatic bool\nmulticast_group_equal(const struct multicast_group *a,\n                      const struct multicast_group *b)\n{\n    return !strcmp(a->name, b->name) && a->key == b->key;\n}\n\n/* Multicast group entry. */\nstruct ovn_multicast {\n    struct hmap_node hmap_node; /* Index on 'datapath' and 'key'. */\n    struct ovn_datapath *datapath;\n    const struct multicast_group *group;\n\n    struct ovn_port **ports;\n    size_t n_ports, allocated_ports;\n};\n\nstatic uint32_t\novn_multicast_hash(const struct ovn_datapath *datapath,\n                   const struct multicast_group *group)\n{\n    return hash_pointer(datapath, group->key);\n}\n\nstatic struct ovn_multicast *\novn_multicast_find(struct hmap *mcgroups, struct ovn_datapath *datapath,\n                   const struct multicast_group *group)\n{\n    struct ovn_multicast *mc;\n\n    HMAP_FOR_EACH_WITH_HASH (mc, hmap_node,\n                             ovn_multicast_hash(datapath, group), mcgroups) {\n        if (mc->datapath == datapath\n            && multicast_group_equal(mc->group, group)) {\n            return mc;\n        }\n    }\n    return NULL;\n}\n\nstatic void\novn_multicast_add_ports(struct hmap *mcgroups, struct ovn_datapath *od,\n                        const struct multicast_group *group,\n                        struct ovn_port **ports, size_t n_ports)\n{\n    struct ovn_multicast *mc = ovn_multicast_find(mcgroups, od, group);\n    if (!mc) {\n        mc = xmalloc(sizeof *mc);\n        hmap_insert(mcgroups, &mc->hmap_node, ovn_multicast_hash(od, group));\n        mc->datapath = od;\n        mc->group = group;\n        mc->n_ports = 0;\n        mc->allocated_ports = 4;\n        mc->ports = xmalloc(mc->allocated_ports * sizeof *mc->ports);\n    }\n\n    size_t n_ports_total = mc->n_ports + n_ports;\n\n    if (n_ports_total > 2 * mc->allocated_ports) {\n        mc->allocated_ports = n_ports_total;\n        mc->ports = xrealloc(mc->ports,\n                             mc->allocated_ports * sizeof *mc->ports);\n    } else if (n_ports_total > mc->allocated_ports) {\n        mc->ports = x2nrealloc(mc->ports, &mc->allocated_ports,\n                               sizeof *mc->ports);\n    }\n\n    memcpy(&mc->ports[mc->n_ports], &ports[0], n_ports * sizeof *ports);\n    mc->n_ports += n_ports;\n}\n\nstatic void\novn_multicast_add(struct hmap *mcgroups, const struct multicast_group *group,\n                  struct ovn_port *port)\n{\n    /* Store the chassis redirect port otherwise traffic will not be tunneled\n     * properly.\n     */\n    if (port->cr_port) {\n        port = port->cr_port;\n    }\n    ovn_multicast_add_ports(mcgroups, port->od, group, &port, 1);\n}\n\nstatic void\novn_multicast_destroy(struct hmap *mcgroups, struct ovn_multicast *mc)\n{\n    if (mc) {\n        hmap_remove(mcgroups, &mc->hmap_node);\n        free(mc->ports);\n        free(mc);\n    }\n}\n\nstatic void\novn_multicast_update_sbrec(const struct ovn_multicast *mc,\n                           const struct sbrec_multicast_group *sb)\n{\n    struct sbrec_port_binding **ports = xmalloc(mc->n_ports * sizeof *ports);\n    for (size_t i = 0; i < mc->n_ports; i++) {\n        ports[i] = CONST_CAST(struct sbrec_port_binding *, mc->ports[i]->sb);\n    }\n    sbrec_multicast_group_set_ports(sb, ports, mc->n_ports);\n    free(ports);\n}\n\n/*\n * IGMP group entry (1:1 mapping to SB database).\n */\nstruct ovn_igmp_group_entry {\n    struct ovs_list list_node; /* Linkage in the list of entries. */\n    size_t n_ports;\n    struct ovn_port **ports;\n};\n\n/*\n * IGMP group entry (aggregate of all entries from the SB database\n * corresponding to the multicast group).\n */\nstruct ovn_igmp_group {\n    struct hmap_node hmap_node; /* Index on 'datapath' and 'address'. */\n    struct ovs_list list_node;  /* Linkage in the per-dp igmp group list. */\n\n    struct ovn_datapath *datapath;\n    struct in6_addr address; /* Multicast IPv6-mapped-IPv4 or IPv4 address. */\n    struct multicast_group mcgroup;\n\n    struct ovs_list entries; /* List of SB entries for this group. */\n};\n\nstatic uint32_t\novn_igmp_group_hash(const struct ovn_datapath *datapath,\n                    const struct in6_addr *address)\n{\n    return hash_pointer(datapath, hash_bytes(address, sizeof *address, 0));\n}\n\nstatic struct ovn_igmp_group *\novn_igmp_group_find(struct hmap *igmp_groups,\n                    const struct ovn_datapath *datapath,\n                    const struct in6_addr *address)\n{\n    struct ovn_igmp_group *group;\n\n    HMAP_FOR_EACH_WITH_HASH (group, hmap_node,\n                             ovn_igmp_group_hash(datapath, address),\n                             igmp_groups) {\n        if (group->datapath == datapath &&\n                ipv6_addr_equals(&group->address, address)) {\n            return group;\n        }\n    }\n    return NULL;\n}\n\nstatic struct ovn_igmp_group *\novn_igmp_group_add(struct lflow_input *input_data,\n                   struct hmap *igmp_groups,\n                   struct ovn_datapath *datapath,\n                   const struct in6_addr *address,\n                   const char *address_s)\n{\n    struct ovn_igmp_group *igmp_group =\n        ovn_igmp_group_find(igmp_groups, datapath, address);\n\n    if (!igmp_group) {\n        igmp_group = xmalloc(sizeof *igmp_group);\n\n        const struct sbrec_multicast_group *mcgroup =\n            mcast_group_lookup(input_data->sbrec_mcast_group_by_name_dp,\n                               address_s,\n                               datapath->sb);\n\n        igmp_group->datapath = datapath;\n        igmp_group->address = *address;\n        if (mcgroup) {\n            igmp_group->mcgroup.key = mcgroup->tunnel_key;\n            ovn_add_tnlid(&datapath->mcast_info.group_tnlids,\n                          mcgroup->tunnel_key);\n        } else {\n            igmp_group->mcgroup.key = 0;\n        }\n        igmp_group->mcgroup.name = address_s;\n        ovs_list_init(&igmp_group->entries);\n\n        hmap_insert(igmp_groups, &igmp_group->hmap_node,\n                    ovn_igmp_group_hash(datapath, address));\n        ovs_list_push_back(&datapath->mcast_info.groups,\n                           &igmp_group->list_node);\n    }\n\n    return igmp_group;\n}\n\nstatic bool\novn_igmp_group_get_address(const struct sbrec_igmp_group *sb_igmp_group,\n                           struct in6_addr *address)\n{\n    ovs_be32 ipv4;\n\n    if (ip_parse(sb_igmp_group->address, &ipv4)) {\n        *address = in6_addr_mapped_ipv4(ipv4);\n        return true;\n    }\n    if (!ipv6_parse(sb_igmp_group->address, address)) {\n        return false;\n    }\n    return true;\n}\n\nstatic struct ovn_port **\novn_igmp_group_get_ports(const struct sbrec_igmp_group *sb_igmp_group,\n                         size_t *n_ports, const struct hmap *ovn_ports)\n{\n    struct ovn_port **ports = NULL;\n\n     *n_ports = 0;\n     for (size_t i = 0; i < sb_igmp_group->n_ports; i++) {\n        struct ovn_port *port =\n            ovn_port_find(ovn_ports, sb_igmp_group->ports[i]->logical_port);\n\n        if (!port || !port->nbsp) {\n            continue;\n        }\n\n        /* If this is already a flood port skip it for the group. */\n        if (port->mcast_info.flood) {\n            continue;\n        }\n\n        /* If this is already a port of a router on which relay is enabled,\n         * skip it for the group. Traffic is flooded there anyway.\n         */\n        if (port->peer && port->peer->od &&\n                port->peer->od->mcast_info.rtr.relay) {\n            continue;\n        }\n\n        if (ports == NULL) {\n            ports = xmalloc(sb_igmp_group->n_ports * sizeof *ports);\n        }\n\n        ports[(*n_ports)] = port;\n        (*n_ports)++;\n    }\n\n    return ports;\n}\n\nstatic void\novn_igmp_group_add_entry(struct ovn_igmp_group *igmp_group,\n                         struct ovn_port **ports, size_t n_ports)\n{\n    struct ovn_igmp_group_entry *entry = xmalloc(sizeof *entry);\n\n    entry->ports = ports;\n    entry->n_ports = n_ports;\n    ovs_list_push_back(&igmp_group->entries, &entry->list_node);\n}\n\nstatic void\novn_igmp_group_destroy_entry(struct ovn_igmp_group_entry *entry)\n{\n    free(entry->ports);\n}\n\nstatic bool\novn_igmp_group_allocate_id(struct ovn_igmp_group *igmp_group)\n{\n    if (igmp_group->mcgroup.key == 0) {\n        struct mcast_info *mcast_info = &igmp_group->datapath->mcast_info;\n        igmp_group->mcgroup.key = ovn_mcast_group_allocate_key(mcast_info);\n    }\n\n    if (igmp_group->mcgroup.key == 0) {\n        return false;\n    }\n\n    return true;\n}\n\nstatic void\novn_igmp_mrouter_aggregate_ports(struct ovn_igmp_group *igmp_group,\n                                 struct hmap *mcast_groups)\n{\n    struct ovn_igmp_group_entry *entry;\n\n    LIST_FOR_EACH_POP (entry, list_node, &igmp_group->entries) {\n        ovn_multicast_add_ports(mcast_groups, igmp_group->datapath,\n                                &mc_mrouter_flood, entry->ports,\n                                entry->n_ports);\n\n        ovn_igmp_group_destroy_entry(entry);\n        free(entry);\n    }\n}\n\nstatic void\novn_igmp_group_aggregate_ports(struct ovn_igmp_group *igmp_group,\n                               struct hmap *mcast_groups)\n{\n    struct ovn_igmp_group_entry *entry;\n\n    LIST_FOR_EACH_POP (entry, list_node, &igmp_group->entries) {\n        ovn_multicast_add_ports(mcast_groups, igmp_group->datapath,\n                                &igmp_group->mcgroup, entry->ports,\n                                entry->n_ports);\n\n        ovn_igmp_group_destroy_entry(entry);\n        free(entry);\n    }\n\n    if (igmp_group->datapath->n_localnet_ports) {\n        ovn_multicast_add_ports(mcast_groups, igmp_group->datapath,\n                                &igmp_group->mcgroup,\n                                igmp_group->datapath->localnet_ports,\n                                igmp_group->datapath->n_localnet_ports);\n    }\n}\n\nstatic void\novn_igmp_group_destroy(struct hmap *igmp_groups,\n                       struct ovn_igmp_group *igmp_group)\n{\n    if (igmp_group) {\n        struct ovn_igmp_group_entry *entry;\n\n        LIST_FOR_EACH_POP (entry, list_node, &igmp_group->entries) {\n            ovn_igmp_group_destroy_entry(entry);\n            free(entry);\n        }\n        hmap_remove(igmp_groups, &igmp_group->hmap_node);\n        ovs_list_remove(&igmp_group->list_node);\n        free(igmp_group);\n    }\n}\n\n/* Logical flow generation.\n *\n * This code generates the Logical_Flow table in the southbound database, as a\n * function of most of the northbound database.\n */\n\nstruct ovn_lflow {\n    struct hmap_node hmap_node;\n\n    struct ovn_datapath *od;     /* 'logical_datapath' in SB schema.  */\n    unsigned long *dpg_bitmap;   /* Bitmap of all datapaths by their 'index'.*/\n    enum ovn_stage stage;\n    uint16_t priority;\n    char *match;\n    char *actions;\n    char *io_port;\n    char *stage_hint;\n    char *ctrl_meter;\n    struct ovn_dp_group *dpg;    /* Link to unique Sb datapath group. */\n    const char *where;\n};\n\nstatic void ovn_lflow_destroy(struct hmap *lflows, struct ovn_lflow *lflow);\nstatic struct ovn_lflow *ovn_lflow_find(const struct hmap *lflows,\n                                        const struct ovn_datapath *od,\n                                        enum ovn_stage stage,\n                                        uint16_t priority, const char *match,\n                                        const char *actions,\n                                        const char *ctrl_meter, uint32_t hash);\n\nstatic char *\novn_lflow_hint(const struct ovsdb_idl_row *row)\n{\n    if (!row) {\n        return NULL;\n    }\n    return xasprintf(\"%08x\", row->uuid.parts[0]);\n}\n\nstatic bool\novn_lflow_equal(const struct ovn_lflow *a, const struct ovn_datapath *od,\n                enum ovn_stage stage, uint16_t priority, const char *match,\n                const char *actions, const char *ctrl_meter)\n{\n    return (a->od == od\n            && a->stage == stage\n            && a->priority == priority\n            && !strcmp(a->match, match)\n            && !strcmp(a->actions, actions)\n            && nullable_string_is_equal(a->ctrl_meter, ctrl_meter));\n}\n\nenum {\n    STATE_NULL,               /* parallelization is off */\n    STATE_INIT_HASH_SIZES,    /* parallelization is on; hashes sizing needed */\n    STATE_USE_PARALLELIZATION /* parallelization is on */\n};\nstatic int parallelization_state = STATE_NULL;\n\nstatic void\novn_lflow_init(struct ovn_lflow *lflow, struct ovn_datapath *od,\n               enum ovn_stage stage, uint16_t priority,\n               char *match, char *actions, char *io_port, char *ctrl_meter,\n               char *stage_hint, const char *where)\n{\n    lflow->dpg_bitmap = bitmap_allocate(n_datapaths);\n    lflow->od = od;\n    lflow->stage = stage;\n    lflow->priority = priority;\n    lflow->match = match;\n    lflow->actions = actions;\n    lflow->io_port = io_port;\n    lflow->stage_hint = stage_hint;\n    lflow->ctrl_meter = ctrl_meter;\n    lflow->dpg = NULL;\n    lflow->where = where;\n}\n\n/* The lflow_hash_lock is a mutex array that protects updates to the shared\n * lflow table across threads when parallel lflow build and dp-group are both\n * enabled. To avoid high contention between threads, a big array of mutexes\n * are used instead of just one. This is possible because when parallel build\n * is used we only use hmap_insert_fast() to update the hmap, which would not\n * touch the bucket array but only the list in a single bucket. We only need to\n * make sure that when adding lflows to the same hash bucket, the same lock is\n * used, so that no two threads can add to the bucket at the same time.  It is\n * ok that the same lock is used to protect multiple buckets, so a fixed sized\n * mutex array is used instead of 1-1 mapping to the hash buckets. This\n * simplies the implementation while effectively reduces lock contention\n * because the chance that different threads contending the same lock amongst\n * the big number of locks is very low. */\n#define LFLOW_HASH_LOCK_MASK 0xFFFF\nstatic struct ovs_mutex lflow_hash_locks[LFLOW_HASH_LOCK_MASK + 1];\n\nstatic void\nlflow_hash_lock_init(void)\n{\n    if (!lflow_hash_lock_initialized) {\n        for (size_t i = 0; i < LFLOW_HASH_LOCK_MASK + 1; i++) {\n            ovs_mutex_init(&lflow_hash_locks[i]);\n        }\n        lflow_hash_lock_initialized = true;\n    }\n}\n\nstatic void\nlflow_hash_lock_destroy(void)\n{\n    if (lflow_hash_lock_initialized) {\n        for (size_t i = 0; i < LFLOW_HASH_LOCK_MASK + 1; i++) {\n            ovs_mutex_destroy(&lflow_hash_locks[i]);\n        }\n    }\n    lflow_hash_lock_initialized = false;\n}\n\n/* Full thread safety analysis is not possible with hash locks, because\n * they are taken conditionally based on the 'parallelization_state' and\n * a flow hash.  Also, the order in which two hash locks are taken is not\n * predictable during the static analysis.\n *\n * Since the order of taking two locks depends on a random hash, to avoid\n * ABBA deadlocks, no two hash locks can be nested.  In that sense an array\n * of hash locks is similar to a single mutex.\n *\n * Using a fake mutex to partially simulate thread safety restrictions, as\n * if it were actually a single mutex.\n *\n * OVS_NO_THREAD_SAFETY_ANALYSIS below allows us to ignore conditional\n * nature of the lock.  Unlike other attributes, it applies to the\n * implementation and not to the interface.  So, we can define a function\n * that acquires the lock without analysing the way it does that.\n */\nextern struct ovs_mutex fake_hash_mutex;\n\nstatic struct ovs_mutex *\nlflow_hash_lock(const struct hmap *lflow_map, uint32_t hash)\n    OVS_ACQUIRES(fake_hash_mutex)\n    OVS_NO_THREAD_SAFETY_ANALYSIS\n{\n    struct ovs_mutex *hash_lock = NULL;\n\n    if (parallelization_state == STATE_USE_PARALLELIZATION) {\n        hash_lock =\n            &lflow_hash_locks[hash & lflow_map->mask & LFLOW_HASH_LOCK_MASK];\n        ovs_mutex_lock(hash_lock);\n    }\n    return hash_lock;\n}\n\nstatic void\nlflow_hash_unlock(struct ovs_mutex *hash_lock)\n    OVS_RELEASES(fake_hash_mutex)\n    OVS_NO_THREAD_SAFETY_ANALYSIS\n{\n    if (hash_lock) {\n        ovs_mutex_unlock(hash_lock);\n    }\n}\n\n\n/* This thread-local var is used for parallel lflow building when dp-groups is\n * enabled. It maintains the number of lflows inserted by the current thread to\n * the shared lflow hmap in the current iteration. It is needed because the\n * lflow_hash_lock cannot protect current update of the hmap's size (hmap->n)\n * by different threads.\n *\n * When all threads complete the tasks of an iteration, the counters of all the\n * threads are collected to fix the lflow hmap's size (by the function\n * fix_flow_map_size()).\n * */\nstatic thread_local size_t thread_lflow_counter = 0;\n\n/* Adds an OVN datapath to a datapath group of existing logical flow.\n * Version to use when hash bucket locking is NOT required or the corresponding\n * hash lock is already taken. */\nstatic void\novn_dp_group_add_with_reference(struct ovn_lflow *lflow_ref,\n                                const struct ovn_datapath *od,\n                                const unsigned long *dp_bitmap)\n    OVS_REQUIRES(fake_hash_mutex)\n{\n    if (od) {\n        bitmap_set1(lflow_ref->dpg_bitmap, od->index);\n    }\n    if (dp_bitmap) {\n        bitmap_or(lflow_ref->dpg_bitmap, dp_bitmap, n_datapaths);\n    }\n}\n\n/* Adds a row with the specified contents to the Logical_Flow table.\n * Version to use when hash bucket locking is NOT required.\n */\nstatic void\ndo_ovn_lflow_add(struct hmap *lflow_map, const struct ovn_datapath *od,\n                 const unsigned long *dp_bitmap,\n                 uint32_t hash, enum ovn_stage stage, uint16_t priority,\n                 const char *match, const char *actions, const char *io_port,\n                 const struct ovsdb_idl_row *stage_hint,\n                 const char *where, const char *ctrl_meter)\n    OVS_REQUIRES(fake_hash_mutex)\n{\n\n    struct ovn_lflow *old_lflow;\n    struct ovn_lflow *lflow;\n\n    old_lflow = ovn_lflow_find(lflow_map, NULL, stage, priority, match,\n                               actions, ctrl_meter, hash);\n    if (old_lflow) {\n        ovn_dp_group_add_with_reference(old_lflow, od, dp_bitmap);\n        return;\n    }\n\n    lflow = xmalloc(sizeof *lflow);\n    /* While adding new logical flows we're not setting single datapath, but\n     * collecting a group.  'od' will be updated later for all flows with only\n     * one datapath in a group, so it could be hashed correctly. */\n    ovn_lflow_init(lflow, NULL, stage, priority,\n                   xstrdup(match), xstrdup(actions),\n                   io_port ? xstrdup(io_port) : NULL,\n                   nullable_xstrdup(ctrl_meter),\n                   ovn_lflow_hint(stage_hint), where);\n\n    ovn_dp_group_add_with_reference(lflow, od, dp_bitmap);\n\n    if (parallelization_state != STATE_USE_PARALLELIZATION) {\n        hmap_insert(lflow_map, &lflow->hmap_node, hash);\n    } else {\n        hmap_insert_fast(lflow_map, &lflow->hmap_node, hash);\n        thread_lflow_counter++;\n    }\n}\n\n/* Adds a row with the specified contents to the Logical_Flow table. */\nstatic void\novn_lflow_add_at(struct hmap *lflow_map, const struct ovn_datapath *od,\n                 const unsigned long *dp_bitmap,\n                 enum ovn_stage stage, uint16_t priority,\n                 const char *match, const char *actions, const char *io_port,\n                 const char *ctrl_meter,\n                 const struct ovsdb_idl_row *stage_hint, const char *where)\n    OVS_EXCLUDED(fake_hash_mutex)\n{\n    struct ovs_mutex *hash_lock;\n    uint32_t hash;\n\n    ovs_assert(!od ||\n               ovn_stage_to_datapath_type(stage) == ovn_datapath_get_type(od));\n\n    hash = ovn_logical_flow_hash(ovn_stage_get_table(stage),\n                                 ovn_stage_get_pipeline(stage),\n                                 priority, match,\n                                 actions);\n\n    hash_lock = lflow_hash_lock(lflow_map, hash);\n    do_ovn_lflow_add(lflow_map, od, dp_bitmap, hash, stage, priority,\n                     match, actions, io_port, stage_hint, where, ctrl_meter);\n    lflow_hash_unlock(hash_lock);\n}\n\nstatic void\n__ovn_lflow_add_default_drop(struct hmap *lflow_map,\n                             struct ovn_datapath *od,\n                             enum ovn_stage stage,\n                             const char *where)\n{\n        ovn_lflow_add_at(lflow_map, od, NULL, stage, 0, \"1\",\n                         debug_drop_action(),\n                         NULL, NULL, NULL, where );\n}\n\n/* Adds a row with the specified contents to the Logical_Flow table. */\n#define ovn_lflow_add_with_hint__(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, \\\n                                  ACTIONS, IN_OUT_PORT, CTRL_METER, \\\n                                  STAGE_HINT) \\\n    ovn_lflow_add_at(LFLOW_MAP, OD, NULL, STAGE, PRIORITY, MATCH, ACTIONS, \\\n                     IN_OUT_PORT, CTRL_METER, STAGE_HINT, OVS_SOURCE_LOCATOR)\n\n#define ovn_lflow_add_with_hint(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, \\\n                                ACTIONS, STAGE_HINT) \\\n    ovn_lflow_add_at(LFLOW_MAP, OD, NULL, STAGE, PRIORITY, MATCH, ACTIONS, \\\n                     NULL, NULL, STAGE_HINT, OVS_SOURCE_LOCATOR)\n\n#define ovn_lflow_add_with_dp_group(LFLOW_MAP, DP_BITMAP, STAGE, PRIORITY, \\\n                                    MATCH, ACTIONS, STAGE_HINT) \\\n    ovn_lflow_add_at(LFLOW_MAP, NULL, DP_BITMAP, STAGE, PRIORITY, MATCH, \\\n                     ACTIONS, NULL, NULL, STAGE_HINT, OVS_SOURCE_LOCATOR)\n\n#define ovn_lflow_add_default_drop(LFLOW_MAP, OD, STAGE)                    \\\n    __ovn_lflow_add_default_drop(LFLOW_MAP, OD, STAGE, OVS_SOURCE_LOCATOR)\n\n\n/* This macro is similar to ovn_lflow_add_with_hint, except that it requires\n * the IN_OUT_PORT argument, which tells the lport name that appears in the\n * MATCH, which helps ovn-controller to bypass lflows parsing when the lport is\n * not local to the chassis. The critiera of the lport to be added using this\n * argument:\n *\n * - For ingress pipeline, the lport that is used to match \"inport\".\n * - For egress pipeline, the lport that is used to match \"outport\".\n *\n * For now, only LS pipelines should use this macro.  */\n#define ovn_lflow_add_with_lport_and_hint(LFLOW_MAP, OD, STAGE, PRIORITY, \\\n                                          MATCH, ACTIONS, IN_OUT_PORT, \\\n                                          STAGE_HINT) \\\n    ovn_lflow_add_at(LFLOW_MAP, OD, NULL, STAGE, PRIORITY, MATCH, ACTIONS, \\\n                     IN_OUT_PORT, NULL, STAGE_HINT, OVS_SOURCE_LOCATOR)\n\n#define ovn_lflow_add(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, ACTIONS) \\\n    ovn_lflow_add_at(LFLOW_MAP, OD, NULL, STAGE, PRIORITY, MATCH, ACTIONS, \\\n                     NULL, NULL, NULL, OVS_SOURCE_LOCATOR)\n\n#define ovn_lflow_metered(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, ACTIONS, \\\n                          CTRL_METER) \\\n    ovn_lflow_add_with_hint__(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, \\\n                              ACTIONS, NULL, CTRL_METER, NULL)\n\nstatic struct ovn_lflow *\novn_lflow_find(const struct hmap *lflows, const struct ovn_datapath *od,\n               enum ovn_stage stage, uint16_t priority,\n               const char *match, const char *actions, const char *ctrl_meter,\n               uint32_t hash)\n{\n    struct ovn_lflow *lflow;\n    HMAP_FOR_EACH_WITH_HASH (lflow, hmap_node, hash, lflows) {\n        if (ovn_lflow_equal(lflow, od, stage, priority, match, actions,\n                            ctrl_meter)) {\n            return lflow;\n        }\n    }\n    return NULL;\n}\n\nstatic void\novn_lflow_destroy(struct hmap *lflows, struct ovn_lflow *lflow)\n{\n    if (lflow) {\n        if (lflows) {\n            hmap_remove(lflows, &lflow->hmap_node);\n        }\n        bitmap_free(lflow->dpg_bitmap);\n        free(lflow->match);\n        free(lflow->actions);\n        free(lflow->io_port);\n        free(lflow->stage_hint);\n        free(lflow->ctrl_meter);\n        free(lflow);\n    }\n}\n\nstatic bool\nbuild_dhcpv4_action(struct ovn_port *op, ovs_be32 offer_ip,\n                    struct ds *options_action, struct ds *response_action,\n                    struct ds *ipv4_addr_match)\n{\n    if (!op->nbsp->dhcpv4_options) {\n        /* CMS has disabled native DHCPv4 for this lport. */\n        return false;\n    }\n\n    ovs_be32 host_ip, mask;\n    char *error = ip_parse_masked(op->nbsp->dhcpv4_options->cidr, &host_ip,\n                                  &mask);\n    if (error || ((offer_ip ^ host_ip) & mask)) {\n       /* Either\n        *  - cidr defined is invalid or\n        *  - the offer ip of the logical port doesn't belong to the cidr\n        *    defined in the DHCPv4 options.\n        *  */\n        free(error);\n        return false;\n    }\n\n    const char *server_ip = smap_get(\n        &op->nbsp->dhcpv4_options->options, \"server_id\");\n    const char *server_mac = smap_get(\n        &op->nbsp->dhcpv4_options->options, \"server_mac\");\n    const char *lease_time = smap_get(\n        &op->nbsp->dhcpv4_options->options, \"lease_time\");\n\n    if (!(server_ip && server_mac && lease_time)) {\n        /* \"server_id\", \"server_mac\" and \"lease_time\" should be\n         * present in the dhcp_options. */\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n        VLOG_WARN_RL(&rl, \"Required DHCPv4 options not defined for lport - %s\",\n                     op->json_key);\n        return false;\n    }\n\n    struct smap dhcpv4_options = SMAP_INITIALIZER(&dhcpv4_options);\n    smap_clone(&dhcpv4_options, &op->nbsp->dhcpv4_options->options);\n\n    /* server_mac is not DHCPv4 option, delete it from the smap. */\n    smap_remove(&dhcpv4_options, \"server_mac\");\n    char *netmask = xasprintf(IP_FMT, IP_ARGS(mask));\n    smap_add(&dhcpv4_options, \"netmask\", netmask);\n    free(netmask);\n\n    ds_put_format(options_action,\n                  REGBIT_DHCP_OPTS_RESULT\" = put_dhcp_opts(offerip = \"\n                  IP_FMT\", \", IP_ARGS(offer_ip));\n\n    /* Try to get hostname DHCP option from ovn_port as it can be passed there\n     * instead of DHCP_Options set. Logical_Switch_Port options:hostname takes\n     precedence over DHCP_Options options:hostname. */\n    const char *hostname = smap_get(&op->nbsp->options, \"hostname\");\n    if (hostname) {\n        smap_replace(&dhcpv4_options, \"hostname\", hostname);\n    }\n\n    /* We're not using SMAP_FOR_EACH because we want a consistent order of the\n     * options on different architectures (big or little endian, SSE4.2) */\n    const struct smap_node **sorted_opts = smap_sort(&dhcpv4_options);\n    for (size_t i = 0; i < smap_count(&dhcpv4_options); i++) {\n        const struct smap_node *node = sorted_opts[i];\n        ds_put_format(options_action, \"%s = %s, \", node->key, node->value);\n    }\n    free(sorted_opts);\n\n    ds_chomp(options_action, ' ');\n    ds_chomp(options_action, ',');\n    ds_put_cstr(options_action, \"); next;\");\n\n    ds_put_format(response_action, \"eth.dst = eth.src; eth.src = %s; \"\n                  \"ip4.src = %s; udp.src = 67; udp.dst = 68; \"\n                  \"outport = inport; flags.loopback = 1; output;\",\n                  server_mac, server_ip);\n\n    ds_put_format(ipv4_addr_match,\n                  \"ip4.src == \"IP_FMT\" && ip4.dst == {%s, 255.255.255.255}\",\n                  IP_ARGS(offer_ip), server_ip);\n    smap_destroy(&dhcpv4_options);\n    return true;\n}\n\nstatic bool\nbuild_dhcpv6_action(struct ovn_port *op, struct in6_addr *offer_ip,\n                    struct ds *options_action, struct ds *response_action)\n{\n    if (!op->nbsp->dhcpv6_options) {\n        /* CMS has disabled native DHCPv6 for this lport. */\n        return false;\n    }\n\n    struct in6_addr host_ip, mask;\n\n    char *error = ipv6_parse_masked(op->nbsp->dhcpv6_options->cidr, &host_ip,\n                                        &mask);\n    if (error) {\n        free(error);\n        return false;\n    }\n    struct in6_addr ip6_mask = ipv6_addr_bitxor(offer_ip, &host_ip);\n    ip6_mask = ipv6_addr_bitand(&ip6_mask, &mask);\n    if (!ipv6_mask_is_any(&ip6_mask)) {\n        /* offer_ip doesn't belongs to the cidr defined in lport's DHCPv6\n         * options.*/\n        return false;\n    }\n\n    const struct smap *options_map = &op->nbsp->dhcpv6_options->options;\n    /* \"server_id\" should be the MAC address. */\n    const char *server_mac = smap_get(options_map, \"server_id\");\n    struct eth_addr ea;\n    if (!server_mac || !eth_addr_from_string(server_mac, &ea)) {\n        /* \"server_id\" should be present in the dhcpv6_options. */\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"server_id not present in the DHCPv6 options\"\n                          \" for lport %s\", op->json_key);\n        return false;\n    }\n\n    /* Get the link local IP of the DHCPv6 server from the server MAC. */\n    struct in6_addr lla;\n    in6_generate_lla(ea, &lla);\n\n    char server_ip[INET6_ADDRSTRLEN + 1];\n    ipv6_string_mapped(server_ip, &lla);\n\n    char ia_addr[INET6_ADDRSTRLEN + 1];\n    ipv6_string_mapped(ia_addr, offer_ip);\n\n    ds_put_format(options_action,\n                  REGBIT_DHCP_OPTS_RESULT\" = put_dhcpv6_opts(\");\n\n    /* Check whether the dhcpv6 options should be configured as stateful.\n     * Only reply with ia_addr option for dhcpv6 stateful address mode. */\n    if (!smap_get_bool(options_map, \"dhcpv6_stateless\", false)) {\n        ipv6_string_mapped(ia_addr, offer_ip);\n        ds_put_format(options_action, \"ia_addr = %s, \", ia_addr);\n    }\n\n    /* We're not using SMAP_FOR_EACH because we want a consistent order of the\n     * options on different architectures (big or little endian, SSE4.2) */\n    const struct smap_node **sorted_opts = smap_sort(options_map);\n    for (size_t i = 0; i < smap_count(options_map); i++) {\n        const struct smap_node *node = sorted_opts[i];\n        if (strcmp(node->key, \"dhcpv6_stateless\")) {\n            ds_put_format(options_action, \"%s = %s, \", node->key, node->value);\n        }\n    }\n    free(sorted_opts);\n\n    ds_chomp(options_action, ' ');\n    ds_chomp(options_action, ',');\n    ds_put_cstr(options_action, \"); next;\");\n\n    ds_put_format(response_action, \"eth.dst = eth.src; eth.src = %s; \"\n                  \"ip6.dst = ip6.src; ip6.src = %s; udp.src = 547; \"\n                  \"udp.dst = 546; outport = inport; flags.loopback = 1; \"\n                  \"output;\",\n                  server_mac, server_ip);\n\n    return true;\n}\n\nstruct ovn_port_group_ls {\n    struct hmap_node key_node;  /* Index on 'key'. */\n    struct uuid key;            /* nb_ls->header_.uuid. */\n    struct ovn_datapath *od;\n\n    struct ovn_port **ports; /* Ports in 'od' referrenced by the PG. */\n    size_t n_ports;\n    size_t n_allocated_ports;\n};\n\nstruct ovn_port_group {\n    struct hmap_node key_node;  /* Index on 'key'. */\n    struct uuid key;            /* nb_pg->header_.uuid. */\n    const struct nbrec_port_group *nb_pg;\n    struct hmap nb_lswitches;   /* NB lswitches related to the port group */\n};\n\nstatic struct ovn_port_group_ls *\novn_port_group_ls_add(struct ovn_port_group *pg, struct ovn_datapath *od)\n{\n    struct ovn_port_group_ls *pg_ls = xzalloc(sizeof *pg_ls);\n    pg_ls->key = od->nbs->header_.uuid;\n    pg_ls->od = od;\n    hmap_insert(&pg->nb_lswitches, &pg_ls->key_node, uuid_hash(&pg_ls->key));\n    return pg_ls;\n}\n\nstatic struct ovn_port_group_ls *\novn_port_group_ls_find(struct ovn_port_group *pg, const struct uuid *ls_uuid)\n{\n    struct ovn_port_group_ls *pg_ls;\n\n    HMAP_FOR_EACH_WITH_HASH (pg_ls, key_node, uuid_hash(ls_uuid),\n                             &pg->nb_lswitches) {\n        if (uuid_equals(ls_uuid, &pg_ls->key)) {\n            return pg_ls;\n        }\n    }\n    return NULL;\n}\n\nstatic void\novn_port_group_ls_add_port(struct ovn_port_group_ls *pg_ls,\n                           struct ovn_port *op)\n{\n    if (pg_ls->n_ports == pg_ls->n_allocated_ports) {\n        pg_ls->ports = x2nrealloc(pg_ls->ports,\n                                  &pg_ls->n_allocated_ports,\n                                  sizeof *pg_ls->ports);\n    }\n    pg_ls->ports[pg_ls->n_ports++] = op;\n}\n\nstruct ovn_ls_port_group {\n    struct hmap_node key_node;  /* Index on 'key'. */\n    struct uuid key;            /* nb_pg->header_.uuid. */\n    const struct nbrec_port_group *nb_pg;\n};\n\nstatic void\novn_ls_port_group_add(struct hmap *nb_pgs,\n                      const struct nbrec_port_group *nb_pg)\n{\n    struct ovn_ls_port_group *ls_pg = xzalloc(sizeof *ls_pg);\n    ls_pg->key = nb_pg->header_.uuid;\n    ls_pg->nb_pg = nb_pg;\n    hmap_insert(nb_pgs, &ls_pg->key_node, uuid_hash(&ls_pg->key));\n}\n\nstatic void\novn_ls_port_group_destroy(struct hmap *nb_pgs)\n{\n    struct ovn_ls_port_group *ls_pg;\n    HMAP_FOR_EACH_POP (ls_pg, key_node, nb_pgs) {\n        free(ls_pg);\n    }\n    hmap_destroy(nb_pgs);\n}\n\nstatic void\nls_get_acl_flags(struct ovn_datapath *od)\n{\n    od->has_acls = false;\n    od->has_stateful_acl = false;\n\n    if (od->nbs->n_acls) {\n        od->has_acls = true;\n\n        for (size_t i = 0; i < od->nbs->n_acls; i++) {\n            struct nbrec_acl *acl = od->nbs->acls[i];\n            if (!strcmp(acl->action, \"allow-related\")) {\n                od->has_stateful_acl = true;\n                return;\n            }\n        }\n    }\n\n    struct ovn_ls_port_group *ls_pg;\n    HMAP_FOR_EACH (ls_pg, key_node, &od->nb_pgs) {\n        if (ls_pg->nb_pg->n_acls) {\n            od->has_acls = true;\n\n            for (size_t i = 0; i < ls_pg->nb_pg->n_acls; i++) {\n                struct nbrec_acl *acl = ls_pg->nb_pg->acls[i];\n                if (!strcmp(acl->action, \"allow-related\")) {\n                    od->has_stateful_acl = true;\n                    return;\n                }\n            }\n        }\n    }\n}\n\n/* Adds the logical flows in the (in/out) check port sec stage only if\n *   - the lport is disabled or\n *   - lport is of type vtep - to skip the ingress pipeline.\n *   - lport has qdisc queue id is configured.\n *\n * For all the other logical ports,  generic flow added in\n * build_lswitch_lflows_admission_control() handles the port security.\n */\nstatic void\nbuild_lswitch_port_sec_op(struct ovn_port *op, struct hmap *lflows,\n                                struct ds *actions, struct ds *match)\n{\n    if (!op->nbsp) {\n        return;\n    }\n\n    if (lsp_is_external(op->nbsp)) {\n        return;\n    }\n\n    ds_clear(match);\n    ds_clear(actions);\n    ds_put_format(match, \"inport == %s\", op->json_key);\n    if (!lsp_is_enabled(op->nbsp)) {\n        /* Drop packets from disabled logical ports. */\n        ovn_lflow_add_with_lport_and_hint(\n            lflows, op->od, S_SWITCH_IN_CHECK_PORT_SEC,\n            100, ds_cstr(match), REGBIT_PORT_SEC_DROP\" = 1; next;\",\n            op->key, &op->nbsp->header_);\n\n        ds_clear(match);\n        ds_put_format(match, \"outport == %s\", op->json_key);\n        ovn_lflow_add_with_lport_and_hint(\n            lflows, op->od, S_SWITCH_IN_L2_UNKNOWN, 50, ds_cstr(match),\n            debug_drop_action(), op->key, &op->nbsp->header_);\n        return;\n    }\n\n    const char *queue_id = smap_get(&op->sb->options, \"qdisc_queue_id\");\n    if (queue_id) {\n        ds_put_format(actions, \"set_queue(%s); \", queue_id);\n    }\n\n    if (lsp_is_vtep(op->nbsp)) {\n        ds_put_format(actions, REGBIT_FROM_RAMP\" = 1; \");\n        ds_put_format(actions, \"next(pipeline=ingress, table=%d);\",\n                      ovn_stage_get_table(S_SWITCH_IN_HAIRPIN));\n        ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                          S_SWITCH_IN_CHECK_PORT_SEC, 70,\n                                          ds_cstr(match), ds_cstr(actions),\n                                          op->key, &op->nbsp->header_);\n    } else if (queue_id) {\n        ds_put_cstr(actions,\n                    REGBIT_PORT_SEC_DROP\" = check_in_port_sec(); next;\");\n        ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                          S_SWITCH_IN_CHECK_PORT_SEC, 70,\n                                          ds_cstr(match), ds_cstr(actions),\n                                          op->key, &op->nbsp->header_);\n\n        if (lsp_is_localnet(op->nbsp)) {\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match, \"outport == %s\", op->json_key);\n            ds_put_format(actions, \"set_queue(%s); output;\", queue_id);\n            ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                            S_SWITCH_OUT_APPLY_PORT_SEC, 100,\n                                            ds_cstr(match), ds_cstr(actions),\n                                            op->key, &op->nbsp->header_);\n        }\n    }\n}\n\nstatic void\nbuild_lswitch_learn_fdb_op(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *actions, struct ds *match)\n{\n    if (!op->nbsp) {\n        return;\n    }\n\n    if (!op->n_ps_addrs && op->has_unknown && (!strcmp(op->nbsp->type, \"\") ||\n        (lsp_is_localnet(op->nbsp) && localnet_can_learn_mac(op->nbsp)))) {\n        ds_clear(match);\n        ds_clear(actions);\n        ds_put_format(match, \"inport == %s\", op->json_key);\n        ds_put_format(actions, REGBIT_LKUP_FDB\n                      \" = lookup_fdb(inport, eth.src); next;\");\n        ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                          S_SWITCH_IN_LOOKUP_FDB, 100,\n                                          ds_cstr(match), ds_cstr(actions),\n                                          op->key, &op->nbsp->header_);\n\n        ds_put_cstr(match, \" && \"REGBIT_LKUP_FDB\" == 0\");\n        ds_clear(actions);\n        ds_put_cstr(actions, \"put_fdb(inport, eth.src); next;\");\n        ovn_lflow_add_with_lport_and_hint(lflows, op->od, S_SWITCH_IN_PUT_FDB,\n                                          100, ds_cstr(match),\n                                          ds_cstr(actions), op->key,\n                                          &op->nbsp->header_);\n    }\n}\n\nstatic void\nbuild_lswitch_learn_fdb_od(\n        struct ovn_datapath *od, struct hmap *lflows)\n{\n\n    if (od->nbs) {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_LOOKUP_FDB, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_PUT_FDB, 0, \"1\", \"next;\");\n    }\n}\n\n/* Egress tables 8: Egress port security - IP (priority 0)\n * Egress table 9: Egress port security L2 - multicast/broadcast\n *                 (priority 100). */\nstatic void\nbuild_lswitch_output_port_sec_od(struct ovn_datapath *od,\n                              struct hmap *lflows)\n{\n    if (od->nbs) {\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_CHECK_PORT_SEC, 100,\n                      \"eth.mcast\", REGBIT_PORT_SEC_DROP\" = 0; next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_CHECK_PORT_SEC, 0, \"1\",\n                      REGBIT_PORT_SEC_DROP\" = check_out_port_sec(); next;\");\n\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_APPLY_PORT_SEC, 50,\n                      REGBIT_PORT_SEC_DROP\" == 1\", debug_drop_action());\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_APPLY_PORT_SEC, 0,\n                      \"1\", \"output;\");\n\n    }\n}\n\nstatic void\nskip_port_from_conntrack(struct ovn_datapath *od, struct ovn_port *op,\n                         enum ovn_stage in_stage, enum ovn_stage out_stage,\n                         uint16_t priority, struct hmap *lflows)\n{\n    /* Can't use ct() for router ports. Consider the following configuration:\n     * lp1(10.0.0.2) on hostA--ls1--lr0--ls2--lp2(10.0.1.2) on hostB, For a\n     * ping from lp1 to lp2, First, the response will go through ct() with a\n     * zone for lp2 in the ls2 ingress pipeline on hostB.  That ct zone knows\n     * about this connection. Next, it goes through ct() with the zone for the\n     * router port in the egress pipeline of ls2 on hostB.  This zone does not\n     * know about the connection, as the icmp request went through the logical\n     * router on hostA, not hostB. This would only work with distributed\n     * conntrack state across all chassis. */\n\n    const char *ingress_action = \"next;\";\n    const char *egress_action = od->has_stateful_acl\n                                ? \"next;\"\n                                : \"ct_clear; next;\";\n\n    char *ingress_match = xasprintf(\"ip && inport == %s\", op->json_key);\n    char *egress_match = xasprintf(\"ip && outport == %s\", op->json_key);\n\n    ovn_lflow_add_with_lport_and_hint(lflows, od, in_stage, priority,\n                                      ingress_match, ingress_action,\n                                      op->key, &op->nbsp->header_);\n    ovn_lflow_add_with_lport_and_hint(lflows, od, out_stage, priority,\n                                      egress_match, egress_action,\n                                      op->key, &op->nbsp->header_);\n\n    free(ingress_match);\n    free(egress_match);\n}\n\nstatic void\nbuild_stateless_filter(struct ovn_datapath *od,\n                       const struct nbrec_acl *acl,\n                       struct hmap *lflows)\n{\n    const char *action = REGBIT_ACL_STATELESS\" = 1; next;\";\n    if (!strcmp(acl->direction, \"from-lport\")) {\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_PRE_ACL,\n                                acl->priority + OVN_ACL_PRI_OFFSET,\n                                acl->match,\n                                action,\n                                &acl->header_);\n    } else {\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_OUT_PRE_ACL,\n                                acl->priority + OVN_ACL_PRI_OFFSET,\n                                acl->match,\n                                action,\n                                &acl->header_);\n    }\n}\n\nstatic void\nbuild_stateless_filters(struct ovn_datapath *od,\n                        const struct hmap *port_groups,\n                        struct hmap *lflows)\n{\n    for (size_t i = 0; i < od->nbs->n_acls; i++) {\n        const struct nbrec_acl *acl = od->nbs->acls[i];\n        if (!strcmp(acl->action, \"allow-stateless\")) {\n            build_stateless_filter(od, acl, lflows);\n        }\n    }\n\n    struct ovn_port_group *pg;\n    HMAP_FOR_EACH (pg, key_node, port_groups) {\n        if (ovn_port_group_ls_find(pg, &od->nbs->header_.uuid)) {\n            for (size_t i = 0; i < pg->nb_pg->n_acls; i++) {\n                const struct nbrec_acl *acl = pg->nb_pg->acls[i];\n                if (!strcmp(acl->action, \"allow-stateless\")) {\n                    build_stateless_filter(od, acl, lflows);\n                }\n            }\n        }\n    }\n}\n\nstatic void\nbuild_pre_acls(struct ovn_datapath *od, const struct hmap *port_groups,\n               struct hmap *lflows)\n{\n    /* Ingress and Egress Pre-ACL Table (Priority 0): Packets are\n     * allowed by default. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_ACL, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_ACL, 0, \"1\", \"next;\");\n\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_ACL, 110,\n                  \"eth.dst == $svc_monitor_mac\", \"next;\");\n\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_ACL, 110,\n                  \"eth.src == $svc_monitor_mac\", \"next;\");\n\n    /* If there are any stateful ACL rules in this datapath, we may\n     * send IP packets for some (allow) filters through the conntrack action,\n     * which handles defragmentation, in order to match L4 headers. */\n    if (od->has_stateful_acl) {\n        for (size_t i = 0; i < od->n_router_ports; i++) {\n            skip_port_from_conntrack(od, od->router_ports[i],\n                                     S_SWITCH_IN_PRE_ACL, S_SWITCH_OUT_PRE_ACL,\n                                     110, lflows);\n        }\n        for (size_t i = 0; i < od->n_localnet_ports; i++) {\n            skip_port_from_conntrack(od, od->localnet_ports[i],\n                                     S_SWITCH_IN_PRE_ACL,\n                                     S_SWITCH_OUT_PRE_ACL,\n                                     110, lflows);\n        }\n\n        /* stateless filters always take precedence over stateful ACLs. */\n        build_stateless_filters(od, port_groups, lflows);\n\n        /* Ingress and Egress Pre-ACL Table (Priority 110).\n         *\n         * Not to do conntrack on ND and ICMP destination\n         * unreachable packets. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_ACL, 110,\n                      \"nd || nd_rs || nd_ra || mldv1 || mldv2 || \"\n                      \"(udp && udp.src == 546 && udp.dst == 547)\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_ACL, 110,\n                      \"nd || nd_rs || nd_ra || mldv1 || mldv2 || \"\n                      \"(udp && udp.src == 546 && udp.dst == 547)\", \"next;\");\n\n        /* Do not send multicast packets to conntrack. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_ACL, 110, \"eth.mcast\",\n                      \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_ACL, 110, \"eth.mcast\",\n                      \"next;\");\n\n        /* Ingress and Egress Pre-ACL Table (Priority 100).\n         *\n         * Regardless of whether the ACL is \"from-lport\" or \"to-lport\",\n         * we need rules in both the ingress and egress table, because\n         * the return traffic needs to be followed.\n         *\n         * 'REGBIT_CONNTRACK_DEFRAG' is set to let the pre-stateful table send\n         * it to conntrack for tracking and defragmentation. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_ACL, 100, \"ip\",\n                      REGBIT_CONNTRACK_DEFRAG\" = 1; next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_ACL, 100, \"ip\",\n                      REGBIT_CONNTRACK_DEFRAG\" = 1; next;\");\n    } else if (od->has_lb_vip) {\n        /* We'll build stateless filters if there are LB rules so that\n         * the stateless flows are not tracked in pre-lb. */\n         build_stateless_filters(od, port_groups, lflows);\n    }\n}\n\n/*\n * Returns true if logical switch is configured with DNS records, false\n * otherwise.\n */\nstatic bool\nls_has_dns_records(const struct nbrec_logical_switch *nbs)\n{\n    for (size_t i = 0; i < nbs->n_dns_records; i++) {\n        if (!smap_is_empty(&nbs->dns_records[i]->records)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nstatic bool\nbuild_empty_lb_event_flow(struct ovn_lb_vip *lb_vip,\n                          const struct ovn_northd_lb *lb,\n                          struct ds *match, struct ds *action)\n{\n    bool controller_event = lb->controller_event ||\n                            controller_event_en; /* deprecated */\n    if (!controller_event || lb_vip->n_backends ||\n        lb_vip->empty_backend_rej) {\n        return false;\n    }\n\n    ds_clear(action);\n    ds_clear(match);\n\n    bool ipv4 = lb_vip->address_family == AF_INET;\n\n    ds_put_format(match, \"ip%s.dst == %s && %s\",\n                  ipv4 ? \"4\": \"6\", lb_vip->vip_str, lb->proto);\n\n    char *vip = lb_vip->vip_str;\n    if (lb_vip->port_str) {\n        ds_put_format(match, \" && %s.dst == %s\", lb->proto, lb_vip->port_str);\n        vip = xasprintf(\"%s%s%s:%s\", ipv4 ? \"\" : \"[\", lb_vip->vip_str,\n                        ipv4 ? \"\" : \"]\", lb_vip->port_str);\n    }\n\n    ds_put_format(action,\n                  \"trigger_event(event = \\\"%s\\\", \"\n                  \"vip = \\\"%s\\\", \"\n                  \"protocol = \\\"%s\\\", \"\n                  \"load_balancer = \\\"\" UUID_FMT \"\\\");\",\n                  event_to_string(OVN_EVENT_EMPTY_LB_BACKENDS),\n                  vip, lb->proto,\n                  UUID_ARGS(&lb->nlb->header_.uuid));\n    if (lb_vip->port_str) {\n        free(vip);\n    }\n    return true;\n}\n\nstatic void\nbuild_interconn_mcast_snoop_flows(struct ovn_datapath *od,\n                                  const struct shash *meter_groups,\n                                  struct hmap *lflows)\n{\n    struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n    if (!mcast_sw_info->enabled\n        || !smap_get(&od->nbs->other_config, \"interconn-ts\")) {\n        return;\n    }\n\n    struct ovn_port *op;\n\n    LIST_FOR_EACH (op, dp_node, &od->port_list) {\n        if (!lsp_is_remote(op->nbsp)) {\n            continue;\n        }\n        /* Punt IGMP traffic to controller. */\n        char *match = xasprintf(\"inport == %s && igmp\", op->json_key);\n        ovn_lflow_metered(lflows, od, S_SWITCH_OUT_PRE_LB, 120, match,\n                          \"clone { igmp; }; next;\",\n                          copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                         meter_groups));\n        free(match);\n\n        /* Punt MLD traffic to controller. */\n        match = xasprintf(\"inport == %s && (mldv1 || mldv2)\", op->json_key);\n        ovn_lflow_metered(lflows, od, S_SWITCH_OUT_PRE_LB, 120, match,\n                          \"clone { igmp; }; next;\",\n                          copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                         meter_groups));\n        free(match);\n    }\n}\n\nstatic void\nbuild_pre_lb(struct ovn_datapath *od, const struct shash *meter_groups,\n             struct hmap *lflows)\n{\n    /* Handle IGMP/MLD packets crossing AZs. */\n    build_interconn_mcast_snoop_flows(od, meter_groups, lflows);\n\n    /* Do not send multicast packets to conntrack */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB, 110, \"eth.mcast\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB, 110, \"eth.mcast\", \"next;\");\n\n    /* Do not send ND packets to conntrack */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB, 110,\n                  \"nd || nd_rs || nd_ra || mldv1 || mldv2\",\n                  \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB, 110,\n                  \"nd || nd_rs || nd_ra || mldv1 || mldv2\",\n                  \"next;\");\n\n    /* Do not send service monitor packets to conntrack. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB, 110,\n                  \"eth.dst == $svc_monitor_mac\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB, 110,\n                  \"eth.src == $svc_monitor_mac\", \"next;\");\n\n    /* Allow all packets to go to next tables by default. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB, 0, \"1\", \"next;\");\n\n    for (size_t i = 0; i < od->n_router_ports; i++) {\n        skip_port_from_conntrack(od, od->router_ports[i],\n                                 S_SWITCH_IN_PRE_LB, S_SWITCH_OUT_PRE_LB,\n                                 110, lflows);\n    }\n    /* Localnet ports have no need for going through conntrack, unless\n     * the logical switch has a load balancer. Then, conntrack is necessary\n     * so that traffic arriving via the localnet port can be load\n     * balanced.\n     */\n    if (!od->has_lb_vip) {\n        for (size_t i = 0; i < od->n_localnet_ports; i++) {\n            skip_port_from_conntrack(od, od->localnet_ports[i],\n                                     S_SWITCH_IN_PRE_LB, S_SWITCH_OUT_PRE_LB,\n                                     110, lflows);\n        }\n    }\n\n    /* Do not sent statless flows via conntrack */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB, 110,\n                  REGBIT_ACL_STATELESS\" == 1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB, 110,\n                  REGBIT_ACL_STATELESS\" == 1\", \"next;\");\n\n    /* 'REGBIT_CONNTRACK_NAT' is set to let the pre-stateful table send\n     * packet to conntrack for defragmentation and possibly for unNATting.\n     *\n     * Send all the packets to conntrack in the ingress pipeline if the\n     * logical switch has a load balancer with VIP configured. Earlier\n     * we used to set the REGBIT_CONNTRACK_DEFRAG flag in the ingress\n     * pipeline if the IP destination matches the VIP. But this causes\n     * few issues when a logical switch has no ACLs configured with\n     * allow-related.\n     * To understand the issue, lets a take a TCP load balancer -\n     * 10.0.0.10:80=10.0.0.3:80.\n     * If a logical port - p1 with IP - 10.0.0.5 opens a TCP connection\n     * with the VIP - 10.0.0.10, then the packet in the ingress pipeline\n     * of 'p1' is sent to the p1's conntrack zone id and the packet is\n     * load balanced to the backend - 10.0.0.3. For the reply packet from\n     * the backend lport, it is not sent to the conntrack of backend\n     * lport's zone id. This is fine as long as the packet is valid.\n     * Suppose the backend lport sends an invalid TCP packet (like\n     * incorrect sequence number), the packet gets * delivered to the\n     * lport 'p1' without unDNATing the packet to the VIP - 10.0.0.10.\n     * And this causes the connection to be reset by the lport p1's VIF.\n     *\n     * We can't fix this issue by adding a logical flow to drop ct.inv\n     * packets in the egress pipeline since it will drop all other\n     * connections not destined to the load balancers.\n     *\n     * To fix this issue, we send all the packets to the conntrack in the\n     * ingress pipeline if a load balancer is configured. We can now\n     * add a lflow to drop ct.inv packets.\n     */\n    if (od->has_lb_vip) {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB,\n                      100, \"ip\", REGBIT_CONNTRACK_NAT\" = 1; next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB,\n                      100, \"ip\", REGBIT_CONNTRACK_NAT\" = 1; next;\");\n    }\n}\n\nstatic void\nbuild_pre_stateful(struct ovn_datapath *od,\n                   const struct chassis_features *features,\n                   struct hmap *lflows)\n{\n    /* Ingress and Egress pre-stateful Table (Priority 0): Packets are\n     * allowed by default. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_STATEFUL, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_STATEFUL, 0, \"1\", \"next;\");\n\n    /* Note: priority-120 flows are added in build_lb_rules_pre_stateful(). */\n\n    const char *ct_lb_action = features->ct_no_masked_label\n                               ? \"ct_lb_mark;\"\n                               : \"ct_lb;\";\n\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_STATEFUL, 110,\n                  REGBIT_CONNTRACK_NAT\" == 1\", ct_lb_action);\n\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_STATEFUL, 110,\n                  REGBIT_CONNTRACK_NAT\" == 1\", ct_lb_action);\n\n    /* If REGBIT_CONNTRACK_DEFRAG is set as 1, then the packets should be\n     * sent to conntrack for tracking and defragmentation. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_STATEFUL, 100,\n                  REGBIT_CONNTRACK_DEFRAG\" == 1\", \"ct_next;\");\n\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_STATEFUL, 100,\n                  REGBIT_CONNTRACK_DEFRAG\" == 1\", \"ct_next;\");\n\n}\n\nstatic void\nbuild_acl_hints(struct ovn_datapath *od,\n                const struct chassis_features *features,\n                struct hmap *lflows)\n{\n    /* This stage builds hints for the IN/OUT_ACL stage. Based on various\n     * combinations of ct flags packets may hit only a subset of the logical\n     * flows in the IN/OUT_ACL stage.\n     *\n     * Populating ACL hints first and storing them in registers simplifies\n     * the logical flow match expressions in the IN/OUT_ACL stage and\n     * generates less openflows.\n     *\n     * Certain combinations of ct flags might be valid matches for multiple\n     * types of ACL logical flows (e.g., allow/drop). In such cases hints\n     * corresponding to all potential matches are set.\n     */\n\n    enum ovn_stage stages[] = {\n        S_SWITCH_IN_ACL_HINT,\n        S_SWITCH_OUT_ACL_HINT,\n    };\n\n    for (size_t i = 0; i < ARRAY_SIZE(stages); i++) {\n        enum ovn_stage stage = stages[i];\n        const char *match;\n\n        /* In any case, advance to the next stage. */\n        if (!od->has_acls && !od->has_lb_vip) {\n            ovn_lflow_add(lflows, od, stage, UINT16_MAX, \"1\", \"next;\");\n        } else {\n            ovn_lflow_add(lflows, od, stage, 0, \"1\", \"next;\");\n        }\n\n        if (!od->has_stateful_acl && !od->has_lb_vip) {\n            continue;\n        }\n\n        /* New, not already established connections, may hit either allow\n         * or drop ACLs. For allow ACLs, the connection must also be committed\n         * to conntrack so we set REGBIT_ACL_HINT_ALLOW_NEW.\n         */\n        ovn_lflow_add(lflows, od, stage, 7, \"ct.new && !ct.est\",\n                      REGBIT_ACL_HINT_ALLOW_NEW \" = 1; \"\n                      REGBIT_ACL_HINT_DROP \" = 1; \"\n                      \"next;\");\n\n        /* Already established connections in the \"request\" direction that\n         * are already marked as \"blocked\" may hit either:\n         * - allow ACLs for connections that were previously allowed by a\n         *   policy that was deleted and is being readded now. In this case\n         *   the connection should be recommitted so we set\n         *   REGBIT_ACL_HINT_ALLOW_NEW.\n         * - drop ACLs.\n         */\n        match = features->ct_no_masked_label\n                ? \"!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1\"\n                : \"!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1\";\n        ovn_lflow_add(lflows, od, stage, 6, match,\n                      REGBIT_ACL_HINT_ALLOW_NEW \" = 1; \"\n                      REGBIT_ACL_HINT_DROP \" = 1; \"\n                      \"next;\");\n\n        /* Not tracked traffic can either be allowed or dropped. */\n        ovn_lflow_add(lflows, od, stage, 5, \"!ct.trk\",\n                      REGBIT_ACL_HINT_ALLOW \" = 1; \"\n                      REGBIT_ACL_HINT_DROP \" = 1; \"\n                      \"next;\");\n\n        /* Already established connections in the \"request\" direction may hit\n         * either:\n         * - allow ACLs in which case the traffic should be allowed so we set\n         *   REGBIT_ACL_HINT_ALLOW.\n         * - drop ACLs in which case the traffic should be blocked and the\n         *   connection must be committed with ct_mark.blocked set so we set\n         *   REGBIT_ACL_HINT_BLOCK.\n         */\n        match = features->ct_no_masked_label\n                ? \"!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0\"\n                : \"!ct.new && ct.est && !ct.rpl && ct_label.blocked == 0\";\n        ovn_lflow_add(lflows, od, stage, 4, match,\n                      REGBIT_ACL_HINT_ALLOW \" = 1; \"\n                      REGBIT_ACL_HINT_BLOCK \" = 1; \"\n                      \"next;\");\n\n        /* Not established or established and already blocked connections may\n         * hit drop ACLs.\n         */\n        ovn_lflow_add(lflows, od, stage, 3, \"!ct.est\",\n                      REGBIT_ACL_HINT_DROP \" = 1; \"\n                      \"next;\");\n        match = features->ct_no_masked_label\n                ? \"ct.est && ct_mark.blocked == 1\"\n                : \"ct.est && ct_label.blocked == 1\";\n        ovn_lflow_add(lflows, od, stage, 2, match,\n                      REGBIT_ACL_HINT_DROP \" = 1; \"\n                      \"next;\");\n\n        /* Established connections that were previously allowed might hit\n         * drop ACLs in which case the connection must be committed with\n         * ct_mark.blocked set.\n         */\n        match = features->ct_no_masked_label\n                ? \"ct.est && ct_mark.blocked == 0\"\n                : \"ct.est && ct_label.blocked == 0\";\n        ovn_lflow_add(lflows, od, stage, 1, match,\n                      REGBIT_ACL_HINT_BLOCK \" = 1; \"\n                      \"next;\");\n    }\n}\n\nstatic const struct nbrec_meter*\nfair_meter_lookup_by_name(const struct shash *meter_groups,\n                          const char *meter_name)\n{\n    const struct nbrec_meter *nb_meter =\n        meter_name ? shash_find_data(meter_groups, meter_name) : NULL;\n    if (nb_meter) {\n        return (nb_meter->fair && *nb_meter->fair) ? nb_meter : NULL;\n    }\n    return NULL;\n}\n\nstatic char*\nalloc_acl_log_unique_meter_name(const struct nbrec_acl *acl)\n{\n    return xasprintf(\"%s__\" UUID_FMT,\n                     acl->meter, UUID_ARGS(&acl->header_.uuid));\n}\n\nstatic void\nbuild_acl_log_meter(struct ds *actions, const struct nbrec_acl *acl,\n                    const struct shash *meter_groups)\n{\n    if (!acl->meter) {\n        return;\n    }\n\n    /* If ACL log meter uses a fair meter, use unique Meter name. */\n    if (fair_meter_lookup_by_name(meter_groups, acl->meter)) {\n        char *meter_name = alloc_acl_log_unique_meter_name(acl);\n        ds_put_format(actions, \"meter=\\\"%s\\\", \", meter_name);\n        free(meter_name);\n    } else {\n        ds_put_format(actions, \"meter=\\\"%s\\\", \", acl->meter);\n    }\n}\n\nstatic void\nbuild_acl_log(struct ds *actions, const struct nbrec_acl *acl,\n              const struct shash *meter_groups)\n{\n    if (!acl->log) {\n        return;\n    }\n\n    ds_put_cstr(actions, \"log(\");\n\n    if (acl->name) {\n        ds_put_format(actions, \"name=\\\"%s\\\", \", acl->name);\n    }\n\n    /* If a severity level isn't specified, default to \"info\". */\n    if (acl->severity) {\n        ds_put_format(actions, \"severity=%s, \", acl->severity);\n    } else {\n        ds_put_format(actions, \"severity=info, \");\n    }\n\n    if (!strcmp(acl->action, \"drop\")) {\n        ds_put_cstr(actions, \"verdict=drop, \");\n    } else if (!strcmp(acl->action, \"reject\")) {\n        ds_put_cstr(actions, \"verdict=reject, \");\n    } else if (!strcmp(acl->action, \"allow\")\n        || !strcmp(acl->action, \"allow-related\")\n        || !strcmp(acl->action, \"allow-stateless\")) {\n        ds_put_cstr(actions, \"verdict=allow, \");\n    }\n\n    build_acl_log_meter(actions, acl, meter_groups);\n\n    ds_chomp(actions, ' ');\n    ds_chomp(actions, ',');\n    ds_put_cstr(actions, \"); \");\n}\n\nstatic void\nbuild_reject_acl_rules(struct ovn_datapath *od, struct hmap *lflows,\n                       enum ovn_stage stage, struct nbrec_acl *acl,\n                       struct ds *extra_match, struct ds *extra_actions,\n                       const struct ovsdb_idl_row *stage_hint,\n                       const struct shash *meter_groups)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n    bool ingress = (ovn_stage_get_pipeline(stage) == P_IN);\n\n    char *next_action =\n        xasprintf(\"next(pipeline=%s,table=%d);\",\n                  ingress ? \"egress\": \"ingress\",\n                  ingress ? ovn_stage_get_table(S_SWITCH_OUT_QOS_MARK)\n                          : ovn_stage_get_table(S_SWITCH_IN_L2_LKUP));\n\n    build_acl_log(&actions, acl, meter_groups);\n    if (extra_match->length > 0) {\n        ds_put_format(&match, \"(%s) && \", extra_match->string);\n    }\n    ds_put_cstr(&match, acl->match);\n\n    if (extra_actions->length > 0) {\n        ds_put_format(&actions, \"%s \", extra_actions->string);\n    }\n\n    ds_put_format(&actions, \"reg0 = 0; \"\n                  \"reject { \"\n                  \"/* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ \"\n                  \"outport <-> inport; %s };\", next_action);\n    ovn_lflow_add_with_hint__(lflows, od, stage,\n                              acl->priority + OVN_ACL_PRI_OFFSET,\n                              ds_cstr(&match), ds_cstr(&actions), NULL,\n                              copp_meter_get(COPP_REJECT, od->nbs->copp,\n                                             meter_groups),\n                              stage_hint);\n\n    free(next_action);\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic void\nconsider_acl(struct hmap *lflows, struct ovn_datapath *od,\n             struct nbrec_acl *acl, bool has_stateful, bool ct_masked_mark,\n             const struct shash *meter_groups, struct ds *match,\n             struct ds *actions)\n{\n    const char *ct_blocked_match = ct_masked_mark\n                                   ? \"ct_mark.blocked\"\n                                   : \"ct_label.blocked\";\n    bool ingress = !strcmp(acl->direction, \"from-lport\") ? true :false;\n    enum ovn_stage stage;\n\n    if (ingress && smap_get_bool(&acl->options, \"apply-after-lb\", false)) {\n        stage = S_SWITCH_IN_ACL_AFTER_LB;\n    } else if (ingress) {\n        stage = S_SWITCH_IN_ACL;\n    } else {\n        stage = S_SWITCH_OUT_ACL;\n    }\n\n    if (!strcmp(acl->action, \"allow-stateless\")) {\n        ds_clear(actions);\n        build_acl_log(actions, acl, meter_groups);\n        ds_put_cstr(actions, \"next;\");\n        ovn_lflow_add_with_hint(lflows, od, stage,\n                                acl->priority + OVN_ACL_PRI_OFFSET,\n                                acl->match, ds_cstr(actions),\n                                &acl->header_);\n    } else if (!strcmp(acl->action, \"allow\")\n        || !strcmp(acl->action, \"allow-related\")) {\n        /* If there are any stateful flows, we must even commit \"allow\"\n         * actions.  This is because, while the initiater's\n         * direction may not have any stateful rules, the server's\n         * may and then its return traffic would not have an\n         * associated conntrack entry and would return \"+invalid\". */\n        if (!has_stateful) {\n            ds_clear(actions);\n            build_acl_log(actions, acl, meter_groups);\n            ds_put_cstr(actions, \"next;\");\n            ovn_lflow_add_with_hint(lflows, od, stage,\n                                    acl->priority + OVN_ACL_PRI_OFFSET,\n                                    acl->match, ds_cstr(actions),\n                                    &acl->header_);\n        } else {\n            /* Commit the connection tracking entry if it's a new\n             * connection that matches this ACL.  After this commit,\n             * the reply traffic is allowed by a flow we create at\n             * priority 65535, defined earlier.\n             *\n             * It's also possible that a known connection was marked for\n             * deletion after a policy was deleted, but the policy was\n             * re-added while that connection is still known.  We catch\n             * that case here and un-set ct_mark.blocked (which will be done\n             * by ct_commit in the \"stateful\" stage) to indicate that the\n             * connection should be allowed to resume.\n             */\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match, REGBIT_ACL_HINT_ALLOW_NEW \" == 1 && (%s)\",\n                          acl->match);\n\n            ds_put_cstr(actions, REGBIT_CONNTRACK_COMMIT\" = 1; \");\n            if (acl->label) {\n                ds_put_format(actions, REGBIT_ACL_LABEL\" = 1; \"\n                              REG_LABEL\" = %\"PRId64\"; \", acl->label);\n            }\n            build_acl_log(actions, acl, meter_groups);\n            ds_put_cstr(actions, \"next;\");\n            ovn_lflow_add_with_hint(lflows, od, stage,\n                                    acl->priority + OVN_ACL_PRI_OFFSET,\n                                    ds_cstr(match),\n                                    ds_cstr(actions),\n                                    &acl->header_);\n\n            /* Match on traffic in the request direction for an established\n             * connection tracking entry that has not been marked for\n             * deletion. We use this to ensure that this\n             * connection is still allowed by the currently defined\n             * policy. Match untracked packets too.\n             * Commit the connection only if the ACL has a label. This is done\n             * to update the connection tracking entry label in case the ACL\n             * allowing the connection changes. */\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match, REGBIT_ACL_HINT_ALLOW \" == 1 && (%s)\",\n                          acl->match);\n            if (acl->label) {\n                ds_put_cstr(actions, REGBIT_CONNTRACK_COMMIT\" = 1; \");\n                ds_put_format(actions, REGBIT_ACL_LABEL\" = 1; \"\n                              REG_LABEL\" = %\"PRId64\"; \", acl->label);\n            }\n            build_acl_log(actions, acl, meter_groups);\n            ds_put_cstr(actions, \"next;\");\n            ovn_lflow_add_with_hint(lflows, od, stage,\n                                    acl->priority + OVN_ACL_PRI_OFFSET,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &acl->header_);\n\n            /* Related and reply traffic are universally allowed by priority\n             * 65532 flows created in build_acls(). If logging is enabled on\n             * the ACL, then we need to ensure that the related and reply\n             * traffic is logged, so we install a slightly higher-priority\n             * flow that matches the ACL, allows the traffic, and logs it.\n             *\n             * Note: Matching the ct_label.label may prevent OVS flow HW\n             * offloading to work for some NICs because masked-access of\n             * ct_label is not supported on those NICs due to HW\n             * limitations. In such case the user may choose to avoid using the\n             * \"log-related\" option.\n             */\n            bool log_related = smap_get_bool(&acl->options, \"log-related\",\n                                             false);\n            if (acl->log && acl->label && log_related) {\n                /* Related/reply flows need to be set on the opposite pipeline\n                 * from where the ACL itself is set.\n                 */\n                enum ovn_stage log_related_stage = ingress ?\n                    S_SWITCH_OUT_ACL :\n                    S_SWITCH_IN_ACL;\n                ds_clear(match);\n                ds_clear(actions);\n\n                ds_put_format(match, \"ct.est && !ct.rel && !ct.new%s && \"\n                              \"ct.rpl && %s == 0 && \"\n                              \"ct_label.label == %\" PRId64,\n                              use_ct_inv_match ? \" && !ct.inv\" : \"\",\n                              ct_blocked_match, acl->label);\n                build_acl_log(actions, acl, meter_groups);\n                ds_put_cstr(actions, \"next;\");\n                ovn_lflow_add_with_hint(lflows, od, log_related_stage,\n                                        UINT16_MAX - 2,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &acl->header_);\n\n                ds_clear(match);\n                ds_put_format(match, \"!ct.est && ct.rel && !ct.new%s && \"\n                                     \"%s == 0 && \"\n                                     \"ct_label.label == %\" PRId64,\n                                     use_ct_inv_match ? \" && !ct.inv\" : \"\",\n                                     ct_blocked_match, acl->label);\n                ovn_lflow_add_with_hint(lflows, od, log_related_stage,\n                                        UINT16_MAX - 2,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &acl->header_);\n            }\n\n        }\n    } else if (!strcmp(acl->action, \"drop\")\n               || !strcmp(acl->action, \"reject\")) {\n        /* The implementation of \"drop\" differs if stateful ACLs are in\n         * use for this datapath.  In that case, the actions differ\n         * depending on whether the connection was previously committed\n         * to the connection tracker with ct_commit. */\n        if (has_stateful) {\n            /* If the packet is not tracked or not part of an established\n             * connection, then we can simply reject/drop it. */\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_cstr(match, REGBIT_ACL_HINT_DROP \" == 1\");\n            if (!strcmp(acl->action, \"reject\")) {\n                build_reject_acl_rules(od, lflows, stage, acl, match,\n                                       actions, &acl->header_, meter_groups);\n            } else {\n                ds_put_format(match, \" && (%s)\", acl->match);\n                build_acl_log(actions, acl, meter_groups);\n                ds_put_cstr(actions, debug_implicit_drop_action());\n                ovn_lflow_add_with_hint(lflows, od, stage,\n                                        acl->priority + OVN_ACL_PRI_OFFSET,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &acl->header_);\n            }\n            /* For an existing connection without ct_mark.blocked set, we've\n             * encountered a policy change. ACLs previously allowed\n             * this connection and we committed the connection tracking\n             * entry.  Current policy says that we should drop this\n             * connection.  First, we set ct_mark.blocked to indicate\n             * that this connection is set for deletion.  By not\n             * specifying \"next;\", we implicitly drop the packet after\n             * updating conntrack state.  We would normally defer\n             * ct_commit() to the \"stateful\" stage, but since we're\n             * rejecting/dropping the packet, we go ahead and do it here.\n             */\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_cstr(match, REGBIT_ACL_HINT_BLOCK \" == 1\");\n            ds_put_format(actions, \"ct_commit { %s = 1; }; \",\n                          ct_blocked_match);\n            if (!strcmp(acl->action, \"reject\")) {\n                build_reject_acl_rules(od, lflows, stage, acl, match,\n                                       actions, &acl->header_, meter_groups);\n            } else {\n                ds_put_format(match, \" && (%s)\", acl->match);\n                build_acl_log(actions, acl, meter_groups);\n                ds_put_cstr(actions, debug_implicit_drop_action());\n                ovn_lflow_add_with_hint(lflows, od, stage,\n                                        acl->priority + OVN_ACL_PRI_OFFSET,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &acl->header_);\n            }\n        } else {\n            /* There are no stateful ACLs in use on this datapath,\n             * so a \"reject/drop\" ACL is simply the \"reject/drop\"\n             * logical flow action in all cases. */\n            ds_clear(match);\n            ds_clear(actions);\n            if (!strcmp(acl->action, \"reject\")) {\n                build_reject_acl_rules(od, lflows, stage, acl, match,\n                                       actions, &acl->header_, meter_groups);\n            } else {\n                build_acl_log(actions, acl, meter_groups);\n                ds_put_cstr(actions, debug_implicit_drop_action());\n                ovn_lflow_add_with_hint(lflows, od, stage,\n                                        acl->priority + OVN_ACL_PRI_OFFSET,\n                                        acl->match, ds_cstr(actions),\n                                        &acl->header_);\n            }\n        }\n    }\n}\n\nstatic struct ovn_port_group *\novn_port_group_create(struct hmap *pgs,\n                      const struct nbrec_port_group *nb_pg)\n{\n    struct ovn_port_group *pg = xzalloc(sizeof *pg);\n    pg->key = nb_pg->header_.uuid;\n    pg->nb_pg = nb_pg;\n    hmap_init(&pg->nb_lswitches);\n    hmap_insert(pgs, &pg->key_node, uuid_hash(&pg->key));\n    return pg;\n}\n\nstatic void\novn_port_group_destroy(struct hmap *pgs, struct ovn_port_group *pg)\n{\n    if (pg) {\n        hmap_remove(pgs, &pg->key_node);\n        struct ovn_port_group_ls *ls;\n        HMAP_FOR_EACH_POP (ls, key_node, &pg->nb_lswitches) {\n            free(ls->ports);\n            free(ls);\n        }\n        hmap_destroy(&pg->nb_lswitches);\n        free(pg);\n    }\n}\n\nstatic void\ncopy_ra_to_sb(struct ovn_port *op, const char *address_mode);\n\nstatic void\novn_update_ipv6_options(struct hmap *ports)\n{\n    struct ovn_port *op;\n    HMAP_FOR_EACH (op, key_node, ports) {\n        if (!op->nbrp || op->nbrp->peer || !op->peer) {\n            continue;\n        }\n\n        if (!op->lrp_networks.n_ipv6_addrs) {\n            continue;\n        }\n\n        struct smap options;\n        smap_clone(&options, &op->sb->options);\n\n        /* enable IPv6 prefix delegation */\n        bool prefix_delegation = smap_get_bool(&op->nbrp->options,\n                                           \"prefix_delegation\", false);\n        if (!lrport_is_enabled(op->nbrp)) {\n            prefix_delegation = false;\n        }\n        if (smap_get_bool(&options, \"ipv6_prefix_delegation\",\n                          false) != prefix_delegation) {\n            smap_add(&options, \"ipv6_prefix_delegation\",\n                     prefix_delegation ? \"true\" : \"false\");\n        }\n\n        bool ipv6_prefix = smap_get_bool(&op->nbrp->options,\n                                     \"prefix\", false);\n        if (!lrport_is_enabled(op->nbrp)) {\n            ipv6_prefix = false;\n        }\n        if (smap_get_bool(&options, \"ipv6_prefix\", false) != ipv6_prefix) {\n            smap_add(&options, \"ipv6_prefix\",\n                     ipv6_prefix ? \"true\" : \"false\");\n        }\n        sbrec_port_binding_set_options(op->sb, &options);\n\n        smap_destroy(&options);\n\n        const char *address_mode = smap_get(\n            &op->nbrp->ipv6_ra_configs, \"address_mode\");\n\n        if (!address_mode) {\n            continue;\n        }\n        if (strcmp(address_mode, \"slaac\") &&\n            strcmp(address_mode, \"dhcpv6_stateful\") &&\n            strcmp(address_mode, \"dhcpv6_stateless\")) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n            VLOG_WARN_RL(&rl, \"Invalid address mode [%s] defined\",\n                         address_mode);\n            continue;\n        }\n\n        if (smap_get_bool(&op->nbrp->ipv6_ra_configs, \"send_periodic\",\n                          false)) {\n            copy_ra_to_sb(op, address_mode);\n        }\n    }\n}\n\nstatic void\nbuild_port_group_lswitches(struct northd_input *input_data,\n                           struct hmap *pgs,\n                           struct hmap *ports)\n{\n    hmap_init(pgs);\n\n    const struct nbrec_port_group *nb_pg;\n    NBREC_PORT_GROUP_TABLE_FOR_EACH (nb_pg,\n                                  input_data->nbrec_port_group_table) {\n        struct ovn_port_group *pg = ovn_port_group_create(pgs, nb_pg);\n        for (size_t i = 0; i < nb_pg->n_ports; i++) {\n            struct ovn_port *op = ovn_port_find(ports, nb_pg->ports[i]->name);\n            if (!op) {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n                VLOG_ERR_RL(&rl, \"lport %s in port group %s not found.\",\n                            nb_pg->ports[i]->name,\n                            nb_pg->name);\n                continue;\n            }\n\n            if (!op->od->nbs) {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n                VLOG_WARN_RL(&rl, \"lport %s in port group %s has no lswitch.\",\n                             nb_pg->ports[i]->name,\n                             nb_pg->name);\n                continue;\n            }\n\n            struct ovn_port_group_ls *pg_ls =\n                ovn_port_group_ls_find(pg, &op->od->nbs->header_.uuid);\n            if (!pg_ls) {\n                pg_ls = ovn_port_group_ls_add(pg, op->od);\n                ovn_ls_port_group_add(&op->od->nb_pgs, nb_pg);\n            }\n            ovn_port_group_ls_add_port(pg_ls, op);\n        }\n    }\n}\n\n#define IPV6_CT_OMIT_MATCH \"nd || nd_ra || nd_rs || mldv1 || mldv2\"\n\nstatic void\nbuild_acls(struct ovn_datapath *od, const struct chassis_features *features,\n           struct hmap *lflows, const struct hmap *port_groups,\n           const struct shash *meter_groups)\n{\n    const char *default_acl_action = default_acl_drop ? debug_drop_action() :\n                                                        \"next;\";\n    bool has_stateful = od->has_stateful_acl || od->has_lb_vip;\n    const char *ct_blocked_match = features->ct_no_masked_label\n                                   ? \"ct_mark.blocked\"\n                                   : \"ct_label.blocked\";\n    struct ds match   = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    /* Ingress and Egress ACL Table (Priority 0): Packets are allowed by\n     * default.  If the logical switch has no ACLs or no load balancers,\n     * then add 65535-priority flow to advance the packet to next\n     * stage.\n     *\n     * A related rule at priority 1 is added below if there\n     * are any stateful ACLs in this datapath. */\n    if (!od->has_acls) {\n        if (!od->has_lb_vip) {\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, UINT16_MAX, \"1\",\n                          \"next;\");\n            ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, UINT16_MAX, \"1\",\n                          \"next;\");\n        } else {\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, 0, \"1\", \"next;\");\n            ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, 0, \"1\", \"next;\");\n        }\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL_AFTER_LB, 0, \"1\", \"next;\");\n    } else {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, 0, \"1\",\n                      default_acl_action);\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, 0, \"1\",\n                      default_acl_action);\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL_AFTER_LB, 0, \"1\",\n                      default_acl_action);\n    }\n\n\n    if (has_stateful) {\n        /* Ingress and Egress ACL Table (Priority 1).\n         *\n         * By default, traffic is allowed (if default_acl_drop is 'false') or\n         * dropped (if default_acl_drop is 'true').  This is partially\n         * handled by the Priority 0 ACL flows added earlier, but we also\n         * need to commit IP flows.  This is because, while the initiater's\n         * direction may not have any stateful rules, the server's may\n         * and then its return traffic would not have an associated\n         * conntrack entry and would return \"+invalid\".\n         *\n         * We use \"ct_commit\" for a connection that is not already known\n         * by the connection tracker.  Once a connection is committed,\n         * subsequent packets will hit the flow at priority 0 that just\n         * uses \"next;\"\n         *\n         * We also check for established connections that have ct_mark.blocked\n         * set on them.  That's a connection that was disallowed, but is\n         * now allowed by policy again since it hit this default-allow flow.\n         * We need to set ct_mark.blocked=0 to let the connection continue,\n         * which will be done by ct_commit() in the \"stateful\" stage.\n         * Subsequent packets will hit the flow at priority 0 that just\n         * uses \"next;\". */\n        ds_clear(&match);\n        ds_put_format(&match, \"ip && ct.est && %s == 1\", ct_blocked_match);\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, 1,\n                      ds_cstr(&match),\n                      REGBIT_CONNTRACK_COMMIT\" = 1; next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, 1,\n                      ds_cstr(&match),\n                      REGBIT_CONNTRACK_COMMIT\" = 1; next;\");\n\n        default_acl_action = default_acl_drop\n                             ? debug_drop_action()\n                             : REGBIT_CONNTRACK_COMMIT\" = 1; next;\";\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, 1, \"ip && !ct.est\",\n                      default_acl_action);\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, 1, \"ip && !ct.est\",\n                      default_acl_action);\n\n        /* Ingress and Egress ACL Table (Priority 65532).\n         *\n         * Always drop traffic that's in an invalid state.  Also drop\n         * reply direction packets for connections that have been marked\n         * for deletion (ct_mark.blocked is set).\n         *\n         * This is enforced at a higher priority than ACLs can be defined. */\n        ds_clear(&match);\n        ds_put_format(&match, \"%s(ct.est && ct.rpl && %s == 1)\",\n                      use_ct_inv_match ? \"ct.inv || \" : \"\",\n                      ct_blocked_match);\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match), debug_drop_action());\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match),  debug_drop_action());\n\n        /* Ingress and Egress ACL Table (Priority 65535 - 3).\n         *\n         * Allow reply traffic that is part of an established\n         * conntrack entry that has not been marked for deletion\n         * (ct_mark.blocked).  We only match traffic in the\n         * reply direction because we want traffic in the request\n         * direction to hit the currently defined policy from ACLs.\n         *\n         * This is enforced at a higher priority than ACLs can be defined. */\n        ds_clear(&match);\n        ds_put_format(&match, \"ct.est && !ct.rel && !ct.new%s && \"\n                      \"ct.rpl && %s == 0\",\n                      use_ct_inv_match ? \" && !ct.inv\" : \"\",\n                      ct_blocked_match);\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match), REGBIT_ACL_HINT_DROP\" = 0; \"\n                      REGBIT_ACL_HINT_BLOCK\" = 0; \"\n                      REGBIT_ACL_HINT_ALLOW_REL\" = 1; next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match), \"next;\");\n\n        /* Ingress and Egress ACL Table (Priority 65535).\n         *\n         * Allow traffic that is related to an existing conntrack entry that\n         * has not been marked for deletion (ct_mark.blocked). At the same\n         * time apply NAT on this traffic.\n         *\n         * This is enforced at a higher priority than ACLs can be defined.\n         *\n         * NOTE: This does not support related data sessions (eg,\n         * a dynamically negotiated FTP data channel), but will allow\n         * related traffic such as an ICMP Port Unreachable through\n         * that's generated from a non-listening UDP port.  */\n        const char *ct_in_acl_action =\n            features->ct_lb_related\n            ? REGBIT_ACL_HINT_ALLOW_REL\" = 1; ct_commit_nat;\"\n            : REGBIT_ACL_HINT_ALLOW_REL\" = 1; next;\";\n        const char *ct_out_acl_action = features->ct_lb_related\n                                        ? \"ct_commit_nat;\"\n                                        : \"next;\";\n        ds_clear(&match);\n        ds_put_format(&match, \"!ct.est && ct.rel && !ct.new%s && %s == 0\",\n                      use_ct_inv_match ? \" && !ct.inv\" : \"\",\n                      ct_blocked_match);\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match), ct_in_acl_action);\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match), ct_out_acl_action);\n\n        /* Reply and related traffic matched by an \"allow-related\" ACL\n         * should be allowed in the ls_in_acl_after_lb stage too. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL_AFTER_LB, UINT16_MAX - 3,\n                      REGBIT_ACL_HINT_ALLOW_REL\" == 1\", \"next;\");\n    }\n\n    /* Ingress and Egress ACL Table (Priority 65532).\n     *\n     * Always allow service IPv6 protocols regardless of other ACLs defined.\n     *\n     * Also, don't send them to conntrack because session tracking\n     * for these protocols is not working properly:\n     * https://bugzilla.kernel.org/show_bug.cgi?id=11797. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, UINT16_MAX - 3,\n                  IPV6_CT_OMIT_MATCH, \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, UINT16_MAX - 3,\n                  IPV6_CT_OMIT_MATCH, \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL_AFTER_LB, UINT16_MAX - 3,\n                  IPV6_CT_OMIT_MATCH, \"next;\");\n\n    /* Ingress or Egress ACL Table (Various priorities). */\n    for (size_t i = 0; i < od->nbs->n_acls; i++) {\n        struct nbrec_acl *acl = od->nbs->acls[i];\n        consider_acl(lflows, od, acl, has_stateful,\n                     features->ct_no_masked_label,\n                     meter_groups, &match, &actions);\n    }\n    struct ovn_port_group *pg;\n    HMAP_FOR_EACH (pg, key_node, port_groups) {\n        if (ovn_port_group_ls_find(pg, &od->nbs->header_.uuid)) {\n            for (size_t i = 0; i < pg->nb_pg->n_acls; i++) {\n                consider_acl(lflows, od, pg->nb_pg->acls[i], has_stateful,\n                             features->ct_no_masked_label,\n                             meter_groups, &match, &actions);\n            }\n        }\n    }\n\n    /* Add 34000 priority flow to allow DHCP reply from ovn-controller to all\n     * logical ports of the datapath if the CMS has configured DHCPv4 options.\n     * */\n    for (size_t i = 0; i < od->nbs->n_ports; i++) {\n        if (lsp_is_external(od->nbs->ports[i])) {\n            continue;\n        }\n\n        if (od->nbs->ports[i]->dhcpv4_options) {\n            const char *server_id = smap_get(\n                &od->nbs->ports[i]->dhcpv4_options->options, \"server_id\");\n            const char *server_mac = smap_get(\n                &od->nbs->ports[i]->dhcpv4_options->options, \"server_mac\");\n            const char *lease_time = smap_get(\n                &od->nbs->ports[i]->dhcpv4_options->options, \"lease_time\");\n            if (server_id && server_mac && lease_time) {\n                const char *dhcp_actions =\n                    has_stateful ? \"ct_commit; next;\" : \"next;\";\n                ds_clear(&match);\n                ds_put_format(&match, \"outport == \\\"%s\\\" && eth.src == %s \"\n                              \"&& ip4.src == %s && udp && udp.src == 67 \"\n                              \"&& udp.dst == 68\", od->nbs->ports[i]->name,\n                              server_mac, server_id);\n                ovn_lflow_add_with_lport_and_hint(\n                    lflows, od, S_SWITCH_OUT_ACL, 34000, ds_cstr(&match),\n                    dhcp_actions, od->nbs->ports[i]->name,\n                    &od->nbs->ports[i]->dhcpv4_options->header_);\n            }\n        }\n\n        if (od->nbs->ports[i]->dhcpv6_options) {\n            const char *server_mac = smap_get(\n                &od->nbs->ports[i]->dhcpv6_options->options, \"server_id\");\n            struct eth_addr ea;\n            if (server_mac && eth_addr_from_string(server_mac, &ea)) {\n                /* Get the link local IP of the DHCPv6 server from the\n                 * server MAC. */\n                struct in6_addr lla;\n                in6_generate_lla(ea, &lla);\n\n                char server_ip[INET6_ADDRSTRLEN + 1];\n                ipv6_string_mapped(server_ip, &lla);\n\n                const char *dhcp6_actions = has_stateful ? \"ct_commit; next;\" :\n                    \"next;\";\n                ds_clear(&match);\n                ds_put_format(&match, \"outport == \\\"%s\\\" && eth.src == %s \"\n                              \"&& ip6.src == %s && udp && udp.src == 547 \"\n                              \"&& udp.dst == 546\", od->nbs->ports[i]->name,\n                              server_mac, server_ip);\n                ovn_lflow_add_with_lport_and_hint(\n                    lflows, od, S_SWITCH_OUT_ACL, 34000, ds_cstr(&match),\n                    dhcp6_actions, od->nbs->ports[i]->name,\n                    &od->nbs->ports[i]->dhcpv6_options->header_);\n            }\n        }\n    }\n\n    /* Add a 34000 priority flow to advance the DNS reply from ovn-controller,\n     * if the CMS has configured DNS records for the datapath.\n     */\n    if (ls_has_dns_records(od->nbs)) {\n        const char *dns_actions = has_stateful ? \"ct_commit; next;\" : \"next;\";\n        ovn_lflow_add(\n            lflows, od, S_SWITCH_OUT_ACL, 34000, \"udp.src == 53\",\n            dns_actions);\n    }\n\n    if (od->has_acls || od->has_lb_vip) {\n        /* Add a 34000 priority flow to advance the service monitor reply\n        * packets to skip applying ingress ACLs. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, 34000,\n                    \"eth.dst == $svc_monitor_mac\", \"next;\");\n\n        /* Add a 34000 priority flow to advance the service monitor packets\n        * generated by ovn-controller to skip applying egress ACLs. */\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, 34000,\n                    \"eth.src == $svc_monitor_mac\", \"next;\");\n    }\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_qos(struct ovn_datapath *od, struct hmap *lflows) {\n    struct ds action = DS_EMPTY_INITIALIZER;\n\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_QOS_MARK, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_QOS_MARK, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_QOS_METER, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_QOS_METER, 0, \"1\", \"next;\");\n\n    for (size_t i = 0; i < od->nbs->n_qos_rules; i++) {\n        struct nbrec_qos *qos = od->nbs->qos_rules[i];\n        bool ingress = !strcmp(qos->direction, \"from-lport\") ? true :false;\n        enum ovn_stage stage = ingress ? S_SWITCH_IN_QOS_MARK : S_SWITCH_OUT_QOS_MARK;\n        int64_t rate = 0;\n        int64_t burst = 0;\n\n        for (size_t j = 0; j < qos->n_action; j++) {\n            if (!strcmp(qos->key_action[j], \"dscp\")) {\n                ds_clear(&action);\n                ds_put_format(&action, \"ip.dscp = %\"PRId64\"; next;\",\n                              qos->value_action[j]);\n                ovn_lflow_add_with_hint(lflows, od, stage,\n                                        qos->priority,\n                                        qos->match, ds_cstr(&action),\n                                        &qos->header_);\n            }\n        }\n\n        for (size_t n = 0; n < qos->n_bandwidth; n++) {\n            if (!strcmp(qos->key_bandwidth[n], \"rate\")) {\n                rate = qos->value_bandwidth[n];\n            } else if (!strcmp(qos->key_bandwidth[n], \"burst\")) {\n                burst = qos->value_bandwidth[n];\n            }\n        }\n        if (rate) {\n            stage = ingress ? S_SWITCH_IN_QOS_METER : S_SWITCH_OUT_QOS_METER;\n            ds_clear(&action);\n            if (burst) {\n                ds_put_format(&action,\n                              \"set_meter(%\"PRId64\", %\"PRId64\"); next;\",\n                              rate, burst);\n            } else {\n                ds_put_format(&action,\n                              \"set_meter(%\"PRId64\"); next;\",\n                              rate);\n            }\n\n            /* Ingress and Egress QoS Meter Table.\n             *\n             * We limit the bandwidth of this flow by adding a meter table.\n             */\n            ovn_lflow_add_with_hint(lflows, od, stage,\n                                    qos->priority,\n                                    qos->match, ds_cstr(&action),\n                                    &qos->header_);\n        }\n    }\n    ds_destroy(&action);\n}\n\nstatic void\nbuild_lb_rules_pre_stateful(struct hmap *lflows, struct ovn_northd_lb *lb,\n                            bool ct_lb_mark, struct ds *match,\n                            struct ds *action)\n{\n    if (!lb->n_nb_ls) {\n        return;\n    }\n\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n        ds_clear(action);\n        ds_clear(match);\n        const char *ip_match = NULL;\n\n        /* Store the original destination IP to be used when generating\n         * hairpin flows.\n         */\n        if (lb->vips[i].address_family == AF_INET) {\n            ip_match = \"ip4\";\n            ds_put_format(action, REG_ORIG_DIP_IPV4 \" = %s; \",\n                          lb_vip->vip_str);\n        } else {\n            ip_match = \"ip6\";\n            ds_put_format(action, REG_ORIG_DIP_IPV6 \" = %s; \",\n                          lb_vip->vip_str);\n        }\n\n        const char *proto = NULL;\n        if (lb_vip->port_str) {\n            proto = \"tcp\";\n            if (lb->nlb->protocol) {\n                if (!strcmp(lb->nlb->protocol, \"udp\")) {\n                    proto = \"udp\";\n                } else if (!strcmp(lb->nlb->protocol, \"sctp\")) {\n                    proto = \"sctp\";\n                }\n            }\n\n            /* Store the original destination port to be used when generating\n             * hairpin flows.\n             */\n            ds_put_format(action, REG_ORIG_TP_DPORT \" = %s; \",\n                          lb_vip->port_str);\n        }\n        ds_put_format(action, \"%s;\", ct_lb_mark ? \"ct_lb_mark\" : \"ct_lb\");\n\n        ds_put_format(match, REGBIT_CONNTRACK_NAT\" == 1 && %s.dst == %s\",\n                      ip_match, lb_vip->vip_str);\n        if (lb_vip->port_str) {\n            ds_put_format(match, \" && %s.dst == %s\", proto, lb_vip->port_str);\n        }\n\n        ovn_lflow_add_with_dp_group(\n            lflows, lb->nb_ls_map, S_SWITCH_IN_PRE_STATEFUL, 120,\n            ds_cstr(match), ds_cstr(action), &lb->nlb->header_);\n    }\n}\n\n/* Builds the logical router flows related to load balancer affinity.\n * For a LB configured with 'vip=V:VP' and backends 'B1:BP1,B2:BP2' and\n * affinity timeout set to T, it generates the following logical flows:\n * - load balancing affinity check:\n *   table=lr_in_lb_aff_check, priority=100\n *      match=(new_lb_match)\n *      action=(REG_NEXT_HOP_IPV4 = ip4.dst;\n *              REG_ORIG_TP_DPORT_ROUTER = tcp.dst;\n *              REGBIT_KNOWN_LB_SESSION = chk_lb_aff(); next;)\n *\n * - load balancing:\n *   table=lr_in_dnat, priority=150\n *      match=(REGBIT_KNOWN_LB_SESSION == 1 && ct.new && ip4\n *             && REG_LB_AFF_BACKEND_IP4 == B1 && REG_LB_AFF_MATCH_PORT == BP1)\n *      action=(REG_NEXT_HOP_IPV4 = V; lb_action;\n *              ct_lb_mark(backends=B1:BP1; ct_flag);)\n *   table=lr_in_dnat, priority=150\n *      match=(REGBIT_KNOWN_LB_SESSION == 1 && ct.new && ip4\n *             && REG_LB_AFF_BACKEND_IP4 == B2 && REG_LB_AFF_MATCH_PORT == BP2)\n *      action=(REG_NEXT_HOP_IPV4 = V; lb_action;\n *              ct_lb_mark(backends=B2:BP2; ct_flag);)\n *\n * - load balancing affinity learn:\n *   table=lr_in_lb_aff_learn, priority=100\n *      match=(REGBIT_KNOWN_LB_SESSION == 0\n *             && ct.new && ip4\n *             && REG_NEXT_HOP_IPV4 == V && REG_ORIG_TP_DPORT_ROUTER = VP\n *             && ip4.dst == B1 && tcp.dst == BP1)\n *      action=(commit_lb_aff(vip = \"V:VP\", backend = \"B1:BP1\",\n *                            proto = tcp, timeout = T));\n *   table=lr_in_lb_aff_learn, priority=100\n *      match=(REGBIT_KNOWN_LB_SESSION == 0\n *             && ct.new && ip4\n *             && REG_NEXT_HOP_IPV4 == V && REG_ORIG_TP_DPORT_ROUTER = VP\n *             && ip4.dst == B2 && tcp.dst == BP2)\n *      action=(commit_lb_aff(vip = \"V:VP\", backend = \"B2:BP2\",\n *                            proto = tcp, timeout = T));\n *\n */\nstatic void\nbuild_lb_affinity_lr_flows(struct hmap *lflows, struct ovn_northd_lb *lb,\n                           struct ovn_lb_vip *lb_vip, char *new_lb_match,\n                           char *lb_action, const unsigned long *dp_bitmap)\n{\n    if (!lb->affinity_timeout ||\n        bitmap_is_all_zeros(dp_bitmap, n_datapaths)) {\n        return;\n    }\n\n    struct ds aff_action = DS_EMPTY_INITIALIZER;\n    struct ds aff_action_learn = DS_EMPTY_INITIALIZER;\n    struct ds aff_match = DS_EMPTY_INITIALIZER;\n    struct ds aff_match_learn = DS_EMPTY_INITIALIZER;\n    struct ds aff_check_action = DS_EMPTY_INITIALIZER;\n\n    bool ipv6 = !IN6_IS_ADDR_V4MAPPED(&lb_vip->vip);\n    const char *ip_match = ipv6 ? \"ip6\" : \"ip4\";\n\n    const char *reg_vip = ipv6 ? REG_NEXT_HOP_IPV6 : REG_NEXT_HOP_IPV4;\n    const char *reg_backend =\n        ipv6 ? REG_LB_L3_AFF_BACKEND_IP6 : REG_LB_AFF_BACKEND_IP4;\n    const char *ct_flag = NULL;\n    if (lb_action && !strcmp(lb_action, \"flags.skip_snat_for_lb = 1; \")) {\n        ct_flag = \"; skip_snat\";\n    } else if (lb_action &&\n               !strcmp(lb_action, \"flags.force_snat_for_lb = 1; \")) {\n        ct_flag = \"; force_snat\";\n    }\n\n    /* Create affinity check flow. */\n    ds_put_format(&aff_check_action, \"%s = %s.dst; \", reg_vip, ip_match);\n\n    if (lb_vip->port_str) {\n        ds_put_format(&aff_check_action, REG_ORIG_TP_DPORT_ROUTER\" = %s.dst; \",\n                      lb->proto);\n    }\n    ds_put_cstr(&aff_check_action, REGBIT_KNOWN_LB_SESSION\n                \" = chk_lb_aff(); next;\");\n\n    ovn_lflow_add_with_dp_group(\n        lflows, dp_bitmap, S_ROUTER_IN_LB_AFF_CHECK, 100,\n        new_lb_match, ds_cstr(&aff_check_action), &lb->nlb->header_);\n\n    /* Prepare common part of affinity LB and affinity learn action. */\n    ds_put_format(&aff_action, \"%s = %s; \", reg_vip, lb_vip->vip_str);\n    ds_put_cstr(&aff_action_learn, \"commit_lb_aff(vip = \\\"\");\n\n    if (lb_vip->port_str) {\n        ds_put_format(&aff_action_learn, ipv6 ? \"[%s]:%s\" : \"%s:%s\",\n                      lb_vip->vip_str, lb_vip->port_str);\n    } else {\n        ds_put_cstr(&aff_action_learn, lb_vip->vip_str);\n    }\n\n    if (lb_action) {\n        ds_put_cstr(&aff_action, lb_action);\n    }\n    ds_put_cstr(&aff_action, \"ct_lb_mark(backends=\");\n    ds_put_cstr(&aff_action_learn, \"\\\", backend = \\\"\");\n\n    /* Prepare common part of affinity learn match. */\n    if (lb_vip->port_str) {\n        ds_put_format(&aff_match_learn, REGBIT_KNOWN_LB_SESSION\" == 0 && \"\n                      \"ct.new && %s && %s == %s && \"\n                      REG_ORIG_TP_DPORT_ROUTER\" == %s && \"\n                      \"%s.dst == \", ip_match, reg_vip, lb_vip->vip_str,\n                      lb_vip->port_str, ip_match);\n    } else {\n        ds_put_format(&aff_match_learn, REGBIT_KNOWN_LB_SESSION\" == 0 && \"\n                      \"ct.new && %s && %s == %s && %s.dst == \", ip_match,\n                      reg_vip, lb_vip->vip_str, ip_match);\n    }\n\n    /* Prepare common part of affinity match. */\n    ds_put_format(&aff_match, REGBIT_KNOWN_LB_SESSION\" == 1 && \"\n                  \"ct.new && %s && %s == \", ip_match, reg_backend);\n\n    /* Store the common part length. */\n    size_t aff_action_len = aff_action.length;\n    size_t aff_action_learn_len = aff_action_learn.length;\n    size_t aff_match_len = aff_match.length;\n    size_t aff_match_learn_len = aff_match_learn.length;\n\n\n    for (size_t i = 0; i < lb_vip->n_backends; i++) {\n        struct ovn_lb_backend *backend = &lb_vip->backends[i];\n\n        ds_put_cstr(&aff_match_learn, backend->ip_str);\n        ds_put_cstr(&aff_match, backend->ip_str);\n\n        if (backend->port) {\n            ds_put_format(&aff_action, ipv6 ? \"[%s]:%d\" : \"%s:%d\",\n                          backend->ip_str, backend->port);\n            ds_put_format(&aff_action_learn, ipv6 ? \"[%s]:%d\" : \"%s:%d\",\n                          backend->ip_str, backend->port);\n\n            ds_put_format(&aff_match_learn, \" && %s.dst == %d\",\n                          lb->proto, backend->port);\n            ds_put_format(&aff_match, \" && \"REG_LB_AFF_MATCH_PORT\" == %d\",\n                          backend->port);\n        } else {\n            ds_put_cstr(&aff_action, backend->ip_str);\n            ds_put_cstr(&aff_action_learn, backend->ip_str);\n        }\n\n        if (ct_flag) {\n            ds_put_cstr(&aff_action, ct_flag);\n        }\n\n        ds_put_cstr(&aff_action, \");\");\n        ds_put_char(&aff_action_learn, '\"');\n\n        if (lb_vip->port_str) {\n            ds_put_format(&aff_action_learn, \", proto = %s\", lb->proto);\n        }\n\n        ds_put_format(&aff_action_learn, \", timeout = %d); /* drop */\",\n                      lb->affinity_timeout);\n\n        /* Forward to OFTABLE_CHK_LB_AFFINITY table to store flow tuple. */\n        ovn_lflow_add_with_dp_group(\n            lflows, dp_bitmap, S_ROUTER_IN_LB_AFF_LEARN, 100,\n            ds_cstr(&aff_match_learn), ds_cstr(&aff_action_learn),\n            &lb->nlb->header_);\n\n        /* Use already selected backend within affinity timeslot. */\n        ovn_lflow_add_with_dp_group(\n            lflows, dp_bitmap, S_ROUTER_IN_DNAT, 150,\n            ds_cstr(&aff_match), ds_cstr(&aff_action), &lb->nlb->header_);\n\n        ds_truncate(&aff_action, aff_action_len);\n        ds_truncate(&aff_action_learn, aff_action_learn_len);\n        ds_truncate(&aff_match, aff_match_len);\n        ds_truncate(&aff_match_learn, aff_match_learn_len);\n    }\n\n    ds_destroy(&aff_action);\n    ds_destroy(&aff_action_learn);\n    ds_destroy(&aff_match);\n    ds_destroy(&aff_match_learn);\n    ds_destroy(&aff_check_action);\n}\n\n/* Builds the logical switch flows related to load balancer affinity.\n * For a LB configured with 'vip=V:VP' and backends 'B1:BP1,B2:BP2' and\n * affinity timeout set to T, it generates the following logical flows:\n * - load balancing affinity check:\n *   table=ls_in_lb_aff_check, priority=100\n *      match=(ct.new && ip4\n *             && REG_ORIG_DIP_IPV4 == V && REG_ORIG_TP_DPORT == VP)\n *      action=(REGBIT_KNOWN_LB_SESSION = chk_lb_aff(); next;)\n *\n * - load balancing:\n *   table=ls_in_lb, priority=150\n *      match=(REGBIT_KNOWN_LB_SESSION == 1 && ct.new && ip4\n *             && REG_LB_AFF_BACKEND_IP4 == B1 && REG_LB_AFF_MATCH_PORT == BP1)\n *      action=(REGBIT_CONNTRACK_COMMIT = 0;\n *              REG_ORIG_DIP_IPV4 = V; REG_ORIG_TP_DPORT = VP;\n *              ct_lb_mark(backends=B1:BP1);)\n *   table=ls_in_lb, priority=150\n *      match=(REGBIT_KNOWN_LB_SESSION == 1 && ct.new && ip4\n *             && REG_LB_AFF_BACKEND_IP4 == B2 && REG_LB_AFF_MATCH_PORT == BP2)\n *      action=(REGBIT_CONNTRACK_COMMIT = 0;\n *              REG_ORIG_DIP_IPV4 = V;\n *              REG_ORIG_TP_DPORT = VP;\n *              ct_lb_mark(backends=B1:BP2);)\n *\n * - load balancing affinity learn:\n *   table=ls_in_lb_aff_learn, priority=100\n *      match=(REGBIT_KNOWN_LB_SESSION == 0\n *             && ct.new && ip4\n *             && REG_ORIG_DIP_IPV4 == V && REG_ORIG_TP_DPORT == VP\n *             && ip4.dst == B1 && tcp.dst == BP1)\n *      action=(commit_lb_aff(vip = \"V:VP\", backend = \"B1:BP1\",\n *                            proto = tcp, timeout = T));\n *   table=ls_in_lb_aff_learn, priority=100\n *      match=(REGBIT_KNOWN_LB_SESSION == 0\n *             && ct.new && ip4\n *             && REG_ORIG_DIP_IPV4 == V && REG_ORIG_TP_DPORT == VP\n *             && ip4.dst == B2 && tcp.dst == BP2)\n *      action=(commit_lb_aff(vip = \"V:VP\", backend = \"B2:BP2\",\n *                            proto = tcp, timeout = T));\n *\n */\nstatic void\nbuild_lb_affinity_ls_flows(struct hmap *lflows, struct ovn_northd_lb *lb,\n                           struct ovn_lb_vip *lb_vip)\n{\n    if (!lb->affinity_timeout || !lb->n_nb_ls) {\n        return;\n    }\n\n    struct ds new_lb_match = DS_EMPTY_INITIALIZER;\n    if (IN6_IS_ADDR_V4MAPPED(&lb_vip->vip)) {\n        ds_put_format(&new_lb_match,\n                      \"ct.new && ip4 && \"REG_ORIG_DIP_IPV4 \" == %s\",\n                      lb_vip->vip_str);\n    } else {\n        ds_put_format(&new_lb_match,\n                      \"ct.new && ip6 && \"REG_ORIG_DIP_IPV6 \" == %s\",\n                      lb_vip->vip_str);\n    }\n\n    if (lb_vip->port_str) {\n        ds_put_format(&new_lb_match, \" && \"REG_ORIG_TP_DPORT \" == %s\",\n                      lb_vip->port_str);\n    }\n\n    static char *aff_check = REGBIT_KNOWN_LB_SESSION\" = chk_lb_aff(); next;\";\n\n    ovn_lflow_add_with_dp_group(\n        lflows, lb->nb_ls_map, S_SWITCH_IN_LB_AFF_CHECK, 100,\n        ds_cstr(&new_lb_match), aff_check, &lb->nlb->header_);\n    ds_destroy(&new_lb_match);\n\n    struct ds aff_action = DS_EMPTY_INITIALIZER;\n    struct ds aff_action_learn = DS_EMPTY_INITIALIZER;\n    struct ds aff_match = DS_EMPTY_INITIALIZER;\n    struct ds aff_match_learn = DS_EMPTY_INITIALIZER;\n\n    bool ipv6 = !IN6_IS_ADDR_V4MAPPED(&lb_vip->vip);\n    const char *ip_match = ipv6 ? \"ip6\" : \"ip4\";\n\n    const char *reg_vip = ipv6 ? REG_ORIG_DIP_IPV6 : REG_ORIG_DIP_IPV4;\n    const char *reg_backend =\n        ipv6 ? REG_LB_L2_AFF_BACKEND_IP6 : REG_LB_AFF_BACKEND_IP4;\n\n    /* Prepare common part of affinity LB and affinity learn action. */\n    ds_put_format(&aff_action, REGBIT_CONNTRACK_COMMIT\" = 0; %s = %s; \",\n                  reg_vip, lb_vip->vip_str);\n    ds_put_cstr(&aff_action_learn, \"commit_lb_aff(vip = \\\"\");\n\n    if (lb_vip->port_str) {\n        ds_put_format(&aff_action, REG_ORIG_TP_DPORT\" = %s; \",\n                      lb_vip->port_str);\n        ds_put_format(&aff_action_learn, ipv6 ? \"[%s]:%s\" : \"%s:%s\",\n                      lb_vip->vip_str, lb_vip->port_str);\n    } else {\n        ds_put_cstr(&aff_action_learn, lb_vip->vip_str);\n    }\n\n    ds_put_cstr(&aff_action, \"ct_lb_mark(backends=\");\n    ds_put_cstr(&aff_action_learn, \"\\\", backend = \\\"\");\n\n    /* Prepare common part of affinity learn match. */\n    if (lb_vip->port_str) {\n        ds_put_format(&aff_match_learn, REGBIT_KNOWN_LB_SESSION\" == 0 && \"\n                      \"ct.new && %s && %s == %s && \"\n                      REG_ORIG_TP_DPORT\" == %s && %s.dst == \",\n                      ip_match, reg_vip, lb_vip->vip_str,\n                      lb_vip->port_str, ip_match);\n    } else {\n        ds_put_format(&aff_match_learn, REGBIT_KNOWN_LB_SESSION\" == 0 && \"\n                      \"ct.new && %s && %s == %s && %s.dst == \",\n                      ip_match, reg_vip, lb_vip->vip_str, ip_match);\n    }\n\n    /* Prepare common part of affinity match. */\n    ds_put_format(&aff_match, REGBIT_KNOWN_LB_SESSION\" == 1 && \"\n                  \"ct.new && %s && %s == \", ip_match, reg_backend);\n\n    /* Store the common part length. */\n    size_t aff_action_len = aff_action.length;\n    size_t aff_action_learn_len = aff_action_learn.length;\n    size_t aff_match_len = aff_match.length;\n    size_t aff_match_learn_len = aff_match_learn.length;\n\n    for (size_t i = 0; i < lb_vip->n_backends; i++) {\n        struct ovn_lb_backend *backend = &lb_vip->backends[i];\n\n        ds_put_cstr(&aff_match_learn, backend->ip_str);\n        ds_put_cstr(&aff_match, backend->ip_str);\n\n        if (backend->port) {\n            ds_put_format(&aff_action, ipv6 ? \"[%s]:%d\" : \"%s:%d\",\n                          backend->ip_str, backend->port);\n            ds_put_format(&aff_action_learn, ipv6 ? \"[%s]:%d\" : \"%s:%d\",\n                          backend->ip_str, backend->port);\n\n            ds_put_format(&aff_match_learn, \" && %s.dst == %d\",\n                          lb->proto, backend->port);\n            ds_put_format(&aff_match, \" && \"REG_LB_AFF_MATCH_PORT\" == %d\",\n                          backend->port);\n        } else {\n            ds_put_cstr(&aff_action, backend->ip_str);\n            ds_put_cstr(&aff_action_learn, backend->ip_str);\n        }\n\n        ds_put_cstr(&aff_action, \");\");\n        ds_put_char(&aff_action_learn, '\"');\n\n        if (lb_vip->port_str) {\n            ds_put_format(&aff_action_learn, \", proto = %s\", lb->proto);\n        }\n\n        ds_put_format(&aff_action_learn, \", timeout = %d); /* drop */\",\n                      lb->affinity_timeout);\n\n        /* Forward to OFTABLE_CHK_LB_AFFINITY table to store flow tuple. */\n        ovn_lflow_add_with_dp_group(\n            lflows, lb->nb_ls_map, S_SWITCH_IN_LB_AFF_LEARN, 100,\n            ds_cstr(&aff_match_learn), ds_cstr(&aff_action_learn),\n            &lb->nlb->header_);\n\n        /* Use already selected backend within affinity timeslot. */\n        ovn_lflow_add_with_dp_group(\n            lflows, lb->nb_ls_map, S_SWITCH_IN_LB, 150,\n            ds_cstr(&aff_match), ds_cstr(&aff_action), &lb->nlb->header_);\n\n        ds_truncate(&aff_action, aff_action_len);\n        ds_truncate(&aff_action_learn, aff_action_learn_len);\n        ds_truncate(&aff_match, aff_match_len);\n        ds_truncate(&aff_match_learn, aff_match_learn_len);\n    }\n\n    ds_destroy(&aff_action);\n    ds_destroy(&aff_action_learn);\n    ds_destroy(&aff_match);\n    ds_destroy(&aff_match_learn);\n}\n\nstatic void\nbuild_lb_affinity_default_flows(struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (od->nbs) {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_LB_AFF_CHECK, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_LB_AFF_LEARN, 0, \"1\", \"next;\");\n    }\n    if (od->nbr) {\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LB_AFF_CHECK, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LB_AFF_LEARN, 0, \"1\", \"next;\");\n    }\n}\n\nstatic void\nbuild_lb_rules(struct hmap *lflows, struct ovn_northd_lb *lb,\n               const struct chassis_features *features, struct ds *match,\n               struct ds *action, const struct shash *meter_groups)\n{\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n        struct ovn_northd_lb_vip *lb_vip_nb = &lb->vips_nb[i];\n        const char *ip_match = NULL;\n        if (lb_vip->address_family == AF_INET) {\n            ip_match = \"ip4\";\n        } else {\n            ip_match = \"ip6\";\n        }\n\n        ds_clear(action);\n        ds_clear(match);\n\n        /* Make sure that we clear the REGBIT_CONNTRACK_COMMIT flag.  Otherwise\n         * the load balanced packet will be committed again in\n         * S_SWITCH_IN_STATEFUL. */\n        ds_put_format(action, REGBIT_CONNTRACK_COMMIT\" = 0; \");\n\n        /* New connections in Ingress table. */\n        const char *meter = NULL;\n        bool reject = build_lb_vip_actions(lb_vip, lb_vip_nb, action,\n                                           lb->selection_fields, NULL,\n                                           NULL, true, features);\n\n        ds_put_format(match, \"ct.new && %s.dst == %s\", ip_match,\n                      lb_vip->vip_str);\n        int priority = 110;\n        if (lb_vip->port_str) {\n            ds_put_format(match, \" && %s.dst == %s\", lb->proto,\n                          lb_vip->port_str);\n            priority = 120;\n        }\n\n        build_lb_affinity_ls_flows(lflows, lb, lb_vip);\n\n        unsigned long *dp_non_meter = NULL;\n        bool build_non_meter = false;\n        if (reject) {\n            size_t index;\n\n            dp_non_meter = bitmap_clone(lb->nb_ls_map, n_datapaths);\n            BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_ls_map) {\n                struct ovn_datapath *od = datapaths_array[index];\n\n                meter = copp_meter_get(COPP_REJECT, od->nbs->copp,\n                                       meter_groups);\n                if (!meter) {\n                    build_non_meter = true;\n                    continue;\n                }\n                bitmap_set0(dp_non_meter, index);\n                ovn_lflow_add_with_hint__(\n                        lflows, od, S_SWITCH_IN_LB, priority,\n                        ds_cstr(match), ds_cstr(action),\n                        NULL, meter, &lb->nlb->header_);\n            }\n        }\n        if (!reject || build_non_meter) {\n            ovn_lflow_add_with_dp_group(\n                lflows, dp_non_meter ? dp_non_meter : lb->nb_ls_map,\n                S_SWITCH_IN_LB, priority,\n                ds_cstr(match), ds_cstr(action), &lb->nlb->header_);\n        }\n        bitmap_free(dp_non_meter);\n    }\n}\n\nstatic void\nbuild_stateful(struct ovn_datapath *od,\n               const struct chassis_features *features,\n               struct hmap *lflows)\n{\n    const char *ct_block_action = features->ct_no_masked_label\n                                  ? \"ct_mark.blocked\"\n                                  : \"ct_label.blocked\";\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    /* Ingress LB, Ingress and Egress stateful Table (Priority 0): Packets are\n     * allowed by default. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_LB, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_STATEFUL, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_STATEFUL, 0, \"1\", \"next;\");\n\n    /* If REGBIT_CONNTRACK_COMMIT is set as 1 and\n     * REGBIT_CONNTRACK_SET_LABEL is set to 1, then the packets should be\n     * committed to conntrack.\n     * We always set ct_mark.blocked to 0 here as\n     * any packet that makes it this far is part of a connection we\n     * want to allow to continue. */\n    ds_put_format(&actions, \"ct_commit { %s = 0; \"\n                            \"ct_label.label = \" REG_LABEL \"; }; next;\",\n                  ct_block_action);\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_STATEFUL, 100,\n                  REGBIT_CONNTRACK_COMMIT\" == 1 && \"\n                  REGBIT_ACL_LABEL\" == 1\",\n                  ds_cstr(&actions));\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_STATEFUL, 100,\n                  REGBIT_CONNTRACK_COMMIT\" == 1 && \"\n                  REGBIT_ACL_LABEL\" == 1\",\n                  ds_cstr(&actions));\n\n    /* If REGBIT_CONNTRACK_COMMIT is set as 1, then the packets should be\n     * committed to conntrack. We always set ct_mark.blocked to 0 here as\n     * any packet that makes it this far is part of a connection we\n     * want to allow to continue. */\n    ds_clear(&actions);\n    ds_put_format(&actions, \"ct_commit { %s = 0; }; next;\", ct_block_action);\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_STATEFUL, 100,\n                  REGBIT_CONNTRACK_COMMIT\" == 1 && \"\n                  REGBIT_ACL_LABEL\" == 0\",\n                  ds_cstr(&actions));\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_STATEFUL, 100,\n                  REGBIT_CONNTRACK_COMMIT\" == 1 && \"\n                  REGBIT_ACL_LABEL\" == 0\",\n                  ds_cstr(&actions));\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_lb_hairpin(struct ovn_datapath *od, struct hmap *lflows)\n{\n    /* Ingress Pre-Hairpin/Nat-Hairpin/Hairpin tabled (Priority 0).\n     * Packets that don't need hairpinning should continue processing.\n     */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_HAIRPIN, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_NAT_HAIRPIN, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_HAIRPIN, 0, \"1\", \"next;\");\n\n    if (od->has_lb_vip) {\n        /* Check if the packet needs to be hairpinned.\n         * Set REGBIT_HAIRPIN in the original direction and\n         * REGBIT_HAIRPIN_REPLY in the reply direction.\n         */\n        ovn_lflow_add_with_hint(\n            lflows, od, S_SWITCH_IN_PRE_HAIRPIN, 100, \"ip && ct.trk\",\n            REGBIT_HAIRPIN \" = chk_lb_hairpin(); \"\n            REGBIT_HAIRPIN_REPLY \" = chk_lb_hairpin_reply(); \"\n            \"next;\",\n            &od->nbs->header_);\n\n        /* If packet needs to be hairpinned, snat the src ip with the VIP\n         * for new sessions. */\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_NAT_HAIRPIN, 100,\n                                \"ip && ct.new && ct.trk\"\n                                \" && \"REGBIT_HAIRPIN \" == 1\",\n                                \"ct_snat_to_vip; next;\",\n                                &od->nbs->header_);\n\n        /* If packet needs to be hairpinned, for established sessions there\n         * should already be an SNAT conntrack entry.\n         */\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_NAT_HAIRPIN, 100,\n                                \"ip && ct.est && ct.trk\"\n                                \" && \"REGBIT_HAIRPIN \" == 1\",\n                                \"ct_snat;\",\n                                &od->nbs->header_);\n\n        /* For the reply of hairpinned traffic, snat the src ip to the VIP. */\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_NAT_HAIRPIN, 90,\n                                \"ip && \"REGBIT_HAIRPIN_REPLY \" == 1\",\n                                \"ct_snat;\",\n                                &od->nbs->header_);\n\n        /* Ingress Hairpin table.\n        * - Priority 1: Packets that were SNAT-ed for hairpinning should be\n        *   looped back (i.e., swap ETH addresses and send back on inport).\n        */\n        ovn_lflow_add(\n            lflows, od, S_SWITCH_IN_HAIRPIN, 1,\n            \"(\"REGBIT_HAIRPIN \" == 1 || \" REGBIT_HAIRPIN_REPLY \" == 1)\",\n            \"eth.dst <-> eth.src; outport = inport; flags.loopback = 1; \"\n            \"output;\");\n    }\n}\n\nstatic void\nbuild_vtep_hairpin(struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (!od->has_vtep_lports) {\n        /* There is no need in these flows if datapath has no vtep lports. */\n        return;\n    }\n\n    /* Ingress Pre-ARP flows for VTEP hairpining traffic. Priority 1000:\n     * Packets received from VTEP ports must go directly to L2LKP table.\n     */\n    char *action = xasprintf(\"next(pipeline=ingress, table=%d);\",\n                             ovn_stage_get_table(S_SWITCH_IN_L2_LKUP));\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_HAIRPIN, 1000,\n                  REGBIT_FROM_RAMP\" == 1\", action);\n    free(action);\n\n    /* Ingress pre-arp flow for traffic from VTEP (ramp) switch.\n    * Priority 2000: Packets, that were received from VTEP (ramp) switch and\n    * router ports of current datapath are l3dgw ports and they reside on\n    * current chassis, should be passed to next table for ARP/ND hairpin\n    * processing. */\n    struct ds match = DS_EMPTY_INITIALIZER;\n    for (int i = 0; i < od->n_router_ports; i++) {\n        struct ovn_port *op = od->router_ports[i]->peer;\n        if (is_l3dgw_port(op)) {\n            ds_clear(&match);\n            ds_put_format(&match,\n                          REGBIT_FROM_RAMP\" == 1 && is_chassis_resident(%s)\",\n                          op->cr_port->json_key);\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_HAIRPIN, 2000,\n                          ds_cstr(&match), \"next;\");\n        }\n    }\n    ds_destroy(&match);\n}\n\n/* Build logical flows for the forwarding groups */\nstatic void\nbuild_fwd_group_lflows(struct ovn_datapath *od, struct hmap *lflows)\n{\n\n    if (!(!od->nbs || !od->nbs->n_forwarding_groups)) {\n        struct ds match = DS_EMPTY_INITIALIZER;\n        struct ds actions = DS_EMPTY_INITIALIZER;\n        struct ds group_ports = DS_EMPTY_INITIALIZER;\n\n        for (int i = 0; i < od->nbs->n_forwarding_groups; ++i) {\n            const struct nbrec_forwarding_group *fwd_group = NULL;\n            fwd_group = od->nbs->forwarding_groups[i];\n            if (!fwd_group->n_child_port) {\n                continue;\n            }\n\n            /* ARP responder for the forwarding group's virtual IP */\n            ds_put_format(&match, \"arp.tpa == %s && arp.op == 1\",\n                          fwd_group->vip);\n            ds_put_format(&actions,\n                \"eth.dst = eth.src; \"\n                \"eth.src = %s; \"\n                \"arp.op = 2; /* ARP reply */ \"\n                \"arp.tha = arp.sha; \"\n                \"arp.sha = %s; \"\n                \"arp.tpa = arp.spa; \"\n                \"arp.spa = %s; \"\n                \"outport = inport; \"\n                \"flags.loopback = 1; \"\n                \"output;\",\n                fwd_group->vmac, fwd_group->vmac, fwd_group->vip);\n\n            ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_ARP_ND_RSP, 50,\n                                    ds_cstr(&match), ds_cstr(&actions),\n                                    &fwd_group->header_);\n\n            /* L2 lookup for the forwarding group's virtual MAC */\n            ds_clear(&match);\n            ds_put_format(&match, \"eth.dst == %s\", fwd_group->vmac);\n\n            /* Create a comma separated string of child ports */\n            ds_clear(&group_ports);\n            if (fwd_group->liveness) {\n                ds_put_cstr(&group_ports, \"liveness=\\\"true\\\",\");\n            }\n            ds_put_cstr(&group_ports, \"childports=\");\n            for (i = 0; i < (fwd_group->n_child_port - 1); ++i) {\n                ds_put_format(&group_ports, \"\\\"%s\\\",\",\n                             fwd_group->child_port[i]);\n            }\n            ds_put_format(&group_ports, \"\\\"%s\\\"\",\n                          fwd_group->child_port[fwd_group->n_child_port - 1]);\n\n            ds_clear(&actions);\n            ds_put_format(&actions, \"fwd_group(%s);\", ds_cstr(&group_ports));\n            ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_L2_LKUP, 50,\n                                    ds_cstr(&match), ds_cstr(&actions),\n                                    &fwd_group->header_);\n        }\n\n        ds_destroy(&match);\n        ds_destroy(&actions);\n        ds_destroy(&group_ports);\n    }\n}\n\nstatic void\nbuild_lrouter_groups__(struct hmap *ports, struct ovn_datapath *od)\n{\n    ovs_assert((od && od->nbr && od->lr_group));\n\n    /* For logical router with distributed gateway ports. If it\n     * has HA_Chassis_Group associated to it in SB DB, then store the\n     * ha chassis group name. */\n    for (size_t i = 0; i < od->n_l3dgw_ports; i++) {\n        struct ovn_port *crp = od->l3dgw_ports[i]->cr_port;\n        if (crp->sb->ha_chassis_group &&\n            crp->sb->ha_chassis_group->n_ha_chassis > 1) {\n            sset_add(&od->lr_group->ha_chassis_groups,\n                     crp->sb->ha_chassis_group->name);\n        }\n    }\n\n    for (size_t i = 0; i < od->nbr->n_ports; i++) {\n        struct ovn_port *router_port =\n            ovn_port_find(ports, od->nbr->ports[i]->name);\n\n        if (!router_port || !router_port->peer) {\n            continue;\n        }\n\n        /* Get the peer logical switch/logical router datapath. */\n        struct ovn_datapath *peer_dp = router_port->peer->od;\n        if (peer_dp->nbr) {\n            if (!peer_dp->lr_group) {\n                peer_dp->lr_group = od->lr_group;\n                od->lr_group->router_dps[od->lr_group->n_router_dps++]\n                    = peer_dp;\n                build_lrouter_groups__(ports, peer_dp);\n            }\n        } else {\n            for (size_t j = 0; j < peer_dp->n_router_ports; j++) {\n                if (!peer_dp->router_ports[j]->peer) {\n                    /* If there is no peer port connecting to the\n                    * router port, ignore it. */\n                    continue;\n                }\n\n                struct ovn_datapath *router_dp;\n                router_dp = peer_dp->router_ports[j]->peer->od;\n                if (router_dp == od) {\n                    continue;\n                }\n\n                if (router_dp->lr_group == od->lr_group) {\n                    /* 'router_dp' and 'od' already belong to the same\n                    * lrouter group. Nothing to be done. */\n                    continue;\n                }\n\n                router_dp->lr_group = od->lr_group;\n                od->lr_group->router_dps[od->lr_group->n_router_dps++]\n                    = router_dp;\n                build_lrouter_groups__(ports, router_dp);\n            }\n        }\n    }\n}\n\n/* Adds each logical router into a logical router group. All the\n * logical routers which belong to a group are connected to\n * each other either directly or indirectly (via transit logical switches\n * in between).\n *\n * Suppose if 'lr_list' has lr0, lr1, lr2, lr3, lr4, lr5\n * and the topology is like\n *  sw0 <-> lr0 <-> sw1 <-> lr1 <->sw2 <-> lr2\n *  sw3 <-> lr3 <-> lr4 <-> sw5\n *  sw6 <-> lr5 <-> sw7\n * Then 3 groups are created.\n * Group 1 -> lr0, lr1 and lr2\n *            lr0, lr1 and lr2's ovn_datapath->lr_group will point to this\n *            group. This means sw0's logical ports can send packets to sw2's\n *            logical ports if proper static route's are added.\n * Group 2 -> lr3 and lr4\n *            lr3 and lr4's ovn_datapath->lr_group will point to this group.\n * Group 3 -> lr5\n *\n * Each logical router can belong to only one group.\n */\nstatic void\nbuild_lrouter_groups(struct hmap *ports, struct ovs_list *lr_list)\n{\n    struct ovn_datapath *od;\n    size_t n_router_dps = ovs_list_size(lr_list);\n\n    LIST_FOR_EACH (od, lr_list, lr_list) {\n        if (!od->lr_group) {\n            od->lr_group = xzalloc(sizeof *od->lr_group);\n            /* Each logical router group can have max\n             * 'n_router_dps'. So allocate enough memory. */\n            od->lr_group->router_dps =\n                xcalloc(n_router_dps, sizeof *od->lr_group->router_dps);\n            od->lr_group->router_dps[0] = od;\n            od->lr_group->n_router_dps = 1;\n            sset_init(&od->lr_group->ha_chassis_groups);\n            hmapx_init(&od->lr_group->tmp_ha_chassis);\n            build_lrouter_groups__(ports, od);\n        }\n    }\n}\n\n/*\n * Ingress table 25: Flows that flood self originated ARP/RARP/ND packets in\n * the switching domain.\n */\nstatic void\nbuild_lswitch_rport_arp_req_self_orig_flow(struct ovn_port *op,\n                                           uint32_t priority,\n                                           struct ovn_datapath *od,\n                                           struct hmap *lflows)\n{\n    struct sset all_eth_addrs = SSET_INITIALIZER(&all_eth_addrs);\n    struct ds eth_src = DS_EMPTY_INITIALIZER;\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    sset_add(&all_eth_addrs, op->lrp_networks.ea_s);\n\n    for (size_t i = 0; i < op->od->nbr->n_nat; i++) {\n        struct ovn_nat *nat_entry = &op->od->nat_entries[i];\n        const struct nbrec_nat *nat = nat_entry->nb;\n\n        if (!nat_entry_is_valid(nat_entry)) {\n            continue;\n        }\n\n        if (!strcmp(nat->type, \"snat\")) {\n            continue;\n        }\n\n        if (!nat->external_mac) {\n            continue;\n        }\n        sset_add(&all_eth_addrs, nat->external_mac);\n    }\n\n    /* Self originated ARP requests/RARP/ND need to be flooded to the L2 domain\n     * (except on router ports).  Determine that packets are self originated\n     * by also matching on source MAC. Matching on ingress port is not\n     * reliable in case this is a VLAN-backed network.\n     * Priority: 75.\n     */\n    const char *eth_addr;\n\n    ds_put_cstr(&eth_src, \"{\");\n    SSET_FOR_EACH (eth_addr, &all_eth_addrs) {\n        ds_put_format(&eth_src, \"%s, \", eth_addr);\n    }\n    ds_chomp(&eth_src, ' ');\n    ds_chomp(&eth_src, ',');\n    ds_put_cstr(&eth_src, \"}\");\n\n    ds_put_format(&match,\n                  \"eth.src == %s && (arp.op == 1 || rarp.op == 3 || nd_ns)\",\n                  ds_cstr(&eth_src));\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, priority, ds_cstr(&match),\n                  \"outport = \\\"\"MC_FLOOD_L2\"\\\"; output;\");\n\n    sset_destroy(&all_eth_addrs);\n    ds_destroy(&eth_src);\n    ds_destroy(&match);\n}\n\nstatic void\narp_nd_ns_match(const char *ips, int addr_family, struct ds *match)\n{\n    /* Packets received from VXLAN tunnels have already been through the\n     * router pipeline so we should skip them. Normally this is done by the\n     * multicast_group implementation (VXLAN packets skip table 32 which\n     * delivers to patch ports) but we're bypassing multicast_groups.\n     */\n    ds_put_cstr(match, FLAGBIT_NOT_VXLAN \" && \");\n\n    if (addr_family == AF_INET) {\n        ds_put_format(match, \"arp.op == 1 && arp.tpa == %s\", ips);\n    } else {\n        ds_put_format(match, \"nd_ns && nd.target == %s\", ips);\n    }\n}\n\n/* Returns 'true' if the IPv4 'addr' is on the same subnet with one of the\n * IPs configured on the router port.\n */\nstatic bool\nlrouter_port_ipv4_reachable(const struct ovn_port *op, ovs_be32 addr)\n{\n    for (size_t i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n        struct ipv4_netaddr *op_addr = &op->lrp_networks.ipv4_addrs[i];\n\n        if ((addr & op_addr->mask) == op_addr->network) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Returns 'true' if the IPv6 'addr' is on the same subnet with one of the\n * IPs configured on the router port.\n */\nstatic bool\nlrouter_port_ipv6_reachable(const struct ovn_port *op,\n                            const struct in6_addr *addr)\n{\n    for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n        struct ipv6_netaddr *op_addr = &op->lrp_networks.ipv6_addrs[i];\n\n        struct in6_addr nat_addr6_masked =\n            ipv6_addr_bitand(addr, &op_addr->mask);\n\n        if (ipv6_addr_equals(&nat_addr6_masked, &op_addr->network)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/*\n * Ingress table 25: Flows that forward ARP/ND requests only to the routers\n * that own the addresses. Other ARP/ND packets are still flooded in the\n * switching domain as regular broadcast.\n */\nstatic void\nbuild_lswitch_rport_arp_req_flow(const char *ips,\n    int addr_family, struct ovn_port *patch_op, struct ovn_datapath *od,\n    uint32_t priority, struct hmap *lflows,\n    const struct ovsdb_idl_row *stage_hint)\n{\n    struct ds match   = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    arp_nd_ns_match(ips, addr_family, &match);\n\n    /* Send a the packet to the router pipeline.  If the switch has non-router\n     * ports then flood it there as well.\n     */\n    if (od->n_router_ports != od->nbs->n_ports) {\n        ds_put_format(&actions, \"clone {outport = %s; output; }; \"\n                                \"outport = \\\"\"MC_FLOOD_L2\"\\\"; output;\",\n                      patch_op->json_key);\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_L2_LKUP,\n                                priority, ds_cstr(&match),\n                                ds_cstr(&actions), stage_hint);\n    } else {\n        ds_put_format(&actions, \"outport = %s; output;\", patch_op->json_key);\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_L2_LKUP, priority,\n                                ds_cstr(&match), ds_cstr(&actions),\n                                stage_hint);\n    }\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\n/*\n * Ingress table 25: Flows that forward ARP/ND requests only to the routers\n * that own the addresses.\n * Priorities:\n * - 80: self originated GARPs that need to follow regular processing.\n * - 75: ARP requests to router owned IPs (interface IP/LB/NAT).\n */\nstatic void\nbuild_lswitch_rport_arp_req_flows(struct ovn_port *op,\n                                  struct ovn_datapath *sw_od,\n                                  struct ovn_port *sw_op,\n                                  struct hmap *lflows,\n                                  const struct ovsdb_idl_row *stage_hint)\n{\n    if (!op || !op->nbrp) {\n        return;\n    }\n\n    if (!lrport_is_enabled(op->nbrp)) {\n        return;\n    }\n\n    /* Forward ARP requests for owned IP addresses (L3, VIP, NAT) only to this\n     * router port.\n     * Priority: 80.\n     */\n\n    const char *ip_addr;\n    SSET_FOR_EACH (ip_addr, &op->od->lb_ips->ips_v4) {\n        ovs_be32 ipv4_addr;\n\n        /* Check if the ovn port has a network configured on which we could\n         * expect ARP requests for the LB VIP.\n         */\n        if (ip_parse(ip_addr, &ipv4_addr) &&\n            lrouter_port_ipv4_reachable(op, ipv4_addr)) {\n            build_lswitch_rport_arp_req_flow(\n                ip_addr, AF_INET, sw_op, sw_od, 80, lflows,\n                stage_hint);\n        }\n    }\n    SSET_FOR_EACH (ip_addr, &op->od->lb_ips->ips_v6) {\n        struct in6_addr ipv6_addr;\n\n        /* Check if the ovn port has a network configured on which we could\n         * expect NS requests for the LB VIP.\n         */\n        if (ipv6_parse(ip_addr, &ipv6_addr) &&\n            lrouter_port_ipv6_reachable(op, &ipv6_addr)) {\n            build_lswitch_rport_arp_req_flow(\n                ip_addr, AF_INET6, sw_op, sw_od, 80, lflows,\n                stage_hint);\n        }\n    }\n\n    for (size_t i = 0; i < op->od->nbr->n_nat; i++) {\n        struct ovn_nat *nat_entry = &op->od->nat_entries[i];\n        const struct nbrec_nat *nat = nat_entry->nb;\n\n        if (!nat_entry_is_valid(nat_entry)) {\n            continue;\n        }\n\n        if (!strcmp(nat->type, \"snat\")) {\n            continue;\n        }\n\n        /* Check if the ovn port has a network configured on which we could\n         * expect ARP requests/NS for the DNAT external_ip.\n         */\n        if (nat_entry_is_v6(nat_entry)) {\n            if (!sset_contains(&op->od->lb_ips->ips_v6, nat->external_ip)) {\n                build_lswitch_rport_arp_req_flow(\n                    nat->external_ip, AF_INET6, sw_op, sw_od, 80, lflows,\n                    stage_hint);\n            }\n        } else {\n            if (!sset_contains(&op->od->lb_ips->ips_v4, nat->external_ip)) {\n                build_lswitch_rport_arp_req_flow(\n                    nat->external_ip, AF_INET, sw_op, sw_od, 80, lflows,\n                    stage_hint);\n            }\n        }\n    }\n\n    for (size_t i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n        build_lswitch_rport_arp_req_flow(\n            op->lrp_networks.ipv4_addrs[i].addr_s, AF_INET, sw_op, sw_od, 80,\n            lflows, stage_hint);\n    }\n    for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n        build_lswitch_rport_arp_req_flow(\n            op->lrp_networks.ipv6_addrs[i].addr_s, AF_INET6, sw_op, sw_od, 80,\n            lflows, stage_hint);\n    }\n\n    /* Self originated ARP requests/RARP/ND need to be flooded as usual.\n     *\n     * However, if the switch doesn't have any non-router ports we shouldn't\n     * even try to flood.\n     *\n     * Priority: 75.\n     */\n    if (sw_od->n_router_ports != sw_od->nbs->n_ports) {\n        build_lswitch_rport_arp_req_self_orig_flow(op, 75, sw_od, lflows);\n    }\n}\n\nstatic void\nbuild_dhcpv4_options_flows(struct ovn_port *op,\n                           struct lport_addresses *lsp_addrs,\n                           struct ovn_port *inport, bool is_external,\n                           const struct shash *meter_groups,\n                           struct hmap *lflows)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    for (size_t j = 0; j < lsp_addrs->n_ipv4_addrs; j++) {\n        struct ds options_action = DS_EMPTY_INITIALIZER;\n        struct ds response_action = DS_EMPTY_INITIALIZER;\n        struct ds ipv4_addr_match = DS_EMPTY_INITIALIZER;\n        if (build_dhcpv4_action(\n                op, lsp_addrs->ipv4_addrs[j].addr,\n                &options_action, &response_action, &ipv4_addr_match)) {\n            ds_clear(&match);\n            ds_put_format(\n                &match, \"inport == %s && eth.src == %s && \"\n                \"ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && \"\n                \"udp.src == 68 && udp.dst == 67\",\n                inport->json_key, lsp_addrs->ea_s);\n\n            if (is_external) {\n                ds_put_format(&match, \" && is_chassis_resident(%s)\",\n                              op->json_key);\n            }\n\n            ovn_lflow_add_with_hint__(lflows, op->od,\n                                      S_SWITCH_IN_DHCP_OPTIONS, 100,\n                                      ds_cstr(&match),\n                                      ds_cstr(&options_action),\n                                      inport->key,\n                                      copp_meter_get(COPP_DHCPV4_OPTS,\n                                                     op->od->nbs->copp,\n                                                     meter_groups),\n                                      &op->nbsp->dhcpv4_options->header_);\n            ds_clear(&match);\n            /* Allow ip4.src = OFFER_IP and\n             * ip4.dst = {SERVER_IP, 255.255.255.255} for the below\n             * cases\n             *  -  When the client wants to renew the IP by sending\n             *     the DHCPREQUEST to the server ip.\n             *  -  When the client wants to renew the IP by\n             *     broadcasting the DHCPREQUEST.\n             */\n            ds_put_format(\n                &match, \"inport == %s && eth.src == %s && \"\n                \"%s && udp.src == 68 && udp.dst == 67\",\n                inport->json_key, lsp_addrs->ea_s, ds_cstr(&ipv4_addr_match));\n\n            if (is_external) {\n                ds_put_format(&match, \" && is_chassis_resident(%s)\",\n                              op->json_key);\n            }\n\n            ovn_lflow_add_with_hint__(lflows, op->od,\n                                      S_SWITCH_IN_DHCP_OPTIONS, 100,\n                                      ds_cstr(&match),\n                                      ds_cstr(&options_action),\n                                      inport->key,\n                                      copp_meter_get(COPP_DHCPV4_OPTS,\n                                                     op->od->nbs->copp,\n                                                     meter_groups),\n                                      &op->nbsp->dhcpv4_options->header_);\n            ds_clear(&match);\n\n            /* If REGBIT_DHCP_OPTS_RESULT is set, it means the\n             * put_dhcp_opts action is successful. */\n            ds_put_format(\n                &match, \"inport == %s && eth.src == %s && \"\n                \"ip4 && udp.src == 68 && udp.dst == 67\"\n                \" && \"REGBIT_DHCP_OPTS_RESULT,\n                inport->json_key, lsp_addrs->ea_s);\n\n            if (is_external) {\n                ds_put_format(&match, \" && is_chassis_resident(%s)\",\n                              op->json_key);\n            }\n\n            ovn_lflow_add_with_lport_and_hint(\n                lflows, op->od, S_SWITCH_IN_DHCP_RESPONSE, 100,\n                ds_cstr(&match), ds_cstr(&response_action), inport->key,\n                &op->nbsp->dhcpv4_options->header_);\n            ds_destroy(&options_action);\n            ds_destroy(&response_action);\n            ds_destroy(&ipv4_addr_match);\n            break;\n        }\n    }\n    ds_destroy(&match);\n}\n\nstatic void\nbuild_dhcpv6_options_flows(struct ovn_port *op,\n                           struct lport_addresses *lsp_addrs,\n                           struct ovn_port *inport, bool is_external,\n                           const struct shash *meter_groups,\n                           struct hmap *lflows)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    for (size_t j = 0; j < lsp_addrs->n_ipv6_addrs; j++) {\n        struct ds options_action = DS_EMPTY_INITIALIZER;\n        struct ds response_action = DS_EMPTY_INITIALIZER;\n        if (build_dhcpv6_action(\n                op, &lsp_addrs->ipv6_addrs[j].addr,\n                &options_action, &response_action)) {\n            ds_clear(&match);\n            ds_put_format(\n                &match, \"inport == %s && eth.src == %s\"\n                \" && ip6.dst == ff02::1:2 && udp.src == 546 &&\"\n                \" udp.dst == 547\",\n                inport->json_key, lsp_addrs->ea_s);\n\n            if (is_external) {\n                ds_put_format(&match, \" && is_chassis_resident(%s)\",\n                              op->json_key);\n            }\n\n            ovn_lflow_add_with_hint__(lflows, op->od,\n                                      S_SWITCH_IN_DHCP_OPTIONS, 100,\n                                      ds_cstr(&match),\n                                      ds_cstr(&options_action),\n                                      inport->key,\n                                      copp_meter_get(COPP_DHCPV6_OPTS,\n                                                     op->od->nbs->copp,\n                                                     meter_groups),\n                                      &op->nbsp->dhcpv6_options->header_);\n\n            /* If REGBIT_DHCP_OPTS_RESULT is set to 1, it means the\n             * put_dhcpv6_opts action is successful */\n            ds_put_cstr(&match, \" && \"REGBIT_DHCP_OPTS_RESULT);\n            ovn_lflow_add_with_lport_and_hint(\n                lflows, op->od, S_SWITCH_IN_DHCP_RESPONSE, 100,\n                ds_cstr(&match), ds_cstr(&response_action), inport->key,\n                &op->nbsp->dhcpv6_options->header_);\n            ds_destroy(&options_action);\n            ds_destroy(&response_action);\n            break;\n        }\n    }\n    ds_destroy(&match);\n}\n\nstatic void\nbuild_drop_arp_nd_flows_for_unbound_router_ports(struct ovn_port *op,\n                                                 const struct ovn_port *port,\n                                                 struct hmap *lflows)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    for (size_t i = 0; i < op->n_lsp_addrs; i++) {\n        for (size_t j = 0; j < op->od->n_router_ports; j++) {\n            struct ovn_port *rp = op->od->router_ports[j];\n            for (size_t k = 0; k < rp->n_lsp_addrs; k++) {\n                for (size_t l = 0; l < rp->lsp_addrs[k].n_ipv4_addrs; l++) {\n                    ds_clear(&match);\n                    ds_put_format(\n                        &match, \"inport == %s && eth.src == %s\"\n                        \" && !is_chassis_resident(%s)\"\n                        \" && arp.tpa == %s && arp.op == 1\",\n                        port->json_key,\n                        op->lsp_addrs[i].ea_s, op->json_key,\n                        rp->lsp_addrs[k].ipv4_addrs[l].addr_s);\n                    ovn_lflow_add_with_lport_and_hint(\n                        lflows, op->od, S_SWITCH_IN_EXTERNAL_PORT, 100,\n                        ds_cstr(&match),  debug_drop_action(), port->key,\n                        &op->nbsp->header_);\n                }\n                for (size_t l = 0; l < rp->lsp_addrs[k].n_ipv6_addrs; l++) {\n                    ds_clear(&match);\n                    ds_put_format(\n                        &match, \"inport == %s && eth.src == %s\"\n                        \" && !is_chassis_resident(%s)\"\n                        \" && nd_ns && ip6.dst == {%s, %s} && nd.target == %s\",\n                        port->json_key,\n                        op->lsp_addrs[i].ea_s, op->json_key,\n                        rp->lsp_addrs[k].ipv6_addrs[l].addr_s,\n                        rp->lsp_addrs[k].ipv6_addrs[l].sn_addr_s,\n                        rp->lsp_addrs[k].ipv6_addrs[l].addr_s);\n                    ovn_lflow_add_with_lport_and_hint(\n                        lflows, op->od, S_SWITCH_IN_EXTERNAL_PORT, 100,\n                        ds_cstr(&match), debug_drop_action(), port->key,\n                        &op->nbsp->header_);\n                }\n\n                ds_clear(&match);\n                ds_put_format(\n                    &match, \"inport == %s && eth.src == %s\"\n                    \" && eth.dst == %s\"\n                    \" && !is_chassis_resident(%s)\",\n                    port->json_key,\n                    op->lsp_addrs[i].ea_s, rp->lsp_addrs[k].ea_s,\n                    op->json_key);\n                ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                                  S_SWITCH_IN_EXTERNAL_PORT,\n                                                  100, ds_cstr(&match),\n                                                  debug_drop_action(),\n                                                  port->key,\n                                                  &op->nbsp->header_);\n            }\n        }\n    }\n    ds_destroy(&match);\n}\n\nstatic bool\nis_vlan_transparent(const struct ovn_datapath *od)\n{\n    return smap_get_bool(&od->nbs->other_config, \"vlan-passthru\", false);\n}\n\nstatic void\nbuild_lswitch_flows(const struct hmap *datapaths,\n                    struct hmap *lflows)\n{\n    /* This flow table structure is documented in ovn-northd(8), so please\n     * update ovn-northd.8.xml if you change anything. */\n\n    struct ovn_datapath *od;\n\n    /* Ingress table 25/26: Destination lookup for unknown MACs\n     * (priority 0). */\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs) {\n            continue;\n        }\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 0, \"1\",\n                      \"outport = get_fdb(eth.dst); next;\");\n\n        if (od->has_unknown) {\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_UNKNOWN, 50,\n                          \"outport == \\\"none\\\"\",\n                          \"outport = \\\"\"MC_UNKNOWN \"\\\"; output;\");\n        } else {\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_UNKNOWN, 50,\n                          \"outport == \\\"none\\\"\",  debug_drop_action());\n        }\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_UNKNOWN, 0, \"1\",\n                      \"output;\");\n    }\n\n}\n\n/* Build pre-ACL and ACL tables for both ingress and egress.\n * Ingress tables 3 through 10.  Egress tables 0 through 7. */\nstatic void\nbuild_lswitch_lflows_pre_acl_and_acl(struct ovn_datapath *od,\n                                     const struct hmap *port_groups,\n                                     const struct chassis_features *features,\n                                     struct hmap *lflows,\n                                     const struct shash *meter_groups)\n{\n    if (od->nbs) {\n        ls_get_acl_flags(od);\n\n        build_pre_acls(od, port_groups, lflows);\n        build_pre_lb(od, meter_groups, lflows);\n        build_pre_stateful(od, features, lflows);\n        build_acl_hints(od, features, lflows);\n        build_acls(od, features, lflows, port_groups, meter_groups);\n        build_qos(od, lflows);\n        build_stateful(od, features, lflows);\n        build_lb_hairpin(od, lflows);\n        build_vtep_hairpin(od, lflows);\n    }\n}\n\n/* Logical switch ingress table 0: Admission control framework (priority\n * 100). */\nstatic void\nbuild_lswitch_lflows_admission_control(struct ovn_datapath *od,\n                                       struct hmap *lflows)\n{\n    if (od->nbs) {\n        /* Logical VLANs not supported. */\n        if (!is_vlan_transparent(od)) {\n            /* Block logical VLANs. */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_CHECK_PORT_SEC, 100,\n                          \"vlan.present\", debug_drop_action());\n        }\n\n        /* Broadcast/multicast source address is invalid. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_CHECK_PORT_SEC, 100,\n                      \"eth.src[40]\", debug_drop_action());\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_CHECK_PORT_SEC, 50, \"1\",\n                      REGBIT_PORT_SEC_DROP\" = check_in_port_sec(); next;\");\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_APPLY_PORT_SEC, 50,\n                      REGBIT_PORT_SEC_DROP\" == 1\", debug_drop_action());\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_APPLY_PORT_SEC, 0, \"1\", \"next;\");\n    }\n}\n\n/* Ingress table 19: ARP/ND responder, skip requests coming from localnet\n * ports. (priority 100); see ovn-northd.8.xml for the rationale. */\n\nstatic void\nbuild_lswitch_arp_nd_responder_skip_local(struct ovn_port *op,\n                                          struct hmap *lflows,\n                                          struct ds *match)\n{\n    if (op->nbsp && lsp_is_localnet(op->nbsp)) {\n        ds_clear(match);\n        ds_put_format(match, \"inport == %s\", op->json_key);\n        ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                          S_SWITCH_IN_ARP_ND_RSP, 100,\n                                          ds_cstr(match), \"next;\", op->key,\n                                          &op->nbsp->header_);\n    }\n}\n\n/* Ingress table 19: ARP/ND responder, reply for known IPs.\n * (priority 50). */\nstatic void\nbuild_lswitch_arp_nd_responder_known_ips(struct ovn_port *op,\n                                         struct hmap *lflows,\n                                         const struct hmap *ports,\n                                         const struct shash *meter_groups,\n                                         struct ds *actions,\n                                         struct ds *match)\n{\n    if (op->nbsp) {\n        if (!strcmp(op->nbsp->type, \"virtual\")) {\n            /* Handle\n             *  - GARPs for virtual ip which belongs to a logical port\n             *    of type 'virtual' and bind that port.\n             *\n             *  - ARP reply from the virtual ip which belongs to a logical\n             *    port of type 'virtual' and bind that port.\n             *\n             *  - IPv6 Neighbor Solicitations requests that targets virtual\n             *    ip which belongs to a logical port of type 'virtual' and\n             *    bind that port.\n             *\n             *  - IPv6 unsolicited Neighbor Advertisements that targets\n             *    ip which belongs to a logical port of type 'virtual'\n             *    and bind that port.\n             * */\n            struct in6_addr ip;\n\n            const char *virtual_ip = smap_get(&op->nbsp->options,\n                                              \"virtual-ip\");\n            const char *virtual_parents = smap_get(&op->nbsp->options,\n                                                   \"virtual-parents\");\n            if (!virtual_ip || !virtual_parents) {\n                return;\n            }\n\n            bool is_ipv4 = strchr(virtual_ip, '.') ? true : false;\n            if (is_ipv4) {\n                ovs_be32 ipv4;\n                if (!ip_parse(virtual_ip, &ipv4)) {\n                     return;\n                }\n            } else {\n                if (!ipv6_parse(virtual_ip, &ip)) {\n                     return;\n                }\n            }\n\n            char *tokstr = xstrdup(virtual_parents);\n            char *save_ptr = NULL;\n            char *vparent;\n            for (vparent = strtok_r(tokstr, \",\", &save_ptr); vparent != NULL;\n                 vparent = strtok_r(NULL, \",\", &save_ptr)) {\n                struct ovn_port *vp = ovn_port_find(ports, vparent);\n                if (!vp || vp->od != op->od) {\n                    /* vparent name should be valid and it should belong\n                     * to the same logical switch. */\n                    continue;\n                }\n\n                if (is_ipv4) {\n                    ds_clear(match);\n                    ds_put_format(match, \"inport == \\\"%s\\\" && \"\n                            \"((arp.op == 1 && arp.spa == %s && \"\n                            \"arp.tpa == %s) || (arp.op == 2 && \"\n                            \"arp.spa == %s))\",\n                            vparent, virtual_ip, virtual_ip,\n                            virtual_ip);\n                } else {\n                    struct ipv6_netaddr na;\n                    /* Find VIP multicast group */\n                    in6_addr_solicited_node(&na.sn_addr, &ip);\n                    inet_ntop(AF_INET6, &na.sn_addr, na.sn_addr_s,\n                              sizeof na.sn_addr_s);\n\n                    ds_clear(match);\n                    ds_put_format(match, \"inport == \\\"%s\\\" && \"\n                            \"((nd_ns && ip6.dst == {%s, %s} && \"\n                            \"nd.target == %s) ||\"\n                            \"(nd_na && nd.target == %s))\",\n                            vparent,\n                            virtual_ip,\n                            na.sn_addr_s,\n                            virtual_ip,\n                            virtual_ip);\n                }\n\n                ds_clear(actions);\n                ds_put_format(actions,\n                    \"bind_vport(%s, inport); \"\n                    \"next;\",\n                    op->json_key);\n                ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                                  S_SWITCH_IN_ARP_ND_RSP, 100,\n                                                  ds_cstr(match),\n                                                  ds_cstr(actions), vparent,\n                                                  &vp->nbsp->header_);\n            }\n\n            free(tokstr);\n        } else {\n            /*\n             * Add ARP/ND reply flows if either the\n             *  - port is up and it doesn't have 'unknown' address defined or\n             *  - port type is router or\n             *  - port type is localport\n             */\n            if (check_lsp_is_up &&\n                !lsp_is_up(op->nbsp) && !lsp_is_router(op->nbsp) &&\n                strcmp(op->nbsp->type, \"localport\")) {\n                return;\n            }\n\n            if (lsp_is_external(op->nbsp) || op->has_unknown) {\n                return;\n            }\n\n            if (is_vlan_transparent(op->od)) {\n                return;\n            }\n\n            for (size_t i = 0; i < op->n_lsp_addrs; i++) {\n                for (size_t j = 0; j < op->lsp_addrs[i].n_ipv4_addrs; j++) {\n                    ds_clear(match);\n                    ds_put_format(match, \"arp.tpa == %s && arp.op == 1\",\n                                op->lsp_addrs[i].ipv4_addrs[j].addr_s);\n                    ds_clear(actions);\n                    ds_put_format(actions,\n                        \"eth.dst = eth.src; \"\n                        \"eth.src = %s; \"\n                        \"arp.op = 2; /* ARP reply */ \"\n                        \"arp.tha = arp.sha; \"\n                        \"arp.sha = %s; \"\n                        \"arp.tpa = arp.spa; \"\n                        \"arp.spa = %s; \"\n                        \"outport = inport; \"\n                        \"flags.loopback = 1; \"\n                        \"output;\",\n                        op->lsp_addrs[i].ea_s, op->lsp_addrs[i].ea_s,\n                        op->lsp_addrs[i].ipv4_addrs[j].addr_s);\n                    ovn_lflow_add_with_hint(lflows, op->od,\n                                            S_SWITCH_IN_ARP_ND_RSP, 50,\n                                            ds_cstr(match),\n                                            ds_cstr(actions),\n                                            &op->nbsp->header_);\n\n                    /* Do not reply to an ARP request from the port that owns\n                     * the address (otherwise a DHCP client that ARPs to check\n                     * for a duplicate address will fail).  Instead, forward\n                     * it the usual way.\n                     *\n                     * (Another alternative would be to simply drop the packet.\n                     * If everything is working as it is configured, then this\n                     * would produce equivalent results, since no one should\n                     * reply to the request.  But ARPing for one's own IP\n                     * address is intended to detect situations where the\n                     * network is not working as configured, so dropping the\n                     * request would frustrate that intent.) */\n                    ds_put_format(match, \" && inport == %s\", op->json_key);\n                    ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                                      S_SWITCH_IN_ARP_ND_RSP,\n                                                      100, ds_cstr(match),\n                                                      \"next;\", op->key,\n                                                      &op->nbsp->header_);\n                }\n\n                /* For ND solicitations, we need to listen for both the\n                 * unicast IPv6 address and its all-nodes multicast address,\n                 * but always respond with the unicast IPv6 address. */\n                for (size_t j = 0; j < op->lsp_addrs[i].n_ipv6_addrs; j++) {\n                    ds_clear(match);\n                    ds_put_format(match,\n                            \"nd_ns && ip6.dst == {%s, %s} && nd.target == %s\",\n                            op->lsp_addrs[i].ipv6_addrs[j].addr_s,\n                            op->lsp_addrs[i].ipv6_addrs[j].sn_addr_s,\n                            op->lsp_addrs[i].ipv6_addrs[j].addr_s);\n\n                    ds_clear(actions);\n                    ds_put_format(actions,\n                            \"%s { \"\n                            \"eth.src = %s; \"\n                            \"ip6.src = %s; \"\n                            \"nd.target = %s; \"\n                            \"nd.tll = %s; \"\n                            \"outport = inport; \"\n                            \"flags.loopback = 1; \"\n                            \"output; \"\n                            \"};\",\n                            lsp_is_router(op->nbsp) ? \"nd_na_router\" : \"nd_na\",\n                            op->lsp_addrs[i].ea_s,\n                            op->lsp_addrs[i].ipv6_addrs[j].addr_s,\n                            op->lsp_addrs[i].ipv6_addrs[j].addr_s,\n                            op->lsp_addrs[i].ea_s);\n                    ovn_lflow_add_with_hint__(lflows, op->od,\n                                              S_SWITCH_IN_ARP_ND_RSP, 50,\n                                              ds_cstr(match),\n                                              ds_cstr(actions),\n                                              NULL,\n                                              copp_meter_get(COPP_ND_NA,\n                                                  op->od->nbs->copp,\n                                                  meter_groups),\n                                              &op->nbsp->header_);\n\n                    /* Do not reply to a solicitation from the port that owns\n                     * the address (otherwise DAD detection will fail). */\n                    ds_put_format(match, \" && inport == %s\", op->json_key);\n                    ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                                      S_SWITCH_IN_ARP_ND_RSP,\n                                                      100, ds_cstr(match),\n                                                      \"next;\", op->key,\n                                                      &op->nbsp->header_);\n                }\n            }\n        }\n\n        if (op->peer) {\n            const char *arp_proxy = smap_get(&op->nbsp->options,\"arp_proxy\");\n\n            struct lport_addresses proxy_arp_addrs;\n            int i = 0;\n\n            /* Add responses for ARP proxies. */\n            if (arp_proxy && extract_ip_addresses(arp_proxy,\n                                                  &proxy_arp_addrs) &&\n                proxy_arp_addrs.n_ipv4_addrs) {\n                /* Match rule on all proxy ARP IPs. */\n                ds_clear(match);\n                ds_put_cstr(match, \"arp.op == 1 && arp.tpa == {\");\n\n                for (i = 0; i < proxy_arp_addrs.n_ipv4_addrs; i++) {\n                    ds_put_format(match, \"%s,\",\n                                  proxy_arp_addrs.ipv4_addrs[i].addr_s);\n                }\n\n                ds_chomp(match, ',');\n                ds_put_cstr(match, \"}\");\n                destroy_lport_addresses(&proxy_arp_addrs);\n\n                ds_clear(actions);\n                ds_put_format(actions,\n                    \"eth.dst = eth.src; \"\n                    \"eth.src = %s; \"\n                    \"arp.op = 2; /* ARP reply */ \"\n                    \"arp.tha = arp.sha; \"\n                    \"arp.sha = %s; \"\n                    \"arp.tpa <-> arp.spa; \"\n                    \"outport = inport; \"\n                    \"flags.loopback = 1; \"\n                    \"output;\",\n                    op->peer->lrp_networks.ea_s,\n                    op->peer->lrp_networks.ea_s);\n\n                ovn_lflow_add_with_hint(lflows, op->od, S_SWITCH_IN_ARP_ND_RSP,\n                    50, ds_cstr(match), ds_cstr(actions), &op->nbsp->header_);\n            }\n        }\n    }\n}\n\n/* Ingress table 19: ARP/ND responder, by default goto next.\n * (priority 0)*/\nstatic void\nbuild_lswitch_arp_nd_responder_default(struct ovn_datapath *od,\n                                       struct hmap *lflows)\n{\n    if (od->nbs) {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ARP_ND_RSP, 0, \"1\", \"next;\");\n    }\n}\n\n/* Ingress table 19: ARP/ND responder for service monitor source ip.\n * (priority 110)*/\nstatic void\nbuild_lswitch_arp_nd_service_monitor(struct ovn_northd_lb *lb,\n                                     struct hmap *lflows,\n                                     struct ds *actions,\n                                     struct ds *match)\n{\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_northd_lb_vip *lb_vip_nb = &lb->vips_nb[i];\n        if (!lb_vip_nb->lb_health_check) {\n            continue;\n        }\n\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n        for (size_t j = 0; j < lb_vip_nb->n_backends; j++) {\n            struct ovn_northd_lb_backend *backend_nb =\n                &lb_vip_nb->backends_nb[j];\n            if (!backend_nb->op || !backend_nb->svc_mon_src_ip) {\n                continue;\n            }\n\n            ds_clear(match);\n            ds_clear(actions);\n            if (IN6_IS_ADDR_V4MAPPED(&lb_vip->vip)) {\n                ds_put_format(match, \"arp.tpa == %s && arp.op == 1\",\n                              backend_nb->svc_mon_src_ip);\n                ds_put_format(actions,\n                    \"eth.dst = eth.src; \"\n                    \"eth.src = %s; \"\n                    \"arp.op = 2; /* ARP reply */ \"\n                    \"arp.tha = arp.sha; \"\n                    \"arp.sha = %s; \"\n                    \"arp.tpa = arp.spa; \"\n                    \"arp.spa = %s; \"\n                    \"outport = inport; \"\n                    \"flags.loopback = 1; \"\n                    \"output;\",\n                    svc_monitor_mac, svc_monitor_mac,\n                    backend_nb->svc_mon_src_ip);\n            } else {\n                ds_put_format(match, \"nd_ns && nd.target == %s\",\n                              backend_nb->svc_mon_src_ip);\n                ds_put_format(actions,\n                        \"nd_na { \"\n                        \"eth.dst = eth.src; \"\n                        \"eth.src = %s; \"\n                        \"ip6.src = %s; \"\n                        \"nd.target = %s; \"\n                        \"nd.tll = %s; \"\n                        \"outport = inport; \"\n                        \"flags.loopback = 1; \"\n                        \"output; \"\n                        \"};\",\n                        svc_monitor_mac,\n                        backend_nb->svc_mon_src_ip,\n                        backend_nb->svc_mon_src_ip,\n                        svc_monitor_mac);\n            }\n            ovn_lflow_add_with_hint(lflows,\n                                    backend_nb->op->od,\n                                    S_SWITCH_IN_ARP_ND_RSP, 110,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &lb->nlb->header_);\n        }\n    }\n}\n\n\n/* Logical switch ingress table 20 and 21: DHCP options and response\n * priority 100 flows. */\nstatic void\nbuild_lswitch_dhcp_options_and_response(struct ovn_port *op,\n                                        struct hmap *lflows,\n                                        const struct shash *meter_groups)\n{\n    if (op->nbsp) {\n        if (!lsp_is_enabled(op->nbsp) || lsp_is_router(op->nbsp)) {\n            /* Don't add the DHCP flows if the port is not enabled or if the\n             * port is a router port. */\n            return;\n        }\n\n        if (!op->nbsp->dhcpv4_options && !op->nbsp->dhcpv6_options) {\n            /* CMS has disabled both native DHCPv4 and DHCPv6 for this lport.\n             */\n            return;\n        }\n\n        bool is_external = lsp_is_external(op->nbsp);\n        if (is_external && (!op->od->n_localnet_ports ||\n                            !op->nbsp->ha_chassis_group)) {\n            /* If it's an external port and there are no localnet ports\n             * and if it doesn't belong to an HA chassis group ignore it. */\n            return;\n        }\n\n        for (size_t i = 0; i < op->n_lsp_addrs; i++) {\n            if (is_external) {\n                for (size_t j = 0; j < op->od->n_localnet_ports; j++) {\n                    build_dhcpv4_options_flows(\n                        op, &op->lsp_addrs[i],\n                        op->od->localnet_ports[j], is_external,\n                        meter_groups, lflows);\n                    build_dhcpv6_options_flows(\n                        op, &op->lsp_addrs[i],\n                        op->od->localnet_ports[j], is_external,\n                        meter_groups, lflows);\n                }\n            } else {\n                build_dhcpv4_options_flows(op, &op->lsp_addrs[i], op,\n                                           is_external, meter_groups,\n                                           lflows);\n                build_dhcpv6_options_flows(op, &op->lsp_addrs[i], op,\n                                           is_external, meter_groups,\n                                           lflows);\n            }\n        }\n    }\n}\n\n/* Ingress table 20 and 21: DHCP options and response, by default goto\n * next. (priority 0).\n * Ingress table 22 and 23: DNS lookup and response, by default goto next.\n * (priority 0).\n * Ingress table 24 - External port handling, by default goto next.\n * (priority 0). */\nstatic void\nbuild_lswitch_dhcp_and_dns_defaults(struct ovn_datapath *od,\n                                        struct hmap *lflows)\n{\n    if (od->nbs) {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DHCP_OPTIONS, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DHCP_RESPONSE, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DNS_LOOKUP, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DNS_RESPONSE, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_EXTERNAL_PORT, 0, \"1\", \"next;\");\n    }\n}\n\n/* Logical switch ingress table 22 and 23: DNS lookup and response\n* priority 100 flows.\n*/\nstatic void\nbuild_lswitch_dns_lookup_and_response(struct ovn_datapath *od,\n                                      struct hmap *lflows,\n                                      const struct shash *meter_groups)\n{\n    if (od->nbs && ls_has_dns_records(od->nbs)) {\n        ovn_lflow_metered(lflows, od, S_SWITCH_IN_DNS_LOOKUP, 100,\n                          \"udp.dst == 53\",\n                          REGBIT_DNS_LOOKUP_RESULT\" = dns_lookup(); next;\",\n                          copp_meter_get(COPP_DNS, od->nbs->copp,\n                                         meter_groups));\n        const char *dns_action = \"eth.dst <-> eth.src; ip4.src <-> ip4.dst; \"\n                      \"udp.dst = udp.src; udp.src = 53; outport = inport; \"\n                      \"flags.loopback = 1; output;\";\n        const char *dns_match = \"udp.dst == 53 && \"REGBIT_DNS_LOOKUP_RESULT;\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DNS_RESPONSE, 100,\n                      dns_match, dns_action);\n        dns_action = \"eth.dst <-> eth.src; ip6.src <-> ip6.dst; \"\n                      \"udp.dst = udp.src; udp.src = 53; outport = inport; \"\n                      \"flags.loopback = 1; output;\";\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DNS_RESPONSE, 100,\n                      dns_match, dns_action);\n    }\n}\n\n/* Table 24: External port. Drop ARP request for router ips from\n * external ports  on chassis not binding those ports.\n * This makes the router pipeline to be run only on the chassis\n * binding the external ports. */\nstatic void\nbuild_lswitch_external_port(struct ovn_port *op,\n                            struct hmap *lflows)\n{\n    if (op->nbsp && lsp_is_external(op->nbsp)) {\n\n        for (size_t i = 0; i < op->od->n_localnet_ports; i++) {\n            build_drop_arp_nd_flows_for_unbound_router_ports(\n                op, op->od->localnet_ports[i], lflows);\n        }\n    }\n}\n\n/* Ingress table 25: Destination lookup, broadcast and multicast handling\n * (priority 70 - 100). */\nstatic void\nbuild_lswitch_destination_lookup_bmcast(struct ovn_datapath *od,\n                                        struct hmap *lflows,\n                                        struct ds *actions,\n                                        const struct shash *meter_groups)\n{\n    if (od->nbs) {\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 110,\n                      \"eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)\",\n                      \"handle_svc_check(inport);\");\n\n        struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n        if (mcast_sw_info->enabled) {\n            ds_clear(actions);\n            ds_put_cstr(actions, \"igmp;\");\n            /* Punt IGMP traffic to controller. */\n            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,\n                              \"igmp\", ds_cstr(actions),\n                              copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                             meter_groups));\n\n            /* Punt MLD traffic to controller. */\n            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,\n                              \"mldv1 || mldv2\", ds_cstr(actions),\n                              copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                             meter_groups));\n\n            /* Flood all IP multicast traffic destined to 224.0.0.X to all\n             * ports - RFC 4541, section 2.1.2, item 2.\n             */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,\n                          \"ip4.mcast && ip4.dst == 224.0.0.0/24\",\n                          \"outport = \\\"\"MC_FLOOD_L2\"\\\"; output;\");\n\n            /* Flood all IPv6 multicast traffic destined to reserved\n             * multicast IPs (RFC 4291, 2.7.1).\n             */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,\n                          \"ip6.mcast_flood\",\n                          \"outport = \\\"\"MC_FLOOD\"\\\"; output;\");\n\n            /* Forward uregistered IP multicast to routers with relay enabled\n             * and to any ports configured to flood IP multicast traffic.\n             * If configured to flood unregistered traffic this will be\n             * handled by the L2 multicast flow.\n             */\n            if (!mcast_sw_info->flood_unregistered) {\n                ds_clear(actions);\n\n                if (mcast_sw_info->flood_relay) {\n                    ds_put_cstr(actions,\n                                \"clone { \"\n                                    \"outport = \\\"\"MC_MROUTER_FLOOD\"\\\"; \"\n                                    \"output; \"\n                                \"}; \");\n                }\n\n                if (mcast_sw_info->flood_static) {\n                    ds_put_cstr(actions, \"outport =\\\"\"MC_STATIC\"\\\"; output;\");\n                }\n\n                /* Explicitly drop the traffic if relay or static flooding\n                 * is not configured.\n                 */\n                if (!mcast_sw_info->flood_relay &&\n                        !mcast_sw_info->flood_static) {\n                    ds_put_cstr(actions, debug_drop_action());\n                }\n\n                ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 80,\n                              \"ip4.mcast || ip6.mcast\",\n                              ds_cstr(actions));\n            }\n        }\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 70, \"eth.mcast\",\n                      \"outport = \\\"\"MC_FLOOD\"\\\"; output;\");\n    }\n}\n\n\n/* Ingress table 25: Add IP multicast flows learnt from IGMP/MLD\n * (priority 90). */\nstatic void\nbuild_lswitch_ip_mcast_igmp_mld(struct ovn_igmp_group *igmp_group,\n                                struct hmap *lflows,\n                                struct ds *actions,\n                                struct ds *match)\n{\n    uint64_t dummy;\n\n    if (igmp_group->datapath) {\n\n        ds_clear(match);\n        ds_clear(actions);\n\n        struct mcast_switch_info *mcast_sw_info =\n            &igmp_group->datapath->mcast_info.sw;\n        uint64_t table_size = mcast_sw_info->table_size;\n\n        if (IN6_IS_ADDR_V4MAPPED(&igmp_group->address)) {\n            /* RFC 4541, section 2.1.2, item 2: Skip groups in the 224.0.0.X\n             * range.\n             */\n            ovs_be32 group_address =\n                in6_addr_get_mapped_ipv4(&igmp_group->address);\n            if (ip_is_local_multicast(group_address)) {\n                return;\n            }\n            if (atomic_compare_exchange_strong(\n                        &mcast_sw_info->active_v4_flows, &table_size,\n                        mcast_sw_info->table_size)) {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n\n                VLOG_INFO_RL(&rl, \"Too many active mcast flows: %\"PRIu64,\n                             mcast_sw_info->active_v4_flows);\n                return;\n            }\n            atomic_add(&mcast_sw_info->active_v4_flows, 1, &dummy);\n            ds_put_format(match, \"eth.mcast && ip4 && ip4.dst == %s \",\n                          igmp_group->mcgroup.name);\n        } else {\n            /* RFC 4291, section 2.7.1: Skip groups that correspond to all\n             * hosts, all link-local routers and all site routers.\n             */\n            if (ipv6_is_all_hosts(&igmp_group->address) ||\n                ipv6_is_all_router(&igmp_group->address) ||\n                ipv6_is_all_site_router(&igmp_group->address)) {\n                return;\n            }\n            if (atomic_compare_exchange_strong(\n                        &mcast_sw_info->active_v6_flows, &table_size,\n                        mcast_sw_info->table_size)) {\n                return;\n            }\n            atomic_add(&mcast_sw_info->active_v6_flows, 1, &dummy);\n            ds_put_format(match, \"eth.mcast && ip6 && ip6.dst == %s \",\n                          igmp_group->mcgroup.name);\n        }\n\n        /* Also flood traffic to all multicast routers with relay enabled. */\n        if (mcast_sw_info->flood_relay) {\n            ds_put_cstr(actions,\n                        \"clone { \"\n                            \"outport = \\\"\"MC_MROUTER_FLOOD \"\\\"; \"\n                            \"output; \"\n                        \"};\");\n        }\n        if (mcast_sw_info->flood_static) {\n            ds_put_cstr(actions,\n                        \"clone { \"\n                            \"outport =\\\"\"MC_STATIC\"\\\"; \"\n                            \"output; \"\n                        \"};\");\n        }\n        ds_put_format(actions, \"outport = \\\"%s\\\"; output; \",\n                      igmp_group->mcgroup.name);\n\n        ovn_lflow_add(lflows, igmp_group->datapath, S_SWITCH_IN_L2_LKUP,\n                      90, ds_cstr(match), ds_cstr(actions));\n    }\n}\n\nstatic struct ovs_mutex mcgroup_mutex = OVS_MUTEX_INITIALIZER;\n\n/* Ingress table 25: Destination lookup, unicast handling (priority 50), */\nstatic void\nbuild_lswitch_ip_unicast_lookup(struct ovn_port *op,\n                                struct hmap *lflows,\n                                struct hmap *mcgroups,\n                                struct ds *actions,\n                                struct ds *match)\n{\n    if (op->nbsp && (!lsp_is_external(op->nbsp))) {\n\n        /* For ports connected to logical routers add flows to bypass the\n         * broadcast flooding of ARP/ND requests in table 19. We direct the\n         * requests only to the router port that owns the IP address.\n         */\n        if (lsp_is_router(op->nbsp)) {\n            build_lswitch_rport_arp_req_flows(op->peer, op->od, op, lflows,\n                                              &op->nbsp->header_);\n        }\n\n        for (size_t i = 0; i < op->nbsp->n_addresses; i++) {\n            /* Addresses are owned by the logical port.\n             * Ethernet address followed by zero or more IPv4\n             * or IPv6 addresses (or both). */\n            struct eth_addr mac;\n            bool lsp_enabled = lsp_is_enabled(op->nbsp);\n            const char *action = lsp_enabled ? \"outport = %s; output;\" :\n                                               debug_drop_action();\n            if (ovs_scan(op->nbsp->addresses[i],\n                        ETH_ADDR_SCAN_FMT, ETH_ADDR_SCAN_ARGS(mac))) {\n                ds_clear(match);\n                ds_put_format(match, \"eth.dst == \"ETH_ADDR_FMT,\n                              ETH_ADDR_ARGS(mac));\n\n                ds_clear(actions);\n                ds_put_format(actions, action, op->json_key);\n                ovn_lflow_add_with_hint(lflows, op->od, S_SWITCH_IN_L2_LKUP,\n                                        50, ds_cstr(match),\n                                        ds_cstr(actions),\n                                        &op->nbsp->header_);\n            } else if (!strcmp(op->nbsp->addresses[i], \"unknown\")) {\n                if (lsp_enabled) {\n                    ovs_mutex_lock(&mcgroup_mutex);\n                    ovn_multicast_add(mcgroups, &mc_unknown, op);\n                    ovs_mutex_unlock(&mcgroup_mutex);\n                    op->od->has_unknown = true;\n                }\n            } else if (is_dynamic_lsp_address(op->nbsp->addresses[i])) {\n                if (!op->nbsp->dynamic_addresses\n                    || !ovs_scan(op->nbsp->dynamic_addresses,\n                            ETH_ADDR_SCAN_FMT, ETH_ADDR_SCAN_ARGS(mac))) {\n                    continue;\n                }\n                ds_clear(match);\n                ds_put_format(match, \"eth.dst == \"ETH_ADDR_FMT,\n                              ETH_ADDR_ARGS(mac));\n\n                ds_clear(actions);\n                ds_put_format(actions, action, op->json_key);\n                ovn_lflow_add_with_hint(lflows, op->od, S_SWITCH_IN_L2_LKUP,\n                                        50, ds_cstr(match),\n                                        ds_cstr(actions),\n                                        &op->nbsp->header_);\n            } else if (!strcmp(op->nbsp->addresses[i], \"router\")) {\n                if (!op->peer || !op->peer->nbrp\n                    || !ovs_scan(op->peer->nbrp->mac,\n                            ETH_ADDR_SCAN_FMT, ETH_ADDR_SCAN_ARGS(mac))) {\n                    continue;\n                }\n                ds_clear(match);\n                ds_put_format(match, \"eth.dst == \"ETH_ADDR_FMT,\n                              ETH_ADDR_ARGS(mac));\n                if (op->peer->od->n_l3dgw_ports\n                    && op->od->n_localnet_ports) {\n                    bool add_chassis_resident_check = false;\n                    const char *json_key;\n                    if (is_l3dgw_port(op->peer)) {\n                        /* The peer of this port represents a distributed\n                         * gateway port. The destination lookup flow for the\n                         * router's distributed gateway port MAC address should\n                         * only be programmed on the gateway chassis. */\n                        add_chassis_resident_check = true;\n                        json_key = op->peer->cr_port->json_key;\n                    } else {\n                        /* Check if the option 'reside-on-redirect-chassis'\n                         * is set to true on the peer port. If set to true\n                         * and if the logical switch has a localnet port, it\n                         * means the router pipeline for the packets from\n                         * this logical switch should be run on the chassis\n                         * hosting the gateway port.\n                         */\n                        add_chassis_resident_check = smap_get_bool(\n                            &op->peer->nbrp->options,\n                            \"reside-on-redirect-chassis\", false) &&\n                            op->peer->od->n_l3dgw_ports == 1;\n                        json_key =\n                            op->peer->od->l3dgw_ports[0]->cr_port->json_key;\n                    }\n\n                    if (add_chassis_resident_check) {\n                        ds_put_format(match, \" && is_chassis_resident(%s)\",\n                                      json_key);\n                    }\n                }\n\n                ds_clear(actions);\n                ds_put_format(actions, action, op->json_key);\n                ovn_lflow_add_with_hint(lflows, op->od,\n                                        S_SWITCH_IN_L2_LKUP, 50,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbsp->header_);\n\n                /* Add ethernet addresses specified in NAT rules on\n                 * distributed logical routers. */\n                if (is_l3dgw_port(op->peer)) {\n                    for (int j = 0; j < op->peer->od->nbr->n_nat; j++) {\n                        const struct nbrec_nat *nat\n                                                  = op->peer->od->nbr->nat[j];\n                        if (!strcmp(nat->type, \"dnat_and_snat\")\n                            && nat->logical_port && nat->external_mac\n                            && eth_addr_from_string(nat->external_mac, &mac)) {\n\n                            ds_clear(match);\n                            ds_put_format(match, \"eth.dst == \"ETH_ADDR_FMT\n                                          \" && is_chassis_resident(\\\"%s\\\")\",\n                                          ETH_ADDR_ARGS(mac),\n                                          nat->logical_port);\n\n                            ds_clear(actions);\n                            ds_put_format(actions, action, op->json_key);\n                            ovn_lflow_add_with_hint(lflows, op->od,\n                                                    S_SWITCH_IN_L2_LKUP, 50,\n                                                    ds_cstr(match),\n                                                    ds_cstr(actions),\n                                                    &op->nbsp->header_);\n                        }\n                    }\n                }\n            } else {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n\n                VLOG_INFO_RL(&rl,\n                             \"%s: invalid syntax '%s' in addresses column\",\n                             op->nbsp->name, op->nbsp->addresses[i]);\n            }\n        }\n    }\n}\n\nstruct bfd_entry {\n    struct hmap_node hmap_node;\n\n    const struct sbrec_bfd *sb_bt;\n\n    bool ref;\n};\n\nstatic struct bfd_entry *\nbfd_port_lookup(const struct hmap *bfd_map, const char *logical_port,\n                const char *dst_ip)\n{\n    struct bfd_entry *bfd_e;\n    uint32_t hash;\n\n    hash = hash_string(dst_ip, 0);\n    hash = hash_string(logical_port, hash);\n    HMAP_FOR_EACH_WITH_HASH (bfd_e, hmap_node, hash, bfd_map) {\n        if (!strcmp(bfd_e->sb_bt->logical_port, logical_port) &&\n            !strcmp(bfd_e->sb_bt->dst_ip, dst_ip)) {\n            return bfd_e;\n        }\n    }\n    return NULL;\n}\n\nvoid\nbfd_cleanup_connections(struct lflow_input *input_data,\n                        struct hmap *bfd_map)\n{\n    const struct nbrec_bfd *nb_bt;\n    struct bfd_entry *bfd_e;\n\n    NBREC_BFD_TABLE_FOR_EACH (nb_bt, input_data->nbrec_bfd_table) {\n        bfd_e = bfd_port_lookup(bfd_map, nb_bt->logical_port, nb_bt->dst_ip);\n        if (!bfd_e) {\n            continue;\n        }\n\n        if (!bfd_e->ref && strcmp(nb_bt->status, \"admin_down\")) {\n            /* no user for this bfd connection */\n            nbrec_bfd_set_status(nb_bt, \"admin_down\");\n        }\n    }\n\n    HMAP_FOR_EACH_POP (bfd_e, hmap_node, bfd_map) {\n        free(bfd_e);\n    }\n}\n\n#define BFD_DEF_MINTX       1000 /* 1s */\n#define BFD_DEF_MINRX       1000 /* 1s */\n#define BFD_DEF_DETECT_MULT 5\n\nstatic void\nbuild_bfd_update_sb_conf(const struct nbrec_bfd *nb_bt,\n                         const struct sbrec_bfd *sb_bt)\n{\n    if (strcmp(nb_bt->dst_ip, sb_bt->dst_ip)) {\n        sbrec_bfd_set_dst_ip(sb_bt, nb_bt->dst_ip);\n    }\n\n    if (strcmp(nb_bt->logical_port, sb_bt->logical_port)) {\n        sbrec_bfd_set_logical_port(sb_bt, nb_bt->logical_port);\n    }\n\n    if (strcmp(nb_bt->status, sb_bt->status)) {\n        sbrec_bfd_set_status(sb_bt, nb_bt->status);\n    }\n\n    int detect_mult = nb_bt->n_detect_mult ? nb_bt->detect_mult[0]\n                                           : BFD_DEF_DETECT_MULT;\n    if (detect_mult != sb_bt->detect_mult) {\n        sbrec_bfd_set_detect_mult(sb_bt, detect_mult);\n    }\n\n    int min_tx = nb_bt->n_min_tx ? nb_bt->min_tx[0] : BFD_DEF_MINTX;\n    if (min_tx != sb_bt->min_tx) {\n        sbrec_bfd_set_min_tx(sb_bt, min_tx);\n    }\n\n    int min_rx = nb_bt->n_min_rx ? nb_bt->min_rx[0] : BFD_DEF_MINRX;\n    if (min_rx != sb_bt->min_rx) {\n        sbrec_bfd_set_min_rx(sb_bt, min_rx);\n    }\n}\n\n/* RFC 5881 section 4\n * The source port MUST be in the range 49152 through 65535.\n * The same UDP source port number MUST be used for all BFD\n * Control packets associated with a particular session.\n * The source port number SHOULD be unique among all BFD\n * sessions on the system\n */\n#define BFD_UDP_SRC_PORT_START  49152\n#define BFD_UDP_SRC_PORT_LEN    (65535 - BFD_UDP_SRC_PORT_START)\n\nstatic int bfd_get_unused_port(unsigned long *bfd_src_ports)\n{\n    int port;\n\n    port = bitmap_scan(bfd_src_ports, 0, 0, BFD_UDP_SRC_PORT_LEN);\n    if (port == BFD_UDP_SRC_PORT_LEN) {\n        return -ENOSPC;\n    }\n    bitmap_set1(bfd_src_ports, port);\n\n    return port + BFD_UDP_SRC_PORT_START;\n}\n\nvoid\nbuild_bfd_table(struct lflow_input *input_data,\n                struct ovsdb_idl_txn *ovnsb_txn,\n                struct hmap *bfd_connections, struct hmap *ports)\n{\n    struct hmap sb_only = HMAP_INITIALIZER(&sb_only);\n    const struct sbrec_bfd *sb_bt;\n    unsigned long *bfd_src_ports;\n    struct bfd_entry *bfd_e;\n    uint32_t hash;\n\n    bfd_src_ports = bitmap_allocate(BFD_UDP_SRC_PORT_LEN);\n\n    SBREC_BFD_TABLE_FOR_EACH (sb_bt, input_data->sbrec_bfd_table) {\n        bfd_e = xmalloc(sizeof *bfd_e);\n        bfd_e->sb_bt = sb_bt;\n        hash = hash_string(sb_bt->dst_ip, 0);\n        hash = hash_string(sb_bt->logical_port, hash);\n        hmap_insert(&sb_only, &bfd_e->hmap_node, hash);\n        bitmap_set1(bfd_src_ports, sb_bt->src_port - BFD_UDP_SRC_PORT_START);\n    }\n\n    const struct nbrec_bfd *nb_bt;\n    NBREC_BFD_TABLE_FOR_EACH (nb_bt, input_data->nbrec_bfd_table) {\n        if (!nb_bt->status) {\n            /* default state is admin_down */\n            nbrec_bfd_set_status(nb_bt, \"admin_down\");\n        }\n\n        bfd_e = bfd_port_lookup(&sb_only, nb_bt->logical_port, nb_bt->dst_ip);\n        if (!bfd_e) {\n            int udp_src = bfd_get_unused_port(bfd_src_ports);\n            if (udp_src < 0) {\n                continue;\n            }\n\n            sb_bt = sbrec_bfd_insert(ovnsb_txn);\n            sbrec_bfd_set_logical_port(sb_bt, nb_bt->logical_port);\n            sbrec_bfd_set_dst_ip(sb_bt, nb_bt->dst_ip);\n            sbrec_bfd_set_disc(sb_bt, 1 + random_uint32());\n            sbrec_bfd_set_src_port(sb_bt, udp_src);\n            sbrec_bfd_set_status(sb_bt, nb_bt->status);\n\n            int min_tx = nb_bt->n_min_tx ? nb_bt->min_tx[0] : BFD_DEF_MINTX;\n            sbrec_bfd_set_min_tx(sb_bt, min_tx);\n            int min_rx = nb_bt->n_min_rx ? nb_bt->min_rx[0] : BFD_DEF_MINRX;\n            sbrec_bfd_set_min_rx(sb_bt, min_rx);\n            int d_mult = nb_bt->n_detect_mult ? nb_bt->detect_mult[0]\n                                              : BFD_DEF_DETECT_MULT;\n            sbrec_bfd_set_detect_mult(sb_bt, d_mult);\n        } else {\n            if (strcmp(bfd_e->sb_bt->status, nb_bt->status)) {\n                if (!strcmp(nb_bt->status, \"admin_down\") ||\n                    !strcmp(bfd_e->sb_bt->status, \"admin_down\")) {\n                    sbrec_bfd_set_status(bfd_e->sb_bt, nb_bt->status);\n                } else {\n                    nbrec_bfd_set_status(nb_bt, bfd_e->sb_bt->status);\n                }\n            }\n            build_bfd_update_sb_conf(nb_bt, bfd_e->sb_bt);\n\n            hmap_remove(&sb_only, &bfd_e->hmap_node);\n            bfd_e->ref = false;\n            hash = hash_string(bfd_e->sb_bt->dst_ip, 0);\n            hash = hash_string(bfd_e->sb_bt->logical_port, hash);\n            hmap_insert(bfd_connections, &bfd_e->hmap_node, hash);\n        }\n\n        struct ovn_port *op = ovn_port_find(ports, nb_bt->logical_port);\n        if (op) {\n            op->has_bfd = true;\n        }\n    }\n\n    HMAP_FOR_EACH_POP (bfd_e, hmap_node, &sb_only) {\n        struct ovn_port *op = ovn_port_find(ports, bfd_e->sb_bt->logical_port);\n        if (op) {\n            op->has_bfd = false;\n        }\n        sbrec_bfd_delete(bfd_e->sb_bt);\n        free(bfd_e);\n    }\n    hmap_destroy(&sb_only);\n\n    bitmap_free(bfd_src_ports);\n}\n\n/* Returns a string of the IP address of the router port 'op' that\n * overlaps with 'ip_s\".  If one is not found, returns NULL.\n *\n * The caller must not free the returned string. */\nstatic const char *\nfind_lrp_member_ip(const struct ovn_port *op, const char *ip_s)\n{\n    return find_lport_address(&op->lrp_networks, ip_s);\n}\n\nstatic struct ovn_port*\nget_outport_for_routing_policy_nexthop(struct ovn_datapath *od,\n                                       const struct hmap *ports,\n                                       int priority, const char *nexthop)\n{\n    if (nexthop == NULL) {\n        return NULL;\n    }\n\n    /* Find the router port matching the next hop. */\n    for (int i = 0; i < od->nbr->n_ports; i++) {\n       struct nbrec_logical_router_port *lrp = od->nbr->ports[i];\n\n       struct ovn_port *out_port = ovn_port_find(ports, lrp->name);\n       if (out_port && find_lrp_member_ip(out_port, nexthop)) {\n           return out_port;\n       }\n    }\n\n    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n    VLOG_WARN_RL(&rl, \"No path for routing policy priority %d; next hop %s\",\n                 priority, nexthop);\n    return NULL;\n}\n\nstatic void\nbuild_routing_policy_flow(struct hmap *lflows, struct ovn_datapath *od,\n                          const struct hmap *ports,\n                          const struct nbrec_logical_router_policy *rule,\n                          const struct ovsdb_idl_row *stage_hint)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    if (!strcmp(rule->action, \"reroute\")) {\n        ovs_assert(rule->n_nexthops <= 1);\n\n        char *nexthop =\n            (rule->n_nexthops == 1 ? rule->nexthops[0] : rule->nexthop);\n        struct ovn_port *out_port = get_outport_for_routing_policy_nexthop(\n             od, ports, rule->priority, nexthop);\n        if (!out_port) {\n            return;\n        }\n\n        const char *lrp_addr_s = find_lrp_member_ip(out_port, nexthop);\n        if (!lrp_addr_s) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"lrp_addr not found for routing policy \"\n                         \" priority %\"PRId64\" nexthop %s\",\n                         rule->priority, nexthop);\n            return;\n        }\n        uint32_t pkt_mark = ovn_smap_get_uint(&rule->options, \"pkt_mark\", 0);\n        if (pkt_mark) {\n            ds_put_format(&actions, \"pkt.mark = %u; \", pkt_mark);\n        }\n\n        bool is_ipv4 = strchr(nexthop, '.') ? true : false;\n        ds_put_format(&actions, \"%s = %s; \"\n                      \"%s = %s; \"\n                      \"eth.src = %s; \"\n                      \"outport = %s; \"\n                      \"flags.loopback = 1; \"\n                      REG_ECMP_GROUP_ID\" = 0; \"\n                      \"next;\",\n                      is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6,\n                      nexthop,\n                      is_ipv4 ? REG_SRC_IPV4 : REG_SRC_IPV6,\n                      lrp_addr_s,\n                      out_port->lrp_networks.ea_s,\n                      out_port->json_key);\n\n    } else if (!strcmp(rule->action, \"drop\")) {\n        ds_put_cstr(&actions, debug_drop_action());\n    } else if (!strcmp(rule->action, \"allow\")) {\n        uint32_t pkt_mark = ovn_smap_get_uint(&rule->options, \"pkt_mark\", 0);\n        if (pkt_mark) {\n            ds_put_format(&actions, \"pkt.mark = %u; \", pkt_mark);\n        }\n        ds_put_cstr(&actions, REG_ECMP_GROUP_ID\" = 0; next;\");\n    }\n    ds_put_format(&match, \"%s\", rule->match);\n\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_POLICY, rule->priority,\n                            ds_cstr(&match), ds_cstr(&actions), stage_hint);\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_ecmp_routing_policy_flows(struct hmap *lflows, struct ovn_datapath *od,\n                                const struct hmap *ports,\n                                const struct nbrec_logical_router_policy *rule,\n                                uint16_t ecmp_group_id)\n{\n    ovs_assert(rule->n_nexthops > 1);\n\n    bool nexthops_is_ipv4 = true;\n\n    /* Check that all the nexthops belong to the same addr family before\n     * adding logical flows. */\n    for (uint16_t i = 0; i < rule->n_nexthops; i++) {\n        bool is_ipv4 = strchr(rule->nexthops[i], '.') ? true : false;\n\n        if (i == 0) {\n            nexthops_is_ipv4 = is_ipv4;\n        }\n\n        if (is_ipv4 != nexthops_is_ipv4) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"nexthop [%s] of the router policy with \"\n                         \"the match [%s] do not belong to the same address \"\n                         \"family as other next hops\",\n                         rule->nexthops[i], rule->match);\n            return;\n        }\n    }\n\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    for (size_t i = 0; i < rule->n_nexthops; i++) {\n        struct ovn_port *out_port = get_outport_for_routing_policy_nexthop(\n             od, ports, rule->priority, rule->nexthops[i]);\n        if (!out_port) {\n            goto cleanup;\n        }\n\n        const char *lrp_addr_s =\n            find_lrp_member_ip(out_port, rule->nexthops[i]);\n        if (!lrp_addr_s) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"lrp_addr not found for routing policy \"\n                            \" priority %\"PRId64\" nexthop %s\",\n                            rule->priority, rule->nexthops[i]);\n            goto cleanup;\n        }\n\n        ds_clear(&actions);\n        uint32_t pkt_mark = ovn_smap_get_uint(&rule->options, \"pkt_mark\", 0);\n        if (pkt_mark) {\n            ds_put_format(&actions, \"pkt.mark = %u; \", pkt_mark);\n        }\n\n        bool is_ipv4 = strchr(rule->nexthops[i], '.') ? true : false;\n\n        ds_put_format(&actions, \"%s = %s; \"\n                      \"%s = %s; \"\n                      \"eth.src = %s; \"\n                      \"outport = %s; \"\n                      \"flags.loopback = 1; \"\n                      \"next;\",\n                      is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6,\n                      rule->nexthops[i],\n                      is_ipv4 ? REG_SRC_IPV4 : REG_SRC_IPV6,\n                      lrp_addr_s,\n                      out_port->lrp_networks.ea_s,\n                      out_port->json_key);\n\n        ds_clear(&match);\n        ds_put_format(&match, REG_ECMP_GROUP_ID\" == %\"PRIu16\" && \"\n                      REG_ECMP_MEMBER_ID\" == %\"PRIuSIZE,\n                      ecmp_group_id, i + 1);\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_POLICY_ECMP,\n                                100, ds_cstr(&match),\n                                ds_cstr(&actions), &rule->header_);\n    }\n\n    ds_clear(&actions);\n    ds_put_format(&actions, \"%s = %\"PRIu16\n                  \"; %s = select(\", REG_ECMP_GROUP_ID, ecmp_group_id,\n                  REG_ECMP_MEMBER_ID);\n\n    for (size_t i = 0; i < rule->n_nexthops; i++) {\n        if (i > 0) {\n            ds_put_cstr(&actions, \", \");\n        }\n\n        ds_put_format(&actions, \"%\"PRIuSIZE, i + 1);\n    }\n    ds_put_cstr(&actions, \");\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_POLICY,\n                            rule->priority, rule->match,\n                            ds_cstr(&actions), &rule->header_);\n\ncleanup:\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic uint32_t\nroute_table_add(struct simap *route_tables, const char *route_table_name)\n{\n    /* route table ids start from 1 */\n    uint32_t rtb_id = simap_count(route_tables) + 1;\n\n    if (rtb_id == UINT16_MAX) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"too many route tables for Logical Router.\");\n        return 0;\n    }\n\n    if (!simap_put(route_tables, route_table_name, rtb_id)) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"Route table id unexpectedly appeared\");\n    }\n\n    return rtb_id;\n}\n\nstatic uint32_t\nget_route_table_id(struct simap *route_tables, const char *route_table_name)\n{\n    if (!route_table_name || !route_table_name[0]) {\n        return 0;\n    }\n\n    uint32_t rtb_id = simap_get(route_tables, route_table_name);\n    if (!rtb_id) {\n        rtb_id = route_table_add(route_tables, route_table_name);\n    }\n\n    return rtb_id;\n}\n\nstatic void\nbuild_route_table_lflow(struct ovn_datapath *od, struct hmap *lflows,\n                        struct nbrec_logical_router_port *lrp,\n                        struct simap *route_tables)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    const char *route_table_name = smap_get(&lrp->options, \"route_table\");\n    uint32_t rtb_id = get_route_table_id(route_tables, route_table_name);\n    if (!rtb_id) {\n        return;\n    }\n\n    ds_put_format(&match, \"inport == \\\"%s\\\"\", lrp->name);\n    ds_put_format(&actions, \"%s = %d; next;\",\n                  REG_ROUTE_TABLE_ID, rtb_id);\n\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING_PRE, 100,\n                  ds_cstr(&match), ds_cstr(&actions));\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstruct parsed_route {\n    struct ovs_list list_node;\n    struct in6_addr prefix;\n    unsigned int plen;\n    bool is_src_route;\n    uint32_t route_table_id;\n    uint32_t hash;\n    const struct nbrec_logical_router_static_route *route;\n    bool ecmp_symmetric_reply;\n    bool is_discard_route;\n};\n\nstatic uint32_t\nroute_hash(struct parsed_route *route)\n{\n    return hash_bytes(&route->prefix, sizeof route->prefix,\n                      (uint32_t)route->plen);\n}\n\nstatic struct ovs_mutex bfd_lock = OVS_MUTEX_INITIALIZER;\n\nstatic bool\nfind_static_route_outport(struct ovn_datapath *od, const struct hmap *ports,\n    const struct nbrec_logical_router_static_route *route, bool is_ipv4,\n    const char **p_lrp_addr_s, struct ovn_port **p_out_port);\n\n/* Parse and validate the route. Return the parsed route if successful.\n * Otherwise return NULL. */\nstatic struct parsed_route *\nparsed_routes_add(struct ovn_datapath *od, const struct hmap *ports,\n                  struct ovs_list *routes, struct simap *route_tables,\n                  const struct nbrec_logical_router_static_route *route,\n                  const struct hmap *bfd_connections)\n{\n    /* Verify that the next hop is an IP address with an all-ones mask. */\n    struct in6_addr nexthop;\n    unsigned int plen;\n    bool is_discard_route = !strcmp(route->nexthop, \"discard\");\n    bool valid_nexthop = route->nexthop[0] && !is_discard_route;\n    if (valid_nexthop) {\n        if (!ip46_parse_cidr(route->nexthop, &nexthop, &plen)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad 'nexthop' %s in static route \"\n                         UUID_FMT, route->nexthop,\n                         UUID_ARGS(&route->header_.uuid));\n            return NULL;\n        }\n        if ((IN6_IS_ADDR_V4MAPPED(&nexthop) && plen != 32) ||\n            (!IN6_IS_ADDR_V4MAPPED(&nexthop) && plen != 128)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad next hop mask %s in static route \"\n                         UUID_FMT, route->nexthop,\n                         UUID_ARGS(&route->header_.uuid));\n            return NULL;\n        }\n    }\n\n    /* Parse ip_prefix */\n    struct in6_addr prefix;\n    if (!ip46_parse_cidr(route->ip_prefix, &prefix, &plen)) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"bad 'ip_prefix' %s in static route \"\n                     UUID_FMT, route->ip_prefix,\n                     UUID_ARGS(&route->header_.uuid));\n        return NULL;\n    }\n\n    /* Verify that ip_prefix and nexthop have same address familiy. */\n    if (valid_nexthop) {\n        if (IN6_IS_ADDR_V4MAPPED(&prefix) != IN6_IS_ADDR_V4MAPPED(&nexthop)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"Address family doesn't match between 'ip_prefix'\"\n                         \" %s and 'nexthop' %s in static route \"UUID_FMT,\n                         route->ip_prefix, route->nexthop,\n                         UUID_ARGS(&route->header_.uuid));\n            return NULL;\n        }\n    }\n\n    /* Verify that ip_prefix and nexthop are on the same network. */\n    if (!is_discard_route &&\n        !find_static_route_outport(od, ports, route,\n                                   IN6_IS_ADDR_V4MAPPED(&prefix),\n                                   NULL, NULL)) {\n        return NULL;\n    }\n\n    const struct nbrec_bfd *nb_bt = route->bfd;\n    if (nb_bt && !strcmp(nb_bt->dst_ip, route->nexthop)) {\n        struct bfd_entry *bfd_e;\n\n        bfd_e = bfd_port_lookup(bfd_connections, nb_bt->logical_port,\n                                nb_bt->dst_ip);\n        ovs_mutex_lock(&bfd_lock);\n        if (bfd_e) {\n            bfd_e->ref = true;\n        }\n\n        if (!strcmp(nb_bt->status, \"admin_down\")) {\n            nbrec_bfd_set_status(nb_bt, \"down\");\n        }\n\n        if (!strcmp(nb_bt->status, \"down\")) {\n            ovs_mutex_unlock(&bfd_lock);\n            return NULL;\n        }\n        ovs_mutex_unlock(&bfd_lock);\n    }\n\n    struct parsed_route *pr = xzalloc(sizeof *pr);\n    pr->prefix = prefix;\n    pr->plen = plen;\n    pr->route_table_id = get_route_table_id(route_tables, route->route_table);\n    pr->is_src_route = (route->policy && !strcmp(route->policy,\n                                                 \"src-ip\"));\n    pr->hash = route_hash(pr);\n    pr->route = route;\n    pr->ecmp_symmetric_reply = smap_get_bool(&route->options,\n                                             \"ecmp_symmetric_reply\", false);\n    pr->is_discard_route = is_discard_route;\n    ovs_list_insert(routes, &pr->list_node);\n    return pr;\n}\n\nstatic void\nparsed_routes_destroy(struct ovs_list *routes)\n{\n    struct parsed_route *pr;\n    LIST_FOR_EACH_SAFE (pr, list_node, routes) {\n        ovs_list_remove(&pr->list_node);\n        free(pr);\n    }\n}\n\nstruct ecmp_route_list_node {\n    struct ovs_list list_node;\n    uint16_t id; /* starts from 1 */\n    const struct parsed_route *route;\n};\n\nstruct ecmp_groups_node {\n    struct hmap_node hmap_node; /* In ecmp_groups */\n    uint16_t id; /* starts from 1 */\n    struct in6_addr prefix;\n    unsigned int plen;\n    bool is_src_route;\n    const char *origin;\n    uint32_t route_table_id;\n    uint16_t route_count;\n    struct ovs_list route_list; /* Contains ecmp_route_list_node */\n};\n\nstatic void\necmp_groups_add_route(struct ecmp_groups_node *group,\n                      const struct parsed_route *route)\n{\n    if (group->route_count == UINT16_MAX) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"too many routes in a single ecmp group.\");\n        return;\n    }\n\n    struct ecmp_route_list_node *er = xmalloc(sizeof *er);\n    er->route = route;\n    er->id = ++group->route_count;\n    ovs_list_insert(&group->route_list, &er->list_node);\n}\n\nstatic struct ecmp_groups_node *\necmp_groups_add(struct hmap *ecmp_groups,\n                const struct parsed_route *route)\n{\n    if (hmap_count(ecmp_groups) == UINT16_MAX) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"too many ecmp groups.\");\n        return NULL;\n    }\n\n    struct ecmp_groups_node *eg = xzalloc(sizeof *eg);\n    hmap_insert(ecmp_groups, &eg->hmap_node, route->hash);\n\n    eg->id = hmap_count(ecmp_groups);\n    eg->prefix = route->prefix;\n    eg->plen = route->plen;\n    eg->is_src_route = route->is_src_route;\n    eg->origin = smap_get_def(&route->route->options, \"origin\", \"\");\n    eg->route_table_id = route->route_table_id;\n    ovs_list_init(&eg->route_list);\n    ecmp_groups_add_route(eg, route);\n\n    return eg;\n}\n\nstatic struct ecmp_groups_node *\necmp_groups_find(struct hmap *ecmp_groups, struct parsed_route *route)\n{\n    struct ecmp_groups_node *eg;\n    HMAP_FOR_EACH_WITH_HASH (eg, hmap_node, route->hash, ecmp_groups) {\n        if (ipv6_addr_equals(&eg->prefix, &route->prefix) &&\n            eg->plen == route->plen &&\n            eg->is_src_route == route->is_src_route &&\n            eg->route_table_id == route->route_table_id) {\n            return eg;\n        }\n    }\n    return NULL;\n}\n\nstatic void\necmp_groups_destroy(struct hmap *ecmp_groups)\n{\n    struct ecmp_groups_node *eg;\n    HMAP_FOR_EACH_SAFE (eg, hmap_node, ecmp_groups) {\n        struct ecmp_route_list_node *er;\n        LIST_FOR_EACH_SAFE (er, list_node, &eg->route_list) {\n            ovs_list_remove(&er->list_node);\n            free(er);\n        }\n        hmap_remove(ecmp_groups, &eg->hmap_node);\n        free(eg);\n    }\n    hmap_destroy(ecmp_groups);\n}\n\nstruct unique_routes_node {\n    struct hmap_node hmap_node;\n    const struct parsed_route *route;\n};\n\nstatic void\nunique_routes_add(struct hmap *unique_routes,\n                  const struct parsed_route *route)\n{\n    struct unique_routes_node *ur = xmalloc(sizeof *ur);\n    ur->route = route;\n    hmap_insert(unique_routes, &ur->hmap_node, route->hash);\n}\n\n/* Remove the unique_routes_node from the hmap, and return the parsed_route\n * pointed by the removed node. */\nstatic const struct parsed_route *\nunique_routes_remove(struct hmap *unique_routes,\n                     const struct parsed_route *route)\n{\n    struct unique_routes_node *ur;\n    HMAP_FOR_EACH_WITH_HASH (ur, hmap_node, route->hash, unique_routes) {\n        if (ipv6_addr_equals(&route->prefix, &ur->route->prefix) &&\n            route->plen == ur->route->plen &&\n            route->is_src_route == ur->route->is_src_route &&\n            route->route_table_id == ur->route->route_table_id) {\n            hmap_remove(unique_routes, &ur->hmap_node);\n            const struct parsed_route *existed_route = ur->route;\n            free(ur);\n            return existed_route;\n        }\n    }\n    return NULL;\n}\n\nstatic void\nunique_routes_destroy(struct hmap *unique_routes)\n{\n    struct unique_routes_node *ur;\n    HMAP_FOR_EACH_SAFE (ur, hmap_node, unique_routes) {\n        hmap_remove(unique_routes, &ur->hmap_node);\n        free(ur);\n    }\n    hmap_destroy(unique_routes);\n}\n\nstatic char *\nbuild_route_prefix_s(const struct in6_addr *prefix, unsigned int plen)\n{\n    char *prefix_s;\n    if (IN6_IS_ADDR_V4MAPPED(prefix)) {\n        prefix_s = xasprintf(IP_FMT, IP_ARGS(in6_addr_get_mapped_ipv4(prefix) &\n                                             be32_prefix_mask(plen)));\n    } else {\n        struct in6_addr mask = ipv6_create_mask(plen);\n        struct in6_addr network = ipv6_addr_bitand(prefix, &mask);\n        prefix_s = xmalloc(INET6_ADDRSTRLEN);\n        inet_ntop(AF_INET6, &network, prefix_s, INET6_ADDRSTRLEN);\n    }\n    return prefix_s;\n}\n\nstatic void\nbuild_route_match(const struct ovn_port *op_inport, uint32_t rtb_id,\n                  const char *network_s, int plen, bool is_src_route,\n                  bool is_ipv4, struct ds *match, uint16_t *priority, int ofs)\n{\n    const char *dir;\n    /* The priority here is calculated to implement longest-prefix-match\n     * routing. */\n    if (is_src_route) {\n        dir = \"src\";\n        ofs = 0;\n    } else {\n        dir = \"dst\";\n    }\n\n    *priority = (plen * ROUTE_PRIO_OFFSET_MULTIPLIER) + ofs;\n\n    if (op_inport) {\n        ds_put_format(match, \"inport == %s && \", op_inport->json_key);\n    }\n    if (rtb_id || ofs == ROUTE_PRIO_OFFSET_STATIC) {\n        ds_put_format(match, \"%s == %d && \", REG_ROUTE_TABLE_ID, rtb_id);\n    }\n    ds_put_format(match, \"ip%s.%s == %s/%d\", is_ipv4 ? \"4\" : \"6\", dir,\n                  network_s, plen);\n}\n\n/* Output: p_lrp_addr_s and p_out_port. */\nstatic bool\nfind_static_route_outport(struct ovn_datapath *od, const struct hmap *ports,\n    const struct nbrec_logical_router_static_route *route, bool is_ipv4,\n    const char **p_lrp_addr_s, struct ovn_port **p_out_port)\n{\n    const char *lrp_addr_s = NULL;\n    struct ovn_port *out_port = NULL;\n    if (route->output_port) {\n        out_port = ovn_port_find(ports, route->output_port);\n        if (!out_port) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"Bad out port %s for static route %s\",\n                         route->output_port, route->ip_prefix);\n            return false;\n        }\n        if (route->nexthop[0]) {\n            lrp_addr_s = find_lrp_member_ip(out_port, route->nexthop);\n        }\n        if (!lrp_addr_s) {\n            /* There are no IP networks configured on the router's port via\n             * which 'route->nexthop' is theoretically reachable.  But since\n             * 'out_port' has been specified, we honor it by trying to reach\n             * 'route->nexthop' via the first IP address of 'out_port'.\n             * (There are cases, e.g in GCE, where each VM gets a /32 IP\n             * address and the default gateway is still reachable from it.) */\n            if (is_ipv4) {\n                if (out_port->lrp_networks.n_ipv4_addrs) {\n                    lrp_addr_s = out_port->lrp_networks.ipv4_addrs[0].addr_s;\n                }\n            } else {\n                if (out_port->lrp_networks.n_ipv6_addrs) {\n                    lrp_addr_s = out_port->lrp_networks.ipv6_addrs[0].addr_s;\n                }\n            }\n        }\n    } else {\n        /* output_port is not specified, find the\n         * router port matching the next hop. */\n        int i;\n        for (i = 0; i < od->nbr->n_ports; i++) {\n            struct nbrec_logical_router_port *lrp = od->nbr->ports[i];\n            out_port = ovn_port_find(ports, lrp->name);\n            if (!out_port) {\n                /* This should not happen. */\n                continue;\n            }\n\n            if (route->nexthop[0]) {\n                lrp_addr_s = find_lrp_member_ip(out_port, route->nexthop);\n            }\n            if (lrp_addr_s) {\n                break;\n            }\n        }\n    }\n    if (!out_port || !lrp_addr_s) {\n        /* There is no matched out port. */\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"No path for static route %s; next hop %s\",\n                     route->ip_prefix, route->nexthop);\n        return false;\n    }\n    if (p_out_port) {\n        *p_out_port = out_port;\n    }\n    if (p_lrp_addr_s) {\n        *p_lrp_addr_s = lrp_addr_s;\n    }\n\n    return true;\n}\n\nstatic void\nadd_ecmp_symmetric_reply_flows(struct hmap *lflows,\n                               struct ovn_datapath *od,\n                               bool ct_masked_mark,\n                               const char *port_ip,\n                               struct ovn_port *out_port,\n                               const struct parsed_route *route,\n                               struct ds *route_match)\n{\n    const struct nbrec_logical_router_static_route *st_route = route->route;\n    struct ds base_match = DS_EMPTY_INITIALIZER;\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n    struct ds ecmp_reply = DS_EMPTY_INITIALIZER;\n    char *cidr = normalize_v46_prefix(&route->prefix, route->plen);\n    const char *ct_ecmp_reply_port_match = ct_masked_mark\n                                           ? \"ct_mark.ecmp_reply_port\"\n                                           : \"ct_label.ecmp_reply_port\";\n\n    /* If symmetric ECMP replies are enabled, then packets that arrive over\n     * an ECMP route need to go through conntrack.\n     */\n    ds_put_format(&base_match, \"inport == %s && ip%s.%s == %s\",\n                  out_port->json_key,\n                  IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"4\" : \"6\",\n                  route->is_src_route ? \"dst\" : \"src\",\n                  cidr);\n    free(cidr);\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_DEFRAG, 100,\n            ds_cstr(&base_match),\n            REGBIT_KNOWN_ECMP_NH\" = chk_ecmp_nh_mac(); ct_next;\",\n            &st_route->header_);\n\n    /* And packets that go out over an ECMP route need conntrack */\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_DEFRAG, 100,\n            ds_cstr(route_match),\n            REGBIT_KNOWN_ECMP_NH\" = chk_ecmp_nh(); ct_next;\",\n            &st_route->header_);\n\n    /* Save src eth and inport in ct_label for packets that arrive over\n     * an ECMP route.\n     *\n     * NOTE: we purposely are not clearing match before this\n     * ds_put_cstr() call. The previous contents are needed.\n     */\n    ds_put_format(&match, \"%s && (ct.new && !ct.est) && tcp\",\n                  ds_cstr(&base_match));\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = tcp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n    ds_clear(&match);\n    ds_put_format(&match, \"%s && (ct.new && !ct.est) && udp\",\n                  ds_cstr(&base_match));\n    ds_clear(&actions);\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = udp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n    ds_clear(&match);\n    ds_put_format(&match, \"%s && (ct.new && !ct.est) && sctp\",\n                  ds_cstr(&base_match));\n    ds_clear(&actions);\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = sctp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n\n    ds_clear(&match);\n    ds_put_format(&match,\n            \"%s && (!ct.rpl && ct.est) && tcp && \"REGBIT_KNOWN_ECMP_NH\" == 0\",\n            ds_cstr(&base_match));\n    ds_clear(&actions);\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = tcp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n\n    ds_clear(&match);\n    ds_put_format(&match,\n            \"%s && (!ct.rpl && ct.est) && udp && \"REGBIT_KNOWN_ECMP_NH\" == 0\",\n            ds_cstr(&base_match));\n    ds_clear(&actions);\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = udp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n    ds_clear(&match);\n    ds_put_format(&match,\n            \"%s && (!ct.rpl && ct.est) && sctp && \"REGBIT_KNOWN_ECMP_NH\" == 0\",\n            ds_cstr(&base_match));\n    ds_clear(&actions);\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = sctp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n\n    /* Bypass ECMP selection if we already have ct_label information\n     * for where to route the packet.\n     */\n    ds_put_format(&ecmp_reply,\n                  \"ct.rpl && \"REGBIT_KNOWN_ECMP_NH\" == 1 && %s == %\"PRId64,\n                  ct_ecmp_reply_port_match, out_port->sb->tunnel_key);\n    ds_clear(&match);\n    ds_put_format(&match, \"%s && %s\", ds_cstr(&ecmp_reply),\n                  ds_cstr(route_match));\n    ds_clear(&actions);\n    ds_put_format(&actions, \"ip.ttl--; flags.loopback = 1; \"\n                  \"eth.src = %s; %sreg1 = %s; outport = %s; next;\",\n                  out_port->lrp_networks.ea_s,\n                  IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"\" : \"xx\",\n                  port_ip, out_port->json_key);\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_ROUTING, 10300,\n                           ds_cstr(&match), ds_cstr(&actions),\n                           &st_route->header_);\n\n    /* Egress reply traffic for symmetric ECMP routes skips router policies. */\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_POLICY, 65535,\n                            ds_cstr(&ecmp_reply), \"next;\",\n                            &st_route->header_);\n\n    /* Use REG_ECMP_ETH_FULL to pass the eth field from ct_label to eth.dst to\n     * avoid masked access to ct_label. Otherwise it may prevent OVS flow\n     * HW offloading to work for some NICs because masked-access of ct_label is\n     * not supported on those NICs due to HW limitations.\n     *\n     * Use push/pop to save the value of the register before using it and\n     * restore it immediately afterwards, so that the use of the register is\n     * temporary and doesn't interfere with other stages. */\n    const char *action = \"push(\" REG_ECMP_ETH_FULL \"); \"\n                         REG_ECMP_ETH_FULL \" = ct_label;\"\n                         \" eth.dst = \" REG_ECMP_ETH_FIELD \";\"\n                         \" pop(\" REG_ECMP_ETH_FULL \"); next;\";\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ARP_RESOLVE,\n                            200, ds_cstr(&ecmp_reply),\n                            action, &st_route->header_);\n\n    ds_destroy(&base_match);\n    ds_destroy(&match);\n    ds_destroy(&actions);\n    ds_destroy(&ecmp_reply);\n}\n\nstatic void\nbuild_ecmp_route_flow(struct hmap *lflows, struct ovn_datapath *od,\n                      bool ct_masked_mark, const struct hmap *ports,\n                      struct ecmp_groups_node *eg)\n\n{\n    bool is_ipv4 = IN6_IS_ADDR_V4MAPPED(&eg->prefix);\n    uint16_t priority;\n    struct ecmp_route_list_node *er;\n    struct ds route_match = DS_EMPTY_INITIALIZER;\n\n    char *prefix_s = build_route_prefix_s(&eg->prefix, eg->plen);\n    int ofs = !strcmp(eg->origin, ROUTE_ORIGIN_CONNECTED) ?\n        ROUTE_PRIO_OFFSET_CONNECTED: ROUTE_PRIO_OFFSET_STATIC;\n    build_route_match(NULL, eg->route_table_id, prefix_s, eg->plen,\n                      eg->is_src_route, is_ipv4, &route_match, &priority, ofs);\n    free(prefix_s);\n\n    struct ds actions = DS_EMPTY_INITIALIZER;\n    ds_put_format(&actions, \"ip.ttl--; flags.loopback = 1; %s = %\"PRIu16\n                  \"; %s = select(\", REG_ECMP_GROUP_ID, eg->id,\n                  REG_ECMP_MEMBER_ID);\n\n    bool is_first = true;\n    LIST_FOR_EACH (er, list_node, &eg->route_list) {\n        if (is_first) {\n            is_first = false;\n        } else {\n            ds_put_cstr(&actions, \", \");\n        }\n        ds_put_format(&actions, \"%\"PRIu16, er->id);\n    }\n\n    ds_put_cstr(&actions, \");\");\n\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, priority,\n                  ds_cstr(&route_match), ds_cstr(&actions));\n\n    /* Add per member flow */\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct sset visited_ports = SSET_INITIALIZER(&visited_ports);\n    LIST_FOR_EACH (er, list_node, &eg->route_list) {\n        const struct parsed_route *route_ = er->route;\n        const struct nbrec_logical_router_static_route *route = route_->route;\n        /* Find the outgoing port. */\n        const char *lrp_addr_s = NULL;\n        struct ovn_port *out_port = NULL;\n        if (!find_static_route_outport(od, ports, route, is_ipv4, &lrp_addr_s,\n                                       &out_port)) {\n            continue;\n        }\n        /* Symmetric ECMP reply is only usable on gateway routers.\n         * It is NOT usable on distributed routers with a gateway port.\n         */\n        if (smap_get(&od->nbr->options, \"chassis\") &&\n            route_->ecmp_symmetric_reply && sset_add(&visited_ports,\n                                                     out_port->key)) {\n            add_ecmp_symmetric_reply_flows(lflows, od, ct_masked_mark,\n                                           lrp_addr_s, out_port,\n                                           route_, &route_match);\n        }\n        ds_clear(&match);\n        ds_put_format(&match, REG_ECMP_GROUP_ID\" == %\"PRIu16\" && \"\n                      REG_ECMP_MEMBER_ID\" == %\"PRIu16,\n                      eg->id, er->id);\n        ds_clear(&actions);\n        ds_put_format(&actions, \"%s = %s; \"\n                      \"%s = %s; \"\n                      \"eth.src = %s; \"\n                      \"outport = %s; \"\n                      \"next;\",\n                      is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6,\n                      route->nexthop,\n                      is_ipv4 ? REG_SRC_IPV4 : REG_SRC_IPV6,\n                      lrp_addr_s,\n                      out_port->lrp_networks.ea_s,\n                      out_port->json_key);\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_ROUTING_ECMP, 100,\n                                ds_cstr(&match), ds_cstr(&actions),\n                                &route->header_);\n    }\n    sset_destroy(&visited_ports);\n    ds_destroy(&match);\n    ds_destroy(&route_match);\n    ds_destroy(&actions);\n}\n\nstatic void\nadd_route(struct hmap *lflows, struct ovn_datapath *od,\n          const struct ovn_port *op, const char *lrp_addr_s,\n          const char *network_s, int plen, const char *gateway,\n          bool is_src_route, const uint32_t rtb_id,\n          const struct ovsdb_idl_row *stage_hint, bool is_discard_route,\n          int ofs)\n{\n    bool is_ipv4 = strchr(network_s, '.') ? true : false;\n    struct ds match = DS_EMPTY_INITIALIZER;\n    uint16_t priority;\n    const struct ovn_port *op_inport = NULL;\n\n    /* IPv6 link-local addresses must be scoped to the local router port. */\n    if (!is_ipv4) {\n        struct in6_addr network;\n        ovs_assert(ipv6_parse(network_s, &network));\n        if (in6_is_lla(&network)) {\n            op_inport = op;\n        }\n    }\n    build_route_match(op_inport, rtb_id, network_s, plen, is_src_route,\n                      is_ipv4, &match, &priority, ofs);\n\n    struct ds common_actions = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n    if (is_discard_route) {\n        ds_put_cstr(&actions, debug_drop_action());\n    } else {\n        ds_put_format(&common_actions, REG_ECMP_GROUP_ID\" = 0; %s = \",\n                      is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6);\n        if (gateway && gateway[0]) {\n            ds_put_cstr(&common_actions, gateway);\n        } else {\n            ds_put_format(&common_actions, \"ip%s.dst\", is_ipv4 ? \"4\" : \"6\");\n        }\n        ds_put_format(&common_actions, \"; \"\n                      \"%s = %s; \"\n                      \"eth.src = %s; \"\n                      \"outport = %s; \"\n                      \"flags.loopback = 1; \"\n                      \"next;\",\n                      is_ipv4 ? REG_SRC_IPV4 : REG_SRC_IPV6,\n                      lrp_addr_s,\n                      op->lrp_networks.ea_s,\n                      op->json_key);\n        ds_put_format(&actions, \"ip.ttl--; %s\", ds_cstr(&common_actions));\n    }\n\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_ROUTING, priority,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            stage_hint);\n    if (op && op->has_bfd) {\n        ds_put_format(&match, \" && udp.dst == 3784\");\n        ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_ROUTING,\n                                priority + 1, ds_cstr(&match),\n                                ds_cstr(&common_actions), stage_hint);\n    }\n    ds_destroy(&match);\n    ds_destroy(&common_actions);\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_static_route_flow(struct hmap *lflows, struct ovn_datapath *od,\n                        const struct hmap *ports,\n                        const struct parsed_route *route_)\n{\n    const char *lrp_addr_s = NULL;\n    struct ovn_port *out_port = NULL;\n\n    const struct nbrec_logical_router_static_route *route = route_->route;\n\n    /* Find the outgoing port. */\n    if (!route_->is_discard_route) {\n        if (!find_static_route_outport(od, ports, route,\n                                       IN6_IS_ADDR_V4MAPPED(&route_->prefix),\n                                       &lrp_addr_s, &out_port)) {\n            return;\n        }\n    }\n\n    int ofs = !strcmp(smap_get_def(&route->options, \"origin\", \"\"),\n                      ROUTE_ORIGIN_CONNECTED) ? ROUTE_PRIO_OFFSET_CONNECTED\n                                              : ROUTE_PRIO_OFFSET_STATIC;\n\n    char *prefix_s = build_route_prefix_s(&route_->prefix, route_->plen);\n    add_route(lflows, route_->is_discard_route ? od : out_port->od, out_port,\n              lrp_addr_s, prefix_s, route_->plen, route->nexthop,\n              route_->is_src_route, route_->route_table_id, &route->header_,\n              route_->is_discard_route, ofs);\n\n    free(prefix_s);\n}\n\nstatic void\nop_put_v4_networks(struct ds *ds, const struct ovn_port *op, bool add_bcast)\n{\n    if (!add_bcast && op->lrp_networks.n_ipv4_addrs == 1) {\n        ds_put_format(ds, \"%s\", op->lrp_networks.ipv4_addrs[0].addr_s);\n        return;\n    }\n\n    ds_put_cstr(ds, \"{\");\n    for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n        ds_put_format(ds, \"%s, \", op->lrp_networks.ipv4_addrs[i].addr_s);\n        if (add_bcast) {\n            ds_put_format(ds, \"%s, \", op->lrp_networks.ipv4_addrs[i].bcast_s);\n        }\n    }\n    ds_chomp(ds, ' ');\n    ds_chomp(ds, ',');\n    ds_put_cstr(ds, \"}\");\n}\n\nstatic void\nop_put_v6_networks(struct ds *ds, const struct ovn_port *op)\n{\n    if (op->lrp_networks.n_ipv6_addrs == 1) {\n        ds_put_format(ds, \"%s\", op->lrp_networks.ipv6_addrs[0].addr_s);\n        return;\n    }\n\n    ds_put_cstr(ds, \"{\");\n    for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n        ds_put_format(ds, \"%s, \", op->lrp_networks.ipv6_addrs[i].addr_s);\n    }\n    ds_chomp(ds, ' ');\n    ds_chomp(ds, ',');\n    ds_put_cstr(ds, \"}\");\n}\n\nstatic bool\nget_force_snat_ip(struct ovn_datapath *od, const char *key_type,\n                  struct lport_addresses *laddrs)\n{\n    char *key = xasprintf(\"%s_force_snat_ip\", key_type);\n    const char *addresses = smap_get(&od->nbr->options, key);\n    free(key);\n\n    if (!addresses) {\n        return false;\n    }\n\n    if (!extract_ip_address(addresses, laddrs)) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"bad ip %s in options of router \"UUID_FMT\"\",\n                     addresses, UUID_ARGS(&od->key));\n        return false;\n    }\n\n    return true;\n}\n\nenum lrouter_nat_lb_flow_type {\n    LROUTER_NAT_LB_FLOW_NORMAL = 0,\n    LROUTER_NAT_LB_FLOW_SKIP_SNAT,\n    LROUTER_NAT_LB_FLOW_FORCE_SNAT,\n    LROUTER_NAT_LB_FLOW_MAX,\n};\n\nstruct lrouter_nat_lb_flows_ctx {\n    const char *new_action[LROUTER_NAT_LB_FLOW_MAX];\n\n    struct ds *new_match;\n    struct ds *undnat_match;\n\n    struct ovn_lb_vip *lb_vip;\n    struct ovn_northd_lb *lb;\n    bool reject;\n\n    int prio;\n\n    struct hmap *lflows;\n    const struct shash *meter_groups;\n};\n\nstatic void\nbuild_distr_lrouter_nat_flows_for_lb(struct lrouter_nat_lb_flows_ctx *ctx,\n                                     enum lrouter_nat_lb_flow_type type,\n                                     struct ovn_datapath *od)\n{\n    const char *undnat_action;\n\n    switch (type) {\n    case LROUTER_NAT_LB_FLOW_FORCE_SNAT:\n        undnat_action = \"flags.force_snat_for_lb = 1; next;\";\n        break;\n    case LROUTER_NAT_LB_FLOW_SKIP_SNAT:\n        undnat_action = \"flags.skip_snat_for_lb = 1; next;\";\n        break;\n    case LROUTER_NAT_LB_FLOW_NORMAL:\n    case LROUTER_NAT_LB_FLOW_MAX:\n        undnat_action = od->is_gw_router ? \"ct_dnat;\" : \"ct_dnat_in_czone;\";\n        break;\n    }\n    /* Store the match lengths, so we can reuse the ds buffer. */\n    size_t new_match_len = ctx->new_match->length;\n    size_t undnat_match_len = ctx->undnat_match->length;\n\n\n    const char *meter = NULL;\n\n    if (ctx->reject) {\n        meter = copp_meter_get(COPP_REJECT, od->nbr->copp, ctx->meter_groups);\n    }\n\n    if (ctx->lb_vip->n_backends || !ctx->lb_vip->empty_backend_rej) {\n        ds_put_format(ctx->new_match, \" && is_chassis_resident(%s)\",\n                      od->l3dgw_ports[0]->cr_port->json_key);\n    }\n\n    ovn_lflow_add_with_hint__(ctx->lflows, od, S_ROUTER_IN_DNAT, ctx->prio,\n                              ds_cstr(ctx->new_match), ctx->new_action[type],\n                              NULL, meter, &ctx->lb->nlb->header_);\n\n    ds_truncate(ctx->new_match, new_match_len);\n\n    if (!ctx->lb_vip->n_backends) {\n        return;\n    }\n\n    ds_put_format(ctx->undnat_match,\n                  \") && outport == %s && is_chassis_resident(%s)\",\n                  od->l3dgw_ports[0]->json_key,\n                  od->l3dgw_ports[0]->cr_port->json_key);\n    ovn_lflow_add_with_hint(ctx->lflows, od, S_ROUTER_OUT_UNDNAT, 120,\n                            ds_cstr(ctx->undnat_match), undnat_action,\n                            &ctx->lb->nlb->header_);\n    ds_truncate(ctx->undnat_match, undnat_match_len);\n}\n\nstatic void\nbuild_gw_lrouter_nat_flows_for_lb(struct lrouter_nat_lb_flows_ctx *ctx,\n                                  enum lrouter_nat_lb_flow_type type,\n                                  const unsigned long *dp_bitmap)\n{\n    unsigned long *dp_non_meter = NULL;\n    bool build_non_meter = false;\n    size_t index;\n\n    if (bitmap_is_all_zeros(dp_bitmap, n_datapaths)) {\n        return;\n    }\n\n    if (ctx->reject) {\n        dp_non_meter = bitmap_clone(dp_bitmap, n_datapaths);\n        BITMAP_FOR_EACH_1 (index, n_datapaths, dp_bitmap) {\n            struct ovn_datapath *od = datapaths_array[index];\n            const char *meter;\n\n            meter = copp_meter_get(COPP_REJECT, od->nbr->copp,\n                                   ctx->meter_groups);\n            if (!meter) {\n                build_non_meter = true;\n                continue;\n            }\n            bitmap_set0(dp_non_meter, index);\n            ovn_lflow_add_with_hint__(ctx->lflows, od, S_ROUTER_IN_DNAT,\n                    ctx->prio, ds_cstr(ctx->new_match), ctx->new_action[type],\n                    NULL, meter, &ctx->lb->nlb->header_);\n        }\n    }\n    if (!ctx->reject || build_non_meter) {\n        ovn_lflow_add_with_dp_group(ctx->lflows,\n            dp_non_meter ? dp_non_meter : dp_bitmap,\n            S_ROUTER_IN_DNAT, ctx->prio, ds_cstr(ctx->new_match),\n            ctx->new_action[type], &ctx->lb->nlb->header_);\n    }\n    bitmap_free(dp_non_meter);\n}\n\nstatic void\nbuild_lrouter_nat_flows_for_lb(struct ovn_lb_vip *lb_vip,\n                               struct ovn_northd_lb *lb,\n                               struct ovn_northd_lb_vip *vips_nb,\n                               struct hmap *lflows,\n                               struct ds *match, struct ds *action,\n                               const struct shash *meter_groups,\n                               const struct chassis_features *features)\n{\n    bool ipv4 = lb_vip->address_family == AF_INET;\n    const char *ip_match = ipv4 ? \"ip4\" : \"ip6\";\n\n    int prio = 110;\n\n    struct ds skip_snat_act = DS_EMPTY_INITIALIZER;\n    struct ds force_snat_act = DS_EMPTY_INITIALIZER;\n    struct ds undnat_match = DS_EMPTY_INITIALIZER;\n    struct ds unsnat_match = DS_EMPTY_INITIALIZER;\n\n    ds_clear(match);\n    ds_clear(action);\n\n    bool reject = build_lb_vip_actions(lb_vip, vips_nb, action,\n                                       lb->selection_fields, &skip_snat_act,\n                                       &force_snat_act, false, features);\n\n    /* Higher priority rules are added for load-balancing in DNAT\n     * table.  For every match (on a VIP[:port]), we add two flows.\n     * One flow is for specific matching on ct.new with an action\n     * of \"ct_lb_mark($targets);\". The other flow is for ct.est with\n     * an action of \"next;\".\n     */\n    ds_put_format(match, \"ct.new && !ct.rel && %s && %s.dst == %s\",\n                  ip_match, ip_match, lb_vip->vip_str);\n    if (lb_vip->port_str) {\n        prio = 120;\n        ds_put_format(match, \" && %s && %s.dst == %s\",\n                      lb->proto, lb->proto, lb_vip->port_str);\n    }\n\n    /* Add logical flows to UNDNAT the load balanced reverse traffic in\n     * the router egress pipleine stage - S_ROUTER_OUT_UNDNAT if the logical\n     * router has a gateway router port associated.\n     */\n    ds_put_format(&undnat_match, \"%s && (\", ip_match);\n\n    for (size_t i = 0; i < lb_vip->n_backends; i++) {\n        struct ovn_lb_backend *backend = &lb_vip->backends[i];\n        ds_put_format(&undnat_match, \"(%s.src == %s\", ip_match,\n                      backend->ip_str);\n\n        if (backend->port_str) {\n            ds_put_format(&undnat_match, \" && %s.src == %s) || \",\n                          lb->proto, backend->port_str);\n        } else {\n            ds_put_cstr(&undnat_match, \") || \");\n        }\n    }\n    /* Remove the trailing \" || \". */\n    ds_truncate(&undnat_match, undnat_match.length - 4);\n\n    ds_put_format(&unsnat_match, \"%s && %s.dst == %s && %s\",\n                  ip_match, ip_match, lb_vip->vip_str, lb->proto);\n    if (lb_vip->port_str) {\n        ds_put_format(&unsnat_match, \" && %s.dst == %s\", lb->proto,\n                      lb_vip->port_str);\n    }\n\n    struct lrouter_nat_lb_flows_ctx ctx = {\n        .lb_vip = lb_vip,\n        .lb = lb,\n        .reject = reject,\n        .prio = prio,\n        .lflows = lflows,\n        .meter_groups = meter_groups,\n        .new_match = match,\n        .undnat_match = &undnat_match\n    };\n\n    ctx.new_action[LROUTER_NAT_LB_FLOW_NORMAL] = ds_cstr(action);\n    ctx.new_action[LROUTER_NAT_LB_FLOW_SKIP_SNAT] = ds_cstr(&skip_snat_act);\n    ctx.new_action[LROUTER_NAT_LB_FLOW_FORCE_SNAT] = ds_cstr(&force_snat_act);\n\n    enum {\n        LROUTER_NAT_LB_AFF            = LROUTER_NAT_LB_FLOW_MAX,\n        LROUTER_NAT_LB_AFF_FORCE_SNAT = LROUTER_NAT_LB_FLOW_MAX + 1,\n    };\n    unsigned long *dp_bitmap[LROUTER_NAT_LB_FLOW_MAX + 2];\n\n    for (size_t i = 0; i < LROUTER_NAT_LB_FLOW_MAX + 2; i++) {\n        dp_bitmap[i] = bitmap_allocate(n_datapaths);\n    }\n\n    /* Group gw router since we do not have datapath dependency in\n     * lflow generation for them.\n     */\n    size_t index;\n    BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {\n        struct ovn_datapath *od = datapaths_array[index];\n        enum lrouter_nat_lb_flow_type type;\n\n        if (lb->skip_snat) {\n            type = LROUTER_NAT_LB_FLOW_SKIP_SNAT;\n        } else if (!lport_addresses_is_empty(&od->lb_force_snat_addrs) ||\n                   od->lb_force_snat_router_ip) {\n            type = LROUTER_NAT_LB_FLOW_FORCE_SNAT;\n        } else {\n            type = LROUTER_NAT_LB_FLOW_NORMAL;\n        }\n\n        if (!od->n_l3dgw_ports) {\n            bitmap_set1(dp_bitmap[type], index);\n        } else {\n            build_distr_lrouter_nat_flows_for_lb(&ctx, type, od);\n        }\n\n        if (lb->affinity_timeout) {\n            if (!lport_addresses_is_empty(&od->lb_force_snat_addrs) ||\n                od->lb_force_snat_router_ip) {\n                bitmap_set1(dp_bitmap[LROUTER_NAT_LB_AFF_FORCE_SNAT], index);\n            } else {\n                bitmap_set1(dp_bitmap[LROUTER_NAT_LB_AFF], index);\n            }\n        }\n\n        if (sset_contains(&od->external_ips, lb_vip->vip_str)) {\n            /* The load balancer vip is also present in the NAT entries.\n             * So add a high priority lflow to advance the the packet\n             * destined to the vip (and the vip port if defined)\n             * in the S_ROUTER_IN_UNSNAT stage.\n             * There seems to be an issue with ovs-vswitchd. When the new\n             * connection packet destined for the lb vip is received,\n             * it is dnat'ed in the S_ROUTER_IN_DNAT stage in the dnat\n             * conntrack zone. For the next packet, if it goes through\n             * unsnat stage, the conntrack flags are not set properly, and\n             * it doesn't hit the established state flows in\n             * S_ROUTER_IN_DNAT stage. */\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT, 120,\n                                    ds_cstr(&unsnat_match), \"next;\",\n                                    &lb->nlb->header_);\n        }\n    }\n\n    for (size_t type = 0; type < LROUTER_NAT_LB_FLOW_MAX; type++) {\n        build_gw_lrouter_nat_flows_for_lb(&ctx, type, dp_bitmap[type]);\n    }\n\n    /* LB affinity flows for datapaths where CMS has specified\n     * force_snat_for_lb floag option.\n     */\n    build_lb_affinity_lr_flows(lflows, lb, lb_vip, ds_cstr(match),\n                               \"flags.force_snat_for_lb = 1; \",\n                               dp_bitmap[LROUTER_NAT_LB_AFF_FORCE_SNAT]);\n\n    /* LB affinity flows for datapaths where CMS has specified\n     * skip_snat_for_lb floag option or regular datapaths.\n     */\n    char *lb_aff_action =\n        lb->skip_snat ? \"flags.skip_snat_for_lb = 1; \" : NULL;\n    build_lb_affinity_lr_flows(lflows, lb, lb_vip, ds_cstr(match),\n                               lb_aff_action, dp_bitmap[LROUTER_NAT_LB_AFF]);\n\n    ds_destroy(&unsnat_match);\n    ds_destroy(&undnat_match);\n    ds_destroy(&skip_snat_act);\n    ds_destroy(&force_snat_act);\n\n    for (size_t i = 0; i < LROUTER_NAT_LB_FLOW_MAX + 2; i++) {\n        bitmap_free(dp_bitmap[i]);\n    }\n}\n\nstatic void\nbuild_lswitch_flows_for_lb(struct ovn_northd_lb *lb, struct hmap *lflows,\n                           const struct shash *meter_groups,\n                           const struct chassis_features *features,\n                           struct ds *match, struct ds *action)\n{\n    if (!lb->n_nb_ls) {\n        return;\n    }\n\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n\n        /* pre-stateful lb */\n        if (!build_empty_lb_event_flow(lb_vip, lb, match, action)) {\n            continue;\n        }\n\n        size_t index;\n        BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_ls_map) {\n            struct ovn_datapath *od = datapaths_array[index];\n\n            ovn_lflow_add_with_hint__(lflows, od,\n                                      S_SWITCH_IN_PRE_LB, 130, ds_cstr(match),\n                                      ds_cstr(action),\n                                      NULL,\n                                      copp_meter_get(COPP_EVENT_ELB,\n                                                     od->nbs->copp,\n                                                     meter_groups),\n                                      &lb->nlb->header_);\n        }\n        /* Ignore L4 port information in the key because fragmented packets\n         * may not have L4 information.  The pre-stateful table will send\n         * the packet through ct() action to de-fragment. In stateful\n         * table, we will eventually look at L4 information. */\n    }\n\n    /* stateful lb\n     * Load balancing rules for new connections get committed to conntrack\n     * table.  So even if REGBIT_CONNTRACK_COMMIT is set in a previous table\n     * a higher priority rule for load balancing below also commits the\n     * connection, so it is okay if we do not hit the above match on\n     * REGBIT_CONNTRACK_COMMIT. */\n    build_lb_rules_pre_stateful(lflows, lb, features->ct_no_masked_label,\n                                match, action);\n    build_lb_rules(lflows, lb, features, match, action, meter_groups);\n}\n\n/* If there are any load balancing rules, we should send the packet to\n * conntrack for defragmentation and tracking.  This helps with two things.\n *\n * 1. With tracking, we can send only new connections to pick a DNAT ip address\n *    from a group.\n * 2. If there are L4 ports in load balancing rules, we need the\n *    defragmentation to match on L4 ports.\n */\nstatic void\nbuild_lrouter_defrag_flows_for_lb(struct ovn_northd_lb *lb,\n                                  struct hmap *lflows,\n                                  struct ds *match)\n{\n    if (!lb->n_nb_lr) {\n        return;\n    }\n\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n        bool ipv6 = lb_vip->address_family == AF_INET6;\n        int prio = 100;\n\n        ds_clear(match);\n        ds_put_format(match, \"ip && ip%c.dst == %s\", ipv6 ? '6' : '4',\n                      lb_vip->vip_str);\n\n        ovn_lflow_add_with_dp_group(\n            lflows, lb->nb_lr_map, S_ROUTER_IN_DEFRAG, prio,\n            ds_cstr(match), \"ct_dnat;\", &lb->nlb->header_);\n    }\n}\n\nstatic void\nbuild_lrouter_flows_for_lb(struct ovn_northd_lb *lb, struct hmap *lflows,\n                           const struct shash *meter_groups,\n                           const struct chassis_features *features,\n                           struct ds *match, struct ds *action)\n{\n    size_t index;\n\n    if (!lb->n_nb_lr) {\n        return;\n    }\n\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n\n        build_lrouter_nat_flows_for_lb(lb_vip, lb, &lb->vips_nb[i],\n                                       lflows, match, action, meter_groups,\n                                       features);\n\n        if (!build_empty_lb_event_flow(lb_vip, lb, match, action)) {\n            continue;\n        }\n\n        BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {\n            struct ovn_datapath *od = datapaths_array[index];\n\n            ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_DNAT,\n                                      130, ds_cstr(match), ds_cstr(action),\n                                      NULL,\n                                      copp_meter_get(COPP_EVENT_ELB,\n                                                     od->nbr->copp,\n                                                     meter_groups),\n                                      &lb->nlb->header_);\n        }\n    }\n\n    if (lb->skip_snat) {\n        BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {\n            struct ovn_datapath *od = datapaths_array[index];\n\n            ovn_lflow_add(lflows, od, S_ROUTER_OUT_SNAT, 120,\n                          \"flags.skip_snat_for_lb == 1 && ip\", \"next;\");\n        }\n    }\n}\n\n#define ND_RA_MAX_INTERVAL_MAX 1800\n#define ND_RA_MAX_INTERVAL_MIN 4\n\n#define ND_RA_MIN_INTERVAL_MAX(max) ((max) * 3 / 4)\n#define ND_RA_MIN_INTERVAL_MIN 3\n\nstatic void\ncopy_ra_to_sb(struct ovn_port *op, const char *address_mode)\n{\n    struct smap options;\n    smap_clone(&options, &op->sb->options);\n\n    smap_add(&options, \"ipv6_ra_send_periodic\", \"true\");\n    smap_add(&options, \"ipv6_ra_address_mode\", address_mode);\n\n    int max_interval = smap_get_int(&op->nbrp->ipv6_ra_configs,\n            \"max_interval\", ND_RA_MAX_INTERVAL_DEFAULT);\n    if (max_interval > ND_RA_MAX_INTERVAL_MAX) {\n        max_interval = ND_RA_MAX_INTERVAL_MAX;\n    }\n    if (max_interval < ND_RA_MAX_INTERVAL_MIN) {\n        max_interval = ND_RA_MAX_INTERVAL_MIN;\n    }\n    smap_add_format(&options, \"ipv6_ra_max_interval\", \"%d\", max_interval);\n\n    int min_interval = smap_get_int(&op->nbrp->ipv6_ra_configs,\n            \"min_interval\", nd_ra_min_interval_default(max_interval));\n    if (min_interval > ND_RA_MIN_INTERVAL_MAX(max_interval)) {\n        min_interval = ND_RA_MIN_INTERVAL_MAX(max_interval);\n    }\n    if (min_interval < ND_RA_MIN_INTERVAL_MIN) {\n        min_interval = ND_RA_MIN_INTERVAL_MIN;\n    }\n    smap_add_format(&options, \"ipv6_ra_min_interval\", \"%d\", min_interval);\n\n    int mtu = smap_get_int(&op->nbrp->ipv6_ra_configs, \"mtu\", ND_MTU_DEFAULT);\n    /* RFC 2460 requires the MTU for IPv6 to be at least 1280 */\n    if (mtu && mtu >= 1280) {\n        smap_add_format(&options, \"ipv6_ra_mtu\", \"%d\", mtu);\n    }\n\n    struct ds s = DS_EMPTY_INITIALIZER;\n    for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; ++i) {\n        struct ipv6_netaddr *addrs = &op->lrp_networks.ipv6_addrs[i];\n        if (in6_is_lla(&addrs->network)) {\n            smap_add(&options, \"ipv6_ra_src_addr\", addrs->addr_s);\n            continue;\n        }\n        ds_put_format(&s, \"%s/%u \", addrs->network_s, addrs->plen);\n    }\n\n    const char *ra_pd_list = smap_get(&op->sb->options, \"ipv6_ra_pd_list\");\n    if (ra_pd_list) {\n        ds_put_cstr(&s, ra_pd_list);\n    }\n    /* Remove trailing space */\n    ds_chomp(&s, ' ');\n    smap_add(&options, \"ipv6_ra_prefixes\", ds_cstr(&s));\n    ds_destroy(&s);\n\n    const char *rdnss = smap_get(&op->nbrp->ipv6_ra_configs, \"rdnss\");\n    if (rdnss) {\n        smap_add(&options, \"ipv6_ra_rdnss\", rdnss);\n    }\n    const char *dnssl = smap_get(&op->nbrp->ipv6_ra_configs, \"dnssl\");\n    if (dnssl) {\n        smap_add(&options, \"ipv6_ra_dnssl\", dnssl);\n    }\n\n    smap_add(&options, \"ipv6_ra_src_eth\", op->lrp_networks.ea_s);\n\n    const char *prf = smap_get(&op->nbrp->ipv6_ra_configs,\n                               \"router_preference\");\n    if (!prf || (strcmp(prf, \"HIGH\") && strcmp(prf, \"LOW\"))) {\n        smap_add(&options, \"ipv6_ra_prf\", \"MEDIUM\");\n    } else {\n        smap_add(&options, \"ipv6_ra_prf\", prf);\n    }\n\n    const char *route_info = smap_get(&op->nbrp->ipv6_ra_configs,\n                                      \"route_info\");\n    if (route_info) {\n        smap_add(&options, \"ipv6_ra_route_info\", route_info);\n    }\n\n    sbrec_port_binding_set_options(op->sb, &options);\n    smap_destroy(&options);\n}\n\nstatic inline bool\nlrouter_dnat_and_snat_is_stateless(const struct nbrec_nat *nat)\n{\n    return smap_get_bool(&nat->options, \"stateless\", false) &&\n           !strcmp(nat->type, \"dnat_and_snat\");\n}\n\n/* Handles the match criteria and actions in logical flow\n * based on external ip based NAT rule filter.\n *\n * For ALLOWED_EXT_IPs, we will add an additional match criteria\n * of comparing ip*.src/dst with the allowed external ip address set.\n *\n * For EXEMPTED_EXT_IPs, we will have an additional logical flow\n * where we compare ip*.src/dst with the exempted external ip address set\n * and action says \"next\" instead of ct*.\n */\nstatic inline void\nlrouter_nat_add_ext_ip_match(struct ovn_datapath *od,\n                             struct hmap *lflows, struct ds *match,\n                             const struct nbrec_nat *nat,\n                             bool is_v6, bool is_src, int cidr_bits)\n{\n    struct nbrec_address_set *allowed_ext_ips = nat->allowed_ext_ips;\n    struct nbrec_address_set *exempted_ext_ips = nat->exempted_ext_ips;\n\n    ovs_assert(allowed_ext_ips || exempted_ext_ips);\n\n    if (allowed_ext_ips) {\n        ds_put_format(match, \" && ip%s.%s == $%s\",\n                      is_v6 ? \"6\" : \"4\",\n                      is_src ? \"src\" : \"dst\",\n                      allowed_ext_ips->name);\n    } else if (exempted_ext_ips) {\n        struct ds match_exempt = DS_EMPTY_INITIALIZER;\n        enum ovn_stage stage = is_src ? S_ROUTER_IN_DNAT : S_ROUTER_OUT_SNAT;\n        uint16_t priority;\n\n        /* Priority of logical flows corresponding to exempted_ext_ips is\n         * +2 of the corresponding regular NAT rule.\n         * For example, if we have following NAT rule and we associate\n         * exempted external ips to it:\n         * \"ovn-nbctl lr-nat-add router dnat_and_snat 10.15.24.139 50.0.0.11\"\n         *\n         * And now we associate exempted external ip address set to it.\n         * Now corresponding to above rule we will have following logical\n         * flows:\n         * lr_out_snat...priority=163, match=(..ip4.dst == $exempt_range),\n         *                             action=(next;)\n         * lr_out_snat...priority=161, match=(..), action=(ct_snat(....);)\n         *\n         */\n        if (is_src) {\n            /* S_ROUTER_IN_DNAT uses priority 100 */\n            priority = 100 + 2;\n        } else {\n            /* S_ROUTER_OUT_SNAT uses priority (mask + 1 + 128 + 1) */\n            priority = cidr_bits + 3;\n\n            if (!od->is_gw_router) {\n                priority += 128;\n           }\n        }\n\n        ds_clone(&match_exempt, match);\n        ds_put_format(&match_exempt, \" && ip%s.%s == $%s\",\n                      is_v6 ? \"6\" : \"4\",\n                      is_src ? \"src\" : \"dst\",\n                      exempted_ext_ips->name);\n\n        ovn_lflow_add_with_hint(lflows, od, stage, priority,\n                                ds_cstr(&match_exempt), \"next;\",\n                                &nat->header_);\n        ds_destroy(&match_exempt);\n    }\n}\n\n/* Builds the logical flow that replies to ARP requests for an 'ip_address'\n * owned by the router. The flow is inserted in table S_ROUTER_IN_IP_INPUT\n * with the given priority.\n */\nstatic void\nbuild_lrouter_arp_flow(struct ovn_datapath *od, struct ovn_port *op,\n                       const char *ip_address, const char *eth_addr,\n                       struct ds *extra_match, bool drop, uint16_t priority,\n                       const struct ovsdb_idl_row *hint,\n                       struct hmap *lflows)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    if (op) {\n        ds_put_format(&match, \"inport == %s && \", op->json_key);\n    }\n\n    ds_put_format(&match, \"arp.op == 1 && arp.tpa == %s\", ip_address);\n\n    if (extra_match && ds_last(extra_match) != EOF) {\n        ds_put_format(&match, \" && %s\", ds_cstr(extra_match));\n    }\n    if (drop) {\n        ds_put_cstr(&actions, debug_drop_action());\n    } else {\n        ds_put_format(&actions,\n                      \"eth.dst = eth.src; \"\n                      \"eth.src = %s; \"\n                      \"arp.op = 2; /* ARP reply */ \"\n                      \"arp.tha = arp.sha; \"\n                      \"arp.sha = %s; \"\n                      \"arp.tpa <-> arp.spa; \"\n                      \"outport = inport; \"\n                      \"flags.loopback = 1; \"\n                      \"output;\",\n                      eth_addr,\n                      eth_addr);\n    }\n\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_INPUT, priority,\n                            ds_cstr(&match), ds_cstr(&actions), hint);\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\n/* Builds the logical flow that replies to NS requests for an 'ip_address'\n * owned by the router. The flow is inserted in table S_ROUTER_IN_IP_INPUT\n * with the given priority. If 'sn_ip_address' is non-NULL, requests are\n * restricted only to packets with IP destination 'ip_address' or\n * 'sn_ip_address'.\n */\nstatic void\nbuild_lrouter_nd_flow(struct ovn_datapath *od, struct ovn_port *op,\n                      const char *action, const char *ip_address,\n                      const char *sn_ip_address, const char *eth_addr,\n                      struct ds *extra_match, bool drop, uint16_t priority,\n                      const struct ovsdb_idl_row *hint,\n                      struct hmap *lflows, const struct shash *meter_groups)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    if (op) {\n        ds_put_format(&match, \"inport == %s && \", op->json_key);\n    }\n\n    if (sn_ip_address) {\n        ds_put_format(&match, \"ip6.dst == {%s, %s} && \",\n                      ip_address, sn_ip_address);\n    }\n\n    ds_put_format(&match, \"nd_ns && nd.target == %s\", ip_address);\n\n    if (extra_match && ds_last(extra_match) != EOF) {\n        ds_put_format(&match, \" && %s\", ds_cstr(extra_match));\n    }\n\n    if (drop) {\n        ds_put_cstr(&actions, debug_drop_action());\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_INPUT, priority,\n                                ds_cstr(&match), ds_cstr(&actions), hint);\n    } else {\n        ds_put_format(&actions,\n                      \"%s { \"\n                        \"eth.src = %s; \"\n                        \"ip6.src = nd.target; \"\n                        \"nd.tll = %s; \"\n                        \"outport = inport; \"\n                        \"flags.loopback = 1; \"\n                        \"output; \"\n                      \"};\",\n                      action,\n                      eth_addr,\n                      eth_addr);\n        ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_IP_INPUT, priority,\n                                  ds_cstr(&match), ds_cstr(&actions), NULL,\n                                  copp_meter_get(COPP_ND_NA, od->nbr->copp,\n                                                 meter_groups),\n                                  hint);\n    }\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_lrouter_nat_arp_nd_flow(struct ovn_datapath *od,\n                              struct ovn_nat *nat_entry,\n                              struct hmap *lflows,\n                              const struct shash *meter_groups)\n{\n    struct lport_addresses *ext_addrs = &nat_entry->ext_addrs;\n    const struct nbrec_nat *nat = nat_entry->nb;\n\n    if (nat_entry_is_v6(nat_entry)) {\n        build_lrouter_nd_flow(od, NULL, \"nd_na\",\n                              ext_addrs->ipv6_addrs[0].addr_s,\n                              ext_addrs->ipv6_addrs[0].sn_addr_s,\n                              REG_INPORT_ETH_ADDR, NULL, false, 90,\n                              &nat->header_, lflows, meter_groups);\n    } else {\n        build_lrouter_arp_flow(od, NULL,\n                               ext_addrs->ipv4_addrs[0].addr_s,\n                               REG_INPORT_ETH_ADDR, NULL, false, 90,\n                               &nat->header_, lflows);\n    }\n}\n\nstatic void\nbuild_lrouter_port_nat_arp_nd_flow(struct ovn_port *op,\n                                   struct ovn_nat *nat_entry,\n                                   struct hmap *lflows,\n                                   const struct shash *meter_groups)\n{\n    struct lport_addresses *ext_addrs = &nat_entry->ext_addrs;\n    const struct nbrec_nat *nat = nat_entry->nb;\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    /* ARP/ND should be sent from distributed gateway port where the NAT rule\n     * will be applied. */\n    if (!is_nat_gateway_port(nat, op)) {\n        return;\n    }\n\n    /* Mac address to use when replying to ARP/NS. */\n    const char *mac_s = REG_INPORT_ETH_ADDR;\n    struct eth_addr mac;\n\n    if (nat->external_mac &&\n        eth_addr_from_string(nat->external_mac, &mac)\n        && nat->logical_port) {\n        /* distributed NAT case, use nat->external_mac */\n        mac_s = nat->external_mac;\n        /* Traffic with eth.src = nat->external_mac should only be\n         * sent from the chassis where nat->logical_port is\n         * resident, so that upstream MAC learning points to the\n         * correct chassis.  Also need to avoid generation of\n         * multiple ARP responses from different chassis. */\n        ds_put_format(&match, \"is_chassis_resident(\\\"%s\\\")\",\n                      nat->logical_port);\n    } else {\n        mac_s = REG_INPORT_ETH_ADDR;\n        /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s\n         * should only be sent from the gateway chassis, so that\n         * upstream MAC learning points to the gateway chassis.\n         * Also need to avoid generation of multiple ARP responses\n         * from different chassis. */\n        ovs_assert(is_l3dgw_port(op));\n        ds_put_format(&match, \"is_chassis_resident(%s)\",\n                      op->cr_port->json_key);\n    }\n\n    /* Respond to ARP/NS requests on the chassis that binds the gw\n     * port. Drop the ARP/NS requests on other chassis.\n     */\n    if (nat_entry_is_v6(nat_entry)) {\n        build_lrouter_nd_flow(op->od, op, \"nd_na\",\n                              ext_addrs->ipv6_addrs[0].addr_s,\n                              ext_addrs->ipv6_addrs[0].sn_addr_s,\n                              mac_s, &match, false, 92,\n                              &nat->header_, lflows, meter_groups);\n        build_lrouter_nd_flow(op->od, op, \"nd_na\",\n                              ext_addrs->ipv6_addrs[0].addr_s,\n                              ext_addrs->ipv6_addrs[0].sn_addr_s,\n                              mac_s, NULL, true, 91,\n                              &nat->header_, lflows, meter_groups);\n    } else {\n        build_lrouter_arp_flow(op->od, op,\n                               ext_addrs->ipv4_addrs[0].addr_s,\n                               mac_s, &match, false, 92,\n                               &nat->header_, lflows);\n        build_lrouter_arp_flow(op->od, op,\n                               ext_addrs->ipv4_addrs[0].addr_s,\n                               mac_s, NULL, true, 91,\n                               &nat->header_, lflows);\n    }\n\n    ds_destroy(&match);\n}\n\nstatic void\nbuild_lrouter_drop_own_dest(struct ovn_port *op, enum ovn_stage stage,\n                            uint16_t priority, bool drop_snat_ip,\n                            struct hmap *lflows)\n{\n    struct ds match_ips = DS_EMPTY_INITIALIZER;\n\n    if (op->lrp_networks.n_ipv4_addrs) {\n        for (size_t i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            const char *ip = op->lrp_networks.ipv4_addrs[i].addr_s;\n\n            bool router_ip_in_snat_ips = !!shash_find(&op->od->snat_ips, ip);\n            bool router_ip_in_lb_ips =\n                    !!sset_find(&op->od->lb_ips->ips_v4, ip);\n            bool drop_router_ip = (drop_snat_ip == (router_ip_in_snat_ips ||\n                                                    router_ip_in_lb_ips));\n\n            if (drop_router_ip) {\n                ds_put_format(&match_ips, \"%s, \", ip);\n            }\n        }\n\n        if (ds_last(&match_ips) != EOF) {\n            ds_chomp(&match_ips, ' ');\n            ds_chomp(&match_ips, ',');\n\n            char *match = xasprintf(\"ip4.dst == {%s}\", ds_cstr(&match_ips));\n            ovn_lflow_add_with_hint(lflows, op->od, stage, priority,\n                                    match, debug_drop_action(),\n                                    &op->nbrp->header_);\n            free(match);\n        }\n    }\n\n    if (op->lrp_networks.n_ipv6_addrs) {\n        ds_clear(&match_ips);\n\n        for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n            const char *ip = op->lrp_networks.ipv6_addrs[i].addr_s;\n\n            bool router_ip_in_snat_ips = !!shash_find(&op->od->snat_ips, ip);\n            bool router_ip_in_lb_ips =\n                    !!sset_find(&op->od->lb_ips->ips_v6, ip);\n            bool drop_router_ip = (drop_snat_ip == (router_ip_in_snat_ips ||\n                                                    router_ip_in_lb_ips));\n\n            if (drop_router_ip) {\n                ds_put_format(&match_ips, \"%s, \", ip);\n            }\n        }\n\n        if (ds_last(&match_ips) != EOF) {\n            ds_chomp(&match_ips, ' ');\n            ds_chomp(&match_ips, ',');\n\n            char *match = xasprintf(\"ip6.dst == {%s}\", ds_cstr(&match_ips));\n            ovn_lflow_add_with_hint(lflows, op->od, stage, priority,\n                                    match, debug_drop_action(),\n                                    &op->nbrp->header_);\n            free(match);\n        }\n    }\n    ds_destroy(&match_ips);\n}\n\nstatic void\nbuild_lrouter_force_snat_flows(struct hmap *lflows, struct ovn_datapath *od,\n                               const char *ip_version, const char *ip_addr,\n                               const char *context)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n    ds_put_format(&match, \"ip%s && ip%s.dst == %s\",\n                  ip_version, ip_version, ip_addr);\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_UNSNAT, 110,\n                  ds_cstr(&match), \"ct_snat;\");\n\n    /* Higher priority rules to force SNAT with the IP addresses\n     * configured in the Gateway router.  This only takes effect\n     * when the packet has already been DNATed or load balanced once. */\n    ds_clear(&match);\n    ds_put_format(&match, \"flags.force_snat_for_%s == 1 && ip%s\",\n                  context, ip_version);\n    ds_put_format(&actions, \"ct_snat(%s);\", ip_addr);\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_SNAT, 100,\n                  ds_cstr(&match), ds_cstr(&actions));\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_lrouter_force_snat_flows_op(struct ovn_port *op,\n                                  struct hmap *lflows,\n                                  struct ds *match, struct ds *actions)\n{\n    if (!op->nbrp || !op->peer || !op->od->lb_force_snat_router_ip) {\n        return;\n    }\n\n    if (op->lrp_networks.n_ipv4_addrs) {\n        ds_clear(match);\n        ds_clear(actions);\n\n        ds_put_format(match, \"inport == %s && ip4.dst == %s\",\n                      op->json_key, op->lrp_networks.ipv4_addrs[0].addr_s);\n        ovn_lflow_add(lflows, op->od, S_ROUTER_IN_UNSNAT, 110,\n                      ds_cstr(match), \"ct_snat;\");\n\n        ds_clear(match);\n\n        /* Higher priority rules to force SNAT with the router port ip.\n         * This only takes effect when the packet has already been\n         * load balanced once. */\n        ds_put_format(match, \"flags.force_snat_for_lb == 1 && ip4 && \"\n                      \"outport == %s\", op->json_key);\n        ds_put_format(actions, \"ct_snat(%s);\",\n                      op->lrp_networks.ipv4_addrs[0].addr_s);\n        ovn_lflow_add(lflows, op->od, S_ROUTER_OUT_SNAT, 110,\n                      ds_cstr(match), ds_cstr(actions));\n        if (op->lrp_networks.n_ipv4_addrs > 1) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n            VLOG_WARN_RL(&rl, \"Logical router port %s is configured with \"\n                              \"multiple IPv4 addresses.  Only the first \"\n                              \"IP [%s] is considered as SNAT for load \"\n                              \"balancer\", op->json_key,\n                              op->lrp_networks.ipv4_addrs[0].addr_s);\n        }\n    }\n\n    /* op->lrp_networks.ipv6_addrs will always have LLA and that will be\n     * last in the list. So add the flows only if n_ipv6_addrs > 1. */\n    if (op->lrp_networks.n_ipv6_addrs > 1) {\n        ds_clear(match);\n        ds_clear(actions);\n\n        ds_put_format(match, \"inport == %s && ip6.dst == %s\",\n                      op->json_key, op->lrp_networks.ipv6_addrs[0].addr_s);\n        ovn_lflow_add(lflows, op->od, S_ROUTER_IN_UNSNAT, 110,\n                      ds_cstr(match), \"ct_snat;\");\n\n        ds_clear(match);\n\n        /* Higher priority rules to force SNAT with the router port ip.\n         * This only takes effect when the packet has already been\n         * load balanced once. */\n        ds_put_format(match, \"flags.force_snat_for_lb == 1 && ip6 && \"\n                      \"outport == %s\", op->json_key);\n        ds_put_format(actions, \"ct_snat(%s);\",\n                      op->lrp_networks.ipv6_addrs[0].addr_s);\n        ovn_lflow_add(lflows, op->od, S_ROUTER_OUT_SNAT, 110,\n                      ds_cstr(match), ds_cstr(actions));\n        if (op->lrp_networks.n_ipv6_addrs > 2) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n            VLOG_WARN_RL(&rl, \"Logical router port %s is configured with \"\n                              \"multiple IPv6 addresses.  Only the first \"\n                              \"IP [%s] is considered as SNAT for load \"\n                              \"balancer\", op->json_key,\n                              op->lrp_networks.ipv6_addrs[0].addr_s);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_bfd_flows(struct hmap *lflows, struct ovn_port *op,\n                        const struct shash *meter_groups)\n{\n    if (!op->has_bfd) {\n        return;\n    }\n\n    struct ds ip_list = DS_EMPTY_INITIALIZER;\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    if (op->lrp_networks.n_ipv4_addrs) {\n        op_put_v4_networks(&ip_list, op, false);\n        ds_put_format(&match, \"ip4.src == %s && udp.dst == 3784\",\n                      ds_cstr(&ip_list));\n        ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 110,\n                                ds_cstr(&match), \"next; \",\n                                &op->nbrp->header_);\n        ds_clear(&match);\n        ds_put_format(&match, \"ip4.dst == %s && udp.dst == 3784\",\n                      ds_cstr(&ip_list));\n        ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT, 110,\n                                  ds_cstr(&match), \"handle_bfd_msg(); \", NULL,\n                                  copp_meter_get(COPP_BFD, op->od->nbr->copp,\n                                                 meter_groups),\n                                  &op->nbrp->header_);\n    }\n    if (op->lrp_networks.n_ipv6_addrs) {\n        ds_clear(&ip_list);\n        ds_clear(&match);\n\n        op_put_v6_networks(&ip_list, op);\n        ds_put_format(&match, \"ip6.src == %s && udp.dst == 3784\",\n                      ds_cstr(&ip_list));\n        ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 110,\n                                ds_cstr(&match), \"next; \",\n                                &op->nbrp->header_);\n        ds_clear(&match);\n        ds_put_format(&match, \"ip6.dst == %s && udp.dst == 3784\",\n                      ds_cstr(&ip_list));\n        ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT, 110,\n                                  ds_cstr(&match), \"handle_bfd_msg(); \", NULL,\n                                  copp_meter_get(COPP_BFD, op->od->nbr->copp,\n                                                 meter_groups),\n                                  &op->nbrp->header_);\n    }\n\n    ds_destroy(&ip_list);\n    ds_destroy(&match);\n}\n\n/* Logical router ingress Table 0: L2 Admission Control\n * Generic admission control flows (without inport check).\n */\nstatic void\nbuild_adm_ctrl_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (od->nbr) {\n        /* Logical VLANs not supported.\n         * Broadcast/multicast source address is invalid. */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ADMISSION, 100,\n                      \"vlan.present || eth.src[40]\", debug_drop_action());\n\n        /* Default action for L2 security is to drop. */\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_ADMISSION);\n    }\n}\n\nstatic int\nbuild_gateway_get_l2_hdr_size(struct ovn_port *op)\n{\n    struct ovn_port *peer = op->peer;\n\n    if (peer && peer->od && peer->od->nbs) {\n        /* Check if vlans are enabled on a localnet port running the logical\n         * switch connected to this logical router.\n         */\n        for (size_t i = 0; i < peer->od->n_localnet_ports; i++) {\n            struct ovn_port *localnet_port = peer->od->localnet_ports[i];\n            const struct nbrec_logical_switch_port *nbsp = localnet_port->nbsp;\n\n            if (nbsp && nbsp->n_tag_request > 0) {\n                return VLAN_ETH_HEADER_LEN;\n            }\n        }\n    }\n\n    return ETH_HEADER_LEN;\n}\n\n/* All 'gateway_mtu' and 'gateway_mtu_bypass' flows should be built with this\n * function.\n */\nstatic void OVS_PRINTF_FORMAT(9, 10)\nbuild_gateway_mtu_flow(struct hmap *lflows, struct ovn_port *op,\n                       enum ovn_stage stage, uint16_t prio_low,\n                       uint16_t prio_high, struct ds *match,\n                       struct ds *actions, const struct ovsdb_idl_row *hint,\n                       const char *extra_actions_fmt, ...)\n{\n    int gw_mtu = smap_get_int(&op->nbrp->options, \"gateway_mtu\", 0);\n\n    va_list extra_actions_args;\n    va_start(extra_actions_args, extra_actions_fmt);\n\n    ds_clear(actions);\n    if (gw_mtu > 0) {\n        int l2_hdr_size = build_gateway_get_l2_hdr_size(op);\n        ds_put_format(actions, REGBIT_PKT_LARGER\" = check_pkt_larger(%d); \",\n                      gw_mtu + l2_hdr_size);\n    }\n\n    ds_put_format_valist(actions, extra_actions_fmt, extra_actions_args);\n    ovn_lflow_add_with_hint(lflows, op->od, stage, prio_low,\n                            ds_cstr(match), ds_cstr(actions),\n                            hint);\n\n    if (gw_mtu > 0) {\n        const char *gw_mtu_bypass = smap_get(&op->nbrp->options,\n                                             \"gateway_mtu_bypass\");\n        if (gw_mtu_bypass) {\n            ds_clear(actions);\n            ds_put_format_valist(actions, extra_actions_fmt,\n                                 extra_actions_args);\n            ds_put_format(match, \" && (%s)\", gw_mtu_bypass);\n            ovn_lflow_add_with_hint(lflows, op->od, stage, prio_high,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    hint);\n        }\n    }\n    va_end(extra_actions_args);\n}\n\nstatic bool\nconsider_l3dgw_port_is_centralized(struct ovn_port *op)\n{\n    if (l3dgw_port_has_associated_vtep_lports(op)) {\n        return false;\n    }\n\n    if (is_l3dgw_port(op)) {\n        /* Traffic with eth.dst = l3dgw_port->lrp_networks.ea_s\n         * should only be received on the gateway chassis. */\n        return true;\n    }\n\n    return false;\n}\n\n/* Logical router ingress Table 0: L2 Admission Control\n * This table drops packets that the router shouldn\u2019t see at all based\n * on their Ethernet headers.\n */\nstatic void\nbuild_adm_ctrl_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match, struct ds *actions)\n{\n    if (op->nbrp) {\n        if (!lrport_is_enabled(op->nbrp)) {\n            /* Drop packets from disabled logical ports (since logical flow\n             * tables are default-drop). */\n            return;\n        }\n\n        if (is_cr_port(op)) {\n            /* No ingress packets should be received on a chassisredirect\n             * port. */\n            return;\n        }\n\n        /* Store the ethernet address of the port receiving the packet.\n         * This will save us from having to match on inport further down in\n         * the pipeline.\n         */\n        ds_clear(match);\n        ds_put_format(match, \"eth.mcast && inport == %s\", op->json_key);\n        build_gateway_mtu_flow(lflows, op, S_ROUTER_IN_ADMISSION, 50, 55,\n                               match, actions, &op->nbrp->header_,\n                               REG_INPORT_ETH_ADDR \" = %s; next;\",\n                               op->lrp_networks.ea_s);\n\n        ds_clear(match);\n        ds_put_format(match, \"eth.dst == %s && inport == %s\",\n                      op->lrp_networks.ea_s, op->json_key);\n        if (consider_l3dgw_port_is_centralized(op)) {\n            ds_put_format(match, \" && is_chassis_resident(%s)\",\n                          op->cr_port->json_key);\n        }\n        build_gateway_mtu_flow(lflows, op, S_ROUTER_IN_ADMISSION, 50, 55,\n                               match, actions, &op->nbrp->header_,\n                               REG_INPORT_ETH_ADDR \" = %s; next;\",\n                               op->lrp_networks.ea_s);\n    }\n}\n\n\n/* Logical router ingress Table 1 and 2: Neighbor lookup and learning\n * lflows for logical routers. */\nstatic void\nbuild_neigh_learning_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        struct ds *match, struct ds *actions,\n        const struct shash *meter_groups)\n{\n    if (od->nbr) {\n\n        /* Learn MAC bindings from ARP/IPv6 ND.\n         *\n         * For ARP packets, table LOOKUP_NEIGHBOR does a lookup for the\n         * (arp.spa, arp.sha) in the mac binding table using the 'lookup_arp'\n         * action and stores the result in REGBIT_LOOKUP_NEIGHBOR_RESULT bit.\n         * If \"always_learn_from_arp_request\" is set to false, it will also\n         * lookup for the (arp.spa) in the mac binding table using the\n         * \"lookup_arp_ip\" action for ARP request packets, and stores the\n         * result in REGBIT_LOOKUP_NEIGHBOR_IP_RESULT bit; or set that bit\n         * to \"1\" directly for ARP response packets.\n         *\n         * For IPv6 ND NA packets, table LOOKUP_NEIGHBOR does a lookup\n         * for the (nd.target, nd.tll) in the mac binding table using the\n         * 'lookup_nd' action and stores the result in\n         * REGBIT_LOOKUP_NEIGHBOR_RESULT bit. If\n         * \"always_learn_from_arp_request\" is set to false,\n         * REGBIT_LOOKUP_NEIGHBOR_IP_RESULT bit is set.\n         *\n         * For IPv6 ND NS packets, table LOOKUP_NEIGHBOR does a lookup\n         * for the (ip6.src, nd.sll) in the mac binding table using the\n         * 'lookup_nd' action and stores the result in\n         * REGBIT_LOOKUP_NEIGHBOR_RESULT bit. If\n         * \"always_learn_from_arp_request\" is set to false, it will also lookup\n         * for the (ip6.src) in the mac binding table using the \"lookup_nd_ip\"\n         * action and stores the result in REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\n         * bit.\n         *\n         * Table LEARN_NEIGHBOR learns the mac-binding using the action\n         * - 'put_arp/put_nd'. Learning mac-binding is skipped if\n         *   REGBIT_LOOKUP_NEIGHBOR_RESULT bit is set or\n         *   REGBIT_LOOKUP_NEIGHBOR_IP_RESULT is not set.\n         *\n         * */\n\n        /* Flows for LOOKUP_NEIGHBOR. */\n        bool learn_from_arp_request = smap_get_bool(&od->nbr->options,\n            \"always_learn_from_arp_request\", true);\n        ds_clear(actions);\n        ds_put_format(actions, REGBIT_LOOKUP_NEIGHBOR_RESULT\n                      \" = lookup_arp(inport, arp.spa, arp.sha); %snext;\",\n                      learn_from_arp_request ? \"\" :\n                      REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\" = 1; \");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LOOKUP_NEIGHBOR, 100,\n                      \"arp.op == 2\", ds_cstr(actions));\n\n        ds_clear(actions);\n        ds_put_format(actions, REGBIT_LOOKUP_NEIGHBOR_RESULT\n                      \" = lookup_nd(inport, nd.target, nd.tll); %snext;\",\n                      learn_from_arp_request ? \"\" :\n                      REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\" = 1; \");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LOOKUP_NEIGHBOR, 100, \"nd_na\",\n                      ds_cstr(actions));\n\n        if (!learn_from_arp_request) {\n            /* Add flow to skip GARP LLA if we don't know it already.\n             * From RFC 2461, section 4.4, Neighbor Advertisement Message\n             * Format, the Destination Address should be:\n             *   For solicited advertisements, the Source Address of\n             *   an invoking Neighbor Solicitation or, if the\n             *   solicitation's Source Address is the unspecified\n             *   address, the all-nodes multicast address. */\n            ds_clear(actions);\n            ds_put_format(actions, REGBIT_LOOKUP_NEIGHBOR_RESULT\n                                   \" = lookup_nd(inport, ip6.src, nd.tll); \"\n                                   REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\n                                   \" = lookup_nd_ip(inport, ip6.src); next;\");\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_LOOKUP_NEIGHBOR, 110,\n                          \"nd_na && ip6.src == fe80::/10 \"\n                          \"&& ip6.dst == ff00::/8\",\n                          ds_cstr(actions));\n        }\n\n        ds_clear(actions);\n        ds_put_format(actions, REGBIT_LOOKUP_NEIGHBOR_RESULT\n                      \" = lookup_nd(inport, ip6.src, nd.sll); %snext;\",\n                      learn_from_arp_request ? \"\" :\n                      REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\n                      \" = lookup_nd_ip(inport, ip6.src); \");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LOOKUP_NEIGHBOR, 100, \"nd_ns\",\n                      ds_cstr(actions));\n\n        /* For other packet types, we can skip neighbor learning.\n         * So set REGBIT_LOOKUP_NEIGHBOR_RESULT to 1. */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LOOKUP_NEIGHBOR, 0, \"1\",\n                      REGBIT_LOOKUP_NEIGHBOR_RESULT\" = 1; next;\");\n\n        /* Flows for LEARN_NEIGHBOR. */\n        /* Skip Neighbor learning if not required. */\n        ds_clear(match);\n        ds_put_format(match, REGBIT_LOOKUP_NEIGHBOR_RESULT\" == 1%s\",\n                      learn_from_arp_request ? \"\" :\n                      \" || \"REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\" == 0\");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 100,\n                      ds_cstr(match), \"next;\");\n\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 90,\n                          \"arp\", \"put_arp(inport, arp.spa, arp.sha); next;\",\n                          copp_meter_get(COPP_ARP, od->nbr->copp,\n                                         meter_groups));\n\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 95,\n                      \"nd_ns && (ip6.src == 0 || nd.sll == 0)\", \"next;\");\n\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 95,\n                          \"nd_na && nd.tll == 0\",\n                          \"put_nd(inport, nd.target, eth.src); next;\",\n                          copp_meter_get(COPP_ND_NA, od->nbr->copp,\n                                         meter_groups));\n\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 90,\n                          \"nd_na\", \"put_nd(inport, nd.target, nd.tll); next;\",\n                          copp_meter_get(COPP_ND_NA, od->nbr->copp,\n                                         meter_groups));\n\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 90,\n                          \"nd_ns\", \"put_nd(inport, ip6.src, nd.sll); next;\",\n                          copp_meter_get(COPP_ND_NS, od->nbr->copp,\n                                         meter_groups));\n\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR);\n    }\n\n}\n\n/* Logical router ingress Table 1: Neighbor lookup lflows\n * for logical router ports. */\nstatic void\nbuild_neigh_learning_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match, struct ds *actions)\n{\n    if (op->nbrp) {\n\n        bool learn_from_arp_request = smap_get_bool(&op->od->nbr->options,\n            \"always_learn_from_arp_request\", true);\n\n        /* Check if we need to learn mac-binding from ARP requests. */\n        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            if (!learn_from_arp_request) {\n                /* ARP request to this address should always get learned,\n                 * so add a priority-110 flow to set\n                 * REGBIT_LOOKUP_NEIGHBOR_IP_RESULT to 1. */\n                ds_clear(match);\n                ds_put_format(match,\n                              \"inport == %s && arp.spa == %s/%u && \"\n                              \"arp.tpa == %s && arp.op == 1\",\n                              op->json_key,\n                              op->lrp_networks.ipv4_addrs[i].network_s,\n                              op->lrp_networks.ipv4_addrs[i].plen,\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n                if (is_l3dgw_port(op)) {\n                    ds_put_format(match, \" && is_chassis_resident(%s)\",\n                                  op->cr_port->json_key);\n                }\n                const char *actions_s = REGBIT_LOOKUP_NEIGHBOR_RESULT\n                                  \" = lookup_arp(inport, arp.spa, arp.sha); \"\n                                  REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\" = 1;\"\n                                  \" next;\";\n                ovn_lflow_add_with_hint(lflows, op->od,\n                                        S_ROUTER_IN_LOOKUP_NEIGHBOR, 110,\n                                        ds_cstr(match), actions_s,\n                                        &op->nbrp->header_);\n            }\n            ds_clear(match);\n            ds_put_format(match,\n                          \"inport == %s && arp.spa == %s/%u && arp.op == 1\",\n                          op->json_key,\n                          op->lrp_networks.ipv4_addrs[i].network_s,\n                          op->lrp_networks.ipv4_addrs[i].plen);\n            if (is_l3dgw_port(op)) {\n                ds_put_format(match, \" && is_chassis_resident(%s)\",\n                              op->cr_port->json_key);\n            }\n            ds_clear(actions);\n            ds_put_format(actions, REGBIT_LOOKUP_NEIGHBOR_RESULT\n                          \" = lookup_arp(inport, arp.spa, arp.sha); %snext;\",\n                          learn_from_arp_request ? \"\" :\n                          REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\n                          \" = lookup_arp_ip(inport, arp.spa); \");\n            ovn_lflow_add_with_hint(lflows, op->od,\n                                    S_ROUTER_IN_LOOKUP_NEIGHBOR, 100,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &op->nbrp->header_);\n        }\n    }\n}\n\n/* Logical router ingress table ND_RA_OPTIONS & ND_RA_RESPONSE: IPv6 Router\n * Adv (RA) options and response. */\nstatic void\nbuild_ND_RA_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match, struct ds *actions,\n        const struct shash *meter_groups)\n{\n    if (!op->nbrp || op->nbrp->peer || !op->peer) {\n        return;\n    }\n\n    if (!op->lrp_networks.n_ipv6_addrs) {\n        return;\n    }\n\n    const char *address_mode = smap_get(\n        &op->nbrp->ipv6_ra_configs, \"address_mode\");\n\n    if (!address_mode) {\n        return;\n    }\n    if (strcmp(address_mode, \"slaac\") &&\n        strcmp(address_mode, \"dhcpv6_stateful\") &&\n        strcmp(address_mode, \"dhcpv6_stateless\")) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n        VLOG_WARN_RL(&rl, \"Invalid address mode [%s] defined\",\n                     address_mode);\n        return;\n    }\n\n    ds_clear(match);\n    ds_put_format(match, \"inport == %s && ip6.dst == ff02::2 && nd_rs\",\n                          op->json_key);\n    ds_clear(actions);\n\n    const char *mtu_s = smap_get(\n        &op->nbrp->ipv6_ra_configs, \"mtu\");\n\n    /* As per RFC 2460, 1280 is minimum IPv6 MTU. */\n    uint32_t mtu = (mtu_s && atoi(mtu_s) >= 1280) ? atoi(mtu_s) : 0;\n\n    ds_put_format(actions, REGBIT_ND_RA_OPTS_RESULT\" = put_nd_ra_opts(\"\n                  \"addr_mode = \\\"%s\\\", slla = %s\",\n                  address_mode, op->lrp_networks.ea_s);\n    if (mtu > 0) {\n        ds_put_format(actions, \", mtu = %u\", mtu);\n    }\n\n    const char *prf = smap_get_def(\n        &op->nbrp->ipv6_ra_configs, \"router_preference\", \"MEDIUM\");\n    if (strcmp(prf, \"MEDIUM\")) {\n        ds_put_format(actions, \", router_preference = \\\"%s\\\"\", prf);\n    }\n\n    const char *ra_rdnss = smap_get(&op->nbrp->ipv6_ra_configs, \"rdnss\");\n    if (ra_rdnss) {\n        ds_put_format(actions, \", rdnss = %s\", ra_rdnss);\n    }\n\n    const char *ra_dnssl = smap_get(&op->nbrp->ipv6_ra_configs, \"dnssl\");\n    if (ra_dnssl) {\n        ds_put_format(actions, \", dnssl = \\\"%s\\\"\", ra_dnssl);\n    }\n\n    const char *route_info = smap_get(&op->nbrp->ipv6_ra_configs,\n                                      \"route_info\");\n    if (route_info) {\n        ds_put_format(actions, \", route_info = \\\"%s\\\"\", route_info);\n    }\n\n    bool add_rs_response_flow = false;\n\n    for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n        if (in6_is_lla(&op->lrp_networks.ipv6_addrs[i].network)) {\n            continue;\n        }\n\n        ds_put_format(actions, \", prefix = %s/%u\",\n                      op->lrp_networks.ipv6_addrs[i].network_s,\n                      op->lrp_networks.ipv6_addrs[i].plen);\n\n        add_rs_response_flow = true;\n    }\n\n    if (add_rs_response_flow) {\n        ds_put_cstr(actions, \"); next;\");\n        ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_ND_RA_OPTIONS,\n                                  50, ds_cstr(match), ds_cstr(actions), NULL,\n                                  copp_meter_get(COPP_ND_RA_OPTS,\n                                                 op->od->nbr->copp,\n                                                 meter_groups),\n                                  &op->nbrp->header_);\n        ds_clear(actions);\n        ds_clear(match);\n        ds_put_format(match, \"inport == %s && ip6.dst == ff02::2 && \"\n                      \"nd_ra && \"REGBIT_ND_RA_OPTS_RESULT, op->json_key);\n\n        char ip6_str[INET6_ADDRSTRLEN + 1];\n        struct in6_addr lla;\n        in6_generate_lla(op->lrp_networks.ea, &lla);\n        memset(ip6_str, 0, sizeof(ip6_str));\n        ipv6_string_mapped(ip6_str, &lla);\n        ds_put_format(actions, \"eth.dst = eth.src; eth.src = %s; \"\n                      \"ip6.dst = ip6.src; ip6.src = %s; \"\n                      \"outport = inport; flags.loopback = 1; \"\n                      \"output;\",\n                      op->lrp_networks.ea_s, ip6_str);\n        ovn_lflow_add_with_hint(lflows, op->od,\n                                S_ROUTER_IN_ND_RA_RESPONSE, 50,\n                                ds_cstr(match), ds_cstr(actions),\n                                &op->nbrp->header_);\n    }\n}\n\n/* Logical router ingress table ND_RA_OPTIONS & ND_RA_RESPONSE: RS\n * responder, by default goto next. (priority 0). */\nstatic void\nbuild_ND_RA_flows_for_lrouter(struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (od->nbr) {\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ND_RA_OPTIONS, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ND_RA_RESPONSE, 0, \"1\", \"next;\");\n    }\n}\n\n/* Logical router ingress table IP_ROUTING_PRE:\n * by default goto next. (priority 0). */\nstatic void\nbuild_ip_routing_pre_flows_for_lrouter(struct ovn_datapath *od,\n                                       struct hmap *lflows)\n{\n    if (od->nbr) {\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING_PRE, 0, \"1\",\n                      REG_ROUTE_TABLE_ID\" = 0; next;\");\n    }\n}\n\n/* Logical router ingress table IP_ROUTING : IP Routing.\n *\n * A packet that arrives at this table is an IP packet that should be\n * routed to the address in 'ip[46].dst'.\n *\n * For regular routes without ECMP, table IP_ROUTING sets outport to the\n * correct output port, eth.src to the output port's MAC address, and\n * REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6 to the next-hop IP address\n * (leaving 'ip[46].dst', the packet\u2019s final destination, unchanged), and\n * advances to the next table.\n *\n * For ECMP routes, i.e. multiple routes with same policy and prefix, table\n * IP_ROUTING remembers ECMP group id and selects a member id, and advances\n * to table IP_ROUTING_ECMP, which sets outport, eth.src and\n * REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6 for the selected ECMP member.\n */\nstatic void\nbuild_ip_routing_flows_for_lrouter_port(\n        struct ovn_port *op, const struct hmap *ports, struct hmap *lflows)\n{\n    if (op->nbrp) {\n\n        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            add_route(lflows, op->od, op, op->lrp_networks.ipv4_addrs[i].addr_s,\n                      op->lrp_networks.ipv4_addrs[i].network_s,\n                      op->lrp_networks.ipv4_addrs[i].plen, NULL, false, 0,\n                      &op->nbrp->header_, false, ROUTE_PRIO_OFFSET_CONNECTED);\n        }\n\n        for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n            add_route(lflows, op->od, op, op->lrp_networks.ipv6_addrs[i].addr_s,\n                      op->lrp_networks.ipv6_addrs[i].network_s,\n                      op->lrp_networks.ipv6_addrs[i].plen, NULL, false, 0,\n                      &op->nbrp->header_, false, ROUTE_PRIO_OFFSET_CONNECTED);\n        }\n    } else if (lsp_is_router(op->nbsp)) {\n        struct ovn_port *peer = ovn_port_get_peer(ports, op);\n        if (!peer || !peer->nbrp || !peer->lrp_networks.n_ipv4_addrs) {\n            return;\n        }\n\n        for (int i = 0; i < op->od->n_router_ports; i++) {\n            struct ovn_port *router_port = ovn_port_get_peer(\n                    ports, op->od->router_ports[i]);\n            if (!router_port || !router_port->nbrp || router_port == peer) {\n                continue;\n            }\n\n            struct ovn_port_routable_addresses *ra = &router_port->routables;\n            for (size_t j = 0; j < ra->n_addrs; j++) {\n                struct lport_addresses *laddrs = &ra->laddrs[j];\n                for (size_t k = 0; k < laddrs->n_ipv4_addrs; k++) {\n                    add_route(lflows, peer->od, peer,\n                              peer->lrp_networks.ipv4_addrs[0].addr_s,\n                              laddrs->ipv4_addrs[k].network_s,\n                              laddrs->ipv4_addrs[k].plen, NULL, false, 0,\n                              &peer->nbrp->header_, false,\n                              ROUTE_PRIO_OFFSET_CONNECTED);\n                }\n            }\n        }\n    }\n}\n\nstatic void\nbuild_static_route_flows_for_lrouter(\n        struct ovn_datapath *od, const struct chassis_features *features,\n        struct hmap *lflows, const struct hmap *ports,\n        const struct hmap *bfd_connections)\n{\n    if (od->nbr) {\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_IP_ROUTING_ECMP);\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_IP_ROUTING);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING_ECMP, 150,\n                      REG_ECMP_GROUP_ID\" == 0\", \"next;\");\n\n        struct hmap ecmp_groups = HMAP_INITIALIZER(&ecmp_groups);\n        struct hmap unique_routes = HMAP_INITIALIZER(&unique_routes);\n        struct ovs_list parsed_routes = OVS_LIST_INITIALIZER(&parsed_routes);\n        struct simap route_tables = SIMAP_INITIALIZER(&route_tables);\n        struct ecmp_groups_node *group;\n\n        for (int i = 0; i < od->nbr->n_ports; i++) {\n            build_route_table_lflow(od, lflows, od->nbr->ports[i],\n                                    &route_tables);\n        }\n\n        for (int i = 0; i < od->nbr->n_static_routes; i++) {\n            struct parsed_route *route =\n                parsed_routes_add(od, ports, &parsed_routes, &route_tables,\n                                  od->nbr->static_routes[i], bfd_connections);\n            if (!route) {\n                continue;\n            }\n            group = ecmp_groups_find(&ecmp_groups, route);\n            if (group) {\n                ecmp_groups_add_route(group, route);\n            } else {\n                const struct parsed_route *existed_route =\n                    unique_routes_remove(&unique_routes, route);\n                if (existed_route) {\n                    group = ecmp_groups_add(&ecmp_groups, existed_route);\n                    if (group) {\n                        ecmp_groups_add_route(group, route);\n                    }\n                } else {\n                    unique_routes_add(&unique_routes, route);\n                }\n            }\n        }\n        HMAP_FOR_EACH (group, hmap_node, &ecmp_groups) {\n            /* add a flow in IP_ROUTING, and one flow for each member in\n             * IP_ROUTING_ECMP. */\n            build_ecmp_route_flow(lflows, od, features->ct_no_masked_label,\n                                  ports, group);\n        }\n        const struct unique_routes_node *ur;\n        HMAP_FOR_EACH (ur, hmap_node, &unique_routes) {\n            build_static_route_flow(lflows, od, ports, ur->route);\n        }\n        ecmp_groups_destroy(&ecmp_groups);\n        unique_routes_destroy(&unique_routes);\n        parsed_routes_destroy(&parsed_routes);\n        simap_destroy(&route_tables);\n    }\n}\n\n/* IP Multicast lookup. Here we set the output port, adjust TTL and\n * advance to next table (priority 500).\n */\nstatic void\nbuild_mcast_lookup_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        struct ds *match, struct ds *actions)\n{\n    if (od->nbr) {\n\n        /* Drop IPv6 multicast traffic that shouldn't be forwarded,\n         * i.e., router solicitation and router advertisement.\n         */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10550,\n                      \"nd_rs || nd_ra\", debug_drop_action());\n        if (!od->mcast_info.rtr.relay) {\n            return;\n        }\n\n        struct ovn_igmp_group *igmp_group;\n\n        LIST_FOR_EACH (igmp_group, list_node, &od->mcast_info.groups) {\n            ds_clear(match);\n            ds_clear(actions);\n            if (IN6_IS_ADDR_V4MAPPED(&igmp_group->address)) {\n                ds_put_format(match, \"ip4 && ip4.dst == %s \",\n                            igmp_group->mcgroup.name);\n            } else {\n                ds_put_format(match, \"ip6 && ip6.dst == %s \",\n                            igmp_group->mcgroup.name);\n            }\n            if (od->mcast_info.rtr.flood_static) {\n                ds_put_cstr(actions,\n                            \"clone { \"\n                                \"outport = \\\"\"MC_STATIC\"\\\"; \"\n                                \"ip.ttl--; \"\n                                \"next; \"\n                            \"};\");\n            }\n            ds_put_format(actions, \"outport = \\\"%s\\\"; ip.ttl--; next;\",\n                          igmp_group->mcgroup.name);\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10500,\n                          ds_cstr(match), ds_cstr(actions));\n        }\n\n        /* If needed, flood unregistered multicast on statically configured\n         * ports. Otherwise drop any multicast traffic.\n         */\n        if (od->mcast_info.rtr.flood_static) {\n            /* MLD and IGMP packets that need to be flooded statically\n             * should be flooded without decrementing TTL (it's always\n             * 1).  To prevent packets looping for ever (to some extent),\n             * drop IGMP/MLD packets that are received from the router's\n             * own mac addresses.\n             */\n            struct ovn_port *op;\n            LIST_FOR_EACH (op, dp_node, &od->port_list) {\n                ds_clear(match);\n                ds_put_format(match, \"eth.src == %s && igmp\",\n                              op->lrp_networks.ea_s);\n                ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10550,\n                              ds_cstr(match), debug_drop_action());\n\n                ds_clear(match);\n                ds_put_format(match, \"eth.src == %s && (mldv1 || mldv2)\",\n                              op->lrp_networks.ea_s);\n                ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10550,\n                              ds_cstr(match), debug_drop_action());\n            }\n\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10460,\n                          \"igmp\",\n                          \"clone { \"\n                                \"outport = \\\"\"MC_STATIC\"\\\"; \"\n                                \"next; \"\n                          \"};\");\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10460,\n                          \"mldv1 || mldv2\",\n                          \"clone { \"\n                                \"outport = \\\"\"MC_STATIC\"\\\"; \"\n                                \"next; \"\n                          \"};\");\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10450,\n                          \"ip4.mcast || ip6.mcast\",\n                          \"clone { \"\n                                \"outport = \\\"\"MC_STATIC\"\\\"; \"\n                                \"ip.ttl--; \"\n                                \"next; \"\n                          \"};\");\n        } else {\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10450,\n                          \"ip4.mcast || ip6.mcast\", debug_drop_action());\n        }\n    }\n}\n\n/* Logical router ingress table POLICY: Policy.\n *\n * A packet that arrives at this table is an IP packet that should be\n * permitted/denied/rerouted to the address in the rule's nexthop.\n * This table sets outport to the correct out_port,\n * eth.src to the output port's MAC address,\n * and REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6 to the next-hop IP address\n * (leaving 'ip[46].dst', the packet\u2019s final destination, unchanged), and\n * advances to the next table for ARP/ND resolution. */\nstatic void\nbuild_ingress_policy_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        const struct hmap *ports)\n{\n    if (od->nbr) {\n        /* This is a catch-all rule. It has the lowest priority (0)\n         * does a match-all(\"1\") and pass-through (next) */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_POLICY, 0, \"1\",\n                      REG_ECMP_GROUP_ID\" = 0; next;\");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_POLICY_ECMP, 150,\n                      REG_ECMP_GROUP_ID\" == 0\", \"next;\");\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_POLICY_ECMP);\n\n        /* Convert routing policies to flows. */\n        uint16_t ecmp_group_id = 1;\n        for (int i = 0; i < od->nbr->n_policies; i++) {\n            const struct nbrec_logical_router_policy *rule\n                = od->nbr->policies[i];\n            bool is_ecmp_reroute =\n                (!strcmp(rule->action, \"reroute\") && rule->n_nexthops > 1);\n\n            if (is_ecmp_reroute) {\n                build_ecmp_routing_policy_flows(lflows, od, ports, rule,\n                                                ecmp_group_id);\n                ecmp_group_id++;\n            } else {\n                build_routing_policy_flow(lflows, od, ports, rule,\n                                          &rule->header_);\n            }\n        }\n    }\n}\n\n/* Local router ingress table ARP_RESOLVE: ARP Resolution. */\nstatic void\nbuild_arp_resolve_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (od->nbr) {\n        /* Multicast packets already have the outport set so just advance to\n         * next table (priority 500). */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ARP_RESOLVE, 500,\n                      \"ip4.mcast || ip6.mcast\", \"next;\");\n\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ARP_RESOLVE, 1, \"ip4\",\n                      \"get_arp(outport, \" REG_NEXT_HOP_IPV4 \"); next;\");\n\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ARP_RESOLVE, 1, \"ip6\",\n                      \"get_nd(outport, \" REG_NEXT_HOP_IPV6 \"); next;\");\n\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_ARP_RESOLVE);\n    }\n}\n\nstatic void\nroutable_addresses_to_lflows(struct hmap *lflows, struct ovn_port *router_port,\n                             struct ovn_port *peer, struct ds *match,\n                             struct ds *actions)\n{\n    struct ovn_port_routable_addresses *ra = &router_port->routables;\n    if (!ra->n_addrs) {\n        return;\n    }\n\n    for (size_t i = 0; i < ra->n_addrs; i++) {\n        ds_clear(match);\n        ds_put_format(match, \"outport == %s && \"REG_NEXT_HOP_IPV4\" == {\",\n                      peer->json_key);\n        bool first = true;\n        for (size_t j = 0; j < ra->laddrs[i].n_ipv4_addrs; j++) {\n            if (!first) {\n                ds_put_cstr(match, \", \");\n            }\n            ds_put_cstr(match, ra->laddrs[i].ipv4_addrs[j].addr_s);\n            first = false;\n        }\n        ds_put_cstr(match, \"}\");\n\n        ds_clear(actions);\n        ds_put_format(actions, \"eth.dst = %s; next;\", ra->laddrs[i].ea_s);\n        ovn_lflow_add(lflows, peer->od, S_ROUTER_IN_ARP_RESOLVE, 100,\n                      ds_cstr(match), ds_cstr(actions));\n    }\n}\n\n/* Local router ingress table ARP_RESOLVE: ARP Resolution.\n *\n * Any unicast packet that reaches this table is an IP packet whose\n * next-hop IP address is in REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6\n * (ip4.dst/ipv6.dst is the final destination).\n * This table resolves the IP address in\n * REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6 into an output port in outport and\n * an Ethernet address in eth.dst.\n */\nstatic void\nbuild_arp_resolve_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        const struct hmap *ports,\n        struct ds *match, struct ds *actions)\n{\n    if (op->nbsp && !lsp_is_enabled(op->nbsp)) {\n        return;\n    }\n\n    if (op->nbrp) {\n        /* This is a logical router port. If next-hop IP address in\n         * REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6 matches IP address of this\n         * router port, then the packet is intended to eventually be sent\n         * to this logical port. Set the destination mac address using\n         * this port's mac address.\n         *\n         * The packet is still in peer's logical pipeline. So the match\n         * should be on peer's outport. */\n        if (op->peer && op->nbrp->peer) {\n            if (op->lrp_networks.n_ipv4_addrs) {\n                ds_clear(match);\n                ds_put_format(match, \"outport == %s && \"\n                              REG_NEXT_HOP_IPV4 \"== \",\n                              op->peer->json_key);\n                op_put_v4_networks(match, op, false);\n\n                ds_clear(actions);\n                ds_put_format(actions, \"eth.dst = %s; next;\",\n                              op->lrp_networks.ea_s);\n                ovn_lflow_add_with_hint(lflows, op->peer->od,\n                                        S_ROUTER_IN_ARP_RESOLVE, 100,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbrp->header_);\n            }\n\n            if (op->lrp_networks.n_ipv6_addrs) {\n                ds_clear(match);\n                ds_put_format(match, \"outport == %s && \"\n                              REG_NEXT_HOP_IPV6 \" == \",\n                              op->peer->json_key);\n                op_put_v6_networks(match, op);\n\n                ds_clear(actions);\n                ds_put_format(actions, \"eth.dst = %s; next;\",\n                              op->lrp_networks.ea_s);\n                ovn_lflow_add_with_hint(lflows, op->peer->od,\n                                        S_ROUTER_IN_ARP_RESOLVE, 100,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbrp->header_);\n            }\n        }\n\n        if (is_l3dgw_port(op)) {\n            const char *redirect_type = smap_get(&op->nbrp->options,\n                                                 \"redirect-type\");\n            if (redirect_type && !strcasecmp(redirect_type, \"bridged\")) {\n                /* Packet is on a non gateway chassis and\n                 * has an unresolved ARP on a network behind gateway\n                 * chassis attached router port. Since, redirect type\n                 * is \"bridged\", instead of calling \"get_arp\"\n                 * on this node, we will redirect the packet to gateway\n                 * chassis, by setting destination mac router port mac.*/\n                ds_clear(match);\n                ds_put_format(match, \"outport == %s && \"\n                              \"!is_chassis_resident(%s)\", op->json_key,\n                              op->cr_port->json_key);\n                ds_clear(actions);\n                ds_put_format(actions, \"eth.dst = %s; next;\",\n                              op->lrp_networks.ea_s);\n\n                ovn_lflow_add_with_hint(lflows, op->od,\n                                        S_ROUTER_IN_ARP_RESOLVE, 50,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbrp->header_);\n            }\n        }\n\n        /* Drop IP traffic destined to router owned IPs. Part of it is dropped\n         * in stage \"lr_in_ip_input\" but traffic that could have been unSNATed\n         * but didn't match any existing session might still end up here.\n         *\n         * Priority 2.\n         */\n        build_lrouter_drop_own_dest(op, S_ROUTER_IN_ARP_RESOLVE, 2, true,\n                                    lflows);\n    } else if (op->od->n_router_ports && !lsp_is_router(op->nbsp)\n               && strcmp(op->nbsp->type, \"virtual\")) {\n        /* This is a logical switch port that backs a VM or a container.\n         * Extract its addresses. For each of the address, go through all\n         * the router ports attached to the switch (to which this port\n         * connects) and if the address in question is reachable from the\n         * router port, add an ARP/ND entry in that router's pipeline. */\n\n        for (size_t i = 0; i < op->n_lsp_addrs; i++) {\n            const char *ea_s = op->lsp_addrs[i].ea_s;\n            for (size_t j = 0; j < op->lsp_addrs[i].n_ipv4_addrs; j++) {\n                const char *ip_s = op->lsp_addrs[i].ipv4_addrs[j].addr_s;\n                for (size_t k = 0; k < op->od->n_router_ports; k++) {\n                    /* Get the Logical_Router_Port that the\n                     * Logical_Switch_Port is connected to, as\n                     * 'peer'. */\n                    struct ovn_port *peer = ovn_port_get_peer(\n                            ports, op->od->router_ports[k]);\n                    if (!peer || !peer->nbrp) {\n                        continue;\n                    }\n\n                    if (!find_lrp_member_ip(peer, ip_s)) {\n                        continue;\n                    }\n\n                    ds_clear(match);\n                    ds_put_format(match, \"outport == %s && \"\n                                  REG_NEXT_HOP_IPV4 \" == %s\",\n                                  peer->json_key, ip_s);\n\n                    ds_clear(actions);\n                    ds_put_format(actions, \"eth.dst = %s; next;\", ea_s);\n                    ovn_lflow_add_with_hint(lflows, peer->od,\n                                            S_ROUTER_IN_ARP_RESOLVE, 100,\n                                            ds_cstr(match),\n                                            ds_cstr(actions),\n                                            &op->nbsp->header_);\n                }\n            }\n\n            for (size_t j = 0; j < op->lsp_addrs[i].n_ipv6_addrs; j++) {\n                const char *ip_s = op->lsp_addrs[i].ipv6_addrs[j].addr_s;\n                for (size_t k = 0; k < op->od->n_router_ports; k++) {\n                    /* Get the Logical_Router_Port that the\n                     * Logical_Switch_Port is connected to, as\n                     * 'peer'. */\n                    struct ovn_port *peer = ovn_port_get_peer(\n                            ports, op->od->router_ports[k]);\n                    if (!peer || !peer->nbrp) {\n                        continue;\n                    }\n\n                    if (!find_lrp_member_ip(peer, ip_s)) {\n                        continue;\n                    }\n\n                    ds_clear(match);\n                    ds_put_format(match, \"outport == %s && \"\n                                  REG_NEXT_HOP_IPV6 \" == %s\",\n                                  peer->json_key, ip_s);\n\n                    ds_clear(actions);\n                    ds_put_format(actions, \"eth.dst = %s; next;\", ea_s);\n                    ovn_lflow_add_with_hint(lflows, peer->od,\n                                            S_ROUTER_IN_ARP_RESOLVE, 100,\n                                            ds_cstr(match),\n                                            ds_cstr(actions),\n                                            &op->nbsp->header_);\n                }\n            }\n        }\n    } else if (op->od->n_router_ports && !lsp_is_router(op->nbsp)\n               && !strcmp(op->nbsp->type, \"virtual\")) {\n        /* This is a virtual port. Add ARP replies for the virtual ip with\n         * the mac of the present active virtual parent.\n         * If the logical port doesn't have virtual parent set in\n         * Port_Binding table, then add the flow to set eth.dst to\n         * 00:00:00:00:00:00 and advance to next table so that ARP is\n         * resolved by router pipeline using the arp{} action.\n         * The MAC_Binding entry for the virtual ip might be invalid. */\n\n        const char *vip = smap_get(&op->nbsp->options,\n                                   \"virtual-ip\");\n        const char *virtual_parents = smap_get(&op->nbsp->options,\n                                               \"virtual-parents\");\n\n        if (!vip || !virtual_parents || !op->sb) {\n            return;\n        }\n\n        bool is_ipv4 = strchr(vip, '.') ? true : false;\n        if (is_ipv4) {\n            ovs_be32 ipv4;\n            if (!ip_parse(vip, &ipv4)) {\n                 return;\n            }\n        } else {\n            struct in6_addr ipv6;\n            if (!ipv6_parse(vip, &ipv6)) {\n                 return;\n            }\n        }\n\n        if (!op->sb->virtual_parent || !op->sb->virtual_parent[0] ||\n            !op->sb->chassis) {\n            /* The virtual port is not claimed yet. */\n            for (size_t i = 0; i < op->od->n_router_ports; i++) {\n                struct ovn_port *peer = ovn_port_get_peer(\n                        ports, op->od->router_ports[i]);\n                if (!peer || !peer->nbrp) {\n                    continue;\n                }\n\n                if (find_lrp_member_ip(peer, vip)) {\n                    ds_clear(match);\n                    ds_put_format(\n                        match, \"outport == %s && \" \"%s == %s\", peer->json_key,\n                        is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6, vip);\n\n                    const char *arp_actions =\n                                  \"eth.dst = 00:00:00:00:00:00; next;\";\n                    ovn_lflow_add_with_hint(lflows, peer->od,\n                                            S_ROUTER_IN_ARP_RESOLVE, 100,\n                                            ds_cstr(match),\n                                            arp_actions,\n                                            &op->nbsp->header_);\n                    break;\n                }\n            }\n        } else {\n            struct ovn_port *vp =\n                ovn_port_find(ports, op->sb->virtual_parent);\n            if (!vp || !vp->nbsp) {\n                return;\n            }\n\n            for (size_t i = 0; i < vp->n_lsp_addrs; i++) {\n                bool found_vip_network = false;\n                const char *ea_s = vp->lsp_addrs[i].ea_s;\n                for (size_t j = 0; j < vp->od->n_router_ports; j++) {\n                    /* Get the Logical_Router_Port that the\n                    * Logical_Switch_Port is connected to, as\n                    * 'peer'. */\n                    struct ovn_port *peer =\n                        ovn_port_get_peer(ports, vp->od->router_ports[j]);\n                    if (!peer || !peer->nbrp) {\n                        continue;\n                    }\n\n                    if (!find_lrp_member_ip(peer, vip)) {\n                        continue;\n                    }\n\n                    ds_clear(match);\n                    ds_put_format(\n                        match, \"outport == %s && \" \"%s == %s\", peer->json_key,\n                        is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6, vip);\n\n                    ds_clear(actions);\n                    ds_put_format(actions, \"eth.dst = %s; next;\", ea_s);\n                    ovn_lflow_add_with_hint(lflows, peer->od,\n                                            S_ROUTER_IN_ARP_RESOLVE, 100,\n                                            ds_cstr(match),\n                                            ds_cstr(actions),\n                                            &op->nbsp->header_);\n                    found_vip_network = true;\n                    break;\n                }\n\n                if (found_vip_network) {\n                    break;\n                }\n            }\n        }\n    } else if (lsp_is_router(op->nbsp)) {\n        /* This is a logical switch port that connects to a router. */\n\n        /* The peer of this switch port is the router port for which\n         * we need to add logical flows such that it can resolve\n         * ARP entries for all the other router ports connected to\n         * the switch in question. */\n        struct ovn_port *peer = ovn_port_get_peer(ports, op);\n        if (!peer || !peer->nbrp) {\n            return;\n        }\n\n        if (peer->od->nbr &&\n            smap_get_bool(&peer->od->nbr->options,\n                          \"dynamic_neigh_routers\", false)) {\n            return;\n        }\n\n        for (size_t i = 0; i < op->od->n_router_ports; i++) {\n            const char *router_port_name = smap_get(\n                                &op->od->router_ports[i]->nbsp->options,\n                                \"router-port\");\n            struct ovn_port *router_port = ovn_port_find(ports,\n                                                         router_port_name);\n            if (!router_port || !router_port->nbrp) {\n                continue;\n            }\n\n            /* Skip the router port under consideration. */\n            if (router_port == peer) {\n               continue;\n            }\n\n            if (router_port->lrp_networks.n_ipv4_addrs) {\n                ds_clear(match);\n                ds_put_format(match, \"outport == %s && \"\n                              REG_NEXT_HOP_IPV4 \" == \",\n                              peer->json_key);\n                op_put_v4_networks(match, router_port, false);\n\n                ds_clear(actions);\n                ds_put_format(actions, \"eth.dst = %s; next;\",\n                                          router_port->lrp_networks.ea_s);\n                ovn_lflow_add_with_hint(lflows, peer->od,\n                                        S_ROUTER_IN_ARP_RESOLVE, 100,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbsp->header_);\n            }\n\n            if (router_port->lrp_networks.n_ipv6_addrs) {\n                ds_clear(match);\n                ds_put_format(match, \"outport == %s && \"\n                              REG_NEXT_HOP_IPV6 \" == \",\n                              peer->json_key);\n                op_put_v6_networks(match, router_port);\n\n                ds_clear(actions);\n                ds_put_format(actions, \"eth.dst = %s; next;\",\n                              router_port->lrp_networks.ea_s);\n                ovn_lflow_add_with_hint(lflows, peer->od,\n                                        S_ROUTER_IN_ARP_RESOLVE, 100,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbsp->header_);\n            }\n\n            if (smap_get(&peer->od->nbr->options, \"chassis\")\n                || peer->cr_port) {\n                routable_addresses_to_lflows(lflows, router_port, peer,\n                                             match, actions);\n            }\n        }\n    }\n\n}\n\nstatic void\nbuild_icmperr_pkt_big_flows(struct ovn_port *op, int mtu, struct hmap *lflows,\n                            const struct shash *meter_groups, struct ds *match,\n                            struct ds *actions, enum ovn_stage stage,\n                            struct ovn_port *outport)\n{\n    char *outport_match = outport ? xasprintf(\"outport == %s && \",\n                                              outport->json_key)\n                                  : NULL;\n\n    if (op->lrp_networks.ipv4_addrs) {\n        ds_clear(match);\n        ds_put_format(match, \"inport == %s && %sip4 && \"REGBIT_PKT_LARGER\n                      \" && \"REGBIT_EGRESS_LOOPBACK\" == 0\", op->json_key,\n                      outport ? outport_match : \"\");\n\n        ds_clear(actions);\n        /* Set icmp4.frag_mtu to gw_mtu */\n        ds_put_format(actions,\n            \"icmp4_error {\"\n            REGBIT_EGRESS_LOOPBACK\" = 1; \"\n            REGBIT_PKT_LARGER\" = 0; \"\n            \"eth.dst = %s; \"\n            \"ip4.dst = ip4.src; \"\n            \"ip4.src = %s; \"\n            \"ip.ttl = 255; \"\n            \"icmp4.type = 3; /* Destination Unreachable. */ \"\n            \"icmp4.code = 4; /* Frag Needed and DF was Set. */ \"\n            \"icmp4.frag_mtu = %d; \"\n            \"next(pipeline=ingress, table=%d); };\",\n            op->lrp_networks.ea_s,\n            op->lrp_networks.ipv4_addrs[0].addr_s,\n            mtu, ovn_stage_get_table(S_ROUTER_IN_ADMISSION));\n        ovn_lflow_add_with_hint__(lflows, op->od, stage, 150,\n                                  ds_cstr(match), ds_cstr(actions),\n                                  NULL,\n                                  copp_meter_get(\n                                        COPP_ICMP4_ERR,\n                                        op->od->nbr->copp,\n                                        meter_groups),\n                                  &op->nbrp->header_);\n    }\n\n    if (op->lrp_networks.ipv6_addrs) {\n        ds_clear(match);\n        ds_put_format(match, \"inport == %s && %sip6 && \"REGBIT_PKT_LARGER\n                      \" && \"REGBIT_EGRESS_LOOPBACK\" == 0\", op->json_key,\n                      outport ? outport_match : \"\");\n\n        ds_clear(actions);\n        /* Set icmp6.frag_mtu to gw_mtu */\n        ds_put_format(actions,\n            \"icmp6_error {\"\n            REGBIT_EGRESS_LOOPBACK\" = 1; \"\n            REGBIT_PKT_LARGER\" = 0; \"\n            \"eth.dst = %s; \"\n            \"ip6.dst = ip6.src; \"\n            \"ip6.src = %s; \"\n            \"ip.ttl = 255; \"\n            \"icmp6.type = 2; /* Packet Too Big. */ \"\n            \"icmp6.code = 0; \"\n            \"icmp6.frag_mtu = %d; \"\n            \"next(pipeline=ingress, table=%d); };\",\n            op->lrp_networks.ea_s,\n            op->lrp_networks.ipv6_addrs[0].addr_s,\n            mtu, ovn_stage_get_table(S_ROUTER_IN_ADMISSION));\n        ovn_lflow_add_with_hint__(lflows, op->od, stage, 150,\n                                  ds_cstr(match), ds_cstr(actions),\n                                  NULL,\n                                  copp_meter_get(\n                                        COPP_ICMP6_ERR,\n                                        op->od->nbr->copp,\n                                        meter_groups),\n                                  &op->nbrp->header_);\n    }\n    free(outport_match);\n}\n\nstatic void\nbuild_check_pkt_len_flows_for_lrp(struct ovn_port *op,\n                                  struct hmap *lflows,\n                                  const struct hmap *ports,\n                                  const struct shash *meter_groups,\n                                  struct ds *match,\n                                  struct ds *actions)\n{\n    int gw_mtu = smap_get_int(&op->nbrp->options, \"gateway_mtu\", 0);\n    if (gw_mtu <= 0) {\n        return;\n    }\n\n    ds_clear(match);\n    ds_put_format(match, \"outport == %s\", op->json_key);\n    build_gateway_mtu_flow(lflows, op, S_ROUTER_IN_CHK_PKT_LEN, 50, 55,\n                           match, actions, &op->nbrp->header_, \"next;\");\n\n    /* ingress traffic */\n    build_icmperr_pkt_big_flows(op, gw_mtu, lflows, meter_groups,\n                                match, actions, S_ROUTER_IN_IP_INPUT,\n                                NULL);\n\n    for (size_t i = 0; i < op->od->nbr->n_ports; i++) {\n        struct ovn_port *rp = ovn_port_find(ports,\n                                            op->od->nbr->ports[i]->name);\n        if (!rp || rp == op) {\n            continue;\n        }\n\n        /* egress traffic */\n        build_icmperr_pkt_big_flows(rp, gw_mtu, lflows, meter_groups,\n                                    match, actions, S_ROUTER_IN_LARGER_PKTS,\n                                    op);\n    }\n}\n\n/* Local router ingress table CHK_PKT_LEN: Check packet length.\n *\n * Any IPv4 packet with outport set to the distributed gateway\n * router port, check the packet length and store the result in the\n * 'REGBIT_PKT_LARGER' register bit.\n *\n * Local router ingress table LARGER_PKTS: Handle larger packets.\n *\n * Any IPv4 packet with outport set to the distributed gateway\n * router port and the 'REGBIT_PKT_LARGER' register bit is set,\n * generate ICMPv4 packet with type 3 (Destination Unreachable) and\n * code 4 (Fragmentation needed).\n * */\nstatic void\nbuild_check_pkt_len_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        const struct hmap *ports,\n        struct ds *match, struct ds *actions,\n        const struct shash *meter_groups)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    /* Packets are allowed by default. */\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_CHK_PKT_LEN, 0, \"1\",\n                  \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_LARGER_PKTS, 0, \"1\",\n                  \"next;\");\n\n    for (size_t i = 0; i < od->nbr->n_ports; i++) {\n        struct ovn_port *rp = ovn_port_find(ports,\n                                            od->nbr->ports[i]->name);\n        if (!rp || !rp->nbrp) {\n            continue;\n        }\n        build_check_pkt_len_flows_for_lrp(rp, lflows, ports, meter_groups,\n                                          match, actions);\n    }\n}\n\n/* Logical router ingress table GW_REDIRECT: Gateway redirect. */\nstatic void\nbuild_gateway_redirect_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        struct ds *match, struct ds *actions)\n{\n    if (!od->nbr) {\n        return;\n    }\n    for (size_t i = 0; i < od->n_l3dgw_ports; i++) {\n        if (l3dgw_port_has_associated_vtep_lports(od->l3dgw_ports[i])) {\n            /* Skip adding redirect lflow for vtep-enabled l3dgw ports.\n             * Traffic from hypervisor to VTEP (ramp) switch should go in\n             * distributed manner. Only returning routed traffic must go\n             * through centralized gateway (or ha-chassis-group).\n             * This assumes that attached logical switch with vtep lport(s) has\n             * no localnet port(s) for NAT. Otherwise centralized NAT will not\n             * work. */\n            continue;\n        }\n\n        const struct ovsdb_idl_row *stage_hint = NULL;\n        bool add_def_flow = true;\n\n        if (od->l3dgw_ports[i]->nbrp) {\n            stage_hint = &od->l3dgw_ports[i]->nbrp->header_;\n        }\n\n        /* For traffic with outport == l3dgw_port, if the\n         * packet did not match any higher priority redirect\n         * rule, then the traffic is redirected to the central\n         * instance of the l3dgw_port. */\n        ds_clear(match);\n        ds_put_format(match, \"outport == %s\",\n                      od->l3dgw_ports[i]->json_key);\n        ds_clear(actions);\n        ds_put_format(actions, \"outport = %s; next;\",\n                      od->l3dgw_ports[i]->cr_port->json_key);\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_GW_REDIRECT, 50,\n                                ds_cstr(match), ds_cstr(actions),\n                                stage_hint);\n        for (int j = 0; j < od->n_nat_entries; j++) {\n            const struct ovn_nat *nat = &od->nat_entries[j];\n\n            if (!lrouter_dnat_and_snat_is_stateless(nat->nb) ||\n                (!nat->nb->allowed_ext_ips && !nat->nb->exempted_ext_ips)) {\n                continue;\n            }\n\n            struct ds match_ext = DS_EMPTY_INITIALIZER;\n            struct nbrec_address_set  *as = nat->nb->allowed_ext_ips\n                ? nat->nb->allowed_ext_ips : nat->nb->exempted_ext_ips;\n            ds_put_format(&match_ext, \"%s && ip%s.src == $%s\",\n                          ds_cstr(match), nat_entry_is_v6(nat) ? \"6\" : \"4\",\n                          as->name);\n\n            if (nat->nb->allowed_ext_ips) {\n                ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_GW_REDIRECT,\n                                        75, ds_cstr(&match_ext),\n                                        ds_cstr(actions), stage_hint);\n                if (add_def_flow) {\n                    ds_clear(&match_ext);\n                    ds_put_format(&match_ext, \"ip && ip%s.dst == %s\",\n                                  nat_entry_is_v6(nat) ? \"6\" : \"4\",\n                                  nat->nb->external_ip);\n                    ovn_lflow_add(lflows, od, S_ROUTER_IN_GW_REDIRECT, 70,\n                                  ds_cstr(&match_ext), debug_drop_action());\n                    add_def_flow = false;\n                }\n            } else if (nat->nb->exempted_ext_ips) {\n                ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_GW_REDIRECT,\n                                        75, ds_cstr(&match_ext),\n                                        debug_drop_action(),\n                                        stage_hint);\n            }\n            ds_destroy(&match_ext);\n        }\n    }\n\n    /* Packets are allowed by default. */\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_GW_REDIRECT, 0, \"1\", \"next;\");\n}\n\n/* Local router ingress table ARP_REQUEST: ARP request.\n *\n * In the common case where the Ethernet destination has been resolved,\n * this table outputs the packet (priority 0).  Otherwise, it composes\n * and sends an ARP/IPv6 NA request (priority 100). */\nstatic void\nbuild_arp_request_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        struct ds *match, struct ds *actions,\n        const struct shash *meter_groups)\n{\n    if (od->nbr) {\n        for (int i = 0; i < od->nbr->n_static_routes; i++) {\n            const struct nbrec_logical_router_static_route *route;\n\n            route = od->nbr->static_routes[i];\n            struct in6_addr gw_ip6;\n            unsigned int plen;\n            char *error = ipv6_parse_cidr(route->nexthop, &gw_ip6, &plen);\n            if (error || plen != 128) {\n                free(error);\n                continue;\n            }\n\n            ds_clear(match);\n            ds_put_format(match, \"eth.dst == 00:00:00:00:00:00 && \"\n                          \"ip6 && \" REG_NEXT_HOP_IPV6 \" == %s\",\n                          route->nexthop);\n            struct in6_addr sn_addr;\n            struct eth_addr eth_dst;\n            in6_addr_solicited_node(&sn_addr, &gw_ip6);\n            ipv6_multicast_to_ethernet(&eth_dst, &sn_addr);\n\n            char sn_addr_s[INET6_ADDRSTRLEN + 1];\n            ipv6_string_mapped(sn_addr_s, &sn_addr);\n\n            ds_clear(actions);\n            ds_put_format(actions,\n                          \"nd_ns { \"\n                          \"eth.dst = \"ETH_ADDR_FMT\"; \"\n                          \"ip6.dst = %s; \"\n                          \"nd.target = %s; \"\n                          \"output; \"\n                          \"};\", ETH_ADDR_ARGS(eth_dst), sn_addr_s,\n                          route->nexthop);\n\n            ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_ARP_REQUEST, 200,\n                                      ds_cstr(match), ds_cstr(actions), NULL,\n                                      copp_meter_get(COPP_ND_NS_RESOLVE,\n                                                     od->nbr->copp,\n                                                     meter_groups),\n                                      &route->header_);\n        }\n\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_ARP_REQUEST, 100,\n                          \"eth.dst == 00:00:00:00:00:00 && ip4\",\n                          \"arp { \"\n                          \"eth.dst = ff:ff:ff:ff:ff:ff; \"\n                          \"arp.spa = \" REG_SRC_IPV4 \"; \"\n                          \"arp.tpa = \" REG_NEXT_HOP_IPV4 \"; \"\n                          \"arp.op = 1; \" /* ARP request */\n                          \"output; \"\n                          \"};\",\n                          copp_meter_get(COPP_ARP_RESOLVE, od->nbr->copp,\n                                         meter_groups));\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_ARP_REQUEST, 100,\n                          \"eth.dst == 00:00:00:00:00:00 && ip6\",\n                          \"nd_ns { \"\n                          \"nd.target = \" REG_NEXT_HOP_IPV6 \"; \"\n                          \"output; \"\n                          \"};\",\n                          copp_meter_get(COPP_ND_NS_RESOLVE, od->nbr->copp,\n                                         meter_groups));\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ARP_REQUEST, 0, \"1\", \"output;\");\n    }\n}\n\n/* Logical router egress table DELIVERY: Delivery (priority 100-110).\n *\n * Priority 100 rules deliver packets to enabled logical ports.\n * Priority 110 rules match multicast packets and update the source\n * mac before delivering to enabled logical ports. IP multicast traffic\n * bypasses S_ROUTER_IN_IP_ROUTING route lookups.\n */\nstatic void\nbuild_egress_delivery_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match, struct ds *actions)\n{\n    if (op->nbrp) {\n        if (!lrport_is_enabled(op->nbrp)) {\n            /* Drop packets to disabled logical ports (since logical flow\n             * tables are default-drop). */\n            return;\n        }\n\n        if (is_cr_port(op)) {\n            /* No egress packets should be processed in the context of\n             * a chassisredirect port.  The chassisredirect port should\n             * be replaced by the l3dgw port in the local output\n             * pipeline stage before egress processing. */\n            return;\n        }\n\n        /* If multicast relay is enabled then also adjust source mac for IP\n         * multicast traffic.\n         */\n        if (op->od->mcast_info.rtr.relay) {\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match, \"(ip4.mcast || ip6.mcast) && outport == %s\",\n                          op->json_key);\n            ds_put_format(actions, \"eth.src = %s; output;\",\n                          op->lrp_networks.ea_s);\n            ovn_lflow_add(lflows, op->od, S_ROUTER_OUT_DELIVERY, 110,\n                          ds_cstr(match), ds_cstr(actions));\n        }\n\n        ds_clear(match);\n        ds_put_format(match, \"outport == %s\", op->json_key);\n        ovn_lflow_add(lflows, op->od, S_ROUTER_OUT_DELIVERY, 100,\n                      ds_cstr(match), \"output;\");\n\n        ovn_lflow_add_default_drop(lflows, op->od, S_ROUTER_OUT_DELIVERY);\n    }\n\n}\n\nstatic void\nbuild_misc_local_traffic_drop_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (od->nbr) {\n        /* Allow IGMP and MLD packets (with TTL = 1) if the router is\n         * configured to flood them statically on some ports.\n         */\n        if (od->mcast_info.rtr.flood_static) {\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 120,\n                          \"igmp && ip.ttl == 1\", \"next;\");\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 120,\n                          \"(mldv1 || mldv2) && ip.ttl == 1\", \"next;\");\n        }\n\n        /* L3 admission control: drop multicast and broadcast source, localhost\n         * source or destination, and zero network source or destination\n         * (priority 100). */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 100,\n                      \"ip4.src_mcast ||\"\n                      \"ip4.src == 255.255.255.255 || \"\n                      \"ip4.src == 127.0.0.0/8 || \"\n                      \"ip4.dst == 127.0.0.0/8 || \"\n                      \"ip4.src == 0.0.0.0/8 || \"\n                      \"ip4.dst == 0.0.0.0/8\",\n                      debug_drop_action());\n\n        /* Drop ARP packets (priority 85). ARP request packets for router's own\n         * IPs are handled with priority-90 flows.\n         * Drop IPv6 ND packets (priority 85). ND NA packets for router's own\n         * IPs are handled with priority-90 flows.\n         */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 85,\n                      \"arp || nd\", debug_drop_action());\n\n        /* Allow IPv6 multicast traffic that's supposed to reach the\n         * router pipeline (e.g., router solicitations).\n         */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 84, \"nd_rs || nd_ra\",\n                      \"next;\");\n\n        /* Drop other reserved multicast. */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 83,\n                      \"ip6.mcast_rsvd\", debug_drop_action());\n\n        /* Allow other multicast if relay enabled (priority 82). */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 82,\n                      \"ip4.mcast || ip6.mcast\",\n                      (od->mcast_info.rtr.relay ? \"next;\" :\n                                                  debug_drop_action()));\n\n        /* Drop Ethernet local broadcast.  By definition this traffic should\n         * not be forwarded.*/\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 50,\n                      \"eth.bcast\", debug_drop_action());\n\n        /* Avoid ICMP time exceeded for multicast, silent drop instead.\n         * See RFC1812 section 5.3.1:\n         *  If the TTL is reduced to zero (or less), the packet MUST be\n         *  discarded, and if the destination is NOT A MULTICAST address the\n         *  router MUST send an ICMP Time Exceeded message ...\n         *\n         * The reason behind is that TTL has special meanings for multicast.\n         * For example, TTL = 1 means restricted to the same subnet, not\n         * forwarded by the router. So it is very common to see multicast\n         * packets with ttl = 1, and generating ICMP for such packets is\n         * harmful from both slowpath performance and functionality point of\n         * view.\n         *\n         * (priority-31 flows will send ICMP time exceeded) */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 32,\n                      \"ip.ttl == {0, 1} && !ip.later_frag && \"\n                      \"(ip4.mcast || ip6.mcast)\", debug_drop_action());\n\n        /* TTL discard */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 30,\n                      \"ip.ttl == {0, 1}\", debug_drop_action());\n\n        /* Pass other traffic not already handled to the next table for\n         * routing. */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 0, \"1\", \"next;\");\n    }\n}\n\nstatic void\nbuild_dhcpv6_reply_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match)\n{\n    if (op->nbrp && (!op->l3dgw_port)) {\n        for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n            ds_clear(match);\n            ds_put_format(match, \"ip6.dst == %s && udp.src == 547 &&\"\n                          \" udp.dst == 546\",\n                          op->lrp_networks.ipv6_addrs[i].addr_s);\n            ovn_lflow_add(lflows, op->od, S_ROUTER_IN_IP_INPUT, 100,\n                          ds_cstr(match),\n                          \"reg0 = 0; handle_dhcpv6_reply;\");\n        }\n    }\n\n}\n\nstatic void\nbuild_ipv6_input_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match, struct ds *actions,\n        const struct shash *meter_groups)\n{\n    if (op->nbrp && !is_cr_port(op)) {\n        /* No ingress packets are accepted on a chassisredirect\n         * port, so no need to program flows for that port. */\n        if (op->lrp_networks.n_ipv6_addrs) {\n            /* ICMPv6 echo reply.  These flows reply to echo requests\n             * received for the router's IP address. */\n            ds_clear(match);\n            ds_put_cstr(match, \"ip6.dst == \");\n            op_put_v6_networks(match, op);\n            ds_put_cstr(match, \" && icmp6.type == 128 && icmp6.code == 0\");\n\n            const char *lrp_actions =\n                        \"ip6.dst <-> ip6.src; \"\n                        \"ip.ttl = 255; \"\n                        \"icmp6.type = 129; \"\n                        \"flags.loopback = 1; \"\n                        \"next; \";\n            ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 90,\n                                    ds_cstr(match), lrp_actions,\n                                    &op->nbrp->header_);\n        }\n\n        /* ND reply.  These flows reply to ND solicitations for the\n         * router's own IP address. */\n        for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n            ds_clear(match);\n            if (is_l3dgw_port(op)) {\n                /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s\n                 * should only be sent from the gateway chassi, so that\n                 * upstream MAC learning points to the gateway chassis.\n                 * Also need to avoid generation of multiple ND replies\n                 * from different chassis. */\n                ds_put_format(match, \"is_chassis_resident(%s)\",\n                              op->cr_port->json_key);\n            }\n\n            build_lrouter_nd_flow(op->od, op, \"nd_na_router\",\n                                  op->lrp_networks.ipv6_addrs[i].addr_s,\n                                  op->lrp_networks.ipv6_addrs[i].sn_addr_s,\n                                  REG_INPORT_ETH_ADDR, match, false, 90,\n                                  &op->nbrp->header_, lflows, meter_groups);\n        }\n\n        /* UDP/TCP/SCTP port unreachable */\n        if (!op->od->is_gw_router && !op->od->n_l3dgw_ports) {\n            for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip6 && ip6.dst == %s && !ip.later_frag && tcp\",\n                              op->lrp_networks.ipv6_addrs[i].addr_s);\n                const char *action = \"tcp_reset {\"\n                                     \"eth.dst <-> eth.src; \"\n                                     \"ip6.dst <-> ip6.src; \"\n                                     \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_TCP_RESET,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip6 && ip6.dst == %s && !ip.later_frag && sctp\",\n                              op->lrp_networks.ipv6_addrs[i].addr_s);\n                action = \"sctp_abort {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip6.dst <-> ip6.src; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_TCP_RESET,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip6 && ip6.dst == %s && !ip.later_frag && udp\",\n                              op->lrp_networks.ipv6_addrs[i].addr_s);\n                action = \"icmp6 {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip6.dst <-> ip6.src; \"\n                         \"ip.ttl = 255; \"\n                         \"icmp6.type = 1; \"\n                         \"icmp6.code = 4; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_ICMP6_ERR,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip6 && ip6.dst == %s && !ip.later_frag\",\n                              op->lrp_networks.ipv6_addrs[i].addr_s);\n                action = \"icmp6 {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip6.dst <-> ip6.src; \"\n                         \"ip.ttl = 255; \"\n                         \"icmp6.type = 1; \"\n                         \"icmp6.code = 3; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          70, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_ICMP6_ERR,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n            }\n        }\n\n        /* ICMPv6 time exceeded */\n        struct ds ip_ds = DS_EMPTY_INITIALIZER;\n        for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n            /* skip link-local address */\n            if (in6_is_lla(&op->lrp_networks.ipv6_addrs[i].network)) {\n                continue;\n            }\n\n            ds_clear(match);\n            ds_clear(actions);\n            ds_clear(&ip_ds);\n            if (is_l3dgw_port(op)) {\n                ds_put_cstr(&ip_ds, \"ip6.dst <-> ip6.src\");\n            } else {\n                ds_put_format(&ip_ds, \"ip6.dst = ip6.src; ip6.src = %s\",\n                              op->lrp_networks.ipv6_addrs[i].addr_s);\n            }\n            ds_put_format(match,\n                          \"inport == %s && ip6 && \"\n                          \"ip6.src == %s/%d && \"\n                          \"ip.ttl == {0, 1} && !ip.later_frag\",\n                          op->json_key,\n                          op->lrp_networks.ipv6_addrs[i].network_s,\n                          op->lrp_networks.ipv6_addrs[i].plen);\n            ds_put_format(actions,\n                          \"icmp6 {\"\n                          \"eth.dst <-> eth.src; \"\n                          \"%s ; ip.ttl = 254; \"\n                          \"icmp6.type = 3; /* Time exceeded */ \"\n                          \"icmp6.code = 0; /* TTL exceeded in transit */ \"\n                          \"outport = %s; flags.loopback = 1; output; };\",\n                          ds_cstr(&ip_ds), op->json_key);\n            ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                    31, ds_cstr(match), ds_cstr(actions), NULL,\n                    copp_meter_get(COPP_ICMP6_ERR, op->od->nbr->copp,\n                                   meter_groups),\n                    &op->nbrp->header_);\n        }\n        ds_destroy(&ip_ds);\n    }\n\n}\n\nstatic void\nbuild_lrouter_arp_nd_for_datapath(struct ovn_datapath *od,\n                                  struct hmap *lflows,\n                                  const struct shash *meter_groups)\n{\n    if (od->nbr) {\n\n        /* Priority-90-92 flows handle ARP requests and ND packets. Most are\n         * per logical port but DNAT addresses can be handled per datapath\n         * for non gateway router ports.\n         *\n         * Priority 91 and 92 flows are added for each gateway router\n         * port to handle the special cases. In case we get the packet\n         * on a regular port, just reply with the port's ETH address.\n         */\n        for (int i = 0; i < od->nbr->n_nat; i++) {\n            struct ovn_nat *nat_entry = &od->nat_entries[i];\n\n            /* Skip entries we failed to parse. */\n            if (!nat_entry_is_valid(nat_entry)) {\n                continue;\n            }\n\n            /* Skip SNAT entries for now, we handle unique SNAT IPs separately\n             * below.\n             */\n            if (!strcmp(nat_entry->nb->type, \"snat\")) {\n                continue;\n            }\n            build_lrouter_nat_arp_nd_flow(od, nat_entry, lflows, meter_groups);\n        }\n\n        /* Now handle SNAT entries too, one per unique SNAT IP. */\n        struct shash_node *snat_snode;\n        SHASH_FOR_EACH (snat_snode, &od->snat_ips) {\n            struct ovn_snat_ip *snat_ip = snat_snode->data;\n\n            if (ovs_list_is_empty(&snat_ip->snat_entries)) {\n                continue;\n            }\n\n            struct ovn_nat *nat_entry =\n                CONTAINER_OF(ovs_list_front(&snat_ip->snat_entries),\n                             struct ovn_nat, ext_addr_list_node);\n            build_lrouter_nat_arp_nd_flow(od, nat_entry, lflows, meter_groups);\n        }\n    }\n}\n\n/* Logical router ingress table 3: IP Input for IPv4. */\nstatic void\nbuild_lrouter_ipv4_ip_input(struct ovn_port *op,\n                            struct hmap *lflows,\n                            struct ds *match, struct ds *actions,\n                            const struct shash *meter_groups)\n{\n    /* No ingress packets are accepted on a chassisredirect\n     * port, so no need to program flows for that port. */\n    if (op->nbrp && !is_cr_port(op)) {\n        if (op->lrp_networks.n_ipv4_addrs) {\n            /* L3 admission control: drop packets that originate from an\n             * IPv4 address owned by the router or a broadcast address\n             * known to the router (priority 100). */\n            ds_clear(match);\n            ds_put_cstr(match, \"ip4.src == \");\n            op_put_v4_networks(match, op, true);\n            ds_put_cstr(match, \" && \"REGBIT_EGRESS_LOOPBACK\" == 0\");\n            ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 100,\n                                    ds_cstr(match), debug_drop_action(),\n                                    &op->nbrp->header_);\n\n            /* ICMP echo reply.  These flows reply to ICMP echo requests\n             * received for the router's IP address. Since packets only\n             * get here as part of the logical router datapath, the inport\n             * (i.e. the incoming locally attached net) does not matter.\n             * The ip.ttl also does not matter (RFC1812 section 4.2.2.9) */\n            ds_clear(match);\n            ds_put_cstr(match, \"ip4.dst == \");\n            op_put_v4_networks(match, op, false);\n            ds_put_cstr(match, \" && icmp4.type == 8 && icmp4.code == 0\");\n\n            const char * icmp_actions = \"ip4.dst <-> ip4.src; \"\n                          \"ip.ttl = 255; \"\n                          \"icmp4.type = 0; \"\n                          \"flags.loopback = 1; \"\n                          \"next; \";\n            ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 90,\n                                    ds_cstr(match), icmp_actions,\n                                    &op->nbrp->header_);\n        }\n\n        /* BFD msg handling */\n        build_lrouter_bfd_flows(lflows, op, meter_groups);\n\n        /* ICMP time exceeded */\n        struct ds ip_ds = DS_EMPTY_INITIALIZER;\n        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            ds_clear(match);\n            ds_clear(actions);\n            ds_clear(&ip_ds);\n            if (is_l3dgw_port(op)) {\n                ds_put_cstr(&ip_ds, \"ip4.dst <-> ip4.src\");\n            } else {\n                ds_put_format(&ip_ds, \"ip4.dst = ip4.src; ip4.src = %s\",\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n            }\n            ds_put_format(match,\n                          \"inport == %s && ip4 && \"\n                          \"ip.ttl == {0, 1} && !ip.later_frag\", op->json_key);\n            ds_put_format(actions,\n                          \"icmp4 {\"\n                          \"eth.dst <-> eth.src; \"\n                          \"icmp4.type = 11; /* Time exceeded */ \"\n                          \"icmp4.code = 0; /* TTL exceeded in transit */ \"\n                          \"%s ; ip.ttl = 254; \"\n                          \"outport = %s; flags.loopback = 1; output; };\",\n                          ds_cstr(&ip_ds), op->json_key);\n            ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                    31, ds_cstr(match), ds_cstr(actions), NULL,\n                    copp_meter_get(COPP_ICMP4_ERR, op->od->nbr->copp,\n                                   meter_groups),\n                    &op->nbrp->header_);\n\n        }\n        ds_destroy(&ip_ds);\n\n        /* ARP reply.  These flows reply to ARP requests for the router's own\n         * IP address. */\n        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            ds_clear(match);\n            ds_put_format(match, \"arp.spa == %s/%u\",\n                          op->lrp_networks.ipv4_addrs[i].network_s,\n                          op->lrp_networks.ipv4_addrs[i].plen);\n\n            if (op->od->n_l3dgw_ports && op->peer\n                && op->peer->od->n_localnet_ports) {\n                bool add_chassis_resident_check = false;\n                const char *json_key;\n                if (is_l3dgw_port(op)) {\n                    /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s\n                     * should only be sent from the gateway chassis, so that\n                     * upstream MAC learning points to the gateway chassis.\n                     * Also need to avoid generation of multiple ARP responses\n                     * from different chassis. */\n                    add_chassis_resident_check = true;\n                    json_key = op->cr_port->json_key;\n                } else {\n                    /* Check if the option 'reside-on-redirect-chassis'\n                     * is set to true on the router port. If set to true\n                     * and if peer's logical switch has a localnet port, it\n                     * means the router pipeline for the packets from\n                     * peer's logical switch is be run on the chassis\n                     * hosting the gateway port and it should reply to the\n                     * ARP requests for the router port IPs.\n                     */\n                    add_chassis_resident_check = smap_get_bool(\n                        &op->nbrp->options,\n                        \"reside-on-redirect-chassis\", false) &&\n                        op->od->n_l3dgw_ports == 1;\n                    json_key = op->od->l3dgw_ports[0]->cr_port->json_key;\n                }\n\n                if (add_chassis_resident_check) {\n                    ds_put_format(match, \" && is_chassis_resident(%s)\",\n                                  json_key);\n                }\n            }\n\n            build_lrouter_arp_flow(op->od, op,\n                                   op->lrp_networks.ipv4_addrs[i].addr_s,\n                                   REG_INPORT_ETH_ADDR, match, false, 90,\n                                   &op->nbrp->header_, lflows);\n        }\n\n        if (sset_count(&op->od->lb_ips->ips_v4_reachable)) {\n            ds_clear(match);\n            if (is_l3dgw_port(op)) {\n                ds_put_format(match, \"is_chassis_resident(%s)\",\n                              op->cr_port->json_key);\n            }\n\n            /* Create a single ARP rule for all IPs that are used as VIPs. */\n            char *lb_ips_v4_as = lr_lb_address_set_ref(op->od->tunnel_key,\n                                                       AF_INET);\n            build_lrouter_arp_flow(op->od, op, lb_ips_v4_as,\n                                   REG_INPORT_ETH_ADDR,\n                                   match, false, 90, NULL, lflows);\n            free(lb_ips_v4_as);\n        }\n\n        if (sset_count(&op->od->lb_ips->ips_v6_reachable)) {\n            ds_clear(match);\n\n            if (is_l3dgw_port(op)) {\n                ds_put_format(match, \"is_chassis_resident(%s)\",\n                              op->cr_port->json_key);\n            }\n\n            /* Create a single ND rule for all IPs that are used as VIPs. */\n            char *lb_ips_v6_as = lr_lb_address_set_ref(op->od->tunnel_key,\n                                                       AF_INET6);\n            build_lrouter_nd_flow(op->od, op, \"nd_na\", lb_ips_v6_as, NULL,\n                                  REG_INPORT_ETH_ADDR, match, false, 90,\n                                  NULL, lflows, meter_groups);\n            free(lb_ips_v6_as);\n        }\n\n        if (!op->od->is_gw_router && !op->od->n_l3dgw_ports) {\n            /* UDP/TCP/SCTP port unreachable. */\n            for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip4 && ip4.dst == %s && !ip.later_frag && udp\",\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n                const char *action = \"icmp4 {\"\n                                     \"eth.dst <-> eth.src; \"\n                                     \"ip4.dst <-> ip4.src; \"\n                                     \"ip.ttl = 255; \"\n                                     \"icmp4.type = 3; \"\n                                     \"icmp4.code = 3; \"\n                                     \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_ICMP4_ERR,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip4 && ip4.dst == %s && !ip.later_frag && tcp\",\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n                action = \"tcp_reset {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip4.dst <-> ip4.src; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_TCP_RESET,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip4 && ip4.dst == %s && !ip.later_frag && sctp\",\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n                action = \"sctp_abort {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip4.dst <-> ip4.src; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_TCP_RESET,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip4 && ip4.dst == %s && !ip.later_frag\",\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n                action = \"icmp4 {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip4.dst <-> ip4.src; \"\n                         \"ip.ttl = 255; \"\n                         \"icmp4.type = 3; \"\n                         \"icmp4.code = 2; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          70, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_ICMP4_ERR,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n            }\n        }\n\n        /* Drop IP traffic destined to router owned IPs except if the IP is\n         * also a SNAT IP. Those are dropped later, in stage\n         * \"lr_in_arp_resolve\", if unSNAT was unsuccessful.\n         *\n         * If op->od->lb_force_snat_router_ip is true, it means the IP of the\n         * router port is also SNAT IP.\n         *\n         * Priority 60.\n         */\n        if (!op->od->lb_force_snat_router_ip) {\n            build_lrouter_drop_own_dest(op, S_ROUTER_IN_IP_INPUT, 60, false,\n                                        lflows);\n        }\n        /* ARP / ND handling for external IP addresses.\n         *\n         * DNAT and SNAT IP addresses are external IP addresses that need ARP\n         * handling.\n         *\n         * These are already taken care globally, per router. The only\n         * exception is on the l3dgw_port where we might need to use a\n         * different ETH address.\n         */\n        if (!is_l3dgw_port(op)) {\n            return;\n        }\n\n        for (size_t i = 0; i < op->od->nbr->n_nat; i++) {\n            struct ovn_nat *nat_entry = &op->od->nat_entries[i];\n\n            /* Skip entries we failed to parse. */\n            if (!nat_entry_is_valid(nat_entry)) {\n                continue;\n            }\n\n            /* Skip SNAT entries for now, we handle unique SNAT IPs separately\n             * below.\n             */\n            if (!strcmp(nat_entry->nb->type, \"snat\")) {\n                continue;\n            }\n            build_lrouter_port_nat_arp_nd_flow(op, nat_entry, lflows,\n                                               meter_groups);\n        }\n\n        /* Now handle SNAT entries too, one per unique SNAT IP. */\n        struct shash_node *snat_snode;\n        SHASH_FOR_EACH (snat_snode, &op->od->snat_ips) {\n            struct ovn_snat_ip *snat_ip = snat_snode->data;\n\n            if (ovs_list_is_empty(&snat_ip->snat_entries)) {\n                continue;\n            }\n\n            struct ovn_nat *nat_entry =\n                CONTAINER_OF(ovs_list_front(&snat_ip->snat_entries),\n                             struct ovn_nat, ext_addr_list_node);\n            build_lrouter_port_nat_arp_nd_flow(op, nat_entry, lflows,\n                                               meter_groups);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_in_unsnat_flow(struct hmap *lflows, struct ovn_datapath *od,\n                             const struct nbrec_nat *nat, struct ds *match,\n                             struct ds *actions, bool distributed, bool is_v6,\n                             struct ovn_port *l3dgw_port)\n{\n    /* Ingress UNSNAT table: It is for already established connections'\n    * reverse traffic. i.e., SNAT has already been done in egress\n    * pipeline and now the packet has entered the ingress pipeline as\n    * part of a reply. We undo the SNAT here.\n    *\n    * Undoing SNAT has to happen before DNAT processing.  This is\n    * because when the packet was DNATed in ingress pipeline, it did\n    * not know about the possibility of eventual additional SNAT in\n    * egress pipeline. */\n    if (strcmp(nat->type, \"snat\") && strcmp(nat->type, \"dnat_and_snat\")) {\n        return;\n    }\n\n    bool stateless = lrouter_dnat_and_snat_is_stateless(nat);\n    if (od->is_gw_router) {\n        ds_clear(match);\n        ds_clear(actions);\n        ds_put_format(match, \"ip && ip%s.dst == %s\",\n                      is_v6 ? \"6\" : \"4\", nat->external_ip);\n        if (stateless) {\n            ds_put_format(actions, \"next;\");\n        } else {\n            ds_put_cstr(actions, \"ct_snat;\");\n        }\n\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT,\n                                90, ds_cstr(match), ds_cstr(actions),\n                                &nat->header_);\n    } else {\n        /* Distributed router. */\n\n        /* Traffic received on l3dgw_port is subject to NAT. */\n        ds_clear(match);\n        ds_clear(actions);\n        ds_put_format(match, \"ip && ip%s.dst == %s && inport == %s && \"\n                      \"flags.loopback == 0\", is_v6 ? \"6\" : \"4\",\n                      nat->external_ip, l3dgw_port->json_key);\n        if (!distributed && od->n_l3dgw_ports) {\n            /* Flows for NAT rules that are centralized are only\n            * programmed on the gateway chassis. */\n            ds_put_format(match, \" && is_chassis_resident(%s)\",\n                          l3dgw_port->cr_port->json_key);\n        }\n\n        if (stateless) {\n            ds_put_format(actions, \"next;\");\n        } else {\n            ds_put_cstr(actions, \"ct_snat_in_czone;\");\n        }\n\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT,\n                                100, ds_cstr(match), ds_cstr(actions),\n                                &nat->header_);\n\n        if (!stateless) {\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match, \"ip && ip%s.dst == %s && inport == %s && \"\n                          \"flags.loopback == 1 && flags.use_snat_zone == 1\",\n                          is_v6 ? \"6\" : \"4\", nat->external_ip,\n                          l3dgw_port->json_key);\n            if (!distributed && od->n_l3dgw_ports) {\n                /* Flows for NAT rules that are centralized are only\n                * programmed on the gateway chassis. */\n                ds_put_format(match, \" && is_chassis_resident(%s)\",\n                            l3dgw_port->cr_port->json_key);\n            }\n            ds_put_cstr(actions, \"ct_snat;\");\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT,\n                                    100, ds_cstr(match), ds_cstr(actions),\n                                    &nat->header_);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_in_dnat_flow(struct hmap *lflows, struct ovn_datapath *od,\n                           const struct nbrec_nat *nat, struct ds *match,\n                           struct ds *actions, bool distributed,\n                           int cidr_bits, bool is_v6,\n                           struct ovn_port *l3dgw_port)\n{\n    /* Ingress DNAT table: Packets enter the pipeline with destination\n    * IP address that needs to be DNATted from a external IP address\n    * to a logical IP address. */\n    if (!strcmp(nat->type, \"dnat\") || !strcmp(nat->type, \"dnat_and_snat\")) {\n        bool stateless = lrouter_dnat_and_snat_is_stateless(nat);\n\n        if (od->is_gw_router) {\n            /* Packet when it goes from the initiator to destination.\n             * We need to set flags.loopback because the router can\n             * send the packet back through the same interface. */\n            ds_clear(match);\n            ds_put_format(match, \"ip && ip%s.dst == %s\",\n                          is_v6 ? \"6\" : \"4\", nat->external_ip);\n            ds_clear(actions);\n            if (nat->allowed_ext_ips || nat->exempted_ext_ips) {\n                lrouter_nat_add_ext_ip_match(od, lflows, match, nat,\n                                             is_v6, true, cidr_bits);\n            }\n\n            if (!lport_addresses_is_empty(&od->dnat_force_snat_addrs)) {\n                /* Indicate to the future tables that a DNAT has taken\n                 * place and a force SNAT needs to be done in the\n                 * Egress SNAT table. */\n                ds_put_format(actions, \"flags.force_snat_for_dnat = 1; \");\n            }\n\n            if (stateless) {\n                ds_put_format(actions, \"flags.loopback = 1; \"\n                              \"ip%s.dst=%s; next;\",\n                              is_v6 ? \"6\" : \"4\", nat->logical_ip);\n            } else {\n                ds_put_format(actions, \"flags.loopback = 1; ct_dnat(%s\",\n                              nat->logical_ip);\n\n                if (nat->external_port_range[0]) {\n                    ds_put_format(actions, \",%s\", nat->external_port_range);\n                }\n                ds_put_format(actions, \");\");\n            }\n\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_DNAT, 100,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &nat->header_);\n        } else {\n            /* Distributed router. */\n\n            /* Traffic received on l3dgw_port is subject to NAT. */\n            ds_clear(match);\n            ds_put_format(match, \"ip && ip%s.dst == %s && inport == %s\",\n                          is_v6 ? \"6\" : \"4\", nat->external_ip,\n                          l3dgw_port->json_key);\n            if (!distributed && od->n_l3dgw_ports) {\n                /* Flows for NAT rules that are centralized are only\n                * programmed on the gateway chassis. */\n                ds_put_format(match, \" && is_chassis_resident(%s)\",\n                              l3dgw_port->cr_port->json_key);\n            }\n            ds_clear(actions);\n            if (nat->allowed_ext_ips || nat->exempted_ext_ips) {\n                lrouter_nat_add_ext_ip_match(od, lflows, match, nat,\n                                             is_v6, true, cidr_bits);\n            }\n\n            if (!strcmp(nat->type, \"dnat_and_snat\") && stateless) {\n                ds_put_format(actions, \"ip%s.dst=%s; next;\",\n                              is_v6 ? \"6\" : \"4\", nat->logical_ip);\n            } else {\n                ds_put_format(actions, \"ct_dnat_in_czone(%s\", nat->logical_ip);\n                if (nat->external_port_range[0]) {\n                    ds_put_format(actions, \",%s\", nat->external_port_range);\n                }\n                ds_put_format(actions, \");\");\n            }\n\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_DNAT, 100,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &nat->header_);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_out_undnat_flow(struct hmap *lflows, struct ovn_datapath *od,\n                              const struct nbrec_nat *nat, struct ds *match,\n                              struct ds *actions, bool distributed,\n                              struct eth_addr mac, bool is_v6,\n                              struct ovn_port *l3dgw_port)\n{\n    /* Egress UNDNAT table: It is for already established connections'\n    * reverse traffic. i.e., DNAT has already been done in ingress\n    * pipeline and now the packet has entered the egress pipeline as\n    * part of a reply. We undo the DNAT here.\n    *\n    * Note that this only applies for NAT on a distributed router.\n    */\n    if (!od->n_l3dgw_ports ||\n        (strcmp(nat->type, \"dnat\") && strcmp(nat->type, \"dnat_and_snat\"))) {\n        return;\n    }\n\n    ds_clear(match);\n    ds_put_format(match, \"ip && ip%s.src == %s && outport == %s\",\n                  is_v6 ? \"6\" : \"4\", nat->logical_ip,\n                  l3dgw_port->json_key);\n    if (!distributed && od->n_l3dgw_ports) {\n        /* Flows for NAT rules that are centralized are only\n        * programmed on the gateway chassis. */\n        ds_put_format(match, \" && is_chassis_resident(%s)\",\n                      l3dgw_port->cr_port->json_key);\n    }\n    ds_clear(actions);\n    if (distributed) {\n        ds_put_format(actions, \"eth.src = \"ETH_ADDR_FMT\"; \",\n                      ETH_ADDR_ARGS(mac));\n    }\n\n    if (lrouter_dnat_and_snat_is_stateless(nat)) {\n        ds_put_format(actions, \"next;\");\n    } else {\n        ds_put_format(actions,\n                      od->is_gw_router ? \"ct_dnat;\" : \"ct_dnat_in_czone;\");\n    }\n\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_UNDNAT, 100,\n                            ds_cstr(match), ds_cstr(actions),\n                            &nat->header_);\n}\n\nstatic void\nbuild_lrouter_out_is_dnat_local(struct hmap *lflows, struct ovn_datapath *od,\n                                const struct nbrec_nat *nat, struct ds *match,\n                                struct ds *actions, bool distributed,\n                                bool is_v6, struct ovn_port *l3dgw_port)\n{\n    /* Note that this only applies for NAT on a distributed router.\n     */\n    if (!od->n_l3dgw_ports) {\n        return;\n    }\n\n    ds_clear(match);\n    ds_put_format(match, \"ip && ip%s.dst == %s && \",\n                  is_v6 ? \"6\" : \"4\", nat->external_ip);\n    if (distributed) {\n        ds_put_format(match, \"is_chassis_resident(\\\"%s\\\")\", nat->logical_port);\n    } else {\n        ds_put_format(match, \"is_chassis_resident(%s)\",\n                      l3dgw_port->cr_port->json_key);\n    }\n\n    ds_clear(actions);\n    ds_put_cstr(actions, REGBIT_DST_NAT_IP_LOCAL\" = 1; next;\");\n\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_CHECK_DNAT_LOCAL,\n                            50, ds_cstr(match), ds_cstr(actions),\n                            &nat->header_);\n}\n\nstatic void\nbuild_lrouter_out_snat_flow(struct hmap *lflows, struct ovn_datapath *od,\n                            const struct nbrec_nat *nat, struct ds *match,\n                            struct ds *actions, bool distributed,\n                            struct eth_addr mac, int cidr_bits, bool is_v6,\n                            struct ovn_port *l3dgw_port)\n{\n    /* Egress SNAT table: Packets enter the egress pipeline with\n    * source ip address that needs to be SNATted to a external ip\n    * address. */\n    if (strcmp(nat->type, \"snat\") && strcmp(nat->type, \"dnat_and_snat\")) {\n        return;\n    }\n\n    bool stateless = lrouter_dnat_and_snat_is_stateless(nat);\n    if (od->is_gw_router) {\n        ds_clear(match);\n        ds_put_format(match, \"ip && ip%s.src == %s\",\n                      is_v6 ? \"6\" : \"4\", nat->logical_ip);\n        ds_clear(actions);\n\n        if (nat->allowed_ext_ips || nat->exempted_ext_ips) {\n            lrouter_nat_add_ext_ip_match(od, lflows, match, nat,\n                                         is_v6, false, cidr_bits);\n        }\n\n        if (!strcmp(nat->type, \"dnat_and_snat\") && stateless) {\n            ds_put_format(actions, \"ip%s.src=%s; next;\",\n                          is_v6 ? \"6\" : \"4\", nat->external_ip);\n        } else {\n            ds_put_format(match, \" && (!ct.trk || !ct.rpl)\");\n            ds_put_format(actions, \"ct_snat(%s\", nat->external_ip);\n\n            if (nat->external_port_range[0]) {\n                ds_put_format(actions, \",%s\",\n                              nat->external_port_range);\n            }\n            ds_put_format(actions, \");\");\n        }\n\n        /* The priority here is calculated such that the\n        * nat->logical_ip with the longest mask gets a higher\n        * priority. */\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_SNAT,\n                                cidr_bits + 1, ds_cstr(match),\n                                ds_cstr(actions), &nat->header_);\n    } else {\n        uint16_t priority = cidr_bits + 1;\n\n        /* Distributed router. */\n        ds_clear(match);\n        ds_put_format(match, \"ip && ip%s.src == %s && outport == %s\",\n                      is_v6 ? \"6\" : \"4\", nat->logical_ip,\n                      l3dgw_port->json_key);\n        if (od->n_l3dgw_ports) {\n            if (distributed) {\n                ovs_assert(nat->logical_port);\n                priority += 128;\n                ds_put_format(match, \" && is_chassis_resident(\\\"%s\\\")\",\n                              nat->logical_port);\n            } else {\n                /* Flows for NAT rules that are centralized are only\n                * programmed on the gateway chassis. */\n                priority += 128;\n                ds_put_format(match, \" && is_chassis_resident(%s)\",\n                              l3dgw_port->cr_port->json_key);\n            }\n        }\n        ds_clear(actions);\n\n        if (nat->allowed_ext_ips || nat->exempted_ext_ips) {\n            lrouter_nat_add_ext_ip_match(od, lflows, match, nat,\n                                         is_v6, false, cidr_bits);\n        }\n\n        if (distributed) {\n            ds_put_format(actions, \"eth.src = \"ETH_ADDR_FMT\"; \",\n                          ETH_ADDR_ARGS(mac));\n        }\n\n        if (stateless) {\n            ds_put_format(actions, \"ip%s.src=%s; next;\",\n                          is_v6 ? \"6\" : \"4\", nat->external_ip);\n        } else {\n            ds_put_format(actions, \"ct_snat_in_czone(%s\",\n                        nat->external_ip);\n            if (nat->external_port_range[0]) {\n                ds_put_format(actions, \",%s\", nat->external_port_range);\n            }\n            ds_put_format(actions, \");\");\n        }\n\n        /* The priority here is calculated such that the\n        * nat->logical_ip with the longest mask gets a higher\n        * priority. */\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_SNAT,\n                                priority, ds_cstr(match),\n                                ds_cstr(actions), &nat->header_);\n\n        if (!stateless) {\n            ds_put_cstr(match, \" && \"REGBIT_DST_NAT_IP_LOCAL\" == 1\");\n            ds_clear(actions);\n            if (distributed) {\n                ds_put_format(actions, \"eth.src = \"ETH_ADDR_FMT\"; \",\n                              ETH_ADDR_ARGS(mac));\n            }\n            ds_put_format(actions,  REGBIT_DST_NAT_IP_LOCAL\" = 0; ct_snat(%s\",\n                          nat->external_ip);\n            if (nat->external_port_range[0]) {\n                ds_put_format(actions, \",%s\", nat->external_port_range);\n            }\n            ds_put_format(actions, \");\");\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_SNAT,\n                                    priority + 1, ds_cstr(match),\n                                    ds_cstr(actions), &nat->header_);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_ingress_nat_check_pkt_len(struct hmap *lflows,\n                                        const struct nbrec_nat *nat,\n                                        struct ovn_datapath *od, bool is_v6,\n                                        struct ds *match, struct ds *actions,\n                                        int mtu, struct ovn_port *l3dgw_port,\n                                        const struct shash *meter_groups)\n{\n        ds_clear(match);\n        ds_put_format(match, \"inport == %s && \"REGBIT_PKT_LARGER\n                      \" && \"REGBIT_EGRESS_LOOPBACK\" == 0\",\n                      l3dgw_port->json_key);\n\n        ds_clear(actions);\n        if (!is_v6) {\n            ds_put_format(match, \" && ip4 && ip4.dst == %s\", nat->external_ip);\n            /* Set icmp4.frag_mtu to gw_mtu */\n            ds_put_format(actions,\n                \"icmp4_error {\"\n                REGBIT_EGRESS_LOOPBACK\" = 1; \"\n                REGBIT_PKT_LARGER\" = 0; \"\n                \"eth.dst = eth.src; \"\n                \"eth.src = %s; \"\n                \"ip4.dst = ip4.src; \"\n                \"ip4.src = %s; \"\n                \"ip.ttl = 254; \"\n                \"icmp4.type = 3; /* Destination Unreachable. */ \"\n                \"icmp4.code = 4; /* Frag Needed and DF was Set. */ \"\n                \"icmp4.frag_mtu = %d; \"\n                \"outport = %s; flags.loopback = 1; output; };\",\n                nat->external_mac,\n                nat->external_ip,\n                mtu, l3dgw_port->json_key);\n            ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_IP_INPUT, 160,\n                                      ds_cstr(match), ds_cstr(actions),\n                                      NULL,\n                                      copp_meter_get(\n                                            COPP_ICMP4_ERR,\n                                            od->nbr->copp,\n                                            meter_groups),\n                                      &nat->header_);\n        } else {\n            ds_put_format(match, \" && ip6 && ip6.dst == %s\", nat->external_ip);\n            /* Set icmp6.frag_mtu to gw_mtu */\n            ds_put_format(actions,\n                \"icmp6_error {\"\n                REGBIT_EGRESS_LOOPBACK\" = 1; \"\n                REGBIT_PKT_LARGER\" = 0; \"\n                \"eth.dst = eth.src; \"\n                \"eth.src = %s; \"\n                \"ip6.dst = ip6.src; \"\n                \"ip6.src = %s; \"\n                \"ip.ttl = 254; \"\n                \"icmp6.type = 2; /* Packet Too Big. */ \"\n                \"icmp6.code = 0; \"\n                \"icmp6.frag_mtu = %d; \"\n                \"outport = %s; flags.loopback = 1; output; };\",\n                nat->external_mac,\n                nat->external_ip,\n                mtu, l3dgw_port->json_key);\n            ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_IP_INPUT, 160,\n                                      ds_cstr(match), ds_cstr(actions),\n                                      NULL,\n                                      copp_meter_get(\n                                            COPP_ICMP6_ERR,\n                                            od->nbr->copp,\n                                            meter_groups),\n                                      &nat->header_);\n        }\n}\n\nstatic void\nbuild_lrouter_ingress_flow(struct hmap *lflows, struct ovn_datapath *od,\n                           const struct nbrec_nat *nat, struct ds *match,\n                           struct ds *actions, struct eth_addr mac,\n                           bool distributed, bool is_v6,\n                           struct ovn_port *l3dgw_port,\n                           const struct shash *meter_groups)\n{\n    if (od->n_l3dgw_ports && !strcmp(nat->type, \"snat\")) {\n        ds_clear(match);\n        ds_put_format(\n            match, \"inport == %s && %s == %s\",\n            l3dgw_port->json_key,\n            is_v6 ? \"ip6.src\" : \"ip4.src\", nat->external_ip);\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_INPUT,\n                                120, ds_cstr(match), \"next;\",\n                                &nat->header_);\n    }\n    /* Logical router ingress table 0:\n    * For NAT on a distributed router, add rules allowing\n    * ingress traffic with eth.dst matching nat->external_mac\n    * on the l3dgw_port instance where nat->logical_port is\n    * resident. */\n    if (distributed) {\n        /* Store the ethernet address of the port receiving the packet.\n        * This will save us from having to match on inport further\n        * down in the pipeline.\n        */\n        int gw_mtu = smap_get_int(&l3dgw_port->nbrp->options,\n                                  \"gateway_mtu\", 0);\n        ds_clear(match);\n        ds_put_format(match,\n                      \"eth.dst == \"ETH_ADDR_FMT\" && inport == %s\"\n                      \" && is_chassis_resident(\\\"%s\\\")\",\n                      ETH_ADDR_ARGS(mac),\n                      l3dgw_port->json_key,\n                      nat->logical_port);\n        build_gateway_mtu_flow(lflows, l3dgw_port,\n                               S_ROUTER_IN_ADMISSION, 50, 55,\n                               match, actions, &nat->header_,\n                               REG_INPORT_ETH_ADDR \" = %s; next;\",\n                               l3dgw_port->lrp_networks.ea_s);\n        if (gw_mtu) {\n            build_lrouter_ingress_nat_check_pkt_len(lflows, nat, od, is_v6,\n                                                    match, actions, gw_mtu,\n                                                    l3dgw_port, meter_groups);\n        }\n    }\n}\n\nstatic int\nlrouter_check_nat_entry(struct ovn_datapath *od, const struct nbrec_nat *nat,\n                        const struct hmap *ports, ovs_be32 *mask,\n                        bool *is_v6, int *cidr_bits, struct eth_addr *mac,\n                        bool *distributed, struct ovn_port **nat_l3dgw_port)\n{\n    struct in6_addr ipv6, mask_v6, v6_exact = IN6ADDR_EXACT_INIT;\n    ovs_be32 ip;\n\n    if (nat->allowed_ext_ips && nat->exempted_ext_ips) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n        VLOG_WARN_RL(&rl, \"NAT rule: \"UUID_FMT\" not applied, since \"\n                    \"both allowed and exempt external ips set\",\n                    UUID_ARGS(&(nat->header_.uuid)));\n        return -EINVAL;\n    }\n\n    char *error = ip_parse_masked(nat->external_ip, &ip, mask);\n    *is_v6 = false;\n\n    if (error || *mask != OVS_BE32_MAX) {\n        free(error);\n        error = ipv6_parse_masked(nat->external_ip, &ipv6, &mask_v6);\n        if (error || memcmp(&mask_v6, &v6_exact, sizeof(mask_v6))) {\n            /* Invalid for both IPv4 and IPv6 */\n            static struct vlog_rate_limit rl =\n                VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad external ip %s for nat\",\n                        nat->external_ip);\n            free(error);\n            return -EINVAL;\n        }\n        /* It was an invalid IPv4 address, but valid IPv6.\n        * Treat the rest of the handling of this NAT rule\n        * as IPv6. */\n        *is_v6 = true;\n    }\n\n    /* Validate gateway_port of NAT rule. */\n    *nat_l3dgw_port = NULL;\n    if (nat->gateway_port == NULL) {\n        if (od->n_l3dgw_ports == 1) {\n            *nat_l3dgw_port = od->l3dgw_ports[0];\n        } else if (od->n_l3dgw_ports > 1) {\n            /* Find the DGP reachable for the NAT external IP. */\n            for (size_t i = 0; i < od->n_l3dgw_ports; i++) {\n               if (find_lrp_member_ip(od->l3dgw_ports[i], nat->external_ip)) {\n                   *nat_l3dgw_port = od->l3dgw_ports[i];\n                   break;\n               }\n            }\n            if (*nat_l3dgw_port == NULL) {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n                VLOG_WARN_RL(&rl, \"Unable to determine gateway_port for NAT \"\n                             \"with external_ip: %s configured on logical \"\n                             \"router: %s with multiple distributed gateway \"\n                             \"ports\", nat->external_ip, od->nbr->name);\n                return -EINVAL;\n            }\n        }\n    } else {\n        *nat_l3dgw_port = ovn_port_find(ports, nat->gateway_port->name);\n\n        if (!(*nat_l3dgw_port) || (*nat_l3dgw_port)->od != od ||\n            !is_l3dgw_port(*nat_l3dgw_port)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"gateway_port: %s of NAT configured on \"\n                         \"logical router: %s is not a valid distributed \"\n                         \"gateway port on that router\",\n                         nat->gateway_port->name, od->nbr->name);\n            return -EINVAL;\n        }\n    }\n\n    /* Check the validity of nat->logical_ip. 'logical_ip' can\n    * be a subnet when the type is \"snat\". */\n    if (*is_v6) {\n        error = ipv6_parse_masked(nat->logical_ip, &ipv6, &mask_v6);\n        *cidr_bits = ipv6_count_cidr_bits(&mask_v6);\n    } else {\n        error = ip_parse_masked(nat->logical_ip, &ip, mask);\n        *cidr_bits = ip_count_cidr_bits(*mask);\n    }\n    if (!strcmp(nat->type, \"snat\")) {\n        if (error) {\n            /* Invalid for both IPv4 and IPv6 */\n            static struct vlog_rate_limit rl =\n                VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad ip network or ip %s for snat \"\n                        \"in router \"UUID_FMT\"\",\n                        nat->logical_ip, UUID_ARGS(&od->key));\n            free(error);\n            return -EINVAL;\n        }\n    } else {\n        if (error || (*is_v6 == false && *mask != OVS_BE32_MAX)\n            || (*is_v6 && memcmp(&mask_v6, &v6_exact,\n                                sizeof mask_v6))) {\n            /* Invalid for both IPv4 and IPv6 */\n            static struct vlog_rate_limit rl =\n                VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad ip %s for dnat in router \"\n                \"\"UUID_FMT\"\", nat->logical_ip, UUID_ARGS(&od->key));\n            free(error);\n            return -EINVAL;\n        }\n    }\n\n    /* For distributed router NAT, determine whether this NAT rule\n     * satisfies the conditions for distributed NAT processing. */\n    *distributed = false;\n    if (od->n_l3dgw_ports && !strcmp(nat->type, \"dnat_and_snat\") &&\n        nat->logical_port && nat->external_mac) {\n        if (eth_addr_from_string(nat->external_mac, mac)) {\n            *distributed = true;\n        } else {\n            static struct vlog_rate_limit rl =\n                VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad mac %s for dnat in router \"\n                \"\"UUID_FMT\"\", nat->external_mac, UUID_ARGS(&od->key));\n            return -EINVAL;\n        }\n    }\n\n    return 0;\n}\n\n/* NAT, Defrag and load balancing. */\nstatic void\nbuild_lrouter_nat_defrag_and_lb(struct ovn_datapath *od, struct hmap *lflows,\n                                const struct hmap *ports, struct ds *match,\n                                struct ds *actions,\n                                const struct shash *meter_groups,\n                                const struct chassis_features *features)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    /* Packets are allowed by default. */\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_DEFRAG, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_UNSNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_CHECK_DNAT_LOCAL, 0, \"1\",\n                  REGBIT_DST_NAT_IP_LOCAL\" = 0; next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_SNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_UNDNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_POST_UNDNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_POST_SNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_EGR_LOOP, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 0, \"1\", \"next;\");\n\n    const char *ct_flag_reg = features->ct_no_masked_label\n                              ? \"ct_mark\"\n                              : \"ct_label\";\n    /* Ingress DNAT (Priority 50/70).\n     *\n     * Allow traffic that is related to an existing conntrack entry.\n     * At the same time apply NAT for this traffic.\n     *\n     * NOTE: This does not support related data sessions (eg,\n     * a dynamically negotiated FTP data channel), but will allow\n     * related traffic such as an ICMP Port Unreachable through\n     * that's generated from a non-listening UDP port.  */\n    if (od->has_lb_vip && features->ct_lb_related) {\n        ds_clear(match);\n\n        ds_put_cstr(match, \"ct.rel && !ct.est && !ct.new\");\n        size_t match_len = match->length;\n\n        ds_put_format(match, \" && %s.skip_snat == 1\", ct_flag_reg);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 70, ds_cstr(match),\n                      \"flags.skip_snat_for_lb = 1; ct_commit_nat;\");\n\n        ds_truncate(match, match_len);\n        ds_put_format(match, \" && %s.force_snat == 1\", ct_flag_reg);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 70, ds_cstr(match),\n                      \"flags.force_snat_for_lb = 1; ct_commit_nat;\");\n\n        ds_truncate(match, match_len);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 50, ds_cstr(match),\n                      \"ct_commit_nat;\");\n    }\n\n    /* Ingress DNAT (Priority 50/70).\n     *\n     * Pass the traffic that is already established to the next table with\n     * proper flags set.\n     */\n    if (od->has_lb_vip) {\n        ds_clear(match);\n\n        ds_put_format(match, \"ct.est && !ct.rel && !ct.new && %s.natted\",\n                      ct_flag_reg);\n        size_t match_len = match->length;\n\n        ds_put_format(match, \" && %s.skip_snat == 1\", ct_flag_reg);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 70, ds_cstr(match),\n                      \"flags.skip_snat_for_lb = 1; next;\");\n\n        ds_truncate(match, match_len);\n        ds_put_format(match, \" && %s.force_snat == 1\", ct_flag_reg);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 70, ds_cstr(match),\n                      \"flags.force_snat_for_lb = 1; next;\");\n\n        ds_truncate(match, match_len);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 50, ds_cstr(match),\n                      \"next;\");\n    }\n\n    /* If the router has load balancer or DNAT rules, re-circulate every packet\n     * through the DNAT zone so that packets that need to be unDNATed in the\n     * reverse direction get unDNATed.\n     *\n     * We also commit newly initiated connections in the reply direction to the\n     * DNAT zone. This ensures that these flows are tracked. If the flow was\n     * not committed, it would produce ongoing datapath flows with the ct.new\n     * flag set. Some NICs are unable to offload these flows.\n     */\n    if (od->is_gw_router && (od->nbr->n_nat || od->has_lb_vip)) {\n        /* Do not send ND or ICMP packets to connection tracking. */\n        ovn_lflow_add(lflows, od, S_ROUTER_OUT_UNDNAT, 100,\n                      \"nd || nd_rs || nd_ra\", \"next;\");\n        ovn_lflow_add(lflows, od, S_ROUTER_OUT_UNDNAT, 50,\n                      \"ip\", \"flags.loopback = 1; ct_dnat;\");\n        ovn_lflow_add(lflows, od, S_ROUTER_OUT_POST_UNDNAT, 50,\n                      \"ip && ct.new\", \"ct_commit { } ; next; \");\n    }\n\n    /* Send the IPv6 NS packets to next table. When ovn-controller\n     * generates IPv6 NS (for the action - nd_ns{}), the injected\n     * packet would go through conntrack - which is not required. */\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_SNAT, 120, \"nd_ns\", \"next;\");\n\n    /* NAT rules are only valid on Gateway routers and routers with\n     * l3dgw_ports (router has port(s) with gateway chassis\n     * specified). */\n    if (!od->is_gw_router && !od->n_l3dgw_ports) {\n        return;\n    }\n\n    struct sset nat_entries = SSET_INITIALIZER(&nat_entries);\n\n    bool dnat_force_snat_ip =\n        !lport_addresses_is_empty(&od->dnat_force_snat_addrs);\n    bool lb_force_snat_ip =\n        !lport_addresses_is_empty(&od->lb_force_snat_addrs);\n\n    for (int i = 0; i < od->nbr->n_nat; i++) {\n        const struct nbrec_nat *nat = nat = od->nbr->nat[i];\n        struct eth_addr mac = eth_addr_broadcast;\n        bool is_v6, distributed;\n        ovs_be32 mask;\n        int cidr_bits;\n        struct ovn_port *l3dgw_port;\n\n        if (lrouter_check_nat_entry(od, nat, ports, &mask, &is_v6, &cidr_bits,\n                                    &mac, &distributed, &l3dgw_port) < 0) {\n            continue;\n        }\n\n        /* S_ROUTER_IN_UNSNAT */\n        build_lrouter_in_unsnat_flow(lflows, od, nat, match, actions, distributed,\n                                     is_v6, l3dgw_port);\n        /* S_ROUTER_IN_DNAT */\n        build_lrouter_in_dnat_flow(lflows, od, nat, match, actions, distributed,\n                                   cidr_bits, is_v6, l3dgw_port);\n\n        /* ARP resolve for NAT IPs. */\n        if (od->is_gw_router) {\n            /* Add the NAT external_ip to the nat_entries for\n             * gateway routers. This is required for adding load balancer\n             * flows.*/\n            sset_add(&nat_entries, nat->external_ip);\n        } else {\n            if (!sset_contains(&nat_entries, nat->external_ip)) {\n                /* Drop packets coming in from external that still has\n                 * destination IP equals to the NAT external IP, to avoid loop.\n                 * The packets must have gone through DNAT/unSNAT stage but\n                 * failed to convert the destination. */\n                ds_clear(match);\n                ds_put_format(\n                    match, \"inport == %s && outport == %s && ip%s.dst == %s\",\n                    l3dgw_port->json_key, l3dgw_port->json_key,\n                    is_v6 ? \"6\" : \"4\", nat->external_ip);\n                ovn_lflow_add_with_hint(lflows, od,\n                                        S_ROUTER_IN_ARP_RESOLVE,\n                                        150, ds_cstr(match),\n                                        debug_drop_action(),\n                                        &nat->header_);\n                /* Now for packets coming from other (downlink) LRPs, allow ARP\n                 * resolve for the NAT IP, so that such packets can be\n                 * forwarded for E/W NAT. */\n                ds_clear(match);\n                ds_put_format(\n                    match, \"outport == %s && %s == %s\",\n                    l3dgw_port->json_key,\n                    is_v6 ? REG_NEXT_HOP_IPV6 : REG_NEXT_HOP_IPV4,\n                    nat->external_ip);\n                ds_clear(actions);\n                ds_put_format(\n                    actions, \"eth.dst = %s; next;\",\n                    distributed ? nat->external_mac :\n                    l3dgw_port->lrp_networks.ea_s);\n                ovn_lflow_add_with_hint(lflows, od,\n                                        S_ROUTER_IN_ARP_RESOLVE,\n                                        100, ds_cstr(match),\n                                        ds_cstr(actions),\n                                        &nat->header_);\n                if (od->redirect_bridged && distributed) {\n                    ds_clear(match);\n                    ds_put_format(\n                            match,\n                            \"outport == %s && ip%s.src == %s \"\n                            \"&& is_chassis_resident(\\\"%s\\\")\",\n                            od->l3dgw_ports[0]->json_key,\n                            is_v6 ? \"6\" : \"4\", nat->logical_ip,\n                            nat->logical_port);\n                    ds_clear(actions);\n                    if (is_v6) {\n                        ds_put_cstr(actions,\n                            \"get_nd(outport, \" REG_NEXT_HOP_IPV6 \"); next;\");\n                    } else {\n                        ds_put_cstr(actions,\n                            \"get_arp(outport, \" REG_NEXT_HOP_IPV4 \"); next;\");\n                    }\n                    ovn_lflow_add_with_hint(lflows, od,\n                                            S_ROUTER_IN_ARP_RESOLVE, 90,\n                                            ds_cstr(match), ds_cstr(actions),\n                                            &nat->header_);\n                }\n                sset_add(&nat_entries, nat->external_ip);\n            }\n        }\n\n        /* S_ROUTER_OUT_DNAT_LOCAL */\n        build_lrouter_out_is_dnat_local(lflows, od, nat, match, actions,\n                                        distributed, is_v6, l3dgw_port);\n\n        /* S_ROUTER_OUT_UNDNAT */\n        build_lrouter_out_undnat_flow(lflows, od, nat, match, actions, distributed,\n                                      mac, is_v6, l3dgw_port);\n        /* S_ROUTER_OUT_SNAT */\n        build_lrouter_out_snat_flow(lflows, od, nat, match, actions, distributed,\n                                    mac, cidr_bits, is_v6, l3dgw_port);\n\n        /* S_ROUTER_IN_ADMISSION - S_ROUTER_IN_IP_INPUT */\n        build_lrouter_ingress_flow(lflows, od, nat, match, actions, mac,\n                                   distributed, is_v6, l3dgw_port,\n                                   meter_groups);\n\n        /* Ingress Gateway Redirect Table: For NAT on a distributed\n         * router, add flows that are specific to a NAT rule.  These\n         * flows indicate the presence of an applicable NAT rule that\n         * can be applied in a distributed manner.\n         * In particulr REG_SRC_IPV4/REG_SRC_IPV6 and eth.src are set to\n         * NAT external IP and NAT external mac so the ARP request\n         * generated in the following stage is sent out with proper IP/MAC\n         * src addresses.\n         */\n        if (distributed) {\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match,\n                          \"ip%s.src == %s && outport == %s\",\n                          is_v6 ? \"6\" : \"4\", nat->logical_ip,\n                          l3dgw_port->json_key);\n            /* Add a rule to drop traffic from a distributed NAT if\n             * the virtual port has not claimed yet becaused otherwise\n             * the traffic will be centralized misconfiguring the TOR switch.\n             */\n            struct ovn_port *op = ovn_port_find(ports, nat->logical_port);\n            if (op && op->nbsp && !strcmp(op->nbsp->type, \"virtual\")) {\n                ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_GW_REDIRECT,\n                                        80, ds_cstr(match),\n                                        debug_drop_action(), &nat->header_);\n            }\n            ds_put_format(match, \" && is_chassis_resident(\\\"%s\\\")\",\n                          nat->logical_port);\n            ds_put_format(actions, \"eth.src = %s; %s = %s; next;\",\n                          nat->external_mac,\n                          is_v6 ? REG_SRC_IPV6 : REG_SRC_IPV4,\n                          nat->external_ip);\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_GW_REDIRECT,\n                                    100, ds_cstr(match),\n                                    ds_cstr(actions), &nat->header_);\n        }\n\n        /* Egress Loopback table: For NAT on a distributed router.\n         * If packets in the egress pipeline on the distributed\n         * gateway port have ip.dst matching a NAT external IP, then\n         * loop a clone of the packet back to the beginning of the\n         * ingress pipeline with inport = outport. */\n        if (od->n_l3dgw_ports) {\n            /* Distributed router. */\n            ds_clear(match);\n            ds_put_format(match, \"ip%s.dst == %s && outport == %s\",\n                          is_v6 ? \"6\" : \"4\",\n                          nat->external_ip,\n                          l3dgw_port->json_key);\n            if (!distributed) {\n                ds_put_format(match, \" && is_chassis_resident(%s)\",\n                              l3dgw_port->cr_port->json_key);\n            } else {\n                ds_put_format(match, \" && is_chassis_resident(\\\"%s\\\")\",\n                              nat->logical_port);\n            }\n\n            ds_clear(actions);\n            ds_put_format(actions,\n                          \"clone { ct_clear; \"\n                          \"inport = outport; outport = \\\"\\\"; \"\n                          \"eth.dst <-> eth.src; \"\n                          \"flags = 0; flags.loopback = 1; \"\n                          \"flags.use_snat_zone = \"REGBIT_DST_NAT_IP_LOCAL\"; \");\n            for (int j = 0; j < MFF_N_LOG_REGS; j++) {\n                ds_put_format(actions, \"reg%d = 0; \", j);\n            }\n            ds_put_format(actions, REGBIT_EGRESS_LOOPBACK\" = 1; \"\n                          \"next(pipeline=ingress, table=%d); };\",\n                          ovn_stage_get_table(S_ROUTER_IN_ADMISSION));\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_EGR_LOOP, 100,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &nat->header_);\n        }\n    }\n\n    if (od->nbr->n_nat) {\n        ds_clear(match);\n        const char *ct_natted = features->ct_no_masked_label ?\n                                \"ct_mark.natted\" :\n                                \"ct_label.natted\";\n        ds_put_format(match, \"ip && %s == 1\", ct_natted);\n        /* This flow is unique since it is in the egress pipeline but checks\n         * the value of ct_label.natted, which would have been set in the\n         * ingress pipeline. If a change is ever introduced that clears or\n         * otherwise invalidates the ct_label between the ingress and egress\n         * pipelines, then an alternative will need to be devised.\n         */\n        ds_clear(actions);\n        ds_put_cstr(actions, REGBIT_DST_NAT_IP_LOCAL\" = 1; next;\");\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_CHECK_DNAT_LOCAL,\n                                50, ds_cstr(match), ds_cstr(actions),\n                                &od->nbr->header_);\n\n    }\n\n    /* Handle force SNAT options set in the gateway router. */\n    if (od->is_gw_router) {\n        if (dnat_force_snat_ip) {\n            if (od->dnat_force_snat_addrs.n_ipv4_addrs) {\n                build_lrouter_force_snat_flows(lflows, od, \"4\",\n                    od->dnat_force_snat_addrs.ipv4_addrs[0].addr_s,\n                    \"dnat\");\n            }\n            if (od->dnat_force_snat_addrs.n_ipv6_addrs) {\n                build_lrouter_force_snat_flows(lflows, od, \"6\",\n                    od->dnat_force_snat_addrs.ipv6_addrs[0].addr_s,\n                    \"dnat\");\n            }\n        }\n        if (lb_force_snat_ip) {\n            if (od->lb_force_snat_addrs.n_ipv4_addrs) {\n                build_lrouter_force_snat_flows(lflows, od, \"4\",\n                    od->lb_force_snat_addrs.ipv4_addrs[0].addr_s, \"lb\");\n            }\n            if (od->lb_force_snat_addrs.n_ipv6_addrs) {\n                build_lrouter_force_snat_flows(lflows, od, \"6\",\n                    od->lb_force_snat_addrs.ipv6_addrs[0].addr_s, \"lb\");\n            }\n        }\n    }\n\n    sset_destroy(&nat_entries);\n}\n\n\n\nstruct lswitch_flow_build_info {\n    const struct hmap *datapaths;\n    const struct hmap *ports;\n    const struct hmap *port_groups;\n    struct hmap *lflows;\n    struct hmap *mcgroups;\n    struct hmap *igmp_groups;\n    const struct shash *meter_groups;\n    const struct hmap *lbs;\n    const struct hmap *bfd_connections;\n    const struct chassis_features *features;\n    char *svc_check_match;\n    struct ds match;\n    struct ds actions;\n    size_t thread_lflow_counter;\n};\n\n/* Helper function to combine all lflow generation which is iterated by\n * datapath.\n *\n * When extending the function new \"work data\" must be added to the lsi\n * struct, not passed as an argument.\n */\n\nstatic void\nbuild_lswitch_and_lrouter_iterate_by_od(struct ovn_datapath *od,\n                                        struct lswitch_flow_build_info *lsi)\n{\n    /* Build Logical Switch Flows. */\n    build_lswitch_lflows_pre_acl_and_acl(od, lsi->port_groups,\n                                         lsi->features,\n                                         lsi->lflows,\n                                         lsi->meter_groups);\n\n    build_fwd_group_lflows(od, lsi->lflows);\n    build_lswitch_lflows_admission_control(od, lsi->lflows);\n    build_lswitch_learn_fdb_od(od, lsi->lflows);\n    build_lswitch_arp_nd_responder_default(od, lsi->lflows);\n    build_lswitch_dns_lookup_and_response(od, lsi->lflows, lsi->meter_groups);\n    build_lswitch_dhcp_and_dns_defaults(od, lsi->lflows);\n    build_lswitch_destination_lookup_bmcast(od, lsi->lflows, &lsi->actions,\n                                            lsi->meter_groups);\n    build_lswitch_output_port_sec_od(od, lsi->lflows);\n\n    /* Build Logical Router Flows. */\n    build_adm_ctrl_flows_for_lrouter(od, lsi->lflows);\n    build_neigh_learning_flows_for_lrouter(od, lsi->lflows, &lsi->match,\n                                           &lsi->actions, lsi->meter_groups);\n    build_ND_RA_flows_for_lrouter(od, lsi->lflows);\n    build_ip_routing_pre_flows_for_lrouter(od, lsi->lflows);\n    build_static_route_flows_for_lrouter(od, lsi->features,\n                                         lsi->lflows, lsi->ports,\n                                         lsi->bfd_connections);\n    build_mcast_lookup_flows_for_lrouter(od, lsi->lflows, &lsi->match,\n                                         &lsi->actions);\n    build_ingress_policy_flows_for_lrouter(od, lsi->lflows, lsi->ports);\n    build_arp_resolve_flows_for_lrouter(od, lsi->lflows);\n    build_check_pkt_len_flows_for_lrouter(od, lsi->lflows, lsi->ports,\n                                          &lsi->match, &lsi->actions,\n                                          lsi->meter_groups);\n    build_gateway_redirect_flows_for_lrouter(od, lsi->lflows, &lsi->match,\n                                             &lsi->actions);\n    build_arp_request_flows_for_lrouter(od, lsi->lflows, &lsi->match,\n                                        &lsi->actions, lsi->meter_groups);\n    build_misc_local_traffic_drop_flows_for_lrouter(od, lsi->lflows);\n    build_lrouter_arp_nd_for_datapath(od, lsi->lflows, lsi->meter_groups);\n    build_lrouter_nat_defrag_and_lb(od, lsi->lflows, lsi->ports, &lsi->match,\n                                    &lsi->actions, lsi->meter_groups,\n                                    lsi->features);\n    build_lb_affinity_default_flows(od, lsi->lflows);\n}\n\n/* Helper function to combine all lflow generation which is iterated by port.\n */\nstatic void\nbuild_lswitch_and_lrouter_iterate_by_op(struct ovn_port *op,\n                                        struct lswitch_flow_build_info *lsi)\n{\n    /* Build Logical Switch Flows. */\n    build_lswitch_port_sec_op(op, lsi->lflows, &lsi->actions, &lsi->match);\n    build_lswitch_learn_fdb_op(op, lsi->lflows, &lsi->actions,\n                               &lsi->match);\n    build_lswitch_arp_nd_responder_skip_local(op, lsi->lflows,\n                                              &lsi->match);\n    build_lswitch_arp_nd_responder_known_ips(op, lsi->lflows,\n                                             lsi->ports,\n                                             lsi->meter_groups,\n                                             &lsi->actions,\n                                             &lsi->match);\n    build_lswitch_dhcp_options_and_response(op, lsi->lflows,\n                                            lsi->meter_groups);\n    build_lswitch_external_port(op, lsi->lflows);\n    build_lswitch_ip_unicast_lookup(op, lsi->lflows, lsi->mcgroups,\n                                    &lsi->actions, &lsi->match);\n\n    /* Build Logical Router Flows. */\n    build_adm_ctrl_flows_for_lrouter_port(op, lsi->lflows, &lsi->match,\n                                          &lsi->actions);\n    build_neigh_learning_flows_for_lrouter_port(op, lsi->lflows, &lsi->match,\n                                                &lsi->actions);\n    build_ip_routing_flows_for_lrouter_port(op, lsi->ports, lsi->lflows);\n    build_ND_RA_flows_for_lrouter_port(op, lsi->lflows, &lsi->match,\n                                       &lsi->actions, lsi->meter_groups);\n    build_arp_resolve_flows_for_lrouter_port(op, lsi->lflows, lsi->ports,\n                                             &lsi->match, &lsi->actions);\n    build_egress_delivery_flows_for_lrouter_port(op, lsi->lflows, &lsi->match,\n                                                 &lsi->actions);\n    build_dhcpv6_reply_flows_for_lrouter_port(op, lsi->lflows, &lsi->match);\n    build_ipv6_input_flows_for_lrouter_port(op, lsi->lflows,\n                                            &lsi->match, &lsi->actions,\n                                            lsi->meter_groups);\n    build_lrouter_ipv4_ip_input(op, lsi->lflows,\n                                &lsi->match, &lsi->actions, lsi->meter_groups);\n    build_lrouter_force_snat_flows_op(op, lsi->lflows, &lsi->match,\n                                      &lsi->actions);\n}\n\nstatic void *\nbuild_lflows_thread(void *arg)\n{\n    struct worker_control *control = (struct worker_control *) arg;\n    struct lswitch_flow_build_info *lsi;\n\n    struct ovn_datapath *od;\n    struct ovn_port *op;\n    struct ovn_northd_lb *lb;\n    struct ovn_igmp_group *igmp_group;\n    int bnum;\n\n    while (!stop_parallel_processing()) {\n        wait_for_work(control);\n        lsi = (struct lswitch_flow_build_info *) control->data;\n        if (stop_parallel_processing()) {\n            return NULL;\n        }\n        thread_lflow_counter = 0;\n        if (lsi) {\n            /* Iterate over bucket ThreadID, ThreadID+size, ... */\n            for (bnum = control->id;\n                    bnum <= lsi->datapaths->mask;\n                    bnum += control->pool->size)\n            {\n                HMAP_FOR_EACH_IN_PARALLEL (od, key_node, bnum, lsi->datapaths) {\n                    if (stop_parallel_processing()) {\n                        return NULL;\n                    }\n                    build_lswitch_and_lrouter_iterate_by_od(od, lsi);\n                }\n            }\n            for (bnum = control->id;\n                    bnum <= lsi->ports->mask;\n                    bnum += control->pool->size)\n            {\n                HMAP_FOR_EACH_IN_PARALLEL (op, key_node, bnum, lsi->ports) {\n                    if (stop_parallel_processing()) {\n                        return NULL;\n                    }\n                    build_lswitch_and_lrouter_iterate_by_op(op, lsi);\n                }\n            }\n            for (bnum = control->id;\n                    bnum <= lsi->lbs->mask;\n                    bnum += control->pool->size)\n            {\n                HMAP_FOR_EACH_IN_PARALLEL (lb, hmap_node, bnum, lsi->lbs) {\n                    if (stop_parallel_processing()) {\n                        return NULL;\n                    }\n                    build_lswitch_arp_nd_service_monitor(lb, lsi->lflows,\n                                                         &lsi->match,\n                                                         &lsi->actions);\n                    build_lrouter_defrag_flows_for_lb(lb, lsi->lflows,\n                                                      &lsi->match);\n                    build_lrouter_flows_for_lb(lb, lsi->lflows,\n                                               lsi->meter_groups,\n                                               lsi->features,\n                                               &lsi->match, &lsi->actions);\n                    build_lswitch_flows_for_lb(lb, lsi->lflows,\n                                               lsi->meter_groups,\n                                               lsi->features,\n                                               &lsi->match, &lsi->actions);\n                }\n            }\n            for (bnum = control->id;\n                    bnum <= lsi->igmp_groups->mask;\n                    bnum += control->pool->size)\n            {\n                HMAP_FOR_EACH_IN_PARALLEL (\n                        igmp_group, hmap_node, bnum, lsi->igmp_groups) {\n                    if (stop_parallel_processing()) {\n                        return NULL;\n                    }\n                    build_lswitch_ip_mcast_igmp_mld(igmp_group, lsi->lflows,\n                                                    &lsi->match,\n                                                    &lsi->actions);\n                }\n            }\n        }\n        lsi->thread_lflow_counter = thread_lflow_counter;\n        post_completed_work(control);\n    }\n    return NULL;\n}\n\nstatic struct worker_pool *build_lflows_pool = NULL;\n\nstatic void\nnoop_callback(struct worker_pool *pool OVS_UNUSED,\n              void *fin_result OVS_UNUSED,\n              void *result_frags OVS_UNUSED,\n              size_t index OVS_UNUSED)\n{\n    /* Do nothing */\n}\n\n/* Fixes the hmap size (hmap->n) after parallel building the lflow_map when\n * dp-groups is enabled, because in that case all threads are updating the\n * global lflow hmap. Although the lflow_hash_lock prevents currently inserting\n * to the same hash bucket, the hmap->n is updated currently by all threads and\n * may not be accurate at the end of each iteration. This function collects the\n * thread-local lflow counters maintained by each thread and update the hmap\n * size with the aggregated value. This function must be called immediately\n * after the worker threads complete the tasks in each iteration before any\n * future operations on the lflow map. */\nstatic void\nfix_flow_map_size(struct hmap *lflow_map,\n                  struct lswitch_flow_build_info *lsiv,\n                  size_t n_lsiv)\n{\n    size_t total = 0;\n    for (size_t i = 0; i < n_lsiv; i++) {\n        total += lsiv[i].thread_lflow_counter;\n    }\n    lflow_map->n = total;\n}\n\nstatic void\nbuild_lswitch_and_lrouter_flows(const struct hmap *datapaths,\n                                const struct hmap *ports,\n                                const struct hmap *port_groups,\n                                struct hmap *lflows,\n                                struct hmap *mcgroups,\n                                struct hmap *igmp_groups,\n                                const struct shash *meter_groups,\n                                const struct hmap *lbs,\n                                const struct hmap *bfd_connections,\n                                const struct chassis_features *features)\n{\n\n    char *svc_check_match = xasprintf(\"eth.dst == %s\", svc_monitor_mac);\n\n    if (parallelization_state == STATE_USE_PARALLELIZATION) {\n        struct lswitch_flow_build_info *lsiv;\n        int index;\n\n        lsiv = xcalloc(sizeof(*lsiv), build_lflows_pool->size);\n\n        /* Set up \"work chunks\" for each thread to work on. */\n\n        for (index = 0; index < build_lflows_pool->size; index++) {\n            /* dp_groups are in use so we lock a shared lflows hash\n             * on a per-bucket level.\n             */\n            lsiv[index].lflows = lflows;\n            lsiv[index].datapaths = datapaths;\n            lsiv[index].ports = ports;\n            lsiv[index].port_groups = port_groups;\n            lsiv[index].mcgroups = mcgroups;\n            lsiv[index].igmp_groups = igmp_groups;\n            lsiv[index].meter_groups = meter_groups;\n            lsiv[index].lbs = lbs;\n            lsiv[index].bfd_connections = bfd_connections;\n            lsiv[index].features = features;\n            lsiv[index].svc_check_match = svc_check_match;\n            lsiv[index].thread_lflow_counter = 0;\n            ds_init(&lsiv[index].match);\n            ds_init(&lsiv[index].actions);\n\n            build_lflows_pool->controls[index].data = &lsiv[index];\n        }\n\n        /* Run thread pool. */\n        run_pool_callback(build_lflows_pool, NULL, NULL, noop_callback);\n        fix_flow_map_size(lflows, lsiv, build_lflows_pool->size);\n\n        for (index = 0; index < build_lflows_pool->size; index++) {\n            ds_destroy(&lsiv[index].match);\n            ds_destroy(&lsiv[index].actions);\n        }\n        free(lsiv);\n    } else {\n        struct ovn_datapath *od;\n        struct ovn_port *op;\n        struct ovn_northd_lb *lb;\n        struct ovn_igmp_group *igmp_group;\n        struct lswitch_flow_build_info lsi = {\n            .datapaths = datapaths,\n            .ports = ports,\n            .port_groups = port_groups,\n            .lflows = lflows,\n            .mcgroups = mcgroups,\n            .igmp_groups = igmp_groups,\n            .meter_groups = meter_groups,\n            .lbs = lbs,\n            .bfd_connections = bfd_connections,\n            .features = features,\n            .svc_check_match = svc_check_match,\n            .match = DS_EMPTY_INITIALIZER,\n            .actions = DS_EMPTY_INITIALIZER,\n        };\n\n        /* Combined build - all lflow generation from lswitch and lrouter\n         * will move here and will be reogranized by iterator type.\n         */\n        stopwatch_start(LFLOWS_DATAPATHS_STOPWATCH_NAME, time_msec());\n        HMAP_FOR_EACH (od, key_node, datapaths) {\n            build_lswitch_and_lrouter_iterate_by_od(od, &lsi);\n        }\n        stopwatch_stop(LFLOWS_DATAPATHS_STOPWATCH_NAME, time_msec());\n        stopwatch_start(LFLOWS_PORTS_STOPWATCH_NAME, time_msec());\n        HMAP_FOR_EACH (op, key_node, ports) {\n            build_lswitch_and_lrouter_iterate_by_op(op, &lsi);\n        }\n        stopwatch_stop(LFLOWS_PORTS_STOPWATCH_NAME, time_msec());\n        stopwatch_start(LFLOWS_LBS_STOPWATCH_NAME, time_msec());\n        HMAP_FOR_EACH (lb, hmap_node, lbs) {\n            build_lswitch_arp_nd_service_monitor(lb, lsi.lflows,\n                                                 &lsi.actions,\n                                                 &lsi.match);\n            build_lrouter_defrag_flows_for_lb(lb, lsi.lflows, &lsi.match);\n            build_lrouter_flows_for_lb(lb, lsi.lflows, lsi.meter_groups,\n                                       lsi.features, &lsi.match, &lsi.actions);\n            build_lswitch_flows_for_lb(lb, lsi.lflows, lsi.meter_groups,\n                                       lsi.features, &lsi.match, &lsi.actions);\n        }\n        stopwatch_stop(LFLOWS_LBS_STOPWATCH_NAME, time_msec());\n        stopwatch_start(LFLOWS_IGMP_STOPWATCH_NAME, time_msec());\n        HMAP_FOR_EACH (igmp_group, hmap_node, igmp_groups) {\n            build_lswitch_ip_mcast_igmp_mld(igmp_group,\n                                            lsi.lflows,\n                                            &lsi.actions,\n                                            &lsi.match);\n        }\n        stopwatch_stop(LFLOWS_IGMP_STOPWATCH_NAME, time_msec());\n\n        ds_destroy(&lsi.match);\n        ds_destroy(&lsi.actions);\n    }\n\n    free(svc_check_match);\n    build_lswitch_flows(datapaths, lflows);\n}\n\nstatic void\novn_sb_set_lflow_logical_dp_group(\n    struct ovsdb_idl_txn *ovnsb_txn,\n    struct hmap *dp_groups,\n    const struct sbrec_logical_flow *sbflow,\n    const unsigned long *dpg_bitmap)\n{\n    struct ovn_dp_group *dpg;\n    size_t n_ods;\n\n    n_ods = bitmap_count1(dpg_bitmap, n_datapaths);\n\n    if (!n_ods) {\n        sbrec_logical_flow_set_logical_dp_group(sbflow, NULL);\n        return;\n    }\n\n    ovs_assert(n_ods != 1);\n\n    dpg = ovn_dp_group_find(dp_groups, dpg_bitmap, hash_int(n_ods, 0));\n    ovs_assert(dpg != NULL);\n\n    if (!dpg->dp_group) {\n        dpg->dp_group = ovn_sb_insert_logical_dp_group(ovnsb_txn, dpg->bitmap);\n    }\n    sbrec_logical_flow_set_logical_dp_group(sbflow, dpg->dp_group);\n}\n\nstatic ssize_t max_seen_lflow_size = 128;\n\nvoid run_update_worker_pool(int n_threads)\n{\n    /* If number of threads has been updated (or initially set),\n     * update the worker pool. */\n    if (update_worker_pool(n_threads, &build_lflows_pool,\n                           build_lflows_thread) != POOL_UNCHANGED) {\n        /* worker pool was updated */\n        if (get_worker_pool_size() <= 1) {\n            /* destroy potentially created lflow_hash_lock */\n            lflow_hash_lock_destroy();\n            parallelization_state = STATE_NULL;\n        } else if (parallelization_state != STATE_USE_PARALLELIZATION) {\n            lflow_hash_lock_init();\n            parallelization_state = STATE_INIT_HASH_SIZES;\n        }\n    }\n}\n\nstatic void\nbuild_mcast_groups(struct lflow_input *data,\n                   const struct hmap *datapaths,\n                   const struct hmap *ports,\n                   struct hmap *mcast_groups,\n                   struct hmap *igmp_groups);\n\n/* Updates the Logical_Flow and Multicast_Group tables in the OVN_SB database,\n * constructing their contents based on the OVN_NB database. */\nvoid build_lflows(struct lflow_input *input_data,\n                  struct ovsdb_idl_txn *ovnsb_txn)\n{\n    struct hmap lflows;\n    struct hmap mcast_groups;\n    struct hmap igmp_groups;\n\n    build_mcast_groups(input_data, input_data->datapaths, input_data->ports,\n                       &mcast_groups, &igmp_groups);\n\n    fast_hmap_size_for(&lflows, max_seen_lflow_size);\n\n    build_lswitch_and_lrouter_flows(input_data->datapaths, input_data->ports,\n                                    input_data->port_groups, &lflows,\n                                    &mcast_groups, &igmp_groups,\n                                    input_data->meter_groups, input_data->lbs,\n                                    input_data->bfd_connections,\n                                    input_data->features);\n\n    if (parallelization_state == STATE_INIT_HASH_SIZES) {\n        parallelization_state = STATE_USE_PARALLELIZATION;\n    }\n\n    /* Parallel build may result in a suboptimal hash. Resize the\n     * hash to a correct size before doing lookups */\n\n    hmap_expand(&lflows);\n\n    if (hmap_count(&lflows) > max_seen_lflow_size) {\n        max_seen_lflow_size = hmap_count(&lflows);\n    }\n\n    stopwatch_start(LFLOWS_DP_GROUPS_STOPWATCH_NAME, time_msec());\n    /* Collecting all unique datapath groups. */\n    struct hmap dp_groups = HMAP_INITIALIZER(&dp_groups);\n    struct hmap single_dp_lflows;\n\n    /* Single dp_flows will never grow bigger than lflows,\n     * thus the two hmaps will remain the same size regardless\n     * of how many elements we remove from lflows and add to\n     * single_dp_lflows.\n     * Note - lflows is always sized for at least 128 flows.\n     */\n    fast_hmap_size_for(&single_dp_lflows, max_seen_lflow_size);\n\n    struct ovn_lflow *lflow;\n    HMAP_FOR_EACH_SAFE (lflow, hmap_node, &lflows) {\n        struct ovn_dp_group *dpg;\n        uint32_t hash, n_ods;\n\n        n_ods = bitmap_count1(lflow->dpg_bitmap, n_datapaths);\n\n        ovs_assert(n_ods);\n\n        if (n_ods == 1) {\n            /* There is only one datapath, so it should be moved out of the\n             * group to a single 'od'. */\n            size_t index = bitmap_scan(lflow->dpg_bitmap, true, 0,\n                                       n_datapaths);\n\n            bitmap_set0(lflow->dpg_bitmap, index);\n            lflow->od = datapaths_array[index];\n\n            /* Logical flow should be re-hashed to allow lookups. */\n            hash = hmap_node_hash(&lflow->hmap_node);\n            /* Remove from lflows. */\n            hmap_remove(&lflows, &lflow->hmap_node);\n            hash = ovn_logical_flow_hash_datapath(&lflow->od->sb->header_.uuid,\n                                                  hash);\n            /* Add to single_dp_lflows. */\n            hmap_insert_fast(&single_dp_lflows, &lflow->hmap_node, hash);\n            continue;\n        }\n\n        hash = hash_int(n_ods, 0);\n        dpg = ovn_dp_group_find(&dp_groups, lflow->dpg_bitmap, hash);\n        if (!dpg) {\n            dpg = xzalloc(sizeof *dpg);\n            dpg->bitmap = bitmap_clone(lflow->dpg_bitmap, n_datapaths);\n            hmap_insert(&dp_groups, &dpg->node, hash);\n        }\n        lflow->dpg = dpg;\n    }\n\n    /* Merge multiple and single dp hashes. */\n\n    fast_hmap_merge(&lflows, &single_dp_lflows);\n\n    hmap_destroy(&single_dp_lflows);\n\n    stopwatch_stop(LFLOWS_DP_GROUPS_STOPWATCH_NAME, time_msec());\n    stopwatch_start(LFLOWS_TO_SB_STOPWATCH_NAME, time_msec());\n\n    /* Push changes to the Logical_Flow table to database. */\n    const struct sbrec_logical_flow *sbflow;\n    SBREC_LOGICAL_FLOW_TABLE_FOR_EACH_SAFE (sbflow,\n                                     input_data->sbrec_logical_flow_table) {\n        struct sbrec_logical_dp_group *dp_group = sbflow->logical_dp_group;\n        struct ovn_datapath *logical_datapath_od = NULL;\n        size_t i;\n\n        /* Find one valid datapath to get the datapath type. */\n        struct sbrec_datapath_binding *dp = sbflow->logical_datapath;\n        if (dp) {\n            logical_datapath_od = ovn_datapath_from_sbrec(\n                                            input_data->datapaths, dp);\n            if (logical_datapath_od\n                && ovn_datapath_is_stale(logical_datapath_od)) {\n                logical_datapath_od = NULL;\n            }\n        }\n        for (i = 0; dp_group && i < dp_group->n_datapaths; i++) {\n            logical_datapath_od = ovn_datapath_from_sbrec(\n                             input_data->datapaths, dp_group->datapaths[i]);\n            if (logical_datapath_od\n                && !ovn_datapath_is_stale(logical_datapath_od)) {\n                break;\n            }\n            logical_datapath_od = NULL;\n        }\n\n        if (!logical_datapath_od) {\n            /* This lflow has no valid logical datapaths. */\n            sbrec_logical_flow_delete(sbflow);\n            continue;\n        }\n\n        enum ovn_pipeline pipeline\n            = !strcmp(sbflow->pipeline, \"ingress\") ? P_IN : P_OUT;\n\n        lflow = ovn_lflow_find(\n            &lflows, dp_group ? NULL : logical_datapath_od,\n            ovn_stage_build(ovn_datapath_get_type(logical_datapath_od),\n                            pipeline, sbflow->table_id),\n            sbflow->priority, sbflow->match, sbflow->actions,\n            sbflow->controller_meter, sbflow->hash);\n        if (lflow) {\n            if (input_data->ovn_internal_version_changed) {\n                const char *stage_name = smap_get_def(&sbflow->external_ids,\n                                                  \"stage-name\", \"\");\n                const char *stage_hint = smap_get_def(&sbflow->external_ids,\n                                                  \"stage-hint\", \"\");\n                const char *source = smap_get_def(&sbflow->external_ids,\n                                                  \"source\", \"\");\n\n                if (strcmp(stage_name, ovn_stage_to_str(lflow->stage))) {\n                    sbrec_logical_flow_update_external_ids_setkey(sbflow,\n                     \"stage-name\", ovn_stage_to_str(lflow->stage));\n                }\n                if (lflow->stage_hint) {\n                    if (strcmp(stage_hint, lflow->stage_hint)) {\n                        sbrec_logical_flow_update_external_ids_setkey(sbflow,\n                        \"stage-hint\", lflow->stage_hint);\n                    }\n                }\n                if (lflow->where) {\n                    if (strcmp(source, lflow->where)) {\n                        sbrec_logical_flow_update_external_ids_setkey(sbflow,\n                        \"source\", lflow->where);\n                    }\n                }\n            }\n\n            /* This is a valid lflow.  Checking if the datapath group needs\n             * updates. */\n            bool update_dp_group = false;\n\n            if ((!lflow->dpg && dp_group) || (lflow->dpg && !dp_group)) {\n                /* Need to add or delete datapath group. */\n                update_dp_group = true;\n            } else if (!lflow->dpg && !dp_group) {\n                /* No datapath group and not needed. */\n            } else if (lflow->dpg->dp_group) {\n                /* We know the datapath group in Sb that should be used. */\n                if (lflow->dpg->dp_group != dp_group) {\n                    /* Flow has different datapath group in the database.  */\n                    update_dp_group = true;\n                }\n                /* Datapath group is already up to date. */\n            } else {\n                /* There is a datapath group and we need to perform\n                 * a full comparison. */\n                unsigned long *dpg_bitmap;\n                struct ovn_datapath *od;\n\n                dpg_bitmap = bitmap_allocate(n_datapaths);\n                /* Check all logical datapaths from the group. */\n                for (i = 0; i < dp_group->n_datapaths; i++) {\n                    od = ovn_datapath_from_sbrec(\n                            input_data->datapaths, dp_group->datapaths[i]);\n                    if (!od || ovn_datapath_is_stale(od)) {\n                        continue;\n                    }\n                    bitmap_set1(dpg_bitmap, od->index);\n                }\n\n                update_dp_group = !bitmap_equal(dpg_bitmap, lflow->dpg_bitmap,\n                                                n_datapaths);\n                bitmap_free(dpg_bitmap);\n            }\n\n            if (update_dp_group) {\n                ovn_sb_set_lflow_logical_dp_group(ovnsb_txn, &dp_groups,\n                                                  sbflow, lflow->dpg_bitmap);\n            } else if (lflow->dpg && !lflow->dpg->dp_group) {\n                /* Setting relation between unique datapath group and\n                 * Sb DB datapath goup. */\n                lflow->dpg->dp_group = dp_group;\n            }\n\n            /* This lflow updated.  Not needed anymore. */\n            ovn_lflow_destroy(&lflows, lflow);\n        } else {\n            sbrec_logical_flow_delete(sbflow);\n        }\n    }\n\n    HMAP_FOR_EACH_SAFE (lflow, hmap_node, &lflows) {\n        const char *pipeline = ovn_stage_get_pipeline_name(lflow->stage);\n        uint8_t table = ovn_stage_get_table(lflow->stage);\n\n        sbflow = sbrec_logical_flow_insert(ovnsb_txn);\n        if (lflow->od) {\n            sbrec_logical_flow_set_logical_datapath(sbflow, lflow->od->sb);\n        }\n        ovn_sb_set_lflow_logical_dp_group(ovnsb_txn, &dp_groups,\n                                          sbflow, lflow->dpg_bitmap);\n        sbrec_logical_flow_set_pipeline(sbflow, pipeline);\n        sbrec_logical_flow_set_table_id(sbflow, table);\n        sbrec_logical_flow_set_priority(sbflow, lflow->priority);\n        sbrec_logical_flow_set_match(sbflow, lflow->match);\n        sbrec_logical_flow_set_actions(sbflow, lflow->actions);\n        if (lflow->io_port) {\n            struct smap tags = SMAP_INITIALIZER(&tags);\n            smap_add(&tags, \"in_out_port\", lflow->io_port);\n            sbrec_logical_flow_set_tags(sbflow, &tags);\n            smap_destroy(&tags);\n        }\n        sbrec_logical_flow_set_controller_meter(sbflow, lflow->ctrl_meter);\n\n        /* Trim the source locator lflow->where, which looks something like\n         * \"ovn/northd/northd.c:1234\", down to just the part following the\n         * last slash, e.g. \"northd.c:1234\". */\n        const char *slash = strrchr(lflow->where, '/');\n#if _WIN32\n        const char *backslash = strrchr(lflow->where, '\\\\');\n        if (!slash || backslash > slash) {\n            slash = backslash;\n        }\n#endif\n        const char *where = slash ? slash + 1 : lflow->where;\n\n        struct smap ids = SMAP_INITIALIZER(&ids);\n        smap_add(&ids, \"stage-name\", ovn_stage_to_str(lflow->stage));\n        smap_add(&ids, \"source\", where);\n        if (lflow->stage_hint) {\n            smap_add(&ids, \"stage-hint\", lflow->stage_hint);\n        }\n        sbrec_logical_flow_set_external_ids(sbflow, &ids);\n        smap_destroy(&ids);\n\n        ovn_lflow_destroy(&lflows, lflow);\n    }\n    hmap_destroy(&lflows);\n\n    stopwatch_stop(LFLOWS_TO_SB_STOPWATCH_NAME, time_msec());\n    struct ovn_dp_group *dpg;\n    HMAP_FOR_EACH_POP (dpg, node, &dp_groups) {\n        bitmap_free(dpg->bitmap);\n        free(dpg);\n    }\n    hmap_destroy(&dp_groups);\n\n    /* Push changes to the Multicast_Group table to database. */\n    const struct sbrec_multicast_group *sbmc;\n    SBREC_MULTICAST_GROUP_TABLE_FOR_EACH_SAFE (sbmc,\n                                input_data->sbrec_multicast_group_table) {\n        struct ovn_datapath *od = ovn_datapath_from_sbrec(\n                               input_data->datapaths, sbmc->datapath);\n\n        if (!od || ovn_datapath_is_stale(od)) {\n            sbrec_multicast_group_delete(sbmc);\n            continue;\n        }\n\n        struct multicast_group group = { .name = sbmc->name,\n                                         .key = sbmc->tunnel_key };\n        struct ovn_multicast *mc = ovn_multicast_find(&mcast_groups,\n                                                      od, &group);\n        if (mc) {\n            ovn_multicast_update_sbrec(mc, sbmc);\n            ovn_multicast_destroy(&mcast_groups, mc);\n        } else {\n            sbrec_multicast_group_delete(sbmc);\n        }\n    }\n    struct ovn_multicast *mc;\n    HMAP_FOR_EACH_SAFE (mc, hmap_node, &mcast_groups) {\n        if (!mc->datapath) {\n            ovn_multicast_destroy(&mcast_groups, mc);\n            continue;\n        }\n        sbmc = sbrec_multicast_group_insert(ovnsb_txn);\n        sbrec_multicast_group_set_datapath(sbmc, mc->datapath->sb);\n        sbrec_multicast_group_set_name(sbmc, mc->group->name);\n        sbrec_multicast_group_set_tunnel_key(sbmc, mc->group->key);\n        ovn_multicast_update_sbrec(mc, sbmc);\n        ovn_multicast_destroy(&mcast_groups, mc);\n    }\n\n    struct ovn_igmp_group *igmp_group;\n\n    HMAP_FOR_EACH_SAFE (igmp_group, hmap_node, &igmp_groups) {\n        ovn_igmp_group_destroy(&igmp_groups, igmp_group);\n    }\n\n    hmap_destroy(&igmp_groups);\n    hmap_destroy(&mcast_groups);\n}\n\n/* Each port group in Port_Group table in OVN_Northbound has a corresponding\n * entry in Port_Group table in OVN_Southbound. In OVN_Northbound the entries\n * contains lport uuids, while in OVN_Southbound we store the lport names.\n */\nstatic void\nsync_port_groups(struct northd_input *input_data,\n                struct ovsdb_idl_txn *ovnsb_txn,\n                 struct hmap *pgs)\n{\n    struct shash sb_port_groups = SHASH_INITIALIZER(&sb_port_groups);\n\n    const struct sbrec_port_group *sb_port_group;\n    SBREC_PORT_GROUP_TABLE_FOR_EACH (sb_port_group,\n                               input_data->sbrec_port_group_table) {\n        shash_add(&sb_port_groups, sb_port_group->name, sb_port_group);\n    }\n\n    struct ds sb_name = DS_EMPTY_INITIALIZER;\n\n    struct ovn_port_group *pg;\n    HMAP_FOR_EACH (pg, key_node, pgs) {\n\n        struct ovn_port_group_ls *pg_ls;\n        HMAP_FOR_EACH (pg_ls, key_node, &pg->nb_lswitches) {\n            get_sb_port_group_name(pg->nb_pg->name, pg_ls->od->sb->tunnel_key,\n                                   &sb_name);\n            sb_port_group = shash_find_and_delete(&sb_port_groups,\n                                                  ds_cstr(&sb_name));\n            if (!sb_port_group) {\n                sb_port_group = sbrec_port_group_insert(ovnsb_txn);\n                sbrec_port_group_set_name(sb_port_group, ds_cstr(&sb_name));\n            }\n\n            const char **nb_port_names = xcalloc(pg_ls->n_ports,\n                                                 sizeof *nb_port_names);\n            for (size_t i = 0; i < pg_ls->n_ports; i++) {\n                nb_port_names[i] = pg_ls->ports[i]->nbsp->name;\n            }\n            sbrec_port_group_set_ports(sb_port_group,\n                                       nb_port_names,\n                                       pg_ls->n_ports);\n            free(nb_port_names);\n        }\n    }\n    ds_destroy(&sb_name);\n\n    struct shash_node *node;\n    SHASH_FOR_EACH_SAFE (node, &sb_port_groups) {\n        sbrec_port_group_delete(node->data);\n        shash_delete(&sb_port_groups, node);\n    }\n    shash_destroy(&sb_port_groups);\n}\n\nstruct band_entry {\n    int64_t rate;\n    int64_t burst_size;\n    const char *action;\n};\n\nstatic int\nband_cmp(const void *band1_, const void *band2_)\n{\n    const struct band_entry *band1p = band1_;\n    const struct band_entry *band2p = band2_;\n\n    if (band1p->rate != band2p->rate) {\n        return band1p->rate > band2p->rate ? -1 : 1;\n    } else if (band1p->burst_size != band2p->burst_size) {\n        return band1p->burst_size > band2p->burst_size ? -1 : 1;\n    } else {\n        return strcmp(band1p->action, band2p->action);\n    }\n}\n\nstatic bool\nbands_need_update(const struct nbrec_meter *nb_meter,\n                  const struct sbrec_meter *sb_meter)\n{\n    if (nb_meter->n_bands != sb_meter->n_bands) {\n        return true;\n    }\n\n    /* A single band is the most common scenario, so speed up that\n     * check. */\n    if (nb_meter->n_bands == 1) {\n        struct nbrec_meter_band *nb_band = nb_meter->bands[0];\n        struct sbrec_meter_band *sb_band = sb_meter->bands[0];\n\n        return !(nb_band->rate == sb_band->rate\n                 && nb_band->burst_size == sb_band->burst_size\n                 && !strcmp(sb_band->action, nb_band->action));\n    }\n\n    /* Place the Northbound entries in sorted order. */\n    struct band_entry *nb_bands;\n    nb_bands = xmalloc(sizeof *nb_bands * nb_meter->n_bands);\n    for (size_t i = 0; i < nb_meter->n_bands; i++) {\n        struct nbrec_meter_band *nb_band = nb_meter->bands[i];\n\n        nb_bands[i].rate = nb_band->rate;\n        nb_bands[i].burst_size = nb_band->burst_size;\n        nb_bands[i].action = nb_band->action;\n    }\n    qsort(nb_bands, nb_meter->n_bands, sizeof *nb_bands, band_cmp);\n\n    /* Place the Southbound entries in sorted order. */\n    struct band_entry *sb_bands;\n    sb_bands = xmalloc(sizeof *sb_bands * sb_meter->n_bands);\n    for (size_t i = 0; i < sb_meter->n_bands; i++) {\n        struct sbrec_meter_band *sb_band = sb_meter->bands[i];\n\n        sb_bands[i].rate = sb_band->rate;\n        sb_bands[i].burst_size = sb_band->burst_size;\n        sb_bands[i].action = sb_band->action;\n    }\n    qsort(sb_bands, sb_meter->n_bands, sizeof *sb_bands, band_cmp);\n\n    bool need_update = false;\n    for (size_t i = 0; i < nb_meter->n_bands; i++) {\n        if (nb_bands[i].rate != sb_bands[i].rate\n            || nb_bands[i].burst_size != sb_bands[i].burst_size\n            || strcmp(nb_bands[i].action, sb_bands[i].action)) {\n            need_update = true;\n            goto done;\n        }\n    }\n\ndone:\n    free(nb_bands);\n    free(sb_bands);\n\n    return need_update;\n}\n\nstatic void\nsync_meters_iterate_nb_meter(struct ovsdb_idl_txn *ovnsb_txn,\n                             const char *meter_name,\n                             const struct nbrec_meter *nb_meter,\n                             struct shash *sb_meters,\n                             struct sset *used_sb_meters)\n{\n    const struct sbrec_meter *sb_meter;\n    bool new_sb_meter = false;\n\n    sb_meter = shash_find_data(sb_meters, meter_name);\n    if (!sb_meter) {\n        sb_meter = sbrec_meter_insert(ovnsb_txn);\n        sbrec_meter_set_name(sb_meter, meter_name);\n        shash_add(sb_meters, sb_meter->name, sb_meter);\n        new_sb_meter = true;\n    }\n    sset_add(used_sb_meters, meter_name);\n\n    if (new_sb_meter || bands_need_update(nb_meter, sb_meter)) {\n        struct sbrec_meter_band **sb_bands;\n        sb_bands = xcalloc(nb_meter->n_bands, sizeof *sb_bands);\n        for (size_t i = 0; i < nb_meter->n_bands; i++) {\n            const struct nbrec_meter_band *nb_band = nb_meter->bands[i];\n\n            sb_bands[i] = sbrec_meter_band_insert(ovnsb_txn);\n\n            sbrec_meter_band_set_action(sb_bands[i], nb_band->action);\n            sbrec_meter_band_set_rate(sb_bands[i], nb_band->rate);\n            sbrec_meter_band_set_burst_size(sb_bands[i],\n                                            nb_band->burst_size);\n        }\n        sbrec_meter_set_bands(sb_meter, sb_bands, nb_meter->n_bands);\n        free(sb_bands);\n    }\n\n    sbrec_meter_set_unit(sb_meter, nb_meter->unit);\n}\n\nstatic void\nsync_acl_fair_meter(struct ovsdb_idl_txn *ovnsb_txn,\n                    struct shash *meter_groups,\n                    const struct nbrec_acl *acl, struct shash *sb_meters,\n                    struct sset *used_sb_meters)\n{\n    const struct nbrec_meter *nb_meter =\n        fair_meter_lookup_by_name(meter_groups, acl->meter);\n\n    if (!nb_meter) {\n        return;\n    }\n\n    char *meter_name = alloc_acl_log_unique_meter_name(acl);\n    sync_meters_iterate_nb_meter(ovnsb_txn, meter_name, nb_meter, sb_meters,\n                                 used_sb_meters);\n    free(meter_name);\n}\n\n/* Each entry in the Meter and Meter_Band tables in OVN_Northbound have\n * a corresponding entries in the Meter and Meter_Band tables in\n * OVN_Southbound. Additionally, ACL logs that use fair meters have\n * a private copy of its meter in the SB table.\n */\nstatic void\nsync_meters(struct northd_input *input_data,\n            struct ovsdb_idl_txn *ovnsb_txn,\n            struct shash *meter_groups)\n{\n    struct shash sb_meters = SHASH_INITIALIZER(&sb_meters);\n    struct sset used_sb_meters = SSET_INITIALIZER(&used_sb_meters);\n\n    const struct sbrec_meter *sb_meter;\n    SBREC_METER_TABLE_FOR_EACH (sb_meter, input_data->sbrec_meter_table) {\n        shash_add(&sb_meters, sb_meter->name, sb_meter);\n    }\n\n    const struct nbrec_meter *nb_meter;\n    NBREC_METER_TABLE_FOR_EACH (nb_meter, input_data->nbrec_meter_table) {\n        sync_meters_iterate_nb_meter(ovnsb_txn, nb_meter->name, nb_meter,\n                                     &sb_meters, &used_sb_meters);\n    }\n\n    /*\n     * In addition to creating Meters in the SB from the block above, check\n     * and see if additional rows are needed to get ACLs logs individually\n     * rate-limited.\n     */\n    const struct nbrec_acl *acl;\n    NBREC_ACL_TABLE_FOR_EACH (acl, input_data->nbrec_acl_table) {\n        sync_acl_fair_meter(ovnsb_txn, meter_groups, acl,\n                            &sb_meters, &used_sb_meters);\n    }\n\n    const char *used_meter;\n    SSET_FOR_EACH_SAFE (used_meter, &used_sb_meters) {\n        shash_find_and_delete(&sb_meters, used_meter);\n        sset_delete(&used_sb_meters, SSET_NODE_FROM_NAME(used_meter));\n    }\n    sset_destroy(&used_sb_meters);\n\n    struct shash_node *node;\n    SHASH_FOR_EACH_SAFE (node, &sb_meters) {\n        sbrec_meter_delete(node->data);\n        shash_delete(&sb_meters, node);\n    }\n    shash_destroy(&sb_meters);\n}\n\nstatic bool\nmirror_needs_update(const struct nbrec_mirror *nb_mirror,\n                    const struct sbrec_mirror *sb_mirror)\n{\n\n    if (nb_mirror->index != sb_mirror->index) {\n        return true;\n    } else if (strcmp(nb_mirror->sink, sb_mirror->sink)) {\n        return true;\n    } else if (strcmp(nb_mirror->type, sb_mirror->type)) {\n        return true;\n    } else if (strcmp(nb_mirror->filter, sb_mirror->filter)) {\n        return true;\n    }\n\n    return false;\n}\n\nstatic void\nsync_mirrors_iterate_nb_mirror(struct ovsdb_idl_txn *ovnsb_txn,\n                               const char *mirror_name,\n                               const struct nbrec_mirror *nb_mirror,\n                               struct shash *sb_mirrors)\n{\n    const struct sbrec_mirror *sb_mirror;\n    bool new_sb_mirror = false;\n\n    sb_mirror = shash_find_data(sb_mirrors, mirror_name);\n    if (!sb_mirror) {\n        sb_mirror = sbrec_mirror_insert(ovnsb_txn);\n        sbrec_mirror_set_name(sb_mirror, mirror_name);\n        shash_add(sb_mirrors, sb_mirror->name, sb_mirror);\n        new_sb_mirror = true;\n    }\n\n    if (new_sb_mirror || mirror_needs_update(nb_mirror, sb_mirror)) {\n        sbrec_mirror_set_filter(sb_mirror, nb_mirror->filter);\n        sbrec_mirror_set_index(sb_mirror, nb_mirror->index);\n        sbrec_mirror_set_sink(sb_mirror, nb_mirror->sink);\n        sbrec_mirror_set_type(sb_mirror, nb_mirror->type);\n    }\n}\n\nstatic void\nsync_mirrors(struct northd_input *input_data,\n             struct ovsdb_idl_txn *ovnsb_txn)\n{\n    struct shash sb_mirrors = SHASH_INITIALIZER(&sb_mirrors);\n\n    const struct sbrec_mirror *sb_mirror;\n    SBREC_MIRROR_TABLE_FOR_EACH (sb_mirror, input_data->sbrec_mirror_table) {\n        shash_add(&sb_mirrors, sb_mirror->name, sb_mirror);\n    }\n\n    const struct nbrec_mirror *nb_mirror;\n    NBREC_MIRROR_TABLE_FOR_EACH (nb_mirror, input_data->nbrec_mirror_table) {\n        sync_mirrors_iterate_nb_mirror(ovnsb_txn, nb_mirror->name, nb_mirror,\n                                       &sb_mirrors);\n        shash_find_and_delete(&sb_mirrors, nb_mirror->name);\n    }\n\n    struct shash_node *node, *next;\n    SHASH_FOR_EACH_SAFE (node, next, &sb_mirrors) {\n        sbrec_mirror_delete(node->data);\n        shash_delete(&sb_mirrors, node);\n    }\n    shash_destroy(&sb_mirrors);\n}\n\n/*\n * struct 'dns_info' is used to sync the DNS records between OVN Northbound db\n * and Southbound db.\n */\nstruct dns_info {\n    struct hmap_node hmap_node;\n    const struct nbrec_dns *nb_dns; /* DNS record in the Northbound db. */\n    const struct sbrec_dns *sb_dns; /* DNS record in the Southbound db. */\n\n    /* Datapaths to which the DNS entry is associated with it. */\n    const struct sbrec_datapath_binding **sbs;\n    size_t n_sbs;\n};\n\nstatic inline struct dns_info *\nget_dns_info_from_hmap(struct hmap *dns_map, struct uuid *uuid)\n{\n    struct dns_info *dns_info;\n    size_t hash = uuid_hash(uuid);\n    HMAP_FOR_EACH_WITH_HASH (dns_info, hmap_node, hash, dns_map) {\n        if (uuid_equals(&dns_info->nb_dns->header_.uuid, uuid)) {\n            return dns_info;\n        }\n    }\n\n    return NULL;\n}\n\nstatic void\nsync_dns_entries(struct northd_input *input_data,\n                 struct ovsdb_idl_txn *ovnsb_txn,\n                 struct hmap *datapaths)\n{\n    struct hmap dns_map = HMAP_INITIALIZER(&dns_map);\n    struct ovn_datapath *od;\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs || !od->nbs->n_dns_records) {\n            continue;\n        }\n\n        for (size_t i = 0; i < od->nbs->n_dns_records; i++) {\n            struct dns_info *dns_info = get_dns_info_from_hmap(\n                &dns_map, &od->nbs->dns_records[i]->header_.uuid);\n            if (!dns_info) {\n                size_t hash = uuid_hash(\n                    &od->nbs->dns_records[i]->header_.uuid);\n                dns_info = xzalloc(sizeof *dns_info);;\n                dns_info->nb_dns = od->nbs->dns_records[i];\n                hmap_insert(&dns_map, &dns_info->hmap_node, hash);\n            }\n\n            dns_info->n_sbs++;\n            dns_info->sbs = xrealloc(dns_info->sbs,\n                                     dns_info->n_sbs * sizeof *dns_info->sbs);\n            dns_info->sbs[dns_info->n_sbs - 1] = od->sb;\n        }\n    }\n\n    const struct sbrec_dns *sbrec_dns;\n    SBREC_DNS_TABLE_FOR_EACH_SAFE (sbrec_dns, input_data->sbrec_dns_table) {\n        const char *nb_dns_uuid = smap_get(&sbrec_dns->external_ids, \"dns_id\");\n        struct uuid dns_uuid;\n        if (!nb_dns_uuid || !uuid_from_string(&dns_uuid, nb_dns_uuid)) {\n            sbrec_dns_delete(sbrec_dns);\n            continue;\n        }\n\n        struct dns_info *dns_info =\n            get_dns_info_from_hmap(&dns_map, &dns_uuid);\n        if (dns_info) {\n            dns_info->sb_dns = sbrec_dns;\n        } else {\n            sbrec_dns_delete(sbrec_dns);\n        }\n    }\n\n    struct dns_info *dns_info;\n    HMAP_FOR_EACH_POP (dns_info, hmap_node, &dns_map) {\n        if (!dns_info->sb_dns) {\n            sbrec_dns = sbrec_dns_insert(ovnsb_txn);\n            dns_info->sb_dns = sbrec_dns;\n            char *dns_id = xasprintf(\n                UUID_FMT, UUID_ARGS(&dns_info->nb_dns->header_.uuid));\n            const struct smap external_ids =\n                SMAP_CONST1(&external_ids, \"dns_id\", dns_id);\n            sbrec_dns_set_external_ids(sbrec_dns, &external_ids);\n            free(dns_id);\n        }\n\n        /* Set the datapaths and records. If nothing has changed, then\n         * this will be a no-op.\n         */\n        sbrec_dns_set_datapaths(\n            dns_info->sb_dns,\n            (struct sbrec_datapath_binding **)dns_info->sbs,\n            dns_info->n_sbs);\n\n        /* DNS lookups are case-insensitive. Convert records to lowercase so\n         * we can do consistent lookups when DNS requests arrive\n         */\n        struct smap lower_records = SMAP_INITIALIZER(&lower_records);\n        struct smap_node *node;\n        SMAP_FOR_EACH (node, &dns_info->nb_dns->records) {\n            smap_add_nocopy(&lower_records, xstrdup(node->key),\n                            str_tolower(node->value));\n        }\n\n        sbrec_dns_set_records(dns_info->sb_dns, &lower_records);\n\n        smap_destroy(&lower_records);\n        free(dns_info->sbs);\n        free(dns_info);\n    }\n    hmap_destroy(&dns_map);\n}\n\nstatic void\nsync_template_vars(struct northd_input *input_data,\n                   struct ovsdb_idl_txn *ovnsb_txn)\n{\n    struct shash nb_tvs = SHASH_INITIALIZER(&nb_tvs);\n\n    const struct nbrec_chassis_template_var *nb_tv;\n    const struct sbrec_chassis_template_var *sb_tv;\n\n    NBREC_CHASSIS_TEMPLATE_VAR_TABLE_FOR_EACH (\n            nb_tv, input_data->nbrec_chassis_template_var_table) {\n        shash_add(&nb_tvs, nb_tv->chassis, nb_tv);\n    }\n\n    SBREC_CHASSIS_TEMPLATE_VAR_TABLE_FOR_EACH_SAFE (\n            sb_tv, input_data->sbrec_chassis_template_var_table) {\n        nb_tv = shash_find_and_delete(&nb_tvs, sb_tv->chassis);\n        if (!nb_tv) {\n            sbrec_chassis_template_var_delete(sb_tv);\n            continue;\n        }\n        if (!smap_equal(&sb_tv->variables, &nb_tv->variables)) {\n            sbrec_chassis_template_var_set_variables(sb_tv,\n                                                     &nb_tv->variables);\n        }\n    }\n\n    struct shash_node *node;\n    SHASH_FOR_EACH (node, &nb_tvs) {\n        nb_tv = node->data;\n        sb_tv = sbrec_chassis_template_var_insert(ovnsb_txn);\n        sbrec_chassis_template_var_set_chassis(sb_tv, nb_tv->chassis);\n        sbrec_chassis_template_var_set_variables(sb_tv, &nb_tv->variables);\n    }\n    shash_destroy(&nb_tvs);\n}\n\f\nstatic void\ndestroy_datapaths_and_ports(struct hmap *datapaths, struct hmap *ports,\n                            struct ovs_list *lr_list)\n{\n    struct ovn_datapath *router_dp;\n    LIST_FOR_EACH_POP (router_dp, lr_list, lr_list) {\n        if (router_dp->lr_group) {\n            struct lrouter_group *lr_group = router_dp->lr_group;\n\n            for (size_t i = 0; i < lr_group->n_router_dps; i++) {\n                lr_group->router_dps[i]->lr_group = NULL;\n            }\n\n            free(lr_group->router_dps);\n            sset_destroy(&lr_group->ha_chassis_groups);\n            hmapx_destroy(&lr_group->tmp_ha_chassis);\n            free(lr_group);\n        }\n    }\n\n    struct ovn_datapath *dp;\n    HMAP_FOR_EACH_SAFE (dp, key_node, datapaths) {\n        ovn_datapath_destroy(datapaths, dp);\n    }\n    hmap_destroy(datapaths);\n\n    struct ovn_port *port;\n    HMAP_FOR_EACH_SAFE (port, key_node, ports) {\n        ovn_port_destroy(ports, port);\n    }\n    hmap_destroy(ports);\n}\n\nstatic void\nbuild_ip_mcast(struct northd_input *input_data,\n               struct ovsdb_idl_txn *ovnsb_txn,\n               struct hmap *datapaths)\n{\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs) {\n            continue;\n        }\n\n        const struct sbrec_ip_multicast *ip_mcast =\n            ip_mcast_lookup(input_data->sbrec_ip_mcast_by_dp, od->sb);\n\n        if (!ip_mcast) {\n            ip_mcast = sbrec_ip_multicast_insert(ovnsb_txn);\n        }\n        store_mcast_info_for_switch_datapath(ip_mcast, od);\n    }\n\n    /* Delete southbound records without northbound matches. */\n    const struct sbrec_ip_multicast *sb;\n\n    SBREC_IP_MULTICAST_TABLE_FOR_EACH_SAFE (sb,\n                                   input_data->sbrec_ip_multicast_table) {\n        od = ovn_datapath_from_sbrec(datapaths, sb->datapath);\n        if (!od || ovn_datapath_is_stale(od)) {\n            sbrec_ip_multicast_delete(sb);\n        }\n    }\n}\n\nstatic void\nbuild_mcast_groups(struct lflow_input *input_data,\n                   const struct hmap *datapaths,\n                   const struct hmap *ports,\n                   struct hmap *mcast_groups,\n                   struct hmap *igmp_groups)\n{\n    struct ovn_port *op;\n\n    hmap_init(mcast_groups);\n    hmap_init(igmp_groups);\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        init_mcast_flow_count(od);\n    }\n\n    HMAP_FOR_EACH (op, key_node, ports) {\n        if (op->nbrp && lrport_is_enabled(op->nbrp)) {\n            /* If this port is configured to always flood multicast traffic\n             * add it to the MC_STATIC group.\n             */\n            if (op->mcast_info.flood) {\n                ovn_multicast_add(mcast_groups, &mc_static, op);\n                op->od->mcast_info.rtr.flood_static = true;\n            }\n        } else if (op->nbsp && lsp_is_enabled(op->nbsp)) {\n            ovn_multicast_add(mcast_groups, &mc_flood, op);\n\n            if (!lsp_is_router(op->nbsp)) {\n                ovn_multicast_add(mcast_groups, &mc_flood_l2, op);\n            }\n\n            /* If this port is connected to a multicast router then add it\n             * to the MC_MROUTER_FLOOD group.\n             */\n            if (op->od->mcast_info.sw.flood_relay && op->peer &&\n                    op->peer->od && op->peer->od->mcast_info.rtr.relay) {\n                ovn_multicast_add(mcast_groups, &mc_mrouter_flood, op);\n            }\n\n            /* If this port is configured to always flood multicast reports\n             * add it to the MC_MROUTER_FLOOD group (all reports must be\n             * flooded to statically configured or learned mrouters).\n             */\n            if (op->mcast_info.flood_reports) {\n                ovn_multicast_add(mcast_groups, &mc_mrouter_flood, op);\n                op->od->mcast_info.sw.flood_reports = true;\n            }\n\n            /* If this port is configured to always flood multicast traffic\n             * add it to the MC_STATIC group.\n             */\n            if (op->mcast_info.flood) {\n                ovn_multicast_add(mcast_groups, &mc_static, op);\n                op->od->mcast_info.sw.flood_static = true;\n            }\n        }\n    }\n\n    const struct sbrec_igmp_group *sb_igmp;\n\n    SBREC_IGMP_GROUP_TABLE_FOR_EACH_SAFE (sb_igmp,\n                                     input_data->sbrec_igmp_group_table) {\n        /* If this is a stale group (e.g., controller had crashed,\n         * purge it).\n         */\n        if (!sb_igmp->chassis || !sb_igmp->datapath) {\n            sbrec_igmp_group_delete(sb_igmp);\n            continue;\n        }\n\n        /* If the datapath value is stale, purge the group. */\n        od = ovn_datapath_from_sbrec(datapaths, sb_igmp->datapath);\n\n        if (!od || ovn_datapath_is_stale(od)) {\n            sbrec_igmp_group_delete(sb_igmp);\n            continue;\n        }\n\n        struct in6_addr group_address;\n        if (!strcmp(sb_igmp->address, OVN_IGMP_GROUP_MROUTERS)) {\n            /* Use all-zeros IP to denote a group corresponding to mrouters. */\n            memset(&group_address, 0, sizeof group_address);\n        } else if (!ovn_igmp_group_get_address(sb_igmp, &group_address)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"invalid IGMP group address: %s\",\n                         sb_igmp->address);\n            continue;\n        }\n\n        /* Extract the IGMP group ports from the SB entry. */\n        size_t n_igmp_ports;\n        struct ovn_port **igmp_ports =\n            ovn_igmp_group_get_ports(sb_igmp, &n_igmp_ports, ports);\n\n        /* It can be that all ports in the IGMP group record already have\n         * mcast_flood=true and then we can skip the group completely.\n         */\n        if (!igmp_ports) {\n            continue;\n        }\n\n        /* Add the IGMP group entry. Will also try to allocate an ID for it\n         * if the multicast group already exists.\n         */\n        struct ovn_igmp_group *igmp_group =\n            ovn_igmp_group_add(input_data, igmp_groups, od, &group_address,\n                               sb_igmp->address);\n\n        /* Add the extracted ports to the IGMP group. */\n        ovn_igmp_group_add_entry(igmp_group, igmp_ports, n_igmp_ports);\n    }\n\n    /* Build IGMP groups for multicast routers with relay enabled. The router\n     * IGMP groups are based on the groups learnt by their multicast enabled\n     * peers.\n     */\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n\n        if (ovs_list_is_empty(&od->mcast_info.groups)) {\n            continue;\n        }\n\n        for (size_t i = 0; i < od->n_router_ports; i++) {\n            struct ovn_port *router_port = od->router_ports[i]->peer;\n\n            /* If the router the port connects to doesn't have multicast\n             * relay enabled or if it was already configured to flood\n             * multicast traffic then skip it.\n             */\n            if (!router_port || !router_port->od ||\n                    !router_port->od->mcast_info.rtr.relay ||\n                    router_port->mcast_info.flood) {\n                continue;\n            }\n\n            struct ovn_igmp_group *igmp_group;\n            LIST_FOR_EACH (igmp_group, list_node, &od->mcast_info.groups) {\n                struct in6_addr *address = &igmp_group->address;\n\n                /* Skip mrouter entries. */\n                if (!strcmp(igmp_group->mcgroup.name,\n                            OVN_IGMP_GROUP_MROUTERS)) {\n                    continue;\n                }\n\n                /* For IPv6 only relay routable multicast groups\n                 * (RFC 4291 2.7).\n                 */\n                if (!IN6_IS_ADDR_V4MAPPED(address) &&\n                        !ipv6_addr_is_routable_multicast(address)) {\n                    continue;\n                }\n\n                struct ovn_igmp_group *igmp_group_rtr =\n                    ovn_igmp_group_add(input_data,\n                                       igmp_groups, router_port->od,\n                                       address, igmp_group->mcgroup.name);\n                struct ovn_port **router_igmp_ports =\n                    xmalloc(sizeof *router_igmp_ports);\n                /* Store the chassis redirect port  otherwise traffic will not\n                 * be tunneled properly.\n                 */\n                router_igmp_ports[0] = router_port->cr_port\n                                       ? router_port->cr_port\n                                       : router_port;\n                ovn_igmp_group_add_entry(igmp_group_rtr, router_igmp_ports, 1);\n            }\n        }\n    }\n\n    /* Walk the aggregated IGMP groups and allocate IDs for new entries.\n     * Then store the ports in the associated multicast group.\n     * Mrouter entries are also stored as IGMP groups, deal with those\n     * explicitly.\n     */\n    struct ovn_igmp_group *igmp_group;\n    HMAP_FOR_EACH_SAFE (igmp_group, hmap_node, igmp_groups) {\n\n        /* If this is a mrouter entry just aggregate the mrouter ports\n         * into the MC_MROUTER mcast_group and destroy the igmp_group;\n         * no more processing needed. */\n        if (!strcmp(igmp_group->mcgroup.name, OVN_IGMP_GROUP_MROUTERS)) {\n            ovn_igmp_mrouter_aggregate_ports(igmp_group, mcast_groups);\n            ovn_igmp_group_destroy(igmp_groups, igmp_group);\n            continue;\n        }\n\n        if (!ovn_igmp_group_allocate_id(igmp_group)) {\n            /* If we ran out of keys just destroy the entry. */\n            ovn_igmp_group_destroy(igmp_groups, igmp_group);\n            continue;\n        }\n\n        /* Aggregate the ports from all entries corresponding to this\n         * group.\n         */\n        ovn_igmp_group_aggregate_ports(igmp_group, mcast_groups);\n    }\n}\n\nstatic void\nbuild_meter_groups(struct northd_input *input_data,\n                   struct shash *meter_groups)\n{\n    const struct nbrec_meter *nb_meter;\n    NBREC_METER_TABLE_FOR_EACH (nb_meter, input_data->nbrec_meter_table) {\n        shash_add(meter_groups, nb_meter->name, nb_meter);\n    }\n}\n\nstatic const struct nbrec_static_mac_binding *\nstatic_mac_binding_by_port_ip(struct northd_input *input_data,\n                       const char *logical_port, const char *ip)\n{\n    const struct nbrec_static_mac_binding *nb_smb = NULL;\n\n    NBREC_STATIC_MAC_BINDING_TABLE_FOR_EACH (\n        nb_smb, input_data->nbrec_static_mac_binding_table) {\n        if (!strcmp(nb_smb->logical_port, logical_port) &&\n            !strcmp(nb_smb->ip, ip)) {\n            break;\n        }\n    }\n\n    return nb_smb;\n}\n\nstatic void\nbuild_static_mac_binding_table(struct northd_input *input_data,\n                               struct ovsdb_idl_txn *ovnsb_txn,\n                               struct hmap *ports)\n{\n    /* Cleanup SB Static_MAC_Binding entries which do not have corresponding\n     * NB Static_MAC_Binding entries. */\n    const struct nbrec_static_mac_binding *nb_smb;\n    const struct sbrec_static_mac_binding *sb_smb;\n    SBREC_STATIC_MAC_BINDING_TABLE_FOR_EACH_SAFE (sb_smb,\n        input_data->sbrec_static_mac_binding_table) {\n        nb_smb = static_mac_binding_by_port_ip(input_data,\n                                               sb_smb->logical_port,\n                                               sb_smb->ip);\n        if (!nb_smb) {\n            sbrec_static_mac_binding_delete(sb_smb);\n        }\n    }\n\n    /* Create/Update SB Static_MAC_Binding entries with corresponding values\n     * from NB Static_MAC_Binding entries. */\n    NBREC_STATIC_MAC_BINDING_TABLE_FOR_EACH (\n        nb_smb, input_data->nbrec_static_mac_binding_table) {\n        struct ovn_port *op = ovn_port_find(ports, nb_smb->logical_port);\n        if (op && op->nbrp) {\n            struct ovn_datapath *od = op->od;\n            if (od && od->sb) {\n                const struct sbrec_static_mac_binding *mb =\n                    static_mac_binding_lookup(\n                        input_data->sbrec_static_mac_binding_by_lport_ip,\n                        nb_smb->logical_port, nb_smb->ip);\n                if (!mb) {\n                    /* Create new entry */\n                    mb = sbrec_static_mac_binding_insert(ovnsb_txn);\n                    sbrec_static_mac_binding_set_logical_port(\n                        mb, nb_smb->logical_port);\n                    sbrec_static_mac_binding_set_ip(mb, nb_smb->ip);\n                    sbrec_static_mac_binding_set_mac(mb, nb_smb->mac);\n                    sbrec_static_mac_binding_set_override_dynamic_mac(mb,\n                        nb_smb->override_dynamic_mac);\n                    sbrec_static_mac_binding_set_datapath(mb, od->sb);\n                } else {\n                    /* Update existing entry if there is a change*/\n                    if (strcmp(mb->mac, nb_smb->mac)) {\n                        sbrec_static_mac_binding_set_mac(mb, nb_smb->mac);\n                    }\n                    if (mb->override_dynamic_mac !=\n                        nb_smb->override_dynamic_mac) {\n                        sbrec_static_mac_binding_set_override_dynamic_mac(mb,\n                            nb_smb->override_dynamic_mac);\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid\nnorthd_init(struct northd_data *data)\n{\n    hmap_init(&data->datapaths);\n    hmap_init(&data->ports);\n    hmap_init(&data->port_groups);\n    shash_init(&data->meter_groups);\n    hmap_init(&data->lbs);\n    hmap_init(&data->lb_groups);\n    hmap_init(&data->bfd_connections);\n    ovs_list_init(&data->lr_list);\n    data->features = (struct chassis_features) {\n        .ct_no_masked_label = true,\n        .mac_binding_timestamp = true,\n        .ct_lb_related = true,\n    };\n    data->ovn_internal_version_changed = false;\n}\n\nvoid\nnorthd_destroy(struct northd_data *data)\n{\n    struct ovn_northd_lb *lb;\n    HMAP_FOR_EACH_POP (lb, hmap_node, &data->lbs) {\n        ovn_northd_lb_destroy(lb);\n    }\n    hmap_destroy(&data->lbs);\n\n    struct ovn_lb_group *lb_group;\n    HMAP_FOR_EACH_POP (lb_group, hmap_node, &data->lb_groups) {\n        ovn_lb_group_destroy(lb_group);\n    }\n    hmap_destroy(&data->lb_groups);\n\n    struct ovn_port_group *pg;\n    HMAP_FOR_EACH_SAFE (pg, key_node, &data->port_groups) {\n        ovn_port_group_destroy(&data->port_groups, pg);\n    }\n\n    hmap_destroy(&data->port_groups);\n    hmap_destroy(&data->bfd_connections);\n\n    struct shash_node *node;\n    SHASH_FOR_EACH_SAFE (node, &data->meter_groups) {\n        shash_delete(&data->meter_groups, node);\n    }\n    shash_destroy(&data->meter_groups);\n\n    /* XXX Having to explicitly clean up macam here\n     * is a bit strange. We don't explicitly initialize\n     * macam in this module, but this is the logical place\n     * to clean it up. Ideally, more IPAM logic can be factored\n     * out of ovn-northd and this can be taken care of there\n     * as well.\n     */\n    cleanup_macam();\n\n    destroy_datapaths_and_ports(&data->datapaths, &data->ports,\n                                &data->lr_list);\n    destroy_debug_config();\n}\n\nstatic void\novnnb_db_run(struct northd_input *input_data,\n             struct northd_data *data,\n             struct ovsdb_idl_txn *ovnnb_txn,\n             struct ovsdb_idl_txn *ovnsb_txn,\n             struct ovsdb_idl_index *sbrec_chassis_by_name,\n             struct ovsdb_idl_index *sbrec_chassis_by_hostname)\n{\n    if (!ovnsb_txn || !ovnnb_txn) {\n        return;\n    }\n    stopwatch_start(BUILD_LFLOWS_CTX_STOPWATCH_NAME, time_msec());\n\n    /* Sync ipsec configuration.\n     * Copy nb_cfg from northbound to southbound database.\n     * Also set up to update sb_cfg once our southbound transaction commits. */\n    const struct nbrec_nb_global *nb = nbrec_nb_global_table_first(\n                                       input_data->nbrec_nb_global_table);\n    if (!nb) {\n        nb = nbrec_nb_global_insert(ovnnb_txn);\n    }\n\n    const char *mac_addr_prefix = set_mac_prefix(smap_get(&nb->options,\n                                                          \"mac_prefix\"));\n\n    const char *monitor_mac = smap_get(&nb->options, \"svc_monitor_mac\");\n    if (monitor_mac) {\n        if (eth_addr_from_string(monitor_mac, &svc_monitor_mac_ea)) {\n            snprintf(svc_monitor_mac, sizeof svc_monitor_mac,\n                     ETH_ADDR_FMT, ETH_ADDR_ARGS(svc_monitor_mac_ea));\n        } else {\n            monitor_mac = NULL;\n        }\n    }\n\n    struct smap options;\n    smap_clone(&options, &nb->options);\n\n    smap_replace(&options, \"mac_prefix\", mac_addr_prefix);\n\n    if (!monitor_mac) {\n        eth_addr_random(&svc_monitor_mac_ea);\n        snprintf(svc_monitor_mac, sizeof svc_monitor_mac,\n                 ETH_ADDR_FMT, ETH_ADDR_ARGS(svc_monitor_mac_ea));\n        smap_replace(&options, \"svc_monitor_mac\", svc_monitor_mac);\n    }\n\n    char *max_tunid = xasprintf(\"%d\", get_ovn_max_dp_key_local(input_data));\n    smap_replace(&options, \"max_tunid\", max_tunid);\n    free(max_tunid);\n\n    char *ovn_internal_version = ovn_get_internal_version();\n    if (!strcmp(ovn_internal_version,\n                smap_get_def(&options, \"northd_internal_version\", \"\"))) {\n        data->ovn_internal_version_changed = false;\n    } else {\n        smap_replace(&options, \"northd_internal_version\",\n                     ovn_internal_version);\n    }\n    free(ovn_internal_version);\n\n    if (!smap_equal(&nb->options, &options)) {\n        nbrec_nb_global_verify_options(nb);\n        nbrec_nb_global_set_options(nb, &options);\n    }\n\n    use_ct_inv_match = smap_get_bool(&nb->options,\n                                     \"use_ct_inv_match\", true);\n\n    /* deprecated, use --event instead */\n    controller_event_en = smap_get_bool(&nb->options,\n                                        \"controller_event\", false);\n    check_lsp_is_up = !smap_get_bool(&nb->options,\n                                     \"ignore_lsp_down\", true);\n    default_acl_drop = smap_get_bool(&nb->options, \"default_acl_drop\", false);\n\n    install_ls_lb_from_router = smap_get_bool(&nb->options,\n                                              \"install_ls_lb_from_router\",\n                                              false);\n\n    build_chassis_features(input_data, &data->features);\n\n    init_debug_config(nb);\n\n    build_datapaths(input_data, ovnsb_txn, &data->datapaths, &data->lr_list);\n    build_lbs(input_data, &data->datapaths, &data->lbs, &data->lb_groups);\n    build_ports(input_data, ovnsb_txn, sbrec_chassis_by_name,\n                sbrec_chassis_by_hostname,\n                &data->datapaths, &data->ports);\n    build_lb_port_related_data(&data->datapaths, &data->ports, &data->lbs,\n                               &data->lb_groups, input_data, ovnsb_txn);\n    build_lb_count_dps(&data->lbs);\n    build_ipam(&data->datapaths, &data->ports);\n    build_port_group_lswitches(input_data, &data->port_groups, &data->ports);\n    build_lrouter_groups(&data->ports, &data->lr_list);\n    build_ip_mcast(input_data, ovnsb_txn, &data->datapaths);\n    build_meter_groups(input_data, &data->meter_groups);\n    build_static_mac_binding_table(input_data, ovnsb_txn, &data->ports);\n    stopwatch_stop(BUILD_LFLOWS_CTX_STOPWATCH_NAME, time_msec());\n    stopwatch_start(CLEAR_LFLOWS_CTX_STOPWATCH_NAME, time_msec());\n    ovn_update_ipv6_options(&data->ports);\n    ovn_update_ipv6_prefix(&data->ports);\n\n    sync_lbs(input_data, ovnsb_txn, &data->datapaths, &data->lbs);\n    sync_port_groups(input_data, ovnsb_txn, &data->port_groups);\n    sync_meters(input_data, ovnsb_txn, &data->meter_groups);\n    sync_mirrors(input_data, ovnsb_txn);\n    sync_dns_entries(input_data, ovnsb_txn, &data->datapaths);\n    sync_template_vars(input_data, ovnsb_txn);\n\n    cleanup_stale_fdb_entries(input_data, &data->datapaths);\n    stopwatch_stop(CLEAR_LFLOWS_CTX_STOPWATCH_NAME, time_msec());\n\n    /* Set up SB_Global (depends on chassis features). */\n    const struct sbrec_sb_global *sb = sbrec_sb_global_table_first(\n                                       input_data->sbrec_sb_global_table);\n    if (!sb) {\n        sb = sbrec_sb_global_insert(ovnsb_txn);\n    }\n    if (nb->ipsec != sb->ipsec) {\n        sbrec_sb_global_set_ipsec(sb, nb->ipsec);\n    }\n\n    /* Inform ovn-controllers whether LB flows will use ct_mark (i.e., only\n     * if all chassis support it).  If not explicitly present in the database\n     * the default value to be used for this option is 'true'.\n     */\n    if (!data->features.ct_no_masked_label) {\n        smap_replace(&options, \"lb_hairpin_use_ct_mark\", \"false\");\n    } else {\n        smap_remove(&options, \"lb_hairpin_use_ct_mark\");\n    }\n    if (!smap_equal(&sb->options, &options)) {\n        sbrec_sb_global_set_options(sb, &options);\n    }\n    smap_destroy(&options);\n}\n\n/* Stores the set of chassis which references an ha_chassis_group.\n */\nstruct ha_ref_chassis_info {\n    const struct sbrec_ha_chassis_group *ha_chassis_group;\n    struct hmapx ref_chassis;\n};\n\nstatic void\nadd_to_ha_ref_chassis_info(struct ha_ref_chassis_info *ref_ch_info,\n                           const struct hmapx *chassis)\n{\n    if (!hmapx_count(&ref_ch_info->ref_chassis)) {\n        hmapx_destroy(&ref_ch_info->ref_chassis);\n        hmapx_clone(&ref_ch_info->ref_chassis, chassis);\n    } else {\n        struct hmapx_node *node;\n\n        HMAPX_FOR_EACH (node, chassis) {\n            hmapx_add(&ref_ch_info->ref_chassis, node->data);\n        }\n    }\n}\n\nstruct ha_chassis_group_node {\n    struct hmap_node hmap_node;\n    const struct sbrec_ha_chassis_group *ha_ch_grp;\n};\n\nstatic void\nupdate_sb_ha_group_ref_chassis(struct northd_input *input_data,\n                               struct shash *ha_ref_chassis_map)\n{\n    struct hmap ha_ch_grps = HMAP_INITIALIZER(&ha_ch_grps);\n    struct ha_chassis_group_node *ha_ch_grp_node;\n\n    /* Initialize a set of all ha_chassis_groups in SB. */\n    const struct sbrec_ha_chassis_group *ha_ch_grp;\n    SBREC_HA_CHASSIS_GROUP_TABLE_FOR_EACH (ha_ch_grp,\n                                    input_data->sbrec_ha_chassis_group_table) {\n        ha_ch_grp_node = xzalloc(sizeof *ha_ch_grp_node);\n        ha_ch_grp_node->ha_ch_grp = ha_ch_grp;\n        hmap_insert(&ha_ch_grps, &ha_ch_grp_node->hmap_node,\n                    uuid_hash(&ha_ch_grp->header_.uuid));\n    }\n\n    /* Update each group and remove it from the set. */\n    struct shash_node *node;\n    SHASH_FOR_EACH_SAFE (node, ha_ref_chassis_map) {\n        struct ha_ref_chassis_info *ha_ref_info = node->data;\n        size_t n = hmapx_count(&ha_ref_info->ref_chassis);\n        struct sbrec_chassis **ref_chassis;\n        struct hmapx_node *chassis_node;\n\n        ref_chassis = xmalloc(n * sizeof *ref_chassis);\n\n        n = 0;\n        HMAPX_FOR_EACH (chassis_node, &ha_ref_info->ref_chassis) {\n            ref_chassis[n++] = chassis_node->data;\n        }\n\n        sbrec_ha_chassis_group_set_ref_chassis(ha_ref_info->ha_chassis_group,\n                                               ref_chassis, n);\n        free(ref_chassis);\n\n        /* Remove the updated group from the set. */\n        HMAP_FOR_EACH_WITH_HASH (ha_ch_grp_node, hmap_node,\n            uuid_hash(&ha_ref_info->ha_chassis_group->header_.uuid),\n            &ha_ch_grps) {\n            if (ha_ch_grp_node->ha_ch_grp == ha_ref_info->ha_chassis_group) {\n                hmap_remove(&ha_ch_grps, &ha_ch_grp_node->hmap_node);\n                free(ha_ch_grp_node);\n                break;\n            }\n        }\n        hmapx_destroy(&ha_ref_info->ref_chassis);\n        free(ha_ref_info);\n        shash_delete(ha_ref_chassis_map, node);\n    }\n\n    /* Now the rest of the groups don't have any ref-chassis, so clear the SB\n     * field for those records. */\n    HMAP_FOR_EACH_SAFE (ha_ch_grp_node, hmap_node, &ha_ch_grps) {\n        sbrec_ha_chassis_group_set_ref_chassis(ha_ch_grp_node->ha_ch_grp,\n                                               NULL, 0);\n        hmap_remove(&ha_ch_grps, &ha_ch_grp_node->hmap_node);\n        free(ha_ch_grp_node);\n    }\n\n    hmap_destroy(&ha_ch_grps);\n}\n\n/* This function checks if the port binding 'sb' references\n * a HA chassis group.\n * Eg. Suppose a distributed logical router port - lr0-public\n * uses an HA chassis group - hagrp1 and if hagrp1 has 3 ha\n * chassis - gw1, gw2 and gw3.\n * Or\n * If the distributed logical router port - lr0-public has\n * 3 gateway chassis - gw1, gw2 and gw3.\n * ovn-northd creates ha chassis group - hagrp1 in SB DB\n * and adds gw1, gw2 and gw3 to its ha_chassis list.\n *\n * If port binding 'sb' represents a logical switch port 'p1'\n * and its logical switch is connected to the logical router\n * 'lr0' directly or indirectly (i.e p1's logical switch is\n *  connected to a router 'lr1' and 'lr1' has a path to lr0 via\n *  transit logical switches) and 'sb' is claimed by chassis - 'c1' then\n * this function adds c1 to the list of the reference chassis\n *  - 'ref_chassis' of hagrp1.\n */\nstatic void\ncollect_lb_groups_for_ha_chassis_groups(const struct sbrec_port_binding *sb,\n                                        struct ovn_port *op,\n                                        struct hmapx *lr_groups)\n{\n    struct lrouter_group *lr_group = NULL;\n    for (size_t i = 0; i < op->od->n_router_ports; i++) {\n        if (!op->od->router_ports[i]->peer) {\n            continue;\n        }\n\n        lr_group = op->od->router_ports[i]->peer->od->lr_group;\n        /* If a logical switch has multiple router ports, then\n         * all the logical routers belong to the same logical\n         * router group. */\n        break;\n    }\n\n    if (!lr_group) {\n        return;\n    }\n\n    hmapx_add(lr_groups, lr_group);\n    hmapx_add(&lr_group->tmp_ha_chassis, sb->chassis);\n}\n\nstatic void\nbuild_ha_chassis_group_ref_chassis(struct ovsdb_idl_index *ha_ch_grp_by_name,\n                                   struct hmapx *lr_groups,\n                                   struct shash *ha_ref_chassis_map)\n{\n    struct hmapx_node *node;\n\n    HMAPX_FOR_EACH (node, lr_groups) {\n        struct lrouter_group *lr_group = node->data;\n        const char *ha_group_name;\n\n        SSET_FOR_EACH (ha_group_name, &lr_group->ha_chassis_groups) {\n            const struct sbrec_ha_chassis_group *sb_ha_chassis_grp;\n\n            sb_ha_chassis_grp = ha_chassis_group_lookup_by_name(\n                                    ha_ch_grp_by_name, ha_group_name);\n            if (!sb_ha_chassis_grp) {\n                continue;\n            }\n\n            struct ha_ref_chassis_info *ref_ch_info =\n                shash_find_data(ha_ref_chassis_map, sb_ha_chassis_grp->name);\n            ovs_assert(ref_ch_info);\n\n            add_to_ha_ref_chassis_info(ref_ch_info, &lr_group->tmp_ha_chassis);\n        }\n\n        hmapx_destroy(&lr_group->tmp_ha_chassis);\n        hmapx_init(&lr_group->tmp_ha_chassis);\n    }\n}\n\n/* Handle changes to the 'chassis' column of the 'Port_Binding' table.  When\n * this column is not empty, it means we need to set the corresponding logical\n * port as 'up' in the northbound DB. */\nstatic void\nhandle_port_binding_changes(struct northd_input *input_data,\n                            struct ovsdb_idl_txn *ovnsb_txn,\n                            struct hmap *ports,\n                            struct shash *ha_ref_chassis_map)\n{\n    struct hmapx lr_groups = HMAPX_INITIALIZER(&lr_groups);\n    const struct sbrec_port_binding *sb;\n    bool build_ha_chassis_ref = false;\n\n    if (ovnsb_txn) {\n        const struct sbrec_ha_chassis_group *ha_ch_grp;\n        SBREC_HA_CHASSIS_GROUP_TABLE_FOR_EACH (ha_ch_grp,\n                                    input_data->sbrec_ha_chassis_group_table) {\n            if (ha_ch_grp->n_ha_chassis > 1) {\n                struct ha_ref_chassis_info *ref_ch_info;\n\n                ref_ch_info = xzalloc(sizeof *ref_ch_info);\n                ref_ch_info->ha_chassis_group = ha_ch_grp;\n                hmapx_init(&ref_ch_info->ref_chassis);\n                build_ha_chassis_ref = true;\n                shash_add(ha_ref_chassis_map, ha_ch_grp->name, ref_ch_info);\n            }\n        }\n    }\n\n    SBREC_PORT_BINDING_TABLE_FOR_EACH (sb,\n                                       input_data->sbrec_port_binding_table) {\n        struct ovn_port *op = ovn_port_find(ports, sb->logical_port);\n\n        if (!op || !op->nbsp) {\n            /* The logical port doesn't exist for this port binding.  This can\n             * happen under normal circumstances when ovn-northd hasn't gotten\n             * around to pruning the Port_Binding yet. */\n            continue;\n        }\n\n        bool up = false;\n\n        if (lsp_is_router(op->nbsp)) {\n            up = true;\n        } else if (sb->chassis) {\n            up = smap_get_bool(&sb->chassis->other_config,\n                               OVN_FEATURE_PORT_UP_NOTIF, false)\n                 ? sb->n_up && sb->up[0]\n                 : true;\n        }\n\n        if (!op->nbsp->up || *op->nbsp->up != up) {\n            nbrec_logical_switch_port_set_up(op->nbsp, &up, 1);\n        }\n\n        if (build_ha_chassis_ref && ovnsb_txn && sb->chassis) {\n            /* Check and collect the chassis which has claimed this 'sb'\n             * in relation to LR groups. */\n            collect_lb_groups_for_ha_chassis_groups(sb, op, &lr_groups);\n        }\n    }\n\n    /* Update ha chassis group's ref_chassis if required. */\n    build_ha_chassis_group_ref_chassis(\n                            input_data->sbrec_ha_chassis_grp_by_name,\n                            &lr_groups, ha_ref_chassis_map);\n    hmapx_destroy(&lr_groups);\n}\n\n/* Handle a fairly small set of changes in the southbound database. */\nstatic void\novnsb_db_run(struct northd_input *input_data,\n             struct ovsdb_idl_txn *ovnnb_txn,\n             struct ovsdb_idl_txn *ovnsb_txn,\n             struct hmap *ports)\n{\n    if (!ovnnb_txn ||\n        !ovsdb_idl_has_ever_connected(ovsdb_idl_txn_get_idl(ovnsb_txn))) {\n        return;\n    }\n\n    struct shash ha_ref_chassis_map = SHASH_INITIALIZER(&ha_ref_chassis_map);\n    handle_port_binding_changes(input_data,\n                                ovnsb_txn, ports, &ha_ref_chassis_map);\n    if (ovnsb_txn) {\n        update_sb_ha_group_ref_chassis(input_data,\n                                       &ha_ref_chassis_map);\n    }\n    shash_destroy(&ha_ref_chassis_map);\n}\n\nvoid northd_run(struct northd_input *input_data,\n                struct northd_data *data,\n                struct ovsdb_idl_txn *ovnnb_txn,\n                struct ovsdb_idl_txn *ovnsb_txn)\n{\n    stopwatch_start(OVNNB_DB_RUN_STOPWATCH_NAME, time_msec());\n    ovnnb_db_run(input_data, data, ovnnb_txn, ovnsb_txn,\n                 input_data->sbrec_chassis_by_name,\n                 input_data->sbrec_chassis_by_hostname);\n    stopwatch_stop(OVNNB_DB_RUN_STOPWATCH_NAME, time_msec());\n    stopwatch_start(OVNSB_DB_RUN_STOPWATCH_NAME, time_msec());\n    ovnsb_db_run(input_data, ovnnb_txn, ovnsb_txn, &data->ports);\n    stopwatch_stop(OVNSB_DB_RUN_STOPWATCH_NAME, time_msec());\n}\n\nconst char *\nnorthd_get_svc_monitor_mac(void)\n{\n    return svc_monitor_mac;\n}\n", "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<database name=\"ovn-nb\" title=\"OVN Northbound Database\">\n  <p>\n    This database is the interface between OVN and the cloud management system\n    (CMS), such as OpenStack, running above it.  The CMS produces almost all of\n    the contents of the database.  The <code>ovn-northd</code> program\n    monitors the database contents, transforms it, and stores it into the <ref\n    db=\"OVN_Southbound\"/> database.\n  </p>\n\n  <p>\n    We generally speak of ``the'' CMS, but one can imagine scenarios in\n    which multiple CMSes manage different parts of an OVN deployment.\n  </p>\n\n  <h2>External IDs</h2>\n\n  <p>\n    Each of the tables in this database contains a special column, named\n    <code>external_ids</code>.  This column has the same form and purpose each\n    place it appears.\n  </p>\n\n  <dl>\n    <dt><code>external_ids</code>: map of string-string pairs</dt>\n    <dd>\n      Key-value pairs for use by the CMS.  The CMS might use certain pairs, for\n      example, to identify entities in its own configuration that correspond to\n      those in this database.\n    </dd>\n  </dl>\n\n  <table name=\"NB_Global\" title=\"Northbound configuration\">\n    <p>\n      Northbound configuration for an OVN system.  This table must have exactly\n      one row.\n    </p>\n\n    <group title=\"Identity\">\n      <column name=\"name\">\n        The name of the OVN cluster, which uniquely identifies the OVN cluster\n        throughout all OVN clusters supposed to interconnect with each other.\n      </column>\n    </group>\n\n    <group title=\"Status\">\n      These columns allow a client to track the overall configuration state of\n      the system.\n\n      <column name=\"nb_cfg\">\n        Sequence number for client to increment.  When a client modifies any\n        part of the northbound database configuration and wishes to wait for\n        <code>ovn-northd</code> and possibly all of the hypervisors to finish\n        applying the changes, it may increment this sequence number.\n      </column>\n\n      <column name=\"nb_cfg_timestamp\">\n        <p>\n          The timestamp, in milliseconds since the epoch, when\n          <code>ovn-northd</code> sees the latest <code>nb_cfg</code> and starts\n          processing.\n        </p>\n\n        <p>\n          To print the timestamp as a human-readable date:\n        </p>\n\n        <pre>\n          date -d \"@$(ovn-nbctl get NB_Global . nb_cfg_timestamp | sed 's/...$//')\"\n        </pre>\n      </column>\n\n      <column name=\"sb_cfg\">\n        Sequence number that <code>ovn-northd</code> sets to the value of <ref\n        column=\"nb_cfg\"/> after it finishes applying the corresponding\n        configuration changes to the <ref db=\"OVN_Southbound\"/> database.\n      </column>\n\n      <column name=\"sb_cfg_timestamp\">\n        The timestamp, in milliseconds since the epoch, when\n        <code>ovn-northd</code> finishes applying the\n        corresponding configuration changes to the <ref db=\"OVN_Southbound\"/>\n        database successfully.\n      </column>\n\n      <column name=\"hv_cfg\">\n        <p>\n          Sequence number that <code>ovn-northd</code> sets to the smallest\n          sequence number of all the chassis in the system, as reported in the\n          <code>Chassis_Private</code> table in the southbound database.  Thus,\n          <ref column=\"hv_cfg\"/> equals <ref column=\"nb_cfg\"/> if all chassis\n          are caught up with the northbound configuration (which may never\n          happen, if any chassis is down).  This value can regress, if a\n          chassis was removed from the system and rejoins before catching up.\n        </p>\n\n        <p>\n          If there are no chassis, then <code>ovn-northd</code> copies\n          <code>nb_cfg</code> to <ref column=\"hv_cfg\"/>.  Thus, in this case,\n          the (nonexistent) hypervisors are always considered to be caught up.\n          This means that hypervisors can be \"caught up\" even in cases where\n          <ref column=\"sb_cfg\"/> would show that the southbound database is\n          not.  To detect when both the hypervisors and the southbound database\n          are caught up, a client should take the smaller of <ref\n          column=\"sb_cfg\"/> and <ref column=\"hv_cfg\"/>.\n        </p>\n      </column>\n\n      <column name=\"hv_cfg_timestamp\">\n        The largest timestamp, in milliseconds since the epoch, of the smallest\n        sequence number of all the\n        chassis in the system, as reported in the <code>Chassis_Private</code>\n        table in the southbound database.  In other words, this timestamp\n        reflects the time when the slowest chassis catches up with the\n        northbound configuration, which is useful for end-to-end control plane\n        latency measurement.\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n\n    <group title=\"Common options\">\n      <column name=\"options\">\n        This column provides general key/value settings. The supported\n        options are described individually below.\n      </column>\n\n      <group title=\"Options for configuring OVS BFD\">\n        <p>\n          These options apply when <code>ovn-controller</code> configures\n          OVS BFD on tunnels interfaces. Please note these parameters refer\n          to legacy OVS BFD implementation and not to OVN BFD one.\n        </p>\n\n        <column name=\"options\" key=\"bfd-min-rx\">\n          BFD option <code>min-rx</code> value to use when configuring BFD on\n          tunnel interfaces.\n        </column>\n\n        <column name=\"options\" key=\"bfd-decay-min-rx\">\n          BFD option <code>decay-min-rx</code> value to use when configuring\n          BFD on tunnel interfaces.\n        </column>\n\n        <column name=\"options\" key=\"bfd-min-tx\">\n          BFD option <code>min-tx</code> value to use when configuring BFD on\n          tunnel interfaces.\n        </column>\n\n        <column name=\"options\" key=\"bfd-mult\">\n          BFD option <code>mult</code> value to use when configuring BFD on\n          tunnel interfaces.\n        </column>\n      </group>\n\n      <column name=\"options\" key=\"mac_prefix\">\n        Configure a given OUI to be used as prefix when L2 address is\n        dynamically assigned, e.g. <code>00:11:22</code>\n      </column>\n\n      <column name=\"options\" key=\"mac_binding_removal_limit\"\n              type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 4294967295}'>\n        MAC binding aging bulk removal limit. This limits how many rows\n        can expire in a single transaction. Default value is 0 which\n        is unlimited. When we hit the limit next batch removal is delayed by\n        5 s.\n      </column>\n\n      <column name=\"options\" key=\"controller_event\" type='{\"type\": \"boolean\"}'>\n        Value set by the CMS to enable/disable ovn-controller event reporting.\n        Traffic into OVS can raise a 'controller' event that results in a\n        Controller_Event being written to the <ref table=\"Controller_Event\"/>\n        table in SBDB. When the CMS has seen the event and taken appropriate\n        action, it can remove the corresponding row in\n        <ref table=\"Controller_Event\"/> table.\n        The intention is for a CMS to see the events and take some sort of\n        action. Please see the <ref table=\"Controller_Event\"/> table in SBDB.\n        It is possible to associate a meter to each controller event type\n        in order to not overload the pinctrl thread under heavy load.\n        Each event type relies on a meter with a defined name:\n\n        <ul>\n          <li>empty_lb_backends: event-elb</li>\n        </ul>\n\n      </column>\n\n      <column name=\"options\" key=\"northd_probe_interval\">\n        <p>\n          The inactivity probe interval of the connection to the OVN Northbound\n          and Southbound databases from <code>ovn-northd</code>, in milliseconds.\n          If the value is zero, it disables the connection keepalive feature.\n        </p>\n\n        <p>\n          If the value is nonzero, then it will be forced to a value of\n          at least 1000 ms.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"northd_trim_timeout\">\n        <p>\n          When used, this configuration value specifies the time, in\n          milliseconds, since the last <code>ovn-northd</code> active operation\n          after which memory trimming is performed.  By default this is set to\n          30000 (30 seconds).\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"use_logical_dp_groups\">\n        <p>\n          Note: This option is deprecated, the only behavior is to always\n          combine logical flows by datapath groups.  Changing the value or\n          removing this option all toghether will have no effect.\n        </p>\n        <p>\n          <code>ovn-northd</code> combines logical flows that differs\n          only by logical datapath into a single logical flow with\n          logical datapath group attached.\n        </p>\n      </column>\n      <column name=\"options\" key=\"use_parallel_build\">\n        <p>\n          If set to <code>true</code>, <code>ovn-northd</code> will attempt\n          to compute logical flows in parallel.\n        </p>\n        <p>\n          Parallel computation is enabled only if the system has 4 or more\n          cores/threads available to be used by ovn-northd.\n        </p>\n        <p>\n          The default value is <code>false</code>.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"ignore_lsp_down\">\n        <p>\n          If set to false, ARP/ND reply flows for logical switch ports will be\n          installed only if the port is up, i.e. claimed by a Chassis. If set\n          to true, these flows are installed regardless of the status of the\n          port, which can result in a situation that ARP request to an IP is\n          resolved even before the relevant VM/container is running. For\n          environments where this is not an issue, setting it to\n          <code>true</code> can reduce the load and latency of the control\n          plane. The default value is <code>true</code>.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"use_ct_inv_match\">\n        <p>\n          If set to false, <code>ovn-northd</code> will not use the\n          <code>ct.inv</code> field in any of the logical flow matches.\n          The default value is true.  If the NIC supports offloading\n          OVS datapath flows but doesn't support offloading ct_state\n          <code>inv</code> flag, then the datapath flows matching on this flag\n          (either <code>+inv</code> or <code>-inv</code>) will not be\n          offloaded.  CMS should consider setting <code>use_ct_inv_match</code>\n          to <code>false</code> in such cases.  This results in a side effect\n          of the invalid packets getting delivered to the destination VIF,\n          which otherwise would have been dropped by <code>OVN</code>.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"default_acl_drop\">\n        <p>\n          If set to <code>true</code>., <code>ovn-northd</code> will\n          generate a logical flow to drop all traffic in the ACL stages.\n          By default this option is set to <code>false</code>.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"debug_drop_domain_id\">\n        <p>\n          If set to a 8-bit number and if\n          <code>debug_drop_collector_set</code> is also configured,\n          <code>ovn-northd</code> will add a <code>sample</code> action to\n          every logical flow that contains a 'drop' action.\n          The 8 most significant bits of the observation_domain_id field will\n          be those specified in the\n          <code> debug_drop_domain_id</code>.\n          The 24 least significant bits of the observation_domain_id field will\n          be the datapath's key.\n        </p>\n        <p>\n          The observation_point_id will be set to the first 32 bits of the\n          logical flow's UUID.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"debug_drop_collector_set\">\n        <p>\n          If set to a 32-bit number <code>ovn-northd</code> will add a\n          <code>sample</code> action to every logical flow that contains a\n          'drop' action. The sample action will have the specified\n          collector_set_id. The value must match that of the local OVS\n          configuration as described in <code>ovs-actions</code>(7).\n        </p>\n      </column>\n\n      <group title=\"Options for configuring interconnection route advertisement\">\n        <p>\n          These options control how routes are advertised between OVN\n          deployments for interconnection.  If enabled, <code>ovn-ic</code>\n          from different OVN deployments exchanges routes between each other\n          through the global <ref db=\"OVN_IC_Southbound\"/> database.  Only\n          routers with ports connected to interconnection transit switches\n          participate in route advertisement.  For each of these routers, there\n          are two types of routes to be advertised:\n        </p>\n\n        <p>\n          Firstly, the static routes configured in the router are advertised.\n        </p>\n\n        <p>\n          Secondly, the <code>networks</code> configured in the logical router\n          ports that are not on the transit switches are advertised.  These\n          are considered as directly connected subnets on the router.\n        </p>\n\n        <p>\n          Link local prefixes (IPv4 169.254.0.0/16 and IPv6 FE80::/10)\n          are never advertised.\n        </p>\n\n        <p>\n          The learned routes are added to the\n          <ref column=\"static_routes\" table=\"Logical_Router\"/> column of the\n          <ref table=\"Logical_Router\"/> table, with\n          <code>external_ids:ic-learned-route</code> set to the uuid\n          of the row in <ref table=\"Route\" db=\"OVN_IC_Southbound\"/>\n          table of the <ref db=\"OVN_IC_Southbound\"/> database.\n        </p>\n\n        <column name=\"options\" key=\"ic-route-adv\">\n          A boolean value that enables route advertisement to the global\n          <ref db=\"OVN_IC_Southbound\"/> database.  Default is\n          <code>false</code>.\n        </column>\n\n        <column name=\"options\" key=\"ic-route-learn\">\n          A boolean value that enables route learning from the global\n          <ref db=\"OVN_IC_Southbound\"/> database.  Default is\n          <code>false</code>.\n        </column>\n\n        <column name=\"options\" key=\"ic-route-adv-default\">\n          A boolean value that enables advertising default route to the global\n          <ref db=\"OVN_IC_Southbound\"/> database.  Default is\n          <code>false</code>.  This option takes effect only when option\n          <code>ic-route-adv</code> is <code>true</code>.\n        </column>\n\n        <column name=\"options\" key=\"ic-route-learn-default\">\n          A boolean value that enables learning default route from the global\n          <ref db=\"OVN_IC_Southbound\"/> database.  Default is\n          <code>false</code>.  This option takes effect only when option\n          <code>ic-route-learn</code> is <code>true</code>.\n        </column>\n\n        <column name=\"options\" key=\"ic-route-blacklist\">\n          A string value contains a list of CIDRs delimited by \",\".  A route\n          will not be advertised or learned if the route's prefix belongs to\n          any of the CIDRs listed.\n        </column>\n      </group>\n\n    </group>\n\n    <group title=\"Connection Options\">\n      <column name=\"connections\">\n        Database clients to which the Open vSwitch database server should\n        connect or on which it should listen, along with options for how these\n        connections should be configured.  See the <ref table=\"Connection\"/>\n        table for more information.\n      </column>\n      <column name=\"ssl\">\n        Global SSL configuration.\n      </column>\n    </group>\n    <group title=\"Security Configurations\">\n      <column name=\"ipsec\">\n        Tunnel encryption configuration. If this column is set to be true, all\n        OVN tunnels will be encrypted with IPsec.\n      </column>\n    </group>\n\n    <group title=\"Read-only Options\">\n      <column name=\"options\" key=\"max_tunid\">\n        <p>\n          The maximum supported tunnel ID. Depends on types of encapsulation\n          enabled in the cluster.\n        </p>\n      </column>\n    </group>\n\n  </table>\n\n  <table name=\"Copp\" title=\"Control plane protection\">\n    <p>\n      This table is used to define control plane protection policies, i.e.,\n      associate entries from table <ref table=\"Meter\"/> to control protocol\n      names.\n    </p>\n    <column name=\"name\">\n      CoPP name.\n    </column>\n    <column name=\"meters\" key=\"arp\">\n      Rate limiting meter for ARP packets (request/reply) used for learning\n      neighbors.\n    </column>\n    <column name=\"meters\" key=\"arp-resolve\">\n      Rate limiting meter for packets that require resolving the next-hop\n      (through ARP).\n    </column>\n    <column name=\"meters\" key=\"dhcpv4-opts\">\n      Rate limiting meter for packets that require adding DHCPv4 options.\n    </column>\n    <column name=\"meters\" key=\"dhcpv6-opts\">\n      Rate limiting meter for packets that require adding DHCPv6 options.\n    </column>\n    <column name=\"meters\" key=\"dns\">\n      Rate limiting meter for DNS query packets that need to be replied to.\n    </column>\n    <column name=\"meters\" key=\"event-elb\">\n      Rate limiting meter for empty load balancer events.\n    </column>\n    <column name=\"meters\" key=\"icmp4-error\">\n      Rate limiting meter for packets that require replying with an ICMP\n      error.\n    </column>\n    <column name=\"meters\" key=\"icmp6-error\">\n      Rate limiting meter for packets that require replying with an ICMPv6\n      error.\n    </column>\n    <column name=\"meters\" key=\"igmp\">\n      Rate limiting meter for IGMP packets.\n    </column>\n    <column name=\"meters\" key=\"nd-na\">\n      Rate limiting meter for ND neighbor advertisement packets used for\n      learning neighbors.\n    </column>\n    <column name=\"meters\" key=\"nd-ns\">\n      Rate limiting meter for ND neighbor solicitation packets used for\n      learning neighbors.\n    </column>\n    <column name=\"meters\" key=\"nd-ns-resolve\">\n      Rate limiting meter for packets that require resolving the next-hop\n      (through ND).\n    </column>\n    <column name=\"meters\" key=\"nd-ra-opts\">\n      Rate limiting meter for packets that require adding ND router\n      advertisement options.\n    </column>\n    <column name=\"meters\" key=\"tcp-reset\">\n      Rate limiting meter for packets that require replying with TCP RST\n      packet.\n    </column>\n    <column name=\"meters\" key=\"bfd\">\n      Rate limiting meter for BFD packets.\n    </column>\n    <column name=\"meters\" key=\"reject\">\n      Rate limiting meter for packets that trigger a reject action\n    </column>\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n\n  <table name=\"Logical_Switch\" title=\"L2 logical switch\">\n    <p>\n      Each row represents one L2 logical switch.\n    </p>\n\n    <p>\n      There are two kinds of logical switches, that is, ones that fully\n      virtualize the network (overlay logical switches) and ones that provide\n      simple connectivity to physical networks (bridged logical switches).\n      They work in the same way when providing connectivity between logical\n      ports on same chassis, but differently when connecting remote logical\n      ports.  Overlay logical switches connect remote logical ports by tunnels,\n      while bridged logical switches provide connectivity to remote ports by\n      bridging the packets to directly connected physical L2 segments with the\n      help of <code>localnet</code> ports.  Each bridged logical switch has\n      one or more <code>localnet</code> ports, which have only one special\n      address <code>unknown</code>.\n    </p>\n\n    <column name=\"ports\">\n      <p>\n        The logical ports connected to the logical switch.\n      </p>\n\n      <p>\n        It is an error for multiple logical switches to include the same\n        logical port.\n      </p>\n    </column>\n\n    <column name=\"load_balancer\">\n      Set of load balancers associated to this logical switch.\n    </column>\n\n    <column name=\"load_balancer_group\">\n      Set of load balancers groups associated to this logical switch.\n    </column>\n\n    <column name=\"acls\">\n      Access control rules that apply to packets within the logical switch.\n    </column>\n\n    <column name=\"qos_rules\">\n      QoS marking and metering rules that apply to packets within the\n      logical switch.\n    </column>\n\n    <column name=\"dns_records\">\n      This column defines the DNS records to be used for resolving internal\n      DNS queries within the logical switch by the native DNS resolver.\n      Please see the <ref table=\"DNS\"/> table.\n    </column>\n\n    <column name=\"forwarding_groups\">\n      Groups a set of logical port endpoints for traffic going out of the\n      logical switch.\n    </column>\n\n    <group title=\"Naming\">\n      <p>\n        These columns provide names for the logical switch.  From OVN's\n        perspective, these names have no special meaning or purpose other than\n        to provide convenience for human interaction with the  database.\n        There is no requirement for the name to be unique.  (For a unique\n        identifier for a logical switch, use its row UUID.)\n      </p>\n\n      <p>\n        (Originally, <ref column=\"name\"/> was intended to serve the purpose of\n        a human-friendly name, but the Neutron integration used it to uniquely\n        identify its own switch object, in the format\n        <code>neutron-<var>uuid</var></code>.  Later on, Neutron started\n        propagating the friendly name of a switch as <ref column=\"external_ids\"\n        key=\"neutron:network_name\"/>.  Perhaps this can be cleaned up someday.)\n      </p>\n\n      <column name=\"name\">\n        A name for the logical switch.\n      </column>\n\n      <column name=\"external_ids\" key=\"neutron:network_name\">\n        Another name for the logical switch.\n      </column>\n    </group>\n\n    <group title=\"IP Address Assignment\">\n      <p>\n        These options control automatic IP address management (IPAM) for ports\n        attached to the logical switch.  To enable IPAM for IPv4, set <ref\n        column=\"other_config\" key=\"subnet\"/> and optionally <ref\n        column=\"other_config:exclude_ips\"/>.  To enable IPAM for IPv6, set\n        <ref column=\"other_config\" key=\"ipv6_prefix\"/>.  IPv4 and IPv6 may\n        be enabled together or separately.\n      </p>\n\n      <p>\n        To request dynamic address assignment for a particular port, use the\n        <code>dynamic</code> keyword in the <ref table=\"Logical_Switch_Port\"\n        column=\"addresses\"/> column of the port's <ref\n        table=\"Logical_Switch_Port\"/> row.  This requests both an IPv4 and an\n        IPv6 address, if IPAM for IPv4 and IPv6 are both enabled.\n      </p>\n\n      <column name=\"other_config\" key=\"subnet\">\n        Set this to an IPv4 subnet, e.g. <code>192.168.0.0/24</code>, to enable\n        <code>ovn-northd</code> to automatically assign IP addresses within\n        that subnet.\n      </column>\n\n      <column name=\"other_config\" key=\"exclude_ips\">\n        <p>\n          To exclude some addresses from automatic IP address management, set\n          this to a list of the IPv4 addresses or <code>..</code>-delimited\n          ranges to exclude.  The addresses or ranges should be a subset of\n          those in <ref column=\"other_config\" key=\"subnet\"/>.\n        </p>\n        <p>\n          Whether listed or not, <code>ovn-northd</code> will never allocate\n          the first or last address in a subnet, such as 192.168.0.0 or\n          192.168.0.255 in 192.168.0.0/24.\n        </p>\n        <p>\n          Examples:\n        </p>\n        <ul>\n          <li><code>192.168.0.2 192.168.0.10</code></li>\n          <li><code>192.168.0.4 192.168.0.30..192.168.0.60 192.168.0.110..192.168.0.120</code></li>\n          <li><code>192.168.0.110..192.168.0.120 192.168.0.25..192.168.0.30 192.168.0.144</code></li>\n        </ul>\n      </column>\n\n      <column name=\"other_config\" key=\"ipv6_prefix\">\n        Set this to an IPv6 prefix to enable <code>ovn-northd</code> to\n        automatically assign IPv6 addresses using this prefix.  The assigned\n        IPv6 address will be generated using the IPv6 prefix and the MAC\n        address (converted to an IEEE EUI64 identifier) of the port.  The IPv6\n        prefix defined here should be a valid IPv6 address ending with\n        <code>::</code>.\n        <p>\n          Examples:\n        </p>\n        <ul>\n          <li><code>aef0::</code></li>\n          <li><code>bef0:1234:a890:5678::</code></li>\n          <li><code>8230:5678::</code></li>\n        </ul>\n      </column>\n\n      <column name=\"other_config\" key=\"mac_only\" type='{\"type\": \"boolean\"}'>\n        Value used to request to assign L2 address only if neither subnet\n        nor ipv6_prefix are specified\n      </column>\n    </group>\n\n    <group title=\"IP Multicast Snooping Options\">\n      <p>\n        These options control IP Multicast Snooping configuration of the\n        logical switch. To enable IP Multicast Snooping set\n        <ref column=\"other_config\" key=\"mcast_snoop\"/> to true. To enable IP\n        Multicast Querier set <ref column=\"other_config\" key=\"mcast_querier\"/>\n        to true. If IP Multicast Querier is enabled\n        <ref column=\"other_config\" key=\"mcast_eth_src\"/> and\n        <ref column=\"other_config\" key=\"mcast_ip4_src\"/> must be set.\n      </p>\n      <column name=\"other_config\" key=\"mcast_snoop\"\n          type='{\"type\": \"boolean\"}'>\n        Enables/disables IP Multicast Snooping on the logical switch.\n        Default: <code>false</code>.\n      </column>\n      <column name=\"other_config\" key=\"mcast_querier\"\n          type='{\"type\": \"boolean\"}'>\n        Enables/disables IP Multicast Querier on the logical switch.\n        Only applicable if <ref column=\"other_config\" key=\"mcast_snoop\"/>\n        is enabled.\n        Default: <code>true</code>.\n      </column>\n      <column name=\"other_config\" key=\"mcast_flood_unregistered\"\n          type='{\"type\": \"boolean\"}'>\n        Determines whether unregistered multicast traffic should be flooded\n        or not. Only applicable if\n        <ref column=\"other_config\" key=\"mcast_snoop\"/> is enabled.\n        Default: <code>false</code>.\n      </column>\n      <column name=\"other_config\" key=\"mcast_table_size\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 32766}'>\n        Number of multicast groups to be stored. Default: 2048.\n      </column>\n      <column name=\"other_config\" key=\"mcast_idle_timeout\"\n          type='{\"type\": \"integer\", \"minInteger\": 15, \"maxInteger\": 3600}'>\n        Configures the IP Multicast Snooping group idle timeout (in seconds).\n        Default: 300 seconds.\n      </column>\n      <column name=\"other_config\" key=\"mcast_query_interval\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 3600}'>\n        Configures the IP Multicast Querier interval between queries (in\n        seconds). Default:\n        <ref column=\"other_config\" key=\"mcast_idle_timeout\"/> / 2.\n      </column>\n      <column name=\"other_config\" key=\"mcast_query_max_response\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 10}'>\n        Configures the value of the \"max-response\" field in the multicast\n        queries originated by the logical switch. Default: 1 second.\n      </column>\n      <column name=\"other_config\" key=\"mcast_eth_src\">\n        Configures the source Ethernet address for queries originated by the\n        logical switch.\n      </column>\n      <column name=\"other_config\" key=\"mcast_ip4_src\">\n        Configures the source IPv4 address for queries originated by the\n        logical switch.\n      </column>\n      <column name=\"other_config\" key=\"mcast_ip6_src\">\n        Configures the source IPv6 address for queries originated by the\n        logical switch.\n      </column>\n    </group>\n\n    <group title=\"Interconnection\">\n      <column name=\"other_config\" key=\"interconn-ts\"\n          type='{\"type\": \"string\"}'>\n        The <ref table=\"Transit_Switch\" column=\"name\" db=\"OVN_IC_Northbound\"/>\n        of corresponding transit switch in <ref db=\"OVN_IC_Northbound\"/>\n        database.  This kind of logical switch is created and controlled\n        by <code>ovn-ic</code>.\n      </column>\n    </group>\n\n    <group title=\"Tunnel Key\">\n      <column name=\"other_config\" key=\"requested-tnl-key\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 16777215}'>\n        Configures the datapath tunnel key for the logical switch.  Usually\n        this is not needed because <code>ovn-northd</code> will assign an\n        unique key for each datapath by itself.  However, if it is configured,\n        <code>ovn-northd</code> honors the configured value.  The typical use\n        case is for interconnection: the tunnel keys for transit switches need\n        to be unique globally, so they are maintained in the global\n        <ref db=\"OVN_IC_Southbound\"/> database, and <code>ovn-ic</code> simply\n        syncs the value from <ref db=\"OVN_IC_Southbound\"/> through this config.\n      </column>\n    </group>\n\n    <column name=\"copp\">\n      <p>\n        The control plane protection policy from table <ref table=\"Copp\"/>\n        used for metering packets sent to <code>ovn-controller</code> from\n        ports of this logical switch.\n      </p>\n    </column>\n\n    <group title=\"Other options\">\n      <column name=\"other_config\" key=\"vlan-passthru\"\n          type='{\"type\": \"boolean\"}'>\n        Determines whether VLAN tagged incoming traffic should be allowed. Note\n        that this may have security implications when enabled for a logical\n        switch with a tag=0 localnet port. If not properly isolated from other\n        localnet ports, fabric traffic that belongs to other tagged networks may\n        be passed through such a port.\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Logical_Switch_Port\" title=\"L2 logical switch port\">\n    <p>\n      A port within an L2 logical switch.\n    </p>\n\n    <group title=\"Core Features\">\n      <column name=\"name\">\n        <p>\n          The logical port name.\n        </p>\n\n        <p>\n          For entities (VMs or containers) that are spawned in the hypervisor,\n          the name used here must match those used in the <ref key=\"iface-id\"\n          table=\"Interface\" column=\"external_ids\" db=\"Open_vSwitch\"/> in the\n          <ref db=\"Open_vSwitch\"/> database's <ref table=\"Interface\"\n          db=\"Open_vSwitch\"/> table, because hypervisors use <ref key=\"iface-id\"\n          table=\"Interface\" column=\"external_ids\" db=\"Open_vSwitch\"/> as a lookup\n          key to identify the network interface of that entity.\n        </p>\n\n        <p>\n          For containers that share a VIF within a VM, the name can be any\n          unique identifier.  See <code>Containers</code>, below, for more\n          information.\n        </p>\n\n        <p>\n          A logical switch port may not have the same name as a logical router\n          port, but the database schema cannot enforce this.\n        </p>\n      </column>\n\n      <column name=\"type\">\n        <p>\n          Specify a type for this logical port.  Logical ports can be used to\n          model other types of connectivity into an OVN logical switch.  The\n          following types are defined:\n        </p>\n\n        <dl>\n          <dt>(empty string)</dt>\n          <dd>\n            A VM (or VIF) interface.\n          </dd>\n\n          <dt><code>router</code></dt>\n          <dd>\n            A connection to a logical router.  The value of <ref\n            column=\"options\" key=\"router-port\"/> specifies the <ref\n            column=\"name\"/> of the <ref table=\"Logical_Router_Port\"/>\n            to which this logical switch port is connected.\n          </dd>\n\n          <dt><code>localnet</code></dt>\n          <dd>\n            A connection to a locally accessible network from\n            <code>ovn-controller</code> instances that have a corresponding\n            bridge mapping.  A logical switch can have multiple\n            <code>localnet</code> ports attached.  This type is used to model\n            direct connectivity to existing networks.  In this case, each\n            chassis should have a mapping for one of the physical networks\n            only.  Note: nothing said above implies that a chassis cannot be\n            plugged to multiple physical networks as long as they belong to\n            different switches.\n          </dd>\n\n          <dt><code>localport</code></dt>\n          <dd>\n            A connection to a local VIF. Traffic that arrives on a\n            <code>localport</code> is never forwarded over a tunnel to another\n            chassis. These ports are present on every chassis and have the same\n            address in all of them. This is used to model connectivity to local\n            services that run on every hypervisor.\n          </dd>\n\n          <dt><code>l2gateway</code></dt>\n          <dd>\n            A connection to a physical network.\n          </dd>\n\n          <dt><code>vtep</code></dt>\n          <dd>\n            A port to a logical switch on a VTEP gateway.\n          </dd>\n\n          <dt><code>external</code></dt>\n          <dd>\n            <p>\n              Represents a logical port which is external and not having\n              an OVS port in the integration bridge.\n              <code>OVN</code> will never receive any traffic from this port or\n              send any traffic to this port. <code>OVN</code> can support\n              native services like DHCPv4/DHCPv6/DNS for this port.\n              If <ref column=\"ha_chassis_group\"/> is defined,\n              <code>ovn-controller</code> running in the master chassis of\n              the HA chassis group will bind this port to provide these native\n              services. It is expected that this port belong to a bridged\n              logical switch (with a <code>localnet</code> port).\n            </p>\n\n            <p>\n              It is recommended to use the same HA chassis group for all the\n              external ports of a logical switch. Otherwise, the physical\n              switch might see MAC flap issue when different chassis provide\n              the native services. For example when supporting native DHCPv4\n              service, DHCPv4 server mac (configured in\n              <ref column=\"options:server_mac\" table=\"DHCP_Options\"\n              db=\"OVN_NB\"/> column in table <ref table=\"DHCP_Options\"/>)\n              originating from different ports can cause MAC flap issue.\n              The MAC of the logical router IP(s) can also flap if the\n              same HA chassis group is not set for all the external ports\n              of a logical switch.\n            </p>\n\n            <p>\n              Below are some of the use cases where <code>external</code>\n              ports can be used.\n            </p>\n\n            <ul>\n              <li>\n                VMs connected to SR-IOV nics - Traffic from these VMs by passes\n                the kernel stack and local <code>ovn-controller</code> do not\n                bind these ports and cannot serve the native services.\n              </li>\n\n              <li>\n                When CMS supports provisioning baremetal servers.\n              </li>\n            </ul>\n          </dd>\n\n          <dt><code>virtual</code></dt>\n          <dd>\n            <p>\n              Represents a logical port which does not have an OVS\n              port in the integration bridge and has a virtual ip configured\n              in the <ref column=\"options:virtual-ip\"/> column. This virtual ip\n              can move around between the logical ports configured in\n              the <ref column=\"options:virtual-parents\"/> column.\n            </p>\n\n            <p>\n              One of the use case where <code>virtual</code>\n              ports can be used is.\n            </p>\n\n            <ul>\n              <li>\n                The <code>virtual ip</code> represents a load balancer vip\n                and the <code>virtual parents</code> provide load balancer\n                service in an active-standby setup with the active virtual\n                parent owning the <code>virtual ip</code>.\n              </li>\n            </ul>\n          </dd>\n\n          <dt><code>remote</code></dt>\n          <dd>\n            A remote port is to model a port that resides remotely on another\n            OVN, which is on the other side of a transit logical switch for OVN\n            interconnection.  This type of ports are created by\n            <code>ovn-ic</code> instead of by CMS.  Any change to the port will\n            be automatically overwritten by <code>ovn-ic</code>.\n          </dd>\n        </dl>\n      </column>\n    </group>\n\n    <group title=\"Options\">\n      <column name=\"options\">\n        This column provides key/value settings specific to the logical port\n        <ref column=\"type\"/>.  The type-specific options are described\n        individually below.\n      </column>\n\n      <group title=\"Options for router ports\">\n        <p>\n          These options apply when <ref column=\"type\"/> is <code>router</code>.\n        </p>\n\n        <column name=\"options\" key=\"router-port\">\n          Required.  The <ref column=\"name\"/> of the <ref\n          table=\"Logical_Router_Port\"/> to which this logical switch port is\n          connected.\n        </column>\n\n        <column name=\"options\" key=\"nat-addresses\">\n          <p>\n            This is used to send gratuitous ARPs for SNAT and DNAT IP\n            addresses via the <code>localnet</code> port that is attached\n            to the same logical switch as this type <code>router</code>\n            port.  This option is specified on a logical switch port that is\n            connected to a gateway router, or a logical switch port that is\n            connected to a distributed gateway port on a logical router.\n          </p>\n\n          <p>\n            This must take one of the following forms:\n          </p>\n\n          <dl>\n            <dt><code>router</code></dt>\n            <dd>\n              <p>\n                Gratuitous ARPs will be sent for all SNAT and DNAT external IP\n                addresses and for all load balancer IP addresses defined on the\n                <ref column=\"options\" key=\"router-port\"/>'s logical router,\n                using the <ref column=\"options\" key=\"router-port\"/>'s MAC\n                address.\n              </p>\n\n              <p>\n                This form of <ref column=\"options\" key=\"nat-addresses\"/> is\n                valid for logical switch ports where <ref column=\"options\"\n                key=\"router-port\"/> is the name of a port on a gateway router,\n                or the name of a distributed gateway port.\n              </p>\n\n              <p>\n                Supported only in OVN 2.8 and later.  Earlier versions required\n                NAT addresses to be manually synchronized.\n              </p>\n            </dd>\n\n            <dt><code>Ethernet address followed by one or more IPv4 addresses</code></dt>\n            <dd>\n              <p>\n                Example: <code>80:fa:5b:06:72:b7 158.36.44.22\n                158.36.44.24</code>. This would result in generation of\n                gratuitous ARPs for IP addresses 158.36.44.22 and 158.36.44.24\n                with a MAC address of 80:fa:5b:06:72:b7.\n              </p>\n\n              <p>\n                This form of <ref column=\"options\" key=\"nat-addresses\"/> is\n                only valid for logical switch ports where <ref column=\"options\"\n                key=\"router-port\"/> is the name of a port on a gateway router.\n              </p>\n            </dd>\n          </dl>\n        </column>\n\n        <column name=\"options\" key=\"exclude-lb-vips-from-garp\">\n          If <ref column=\"options\" key=\"nat-addresses\"/> is set to\n          <code>router</code>, Gratuitous ARPs will be sent for all\n          SNAT and DNAT external IP addresses defined on the\n          <ref column=\"options\" key=\"router-port\"/>'s logical router,\n          using the <ref column=\"options\" key=\"router-port\"/>'s MAC address,\n          not cosidering configured load balancers.\n        </column>\n\n        <column name=\"options\" key=\"arp_proxy\">\n          Optional. A list of IPv4 addresses that this\n          logical switch <code>router</code> port will reply to ARP requests.\n          Example: <code>169.254.239.254 169.254.239.2</code>. The\n          <ref column=\"options\" key=\"router-port\"/>'s logical router should\n          have a route to forward packets sent to configured proxy ARP IPs to\n          an appropriate destination.\n        </column>\n      </group>\n\n      <group title=\"Options for localnet ports\">\n        <p>\n          These options apply when <ref column=\"type\"/> is\n          <code>localnet</code>.\n        </p>\n\n        <column name=\"options\" key=\"network_name\">\n          Required.  The name of the network to which the <code>localnet</code>\n          port is connected.  Each hypervisor, via <code>ovn-controller</code>,\n          uses its local configuration to determine exactly how to connect to\n          this locally accessible network, if at all.\n        </column>\n\n        <column name=\"options\" key=\"ethtype\">\n          Optional. VLAN EtherType field value for encapsulating VLAN\n          headers. Supported values: 802.11q (default), 802.11ad.\n        </column>\n\n        <column name=\"options\" key=\"localnet_learn_fdb\"\n                type='{\"type\": \"boolean\"}'>\n          Optional. Allows localnet port to learn MACs and store them in FDB\n          table if set to <code>true</code>. The default value is\n          <code>false</code>.\n        </column>\n\n      </group>\n\n      <group title=\"Options for l2gateway ports\">\n        <p>\n          These options apply when <ref column=\"type\"/> is\n          <code>l2gateway</code>.\n        </p>\n\n        <column name=\"options\" key=\"network_name\">\n          Required.  The name of the network to which the <code>l2gateway</code>\n          port is connected.  The L2 gateway, via <code>ovn-controller</code>,\n          uses its local configuration to determine exactly how to connect to\n          this network.\n        </column>\n\n        <column name=\"options\" key=\"l2gateway-chassis\">\n          Required. The chassis on which the <code>l2gateway</code> logical\n          port should be bound to. <code>ovn-controller</code> running on the\n          defined chassis will connect this logical port to the physical network.\n        </column>\n\n      </group>\n\n      <group title=\"Options for vtep ports\">\n        <p>\n          These options apply when <ref column=\"type\"/> is <code>vtep</code>.\n        </p>\n\n        <column name=\"options\" key=\"vtep-physical-switch\">\n          Required.  The name of the VTEP gateway.\n        </column>\n\n        <column name=\"options\" key=\"vtep-logical-switch\">\n          Required.  A logical switch name connected by the VTEP gateway.\n        </column>\n      </group>\n\n      <group title=\"VMI (or VIF) Options\">\n        <p>\n          These options apply to logical ports with <ref column=\"type\"/> having\n          (empty string)\n        </p>\n\n        <column name=\"options\" key=\"requested-chassis\">\n          <p>\n            If set, identifies a specific chassis (by name or hostname) that\n            is allowed to bind this port. Using this option will prevent\n            thrashing between two chassis trying to bind the same port during\n            a live migration. It can also prevent similar thrashing due to a\n            mis-configuration, if a port is accidentally created on more than\n            one chassis.\n          </p>\n\n          <p>\n            If set to a comma separated list, the first entry identifies the\n            main chassis and the rest are one or more additional chassis that\n            are allowed to bind the same port.\n          </p>\n\n          <p>\n            When multiple chassis are set for the port, and the logical switch\n            is connected to an external network through a <code>localnet</code>\n            port, tunneling is enforced for the port to guarantee delivery of\n            packets directed to the port to all its locations. This has MTU\n            implications because the network used for tunneling must have MTU\n            larger than <code>localnet</code> for stable connectivity.\n          </p>\n\n          <p>\n            If the same host co-hosts more than one controller instance\n            (either belonging to the same or separate clusters), special\n            attention should be given to consistently using unique chassis\n            names used in this option. It is advised that chassis names -\n            and not host names - are used for this option.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"activation-strategy\">\n          If used with multiple chassis set in\n          <ref column=\"requested-chassis\"/>, specifies an activation strategy\n          for all additional chassis. By default, no activation strategy is\n          used, meaning additional port locations are immediately available for\n          use. When set to \"rarp\", the port is blocked for ingress and egress\n          communication until a RARP packet is sent from a new location. The\n          \"rarp\" strategy is useful in live migration scenarios for virtual\n          machines.\n        </column>\n\n        <column name=\"options\" key=\"iface-id-ver\">\n          If set, this port will be bound by <code>ovn-controller</code>\n          only if this same key and value is configured in the\n          <ref table=\"Interface\" column=\"external_ids\" db=\"Open_vSwitch\"/>\n          column in the Open_vSwitch database's\n          <ref table=\"Interface\" db=\"Open_vSwitch\"/> table.\n        </column>\n\n        <column name=\"options\" key=\"qos_min_rate\">\n          If set, indicates the minimum guaranteed rate available for data sent\n          from this interface, in bit/s.\n        </column>\n\n        <column name=\"options\" key=\"qos_max_rate\">\n          If set, indicates the maximum rate for data sent from this interface,\n          in bit/s. The traffic will be shaped according to this limit.\n        </column>\n\n        <column name=\"options\" key=\"qos_burst\">\n          If set, indicates the maximum burst size for data sent from this\n          interface, in bits.\n        </column>\n\n        <column name=\"options\" key=\"hostname\">\n          <p>\n            If set, indicates the DHCPv4 option \"Hostname\" (option code 12)\n            associated for this Logical Switch Port. If DHCPv4 is enabled for\n            this Logical Switch Port, hostname dhcp option will be included in\n            DHCP reply.\n          </p>\n        </column>\n\n        <group title=\"VIF Plugging Options\">\n          <column name=\"options\" key=\"vif-plug-type\">\n            If set, OVN will attempt to perform plugging of this VIF.  In order\n            to get this port plugged by the OVN controller, OVN must be built\n            with support for VIF plugging.  The default behavior is for the CMS\n            to do the VIF plugging.  Each VIF plug provider have their own\n            options namespaced by name, for example \"vif-plug:representor:key\".\n\n            Please refer to the VIF plug provider documentation located in\n            Documentation/topics/vif-plug-providers/ for more information.\n          </column>\n\n          <column name=\"options\" key=\"vif-plug-mtu-request\">\n            Requested MTU for plugged interfaces.  When set the OVN controller\n            will fill the <ref table=\"Interface\" column=\"mtu_request\"/> column\n            of the Open vSwitch database's\n            <ref table=\"Interface\" db=\"vswitch\"/> table.  This in turn will\n            make OVS vswitchd update the MTU of the linked interface.\n          </column>\n        </group>\n      </group>\n\n      <group title=\"Virtual port Options\">\n        <p>\n          These options apply when <ref column=\"type\"/> is\n          <code>virtual</code>.\n        </p>\n\n        <column name=\"options\" key=\"virtual-ip\">\n          This option represents the virtual IPv4 address.\n        </column>\n\n        <column name=\"options\" key=\"virtual-parents\">\n          This options represents a set of logical port names (with in the same\n          logical switch) which can own the <code>virtual ip</code> configured\n          in the <ref column=\"options:virtual-ip\"/>. All these virtual parents\n          should add the <code>virtual ip</code> in the\n          <ref column=\"port_security\"/> if port security addressed are enabled.\n        </column>\n      </group>\n\n      <group title=\"IP Multicast Snooping Options\">\n        <p>\n          These options apply when the port is part of a logical switch\n          which has <ref table=\"Logical_Switch\" column=\"other_config\"/>\n          :mcast_snoop set to <code>true</code>.\n        </p>\n\n        <column name=\"options\" key=\"mcast_flood\"\n                type='{\"type\": \"boolean\"}'>\n          If set to <code>true</code>, multicast packets (except reports) are\n          unconditionally forwarded to the specific port.\n          Default: <code>false</code>.\n        </column>\n\n        <column name=\"options\" key=\"mcast_flood_reports\"\n                type='{\"type\": \"boolean\"}'>\n          If set to <code>true</code>, multicast reports are unconditionally\n          forwarded to the specific port.  Default: <code>false</code>.\n        </column>\n      </group>\n\n    </group>\n\n    <group title=\"Containers\">\n      <p>\n        When a large number of containers are nested within a VM, it may be too\n        expensive to dedicate a VIF to each container.  OVN can use VLAN tags\n        to support such cases.  Each container is assigned a VLAN ID and each\n        packet that passes between the hypervisor and the VM is tagged with the\n        appropriate ID for the container.  Such VLAN IDs never appear on a\n        physical wire, even inside a tunnel, so they need not be unique except\n        relative to a single VM on a hypervisor.\n      </p>\n\n      <p>\n        These columns are used for VIFs that represent nested containers using\n        shared VIFs.  For VMs and for containers that have dedicated VIFs, they\n        are empty.\n      </p>\n\n      <column name=\"parent_name\">\n        The VM interface through which the nested container sends its network\n        traffic.  This must match the <ref column=\"name\"/> column for some\n        other <ref table=\"Logical_Switch_Port\"/>.\n      </column>\n\n      <column name=\"tag_request\">\n        <p>\n          The VLAN tag in the network traffic associated with a container's\n          network interface.  The client can request <code>ovn-northd</code>\n          to allocate a tag that is unique within the scope of a specific\n          parent (specified in <ref column=\"parent_name\"/>) by setting a value\n          of <code>0</code> in this column.  The allocated value is written\n          by <code>ovn-northd</code> in the <ref column=\"tag\"/> column.\n          (Note that these tags are allocated and managed locally in\n          <code>ovn-northd</code>, so they cannot be reconstructed in the event\n          that the database is lost.)  The client can also request a specific\n          non-zero tag and <code>ovn-northd</code> will honor it and copy that\n          value to the <ref column=\"tag\"/> column.\n        </p>\n\n        <p>\n          When <ref column=\"type\"/> is set to <code>localnet</code> or\n          <code>l2gateway</code>, this can\n          be set to indicate that the port represents a connection to a\n          specific VLAN on a locally accessible network. The VLAN ID is used\n          to match incoming traffic and is also added to outgoing traffic.\n        </p>\n      </column>\n\n      <column name=\"tag\">\n        <p>\n          The VLAN tag allocated by <code>ovn-northd</code> based on the\n          contents of the <ref column=\"tag_request\"/> column.\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Port State\">\n      <column name=\"up\">\n        <p>\n          This column is populated by <code>ovn-northd</code>, rather\n          than by the CMS plugin as is most of this database.  When a\n          logical port is bound to a physical location in the OVN\n          Southbound database <ref db=\"OVN_Southbound\"\n          table=\"Binding\"/> table, <code>ovn-northd</code> sets this\n          column to <code>true</code>; otherwise, or if the port\n          becomes unbound later, it sets it to <code>false</code>.\n          If this column is empty, the port is not considered up.\n          This allows the CMS to wait for a VM's (or container's)\n          networking to become active before it allows the VM (or\n          container) to start.\n        </p>\n\n        <p>\n          Logical ports of router type are an exception to this rule.\n          They are considered to be always up, that is this column is\n          always set to <code>true</code>.\n        </p>\n      </column>\n\n      <column name=\"enabled\">\n        This column is used to administratively set port state.  If this column\n        is empty or is set to <code>true</code>, the port is enabled.  If this\n        column is set to <code>false</code>, the port is disabled.  A disabled\n        port has all ingress and egress traffic dropped.\n      </column>\n\n    </group>\n\n    <group title=\"Addressing\">\n      <column name=\"addresses\">\n        <p>\n          Addresses owned by the logical port.\n        </p>\n\n        <p>\n          Each element in the set must take one of the following forms:\n        </p>\n\n        <dl>\n          <dt><code>Ethernet address followed by zero or more IPv4 or IPv6 addresses (or both)</code></dt>\n          <dd>\n            <p>\n              An Ethernet address defined is owned by the logical port.\n              Like a physical Ethernet NIC, a logical port ordinarily has\n              a single fixed Ethernet address.\n            </p>\n\n            <p>\n              When a OVN logical switch processes a unicast Ethernet frame\n              whose destination MAC address is in a logical port's <ref\n              column=\"addresses\"/> column, it delivers it only to that port, as\n              if a MAC learning process had learned that MAC address on the\n              port.\n            </p>\n\n            <p>\n              If IPv4 or IPv6 address(es) (or both) are defined, it indicates\n              that the logical port owns the given IP addresses.\n            </p>\n\n            <p>\n              If IPv4 address(es) are defined, the OVN logical switch uses this\n              information to synthesize responses to ARP requests without\n              traversing the physical network. The OVN logical router connected\n              to the logical switch, if any, uses this information to avoid\n              issuing ARP requests for logical switch ports.\n            </p>\n\n            <p>\n              Note that the order here is important. The Ethernet address must\n              be listed before the IP address(es) if defined.\n            </p>\n\n            <p>\n              Examples:\n            </p>\n\n            <dl>\n              <dt><code>80:fa:5b:06:72:b7</code></dt>\n              <dd>\n                This indicates that the logical port owns the above mac address.\n              </dd>\n\n              <dt><code>80:fa:5b:06:72:b7 10.0.0.4 20.0.0.4</code></dt>\n              <dd>\n                This indicates that the logical port owns the mac address and two\n                IPv4 addresses.\n              </dd>\n\n              <dt><code>80:fa:5b:06:72:b7 fdaa:15f2:72cf:0:f816:3eff:fe20:3f41</code></dt>\n              <dd>\n                This indicates that the logical port owns the mac address and\n                1 IPv6 address.\n              </dd>\n\n              <dt><code>80:fa:5b:06:72:b7 10.0.0.4 fdaa:15f2:72cf:0:f816:3eff:fe20:3f41</code></dt>\n              <dd>\n                This indicates that the logical port owns the mac address and\n                1 IPv4 address and 1 IPv6 address.\n              </dd>\n            </dl>\n          </dd>\n\n          <dt><code>unknown</code></dt>\n          <dd>\n            This indicates that the logical port has an unknown set of Ethernet\n            addresses.  When an OVN logical switch processes a unicast Ethernet\n            frame whose destination MAC address is not in any logical port's\n            <ref column=\"addresses\"/> column, it delivers it to the port (or\n            ports) whose <ref column=\"addresses\"/> columns include\n            <code>unknown</code>.\n          </dd>\n\n          <dt><code>dynamic</code></dt>\n          <dd>\n            <p>\n              Use <code>dynamic</code> to make <code>ovn-northd</code> generate\n              a globally unique MAC address, choose an unused IPv4 address with\n              the logical port's subnet (if <ref table=\"Logical_Switch\"\n              column=\"other_config\" key=\"subnet\"/> is set in the port's <ref\n              table=\"Logical_Switch\"/>), and generate an IPv6 address from the\n              MAC address (if <ref table=\"Logical_Switch\" column=\"other_config\"\n              key=\"ipv6_prefix\"/> is set in the port's <ref\n              table=\"Logical_Switch\"/>) and store them in the port's <ref\n              column=\"dynamic_addresses\"/> column.\n            </p>\n\n            <p>\n              Only one element containing <code>dynamic</code> may appear in\n              <ref column=\"addresses\"/>.\n            </p>\n          </dd>\n\n          <dt><code>dynamic</code> <var>ip</var></dt>\n          <dt><code>dynamic</code> <var>ipv6</var></dt>\n          <dt><code>dynamic</code> <var>ip</var> <var>ipv6</var></dt>\n          <dd>\n            These act like <code>dynamic</code> alone but specify particular\n            IPv4 or IPv6 addresses to use.  OVN IPAM will still automatically\n            allocate the other address if configured appropriately.  Example:\n            <code>dynamic 192.168.0.1 2001::1</code>.\n          </dd>\n\n          <dt><var>mac</var> <code>dynamic</code></dt>\n          <dd>\n            This acts like <code>dynamic</code> alone but specifies a\n            particular MAC address to use.  OVN IPAM will still automatically\n            allocate IPv4 or IPv6 addresses, or both, if configured\n            appropriately.  Example: <code>80:fa:5b:06:72:b7 dynamic</code>\n          </dd>\n\n          <dt><code>router</code></dt>\n          <dd>\n            <p>\n              Accepted only when <ref column=\"type\"/> is <code>router</code>.\n              This indicates that the Ethernet, IPv4, and IPv6 addresses for\n              this logical switch port should be obtained from the connected\n              logical router port, as specified by <code>router-port</code> in\n              <ref column=\"options\"/>.\n            </p>\n\n            <p>\n              The resulting addresses are used to populate the logical\n              switch's destination lookup, and also for the logical switch\n              to generate ARP and ND replies.\n            </p>\n\n            <p>\n              If the connected logical router port has a\n              distributed gateway port specified and the logical router\n              has rules specified in <ref column=\"nat\" table=\"Logical_Router\"/>\n              with <ref column=\"external_mac\" table=\"NAT\"/>, then those\n              addresses are also used to populate the switch's destination\n              lookup.\n            </p>\n\n            <p>\n              Supported only in OVN 2.7 and later.  Earlier versions required\n              router addresses to be manually synchronized.\n            </p>\n          </dd>\n\n        </dl>\n      </column>\n\n      <column name=\"dynamic_addresses\">\n        <p>\n          Addresses assigned to the logical port by <code>ovn-northd</code>, if\n          <code>dynamic</code> is specified in <ref column=\"addresses\"/>.\n          Addresses will be of the same format as those that populate the <ref\n          column=\"addresses\"/> column.  Note that dynamically assigned\n          addresses are constructed and managed locally in ovn-northd, so they\n          cannot be reconstructed in the event that the database is lost.\n        </p>\n      </column>\n\n      <column name=\"port_security\">\n        <p>\n          This column controls the addresses from which the host attached to the\n          logical port (``the host'') is allowed to send packets and to which it\n          is allowed to receive packets.  If this column is empty, all addresses\n          are permitted.\n        </p>\n\n        <p>\n          Each element in the set must begin with one Ethernet address.\n          This would restrict the host to sending packets from and receiving\n          packets to the ethernet addresses defined in the logical port's\n          <ref column=\"port_security\"/> column. It also restricts the inner\n          source MAC addresses that the host may send in ARP and IPv6\n          Neighbor Discovery packets. The host is always allowed to receive packets\n          to multicast and broadcast Ethernet addresses.\n        </p>\n\n        <p>\n          Each element in the set may additionally contain one or more IPv4 or\n          IPv6 addresses (or both), with optional masks.  If a mask is given, it\n          must be a CIDR mask.  In addition to the restrictions described for\n          Ethernet addresses above, such an element restricts the IPv4 or IPv6\n          addresses from which the host may send and to which it may receive\n          packets to the specified addresses.  A masked address, if the host part\n          is zero, indicates that the host is allowed to use any address in the\n          subnet; if the host part is nonzero, the mask simply indicates the size\n          of the subnet. In addition:\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              If any IPv4 address is given, the host is also allowed to receive\n              packets to the IPv4 local broadcast address 255.255.255.255 and to\n              IPv4 multicast addresses (224.0.0.0/4).  If an IPv4 address with a\n              mask is given, the host is also allowed to receive packets to the\n              broadcast address in that specified subnet.\n            </p>\n\n            <p>\n              If any IPv4 address is given, the host is additionally restricted\n              to sending ARP packets with the specified source IPv4 address.\n              (RARP is not restricted.)\n            </p>\n          </li>\n\n          <li>\n            <p>\n              If any IPv6 address is given, the host is also allowed to receive\n              packets to IPv6 multicast addresses (ff00::/8).\n            </p>\n\n            <p>\n              If any IPv6 address is given, the host is additionally restricted\n              to sending IPv6 Neighbor Discovery Solicitation or Advertisement\n              packets with the specified source address or, for solicitations,\n              the unspecified address.\n            </p>\n          </li>\n        </ul>\n\n        <p>\n          If an element includes an IPv4 address, but no IPv6 addresses, then\n          IPv6 traffic is not allowed.  If an element includes an IPv6 address,\n          but no IPv4 address, then IPv4 and ARP traffic is not allowed.\n        </p>\n\n        <p>\n          This column uses the same lexical syntax as the <ref column=\"match\"\n          table=\"Pipeline\" db=\"OVN_Southbound\"/> column in the OVN Southbound\n          database's <ref table=\"Pipeline\" db=\"OVN_Southbound\"/> table.  Multiple\n          addresses within an element may be space or comma separated.\n        </p>\n\n        <p>\n          This column is provided as a convenience to cloud management systems,\n          but all of the features that it implements can be implemented as ACLs\n          using the <ref table=\"ACL\"/> table.\n        </p>\n\n        <p>\n          Examples:\n        </p>\n\n        <dl>\n          <dt><code>80:fa:5b:06:72:b7</code></dt>\n          <dd>\n            The host may send traffic from and receive traffic to the specified\n            MAC address, and to receive traffic to Ethernet multicast and\n            broadcast addresses, but not otherwise.  The host may not send ARP or\n            IPv6 Neighbor Discovery packets with inner source Ethernet addresses\n            other than the one specified.\n          </dd>\n\n          <dt><code>80:fa:5b:06:72:b7 192.168.1.10/24</code></dt>\n          <dd>\n            This adds further restrictions to the first example.  The host may\n            send IPv4 packets from or receive IPv4 packets to only 192.168.1.10,\n            except that it may also receive IPv4 packets to 192.168.1.255 (based\n            on the subnet mask), 255.255.255.255, and any address in 224.0.0.0/4.\n            The host may not send ARPs with a source Ethernet address other than\n            80:fa:5b:06:72:b7 or source IPv4 address other than 192.168.1.10.\n            The host may not send or receive any IPv6 (including IPv6 Neighbor\n            Discovery) traffic.\n          </dd>\n\n          <dt><code>\"80:fa:5b:12:42:ba\", \"80:fa:5b:06:72:b7 192.168.1.10/24\"</code></dt>\n          <dd>\n            The host may send traffic from and receive traffic to the\n            specified MAC addresses, and\n            to receive traffic to Ethernet multicast and broadcast addresses,\n            but not otherwise.   With MAC 80:fa:5b:12:42:ba, the host may\n            send traffic from and receive traffic to any L3 address.\n            With MAC 80:fa:5b:06:72:b7, the host may send IPv4 packets from or\n            receive IPv4 packets to only 192.168.1.10, except that it may also\n            receive IPv4 packets to 192.168.1.255 (based on the subnet mask),\n            255.255.255.255, and any address in 224.0.0.0/4.  The host may not\n            send or receive any IPv6 (including IPv6 Neighbor Discovery) traffic.\n          </dd>\n        </dl>\n      </column>\n    </group>\n\n    <group title=\"DHCP\">\n      <column name=\"dhcpv4_options\">\n        This column defines the DHCPv4 Options to be included by the\n        <code>ovn-controller</code> when it replies to the DHCPv4 requests.\n        Please see the <ref table=\"DHCP_Options\"/> table.\n      </column>\n\n      <column name=\"dhcpv6_options\">\n        This column defines the DHCPv6 Options to be included by the\n        <code>ovn-controller</code> when it replies to the DHCPv6 requests.\n        Please see the <ref table=\"DHCP_Options\"/> table.\n      </column>\n    </group>\n\n    <column name=\"mirror_rules\">\n        Mirror rules that apply to logical switch port which is the source.\n        Please see the <ref table=\"Mirror\"/> table.\n    </column>\n\n    <column name=\"ha_chassis_group\">\n      References a row in the OVN Northbound database's\n      <ref table=\"HA_Chassis_Group\" db=\"OVN_Northbound\"/> table.\n      It indicates the HA chassis group to use if the\n      <ref column=\"type\"/> is set to <code>external</code>.\n      If <ref column=\"type\"/> is not <code>external</code>, this\n      column is ignored.\n    </column>\n\n    <group title=\"Naming\">\n      <column name=\"external_ids\" key=\"neutron:port_name\">\n        <p>\n          This column gives an optional human-friendly name for the port.  This\n          name has no special meaning or purpose other than to provide\n          convenience for human interaction with the northbound database.\n        </p>\n\n        <p>\n          Neutron copies this from its own port object's name.  (Neutron ports\n          do are not assigned human-friendly names by default, so it will often\n          be empty.)\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Tunnel Key\">\n      <column name=\"options\" key=\"requested-tnl-key\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 32767}'>\n        Configures the port binding tunnel key for the port.  Usually\n        this is not needed because <code>ovn-northd</code> will assign an\n        unique key for each port by itself.  However, if it is configured,\n        <code>ovn-northd</code> honors the configured value.  The typical use\n        case is for interconnection: the tunnel keys for ports on transit\n        switches need to be unique globally, so they are maintained in the\n        global <ref db=\"OVN_IC_Southbound\"/> database, and <code>ovn-ic</code>\n        simply syncs the value from <ref db=\"OVN_IC_Southbound\"/> through this\n        config.\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        <p>\n          See <em>External IDs</em> at the beginning of this document.\n        </p>\n\n        <p>\n          The <code>ovn-northd</code> program copies all these pairs into the\n          <ref column=\"external_ids\"/> column of the\n          <ref table=\"Port_Binding\"/> table in <ref db=\"OVN_Southbound\"/>\n          database.\n        </p>\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Forwarding_Group\" title=\"forwarding group\">\n    <p>\n      Each row represents one forwarding group.\n    </p>\n\n    <column name=\"name\">\n      A name for the forwarding group.  This name has no special meaning or\n      purpose other than to provide convenience for human interaction with\n      the ovn-nb database.\n    </column>\n\n    <column name=\"vip\">\n      The virtual IP address assigned to the forwarding group. It will respond\n      with vmac when an ARP request is sent for vip.\n    </column>\n\n    <column name=\"vmac\">\n      The virtual MAC address assigned to the forwarding group.\n    </column>\n\n    <column name=\"liveness\">\n      If set to <code>true</code>, liveness is enabled for child ports\n      otherwise it is disabled.\n    </column>\n\n    <column name=\"child_port\">\n      List of child ports in the forwarding group.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Address_Set\" title=\"Address Sets\">\n    <p>\n      Each row in this table represents a named set of addresses.\n      An address set may contain Ethernet, IPv4, or IPv6 addresses\n      with optional bitwise or CIDR masks.\n      Address set may ultimately be used in ACLs to compare against\n      fields such as <code>ip4.src</code> or <code>ip6.src</code>.\n      A single address set must contain addresses of the\n      same type. As an example, the following would create an address set\n      with three IP addresses:\n    </p>\n\n    <pre>\n      ovn-nbctl create Address_Set name=set1 addresses='10.0.0.1 10.0.0.2 10.0.0.3'\n    </pre>\n\n    <p>\n      Address sets may be used in the <ref column=\"match\" table=\"ACL\"/> column\n      of the <ref table=\"ACL\"/> table.  For syntax information, see the details\n      of the expression language used for the <ref column=\"match\"\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> column in the <ref\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table of the <ref\n      db=\"OVN_Southbound\"/> database.\n    </p>\n\n    <column name=\"name\">\n      A name for the address set.  Names are ASCII and must match\n      <code>[a-zA-Z_.][a-zA-Z_.0-9]*</code>.\n    </column>\n\n    <column name=\"addresses\">\n      The set of addresses in string form.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Port_Group\" title=\"Port Groups\">\n    <p>\n      Each row in this table represents a named group of logical switch ports.\n    </p>\n\n    <p>\n      Port groups may be used in the <ref column=\"match\" table=\"ACL\"/> column\n      of the <ref table=\"ACL\"/> table.  For syntax information, see the details\n      of the expression language used for the <ref column=\"match\"\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> column in the <ref\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table of the <ref\n      db=\"OVN_Southbound\"/> database.\n    </p>\n\n    <p>\n      For each port group, there are two address sets generated to the\n      <ref table=\"Address_Set\" db=\"OVN_Southbound\"/> table of the\n      <ref db=\"OVN_Southbound\"/> database, containing the IP addresses\n      of the group of ports, one for IPv4, and the other for IPv6, with\n      <ref column=\"name\" table=\"Address_Set\" db=\"OVN_Southbound\"/> being\n      the <ref column=\"name\" table=\"Port_Group\" db=\"OVN_Northbound\"/>\n      of the <ref table=\"Port_Group\" db=\"OVN_Northbound\"/> followed by\n      a suffix <code>_ip4</code> for IPv4 and <code>_ip6</code> for IPv6.\n      The generated address sets can be used in the same way as regular\n      address sets in the <ref column=\"match\" table=\"ACL\"/> column\n      of the <ref table=\"ACL\"/> table. For syntax information, see the details\n      of the expression language used for the <ref column=\"match\"\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> column in the <ref\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table of the <ref\n      db=\"OVN_Southbound\"/> database.\n    </p>\n\n    <column name=\"name\">\n      A name for the port group.  Names are ASCII and must match\n      <code>[a-zA-Z_.][a-zA-Z_.0-9]*</code>.\n    </column>\n\n    <column name=\"ports\">\n      The logical switch ports belonging to the group in uuids.\n    </column>\n\n    <column name=\"acls\">\n      Access control rules that apply to the port group. Applying an ACL\n      to a port group has the same effect as applying the ACL to all logical\n      lswitches that the ports of the port group belong to.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Load_Balancer\" title=\"load balancer\">\n    <p>\n      Each row represents one load balancer.\n    </p>\n\n    <column name=\"name\">\n      A name for the load balancer.  This name has no special meaning or\n      purpose other than to provide convenience for human interaction with\n      the ovn-nb database.\n    </column>\n\n    <column name=\"vips\">\n      <p>\n        A map of virtual IP addresses (and an optional port number with\n        <code>:</code> as a separator) associated with this load balancer and\n        their corresponding endpoint IP addresses (and optional port numbers\n        with <code>:</code> as separators) separated by commas.  If\n        the destination IP address (and port number) of a packet leaving a\n        container or a VM matches the virtual IP address (and port number)\n        provided here as a key, then OVN will statefully replace the\n        destination IP address by one of the provided IP address (and port\n        number) in this map as a value.  IPv4 and IPv6 addresses are supported\n        for load balancing; however a VIP of one address family may not be\n        mapped to a destination IP address of a different family.  If\n        specifying an IPv6 address with a port, the address portion must be\n        enclosed in square brackets.  Examples for keys are \"192.168.1.4\" and\n        \"[fd0f::1]:8800\".  Examples for value are \"10.0.0.1, 10.0.0.2\" and\n        \"20.0.0.10:8800, 20.0.0.11:8800\".\n      </p>\n      <p>\n        When the <code>Load_Balancer</code> is added to the\n        <code>logical_switch</code>, the VIP has to be in a different subnet\n        than the one used for the <code>logical_switch</code>.  Since VIP is\n        in a different subnet, you should connect your logical switch to\n        either a OVN logical router or a real router (this is because the\n        client can now send a packet with VIP as the destination IP address\n        and router's mac address as the destination MAC address).\n      </p>\n    </column>\n\n    <column name=\"protocol\">\n      <p>\n        Valid protocols are <code>tcp</code>, <code>udp</code>, or\n        <code>sctp</code>.  This column is useful when a port number is\n        provided as part of the <code>vips</code> column.  If this column is\n        empty and a port number is provided as part of <code>vips</code>\n        column, OVN assumes the protocol to be <code>tcp</code>.\n      </p>\n    </column>\n\n    <group title=\"Health Checks\">\n      <p>\n        OVN supports health checks for load balancer endpoints. When health\n        checks are enabled, the load balancer uses only healthy endpoints.\n      </p>\n\n      <p>\n        Suppose that <ref column=\"vips\"/> contains a key-value pair\n        <code>10.0.0.10:80</code>=<code>10.0.0.4:8080,20.0.0.4:8080</code>.  To\n        enable health checks for this virtual's endpoints, add two key-value\n        pairs to <ref column=\"ip_port_mappings\"/>, with keys\n        <code>10.0.0.4</code> and <code>20.0.0.4</code>, and add to <ref\n        column=\"health_check\"/> a reference to a <ref\n        table=\"Load_Balancer_Health_Check\"/> row whose <ref\n        table=\"Load_Balancer_Health_Check\" column=\"vip\"/> is set to\n        <code>10.0.0.10</code>. The same approach can be used for IPv6 as well.\n      </p>\n\n      <column name=\"health_check\">\n        Load balancer health checks associated with this load balancer.\n      </column>\n\n      <column name=\"ip_port_mappings\">\n        <p>\n          Maps from endpoint IP to a colon-separated pair of logical port name\n          and source IP,\n          e.g. <code><var>port_name</var>:<var>sourc_ip</var></code> for IPv4.\n          Health checks are sent to this port with the specified source IP.\n          For IPv6 square brackets must be used around IP address, e.g:\n          <code><var>port_name</var>:<var>[sourc_ip]</var></code>\n        </p>\n\n        <p>\n          For example, in the example above, IP to port mappings might be\n          defined as <code>10.0.0.4</code>=<code>sw0-p1:10.0.0.2</code> and\n          <code>20.0.0.4</code>=<code>sw1-p1:20.0.0.2</code>, if the values\n          given were suitable ports and IP addresses.\n        </p>\n\n        <p>\n          For IPv6 IP to port mappings might be defined as\n          <code>[2001::1]</code>=<code>sw0-p1:[2002::1]</code>.\n        </p>\n      </column>\n    </group>\n\n    <column name=\"selection_fields\">\n      <p>\n        OVN native load balancers are supported using the OpenFlow groups\n        of type <code>select</code>. OVS supports two selection methods:\n        <code>dp_hash</code> and <code>hash (with optional fields\n        specified)</code> in selecting the buckets of a group.\n        Please see the OVS documentation (man ovs-ofctl)\n        for more details on the selection methods. Each endpoint IP (and port\n        if set) is mapped to a bucket in the group flow.\n      </p>\n\n      <p>\n        CMS can choose the <code>hash</code> selection method by setting the\n        selection fields in this column. <code>ovs-vswitchd</code> uses the\n        specified fields in generating the hash.\n      </p>\n\n      <p>\n        <code>dp_hash</code> selection method uses the assistance of\n        datapath to calculate the hash and it is expected to be\n        faster than <code>hash</code> selection method. So CMS should take\n        this into consideration before using the <code>hash</code> method.\n        Please consult the OVS documentation and OVS sources for the\n        implementation details.\n      </p>\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n    <group title=\"Load_Balancer options\">\n      <column name=\"options\" key=\"reject\" type='{\"type\": \"boolean\"}'>\n        If the load balancer is created with <code>--reject</code> option and\n        it has no active backends, a TCP reset segment (for tcp) or an ICMP\n        port unreachable packet (for all other kind of traffic) will be sent\n        whenever an incoming packet is received for this load-balancer.\n        Please note using <code>--reject</code> option will disable empty_lb\n        SB controller event for this load balancer.\n      </column>\n\n      <column name=\"options\" key=\"hairpin_snat_ip\">\n        IP to be used as source IP for packets that have been hair-pinned\n        after load balancing.  The default behavior when the option is not set\n        is to use the load balancer VIP as source IP.  This option may have\n        exactly one IPv4 and/or one IPv6 address on it, separated by a space\n        character.\n      </column>\n\n      <column name=\"options\" key=\"skip_snat\">\n        If the load balancing rule is configured with <code>skip_snat</code>\n        option, the option lb_force_snat_ip configured for the logical router\n        that references this load balancer will not be applied for this load\n        balancer.\n      </column>\n\n      <column name=\"options\" key=\"add_route\">\n        If set to <code>true</code>, then neighbor routers will have logical\n        flows added that will allow for routing to the VIP IP. It also will\n        have ARP resolution logical flows added. By setting this option, it\n        means there is no reason to create a\n        <ref table=\"Logical_Router_Static_Route\"/> from neighbor routers to\n        this NAT address. It also means that no ARP request is required for\n        neighbor routers to learn the IP-MAC mapping for this VIP IP. For\n        more information about what flows are added for IP routes, please\n        see the <code>ovn-northd</code> manpage section on IP Routing.\n      </column>\n\n      <column name=\"options\" key=\"neighbor_responder\">\n        If set to <code>all</code>, then routers on which the load balancer\n        is applied reply to ARP/neighbor discovery requests for all VIPs\n        of the load balancer.  If set to <code>reachable</code>, then routers\n        on which the load balancer is applied reply to ARP/neighbor discovery\n        requests only for VIPs that are part of a router's subnet.  If set to\n        <code>none</code>, then routers on which the load balancer is applied\n        never reply to ARP/neighbor discovery requests for any of the load\n        balancer VIPs. Load balancers with <code>options:template=true</code>\n        do not support <code>reachable</code> as a valid mode.  The default\n        value of this option, if not specified, is <code>reachable</code> for\n        regular load balancers and <code>none</code> for template load\n        balancers.\n      </column>\n\n      <column name=\"options\" key=\"template\">\n        <p>\n          Option to be set to <code>true</code>, if the load balancer is a\n          template.  The load balancer VIPs and backends must be using\n          <ref table=\"Chassis_Template_Var\"/> in their definitions.\n        </p>\n\n        <p>\n          Load balancer template VIP supported formats are:\n        </p>\n        <pre>\n^VIP_VAR[:^PORT_VAR|:port]\n        </pre>\n\n        <p>\n          where <code>VIP_VAR</code> and <code>PORT_VAR</code> are keys of\n          the <ref table=\"Chassis_Template_Var\"/> <ref column=\"variables\"/>\n          records.\n        </p>\n\n        <p>\n          Note: The VIP and PORT cannot be combined into a single template\n          variable. For example, a <ref table=\"Chassis_Template_Var\"/>\n          variable expanding to <code>10.0.0.1:8080</code> is not valid\n          if used as VIP.\n        </p>\n\n        <p>\n          Load balancer template backend supported formats are:\n        </p>\n        <pre>\n^BACKEND_VAR1[:^PORT_VAR1|:port],^BACKEND_VAR2[:^PORT_VAR2|:port]\n\nor\n\n^BACKENDS_VAR1,^BACKENDS_VAR2\n        </pre>\n        <p>\n          where <code>BACKEND_VAR1</code>, <code>PORT_VAR1</code>,\n          <code>BACKEND_VAR2</code>, <code>PORT_VAR2</code>,\n          <code>BACKENDS_VAR1</code> and <code>BACKENDS_VAR2</code> are keys\n          of the <ref table=\"Chassis_Template_Var\"/> <ref column=\"variables\"/>\n          records.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"address-family\">\n        Address family used by the load balancer.  Supported values are\n        <code>ipv4</code> and <code>ipv6</code>.  The address-family is\n        only used for load balancers with <code>options:template=true</code>.\n        For explicit load balancers, setting the address-family has no\n        effect.\n      </column>\n\n      <column name=\"options\" key=\"affinity_timeout\">\n        If the CMS provides a positive value (in seconds) for\n        <code>affinity_timeout</code>, OVN will dnat connections received\n        from the same client to this lb to the same backend if received in\n        the affinity timeslot. Max supported affinity_timeout is 65535\n        seconds.\n      </column>\n\n      <column name=\"options\" key=\"ct_flush\" type='{\"type\": \"boolean\"}'>\n        The value indicates whether ovn-controller should flush CT entries\n        that are related to this LB. The flush happens if the LB is removed,\n        any of the backends is updated/removed or the LB is not considered\n        local anymore by the ovn-controller. This option is set to\n        <code>false</code> by default.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Load_Balancer_Group\" title=\"load balancer group\">\n    <p>\n      Each row represents a logical grouping of load balancers.  It is up to\n      the CMS to decide the criteria on which load balancers are grouped\n      together.  To simplify configuration and to optimize its processing\n      load balancers that must be associated to the same set of logical\n      switches and/or logical routers should be grouped together.\n    </p>\n\n    <column name=\"name\">\n      A name for the load balancer group.  This name has no special meaning or\n      purpose other than to provide convenience for human interaction with\n      the ovn-nb database.\n    </column>\n\n    <column name=\"load_balancer\">\n      A set of load balancers.\n    </column>\n  </table>\n\n  <table name=\"Load_Balancer_Health_Check\" title=\"load balancer\">\n    <p>\n      Each row represents one load balancer health check.\n    </p>\n\n    <column name=\"vip\">\n      <code>vip</code> whose endpoints should be monitored for health check.\n    </column>\n\n    <group title=\"Health check options\">\n      <column name=\"options\" key=\"interval\" type='{\"type\": \"integer\"}'>\n        The interval, in seconds, between health checks.\n      </column>\n\n      <column name=\"options\" key=\"timeout\" type='{\"type\": \"integer\"}'>\n        The time, in seconds, after which a health check times out.\n      </column>\n\n      <column name=\"options\" key=\"success_count\" type='{\"type\": \"integer\"}'>\n        The number of successful checks after which the endpoint is\n        considered online.\n      </column>\n\n      <column name=\"options\" key=\"failure_count\" type='{\"type\": \"integer\"}'>\n        The number of failure checks after which the endpoint is considered\n        offline.\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"ACL\" title=\"Access Control List (ACL) rule\">\n    <p>\n      Each row in this table represents one ACL rule for a logical switch\n      or a port group that points to it through its <ref column=\"acls\"/>\n      column.  The <ref column=\"action\"/> column for the\n      highest-<ref column=\"priority\"/> matching row in this table determines a\n      packet's treatment.  If no row matches, packets are allowed by default.\n      (Default-deny treatment is possible: add a rule with\n      <ref column=\"priority\"/> 0, <code>1</code> as <ref column=\"match\"/>,\n      and <code>deny</code> as <ref column=\"action\"/>.)\n    </p>\n\n    <column name=\"label\">\n      <p>\n        Associates an identifier with the ACL.\n        The same value will be written to corresponding connection\n        tracker entry. The value should be a valid 32-bit unsigned integer.\n        This value can help in debugging from connection tracker side.\n        For example, through this \"label\" we can backtrack to the ACL rule\n        which is causing a \"leaked\" connection. Connection tracker entries are\n        created only for allowed connections so the label is valid only\n        for allow and allow-related actions.\n      </p>\n    </column>\n    <column name=\"priority\">\n      <p>\n        The ACL rule's priority.  Rules with numerically higher priority\n        take precedence over those with lower.  If two ACL rules with\n        the same priority both match, then the one actually applied to a\n        packet is undefined.\n      </p>\n\n      <p>\n        Return traffic from an <code>allow-related</code> flow is always\n        allowed and cannot be changed through an ACL.\n      </p>\n\n      <p>\n        <code>allow-stateless</code> flows always take precedence before\n        stateful ACLs, regardless of their priority. (Both\n        <code>allow</code> and <code>allow-related</code> ACLs can be\n        stateful.)\n      </p>\n    </column>\n\n    <column name=\"direction\">\n      <p>Direction of the traffic to which this rule should apply:</p>\n      <ul>\n        <li>\n          <code>from-lport</code>: Used to implement filters on traffic\n          arriving from a logical port.  These rules are applied to the\n          logical switch's ingress pipeline.\n        </li>\n        <li>\n          <code>to-lport</code>: Used to implement filters on traffic\n          forwarded to a logical port.  These rules are applied to the\n          logical switch's egress pipeline.\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"match\">\n      <p>\n        The packets that the ACL should match, in the same expression\n        language used for the <ref column=\"match\" table=\"Logical_Flow\"\n        db=\"OVN_Southbound\"/> column in the OVN Southbound database's\n        <ref table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table.  The\n        <code>outport</code> logical port is only available in the\n        <code>to-lport</code> direction (the <code>inport</code> is\n        available in both directions).\n      </p>\n\n      <p>\n        By default all traffic is allowed.  When writing a more\n        restrictive policy, it is important to remember to allow flows\n        such as ARP and IPv6 neighbor discovery packets.\n      </p>\n\n      <p>\n        Note that you can not create an ACL matching on a port with\n        type=router or type=localnet.\n      </p>\n    </column>\n\n    <column name=\"action\">\n      <p>The action to take when the ACL rule matches:</p>\n      <ul>\n        <li>\n          <code>allow-stateless</code>: Always forward the packet in stateless\n          manner, omitting connection tracking mechanism, regardless of other\n          rules defined for the switch.  May require defining additional rules\n          for inbound replies.  For example, if you define a rule to allow\n          outgoing TCP traffic directed to an IP address, then you probably\n          also want to define another rule to allow incoming TCP traffic coming\n          from this same IP address.\n          In addition, traffic that matches stateless ACLs will bypass\n          load-balancer DNAT/un-DNAT processing. Stateful ACLs should be\n          used instead if the traffic is supposed to be load-balanced.\n        </li>\n\n        <li>\n          <code>allow</code>: Forward the packet. It will also send the\n          packets through connection tracking when\n          <code>allow-related</code> rules exist on the logical switch.\n          Otherwise, it's equivalent to <code>allow-stateless</code>.\n        </li>\n\n        <li>\n          <code>allow-related</code>: Forward the packet and related traffic\n          (e.g. inbound replies to an outbound connection).\n        </li>\n\n        <li>\n          <code>drop</code>: Silently drop the packet.\n        </li>\n\n        <li>\n          <code>reject</code>: Drop the packet, replying with a RST for TCP or\n          ICMPv4/ICMPv6 unreachable message for other IPv4/IPv6-based\n          protocols.\n        </li>\n      </ul>\n    </column>\n\n    <group title=\"options\">\n      <p>\n        ACLs options.\n      </p>\n      <column name=\"options\" key=\"apply-after-lb\">\n        <p>\n          If set to true, the ACL will be applied after load balancing\n          stage.  Supported only for <code>from-lport</code> direction.\n        </p>\n\n        <p>\n          The main use case of this option is to support ACLs matching on\n          the destination IP address of the packet for the backend IPs\n          of load balancers.\n        </p>\n\n        <p>\n          <code>OVN</code> will apply the <code>from-lport</code> ACLs in two\n          stages.  ACLs without this option <code>apply-after-lb</code>\n          set, will be applied before the load balancer stage and ACLs\n          with this option set will be applied after the load balancer\n          stage.  The priorities are indepedent between these stages and\n          may not be obvious to the CMS.  Hence CMS should be extra careful\n          when using this option and should carefully evaluate the priorities\n          of all the ACLs and the default deny/allow ACLs if any.\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Logging\">\n      <p>\n        These columns control whether and how OVN logs packets that match an\n        ACL.\n      </p>\n\n      <column name=\"log\">\n        <p>\n          If set to <code>true</code>, packets that match the ACL will trigger\n          a log message on the transport node or nodes that perform ACL\n          processing.  Logging may be combined with any <ref column=\"action\"/>.\n        </p>\n\n        <p>\n          If set to <code>false</code>, the remaining columns in this group\n          have no significance.\n        </p>\n      </column>\n\n      <column name=\"name\">\n        <p>\n          This name, if it is provided, is included in log records.  It\n          provides the administrator and the cloud management system a way to\n          associate a log record with a particular ACL.\n        </p>\n      </column>\n\n      <column name=\"severity\">\n        <p>\n          The severity of the ACL.  The severity levels match those of syslog,\n          in decreasing level of severity: <code>alert</code>,\n          <code>warning</code>, <code>notice</code>, <code>info</code>, or\n          <code>debug</code>.  When the column is empty, the default is\n          <code>info</code>.\n        </p>\n      </column>\n\n      <column name=\"meter\">\n        <p>\n            The name of a meter to rate-limit log messages for the ACL.\n            The string must match the <ref column=\"name\" table=\"meter\"/>\n            column of a row in the <ref table=\"Meter\"/> table.  By\n            default, log messages are not rate-limited. In order to ensure\n            that the same <ref table=\"Meter\"/> rate limits multiple ACL logs\n            separately, set the <ref column=\"fair\" table=\"meter\"/> column.\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"options\">\n        This column provides general key/value settings. The supported\n        options are described individually below.\n      </column>\n\n      <group title=\"ACL configuration options\">\n        <column name=\"options\" key=\"log-related\">\n          If set to <code>true</code>, then log when reply or related\n          traffic is admitted from a stateful ACL. In order for this\n          option to function, the <ref column=\"log\"/> option must be\n          set to <code>true</code> and a <ref column=\"label\"/> must\n          be set, and it must be unique to the ACL. The label is necessary\n          as it is the only means to associate the reply traffic with the\n          ACL to which it belongs. It must be unique, because otherwise it\n          is ambiguous which ACL will be matched.\n\n          Note: If this option is enabled, an extra flow is installed in\n          order to log the related traffic. Therefore, if this is enabled\n          on all ACLs, then the total number of flows necessary to log the\n          ACL traffic is doubled, compared to if this option is not enabled.\n        </column>\n      </group>\n\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Logical_Router\" title=\"L3 logical router\">\n    <p>\n      Each row represents one L3 logical router.\n    </p>\n\n    <column name=\"ports\">\n      The router's ports.\n    </column>\n\n    <column name=\"static_routes\">\n      Zero or more static routes for the router.\n    </column>\n\n    <column name=\"policies\">\n      Zero or more routing policies for the router.\n    </column>\n\n    <column name=\"enabled\">\n      This column is used to administratively set router state.  If this column\n      is empty or is set to <code>true</code>, the router is enabled.  If this\n      column is set to <code>false</code>, the router is disabled.  A disabled\n      router has all ingress and egress traffic dropped.\n    </column>\n\n    <column name=\"nat\">\n      One or more NAT rules for the router.  NAT rules only work on\n      Gateway routers, and on distributed routers with one and only one\n      distributed gateway port.\n    </column>\n\n    <column name=\"load_balancer\">\n      Set of load balancers associated to this logical router.  Load balancer\n      Load balancer rules only work on the Gateway routers or routers with one\n      and only one distributed gateway port.\n    </column>\n\n    <column name=\"load_balancer_group\">\n      Set of load balancers groups associated to this logical router.\n    </column>\n\n    <group title=\"Naming\">\n      <p>\n        These columns provide names for the logical router.  From OVN's\n        perspective, these names have no special meaning or purpose other than\n        to provide convenience for human interaction with the northbound\n        database.  There is no requirement for the name to be unique.  (For a\n        unique identifier for a logical router, use its row UUID.)\n      </p>\n\n      <p>\n        (Originally, <ref column=\"name\"/> was intended to serve the purpose of\n        a human-friendly name, but the Neutron integration used it to uniquely\n        identify its own router object, in the format\n        <code>neutron-<var>uuid</var></code>.  Later on, Neutron started\n        propagating the friendly name of a router as <ref column=\"external_ids\"\n        key=\"neutron:router_name\"/>.  Perhaps this can be cleaned up someday.)\n      </p>\n\n      <column name=\"name\">\n        A name for the logical router.\n      </column>\n\n      <column name=\"external_ids\" key=\"neutron:router_name\">\n        Another name for the logical router.\n      </column>\n    </group>\n\n    <column name=\"copp\">\n      <p>\n        The control plane protection policy from table <ref table=\"Copp\"/>\n        used for metering packets sent to <code>ovn-controller</code> from\n        logical ports of this router.\n      </p>\n    </column>\n\n    <group title=\"Options\">\n      <p>\n        Additional options for the logical router.\n      </p>\n\n      <column name=\"options\" key=\"chassis\">\n        <p>\n          If set, indicates that the logical router in question is a Gateway\n          router (which is centralized) and resides in the set chassis.  The\n          same value is also used by <code>ovn-controller</code> to\n          uniquely identify the chassis in the OVN deployment and\n          comes from <code>external_ids:system-id</code> in the\n          <code>Open_vSwitch</code> table of Open_vSwitch database.\n        </p>\n\n        <p>\n          The Gateway router can only be connected to a distributed router\n          via a switch if SNAT and DNAT are to be configured in the Gateway\n          router.\n        </p>\n      </column>\n      <column name=\"options\" key=\"dnat_force_snat_ip\">\n        <p>\n          If set, indicates a set of IP addresses to use to force SNAT a\n          packet that has already been DNATed in the gateway router.  When\n          multiple gateway routers are configured, a packet can potentially\n          enter any of the gateway router, get DNATted and eventually reach the\n          logical switch port.  For the return traffic to go back to the same\n          gateway router (for unDNATing), the packet needs a SNAT in the first\n          place. This can be achieved by setting the above option with a\n          gateway specific set of IP addresses. This option may have exactly\n          one IPv4 and/or one IPv6 address on it, separated by a a space.\n        </p>\n      </column>\n      <column name=\"options\" key=\"lb_force_snat_ip\">\n        <p>\n          If set, this option can take two possible type of values.  Either\n          a set of IP addresses or the string value - <code>router_ip</code>.\n        </p>\n\n        <p>\n          If a set of IP addresses are configured, it indicates to use to\n          force SNAT a packet that has already been load-balanced in the\n          gateway router.  When multiple gateway routers are configured, a\n          packet can potentially enter any of the gateway routers, get\n          DNATted as part of the load-balancing and eventually reach the\n          logical switch port.  For the return traffic to go back to the\n          same gateway router (for unDNATing), the packet needs a SNAT in the\n          first place.  This can be achieved by setting the above option with\n          a gateway specific set of IP addresses. This option may have exactly\n          one IPv4 and/or one IPv6 address on it, separated by a space\n          character.\n        </p>\n\n        <p>\n          If it is configured with the value <code>router_ip</code>, then\n          the load balanced packet is SNATed with the IP of router port\n          (attached to the gateway router) selected as the destination after\n          taking the routing decision.\n        </p>\n      </column>\n      <column name=\"options\" key=\"mcast_relay\" type='{\"type\": \"boolean\"}'>\n        <p>\n          Enables/disables IP multicast relay between logical switches\n          connected to the logical router. Default: False.\n        </p>\n      </column>\n      <column name=\"options\" key=\"dynamic_neigh_routers\" type='{\"type\": \"boolean\"}'>\n        <p>\n          If set to <code>true</code>, the router will resolve neighbor\n          routers' MAC addresses only by dynamic ARP/ND, instead of\n          prepopulating static mappings for all neighbor routers in the ARP/ND\n          Resolution stage.  This reduces number of flows, but requires ARP/ND\n          messages to resolve the IP-MAC bindings when needed.  It is\n          <code>false</code> by default.  It is recommended to set to\n          <code>true</code> when a large number of logical routers are\n          connected to the same logical switch but most of them never need to\n          send traffic between each other. By default, ovn-northd does not\n          create mappings to NAT and load balancer addresess. However, for NAT\n          and load balancer addresses that have the <code>add_route</code>\n          option added, ovn-northd will create logical flows that map NAT and\n          load balancer IP addresses to the appropriate MAC address. Setting\n          <var>dynamic_neigh_routers</var> to <code>true</code> will prevent\n          the automatic creation of these logical flows.\n        </p>\n      </column>\n      <column name=\"options\" key=\"always_learn_from_arp_request\" type='{\"type\": \"boolean\"}'>\n        <p>\n          This option controls the behavior when handling IPv4 ARP requests or\n          IPv6 ND-NS packets - whether a dynamic neighbor (MAC binding) entry\n          is added/updated.\n        </p>\n\n        <p>\n          <code>true</code> - Always learn the MAC-IP binding, and add/update\n          the MAC binding entry.\n        </p>\n\n        <p>\n          <code>false</code> - If there is a MAC binding for that IP and the\n          MAC is different, or, if TPA of ARP request belongs to any router\n          port on this router, then update/add that MAC-IP binding. Otherwise,\n          don't update/add entries.\n        </p>\n\n        <p>\n          It is <code>true</code> by default.  It is recommended to set to\n          <code>false</code> when a large number of logical routers are\n          connected to the same logical switch but most of them never need to\n          send traffic between each other, to reduce the size of the MAC\n          binding table.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"requested-tnl-key\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 16777215}'>\n        Configures the datapath tunnel key for the logical router.\n        This is not needed because <code>ovn-northd</code> will assign an\n        unique key for each datapath by itself.  However, if it is configured,\n        <code>ovn-northd</code> honors the configured value.\n      </column>\n      <column name=\"options\" key=\"snat-ct-zone\"\n          type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 65535}'>\n        Use the requested conntrack zone for SNAT with this router. This can be\n        useful if egress traffic from the host running OVN comes from both OVN\n        and other sources. This way, OVN and the other sources can make use of\n        the same conntrack zone.\n      </column>\n\n      <column name=\"options\" key=\"mac_binding_age_threshold\"\n              type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 4294967295}'>\n        MAC binding aging <code>threshold</code> value in seconds. MAC binding\n        exceeding this timeout will be automatically removed. The value\n        defaults to 0, which means disabled.\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"QoS\" title=\"QoS rule\">\n    <p>\n      Each row in this table represents one QoS rule for a logical switch\n      that points to it through its <ref column=\"qos_rules\"/> column.\n      Two types of QoS are supported: DSCP marking and metering.  A\n      <ref column=\"match\"/> with the highest-<ref column=\"priority\"/>\n      will have QoS applied to it.  If the <ref column=\"action\"/> column is\n      specified, then matching packets will have DSCP marking applied.\n      If the <ref column=\"bandwidth\"/> column is specified, then matching\n      packets will have metering applied.  <ref column=\"action\"/> and\n      <ref column=\"bandwidth\"/> are not exclusive, so both marking and\n      metering by defined for the same QoS entry. If no row matches,\n      packets will not have any QoS applied.\n    </p>\n\n    <column name=\"priority\">\n      <p>\n        The QoS rule's priority.  Rules with numerically higher priority\n        take precedence over those with lower.  If two QoS rules with\n        the same priority both match, then the one actually applied to a\n        packet is undefined.\n      </p>\n    </column>\n\n    <column name=\"direction\">\n      <p>\n        The value of this field is similar to <ref colun=\"direction\"\n        table=\"ACL\" db=\"OVN_Northbound\"/> column in the OVN Northbound\n        database's <ref table=\"ACL\" db=\"OVN_Northbound\"/> table.\n      </p>\n    </column>\n\n    <column name=\"match\">\n      <p>\n        The packets that the QoS rules should match, in the same expression\n        language used for the <ref column=\"match\" table=\"Logical_Flow\"\n        db=\"OVN_Southbound\"/> column in the OVN Southbound database's\n        <ref table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table.  The\n        <code>outport</code> logical port is only available in the\n        <code>to-lport</code> direction (the <code>inport</code> is\n        available in both directions).\n      </p>\n    </column>\n\n    <column name=\"action\">\n      <p>When specified, matching flows will have DSCP marking applied.</p>\n      <ul>\n        <li>\n          <code>dscp</code>: The value of this action should be in the\n          range of 0 to 63 (inclusive).\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"bandwidth\">\n      <p>\n         When specified, matching packets will have bandwidth metering\n         applied.  Traffic over the limit will be dropped.\n      </p>\n      <ul>\n        <li>\n          <code>rate</code>: The value of rate limit in kbps.\n        </li>\n        <li>\n          <code>burst</code>: The value of burst rate limit in kilobits.\n          This is optional and needs to specify the <code>rate</code>.\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n\n  <table name=\"Mirror\" title=\"Mirror Entry\">\n    <p>\n      Each row in this table represents a mirror that can be used for\n      port mirroring. These mirrors are referenced by the\n      <ref column=\"mirror_rules\" table=\"Logical_Switch_Port\"/> column in\n      the <ref table=\"Logical_Switch_Port\"/> table.\n    </p>\n\n    <column name=\"name\">\n      <p>\n        Represents the name of the mirror.\n      </p>\n    </column>\n\n    <column name=\"filter\">\n      <p>\n        The value of this field represents selection criteria of the mirror.\n        <code>to-lport</code> mirrors the packets coming into logical port.\n        <code>from-lport</code> mirrors the packets going out of logical port.\n      </p>\n    </column>\n\n    <column name=\"sink\">\n      <p>\n        The value of this field represents the destination/sink of the mirror.\n        The value it takes is an IP address of the sink port.\n      </p>\n    </column>\n\n    <column name=\"type\">\n      <p>\n        The value of this field represents the type of the tunnel used for\n        sending the mirrored packets.\n      </p>\n    </column>\n\n    <column name=\"index\">\n      <p>\n        The value of this field represents the tunnel ID. If the configured\n        tunnel type is <code>gre</code>, this field represents the\n        <code>GRE</code> key value and if the configured tunnel type is\n        <code>erspan</code> it represents the <code>erspan_idx</code> value.\n      </p>\n    </column>\n\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n\n  <table name=\"Meter\" title=\"Meter entry\">\n    <p>\n      Each row in this table represents a meter that can be used for QoS or\n      rate-limiting.\n    </p>\n\n    <column name=\"name\">\n      <p>\n        A name for this meter.\n      </p>\n\n      <p>\n        Names that begin with \"__\" (two underscores) are reserved for\n        OVN internal use and should not be added manually.\n      </p>\n    </column>\n\n    <column name=\"unit\">\n      <p>\n        The unit for <ref column=\"rate\" table=\"Meter_Band\"/> and\n        <ref column=\"burst_rate\" table=\"Meter_Band\"/> parameters in\n        the <ref column=\"bands\"/> entry.  <code>kbps</code> specifies\n        kilobits per second, and <code>pktps</code> specifies packets\n        per second.\n      </p>\n    </column>\n\n    <column name=\"bands\">\n      <p>\n        The bands associated with this meter.  Each band specifies a\n        rate above which the band is to take the action\n        <code>action</code>.  If multiple bands' rates are exceeded,\n        then the band with the highest rate among the exceeded bands is\n        selected.\n      </p>\n    </column>\n\n    <column name=\"fair\">\n      <p>\n        This column is used to further describe the desired behavior\n        of the meter when there are multiple references to it. If this\n        column is empty or is set to <code>false</code>, the rate will\n        be shared across all rows that refer to the same Meter\n        <ref column=\"name\" table=\"meter\"/>. Conversely, when this column\n        is set to <code>true</code>, each user of the same Meter will be\n        rate-limited on its own.\n      </p>\n    </column>\n\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n\n  <table name=\"Meter_Band\" title=\"Band for meter entries\">\n    <p>\n      Each row in this table represents a meter band which specifies the\n      rate above which the configured action should be applied.  These bands\n      are referenced by the <ref column=\"bands\" table=\"Meter\"/> column in\n      the <ref table=\"Meter\"/> table.\n    </p>\n\n    <column name=\"action\">\n      <p>\n        The action to execute when this band matches.  The only supported\n        action is <code>drop</code>.\n      </p>\n    </column>\n\n    <column name=\"rate\">\n      <p>\n        The rate limit for this band, in kilobits per second or bits per\n        second, depending on whether the parent <ref table=\"Meter\"/>\n        entry's <ref column=\"unit\" table=\"Meter\"/> column specified\n        <code>kbps</code> or <code>pktps</code>.\n      </p>\n    </column>\n\n    <column name=\"burst_size\">\n      <p>\n        The maximum burst allowed for the band in kilobits or packets,\n        depending on whether <code>kbps</code> or <code>pktps</code> was\n        selected in the parent <ref table=\"Meter\"/> entry's\n        <ref column=\"unit\" table=\"Meter\"/> column.  If the size is zero,\n        the switch is free to select some reasonable value depending on\n        its configuration.\n      </p>\n    </column>\n\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n\n  <table name=\"Logical_Router_Port\" title=\"L3 logical router port\">\n    <p>\n      A port within an L3 logical router.\n    </p>\n\n    <p>\n      Exactly one <ref table=\"Logical_Router\"/> row must reference a given\n      logical router port.\n    </p>\n\n    <column name=\"name\">\n      <p>\n        A name for the logical router port.\n      </p>\n\n      <p>\n        In addition to provide convenience for human interaction with the\n        northbound database, this column is used as reference by its patch port\n        in <ref table=\"Logical_Switch_Port\"/> or another logical router port in\n        <ref table=\"Logical_Router_Port\"/>.\n      </p>\n\n        <p>\n          A logical router port may not have the same name as a logical switch\n          port, but the database schema cannot enforce this.\n        </p>\n    </column>\n\n    <column name=\"networks\">\n      <p>\n        The IP addresses and netmasks of the router.  For example,\n        <code>192.168.0.1/24</code> indicates that the router's IP\n        address is 192.168.0.1 and that packets destined to\n        192.168.0.<var>x</var> should be routed to this port.\n      </p>\n\n      <p>\n        A logical router port always adds a link-local IPv6 address\n        (fe80::/64) automatically generated from the interface's MAC\n        address using the modified EUI-64 format.\n      </p>\n    </column>\n\n    <column name=\"mac\">\n      The Ethernet address that belongs to this router port.\n    </column>\n\n    <column name=\"enabled\">\n      This column is used to administratively set port state.  If this column\n      is empty or is set to <code>true</code>, the port is enabled.  If this\n      column is set to <code>false</code>, the port is disabled.  A disabled\n      port has all ingress and egress traffic dropped.\n    </column>\n\n    <group title=\"Distributed Gateway Ports\">\n      <p>\n        Gateways, as documented under <code>Gateways</code> in the OVN\n        architecture guide, provide limited connectivity between\n        logical networks and physical ones.  OVN support multiple\n        kinds of gateways.  The <ref table=\"Logical_Router_Port\"/>\n        table can be used two different ways to configure\n        <dfn>distributed gateway ports</dfn>, which are one kind of\n        gateway.  These two forms of configuration exist for\n        historical reasons.  Both of them produce the same kind of OVN\n        southbound records and the same behavior in practice.\n      </p>\n\n      <p>\n        If either of these are set, this logical router port represents a\n        distributed gateway port that connects this router to a\n        logical switch with a <code>localnet</code> port or a\n        connection to another OVN deployment.\n      </p>\n\n      <p>\n        Also mentioned in the OVN architecture guide, distributed gateway ports\n        can also be used for scalability reasons in deployments where logical\n        switches are dedicated to chassises rather than distributed.\n      </p>\n\n      <p>\n        The preferred way to configure a gateway is <ref\n        column=\"ha_chassis_group\"/>, but <ref\n        column=\"gateway_chassis\"/> is also supported for backward\n        compatibility.  Only one of these should be set at a time on a\n        given LRP, since they configure the same features.\n      </p>\n\n      <p>\n        Even when a gateway is configured, the logical router port\n        still effectively resides on each chassis.  However, due to\n        the implications of the use of L2 learning in the physical\n        network, as well as the need to support advanced features such\n        as one-to-many NAT (aka IP masquerading), a subset of the\n        logical router processing is handled in a centralized manner\n        on the gateway chassis.\n      </p>\n\n      <p>\n        There can be more than one distributed gateway ports configured\n        on each logical router, each connecting to different L2 segments.\n        Load-balancing is not yet supported on logical routers with more\n        than one distributed gateway ports.\n      </p>\n\n      <p>\n        For each distributed gateway port, it may have more than one gateway\n        chassises. When more than one gateway chassis is specified, OVN only\n        uses one at a time.  OVN can rely on OVS BFD implementation to monitor\n        gateway connectivity, preferring the highest-priority gateway\n        that is online.  Priorities are specified in the <code>priority</code>\n        column of <ref table=\"Gateway_Chassis\"/> or <ref table=\"HA_Chassis\"/>.\n      </p>\n\n      <p>\n        <code>ovn-northd</code> programs the <ref\n        column=\"external_mac\" table=\"NAT\"/> rules specified in the\n        LRP's LR into the peer logical switch's destination lookup on\n        the chassis where the <ref column=\"logical_port\" table=\"NAT\"/>\n        resides.  In addition, the logical router's MAC address is\n        automatically programmed in the peer logical switch's\n        destination lookup flow on the gateway chasssis.  If it is\n        desired to generate gratuitous ARPs for NAT addresses, then\n        set the peer LSP's <ref column=\"options\" key=\"nat-addresses\"\n        table=\"Logical_Switch_Port\"/> to <code>router</code>.\n      </p>\n\n      <p>\n        OVN 20.03 and earlier supported a third way to configure\n        distributed gateway ports using\n        <code>options:redirect-chassis</code> to specify the gateway\n        chassis.  This method is no longer supported.  Any remaining\n        users should switch to one of the newer methods instead.  A\n        <ref column=\"gateway_chassis\"/> may be easily configured from\n        the command line, e.g. <code>ovn-nbctl lrp-set-gateway-chassis\n        <var>lrp</var> <var>chassis</var></code>.\n      </p>\n\n      <column name=\"ha_chassis_group\">\n        Designates an <ref table=\"HA_Chassis_Group\"/> to provide\n        gateway high availability.\n      </column>\n\n      <column name=\"gateway_chassis\">\n        Designates one or more <ref table=\"Gateway_Chassis\"/> for the\n        logical router port.\n      </column>\n\n      <group title=\"Options for Physical VLAN MTU Issues\">\n        <p>\n          MTU issues arise in mixing tunnels with logical networks that are\n          bridged to a physical VLAN.  For an explanation of the MTU issues,\n          see <code>Physical VLAN MTU Issues</code> in the OVN architecture\n          document.  The following options, which are alternatives, provide\n          solutions.  Both of them cause packets to be sent over\n          <code>localnet</code> instead of tunnels, but they differ in whether\n          some or all packets are sent this way.  The most prominent\n          tradeoff between these options is that\n          <code>reside-on-redirect-chassis</code> is easier to configure and\n          that <code>redirect-type</code> performs better for east-west\n          traffic.\n        </p>\n\n        <column name=\"options\" key=\"reside-on-redirect-chassis\"\n                type='{\"type\": \"boolean\"}'>\n          <p>\n            If set to <code>true</code>, this option forces all traffic across\n            the logical router port to pass through the gateway chassis using a\n            hop across a <code>localnet</code> port.  This changes behavior in\n            two ways:\n          </p>\n\n          <ul>\n            <li>\n              Without this option, east-west traffic passes directly between\n              source and destination chassis (or even within a single chassis,\n              for co-located VMs).  With this option, all east-west traffic\n              passes through the gateway chassis.\n            </li>\n\n            <li>\n              Without this option, traffic between the gateway chassis and\n              other chassis is encapsulated in tunnels.  With this option,\n              traffic passes over a <code>localnet</code> interface.\n            </li>\n          </ul>\n\n          <p>\n            This option may usefully be set only on logical router ports that\n            connect a distributed logical router to a logical switch with VIFs.\n            It should not be set on a distributed gateway port.\n          </p>\n\n          <p>\n            OVN honors this option only if the logical router has one and only\n            one distributed gateway port and if the LRP's peer switch has a\n            <code>localnet</code> port.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"redirect-type\"\n                type='{\"type\": \"string\", \"enum\": [\"set\", [\"overlay\", \"bridged\"]]}'>\n          <p>\n            If set to <code>bridged</code> on a distributed gateway port, this\n            option causes OVN to redirect packets to the gateway chassis over a\n            <code>localnet</code> port instead of a tunnel.  The relevant\n            chassis must share a <code>localnet</code> port.\n          </p>\n\n          <p>\n            This feature requires the administrator or the CMS to configure\n            each participating chassis with a unique Ethernet address for the\n            logical router by setting <code>ovn-chassis-mac-mappings</code> in\n            the Open vSwitch database, for use by <code>ovn-controller</code>.\n          </p>\n\n          <p>\n            Setting this option to <code>overlay</code> or leaving it unset has\n            no effect.  This option may usefully be set only on a distributed\n            gateway port when there is one and only one distributed gateway\n            port on the logical router.  It is otherwise ignored.\n          </p>\n        </column>\n      </group>\n    </group>\n\n    <column name=\"ipv6_prefix\">\n       This column contains IPv6 prefix obtained by prefix delegation\n       router according to RFC 3633\n    </column>\n\n    <group title=\"ipv6_ra_configs\">\n      <p>\n        This column defines the IPv6 ND RA address mode and ND MTU Option to be\n        included by <code>ovn-controller</code> when it replies to the IPv6\n        Router solicitation requests.\n      </p>\n\n      <column name=\"ipv6_ra_configs\" key=\"address_mode\">\n        The address mode to be used for IPv6 address configuration.\n        The supported values are:\n        <ul>\n          <li>\n            <code>slaac</code>: Address configuration using Router\n            Advertisement (RA) packet. The IPv6 prefixes defined in the\n            <ref table=\"Logical_Router_Port\"/> table's\n            <ref table=\"Logical_Router_Port\" column=\"networks\"/> column will\n            be included in the RA's ICMPv6 option - Prefix information.\n          </li>\n\n          <li>\n            <code>dhcpv6_stateful</code>: Address configuration using DHCPv6.\n          </li>\n\n          <li>\n            <code>dhcpv6_stateless</code>: Address configuration using Router\n            Advertisement (RA) packet. Other IPv6 options are provided by\n            DHCPv6.\n          </li>\n        </ul>\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"router_preference\">\n        Default Router Preference (PRF) indicates whether to prefer this\n        router over other default routers (RFC 4191).\n        Possible values are:\n\n        <ul>\n          <li>HIGH: mapped to 0x01 in RA PRF field</li>\n          <li>MEDIUM: mapped to 0x00 in RA PRF field</li>\n          <li>LOW: mapped to 0x11 in RA PRF field</li>\n        </ul>\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"route_info\">\n        Route Info is used to configure Route Info Option sent in Router\n        Advertisement according to RFC 4191. Route Info is a comma\n        separated string where each field provides PRF and prefix for a\n        given route (e.g: HIGH-aef1::11/48,LOW-aef2::11/96)\n        Possible PRF values are:\n\n        <ul>\n          <li>HIGH: mapped to 0x01 in RA PRF field</li>\n          <li>MEDIUM: mapped to 0x00 in RA PRF field</li>\n          <li>LOW: mapped to 0x11 in RA PRF field</li>\n        </ul>\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"mtu\">\n        The recommended MTU for the link. Default is 0, which means no MTU\n        Option will be included in RA packet replied by ovn-controller.\n        Per RFC 2460, the mtu value is recommended no less than 1280, so\n        any mtu value less than 1280 will be considered as no MTU Option.\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"send_periodic\">\n        If set to true, then this router interface will send router\n        advertisements periodically.  The default is false.\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"max_interval\">\n        The maximum number of seconds to wait between sending periodic router\n        advertisements.  This option has no effect if <ref\n        column=\"ipv6_ra_configs\" key=\"send_periodic\"/> is false.  The default\n        is 600.\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"min_interval\">\n        The minimum number of seconds to wait between sending periodic router\n        advertisements.  This option has no effect if <ref\n        column=\"ipv6_ra_configs\" key=\"send_periodic\"/> is false.  The default\n        is one-third of <ref column=\"ipv6_ra_configs\" key=\"max_interval\"/>,\n        i.e. 200 seconds if that key is unset.\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"rdnss\">\n        IPv6 address of RDNSS server announced in RA packets. At the moment\n        OVN supports just one RDNSS server.\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"dnssl\">\n        DNS Search List announced in RA packets. Multiple DNS Search List\n        must be 'comma' separated (e.g. \"a.b.c, d.e.f\")\n      </column>\n    </group>\n\n    <group title=\"Options\">\n      <p>\n        Additional options for the logical router port.\n      </p>\n\n      <column name=\"options\" key=\"mcast_flood\"\n              type='{\"type\": \"boolean\"}'>\n        <p>\n          If set to <code>true</code>, multicast traffic (including reports)\n          are unconditionally forwarded to the specific port.\n        </p>\n\n        <p>\n          This option applies when the port is part of a logical router which\n          has <ref table=\"Logical_Router\" column=\"options\"/>:mcast_relay set\n          to <code>true</code>.\n        </p>\n\n        <p>\n          Default: <code>false</code>.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"requested-tnl-key\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 32767}'>\n        Configures the port binding tunnel key for the port.  Usually\n        this is not needed because <code>ovn-northd</code> will assign an\n        unique key for each port by itself.  However, if it is configured,\n        <code>ovn-northd</code> honors the configured value.\n      </column>\n\n      <column name=\"options\" key=\"prefix_delegation\"\n              type='{\"type\": \"boolean\"}'>\n        <p>\n          If set to <code>true</code>, enable IPv6 prefix delegation state\n          machine on this logical router port (RFC3633). IPv6 prefix\n          delegation is available just on a gateway router or on a gateway\n          router port.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"prefix\" type='{\"type\": \"boolean\"}'>\n        <p>\n          If set to <code>true</code>, this interface will receive an IPv6\n          prefix according to RFC3663\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"route_table\">\n        Designates lookup Logical_Router_Static_Routes with specified\n        <code>route_table</code> value. Routes to directly connected networks\n        from same Logical Router and routes without <code>route_table</code>\n        option set have higher priority than routes with\n        <code>route_table</code> option set.\n      </column>\n\n      <column name=\"options\" key=\"gateway_mtu\"\n          type='{\"type\": \"integer\", \"minInteger\": 68, \"maxInteger\": 65535}'>\n        <p>\n          If set, logical flows will be added to router pipeline to check\n          packet length.  If packet length is greater than the value set,\n          ICMPv4 type 3 (Destination Unreachable) code 4 (Fragmentation Needed\n          and Don't Fragment was Set) or ICMPv6 type 2 (Packet Too Big)\n          code 0 (no route to destination) packets will be generated.\n\n          This allows for Path MTU Discovery.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"gateway_mtu_bypass\">\n        <p>\n          When configured, represents a match expression, in the same\n          expression language used for the <ref column=\"match\"\n          table=\"Logical_Flow\" db=\"OVN_Southbound\"/> column in the OVN\n          Southbound database's <ref table=\"Logical_Flow\" db=\"OVN_Southbound\"/>\n          table.  Packets matching this expression will bypass the length\n          check configured through the\n          <ref column=\"options\" key=\"gateway_mtu\"/> option.\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Attachment\">\n      <p>\n        A given router port serves one of two purposes:\n      </p>\n\n      <ul>\n        <li>\n          To attach a logical switch to a logical router.  A logical router\n          port of this type is referenced by exactly one <ref\n          table=\"Logical_Switch_Port\"/> of type <code>router</code>.\n          The value of <ref column=\"name\"/> is set as\n          <code>router-port</code> in column <ref column=\"options\"/> of\n          <ref table=\"Logical_Switch_Port\"/>.  In this case <ref\n          column=\"peer\"/> column is empty.\n        </li>\n\n        <li>\n          To connect one logical router to another.  This requires a pair of\n          logical router ports, each connected to a different router.  Each\n          router port in the pair specifies the other in its <ref\n          column=\"peer\"/> column.  No <ref table=\"Logical_Switch\"/> refers to\n          the router port.\n        </li>\n      </ul>\n\n      <column name=\"peer\">\n        <p>\n          For a router port used to connect two logical routers, this\n          identifies the other router port in the pair by <ref column=\"name\"/>.\n        </p>\n\n        <p>\n          For a router port attached to a logical switch, this column is empty.\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n        <p>\n          The <code>ovn-northd</code> program copies all these pairs into the\n          <ref column=\"external_ids\"/> column of the\n          <ref table=\"Port_Binding\"/> table in <ref db=\"OVN_Southbound\"/>\n          database.\n        </p>\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Logical_Router_Static_Route\" title=\"Logical router static routes\">\n    <p>\n      Each record represents a static route.\n    </p>\n\n    <p>\n      When multiple routes match a packet, the longest-prefix match is chosen.\n      For a given prefix length, a <code>dst-ip</code> route is preferred over\n      a <code>src-ip</code> route.\n    </p>\n\n    <p>\n      When there are ECMP routes, i.e. multiple routes with same prefix and\n      policy, one of them will be selected based on the 5-tuple hashing of the\n      packet header.\n    </p>\n\n    <column name=\"ip_prefix\">\n      <p>\n        IP prefix of this route (e.g. 192.168.100.0/24).\n      </p>\n    </column>\n\n    <column name=\"policy\">\n      <p>\n        If it is specified, this setting describes the policy used to make\n        routing decisions.  This setting must be one of the following strings:\n      </p>\n      <ul>\n        <li>\n          <code>src-ip</code>: This policy sends the packet to the\n          <ref column=\"nexthop\"/> when the packet's source IP address matches\n          <ref column=\"ip_prefix\"/>.\n       </li>\n        <li>\n          <code>dst-ip</code>: This policy sends the packet to the\n          <ref column=\"nexthop\"/> when the packet's destination IP address\n          matches <ref column=\"ip_prefix\"/>.\n        </li>\n      </ul>\n      <p>\n        If not specified, the default is <code>dst-ip</code>.\n     </p>\n    </column>\n\n    <column name=\"nexthop\">\n      <p>\n        Nexthop IP address for this route.  Nexthop IP address should be the IP\n        address of a connected router port or the IP address of a logical port\n        or can be set to <code>discard</code> for dropping packets which match\n        the given route.\n      </p>\n    </column>\n\n    <column name=\"output_port\">\n      <p>\n        The name of the <ref table=\"Logical_Router_Port\"/> via which the packet\n        needs to be sent out.  This is optional and when not specified,\n        OVN will automatically figure this out based on the\n        <ref column=\"nexthop\"/>.  When this is specified and there are\n        multiple IP addresses on the router port and none of them are in the\n        same subnet of <ref column=\"nexthop\"/>, OVN chooses the first IP\n        address as the one via which the <ref column=\"nexthop\"/> is reachable.\n      </p>\n    </column>\n\n    <column name=\"bfd\">\n      <p>\n        Reference to <ref table=\"BFD\"/> row if the route has associated a\n        BFD session\n      </p>\n    </column>\n\n    <column name=\"route_table\">\n      <p>\n        Any string to place route to separate routing table. If Logical Router\n        Port has configured value in <ref table=\"Logical_Router_Port\"\n        column=\"options\" key=\"route_table\"/> other than empty string, OVN\n        performs route lookup for all packets entering Logical Router ingress\n        pipeline from this port in the following manner:\n      </p>\n\n      <ul>\n        <li>\n          1. First lookup among \"global\" routes: routes without\n          <code>route_table</code> value set and routes to directly connected\n          networks.\n        </li>\n        <li>\n          2. Next lookup among routes with same <code>route_table</code> value\n          as specified in LRP's options:route_table field.\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"external_ids\" key=\"ic-learned-route\">\n      <code>ovn-ic</code> populates this key if the route is learned from the\n      global <ref db=\"OVN_IC_Southbound\"/> database.  In this case the value\n      will be set to the uuid of the row in <ref table=\"Route\"\n      db=\"OVN_IC_Southbound\"/> table of the <ref db=\"OVN_IC_Southbound\"/>\n      database.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n\n    <group title=\"Common options\">\n      <column name=\"options\">\n        This column provides general key/value settings. The supported\n        options are described individually below.\n      </column>\n\n      <column name=\"options\" key=\"ecmp_symmetric_reply\">\n        If true, then new traffic that arrives over this route will have\n        its reply traffic bypass ECMP route selection and will be sent out\n        this route instead. Note that this option overrides any rules set\n        in the <ref table=\"Logical_Router_policy\" /> table. This option\n        only works on gateway routers (routers that have\n        <ref column=\"options\" key=\"chassis\" table=\"Logical_Router\" /> set).\n      </column>\n\n      <column name=\"options\" key=\"origin\">\n        In case ovn-interconnection has been learned this route, it will have\n        its origin set: either \"connected\" or \"static\".  This key is supposed\n        to be written only by <code>ovn-ic</code> daemon.  ovn-northd then\n        checks this value when generating Logical Flows.  <ref\n        table=\"Logical_Router_Static_Route\"/> records with same\n        <ref column=\"ip_prefix\"/> within same Logical Router will have next\n        lookup order based on <code>origin</code> key value:\n        <ol>\n          <li>connected</li>\n          <li>static</li>\n        </ol>\n      </column>\n    </group>\n\n  </table>\n\n  <table name=\"Logical_Router_Policy\" title=\"Logical router policies\">\n    <p>\n      Each row in this table represents one routing policy for a logical router\n      that points to it through its <ref column=\"policies\"/> column.  The <ref\n      column=\"action\"/> column for the highest-<ref column=\"priority\"/>\n      matching row in this table determines a packet's treatment.  If no row\n      matches, packets are allowed by default. (Default-deny treatment is\n      possible: add a rule with <ref column=\"priority\"/> 0, <code>1</code> as\n      <ref column=\"match\"/>, and <code>drop</code> as <ref column=\"action\"/>.)\n    </p>\n\n    <column name=\"priority\">\n      <p>\n        The routing policy's priority.  Rules with numerically higher priority\n        take precedence over those with lower. A rule is uniquely identified\n        by the priority and match string.\n      </p>\n    </column>\n\n    <column name=\"match\">\n      <p>\n        The packets that the routing policy should match,\n        in the same expression language used for the\n        <ref column=\"match\" table=\"Logical_Flow\" db=\"OVN_Southbound\"/>\n        column in the OVN Southbound database's\n        <ref table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table.\n      </p>\n\n      <p>\n        By default all traffic is allowed.  When writing a more\n        restrictive policy, it is important to remember to allow flows\n        such as ARP and IPv6 neighbor discovery packets.\n      </p>\n    </column>\n\n    <column name=\"action\">\n      <p>The action to take when the routing policy matches:</p>\n      <ul>\n        <li>\n          <code>allow</code>: Forward the packet.\n        </li>\n\n        <li>\n          <code>drop</code>: Silently drop the packet.\n        </li>\n\n        <li>\n          <code>reroute</code>: Reroute packet to <ref column=\"nexthop\"/> or\n          <ref column=\"nexthops\"/>.\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"nexthop\">\n      <p>\n        Note: This column is deprecated in favor of <ref column=\"nexthops\"/>.\n      </p>\n      <p>\n        Next-hop IP address for this route, which should be the IP\n        address of a connected router port or the IP address of a logical port.\n      </p>\n    </column>\n\n    <column name=\"nexthops\">\n      <p>\n        Next-hop ECMP IP addresses for this route. Each IP in the list should\n        be the IP address of a connected router port or the IP address of a\n        logical port.\n      </p>\n\n      <p>\n        One IP from the list is selected as next hop.\n      </p>\n    </column>\n\n    <column name=\"options\" key=\"pkt_mark\">\n      <p>\n        Marks the packet with the value specified when the router policy\n        is applied. CMS can inspect this packet marker and take some decisions\n        if desired. This value is not preserved when the packet goes out on the\n        wire.\n      </p>\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"NAT\" title=\"NAT rules\">\n    <p>\n      Each record represents a NAT rule.\n    </p>\n\n    <column name=\"type\">\n      <p>Type of the NAT rule.</p>\n      <ul>\n        <li>\n          When <ref column=\"type\"/> is <code>dnat</code>, the externally\n          visible IP address <ref column=\"external_ip\"/> is DNATted to the IP\n          address <ref column=\"logical_ip\"/> in the logical space.\n        </li>\n        <li>\n          When <ref column=\"type\"/> is <code>snat</code>, IP packets\n          with their source IP address that either matches the IP address\n          in <ref column=\"logical_ip\"/> or is in the network provided by\n          <ref column=\"logical_ip\"/> is SNATed into the IP address in\n          <ref column=\"external_ip\"/>.\n        </li>\n        <li>\n          When <ref column=\"type\"/> is <code>dnat_and_snat</code>, the\n          externally visible IP address <ref column=\"external_ip\"/> is\n          DNATted to the IP address <ref column=\"logical_ip\"/> in the\n          logical space. In addition, IP packets with the source IP\n          address that matches <ref column=\"logical_ip\"/> is SNATed into\n          the IP address in <ref column=\"external_ip\"/>.\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"external_ip\">\n      An IPv4 address.\n    </column>\n\n    <column name=\"external_mac\">\n      <p>\n        A MAC address.\n      </p>\n\n      <p>\n        This is only used on the gateway port on distributed routers.\n        This must be specified in order for the NAT rule to be\n        processed in a distributed manner on all chassis.  If this is\n        not specified for a NAT rule on a distributed router, then\n        this NAT rule will be processed in a centralized manner on\n        the gateway port instance on the gateway chassis.\n      </p>\n\n      <p>\n        This MAC address must be unique on the logical switch that the\n        gateway port is attached to.  If the MAC address used on the\n        <ref column=\"logical_port\"/> is globally unique, then that MAC\n        address can be specified as this <ref column=\"external_mac\"/>.\n      </p>\n    </column>\n\n    <column name=\"external_port_range\">\n      <p>\n        L4 source port range\n      </p>\n\n      <p>\n        Range of ports, from which a port number will be picked that will\n        replace the source port of to be NATed packet. This is basically\n        PAT (port address translation).\n      </p>\n\n      <p>\n        Value of the column is in the format, port_lo-port_hi.\n        For example:\n        external_port_range : \"1-30000\"\n      </p>\n\n      <p>\n        Valid range of ports is 1-65535.\n      </p>\n\n    </column>\n\n    <column name=\"logical_ip\">\n      An IPv4 network (e.g 192.168.1.0/24) or an IPv4 address.\n    </column>\n\n    <column name=\"logical_port\">\n      <p>\n        The name of the logical port where the <ref column=\"logical_ip\"/>\n        resides.\n      </p>\n\n      <p>\n        This is only used on distributed routers.  This must be\n        specified in order for the NAT rule to be processed in a\n        distributed manner on all chassis.  If this is not specified\n        for a NAT rule on a distributed router, then this NAT rule\n        will be processed in a centralized manner on the gateway\n        port instance on the gateway chassis.\n      </p>\n    </column>\n\n    <column name=\"allowed_ext_ips\">\n      It represents Address Set of external ips that NAT rule is applicable to.\n      For SNAT type NAT rules, this refers to destination addresses.\n      For DNAT type NAT rules, this refers to source addresses.\n\n      <p>\n        This configuration overrides the default NAT behavior of applying a\n        rule solely based on internal IP. Without this configuration, NAT\n        happens without considering the external IP (i.e dest/source for\n        snat/dnat type rule). With this configuration NAT rule is applied\n        ONLY if external ip is in the input Address Set.\n      </p>\n    </column>\n\n    <column name=\"exempted_ext_ips\">\n      It represents Address Set of external ips that NAT rule is NOT\n      applicable to.\n      For SNAT type NAT rules, this refers to destination addresses.\n      For DNAT type NAT rules, this refers to source addresses.\n\n      <p>\n        This configuration overrides the default NAT behavior of applying a\n        rule solely based on internal IP. Without this configuration, NAT\n        happens without considering the external IP (i.e dest/source for\n        snat/dnat type rule). With this configuration NAT rule is NOT applied\n        if external ip is in the input Address Set.\n      </p>\n\n      <p>\n        If there are NAT rules in a logical router with overlapping IP prefixes\n        (including /32), then usage of <var>exempted_ext_ips</var> should be\n        avoided in following scenario.\n        a. SNAT rule (let us say RULE1) with logical_ip PREFIX/MASK\n           (let us say 50.0.0.0/24).\n        b. SNAT rule (let us say RULE2) with logical_ip PREFIX/MASK+1\n           (let us say 50.0.0.0/25).\n        c. Now, if exempted_ext_ips is associated with RULE2, then a logical\n           ip which matches both 50.0.0.0/24 and 50.0.0.0/25 may get the RULE2\n           applied to it instead of RULE1.\n      </p>\n\n      <p>\n        <var>allowed_ext_ips</var> and <var>exempted_ext_ips</var> are mutually\n        exclusive to each other. If both Address Sets are set for a rule,\n        then the NAT rule is not considered.\n      </p>\n    </column>\n\n    <column name=\"gateway_port\">\n      <p>\n        A distributed gateway port in the <ref table=\"Logical_Router_Port\"/>\n        table where the NAT rule needs to be applied.\n      </p>\n\n      <p>\n        When multiple distributed gateway ports are configured on a\n        <ref table=\"Logical_Router\"/>, applying a NAT rule at each of the\n        distributed gateway ports might not be desired. Consider the case\n        where a logical router has 2 distributed gateway port, one with\n        <ref column=\"networks\" table=\"Logical_Router_Port\"/>\n        <code>50.0.0.10/24</code> and the other with\n        <ref column=\"networks\" table=\"Logical_Router_Port\"/>\n        <code>60.0.0.10/24</code>. If the logical router has a\n        NAT rule of <ref column=\"type\"/> <code>snat</code>,\n        <ref column=\"logical_ip\"/> <code>10.1.1.0/24</code> and\n        <ref column=\"external_ip\"/> <code>50.1.1.20/24</code>, the rule needs\n        to be selectively applied on matching packets entering/leaving\n        through the distributed gateway port with\n        <ref column=\"networks\" table=\"Logical_Router_Port\"/>\n        <code>50.0.0.10/24</code>.\n      </p>\n\n      <p>\n        When a logical router has multiple distributed gateway ports and this\n        column is not set for a NAT rule, then the rule will be applied at the\n        distributed gateway port which is in the same network as the\n        <ref column=\"external_ip\"/> of the NAT rule, if such a router port\n        exists. If logical router has a single distributed gateway port and\n        this column is not set for a NAT rule, the rule will be applied at the\n        distributed gateway port even if the router port is not in the same\n        network as the <ref column=\"external_ip\"/> of the NAT rule.\n      </p>\n    </column>\n\n    <column name=\"options\" key=\"stateless\">\n      Indicates if a dnat_and_snat rule should lead to connection\n      tracking state or not.\n    </column>\n\n    <column name=\"options\" key=\"add_route\">\n      If set to <code>true</code>, then neighbor routers will have logical\n      flows added that will allow for routing to the NAT address. It also will\n      have ARP resolution logical flows added. By setting this option, it means\n      there is no reason to create a <ref table=\"Logical_Router_Static_Route\"/>\n      from neighbor routers to this NAT address. It also means that no ARP\n      request is required for neighbor routers to learn the IP-MAC mapping for\n      this NAT address. This option only applies to NATs of type\n      <code>dnat</code> and <code>dnat_and_snat</code>. For more information\n      about what flows are added for IP routes, please see the\n      <code>ovn-northd</code> manpage section on IP Routing.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n\n  </table>\n\n  <table name=\"DHCP_Options\" title=\"DHCP options\">\n    <p>\n      OVN implements native DHCPv4 support which caters to the common\n      use case of providing an IPv4 address to a booting instance by\n      providing stateless replies to DHCPv4 requests based on statically\n      configured address mappings. To do this it allows a short list of\n      DHCPv4 options to be configured and applied at each compute host\n      running <code>ovn-controller</code>.\n    </p>\n\n    <p>\n      OVN also implements native DHCPv6 support which provides stateless\n      replies to DHCPv6 requests.\n    </p>\n\n    <column name=\"cidr\">\n      <p>\n        The DHCPv4/DHCPv6 options will be included if the logical port has its\n        IP address in this <ref column=\"cidr\"/>.\n      </p>\n    </column>\n\n    <group title=\"DHCPv4 options\">\n      <p>\n        The CMS should define the set of DHCPv4 options as key/value pairs\n        in the <ref column=\"options\"/> column of this table. For\n        <code>ovn-controller</code> to include these DHCPv4 options, the\n        <ref column=\"dhcpv4_options\"/> of <ref table=\"Logical_Switch_Port\"/>\n        should refer to an entry in this table.\n      </p>\n\n      <group title=\"Mandatory DHCPv4 options\">\n        <p>\n          The following options must be defined.\n        </p>\n\n        <column name=\"options\" key=\"server_id\">\n          The IP address for the DHCP server to use.  This should be in the\n          subnet of the offered IP.  This is also included in the DHCP offer as\n          option 54, ``server identifier.''\n        </column>\n\n        <column name=\"options\" key=\"server_mac\">\n          The Ethernet address for the DHCP server to use.\n        </column>\n\n        <column name=\"options\" key=\"lease_time\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 4294967295}'>\n          <p>\n            The offered lease time in seconds,\n          </p>\n\n          <p>\n            The DHCPv4 option code for this option is 51.\n          </p>\n        </column>\n      </group>\n\n      <group title=\"IPv4 DHCP Options\">\n        <p>\n          Below are the supported DHCPv4 options whose values are an IPv4\n          address, e.g. <code>192.168.1.1</code>.  Some options accept multiple\n          IPv4 addresses enclosed within curly braces, e.g. <code>{192.168.1.2,\n          192.168.1.3}</code>. Please refer to RFC 2132 for more details on\n          DHCPv4 options and their codes.\n        </p>\n\n        <column name=\"options\" key=\"router\">\n          <p>\n            The IP address of a gateway for the client to use.  This should be\n            in the subnet of the offered IP.  The DHCPv4 option code for this\n            option is 3.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"netmask\">\n          <p>\n            The DHCPv4 option code for this option is 1.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"dns_server\">\n          <p>\n            The DHCPv4 option code for this option is 6.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"log_server\">\n          <p>\n            The DHCPv4 option code for this option is 7.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"lpr_server\">\n          <p>\n            The DHCPv4 option code for this option is 9.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"swap_server\">\n          <p>\n            The DHCPv4 option code for this option is 16.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"policy_filter\">\n          <p>\n            The DHCPv4 option code for this option is 21.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"router_solicitation\">\n          <p>\n            The DHCPv4 option code for this option is 32.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"nis_server\">\n          <p>\n            The DHCPv4 option code for this option is 41.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"ntp_server\">\n          <p>\n            The DHCPv4 option code for this option is 42.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"netbios_name_server\">\n          <p>\n            The DHCPv4 option code for this option is 44.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"classless_static_route\">\n          <p>\n            The DHCPv4 option code for this option is 121.\n          </p>\n\n          <p>\n             This option can contain one or more static routes, each of which\n             consists of a destination descriptor and the IP address of the\n             router that should be used to reach that destination. Please see\n             RFC 3442 for more details.\n          </p>\n\n          <p>\n            Example: <code>{30.0.0.0/24,10.0.0.10, 0.0.0.0/0,10.0.0.1}</code>\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"ms_classless_static_route\">\n          <p>\n            The DHCPv4 option code for this option is 249. This option is\n            similar to <code>classless_static_route</code> supported by\n            Microsoft Windows DHCPv4 clients.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"next_server\">\n          <p>\n            The DHCPv4 option code for setting the \"Next server IP\n            address\" field in the DHCP header.\n          </p>\n        </column>\n\n      </group>\n\n      <group title=\"Boolean DHCP Options\">\n        <p>\n          These options accept a Boolean value, expressed as <code>0</code> for\n          false or <code>1</code> for true.\n        </p>\n\n        <column name=\"options\" key=\"ip_forward_enable\"\n                type='{\"type\": \"string\", \"enum\": [\"set\", [\"0\", \"1\"]]}'>\n          <p>\n            The DHCPv4 option code for this option is 19.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"router_discovery\"\n                type='{\"type\": \"string\", \"enum\": [\"set\", [\"0\", \"1\"]]}'>\n          <p>\n            The DHCPv4 option code for this option is 31.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"ethernet_encap\"\n                type='{\"type\": \"string\", \"enum\": [\"set\", [\"0\", \"1\"]]}'>\n          <p>\n            The DHCPv4 option code for this option is 36.\n          </p>\n        </column>\n      </group>\n\n      <group title=\"Integer DHCP Options\">\n        <p>\n          These options accept a nonnegative integer value.\n        </p>\n\n        <column name=\"options\" key=\"default_ttl\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 255}'>\n          The DHCPv4 option code for this option is 23.\n        </column>\n\n        <column name=\"options\" key=\"tcp_ttl\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 255}'>\n          The DHCPv4 option code for this option is 37.\n        </column>\n\n        <column name=\"options\" key=\"mtu\"\n                type='{\"type\": \"integer\", \"minInteger\": 68, \"maxInteger\": 65535}'>\n          The DHCPv4 option code for this option is 26.\n        </column>\n\n        <column name=\"options\" key=\"T1\"\n                type='{\"type\": \"integer\", \"minInteger\": 68, \"maxInteger\": 4294967295}'>\n          This specifies the time interval from address assignment until the\n          client begins trying to renew its address.  The DHCPv4 option code\n          for this option is 58.\n        </column>\n\n        <column name=\"options\" key=\"T2\"\n                type='{\"type\": \"integer\", \"minInteger\": 68, \"maxInteger\": 4294967295}'>\n          This specifies the time interval from address assignment until the\n          client begins trying to rebind its address.  The DHCPv4 option code\n          for this option is 59.\n        </column>\n\n        <column name=\"options\" key=\"arp_cache_timeout\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 255}'>\n          The DHCPv4 option code for this option is 35. This option\n          specifies the timeout in seconds for ARP cache entries.\n        </column>\n\n        <column name=\"options\" key=\"tcp_keepalive_interval\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 255}'>\n          The DHCPv4 option code for this option is 38. This option\n          specifies the interval that the client TCP should wait before\n          sending a keepalive message on a TCP connection.\n        </column>\n\n        <column name=\"options\" key=\"netbios_node_type\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 255}'>\n          <p>\n            The DHCPv4 option code for this option is 46.\n          </p>\n        </column>\n      </group>\n\n      <group title=\"String DHCP Options\">\n        <p>\n          These options accept a string value.\n        </p>\n\n        <column name=\"options\" key=\"wpad\">\n          <p>\n            The DHCPv4 option code for this option is 252. This option is used\n            as part of web proxy auto discovery to provide a URL for a web\n            proxy.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"bootfile_name\">\n          <p>\n            The DHCPv4 option code for this option is 67. This option is used\n            to identify a bootfile.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"path_prefix\">\n          <p>\n            The DHCPv4 option code for this option is 210. In PXELINUX'\n            case this option is used to set a common path prefix,\n            instead of deriving it from the bootfile name.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"tftp_server_address\">\n          <p>\n            The DHCPv4 option code for this option is 150. The option\n            contains one or more IPv4 addresses that the client MAY\n            use. This option is Cisco proprietary, the IEEE standard\n            that matches with this requirement is option 66 (tftp_server).\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"hostname\">\n          <p>\n            The DHCPv4 option code for this option is 12.\n            If set, indicates the DHCPv4 option \"Hostname\".\n            Alternatively, this option can be configured in\n            <ref column=\"options:hostname\" table=\"Logical_Switch_Port\"\n            db=\"OVN_NB\"/> column in table <ref table=\"Logical_Switch_Port\"/>.\n            If Hostname option value is set in both conflicting\n            <ref table=\"Logical_Switch_Port\"/> and\n            <ref table=\"DHCP_Options\"/> tables,\n            <ref table=\"Logical_Switch_Port\"/> takes precedence.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"domain_name\">\n          <p>\n            The DHCPv4 option code for this option is 15. This option\n            specifies the domain name that client should use when\n            resolving hostnames via the Domain Name System.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"bootfile_name_alt\">\n          <p>\n          </p>\n            \"bootfile_name_alt\" option is used to support iPXE.\n            When both \"bootfile_name\" and \"bootfile_name_alt\" are provided\n            by the CMS, \"bootfile_name\" will be used for option 67 if the\n            dhcp request contains etherboot option (175), otherwise\n            \"bootfile_name_alt\" will be used.\n        </column>\n\n        <column name=\"options\" key=\"broadcast_address\">\n          <p>\n            The DHCPv4 option code for this option is 28. This option\n            specifies the IP address used as a broadcast address.\n          </p>\n        </column>\n      </group>\n\n      <group title=\"DHCP Options of type host_id\">\n        <p>\n          These options accept either an IPv4 address or a string value.\n        </p>\n\n        <column name=\"options\" key=\"tftp_server\">\n          <p>\n            The DHCPv4 option code for this option is 66.\n          </p>\n        </column>\n      </group>\n\n      <group title=\" DHCP Options of type domains\">\n        <p>\n          These options accept string value which is a comma separated\n          list of domain names. The domain names are encoded based on RFC 1035.\n        </p>\n\n        <column name=\"options\" key=\"domain_search_list\">\n          <p>\n            The DHCPv4 option code for this option is 119.\n          </p>\n        </column>\n      </group>\n    </group>\n\n    <group title=\"DHCPv6 options\">\n      <p>\n        OVN also implements native DHCPv6 support. The CMS should define\n        the set of DHCPv6 options as key/value pairs. The define DHCPv6\n        options will be included in the DHCPv6 response to the DHCPv6\n        Solicit/Request/Confirm packet from the logical ports having the\n        IPv6 addresses in the <ref column=\"cidr\"/>.\n      </p>\n\n      <group title=\"Mandatory DHCPv6 options\">\n        <p>\n          The following options must be defined.\n        </p>\n\n        <column name=\"options\" key=\"server_id\">\n          <p>\n            The Ethernet address for the DHCP server to use. This is also\n            included in the DHCPv6 reply as option 2, ``Server Identifier''\n            to carry a DUID identifying a server between a client and a server.\n            <code>ovn-controller</code> defines DUID based on\n            Link-layer Address [DUID-LL].\n          </p>\n        </column>\n      </group>\n\n      <group title=\"IPv6 DHCPv6 options\">\n        <p>\n          Below are the supported DHCPv6 options whose values are an IPv6\n          address, e.g. <code>aef0::4</code>.  Some options accept multiple\n          IPv6 addresses enclosed within curly braces, e.g. <code>{aef0::4,\n          aef0::5}</code>. Please refer to RFC 3315 for more details on\n          DHCPv6 options and their codes.\n        </p>\n\n        <column name=\"options\" key=\"dns_server\">\n          <p>\n            The DHCPv6 option code for this option is 23. This option specifies\n            the DNS servers that the VM should use.\n          </p>\n        </column>\n      </group>\n\n      <group title=\"String DHCPv6 options\">\n        <p>\n          These options accept string values.\n        </p>\n\n        <column name=\"options\" key=\"domain_search\">\n          <p>\n            The DHCPv6 option code for this option is 24. This option specifies\n            the domain search list the client should use to resolve hostnames\n            with DNS.\n          </p>\n\n          <p>\n            Example: <code>\"ovn.org\"</code>.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"dhcpv6_stateless\">\n          <p>\n            This option specifies the OVN native DHCPv6 will work in stateless\n            mode, which means OVN native DHCPv6 will not offer IPv6 addresses\n            for VM/VIF ports, but only reply other configurations, such as\n            DNS and domain search list. When setting this option with string\n            value \"true\", VM/VIF will configure IPv6 addresses by stateless\n            way. Default value for this option is false.\n          </p>\n        </column>\n      </group>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Connection\" title=\"OVSDB client connections.\">\n    <p>\n      Configuration for a database connection to an Open vSwitch database\n      (OVSDB) client.\n    </p>\n\n    <p>\n      This table primarily configures the Open vSwitch database server\n      (<code>ovsdb-server</code>).\n    </p>\n\n    <p>\n      The Open vSwitch database server can initiate and maintain active\n      connections to remote clients.  It can also listen for database\n      connections.\n    </p>\n\n    <group title=\"Core Features\">\n      <column name=\"target\">\n        <p>Connection methods for clients.</p>\n        <p>\n          The following connection methods are currently supported:\n        </p>\n        <dl>\n          <dt><code>ssl:<var>host</var></code>[<code>:<var>port</var></code>]</dt>\n          <dd>\n            <p>\n              The specified SSL <var>port</var> on the host at the given\n              <var>host</var>, which can either be a DNS name (if built with\n              unbound library) or an IP address. A valid SSL configuration must\n              be provided when this form is used, this configuration can be\n              specified via command-line options or the <ref table=\"SSL\"/> table.\n            </p>\n            <p>\n              If <var>port</var> is not specified, it defaults to 6640.\n            </p>\n            <p>\n              SSL support is an optional feature that is not always\n              built as part of Open vSwitch.\n            </p>\n          </dd>\n\n          <dt><code>tcp:<var>host</var></code>[<code>:<var>port</var></code>]</dt>\n          <dd>\n            <p>\n              The specified TCP <var>port</var> on the host at the given\n              <var>host</var>, which can either be a DNS name (if built with\n              unbound library) or an IP address.  If <var>host</var> is an IPv6\n              address, wrap it in square brackets, e.g. <code>tcp:[::1]:6640</code>.\n            </p>\n            <p>\n              If <var>port</var> is not specified, it defaults to 6640.\n            </p>\n          </dd>\n          <dt><code>pssl:</code>[<var>port</var>][<code>:<var>host</var></code>]</dt>\n          <dd>\n            <p>\n              Listens for SSL connections on the specified TCP <var>port</var>.\n              Specify 0 for <var>port</var> to have the kernel automatically\n              choose an available port.  If <var>host</var>, which can either\n              be a DNS name (if built with unbound library) or an IP address,\n              is specified, then connections are restricted to the resolved or\n              specified local IPaddress (either IPv4 or IPv6 address).  If\n              <var>host</var> is an IPv6 address, wrap in square brackets,\n              e.g. <code>pssl:6640:[::1]</code>.  If <var>host</var> is not\n              specified then it listens only on IPv4 (but not IPv6) addresses.\n              A valid SSL configuration must be provided when this form is used,\n             this can be specified either via command-line options or the\n             <ref table=\"SSL\"/> table.\n            </p>\n            <p>\n              If <var>port</var> is not specified, it defaults to 6640.\n            </p>\n            <p>\n              SSL support is an optional feature that is not always built as\n              part of Open vSwitch.\n            </p>\n          </dd>\n          <dt><code>ptcp:</code>[<var>port</var>][<code>:<var>host</var></code>]</dt>\n          <dd>\n            <p>\n              Listens for connections on the specified TCP <var>port</var>.\n              Specify 0 for <var>port</var> to have the kernel automatically\n              choose an available port.  If <var>host</var>, which can either\n              be a DNS name (if built with unbound library) or an IP address,\n              is specified, then connections are restricted to the resolved or\n              specified local IP address (either IPv4 or IPv6 address).  If\n              <var>host</var> is an IPv6 address, wrap it in square brackets,\n              e.g. <code>ptcp:6640:[::1]</code>.  If <var>host</var> is not\n              specified then it listens only on IPv4 addresses.\n            </p>\n            <p>\n              If <var>port</var> is not specified, it defaults to 6640.\n            </p>\n          </dd>\n        </dl>\n        <p>When multiple clients are configured, the <ref column=\"target\"/>\n        values must be unique.  Duplicate <ref column=\"target\"/> values yield\n        unspecified results.</p>\n      </column>\n    </group>\n\n    <group title=\"Client Failure Detection and Handling\">\n      <column name=\"max_backoff\">\n        Maximum number of milliseconds to wait between connection attempts.\n        Default is implementation-specific.\n      </column>\n\n      <column name=\"inactivity_probe\">\n        Maximum number of milliseconds of idle time on connection to the client\n        before sending an inactivity probe message.  If Open vSwitch does not\n        communicate with the client for the specified number of seconds, it\n        will send a probe.  If a response is not received for the same\n        additional amount of time, Open vSwitch assumes the connection has been\n        broken and attempts to reconnect.  Default is implementation-specific.\n        A value of 0 disables inactivity probes.\n      </column>\n    </group>\n\n    <group title=\"Status\">\n      <p>\n        Key-value pair of <ref column=\"is_connected\"/> is always updated.\n        Other key-value pairs in the status columns may be updated depends\n        on the <ref column=\"target\"/> type.\n      </p>\n\n      <p>\n        When <ref column=\"target\"/> specifies a connection method that\n        listens for inbound connections (e.g. <code>ptcp:</code> or\n        <code>punix:</code>), both <ref column=\"n_connections\"/> and\n        <ref column=\"is_connected\"/> may also be updated while the\n        remaining key-value pairs are omitted.\n      </p>\n\n      <p>\n        On the other hand, when <ref column=\"target\"/> specifies an\n        outbound connection, all key-value pairs may be updated, except\n        the above-mentioned two key-value pairs associated with inbound\n        connection targets. They are omitted.\n      </p>\n\n    <column name=\"is_connected\">\n        <code>true</code> if currently connected to this client,\n        <code>false</code> otherwise.\n      </column>\n\n      <column name=\"status\" key=\"last_error\">\n        A human-readable description of the last error on the connection\n        to the manager; i.e. <code>strerror(errno)</code>.  This key\n        will exist only if an error has occurred.\n      </column>\n\n      <column name=\"status\" key=\"state\"\n              type='{\"type\": \"string\", \"enum\": [\"set\", [\"VOID\", \"BACKOFF\", \"CONNECTING\", \"ACTIVE\", \"IDLE\"]]}'>\n        <p>\n          The state of the connection to the manager:\n        </p>\n        <dl>\n          <dt><code>VOID</code></dt>\n          <dd>Connection is disabled.</dd>\n\n          <dt><code>BACKOFF</code></dt>\n          <dd>Attempting to reconnect at an increasing period.</dd>\n\n          <dt><code>CONNECTING</code></dt>\n          <dd>Attempting to connect.</dd>\n\n          <dt><code>ACTIVE</code></dt>\n          <dd>Connected, remote host responsive.</dd>\n\n          <dt><code>IDLE</code></dt>\n          <dd>Connection is idle.  Waiting for response to keep-alive.</dd>\n        </dl>\n        <p>\n          These values may change in the future.  They are provided only for\n          human consumption.\n        </p>\n      </column>\n\n      <column name=\"status\" key=\"sec_since_connect\"\n              type='{\"type\": \"integer\", \"minInteger\": 0}'>\n        The amount of time since this client last successfully connected\n        to the database (in seconds). Value is empty if client has never\n        successfully been connected.\n      </column>\n\n      <column name=\"status\" key=\"sec_since_disconnect\"\n              type='{\"type\": \"integer\", \"minInteger\": 0}'>\n        The amount of time since this client last disconnected from the\n        database (in seconds). Value is empty if client has never\n        disconnected.\n      </column>\n\n      <column name=\"status\" key=\"locks_held\">\n        Space-separated list of the names of OVSDB locks that the connection\n        holds.  Omitted if the connection does not hold any locks.\n      </column>\n\n      <column name=\"status\" key=\"locks_waiting\">\n        Space-separated list of the names of OVSDB locks that the connection is\n        currently waiting to acquire.  Omitted if the connection is not waiting\n        for any locks.\n      </column>\n\n      <column name=\"status\" key=\"locks_lost\">\n        Space-separated list of the names of OVSDB locks that the connection\n        has had stolen by another OVSDB client.  Omitted if no locks have been\n        stolen from this connection.\n      </column>\n\n      <column name=\"status\" key=\"n_connections\"\n              type='{\"type\": \"integer\", \"minInteger\": 2}'>\n        When <ref column=\"target\"/> specifies a connection method that\n        listens for inbound connections (e.g. <code>ptcp:</code> or\n        <code>pssl:</code>) and more than one connection is actually active,\n        the value is the number of active connections.  Otherwise, this\n        key-value pair is omitted.\n      </column>\n\n      <column name=\"status\" key=\"bound_port\" type='{\"type\": \"integer\"}'>\n        When <ref column=\"target\"/> is <code>ptcp:</code> or\n        <code>pssl:</code>, this is the TCP port on which the OVSDB server is\n        listening.  (This is particularly useful when <ref\n        column=\"target\"/> specifies a port of 0, allowing the kernel to\n        choose any available port.)\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      The overall purpose of these columns is described under <code>Common\n      Columns</code> at the beginning of this document.\n\n      <column name=\"external_ids\"/>\n      <column name=\"other_config\"/>\n    </group>\n  </table>\n  <table name=\"DNS\" title=\"Native DNS resolution\">\n    <p>\n      Each row in this table stores the DNS records. The\n      <ref table=\"Logical_Switch\"/> table's <ref table=\"Logical_Switch\"\n      column=\"dns_records\"/> references these records.\n    </p>\n\n    <column name=\"records\">\n      Key-value pair of DNS records with <code>DNS query name</code> as the key\n      and value as a string of IP address(es) separated by comma or space.\n\n      For PTR requests, the key-value pair can be\n      <code>Reverse IPv4 address.in-addr.arpa</code> and the value\n      <code>DNS domain name</code>.  For IPv6 addresses, the key\n      has to be <code>Reverse IPv6 address.ip6.arpa</code>.\n\n      <p><b>Example: </b> \"vm1.ovn.org\" = \"10.0.0.4 aef0::4\"</p>\n      <p><b>Example: </b> \"4.0.0.10.in-addr.arpa\" = \"vm1.ovn.org\"</p>\n    </column>\n\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n  <table name=\"SSL\">\n    SSL configuration for ovn-nb database access.\n\n    <column name=\"private_key\">\n      Name of a PEM file containing the private key used as the switch's\n      identity for SSL connections to the controller.\n    </column>\n\n    <column name=\"certificate\">\n      Name of a PEM file containing a certificate, signed by the\n      certificate authority (CA) used by the controller and manager,\n      that certifies the switch's private key, identifying a trustworthy\n      switch.\n    </column>\n\n    <column name=\"ca_cert\">\n      Name of a PEM file containing the CA certificate used to verify\n      that the switch is connected to a trustworthy controller.\n    </column>\n\n    <column name=\"bootstrap_ca_cert\">\n      If set to <code>true</code>, then Open vSwitch will attempt to\n      obtain the CA certificate from the controller on its first SSL\n      connection and save it to the named PEM file. If it is successful,\n      it will immediately drop the connection and reconnect, and from then\n      on all SSL connections must be authenticated by a certificate signed\n      by the CA certificate thus obtained.  <em>This option exposes the\n      SSL connection to a man-in-the-middle attack obtaining the initial\n      CA certificate.</em>  It may still be useful for bootstrapping.\n    </column>\n\n    <column name=\"ssl_protocols\">\n      List of SSL protocols to be enabled for SSL connections. The default\n      when this option is omitted is <code>TLSv1,TLSv1.1,TLSv1.2</code>.\n    </column>\n\n    <column name=\"ssl_ciphers\">\n      List of ciphers (in OpenSSL cipher string format) to be supported\n      for SSL connections. The default when this option is omitted is\n      <code>HIGH:!aNULL:!MD5</code>.\n    </column>\n\n    <group title=\"Common Columns\">\n      The overall purpose of these columns is described under <code>Common\n      Columns</code> at the beginning of this document.\n\n      <column name=\"external_ids\"/>\n    </group>\n  </table>\n  <table name=\"Gateway_Chassis\">\n    <p>\n      Association of a chassis to a logical router port. The traffic\n      going out through an specific router port will be redirected to a\n      chassis, or a set of them in high availability configurations.\n    </p>\n\n    <column name=\"name\">\n      <p>\n        Name of the <ref table=\"Gateway_Chassis\"/>.\n      </p>\n      <p>\n        A suggested, but not required naming convention is\n        <code>${port_name}_${chassis_name}</code>.\n      </p>\n    </column>\n\n    <column name=\"chassis_name\">\n      <p>\n        Name of the chassis that we want to redirect traffic through for the\n        associated logical router port.  The value must match the\n        <ref db=\"OVN_Southbound\" table=\"Chassis\" column=\"name\"/> column\n        of the <ref db=\"OVN_Southbound\" table=\"Chassis\"/> table in the\n        <ref db=\"OVN_Southbound\"/> database.\n      </p>\n    </column>\n\n    <column name=\"priority\">\n      <p>\n        This is the priority of a chassis among all\n        <ref table=\"Gateway_Chassis\"/> belonging to the same logical router\n        port.\n      </p>\n    </column>\n\n    <column name=\"options\">\n      Reserved for future use.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"HA_Chassis_Group\">\n    <p>\n      Table representing a group of chassis which can provide high availability\n      services. Each chassis in the group is represented by the table\n      <ref table=\"HA_Chassis\"/>. The HA chassis with highest priority will\n      be the master of this group. If the master chassis failover is detected,\n      the HA chassis with the next higher priority takes over the\n      responsibility of providing the HA. If a distributed gateway router port\n      references a row in this table, then the master HA chassis in this group\n      provides the gateway functionality.\n    </p>\n\n    <column name=\"name\">\n      Name of the <ref table=\"HA_Chassis_Group\"/>. Name should be unique.\n    </column>\n\n    <column name=\"ha_chassis\">\n      A list of HA chassis which belongs to this group.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"HA_Chassis\">\n    <column name=\"chassis_name\">\n      <p>\n        Name of the chassis which is part of the HA chassis group.\n        The value must match the\n        <ref db=\"OVN_Southbound\" table=\"Chassis\" column=\"name\"/> column\n        of the <ref db=\"OVN_Southbound\" table=\"Chassis\"/> table in the\n        <ref db=\"OVN_Southbound\"/> database.\n      </p>\n    </column>\n\n    <column name=\"priority\">\n      <p>\n        Priority of the chassis. Chassis with highest priority will be\n        the master.\n      </p>\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"BFD\">\n    <p>\n      Contains BFD parameter for ovn-controller BFD configuration.\n      OVN BFD implementation is used to provide detection of failures in the\n      path between adjacent forwarding engines, including the OVN interfaces.\n      OVN BFD provides link status info to OVN northd in order to update\n      logical flows according to the status of BFD endpoints. In the current\n      implementation OVN BFD is used to check next-hop status for ECMP routes.\n      Please note BFD table refers to OVN BFD implementation and not to OVS\n      legacy one.\n    </p>\n\n    <group title=\"Configuration\">\n      <p>\n        <code>ovn-northd</code> reads configuration from these columns.\n      </p>\n\n      <column name=\"logical_port\">\n        OVN logical port when BFD engine is running.\n      </column>\n\n      <column name=\"dst_ip\">\n        BFD peer IP address.\n      </column>\n\n      <column name=\"min_tx\">\n        This is the minimum interval, in milliseconds, that the local\n        system would like to use when transmitting BFD Control packets,\n        less any jitter applied. The value zero is reserved. Default\n        value is 1000 ms.\n      </column>\n\n      <column name=\"min_rx\">\n        This is the minimum interval, in milliseconds, between received\n        BFD Control packets that this system is capable of supporting,\n        less any jitter applied by the sender. If this value is zero,\n        the transmitting system does not want the remote system to send\n        any periodic BFD Control packets.\n      </column>\n\n      <column name=\"detect_mult\">\n        Detection time multiplier.  The negotiated transmit interval,\n        multiplied by this value, provides the Detection Time for the\n        receiving system in Asynchronous mode. Default value is 5.\n      </column>\n\n      <column name=\"options\">\n        Reserved for future use.\n      </column>\n\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n\n    <group title=\"Status Reporting\">\n      <p>\n        <code>ovn-northd</code> writes BFD status into these columns.\n      </p>\n\n      <column name=\"status\">\n        <p>\n          BFD port logical states. Possible values are:\n          <ul>\n            <li>\n              <code>admin_down</code>\n            </li>\n            <li>\n              <code>down</code>\n            </li>\n            <li>\n              <code>init</code>\n            </li>\n            <li>\n              <code>up</code>\n            </li>\n          </ul>\n        </p>\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Static_MAC_Binding\">\n    <p>\n      Each record represents a Static_MAC_Binding entry for a logical router.\n    </p>\n\n    <group title=\"Configuration\">\n      <p>\n        <code>ovn-northd</code> reads configuration from these columns\n        and propagates the value to SBDB.\n      </p>\n\n      <column name=\"logical_port\">\n        The logical router port for the binding.\n      </column>\n\n      <column name=\"ip\">\n        The bound IP address.\n      </column>\n\n      <column name=\"mac\">\n        The Ethernet address to which the IP is bound.\n      </column>\n\n      <column name=\"override_dynamic_mac\">\n        Override dynamically learnt MACs.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Chassis_Template_Var\">\n    <p>\n      One record per chassis, each containing a map, <code>variables</code>,\n      between template variable names and their value for that specific\n      chassis.  A template variable has a name and potentially different\n      values on different hypervisors in the OVN cluster.  For example,\n      two rows, <code>R1 = (.chassis=C1, variables={(N: V1)}</code> and\n      <code>R2 = (.chassis=C2, variables={(N: V2)}</code> will make\n      <code>ovn-controller</code> running on chassis <code>C1</code> and\n      <code>C2</code> interpret the token <code>N</code> either as\n      <code>V1</code> (on <code>C1</code>) or as <code>V2</code> (on\n      <code>C2</code>).  Users can refer to template variables from\n      within other logical components, e.g., within ACL, QoS or\n      Logical_Router_Policy matches or from Load_Balancer VIP and\n      backend definitions.\n    </p>\n    <p>\n      If a template variable is referenced on a chassis for which that\n      variable is not defined then <code>ovn-controller</code> running\n      on that chassis will just interpret it as a raw string literal.\n    </p>\n    <column name=\"chassis\">\n      The chassis this set of variable values applies to.\n    </column>\n    <column name=\"variables\">\n      The set of variable values for a given chassis.\n    </column>\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n</database>\n", "AT_BANNER([OVN northd])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check from NBDB to SBDB])\novn_start\n\novn-nbctl create Logical_Router name=R1\novn-sbctl chassis-add gw1 geneve 127.0.0.1\novn-sbctl chassis-add gw2 geneve 1.2.4.8\n\n# Connect alice to R1 as distributed router gateway port on hv2\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24\n\novn-nbctl --wait=sb \\\n    --id=@gc0 create Gateway_Chassis name=alice_gw1 \\\n                                     chassis_name=gw1 \\\n                                     priority=20 -- \\\n    --id=@gc1 create Gateway_Chassis name=alice_gw2 \\\n                                     chassis_name=gw2 \\\n                                     priority=10 -- \\\n    set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]'\n\nnb_gwc1_uuid=`ovn-nbctl --bare --columns _uuid find Gateway_Chassis name=\"alice_gw1\"`\n\n# With the new ha_chassis_group table added, there should be no rows in\n# gateway_chassis table in SB DB.\ncheck_row_count Gateway_Chassis 0\n\n# There should be one ha_chassis_group with the name \"alice\"\ncheck_row_count HA_Chassis_Group 1 name=alice\nha_chgrp_uuid=$(fetch_column HA_Chassis_Group _uuid name=alice)\ncheck_row_count Port_Binding 1 logical_port=cr-alice ha_chassis_group=$ha_chgrp_uuid\n\nha_ch=$(fetch_column HA_Chassis_Group ha_chassis name=alice)\ncheck_column \"$ha_ch\" HA_Chassis _uuid\n\novn-sbctl list ha_chassis_group\n\n# Delete chassis - gw2 in SB DB.\n# ovn-northd should not recreate ha_chassis rows\n# repeatedly when gw2 is deleted.\novn-sbctl chassis-del gw2\n\nha_ch_list=$(fetch_column HA_Chassis _uuid)\ncheck_column \"$ha_ch_list\" HA_Chassis _uuid\n\n# Add back the gw2 chassis\novn-sbctl chassis-add gw2 geneve 1.2.4.8\n\n# delete the 2nd Gateway_Chassis on NBDB for alice port\ncheck_column '' Port_Binding gateway_chassis logical_port=cr-alice\n\nha_ch=$(fetch_column HA_Chassis_Group ha_chassis)\ncheck_column \"$ha_ch\" HA_Chassis _uuid\n\n# delete the 2nd Gateway_Chassis on NBDB for alice port\novn-nbctl --wait=sb set Logical_Router_Port alice gateway_chassis=${nb_gwc1_uuid}\n\n# There should be only 1 row in ha_chassis SB DB table.\ncheck_row_count HA_Chassis 1\ncheck_row_count Gateway_Chassis 0\n\n# delete all the gateway_chassis on NBDB for alice port\novn-nbctl --wait=sb clear Logical_Router_Port alice gateway_chassis\n\n# expect that the ha_chassis doesn't exist anymore\ncheck_row_count HA_Chassis 0\ncheck_row_count Gateway_Chassis 0\ncheck_row_count Ha_Chassis_Group 0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check up state of VIF LSP])\novn_start\n\novn-nbctl ls-add S1\novn-nbctl --wait=sb lsp-add S1 S1-vm1\nwait_row_count nb:Logical_Switch_Port 1 name=S1-vm1 'up!=true'\n\novn-sbctl chassis-add hv1 geneve 127.0.0.1\novn-sbctl lsp-bind S1-vm1 hv1\nwait_row_count nb:Logical_Switch_Port 1 name=S1-vm1 'up=true'\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check up state of router LSP linked to a distributed LR])\novn_start\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01\novn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1\nAT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check up state of router LSP linked to a gateway LR])\novn_start\n\novn-sbctl chassis-add gw1 geneve 127.0.0.1\n\novn-nbctl create Logical_Router name=R1 options:chassis=gw1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01\novn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1\n\novn-sbctl lsp-bind S1-R1 gw1\nAT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check up state of router LSP linked to an LRP with set Gateway Chassis])\novn_start\n\novn-sbctl chassis-add gw1 geneve 127.0.0.1\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\novn-nbctl lrp-set-gateway-chassis R1-S1 gw1\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 router\novn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1\nAT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check LRP external id propagation to SBDB])\novn_start\n\novn-nbctl lr-add ro\novn-nbctl lrp-add ro lrp0 00:00:00:00:00:01 192.168.1.1/24\novn-nbctl --wait=sb set logical_router_port lrp0 external_ids=test=123\ncheck_column \"test=123\" sb:Port_Binding external_ids logical_port=lrp0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check IPv6 RA config propagation to SBDB])\novn_start\n\novn-nbctl lr-add ro\novn-nbctl lrp-add ro ro-sw 00:00:00:00:00:01 aef0:0:0:0:0:0:0:1/64\novn-nbctl ls-add sw\novn-nbctl lsp-add sw sw-ro\novn-nbctl lsp-set-type sw-ro router\novn-nbctl lsp-set-options sw-ro router-port=ro-sw\novn-nbctl lsp-set-addresses sw-ro 00:00:00:00:00:01\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:send_periodic=true\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=slaac\novn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:mtu=1280\n\nuuid=$(ovn-sbctl --columns=_uuid --bare find Port_Binding logical_port=ro-sw)\n\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_send_periodic],\n[0], [\"true\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_address_mode],\n[0], [slaac\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[0], [\"600\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[0], [\"200\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_mtu],\n[0], [\"1280\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_eth],\n[0], [\"00:00:00:00:00:01\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_addr],\n[0], [\"fe80::200:ff:fe00:1\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_prefixes],\n[0], [\"aef0::/64\"\n])\n\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=300\novn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=600\n\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[0], [\"300\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[0], [\"225\"\n])\n\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=300\novn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=250\n\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[0], [\"300\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[0], [\"225\"\n])\n\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=0\novn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=0\n\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[0], [\"4\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[0], [\"3\"\n])\n\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=3600\novn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=2400\n\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[0], [\"1800\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[0], [\"1350\"\n])\n\novn-nbctl --wait=sb set Logical_Router_port ro-sw ipv6_ra_configs:send_periodic=false\n\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_send_periodic],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_send_periodic\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_max_interval\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_min_interval\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_mtu],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_mtu\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_address_mode],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_address_mode\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_eth],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_src_eth\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_addr],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_src_addr\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_prefixes],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_prefixes\" in Port_Binding record \"${uuid}\" column options\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([test unixctl])\novn_init_db ovn-sb; ovn-sbctl init\novn_init_db ovn-nb; ovn-nbctl init\n\n# test unixctl option\nmkdir \"$ovs_base\"/northd\nas northd start_daemon NORTHD_TYPE --unixctl=\"$ovs_base\"/northd/NORTHD_TYPE[].ctl --ovnnb-db=unix:\"$ovs_base\"/ovn-nb/ovn-nb.sock --ovnsb-db=unix:\"$ovs_base\"/ovn-sb/ovn-sb.sock\novn-nbctl ls-add sw\novn-nbctl --wait=sb lsp-add sw p1\n# northd created with unixctl option successfully created port_binding entry\ncheck_row_count Port_Binding 1 logical_port=p1\nAT_CHECK([ovn-nbctl --wait=sb lsp-del p1])\n\n# ovs-appctl exit with unixctl option\nOVS_APP_EXIT_AND_WAIT_BY_TARGET([\"$ovs_base\"/northd/]NORTHD_TYPE[.ctl], [\"$ovs_base\"/northd/]NORTHD_TYPE[.pid])\n\n# Check no port_binding entry for new port as ovn-northd is not running\n#\n# 142 is 128+14, the exit status that the shell reports when a\n# process exits due to SIGARLM (signal 14).\novn-nbctl lsp-add sw p2\nAT_CHECK([ovn-nbctl --timeout=10 --wait=sb sync], [142], [], [ignore])\ncheck_row_count Port_Binding 0 logical_port=p2\n\n# test default unixctl path\nas northd start_daemon NORTHD_TYPE --ovnnb-db=unix:\"$ovs_base\"/ovn-nb/ovn-nb.sock --ovnsb-db=unix:\"$ovs_base\"/ovn-sb/ovn-sb.sock\novn-nbctl --wait=sb lsp-add sw p3\n# northd created with default unixctl path successfully created port_binding entry\ncheck_row_count Port_Binding 1 logical_port=p3\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check HA_Chassis_Group propagation from NBDB to SBDB])\novn_start\n\ncheck ovn-nbctl --wait=sb ha-chassis-group-add hagrp1\n\n# ovn-northd should not create HA chassis group and HA chassis rows\n# unless the HA chassis group in OVN NB DB is associated to\n# a logical router port or logical port of type external.\ncheck_row_count HA_Chassis_Group 0 name=hagrp1\n\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 30\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 20\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch3 10\n\n# There should be no HA_Chassis rows in SB DB.\ncheck_row_count HA_Chassis 0\n\n# Add chassis ch1.\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.2\n\nwait_row_count Chassis 1 name=ch1\n\n# There should be no HA_Chassis rows\ncheck_row_count HA_Chassis 0\n\n# Create a logical router port and attach ha chassis group.\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl --wait=sb lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24\n\nhagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp1`\necho \"hagrp1_uuid=$hagrp1_uuid\"\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-public ha_chassis_group=$hagrp1_uuid\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\n\ncheck_row_count HA_Chassis 3\n\n# ovn-northd has a weird history regarding HA_Chassis and missing\n# Chassis records, see commit f879850b5f2c (\"ovn-northd: Fix the\n# HA_Chassis sync issue in OVN SB DB\").\n#\n# Make sure that ovn-northd doesn't recreate the ha_chassis\n# records if the chassis record is missing in SB DB.\nha_ch_list=$(fetch_column HA_Chassis _uuid)\ncheck_column \"$ha_ch_list\" HA_Chassis _uuid\n\n# 2 HA chassis should be created with 'chassis' column empty because\n# we have not added hv1 and hv2 chassis to the SB DB.\ncheck_row_count HA_Chassis 2 'chassis=[[]]'\n\n# We should have 1 ha chassis with 'chassis' column set for hv1\ncheck_row_count HA_Chassis 1 'chassis!=[[]]'\n\n# Create another logical router port and associate to the same ha_chasis_group\ncheck ovn-nbctl lr-add lr1\ncheck ovn-nbctl lrp-add lr1 lr1-public 00:00:20:20:12:14 182.168.0.100/24\n\ncheck ovn-nbctl set logical_router_port lr1-public ha_chassis_group=$hagrp1_uuid\n\n# We should still have 1 HA chassis group and 3 HA chassis in SB DB.\nwait_row_count HA_Chassis_Group 1 name=hagrp1\ncheck_row_count HA_Chassis 3\n\n# Change the priority of ch1 - ha chassis in NB DB. It should get\n# reflected in SB DB.\novn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 100\n\nwait_row_count HA_Chassis 1 priority=100\n\n# Delete ch1 HA chassis in NB DB.\novn-nbctl --wait=sb ha-chassis-group-remove-chassis hagrp1 ch1\n\nwait_row_count HA_Chassis 2\n\n# Add back the ha chassis\novn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 40\nwait_row_count HA_Chassis 3\n\n# Delete lr0-public. We should still have 1 HA chassis group and\n# 3 HA chassis in SB DB.\novn-nbctl --wait=sb lrp-del lr0-public\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\nwait_row_count HA_Chassis 3\n\n# Delete lr1-public. There should be no HA chassis group in SB DB.\novn-nbctl --wait=sb lrp-del lr1-public\n\nwait_row_count HA_Chassis_Group 0 name=hagrp1\nwait_row_count HA_Chassis 0\n\n# Add lr0-public again\novn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24\novn-nbctl set logical_router_port lr0-public ha_chassis_group=$hagrp1_uuid\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\nwait_row_count HA_Chassis 3\n\n# Create a Gateway chassis. ovn-northd should ignore this.\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis lr0-public ch1 20\n\n# There should be only 1 HA chassis group in SB DB with the\n# name hagrp1.\nwait_row_count HA_Chassis_Group 1\nwait_row_count HA_Chassis_Group 1 name=hagrp1\nwait_row_count HA_Chassis 3\n\n# Now delete HA chassis group. ovn-northd should create HA chassis group\n# with the Gateway chassis name\novn-nbctl clear logical_router_port lr0-public ha_chassis_group\novn-nbctl ha-chassis-group-del hagrp1\n\nwait_row_count HA_Chassis_Group 0 name=hagrp1\nwait_row_count HA_Chassis_Group 1 name=lr0-public\nwait_row_count HA_Chassis 1\n\novn-nbctl lrp-set-gateway-chassis lr0-public ch2 10\n\nwait_row_count HA_Chassis_Group 1 name=lr0-public\n\novn-sbctl --bare --columns _uuid find ha_chassis\nwait_row_count HA_Chassis 2\n\n# Test if 'ref_chassis' column is properly set or not in\n# SB DB ha_chassis_group.\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1\n\ncheck ovn-sbctl chassis-add ch2 geneve 127.0.0.3\ncheck ovn-sbctl chassis-add ch3 geneve 127.0.0.4\ncheck ovn-sbctl chassis-add comp1 geneve 127.0.0.5\ncheck ovn-sbctl chassis-add comp2 geneve 127.0.0.6\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:20:20:12:14 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw0-lr0 router-port=lr0-sw0\n\novn-sbctl lsp-bind sw0-p1 comp1\nwait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 up=true\n\ncomp1_ch_uuid=$(fetch_column Chassis _uuid name=comp1)\ncomp2_ch_uuid=$(fetch_column Chassis _uuid name=comp2)\nch2_ch_uuid=$comp1_ch_uuid\n\n# Check ref_chassis.\necho \"comp1_ch_uuid = $comp1_ch_uuid\"\nwait_column \"$comp1_ch_uuid\" HA_Chassis_Group ref_chassis\n\n# unbind sw0-p1\novn-sbctl lsp-unbind sw0-p1\nwait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 up=false\nwait_column \"\" HA_Chassis_Group ref_chassis\n\n# Bind sw0-p1 in comp2\novn-sbctl lsp-bind sw0-p1 comp2\nwait_column \"$comp2_ch_uuid\" HA_Chassis_Group ref_chassis\n\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-p1\novn-nbctl lr-add lr1\novn-nbctl lrp-add lr1 lr1-sw1 00:00:20:20:12:15 20.0.0.1/24\novn-nbctl lsp-add sw1 sw1-lr1\novn-nbctl lsp-set-type sw1-lr1 router\novn-nbctl lsp-set-addresses sw1-lr1 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw1-lr1 router-port=lr1-sw1\n\n# Bind sw1-p1 in comp1.\ncheck ovn-sbctl lsp-bind sw1-p1 comp1\n# Wait until sw1-p1 is up\nwait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 up=true\n\n# sw1-p1 is not connected to lr0. So comp1 should not be in 'ref_chassis'\nwait_column \"$comp2_ch_uuid\" HA_Chassis_Group ref_chassis\n\n# Now attach sw0 to lr1\ncheck ovn-nbctl lrp-add lr1 lr1-sw0 00:00:20:20:12:16 10.0.0.10/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr1\ncheck ovn-nbctl lsp-set-type sw0-lr1 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr1 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw0-lr1 router-port=lr1-sw0\n\n# Both comp1 and comp2 should be in 'ref_chassis' as sw1 is indirectly\n# connected to lr0\nexp_ref_ch_list=\"$comp1_ch_uuid $comp2_ch_uuid\"\n\nwait_column \"$exp_ref_ch_list\" HA_Chassis_Group ref_chassis\n\n# Unind sw1-p1. comp2 should not be in the ref_chassis.\novn-sbctl lsp-unbind sw1-p1\nwait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 up=false\nwait_column \"$comp2_ch_uuid\" HA_Chassis_Group ref_chassis\n\n# Create sw2 and attach it to lr2\ncheck ovn-nbctl ls-add sw2\ncheck ovn-nbctl lsp-add sw2 sw2-p1\ncheck ovn-nbctl lr-add lr2\ncheck ovn-nbctl lrp-add lr2 lr2-sw2 00:00:20:20:12:17 30.0.0.1/24\ncheck ovn-nbctl lsp-add sw2 sw2-lr2\ncheck ovn-nbctl lsp-set-type sw2-lr2 router\ncheck ovn-nbctl lsp-set-addresses sw2-lr2 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw2-lr2 router-port=lr2-sw2\n\n# Bind sw2-p1 to comp1\ncheck ovn-sbctl lsp-bind sw2-p1 comp1\n# Wait until sw2-p1 is up\nwait_row_count nb:Logical_Switch_Port 1 name=sw2-p1 up=true\n\n# sw2-p1 is not connected to lr0. So comp1 should not be in 'ref_chassis'\nwait_column \"$comp2_ch_uuid\" HA_Chassis_Group ref_chassis\n\n# Now attach sw1 to lr2. With this sw2-p1 is indirectly connected to lr0.\ncheck ovn-nbctl lrp-add lr2 lr2-sw1 00:00:20:20:12:18 20.0.0.10/24\ncheck ovn-nbctl lsp-add sw1 sw1-lr2\ncheck ovn-nbctl lsp-set-type sw1-lr2 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr2 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw1-lr2 router-port=lr2-sw1\n\n# sw2-p1 is indirectly connected to lr0. So comp1 (and comp2) should be in\n# 'ref_chassis'\nwait_column \"$exp_ref_ch_list\" HA_Chassis_Group ref_chassis\n\n# Create sw0-p2 and bind it to comp1\ncheck ovn-nbctl --wait=sb lsp-add sw0 sw0-p2\novn-sbctl lsp-bind sw0-p2 comp1\nwait_row_count nb:Logical_Switch_Port 1 name=sw0-p2 up=true\nwait_column \"$exp_ref_ch_list\" HA_Chassis_Group ref_chassis\n\n# unbind sw0-p2\novn-sbctl lsp-unbind sw0-p2\nwait_row_count nb:Logical_Switch_Port 1 name=sw0-p2 up=false\nwait_column \"$exp_ref_ch_list\" HA_Chassis_Group ref_chassis\n\n# Delete lr1-sw0. comp1 should be deleted from ref_chassis as there is no link\n# from sw1 and sw2 to lr0.\ncheck ovn-nbctl lrp-del lr1-sw0\n\nwait_column \"$comp2_ch_uuid\" HA_Chassis_Group ref_chassis\n\n# Delete one of the gateway chassises making the ha_chassis_group has only one\n# chassis. In this case ref_chassis field should be empty for this\n# ha_chassis_group. (ref_chassis is calculated only if there are more than 1\n# chassises in the ha_chassis_group.\ncheck ovn-nbctl --wait=sb lrp-del-gateway-chassis lr0-public ch2\nwait_column \"\" HA_Chassis_Group ref_chassis\n\n# Set redirect-chassis option to lr0-public. It should be ignored\n# (because redirect-chassis is obsolete).\ncheck ovn-nbctl set logical_router_port lr0-public options:redirect-chassis=ch1\n\nwait_row_count HA_Chassis_Group 1\nwait_row_count HA_Chassis_Group 1 name=lr0-public\n\nwait_row_count HA_Chassis 1\n\n# Delete the gateway chassis.\ncheck ovn-nbctl clear logical_router_port lr0-public gateway_chassis\n\nwait_row_count HA_Chassis_Group 0\ncheck_row_count HA_Chassis 0\n\n# Delete old sw0.\ncheck ovn-nbctl --wait=sb ls-del sw0\n\n# Create external logical ports and associate ha_chassis_group\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-pext1\ncheck ovn-nbctl lsp-add sw0 sw0-pext2\ncheck ovn-nbctl lsp-add sw0 sw0-p1\n\ncheck ovn-nbctl lsp-set-addresses sw0-pext1 \"00:00:00:00:00:03 10.0.0.3\"\ncheck ovn-nbctl lsp-set-addresses sw0-pext2 \"00:00:00:00:00:03 10.0.0.4\"\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"00:00:00:00:00:03 10.0.0.5\"\n\ncheck ovn-nbctl --wait=sb ha-chassis-group-add hagrp1\n\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 30\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 20\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch3 10\n\n# ovn-northd should not create HA chassis group and HA chassis rows\n# unless the HA chassis group in OVN NB DB is associated to\n# a logical router port or logical port of type external.\nwait_row_count HA_Chassis_Group 0\ncheck_row_count HA_Chassis 0\n\nhagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group \\\nname=hagrp1`\n\n# The type of the lsp - sw0-pext1 is still not set to external.\n# So ha_chassis_group should be ignored.\novn-nbctl set logical_switch_port sw0-pext1 ha_chassis_group=$hagrp1_uuid\n\nwait_row_count HA_Chassis_Group 0 name=hagrp1\ncheck_row_count HA_Chassis 0\n\n# Set the type of sw0-pext1 to external\novn-nbctl lsp-set-type sw0-pext1 external\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\ncheck_row_count HA_Chassis 3\n\nsb_hagrp1_uuid=`ovn-sbctl --bare --columns _uuid find ha_chassis_group \\\nname=hagrp1`\n\ncheck_row_count Port_Binding 1 logical_port=sw0-pext1 ha_chassis_group=$sb_hagrp1_uuid\n\n# Set the type of sw0-pext2 to external and associate ha_chassis_group\novn-nbctl lsp-set-type sw0-pext2 external\novn-nbctl set logical_switch_port sw0-pext2 ha_chassis_group=$hagrp1_uuid\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\ncheck_row_count HA_Chassis 3\ncheck_row_count Port_Binding 1 logical_port=sw0-pext1 ha_chassis_group=$sb_hagrp1_uuid\nwait_row_count Port_Binding 1 logical_port=sw0-pext2 ha_chassis_group=$sb_hagrp1_uuid\n\n# sw0-p1 is a normal port. So ha_chassis_group should not be set\n# in port_binding.\novn-nbctl --wait=sb set logical_switch_port sw0-p1 \\\nha_chassis_group=$hagrp1_uuid\n\nwait_row_count Port_Binding 0 logical_port=sw0-p1 'chassis!=[[]]'\n\n# Clear ha_chassis_group for sw0-pext1\ncheck ovn-nbctl --wait=sb clear logical_switch_port sw0-pext1 ha_chassis_group\n\nwait_row_count Port_Binding 0 logical_port=sw0-pext1 'chassis!=[[]]'\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\nwait_row_count HA_Chassis 3\n\nAS_BOX([Clear ha_chassis_group for sw0-pext2 and reset port type to normal in the same txn])\n\ncheck ovn-nbctl  --wait=sb clear logical_switch_port sw0-pext2 \\\nha_chassis_group -- set logical_switch_port sw0-pext2 'type=\"\"'\nwait_row_count HA_Chassis_Group 0\nwait_row_count Port_Binding 0 logical_port=sw0-pext2 'chassis!=[[]]'\ncheck_row_count HA_Chassis 0\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd pause and resume])\n# By starting the backup northd paused, we ensure that the primary\n# northd is active; otherwise, there's a race.  (We also test that\n# the ovn-northd --dry-run option works.)\novn_start --backup-northd=paused\n\nget_northd_status() {\n    as northd ovn-appctl -t NORTHD_TYPE is-paused\n    as northd ovn-appctl -t NORTHD_TYPE status\n    as northd-backup ovn-appctl -t NORTHD_TYPE is-paused\n    as northd-backup ovn-appctl -t NORTHD_TYPE status\n}\n\nAS_BOX([Check that the backup is paused])\nOVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false\nStatus: active\ntrue\nStatus: paused\n])\n\nAS_BOX([Resume the backup])\ncheck as northd-backup ovs-appctl -t NORTHD_TYPE resume\nOVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false\nStatus: active\nfalse\nStatus: standby\n])\n\nAS_BOX([Check that ovn-northd is active])\n# Check that ovn-northd is active, by verifying that it creates and\n# destroys southbound datapaths as one would expect.\ncheck_row_count Datapath_Binding 0\ncheck ovn-nbctl --wait=sb ls-add sw0\ncheck_row_count Datapath_Binding 1\ncheck ovn-nbctl --wait=sb ls-del sw0\ncheck_row_count Datapath_Binding 0\n\nAS_BOX([Pause the main northd])\ncheck as northd ovs-appctl -t NORTHD_TYPE pause\ncheck as northd-backup ovs-appctl -t NORTHD_TYPE pause\nAT_CHECK([get_northd_status], [0], [true\nStatus: paused\ntrue\nStatus: paused\n])\n\nAS_BOX([Verify that ovn-northd is paused])\n# Now ovn-northd won't respond by adding a datapath, because it's paused.\ncheck ovn-nbctl ls-add sw0\ncheck sleep 5\ncheck_row_count Datapath_Binding 0\n\n# Do not resume both main and backup right after each other\n# as there would be no guarentee of which one would become active\nAS_BOX([Resume the main northd])\ncheck as northd ovs-appctl -t NORTHD_TYPE resume\nOVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false\nStatus: active\ntrue\nStatus: paused\n])\n\nAS_BOX([Resume the backup northd])\ncheck as northd-backup ovs-appctl -t NORTHD_TYPE resume\nOVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false\nStatus: active\nfalse\nStatus: standby\n])\n\ncheck ovn-nbctl --wait=sb sync\ncheck_row_count Datapath_Binding 1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd restart])\novn_start --backup-northd=none\n\n# Check that ovn-northd is active, by verifying that it creates and\n# destroys southbound datapaths as one would expect.\ncheck_row_count Datapath_Binding 0\ncheck ovn-nbctl --wait=sb ls-add sw0\ncheck_row_count Datapath_Binding 1\n\n# Kill northd.\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\n# With ovn-northd gone, changes to nbdb won't be reflected into sbdb.\n# Make sure.\ncheck ovn-nbctl ls-add sw1\nsleep 5\ncheck_row_count Datapath_Binding 1\n\n# Now resume ovn-northd.  Changes should catch up.\novn_start_northd primary\nwait_row_count Datapath_Binding 2\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([northbound database reconnection])\n\novn_start --backup-northd=none\n\n# Check that ovn-northd is active, by verifying that it creates and\n# destroys southbound datapaths as one would expect.\ncheck_row_count Datapath_Binding 0\ncheck ovn-nbctl --wait=sb ls-add sw0\ncheck_row_count Datapath_Binding 1\ndp1=$(fetch_column Datapath_Binding _uuid external_ids:name=sw0)\n\n# Make nbdb ovsdb-server drop connection from ovn-northd.\nconn=$(as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/list-remotes|grep ^punix)\ncheck as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/remove-remote \"$conn\"\nconn2=punix:`pwd`/special.sock\ncheck as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/add-remote \"$conn2\"\n\n# ovn-northd won't respond to changes (because the nbdb connection dropped).\ncheck ovn-nbctl --db=\"${conn2#p}\" ls-add sw1\nsleep 5\ncheck_row_count Datapath_Binding 1\n\n# Now re-enable the nbdb connection and observe ovn-northd catch up.\ncheck as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/add-remote \"$conn\"\nwait_row_count Datapath_Binding 2\ndp2=$(fetch_column Datapath_Binding _uuid external_ids:name=sw1)\nwait_column \"$dp1 $dp2\" Logical_DP_Group datapaths\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([southbound database reconnection])\n\novn_start --backup-northd=none\n\n# Check that ovn-northd is active, by verifying that it creates and\n# destroys southbound datapaths as one would expect.\ncheck_row_count Datapath_Binding 0\ncheck ovn-nbctl --wait=sb ls-add sw0\ncheck_row_count Datapath_Binding 1\ndp1=$(fetch_column Datapath_Binding _uuid external_ids:name=sw0)\n\n# Make sbdb ovsdb-server drop connection from ovn-northd.\nconn=$(as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/list-remotes|grep ^punix)\ncheck as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/remove-remote \"$conn\"\nconn2=punix:`pwd`/special.sock\ncheck as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/add-remote \"$conn2\"\n\n# ovn-northd can't respond to changes (because the sbdb connection dropped).\ncheck ovn-nbctl ls-add sw1\nsleep 5\nOVN_SB_DB=${conn2#p} check_row_count Datapath_Binding 1\n\n# Now re-enable the sbdb connection and observe ovn-northd catch up.\n#\n# It's important to check both Datapath_Binding and Logical_Flow.\ncheck as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/add-remote \"$conn\"\nwait_row_count Datapath_Binding 2\ndp2=$(fetch_column Datapath_Binding _uuid external_ids:name=sw1)\nwait_column \"$dp1 $dp2\" Logical_DP_Group datapaths\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check Redirect Chassis propagation from NB to SB])\novn_start\n\novn-sbctl chassis-add gw1 geneve 127.0.0.1\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 router\novn-nbctl lsp-set-options S1-R1 router-port=R1-S1\n\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1\n\novn-nbctl lrp-set-redirect-type R1-S1 bridged\nwait_row_count Port_Binding 1 logical_port=cr-R1-S1 options:redirect-type=bridged\n\novn-nbctl lrp-set-redirect-type R1-S1 overlay\nwait_row_count Port_Binding 1 logical_port=cr-R1-S1 options:redirect-type=overlay\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check stateless dnat_and_snat rule])\novn_start\n\novn-sbctl chassis-add gw1 geneve 127.0.0.1\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 router\novn-nbctl lsp-set-options S1-R1 router-port=R1-S1\n\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1\n\ncheck_flow_matches() {\n    local regex=$1 count=$2\n    local found=$(grep -c \"$1\" r1-flows)\n    echo \"checking for $count flows matching $regex... found $found\"\n    AT_FAIL_IF([test $found != $count])\n}\n\ncheck_flow_match_sets() {\n    ovn-sbctl dump-flows R1 > r1-flows\n    AT_CAPTURE_FILE([r1-flows])\n\n    for regex in lr_in_unsnat ct_snat ct_dnat ip4.dst= ip4.src= ip6.dst= ip6.src=; do\n        check_flow_matches $regex $1\n        shift\n    done\n}\n\necho\necho \"IPv4: stateful\"\novn-nbctl --wait=sb lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11\ncheck_flow_match_sets 3 4 2 0 0 0 0\novn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1\n\necho\necho \"IPv4: stateless\"\novn-nbctl --wait=sb --stateless lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11\ncheck_flow_match_sets 2 0 0 1 1 0 0\novn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1\n\necho\necho \"IPv6: stateful\"\novn-nbctl --wait=sb lr-nat-add R1 dnat_and_snat fd01::1 fd11::2\ncheck_flow_match_sets 3 4 2 0 0 0 0\novn-nbctl lr-nat-del R1 dnat_and_snat  fd01::1\n\necho\necho \"IPv6: stateless\"\novn-nbctl --wait=sb --stateless lr-nat-add R1 dnat_and_snat fd01::1 fd11::2\ncheck_flow_match_sets 2 0 0 0 0 1 1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check portrange dnat, snat and dnat_and_snat rules])\novn_start\n\novn-sbctl chassis-add gw1 geneve 127.0.0.1\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 router\novn-nbctl lsp-set-options S1-R1 router-port=R1-S1\n\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1\n\nuuid=`ovn-sbctl --columns=_uuid --bare find Port_Binding logical_port=cr-R1-S1`\necho \"CR-LRP UUID is: \" $uuid\n\n# IPV4\novn-nbctl --portrange lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11 1-3000\n\nAT_CAPTURE_FILE([sbflows])\nOVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows && test 3 = `grep -c lr_in_unsnat sbflows`])\nAT_CHECK([grep -c 'ct_snat.*3000' sbflows && grep -c 'ct_dnat.*3000' sbflows],\n  [0], [2\n1\n])\n\novn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1\novn-nbctl --wait=sb --portrange lr-nat-add R1 snat  172.16.1.1 50.0.0.11 1-3000\n\nAT_CAPTURE_FILE([sbflows2])\nOVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows2 && test 3 = `grep -c lr_in_unsnat sbflows`])\nAT_CHECK([grep -c 'ct_snat.*3000' sbflows2 && grep -c 'ct_dnat.*3000' sbflows2],\n  [1], [2\n0\n])\n\novn-nbctl lr-nat-del R1 snat  172.16.1.1\novn-nbctl --wait=sb --portrange --stateless lr-nat-add R1 dnat_and_snat  172.16.1.2 50.0.0.12 1-3000\n\nAT_CAPTURE_FILE([sbflows3])\nOVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows3 && test 4 = `grep -c lr_in_unsnat sbflows3`])\nAT_CHECK([grep 'ct_[s]dnat.*172\\.16\\.1\\.2.*3000' sbflows3], [1])\n\novn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check allowed/disallowed external dnat, snat and dnat_and_snat rules])\novn_start\n\n# Logical network:\n# 2 LRs - CR and DR\n# CR ==> Centralized router\n# DR ==> Distributed router\n#\n# DR is connected to S1 and CR is connected to S2\n\ncheck ovn-sbctl chassis-add gw1 geneve 127.0.0.1\n\ncheck ovn-nbctl lr-add DR\ncheck ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24\n\ncr_uuid=$(ovn-nbctl create Logical_Router name=CR)\ncheck ovn-nbctl lrp-add CR CR-S2 02:ac:10:01:00:01 172.16.1.1/24\n\ncheck ovn-nbctl ls-add S1\ncheck ovn-nbctl lsp-add S1 S1-DR\ncheck ovn-nbctl lsp-set-type S1-DR router\ncheck ovn-nbctl lsp-set-addresses S1-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1\n\ncheck ovn-nbctl ls-add S2\ncheck ovn-nbctl lsp-add S2 S2-CR\ncheck ovn-nbctl lsp-set-type S2-CR router\ncheck ovn-nbctl lsp-set-addresses S2-CR router\ncheck ovn-nbctl --wait=sb lsp-set-options S2-CR router-port=CR-S2\n\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S1 gw1\n\nuuid=$(fetch_column Port_Binding _uuid logical_port=cr-DR-S1)\necho \"CR-LRP UUID is: \" $uuid\n\ncheck ovn-nbctl set Logical_Router $cr_uuid options:chassis=gw1\ncheck ovn-nbctl --wait=sb sync\n\novn-nbctl create Address_Set name=allowed_range addresses=\\\"1.1.1.1\\\"\novn-nbctl create Address_Set name=disallowed_range addresses=\\\"2.2.2.2\\\"\n\n# SNAT with ALLOWED_IPs\ncheck ovn-nbctl lr-nat-add DR snat  172.16.1.1 50.0.0.11\ncheck ovn-nbctl lr-nat-update-ext-ip DR snat 50.0.0.11 allowed_range\n\ncheck ovn-nbctl lr-nat-add CR snat  172.16.1.1 50.0.0.11\ncheck ovn-nbctl lr-nat-update-ext-ip CR snat 50.0.0.11 allowed_range\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > drflows\nAT_CAPTURE_FILE([drflows])\novn-sbctl dump-flows CR > crflows\nAT_CAPTURE_FILE([crflows])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $allowed_range), action=(ct_snat_in_czone(172.16.1.1);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $allowed_range && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.1);)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $allowed_range && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.1);)\n])\n\n\n# SNAT with DISALLOWED_IPs\ncheck ovn-nbctl lr-nat-del DR snat  50.0.0.11\ncheck ovn-nbctl lr-nat-del CR snat  50.0.0.11\n\ncheck ovn-nbctl lr-nat-add DR snat  172.16.1.1 50.0.0.11\ncheck ovn-nbctl lr-nat-add CR snat  172.16.1.1 50.0.0.11\n\ncheck ovn-nbctl --is-exempted lr-nat-update-ext-ip DR snat 50.0.0.11 disallowed_range\ncheck ovn-nbctl --is-exempted lr-nat-update-ext-ip CR snat 50.0.0.11 disallowed_range\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > drflows2\nAT_CAPTURE_FILE([drflows2])\novn-sbctl dump-flows CR > crflows2\nAT_CAPTURE_FILE([crflows2])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows2 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone(172.16.1.1);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.1);)\n  table=??(lr_out_snat        ), priority=163  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $disallowed_range), action=(next;)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows2 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.1);)\n  table=??(lr_out_snat        ), priority=35   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $disallowed_range), action=(next;)\n])\n\n# Stateful FIP with ALLOWED_IPs\ncheck ovn-nbctl lr-nat-del DR snat  50.0.0.11\ncheck ovn-nbctl lr-nat-del CR snat  50.0.0.11\n\ncheck ovn-nbctl lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11\ncheck ovn-nbctl lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11\n\ncheck ovn-nbctl lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 allowed_range\ncheck ovn-nbctl --wait=sb lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 allowed_range\n\novn-sbctl dump-flows DR > drflows3\nAT_CAPTURE_FILE([drflows2])\novn-sbctl dump-flows CR > crflows3\nAT_CAPTURE_FILE([crflows2])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows3 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $allowed_range), action=(ct_snat_in_czone(172.16.1.2);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $allowed_range && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.2);)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows3 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $allowed_range && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.2);)\n])\n\n# Stateful FIP with DISALLOWED_IPs\novn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2\novn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2\n\novn-nbctl lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11\novn-nbctl lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11\n\novn-nbctl --is-exempted lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 disallowed_range\ncheck ovn-nbctl --wait=sb --is-exempted lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 disallowed_range\n\novn-sbctl dump-flows DR > drflows4\nAT_CAPTURE_FILE([drflows2])\novn-sbctl dump-flows CR > crflows4\nAT_CAPTURE_FILE([crflows2])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows4 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone(172.16.1.2);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.2);)\n  table=??(lr_out_snat        ), priority=163  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $disallowed_range), action=(next;)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows4 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.2);)\n  table=??(lr_out_snat        ), priority=35   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $disallowed_range), action=(next;)\n])\n\n# Stateless FIP with DISALLOWED_IPs\novn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2\novn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2\n\novn-nbctl --stateless lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11\novn-nbctl --stateless lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11\n\novn-nbctl lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 allowed_range\ncheck ovn-nbctl --wait=sb lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 allowed_range\n\novn-sbctl dump-flows DR > drflows5\nAT_CAPTURE_FILE([drflows2])\novn-sbctl dump-flows CR > crflows5\nAT_CAPTURE_FILE([crflows2])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows5 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $allowed_range), action=(ip4.src=172.16.1.2; next;)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows5 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $allowed_range), action=(ip4.src=172.16.1.2; next;)\n])\n\n# Stateful FIP with DISALLOWED_IPs\novn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2\novn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2\n\novn-nbctl --stateless lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11\novn-nbctl --stateless lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11\n\novn-nbctl --is-exempted lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 disallowed_range\novn-nbctl --is-exempted lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 disallowed_range\n\novn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > drflows6\nAT_CAPTURE_FILE([drflows2])\novn-sbctl dump-flows CR > crflows6\nAT_CAPTURE_FILE([crflows2])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows6 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ip4.src=172.16.1.2; next;)\n  table=??(lr_out_snat        ), priority=163  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $disallowed_range), action=(next;)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows6 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11), action=(ip4.src=172.16.1.2; next;)\n  table=??(lr_out_snat        ), priority=35   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $disallowed_range), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check Load balancer health check and Service Monitor sync])\novn_start NORTHD_TYPE\ncheck ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80\n\ncheck ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1\ncheck ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1\n\nwait_row_count Service_Monitor 0\n\nAT_CHECK([ovn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer . \\\nhealth_check @hc | uuidfilt], [0], [<0>\n])\n\nwait_row_count Service_Monitor 0\n\nAS_BOX([create logical switches and ports])\novn-nbctl ls-add sw0\novn-nbctl --wait=sb lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \\\n\"00:00:00:00:00:03 10.0.0.3\"\n\nwait_row_count Service_Monitor 0\n\novn-nbctl ls-add sw1\novn-nbctl --wait=sb lsp-add sw1 sw1-p1 -- lsp-set-addresses sw1-p1 \\\n\"02:00:00:00:00:03 20.0.0.3\"\n\n# service_monitors state online requires corresponding port_binding to be \"up\"\novn-sbctl chassis-add hv1 geneve 127.0.0.1\novn-sbctl lsp-bind sw0-p1 hv1\novn-sbctl lsp-bind sw1-p1 hv1\nwait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 'up=true'\nwait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 'up=true'\n\nwait_row_count Service_Monitor 0\n\novn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2\nwait_row_count Service_Monitor 1\n\novn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2\nwait_row_count Service_Monitor 2\n\ncheck ovn-nbctl --wait=sb ls-lb-add sw0 lb1\n\nAT_CAPTURE_FILE([sbflows])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows | grep 'priority=120.*backends' | sed 's/table=..//'], 0, [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\n\n# disabled LSPs should not be a backend of Load Balancer\ncheck ovn-nbctl lsp-set-enabled sw0-p1 disabled\n\nAT_CAPTURE_FILE([sbflows])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows | grep 'priority=120.*backends' | sed 's/table=..//'], 0, [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=20.0.0.3:80);)\n])\nwait_row_count Service_Monitor 1\n\ncheck ovn-nbctl lsp-set-enabled sw0-p1 enabled\n\nAT_CAPTURE_FILE([sbflows])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows | grep 'priority=120.*backends' | sed 's/table=..//'], 0, [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\nwait_row_count Service_Monitor 2\n\nAS_BOX([Delete the Load_Balancer_Health_Check])\novn-nbctl --wait=sb clear load_balancer . health_check\nwait_row_count Service_Monitor 0\n\nAT_CAPTURE_FILE([sbflows2])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows2 | grep 'priority=120.*backends' | sed 's/table=..//'], [0],\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\n\nAS_BOX([Create the Load_Balancer_Health_Check again.])\novn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer . \\\nhealth_check @hc\nwait_row_count Service_Monitor 2\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows sw0 | grep backends | grep priority=120 > lflows.txt\nAT_CHECK([cat lflows.txt | sed 's/table=..//'], [0], [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\n\nAS_BOX([Get the uuid of both the service_monitor])\nsm_sw0_p1=$(fetch_column Service_Monitor _uuid logical_port=sw0-p1)\nsm_sw1_p1=$(fetch_column Service_Monitor _uuid logical_port=sw1-p1)\n\nAT_CAPTURE_FILE([sbflows3])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows 3 | grep 'priority=120.*backends' | sed 's/table=..//'], [0],\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\n\nAS_BOX([Set the service monitor for sw1-p1 to offline])\ncheck ovn-sbctl set service_monitor sw1-p1 status=offline\nwait_row_count Service_Monitor 1 logical_port=sw1-p1 status=offline\ncheck ovn-nbctl --wait=sb sync\n\nAT_CAPTURE_FILE([sbflows4])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows4 | grep 'priority=120.*backends' | sed 's/table=..//'], [0],\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80);)\n])\n\nAS_BOX([Set the service monitor for sw0-p1 to offline])\novn-sbctl set service_monitor $sm_sw0_p1 status=offline\n\nwait_row_count Service_Monitor 1 logical_port=sw0-p1 status=offline\ncheck ovn-nbctl --wait=sb sync\n\nAT_CAPTURE_FILE([sbflows5])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows5 | grep 'priority=120.*backends'], 1)\n\nAT_CAPTURE_FILE([sbflows6])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows6 | grep \"ip4.dst == 10.0.0.10 && tcp.dst == 80\" | grep priority=120 | grep ls_in_lb | sed 's/table=..//'], [0], [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(drop;)\n])\n\nAS_BOX([Set the service monitor for sw0-p1 and sw1-p1 to online])\novn-sbctl set service_monitor $sm_sw0_p1 status=online\novn-sbctl set service_monitor $sm_sw1_p1 status=online\n\nwait_row_count Service_Monitor 1 logical_port=sw1-p1 status=online\ncheck ovn-nbctl --wait=sb sync\n\nAT_CAPTURE_FILE([sbflows7])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows7 | grep backends | grep priority=120 | sed 's/table=..//'], 0,\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\n\nAS_BOX([Set the service monitor for sw1-p1 to error])\novn-sbctl set service_monitor $sm_sw1_p1 status=error\nwait_row_count Service_Monitor 1 logical_port=sw1-p1 status=error\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows sw0 | grep \"ip4.dst == 10.0.0.10 && tcp.dst == 80\" \\\n| grep priority=120 > lflows.txt\nAT_CHECK([cat lflows.txt | grep ls_in_lb | sed 's/table=..//'], [0], [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80);)\n])\n\nAS_BOX([Add one more vip to lb1])\ncheck ovn-nbctl set load_balancer . vip:10.0.0.40\\\\:1000=10.0.0.3:1000,20.0.0.3:80\n\nAS_BOX([create health_check for new vip - 10.0.0.40])\nAT_CHECK(\n  [ovn-nbctl --wait=sb \\\n          -- --id=@hc create Load_Balancer_Health_Check vip=10.0.0.40\\\\:1000 \\\n          -- add Load_Balancer . health_check @hc | uuidfilt], [0], [<0>\n])\n\n# There should be totally 3 rows in service_monitor for -\n#    * 10.0.0.3:80\n#    * 10.0.0.3:1000\n#    * 20.0.0.3:80\n\nwait_row_count Service_Monitor 3\nwait_row_count Service_Monitor 2 logical_port=sw0-p1\nwait_row_count Service_Monitor 1 port=1000\n\nAT_CAPTURE_FILE([sbflows9])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows9 | grep backends | grep priority=120 | sed 's/table=..//' | sort],\n  0,\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80);)\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:1000);)\n])\n\nAS_BOX([Set the service monitor for sw1-p1 to online])\ncheck ovn-sbctl set service_monitor sw1-p1 status=online\n\nwait_row_count Service_Monitor 1 logical_port=sw1-p1 status=online\ncheck ovn-nbctl --wait=sb sync\n\nAT_CAPTURE_FILE([sbflows10])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows10 | grep backends | grep priority=120 | sed 's/table=..//' | sort],\n  0,\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:1000,20.0.0.3:80);)\n])\n\nAS_BOX([Associate lb1 to sw1])\ncheck ovn-nbctl --wait=sb ls-lb-add sw1 lb1\nAT_CAPTURE_FILE([sbflows11])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw1 | tee sbflows11 | grep backends | grep priority=120 | sed 's/table=..//' | sort],\n  0, [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:1000,20.0.0.3:80);)\n])\n\nAS_BOX([Now create lb2 same as lb1 but udp protocol.])\ncheck ovn-nbctl lb-add lb2 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80 udp\ncheck ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2\ncheck ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2\n\nAT_CHECK([ovn-nbctl -- --id=@hc create Load_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer lb2 health_check @hc | uuidfilt],\n         [0], [<0>\n])\n\ncheck ovn-nbctl ls-lb-add sw0 lb2\ncheck ovn-nbctl ls-lb-add sw1 lb2\ncheck ovn-nbctl --wait=sb sync\n\nwait_row_count Service_Monitor 5\n\nAS_BOX([Change the svc_monitor_mac.])\n# This should get reflected in service_monitor table rows.\ncheck ovn-nbctl set NB_Global . options:svc_monitor_mac=\"fe:a0:65:a2:01:03\"\n\nwait_row_count Service_Monitor 5 src_mac='\"fe:a0:65:a2:01:03\"'\n\nAS_BOX([Change the source ip for 10.0.0.3 backend ip in lb2])\ncheck ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.100\n\nwait_row_count Service_Monitor 1 logical_port=sw0-p1 src_ip=10.0.0.100\n\novn-nbctl --wait=sb lb-del lb1\nwait_row_count Service_Monitor 2\n\novn-nbctl --wait=sb lb-del lb2\nwait_row_count Service_Monitor 0\n\ncheck ovn-nbctl --reject lb-add lb3 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80\ncheck ovn-nbctl --wait=sb set load_balancer lb3 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2\ncheck ovn-nbctl --wait=sb set load_balancer lb3 ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2\nwait_row_count Service_Monitor 0\n\ncheck ovn-nbctl --wait=sb ls-lb-add sw0 lb3\nAT_CHECK([ovn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer lb3 \\\nhealth_check @hc | uuidfilt], [0], [<0>\n])\nwait_row_count Service_Monitor 2\n\n# Set the service monitor for sw0-p1 and sw1-p1 to online\nsm_sw0_p1=$(fetch_column Service_Monitor _uuid logical_port=sw0-p1)\nsm_sw1_p1=$(fetch_column Service_Monitor _uuid logical_port=sw1-p1)\n\novn-sbctl set service_monitor $sm_sw0_p1 status=offline\novn-sbctl set service_monitor $sm_sw1_p1 status=offline\n\nAT_CAPTURE_FILE([sbflows12])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows12 | grep \"ip4.dst == 10.0.0.10 && tcp.dst == 80\" | grep priority=120 | grep ls_in_lb | sed 's/table=..//'], [0], [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=5);};)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load balancer VIP in NAT entries])\nAT_SKIP_IF([test $HAVE_PYTHON = no])\novn_start\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:01:01:02:04 192.168.2.1/24\ncheck ovn-nbctl lrp-add lr0 lr0-join 00:00:01:01:02:04 10.10.0.1/24\n\ncheck ovn-nbctl set logical_router lr0 options:chassis=ch1\n\ncheck ovn-nbctl lb-add lb1 \"192.168.2.1:8080\" \"10.0.0.4:8080\"\ncheck ovn-nbctl lb-add lb2 \"192.168.2.4:8080\" \"10.0.0.5:8080\" udp\ncheck ovn-nbctl lb-add lb3 \"192.168.2.5:8080\" \"10.0.0.6:8080\"\ncheck ovn-nbctl lb-add lb4 \"192.168.2.6:8080\" \"10.0.0.7:8080\"\n\ncheck ovn-nbctl lr-lb-add lr0 lb1\ncheck ovn-nbctl lr-lb-add lr0 lb2\ncheck ovn-nbctl lr-lb-add lr0 lb3\ncheck ovn-nbctl lr-lb-add lr0 lb4\n\ncheck ovn-nbctl lr-nat-add lr0 snat 192.168.2.1 10.0.0.0/24\ncheck ovn-nbctl lr-nat-add lr0 dnat_and_snat 192.168.2.4 10.0.0.4\ncheck ovn-nbctl --wait=sb lr-nat-add lr0 dnat 192.168.2.5 10.0.0.5\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no flows for LB VIPs in lr_in_unsnat if the VIP is not a\n# dnat_and_snat or snat entry.\nAT_CHECK([grep \"lr_in_unsnat\" sbflows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.1 && tcp && tcp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.4 && udp && udp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.5 && tcp && tcp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.4), action=(ct_snat;)\n])\n\nAS_BOX([Check behavior with LB Groups])\ncheck ovn-nbctl lr-lb-del lr0 lb1\ncheck ovn-nbctl lr-lb-del lr0 lb2\ncheck ovn-nbctl lr-lb-del lr0 lb3\ncheck ovn-nbctl lr-lb-del lr0 lb4\n\nlb1=$(fetch_column nb:load_balancer _uuid name=lb1)\nlb2=$(fetch_column nb:load_balancer _uuid name=lb2)\nlb3=$(fetch_column nb:load_balancer _uuid name=lb3)\nlb4=$(fetch_column nb:load_balancer _uuid name=lb4)\n\nlbg=$(ovn-nbctl create load_balancer_group name=lbg -- \\\n  add load_balancer_group lbg load_balancer $lb1 -- \\\n  add load_balancer_group lbg load_balancer $lb2 -- \\\n  add load_balancer_group lbg load_balancer $lb3 -- \\\n  add load_balancer_group lbg load_balancer $lb4)\n\ncheck ovn-nbctl --wait=sb add logical_router lr0 load_balancer_group $lbg\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no flows for LB VIPs in lr_in_unsnat if the VIP is not a\n# dnat_and_snat or snat entry.\nAT_CHECK([grep \"lr_in_unsnat\" sbflows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.1 && tcp && tcp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.4 && udp && udp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.5 && tcp && tcp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.4), action=(ct_snat;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LRP same IP as VIP or SNAT])\novn_start\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:00:00:00:10 192.168.0.1/24 2000::1/64\ncheck ovn-nbctl --wait=sb lrp-add lr0 lr0-join 00:00:00:00:00:20 10.10.0.1/24 192.168.1.1/24\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be drop lflows for all IPs of both LRPs\nAT_CHECK([grep \"lr_in_ip_input\" sbflows | grep 'ip.\\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {2000::1, fe80::200:ff:fe00:10}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)\n])\n\n# create SNAT with external IP equal to LRP's IP\ncheck ovn-nbctl --wait=sb lr-nat-add lr0 snat 192.168.0.1 10.10.0.0/24\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no drop lflow for 192.168.0.1\nAT_CHECK([grep \"lr_in_ip_input\" sbflows | grep 'ip.\\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {2000::1, fe80::200:ff:fe00:10}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)\n])\n\ncheck ovn-nbctl lr-nat-del lr0\n\n# create SNAT with external IPv6 equal to LRP's IPv6\ncheck ovn-nbctl --wait=sb lr-nat-add lr0 snat 2000::1 2aaa::/64\novn-nbctl show lr0\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no drop lflow for 2000::1\nAT_CHECK([grep \"lr_in_ip_input\" sbflows | grep 'ip.\\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:10}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)\n])\n\ncheck ovn-nbctl lr-nat-del lr0\n\n# create LB with VIP equal to LRP's IP and assign it to LR\ncheck ovn-nbctl lb-add lb1 \"192.168.1.1:8080\" \"10.0.0.4:8080\"\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb1\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no drop lflow for 192.168.1.1\nAT_CHECK([grep \"lr_in_ip_input\" sbflows | grep 'ip.\\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {2000::1, fe80::200:ff:fe00:10}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)\n])\n\ncheck ovn-nbctl lb-del lb1\n\n# create LB with VIP equal to LRP's IPv6 and assign it to LR\ncheck ovn-nbctl lb-add lb1 [[2000::1]]:8080 [[2aaa::10]]:8080\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb1\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no drop lflow for 2000::1\nAT_CHECK([grep \"lr_in_ip_input\" sbflows | grep 'ip.\\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:10}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([DNAT force snat IP])\novn_start\n\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-public 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lrp-add lr0 lr0-join 00:00:01:01:02:04 10.10.0.1/24\n\novn-nbctl set logical_router lr0 options:chassis=ch1\novn-nbctl lr-nat-add lr0 dnat 192.168.2.2 10.0.0.5\novn-nbctl set logical_router lr0 options:dnat_force_snat_ip=192.168.2.3\novn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list lr0 | grep lr_in_unsnat | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(ip4 && ip4.dst == 192.168.2.3), action=(ct_snat;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check reconcile stale Datapath_Binding])\novn_start\n\ncheck ovn-nbctl lr-add lr\ncheck ovn-nbctl lrp-add lr p 00:00:00:00:00:01 1.1.1.1/24\ncheck ovn-nbctl --wait=sb sync\n\n# Create a MAC_Binding referring the router datapath.\nAT_CHECK([ovn-sbctl --id=@dp get datapath . -- create mac_binding logical_port=p ip=1.1.1.2 datapath=@dp | uuidfilt], [0], [<0>\n])\n\ncheck ovn-nbctl --wait=sb \\\n             -- lrp-del p \\\n             -- lr-del lr \\\n             -- lr-add lr \\\n             -- lrp-add lr p 00:00:00:00:00:01 1.1.1.1/24\n\ncheck_row_count Datapath_Binding 1\n\nnb_uuid=$(ovn-sbctl get Datapath_Binding . external_ids:logical-router)\nlr_uuid=\\\"$(ovn-nbctl get Logical_Router . _uuid)\\\"\necho nb_uuid=\"$nb_uuid\" lr_uuid=\"$lr_uuid\"\nAT_CHECK([test \"${nb_uuid}\" = \"${lr_uuid}\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check reconcile stale tunnel keys])\novn_start\n\novn-nbctl ls-add ls1\novn-nbctl ls-add ls2\novn-nbctl lsp-add ls1 lsp1\novn-nbctl lsp-add ls2 lsp2\nAT_CHECK([ovn-nbctl --wait=sb sync], [0])\n\n# Ports are bound on different datapaths so it's expected that they both\n# get tunnel_key == 1.\ncheck_column 1 Port_Binding tunnel_key logical_port=lsp1\ncheck_column 1 Port_Binding tunnel_key logical_port=lsp2\n\novn-nbctl lsp-del lsp2 -- lsp-add ls1 lsp2\nAT_CHECK([ovn-nbctl --wait=sb sync], [0])\n\ncheck_column 1 Port_Binding tunnel_key logical_port=lsp1\ncheck_column 2 Port_Binding tunnel_key logical_port=lsp2\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check reconcile stale Ha_Chassis_Group])\novn_start\n\novn-nbctl ls-add ls1\novn-nbctl ls-add ls2\novn-nbctl lsp-add ls1 lsp1\novn-nbctl lsp-add ls2 lsp2\n\novn-nbctl lsp-set-type lsp2 external\n\novn-nbctl ha-chassis-group-add chg1\novn-nbctl ha-chassis-group-add-chassis chg1 chassis-1 30\n\nchg1_uuid=$(ovn-nbctl --bare --columns _uuid list Ha_Chassis_Group .)\novn-nbctl set logical_switch_port lsp2 ha_chassis_group=${chg1_uuid}\nAT_CHECK([ovn-nbctl --wait=sb sync], [0])\n\n# Move lsp2 from ls2 to ls1. This should also remove the SB HA_Chassis_Group\n# record.\novn-nbctl lsp-del lsp2 -- lsp-add ls1 lsp2\nAT_CHECK([ovn-nbctl --wait=sb sync], [0])\n\ncheck_row_count HA_Chassis_Group 0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check NB/SB Port_Group translation (lsp add/del)])\novn_start\n\novn-nbctl ls-add ls1\novn-nbctl ls-add ls2\novn-nbctl lsp-add ls1 lsp1\novn-nbctl lsp-add ls2 lsp2\novn-nbctl --wait=sb sync\nls1_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls1)\nls2_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls2)\n\n# Add an empty port group. This should generate no entry in the SB.\novn-nbctl --wait=sb pg-add pg_test\nAT_CHECK([test 0 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])\n\n# Add lsp1 to the port group. This should generate an entry in the SB only\n# for ls1.\novn-nbctl --wait=sb pg-set-ports pg_test lsp1\nAT_CHECK([test 1 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])\nAT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls1_key}_pg_test], [0], [dnl\nlsp1\n])\n\n# Add lsp2 to the port group. This should generate a new entry in the SB, for\n# ls2.\novn-nbctl --wait=sb pg-set-ports pg_test lsp1 lsp2\nAT_CHECK([test 2 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])\nAT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls1_key}_pg_test], [0], [dnl\nlsp1\n])\nAT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls2_key}_pg_test], [0], [dnl\nlsp2\n])\n\n# Remove lsp1 from the port group. The SB Port_Group for ls1 should be\n# removed.\novn-nbctl --wait=sb pg-set-ports pg_test lsp2\nAT_CHECK([test 1 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])\nAT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls2_key}_pg_test], [0], [dnl\nlsp2\n])\n\n# Remove lsp2 from the port group. All SB Port_Groups should be purged.\novn-nbctl --wait=sb clear Port_Group pg_test ports\nAT_CHECK([test 0 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check NB/SB Port_Group translation (ls del)])\novn_start\n\novn-nbctl ls-add ls1\novn-nbctl ls-add ls2\novn-nbctl lsp-add ls1 lsp1\novn-nbctl lsp-add ls2 lsp2\novn-nbctl --wait=sb sync\nls1_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls1)\nls2_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls2)\n\n# Add lsp1 & lsp2 to a port group. This should generate two entries in the\n# SB (one per logical switch).\novn-nbctl --wait=sb pg-add pg_test lsp1 lsp2\nwait_row_count Port_Group 2\ncheck_row_count Port_Group 1 name=${ls1_key}_pg_test\ncheck_row_count Port_Group 1 name=${ls2_key}_pg_test\n\n# Delete logical switch ls1. This should remove the associated SB Port_Group.\novn-nbctl --wait=sb ls-del ls1\nwait_row_count Port_Group 1\ncheck_row_count Port_Group 1 name=${ls2_key}_pg_test\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check router ARP/NS responder])\novn_start\n\novn-sbctl chassis-add ch geneve 127.0.0.1\n\novn-nbctl lr-add lr\novn-nbctl lrp-add lr lrp-public 00:00:00:00:01:00 43.43.43.1/24 4343::1/64\novn-nbctl lrp-add lr lrp 00:00:00:00:00:01 42.42.42.1/24\n\novn-nbctl ls-add ls\novn-nbctl lsp-add ls ls-rp\novn-nbctl lsp-set-type ls-rp router\novn-nbctl lsp-set-addresses ls-rp router\novn-nbctl lsp-set-options ls-rp router-port=lrp\novn-nbctl lsp-add ls ls-vm\n\novn-nbctl set logical_router lr options:chassis=ch\novn-nbctl lr-nat-add lr dnat_and_snat 43.43.43.2 42.42.42.2\novn-nbctl lr-nat-add lr dnat 43.43.43.3 42.42.42.3\novn-nbctl lr-nat-add lr dnat_and_snat 43.43.43.4 42.42.42.4 ls-vm 00:00:00:00:00:02\novn-nbctl lr-nat-add lr snat 43.43.43.150 43.43.43.50\novn-nbctl lr-nat-add lr snat 43.43.43.150 43.43.43.51\n\novn-nbctl lb-add lb1 \"192.168.2.1:8080\" \"10.0.0.4:8080\"\novn-nbctl lb-add lb2 \"192.168.2.4:8080\" \"10.0.0.5:8080\" udp\novn-nbctl lb-add lb3 \"192.168.2.5:8080\" \"10.0.0.6:8080\"\novn-nbctl lb-add lb4 \"192.168.2.6:8080\" \"10.0.0.7:8080\"\novn-nbctl lb-add lb5 \"[[fe80::200:ff:fe00:101]]:8080\" \"[[fe02::200:ff:fe00:101]]:8080\"\novn-nbctl lb-add lb5 \"[[fe80::200:ff:fe00:102]]:8080\" \"[[fe02::200:ff:fe00:102]]:8080\"\novn-nbctl lb-add lb6 \"43.43.43.43:8080\" \"10.0.0.8:8080\" udp\novn-nbctl lb-add lb7 \"[[4343::4343]]:8080\" \"[[10::10]]:8080\" udp\novn-nbctl lb-add lb8 \"44.44.44.44:8080\" \"10.0.0.8:8080\" udp\novn-nbctl set Load_Balancer lb8 options:neighbor_responder=all\novn-nbctl lb-add lb9 \"[[4444::4444]]:8080\" \"[[10::10]]:8080\" udp\novn-nbctl set Load_Balancer lb9 options:neighbor_responder=all\n\novn-nbctl lb-add lb10 \"55.55.55.55:8080\" \"10.0.0.8:8080\" udp\novn-nbctl set Load_Balancer lb10 options:neighbor_responder=none\novn-nbctl lb-add lb11 \"[[5555::5555]]:8080\" \"[[10::10]]:8080\" udp\novn-nbctl set Load_Balancer lb11 options:neighbor_responder=none\n\novn-nbctl lr-lb-add lr lb1\novn-nbctl lr-lb-add lr lb2\novn-nbctl lr-lb-add lr lb3\novn-nbctl lr-lb-add lr lb4\novn-nbctl lr-lb-add lr lb5\novn-nbctl lr-lb-add lr lb6\novn-nbctl lr-lb-add lr lb7\novn-nbctl lr-lb-add lr lb8\novn-nbctl lr-lb-add lr lb9\novn-nbctl lr-lb-add lr lb10\novn-nbctl lr-lb-add lr lb11\n\novn-nbctl --wait=sb sync\nlr_key=$(fetch_column sb:datapath_binding tunnel_key external_ids:name=lr)\nlb_as_v4=\"_rtr_lb_${lr_key}_ip4\"\nlb_as_v6=\"_rtr_lb_${lr_key}_ip6\"\n\n# Check generated VIP address sets (only reachable IPs).\ncheck_column '43.43.43.43 44.44.44.44' Address_Set addresses name=${lb_as_v4}\ncheck_column '4343::4343 4444::4444 fe80::200:ff:fe00:101 fe80::200:ff:fe00:102' Address_Set addresses name=${lb_as_v6}\n\n# Ingress router port ETH address is stored in lr_in_admission.\nAT_CHECK([ovn-sbctl lflow-list | grep -E \"lr_in_admission.*xreg0\\[[0..47\\]]\" | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.dst == 00:00:00:00:01:00 && inport == \"lrp-public\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.mcast && inport == \"lrp\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.mcast && inport == \"lrp-public\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)\n])\n\n# Ingress router port ETH address is used for ARP reply/NA in lr_in_ip_input.\nAT_CHECK_UNQUOTED([ovn-sbctl lflow-list | grep -E \"lr_in_ip_input.*priority=90\" | grep \"arp\\|nd\" | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.150), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.2), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.3), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.4), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && arp.op == 1 && arp.tpa == \\$${lb_as_v4}), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && arp.op == 1 && arp.tpa == 42.42.42.1 && arp.spa == 42.42.42.0/24), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && ip6.dst == {fe80::200:ff:fe00:1, ff02::1:ff00:1} && nd_ns && nd.target == fe80::200:ff:fe00:1), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && nd_ns && nd.target == \\$${lb_as_v6}), dnl\naction=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == \\$${lb_as_v4}), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.1 && arp.spa == 43.43.43.0/24), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && ip6.dst == {4343::1, ff02::1:ff00:1} && nd_ns && nd.target == 4343::1), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && ip6.dst == {fe80::200:ff:fe00:100, ff02::1:ff00:100} && nd_ns && nd.target == fe80::200:ff:fe00:100), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && nd_ns && nd.target == \\$${lb_as_v6}), dnl\naction=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n])\n\n# xreg0[0..47] isn't used anywhere else.\nAT_CHECK([ovn-sbctl lflow-list | grep \"xreg0\\[[0..47\\]]\" | grep -vE 'lr_in_admission|lr_in_ip_input'], [1], [])\n\n# Test chassis redirect port.\novn-nbctl remove logical_router lr options chassis\novn-nbctl lrp-set-gateway-chassis lrp-public ch\novn-nbctl --wait=sb sync\n\n# Ingress router port ETH address is stored in lr_in_admission.\nAT_CHECK([ovn-sbctl lflow-list | grep -E \"lr_in_admission.*xreg0\\[[0..47\\]]\" | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.dst == 00:00:00:00:00:02 && inport == \"lrp-public\" && is_chassis_resident(\"ls-vm\")), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.dst == 00:00:00:00:01:00 && inport == \"lrp-public\" && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.mcast && inport == \"lrp\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.mcast && inport == \"lrp-public\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)\n])\n\n# Ingress router port is used for ARP reply/NA in lr_in_ip_input.\n# xxreg0[0..47] is used unless external_mac is set.\n# Priority 90 flows (per router).\nAT_CHECK_UNQUOTED([ovn-sbctl lflow-list | grep -E \"lr_in_ip_input.*priority=90\" | grep \"arp\\|nd\" | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.150), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.2), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.3), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.4), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && arp.op == 1 && arp.tpa == \\$${lb_as_v4}), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && arp.op == 1 && arp.tpa == 42.42.42.1 && arp.spa == 42.42.42.0/24), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && ip6.dst == {fe80::200:ff:fe00:1, ff02::1:ff00:1} && nd_ns && nd.target == fe80::200:ff:fe00:1), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && nd_ns && nd.target == \\$${lb_as_v6}), dnl\naction=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == \\$${lb_as_v4} && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.1 && arp.spa == 43.43.43.0/24), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && ip6.dst == {4343::1, ff02::1:ff00:1} && nd_ns && nd.target == 4343::1 && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && ip6.dst == {fe80::200:ff:fe00:100, ff02::1:ff00:100} && nd_ns && nd.target == fe80::200:ff:fe00:100 && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && nd_ns && nd.target == \\$${lb_as_v6} && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n])\n\n# Priority 91 drop flows (per distributed gw port), if port is not resident.\nAT_CHECK([ovn-sbctl lflow-list | grep -E \"lr_in_ip_input.*priority=91\" | grep \"arp\\|nd\" | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=91   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.150), action=(drop;)\n  table=3 (lr_in_ip_input     ), priority=91   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.2), dnl\naction=(drop;)\n  table=3 (lr_in_ip_input     ), priority=91   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.3), dnl\naction=(drop;)\n  table=3 (lr_in_ip_input     ), priority=91   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.4), dnl\naction=(drop;)\n])\n\n# Priority 92 ARP/NS responders (per distributed gw port), if port is resident.\nAT_CHECK([ovn-sbctl lflow-list | grep -E \"lr_in_ip_input.*priority=92\" | grep \"arp\\|nd\" | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=92   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.150 && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=92   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.2 && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=92   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.3 && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=92   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.4 && is_chassis_resident(\"ls-vm\")), dnl\naction=(eth.dst = eth.src; eth.src = 00:00:00:00:00:02; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = 00:00:00:00:00:02; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n])\n\n# xreg0[0..47] isn't used anywhere else.\nAT_CHECK([ovn-sbctl lflow-list | grep \"xreg0\\[[0..47\\]]\" | grep -vE 'lr_in_admission|lr_in_ip_input'], [1], [])\n\nAT_CLEANUP\n])\n\n# This test case tests that when a logical switch has load balancers associated\n# (with VIPs configured), the below logical flow is added by ovn-northd.\n# table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n# This test case is added for the BZ -\n# https://bugzilla.redhat.com/show_bug.cgi?id=1849162\n#\n# ovn-northd was not adding the above lflow if the last load balancer associated\n# to the logical switch doesn't have the VIP configured even if other load\n# balancers before the last one in the last have VIPs configured.\n# So make sure that the above lflow is added even if one load balancer has VIP\n# associated.\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load balancer - missing ls_out_pre_lb flows])\novn_start\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1\n\novn-nbctl lb-add lb1 \"10.0.0.10\" \"10.0.0.3\"\novn-nbctl lb-add lb2 \"10.0.0.11\" \"10.0.0.4\"\n\novn-nbctl lb-add lb3 \"10.0.0.12\" \"10.0.0.5\"\novn-nbctl lb-add lb4 \"10.0.0.13\" \"10.0.0.6\"\n\nlb1=$(fetch_column nb:load_balancer _uuid name=lb1)\nlb2=$(fetch_column nb:load_balancer _uuid name=lb2)\nlb3=$(fetch_column nb:load_balancer _uuid name=lb3)\nlb4=$(fetch_column nb:load_balancer _uuid name=lb4)\n\nlbg=$(ovn-nbctl create load_balancer_group name=lbg)\ncheck ovn-nbctl add logical_switch  sw0 load_balancer_group $lbg\n\novn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n])\n\ncheck ovn-nbctl ls-lb-add sw0 lb1\ncheck ovn-nbctl add load_balancer_group $lbg load_balancer $lb3\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl ls-lb-add sw0 lb2\ncheck ovn-nbctl add load_balancer_group $lbg load_balancer $lb4\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl clear load_balancer $lb1 vips\ncheck ovn-nbctl clear load_balancer $lb3 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl clear load_balancer $lb2 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl clear load_balancer $lb4 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n])\n\ncheck ovn-nbctl set load_balancer $lb1 vips:\"10.0.0.10\"=\"10.0.0.3\"\ncheck ovn-nbctl set load_balancer $lb2 vips:\"10.0.0.11\"=\"10.0.0.4\"\ncheck ovn-nbctl set load_balancer $lb3 vips:\"10.0.0.12\"=\"10.0.0.5\"\ncheck ovn-nbctl set load_balancer $lb4 vips:\"10.0.0.13\"=\"10.0.0.6\"\n\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\n# Now reverse the order of clearing the vip.\ncheck ovn-nbctl clear load_balancer $lb2 vips\ncheck ovn-nbctl clear load_balancer $lb4 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl clear load_balancer $lb1 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl clear load_balancer $lb3 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ignore_lsp_down])\novn_start\n\novn-nbctl set NB_Global . options:ignore_lsp_down=false\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \"aa:aa:aa:aa:aa:aa 10.0.0.1\"\n\novn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep arp | grep 10\\.0\\.0\\.1], [1], [ignore])\n\novn-nbctl --wait=sb set NB_Global . options:ignore_lsp_down=true\nAT_CHECK([ovn-sbctl lflow-list | grep arp | grep 10\\.0\\.0\\.1], [0], [ignore])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd -- reject ACL])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1\n\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-p1\n\ncheck ovn-nbctl pg-add pg0 sw0-p1 sw1-p1\ncheck ovn-nbctl acl-add pg0 from-lport 1002 \"inport == @pg0 && ip4 && tcp && tcp.dst == 80\" reject\ncheck ovn-nbctl acl-add pg0 to-lport 1003 \"outport == @pg0 && ip6 && udp\" reject\n\ncheck ovn-nbctl --wait=sb sync\n\nAS_BOX([1])\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\novn-sbctl dump-flows sw1 > sw1flows\nAT_CAPTURE_FILE([sw1flows])\n\nAT_CHECK(\n  [grep -E 'ls_(in|out)_acl' sw0flows sw1flows | grep pg0 | sort], [0], [dnl\nsw0flows:  table=4 (ls_out_acl         ), priority=2003 , match=(outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw0flows:  table=8 (ls_in_acl          ), priority=2002 , match=(inport == @pg0 && ip4 && tcp && tcp.dst == 80), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=5); };)\nsw1flows:  table=4 (ls_out_acl         ), priority=2003 , match=(outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows:  table=8 (ls_in_acl          ), priority=2002 , match=(inport == @pg0 && ip4 && tcp && tcp.dst == 80), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=5); };)\n])\n\nAS_BOX([2])\n\novn-nbctl --wait=sb acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && udp\" reject\n\novn-sbctl dump-flows sw0 > sw0flows2\nAT_CAPTURE_FILE([sw0flows2])\novn-sbctl dump-flows sw1 > sw1flows2\nAT_CAPTURE_FILE([sw1flows2])\n\nAT_CHECK([grep \"ls_out_acl\" sw0flows2 sw1flows2 | grep pg0 | sort], [0], [dnl\nsw0flows2:  table=4 (ls_out_acl         ), priority=2002 , match=(outport == @pg0 && ip4 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw0flows2:  table=4 (ls_out_acl         ), priority=2003 , match=(outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows2:  table=4 (ls_out_acl         ), priority=2002 , match=(outport == @pg0 && ip4 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows2:  table=4 (ls_out_acl         ), priority=2003 , match=(outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\n])\n\nAS_BOX([3])\n\novn-nbctl --wait=sb acl-add pg0 to-lport 1001 \"outport == @pg0 && ip\" allow-related\n\novn-sbctl dump-flows sw0 > sw0flows3\nAT_CAPTURE_FILE([sw0flows3])\novn-sbctl dump-flows sw1 > sw1flows3\nAT_CAPTURE_FILE([sw1flows3])\n\nAT_CHECK([grep \"ls_out_acl\" sw0flows3 sw1flows3 | grep pg0 | sort], [0], [dnl\nsw0flows3:  table=4 (ls_out_acl         ), priority=2001 , match=(reg0[[7]] == 1 && (outport == @pg0 && ip)), action=(reg0[[1]] = 1; next;)\nsw0flows3:  table=4 (ls_out_acl         ), priority=2001 , match=(reg0[[8]] == 1 && (outport == @pg0 && ip)), action=(next;)\nsw0flows3:  table=4 (ls_out_acl         ), priority=2002 , match=((reg0[[10]] == 1) && outport == @pg0 && ip4 && udp), action=(ct_commit { ct_mark.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw0flows3:  table=4 (ls_out_acl         ), priority=2002 , match=((reg0[[9]] == 1) && outport == @pg0 && ip4 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw0flows3:  table=4 (ls_out_acl         ), priority=2003 , match=((reg0[[10]] == 1) && outport == @pg0 && ip6 && udp), action=(ct_commit { ct_mark.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw0flows3:  table=4 (ls_out_acl         ), priority=2003 , match=((reg0[[9]] == 1) && outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2001 , match=(reg0[[7]] == 1 && (outport == @pg0 && ip)), action=(reg0[[1]] = 1; next;)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2001 , match=(reg0[[8]] == 1 && (outport == @pg0 && ip)), action=(next;)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2002 , match=((reg0[[10]] == 1) && outport == @pg0 && ip4 && udp), action=(ct_commit { ct_mark.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2002 , match=((reg0[[9]] == 1) && outport == @pg0 && ip4 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2003 , match=((reg0[[10]] == 1) && outport == @pg0 && ip6 && udp), action=(ct_commit { ct_mark.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2003 , match=((reg0[[9]] == 1) && outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\n])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL fair Meters])\nAT_KEYWORDS([acl log meter fair])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \"50:54:00:00:00:01 10.0.0.11\"\ncheck ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 \"50:54:00:00:00:02 10.0.0.12\"\ncheck ovn-nbctl lsp-add sw1 sw1-p3 -- lsp-set-addresses sw1-p3 \"50:54:00:00:00:03 10.0.0.13\"\ncheck ovn-nbctl pg-add pg0 sw0-p1 sw0-p2 sw1-p3\n\ncheck ovn-nbctl meter-add meter_me drop 1 pktps\nnb_meter_uuid=$(fetch_column nb:Meter _uuid name=meter_me)\n\ncheck ovn-nbctl acl-add sw0 to-lport 1002 'outport == \"sw0-p1\" && ip4.src == 10.0.0.12' allow\ncheck ovn-nbctl acl-add sw0 to-lport 1002 'outport == \"sw0-p1\" && ip4.src == 10.0.0.13' allow\ncheck ovn-nbctl acl-add pg0 to-lport 1002 'outport == \"pg0\" && ip4.src == 10.0.0.11' drop\n\nacl1=$(ovn-nbctl --bare --column _uuid,match find acl | grep -F -B1 '10.0.0.12' | head -1)\nacl2=$(ovn-nbctl --bare --column _uuid,match find acl | grep -F -B1 '10.0.0.13' | head -1)\nacl3=$(ovn-nbctl --bare --column _uuid,match find acl | grep -F -B1 '10.0.0.11' | head -1)\ncheck ovn-nbctl set acl $acl1 log=true severity=alert meter=meter_me name=acl_one\ncheck ovn-nbctl set acl $acl2 log=true severity=info  meter=meter_me name=acl_two\ncheck ovn-nbctl set acl $acl3 log=true severity=info  meter=meter_me name=acl_three\ncheck ovn-nbctl --wait=sb sync\n\ncheck_row_count nb:meter 1\ncheck_column meter_me nb:meter name\n\ncheck_acl_lflow() {\n    acl_log_name=$1\n    meter_name=$2\n    ls=$3\n    echo \"checking that logical flow for acl log $acl_log_name has $meter_name\"\n    ovn-sbctl dump-flows $ls > sbflows\n    AT_CAPTURE_FILE([sbflows])\n    AT_CHECK([grep ls_out_acl sbflows | \\\n              grep \"\\\"${acl_log_name}\\\"\" | \\\n              grep -c \"meter=\\\"${meter_name}\\\"\"], [0], [1\n])\n}\n\ncheck_meter_by_name() {\n    [test \"$1\" = \"NOT\"] && { expected_count=0; shift; } || expected_count=1\n    for meter_name in $* ; do\n        # echo checking for $expected_count $meter_name in sb meter table\n        check_row_count meter $expected_count name=$meter_name\n    done\n}\n\nAS_BOX([Make sure 'fair' value properly affects the Meters in SB])\ncheck_meter_by_name meter_me\ncheck_meter_by_name NOT meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}\n\ncheck ovn-nbctl --wait=sb set Meter $nb_meter_uuid fair=true\ncheck_meter_by_name meter_me meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}\n\ncheck ovn-nbctl --wait=sb set Meter $nb_meter_uuid fair=false\ncheck_meter_by_name meter_me\ncheck_meter_by_name NOT meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}\n\ncheck ovn-nbctl --wait=sb set Meter $nb_meter_uuid fair=true\ncheck_meter_by_name meter_me meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}\n\nAS_BOX([Change template meter and make sure that is reflected on acl meters])\ntemplate_band=$(fetch_column nb:meter bands name=meter_me)\ncheck ovn-nbctl --wait=sb set meter_band $template_band rate=123\nAS_BOX([Make sure that every Meter_Band has the right rate.])\n# ovn-northd creates 4 identical Meter_Band rows, all identical;\nn_meter_bands=$(count_rows meter_band)\nAT_FAIL_IF([test \"$n_meter_bands\" != 4])\ncheck_row_count meter_band $n_meter_bands rate=123\n\nAS_BOX([Check meter in logical flows for acl logs])\ncheck_acl_lflow acl_one meter_me__${acl1} sw0\ncheck_acl_lflow acl_two meter_me__${acl2} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw1\n\nAS_BOX([Stop using meter for acl1])\ncheck ovn-nbctl --wait=sb clear acl $acl1 meter\ncheck_meter_by_name meter_me meter_me__${acl2}\ncheck_meter_by_name NOT meter_me__${acl1}\ncheck_acl_lflow acl_two meter_me__${acl2} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw1\n\nAS_BOX([Remove template Meter should remove all others as well])\ncheck ovn-nbctl --wait=sb meter-del meter_me\ncheck_row_count meter 0\nAS_BOX([Check that logical flow remains but uses non-unique meter])\ncheck_acl_lflow acl_two meter_me sw0\ncheck_acl_lflow acl_three meter_me sw0\ncheck_acl_lflow acl_three meter_me sw1\n\nAS_BOX([Re-add template meter and make sure acl2's meter is back in sb])\ncheck ovn-nbctl --wait=sb --fair meter-add meter_me drop 1 pktps\ncheck_meter_by_name meter_me meter_me__${acl2}\ncheck_meter_by_name NOT meter_me__${acl1}\ncheck_acl_lflow acl_two meter_me__${acl2} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw1\n\nAS_BOX([Remove acl2])\nsw0=$(fetch_column nb:logical_switch _uuid name=sw0)\ncheck ovn-nbctl --wait=sb remove logical_switch $sw0 acls $acl2\ncheck_meter_by_name meter_me meter_me__${acl3}\ncheck_meter_by_name NOT meter_me__${acl1} meter_me__${acl2}\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Check NB-SB mirrors sync])\nAT_KEYWORDS([mirrors])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-port1\ncheck ovn-nbctl lsp-add sw0 sw0-port2\ncheck ovn-nbctl --wait=sb mirror-add mirror1 erspan 1 from-lport 10.10.10.2\ncheck_column mirror1 Mirror name\ncheck_column 10.10.10.2 Mirror sink\ncheck_column erspan Mirror type\ncheck_column 1 Mirror index\ncheck_column from-lport Mirror filter\n\ncheck ovn-nbctl --wait=sb set mirror . sink=192.168.1.13\n\ncheck_column 192.168.1.13 Mirror sink\ncheck_column erspan Mirror type\ncheck_column 1 Mirror index\ncheck_column from-lport Mirror filter\n\ncheck ovn-nbctl --wait=sb set mirror . type=gre\n\ncheck_column 192.168.1.13 Mirror sink\ncheck_column gre Mirror type\ncheck_column 1 Mirror index\ncheck_column from-lport Mirror filter\n\ncheck ovn-nbctl --wait=sb set mirror . index=12\n\ncheck_column 192.168.1.13 Mirror sink\ncheck_column gre Mirror type\ncheck_column 12 Mirror index\ncheck_column from-lport Mirror filter\n\ncheck ovn-nbctl --wait=sb set mirror . filter=to-lport\n\ncheck_column 192.168.1.13 Mirror sink\ncheck_column gre Mirror type\ncheck_column 12 Mirror index\ncheck_column to-lport Mirror filter\n\n# Verify mirror attach\ncheck ovn-nbctl --wait=sb lsp-attach-mirror sw0-port1 mirror1\n\nmirror1uuid=$(fetch_column sb:Mirror _uuid name=mirror1)\ncheck_column \"$mirror1uuid\" sb:Port_Binding mirror_rules logical_port=sw0-port1\n\ncheck ovn-nbctl --wait=sb mirror-add mirror2 gre 2 from-lport 10.10.10.2\ncheck_row_count sb:Mirror 2\n\n# Verify mirror detach (and another attach)\ncheck ovn-nbctl lsp-attach-mirror sw0-port1 mirror2\ncheck ovn-nbctl lsp-detach-mirror sw0-port1 mirror1\ncheck ovn-nbctl --wait=sb sync\n\nmirror2uuid=$(fetch_column sb:Mirror _uuid name=mirror2)\ncheck_column \"$mirror2uuid\" sb:Port_Binding mirror_rules logical_port=sw0-port1\n\n# Verify mirror-del (one by one)\ncheck ovn-nbctl --wait=sb mirror-del mirror2\ncheck_row_count sb:Mirror 1\ncheck ovn-nbctl --wait=sb mirror-del mirror1\ncheck_row_count sb:Mirror 0\ncheck_column \"\" sb:Port_Binding mirror_rules logical_port=sw0-port1\n\n# Verify mirror-add\ncheck ovn-nbctl --wait=sb mirror-add mirror2 gre 2 to-lport 10.10.10.2\ncheck_row_count sb:Mirror 1\n\ncheck_column 10.10.10.2 Mirror sink\ncheck_column gre Mirror type\ncheck_column 2 Mirror index\ncheck_column to-lport Mirror filter\n\n# Verify same attached to multiple ports\ncheck ovn-nbctl --wait=sb lsp-attach-mirror sw0-port1 mirror2\ncheck ovn-nbctl --wait=sb lsp-attach-mirror sw0-port2 mirror2\n\nmirror2uuid=$(fetch_column sb:Mirror _uuid name=mirror2)\ncheck_column \"$mirror2uuid\" sb:Port_Binding mirror_rules logical_port=sw0-port1\ncheck_column \"$mirror2uuid\" sb:Port_Binding mirror_rules logical_port=sw0-port2\n\n# Verify same port attached to multiple mirrors\ncheck ovn-nbctl --wait=sb mirror-add mirror1 erspan 1 to-lport 10.10.10.2\ncheck ovn-nbctl --wait=sb lsp-attach-mirror sw0-port1 mirror1\ncheck_row_count sb:Mirror 2\ncheck_row_count nb:Mirror 2\n\nmirror1uuid=$(fetch_column sb:Mirror _uuid name=mirror1)\ncheck_column \"$mirror2uuid $mirror1uuid\" sb:Port_Binding mirror_rules logical_port=sw0-port1\n\n# Verify delete (bulk)\ncheck ovn-nbctl --wait=sb mirror-del\ncheck_row_count nb:Mirror 0\ncheck_column \"\" nb:Logical_Switch_Port mirror_rules name=sw0-port1\ncheck_column \"\" nb:Logical_Switch_Port mirror_rules name=sw0-port2\ncheck_row_count sb:Mirror 0\ncheck_column \"\" sb:Port_Binding mirror_rules logical_port=sw0-port1\ncheck_column \"\" sb:Port_Binding mirror_rules logical_port=sw0-port2\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL skip hints for stateless config])\nAT_KEYWORDS([acl])\novn_start\n\ncheck ovn-nbctl --wait=sb \\\n    -- ls-add ls \\\n    -- lsp-add ls lsp \\\n    -- acl-add ls from-lport 1 \"ip\" allow \\\n    -- acl-add ls to-lport 1 \"ip\" allow\n\nAS_BOX([Check no match on ct_state with stateless ACLs])\nAT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl -e ls_out_acl | grep 'ct\\.' | sort], [0], [dnl\n])\n\nAS_BOX([Check match ct_state with stateful ACLs])\ncheck ovn-nbctl --wait=sb \\\n    -- acl-add ls from-lport 2 \"udp\" allow-related \\\n    -- acl-add ls to-lport 2 \"udp\" allow-related\nAT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl -e ls_out_acl | grep 'ct\\.' | sort], [0], [dnl\n  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n])\n\nAS_BOX([Check match ct_state with load balancer])\ncheck ovn-nbctl --wait=sb \\\n    -- acl-del ls from-lport 2 \"udp\" \\\n    -- acl-del ls to-lport 2 \"udp\" \\\n    -- lb-add lb \"10.0.0.1\" \"10.0.0.2\" \\\n    -- ls-lb-add ls lb\n\nAT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl -e ls_out_acl | sort], [0], [dnl\n  table=17(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=17(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=17(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=3 (ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=1001 , match=(reg0[[7]] == 1 && (ip)), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=1001 , match=(reg0[[8]] == 1 && (ip)), action=(next;)\n  table=4 (ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=4 (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=7 (ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=1001 , match=(reg0[[7]] == 1 && (ip)), action=(reg0[[1]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=1001 , match=(reg0[[8]] == 1 && (ip)), action=(next;)\n  table=8 (ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=8 (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\novn-nbctl --wait=sb clear logical_switch ls acls\novn-nbctl --wait=sb clear logical_switch ls load_balancer\n\nAT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl -e ls_out_acl | sort], [0], [dnl\n  table=17(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=17(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=3 (ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=4 (ls_out_acl         ), priority=65535, match=(1), action=(next;)\n  table=7 (ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=8 (ls_in_acl          ), priority=65535, match=(1), action=(next;)\n])\n\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([datapath requested-tnl-key])\nAT_KEYWORDS([requested tnl tunnel key keys])\novn_start\n\nget_tunnel_keys() {\n    set $(ovn-sbctl get datapath_binding ls0 tunnel_key \\\n                 -- get datapath_binding ls1 tunnel_key \\\n                 -- get datapath_binding ls2 tunnel_key)\n    echo \"ls0=$ls0 ls1=$ls1 ls2=$ls2\"\n    ls0=$1 ls1=$2 ls2=$3\n    AT_CHECK([test \"$ls0\" != \"$ls1\" && \\\n              test \"$ls1\" != \"$ls2\" && \\\n              test \"$ls0\" != \"$ls2\"])\n}\n\necho\necho \"__file__:__line__: Add three logical switches, check tunnel ids\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb ls-add ls0\n   ovn-nbctl --wait=sb ls-add ls1\n   ovn-nbctl --wait=sb ls-add ls2])\nget_tunnel_keys\nAT_CHECK([test $ls0 = 1 && test $ls1 = 2 && test $ls2 = 3])\n\necho\necho \"__file__:__line__: Assign ls0 new tunnel key, others don't change.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch ls0 other-config:requested-tnl-key=4])\nget_tunnel_keys\nAT_CHECK([test $ls0 = 4 && test $ls1 = 2 && test $ls2 = 3])\n\necho\necho \"__file__:__line__: Assign ls0 a conflict with ls1, which moves aside.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch ls0 other-config:requested-tnl-key=2])\nget_tunnel_keys\nAT_CHECK([test $ls0 = 2 && test $ls2 = 3])\n\necho\necho \"__file__:__line__: Assign ls0 and ls1 conflicts and verify that they end up different and ls2 doesn't change.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch ls1 other-config:requested-tnl-key=2])\nget_tunnel_keys\nAT_CHECK([test $ls2 = 3])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LR requested-tnl-key])\novn_start\n\novn-nbctl --wait=sb lr-add lr0\nAT_CHECK([test 1 = $(ovn-sbctl get datapath_binding lr0 tunnel_key)])\n\novn-nbctl --wait=sb lr-add lr1\nAT_CHECK([test 2 = $(ovn-sbctl get datapath_binding lr1 tunnel_key)])\n\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-router lr0 options:requested-tnl-key=100])\nAT_CHECK([test 100 = $(ovn-sbctl get datapath_binding lr0 tunnel_key)])\n\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-router lr1 options:requested-tnl-key=100])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([port requested-tnl-key])\nAT_KEYWORDS([requested tnl tunnel key keys])\novn_start\n\nget_tunnel_keys() {\n    set $(ovn-sbctl get port_binding lsp00 tunnel_key \\\n                 -- get port_binding lsp01 tunnel_key \\\n                 -- get port_binding lsp02 tunnel_key \\\n                 -- get port_binding lsp10 tunnel_key \\\n                 -- get port_binding lsp11 tunnel_key \\\n                 -- get port_binding lsp12 tunnel_key)\n    lsp00=$1 lsp01=$2 lsp02=$3 lsp10=$4 lsp11=$5 lsp12=$6\n    ls0=$1$2$3 ls1=$4$5$6\n    echo \"ls0=$1$2$3 ls1=$4$5$6\"\n    AT_CHECK([test \"$lsp00\" != \"$lsp01\" && \\\n              test \"$lsp01\" != \"$lsp02\" && \\\n              test \"$lsp00\" != \"$lsp02\"])\n    AT_CHECK([test \"$lsp10\" != \"$lsp11\" && \\\n              test \"$lsp11\" != \"$lsp12\" && \\\n              test \"$lsp10\" != \"$lsp12\"])\n}\n\necho\necho \"__file__:__line__: Add two logical switches with three ports each, check tunnel ids\"\nAT_CHECK(\n  [for i in 0 1; do\n       ovn-nbctl --wait=sb ls-add ls$i || exit $?\n       for j in 0 1 2; do\n           ovn-nbctl --wait=sb lsp-add ls$i lsp$i$j || exit $?\n       done\n   done])\nget_tunnel_keys\nAT_CHECK([test $ls0 = 123 && test $ls1 = 123])\n\necho\necho \"__file__:__line__: Assign lsp00 new tunnel key, others don't change.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch-port lsp00 options:requested-tnl-key=4])\nget_tunnel_keys\nAT_CHECK([test $ls0 = 423 && test $ls1 = 123])\n\necho\necho \"__file__:__line__: Assign lsp00 a conflict with lsp01, which moves aside.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch-port lsp00 options:requested-tnl-key=2])\nget_tunnel_keys\nAT_CHECK([test $lsp00 = 2 && test $lsp02 = 3 && test $ls1 = 123])\n\necho\necho \"__file__:__line__: Assign lsp00 and lsp01 conflicts and verify that they end up different and lsp02 doesn't change.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch-port lsp01 options:requested-tnl-key=2])\nget_tunnel_keys\nAT_CHECK([test $lsp02 = 3 && test $ls1 = 123])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([NB to SB load balancer sync])\novn_start\n\ncheck ovn-nbctl lb-add lb0 10.0.0.10:80 10.0.0.4:8080\ncheck ovn-nbctl --wait=sb lb-add lbg0 20.0.0.10:80 20.0.0.4:8080\ncheck_row_count nb:load_balancer 2\n\necho\necho \"__file__:__line__: Check that there are no SB load balancer rows.\"\ncheck_row_count sb:load_balancer 0\n\nlbg0=$(fetch_column nb:load_balancer _uuid name=lbg0)\nlbg=$(ovn-nbctl create load_balancer_group name=lbg)\ncheck ovn-nbctl add load_balancer_group $lbg load_balancer $lbg0\ncheck ovn-nbctl ls-add sw0 -- add logical_switch sw0 load_balancer_group $lbg\ncheck ovn-nbctl --wait=sb ls-lb-add sw0 lb0\nsw0_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw0)\n\necho\necho \"__file__:__line__: Check that there is one SB load balancer row for lb0 and one for lbg0\"\ncheck_row_count sb:load_balancer 2\ncheck_column \"10.0.0.10:80=10.0.0.4:8080 tcp\" sb:load_balancer vips,protocol name=lb0\ncheck_column \"20.0.0.10:80=20.0.0.4:8080 tcp\" sb:load_balancer vips,protocol name=lbg0\n\nlb0_uuid=$(fetch_column sb:load_balancer _uuid name=lb0)\nlbg0_uuid=$(fetch_column sb:load_balancer _uuid name=lbg0)\n\necho\necho \"__file__:__line__: Check that SB lb0 has sw0 in datapaths column.\"\n\nlb0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lb0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lb0_dp_group | tail -1], [0], [dnl\n$sw0_sb_uuid\n])\n\ncheck_column \"\" sb:datapath_binding load_balancers external_ids:name=sw0\n\necho\necho \"__file__:__line__: Check that SB lbg0 has sw0 in datapaths column.\"\n\nlbg0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lbg0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lbg0_dp_group | tail -1], [0], [dnl\n$sw0_sb_uuid\n])\n\ncheck_column \"\" sb:datapath_binding load_balancers external_ids:name=sw0\n\ncheck ovn-nbctl --wait=sb set load_balancer lb0 vips:\"10.0.0.20\\:90\"=\"20.0.0.4:8080,30.0.0.4:8080\"\n\necho\necho \"__file__:__line__: Check that SB lb0 has vips and protocol columns are set properly.\"\n\ncheck_column \"10.0.0.10:80=10.0.0.4:8080 10.0.0.20:90=20.0.0.4:8080,30.0.0.4:8080 tcp\" \\\nsb:load_balancer vips,protocol name=lb0\n\ncheck ovn-nbctl --wait=sb set load_balancer lbg0 vips:\"20.0.0.20\\:90\"=\"20.0.0.4:8080,30.0.0.4:8080\"\n\necho\necho \"__file__:__line__: Check that SB lbg0 has vips and protocol columns are set properly.\"\n\ncheck_column \"20.0.0.10:80=20.0.0.4:8080 20.0.0.20:90=20.0.0.4:8080,30.0.0.4:8080 tcp\" \\\nsb:load_balancer vips,protocol name=lbg0\n\ncheck ovn-nbctl lr-add lr0 -- add logical_router lr0 load_balancer_group $lbg\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb0\n\necho\necho \"__file__:__line__: Check that SB lb0 has only sw0 in datapaths column.\"\nlb0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lb0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lb0_dp_group | tail -1], [0], [dnl\n$sw0_sb_uuid\n])\n\necho\necho \"__file__:__line__: Check that SB lbg0 has only sw0 in datapaths column.\"\nlbg0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lbg0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lbg0_dp_group | tail -1], [0], [dnl\n$sw0_sb_uuid\n])\n\ncheck ovn-nbctl ls-add sw1 -- add logical_switch sw1 load_balancer_group $lbg\ncheck ovn-nbctl --wait=sb ls-lb-add sw1 lb0\nsw1_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw1)\n\necho \"$sw0_sb_uuid\" > sw_sb_uuids\necho \"$sw1_sb_uuid\" >> sw_sb_uuids\n\necho\necho \"__file__:__line__: Check that SB lb0 has sw0 and sw1 in datapaths column.\"\nlb0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lb0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lb0_dp_group | tail -1 | tr ' ' '\\n' | sort], [0], [dnl\n$(cat sw_sb_uuids | sort)\n])\n\necho\necho \"__file__:__line__: Check that SB lbg0 has sw0 and sw1 in datapaths column.\"\nlbg0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lbg0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lbg0_dp_group | tail -1 | tr ' ' '\\n' | sort], [0], [dnl\n$(cat sw_sb_uuids | sort)\n])\n\ncheck_column \"\" sb:datapath_binding load_balancers external_ids:name=sw1\n\ncheck ovn-nbctl --wait=sb lb-add lb1 10.0.0.30:80 20.0.0.50:8080 udp\ncheck ovn-nbctl --wait=sb lb-add lbg1 20.0.0.30:80 20.0.0.50:8080 udp\ncheck_row_count sb:load_balancer 2\n\nlbg1=$(fetch_column nb:load_balancer _uuid name=lbg1)\ncheck ovn-nbctl add load_balancer_group $lbg load_balancer $lbg1\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb1\ncheck_row_count sb:load_balancer 3\n\necho\necho \"__file__:__line__: Associate lb1 to sw1 and check that lb1 is created in SB DB.\"\n\ncheck ovn-nbctl --wait=sb ls-lb-add sw1 lb1\ncheck_row_count sb:load_balancer 4\n\necho\necho \"__file__:__line__: Check that SB lb1 has vips and protocol columns are set properly.\"\ncheck_column \"10.0.0.30:80=20.0.0.50:8080 udp\" sb:load_balancer vips,protocol name=lb1\n\necho\necho \"__file__:__line__: Check that SB lbg1 has vips and protocol columns are set properly.\"\ncheck_column \"20.0.0.30:80=20.0.0.50:8080 udp\" sb:load_balancer vips,protocol name=lbg1\n\nlb1_uuid=$(fetch_column sb:load_balancer _uuid name=lb1)\nlb1_dp_group=$(fetch_column sb:load_balancer datapath_group name=lb1)\n\necho\necho \"__file__:__line__: Check that SB lb1 has sw1 in datapaths column.\"\n\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lb1_dp_group | tail -1], [0], [dnl\n$sw1_sb_uuid\n])\n\nlbg1_uuid=$(fetch_column sb:load_balancer _uuid name=lbg1)\nlbg1_dp_group=$(fetch_column sb:load_balancer datapath_group name=lbg1)\n\necho\necho \"__file__:__line__: Check that SB lbg1 has sw0 and sw1 in datapaths column.\"\n\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lbg1_dp_group | tail -1 | tr ' ' '\\n' | sort], [0], [dnl\n$(cat sw_sb_uuids | sort)\n])\n\necho\necho \"__file__:__line__: check that datapath sw1 has no entry in the load_balancers column.\"\ncheck_column \"\" sb:datapath_binding load_balancers external_ids:name=sw1\n\necho\necho \"__file__:__line__: Set hairpin_snat_ip on lb1 and check that SB DB is updated.\"\ncheck ovn-nbctl --wait=sb set Load_Balancer lb1 options:hairpin_snat_ip=\"42.42.42.42 4242::4242\"\ncheck_column \"$lb1_uuid\" sb:load_balancer _uuid name=lb1 options='{hairpin_orig_tuple=\"true\", hairpin_snat_ip=\"42.42.42.42 4242::4242\"}'\n\necho\necho \"__file__:__line__: Delete load balancers lb1 and lbg1 and check that datapath sw1's load_balancers is still empty.\"\n\novn-nbctl --wait=sb lb-del lb1 -- lb-del lbg1\ncheck_column \"\" sb:datapath_binding load_balancers external_ids:name=sw1\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LS load balancer hairpin logical flows])\novn_start\n\nlbg=$(ovn-nbctl create load_balancer_group name=lbg)\n\ncheck ovn-nbctl \\\n    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080\n\nlb0=$(fetch_column nb:load_balancer _uuid name=lb0)\n\ncheck ovn-nbctl \\\n    -- ls-add sw0 -- \\\n    -- add logical_switch sw0 load_balancer_group $lbg \\\n    -- ls-lb-add sw0 lb0\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_pre_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_pre_hairpin  ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_hairpin  ), priority=100  , match=(ip && ct.trk), action=(reg0[[6]] = chk_lb_hairpin(); reg0[[12]] = chk_lb_hairpin_reply(); next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_nat_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_nat_hairpin  ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.est && ct.trk && reg0[[6]] == 1), action=(ct_snat;)\n  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.new && ct.trk && reg0[[6]] == 1), action=(ct_snat_to_vip; next;)\n  table=??(ls_in_nat_hairpin  ), priority=90   , match=(ip && reg0[[12]] == 1), action=(ct_snat;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_hairpin | sort | sed 's/table=../table=??/g'], [0], [dnl\n  table=??(ls_in_hairpin      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_hairpin      ), priority=1    , match=((reg0[[6]] == 1 || reg0[[12]] == 1)), action=(eth.dst <-> eth.src; outport = inport; flags.loopback = 1; output;)\n])\n\ncheck ovn-nbctl -- ls-lb-del sw0 lb0\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_pre_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_pre_hairpin  ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_nat_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_nat_hairpin  ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_hairpin | sort | sed 's/table=../table=??/g'], [0], [dnl\n  table=??(ls_in_hairpin      ), priority=0    , match=(1), action=(next;)\n])\n\ncheck ovn-nbctl -- add load_balancer_group $lbg load_balancer $lb0\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_pre_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_pre_hairpin  ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_hairpin  ), priority=100  , match=(ip && ct.trk), action=(reg0[[6]] = chk_lb_hairpin(); reg0[[12]] = chk_lb_hairpin_reply(); next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_nat_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_nat_hairpin  ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.est && ct.trk && reg0[[6]] == 1), action=(ct_snat;)\n  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.new && ct.trk && reg0[[6]] == 1), action=(ct_snat_to_vip; next;)\n  table=??(ls_in_nat_hairpin  ), priority=90   , match=(ip && reg0[[12]] == 1), action=(ct_snat;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_hairpin | sort | sed 's/table=../table=??/g'], [0], [dnl\n  table=??(ls_in_hairpin      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_hairpin      ), priority=1    , match=((reg0[[6]] == 1 || reg0[[12]] == 1)), action=(eth.dst <-> eth.src; outport = inport; flags.loopback = 1; output;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Router policies - ECMP reroute])\nAT_KEYWORDS([router policies ecmp reroute])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-port1\ncheck ovn-nbctl lsp-set-addresses sw0-port1 \"50:54:00:00:00:03 10.0.0.3\"\n\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-port1\ncheck ovn-nbctl lsp-set-addresses sw1-port1 \"40:54:00:00:00:03 20.0.0.3\"\n\n# Create a logical router and attach both logical switches\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64\ncheck ovn-nbctl lsp-add sw1 sw1-lr0\ncheck ovn-nbctl lsp-set-type sw1-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options sw1-lr0 router-port=lr-sw1\n\ncheck ovn-nbctl ls-add public\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24\ncheck ovn-nbctl lsp-add public public-lr0\ncheck ovn-nbctl lsp-set-type public-lr0 router\ncheck ovn-nbctl lsp-set-addresses public-lr0 router\ncheck ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public\n\ncheck ovn-nbctl --wait=sb lr-policy-add lr0  10 \"ip4.src == 10.0.0.3\" reroute 172.168.0.101,172.168.0.102\n\novn-nbctl lr-policy-list lr0 > policy-list\nAT_CAPTURE_FILE([policy-list])\nAT_CHECK([cat policy-list], [0], [dnl\nRouting Policies\n        10                                ip4.src == 10.0.0.3         reroute             172.168.0.101, 172.168.0.102\n])\n\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = 0; next;)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.3), action=(reg8[[0..15]] = 1; reg8[[16..31]] = select(1, 2);)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb lr-policy-add lr0  10 \"ip4.src == 10.0.0.4\" reroute 172.168.0.101,172.168.0.102,172.168.0.103\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 |  \\\nsed 's/reg8\\[[0..15\\]] = [[0-9]]*/reg8\\[[0..15\\]] = <cleared>/' | \\\nsed 's/reg8\\[[0..15\\]] == [[0-9]]*/reg8\\[[0..15\\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.3), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2);)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.4), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2, 3);)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 3), action=(reg0 = 172.168.0.103; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb lr-policy-add lr0  10 \"ip4.src == 10.0.0.5\" reroute 172.168.0.110\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 |  \\\nsed 's/reg8\\[[0..15\\]] = [[0-9]]*/reg8\\[[0..15\\]] = <cleared>/' | \\\nsed 's/reg8\\[[0..15\\]] == [[0-9]]*/reg8\\[[0..15\\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.3), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2);)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.4), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2, 3);)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.5), action=(reg0 = 172.168.0.110; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 3), action=(reg0 = 172.168.0.103; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb lr-policy-del lr0  10 \"ip4.src == 10.0.0.3\"\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 |  \\\nsed 's/reg8\\[[0..15\\]] = [[0-9]]*/reg8\\[[0..15\\]] = <cleared>/' | \\\nsed 's/reg8\\[[0..15\\]] == [[0-9]]*/reg8\\[[0..15\\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.4), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2, 3);)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.5), action=(reg0 = 172.168.0.110; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 3), action=(reg0 = 172.168.0.103; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb lr-policy-del lr0  10 \"ip4.src == 10.0.0.4\"\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 |  \\\nsed 's/reg8\\[[0..15\\]] = [[0-9]]*/reg8\\[[0..15\\]] = <cleared>/' | \\\nsed 's/reg8\\[[0..15\\]] == [[0-9]]*/reg8\\[[0..15\\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.5), action=(reg0 = 172.168.0.110; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb add logical_router_policy . nexthops \"2000\\:\\:b\"\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 |  \\\nsed 's/reg8\\[[0..15\\]] = [[0-9]]*/reg8\\[[0..15\\]] = <cleared>/' | \\\nsed 's/reg8\\[[0..15\\]] == [[0-9]]*/reg8\\[[0..15\\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL allow-stateless omit conntrack - Logical_Switch])\novn_start\n\novn-nbctl ls-add ls\novn-nbctl lsp-add ls lsp1\novn-nbctl lsp-set-addresses lsp1 00:00:00:00:00:01\novn-nbctl lsp-add ls lsp2\novn-nbctl lsp-set-addresses lsp2 00:00:00:00:00:02\n\nfor direction in from to; do\n    ovn-nbctl acl-add ls ${direction}-lport 3 \"tcp\" allow-related\n    ovn-nbctl acl-add ls ${direction}-lport 2 \"udp\" allow-related\n    ovn-nbctl acl-add ls ${direction}-lport 1 \"ip\" drop\ndone\novn-nbctl --wait=sb sync\n\nflow_eth='eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02'\nflow_ip='ip.ttl==64 && ip4.src == 42.42.42.1 && ip4.dst == 66.66.66.66'\nflow_tcp='tcp && tcp.dst == 80'\nflow_udp='udp && udp.dst == 80'\n\nlsp1_inport=$(fetch_column Port_Binding tunnel_key logical_port=lsp1)\n\n# TCP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# UDP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# Allow stateless for TCP.\nfor direction in from to; do\n    ovn-nbctl acl-add ls ${direction}-lport 4 tcp allow-stateless\ndone\novn-nbctl --wait=sb sync\n\n# TCP packets should not go to conntrack anymore.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\n# UDP packets still go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# Add a load balancer.\novn-nbctl lb-add lb-tcp 66.66.66.66:80 42.42.42.2:8080 tcp\novn-nbctl lb-add lb-udp 66.66.66.66:80 42.42.42.2:8080 udp\novn-nbctl ls-lb-add ls lb-tcp\novn-nbctl ls-lb-add ls lb-udp\n\n# Remove stateless for TCP.\novn-nbctl acl-del ls\novn-nbctl --wait=sb sync\n\n# TCP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\n# UDP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\n# Allow stateless for TCP.\nfor direction in from to; do\n    ovn-nbctl acl-add ls ${direction}-lport 4 tcp allow-stateless\ndone\novn-nbctl --wait=sb sync\n\n# TCP packets should not go to conntrack for load balancing.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\n# UDP packets still go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL allow-stateless omit conntrack - Port_Group])\novn_start\n\novn-nbctl ls-add ls\novn-nbctl lsp-add ls lsp1\novn-nbctl lsp-set-addresses lsp1 00:00:00:00:00:01\novn-nbctl lsp-add ls lsp2\novn-nbctl lsp-set-addresses lsp2 00:00:00:00:00:02\n\novn-nbctl pg-add pg lsp1 lsp2\n\nfor direction in from to; do\n    ovn-nbctl acl-add pg ${direction}-lport 3 \"tcp\" allow-related\n    ovn-nbctl acl-add pg ${direction}-lport 2 \"udp\" allow-related\n    ovn-nbctl acl-add pg ${direction}-lport 1 \"ip\" drop\ndone\novn-nbctl --wait=sb sync\n\nlsp1_inport=$(fetch_column Port_Binding tunnel_key logical_port=lsp1)\necho $lsp1_inport\n\nflow_eth='eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02'\nflow_ip='ip.ttl==64 && ip4.src == 42.42.42.1 && ip4.dst == 66.66.66.66'\nflow_tcp='tcp && tcp.dst == 80'\nflow_udp='udp && udp.dst == 80'\n\n# TCP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# UDP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# Allow stateless for TCP.\nfor direction in from to; do\n    ovn-nbctl acl-add pg ${direction}-lport 4 tcp allow-stateless\ndone\novn-nbctl --wait=sb sync\n\n# TCP packets should not go to conntrack anymore.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\n# UDP packets still go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# Add a load balancer.\novn-nbctl lb-add lb-tcp 66.66.66.66:80 42.42.42.2:8080 tcp\novn-nbctl lb-add lb-udp 66.66.66.66:80 42.42.42.2:8080 udp\novn-nbctl ls-lb-add ls lb-tcp\novn-nbctl ls-lb-add ls lb-udp\n\n# Remove stateless for TCP.\novn-nbctl acl-del pg\novn-nbctl --wait=sb sync\n\n# TCP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\n# UDP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\n# Allow stateless for TCP.\nfor direction in from to; do\n    ovn-nbctl acl-add pg ${direction}-lport 4 tcp allow-stateless\ndone\novn-nbctl --wait=sb sync\n\n# TCP packets should not go to conntrack for load balancing.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\n# UDP packets still go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL allow-stateless overrides stateful rules with higher priority - Logical_Switch])\novn_start\n\novn-nbctl ls-add ls\novn-nbctl lsp-add ls lsp1\novn-nbctl lsp-set-addresses lsp1 00:00:00:00:00:01\novn-nbctl lsp-add ls lsp2\novn-nbctl lsp-set-addresses lsp2 00:00:00:00:00:02\n\nfor direction in from to; do\n    ovn-nbctl acl-add ls ${direction}-lport 3 \"tcp\" allow-related\n    ovn-nbctl acl-add ls ${direction}-lport 3 \"udp\" allow\ndone\novn-nbctl --wait=sb sync\n\nflow_eth='eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02'\nflow_ip='ip.ttl==64 && ip4.src == 42.42.42.1 && ip4.dst == 66.66.66.66'\nflow_tcp='tcp && tcp.dst == 80'\nflow_udp='udp && udp.dst == 80'\n\nlsp1_inport=$(fetch_column Port_Binding tunnel_key logical_port=lsp1)\n\n# TCP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# Allow stateless with *lower* priority. It always beats stateful rules.\nfor direction in from to; do\n    ovn-nbctl acl-add ls ${direction}-lport 1 tcp allow-stateless\n    ovn-nbctl acl-add ls ${direction}-lport 1 udp allow-stateless\ndone\novn-nbctl --wait=sb sync\n\n# TCP packets should not go to conntrack anymore.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\n# UDP packets should not go to conntrack anymore.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check BFD config propagation to SBDB])\nAT_KEYWORDS([northd-bfd])\novn_start\n\ncheck ovn-nbctl --wait=sb lr-add r0\nfor i in $(seq 1 7); do\n    check ovn-nbctl --wait=sb lrp-add r0 r0-sw$i 00:00:00:00:00:0$i 192.168.$i.1/24\n    check ovn-nbctl --wait=sb ls-add sw$i\n    check ovn-nbctl --wait=sb lsp-add sw$i sw$i-r0\n    check ovn-nbctl --wait=sb lsp-set-type sw$i-r0 router\n    check ovn-nbctl --wait=sb lsp-set-options sw$i-r0 router-port=r0-sw$i\n    check ovn-nbctl --wait=sb lsp-set-addresses sw$i-r0 00:00:00:00:00:0$i\ndone\n\nuuid=$(ovn-nbctl create bfd logical_port=r0-sw1 dst_ip=192.168.1.2 status=down min_tx=250 min_rx=250 detect_mult=10)\novn-nbctl create bfd logical_port=r0-sw2 dst_ip=192.168.2.2 status=down min_tx=500 min_rx=500 detect_mult=20\novn-nbctl create bfd logical_port=r0-sw3 dst_ip=192.168.3.2 status=down\novn-nbctl create bfd logical_port=r0-sw4 dst_ip=192.168.4.2 status=down min_tx=0 detect_mult=0\n\nwait_row_count bfd 1 logical_port=r0-sw1 detect_mult=10 dst_ip=192.168.1.2 \\\n                     min_rx=250 min_tx=250 status=admin_down\nwait_row_count bfd 1 logical_port=r0-sw2 detect_mult=20 dst_ip=192.168.2.2 \\\n                     min_rx=500 min_tx=500 status=admin_down\nwait_row_count bfd 1 logical_port=r0-sw3 detect_mult=5 dst_ip=192.168.3.2 \\\n                     min_rx=1000 min_tx=1000 status=admin_down\n\nuuid=$(fetch_column nb:bfd _uuid logical_port=r0-sw1)\ncheck ovn-nbctl set bfd $uuid min_tx=1000 min_rx=1000 detect_mult=100\n\nuuid_2=$(fetch_column nb:bfd _uuid logical_port=r0-sw2)\ncheck ovn-nbctl clear bfd $uuid_2 min_rx\nwait_row_count bfd 1 logical_port=r0-sw2 min_rx=1000\nwait_row_count bfd 1 logical_port=r0-sw1 min_rx=1000 min_tx=1000 detect_mult=100\n\ncheck ovn-nbctl --bfd=$uuid lr-route-add r0 100.0.0.0/8 192.168.1.2\nwait_column down bfd status logical_port=r0-sw1\nAT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.1.2 | grep -q bfd],[0])\n\ncheck ovn-nbctl --bfd lr-route-add r0 200.0.0.0/8 192.168.2.2\nwait_column down bfd status logical_port=r0-sw2\nAT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.2.2 | grep -q bfd],[0])\n\ncheck ovn-nbctl --bfd lr-route-add r0 240.0.0.0/8 192.168.5.2 r0-sw5\nwait_column down bfd status logical_port=r0-sw5\nAT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.5.2 | grep -q bfd],[0])\n\ncheck ovn-nbctl --bfd --policy=src-ip lr-route-add r0 192.168.6.1/32 192.168.10.10 r0-sw6\nwait_column down bfd status logical_port=r0-sw6\nAT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.6.1 | grep -q bfd],[0])\n\ncheck ovn-nbctl --bfd --policy=src-ip lr-route-add r0 192.168.7.1/32 192.168.10.10 r0-sw7\nwait_column down bfd status logical_port=r0-sw7\nAT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.7.1 | grep -q bfd],[0])\n\nroute_uuid=$(fetch_column nb:logical_router_static_route _uuid ip_prefix=\"100.0.0.0/8\")\ncheck ovn-nbctl clear logical_router_static_route $route_uuid bfd\nwait_column admin_down bfd status logical_port=r0-sw1\n\novn-nbctl destroy bfd $uuid\nwait_row_count bfd 5\n\n# Simulate BFD up in Southbound for an automatically created entry.\n# This entry is referenced so the state in the Northbound should also\n# become \"up\".\nwait_column down nb:bfd status logical_port=r0-sw2\nbfd2_uuid=$(fetch_column bfd _uuid logical_port=r0-sw2)\ncheck ovn-sbctl set bfd $bfd2_uuid status=up\nwait_column up nb:bfd status logical_port=r0-sw2\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- check CoPP config])\nAT_KEYWORDS([northd-CoPP])\n\novn_start\n\ncheck ovn-nbctl --wait=sb lr-add r0\ncheck ovn-nbctl --wait=sb lrp-add r0 r0-sw1 00:00:00:00:00:01 192.168.1.1/24\ncheck ovn-nbctl --wait=sb ls-add sw1\ncheck ovn-nbctl --wait=sb lsp-add sw1 sw1-r0\ncheck ovn-nbctl --wait=sb lsp-set-type sw1-r0 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw1-r0 router-port=r0-sw1\ncheck ovn-nbctl --wait=sb lsp-set-addresses sw1-r0 00:00:00:00:00:01\n\ncheck ovn-nbctl --event lb-add lb0 192.168.1.100:80 \"\"\ncheck ovn-nbctl ls-lb-add sw1 lb0\ncheck ovn-nbctl --wait=hv meter-add meter0 drop 100 pktps 10\ncheck ovn-nbctl --wait=hv copp-add copp0 event-elb meter0\ncheck ovn-nbctl --wait=hv ls-copp-add copp0 sw1\nAT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl\nevent-elb: meter0\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep trigger_event -A 2 | grep -q meter0])\n\ncheck ovn-nbctl --wait=hv meter-add meter1 drop 300 pktps 10\nAT_CHECK([ovn-nbctl meter-list |grep meter1 -A 1], [0], [dnl\nmeter1: bands:\n  drop: 300 pktps, 10 packet burst\n])\ncheck ovn-nbctl --wait=hv --may-exist meter-add meter1 drop 200 pktps 10\nAT_CHECK([ovn-nbctl meter-list |grep meter1 -A 1], [0], [dnl\nmeter1: bands:\n  drop: 200 pktps, 10 packet burst\n])\ncheck ovn-nbctl --wait=hv copp-add copp1 arp meter1\ncheck ovn-nbctl --wait=hv lr-copp-add copp1 r0\nAT_CHECK([ovn-nbctl copp-list copp1], [0], [dnl\narp: meter1\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep arp -A 2 | grep -q meter1])\n\ncheck ovn-nbctl --wait=hv copp-del copp1 arp\nAT_CHECK([ovn-nbctl copp-list copp1], [0], [dnl\n])\nAT_CHECK([ovn-sbctl list logical_flow | grep arp -A 2 | grep -q meter1],[1])\n\ncheck ovn-nbctl --wait=hv meter-add meter2 drop 400 pktps 10\ncheck ovn-nbctl --wait=hv copp-add copp2 icmp4-error meter2\ncheck ovn-nbctl --wait=hv lr-copp-add copp2 r0\nAT_CHECK([ovn-nbctl copp-list copp2], [0], [dnl\nicmp4-error: meter2\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep icmp4 -A 2 | grep -q meter2])\n\ncheck ovn-nbctl --wait=hv copp-del copp2 icmp4-error\nAT_CHECK([ovn-nbctl copp-list copp2], [0], [dnl\n])\n\ncheck ovn-nbctl --wait=hv copp-add copp3 icmp6-error meter2\ncheck ovn-nbctl --wait=hv lr-copp-add copp3 r0\nAT_CHECK([ovn-nbctl copp-list copp3], [0], [dnl\nicmp6-error: meter2\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep icmp6 -A 2 | grep -q meter2])\n\ncheck ovn-nbctl --wait=hv copp-del copp3 icmp6-error\nAT_CHECK([ovn-nbctl copp-list copp3], [0], [dnl\n])\n\ncheck ovn-nbctl --wait=hv copp-add copp4 tcp-reset meter2\ncheck ovn-nbctl --wait=hv lr-copp-add copp4 r0\nAT_CHECK([ovn-nbctl copp-list copp4], [0], [dnl\ntcp-reset: meter2\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep tcp -A 2 | grep -q meter2])\n\ncheck ovn-nbctl --wait=hv copp-del copp4 tcp-reset\nAT_CHECK([ovn-nbctl copp-list copp4], [0], [dnl\n])\n\ncheck ovn-nbctl --wait=hv copp-del copp0 event-elb\nAT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep trigger_event -A 2 | grep -q meter0],[1])\n\n# let's try to add an usupported protocol \"dhcp\"\nAT_CHECK([ovn-nbctl --wait=hv copp-add copp5 dhcp meter1],[1],[],[dnl\novn-nbctl: Invalid control protocol. Allowed values: arp, arp-resolve, dhcpv4-opts, dhcpv6-opts, dns, event-elb, icmp4-error, icmp6-error, igmp, nd-na, nd-ns, nd-ns-resolve, nd-ra-opts, tcp-reset, bfd, reject.\n])\n\n#Let's try to add a valid protocol to an unknown datapath\ncheck ovn-nbctl --wait=hv copp-add copp6 arp meter1\nAT_CHECK([ovn-nbctl --wait=hv ls-copp-add copp6 sw10],[1],[],[dnl\novn-nbctl: sw10: switch name not found\n])\n\ncheck ovn-nbctl --bfd lr-route-add r0 240.0.0.0/8 192.168.50.2 r0-sw1\ncheck ovn-nbctl --wait=hv copp-add copp7 bfd meter0\ncheck ovn-nbctl --wait=hv lr-copp-add copp7 r0\nAT_CHECK([ovn-nbctl copp-list copp7], [0], [dnl\nbfd: meter0\n])\nAT_CHECK([ovn-sbctl list logical_flow | grep bfd -A 2 | grep -q meter0])\n\ncheck ovn-nbctl --wait=hv set Logical_Switch sw1 \\\n    other_config:mcast_querier=\"false\" \\\n    other_config:mcast_snoop=\"true\"\ncheck ovn-nbctl --wait=hv copp-add copp8 igmp meter1\ncheck ovn-nbctl --wait=hv ls-copp-add copp8 sw1\nAT_CHECK([ovn-nbctl copp-list copp8], [0], [dnl\nigmp: meter1\n])\nAT_CHECK([ovn-sbctl list logical_flow | grep igmp -A 2 | grep -q meter1])\n\ncheck ovn-nbctl copp-del copp8\nAT_CHECK([ovn-nbctl copp-list copp8], [0], [dnl\n])\n\n# let's add igmp meter1 twice\nAT_CHECK([ovn-nbctl --wait=hv copp-add copp9 igmp meter1])\nAT_CHECK([ovn-nbctl copp-list copp9], [0], [dnl\nigmp: meter1\n])\n\n# let's delete a wrong meter\nAT_CHECK([ovn-nbctl --wait=hv copp-del copp9 event-elb])\nAT_CHECK([ovn-nbctl copp-list copp9], [0], [dnl\nigmp: meter1\n])\n\ncheck ovn-nbctl copp-del copp9\nAT_CHECK([ovn-nbctl copp-list copp9], [0], [dnl\n])\n\ncheck ovn-nbctl copp-del copp6\ncheck ovn-nbctl copp-del copp7\nAT_CHECK([ovn-nbctl list copp], [0], [dnl\n])\n\ncheck ovn-nbctl --wait=hv copp-add copp0 arp meter0\ncheck ovn-nbctl --wait=hv lr-copp-add copp0 r0\nAT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl\narp: meter0\n])\n\nAT_CHECK([fetch_column nb:CoPP name], [0], [dnl\ncopp0\n])\n\ncopp_uuid=$(fetch_column nb:CoPP _uuid)\ncheck ovn-nbctl --wait=hv copp-add copp0 arp meter0\ncheck ovn-nbctl --wait=hv ls-copp-add copp0 sw1\n\nls_copp_uuid=$(fetch_column nb:Logical_Switch copp)\nAT_CHECK([test \"$ls_copp_uuid\" = \"$copp_uuid\"])\n\ncheck ovn-nbctl --wait=hv copp-add $copp_uuid igmp meter0\nAT_CHECK([ovn-nbctl copp-list copp0 | sort], [0], [dnl\narp: meter0\nigmp: meter0\n])\n\ncheck ovn-nbctl --wait=sb lrp-add r0 r0-sw2 00:00:00:00:00:03 192.168.2.1/24\ncheck ovn-nbctl --wait=sb ls-add sw2\ncheck ovn-nbctl --wait=sb lsp-add sw2 sw2-r0\ncheck ovn-nbctl --wait=sb lsp-set-type sw2-r0 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw2-r0 router-port=r0-sw2\ncheck ovn-nbctl --wait=sb lsp-set-addresses sw2-r0 00:00:00:00:00:02\n\ncheck ovn-nbctl --wait=hv copp-add copp0 event-elb meter0\ncheck ovn-nbctl --wait=hv ls-copp-add copp0 sw2\nls2_copp_uuid=$(ovn-nbctl get Logical_Switch sw2 copp)\nAT_CHECK([test \"$ls2_copp_uuid\" = \"$copp_uuid\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check LSP attached to multiple LS])\novn_start\n\ncheck ovn-nbctl ls-add ls1 \\\n    -- ls-add ls2 \\\n    -- lsp-add ls1 p1\ncheck ovn-nbctl --wait=sb sync\n\nuuid=$(fetch_column nb:Logical_Switch_Port _uuid name=p1)\ncheck ovn-nbctl set Logical_Switch ls2 ports=$uuid\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([grep -qE 'duplicate logical port p1' northd/ovn-northd.log], [0])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check LRP attached to multiple LR])\novn_start\n\ncheck ovn-nbctl lr-add lr1 \\\n    -- lr-add lr2 \\\n    -- lrp-add lr1 p1 00:00:00:00:00:01 10.0.0.1/24\ncheck ovn-nbctl --wait=sb sync\n\nuuid=$(fetch_column nb:Logical_Router_Port _uuid name=p1)\ncheck ovn-nbctl set Logical_Router lr2 ports=$uuid\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([grep -qE 'duplicate logical router port p1' northd/ovn-northd.log], [0])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check duplicate LSP/LRP])\novn_start\n\ncheck ovn-nbctl ls-add ls \\\n    -- lsp-add ls p1 \\\n    -- lr-add lr \\\n    -- lrp-add lr p1 00:00:00:00:00:01 10.0.0.1/24\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([grep -qE 'duplicate logical.*port p1' northd/ovn-northd.log], [0])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Port_Binding.up backwards compatibility])\novn_start\n\novn-nbctl ls-add ls1\novn-nbctl --wait=sb lsp-add ls1 lsp1\n\n# Simulate the fact that lsp1 had been previously bound on hv1 by an\n# ovn-controller running an older version.\novn-sbctl \\\n    --id=@e create encap chassis_name=hv1 ip=\"192.168.0.1\" type=\"geneve\" \\\n    -- --id=@c create chassis name=hv1 encaps=@e \\\n    -- set Port_Binding lsp1 chassis=@c\n\nwait_for_ports_up lsp1\n\n# Simulate the fact that hv1 is aware of Port_Binding.up, ovn-northd\n# should transition the port state to down.\ncheck ovn-sbctl set chassis hv1 other_config:port-up-notif=true\nwait_row_count nb:Logical_Switch_Port 1 up=false name=lsp1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load Balancers and lb_force_snat_ip for Gateway Routers])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\n\n# Create a logical router and attach both logical switches\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\ncheck ovn-nbctl lsp-add sw1 sw1-lr0\ncheck ovn-nbctl lsp-set-type sw1-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\ncheck ovn-nbctl ls-add public\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24\ncheck ovn-nbctl lsp-add public public-lr0\ncheck ovn-nbctl lsp-set-type public-lr0 router\ncheck ovn-nbctl lsp-set-addresses public-lr0 router\ncheck ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public\n\nlbg=$(ovn-nbctl create load_balancer_group name=lbg)\n\ncheck ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.4:8080\ncheck ovn-nbctl lb-add lbg1 10.0.0.100:80 10.0.0.40:8080\nlbg1=$(fetch_column nb:load_balancer _uuid name=lbg1)\ncheck ovn-nbctl add load_balancer_group $lbg load_balancer $lbg1\ncheck ovn-nbctl lr-lb-add lr0 lb1\ncheck ovn-nbctl add logical_router lr0 load_balancer_group $lbg\ncheck ovn-nbctl set logical_router lr0 options:chassis=ch1\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.4:8080);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.40:8080);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\n\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip=\"20.0.0.4 aef0::4\"\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(ip4 && ip4.dst == 20.0.0.4), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(ip6 && ip6.dst == aef0::4), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=100  , match=(flags.force_snat_for_lb == 1 && ip4), action=(ct_snat(20.0.0.4);)\n  table=? (lr_out_snat        ), priority=100  , match=(flags.force_snat_for_lb == 1 && ip6), action=(ct_snat(aef0::4);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip=\"router_ip\"\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_ip_input\" lr0flows | grep \"priority=60\" | sort], [0], [dnl\n])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.100), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw1\" && ip4.dst == 20.0.0.1), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-public\"), action=(ct_snat(172.168.0.100);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw0\"), action=(ct_snat(10.0.0.1);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw1\"), action=(ct_snat(20.0.0.1);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\ncheck ovn-nbctl --wait=sb remove logical_router lr0 options chassis\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\ncheck ovn-nbctl set logical_router lr0 options:chassis=ch1\ncheck ovn-nbctl --wait=sb add logical_router_port lr0-sw1 networks \"bef0\\:\\:1/64\"\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.100), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw1\" && ip4.dst == 20.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw1\" && ip6.dst == bef0::1), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-public\"), action=(ct_snat(172.168.0.100);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw0\"), action=(ct_snat(10.0.0.1);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw1\"), action=(ct_snat(20.0.0.1);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip6 && outport == \"lr0-sw1\"), action=(ct_snat(bef0::1);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\ncheck ovn-nbctl --wait=sb lb-add lb2 10.0.0.20:80 10.0.0.40:8080\ncheck ovn-nbctl --wait=sb set load_balancer lb2 options:skip_snat=true\ncheck ovn-nbctl lr-lb-add lr0 lb2\ncheck ovn-nbctl --wait=sb lb-del lb1\novn-sbctl dump-flows lr0 > lr0flows\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.100), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw1\" && ip4.dst == 20.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw1\" && ip6.dst == bef0::1), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.20), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | grep skip_snat_for_lb | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.20 && tcp && tcp.dst == 80), action=(flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; skip_snat);)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | grep skip_snat_for_lb | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=120  , match=(flags.skip_snat_for_lb == 1 && ip), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([HA chassis group cleanup for external port ])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-type sw0-p1 external\n\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.1\ncheck ovn-sbctl chassis-add ch2 geneve 127.0.0.2\n\ncheck ovn-nbctl ha-chassis-group-add hagrp1\ncheck ovn-nbctl ha-chassis-group-add-chassis hagrp1 ch1 20\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 10\n\nha_grp1_uuid=$(fetch_column nb:ha_chassis_group _uuid)\necho \"ha grp1 uuid = $ha_grp1_uuid\"\novn-nbctl list ha_chassis_group\ncheck ovn-nbctl set logical_switch_port sw0-p1 ha_chassis_group=$ha_grp1_uuid\n\nwait_row_count ha_chassis_group 1\ncheck ovn-nbctl clear logical_switch_port sw0-p1 ha_chassis_group\nwait_row_count ha_chassis_group 0\n\ncheck ovn-nbctl set logical_switch_port sw0-p1 ha_chassis_group=$ha_grp1_uuid\nwait_row_count ha_chassis_group 1\nsb_ha_grp1_uuid=$(fetch_column ha_chassis_group _uuid)\n\necho\necho \"__file__:__line__:Check that port_binding sw0-p1 has ha_chassis_group set\"\n\ncheck_column \"$sb_ha_grp1_uuid\" Port_Binding ha_chassis_group logical_port=sw0-p1\n\nAS_BOX([Clear ha_chassis_group for sw0-p1 and reset port type to normal port in the same txn])\n\ncheck ovn-nbctl clear logical_switch_port sw0-p1 ha_chassis_group -- set logical_switch_port sw0-p1 'type=\"\"'\nwait_row_count ha_chassis_group 0\ncheck_column \"\" Port_Binding chassis logical_port=sw0-p1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([FDB cleanup])\n\novn_start\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1\novn-nbctl lsp-add sw0 sw0-p2\novn-nbctl lsp-add sw0 sw0-p3\n\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-p1\novn-nbctl lsp-add sw1 sw1-p2\novn-nbctl --wait=sb lsp-add sw1 sw1-p3\n\nsw0_key=$(fetch_column datapath_binding tunnel_key external_ids:name=sw0)\nsw1_key=$(fetch_column datapath_binding tunnel_key external_ids:name=sw1)\nsw0p1_key=$(fetch_column port_binding tunnel_key logical_port=sw0-p1)\nsw0p2_key=$(fetch_column port_binding tunnel_key logical_port=sw0-p2)\nsw1p1_key=$(fetch_column port_binding tunnel_key logical_port=sw1-p1)\n\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:00\\:01\" dp_key=$sw0_key port_key=$sw0p1_key\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:00\\:02\" dp_key=$sw0_key port_key=$sw0p1_key\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:00\\:03\" dp_key=$sw0_key port_key=$sw0p2_key\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:01\\:01\" dp_key=$sw1_key port_key=$sw1p1_key\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:01\\:02\" dp_key=$sw1_key port_key=$sw1p1_key\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:01\\:03\" dp_key=$sw1_key port_key=$sw1p1_key\n\nwait_row_count FDB 6\n\novn-sbctl create fdb mac=\"00\\:00\\:00\\:00\\:01\\:03\" dp_key=$sw1_key port_key=10\nwait_row_count FDB 6\novn-sbctl create fdb mac=\"00\\:00\\:00\\:00\\:01\\:03\" dp_key=4 port_key=10\nwait_row_count FDB 6\n\novn-nbctl --wait=sb ls-del sw1\nwait_row_count FDB 3\n\novn-nbctl lsp-del sw0-p3\nwait_row_count FDB 3\n\novn-nbctl lsp-del sw0-p1\nwait_row_count FDB 1\n\ncheck_column '00:00:00:00:00:03' FDB mac\novn-sbctl list fdb\n\ncheck_column $sw0_key FDB dp_key\ncheck_column $sw0p2_key FDB port_key\n\novn-nbctl --wait=sb lsp-add sw0-p1\nwait_row_count FDB 1\n\novn-nbctl lsp-del sw0-p2\novn-nbctl lsp-add sw0-p2\nwait_row_count FDB 0\n\novn-sbctl list FDB\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LS load balancer logical flows])\novn_start\n\nlbg=$(ovn-nbctl create load_balancer_group name=lbg)\ncheck ovn-nbctl \\\n    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080 \\\n    -- lb-add lbg0 10.0.0.20:80 10.0.0.40:8080\nlbg0=$(fetch_column nb:load_balancer _uuid name=lbg0)\n\ncheck ovn-nbctl \\\n    -- ls-add sw0 \\\n    -- add logical_switch sw0 load_balancer_group $lbg \\\n    -- ls-lb-add sw0 lb0 \\\n    -- add load_balancer_group $lbg load_balancer $lbg0\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl --wait=sb sync\n\ncheck_stateful_flows() {\n    action=$1\n    ovn-sbctl dump-flows sw0 > sw0flows\n    AT_CAPTURE_FILE([sw0flows])\n\n    AT_CHECK([grep \"ls_in_pre_lb\" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_pre_lb       ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.mcast), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(ip && inport == \"sw0-lr0\"), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(reg0[[16]] == 1), action=(next;)\n])\n\n    AT_CHECK([grep \"ls_in_pre_stateful\" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_pre_stateful ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_pre_stateful ), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)\n  table=? (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n  table=? (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg1 = 10.0.0.10; reg2[[0..15]] = 80; ct_lb_mark;)\n  table=? (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 10.0.0.20 && tcp.dst == 80), action=(reg1 = 10.0.0.20; reg2[[0..15]] = 80; ct_lb_mark;)\n])\n\n    AT_CHECK([grep \"ls_in_lb \" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.4:8080);)\n  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.20 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.40:8080);)\n])\n\n    AT_CHECK([grep \"ls_in_stateful\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\n    AT_CHECK_UNQUOTED([grep \"ls_out_pre_lb\" sw0flows | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=0    , match=(1), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.mcast), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.src == \\$svc_monitor_mac), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(ip && outport == \"sw0-lr0\"), action=($action)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(reg0[[16]] == 1), action=(next;)\n])\n\n    AT_CHECK([grep \"ls_out_pre_stateful\" sw0flows | sort], [0], [dnl\n  table=2 (ls_out_pre_stateful), priority=0    , match=(1), action=(next;)\n  table=2 (ls_out_pre_stateful), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)\n  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n])\n\n    AT_CHECK([grep \"ls_out_lb\" sw0flows | sort], [0], [])\n\n    AT_CHECK([grep \"ls_out_stateful\" sw0flows | sort], [0], [dnl\n  table=7 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n}\n\ncheck_stateful_flows \"ct_clear; next;\"\n\n# Add few ACLs\ncheck ovn-nbctl --wait=sb acl-add sw0 from-lport 1002 \"ip4 && tcp && tcp.dst == 80\" allow-related\ncheck ovn-nbctl --wait=sb acl-add sw0 to-lport 1002 \"ip4 && tcp && tcp.src == 80\" drop\n\ncheck_stateful_flows \"next;\"\n\n# Remove load balancers from sw0\ncheck ovn-nbctl ls-lb-del sw0 lb0\ncheck ovn-nbctl clear logical_switch sw0 load_balancer_group\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep \"ls_in_pre_lb\" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_pre_lb       ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.mcast), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(ip && inport == \"sw0-lr0\"), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(reg0[[16]] == 1), action=(next;)\n])\n\nAT_CHECK([grep \"ls_in_pre_stateful\" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_pre_stateful ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_pre_stateful ), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)\n  table=? (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n])\n\nAT_CHECK([grep \"ls_in_lb \" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"ls_in_stateful\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAT_CHECK([grep \"ls_out_pre_lb\" sw0flows | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=0    , match=(1), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.mcast), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(ip && outport == \"sw0-lr0\"), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(reg0[[16]] == 1), action=(next;)\n])\n\nAT_CHECK([grep \"ls_out_pre_stateful\" sw0flows | sort], [0], [dnl\n  table=2 (ls_out_pre_stateful), priority=0    , match=(1), action=(next;)\n  table=2 (ls_out_pre_stateful), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)\n  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n])\n\nAT_CHECK([grep \"ls_out_stateful\" sw0flows | sort], [0], [dnl\n  table=7 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\n# LB with event=false and reject=false\nAT_CHECK([ovn-nbctl create load_balancer name=lb1 options:reject=false options:event=false vips:\\\"10.0.0.20\\\"=\\\"\\\" protocol=tcp], [0], [ignore])\ncheck ovn-nbctl --wait=sb ls-lb-add sw0 lb1\n\nAT_CHECK([ovn-sbctl dump-flows sw0 | grep \"ls_in_lb \" | sort ], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=12(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.20), action=(drop;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- ACL label usage])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0p1\n\ncheck ovn-nbctl --wait=sb --label=1234 acl-add sw0 to-lport 1002 tcp allow-related\ncheck ovn-nbctl --wait=sb --label=1234 acl-add sw0 from-lport 1002 tcp allow-related\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 2002 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n])\nAT_CHECK([grep \"ls_in_stateful\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 2002 | sort], [0], [dnl\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n])\nAT_CHECK([grep \"ls_out_stateful\" sw0flows | sort], [0], [dnl\n  table=7 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\n# Add new ACL without label\ncheck ovn-nbctl --wait=sb acl-add sw0 to-lport 1002 udp allow-related\ncheck ovn-nbctl --wait=sb acl-add sw0 from-lport 1002 udp allow-related\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 2002 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg0[[1]] = 1; next;)\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(next;)\n])\nAT_CHECK([grep \"ls_in_stateful\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 2002 | sort], [0], [dnl\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(next;)\n])\nAT_CHECK([grep \"ls_out_stateful\" sw0flows | sort], [0], [dnl\n  table=7 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\n# Delete new ACL with label\ncheck ovn-nbctl --wait=sb acl-del sw0 to-lport 1002 tcp\ncheck ovn-nbctl --wait=sb acl-del sw0 from-lport 1002 tcp\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 2002 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg0[[1]] = 1; next;)\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(next;)\n])\nAT_CHECK([grep \"ls_in_stateful\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 2002 | sort], [0], [dnl\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(next;)\n])\nAT_CHECK([grep \"ls_out_stateful\" sw0flows | sort], [0], [dnl\n  table=7 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- ct.inv usage])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0p1\n\ncheck ovn-nbctl --wait=sb acl-add sw0 to-lport 1002 ip allow-related\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\n# Disable ct.inv usage.\ncheck ovn-nbctl --wait=sb set NB_Global . options:use_ct_inv_match=false\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=? (ls_in_acl          ), priority=65532, match=((ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=? (ls_out_acl         ), priority=65532, match=((ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\nAT_CHECK([grep -c \"ct.inv\" sw0flows], [1], [dnl\n0\n])\n\n# Enable ct.inv usage.\ncheck ovn-nbctl --wait=sb set NB_Global . options:use_ct_inv_match=true\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\nAT_CHECK([grep -c \"ct.inv\" sw0flows], [0], [dnl\n6\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([northd ssl file change])\nAT_SKIP_IF([test \"$HAVE_OPENSSL\" = no])\nPKIDIR=\"$(cd $abs_top_builddir/tests && pwd)\"\nAT_SKIP_IF([expr \"$PKIDIR\" : \".*[[ \t'\\\"\n\\\\]]\"])\novn_start --backup-northd=none\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nkey_server=testpki-test-privkey.pem\ncert_server=testpki-test-cert.pem\ncacert=testpki-cacert.pem\n\ncd ovn-sb\nrm ovsdb-server.log\nssl_options=\"--remote=pssl:0:127.0.0.1 ovn-sb.db -p $PKIDIR/$key_server -c $PKIDIR/$cert_server -C $PKIDIR/$cacert\"\nAT_CHECK([ovsdb-server --detach --no-chdir --pidfile --log-file $ssl_options], [0], [], [stderr])\non_exit \"kill `cat ovsdb-server.pid`\"\nPARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])\ncd ..\n\nkey=testpki-hv1-privkey.pem\ncert=testpki-hv1-cert.pem\n\nkey2=testpki-hv2-privkey.pem\ncert3=testpki-hv3-cert.pem\n\n# Use mismatched key and cert when restarting using SSL options\ncp $PKIDIR/$key2 $key\ncp $PKIDIR/$cert3 $cert\ncp $PKIDIR/$cacert $cacert\nas northd\nstart_daemon ovn$NORTHD_TYPE -vjsonrpc \\\n    --ovnnb-db=$OVN_NB_DB --ovnsb-db=ssl:127.0.0.1:$TCP_PORT \\\n    -p $key -c $cert -C $cacert\n\n# SSL should not connect because of key and cert mismatch\nAT_FAIL_IF([ovn-nbctl --timeout=3 --wait=sb sync])\n\n# Modify the files with the correct key and cert, and reconnect should succeed\ncp $PKIDIR/$key $key\ncp $PKIDIR/$cert $cert\ncheck ovn-nbctl --wait=sb sync\n\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([trace with IPv4 dnat])\nAT_KEYWORDS([dnat])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-port1\ncheck ovn-nbctl lsp-set-addresses sw0-port1 \"50:54:00:00:00:01 192.168.0.2\"\n\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-port1\ncheck ovn-nbctl lsp-set-addresses sw1-port1 \"50:54:00:00:00:03 11.0.0.2\"\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lrp0 00:00:00:00:ff:01 192.168.0.1/24\ncheck ovn-nbctl lsp-add sw0 lrp0-attachment\ncheck ovn-nbctl lsp-set-type lrp0-attachment router\ncheck ovn-nbctl lsp-set-addresses lrp0-attachment 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options lrp0-attachment router-port=lrp0\ncheck ovn-nbctl lrp-add lr0 lrp1 00:00:00:00:ff:02 11.0.0.1/24 -- lrp-set-gateway-chassis lrp1 chassis-1\ncheck ovn-nbctl lsp-add sw1 lrp1-attachment\ncheck ovn-nbctl lsp-set-type lrp1-attachment router\ncheck ovn-nbctl lsp-set-addresses lrp1-attachment 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options lrp1-attachment router-port=lrp1\n\ncheck ovn-nbctl lr-nat-add lr0 dnat 42.42.42.42 192.168.0.2\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn_trace --minimal 'inport == \"sw1-port1\" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip4.dst == 42.42.42.42 && ip4.src == 11.0.0.2 && ip.ttl == 64' | grep \"output(\\\"sw0-port1\\\")\"], [0], [ignore])\n\ndnl If we remove the DNAT entry we will be unable to trace to the DNAT address\ncheck ovn-nbctl lr-nat-del lr0 dnat 42.42.42.42\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn_trace --minimal 'inport == \"sw1-port1\" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip4.dst == 42.42.42.42 && ip4.src == 11.0.0.2 && ip.ttl == 64' | grep \"output(\\\"sw0-port1\\\")\"], [1], [ignore])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([trace with IPv6 dnat])\nAT_KEYWORDS([dnat])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-port1\ncheck ovn-nbctl lsp-set-addresses sw0-port1 \"50:54:00:00:00:01 fd68::2\"\n\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-port1\ncheck ovn-nbctl lsp-set-addresses sw1-port1 \"50:54:00:00:00:03 fd11::2\"\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lrp0 00:00:00:00:ff:01 fd68::1/64\ncheck ovn-nbctl lsp-add sw0 lrp0-attachment\ncheck ovn-nbctl lsp-set-type lrp0-attachment router\ncheck ovn-nbctl lsp-set-addresses lrp0-attachment 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options lrp0-attachment router-port=lrp0\ncheck ovn-nbctl lrp-add lr0 lrp1 00:00:00:00:ff:02 fd11::1/64 -- lrp-set-gateway-chassis lrp1 chassis-1\ncheck ovn-nbctl lsp-add sw1 lrp1-attachment\ncheck ovn-nbctl lsp-set-type lrp1-attachment router\ncheck ovn-nbctl lsp-set-addresses lrp1-attachment 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options lrp1-attachment router-port=lrp1\n\ncheck ovn-nbctl lr-nat-add lr0 dnat fd42::42 fd68::2\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn_trace --minimal 'inport == \"sw1-port1\" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip6.dst == fd42::42 && ip6.src == fd11::2 && ip.ttl == 64' | grep \"output(\\\"sw0-port1\\\")\"], [0], [ignore])\n\ndnl If we remove the DNAT entry we will be unable to trace to the DNAT address\ncheck ovn-nbctl lr-nat-del lr0 dnat fd42::42\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn_trace --minimal 'inport == \"sw1-port1\" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip6.dst == fd42::42 && ip6.src == fd11::2 && ip.ttl == 64' | grep \"output(\\\"sw0-port1\\\")\"], [1], [ignore])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([DHCP options])\nAT_KEYWORDS([dnat])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-port1\ncheck ovn-nbctl lsp-set-addresses sw0-port1 \"50:54:00:00:00:01 10.0.0.2\"\ncheck ovn-nbctl lsp-add sw0 sw0-port2\ncheck ovn-nbctl lsp-set-addresses sw0-port2 \"50:54:00:00:00:02 10.0.0.3\"\n\novn-nbctl dhcp-options-create 10.0.0.0/24\n\nCIDR_UUID=$(ovn-nbctl --bare --columns=_uuid find dhcp_options cidr=\"10.0.0.0/24\")\novn-nbctl dhcp-options-set-options $CIDR_UUID   lease_time=3600   router=10.0.0.1   server_id=10.0.0.1   server_mac=c0:ff:ee:00:00:01 hostname=\"\\\"foo\\\"\"\novn-nbctl --wait=sb lsp-set-dhcpv4-options sw0-port1 $CIDR_UUID\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_dhcp_options\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_dhcp_options ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"foo\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 10.0.0.2 && ip4.dst == {10.0.0.1, 255.255.255.255} && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"foo\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n])\n\ncheck ovn-nbctl --wait=sb lsp-set-options sw0-port1 hostname=\"\\\"port1\\\"\"\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_dhcp_options\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_dhcp_options ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"port1\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 10.0.0.2 && ip4.dst == {10.0.0.1, 255.255.255.255} && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"port1\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n])\n\novn-nbctl dhcp-options-set-options $CIDR_UUID  lease_time=3600   router=10.0.0.1   server_id=10.0.0.1   server_mac=c0:ff:ee:00:00:01\ncheck ovn-nbctl --wait=sb lsp-set-options sw0-port1 hostname=\"\\\"bar\\\"\"\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_dhcp_options\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_dhcp_options ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"bar\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 10.0.0.2 && ip4.dst == {10.0.0.1, 255.255.255.255} && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"bar\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- NAT and Load Balancer flows])\n\n# Determine if expected flows are present. The only parameter to this\n# function is the number of expected flows per NAT destination address.\n# This should always be either 0 or 1. 0 means that we do not expect\n# lflows to be present. 1 means we expect an lflow to be present\ncheck_lflows() {\n    expected=$1\n    ro1_flows=$(ovn-sbctl lflow-list ro1)\n\n    ro1_ip_routing=$(grep lr_in_ip_routing <<< \"$ro1_flows\")\n    match=$(grep -c \"match=(ip4.dst == 20.0.0.100/32)\" <<< \"$ro1_ip_routing\")\n    AT_CHECK([test \"$expected\" = \"$match\"])\n\n    ro1_arp_resolve=$(grep lr_in_arp_resolve <<< \"$ro1_flows\")\n    match=$(grep -c 'match=(outport == \"ro1-sw\" && reg0 == {20.0.0.100})' <<< \"$ro1_arp_resolve\")\n    AT_CHECK([test \"$expected\" = \"$match\"])\n\n    ro2_flows=$(ovn-sbctl lflow-list ro2)\n\n    ro2_ip_routing=$(grep lr_in_ip_routing <<< \"$ro2_flows\")\n    match=$(grep -c \"match=(ip4.dst == 10.0.0.100/32)\" <<< \"$ro2_ip_routing\")\n    AT_CHECK([test \"$expected\" = \"$match\"])\n\n    ro2_arp_resolve=$(grep lr_in_arp_resolve <<< \"$ro2_flows\")\n    match=$(grep -c 'match=(outport == \"ro2-sw\" && reg0 == {10.0.0.100})' <<< \"$ro2_arp_resolve\")\n    AT_CHECK([test \"$expected\" = \"$match\"])\n}\n\novn_start\n\nAS_BOX([Setting up the logical network])\n\ncheck ovn-nbctl ls-add sw\n\ncheck ovn-nbctl lr-add ro1\ncheck ovn-nbctl lrp-add ro1 ro1-sw 00:00:00:00:00:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw sw-ro1\n\ncheck ovn-nbctl lr-add ro2\ncheck ovn-nbctl lrp-add ro2 ro2-sw 00:00:00:00:00:02 20.0.0.1/24\ncheck ovn-nbctl --wait=sb lsp-add sw sw-ro2\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl lsp-add ls1 vm1\ncheck ovn-nbctl lsp-set-addresses vm1 \"00:00:00:00:01:02 192.168.1.2\"\ncheck ovn-nbctl lrp-add ro1 ro1-ls1 00:00:00:00:01:01 192.168.1.1/24\ncheck ovn-nbctl lsp-add ls1 ls1-ro1\ncheck ovn-nbctl lsp-set-type ls1-ro1 router\ncheck ovn-nbctl lsp-set-addresses ls1-ro1 router\ncheck ovn-nbctl lsp-set-options ls1-ro1 router-port=ro1-ls1\n\ncheck ovn-nbctl ls-add ls2\ncheck ovn-nbctl lsp-add ls2 vm2\ncheck ovn-nbctl lsp-set-addresses vm2 \"00:00:00:00:02:02 192.168.2.2\"\ncheck ovn-nbctl lrp-add ro2 ro2-ls2 00:00:00:00:02:01 192.168.2.1/24\ncheck ovn-nbctl lsp-add ls2 ls2-ro2\ncheck ovn-nbctl lsp-set-type ls2-ro2 router\ncheck ovn-nbctl lsp-set-addresses ls2-ro2 router\ncheck ovn-nbctl lsp-set-options ls2-ro2 router-port=ro2-ls2\n\ncheck ovn-nbctl ha-chassis-group-add grp1\ncheck ovn-nbctl ha-chassis-group-add-chassis grp1 hv1 100\ngrp1_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp1)\n\ncheck ovn-nbctl ha-chassis-group-add grp2\ncheck ovn-nbctl ha-chassis-group-add-chassis grp2 hv2 100\ngrp2_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp2)\n\nAS_BOX([Checking that unconnected logical switch ports generate no lflows])\n\ncheck_lflows 0\n\nAS_BOX([Checking that connected logical switch ports have no lflows for non-gateway ports])\n\ncheck ovn-nbctl lsp-set-type sw-ro1 router\ncheck ovn-nbctl lsp-set-addresses sw-ro1 router\ncheck ovn-nbctl lsp-set-options sw-ro1 router-port=ro1-sw\n\ncheck ovn-nbctl lsp-set-type sw-ro2 router\ncheck ovn-nbctl lsp-set-addresses sw-ro2 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw-ro2 router-port=ro2-sw\n\ncheck_lflows 0\n\nAS_BOX([Checking that NAT flows are not installed for non-gateway routers])\n\ncheck ovn-nbctl lr-nat-add ro1 dnat 10.0.0.100 192.168.1.100\ncheck ovn-nbctl lr-nat-add ro2 dnat 20.0.0.100 192.168.2.100\n\ncheck_lflows 0\n\nAS_BOX([Checking that non-routable NAT flows are not installed for gateway routers])\n\ncheck ovn-nbctl lrp-set-gateway-chassis ro1-sw hv1 100\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis ro2-sw hv2 100\n\ncheck_lflows 0\n\nAS_BOX([Checking that routable NAT flows are installed when gateway chassis exists])\n\ncheck ovn-nbctl lr-nat-del ro1\ncheck ovn-nbctl lr-nat-del ro2\ncheck ovn-nbctl --add-route lr-nat-add ro1 dnat 10.0.0.100 192.168.1.100\ncheck ovn-nbctl --wait=sb --add-route lr-nat-add ro2 dnat 20.0.0.100 192.168.2.100\n\ncheck_lflows 1\n\nAS_BOX([Checking that NAT flows are not installed for routers with gateway chassis removed])\n\ncheck ovn-nbctl lrp-del-gateway-chassis ro1-sw hv1\ncheck ovn-nbctl --wait=sb lrp-del-gateway-chassis ro2-sw hv2\n\ncheck_lflows 0\n\nAS_BOX([Checking that NAT flows are installed for routers with HA_Chassis_Group])\n\ncheck ovn-nbctl set logical_router_port ro1-sw ha_chassis_group=\"$grp1_uuid\"\ncheck ovn-nbctl --wait=sb set logical_router_port ro2-sw ha_chassis_group=\"$grp2_uuid\"\n\ncheck_lflows 1\n\nAS_BOX([Checking that NAT flows are not installed for routers with HA_Chassis_Group removed])\n\ncheck ovn-nbctl clear logical_router_port ro1-sw ha_chassis_group\ncheck ovn-nbctl --wait=sb clear logical_router_port ro2-sw ha_chassis_group\n\ncheck_lflows 0\n\nAS_BOX([Checking that Floating IP NAT flows are not installed with no gateway port set])\n\ncheck ovn-nbctl lr-nat-del ro1\ncheck ovn-nbctl lr-nat-del ro2\n\ncheck ovn-nbctl lr-nat-add ro1 dnat_and_snat 10.0.0.100 192.168.1.2 vm1 00:00:00:00:00:01\ncheck ovn-nbctl --wait=sb lr-nat-add ro2 dnat_and_snat 20.0.0.100 192.168.2.2 vm2 00:00:00:00:00:02\n\ncheck_lflows 0\n\nAS_BOX([Checking that non-routable Floating IP NAT flows are not installed for gateway routers])\n\ncheck ovn-nbctl lrp-set-gateway-chassis ro1-sw hv1 100\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis ro2-sw hv2 100\n\ncheck_lflows 0\n\nAS_BOX([Checking that routable Floating IP NAT flows are installed for gateway routers])\ncheck ovn-nbctl lr-nat-del ro1\ncheck ovn-nbctl lr-nat-del ro2\n\ncheck ovn-nbctl --add-route lr-nat-add ro1 dnat_and_snat 10.0.0.100 192.168.1.2 vm1 00:00:00:00:00:01\ncheck ovn-nbctl --wait=sb --add-route lr-nat-add ro2 dnat_and_snat 20.0.0.100 192.168.2.2 vm2 00:00:00:00:00:02\n\ncheck_lflows 1\n\nAS_BOX([Checking that Floating IP NAT flows are not installed for routers with gateway chassis removed])\n\ncheck ovn-nbctl lrp-del-gateway-chassis ro1-sw hv1\ncheck ovn-nbctl --wait=sb lrp-del-gateway-chassis ro2-sw hv2\n\ncheck_lflows 0\n\nAS_BOX([Checking that Floating IP NAT flows are installed for routers with ha_chassis_group])\n\ngrp1_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp1)\ncheck ovn-nbctl set logical_router_port ro1-sw ha_chassis_group=\"$grp1_uuid\"\n\ngrp2_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp2)\ncheck ovn-nbctl --wait=sb set logical_router_port ro2-sw ha_chassis_group=\"$grp2_uuid\"\n\ncheck_lflows 1\n\nAS_BOX([Checking that Floating IP NAT flows are not installed for routers with HA_Chassis_Group removed])\n\ncheck ovn-nbctl clear logical_router_port ro1-sw ha_chassis_group\ncheck ovn-nbctl --wait=sb clear logical_router_port ro2-sw ha_chassis_group\n\ncheck_lflows 0\n\nAS_BOX([Checking that Load Balancer VIP flows are not installed for routers with no gateway port])\n\ncheck ovn-nbctl lr-nat-del ro1\ncheck ovn-nbctl lr-nat-del ro2\n\ncheck ovn-nbctl lb-add lb1 10.0.0.100 192.168.1.2\ncheck ovn-nbctl lr-lb-add ro1 lb1\n\ncheck ovn-nbctl lb-add lb2 20.0.0.100 192.168.2.2\ncheck ovn-nbctl --wait=sb lr-lb-add ro2 lb2\n\ncheck_lflows 0\n\nAS_BOX([Checking that non-routable Load Balancer VIP flows are not installed for gateway routers])\n\ncheck ovn-nbctl lrp-set-gateway-chassis ro1-sw hv1 100\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis ro2-sw hv2 100\n\ncheck_lflows 0\n\nAS_BOX([Checking that routable Load Balancer VIP flows are installed for gateway routers])\n\ncheck ovn-nbctl lr-lb-del ro1 lb1\ncheck ovn-nbctl lr-lb-del ro2 lb2\ncheck ovn-nbctl lb-del lb1\ncheck ovn-nbctl lb-del lb2\n\ncheck ovn-nbctl --add-route lb-add lb1 10.0.0.100 192.168.1.2\ncheck ovn-nbctl --add-route lb-add lb2 20.0.0.100 192.168.2.2\ncheck ovn-nbctl lr-lb-add ro1 lb1\ncheck ovn-nbctl --wait=sb lr-lb-add ro2 lb2\n\ncheck_lflows 1\n\nAS_BOX([Checking that Load Balancer VIP flows are not installed for routers with gateway chassis removed])\n\ncheck ovn-nbctl lrp-del-gateway-chassis ro1-sw hv1\ncheck ovn-nbctl --wait=sb lrp-del-gateway-chassis ro2-sw hv2\n\ncheck_lflows 0\n\nAS_BOX([Checking that Load Balancer VIP flows are installed for routers with ha_chassis_group])\n\ngrp1_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp1)\ncheck ovn-nbctl set logical_router_port ro1-sw ha_chassis_group=\"$grp1_uuid\"\n\ngrp2_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp2)\ncheck ovn-nbctl --wait=sb set logical_router_port ro2-sw ha_chassis_group=\"$grp2_uuid\"\n\ncheck_lflows 1\n\nAS_BOX([Checking that Load Balancer VIP flows are not iinstalled for routers with HA_Chassis_Group removed])\n\ncheck ovn-nbctl clear logical_router_port ro1-sw ha_chassis_group\ncheck ovn-nbctl --wait=sb clear logical_router_port ro2-sw ha_chassis_group\n\ncheck_lflows 0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- ARP flows for unreachable addresses - NAT and LB])\novn_start\n\nAS_BOX([Setting up the logical network])\n\n# This network is the same as the one from \"Router Address Propagation\"\ncheck ovn-nbctl ls-add sw\n\ncheck ovn-nbctl lr-add ro1\ncheck ovn-nbctl lrp-add ro1 ro1-sw 00:00:00:00:00:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw sw-ro1\ncheck ovn-nbctl lsp-set-type sw-ro1 router\ncheck ovn-nbctl lsp-set-addresses sw-ro1 router\ncheck ovn-nbctl lsp-set-options sw-ro1 router-port=ro1-sw\n\ncheck ovn-nbctl lr-add ro2\ncheck ovn-nbctl lrp-add ro2 ro2-sw 00:00:00:00:00:02 20.0.0.1/24\ncheck ovn-nbctl lsp-add sw sw-ro2\ncheck ovn-nbctl lsp-set-type sw-ro2 router\ncheck ovn-nbctl lsp-set-addresses sw-ro2 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw-ro2 router-port=ro2-sw\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl lsp-add ls1 vm1\ncheck ovn-nbctl lsp-set-addresses vm1 \"00:00:00:00:01:02 192.168.1.2\"\ncheck ovn-nbctl lrp-add ro1 ro1-ls1 00:00:00:00:01:01 192.168.1.1/24\ncheck ovn-nbctl lsp-add ls1 ls1-ro1\ncheck ovn-nbctl lsp-set-type ls1-ro1 router\ncheck ovn-nbctl lsp-set-addresses ls1-ro1 router\ncheck ovn-nbctl lsp-set-options ls1-ro1 router-port=ro1-ls1\n\ncheck ovn-nbctl ls-add ls2\ncheck ovn-nbctl lsp-add ls2 vm2\ncheck ovn-nbctl lsp-set-addresses vm2 \"00:00:00:00:02:02 192.168.2.2\"\ncheck ovn-nbctl lrp-add ro2 ro2-ls2 00:00:00:00:02:01 192.168.2.1/24\ncheck ovn-nbctl lsp-add ls2 ls2-ro2\ncheck ovn-nbctl lsp-set-type ls2-ro2 router\ncheck ovn-nbctl lsp-set-addresses ls2-ro2 router\ncheck ovn-nbctl lsp-set-options ls2-ro2 router-port=ro2-ls2\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\novn-sbctl lflow-list ls2 > ls2_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls2_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:01), action=(outport = \"ls2-ro2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:02), action=(outport = \"vm2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:02:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.2.1), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:201), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\nAS_BOX([Adding some reachable NAT addresses])\n\ncheck ovn-nbctl lr-nat-add ro1 dnat 10.0.0.100 192.168.1.100\ncheck ovn-nbctl lr-nat-add ro1 snat 10.0.0.200 192.168.1.200/30\n\ncheck ovn-nbctl lr-nat-add ro2 dnat 20.0.0.100 192.168.2.100\ncheck ovn-nbctl --wait=sb lr-nat-add ro2 snat 20.0.0.200 192.168.2.200/30\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\novn-sbctl lflow-list ls2 > ls2_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls2_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:01), action=(outport = \"ls2-ro2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:02), action=(outport = \"vm2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:02:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.2.1), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 20.0.0.100), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:201), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\nAS_BOX([Adding some unreachable NAT addresses])\n\ncheck ovn-nbctl lr-nat-add ro1 dnat 30.0.0.100 192.168.1.130\ncheck ovn-nbctl lr-nat-add ro1 snat 30.0.0.200 192.168.1.148/30\n\ncheck ovn-nbctl lr-nat-add ro2 dnat 40.0.0.100 192.168.2.130\ncheck ovn-nbctl --wait=sb lr-nat-add ro2 snat 40.0.0.200 192.168.2.148/30\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\novn-sbctl lflow-list ls2 > ls2_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls2_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:01), action=(outport = \"ls2-ro2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:02), action=(outport = \"vm2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:02:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.2.1), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 20.0.0.100), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 40.0.0.100), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:201), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\nAS_BOX([Adding load balancer reachable VIPs to ro1])\n\novn-nbctl lb-add lb1 192.168.1.100:80 10.0.0.10:80\novn-nbctl --wait=sb lr-lb-add ro1 lb1\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\nAS_BOX([Adding load balancer unreachable VIPs to ro1])\novn-nbctl --wait=sb lb-add lb1 192.168.4.100:80 10.0.0.10:80\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\n# Make sure that there is no flow for VIP 192.168.4.100 as ro1-ls1 doesn't\n# have a gw router port or is not a gateway router.\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | grep \"192.168.4.100\" | grep \"_MC_flood\" -c], [1], [0\n])\n\nAS_BOX([Configuring ro1-ls1 router port as a gateway router port])\n\novn-nbctl --wait=sb lrp-set-gateway-chassis ro1-ls1 chassis-1 30\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\n\n# Make sure that there is no flow for VIP 192.168.4.100 as it is unreachable.\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | grep \"192.168.4.100\" | grep -v clone | grep \"_MC_flood\" -c], [1], [0\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- LR NAT flows])\novn_start\n\ncheck ovn-nbctl \\\n    -- ls-add sw0 \\\n    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080 \\\n    -- ls-lb-add sw0 lb0\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\n# Create few dnat_and_snat entries\n\ncheck ovn-nbctl lr-nat-add lr0 snat 172.168.0.10 10.0.0.0/24\ncheck ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.168.0.20 10.0.0.3\ncheck ovn-nbctl lr-nat-add lr0 snat 172.168.0.30 10.0.0.10\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\ncheck ovn-sbctl chassis-add gw1 geneve 127.0.0.1 \\\n  -- set chassis gw1 other_config:ct-no-masked-label=\"true\" \\\n  -- set chassis gw1 other_config:ovn-ct-lb-related=\"true\"\n\n# Create a distributed gw port on lr0\ncheck ovn-nbctl ls-add public\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:00:00:ff:02 172.168.0.10/24\ncheck ovn-nbctl lrp-set-gateway-chassis lr0-public gw1\n\novn-nbctl lsp-add public public-lr0 -- set Logical_Switch_Port public-lr0 \\\n    type=router options:router-port=lr0-public \\\n    -- lsp-set-addresses public-lr0 router\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone(10.0.0.3);)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.10 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.20 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.30 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=153  , match=(ip && ip4.src == 10.0.0.0/24 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=154  , match=(ip && ip4.src == 10.0.0.0/24 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.10 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.20);)\n  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.10 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.20);)\n])\n\n# Associate load balancer to lr0\n\ncheck ovn-nbctl lb-add lb0 172.168.0.100:8082 \"10.0.0.50:82,10.0.0.60:82\"\n\n# No L4\ncheck ovn-nbctl lb-add lb1 172.168.0.200 \"10.0.0.80,10.0.0.81\"\ncheck ovn-nbctl lb-add lb2 172.168.0.210:60 \"10.0.0.50:6062,10.0.0.60:6062\" udp\n\ncheck ovn-nbctl lr-lb-add lr0 lb0\ncheck ovn-nbctl lr-lb-add lr0 lb1\ncheck ovn-nbctl lr-lb-add lr0 lb2\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone(10.0.0.3);)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_lb_mark(backends=10.0.0.80,10.0.0.81);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_lb_mark(backends=10.0.0.4:8080);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.10 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.20 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.30 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.4 && tcp.src == 8080)) && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.50 && tcp.src == 82) || (ip4.src == 10.0.0.60 && tcp.src == 82)) && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.50 && udp.src == 6062) || (ip4.src == 10.0.0.60 && udp.src == 6062)) && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.80) || (ip4.src == 10.0.0.81)) && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=153  , match=(ip && ip4.src == 10.0.0.0/24 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=154  , match=(ip && ip4.src == 10.0.0.0/24 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.10 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.20);)\n  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.10 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.20);)\n])\n\n# Make the logical router as Gateway router\ncheck ovn-nbctl clear logical_router_port lr0-public gateway_chassis\ncheck ovn-nbctl set logical_router lr0 options:chassis=gw1\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(ct_lb_mark(backends=10.0.0.80,10.0.0.81);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.4:8080);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)\n])\n\n\n# Set lb force snat logical router.\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip=\"router_ip\"\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.80,10.0.0.81; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-public\"), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw0\"), action=(ct_snat(10.0.0.1);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)\n])\n\n# Add a LB VIP same as router ip.\ncheck ovn-nbctl lb-add lb0 172.168.0.10:9082 \"10.0.0.50:82,10.0.0.60:82\"\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.80,10.0.0.81; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-public\"), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw0\"), action=(ct_snat(10.0.0.1);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)\n])\n\n# Add IPv6 router port and LB.\ncheck ovn-nbctl lrp-del lr0-sw0\ncheck ovn-nbctl lrp-del lr0-public\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 aef0::1\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:00:00:ff:02 172.168.0.10/24 def0::10\n\nlb1_uuid=$(fetch_column nb:Load_Balancer _uuid name=lb1)\novn-nbctl set load_balancer $lb1_uuid vips:'\"[[def0::2]]:8000\"'='\"@<:@aef0::2@:>@:80,@<:@aef0::3@:>@:80\"'\n\novn-nbctl list load_Balancer\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip6.dst == def0::10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip6.dst == aef0::1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip6.dst == def0::2), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.80,10.0.0.81; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip6 && ip6.dst == def0::2 && tcp && tcp.dst == 8000), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=[[aef0::2]]:80,[[aef0::3]]:80; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-public\"), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw0\"), action=(ct_snat(10.0.0.1);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip6 && outport == \"lr0-public\"), action=(ct_snat(def0::10);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip6 && outport == \"lr0-sw0\"), action=(ct_snat(aef0::1);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)\n])\n\ncheck ovn-nbctl lrp-del lr0-sw0\ncheck ovn-nbctl lrp-del lr0-public\ncheck ovn-nbctl lr-lb-del lr0\ncheck ovn-nbctl lr-nat-del lr0\n\ncheck ovn-nbctl lb-add lb3 172.168.0.210:60 \"10.0.0.50:6062,10.0.0.60:6062\" udp\ncheck ovn-nbctl lb-add lb4 172.168.0.210:60 \"10.0.0.50:6062,10.0.0.60:6062\" tcp\ncheck ovn-nbctl lr-lb-add lr0 lb3\ncheck ovn-nbctl lr-lb-add lr0 lb4\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && tcp && tcp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\n# LB with reject configured\ncheck ovn-nbctl --wait=sb remove logical_router lr0 options lb_force_snat_ip\ncheck ovn-nbctl --wait=sb sync\n\ncheck ovn-nbctl lr-lb-del lr0\ncheck ovn-nbctl lsp-add sw0 vip1\ncheck ovn-nbctl lsp-add sw0 vip2\ncheck ovn-nbctl --reject lb-add lb5 172.168.10.10 10.0.20.10,10.0.20.20\ncheck ovn-nbctl --wait=sb set load_balancer lb5 ip_port_mappings:10.0.20.10=vip1:10.0.0.2\ncheck ovn-nbctl --wait=sb set load_balancer lb5 ip_port_mappings:10.0.20.20=vip2:20.0.0.2\n\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb5\nAT_CHECK([ovn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"172.168.10.10\" -- add Load_Balancer lb5 \\\nhealth_check @hc | uuidfilt], [0], [<0>\n])\nwait_row_count Service_Monitor 2\n\n# Set the service monitor for vip1 and vip2 to offline\nsm_vip1=$(fetch_column Service_Monitor _uuid logical_port=vip1)\nsm_vip2=$(fetch_column Service_Monitor _uuid logical_port=vip2)\n\novn-sbctl set service_monitor $sm_vip1 status=offline\novn-sbctl set service_monitor $sm_vip2 status=offline\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.10), action=(reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=3);};)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\n# LB with reject and skip_snat\ncheck ovn-nbctl --wait=sb set load_balancer lb5 options:skip_snat=true\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.10), action=(flags.skip_snat_for_lb = 1; reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=3);};)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\ncheck ovn-nbctl --wait=sb remove load_balancer lb5 options skip_snat\n\n# LB with reject and force_snat\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip=\"router_ip\"\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.10), action=(flags.force_snat_for_lb = 1; reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=3);};)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\n# LB with event=false and reject=false\ncheck ovn-nbctl lr-lb-del lr0\ncheck ovn-nbctl remove logical_router lr0 options lb_force_snat_ip\nAT_CHECK([ovn-nbctl create load_balancer name=lb6 options:reject=false options:event=false vips:\\\"172.168.10.30\\\"=\\\"\\\" protocol=tcp], [0], [ignore])\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb6\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.30), action=(drop;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\n# LB with event=false, reject=false and skip_snat\ncheck ovn-nbctl --wait=sb set load_balancer lb6 options:skip_snat=true\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.30), action=(flags.skip_snat_for_lb = 1; drop;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\ncheck ovn-nbctl remove load_balancer lb6 options skip_snat\n\n# LB with event=false, reject=false and force_snat\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip=\"router_ip\"\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.30), action=(flags.force_snat_for_lb = 1; drop;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load Balancer SB duplicates])\novn_start\n\ncheck ovn-nbctl ls-add ls -- lb-add lb1 10.0.0.1:80 10.0.0.2:80 -- ls-lb-add ls lb1\ncheck ovn-nbctl --wait=sb sync\n\ndps=$(fetch_column Load_Balancer datapath_group)\nnlb=$(fetch_column nb:Load_Balancer _uuid)\nAT_CHECK([ovn-sbctl create Load_Balancer name=lb1 datapath_group=\"$dps\" external_ids=\"lb_id=$nlb\"], [0], [ignore])\n\ncheck ovn-nbctl --wait=sb sync\ncheck_row_count Load_Balancer 1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- Add tags to logical flows])\novn_start\n\ncheck ovn-nbctl \\\n    -- ls-add sw0 \\\n    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080 \\\n    -- ls-lb-add sw0 lb0\n\ncheck ovn-nbctl lsp-add sw0 lsp0 \\\n    -- lsp-set-addresses lsp0 \"00:00:00:00:ff:01 1.2.3.4\" \\\n    -- lsp-set-port-security lsp0 \"00:00:00:00:ff:01 1.2.3.4\"\n\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl --columns=tags list logical_flow | grep lsp0 -c], [0], [dnl\n1\n])\n\ncheck ovn-nbctl set logical_switch_port lsp0 enabled=false\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl --columns=tags list logical_flow | grep lsp0 -c], [0], [dnl\n3\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- gateway mtu check pkt larger flows])\novn_start\n\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.1\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\n\n# Create a logical router and attach both logical switches\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\ncheck ovn-nbctl lsp-add sw1 sw1-lr0\ncheck ovn-nbctl lsp-set-type sw1-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\ncheck ovn-nbctl ls-add public\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24\ncheck ovn-nbctl lsp-add public public-lr0\ncheck ovn-nbctl lsp-set-type public-lr0 router\ncheck ovn-nbctl lsp-set-addresses public-lr0 router\ncheck ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public\n\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis lr0-public ch1\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-public options:gateway_mtu=1500\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\n\nAT_CHECK([grep -E \"lr_in_admission.*check_pkt_larger\" lr0flows | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n])\n\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp4_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp6_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\n\n# Clear the gateway-chassis for lr0-public\ncheck ovn-nbctl --wait=sb clear logical_router_port lr0-public gateway_chassis\n\n# Make lr0 as a gateway router.\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:chassis=ch1\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\n\nAT_CHECK([grep -E \"lr_in_admission.*check_pkt_larger\" lr0flows | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n])\n\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp4_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp6_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\n\n# Set gateway_mtu_bypass to avoid check_pkt_larger() for tcp on lr0-public.\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-public options:gateway_mtu_bypass=tcp\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == \"lr0-public\" && (tcp)), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\n\nAT_CHECK([grep \"lr_in_admission\" lr0flows | grep -e \"check_pkt_larger\" -e \"tcp\" | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.mcast && inport == \"lr0-public\" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n])\n\n# Set gateway_mtu option on lr0-sw0\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-sw0 options:gateway_mtu=1400\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == \"lr0-public\" && (tcp)), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n])\n\nAT_CHECK([grep \"lr_in_admission.*check_pkt_larger\" lr0flows | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:ff:01 && inport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n])\n\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp4_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n])\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp6_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n])\n\n# Set gateway_mtu_bypass to avoid check_pkt_larger() for tcp on lr0-sw0.\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-sw0 options:gateway_mtu_bypass=tcp\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == \"lr0-public\" && (tcp)), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == \"lr0-sw0\" && (tcp)), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n])\n\nAT_CHECK([grep \"lr_in_admission\" lr0flows | grep -e \"check_pkt_larger\" -e \"tcp\" | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:ff:01 && inport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.dst == 00:00:00:00:ff:01 && inport == \"lr0-sw0\" && (tcp)), action=(xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.mcast && inport == \"lr0-public\" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.mcast && inport == \"lr0-sw0\" && (tcp)), action=(xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n])\n\n# Clear gateway_mtu option on lr0-public\ncheck ovn-nbctl --wait=sb clear logical_router_port lr0-public options\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == \"lr0-sw0\" && (tcp)), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n])\n\ncheck ovn-nbctl --wait=sb clear logical_router_port lr0-sw0 options\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-public options:gateway_mtu=1500\ncheck ovn-nbctl lsp-add public ext-port\ncheck ovn-nbctl lsp-set-addresses ext-port unknown\ncheck ovn-nbctl lsp-set-type ext-port localnet\ncheck ovn-nbctl --wait=sb set Logical_Switch_Port ext-port tag_request=2\novn-sbctl dump-flows lr0 > lr0flows\n\nAT_CHECK([grep \"lr_in_admission\" lr0flows | grep -e \"check_pkt_larger\" | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1518); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1518); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- static routes flows])\nAT_KEYWORDS([static-routes-flows])\novn_start\n\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.1\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl set logical_router lr0 options:chassis=ch1\ncheck ovn-nbctl ls-add public\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 192.168.0.1/24\ncheck ovn-nbctl lsp-add public public-lr0\ncheck ovn-nbctl lsp-set-type public-lr0 router\ncheck ovn-nbctl lsp-set-addresses public-lr0 router\ncheck ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public\n\ncheck ovn-nbctl --wait=sb --ecmp-symmetric-reply lr-route-add lr0 1.0.0.1 192.168.0.10\n\novn-sbctl dump-flows lr0 > lr0flows\n\nAT_CHECK([grep -e \"lr_in_ip_routing.*select\" lr0flows |sort], [0], [dnl\n])\nAT_CHECK([grep -e \"lr_in_ip_routing_ecmp\" lr0flows | sed 's/table=../table=??/' |sort], [0], [dnl\n  table=??(lr_in_ip_routing_ecmp), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_ip_routing_ecmp), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb --ecmp-symmetric-reply lr-route-add lr0 1.0.0.1 192.168.0.20\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CHECK([grep -e \"lr_in_ip_routing.*select\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=97   , match=(reg7 == 0 && ip4.dst == 1.0.0.1/32), action=(ip.ttl--; flags.loopback = 1; reg8[[0..15]] = 1; reg8[[16..31]] = select(1, 2);)\n])\nAT_CHECK([grep -e \"lr_in_ip_routing_ecmp\" lr0flows | sed 's/192\\.168\\.0\\..0/192.168.0.??/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing_ecmp), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 1), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; next;)\n  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 2), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; next;)\n  table=??(lr_in_ip_routing_ecmp), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)\n])\n\nAT_CHECK([grep -e \"lr_in_ecmp_stateful\".*commit_ecmp_nh lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (!ct.rpl && ct.est) && sctp && reg9[[5]] == 0), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = sctp); next;)\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (!ct.rpl && ct.est) && tcp && reg9[[5]] == 0), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = tcp); next;)\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (!ct.rpl && ct.est) && udp && reg9[[5]] == 0), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = udp); next;)\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (ct.new && !ct.est) && sctp), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = sctp); next;)\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (ct.new && !ct.est) && tcp), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = tcp); next;)\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (ct.new && !ct.est) && udp), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = udp); next;)\n])\n\nAT_CHECK([grep -e \"lr_in_defrag\".*chk_ecmp_nh* lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_defrag       ), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1), action=(reg9[[5]] = chk_ecmp_nh_mac(); ct_next;)\n  table=??(lr_in_defrag       ), priority=100  , match=(reg7 == 0 && ip4.dst == 1.0.0.1/32), action=(reg9[[5]] = chk_ecmp_nh(); ct_next;)\n])\n\ndnl The chassis was created with other_config:ct-no-masked-label=false, the flows\ndnl should be using ct_label.ecmp_reply_port.\nAT_CHECK([grep -e \"lr_in_arp_resolve.*ecmp\" lr0flows | sed 's/table=../table=??/'], [0], [dnl\n  table=??(lr_in_arp_resolve  ), priority=200  , match=(ct.rpl && reg9[[5]] == 1 && ct_label.ecmp_reply_port == 1), action=(push(xxreg1); xxreg1 = ct_label; eth.dst = xxreg1[[32..79]]; pop(xxreg1); next;)\n])\n\ndnl Simulate an ovn-controller upgrade to a version that supports\ndnl ct-no-masked-label.  ovn-northd should start using ct_mark.ecmp_reply_port.\n\ncheck ovn-sbctl set chassis ch1 other_config:ct-no-masked-label=true\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows lr0 > lr0flows\nAT_CHECK([grep -e \"lr_in_arp_resolve.*ecmp\" lr0flows | sed 's/table=../table=??/'], [0], [dnl\n  table=??(lr_in_arp_resolve  ), priority=200  , match=(ct.rpl && reg9[[5]] == 1 && ct_mark.ecmp_reply_port == 1), action=(push(xxreg1); xxreg1 = ct_label; eth.dst = xxreg1[[32..79]]; pop(xxreg1); next;)\n])\n\n# add ecmp route with wrong nexthop\ncheck ovn-nbctl --wait=sb --ecmp-symmetric-reply lr-route-add lr0 1.0.0.1 192.168.1.20\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CHECK([grep -e \"lr_in_ip_routing.*select\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=97   , match=(reg7 == 0 && ip4.dst == 1.0.0.1/32), action=(ip.ttl--; flags.loopback = 1; reg8[[0..15]] = 1; reg8[[16..31]] = select(1, 2);)\n])\nAT_CHECK([grep -e \"lr_in_ip_routing_ecmp\" lr0flows | sed 's/192\\.168\\.0\\..0/192.168.0.??/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing_ecmp), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 1), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; next;)\n  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 2), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; next;)\n  table=??(lr_in_ip_routing_ecmp), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)\n])\n\ncheck ovn-nbctl lr-route-del lr0\nwait_row_count nb:Logical_Router_Static_Route 0\n\ncheck ovn-nbctl --wait=sb lr-route-add lr0 1.0.0.0/24 192.168.0.10\novn-sbctl dump-flows lr0 > lr0flows\n\nAT_CHECK([grep -e \"lr_in_ip_routing.*192.168.0.10\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=73   , match=(reg7 == 0 && ip4.dst == 1.0.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.10; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n])\n\ncheck ovn-nbctl --wait=sb lr-route-add lr0 2.0.0.0/24 lr0-public\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CHECK([grep -e \"lr_in_ip_routing.*2.0.0.0\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=73   , match=(reg7 == 0 && ip4.dst == 2.0.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd -- lr multiple gw ports])\nAT_KEYWORDS([multiple-l3dgw-ports])\novn_start\n\n# Logical network:\n# 1 Logical Router, 3 bridged Logical Switches,\n# 1 gateway chassis attached to each corresponding LRP.\n#\n#                | S1 (gw1)\n#                |\n#      ls  ----  DR -- S3 (gw3)\n# (20.0.0.0/24)  |\n#                | S2 (gw2)\n#\n# Validate basic LR logical flows.\n\ncheck ovn-sbctl chassis-add gw1 geneve 127.0.0.1\ncheck ovn-sbctl chassis-add gw2 geneve 128.0.0.1\ncheck ovn-sbctl chassis-add gw3 geneve 129.0.0.1\n\ncheck ovn-nbctl lr-add DR\ncheck ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24\ncheck ovn-nbctl lrp-add DR DR-S2 03:ac:10:01:00:01 172.16.2.1/24\ncheck ovn-nbctl lrp-add DR DR-S3 04:ac:10:01:00:01 172.16.3.1/24\ncheck ovn-nbctl lrp-add DR DR-ls 05:ac:10:01:00:01 20.0.0.1/24\n\ncheck ovn-nbctl ls-add S1\ncheck ovn-nbctl lsp-add S1 S1-DR\ncheck ovn-nbctl lsp-set-type S1-DR router\ncheck ovn-nbctl lsp-set-addresses S1-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1\n\ncheck ovn-nbctl ls-add S2\ncheck ovn-nbctl lsp-add S2 S2-DR\ncheck ovn-nbctl lsp-set-type S2-DR router\ncheck ovn-nbctl lsp-set-addresses S2-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S2-DR router-port=DR-S2\n\ncheck ovn-nbctl ls-add S3\ncheck ovn-nbctl lsp-add S3 S3-DR\ncheck ovn-nbctl lsp-set-type S3-DR router\ncheck ovn-nbctl lsp-set-addresses S3-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S3-DR router-port=DR-S3\n\ncheck ovn-nbctl ls-add  ls\ncheck ovn-nbctl lsp-add ls ls-DR\ncheck ovn-nbctl lsp-set-type ls-DR router\ncheck ovn-nbctl lsp-set-addresses ls-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options ls-DR router-port=DR-ls\n\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S1 gw1\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S2 gw2\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S3 gw3\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > lrflows\nAT_CAPTURE_FILE([lrflows])\n\n# Check the flows in lr_in_admission stage\nAT_CHECK([grep lr_in_admission lrflows | grep cr-DR | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 02:ac:10:01:00:01 && inport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(xreg0[[0..47]] = 02:ac:10:01:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 03:ac:10:01:00:01 && inport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(xreg0[[0..47]] = 03:ac:10:01:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 04:ac:10:01:00:01 && inport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(xreg0[[0..47]] = 04:ac:10:01:00:01; next;)\n])\n# Check the flows in lr_in_lookup_neighbor stage\nAT_CHECK([grep lr_in_lookup_neighbor lrflows | grep cr-DR | sort], [0], [dnl\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(inport == \"DR-S1\" && arp.spa == 172.16.1.0/24 && arp.op == 1 && is_chassis_resident(\"cr-DR-S1\")), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(inport == \"DR-S2\" && arp.spa == 172.16.2.0/24 && arp.op == 1 && is_chassis_resident(\"cr-DR-S2\")), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(inport == \"DR-S3\" && arp.spa == 172.16.3.0/24 && arp.op == 1 && is_chassis_resident(\"cr-DR-S3\")), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)\n])\n# Check the flows in lr_in_gw_redirect stage\nAT_CHECK([grep lr_in_gw_redirect lrflows | grep cr-DR | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == \"DR-S1\"), action=(outport = \"cr-DR-S1\"; next;)\n  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == \"DR-S2\"), action=(outport = \"cr-DR-S2\"; next;)\n  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == \"DR-S3\"), action=(outport = \"cr-DR-S3\"; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd -- lrp with chassis-redirect and ls with vtep lport])\nAT_KEYWORDS([multiple-l3dgw-ports])\novn_start NORTHD_TYPE\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.2\n\ncheck ovn-nbctl lr-add lr1\ncheck ovn-nbctl lrp-add lr1 lrp1 00:00:00:00:00:01 10.0.0.1/24\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl lsp-add ls1 lsp1 -- \\\n    lsp-set-addresses lsp1 router -- \\\n    lsp-set-type lsp1 router -- \\\n    lsp-set-options lsp1 router-port=lrp1\n\n# ensure initial flows are installed without is_chassis_resident match part\novn-nbctl --wait=sb sync\novn-sbctl dump-flows lr1 > lrflows\nAT_CAPTURE_FILE([lrflows])\n\n# Check the flows in lr_in_admission stage\nAT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n])\n\n# Check the flows in lr_in_gw_redirect stage\nAT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [])\n\nwait_row_count Port_Binding 0 logical_port=cr-lrp1 options:always-redirect=\"true\"\n\n# make lrp a cr-port and check its flows\ncheck ovn-nbctl lrp-set-gateway-chassis lrp1 ch1\n\novn-nbctl --wait=sb sync\novn-sbctl dump-flows lr1 > lrflows\nAT_CAPTURE_FILE([lrflows])\n\n# Check the flows in lr_in_admission stage\nAT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp1\" && is_chassis_resident(\"cr-lrp1\")), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n])\n\n# Check the flows in lr_in_gw_redirect stage\nAT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == \"lrp1\"), action=(outport = \"cr-lrp1\"; next;)\n])\n\nwait_row_count Port_Binding 1 logical_port=cr-lrp1 options:always-redirect=\"true\"\n\n# attach vtep logical port to logical switch and check flows.\n# there should not be is_chassis_resident part.\ncheck ovn-nbctl lsp-add ls1 lsp-vtep -- lsp-set-type lsp-vtep vtep\n\novn-nbctl --wait=sb sync\novn-sbctl dump-flows lr1 > lrflows\nAT_CAPTURE_FILE([lrflows])\n\n# Check the flows in lr_in_admission stage\nAT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n])\n\n# Check the flows in lr_in_gw_redirect stage\nAT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [])\n\nwait_row_count Port_Binding 0 logical_port=cr-lrp1 options:always-redirect=\"true\"\n\n# delete vtep lport and check lrp has is_chassis_resident match part again.\ncheck ovn-nbctl lsp-del lsp-vtep\n\novn-nbctl --wait=sb sync\novn-sbctl dump-flows lr1 > lrflows\nAT_CAPTURE_FILE([lrflows])\n\n# Check the flows in lr_in_admission stage\nAT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp1\" && is_chassis_resident(\"cr-lrp1\")), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n])\n\n# Check the flows in lr_in_gw_redirect stage\nAT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == \"lrp1\"), action=(outport = \"cr-lrp1\"; next;)\n])\n\nwait_row_count Port_Binding 1 logical_port=cr-lrp1 options:always-redirect=\"true\"\n\nAT_CLEANUP\n])\n\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check options:requested-chassis fills requested_chassis col])\novn_start NORTHD_TYPE\n\n# Add chassis ch1.\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.2\ncheck ovn-sbctl chassis-add ch2 geneve 127.0.0.3\n\nwait_row_count Chassis 2\n\nch1_uuid=`ovn-sbctl --bare --columns _uuid find Chassis name=\"ch1\"`\nch2_uuid=`ovn-sbctl --bare --columns _uuid find Chassis name=\"ch2\"`\n\ncheck ovn-sbctl set chassis $ch2_uuid hostname=ch2-hostname\n\novn-nbctl ls-add S1\novn-nbctl --wait=sb lsp-add S1 S1-vm1\novn-nbctl --wait=sb lsp-add S1 S1-vm2\n\nwait_row_count Port_Binding 1 logical_port=S1-vm1 requested_chassis!=$ch1_uuid\nwait_row_count Port_Binding 1 logical_port=S1-vm2 requested_chassis!=$ch2_uuid\n\novn-nbctl --wait=sb set logical_switch_port S1-vm1 \\\n    options:requested-chassis=ch1\n\nwait_row_count Port_Binding 1 logical_port=S1-vm1 requested_chassis=$ch1_uuid\n\novn-nbctl --wait=sb set logical_switch_port S1-vm2 \\\n    options:requested-chassis=ch2-hostname\n\nwait_row_count Port_binding 1 logical-port=S1-vm2 requested_chassis=$ch2_uuid\n\novn-nbctl --wait=sb remove logical_switch_port S1-vm2 \\\n    options requested-chassis=ch2-hostname\n\nwait_row_count Port_binding 1 logical-port=S1-vm2 requested_chassis!=$ch2_uuid\n\novn-nbctl --wait=sb set logical_switch_port S1-vm2 \\\n    options:requested-chassis=ch2\n\nwait_row_count Port_binding 1 logical-port=S1-vm2 requested_chassis=$ch2_uuid\n\nAT_CLEANUP\n])\n\n# Duplicated datapaths shouldn't be created, but in case it is created because\n# of bug or dirty data, it should be properly deleted instead of causing\n# permanent failure in northd.\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([handling duplicated datapaths])\novn_start\n\ncheck ovn-nbctl --wait=sb ls-add ls1\nls1_uuid=$(fetch_column nb:Logical_Switch _uuid)\n\n# create a duplicated sb datapath (and an IP_Mulicast record that references\n# it) on purpose.\nAT_CHECK([ovn-sbctl --id=@dp create Datapath_Binding external_ids:logical-switch=$ls1_uuid external_ids:name=ls1 tunnel_key=123 -- create IP_Multicast datapath=@dp], [0], [ignore])\n\n# northd should delete one of the datapaths in the end\nwait_row_count Datapath_Binding 1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([conntrack nat implies conntrack])\novn_start\n\ncheck ovn-nbctl lr-add rtr \\\n  -- set logical_router rtr options:chassis=hv \\\n  -- lrp-add rtr rtr-ls 00:00:00:00:01:00 42.42.42.1/24 \\\n  -- lb-add lb-test 43.43.43.43:4343 42.42.42.2:4242 tcp \\\n  -- lr-lb-add rtr lb-test\ncheck ovn-nbctl --wait=sb sync\n\nflow=\"eth.dst == 00:00:00:00:01:00 && inport == \\\"rtr-ls\\\" && ip4.src == 42.42.42.42 && ip4.dst == 43.43.43.43 && ip.ttl == 64 && tcp && tcp.dst == 4343\"\n\nAT_CHECK_UNQUOTED([ovn_trace --ct new --minimal \"${flow}\" --lb-dst 42.42.42.42:4242], [0], [dnl\nct_dnat /* assuming no un-dnat entry, so no change */ {\n    ct_lb_mark /* default (use --ct to customize) */ {\n        ip.ttl--;\n        eth.src = 00:00:00:00:01:00;\n        eth.dst = 00:00:00:00:00:00;\n        arp {\n            eth.dst = ff:ff:ff:ff:ff:ff;\n            arp.spa = 0x2a2a2a01;\n            arp.tpa = 0x2a2a2a02;\n            arp.op = 1;\n            output(\"rtr-ls\");\n        };\n    };\n};\n])\n\nAT_CHECK_UNQUOTED([ovn_trace --minimal \"${flow}\" --lb-dst 42.42.42.42:4242], [0], [dnl\nct_dnat /* assuming no un-dnat entry, so no change */ /* default (use --ct to customize) */;\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([route tables -- flows])\nAT_KEYWORDS([route-tables-flows])\novn_start\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lrp0 00:00:00:00:00:01 192.168.0.1/24\ncheck ovn-nbctl lrp-add lr0 lrp1 00:00:00:00:01:01 192.168.1.1/24\ncheck ovn-nbctl lrp-add lr0 lrp2 00:00:00:00:02:01 192.168.2.1/24\ncheck ovn-nbctl lrp-set-options lrp1 route_table=rtb-1\ncheck ovn-nbctl lrp-set-options lrp2 route_table=rtb-2\n\ncheck ovn-nbctl lr-route-add lr0 0.0.0.0/0 192.168.0.10\ncheck ovn-nbctl --route-table=rtb-1 lr-route-add lr0 192.168.0.0/24 192.168.1.10\ncheck ovn-nbctl --route-table=rtb-2 lr-route-add lr0 0.0.0.0/0 192.168.0.10\ncheck ovn-nbctl --route-table=rtb-2 lr-route-add lr0 1.1.1.1/32 192.168.0.20\ncheck ovn-nbctl --route-table=rtb-2 lr-route-add lr0 2.2.2.2/32 192.168.0.30\ncheck ovn-nbctl --route-table=rtb-2 --ecmp lr-route-add lr0 2.2.2.2/32 192.168.0.31\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"lr_in_ip_routing_pre.*match=(1)\" lr0flows | sed 's/table=../table=??/'], [0], [dnl\n  table=??(lr_in_ip_routing_pre), priority=0    , match=(1), action=(reg7 = 0; next;)\n])\n\np1_reg=$(grep -oP \"lr_in_ip_routing_pre.*lrp1.*action=\\(reg7 = \\K.\" lr0flows)\np2_reg=$(grep -oP \"lr_in_ip_routing_pre.*lrp2.*action=\\(reg7 = \\K.\" lr0flows)\necho $p1_reg\necho $p2_reg\n\n# exact register values are not predictable\nif [[ $p1_reg -eq 2 ] && [ $p2_reg -eq 1 ]]; then\n  echo \"swap reg values in dump\"\n  sed -i -r s'/^(.*lrp2.*action=\\(reg7 = )(1)(.*)/\\12\\3/g' lr0flows  # \"reg7 = 1\" -> \"reg7 = 2\"\n  sed -i -r s'/^(.*lrp1.*action=\\(reg7 = )(2)(.*)/\\11\\3/g' lr0flows  # \"reg7 = 2\" -> \"reg7 = 1\"\n  sed -i -r s'/^(.*match=\\(reg7 == )(2)( &&.*lrp1.*)/\\11\\3/g' lr0flows  # \"reg7 == 2\" -> \"reg7 == 1\"\n  sed -i -r s'/^(.*match=\\(reg7 == )(1)( &&.*lrp0.*)/\\12\\3/g' lr0flows  # \"reg7 == 1\" -> \"reg7 == 2\"\nfi\n\ncheck test \"$p1_reg\" != \"$p2_reg\" -a $((p1_reg * p2_reg)) -eq 2\n\nAT_CHECK([grep \"lr_in_ip_routing_pre\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing_pre), priority=0    , match=(1), action=(reg7 = 0; next;)\n  table=??(lr_in_ip_routing_pre), priority=100  , match=(inport == \"lrp1\"), action=(reg7 = 1; next;)\n  table=??(lr_in_ip_routing_pre), priority=100  , match=(inport == \"lrp2\"), action=(reg7 = 2; next;)\n])\n\ngrep -e \"(lr_in_ip_routing   ).*outport\" lr0flows\n\nAT_CHECK([grep -e \"(lr_in_ip_routing   ).*outport\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=1    , match=(reg7 == 0 && ip4.dst == 0.0.0.0/0), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.10; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = \"lrp0\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=1    , match=(reg7 == 2 && ip4.dst == 0.0.0.0/0), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.10; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = \"lrp0\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=194  , match=(inport == \"lrp0\" && ip6.dst == fe80::/64), action=(ip.ttl--; reg8[[0..15]] = 0; xxreg0 = ip6.dst; xxreg1 = fe80::200:ff:fe00:1; eth.src = 00:00:00:00:00:01; outport = \"lrp0\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=194  , match=(inport == \"lrp1\" && ip6.dst == fe80::/64), action=(ip.ttl--; reg8[[0..15]] = 0; xxreg0 = ip6.dst; xxreg1 = fe80::200:ff:fe00:101; eth.src = 00:00:00:00:01:01; outport = \"lrp1\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=194  , match=(inport == \"lrp2\" && ip6.dst == fe80::/64), action=(ip.ttl--; reg8[[0..15]] = 0; xxreg0 = ip6.dst; xxreg1 = fe80::200:ff:fe00:201; eth.src = 00:00:00:00:02:01; outport = \"lrp2\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=73   , match=(reg7 == 1 && ip4.dst == 192.168.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.1.10; reg1 = 192.168.1.1; eth.src = 00:00:00:00:01:01; outport = \"lrp1\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=74   , match=(ip4.dst == 192.168.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = \"lrp0\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=74   , match=(ip4.dst == 192.168.1.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.1.1; eth.src = 00:00:00:00:01:01; outport = \"lrp1\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=74   , match=(ip4.dst == 192.168.2.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.2.1; eth.src = 00:00:00:00:02:01; outport = \"lrp2\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=97   , match=(reg7 == 2 && ip4.dst == 1.1.1.1/32), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.20; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = \"lrp0\"; flags.loopback = 1; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check exclude-lb-vips-from-garp option])\novn_start\n\novn-nbctl lr-add R1\novn-nbctl set logical_router R1 options:chassis=hv1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01\novn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1 nat-addresses=\"router\"\n\novn-nbctl lr-nat-add R1 snat 172.16.1.1 10.0.0.0/24\novn-nbctl lr-nat-add R1 dnat 172.16.1.2 10.0.0.1\n# Add load balancers\novn-nbctl lb-add lb0 172.16.1.10:80 10.0.0.1:80\novn-nbctl lr-lb-add R1 lb0\novn-nbctl lb-add lb1 172.16.1.10:8080 10.0.0.1:8080\novn-nbctl lr-lb-add R1 lb1\novn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl get Port_Binding S1-R1 nat_addresses |grep -q 172.16.1.10], [0])\n\novn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1 nat-addresses=\"router\" \\\n                    exclude-lb-vips-from-garp=\"true\"\n\nAT_CHECK([ovn-sbctl get Port_Binding S1-R1 nat_addresses |grep -q 172.16.1.10], [1])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL log replies -- flows])\n\nset_acl_options() {\n    local acl_name=$1\n    local label=$2\n    local log_related=$3\n\n    local acl_uuid=$(fetch_column nb:ACL _uuid name=$acl_name)\n    check ovn-nbctl set ACL $acl_uuid label=$label options:log-related=$log_related\n}\n\nrecord_log_flows() {\n    ovn-sbctl lflow-list sw0 | grep -E 'ls_(out|in)_acl.*, priority=65533' | sed 's/table=../table=??/' | sort > log_flows\n}\n\ncheck_log_flows_count() {\n    local expected=$1\n    local table=$2\n    local count=\n\n    echo $table\n    if test -f log_flows; then\n        count=$(grep -c -E ls_${table}_acl log_flows)\n    else\n        count=$(ovn-sbctl lflow-list sw0 | grep -c -E \"ls_$table_acl.*, priority=65533\")\n    fi\n\n    check test \"$count\" -eq \"$expected\"\n}\n\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \"00:00:00:00:00:01 10.0.0.1\"\ncheck ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 \"00:00:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl pg-add pg1 sw0-p1 sw0-p2\ncheck ovn-nbctl pg-add pg2 sw0-p1 sw0-p2\ncheck ovn-nbctl pg-add pg3 sw0-p1 sw0-p2\n\ncheck ovn-nbctl --log --name=allow_acl acl-add pg1 from-lport 100 'inport=@pg1 && ip4' allow\nset_acl_options allow_acl 1 true\n\ncheck ovn-nbctl --wait=sb sync\n\n# An allow ACL should *not* result in a priority 65533 log flow being installed\n# since there are no stateful ACLs on the system.\ncheck_log_flows_count 0 in\ncheck_log_flows_count 0 out\n\n# Now add an allow-related ACL. This should result in both the allow-related\n# ACL and the allow ACL having priority 65533 log flows added.\ncheck ovn-nbctl --log --name=allow_related_acl acl-add pg2 from-lport 100 'inport=@pg2 && ip4' allow-related\nset_acl_options allow_related_acl 2 true\ncheck ovn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count will be 4 since we have\n# 2 flows for reply traffic for each ACL\n# 2 flows for related traffic for each ACL\ncheck_log_flows_count 4 out\n# Since the ACLs are ingress, the ingress table\n# should have no log flows\ncheck_log_flows_count 0 in\n\n# Now ensure the flows are what we expect them to be for the ACLs we created\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# Now add a stateless-allow ACL.\ncheck ovn-nbctl --log --name=allow_stateless_acl acl-add pg3 from-lport 100 'inport=@pg3 && ip4' allow-stateless\nset_acl_options allow_stateless_acl 3 true\ncheck ovn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count will still be 4 since the stateless ACL should not have special log flows created\ncheck_log_flows_count 4 out\ncheck_log_flows_count 0 in\n\n# And the log flows will remain the same since the stateless ACL will not be represented.\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# Now remove the label from the allow-related ACL.\nset_acl_options allow_related_acl 0 true\novn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count should now be 2 since the allow_related ACL will not have special\n# log flows created. But since there there is an allow-related ACL present, the\n# allow ACL will be stateful and have special log flows created.\ncheck_log_flows_count 2 out\ncheck_log_flows_count 0 in\n\n# And make sure only the allow ACL has the log flows installed\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# And now add the label back, but disable log_related on the allow-related ACL.\nset_acl_options allow_related_acl 2 false\n\nrecord_log_flows\n\n# The count will again be 2 because only the allow ACL will have log flows installed.\ncheck_log_flows_count 2 out\ncheck_log_flows_count 0 in\n\n# And make sure only the allow ACL has the log flows installed\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# And just for sanity's sake, let's remove the allow-related ACL and make sure\n# all the special log messages are gone.\ncheck ovn-nbctl acl-del pg2\ncheck ovn-nbctl --wait=sb sync\n\ncheck_log_flows_count 0 out\ncheck_log_flows_count 0 in\n\n# Now let's clear out all the ACLs, and re-do everything but with egress ACLs.\ncheck ovn-nbctl acl-del pg1\ncheck ovn-nbctl acl-del pg3\ncheck_row_count nb:ACL 0\n\n# Start again with an allow_acl only\ncheck ovn-nbctl --log --name=allow_acl acl-add pg1 to-lport 100 'inport=@pg1 && ip4' allow\nset_acl_options allow_acl 1 true\n\ncheck ovn-nbctl --wait=sb sync\n\n# Again, the allow ACL is stateless, so no related log flows.\ncheck_log_flows_count 0 in\ncheck_log_flows_count 0 out\n\n# Adding a new allow-related ACL...\ncheck ovn-nbctl --log --name=allow_related_acl acl-add pg2 to-lport 100 'inport=@pg2 && ip4' allow-related\nset_acl_options allow_related_acl 2 true\ncheck ovn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count will be 4 since we have\n# 2 flows for reply traffic for each ACL\n# 2 flows for related traffic for each ACL\ncheck_log_flows_count 4 in\n# And this time, we should have no egress flows\ncheck_log_flows_count 0 out\n\n# Now ensure the flows are what we expect them to be for the ACLs we created\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# Now add a stateless-allow ACL.\ncheck ovn-nbctl --log --name=allow_stateless_acl acl-add pg3 from-lport 100 'inport=@pg3 && ip4' allow-stateless\nset_acl_options allow_stateless_acl 3 true\ncheck ovn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count will still be 4 since the stateless ACL should not have special log flows created\ncheck_log_flows_count 4 in\ncheck_log_flows_count 0 out\n\n# And the log flows will remain the same since the stateless ACL will not be represented.\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# Now remove the label from the allow-related ACL.\nset_acl_options allow_related_acl 0 true\novn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count should now be 2 since the allow_related ACL will not have special\n# log flows created. But since there there is an allow-related ACL present, the\n# allow ACL will be stateful and have special log flows created.\ncheck_log_flows_count 2 in\ncheck_log_flows_count 0 out\n\n# And make sure only the allow ACL has the log flows installed\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# And now add the label back, but disable log_related on the allow-related ACL.\nset_acl_options allow_related_acl 2 false\n\nrecord_log_flows\n\n# The count will again be 2 because only the allow ACL will have log flows installed.\ncheck_log_flows_count 2 in\ncheck_log_flows_count 0 out\n\n# And make sure only the allow ACL has the log flows installed\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# And just for sanity's sake, let's remove the allow-related ACL and make sure\n# all the special log messages are gone.\ncheck ovn-nbctl acl-del pg2\ncheck ovn-nbctl --wait=sb sync\n\ncheck_log_flows_count 0 out\ncheck_log_flows_count 0 in\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Static IP multicast report forwarding])\n\novn_start\n\ncheck ovn-nbctl lr-add lr\ncheck ovn-nbctl lrp-add lr lrp1 00:00:00:00:00:01 10.10.10.1/24 1010::1/64\ncheck ovn-nbctl lrp-add lr lrp2 00:00:00:00:00:02 20.20.20.1/24 2020::1/64\ncheck ovn-nbctl set logical_router lr options:mcast_relay=\"true\"\ncheck ovn-nbctl set logical_router_port lrp1 options:mcast_flood=\"true\"\ncheck ovn-nbctl set logical_router_port lrp2 options:mcast_flood=\"true\"\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr > lrflows\nAT_CAPTURE_FILE([lrflows])\n\ndnl Flows to skip TTL == {0, 1} check for IGMP and MLD packets.\nAT_CHECK([grep -e 'lr_in_ip_input    ' lrflows | grep -e 'igmp' -e 'mld' -e 'ip.ttl == {0, 1}' | sed 's/table=../table=??/'], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=120  , match=((mldv1 || mldv2) && ip.ttl == 1), action=(next;)\n  table=??(lr_in_ip_input     ), priority=120  , match=(igmp && ip.ttl == 1), action=(next;)\n  table=??(lr_in_ip_input     ), priority=32   , match=(ip.ttl == {0, 1} && !ip.later_frag && (ip4.mcast || ip6.mcast)), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=31   , match=(inport == \"lrp1\" && ip4 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp4 {eth.dst <-> eth.src; icmp4.type = 11; /* Time exceeded */ icmp4.code = 0; /* TTL exceeded in transit */ ip4.dst = ip4.src; ip4.src = 10.10.10.1 ; ip.ttl = 254; outport = \"lrp1\"; flags.loopback = 1; output; };)\n  table=??(lr_in_ip_input     ), priority=31   , match=(inport == \"lrp1\" && ip6 && ip6.src == 1010::/64 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp6 {eth.dst <-> eth.src; ip6.dst = ip6.src; ip6.src = 1010::1 ; ip.ttl = 254; icmp6.type = 3; /* Time exceeded */ icmp6.code = 0; /* TTL exceeded in transit */ outport = \"lrp1\"; flags.loopback = 1; output; };)\n  table=??(lr_in_ip_input     ), priority=31   , match=(inport == \"lrp2\" && ip4 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp4 {eth.dst <-> eth.src; icmp4.type = 11; /* Time exceeded */ icmp4.code = 0; /* TTL exceeded in transit */ ip4.dst = ip4.src; ip4.src = 20.20.20.1 ; ip.ttl = 254; outport = \"lrp2\"; flags.loopback = 1; output; };)\n  table=??(lr_in_ip_input     ), priority=31   , match=(inport == \"lrp2\" && ip6 && ip6.src == 2020::/64 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp6 {eth.dst <-> eth.src; ip6.dst = ip6.src; ip6.src = 2020::1 ; ip.ttl = 254; icmp6.type = 3; /* Time exceeded */ icmp6.code = 0; /* TTL exceeded in transit */ outport = \"lrp2\"; flags.loopback = 1; output; };)\n  table=??(lr_in_ip_input     ), priority=30   , match=(ip.ttl == {0, 1}), action=(drop;)\n])\n\ndnl Flows to \"route\" (statically forward) without decrementing TTL for\ndnl IGMP and MLD packets.  Also, flows to drop potentially looping IGMP/MLD\ndnl packets.\nAT_CHECK([grep -e 'lr_in_ip_routing   ' lrflows | grep -e 'igmp' -e 'mld' | sed 's/table=../table=??/'], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:01 && (mldv1 || mldv2)), action=(drop;)\n  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:01 && igmp), action=(drop;)\n  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:02 && (mldv1 || mldv2)), action=(drop;)\n  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:02 && igmp), action=(drop;)\n  table=??(lr_in_ip_routing   ), priority=10460, match=(igmp), action=(clone { outport = \"_MC_static\"; next; };)\n  table=??(lr_in_ip_routing   ), priority=10460, match=(mldv1 || mldv2), action=(clone { outport = \"_MC_static\"; next; };)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACLs after lb])\nAT_KEYWORDS([acl])\novn_start\n\ncheck ovn-nbctl --wait=sb \\\n    -- ls-add ls \\\n    -- lsp-add ls lsp\n\ncheck ovn-nbctl pg-add pg0 lsp\n\ncheck ovn-nbctl acl-add pg0 from-lport 1004 \"ip4 && ip4.dst == 10.0.0.2\" drop\ncheck ovn-nbctl acl-add pg0 from-lport 1002 \"ip4 && tcp\" allow-related\ncheck ovn-nbctl acl-add pg0 from-lport 1003 \"ip4 && icmp\" allow-related\ncheck ovn-nbctl acl-add pg0 from-lport 1001 \"ip4\" drop\n\ncheck ovn-nbctl lb-add lb0 10.0.0.2 10.0.0.10\ncheck ovn-nbctl ls-lb-add ls lb0\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows ls > lsflows\nAT_CAPTURE_FILE([lsflows])\n\nAT_CHECK([grep -e \"ls_in_acl\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2001 , match=(reg0[[10]] == 1 && (ip4)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl          ), priority=2001 , match=(reg0[[9]] == 1 && (ip4)), action=(/* drop */)\n  table=??(ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_in_acl          ), priority=2003 , match=(reg0[[7]] == 1 && (ip4 && icmp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2003 , match=(reg0[[8]] == 1 && (ip4 && icmp)), action=(next;)\n  table=??(ls_in_acl          ), priority=2004 , match=(reg0[[10]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl          ), priority=2004 , match=(reg0[[9]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(/* drop */)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n])\n\nAT_CHECK([grep -e \"ls_in_lb \" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.2), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.10);)\n])\n\nAT_CHECK([grep -e \"ls_in_stateful\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAS_BOX([Remove and add the ACLs back with the apply-after-lb option])\n\ncheck ovn-nbctl clear port_group . acls\n\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1004 \"ip4 && ip4.dst == 10.0.0.2\" drop\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"ip4 && tcp\" allow-related\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1003 \"ip4 && icmp\" allow-related\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1001 \"ip4\" drop\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows ls > lsflows\nAT_CAPTURE_FILE([lsflows])\n\nAT_CHECK([grep -e \"ls_in_acl\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=2001 , match=(reg0[[10]] == 1 && (ip4)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2001 , match=(reg0[[9]] == 1 && (ip4)), action=(/* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2002 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl_after_lb ), priority=2002 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=2003 , match=(reg0[[7]] == 1 && (ip4 && icmp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl_after_lb ), priority=2003 , match=(reg0[[8]] == 1 && (ip4 && icmp)), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=2004 , match=(reg0[[10]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2004 , match=(reg0[[9]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(/* drop */)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n])\n\nAT_CHECK([grep -e \"ls_in_lb \" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.2), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.10);)\n])\n\nAT_CHECK([grep -e \"ls_in_stateful\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAS_BOX([Remove and add the ACLs back with a few ACLs with apply-after-lb option])\n\ncheck ovn-nbctl clear port_group . acls\n\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1004 \"ip4 && ip4.dst == 10.0.0.2\" drop\ncheck ovn-nbctl acl-add pg0 from-lport 1002 \"ip4 && tcp\" allow-related\ncheck ovn-nbctl acl-add pg0 from-lport 1003 \"ip4 && icmp\" allow-related\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1001 \"ip4\" drop\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows ls > lsflows\nAT_CAPTURE_FILE([lsflows])\n\nAT_CHECK([grep -e \"ls_in_acl\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_in_acl          ), priority=2003 , match=(reg0[[7]] == 1 && (ip4 && icmp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2003 , match=(reg0[[8]] == 1 && (ip4 && icmp)), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=2001 , match=(reg0[[10]] == 1 && (ip4)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2001 , match=(reg0[[9]] == 1 && (ip4)), action=(/* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2004 , match=(reg0[[10]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2004 , match=(reg0[[9]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(/* drop */)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n])\n\nAT_CHECK([grep -e \"ls_in_lb \" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.2), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.10);)\n])\n\nAT_CHECK([grep -e \"ls_in_stateful\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd -- lr multiple gw ports NAT])\nAT_KEYWORDS([multiple-l3dgw-ports])\novn_start\n\n# Logical network:\n# 1 Logical Router, 3 bridged Logical Switches,\n# 1 gateway chassis attached to each corresponding LRP.\n#\n#                | S1 (gw1)\n#                |\n#      ls  ----  DR -- S3 (gw3)\n# (20.0.0.0/24)  |\n#                | S2 (gw2)\n#\n# Validate SNAT, DNAT and DNAT_AND_SNAT behavior with multiple\n# distributed gateway LRPs.\n\ncheck ovn-sbctl chassis-add gw1 geneve 127.0.0.1\ncheck ovn-sbctl chassis-add gw2 geneve 128.0.0.1\ncheck ovn-sbctl chassis-add gw3 geneve 129.0.0.1\n\ncheck ovn-nbctl lr-add DR\ncheck ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24\ncheck ovn-nbctl lrp-add DR DR-S2 03:ac:10:01:00:01 10.0.0.1/24\ncheck ovn-nbctl lrp-add DR DR-S3 04:ac:10:01:00:01 192.168.0.1/24\ncheck ovn-nbctl lrp-add DR DR-ls 05:ac:10:01:00:01 20.0.0.1/24\n\ncheck ovn-nbctl ls-add S1\ncheck ovn-nbctl lsp-add S1 S1-DR\ncheck ovn-nbctl lsp-set-type S1-DR router\ncheck ovn-nbctl lsp-set-addresses S1-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1\n\ncheck ovn-nbctl ls-add S2\ncheck ovn-nbctl lsp-add S2 S2-DR\ncheck ovn-nbctl lsp-set-type S2-DR router\ncheck ovn-nbctl lsp-set-addresses S2-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S2-DR router-port=DR-S2\n\ncheck ovn-nbctl ls-add S3\ncheck ovn-nbctl lsp-add S3 S3-DR\ncheck ovn-nbctl lsp-set-type S3-DR router\ncheck ovn-nbctl lsp-set-addresses S3-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S3-DR router-port=DR-S3\n\ncheck ovn-nbctl ls-add  ls\ncheck ovn-nbctl lsp-add ls ls-DR\ncheck ovn-nbctl lsp-set-type ls-DR router\ncheck ovn-nbctl lsp-set-addresses ls-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options ls-DR router-port=DR-ls\n\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S1 gw1\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S2 gw2\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S3 gw3\n\n# Configure SNAT with and without setting \"gateway_port\" column\ncheck ovn-nbctl                      lr-nat-add DR snat  172.16.1.10    20.0.0.10\ncheck ovn-nbctl --gateway-port=DR-S2 lr-nat-add DR snat  10.0.0.10      20.0.0.10\ncheck ovn-nbctl                      lr-nat-add DR snat  192.168.0.10   20.0.0.10\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > lrflows\nAT_CAPTURE_FILE([lrflows])\n\nAT_CHECK([grep lr_in_ip_input lrflows | grep arp | grep -e 172.16.1.10 -e 10.0.0.10 -e 192.168.0.10 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 10.0.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 172.16.1.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 192.168.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 192.168.0.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident(\"cr-DR-S1\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10 && is_chassis_resident(\"cr-DR-S2\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 192.168.0.10 && is_chassis_resident(\"cr-DR-S3\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n])\n\nAT_CHECK([grep lr_in_unsnat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == \"DR-S3\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == \"DR-S3\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat;)\n])\n\nAT_CHECK([grep lr_out_snat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone(172.16.1.10);)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat_in_czone(10.0.0.10);)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat_in_czone(192.168.0.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(10.0.0.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(192.168.0.10);)\n])\n\ncheck ovn-nbctl --wait=sb lr-nat-del DR snat 20.0.0.10\nAT_CHECK([ovn-sbctl dump-flows DR | grep -e lr_in_unsnat -e lr_out_snat | grep ct_snat | wc -l], [0], [0\n])\n\n# Configure DNAT - 2 gateway_ports configured for same external IP\ncheck ovn-nbctl                      lr-nat-add DR dnat  172.16.1.10    20.0.0.10\ncheck ovn-nbctl --gateway-port=DR-S2 lr-nat-add DR dnat  10.0.0.10      20.0.0.10\ncheck ovn-nbctl --gateway-port=DR-S3 lr-nat-add DR dnat  172.16.1.10    20.0.0.10\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > lrflows\nAT_CAPTURE_FILE([lrflows])\n\nAT_CHECK([grep lr_in_ip_input lrflows | grep arp | grep -e 172.16.1.10 -e 10.0.0.10 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 10.0.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 172.16.1.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident(\"cr-DR-S1\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10 && is_chassis_resident(\"cr-DR-S2\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident(\"cr-DR-S3\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n])\n\nAT_CHECK([grep lr_in_dnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_dnat_in_czone(20.0.0.10);)\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_dnat_in_czone(20.0.0.10);)\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_dnat_in_czone(20.0.0.10);)\n])\n\nAT_CHECK([grep lr_out_undnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_dnat_in_czone;)\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_dnat_in_czone;)\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_dnat_in_czone;)\n])\n\ncheck ovn-nbctl --wait=sb lr-nat-del DR dnat\n\nAT_CHECK([ovn-sbctl dump-flows DR | grep -e lr_in_dnat -e lr_out_undnat | grep ct_dnat | wc -l], [0], [0\n])\n\n# Configure DNAT_AND_SNAT\ncheck ovn-nbctl --gateway-port=DR-S1 lr-nat-add DR dnat_and_snat  172.16.1.10    20.0.0.10\ncheck ovn-nbctl                      lr-nat-add DR dnat_and_snat  10.0.0.10      20.0.0.10\ncheck ovn-nbctl --gateway-port=DR-S3 lr-nat-add DR dnat_and_snat  192.168.0.10   20.0.0.10\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > lrflows\nAT_CAPTURE_FILE([lrflows])\n\nAT_CHECK([grep lr_in_ip_input lrflows | grep arp | grep -e 172.16.1.10 -e 10.0.0.10 -e 192.168.0.10 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 10.0.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 172.16.1.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 192.168.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 192.168.0.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident(\"cr-DR-S1\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10 && is_chassis_resident(\"cr-DR-S2\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 192.168.0.10 && is_chassis_resident(\"cr-DR-S3\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n])\n\nAT_CHECK([grep lr_in_unsnat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == \"DR-S3\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == \"DR-S3\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat;)\n])\n\nAT_CHECK([grep lr_out_snat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone(172.16.1.10);)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat_in_czone(10.0.0.10);)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat_in_czone(192.168.0.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(10.0.0.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(192.168.0.10);)\n])\n\nAT_CHECK([grep lr_in_dnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_dnat_in_czone(20.0.0.10);)\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_dnat_in_czone(20.0.0.10);)\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_dnat_in_czone(20.0.0.10);)\n])\n\nAT_CHECK([grep lr_out_undnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_dnat_in_czone;)\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_dnat_in_czone;)\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_dnat_in_czone;)\n])\n\ncheck ovn-nbctl --wait=sb lr-nat-del DR dnat_and_snat\n\nAT_CHECK([ovn-sbctl dump-flows DR | grep -e lr_in_unsnat -e lr_out_snat -e lr_in_dnat -e lr_out_undnat | grep ct_snat| wc -l], [0], [0\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LR NB Static_MAC_Binding table])\novn_start\n\n# Create logical routers\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-p0 00:00:01:01:02:03 192.168.10.1/24\novn-nbctl lrp-add lr0 lr0-p1 00:00:02:02:03:04 192.168.11.1/24\n\novn-nbctl static-mac-binding-add lr0-p0 192.168.10.10 00:00:11:22:33:44\novn-nbctl static-mac-binding-add lr0-p0 192.168.10.100 00:00:22:33:44:55\n\nwait_row_count nb:Static_MAC_Binding 2 logical_port=lr0-p0\nwait_row_count Static_MAC_Binding 1 logical_port=lr0-p0 ip=192.168.10.10 mac=\"00\\:00\\:11\\:22\\:33\\:44\"\nwait_row_count Static_MAC_Binding 1 logical_port=lr0-p0 ip=192.168.10.100 mac=\"00\\:00\\:22\\:33\\:44\\:55\"\n\novn-nbctl static-mac-binding-add lr0-p1 10.0.0.10 00:00:33:44:55:66\nwait_row_count nb:Static_MAC_Binding 1 logical_port=lr0-p1\nwait_row_count Static_MAC_Binding 1 logical_port=lr0-p1 ip=10.0.0.10 mac=\"00\\:00\\:33\\:44\\:55\\:66\"\n\novn-nbctl --may-exist static-mac-binding-add lr0-p0 192.168.10.100 00:00:22:33:55:66\nwait_row_count Static_MAC_Binding 1 logical_port=lr0-p0 ip=192.168.10.100 mac=\"00\\:00\\:22\\:33\\:55\\:66\"\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LR neighbor lookup and learning flows])\novn_start\n\n# Create logical routers\novn-nbctl --wait=sb lr-add lr0\n\novn-sbctl dump-flows lr0 > lrflows\nAT_CAPTURE_FILE([lrflows])\n\nAT_CHECK([cat lrflows | grep -e lr_in_lookup_neighbor -e lr_in_learn_neighbor | sort], [0], [dnl\n  table=1 (lr_in_lookup_neighbor), priority=0    , match=(1), action=(reg9[[2]] = 1; next;)\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(arp.op == 2), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(nd_na), action=(reg9[[2]] = lookup_nd(inport, nd.target, nd.tll); next;)\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(nd_ns), action=(reg9[[2]] = lookup_nd(inport, ip6.src, nd.sll); next;)\n  table=2 (lr_in_learn_neighbor), priority=0    , match=(1), action=(drop;)\n  table=2 (lr_in_learn_neighbor), priority=100  , match=(reg9[[2]] == 1), action=(next;)\n  table=2 (lr_in_learn_neighbor), priority=90   , match=(arp), action=(put_arp(inport, arp.spa, arp.sha); next;)\n  table=2 (lr_in_learn_neighbor), priority=90   , match=(nd_na), action=(put_nd(inport, nd.target, nd.tll); next;)\n  table=2 (lr_in_learn_neighbor), priority=90   , match=(nd_ns), action=(put_nd(inport, ip6.src, nd.sll); next;)\n  table=2 (lr_in_learn_neighbor), priority=95   , match=(nd_na && nd.tll == 0), action=(put_nd(inport, nd.target, eth.src); next;)\n  table=2 (lr_in_learn_neighbor), priority=95   , match=(nd_ns && (ip6.src == 0 || nd.sll == 0)), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LS default ACL drop])\nAT_KEYWORDS([acl])\n\novn_start\n\ncheck ovn-nbctl ls-add ls\ncheck ovn-nbctl lsp-add ls lsp1 -- lsp-set-addresses lsp1 00:00:00:00:00:01\ncheck ovn-nbctl lsp-add ls lsp2 -- lsp-set-addresses lsp2 00:00:00:00:00:02\n\nflow=\"inport == \\\"lsp1\\\" && eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02 && ip.ttl == 64 && ip4.src == 42.42.42.42 && ip4.dst == 42.42.42.43 && udp && udp.src == 42 && udp.dst == 84\"\n\nAS_BOX([No ACL, default_acl_drop not set])\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl          ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl         ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([No ACL, default_acl_drop false])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl          ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl         ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([No ACL, default_acl_drop true])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl          ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl         ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([from-lport ACL])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl acl-add ls from-lport 1 \"ip4 && tcp\" allow\n\nAS_BOX([from-lport ACL, default_acl_drop not set])\ncheck ovn-nbctl --wait=sb remove NB_Global . options default_acl_drop\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([from-lport ACL, default_acl_drop false])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([from-lport ACL, default_acl_drop true])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\n])\n\nAS_BOX([from-lport ACL allow-related, default_acl_drop true])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl --wait=sb acl-add ls from-lport 1 \"ip4 && tcp\" allow-related\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=1001 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=1001 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk);\n])\n\nAS_BOX([from-lport --apply-after-lb ACL])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl --apply-after-lb acl-add ls from-lport 1 \"ip4 && tcp\" allow\n\nAS_BOX([from-lport --apply-after-lb ACL, default_acl_drop not set])\ncheck ovn-nbctl --wait=sb remove NB_Global . options default_acl_drop\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([from-lport --apply-after-lb ACL, default_acl_drop false])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([from-lport --apply-after-lb ACL, default_acl_drop true])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\n])\n\nAS_BOX([from-lport --apply-after-lb ACL allow-related, default_acl_drop true])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl --wait=sb --apply-after-lb acl-add ls from-lport 1 \"ip4 && tcp\" allow-related\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=1001 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl_after_lb ), priority=1001 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk);\n])\n\nAS_BOX([to-lport ACL])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl acl-add ls to-lport 1 \"ip4 && tcp\" allow\n\nAS_BOX([to-lport ACL, default_acl_drop not set])\ncheck ovn-nbctl --wait=sb remove NB_Global . options default_acl_drop\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([to-lport ACL, default_acl_drop false])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([to-lport ACL, default_acl_drop true])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\n])\n\nAS_BOX([to-lport ACL allow-related, default_acl_drop true])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl --wait=sb acl-add ls to-lport 1 \"ip4 && tcp\" allow-related\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_out_acl         ), priority=1001 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_out_acl         ), priority=1001 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk);\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([northd-parallelization unixctl])\novn_start\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1\nOVS_WAIT_FOR_OUTPUT([as northd ovn-appctl -t NORTHD_TYPE parallel-build/get-n-threads], [0], [1\n])\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 4\nOVS_WAIT_FOR_OUTPUT([as northd ovn-appctl -t NORTHD_TYPE parallel-build/get-n-threads], [0], [4\n])\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1\nOVS_WAIT_FOR_OUTPUT([as northd ovn-appctl -t NORTHD_TYPE parallel-build/get-n-threads], [0], [1\n])\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 0], [2], [],\n  [invalid n_threads: 0\novn-appctl: ovn-northd: server returned an error\n])\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads -1], [2], [],\n  [invalid n_threads: -1\novn-appctl: ovn-northd: server returned an error\n])\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 300], [2], [],\n  [invalid n_threads: 300\novn-appctl: ovn-northd: server returned an error\n])\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads], [2], [],\n  [\"parallel-build/set-n-threads\" command requires at least 1 arguments\novn-appctl: ovn-northd: server returned an error\n])\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1 2], [2], [],\n  [\"parallel-build/set-n-threads\" command takes at most 1 arguments\novn-appctl: ovn-northd: server returned an error\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([northd-parallelization runtime])\novn_start\n\nadd_switch_ports() {\n    for port in $(seq $1 $2); do\n        OVN_NBCTL(lsp-add ls1 lsp${port})\n        OVN_NBCTL(lsp-set-addresses lsp${port} dynamic)\n    done\n    RUN_OVN_NBCTL()\n}\n\ndelete_switch_ports() {\n    for port in $(seq $1 $2); do\n        OVN_NBCTL(lsp-del lsp${port})\n    done\n    RUN_OVN_NBCTL()\n}\n\nm4_define([DUMP_FLOWS_SORTED], [sed -e 's/arp.tpa == 10.1.0.[[0-9]]\\{1,3\\}/arp.tpa == 10.1.0.??/;s/eth.dst == ..:..:..:..:..:../??:??:??:??:??:??/' | sort])\n\n# Build some rather heavy config and modify number of threads in the middle\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl set Logical_Switch ls1 other_config:subnet=10.1.0.0/16\ncheck ovn-nbctl set Logical_Switch ls1 other_config:exclude_ips=10.1.255.254\n\ncheck ovn-nbctl lr-add lr1\ncheck ovn-nbctl lsp-add ls1 lsp0 -- set Logical_Switch_Port lsp0 type=router options:router-port=lrp0 addresses=dynamic\ncheck ovn-nbctl lrp-add lr1 lrp0 \"f0:00:00:01:00:01\" 10.1.255.254/16\ncheck ovn-nbctl lr-nat-add lr1 snat 10.2.0.1 10.1.0.0/16\nadd_switch_ports 1 50\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 4\nadd_switch_ports 51 100\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 8\nadd_switch_ports 101 150\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 4\nadd_switch_ports 151 200\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1\nadd_switch_ports 201 250\ncheck ovn-nbctl --wait=sb sync\n\n# Run 3 times: one with parallelization enabled, one with disabled, and one while changing\n# Compare the flows produced by the three runs\n# Ignore IP/MAC addresses\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > flows1\n\n# Restart with 1 thread\ndelete_switch_ports 1 250\nadd_switch_ports 1 250\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > flows2\nAT_CHECK([diff flows1 flows2])\n\n# Restart with with 8 threads\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 8\ndelete_switch_ports 1 250\nadd_switch_ports 1 250\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > flows3\nAT_CHECK([diff flows1 flows3])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Port security lflows])\novn_start\n\n# Create logical routers\ncheck ovn-nbctl --wait=sb ls-add sw0\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\ncheck ovn-nbctl lsp-add sw0 sw0p1 -- lsp-set-addresses sw0p1 \"00:00:00:00:00:01\"\ncheck ovn-nbctl lsp-add sw0 sw0p2 -- lsp-set-addresses sw0p2 \"00:00:00:00:00:02\"\ncheck ovn-nbctl --wait=sb lsp-add sw0 localnetport -- lsp-set-type localnetport localnet\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = \"sw0p1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = \"sw0p2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\ncheck ovn-nbctl lsp-set-port-security sw0p1 \"00:00:00:00:00:01 10.0.0.3 1000::3\"\ncheck ovn-nbctl --wait=sb lsp-set-port-security sw0p2 \"00:00:00:00:00:02 10.0.0.4 1000::4\"\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = \"sw0p1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = \"sw0p2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\n# Disable sw0p1\ncheck ovn-nbctl --wait=sb set logical_switch_port sw0p1 enabled=false\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(inport == \"sw0p1\"), action=(reg0[[15]] = 1; next;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = \"sw0p2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"sw0p1\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\ncheck ovn-nbctl --wait=sb lsp-set-options sw0p2 qdisc_queue_id=10\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(inport == \"sw0p1\"), action=(reg0[[15]] = 1; next;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_check_port_sec), priority=70   , match=(inport == \"sw0p2\"), action=(set_queue(10); reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = \"sw0p2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"sw0p1\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\ncheck ovn-nbctl set logical_switch_port sw0p1 enabled=true\ncheck ovn-nbctl lsp-set-type sw0p1 vtep\ncheck ovn-nbctl --wait=sb lsp-set-options localnetport qdisc_queue_id=10\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_check_port_sec), priority=70   , match=(inport == \"localnetport\"), action=(set_queue(10); reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_check_port_sec), priority=70   , match=(inport == \"sw0p1\"), action=(reg0[[14]] = 1; next(pipeline=ingress, table=16);)\n  table=??(ls_in_check_port_sec), priority=70   , match=(inport == \"sw0p2\"), action=(set_queue(10); reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = \"sw0p1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = \"sw0p2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=100  , match=(outport == \"localnetport\"), action=(set_queue(10); output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\nAT_CLEANUP\n])\n\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load balancer ct_lb_mark backwards compatibility])\nAT_KEYWORDS([lb])\novn_start\n\ncheck ovn-nbctl                                               \\\n  -- ls-add ls                                                \\\n  -- lr-add lr -- set logical_router lr options:chassis=local \\\n  -- lb-add lb-test 66.66.66.66 42.42.42.2                    \\\n  -- ls-lb-add ls lb-test                                     \\\n  -- lr-lb-add lr lb-test\n\nAS_BOX([No chassis registered - use ct_lb_mark and ct_mark.natted])\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep -e natted -e ct_lb], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(ct_lb_mark(backends=42.42.42.2);)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=6 (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 66.66.66.66), action=(reg1 = 66.66.66.66; ct_lb_mark;)\n  table=6 (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n  table=12(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 66.66.66.66), action=(reg0[[1]] = 0; ct_lb_mark(backends=42.42.42.2);)\n  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n])\n\nAS_BOX([Chassis registered that doesn't support ct_lb_mark - use ct_lb and ct_label.natted])\ncheck ovn-sbctl chassis-add hv geneve 127.0.0.1\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep -e natted -e ct_lb], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(ct_lb(backends=42.42.42.2);)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted), action=(next;)\n  table=6 (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 66.66.66.66), action=(reg1 = 66.66.66.66; ct_lb;)\n  table=6 (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb;)\n  table=12(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 66.66.66.66), action=(reg0[[1]] = 0; ct_lb(backends=42.42.42.2);)\n  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb;)\n])\n\nAS_BOX([Chassis upgrades and supports ct_lb_mark - use ct_lb_mark and ct_mark.natted])\ncheck ovn-sbctl set chassis hv other_config:ct-no-masked-label=true\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep -e natted -e ct_lb], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(ct_lb_mark(backends=42.42.42.2);)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=6 (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 66.66.66.66), action=(reg1 = 66.66.66.66; ct_lb_mark;)\n  table=6 (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n  table=12(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 66.66.66.66), action=(reg0[[1]] = 0; ct_lb_mark(backends=42.42.42.2);)\n  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL ct_mark.blocked backwards compatibility])\nAT_KEYWORDS([acl])\novn_start\n\ncheck ovn-nbctl                                               \\\n  -- ls-add ls                                                \\\n  -- acl-add ls from-lport 1 1 allow-related                  \\\n  -- --apply-after-lb acl-add ls from-lport 1 1 allow-related \\\n  -- acl-add ls to-lport 1 1 allow-related\n\nAS_BOX([No chassis registered - use ct_mark.blocked])\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep 'ls.*acl.*blocked' ], [0], [dnl\n  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n])\n\nAS_BOX([Chassis registered that doesn't support ct_mark.blocked - use ct_label.blocked])\ncheck ovn-sbctl chassis-add hv geneve 127.0.0.1\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep 'ls.*acl.*blocked' ], [0], [dnl\n  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_label.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_label.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(drop;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_label.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_label.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_label.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(drop;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_label.blocked == 1), action=(reg0[[1]] = 1; next;)\n])\n\nAS_BOX([Chassis upgrades and supports ct_mark.blocked - use ct_mark.blocked])\ncheck ovn-sbctl set chassis hv other_config:ct-no-masked-label=true\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep 'ls.*acl.*blocked' ], [0], [dnl\n  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Localnet MAC learning option])\novn_start\n\nAT_CHECK([ovn-nbctl ls-add ls0])\n\nAT_CHECK([ovn-nbctl lsp-add ls0 ln_port])\nAT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])\nAT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])\nAT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=phys])\nAT_CHECK([ovn-nbctl --wait=sb sync])\n\n# Check MAC learning flows with 'localnet_learn_fdb' default (false)\nAT_CHECK([ovn-sbctl dump-flows ls0 | grep -e 'ls_in_\\(put\\|lookup\\)_fdb' | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_lookup_fdb   ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_put_fdb      ), priority=0    , match=(1), action=(next;)\n])\n\n# Enable 'localnet_learn_fdb' and check the flows\nAT_CHECK([ovn-nbctl --wait=sb lsp-set-options ln_port localnet_learn_fdb=true])\nAT_CHECK([ovn-sbctl dump-flows ls0 | grep -e 'ls_in_\\(put\\|lookup\\)_fdb' | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_lookup_fdb   ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_lookup_fdb   ), priority=100  , match=(inport == \"ln_port\"), action=(reg0[[11]] = lookup_fdb(inport, eth.src); next;)\n  table=? (ls_in_put_fdb      ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_put_fdb      ), priority=100  , match=(inport == \"ln_port\" && reg0[[11]] == 0), action=(put_fdb(inport, eth.src); next;)\n])\n\n# Disable 'localnet_learn_fdb' and check the flows\nAT_CHECK([ovn-nbctl --wait=sb lsp-set-options ln_port localnet_learn_fdb=false])\nAT_CHECK([ovn-sbctl dump-flows ls0 | grep -e 'ls_in_\\(put\\|lookup\\)_fdb' | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_lookup_fdb   ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_put_fdb      ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check install_ls_lb_from_router option])\nAT_KEYWORDS([lb-ls-install-from-lrouter])\novn_start\n\novn-nbctl lr-add R1\novn-nbctl set logical_router R1 options:chassis=hv1\novn-nbctl lrp-add R1 R1-S0 02:ac:10:01:00:01 10.0.0.1/24\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:01:01 20.0.0.1/24\novn-nbctl lrp-add R1 R1-PUB 02:ac:20:01:01:01 172.16.0.1/24\n\novn-nbctl ls-add S0\novn-nbctl lsp-add S0 S0-R1\novn-nbctl lsp-set-type S0-R1 router\novn-nbctl lsp-set-addresses S0-R1 02:ac:10:01:00:01\novn-nbctl lsp-set-options S0-R1 router-port=R1-S0\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:01:01\novn-nbctl lsp-set-options S1-R1 router-port=R1-S1\n\n# Add load balancers on the logical router R1\novn-nbctl lb-add lb0 172.16.0.10:80 10.0.0.2:80\novn-nbctl lr-lb-add R1 lb0\n\novn-nbctl lb-add lb1 172.16.0.11:8080 10.0.0.2:8080\nlb1_uuid=$(fetch_column nb:load_balancer _uuid name=lb1)\nlbg=$(ovn-nbctl create load_balancer_group name=lbg -- \\\n    add load_balancer_group lbg load_balancer $lb1_uuid)\novn-nbctl add logical_router R1 load_balancer_group $lbg\novn-nbctl --wait=sb sync\n\novn-sbctl dump-flows S0 > S0flows\novn-sbctl dump-flows S1 > S1flows\n\nAT_CAPTURE_FILE([S0flows])\nAT_CAPTURE_FILE([S1flows])\n\nAT_CHECK([grep \"ls_in_lb \" S0flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n])\nAT_CHECK([grep \"ls_in_lb \" S1flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n])\n\novn-nbctl --wait=sb set NB_Global . options:install_ls_lb_from_router=true\n\novn-sbctl dump-flows S0 > S0flows\novn-sbctl dump-flows S1 > S1flows\n\nAT_CAPTURE_FILE([S0flows])\nAT_CAPTURE_FILE([S1flows])\n\nAT_CHECK([grep \"ls_in_lb \" S0flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=12(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:80);)\n  table=12(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.11 && tcp.dst == 8080), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:8080);)\n])\nAT_CHECK([grep \"ls_in_lb \" S1flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=12(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:80);)\n  table=12(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.11 && tcp.dst == 8080), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:8080);)\n])\n\novn-sbctl get datapath S0 _uuid > dp_uuids\novn-sbctl get datapath S1 _uuid >> dp_uuids\nlb_dp_group=$(ovn-sbctl --bare --columns datapath_group find Load_Balancer name=lb0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lb_dp_group | tail -1 | tr ' ' '\\n' | sort], [0], [dnl\n$(cat dp_uuids | sort)\n])\n\novn-nbctl --wait=sb set NB_Global . options:install_ls_lb_from_router=false\n\novn-sbctl dump-flows S0 > S0flows\novn-sbctl dump-flows S1 > S1flows\n\nAT_CAPTURE_FILE([S0flows])\nAT_CAPTURE_FILE([S1flows])\n\nAT_CHECK([grep \"ls_in_lb \" S0flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n])\nAT_CHECK([grep \"ls_in_lb \" S1flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n])\n\ncheck_column \"\" sb:load_balancer datapaths name=lb0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check fip flows with redirect-type bridged])\nAT_KEYWORDS([fip-redirect-type-bridged])\novn_start\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S0 02:ac:10:01:00:01 10.0.0.1/24 1000::a/64\novn-nbctl lrp-add R1 R1-PUB 02:ac:20:01:01:01 172.16.0.1/24 3000::a/64\novn-nbctl lrp-set-gateway-chassis R1-PUB hv1 20\n\novn-nbctl ls-add S0\novn-nbctl lsp-add S0 S0-R1\novn-nbctl lsp-set-type S0-R1 router\novn-nbctl lsp-set-addresses S0-R1 02:ac:10:01:00:01\novn-nbctl lsp-set-options S0-R1 router-port=R1-S0\novn-nbctl lsp-add S0 S0-P0\novn-nbctl lsp-set-addresses S0-P0 \"50:54:00:00:00:03 10.0.0.3 1000::3\"\n\novn-nbctl lr-nat-add R1 dnat_and_snat 172.16.0.110 10.0.0.3 S0-P0 30:54:00:00:00:03\novn-nbctl lr-nat-add R1 dnat_and_snat 3000::c 1000::3 S0-P0 40:54:00:00:00:03\n\novn-sbctl dump-flows R1 > R1flows\nAT_CAPTURE_FILE([R1flows])\nAT_CHECK([grep \"lr_in_arp_resolve\" R1flows | grep priority=90 | sort], [0], [dnl\n])\n\novn-nbctl --wait=sb set logical_router_port R1-PUB options:redirect-type=bridged\novn-sbctl dump-flows R1 > R1flows\nAT_CAPTURE_FILE([R1flows])\n\nAT_CHECK([grep \"lr_in_arp_resolve\" R1flows | grep priority=90 | sort], [0], [dnl\n  table=17(lr_in_arp_resolve  ), priority=90   , match=(outport == \"R1-PUB\" && ip4.src == 10.0.0.3 && is_chassis_resident(\"S0-P0\")), action=(get_arp(outport, reg0); next;)\n  table=17(lr_in_arp_resolve  ), priority=90   , match=(outport == \"R1-PUB\" && ip6.src == 1000::3 && is_chassis_resident(\"S0-P0\")), action=(get_nd(outport, xxreg0); next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check lb-affinity flows])\nAT_KEYWORDS([lb-affinity-flows])\novn_start\n\novn-nbctl lr-add R1\novn-nbctl set logical_router R1 options:chassis=hv1\novn-nbctl lrp-add R1 R1-S0 02:ac:10:01:00:01 10.0.0.1/24\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:01:01 20.0.0.1/24\novn-nbctl lrp-add R1 R1-PUB 02:ac:20:01:01:01 172.16.0.1/24\n\novn-nbctl ls-add S0\novn-nbctl lsp-add S0 S0-R1\novn-nbctl lsp-set-type S0-R1 router\novn-nbctl lsp-set-addresses S0-R1 02:ac:10:01:00:01\novn-nbctl lsp-set-options S0-R1 router-port=R1-S0\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:01:01\novn-nbctl lsp-set-options S1-R1 router-port=R1-S1\n\n# Add load balancers on the logical router R1\novn-nbctl lb-add lb0 172.16.0.10:80 10.0.0.2:80,20.0.0.2:80 tcp\novn-nbctl lr-lb-add R1 lb0\novn-nbctl ls-lb-add S0 lb0\novn-nbctl --wait=sb sync\n\novn-sbctl dump-flows S0 > S0flows\novn-sbctl dump-flows R1 > R1flows\n\nAT_CAPTURE_FILE([S0flows])\nAT_CAPTURE_FILE([R1flows])\n\nAT_CHECK([grep \"ls_in_lb_aff_check\" S0flows | sort], [0], [dnl\n  table=11(ls_in_lb_aff_check ), priority=0    , match=(1), action=(next;)\n])\nAT_CHECK([grep \"ls_in_lb_aff_learn\" S0flows | sort], [0], [dnl\n  table=13(ls_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_lb_aff_check\" R1flows | sort], [0], [dnl\n  table=6 (lr_in_lb_aff_check ), priority=0    , match=(1), action=(next;)\n])\nAT_CHECK([grep \"lr_in_lb_aff_learn\" R1flows | sort], [0], [dnl\n  table=8 (lr_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)\n])\n\novn-nbctl --wait=sb set load_balancer lb0 options:affinity_timeout=60\n\nAS_BOX([Test LS flows])\novn-sbctl dump-flows S0 > S0flows\nAT_CAPTURE_FILE([S0flows])\n\nAT_CHECK([grep \"ls_in_lb_aff_check\" S0flows | sort], [0], [dnl\n  table=11(ls_in_lb_aff_check ), priority=0    , match=(1), action=(next;)\n  table=11(ls_in_lb_aff_check ), priority=100  , match=(ct.new && ip4 && reg1 == 172.16.0.10 && reg2[[0..15]] == 80), action=(reg9[[6]] = chk_lb_aff(); next;)\n])\nAT_CHECK([grep \"ls_in_lb \" S0flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=12(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80);)\n  table=12(ls_in_lb           ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0[[1]] = 0; reg1 = 172.16.0.10; reg2[[0..15]] = 80; ct_lb_mark(backends=10.0.0.2:80);)\n  table=12(ls_in_lb           ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0[[1]] = 0; reg1 = 172.16.0.10; reg2[[0..15]] = 80; ct_lb_mark(backends=20.0.0.2:80);)\n])\nAT_CHECK([grep \"ls_in_lb_aff_learn\" S0flows | sort], [0], [dnl\n  table=13(ls_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)\n  table=13(ls_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg1 == 172.16.0.10 && reg2[[0..15]] == 80 && ip4.dst == 10.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = \"172.16.0.10:80\", backend = \"10.0.0.2:80\", proto = tcp, timeout = 60); /* drop */)\n  table=13(ls_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg1 == 172.16.0.10 && reg2[[0..15]] == 80 && ip4.dst == 20.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = \"172.16.0.10:80\", backend = \"20.0.0.2:80\", proto = tcp, timeout = 60); /* drop */)\n])\n\nAS_BOX([Test LR flows])\novn-sbctl dump-flows R1 > R1flows\nAT_CAPTURE_FILE([R1flows])\n\nAT_CHECK([grep \"lr_in_lb_aff_check\" R1flows | sort], [0], [dnl\n  table=6 (lr_in_lb_aff_check ), priority=0    , match=(1), action=(next;)\n  table=6 (lr_in_lb_aff_check ), priority=100  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(reg0 = ip4.dst; reg9[[16..31]] = tcp.dst; reg9[[6]] = chk_lb_aff(); next;)\n])\nAT_CHECK([grep \"lr_in_dnat \" R1flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; ct_lb_mark(backends=10.0.0.2:80);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; ct_lb_mark(backends=20.0.0.2:80);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\nAT_CHECK([grep \"lr_in_lb_aff_learn\" R1flows | sort], [0], [dnl\n  table=8 (lr_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)\n  table=8 (lr_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg0 == 172.16.0.10 && reg9[[16..31]] == 80 && ip4.dst == 10.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = \"172.16.0.10:80\", backend = \"10.0.0.2:80\", proto = tcp, timeout = 60); /* drop */)\n  table=8 (lr_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg0 == 172.16.0.10 && reg9[[16..31]] == 80 && ip4.dst == 20.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = \"172.16.0.10:80\", backend = \"20.0.0.2:80\", proto = tcp, timeout = 60); /* drop */)\n])\n\nAS_BOX([Test LR flows - skip_snat=true])\ncheck ovn-nbctl --wait=sb set load_balancer lb0 options:skip_snat=true\n\novn-sbctl dump-flows R1 > R1flows_skip_snat\nAT_CAPTURE_FILE([R1flows_skip_snat])\n\nAT_CHECK([grep \"lr_in_dnat \" R1flows_skip_snat | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80; skip_snat);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80; skip_snat);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.skip_snat_for_lb = 1; ct_lb_mark(backends=20.0.0.2:80; skip_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\ncheck ovn-nbctl remove load_balancer lb0 options skip_snat\n\nAS_BOX([Test LR flows - lb_force_snat_ip=\"172.16.0.1\"])\ncheck ovn-nbctl --wait=sb set logical_router R1 options:lb_force_snat_ip=\"172.16.0.1\"\n\novn-sbctl dump-flows R1 > R1flows_force_snat\nAT_CAPTURE_FILE([R1flows_force_snat])\n\nAT_CHECK([grep \"lr_in_dnat \" R1flows_force_snat | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80; force_snat);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80; force_snat);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.force_snat_for_lb = 1; ct_lb_mark(backends=20.0.0.2:80; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Address set incremental processing])\novn_start\n\n# Create a few resources.\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \"02:ac:10:01:00:04 20.0.0.4\"\ncheck ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 \"02:ac:10:01:00:05 20.0.0.5\"\n\nfetch_column NB:Logical_Switch_Port _uuid name=sw0-p1\n\novn-nbctl list logical_switch_port name=sw0-p1\n\np1_uuid=$(fetch_column nb:Logical_Switch_Port _uuid name=sw0-p1)\np2_uuid=$(fetch_column nb:Logical_Switch_Port _uuid name=sw0-p2)\n\necho \"p1 uuid - $p1_uuid\"\novn-nbctl --wait=sb sync\n\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\nfoo_as_uuid=$(ovn-nbctl create address_set name=foo addresses=\\\"1.1.1.1\\\",\\\"1.1.1.2\\\")\nwait_column '1.1.1.1 1.1.1.2' Address_Set addresses name=foo\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [1\n])\n\nrm -f northd/ovn-northd.log\ncheck as northd ovn-appctl -t NORTHD_TYPE vlog/reopen\ncheck as northd ovn-appctl -t NORTHD_TYPE vlog/set jsonrpc:dbg\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\ncheck ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.3 -- \\\n                add address_set $foo_as_uuid addresses 1.1.2.1/4\nwait_column '1.1.1.1 1.1.1.2 1.1.1.3 1.1.2.1/4' Address_Set addresses name=foo\n\n# There should be no recompute of the sync_to_sb_addr_set engine node .\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [0\n])\n\nAT_CHECK([grep transact northd/ovn-northd.log | grep Address_Set | \\\ngrep -c mutate], [0], [1\n])\n\ncheck ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.4 -- \\\n                remove address_set $foo_as_uuid addresses 1.1.1.1 -- \\\n                remove address_set $foo_as_uuid addresses 1.1.2.1/4\nwait_column '1.1.1.2 1.1.1.3 1.1.1.4' Address_Set addresses name=foo\n\n# There should be no recompute of the sync_to_sb_addr_set engine node .\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [0\n])\n\nAT_CHECK([grep transact northd/ovn-northd.log | grep Address_Set | \\\ngrep -c mutate], [0], [2\n])\n\n# Pause ovn-northd and add/remove few addresses.  when it is resumed\n# it should use mutate for updating the address sets.\ncheck as northd ovn-appctl -t NORTHD_TYPE pause\ncheck as northd-backup ovn-appctl -t NORTHD_TYPE pause\n\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\ncheck ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.5\ncheck ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.6\ncheck ovn-nbctl remove address_set $foo_as_uuid addresses 1.1.1.2\n\ncheck_column '1.1.1.2 1.1.1.3 1.1.1.4' Address_Set addresses name=foo\n\n# Resume northd now\ncheck as northd ovn-appctl -t NORTHD_TYPE resume\nwait_column '1.1.1.3 1.1.1.4 1.1.1.5 1.1.1.6' Address_Set addresses name=foo\n# There should be recompute of the sync_to_sb_addr_set engine node .\nrecompute_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute)\nAT_CHECK([test $recompute_stat -ge 1])\n\nAT_CHECK([grep transact northd/ovn-northd.log | grep Address_Set | \\\ngrep -c mutate], [0], [3\n])\n\n# Create a port group. This should result in recompute of sb_to_sync_addr_set engine node.\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\ncheck ovn-nbctl pg-add pg1\nwait_column '' Address_Set addresses name=pg1_ip4\nrecompute_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute)\nAT_CHECK([test $recompute_stat -ge 1])\n\n# Add sw0-p1 to port group pg1\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\ncheck ovn-nbctl add port_group pg1 ports ${p1_uuid}\nwait_column '20.0.0.4' Address_Set addresses name=pg1_ip4\n\n# There should be recompute of the sync_to_sb_addr_set engine node since northd engine changes.\n# There will be another recompute when the update message is received from the sb ovsdb-server.\n# Once we add I-P for Port_Groups, there should be no recompute here.\nrecompute_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute)\nAT_CHECK([test $recompute_stat -ge 1])\n\n# Any change to northd engine node should result in full recompute of sync_to_sb_addr_set node.\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\ncheck ovn-nbctl --wait=sb sync\nrecompute_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute)\nAT_CHECK([test $recompute_stat -ge 1])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Check default drop])\nAT_KEYWORDS([drop])\n\novn_start\n\n# Check that there is an explicit drop lflow in for spoecified DP and table.\ncheck_default_lflow() {\n    dp=$1\n    pipeline=$2\n\n    table_len=$(ovn-sbctl --bare --columns table find logical_flow logical_datapath=$dp pipeline=$pipeline | sort | uniq | wc -l)\n    table_len_default=$(ovn-sbctl --bare --columns table find logical_flow logical_datapath=$dp pipeline=$pipeline match=1 | sort | uniq | wc -l)\n\n    echo \"Checking if datapath $dp pipeline $pipeline has default actions\"\n    AT_CHECK([test $table_len -eq $table_len_default], [0], [ignore], [ignore], [echo \"Datapath $dp pipeline $pipeline is missing some default action\"])\n}\n\n# Create LS + LR\ncheck ovn-nbctl --wait=sb \\\n                -- lr-add R1 \\\n                -- lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24 \\\n                -- ls-add S1 \\\n                -- lsp-add S1 S1-R1 \\\n                -- lsp-set-type S1-R1 router \\\n                -- lsp-set-addresses S1-R1 02:ac:10:01:00:01 \\\n                -- lsp-set-options S1-R1 router-port=R1-S1 \\\n                -- lsp-add S1 p1 \\\n                -- lsp-set-addresses p1 \"02:ac:10:01:00:0a 172.16.1.100\"\n\novn-sbctl dump-flows R1 > R1_flows\novn-sbctl dump-flows R1 | grep \"match=(1)\" > R1_default_flows\novn-sbctl dump-flows S1 > S1_flows\novn-sbctl dump-flows S1 | grep \"match=(1)\" > S1_default_flows\n\nAT_CAPTURE_FILE([R1_flows])\nAT_CAPTURE_FILE([R1_default_flows])\nAT_CAPTURE_FILE([S1_flows])\nAT_CAPTURE_FILE([S1_default_flows])\n\nlr_uuid=$(fetch_column datapath _uuid external_ids:name=R1)\nls_uuid=$(fetch_column datapath _uuid external_ids:name=S1)\n\ncheck_default_lflow $lr_uuid ingress\ncheck_default_lflow $lr_uuid egress\n\ncheck_default_lflow $ls_uuid ingress\ncheck_default_lflow $ls_uuid egress\n\n# Add stateless ACL\ncheck ovn-nbctl --wait=sb \\\n                -- acl-add S1 from-lport 100 'inport=p1 && ip4' allow-stateless\n\nAT_CHECK([ovn-sbctl dump-flows | grep \"ls_in_acl\" | grep \"match=(1)\"  | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb acl-del S1\n\n\n# Add stateful ACL\ncheck ovn-nbctl --wait=sb \\\n                -- acl-add S1 from-lport 2 \"udp\" allow-related\n\nAT_CHECK([ovn-sbctl dump-flows | grep \"ls_in_acl\" | grep \"match=(1)\"  | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb acl-del S1\n\n# Add LB\ncheck ovn-nbctl --wait=sb \\\n    -- lb-add lb \"10.0.0.1\" \"10.0.0.2\" \\\n    -- ls-lb-add S1 lb\n\nAT_CHECK([ovn-sbctl dump-flows | grep \"ls_in_acl\" | grep \"match=(1)\"  | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n])\n\n\n# Check LB + stateless ACL\ncheck ovn-nbctl --wait=sb \\\n                -- acl-add S1 from-lport 100 'inport=p1 && ip4' allow-stateless\n\nAT_CHECK([ovn-sbctl dump-flows | grep \"ls_in_acl\" | grep \"match=(1)\"  | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb acl-del S1\n\n# Check LB + statelful ACL\ncheck ovn-nbctl --wait=sb \\\n                -- acl-add S1 from-lport 2 \"udp\" allow-related\n\nAT_CHECK([ovn-sbctl dump-flows | grep \"ls_in_acl\" | grep \"match=(1)\"  | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([NB to SB Chassis_Template_Var propagation])\nAT_KEYWORDS([templates])\novn_start\n\nAT_CHECK([ovn-nbctl create Chassis_Template_Var chassis=\"hv1\"], [0], [ignore])\nAT_CHECK([ovn-nbctl create Chassis_Template_Var chassis=\"hv2\"], [0], [ignore])\n\ncheck ovn-nbctl set Chassis_Template_Var hv1 variables:tv=v1\ncheck ovn-nbctl set Chassis_Template_Var hv2 variables:tv=v2\n\nAS_BOX([Ensure values are propagated to SB])\ncheck ovn-nbctl --wait=sb sync\ncheck_column \"tv=v1\" sb:Chassis_Template_Var variables chassis=\"hv1\"\ncheck_column \"tv=v2\" sb:Chassis_Template_Var variables chassis=\"hv2\"\n\nAS_BOX([Ensure SB is reconciled])\ncheck ovn-sbctl --all destroy Chassis_Template_Var\ncheck ovn-nbctl --wait=sb sync\ncheck_column \"tv=v1\" sb:Chassis_Template_Var variables chassis=\"hv1\"\ncheck_column \"tv=v2\" sb:Chassis_Template_Var variables chassis=\"hv2\"\n\nAS_BOX([Ensure SB is reconciled - deletion])\ncheck ovn-nbctl destroy Chassis_Template_Var hv1\ncheck ovn-nbctl --wait=sb sync\ncheck_column \"tv=v2\" sb:Chassis_Template_Var variables chassis=\"hv2\"\n\nAS_BOX([Ensure SB is reconciled - cleanup])\ncheck ovn-nbctl destroy Chassis_Template_Var hv2\ncheck ovn-nbctl --wait=sb sync\ncheck_row_count sb:Chassis_Template_Var 0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load balancer CT related backwards compatibility])\nAT_KEYWORDS([lb])\novn_start\n\ncheck ovn-nbctl                                               \\\n  -- ls-add ls                                                \\\n  -- lr-add lr -- set logical_router lr options:chassis=local \\\n  -- lb-add lb-test 192.168.0.1 192.168.1.10                  \\\n  -- ls-lb-add ls lb-test                                     \\\n  -- lr-lb-add lr lb-test\n\nm4_define([DUMP_FLOWS_SORTED], [sed 's/table=[[0-9]]\\{1,2\\}/table=?/' | sort])\n\nAS_BOX([No chassis registered - CT related flows should be installed])\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > lflows0\n\nAT_CHECK([grep -e \"lr_in_defrag\" -e \"lr_in_dnat\" lflows0], [0], [dnl\n  table=? (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 192.168.0.1), action=(ct_dnat;)\n  table=? (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(ct_lb_mark(backends=192.168.1.10);)\n  table=? (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=? (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep -e \"ls_in_acl\" -e \"ls_out_acl\" lflows0 | grep \"priority=65532\"], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n])\n\n\nAS_BOX([Chassis registered that doesn't support CT related])\ncheck ovn-sbctl chassis-add hv geneve 127.0.0.1\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > lflows1\n\nAT_CHECK([grep -e \"lr_in_defrag\" -e \"lr_in_dnat\" lflows1], [0], [dnl\n  table=? (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 192.168.0.1), action=(ct_dnat;)\n  table=? (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(ct_lb(backends=192.168.1.10);)\n  table=? (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted), action=(next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n])\n\nAT_CHECK([grep -e \"ls_in_acl\" -e \"ls_out_acl\" lflows1 | grep \"priority=65532\"], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n])\n\nAS_BOX([Chassis upgrades and supports CT related])\ncheck ovn-sbctl set chassis hv other_config:ct-no-masked-label=true\ncheck ovn-sbctl set chassis hv other_config:ovn-ct-lb-related=true\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > lflows2\n\nAT_CHECK([grep -e \"lr_in_defrag\" -e \"lr_in_dnat\" lflows2], [0], [dnl\n  table=? (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 192.168.0.1), action=(ct_dnat;)\n  table=? (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(ct_lb_mark(backends=192.168.1.10);)\n  table=? (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=? (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep -e \"ls_in_acl\" -e \"ls_out_acl\" lflows2 | grep \"priority=65532\"], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Chassis-feature compatibitility - remote chassis])\novn_start\n\nAS_BOX([Local chassis])\ncheck ovn-sbctl chassis-add hv1 geneve 127.0.0.1 \\\n  -- set chassis hv1 other_config:ct-no-masked-label=true \\\n  -- set chassis hv1 other_config:ovn-ct-lb-related=true \\\n  -- set chassis hv1 other_config:mac-binding-timestamp=true\n\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE debug/chassis-features-list], [0], [dnl\nct_no_masked_label:    true\nct_lb_related:         true\nmac_binding_timestamp: true\n])\n\nAS_BOX([Remote chassis])\ncheck ovn-sbctl chassis-add hv2 geneve 127.0.0.2 \\\n  -- set chassis hv2 other_config:is-remote=true \\\n  -- set chassis hv2 other_config:ct-no-masked-label=false \\\n  -- set chassis hv2 other_config:ovn-ct-lb-related=false \\\n  -- set chassis hv2 other_config:mac-binding-timestamp=false\n\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE debug/chassis-features-list], [0], [dnl\nct_no_masked_label:    true\nct_lb_related:         true\nmac_binding_timestamp: true\n])\n\nAT_CLEANUP\n])\n\nAT_SETUP([Localnet ports on LS with LB])\novn_start\n# In the past, traffic arriving on localnet ports has skipped conntrack.\n# This test ensures that we still skip conntrack for localnet ports,\n# *except* for the case where the logical switch has a load balancer\n# configured. In this case, the localnet port will not skip conntrack,\n# allowing for traffic to be load balanced on the localnet port.\n\ncheck ovn-nbctl ls-add sw\ncheck ovn-nbctl lsp-add sw sw-ln\ncheck ovn-nbctl lsp-set-type sw-ln localnet\ncheck ovn-nbctl lsp-set-addresses sw-ln unknown\ncheck ovn-nbctl --wait=sb sync\n\n# Since this test is only concerned with logical flows, we don't need to\n# configure anything else that we normally would with regards to localnet\n# ports\n\n\n# First, ensure that conntrack is skipped for the localnet port since there\n# isn't a load balancer configured.\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_in_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_pre_lb       ), priority=110  , match=(ip && inport == \"sw-ln\"), action=(next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_out_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_out_pre_lb      ), priority=110  , match=(ip && outport == \"sw-ln\"), action=(ct_clear; next;)\n])\n\n# Now add a load balancer and ensure that we no longer are skipping conntrack\n# for the localnet port\n\ncheck ovn-nbctl lb-add lb 10.0.0.1:80 10.0.0.100:8080 tcp\ncheck ovn-nbctl ls-lb-add sw lb\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_in_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_out_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n])\n\n# And ensure that removing the load balancer from the switch results in skipping\n# conntrack again\ncheck ovn-nbctl ls-lb-del sw lb\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_in_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_pre_lb       ), priority=110  , match=(ip && inport == \"sw-ln\"), action=(next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_out_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_out_pre_lb      ), priority=110  , match=(ip && outport == \"sw-ln\"), action=(ct_clear; next;)\n])\n\nAT_CLEANUP\n])\n", "AT_BANNER([system-ovn])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([2 LRs connected via LS, gateway router, SNAT and DNAT])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switches foo (192.168.1.0/24) and\n# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected\n# to it.  R2 is a gateway router on which we add NAT rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.2 -- add logical_router R2 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.2.2 \\\n    external_ip=30.0.0.1 -- add logical_router R2 nat @nat\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.1)'])\n\n# 'alice1' should be able to ping 'foo1' directly.\nNS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 192.168.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# North-South DNAT: 'alice1' should also be able to ping 'foo1' via 30.0.0.2\nNS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=172.16.1.2,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic\n# from 30.0.0.1\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# Add static routes to handle east-west NAT.\novn-nbctl lr-route-add R1 30.0.0.0/24 20.0.0.2\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# East-west DNAT and SNAT: 'bar1' pings 30.0.0.2. 'foo1' receives it.\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# As we have a static route that sends all packets with destination\n# 30.0.0.2 to R2, it hits the DNAT rule and converts 30.0.0.2 to 192.168.1.2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# As we have a SNAT rule that converts 192.168.2.2 to 30.0.0.1, the source is\n# SNATted and 'foo1' receives it.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([2 LRs connected via LS, gateway router, SNAT and DNAT - IPv6])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in fd00::/64 network. R1 has switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it. R2 has alice (fd21::/64) connected\n# to it.  R2 is a gateway router on which we add NAT rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd21::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd00::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd00::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 fd21::/64 fd00::2\novn-nbctl lr-route-add R2 fd11::/64 fd00::1\novn-nbctl lr-route-add R2 fd12::/64 fd00::1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd21::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd21::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd21::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd21::2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n         \"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=\\\"fd11::2\\\" \\\n    external_ip=\\\"fd30::2\\\" -- add logical_router R2 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=\\\"fd12::2\\\" \\\n    external_ip=\\\"fd30::1\\\" -- add logical_router R2 nat @nat\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd30::1)'])\n\n# 'alice1' should be able to ping 'foo1' directly.\nNS_CHECK_EXEC([alice1], [ping6 -v -q -c 3 -i 0.3 -w 2 fd11::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# North-South DNAT: 'alice1' should also be able to ping 'foo1' via fd30::2\nNS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd21::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd21::2,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd21::2,id=<cleared>,type=129,code=0),zone=<cleared>\nicmpv6,orig=(src=fd21::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd21::2,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic\n# from fd30::1\nNS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd21::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd21::2,id=<cleared>,type=128,code=0),reply=(src=fd21::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# Add static routes to handle east-west NAT.\novn-nbctl lr-route-add R1 fd30::/64 fd00::2\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# East-west DNAT and SNAT: 'bar1' pings fd30::2. 'foo1' receives it.\nNS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# As we have a static route that sends all packets with destination\n# fd30::2 to R2, it hits the DNAT rule and converts fd30::2 to fd11::2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd12::2,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# As we have a SNAT rule that converts fd12::2 to fd30::1, the source is\n# SNATted and 'foo1' receives it.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([2 LRs connected via LS, gateway router, easy SNAT])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) connected\n# to it.  R2 has alice (172.16.1.0/24) connected to it.\n# R2 is a gateway router on which we add NAT rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n\novn-nbctl lr-add R1\novn-nbctl lr-add R2 -- set Logical_Router R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect alice to R2\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.2\"\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.1.2 \\\n    external_ip=172.16.1.1 -- add logical_router R2 nat @nat\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])\n\n# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic\n# from 172.16.1.1\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([2 LRs connected via LS, gateway router, easy SNAT - IPv6])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in fd20::/64 network. R1 has switchess foo (fd10::/64) connected\n# to it.  R2 has alice (fd30::/64) connected to it.\n# R2 is a gateway router on which we add NAT rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n\novn-nbctl lr-add R1\novn-nbctl lr-add R2 -- set Logical_Router R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd10::1/64\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd30::1/64\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect alice to R2\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 fd30::/64 fd20::2\novn-nbctl lr-route-add R2 fd10::/64 fd20::1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd10::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd10::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo1 ip a | grep fd10::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd10::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd30::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd30::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd30::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd30::2\"\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=\\\"fd10::2\\\" \\\n    external_ip=\\\"fd30::1\\\" -- add logical_router R2 nat @nat\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd30::1)'])\n\n# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic\n# from fd30::1\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd10::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd30::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, SNAT and DNAT])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and\n# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected\n# to it.  R3 has bob (172.16.1.0/24) connected to it. Note how both alice and\n# bob have the same subnet behind it.  We are trying to simulate external\n# network via those 2 switches. In real world the switch ports of these\n# switches will have addresses set as \"unknown\" to make them learning switches.\n# Or those switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.1.0/24 20.0.0.2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.2.0/24 20.0.0.3\n\n# Static routes.\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\novn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:dnat_force_snat_ip=20.0.0.2\novn-nbctl set logical_router R3 options:dnat_force_snat_ip=20.0.0.3\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.3/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"172.16.1.4/24\", \"f0:00:00:01:02:06\", \\\n         \"172.16.1.2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 172.16.1.4\"\n\n# Router R2\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.2 -- add logical_router R2 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.1 -- add logical_router R2 nat @nat\n\n# Router R3\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.3 -- add logical_router R3 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.2.2 \\\n    external_ip=30.0.0.4 -- add logical_router R3 nat @nat\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.4)'])\n\n# North-South DNAT: 'alice1' should be able to ping 'foo1' via 30.0.0.2\nNS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.3,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from 20.0.0.2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.3,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# North-South DNAT: 'bob1' should be able to ping 'foo1' via 30.0.0.3\nNS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.4,dst=30.0.0.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from 20.0.0.3\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.4,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic\n# from 30.0.0.4\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=30.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic\n# from 30.0.0.1\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=172.16.1.3,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, SNAT and DNAT - IPv6])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in fd20::/64 network. R1 has switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it. R2 has alice (fd30::/64) connected\n# to it.  R3 has bob (fd30::/64) connected to it. Note how both alice and\n# bob have the same subnet behind it.  We are trying to simulate external\n# network via those 2 switches. In real world the switch ports of these\n# switches will have addresses set as \"unknown\" to make them learning switches.\n# Or those switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd30::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 fd30::2/64\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 fd20::3/64\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd11::/64 fd20::2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd12::/64 fd20::3\n\n# Static routes.\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\novn-nbctl lr-route-add R3 fd11::/64 fd20::1\novn-nbctl lr-route-add R3 fd12::/64 fd20::1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:dnat_force_snat_ip=fd20::2\novn-nbctl set logical_router R3 options:dnat_force_snat_ip=fd20::3\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd30::3/64\", \"f0:00:00:01:02:04\", \\\n         \"fd30::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd30::3 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd30::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n         \"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"fd30::4/64\", \"f0:00:00:01:02:06\", \\\n         \"fd30::2\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bob1 ip a | grep fd30::4 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 fd30::4\"\n\n# External IPs -- 30.0.0.N --> fd40::N (from IPv4 version of test case)\n\n# Router R2\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::2\"' -- add logical_router R2 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::1\"' -- add logical_router R2 nat @nat\n\n# Router R3\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::3\"' -- add logical_router R3 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip='\"fd12::2\"' \\\n    external_ip='\"fd40::4\"' -- add logical_router R3 nat @nat\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd40::4)'])\n\n# North-South DNAT: 'alice1' should be able to ping 'foo1' via fd30::2\nNS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd40::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::3,dst=fd40::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::3,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from fd20::2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::3,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# North-South DNAT: 'bob1' should be able to ping 'foo1' via fd40::3\nNS_CHECK_EXEC([bob1], [ping6 -q -c 3 -i 0.3 -w 2 fd40::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::4,dst=fd40::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::4,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from fd20::3\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::4,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic\n# from fd40::4\nNS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd30::4,id=<cleared>,type=128,code=0),reply=(src=fd30::4,dst=fd40::4,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic\n# from fd40::1\nNS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd11::2,dst=fd30::3,id=<cleared>,type=128,code=0),reply=(src=fd30::3,dst=fd40::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, SNAT and DNAT - Dual Stack])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 and fd20::/64 networks. R1 has switches foo (192.168.1.0/24\n# and fd11::/64) and bar (192.168.2.0/24 and fd12::/64) connected to it. R2\n# has alice (172.16.1.0/24 and fd30::/64) connected to it.  R3 has bob\n# (172.16.1.0/24 andfd30::/64) connected to it. Note how both alice and bob\n# have the same subnets behind them.  We are trying to simulate external network\n# via those 2 switches. In real world the switch ports of these switches will\n# have addresses set as \"unknown\" to make them learning switches. Or those\n# switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24 fd30::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24 fd30::2/64\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24 fd20::3/64\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd11::/64 fd20::2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd12::/64 fd20::3\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.1.0/24 20.0.0.2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.2.0/24 20.0.0.3\n\n# Static routes.\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\novn-nbctl lr-route-add R3 fd11::/64 fd20::1\novn-nbctl lr-route-add R3 fd12::/64 fd20::1\novn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:dnat_force_snat_ip=\"20.0.0.2 fd20::2\"\novn-nbctl set logical_router R3 options:dnat_force_snat_ip=\"20.0.0.3 fd20::3\"\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\nADD_NAMESPACES(foo16)\nADD_VETH(foo16, foo16, br-int, \"fd11::2/64\", \"f0:00:00:02:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo16 ip a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo16 \\\n-- lsp-set-addresses foo16 \"f0:00:00:02:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.3/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.3\"\n\nADD_NAMESPACES(alice16)\nADD_VETH(alice16, alice16, br-int, \"fd30::3/64\", \"f0:00:00:02:02:04\", \\\n         \"fd30::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice16 ip a | grep fd30::3 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice16 \\\n-- lsp-set-addresses alice16 \"f0:00:00:02:02:04 fd30::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\nADD_NAMESPACES(bar16)\nADD_VETH(bar16, bar16, br-int, \"fd12::2/64\", \"f0:00:00:02:02:05\", \\\n         \"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bar16 ip a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar16 \\\n-- lsp-set-addresses bar16 \"f0:00:00:02:02:05 fd12::2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"172.16.1.4/24\", \"f0:00:00:01:02:06\", \\\n         \"172.16.1.2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 172.16.1.4\"\n\nADD_NAMESPACES(bob16)\nADD_VETH(bob16, bob16, br-int, \"fd30::4/64\", \"f0:00:00:02:02:06\", \\\n         \"fd30::2\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bob16 ip a | grep fd30::4 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bob bob16 \\\n-- lsp-set-addresses bob16 \"f0:00:00:02:02:06 fd30::4\"\n\n# Router R2\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.2 -- add logical_router R2 nat @nat\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::2\"' -- add logical_router R2 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.1 -- add logical_router R2 nat @nat\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::1\"' -- add logical_router R2 nat @nat\n\n# Router R3\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.3 -- add logical_router R3 nat @nat\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::3\"' -- add logical_router R3 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.2.2 \\\n    external_ip=30.0.0.4 -- add logical_router R3 nat @nat\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip='\"fd12::2\"' \\\n    external_ip='\"fd40::4\"' -- add logical_router R3 nat @nat\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd40::4)'])\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.4)'])\n\n# North-South DNAT: 'alice1' should be able to ping 'foo1' via 30.0.0.2\nNS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# North-South DNAT: 'alice16' should be able to ping 'foo16' via fd30::2\nNS_CHECK_EXEC([alice16], [ping6 -q -c 3 -i 0.3 -w 2 fd40::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.3,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::3,dst=fd40::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::3,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from 20.0.0.2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.3,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n# But foo16 should receive traffic from fd20::2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::3,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# North-South DNAT: 'bob1' should be able to ping 'foo1' via 30.0.0.3\nNS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# North-South DNAT: 'bob16' should be able to ping 'foo16' via fd40::3\nNS_CHECK_EXEC([bob16], [ping6 -q -c 3 -i 0.3 -w 2 fd40::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.4,dst=30.0.0.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::4,dst=fd40::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::4,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from 20.0.0.3\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.4,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# But foo16 should receive traffic from fd20::3\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::4,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic\n# from 30.0.0.4\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n# South-North SNAT: 'bar16' pings 'bob16'. But 'bob16' receives traffic\n# from fd40::4\nNS_CHECK_EXEC([bar16], [ping6 -q -c 3 -i 0.3 -w 2 fd30::4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=30.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd30::4,id=<cleared>,type=128,code=0),reply=(src=fd30::4,dst=fd40::4,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic\n# from 30.0.0.1\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# South-North SNAT: 'foo16' pings 'alice16'. But 'alice16' receives traffic\n# from fd40::1\nNS_CHECK_EXEC([foo16], [ping6 -q -c 3 -i 0.3 -w 2 fd30::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=172.16.1.3,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd11::2,dst=fd30::3,id=<cleared>,type=128,code=0),reply=(src=fd30::3,dst=fd40::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancing])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 2 logical switches \"foo\" (192.168.1.0/24) and \"bar\" (172.16.1.0/24)\n# connected to a router R1.\n# foo has foo1 to act as a client.\n# bar has bar1, bar2, bar3 to act as servers.\n#\n# Loadbalancer VIPs in 30.0.0.0/24 network.\n\novn-nbctl create Logical_Router name=R1\novn-nbctl ls-add foo\novn-nbctl ls-add bar\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 172.16.1.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Create logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"172.16.1.2/24\", \"f0:00:0f:01:02:03\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:0f:01:02:03 172.16.1.2\"\n\nADD_NAMESPACES(bar2)\nADD_VETH(bar2, bar2, br-int, \"172.16.1.3/24\", \"f0:00:0f:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add bar bar2 \\\n-- lsp-set-addresses bar2 \"f0:00:0f:01:02:04 172.16.1.3\"\n\nADD_NAMESPACES(bar3)\nADD_VETH(bar3, bar3, br-int, \"172.16.1.4/24\", \"f0:00:0f:01:02:05\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add bar bar3 \\\n-- lsp-set-addresses bar3 \"f0:00:0f:01:02:05 172.16.1.4\"\n\n# Config OVN load-balancer with a VIP.\novn-nbctl lb-add lb1 30.0.0.1 \"172.16.1.2,172.16.1.3,172.16.1.4\"\novn-nbctl ls-lb-add foo lb1\n\n# Create another load-balancer with another VIP.\nlb2_uuid=`ovn-nbctl create load_balancer name=lb2 vips:30.0.0.3=\"172.16.1.2,172.16.1.3,172.16.1.4\"`\novn-nbctl ls-lb-add foo lb2\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $lb2_uuid vips:'\"30.0.0.2:8000\"'='\"172.16.1.2:80,172.16.1.3:80,172.16.1.4:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=172.16.1.4:80)'])\n\n# Start webservers in 'bar1', 'bar2' and 'bar3'.\nOVS_START_L7([bar1], [http])\nOVS_START_L7([bar2], [http])\nOVS_START_L7([bar3], [http])\n\n# Add ACLs (after lb) to drop the traffic if destined to backend  ips.\ncheck ovn-nbctl --apply-after-lb acl-add foo from-lport 1002 \"ip4 && ip4.dst == {172.16.1.2,172.16.1.3,172.16.1.4} && ct.new\" drop\ncheck ovn-nbctl --wait=hv sync\n\nAT_CHECK([ip netns exec foo1 wget 30.0.0.1 -t 3 -T 1], [4], [ignore], [ignore])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# Clear the apply-after-lb option.  The traffic will be allowed.\ncheck ovn-nbctl clear acl . options\novn-nbctl --wait=hv sync\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\novn-nbctl acl-del foo from-lport 1002 \"ip4 && ip4.dst == {172.16.1.2,172.16.1.3,172.16.1.4} && ct.new\"\novn-nbctl --wait=hv sync\n\ndnl Should work with the virtual IP 30.0.0.1 address through NAT\ndnl Each server should have at least one connection.\ndnl With 20 requests, one server might not receive any connection\ndnl in 0.3% of cases, so run a few times.\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Should work with the virtual IP 30.0.0.3 address through NAT\ndnl Each server should have at least one connection.\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.3 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\ndnl Each server should have at least one connection.\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Configure selection_fields.\novn-nbctl set load_balancer $lb2_uuid selection_fields=\"ip_src,ip_dst,tp_src,tp_dst\"\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)\" -c) -eq 2\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\ndnl Test load-balancing that includes L4 ports in NAT.\ndnl Each server should have at least one connection.\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\necho \"foo\" > foo\nfor i in `seq 1 20`; do\n    echo Request $i\n    ip netns exec foo1 nc -p 30000 30.0.0.2 8000 < foo\ndone\n\ndnl Only one backend should be chosen.\nAT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 -c) -eq 1])\n\novn-nbctl set load_balancer $lb2_uuid selection_fields=\"ip_src\"\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields=ip_src\" -c) -eq 2\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\nfor i in `seq 1 20`; do\n    echo Request $i\n    ip netns exec foo1 nc 30.0.0.2 8000 < foo\ndone\n\ndnl Only one backend should be chosen as eth_src and ip_src is fixed.\nbar1_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.2 -c)\nbar2_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.3 -c)\nbar3_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.4 -c)\n\nAT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1 -c) -ne 0])\n\nif [[ \"$bar1_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar2_ct -eq 0])\n    AT_CHECK([test $bar3_ct -eq 0])\nelse\n    AT_CHECK([test $bar1_ct -eq 0])\nfi\n\nif [[ \"$bar2_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar1_ct -eq 0])\n    AT_CHECK([test $bar3_ct -eq 0])\nelse\n    AT_CHECK([test $bar2_ct -eq 0])\nfi\n\nif [[ \"$bar3_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar1_ct -eq 0])\n    AT_CHECK([test $bar2_ct -eq 0])\nelse\n    AT_CHECK([test $bar3_ct -eq 0])\nfi\n\n# Change the protocol of lb2 to udp and set tp_src and tp_dst.\novn-nbctl set load_balancer $lb2_uuid selection_fields=\"ip_src,ip_dst,tp_src,tp_dst\"\n\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)\" -c) -eq 2\n])\n\novn-nbctl set load_balancer $lb2_uuid protocol=udp\n\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(ip_src,ip_dst,udp_src,udp_dst)\" -c) -eq 2\n])\n\n# Change the protocol of lb2 to sctp.\novn-nbctl set load_balancer $lb2_uuid protocol=sctp\n\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(ip_src,ip_dst,sctp_src,sctp_dst)\" -c) -eq 2\n])\n\novn-nbctl --reject lb-add lb3 30.0.0.10:80 \"\"\novn-nbctl ls-lb-add foo lb3\n# Filter reset segments\nNS_CHECK_EXEC([foo1], [tcpdump -l -c 1 -neei foo1 ip[[33:1]]=0x14 > rst.pcap 2>tcpdump_err &])\nOVS_WAIT_UNTIL([grep \"listening\" tcpdump_err])\nNS_CHECK_EXEC([foo1], [wget -q 30.0.0.10],[4])\n\nOVS_WAIT_UNTIL([\n    n_reset=$(cat rst.pcap | wc -l)\n    test \"${n_reset}\" = \"1\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancing - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 2 logical switches \"foo\" (fd01::/64) and \"bar\" (fd02::/64)\n# connected to a router R1.\n# foo has foo1 to act as a client.\n# bar has bar1, bar2, bar3 to act as servers.\n#\n# Loadbalancer VIPs in fd03::/64 network.\n\novn-nbctl create Logical_Router name=R1\novn-nbctl ls-add foo\novn-nbctl ls-add bar\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd02::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Create logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd01::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd01::1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd01::2\"\n\n# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd02::2/64\", \"f0:00:0f:01:02:03\", \\\n         \"fd02::1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:0f:01:02:03 fd02::2\"\n\nADD_NAMESPACES(bar2)\nADD_VETH(bar2, bar2, br-int, \"fd02::3/64\", \"f0:00:0f:01:02:04\", \\\n         \"fd02::1\")\novn-nbctl lsp-add bar bar2 \\\n-- lsp-set-addresses bar2 \"f0:00:0f:01:02:04 fd02::3\"\n\nADD_NAMESPACES(bar3)\nADD_VETH(bar3, bar3, br-int, \"fd02::4/64\", \"f0:00:0f:01:02:05\", \\\n         \"fd02::1\")\novn-nbctl lsp-add bar bar3 \\\n-- lsp-set-addresses bar3 \"f0:00:0f:01:02:05 fd02::4\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:\\\"fd03::1\\\"=\\\"fd02::2,fd02::3,fd02::4\\\"`\novn-nbctl set logical_switch foo load_balancer=$uuid\n\n# Create another load-balancer with another VIP.\nlb2_uuid=`ovn-nbctl create load_balancer vips:\\\"fd03::3\\\"=\\\"fd02::2,fd02::3,fd02::4\\\"`\novn-nbctl add logical_switch foo load_balancer $lb2_uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $lb2_uuid vips:'\"[[fd03::2]]:8000\"'='\"@<:@fd02::2@:>@:80,@<:@fd02::3@:>@:80,@<:@fd02::4@:>@:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd02::4\\]]:80)'])\n\n# Start webservers in 'bar1', 'bar2' and 'bar3'.\nOVS_START_L7([bar1], [http6])\nOVS_START_L7([bar2], [http6])\nOVS_START_L7([bar3], [http6])\n\ndnl Should work with the virtual IP fd03::1 address through NAT\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log || (ovs-ofctl -O OpenFlow13 dump-flows br-int && false)])\ndone\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::1) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Should work with the virtual IP fd03::3 address through NAT\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::3]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::3) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_WAIT_FOR_OUTPUT([\ndnl Test load-balancing that includes L4 ports in NAT.\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Configure selection_fields.\novn-nbctl set load_balancer $lb2_uuid selection_fields=\"ip_src,ip_dst,tp_src,tp_dst\"\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)\" -c) -eq 2\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nOVS_WAIT_FOR_OUTPUT([\ndnl Test load-balancing that includes L4 ports in NAT.\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\necho \"foo\" > foo\nfor i in `seq 1 20`; do\n    echo Request $i\n    ip netns exec foo1 nc -6 -p 30000 fd03::2 8000 < foo\ndone\n\n# Only one backend should be chosen. Since the source port is fixed,\n# there should be only one conntrack entry.\nAT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep fd03::2 -c) -eq 1])\n\novn-nbctl set load_balancer $lb2_uuid selection_fields=\"eth_src,ip_src\"\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(eth_src,ip_src)\" -c) -eq 2\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\nfor i in `seq 1 20`; do\n    echo Request $i\n    ip netns exec foo1 nc -6 fd03::2 8000 < foo\ndone\n\ndnl Only one backend should be chosen as eth_src and ip_src is fixed.\nbar1_ct=$(ovs-appctl dpctl/dump-conntrack | grep fd03::2 | grep fd02::2 -c)\nbar2_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep fd02::3 -c)\nbar3_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep fd02::4 -c)\n\nAT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep fd03::2 | grep fd02 -c) -ne 0])\n\nif [[ \"$bar1_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar1_ct -eq 20])\n    AT_CHECK([test $bar2_ct -eq 0])\n    AT_CHECK([test $bar3_ct -eq 0])\nelse\n    AT_CHECK([test $bar1_ct -eq 0])\nfi\n\nif [[ \"$bar2_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar1_ct -eq 20])\n    AT_CHECK([test $bar2_ct -eq 0])\n    AT_CHECK([test $bar3_ct -eq 0])\nelse\n    AT_CHECK([test $bar2_ct -eq 0])\nfi\n\nif [[ \"$bar3_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar1_ct -eq 20])\n    AT_CHECK([test $bar2_ct -eq 0])\n    AT_CHECK([test $bar3_ct -eq 0])\nelse\n    AT_CHECK([test $bar3_ct -eq 0])\nfi\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancing - same subnet.])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 1 logical switch \"foo\" (192.168.1.0/24) connected to router R1.\n# foo has foo1, foo2, foo3, foo4 as logical ports.\n#\n# Loadbalancer VIPs in 30.0.0.0/24 network. Router is needed for default\n# gateway. We will test load-balancing with foo1 as a client and foo2, foo3 and\n# foo4 as servers.\n\novn-nbctl create Logical_Router name=R1\novn-nbctl ls-add foo\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Create logical port 'foo1', 'foo2', 'foo3' and 'foo4' in switch 'foo'.\nADD_NAMESPACES(foo1, foo2, foo3, foo4)\nfor i in `seq 1 4`; do\n    j=`expr $i + 1`\n    ADD_VETH(foo$i, foo$i, br-int, \"192.168.1.$j/24\", \"f0:00:00:01:02:0$j\", \\\n             \"192.168.1.1\")\n    ovn-nbctl lsp-add foo foo$i \\\n        -- lsp-set-addresses foo$i \"f0:00:00:01:02:0$j 192.168.1.$j\"\ndone\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.3,192.168.1.4,192.168.1.5\"`\novn-nbctl set logical_switch foo load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"30.0.0.2:8000\"'='\"192.168.1.3:80,192.168.1.4:80,192.168.1.5:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.1.5:80)'])\n\n# Start webservers in 'foo2', 'foo3' and 'foo4'.\nOVS_START_L7([foo2], [http])\nOVS_START_L7([foo3], [http])\nOVS_START_L7([foo4], [http])\n\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.5,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.5,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancing - same subnet. - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 1 logical switch \"foo\" (fd01::/64) connected to router R1.\n# foo has foo1, foo2, foo3, foo4 as logical ports.\n#\n# Loadbalancer VIPs in fd03::/64 network. Router is needed for default\n# gateway. We will test load-balancing with foo1 as a client and foo2, foo3 and\n# foo4 as servers.\n\novn-nbctl create Logical_Router name=R1\novn-nbctl ls-add foo\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Create logical port 'foo1', 'foo2', 'foo3' and 'foo4' in switch 'foo'.\nADD_NAMESPACES(foo1, foo2, foo3, foo4)\nfor i in `seq 1 4`; do\n    j=`expr $i + 1`\n    ADD_VETH(foo$i, foo$i, br-int, \"fd01::$j/64\", \"f0:00:00:01:02:0$j\", \\\n             \"fd01::1\")\n    ovn-nbctl lsp-add foo foo$i \\\n        -- lsp-set-addresses foo$i \"f0:00:00:01:02:0$j fd01::$j\"\ndone\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:\\\"fd03::1\\\"=\\\"fd01::3,fd01::4,fd01::5\\\"`\novn-nbctl set logical_switch foo load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"[[fd03::2]]:8000\"'='\"@<:@fd01::3@:>@:80,@<:@fd01::4@:>@:80,@<:@fd01::5@:>@:80\"'\n\novn-nbctl list load_balancer\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd01::5\\]]:80)'])\n\n# Start webservers in 'foo2', 'foo3' and 'foo4'.\nOVS_START_L7([foo2], [http6])\nOVS_START_L7([foo3], [http6])\nOVS_START_L7([foo4], [http6])\n\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::1) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::5,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::5,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing in gateway router])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and\n# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected\n# to it.  R2 is a gateway router on which we add load-balancing rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.2,192.168.2.2\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"30.0.0.2:8000\"'='\"192.168.1.2:80,192.168.2.2:80\"'\n\n# Add SNAT rule to make sure that Load-balancing still works with a SNAT rule.\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.2.2 \\\n    external_ip=30.0.0.2 -- add logical_router R2 nat @nat\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2:80)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http])\nOVS_START_L7([bar1], [http])\n\ncheck ovs-appctl dpctl/flush-conntrack\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ncheck ovs-appctl dpctl/flush-conntrack\nOVS_WAIT_FOR_OUTPUT([\ndnl Test load-balancing that includes L4 ports in NAT.\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ncheck_est_flows () {\n    n=$(ovs-ofctl dump-flows br-int table=13 | grep \\\n\"priority=100,tcp,metadata=0x2,nw_dst=30.0.0.2\" | grep nat |\nsed -n 's/.*n_packets=\\([[0-9]]\\{1,\\}\\).*/\\1/p')\n\n    echo \"n_packets=$n\"\n    test ! -z $n\n    test \"$n\" != 0\n}\n\nOVS_WAIT_UNTIL([check_est_flows], [check established flows])\n\n\novn-nbctl set logical_router R2 options:lb_force_snat_ip=\"20.0.0.2\"\n\n# Destroy the load balancer and create again. ovn-controller will\n# clear the OF flows and re add again and clears the n_packets\n# for these flows.\novn-nbctl destroy load_balancer $uuid\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.2,192.168.2.2\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"30.0.0.2:8000\"'='\"192.168.1.2:80,192.168.2.2:80\"'\n\novn-nbctl list load_balancer\novn-sbctl dump-flows R2\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-flows br-int table=45 | \\\ngrep 'nat(src=20.0.0.2)'])\n\ncheck ovs-appctl dpctl/flush-conntrack\nexp_ct1=\"tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\"\nexp_ct2=\"tcp,orig=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\nct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\nct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\n\ntest \"x$ct1 = x$exp_ct1\" && test \"x$ct2 = x$exp_ct2\"\n], [0], [dnl\n])\n\nOVS_WAIT_UNTIL([check_est_flows], [check established flows])\n\novn-nbctl set logical_router R2 options:lb_force_snat_ip=router_ip\n\n# Destroy the load balancer and create again. ovn-controller will\n# clear the OF flows and re add again and clears the n_packets\n# for these flows.\novn-nbctl destroy load_balancer $uuid\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.2,192.168.2.2\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"30.0.0.2:8000\"'='\"192.168.1.2:80,192.168.2.2:80\"'\n\novn-nbctl list load_balancer\novn-sbctl dump-flows R2\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-flows br-int table=45 | \\\ngrep 'nat(src=20.0.0.2)'])\n\nrm -f wget*.log\n\ncheck ovs-appctl dpctl/flush-conntrack\ndnl Test load-balancing that includes L4 ports in NAT.\nexp_ct1=\"tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\"\nexp_ct2=\"tcp,orig=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\n\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\nct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\nct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ntest \"x$ct1 = x$exp_ct1\" && test \"x$ct2 = x$exp_ct2\"\n], [0], [dnl\n])\n\nOVS_WAIT_UNTIL([check_est_flows], [check established flows])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing in gateway router hairpin scenario])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-ext], [set Bridge br-ext fail-mode=standalone])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add R1\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add public\n\ncheck ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24\n\ncheck ovn-nbctl set logical_router R1 options:chassis=hv1\n\ncheck ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\n\ncheck ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \\\n    type=router options:router-port=rp-public \\\n    -- lsp-set-addresses public-rp router\n\ncheck ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext\n\ncheck ovn-nbctl lsp-add public public1 \\\n        -- lsp-set-addresses public1 unknown \\\n        -- lsp-set-type public1 localnet \\\n        -- lsp-set-options public1 network_name=phynet\n\nADD_NAMESPACES(server)\nADD_VETH(s1, server, br-ext, \"172.16.1.100/24\", \"1a:00:00:00:00:01\", \\\n         \"172.16.1.1\")\n\nOVS_WAIT_UNTIL([test \"$(ip netns exec server ip a | grep fe80 | grep tentative)\" = \"\"])\n\nADD_NAMESPACES(client)\nADD_VETH(c1, client, br-ext, \"172.16.1.110/24\", \"1a:00:00:00:00:02\", \\\n         \"172.16.1.1\")\n\nOVS_WAIT_UNTIL([test \"$(ip netns exec client ip a | grep fe80 | grep tentative)\" = \"\"])\n\n# Start webservers in 'server'.\nOVS_START_L7([server], [http])\n\n# Create a load balancer and associate to R1\ncheck ovn-nbctl lb-add lb1 172.16.1.150:80 172.16.1.100:80\ncheck ovn-nbctl lr-lb-add R1 lb1\n\ncheck ovn-nbctl --wait=hv sync\n\nfor i in $(seq 1 5); do\n    echo Request $i\n    NS_CHECK_EXEC([client], [wget 172.16.1.100 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\n# Now send the traffic from client to the VIP - 172.16.1.150\ncheck ovn-nbctl set logical_router R1 options:lb_force_snat_ip=router_ip\ncheck ovn-nbctl --wait=hv sync\n\nfor i in $(seq 1 5); do\n    echo Request $i\n    NS_CHECK_EXEC([client], [wget 172.16.1.150 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/Failed to acquire.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing in gateway router - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in fd20::/64 network. R1 has switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it. R2 has alice (fd72::/64) connected\n# to it.  R2 is a gateway router on which we add load-balancing rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd72::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 fd72::/64 fd20::2\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd72::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd72::1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd72::2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n\"fd12::1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:\\\"fd30::1\\\"=\\\"fd11::2,fd12::2\\\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"[[fd30::2]]:8000\"'='\"@<:@fd11::2@:>@:80,@<:@fd12::2@:>@:80\"'\n\novn-nbctl list load_balancer\n\n# Add SNAT rule to make sure that Load-balancing still works with a SNAT rule.\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=\\\"fd12::2\\\" \\\n    external_ip=\\\"fd30::2\\\" -- add logical_router R2 nat @nat\n\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd12::2\\]]:80)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http6])\nOVS_START_L7([bar1], [http6])\n\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget http://[[fd30::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::2) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, load-balancing])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and\n# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected\n# to it.  R3 has bob (172.16.1.0/24) connected to it. Note how both alice and\n# bob have the same subnet behind it.  We are trying to simulate external\n# network via those 2 switches. In real world the switch ports of these\n# switches will have addresses set as \"unknown\" to make them learning switches.\n# Or those switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.1.0/24 20.0.0.2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.2.0/24 20.0.0.3\n\n# Static routes.\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\novn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:lb_force_snat_ip=20.0.0.2\novn-nbctl set logical_router R3 options:lb_force_snat_ip=20.0.0.3\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.3/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"172.16.1.4/24\", \"f0:00:00:01:02:06\", \\\n         \"172.16.1.2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 172.16.1.4\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.2,192.168.2.2\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\novn-nbctl set logical_router R3 load_balancer=$uuid\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http])\nOVS_START_L7([bar1], [http])\n\ndnl Should work with the virtual IP address through NAT\nexp_ct1=\"tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\"\nexp_ct2=\"tcp,orig=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.3,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\n\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\nct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ndnl Force SNAT should have worked.\nct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ntest \"x$ct1 = x$exp_ct1\" && test \"x$ct2 = x$exp_ct2\"\n], [0], [dnl\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, load-balancing - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in fd20::/64 network. R1 has switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it. R2 has alice (fd72::/64) connected\n# to it.  R3 has bob (fd72::/64) connected to it. Note how both alice and\n# bob have the same subnet behind it.  We are trying to simulate external\n# network via those 2 switches. In real world the switch ports of these\n# switches will have addresses set as \"unknown\" to make them learning switches.\n# Or those switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd72::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 fd72::2/64\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 fd20::3/64\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd11::/64 fd20::2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd12::/64 fd20::3\n\n# Static routes.\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\novn-nbctl lr-route-add R3 fd11::/64 fd20::1\novn-nbctl lr-route-add R3 fd12::/64 fd20::1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:lb_force_snat_ip=fd20::2\novn-nbctl set logical_router R3 options:lb_force_snat_ip=fd20::3\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd72::3/64\", \"f0:00:00:01:02:04\", \\\n         \"fd72::1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd72::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n\"fd12::1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"fd72::4/64\", \"f0:00:00:01:02:06\", \\\n         \"fd72::2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 fd72::4\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl create load_balancer vips:\\\"fd30::1\\\"=\\\"fd11::2,fd12::2\\\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\novn-nbctl set logical_router R3 load_balancer=$uuid\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=fd12::2)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http6])\nOVS_START_L7([bar1], [http6])\n\ndnl Should work with the virtual IP address through NAT\nexp_ct1=\"tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\nexp_ct2=tcp,orig=(src=fd72::3,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::3,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\n\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\nct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ndnl Force SNAT should have worked.\nct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ntest \"x$ct1 = x$exp_ct1\" && test \"x$ct2 = x$exp_ct2\"\n], [0], [dnl\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, load-balancing - Dual Stack])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 and fd20::/64 networks. R1 has switches foo (192.168.1.0/24\n# and fd11::/64) and bar (192.168.2.0/24 and fd12::/64) connected to it. R2\n# has alice (172.16.1.0/24 and fd72::/64) connected to it.  R3 has bob\n# (172.16.1.0/24 and fd72::/64) connected to it. Note how both alice and\n# bob have the same subnets behind them.  We are trying to simulate external\n# network via those 2 switches. In real world the switch ports of these\n# switches will have addresses set as \"unknown\" to make them learning switches.\n# Or those switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24 fd72::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24 fd72::2/64\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24 fd20::3/64\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.1.0/24 20.0.0.2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.2.0/24 20.0.0.3\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd11::/64 fd20::2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd12::/64 fd20::3\n\n# Static routes.\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\novn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\novn-nbctl lr-route-add R3 fd11::/64 fd20::1\novn-nbctl lr-route-add R3 fd12::/64 fd20::1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:lb_force_snat_ip=\"20.0.0.2 fd20::2\"\novn-nbctl set logical_router R3 options:lb_force_snat_ip=\"20.0.0.3 fd20::3\"\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'foo16' in switch 'foo'.\nADD_NAMESPACES(foo16)\nADD_VETH(foo16, foo16, br-int, \"fd11::2/64\", \"f0:00:06:01:02:03\", \\\n         \"fd11::1\")\novn-nbctl lsp-add foo foo16 \\\n-- lsp-set-addresses foo16 \"f0:00:06:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.3/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.3\"\n\n# Logical port 'alice16' in switch 'alice'.\nADD_NAMESPACES(alice16)\nADD_VETH(alice16, alice16, br-int, \"fd72::3/64\", \"f0:00:06:01:02:04\", \\\n         \"fd72::1\")\novn-nbctl lsp-add alice alice16 \\\n-- lsp-set-addresses alice16 \"f0:00:06:01:02:04 fd72::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\n# Logical port 'bar16' in switch 'bar'.\nADD_NAMESPACES(bar16)\nADD_VETH(bar16, bar16, br-int, \"fd12::2/64\", \"f0:00:06:01:02:05\", \\\n\"fd12::1\")\novn-nbctl lsp-add bar bar16 \\\n-- lsp-set-addresses bar16 \"f0:00:06:01:02:05 fd12::2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"172.16.1.4/24\", \"f0:00:00:01:02:06\", \\\n         \"172.16.1.2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 172.16.1.4\"\n\n# Logical port 'bob16' in switch 'bob'.\nADD_NAMESPACES(bob16)\nADD_VETH(bob16, bob16, br-int, \"fd72::4/64\", \"f0:00:06:01:02:06\", \\\n         \"fd72::2\")\novn-nbctl lsp-add bob bob16 \\\n-- lsp-set-addresses bob16 \"f0:00:06:01:02:06 fd72::4\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.2,192.168.2.2\" \\\nvips:\\\"fd30::1\\\"=\\\"fd11::2,fd12::2\\\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\novn-nbctl set logical_router R3 load_balancer=$uuid\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2)'])\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=fd12::2)'])\n\n# Start webservers in 'foo1', 'foo16, 'bar1', and 'bar16'.\nOVS_START_L7([foo1], [http])\nOVS_START_L7([bar1], [http])\nOVS_START_L7([foo16], [http6])\nOVS_START_L7([bar16], [http6])\n\ndnl Should work with the virtual IP address through NAT\nexp_ct1=\"tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\"\nexp_ct2=\"tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\"\nexp_ct3=\"tcp,orig=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.3,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\nexp_ct4=\"tcp,orig=(src=fd72::3,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::3,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\n\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\n    NS_EXEC([alice16], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget${i}_6.log])\ndone\n\ndnl Each server should have at least one connection.\nct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\nct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\n\ndnl Force SNAT should have worked.\nct3=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\nct4=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ntest \"x$ct1 = x$exp_ct1\" && test \"x$ct2 = x$exp_ct2\" && test \"x$ct3 = x$exp_ct3\" && test \"x$ct4 = x$exp_ct4\"\n], [0], [dnl\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing in router with gateway router port])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),\n# and alice (172.16.1.0/24) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 LB rules are applied.\n#\n#    foo -- R1 -- bar\n#           |\n#    alice ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"192.168.1.3/24\", \"f0:00:00:01:02:06\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 192.168.1.3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:04\", \\\n         \"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 192.168.2.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 172.16.1.2\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:172.16.1.10=\"192.168.1.2,192.168.2.2\"`\novn-nbctl set logical_router R1 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"172.16.1.11:8000\"'='\"192.168.1.2:80,192.168.2.2:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2:80)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http])\nOVS_START_L7([bar1], [http])\n\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 172.16.1.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.10) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=172.16.1.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=172.16.1.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 172.16.1.11:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.11) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=172.16.1.11,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=172.16.1.11,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing in router with gateway router port - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (fd01::/64), bar (fd02::/64),\n# and alice (fd72::/64) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 LB rules are applied.\n#\n#    foo -- R1 -- bar\n#           |\n#    alice ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd02::1/64\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd72::1/64 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd01::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd01::1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd01::2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"fd01::3/64\", \"f0:00:00:01:02:06\", \\\n         \"fd01::1\")\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 fd01::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd02::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd02::1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 fd02::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd72::2/64\", \"f0:00:00:01:02:05\", \\\n         \"fd72::1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 fd72::2\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:\\\"fd72::10\\\"=\\\"fd01::2,fd02::2\\\"`\novn-nbctl set logical_router R1 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"[[fd72::11]]:8000\"'='\"@<:@fd01::2@:>@:80,@<:@fd02::2@:>@:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd02::2\\]]:80)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http6])\nOVS_START_L7([bar1], [http6])\n\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget http://[[fd72::10]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd72::10) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd72::10,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd72::10,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget http://[[fd72::11]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd72::11) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd72::11,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd72::11,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DNAT and SNAT on distributed router - N/S])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),\n# and alice (172.16.1.0/24) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 NAT rules are applied.\n#\n#    foo -- R1 -- alice\n#           |\n#    bar ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"192.168.1.3/24\", \"f0:00:00:01:02:06\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 192.168.1.3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:04\", \\\n         \"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 192.168.2.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 172.16.1.2\"\n\n# Add external network\nADD_NAMESPACES(ext-net)\nAT_CHECK([ip link add alice-ext netns alice1 type veth peer name ext-veth netns ext-net])\nNS_CHECK_EXEC([ext-net], [ip link set dev ext-veth up], [0], [])\nNS_CHECK_EXEC([ext-net], [ip addr add 10.0.0.1/24 dev ext-veth], [0], [])\nNS_CHECK_EXEC([ext-net], [ip route add default via 10.0.0.2], [0], [])\n\nNS_CHECK_EXEC([alice1], [ip link set dev alice-ext up], [0], [])\nNS_CHECK_EXEC([alice1], [ip addr add 10.0.0.2/24 dev alice-ext], [0], [])\nNS_CHECK_EXEC([alice1], [sysctl -w net.ipv4.conf.all.forwarding=1],[0], [dnl\nnet.ipv4.conf.all.forwarding = 1\n])\n\n# Add DNAT rules\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.1.2 foo1 00:00:02:02:03:04])\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.4 192.168.1.3 foo2 00:00:02:02:03:05])\n\n# Add a SNAT rule\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.0.0/16])\n\n# Add default route to ext-net\nAT_CHECK([ovn-nbctl lr-route-add R1 10.0.0.0/24 172.16.1.2])\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])\n\n# North-South DNAT: 'alice1' pings 'foo1' using 172.16.1.3.\nNS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that DNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'foo2' pings 'alice1'. But 'alice1' receives traffic\n# from 172.16.1.4\nNS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.3,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic\n# from 172.16.1.1\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# Try to ping external network\nNS_CHECK_EXEC([ext-net], [tcpdump -l -n -c 3 -i ext-veth dst 172.16.1.3 and icmp > ext-net.pcap 2>tcpdump_err &])\nOVS_WAIT_UNTIL([grep \"listening\" tcpdump_err])\nAT_CHECK([ovn-nbctl lr-nat-del R1 snat])\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_WAIT_UNTIL([\n    total_pkts=$(cat ext-net.pcap | wc -l)\n    test \"${total_pkts}\" = \"3\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DNAT and SNAT on distributed router - N/S - IPv6])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (fd11::/64), bar (fd12::/64),\n# and alice (fd20::/64) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 NAT rules are applied.\n#\n#    foo -- R1 -- alice\n#           |\n#    bar ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd20::1/64 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"fd11::3/64\", \"f0:00:00:01:02:06\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo2 ip a | grep fd11::3 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 fd11::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 fd12::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd20::2/64\", \"f0:00:00:01:02:05\", \\\n         \"fd20::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd20::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 fd20::2\"\n\novn-nbctl --wait=hv sync\n\n# Add DNAT rules\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::3 fd11::2 foo1 00:00:02:02:03:04])\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::4 fd11::3 foo2 00:00:02:02:03:05])\n\n# Add a SNAT rule\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd11::/64])\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd12::/64])\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd20::1)'])\n\n# North-South DNAT: 'alice1' pings 'foo1' using fd20::3\nNS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd20::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that DNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd20::2,dst=fd20::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# South-North SNAT: 'foo2' pings 'alice1'. But 'alice1' receives traffic\n# from fd20::4\nNS_CHECK_EXEC([foo2], [ping6 -q -c 3 -i 0.3 -w 2 fd20::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\novs-appctl dpctl/dump-conntrack | grep icmpv6\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd11::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd11::3,dst=fd20::2,id=<cleared>,type=128,code=0),reply=(src=fd20::2,dst=fd20::4,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic\n# from fd20::1\nNS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd20::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd20::2,id=<cleared>,type=128,code=0),reply=(src=fd20::2,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DNAT and SNAT on distributed router - E/W])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),\n# and alice (172.16.1.0/24) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 NAT rules are applied.\n#\n#    foo -- R1 -- alice\n#           |\n#    bar ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"192.168.1.3/24\", \"f0:00:00:01:02:06\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 192.168.1.3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:04\", \\\n         \"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 192.168.2.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 172.16.1.2\"\n\n# Add DNAT rules\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.1.2 foo1 00:00:02:02:03:04])\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.4 192.168.2.2 bar1 00:00:02:02:03:05])\n\n# Add a SNAT rule\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.0.0/16])\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])\n\necho \"------ hv dump ------\"\novs-ofctl show br-int\novs-ofctl dump-flows br-int\necho \"---------------------\"\n\n# East-West No NAT: 'foo1' pings 'bar1' using 192.168.2.2.\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that the connection is not tracked.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# East-West No NAT: 'foo2' pings 'bar1' using 192.168.2.2.\nNS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that the connection is not tracked.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# East-West No NAT: 'bar1' pings 'foo2' using 192.168.1.3.\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 192.168.1.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that the connection is not tracked.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# East-West NAT: 'foo1' pings 'bar1' using 172.16.1.4.\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.  First SNAT of 'foo1' address happens.\n# Then DNAT of 'bar1' address happens (listed first below).\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(172.16.1.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.3,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# East-West NAT: 'foo2' pings 'bar1' using 172.16.1.4.\nNS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.  First SNAT of 'foo2' address happens.\n# Then DNAT of 'bar1' address happens (listed first below).\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(172.16.1.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.1,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=192.168.1.3,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DNAT and SNAT on distributed router - E/W - IPv6])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (fd11::/64), bar (fd12::/64),\n# and alice (fd20::/64) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 NAT rules are applied.\n#\n#    foo -- R1 -- alice\n#           |\n#    bar ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd20::1/64 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"fd11::3/64\", \"f0:00:00:01:02:06\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo2 ip a | grep fd11::3 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 fd11::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 fd12::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd20::2/64\", \"f0:00:00:01:02:05\", \\\n         \"fd20::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd20::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 fd20::2\"\n\n# Add DNAT rules\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::3 fd11::2 foo1 00:00:02:02:03:04])\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::4 fd12::2 bar1 00:00:02:02:03:05])\n\n# Add a SNAT rule\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd11::/64])\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd12::/64])\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd20::1)'])\n\necho \"------ hv dump ------\"\novs-ofctl show br-int\novs-ofctl dump-flows br-int\necho \"---------------------\"\n\n# East-West No NAT: 'foo1' pings 'bar1' using fd12::2.\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# East-West No NAT: 'foo2' pings 'bar1' using fd12::2.\nNS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# East-West No NAT: 'bar1' pings 'foo2' using fd11::3.\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 fd11::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# East-West NAT: 'foo1' pings 'bar1' using fd20::4.\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd20::4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.  First SNAT of 'foo1' address happens.\n# Then DNAT of 'bar1' address happens (listed first below).\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd11::2,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd20::4,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>\nicmpv6,orig=(src=fd20::3,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd12::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# East-West NAT: 'foo2' pings 'bar1' using fd20::4.\nNS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 fd20::4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.  First SNAT of 'foo2' address happens.\n# Then DNAT of 'bar1' address happens (listed first below).\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd11::3,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd20::4,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>\nicmpv6,orig=(src=fd20::1,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd12::2,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([conntrack zone flush after port binding release])\n\nCHECK_CONNTRACK()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LS ls1 with two lports p1 and p2.\n# Stateful ACL is added to ls1.\n#\n#    foo -- R1 -- alice\n#           |\n#    bar ----\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl acl-add ls1 from-lport 1 1 allow-related\n\n# Logical port 'p1' in switch 'ls1'.\nADD_NAMESPACES(p1)\nADD_VETH(p1, p1, br-int, \"192.168.1.10/24\", \"00:00:00:00:00:10\")\novn-nbctl lsp-add ls1 p1 \\\n-- lsp-set-addresses p1 \"00:00:00:00:00:10 192.168.1.10\"\n\n# Logical port 'p2' in switch 'ls1'.\novn-nbctl lsp-add ls1 p2 \\\n-- lsp-set-addresses p2 \"00:00:00:00:00:20 192.168.1.20\"\n\novn-nbctl --wait=hv sync\n\nzone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep p1 | cut -d ' ' -f2)\n\n# ping from p1 to p2\nNS_CHECK_EXEC([p1], [ping -q -c 1 -w1 192.168.1.20 > /dev/null], [1])\n\n# check conntrack zone has icmp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(192.168.1.10) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.10,dst=192.168.1.20,id=<cleared>,type=8,code=0),reply=(src=192.168.1.20,dst=192.168.1.10,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# release port binding\ncheck ovs-vsctl clear interface ovs-p1 external_ids\n\n# check conntrack zone is flushed\ncheck ovs-appctl dpctl/dump-conntrack zone=$zone_id\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([2 LSs IGMP and MLD])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_KEYWORDS([ovnigmp IP-multicast])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two independent logical switches (sw1 and sw2).\n# sw1:\n#   - subnet 10.0.0.0/8\n#   - 2 ports (sw1-p1 - sw1-p2)\n# sw2:\n#   - subnet 20.0.0.0/8\n#   - 2 port (sw2-p1 - sw2-p2)\n#   - IGMP Querier from 20.0.0.254\novn-nbctl ls-add sw1\novn-nbctl ls-add sw2\n\nfor i in `seq 1 2`\ndo\n    ADD_NAMESPACES(sw1-p$i)\n# Only send 1 membership report as second one might be received after flushing IGMP groups\n# causing test to fail\n    NS_CHECK_EXEC([sw1-p$i], [sysctl -w net.ipv4.igmp_qrv=1], [0], [dnl\nnet.ipv4.igmp_qrv = 1\n])\n    ADD_VETH(sw1-p$i, sw1-p$i, br-int, \"10.0.0.$i/24\", \"00:00:00:00:01:0$i\", \\\n            \"10.0.0.254\")\n    ovn-nbctl lsp-add sw1 sw1-p$i \\\n        -- lsp-set-addresses sw1-p$i \"00:00:00:00:01:0$i 10.0.0.$i\"\ndone\n\nfor i in `seq 1 2`\ndo\n    ADD_NAMESPACES(sw2-p$i)\n    ADD_VETH(sw2-p$i, sw2-p$i, br-int, \"20.0.0.$i/24\", \"00:00:00:00:02:0$i\", \\\n            \"20.0.0.254\")\n    ovn-nbctl lsp-add sw2 sw2-p$i \\\n        -- lsp-set-addresses sw2-p$i \"00:00:00:00:02:0$i 20.0.0.$i\"\ndone\n\n# Enable IGMP snooping on sw1.\novn-nbctl set Logical_Switch sw1 other_config:mcast_querier=\"false\"\novn-nbctl set Logical_Switch sw1 other_config:mcast_snoop=\"true\"\n\n\ngroup_v4=\"239.0.1.68\"\n# Inject IGMP Join for v4 group on sw1-p1.\nNS_CHECK_EXEC([sw1-p1], [ip addr add dev sw1-p1 ${group_v4}/32 autojoin], [0])\n\n# Inject IGMP Join for v4 group on sw1-p2\nNS_CHECK_EXEC([sw1-p2], [ip addr add dev sw1-p2 ${group_v4}/32 autojoin], [0])\n\n# Check that the IGMP Group is learned.\nOVS_WAIT_UNTIL([\n    total_entries=`ovn-sbctl find IGMP_Group address=\"${group_v4}\" | grep _uuid -c`\n    ports=`ovn-sbctl find IGMP_Group address=\"${group_v4}\" | grep ports | cut -f 2 -d \":\" | wc -w`\n    test \"${total_entries}\" = \"1\"\n    test \"${ports}\" = \"2\"\n])\n\n# Inject IGMP Leave for v4 group on sw1-p2.\nNS_CHECK_EXEC([sw1-p2], [ip addr del dev sw1-p2 ${group_v4}/32], [0])\n\n# Check that only one port is left in the group.\nOVS_WAIT_UNTIL([\n    total_entries=`ovn-sbctl find IGMP_Group address=\"${group_v4}\" | grep _uuid -c`\n    ports=`ovn-sbctl find IGMP_Group address=\"${group_v4}\" | grep ports | cut -f 2 -d \":\" | wc -w`\n    test \"${total_entries}\" = \"1\"\n    test \"${ports}\" = \"1\"\n])\n\n# Flush IGMP groups.\novn-sbctl ip-multicast-flush sw1\novn-nbctl --wait=hv -t 3 sync\nOVS_WAIT_UNTIL([\n    total_entries=`ovn-sbctl find IGMP_Group address=\"${group_v4}\" | grep _uuid -c`\n    test \"${total_entries}\" = \"0\"\n])\n\ngroup_v6=\"ff0a:dead:beef::1\"\ngroup_v6_str=\"ff0a\\:dead\\:beef\\:\\:1\"\n# Inject MLD Join for ff0a:dead:beef::1 on sw1-p1\nNS_CHECK_EXEC([sw1-p1], [ip addr add dev sw1-p1 ${group_v6}/64 autojoin], [0])\n\n# Inject MLD Join for ff0a:dead:beef::1 on sw1-p2\nNS_CHECK_EXEC([sw1-p2], [ip addr add dev sw1-p2 ${group_v6}/64 autojoin], [0])\n\n# Check that the MLD Group is learned.\nOVS_WAIT_UNTIL([\n    total_entries=`ovn-sbctl find IGMP_Group address=\"${group_v6_str}\" | grep _uuid -c`\n    ports=`ovn-sbctl find IGMP_Group address=\"${group_v6_str}\" | grep ports | cut -f 2 -d \":\" | wc -w`\n    test \"${total_entries}\" = \"1\"\n    test \"${ports}\" = \"2\"\n])\n\n# Inject IGMP Leave for v6 group on sw1-p2.\nNS_CHECK_EXEC([sw1-p2], [ip addr del dev sw1-p2 ${group_v6}/64 autojoin], [0])\n\n# Check that only one port is left in the group.\nOVS_WAIT_UNTIL([\n    total_entries=`ovn-sbctl find IGMP_Group address=\"${group_v6_str}\" | grep _uuid -c`\n    ports=`ovn-sbctl find IGMP_Group address=\"${group_v6_str}\" | grep ports | cut -f 2 -d \":\" | wc -w`\n    test \"${total_entries}\" = \"1\"\n    test \"${ports}\" = \"1\"\n])\n\n# Enable IGMP & MLD snooping and querier on sw2 and set query interval to\n# minimum.\novn-nbctl set Logical_Switch sw2 \\\n    other_config:mcast_snoop=\"true\" \\\n    other_config:mcast_querier=\"true\" \\\n    other_config:mcast_query_interval=1 \\\n    other_config:mcast_eth_src=\"00:00:00:00:02:fe\" \\\n    other_config:mcast_ip4_src=\"20.0.0.254\" \\\n    other_config:mcast_ip6_src=\"2000::fe\"\n\n# Check that v4 queries are generated.\nNS_CHECK_EXEC([sw2-p1], [tcpdump -n -c 2 -i sw2-p1 igmp > sw2-p1-v4.pcap &])\n\nOVS_WAIT_UNTIL([\n    total_queries=`grep \"igmp query\" -c sw2-p1-v4.pcap`\n    test \"${total_queries}\" = \"2\"\n])\n\n# Check that v6 queries are generated (ip6 next header == Hop-By-Hop and\n# icmpv6 type == MLD Query).\nNS_CHECK_EXEC([sw2-p1], [tcpdump -n -c 2 -i sw2-p1 ip6[[6]]==0 and ip6[[48]]==0x82 > sw2-p1-v6.pcap &])\n\nOVS_WAIT_UNTIL([\n    total_queries=`grep \"multicast listener query\" -c sw2-p1-v6.pcap`\n    test \"${total_queries}\" = \"2\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Load balancer health checks - IPv4])\nAT_KEYWORDS([lb])\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\n\novn-nbctl lsp-add sw0 sw0-p1\novn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:03\"\novn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:03\"\n\novn-nbctl lsp-add sw0 sw0-p2\novn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:04 10.0.0.4\"\novn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:04 10.0.0.4\"\n\n# Create port group and ACLs for sw0 ports.\novn-nbctl pg-add pg0_drop sw0-p1 sw0-p2\novn-nbctl acl-add pg0_drop from-lport 1001 \"inport == @pg0_drop && ip\" drop\novn-nbctl acl-add pg0_drop to-lport 1001 \"outport == @pg0_drop && ip\" drop\n\novn-nbctl pg-add pg0 sw0-p1 sw0-p2\novn-nbctl acl-add pg0 from-lport 1002 \"inport == @pg0 && ip4\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && icmp4\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80\" allow-related\n\n# Create the second logical switch with one port\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-p1\novn-nbctl lsp-set-addresses sw1-p1 \"40:54:00:00:00:03 20.0.0.3\"\novn-nbctl lsp-set-port-security sw1-p1 \"40:54:00:00:00:03 20.0.0.3\"\n\n# Create port group and ACLs for sw1 ports.\novn-nbctl pg-add pg1_drop sw1-p1\novn-nbctl acl-add pg1_drop from-lport 1001 \"inport == @pg1_drop && ip\" drop\novn-nbctl acl-add pg1_drop to-lport 1001 \"outport == @pg1_drop && ip\" drop\n\novn-nbctl pg-add pg1 sw1-p1\novn-nbctl acl-add pg1 from-lport 1002 \"inport == @pg1 && ip4\" allow-related\novn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && icmp4\" allow-related\novn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80\" allow-related\novn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80\" allow-related\n\n# Create a logical router and attach both logical switches\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\novn-nbctl lsp-add sw0 sw0-lr0\novn-nbctl lsp-set-type sw0-lr0 router\novn-nbctl lsp-set-addresses sw0-lr0 router\novn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\novn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\novn-nbctl lsp-add sw1 sw1-lr0\novn-nbctl lsp-set-type sw1-lr0 router\novn-nbctl lsp-set-addresses sw1-lr0 router\novn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\novn-nbctl --reject lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80\n\novn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2\novn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2\n\novn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer . \\\nhealth_check @hc\n\novn-nbctl --wait=sb ls-lb-add sw0 lb1\novn-nbctl --wait=sb ls-lb-add sw1 lb1\novn-nbctl --wait=sb lr-lb-add lr0 lb1\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw1-p1)\nADD_VETH(sw1-p1, sw1-p1, br-int, \"20.0.0.3/24\", \"40:54:00:00:00:03\", \\\n         \"20.0.0.1\")\n\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\n# Wait until all the services are set to offline.\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor | sed '/^$/d' | grep offline | wc -l`])\n\n# Start webservers in 'sw0-p1' and 'sw1-p1'.\nOVS_START_L7([sw0-p1], [http])\nsw0_p1_pid_file=`cat l7_pid_file`\nOVS_START_L7([sw1-p1], [http])\n\n# Wait until the services are set to online.\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor | sed '/^$/d' | grep online | wc -l`])\n\nOVS_WAIT_UNTIL(\n    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep \"ip4.dst == 10.0.0.10\" > lflows.txt\n     test 1 = `cat lflows.txt | grep \"ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80)\" | wc -l`]\n)\n# From sw0-p2 send traffic to vip - 10.0.0.10\n#dnl Each server should have at least one connection.\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 10`; do\n        NS_EXEC([sw0-p2], [wget 10.0.0.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\n    done\n\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.10) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=20.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Stop webserver in sw0-p1\nkill `cat $sw0_p1_pid_file`\n\n# Wait until service_monitor for sw0-p1 is set to offline\nOVS_WAIT_UNTIL([test 1 = `ovn-sbctl --bare --columns status find \\\nservice_monitor logical_port=sw0-p1 | sed '/^$/d' | grep offline | wc -l`])\n\nOVS_WAIT_UNTIL(\n    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep \"ip4.dst == 10.0.0.10\" > lflows.txt\n     test 1 = `cat lflows.txt | grep \"ct_lb_mark(backends=20.0.0.3:80)\" | wc -l`]\n)\n\novs-appctl dpctl/flush-conntrack\n# From sw0-p2 send traffic to vip - 10.0.0.10\nfor i in `seq 1 20`; do\n    echo Request $i\n    NS_CHECK_EXEC([sw0-p2], [wget 10.0.0.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.10) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=20.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# trigger port binding release and check if status changed to offline\novs-vsctl remove interface ovs-sw1-p1 external_ids iface-id\nwait_row_count Service_Monitor 2\nwait_row_count Service_Monitor 2 status=offline\n\novs-vsctl set interface ovs-sw1-p1 external_ids:iface-id=sw1-p1\nwait_row_count Service_Monitor 2\nwait_row_count Service_Monitor 1 status=online\n\n# Create udp load balancer.\novn-nbctl lb-add lb2 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80 udp\nlb_udp=`ovn-nbctl lb-list | grep udp | awk '{print $1}'`\n\necho \"lb udp uuid = $lb_udp\"\n\novn-nbctl list load_balancer\n\novn-nbctl --wait=sb set load_balancer $lb_udp ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2\novn-nbctl --wait=sb set load_balancer $lb_udp ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2\n\novn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer $lb_udp \\\nhealth_check @hc\n\novn-nbctl --wait=sb ls-lb-add sw0 lb2\novn-nbctl --wait=sb ls-lb-add sw1 lb2\novn-nbctl --wait=sb lr-lb-add lr0 lb2\n\nsleep 10\n\novn-nbctl list load_balancer\necho \"*******Next is health check*******\"\novn-nbctl list Load_Balancer_Health_Check\necho \"********************\"\novn-sbctl list service_monitor\n\n# Wait until udp service_monitor are set to offline\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor protocol=udp | sed '/^$/d' | grep offline | wc -l`])\n\n# Stop webserver in sw1-p1\npid_file=$(cat l7_pid_file)\nNS_CHECK_EXEC([sw1-p1], [kill $(cat $pid_file)])\n\nNS_CHECK_EXEC([sw0-p2], [tcpdump -c 1 -neei sw0-p2 ip[[33:1]]=0x14 > rst.pcap &])\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor protocol=tcp | sed '/^$/d' | grep offline | wc -l`])\nNS_CHECK_EXEC([sw0-p2], [wget 10.0.0.10 -v -o wget$i.log],[4])\n\nOVS_WAIT_UNTIL([\n    n_reset=$(cat rst.pcap | wc -l)\n    test \"${n_reset}\" = \"1\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/Service monitor not found.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Load balancer health checks - IPv6])\nAT_KEYWORDS([lb])\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:03 2001::3\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:03 2001::3\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:04 2001::4\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:04 2001::4\"\n\n# Create port group and ACLs for sw0 ports.\ncheck ovn-nbctl pg-add pg0_drop sw0-p1 sw0-p2\ncheck ovn-nbctl acl-add pg0_drop from-lport 1001 \"inport == @pg0_drop && ip\" drop\ncheck ovn-nbctl acl-add pg0_drop to-lport 1001 \"outport == @pg0_drop && ip\" drop\n\ncheck ovn-nbctl pg-add pg0 sw0-p1 sw0-p2\ncheck ovn-nbctl acl-add pg0 from-lport 1002 \"inport == @pg0 && ip6\" allow-related\ncheck ovn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip6 && ip6.src == ::/0 && icmp6\" allow-related\ncheck ovn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip6 && ip6.src == ::/0 && tcp && tcp.dst == 80\" allow-related\ncheck ovn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip6 && ip6.src == ::/0 && udp && udp.dst == 80\" allow-related\n\n# Create the second logical switch with one port\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-p1\ncheck ovn-nbctl lsp-set-addresses sw1-p1 \"40:54:00:00:00:03 2002::3\"\ncheck ovn-nbctl lsp-set-port-security sw1-p1 \"40:54:00:00:00:03 2002::3\"\n\n# Create port group and ACLs for sw1 ports.\ncheck ovn-nbctl pg-add pg1_drop sw1-p1\ncheck ovn-nbctl acl-add pg1_drop from-lport 1001 \"inport == @pg1_drop && ip\" drop\ncheck ovn-nbctl acl-add pg1_drop to-lport 1001 \"outport == @pg1_drop && ip\" drop\n\ncheck ovn-nbctl pg-add pg1 sw1-p1\ncheck ovn-nbctl acl-add pg1 from-lport 1002 \"inport == @pg1 && ip6\" allow-related\ncheck ovn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip6 && ip6.src == ::/0 && icmp6\" allow-related\ncheck ovn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip6 && ip6.src == ::/0 && tcp && tcp.dst == 80\" allow-related\ncheck ovn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip6 && ip6.src == ::/0 && udp && udp.dst == 80\" allow-related\n\n# Create a logical router and attach both logical switches\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 2001::1/64\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 router\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 2002::1/64\ncheck ovn-nbctl lsp-add sw1 sw1-lr0\ncheck ovn-nbctl lsp-set-type sw1-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr0 router\ncheck ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\ncheck ovn-nbctl --reject lb-add lb1 [[2001::a]]:80 [[2001::3]]:80,[[2002::3]]:80\n\ncheck ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:\\\"[[2001::3]]\\\"=\\\"sw0-p1:[[2001::2]]\\\"\ncheck ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:\\\"[[2002::3]]\\\"=\\\"sw1-p1:[[2002::2]]\\\"\n\novn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"\\[\\[2001\\:\\:a\\]\\]\\:80\" -- add Load_Balancer . \\\nhealth_check @hc\n\ncheck ovn-nbctl ls-lb-add sw0 lb1\ncheck ovn-nbctl ls-lb-add sw1 lb1\ncheck ovn-nbctl lr-lb-add lr0 lb1\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"2001::3/64\", \"50:54:00:00:00:03\", \\\n         \"2001::1\")\n\nADD_NAMESPACES(sw1-p1)\nADD_VETH(sw1-p1, sw1-p1, br-int, \"2002::3/64\", \"40:54:00:00:00:03\", \\\n         \"2002::1\")\n\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"2001::4/64\", \"50:54:00:00:00:04\", \\\n         \"2001::1\")\n\n# Wait until all the services are set to offline.\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor | sed '/^$/d' | grep offline | wc -l`])\n\n# Start webservers in 'sw0-p1' and 'sw1-p1'.\nOVS_START_L7([sw0-p1], [http6])\nsw0_p1_pid_file=$(cat l7_pid_file)\nOVS_START_L7([sw1-p1], [http6])\n\n# Wait until the services are set to online.\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor | sed '/^$/d' | grep online | wc -l`])\n\nOVS_WAIT_UNTIL(\n    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep \"ip6.dst == 2001::a\" > lflows.txt\n     test 1 = `cat lflows.txt | grep \"ct_lb_mark(backends=[\\[2001::3\\]]:80,[\\[2002::3\\]]:80)\" | wc -l`]\n)\n\n# From sw0-p2 send traffic to vip - 2001::a\nfor i in `seq 1 20`; do\n    echo Request $i\n    ovn-sbctl list service_monitor\n    NS_CHECK_EXEC([sw0-p2], [wget http://[[2001::a]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(2001::a) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=2001::4,dst=2001::a,sport=<cleared>,dport=<cleared>),reply=(src=2001::3,dst=2001::4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=2001::4,dst=2001::a,sport=<cleared>,dport=<cleared>),reply=(src=2002::3,dst=2001::4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Stop webserver in sw0-p1\nkill `cat $sw0_p1_pid_file`\n\n# Wait until service_monitor for sw0-p1 is set to offline\nOVS_WAIT_UNTIL([test 1 = `ovn-sbctl --bare --columns status find \\\nservice_monitor logical_port=sw0-p1 | sed '/^$/d' | grep offline | wc -l`])\n\nOVS_WAIT_UNTIL(\n    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep \"ip6.dst == 2001::a\" > lflows.txt\n     test 1 = `cat lflows.txt | grep \"ct_lb_mark(backends=[\\[2002::3\\]]:80)\" | wc -l`]\n)\n\novs-appctl dpctl/flush-conntrack\n# From sw0-p2 send traffic to vip - 2001::a\nfor i in `seq 1 20`; do\n    echo Request $i\n    NS_CHECK_EXEC([sw0-p2], [wget http://[[2001::a]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(2001::a) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=2001::4,dst=2001::a,sport=<cleared>,dport=<cleared>),reply=(src=2002::3,dst=2001::4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# trigger port binding release and check if status changed to offline\novs-vsctl remove interface ovs-sw1-p1 external_ids iface-id\nwait_row_count Service_Monitor 2\nwait_row_count Service_Monitor 2 status=offline\n\novs-vsctl set interface ovs-sw1-p1 external_ids:iface-id=sw1-p1\nwait_row_count Service_Monitor 2\nwait_row_count Service_Monitor 1 status=online\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/Service monitor not found.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Load Balancer LS hairpin IPv4])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One logical switch with IPv4 load balancers that hairpin the traffic.\novn-nbctl ls-add sw\novn-nbctl lsp-add sw lsp -- lsp-set-addresses lsp 00:00:00:00:00:01\novn-nbctl lb-add lb-ipv4-tcp     88.88.88.88:8080 42.42.42.1:4041 tcp\novn-nbctl lb-add lb-ipv4-tcp-dup 88.88.88.89:8080 42.42.42.1:4041 tcp\novn-nbctl lb-add lb-ipv4-udp     88.88.88.88:4040 42.42.42.1:2021 udp\novn-nbctl lb-add lb-ipv4-udp-dup 88.88.88.89:4040 42.42.42.1:2021 udp\novn-nbctl lb-add lb-ipv4 88.88.88.90 42.42.42.1\novn-nbctl ls-lb-add sw lb-ipv4-tcp\novn-nbctl ls-lb-add sw lb-ipv4-tcp-dup\novn-nbctl ls-lb-add sw lb-ipv4-udp\novn-nbctl ls-lb-add sw lb-ipv4-udp-dup\novn-nbctl ls-lb-add sw lb-ipv4\n\novn-nbctl lr-add rtr\novn-nbctl lrp-add rtr rtr-sw 00:00:00:00:01:00 42.42.42.254/24\novn-nbctl lsp-add sw sw-rtr                       \\\n    -- lsp-set-type sw-rtr router                 \\\n    -- lsp-set-addresses sw-rtr 00:00:00:00:01:00 \\\n    -- lsp-set-options sw-rtr router-port=rtr-sw\n\nADD_NAMESPACES(lsp)\nADD_VETH(lsp, lsp, br-int, \"42.42.42.1/24\", \"00:00:00:00:00:01\", \\\n         \"42.42.42.254\")\n\novn-nbctl --wait=hv -t 3 sync\n\n# Start IPv4 TCP server on lsp.\nNETNS_DAEMONIZE([lsp], [nc -l -k 42.42.42.1 4041], [lsp0.pid])\n\n# Check that IPv4 TCP hairpin connection succeeds on both VIPs.\nNS_CHECK_EXEC([lsp], [nc 88.88.88.88 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 88.88.88.89 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 88.88.88.90 4041 -z], [0], [ignore], [ignore])\n\n# Capture IPv4 UDP hairpinned packets.\nfilter=\"dst 42.42.42.1 and dst port 2021 and udp\"\nNS_CHECK_EXEC([lsp], [tcpdump -l -nn -c 3 -i lsp ${filter} > lsp.pcap 2>tcpdump_err &])\nOVS_WAIT_UNTIL([grep \"listening\" tcpdump_err])\n\n# Generate IPv4 UDP hairpin traffic.\nNS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.88 4040], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.89 4040], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.90 2021], [ignore], [ignore], [ignore])\n\n# Check hairpin traffic.\nOVS_WAIT_UNTIL([\n    total_pkts=$(cat lsp.pcap | wc -l)\n    test \"${total_pkts}\" = \"3\"\n])\n\novn-nbctl pg-add pg0 lsp\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1004 \"ip4 && ip4.dst == 10.0.0.2\" drop\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"ip4 && tcp\" allow-related\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"ip4 && udp\" allow\novn-nbctl --wait=hv sync\n\n## Check that IPv4 TCP hairpin connection succeeds on both VIPs.\nNS_CHECK_EXEC([lsp], [nc 88.88.88.88 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 88.88.88.89 8080 -z], [0], [ignore], [ignore])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Load Balancer LS hairpin IPv6])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One logical switch with IPv6 load balancers that hairpin the traffic.\novn-nbctl ls-add sw\novn-nbctl lsp-add sw lsp -- lsp-set-addresses lsp 00:00:00:00:00:01\novn-nbctl lb-add lb-ipv6-tcp     [[8800::0088]]:8080 [[4200::1]]:4041 tcp\novn-nbctl lb-add lb-ipv6-tcp-dup [[8800::0089]]:8080 [[4200::1]]:4041 tcp\novn-nbctl lb-add lb-ipv6-udp     [[8800::0088]]:4040 [[4200::1]]:2021 udp\novn-nbctl lb-add lb-ipv6-udp-dup [[8800::0089]]:4040 [[4200::1]]:2021 udp\novn-nbctl lb-add lb-ipv6 8800::0090 4200::1\novn-nbctl ls-lb-add sw lb-ipv6-tcp\novn-nbctl ls-lb-add sw lb-ipv6-tcp-dup\novn-nbctl ls-lb-add sw lb-ipv6-udp\novn-nbctl ls-lb-add sw lb-ipv6-udp-dup\novn-nbctl ls-lb-add sw lb-ipv6\n\novn-nbctl lr-add rtr\novn-nbctl lrp-add rtr rtr-sw 00:00:00:00:01:00 4200::00ff/64\novn-nbctl lsp-add sw sw-rtr                       \\\n    -- lsp-set-type sw-rtr router                 \\\n    -- lsp-set-addresses sw-rtr 00:00:00:00:01:00 \\\n    -- lsp-set-options sw-rtr router-port=rtr-sw\n\nADD_NAMESPACES(lsp)\nADD_VETH(lsp, lsp, br-int, \"4200::1/64\", \"00:00:00:00:00:01\", \"4200::00ff\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec lsp ip a | grep 4200::1 | grep tentative)\" = \"\"])\novn-nbctl --wait=hv -t 3 sync\n\n# Start IPv6 TCP server on lsp.\nNETNS_DAEMONIZE([lsp], [nc -l -k 4200::1 4041], [lsp0.pid])\n\n# Check that IPv6 TCP hairpin connection succeeds on both VIPs.\nNS_CHECK_EXEC([lsp], [nc 8800::0088 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 8800::0089 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 8800::0090 4041 -z], [0], [ignore], [ignore])\n\n# Capture IPv6 UDP hairpinned packets.\nfilter=\"dst 4200::1 and dst port 2021 and udp\"\nNS_CHECK_EXEC([lsp], [tcpdump -l -nn -c 3 -i lsp $filter > lsp.pcap 2>tcpdump_err &])\nOVS_WAIT_UNTIL([grep \"listening\" tcpdump_err])\n\n# Generate IPv6 UDP hairpin traffic.\nNS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0088 4040], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0089 4040], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0090 2021], [ignore], [ignore], [ignore])\n\n# Check hairpin traffic.\nOVS_WAIT_UNTIL([\n    total_pkts=$(cat lsp.pcap | wc -l)\n    test \"${total_pkts}\" = \"3\"\n])\n\novn-nbctl pg-add pg0 lsp\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"ip6 && tcp\" allow-related\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"ip6 && udp\" allow\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1000 \"ip6\" drop\novn-nbctl --wait=hv sync\n\n# Check that IPv6 TCP hairpin connection succeeds on both VIPs.\nNS_CHECK_EXEC([lsp], [nc 8800::0088 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 8800::0089 8080 -z], [0], [ignore], [ignore])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL reject])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\n\novn-nbctl lsp-add sw0 sw0-p1-rej\novn-nbctl lsp-set-addresses sw0-p1-rej \"50:54:00:00:00:03 10.0.0.3 aef0::3\"\novn-nbctl lsp-set-port-security sw0-p1-rej \"50:54:00:00:00:03 10.0.0.3 aef0::3\"\n\novn-nbctl lsp-add sw0 sw0-p2-rej\novn-nbctl lsp-set-addresses sw0-p2-rej \"50:54:00:00:00:04 10.0.0.4 aef0::4\"\novn-nbctl lsp-set-port-security sw0-p2-rej \"50:54:00:00:00:04 10.0.0.4 aef0::4\"\n\n# Create port group and ACLs for sw0 ports.\novn-nbctl pg-add pg0_drop sw0-p1-rej sw0-p2-rej\novn-nbctl acl-add pg0_drop from-lport 1001 \"inport == @pg0_drop && ip\" drop\novn-nbctl acl-add pg0_drop to-lport 1001 \"outport == @pg0_drop && ip\" drop\n\novn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej\novn-nbctl acl-add pg0 from-lport 1002 \"inport == @pg0 && ip\" allow-related\novn-nbctl --log acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && tcp && tcp.dst == 80\" reject\novn-nbctl --log acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && udp && udp.dst == 90\" reject\n\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 82\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 82\" allow-related\novn-nbctl --log acl-add pg0 to-lport 1004 \"inport == @pg0 && ip && tcp && tcp.dst == 84\" reject\novn-nbctl --log acl-add pg0 to-lport 1004 \"inport == @pg0 && ip && udp && udp.dst == 94\" reject\n\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-p1-rej\novn-nbctl lsp-set-addresses sw1-p1-rej \"40:54:00:00:00:03 20.0.0.3\"\novn-nbctl lsp-set-port-security sw1-p1-rej \"40:54:00:00:00:03 20.0.0.3\"\n\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\novn-nbctl lsp-add sw0 sw0-lr0\novn-nbctl lsp-set-type sw0-lr0 router\novn-nbctl lsp-set-addresses sw0-lr0 router\novn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\novn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\novn-nbctl lsp-add sw1 sw1-lr0\novn-nbctl lsp-set-type sw1-lr0 router\novn-nbctl lsp-set-addresses sw1-lr0 router\novn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1-rej)\nADD_VETH(sw0-p1-rej, sw0-p1-rej, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw0-p2-rej)\nADD_VETH(sw0-p2-rej, sw0-p2-rej, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\nNS_CHECK_EXEC([sw0-p1-rej], [ip a a aef0::3/64 dev sw0-p1-rej], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [ip a a aef0::4/64 dev sw0-p2-rej], [0])\n\nADD_NAMESPACES(sw1-p1-rej)\nADD_VETH(sw1-p1-rej, sw1-p1-rej, br-int, \"20.0.0.3/24\", \"40:54:00:00:00:03\", \\\n         \"20.0.0.1\")\n\n# Capture packets in sw0-p1-rej.\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej tcp > sw0-p1-rej-ip4.pcap 2> err &], [0])\n\n#Wait for tcpdump to get started before generating first packets\nOVS_WAIT_UNTIL([test 1 = $(cat err | grep -c listening)])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'\n])\n\n# Now send traffic to port 84\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'\n])\n\nOVS_WAIT_UNTIL([\n    n_pkt=$(ovs-ofctl dump-flows br-int table=46 | grep -v n_packets=0 | \\\ngrep controller | grep tp_dst=84 -c)\n    test $n_pkt -eq 1\n])\n\nOVS_WAIT_UNTIL([\n    total=`cat sw0-p1-rej-ip4.pcap |  grep \"10\\.0\\.0\\.3\" | wc -l`\n    echo \"total = $total\"\n    test \"${total}\" = \"4\"\n])\n\nkill $(pidof tcpdump)\n\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej tcp port 80 > sw0-p2-rej-ip6.pcap 2> err &], [0])\n\n#Wait for tcpdump to get started before generating first packets\nOVS_WAIT_UNTIL([test 1 = $(cat err | grep -c listening)])\n\nOVS_WAIT_UNTIL([test \"$(ip netns exec sw0-p1-rej ip a | grep aef0::3 | grep tentative)\" = \"\"])\nOVS_WAIT_UNTIL([test \"$(ip netns exec sw0-p2-rej ip a | grep aef0::4 | grep tentative)\" = \"\"])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'\n])\n\n\nOVS_WAIT_UNTIL([\n    total=`cat sw0-p2-rej-ip6.pcap |  grep \"aef0::3\\.80\" |wc -l`\n    echo \"total = $total\"\n    test \"${total}\" = \"2\"\n])\novn-nbctl acl-add sw1 from-lport 1004 \"ip\" allow-related\novn-nbctl acl-add sw1 to-lport 1004 \"ip\" allow-related\novn-nbctl --log acl-add pg0 to-lport 1004 \"outport == @pg0 && ip && tcp && tcp.dst == 84\" reject\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw1-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'\n])\n\nkill $(pidof tcpdump)\n\n\n# Now test for IPv4 UDP.\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej udp port 90 > sw0-p1-rej-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nprintf '.%.0s' {1..100} > foo\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej udp port 94 > sw0-p1-rej-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 94 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 94 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\nkill $(pidof tcpdump)\n\n# Now test for IPv6 UDP.\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej udp port 90 > sw0-p2-rej-ip6-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 90\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej udp port 94 > sw0-p2-rej-ip6-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 94 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 94\" | uniq | wc -l)\n    test $c -ge 1\n])\nkill $(pidof tcpdump)\n\n# Delete all the ACLs of pg0 and add the ACL with a generic match with reject action.\novn-nbctl pg-del pg0\novn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej\novn-nbctl --log acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && (tcp || udp)\" reject\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'\n])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'\n])\n\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nprintf '.%.0s' {1..100} > foo\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n# Now test for IPv6 UDP.\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 90\" | uniq | wc -l)\n    test $c -ge 1\n])\nkill $(pidof tcpdump)\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL after lb - reject])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\n\novn-nbctl lsp-add sw0 sw0-p1-rej\novn-nbctl lsp-set-addresses sw0-p1-rej \"50:54:00:00:00:03 10.0.0.3 aef0::3\"\novn-nbctl lsp-set-port-security sw0-p1-rej \"50:54:00:00:00:03 10.0.0.3 aef0::3\"\n\novn-nbctl lsp-add sw0 sw0-p2-rej\novn-nbctl lsp-set-addresses sw0-p2-rej \"50:54:00:00:00:04 10.0.0.4 aef0::4\"\novn-nbctl lsp-set-port-security sw0-p2-rej \"50:54:00:00:00:04 10.0.0.4 aef0::4\"\n\n# Create port group and ACLs for sw0 ports.\novn-nbctl pg-add pg0_drop sw0-p1-rej sw0-p2-rej\novn-nbctl --apply-after-lb acl-add pg0_drop from-lport 1001 \"inport == @pg0_drop && ip\" drop\novn-nbctl acl-add pg0_drop to-lport 1001 \"outport == @pg0_drop && ip\" drop\n\novn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"inport == @pg0 && ip\" allow-related\novn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && tcp && tcp.dst == 80\" reject\novn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && udp && udp.dst == 90\" reject\n\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 82\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 82\" allow-related\novn-nbctl --log acl-add pg0 to-lport 1004 \"inport == @pg0 && ip && tcp && tcp.dst == 84\" reject\novn-nbctl --log acl-add pg0 to-lport 1004 \"inport == @pg0 && ip && udp && udp.dst == 94\" reject\n\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-p1-rej\novn-nbctl lsp-set-addresses sw1-p1-rej \"40:54:00:00:00:03 20.0.0.3\"\novn-nbctl lsp-set-port-security sw1-p1-rej \"40:54:00:00:00:03 20.0.0.3\"\n\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\novn-nbctl lsp-add sw0 sw0-lr0\novn-nbctl lsp-set-type sw0-lr0 router\novn-nbctl lsp-set-addresses sw0-lr0 router\novn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\novn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\novn-nbctl lsp-add sw1 sw1-lr0\novn-nbctl lsp-set-type sw1-lr0 router\novn-nbctl lsp-set-addresses sw1-lr0 router\novn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1-rej)\nADD_VETH(sw0-p1-rej, sw0-p1-rej, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw0-p2-rej)\nADD_VETH(sw0-p2-rej, sw0-p2-rej, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\nNS_CHECK_EXEC([sw0-p1-rej], [ip a a aef0::3/64 dev sw0-p1-rej], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [ip a a aef0::4/64 dev sw0-p2-rej], [0])\n\nADD_NAMESPACES(sw1-p1-rej)\nADD_VETH(sw1-p1-rej, sw1-p1-rej, br-int, \"20.0.0.3/24\", \"40:54:00:00:00:03\", \\\n         \"20.0.0.1\")\n\n# Capture packets in sw0-p1-rej.\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej tcp > sw0-p1-rej-ip4.pcap 2> err &], [0])\n\n#Wait for tcpdump to get started before generating first packets\nOVS_WAIT_UNTIL([test 1 = $(cat err | grep -c listening)])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'\n])\n\n# Now send traffic to port 84\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'\n])\n\nOVS_WAIT_UNTIL([\n    n_pkt=$(ovs-ofctl dump-flows br-int table=46 | grep -v n_packets=0 | \\\ngrep controller | grep tp_dst=84 -c)\n    test $n_pkt -eq 1\n])\n\nOVS_WAIT_UNTIL([\n    total=`cat sw0-p1-rej-ip4.pcap |  grep \"10\\.0\\.0\\.4\" | wc -l`\n    echo \"total = $total\"\n    test \"${total}\" = \"4\"\n])\n\nkill $(pidof tcpdump)\n\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej tcp port 80 > sw0-p2-rej-ip6.pcap 2> err &], [0])\n\n#Wait for tcpdump to get started before generating first packets\nOVS_WAIT_UNTIL([test 1 = $(cat err | grep -c listening)])\n\nOVS_WAIT_UNTIL([test \"$(ip netns exec sw0-p1-rej ip a | grep aef0::3 | grep tentative)\" = \"\"])\nOVS_WAIT_UNTIL([test \"$(ip netns exec sw0-p2-rej ip a | grep aef0::4 | grep tentative)\" = \"\"])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'\n])\n\n\nOVS_WAIT_UNTIL([\n    total=`cat sw0-p2-rej-ip6.pcap | grep \"aef0::3\\.80\" | wc -l`\n    echo \"total = $total\"\n    test \"${total}\" = \"2\"\n])\n\nkill $(pidof tcpdump)\n\novn-nbctl --apply-after-lb acl-add sw1 from-lport 1004 \"ip\" allow-related\novn-nbctl acl-add sw1 to-lport 1004 \"ip\" allow-related\novn-nbctl --log acl-add pg0 to-lport 1004 \"outport == @pg0 && ip && tcp && tcp.dst == 84\" reject\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw1-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'\n])\n\n# Now test for IPv4 UDP.\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej udp port 90 > sw0-p1-rej-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nprintf '.%.0s' {1..100} > foo\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej udp port 94 > sw0-p1-rej-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 94 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 94 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\n\n# Now test for IPv6 UDP.\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej udp port 90 > sw0-p2-rej-ip6-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 90\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej udp port 94 > sw0-p2-rej-ip6-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 94 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 94\" | uniq | wc -l)\n    test $c -ge 1\n])\n\n# Delete all the ACLs of pg0 and add the ACL with a generic match with reject action.\novn-nbctl pg-del pg0\novn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej\novn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && (tcp || udp)\" reject\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'\n])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nprintf '.%.0s' {1..100} > foo\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n# Now test for IPv6 UDP.\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 90\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([IPv6 prefix delegation - distributed router])\nAT_SKIP_IF([test $HAVE_DHCPD = no])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_KEYWORDS([ovn-ipv6-prefix_d])\n\nOVN_TEST_IPV6_PREFIX_DELEGATION(DGP)\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([IPv6 prefix delegation - gw router])\nAT_SKIP_IF([test $HAVE_DHCPD = no])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_KEYWORDS([ovn-ipv6-prefix_d])\n\nOVN_TEST_IPV6_PREFIX_DELEGATION(GR)\nAT_CLEANUP\n])\n\n# Tests that when an established connection sends TCP reset,\n# the conntrack entry is not in established state.\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([conntrack TCP reset])\nAT_KEYWORDS([conntrack])\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\n\novn-nbctl lsp-add sw0 rst-p1\novn-nbctl lsp-set-addresses rst-p1 \"50:54:00:00:00:03\"\novn-nbctl lsp-set-port-security rst-p1 \"50:54:00:00:00:03\"\n\novn-nbctl lsp-add sw0 rst-p2\novn-nbctl lsp-set-addresses rst-p2 \"50:54:00:00:00:04 10.0.0.4\"\novn-nbctl lsp-set-port-security rst-p2 \"50:54:00:00:00:04 10.0.0.4\"\n\n# Create port group and ACLs for sw0 ports.\novn-nbctl pg-add pg0_drop rst-p1 rst-p2\novn-nbctl acl-add pg0_drop from-lport 1001 \"inport == @pg0_drop && ip\" drop\novn-nbctl acl-add pg0_drop to-lport 1001 \"outport == @pg0_drop && ip\" drop\n\novn-nbctl pg-add pg0 rst-p1 rst-p2\novn-nbctl acl-add pg0 from-lport 1002 \"inport == @pg0 && ip4\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && icmp4\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80\" allow-related\n\n# Create a logical router and attach to logical switch.\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\novn-nbctl lsp-add sw0 sw0-lr0\novn-nbctl lsp-set-type sw0-lr0 router\novn-nbctl lsp-set-addresses sw0-lr0 router\novn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\novn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80\novn-nbctl --wait=sb ls-lb-add sw0 lb1\novn-nbctl --wait=sb lr-lb-add lr0 lb1\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(rst-p1)\nADD_VETH(rst-p1, rst-p1, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(rst-p2)\nADD_VETH(rst-p2, rst-p2, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up rst-p1) = xup])\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up rst-p2) = xup])\n\n# Start webservers in 'rst-p1'.\nOVS_START_L7([rst-p1], [http])\n\nNS_CHECK_EXEC([rst-p2], [$PYTHON $srcdir/test-tcp-rst.py --dst-port 80 --dst-ip 10.0.0.10])\n\n# When tcp reset is sent, conntrack entry should be in the state - CLOSED or CLOSING.\n# But there is a bug where tcp reset packet was not sent to the conntrack.\n# This test case checks that the tcp reset packet is sent to conntrack\n# and the state is not in established state.\nAT_CHECK([\n    ct_est_count=$(ovs-appctl dpctl/dump-conntrack | grep 10.0.0.10 | grep state=ESTABLISHED -c)\n    test $ct_est_count -eq 0\n\n    ct_est_count=$(ovs-appctl dpctl/dump-conntrack | grep 10.0.0.10 | grep state='CLOS\\|TIME_WAIT' -c)\n    test $ct_est_count -eq 1\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/Service monitor not found.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Load balancer for container ports])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1-lbc\novn-nbctl lsp-set-addresses sw0-port1 \"10:54:00:00:00:03 10.0.0.3\"\n\novn-nbctl lsp-add sw0 sw0-p2-lbc\novn-nbctl lsp-set-addresses sw0-port2 \"10:54:00:00:00:04 10.0.0.4\"\n\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-port1 sw0-p1-lbc 10\novn-nbctl lsp-set-addresses sw1-port1 \"40:54:00:00:00:03 20.0.0.3\"\n\novn-nbctl lsp-add sw1 sw1-port2 sw0-p2-lbc 20\novn-nbctl lsp-set-addresses sw1-port2 \"40:54:00:00:00:04 20.0.0.4\"\n\n\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\novn-nbctl lsp-add sw1 sw1-lr0\novn-nbctl lsp-set-type sw1-lr0 router\novn-nbctl lsp-set-addresses sw1-lr0 router\novn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\n\novn-nbctl ls-add sw2\novn-nbctl lsp-add sw2 sw2-port1\novn-nbctl lsp-set-addresses sw2-port1 \"50:54:00:00:00:03 30.0.0.3\"\n\novn-nbctl lrp-add lr0 lr0-sw2 00:00:00:00:ff:03 30.0.0.1/24\novn-nbctl lsp-add sw2 sw2-lr0\novn-nbctl lsp-set-type sw2-lr0 router\novn-nbctl lsp-set-addresses sw2-lr0 router\novn-nbctl lsp-set-options sw2-lr0 router-port=lr0-sw2\n\n\novn-nbctl lb-add lb0 \"30.0.0.10:80\" \"20.0.0.4:80\"\n\novn-nbctl ls-lb-add sw1 lb0\novn-nbctl ls-lb-add sw2 lb0\n\nADD_NAMESPACES(sw0-p1-lbc)\nADD_VETH(sw0-p1-lbc, sw0-p1-lbc, br-int, \"10.0.0.3/24\", \"10:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw0-p2-lbc)\nADD_VETH(sw0-p2-lbc, sw0-p2-lbc, br-int, \"10.0.0.4/24\", \"10:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\n# Create the interface for lport sw1-port1\nNS_CHECK_EXEC([sw0-p1-lbc], [ip link add link sw0-p1-lbc name sw1p1 type vlan id 10], [0])\nNS_CHECK_EXEC([sw0-p1-lbc], [ip link set sw1p1 address 40:54:00:00:00:03], [0])\nNS_CHECK_EXEC([sw0-p1-lbc], [ip link set sw1p1 up], [0])\nNS_CHECK_EXEC([sw0-p1-lbc], [ip addr add 20.0.0.3/24 dev sw1p1], [0])\nNS_CHECK_EXEC([sw0-p1-lbc], [ip route delete default via 10.0.0.1 dev sw0-p1-lbc], [0])\nNS_CHECK_EXEC([sw0-p1-lbc], [ip route add default via 20.0.0.1 dev sw1p1], [0])\n\n# Create the interface for lport sw1-port2\nNS_CHECK_EXEC([sw0-p2-lbc], [ip link add link sw0-p2-lbc name sw1p2 type vlan id 20], [0])\nNS_CHECK_EXEC([sw0-p2-lbc], [ip link set sw1p2 address 40:54:00:00:00:04], [0])\nNS_CHECK_EXEC([sw0-p2-lbc], [ip link set sw1p2 up], [0])\nNS_CHECK_EXEC([sw0-p2-lbc], [ip addr add 20.0.0.4/24 dev sw1p2], [0])\nNS_CHECK_EXEC([sw0-p2-lbc], [ip route delete default via 10.0.0.1 dev sw0-p2-lbc], [0])\nNS_CHECK_EXEC([sw0-p2-lbc], [ip route add default via 20.0.0.1 dev sw1p2], [0])\n\n# Start nc server on sw1p2 (sw0-p2-lbc is the parent)\nNETNS_DAEMONIZE([sw0-p2-lbc], [nc -l -k 20.0.0.4 80], [nc0.pid])\n\n# Send the packet to backend\nNS_CHECK_EXEC([sw0-p1-lbc], [nc -z 20.0.0.4 80], [0], [ignore], [ignore])\n\n# Send the packet to VIP.\nNS_CHECK_EXEC([sw0-p1-lbc], [nc -z 30.0.0.10 80], [0], [ignore], [ignore])\n\n# Now add an ACL in sw1.\novn-nbctl --wait=hv acl-add sw1 to-lport 2002 \"ip\" allow-related\n# Send the packet to backend\nNS_CHECK_EXEC([sw0-p1-lbc], [nc -z 20.0.0.4 80], [0], [ignore], [ignore])\n\n# Send the packet to VIP.\nNS_CHECK_EXEC([sw0-p1-lbc], [nc -z 30.0.0.10 80], [0], [ignore], [ignore])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancer and firewall tuple conflict IPv4])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nOVS_CHECK_CT_ZERO_SNAT()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 1 logical switch connetected to one logical router.\n# 2 VMs, one used as backend for a load balancer.\n\ncheck ovn-nbctl                                                  \\\n    -- lr-add rtr                                                \\\n    -- lrp-add rtr rtr-ls 00:00:00:00:01:00 42.42.42.1/24        \\\n    -- ls-add ls                                                 \\\n    -- lsp-add ls ls-rtr                                         \\\n    -- lsp-set-addresses ls-rtr 00:00:00:00:01:00                \\\n    -- lsp-set-type ls-rtr router                                \\\n    -- lsp-set-options ls-rtr router-port=rtr-ls                 \\\n    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \\\n    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \\\n    -- lb-add lb-test 66.66.66.66:666 42.42.42.2:4242 tcp        \\\n    -- ls-lb-add ls lb-test\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"42.42.42.2/24\", \"00:00:00:00:00:01\", \"42.42.42.1\")\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"42.42.42.3/24\", \"00:00:00:00:00:02\", \"42.42.42.1\")\n\n# Wait for ovn-controller to catch up.\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\n# Start IPv4 TCP server on vm1.\nNETNS_DAEMONIZE([vm1], [nc -k -l 42.42.42.2 4242], [nc-vm1.pid])\n\n# Make sure connecting to the VIP works.\nNS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -p 2000 -z], [0], [ignore], [ignore])\n\n# Start IPv4 TCP connection to VIP from vm2.\nNS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -p 2001 -z], [0], [ignore], [ignore])\n\n# Check conntrack.  We expect two entries:\n# - one in vm1's zone (firewall)\n# - one in vm2's zone (dnat)\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \\\ngrep \"orig=.src=42\\.42\\.42\\.3\" |                                    \\\nsed -e 's/port=2001/port=<clnt_s_port>/g'                           \\\n    -e 's/sport=4242,dport=[[0-9]]\\+/sport=4242,dport=<rnd_port>/g' \\\n    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \\\n    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl\ntcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=42.42.42.3,dst=66.66.66.66,sport=<clnt_s_port>,dport=666),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Start IPv4 TCP connection to backend IP from vm2 which would require\n# additional source port translation to avoid a tuple conflict.\nNS_CHECK_EXEC([vm2], [nc 42.42.42.2 4242 -p 2001 -z], [0], [ignore], [ignore])\n\n# Check conntrack.  We expect three entries:\n# - one in vm1's zone (firewall) - reused from the previous connection.\n# - one in vm2's zone (dnat) - still in TIME_WAIT after the previous connection.\n# - one in vm2's zone (firewall + additional all-zero SNAT)\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \\\ngrep \"orig=.src=42\\.42\\.42\\.3\" |                                    \\\nsed -e 's/port=2001/port=<clnt_s_port>/g'                           \\\n    -e 's/sport=4242,dport=[[0-9]]\\+/sport=4242,dport=<rnd_port>/g' \\\n    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \\\n    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl\ntcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<rnd_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=42.42.42.3,dst=66.66.66.66,sport=<clnt_s_port>,dport=666),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancer and firewall tuple conflict IPv6])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nOVS_CHECK_CT_ZERO_SNAT()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 1 logical switch connetected to one logical router.\n# 2 VMs, one used as backend for a load balancer.\n\ncheck ovn-nbctl                                                  \\\n    -- lr-add rtr                                                \\\n    -- lrp-add rtr rtr-ls 00:00:00:00:01:00 4242::1/64           \\\n    -- ls-add ls                                                 \\\n    -- lsp-add ls ls-rtr                                         \\\n    -- lsp-set-addresses ls-rtr 00:00:00:00:01:00                \\\n    -- lsp-set-type ls-rtr router                                \\\n    -- lsp-set-options ls-rtr router-port=rtr-ls                 \\\n    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \\\n    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \\\n    -- lb-add lb-test [[6666::1]]:666 [[4242::2]]:4242 tcp       \\\n    -- ls-lb-add ls lb-test\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"4242::2/64\", \"00:00:00:00:00:01\", \"4242::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vm1 ip a | grep 4242::2 | grep tentative)\" = \"\"])\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"4242::3/64\", \"00:00:00:00:00:02\", \"4242::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vm2 ip a | grep 4242::3 | grep tentative)\" = \"\"])\n\n# Wait for ovn-controller to catch up.\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\n# Start IPv6 TCP server on vm1.\nNETNS_DAEMONIZE([vm1], [nc -k -l 4242::2 4242], [nc-vm1.pid])\n\n# Make sure connecting to the VIP works.\nNS_CHECK_EXEC([vm2], [nc 6666::1 666 -p 2000 -z], [0], [ignore], [ignore])\n\n# Start IPv6 TCP connection to VIP from vm2.\nNS_CHECK_EXEC([vm2], [nc 6666::1 666 -p 2001 -z], [0], [ignore], [ignore])\n\n# Check conntrack.  We expect two entries:\n# - one in vm1's zone (firewall)\n# - one in vm2's zone (dnat)\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \\\ngrep \"orig=.src=4242::3\" |                                         \\\nsed -e 's/port=2001/port=<clnt_s_port>/g'                           \\\n    -e 's/sport=4242,dport=[[0-9]]\\+/sport=4242,dport=<rnd_port>/g' \\\n    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \\\n    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl\ntcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=4242::3,dst=6666::1,sport=<clnt_s_port>,dport=666),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Start IPv6 TCP connection to backend IP from vm2 which would require\n# additional source port translation to avoid a tuple conflict.\nNS_CHECK_EXEC([vm2], [nc 4242::2 4242 -p 2001 -z], [0], [ignore], [ignore])\n\n# Check conntrack.  We expect three entries:\n# - one in vm1's zone (firewall) - reused from the previous connection.\n# - one in vm2's zone (dnat) - still in TIME_WAIT after the previous connection.\n# - one in vm2's zone (firewall + additional all-zero SNAT)\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \\\ngrep \"orig=.src=4242::3\" |                                          \\\nsed -e 's/port=2001/port=<clnt_s_port>/g'                           \\\n    -e 's/sport=4242,dport=[[0-9]]\\+/sport=4242,dport=<rnd_port>/g' \\\n    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \\\n    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl\ntcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<rnd_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=4242::3,dst=6666::1,sport=<clnt_s_port>,dport=666),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CLEANUP\n])\n\n# When a lport is released on a chassis, ovn-controller was\n# not clearing some of the flowss in the table 33 leading\n# to packet drops if ct() is hit.\n# Make sure that those flows are cleared properly.\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Test packet drops due to incorrect flows in physical table 33])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1-f\novn-nbctl lsp-set-addresses sw0-p1-f \"10:54:00:00:00:03 10.0.0.3\"\n\novn-nbctl lsp-add sw0 sw0-p2-f\novn-nbctl lsp-set-addresses sw0-p2-f \"10:54:00:00:00:04 10.0.0.4\"\n\novn-nbctl lsp-add sw0 sw0-p3-f\novn-nbctl lsp-set-addresses sw0-p3-f \"10:54:00:00:00:05 10.0.0.5\"\n\n# Add ACL with allow-ralated so that conntrack is hit.\n\novn-nbctl acl-add sw0 from-lport 1002 \"ip\" allow-related\novn-nbctl acl-add sw0 to-lport 1002 \"ip\" allow-related\n\nADD_NAMESPACES(sw0-p1-f)\nADD_VETH(sw0-p1-f, sw0-p1-f, br-int, \"10.0.0.3/24\", \"10:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw0-p2-f)\nADD_VETH(sw0-p2-f, sw0-p2-f, br-int, \"10.0.0.4/24\", \"10:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw0-p3-f)\nADD_VETH(sw0-p3-f, sw0-p3-f, br-int, \"10.0.0.5/24\", \"10:54:00:00:00:05\", \\\n         \"10.0.0.1\")\n\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1-f) = xup])\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2-f) = xup])\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xup])\n\n# Send ping from sw0-p1-f to sw0-p3-f\nNS_CHECK_EXEC([sw0-p1-f], [ping -q -c 3 -i 0.3 -w 2 10.0.0.5 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\novs-vsctl remove interface ovs-sw0-p2-f external_ids iface-id\novs-vsctl remove interface ovs-sw0-p3-f external_ids iface-id\n\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2-f) = xdown])\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xdown])\n\novs-vsctl set interface ovs-sw0-p3-f external_ids:iface-id=sw0-p3-f\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xup])\n\n# Send ping from sw0-p1-f to sw0-p3-f again and it should work.\nNS_CHECK_EXEC([sw0-p1-f], [ping -q -c 3 -i 0.3 -w 2 10.0.0.5 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ECMP symmetric reply])\nAT_KEYWORDS([ecmp])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Alice is connected to gateway router R1. R1 is connected to two \"external\"\n# routers, R2 and R3 via an \"ext\" switch.\n# Bob is connected to both R2 and R3. R1 contains two ECMP routes, one through R2\n# and one through R3, to Bob.\n#\n#     alice -- R1 -- ext ---- R2\n#                     |         \\\n#                     |           bob\n#                     |         /\n#                     + ----- R3\n#\n# For this test, Bob sends request traffic through R2 to Alice. We want to ensure that\n# all response traffic from Alice is routed through R2 as well.\n\novn-nbctl create Logical_Router name=R1 options:chassis=hv1\novn-nbctl create Logical_Router name=R2\novn-nbctl create Logical_Router name=R3\n\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add ext\n\n# connect alice to R1\novn-nbctl lrp-add R1 alice 00:00:01:01:02:03 10.0.0.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses='\"00:00:01:01:02:03\"'\n\n# connect bob to R2\novn-nbctl lrp-add R2 R2_bob 00:00:02:01:02:03 172.16.0.2/16\novn-nbctl lsp-add bob rp2-bob -- set Logical_Switch_Port rp2-bob \\\n    type=router options:router-port=R2_bob addresses='\"00:00:02:01:02:03\"'\n\n# connect bob to R3\novn-nbctl lrp-add R3 R3_bob 00:00:02:01:02:04 172.16.0.3/16\novn-nbctl lsp-add bob rp3-bob -- set Logical_Switch_Port rp3-bob \\\n    type=router options:router-port=R3_bob addresses='\"00:00:02:01:02:04\"'\n\n# Connect R1 to ext\novn-nbctl lrp-add R1 R1_ext 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add ext r1-ext -- set Logical_Switch_Port r1-ext \\\n    type=router options:router-port=R1_ext addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to ext\novn-nbctl lrp-add R2 R2_ext 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add ext r2-ext -- set Logical_Switch_Port r2-ext \\\n    type=router options:router-port=R2_ext addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to ext\novn-nbctl lrp-add R3 R3_ext 00:00:04:01:02:05 20.0.0.3/24\novn-nbctl lsp-add ext r3-ext -- set Logical_Switch_Port r3-ext \\\n    type=router options:router-port=R3_ext addresses='\"00:00:04:01:02:05\"'\n\n# Install ECMP routes for alice.\novn-nbctl --ecmp-symmetric-reply --policy=\"src-ip\" lr-route-add R1 10.0.0.0/24 20.0.0.2\novn-nbctl --ecmp-symmetric-reply --policy=\"src-ip\" lr-route-add R1 10.0.0.0/24 20.0.0.3\n\n# Static Routes\novn-nbctl lr-route-add R2 10.0.0.0/24 20.0.0.1\novn-nbctl lr-route-add R3 10.0.0.0/24 20.0.0.1\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"10.0.0.2/24\", \"f0:00:00:01:02:04\", \\\n         \"10.0.0.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 10.0.0.2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"172.16.0.1/16\", \"f0:00:00:01:02:06\", \\\n         \"172.16.0.2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 172.16.0.1\"\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovs-ofctl dump-flows br-int'\n\nNETNS_DAEMONIZE([alice1], [nc -l -k 80], [alice1.pid])\nNS_CHECK_EXEC([bob1], [nc -z 10.0.0.2 80], [0])\n\n# Ensure conntrack entry is present. We should not try to predict\n# the tunnel key for the output port, so we strip it from the labels\n# and just ensure that the known ethernet address is present.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' |\nsed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.0.1,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x401020400000000,protoinfo=(state=<cleared>)\n])\n\n# Ensure datapaths show conntrack states as expected\n# Like with conntrack entries, we shouldn't try to predict\n# port binding tunnel keys. So omit them from expected labels.\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x401020400000000/.*)' -c], [0], [dnl\n1\n])\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x401020400000000)' -c], [0], [dnl\n1\n])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# Change bob1 L2 address anche check the reply is properly updated.\novn-nbctl set Logical_Router_Port R2_ext mac='\"00:00:10:01:02:04\"'\novn-nbctl set Logical_Switch_Port r2-ext \\\n     type=router options:router-port=R2_ext addresses='\"00:00:10:01:02:04\"'\n\n# Wait for ovn-controller before sending traffic\novn-nbctl --wait=hv sync\n\nNS_CHECK_EXEC([bob1], [nc -z 10.0.0.2 80], [0])\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x1001020400000000/.*)' -c], [0], [dnl\n1\n])\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x1001020400000000)' -c], [0], [dnl\n1\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x1001020400000000 | FORMAT_CT(172.16.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' |\nsed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.0.1,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000,protoinfo=(state=<cleared>)\n])\n# Check entries in table 76 and 77 expires w/o traffic\nOVS_WAIT_UNTIL([\ntest $(ovs-ofctl dump-flows br-int | grep -c 'table=76, n_packets') -eq 0\n])\nOVS_WAIT_UNTIL([\ntest $(ovs-ofctl dump-flows br-int | grep -c 'table=77, n_packets') -eq 0\n])\n\novs-ofctl dump-flows br-int\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ECMP IPv6 symmetric reply])\nAT_KEYWORDS([ecmp])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Alice is connected to gateway router R1. R1 is connected to two \"external\"\n# routers, R2 and R3 via an \"ext\" switch.\n# Bob is connected to both R2 and R3. R1 contains two ECMP routes, one through R2\n# and one through R3, to Bob.\n#\n#     alice -- R1 -- ext ---- R2\n#                     |         \\\n#                     |           bob\n#                     |         /\n#                     + ----- R3\n#\n# For this test, Bob sends request traffic through R2 to Alice. We want to ensure that\n# all response traffic from Alice is routed through R2 as well.\n\novn-nbctl create Logical_Router name=R1 options:chassis=hv1\novn-nbctl create Logical_Router name=R2\novn-nbctl create Logical_Router name=R3\n\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add ext\n\n# connect alice to R1\novn-nbctl lrp-add R1 alice 00:00:01:01:02:03 fd01::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses='\"00:00:01:01:02:03\"'\n\n# connect bob to R2\novn-nbctl lrp-add R2 R2_bob 00:00:02:01:02:03 fd07::2/64\novn-nbctl lsp-add bob rp2-bob -- set Logical_Switch_Port rp2-bob \\\n    type=router options:router-port=R2_bob addresses='\"00:00:02:01:02:03\"'\n\n# connect bob to R3\novn-nbctl lrp-add R3 R3_bob 00:00:02:01:02:04 fd07::3/64\novn-nbctl lsp-add bob rp3-bob -- set Logical_Switch_Port rp3-bob \\\n    type=router options:router-port=R3_bob addresses='\"00:00:02:01:02:04\"'\n\n# Connect R1 to ext\novn-nbctl lrp-add R1 R1_ext 00:00:04:01:02:03 fd02::1/64\novn-nbctl lsp-add ext r1-ext -- set Logical_Switch_Port r1-ext \\\n    type=router options:router-port=R1_ext addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to ext\novn-nbctl lrp-add R2 R2_ext 00:00:04:01:02:04 fd02::2/64\novn-nbctl lsp-add ext r2-ext -- set Logical_Switch_Port r2-ext \\\n    type=router options:router-port=R2_ext addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to ext\novn-nbctl lrp-add R3 R3_ext 00:00:04:01:02:05 fd02::3/64\novn-nbctl lsp-add ext r3-ext -- set Logical_Switch_Port r3-ext \\\n    type=router options:router-port=R3_ext addresses='\"00:00:04:01:02:05\"'\n\n# Install ECMP routes for alice.\novn-nbctl --ecmp-symmetric-reply --policy=\"src-ip\" lr-route-add R1 fd01::/126 fd02::2\novn-nbctl --ecmp-symmetric-reply --policy=\"src-ip\" lr-route-add R1 fd01::/126 fd02::3\n\n# Static Routes\novn-nbctl lr-route-add R2 fd01::/64 fd02::1\novn-nbctl lr-route-add R3 fd01::/64 fd02::1\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\n# Only send 1 router solicitation as any additional ones can cause datapath\n# flows to get evicted, causing unexpected failures below.\nNS_CHECK_EXEC([alice1], [sysctl -w net.ipv6.conf.default.router_solicitations=1], [0], [dnl\nnet.ipv6.conf.default.router_solicitations = 1\n])\nADD_VETH(alice1, alice1, br-int, \"fd01::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd01::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd01::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd01::2\"\n# Add neighbour MAC address to avoid sending IPv6 NS messages which could\n# cause datapath flows to be evicted\nNS_CHECK_EXEC([alice1], [ip -6 neigh add fd01::1 lladdr 00:00:01:01:02:03 dev alice1], [0])\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\n# Only send 1 router solicitation as any additional ones can cause datapath\n# flows to get evicted, causing unexpected failures below.\nNS_CHECK_EXEC([bob1], [sysctl -w net.ipv6.conf.default.router_solicitations=1], [0], [dnl\nnet.ipv6.conf.default.router_solicitations = 1\n])\nADD_VETH(bob1, bob1, br-int, \"fd07::1/64\", \"f0:00:00:01:02:06\", \\\n         \"fd07::2\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bob1 ip a | grep fd07::1 | grep tentative)\" = \"\"])\n# Add neighbour MAC addresses to avoid sending IPv6 NS messages which could\n# cause datapath flows to be evicted\nNS_CHECK_EXEC([bob1], [ip -6 neigh add fd07::2 lladdr 00:00:02:01:02:03 dev bob1], [0])\nNS_CHECK_EXEC([bob1], [ip -6 neigh add fd07::3 lladdr 00:00:01:01:02:04 dev bob1], [0])\n\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 fd07::1\"\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovs-ofctl dump-flows br-int'\n\nNETNS_DAEMONIZE([alice1], [nc -6 -l -k 80], [alice1.pid])\nNS_CHECK_EXEC([bob1], [nc -6 -z fd01::2 80], [0])\n\n# Ensure datapaths show conntrack states as expected\n# Like with conntrack entries, we shouldn't try to predict\n# port binding tunnel keys. So omit them from expected labels.\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x401020400000000/.*)' -c], [0], [dnl\n1\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x401020400000000)' -c], [0], [dnl\n1\n])\n\n# Ensure conntrack entry is present. We should not try to predict\n# the tunnel key for the output port, so we strip it from the labels\n# and just ensure that the known ethernet address is present.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd01::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' |\nsed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd07::1,dst=fd01::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd07::1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x401020400000000,protoinfo=(state=<cleared>)\n])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# Change bob1 L2 address anche check the reply is properly updated.\novn-nbctl set Logical_Router_Port R2_ext mac='\"00:00:10:01:02:04\"'\novn-nbctl --wait=hv set Logical_Switch_Port r2-ext \\\n     type=router options:router-port=R2_ext addresses='\"00:00:10:01:02:04\"'\n\nNS_CHECK_EXEC([bob1], [nc -6 -z fd01::2 80], [0])\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x1001020400000000/.*)' -c], [0], [dnl\n1\n])\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x1001020400000000)' -c], [0], [dnl\n1\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x1001020400000000 | FORMAT_CT(fd01::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' |\nsed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd07::1,dst=fd01::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd07::1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000,protoinfo=(state=<cleared>)\n])\n\n# Check entries in table 76 and 77 expires w/o traffic\nOVS_WAIT_UNTIL([\ntest $(ovs-ofctl dump-flows br-int | grep -c 'table=76, n_packets') -eq 0\n])\nOVS_WAIT_UNTIL([\ntest $(ovs-ofctl dump-flows br-int | grep -c 'table=77, n_packets') -eq 0\n])\n\novs-ofctl dump-flows br-int\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([controller I-P handling when ovs iface ofport is -1])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-port1\novn-nbctl lsp-set-addresses sw0-port1 \"10:54:00:00:00:03 10.0.0.3\"\n\novs-vsctl add-port br-int p1 -- \\\n    set Interface p1 external_ids:iface-id=sw0-port1 -- \\\n    set Interface p1 type=internal\n\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-port1) = xup])\novs-vsctl set interface p1 type=\\\"\\\"\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-port1) = xdown])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/could not open network device p1*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ARP resolution for SNAT IP])\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\nADD_BR([br-ext])\n\novs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add sw0\novn-nbctl ls-add public\n\novn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 \\\n    -- lrp-set-gateway-chassis rp-public hv1\n\novn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\n\novn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \\\n    type=router options:router-port=rp-public \\\n    -- lsp-set-addresses public-rp router\n\novn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.1.0/24\novn-nbctl lr-nat-add R1 snat 172.16.1.20 192.168.1.2\n\nADD_NAMESPACES(sw01-x)\nADD_VETH(sw01-x, sw01-x, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add sw0 sw01-x \\\n    -- lsp-set-addresses sw01-x \"f0:00:00:01:02:03 192.168.1.2\"\n\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw01-x) = xup])\n\nADD_NAMESPACES(ext-foo)\nADD_VETH(ext-foo, ext-foo, br-ext, \"172.16.1.100/24\", \"00:10:10:01:02:13\", \\\n         \"172.16.1.1\")\n\nOVS_WAIT_UNTIL([test \"$(ip netns exec ext-foo ip a | grep fe80 | grep tentative)\" = \"\"])\n\nAT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])\novn-nbctl lsp-add public public1 \\\n        -- lsp-set-addresses public1 unknown \\\n        -- lsp-set-type public1 localnet \\\n        -- lsp-set-options public1 network_name=phynet\n\novn-nbctl --wait=hv sync\n\n# Send ping from sw01-x to ext-foo.\nNS_CHECK_EXEC([sw01-x], [ping -q -c 3 -i 0.3 -w 2 172.16.1.100 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.100) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.2,dst=172.16.1.100,id=<cleared>,type=8,code=0),reply=(src=172.16.1.100,dst=172.16.1.20,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/.*error receiving.*/d\n/.*terminating with signal 15.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([egress qos])\nAT_KEYWORDS([ovn-egress-qos])\n\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\nADD_BR([br-ext])\n\novs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\n\nADD_NAMESPACES(sw01)\nADD_VETH(sw01, sw01, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\")\novn-nbctl lsp-add sw0 sw01 \\\n    -- lsp-set-addresses sw01 \"f0:00:00:01:02:03 192.168.1.2\"\n\nADD_NAMESPACES(public)\nADD_VETH(public, public, br-ext, \"192.168.2.2/24\", \"f0:00:00:01:02:05\")\n\nAT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])\novn-nbctl lsp-add sw0 public \\\n        -- lsp-set-addresses public unknown \\\n        -- lsp-set-type public localnet \\\n        -- lsp-set-options public network_name=phynet\n\nAT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_min_rate=200000])\nAT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_max_rate=300000])\nAT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_burst=3000000])\nAT_CHECK([ovs-vsctl set interface ovs-public external-ids:ovn-egress-iface=true])\nOVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-public'])\nOVS_WAIT_UNTIL([tc class show dev ovs-public | \\\n                grep -q 'class htb .* rate 200Kbit ceil 300Kbit burst 375000b cburst 375000b'])\n\n\nAT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_max_rate=300000])\nOVS_WAIT_UNTIL([tc class show dev ovs-public | \\\n                grep -q 'class htb .* rate 200Kbit ceil 34359Mbit burst 375000b .*'])\n\nAT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_min_rate=200000])\nAT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_burst=3000000])\nOVS_WAIT_UNTIL([test \"$(tc qdisc show | grep 'htb 1: dev ovs-public')\" = \"\"])\n\nkill $(pidof ovn-controller)\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/.*error receiving.*/d\n/.*terminating with signal 15.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([BFD])\nAT_SKIP_IF([test $HAVE_BFDD_BEACON = no])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_KEYWORDS([ovn-bfd])\n\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\nADD_BR([br-ext])\n\ncheck ovs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\ncheck ovs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add R1\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl ls-add public\n\ncheck ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24\ncheck ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 1000::a/64 \\\n    -- lrp-set-gateway-chassis rp-public hv1\n\ncheck ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\ncheck ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \\\n    type=router options:router-port=rp-sw1 \\\n    -- lsp-set-addresses sw1-rp router\n\ncheck ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \\\n    type=router options:router-port=rp-public \\\n    -- lsp-set-addresses public-rp router\n\nADD_NAMESPACES(sw01)\nADD_VETH(sw01, sw01, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\ncheck ovn-nbctl lsp-add sw0 sw01 \\\n    -- lsp-set-addresses sw01 \"f0:00:00:01:02:03 192.168.1.2\"\n\nADD_NAMESPACES(sw11)\nADD_VETH(sw11, sw11, br-int, \"192.168.2.2/24\", \"f0:00:00:02:02:03\", \\\n         \"192.168.2.1\")\ncheck ovn-nbctl lsp-add sw1 sw11 \\\n    -- lsp-set-addresses sw11 \"f0:00:00:02:02:03 192.168.2.2\"\n\nADD_NAMESPACES(server)\nNS_CHECK_EXEC([server], [ip link set dev lo up])\nADD_VETH(s1, server, br-ext, \"172.16.1.50/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\nNS_CHECK_EXEC([server], [ip addr add 1000::b/64 dev s1])\n\nAT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])\ncheck ovn-nbctl lsp-add public public1 \\\n        -- lsp-set-addresses public1 unknown \\\n        -- lsp-set-type public1 localnet \\\n        -- lsp-set-options public1 network_name=phynet\n\nNS_CHECK_EXEC([server], [bfdd-beacon --listen=172.16.1.50], [0])\nNS_CHECK_EXEC([server], [bfdd-control allow 172.16.1.1], [0], [dnl\nAllowing connections from 172.16.1.1\n])\n\ncheck ovn-nbctl --bfd lr-route-add R1 100.0.0.0/8 172.16.1.50 rp-public\nuuid=$(fetch_column nb:bfd _uuid logical_port=\"rp-public\")\nroute_uuid=$(fetch_column nb:logical_router_static_route _uuid ip_prefix=\"100.0.0.0/8\")\ncheck ovn-nbctl --wait=hv sync\n\nwait_column \"up\" nb:bfd status logical_port=rp-public\nOVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 | grep 'match=(ip4.dst == 100.0.0.0/8)' | grep -q 172.16.1.50])\n\n# un-associate the bfd connection and the static route\ncheck ovn-nbctl clear logical_router_static_route $route_uuid bfd\nwait_column \"admin_down\" nb:bfd status logical_port=rp-public\nOVS_WAIT_UNTIL([ip netns exec server bfdd-control status | grep -qi state=Down])\nNS_CHECK_EXEC([server], [tcpdump -nni s1 udp port 3784 -Q in > bfd.pcap &])\nsleep 5\nkill $(pidof tcpdump)\nAT_CHECK([grep -qi bfd bfd.pcap],[1])\n\n# restart the connection\ncheck ovn-nbctl set logical_router_static_route $route_uuid bfd=$uuid\nwait_column \"up\" nb:bfd status logical_port=rp-public\n\n# switch to gw router configuration\ncheck ovn-nbctl clear logical_router_static_route $route_uuid bfd\nwait_column \"admin_down\" nb:bfd status logical_port=rp-public\nOVS_WAIT_UNTIL([ip netns exec server bfdd-control status | grep -qi state=Down])\ncheck ovn-nbctl clear logical_router_port rp-public gateway_chassis\ncheck ovn-nbctl set logical_router R1 options:chassis=hv1\ncheck ovn-nbctl set logical_router_static_route $route_uuid bfd=$uuid\nwait_column \"up\" nb:bfd status logical_port=rp-public\n\n# stop bfd endpoint\nNS_CHECK_EXEC([server], [bfdd-control stop], [0], [dnl\nstopping\n])\n\nwait_column \"down\" nb:bfd status logical_port=rp-public\nOVS_WAIT_UNTIL([test \"$(ovn-sbctl dump-flows R1 | grep 'match=(ip4.dst == 100.0.0.0/8)' | grep 172.16.1.50)\" = \"\"])\n\n# remove bfd entry\novn-nbctl destroy bfd $uuid\ncheck_row_count bfd 0\nNS_CHECK_EXEC([server], [tcpdump -nni s1 udp port 3784 -Q in > bfd.pcap &])\nsleep 5\nkill $(pidof tcpdump)\nAT_CHECK([grep -qi bfd bfd.pcap],[1])\n\nuuid_v6=$(ovn-nbctl create bfd logical_port=rp-public dst_ip=\\\"1000::b\\\")\ncheck ovn-nbctl lr-route-add R1 2000::/64 1000::b\nroute_uuid_v6=$(fetch_column nb:logical_router_static_route _uuid ip_prefix=\\\"2000::/64\\\")\novn-nbctl set logical_router_static_route $route_uuid_v6 bfd=$uuid_v6\ncheck ovn-nbctl --wait=hv sync\nNS_CHECK_EXEC([server], [bfdd-beacon --listen=1000::b], [0])\nNS_CHECK_EXEC([server], [bfdd-control allow 1000::a], [0], [dnl\nAllowing connections from 1000::a\n])\n\nwait_column \"up\" nb:bfd status logical_port=rp-public\novn-nbctl destroy bfd $uuid_v6\n\nkill $(pidof ovn-controller)\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/.*error receiving.*/d\n/.*terminating with signal 15.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([No ct_state matches in dp flows when no ACLs in an LS])\nAT_KEYWORDS([no ct_state match])\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:03\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:03\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:04 10.0.0.4\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:04 10.0.0.4\"\n\n\n# Create the second logical switch with one port and configure some ACLs.\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-p1\n\n# Create port group and ACLs for sw1 ports.\ncheck ovn-nbctl pg-add pg1 sw1-p1\ncheck ovn-nbctl acl-add pg1 from-lport 1002 \"ip\" allow-related\ncheck ovn-nbctl acl-add pg1 to-lport 1002 \"ip\" allow-related\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\n\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw1-p1)\nADD_VETH(sw1-p1, sw1-p1, br-int, \"20.0.0.4/24\", \"30:54:00:00:00:04\", \\\n         \"20.0.0.1\")\n\nwait_for_ports_up\n\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\novs-appctl dpctl/dump-flows\n\n# sw1-p1 may send IPv6 traffic.  So filter this out.  Since sw1-p1 has\n# ACLs configured, the datapath flows for the packets from sw1-p1 will have\n# matches on ct_state and ct_label fields.\n# Since sw0 doesn't have any ACLs, there should be no match on ct fields.\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [1], [dnl\n0\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [1], [dnl\n0\n])\n\n# Add an ACL to sw0.\ncheck ovn-nbctl --wait=hv acl-add sw0 to-lport 1002 ip allow-related\n\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\novs-appctl dpctl/dump-flows\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [0], [ignore])\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [0], [ignore])\n\n# Clear ACL for sw0\ncheck ovn-nbctl --wait=hv clear logical_switch sw0 acls\n\ncheck ovs-appctl dpctl/del-flows\n\ncheck ovn-nbctl --wait=hv sync\n\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\novs-appctl dpctl/dump-flows\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [1], [dnl\n0\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [1], [dnl\n0\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DNAT LR hairpin IPv4])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\nstart_daemon ovn-controller\n\n# Logical network:\n# Two VMs\n#   * VM1 with IP address 192.168.100.5\n#   * VM2 with IP address 192.168.100.6\n# The VMs connect to logical switch ls1.\n#\n# An external router with IP address 172.18.1.2. We simulate this with a network namespace.\n# There will be no traffic going here in this test.\n# The external router connects to logical switch ls-pub\n#\n# One logical router (lr1) connects to ls1 and ls-pub. The router port connected to ls-pub is\n# a gateway port.\n#   * The subnet connected to ls1 is 192.168.100.0/24. The Router IP address is 192.168.100.1\n#   * The subnet connected to ls-pub is 172.18.1.0/24. The Router IP address is 172.168.1.1\n# lr1 has the following attributes:\n#   * It has a \"default\" static route that sends traffic out the gateway router port.\n#   * It has a DNAT rule that translates 172.18.2.10 to 192.168.100.6 (VM2)\n#\n# In this test, we want to ensure that a ping from VM1 to IP address 172.18.2.10 reaches VM2.\n\novn-nbctl ls-add ls1\novn-nbctl lsp-add ls1 vm1 -- lsp-set-addresses vm1 \"00:00:00:00:00:05 192.168.100.5\"\novn-nbctl lsp-add ls1 vm2 -- lsp-set-addresses vm2 \"00:00:00:00:00:06 192.168.100.6\"\n\novn-nbctl ls-add ls-pub\novn-nbctl lsp-add ls-pub ext-router -- lsp-set-addresses ext-router \"00:00:00:00:01:02 172.18.1.2\"\n\novn-nbctl lr-add lr1\novn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:00:01 192.168.100.1/24\novn-nbctl lsp-add ls1 ls1-lr1                      \\\n    -- lsp-set-type ls1-lr1 router                 \\\n    -- lsp-set-addresses ls1-lr1 00:00:00:00:00:01 \\\n    -- lsp-set-options ls1-lr1 router-port=lr1-ls1\n\novn-nbctl lrp-add lr1 lr1-ls-pub 00:00:00:00:01:01 172.18.1.1/24\novn-nbctl lrp-set-gateway-chassis lr1-ls-pub hv1\novn-nbctl lsp-add ls-pub ls-pub-lr1                      \\\n    -- lsp-set-type ls-pub-lr1 router                    \\\n    -- lsp-set-addresses ls-pub-lr1 00:00:00:00:01:01    \\\n    -- lsp-set-options ls-pub-lr1 router-port=lr1-ls-pub\n\novn-nbctl lr-nat-add lr1 snat 172.18.1.1 192.168.100.0/24\novn-nbctl lr-nat-add lr1 dnat_and_snat 172.18.2.10 192.168.100.6\novn-nbctl lr-route-add lr1 0.0.0.0/0 172.18.1.2\n\n#ls1_uuid=$(fetch_column Port_Binding datapath logical_port=vm1)\n#ovn-sbctl create MAC_Binding ip=172.18.2.10 datapath=$ls1_uuid logical_port=vm2 mac=\"00:00:00:00:00:06\"\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"192.168.100.5/24\", \"00:00:00:00:00:05\", \\\n         \"192.168.100.1\")\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"192.168.100.6/24\", \"00:00:00:00:00:06\", \\\n         \"192.168.100.1\")\n\nADD_NAMESPACES(ext-router)\nADD_VETH(ext-router, ext-router, br-int, \"172.18.1.2/24\", \"00:00:00:00:01:02\", \\\n         \"172.18.1.1\")\n\n# Let's take a quick look at the logical flows\novn-sbctl lflow-list\n\n# Let's check what ovn-trace says...\novn-trace ls1 'inport == \"vm1\" && eth.src == 00:00:00:00:00:05 && ip4.src == 192.168.100.5 && eth.dst == 00:00:00:00:00:01 && ip4.dst == 172.18.2.10 && ip.ttl == 32'\n\n# A ping from vm1 should hairpin in lr1 and successfully DNAT to vm2\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\ndnat_and_snat_uuid=$(fetch_column nb:NAT _uuid external_ip=172.18.2.10)\novn-nbctl set NAT $dnat_and_snat_uuid options:stateless=true\n\n# A ping from vm1 should hairpin in lr1 and successfully DNAT to vm2\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n# A ping from vm2 should hairpin in lr1 and successfully DNAT to vm2\nNS_CHECK_EXEC([vm2], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nkill $(pidof ovn-controller)\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/.*error receiving.*/d\n/.*terminating with signal 15.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ovn -- Floating IP outside router subnet IPv4])\nAT_KEYWORDS(NAT)\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\nstart_daemon ovn-controller\n\n# Logical network:\n# Two VMs\n#   * VM1 with IP address 192.168.100.5\n#   * VM2 with IP address 192.168.200.5\n#\n# VM1 connects to logical switch ls1. ls1 connects to logical router lr1.\n# VM2 connects to logical switch ls2. ls2 connects to logical router lr2.\n# lr1 and lr2 both connect to logical switch ls-pub.\n# * lr1's interface that connects to ls-pub has IP address 172.18.2.110/24\n# * lr2's interface that connects to ls-pub has IP address 172.18.1.173/24\n#\n# lr1 has the following attributes:\n#   * It has a DNAT rule that translates 172.18.2.11 to 192.168.100.5 (VM1)\n#\n# lr2 has the following attributes:\n#   * It has a DNAT rule that translates 172.18.2.12 to 192.168.200.5 (VM2)\n#\n# In this test, we want to ensure that a ping from VM1 to IP address 172.18.2.12 reaches VM2.\n# When the NAT rules are set up, there should be MAC_Bindings created that allow for traffic\n# to exit lr1, go through ls-pub, and reach the NAT external IP configured on lr2.\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl lsp-add ls1 vm1 -- lsp-set-addresses vm1 \"00:00:00:00:01:05 192.168.100.5\"\n\ncheck ovn-nbctl ls-add ls2\ncheck ovn-nbctl lsp-add ls2 vm2 -- lsp-set-addresses vm2 \"00:00:00:00:02:05 192.168.200.5\"\n\ncheck ovn-nbctl ls-add ls-pub\n\ncheck ovn-nbctl lr-add lr1\ncheck ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:01:01 192.168.100.1/24\ncheck ovn-nbctl lsp-add ls1 ls1-lr1                      \\\n    -- lsp-set-type ls1-lr1 router                 \\\n    -- lsp-set-addresses ls1-lr1 router            \\\n    -- lsp-set-options ls1-lr1 router-port=lr1-ls1\n\ncheck ovn-nbctl lr-add lr2\ncheck ovn-nbctl lrp-add lr2 lr2-ls2 00:00:00:00:02:01 192.168.200.1/24\ncheck ovn-nbctl lsp-add ls2 ls2-lr2                      \\\n    -- lsp-set-type ls2-lr2 router                 \\\n    -- lsp-set-addresses ls2-lr2 router            \\\n    -- lsp-set-options ls2-lr2 router-port=lr2-ls2\n\ncheck ovn-nbctl lrp-add lr1 lr1-ls-pub 00:00:00:00:03:01 172.18.2.110/24\ncheck ovn-nbctl lrp-set-gateway-chassis lr1-ls-pub hv1\ncheck ovn-nbctl lsp-add ls-pub ls-pub-lr1                      \\\n    -- lsp-set-type ls-pub-lr1 router                    \\\n    -- lsp-set-addresses ls-pub-lr1 router               \\\n    -- lsp-set-options ls-pub-lr1 router-port=lr1-ls-pub\n\ncheck ovn-nbctl lrp-add lr2 lr2-ls-pub 00:00:00:00:03:02 172.18.1.173/24\ncheck ovn-nbctl lrp-set-gateway-chassis lr2-ls-pub hv1\ncheck ovn-nbctl lsp-add ls-pub ls-pub-lr2                      \\\n    -- lsp-set-type ls-pub-lr2 router                    \\\n    -- lsp-set-addresses ls-pub-lr2 router               \\\n    -- lsp-set-options ls-pub-lr2 router-port=lr2-ls-pub\n\n# Putting --add-route on these NAT rules means there is no need to\n# add any static routes.\ncheck ovn-nbctl --add-route lr-nat-add lr1 dnat_and_snat 172.18.2.11 192.168.100.5 vm1 00:00:00:00:03:01\ncheck ovn-nbctl --add-route lr-nat-add lr2 dnat_and_snat 172.18.2.12 192.168.200.5 vm2 00:00:00:00:03:02\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"192.168.100.5/24\", \"00:00:00:00:01:05\", \\\n         \"192.168.100.1\")\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"192.168.200.5/24\", \"00:00:00:00:02:05\", \\\n         \"192.168.200.1\")\n\nOVN_POPULATE_ARP\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([Testing a ping])\n\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.12 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ovn -- CoPP])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_SKIP_IF([test $HAVE_SCAPY = no])\nAT_KEYWORDS([ovn-copp])\n\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\nADD_BR([br-ext])\n\ncheck ovs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\ncheck ovs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add R1\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add public\n\ncheck ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 1000::a/64 \\\n    -- lrp-set-gateway-chassis rp-public hv1\n\ncheck ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\n\ncheck ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \\\n    type=router options:router-port=rp-public \\\n    -- lsp-set-addresses public-rp router\n\nADD_NAMESPACES(sw01)\nADD_VETH(sw01, sw01, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\ncheck ovn-nbctl lsp-add sw0 sw01 \\\n    -- lsp-set-addresses sw01 \"f0:00:00:01:02:03 192.168.1.2\"\n\nADD_NAMESPACES(server)\nNS_CHECK_EXEC([server], [ip link set dev lo up])\nADD_VETH(s1, server, br-ext, \"172.16.1.50/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\n\nAT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])\ncheck ovn-nbctl lsp-add public public1 \\\n        -- lsp-set-addresses public1 unknown \\\n        -- lsp-set-type public1 localnet \\\n        -- lsp-set-options public1 network_name=phynet\n\nNS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp -Q in > reject.pcap &])\ncheck ovn-nbctl meter-add acl-meter drop 1 pktps 0\ncheck ovn-nbctl --wait=hv copp-add copp0 reject acl-meter\ncheck ovn-nbctl --wait=hv ls-copp-add copp0 sw0\ncheck ovn-nbctl acl-add sw0 from-lport 1002 'inport == \"sw01\" && ip && udp' reject\n\nAT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl\nreject: acl-meter\n])\n\nip netns exec sw01 scapy -H <<-EOF\np = IP(src=\"192.168.1.2\", dst=\"192.168.1.1\") / UDP(dport = 12345) / Raw(b\"X\"*64)\nsend (p, iface='sw01', loop = 0, verbose = 0, count = 20)\nEOF\n\n# 1pps\nOVS_WAIT_UNTIL([\n    n_reject=$(grep unreachable reject.pcap | wc -l)\n    test \"${n_reject}\" = \"1\"\n])\nkill $(pidof tcpdump)\nrm -f reject.pcap\n\n# Let's update the meter\nNS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp -Q in > reject.pcap &])\ncheck ovn-nbctl --may-exist meter-add acl-meter drop 10 pktps 0\nip netns exec sw01 scapy -H <<-EOF\np = IP(src=\"192.168.1.2\", dst=\"192.168.1.1\") / UDP(dport = 12345) / Raw(b\"X\"*64)\nsend (p, iface='sw01', loop = 0, verbose = 0, count = 40)\nEOF\n\n# 10pps\nOVS_WAIT_UNTIL([\n    n_reject=$(grep unreachable reject.pcap | wc -l)\n    test \"${n_reject}\" = \"10\"\n])\n\nkill $(pidof tcpdump)\nrm -f reject.pcap\n\nNS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp -Q in > reject.pcap &])\ncheck ovn-nbctl --wait=hv copp-del copp0 reject\n\nip netns exec sw01 scapy -H <<-EOF\np = IP(src=\"192.168.1.2\", dst=\"192.168.1.1\") / UDP(dport = 12345) / Raw(b\"X\"*64)\nsend (p, iface='sw01', loop = 0, verbose = 0, count = 20)\nEOF\n\nOVS_WAIT_UNTIL([\n    n_reject=$(grep unreachable reject.pcap | wc -l)\n    test \"${n_reject}\" = \"20\"\n])\nkill $(pidof tcpdump)\n\nNS_EXEC([server], [tcpdump -l -n -i s1 arp[[24:4]]=0xac100164 > arp.pcap &])\ncheck ovn-nbctl meter-add arp-meter drop 1 pktps 0\ncheck ovn-nbctl --wait=hv copp-add copp1 arp-resolve arp-meter\ncheck ovn-nbctl --wait=hv lr-copp-add copp1 R1\nAT_CHECK([ovn-nbctl copp-list copp1], [0], [dnl\narp-resolve: arp-meter\n])\n\nip netns exec sw01 scapy -H <<-EOF\np = IP(src=\"192.168.1.2\", dst=\"172.16.1.100\") / TCP(dport = 80, flags=\"S\") / Raw(b\"X\"*64)\nsend (p, iface='sw01', loop = 0, verbose = 0, count = 100)\nEOF\n\n# 1pps\nOVS_WAIT_UNTIL([\n    n_arp=$(grep ARP arp.pcap | wc -l)\n    test \"${n_arp}\" = \"1\"\n])\nkill $(pidof tcpdump)\n\ncheck ovn-nbctl meter-add icmp-meter drop 1 pktps 0\ncheck ovn-nbctl --wait=hv copp-add copp2 icmp4-error icmp-meter\ncheck ovn-nbctl --wait=hv lr-copp-add copp2 R1\nAT_CHECK([ovn-nbctl copp-list copp2 |grep icmp4-error], [0], [dnl\nicmp4-error: icmp-meter\n])\n\nNS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp > icmp.pcap &])\nip netns exec sw01 scapy -H <<-EOF\np = IP(src=\"192.168.1.2\", dst=\"172.16.1.100\", ttl=1) / TCP(dport = 8080, flags=\"S\") / Raw(b\"X\"*64)\nsend (p, iface='sw01', loop = 0, verbose = 0, count = 100)\nEOF\n\n# 1pps\nOVS_WAIT_UNTIL([\n    n_icmp=$(grep ICMP icmp.pcap | wc -l)\n    test \"${n_icmp}\" = \"1\"\n])\nkill $(pidof tcpdump)\n\ncheck ovn-nbctl meter-add bfd-meter drop 1 pktps 0\ncheck ovn-nbctl --wait=hv copp-add copp3 bfd bfd-meter\ncheck ovn-nbctl --wait=hv lr-copp-add copp3 R1\nAT_CHECK([ovn-nbctl copp-list copp3 |grep bfd], [0], [dnl\nbfd: bfd-meter\n])\n\ncheck ovn-nbctl --wait=hv --bfd lr-route-add R1 240.0.0.0/8 172.16.1.50 rp-public\nprintf \"%08x\" $(ovn-sbctl get bfd . disc) > /tmp/disc\nNS_EXEC([server], [tcpdump -l -nn -i s1 udp port 3784 and ip[[29]]==0x90 -Q in > bfd.pcap &])\nip netns exec server scapy -H <<-EOF\nimport binascii\nf = open(\"/tmp/disc\", \"r\")\n# scapy does not support BFD protocol\n# let's hardcode a BFD payload with the proper my-disc field read from the db\nbfd = binascii.unhexlify(\"20600518a899e77b\" + f.readline().strip() + \"000f4240000f424000000000\")\np = IP(src=\"172.16.1.50\", dst=\"172.16.1.1\") / UDP(dport = 3784, sport = 49152) / Raw(load = bfd)\nsend (p, iface='s1', loop = 0, verbose = 0, count = 100)\nf.close()\nEOF\nrm /tmp/disc\n\n# 1pps\nOVS_WAIT_UNTIL([\n    n_bfd=$(grep 3784 bfd.pcap | wc -l)\n    test \"${n_bfd}\" = \"1\"\n])\nkill $(pidof tcpdump)\n\nkill $(pidof ovn-controller)\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/.*error receiving.*/d\n/.*terminating with signal 15.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL label - conntrack ct_label])\nAT_KEYWORDS([acl label ct_commit])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p3\ncheck ovn-nbctl lsp-set-addresses sw0-p3 \"50:54:00:00:00:04 10.0.0.4\"\ncheck ovn-nbctl lsp-set-port-security sw0-p3 \"50:54:00:00:00:04 10.0.0.4\"\n\n# ACLs\n# Case 1: sw0-p1 ---> sw0-p3 allowed, label=1234\n# Case 2: sw0-p3 ---> sw0-p1 allowed, label=1235\n# Case 3: sw0-p1 ---> sw0-p2 allowed, no label\n# Case 4: sw0-p2 ---> sw0-p1 allowed, no label\n\ncheck ovn-nbctl --label=1234 acl-add sw0 from-lport 1002 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.4' allow-related\ncheck ovn-nbctl --label=1235 acl-add sw0 to-lport 1002 'ip4 && outport == \"sw0-p1\" && ip4.src == 10.0.0.4' allow-related\ncheck ovn-nbctl acl-add sw0 from-lport 1001 \"ip\" allow-related\ncheck ovn-nbctl acl-add sw0 to-lport 1001 \"ip\" allow-related\n\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.2/24\", \"50:54:00:00:00:02\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p3)\nADD_VETH(sw0-p3, sw0-p3, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovn-nbctl acl-list sw0'\non_exit 'ovn-sbctl lflow-list'\non_exit 'ovs-ofctl dump-flows br-int'\n\nwait_for_ports_up\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p1' should be able to ping 'sw0-p3'.\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.4 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/'], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000\nicmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p3' should be able to ping 'sw0-p1'.\nNS_CHECK_EXEC([sw0-p3], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/'], [0], [dnl\nicmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000\nicmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p1' should be able to ping 'sw0-p2'.\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.3 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is not set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p2' should be able to ping 'sw0-p1'.\nNS_CHECK_EXEC([sw0-p2], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is not set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL label - conntrack ct_label - acl after lb])\nAT_KEYWORDS([acl label ct_commit])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p3\ncheck ovn-nbctl lsp-set-addresses sw0-p3 \"50:54:00:00:00:04 10.0.0.4\"\ncheck ovn-nbctl lsp-set-port-security sw0-p3 \"50:54:00:00:00:04 10.0.0.4\"\n\n# ACLs\n# Case 1: sw0-p1 ---> sw0-p3 allowed, label=1234\n# Case 2: sw0-p3 ---> sw0-p1 allowed, label=1235\n# Case 3: sw0-p1 ---> sw0-p2 allowed, no label\n# Case 4: sw0-p2 ---> sw0-p1 allowed, no label\n\ncheck ovn-nbctl --label=1234 --apply-after-lb acl-add sw0 from-lport 1002 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.4' allow-related\ncheck ovn-nbctl --label=1235 acl-add sw0 to-lport 1002 'ip4 && outport == \"sw0-p1\" && ip4.src == 10.0.0.4' allow-related\ncheck ovn-nbctl --apply-after-lb acl-add sw0 from-lport 1001 \"ip\" allow-related\ncheck ovn-nbctl acl-add sw0 to-lport 1001 \"ip\" allow-related\n\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.2/24\", \"50:54:00:00:00:02\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p3)\nADD_VETH(sw0-p3, sw0-p3, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovn-nbctl acl-list sw0'\non_exit 'ovn-sbctl lflow-list'\non_exit 'ovs-ofctl dump-flows br-int'\n\nwait_for_ports_up\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p1' should be able to ping 'sw0-p3'.\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.4 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/'], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000\nicmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p3' should be able to ping 'sw0-p1'.\nNS_CHECK_EXEC([sw0-p3], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/'], [0], [dnl\nicmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000\nicmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p1' should be able to ping 'sw0-p2'.\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.3 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is not set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p2' should be able to ping 'sw0-p1'.\nNS_CHECK_EXEC([sw0-p2], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is not set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL label - conntrack label change])\nAT_KEYWORDS([acl label ct_commit label change])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\n\n# ACLs\n# sw0-p1 ---> sw0-p2 allowed, label=1234\n\ncheck ovn-nbctl --label=1234 acl-add sw0 from-lport 1002 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.3' allow-related\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.2/24\", \"50:54:00:00:00:02\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovn-nbctl acl-list sw0'\non_exit 'ovn-sbctl lflow-list'\non_exit 'ovs-ofctl dump-flows br-int'\n\nwait_for_ports_up\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# start a background ping for ~30 secs.\nNETNS_DAEMONIZE([sw0-p1], [[ping -q -c 100 -i 0.3 -w 15 10.0.0.3]], [ns-sw0-p1.pid])\n\nsleep 3s\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/' | sort], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000\n])\n\n# Add a higher priority ACL with different label.\n# This ACL also allows the ping running in background.\n\ncheck ovn-nbctl --label=1235 acl-add sw0 from-lport 1003 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.3' allow-related\novn-nbctl --wait=hv sync\n\nsleep 3s\n\n# Ensure conntrack entry is updated with new ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/' | sort], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL label - conntrack label change - acl after lb])\nAT_KEYWORDS([acl label ct_commit label change])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\n\n# ACLs\n# sw0-p1 ---> sw0-p2 allowed, label=1234\n\ncheck ovn-nbctl --label=1234 --apply-after-lb acl-add sw0 from-lport 1002 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.3' allow-related\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.2/24\", \"50:54:00:00:00:02\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovn-nbctl acl-list sw0'\non_exit 'ovn-sbctl lflow-list'\non_exit 'ovs-ofctl dump-flows br-int'\n\nwait_for_ports_up\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# start a background ping for ~30 secs.\nNETNS_DAEMONIZE([sw0-p1], [[ping -q -c 100 -i 0.3 -w 15 10.0.0.3]], [ns-sw0-p1.pid])\n\nsleep 3s\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/' | sort], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000\n])\n\n# Add a higher priority ACL with different label.\n# This ACL also allows the ping running in background.\n\ncheck ovn-nbctl --label=1235 --apply-after-lb acl-add sw0 from-lport 1003 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.3' allow-related\novn-nbctl --wait=hv sync\n\nsleep 3s\n\n# Ensure conntrack entry is updated with new ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/' | sort], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL all drop and allow related - acl after lb])\nAT_KEYWORDS([ACL all drop and allow related])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n\n# No ACLs in sw0.\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0p1\ncheck ovn-nbctl lsp-set-addresses sw0p1 \"50:54:00:00:00:02 10.0.0.3\"\n\n# ACLs to drop every thing and just allow-related.\ncheck ovn-nbctl ls-add sw1\n\ncheck ovn-nbctl lsp-add sw1 sw1p1\ncheck ovn-nbctl lsp-set-addresses sw1p1 \"50:54:00:00:00:03 20.0.0.3\"\n\ncheck ovn-nbctl --apply-after-lb acl-add sw1 from-lport 1001 'inport == \"sw1p1\" && ip4' drop\n\ncheck ovn-nbctl acl-add sw1 to-lport 1002 'ip4 && tcp && tcp.dst == 80' allow-related\ncheck ovn-nbctl acl-add sw1 to-lport 1001 'ip4' drop\n\nADD_NAMESPACES(sw0p1)\nADD_VETH(sw0p1, sw0p1, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:02\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw1p1)\nADD_VETH(sw1p1, sw1p1, br-int, \"20.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"20.0.0.1\")\n\n# Create a logical router and attach both logical switches\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\ncheck ovn-nbctl lsp-add sw1 sw1-lr0\ncheck ovn-nbctl lsp-set-type sw1-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovn-nbctl acl-list sw0'\non_exit 'ovn-sbctl lflow-list'\non_exit 'ovs-ofctl dump-flows br-int'\n\nwait_for_ports_up\n\n# Start webservers in 'sw1-p1'\nOVS_START_L7([sw1p1], [http])\n\nAT_CHECK([ip netns exec sw0p1 wget 20.0.0.3 -t 3 -T 1], [0], [ignore], [ignore])\n\n# Clear the apply-after-lb option for the ACL\ncheck ovn-nbctl acl-del sw1 from-lport 1001 'inport == \"sw1p1\" && ip4'\ncheck ovn-nbctl acl-add sw1 from-lport 1001 'inport == \"sw1p1\" && ip4' drop\n\ncheck ovn-nbctl --wait=hv sync\n\nAT_CHECK([ip netns exec sw0p1 wget 20.0.0.3 -t 3 -T 1], [0], [ignore], [ignore])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL log_related])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\nset_acl_options() {\n    local acl_name=$1; shift\n\n    local acl_uuid=$(fetch_column nb:ACL _uuid name=$acl_name)\n    check ovn-nbctl set ACL $acl_uuid \"$@\"\n}\n\nclear_log() {\n    ovn-appctl -t ovn-controller vlog/close\n    rm ovn-controller.log\n    ovn-appctl -t ovn-controller vlog/reopen\n}\n\ntest_ping() {\n    NS_CHECK_EXEC([sw0-p1],  [ping -q -c 1 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\n])\n}\n\ncheck_acl_log_count() {\n    local expected_count=$1\n\n    OVS_WAIT_UNTIL([test $expected_count = `cat ovn-controller.log | grep -c acl_log`])\n}\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \"00:00:00:00:00:01 10.0.0.1\"\ncheck ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 \"00:00:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl pg-add pg1 sw0-p1 sw0-p2\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.1/24\", \"00:00:00:00:00:01\")\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.2/24\", \"00:00:00:00:00:02\")\n\nwait_for_ports_up\n\ncheck ovn-nbctl --log --name=allow_acl acl-add pg1 from-lport 100 'inport == @pg1 && ip4' allow\n\ncheck ovn-nbctl --wait=hv sync\n\ntest_ping\n\n# The allow ACL should match on the request and reply traffic, resulting in 2 logs.\ncheck_acl_log_count 2\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=2 \\\n    --name=allow_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:02 \\\n    --dl_dst=00:00:00:00:00:01 \\\n    --nw_src=10.0.0.2 \\\n    --nw_dst=10.0.0.1 \\\n    --icmp_type=0 \\\n    --icmp_code=0\n\n# Now add a higher-priority stateful ACL that matches on the same\n# parameters. Don't enable reply logging.\ncheck ovn-nbctl --log --name=allow_related_acl acl-add pg1 from-lport 200 'inport == @pg1 && ip4' allow-related\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# Since reply logging is not enabled, the allow-related ACL should match on the\n# request, but the reply will not be logged.\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# As a control, set a label on the allow-related ACL, but still don't enable\n# reply traffic logging.\nset_acl_options allow_related_acl label=1 options:log-related=false\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# This should have the same result as the previous ping\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# As another control, remove the label but enable reply logging.\nset_acl_options allow_related_acl label=0 options:log-related=true\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# This should have the same result as the previous ping\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# This time, add a label and enable reply logging on the allow_related ACL.\nset_acl_options allow_related_acl label=1 options:log-related=true\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# Now we should have the request and reply logged.\ncheck_acl_log_count 2\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=2 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:02 \\\n    --dl_dst=00:00:00:00:00:01 \\\n    --nw_src=10.0.0.2 \\\n    --nw_dst=10.0.0.1 \\\n    --icmp_type=0 \\\n    --icmp_code=0\n\n\n# And now, let's start from scratch but make sure everything works when\n# using egress ACLs.\ncheck ovn-nbctl acl-del pg1\ncheck_row_count nb:ACL 0\n\ncheck ovn-nbctl --log --name=allow_acl acl-add pg1 to-lport 100 'outport == @pg1 && ip4' allow\n\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# The allow ACL should match on the request and reply traffic, resulting in 2 logs.\ncheck_acl_log_count 2\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=2 \\\n    --name=allow_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:02 \\\n    --dl_dst=00:00:00:00:00:01 \\\n    --nw_src=10.0.0.2 \\\n    --nw_dst=10.0.0.1 \\\n    --icmp_type=0 \\\n    --icmp_code=0\n\n# Now add a higher-priority stateful ACL that matches on the same\n# parameters. Don't enable reply logging.\ncheck ovn-nbctl --log --name=allow_related_acl acl-add pg1 to-lport 200 'outport == @pg1 && ip4' allow-related\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# Since reply logging is not enabled, the allow-related ACL should match on the\n# request, but the reply will not be logged.\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# As a control, set a label on the allow-related ACL, but still don't enable\n# reply traffic logging.\nset_acl_options allow_related_acl label=1 options:log-related=false\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# This should have the same result as the previous ping\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# As another control, remove the label but enable reply logging.\nset_acl_options allow_related_acl label=0 options:log-related=true\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# This should have the same result as the previous ping\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# This time, add a label and enable reply logging on the allow_related ACL.\nset_acl_options allow_related_acl label=1 options:log-related=true\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# Now we should have the request and reply logged.\ncheck_acl_log_count 2\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=2 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:02 \\\n    --dl_dst=00:00:00:00:00:01 \\\n    --nw_src=10.0.0.2 \\\n    --nw_dst=10.0.0.1 \\\n    --icmp_type=0 \\\n    --icmp_code=0\n\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([East-West traffic with gateway router if DNAT configured])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n# Logical network:\n# One LR - R1  has two switches: sw0 and sw1\n#    sw0 -- R1 -- sw1\n# Logical port 'sw01' in switch 'sw0'.\n# Logical port 'sw11' in switch 'sw1'.\n# nc server running in sw01\n# nc client running on sw11\n\ncheck ovn-nbctl lr-add R1\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\n\ncheck ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24\ncheck ovn-nbctl set logical_router R1 options:chassis=hv1\n\ncheck ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\ncheck ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \\\n    type=router options:router-port=rp-sw1 \\\n    -- lsp-set-addresses sw1-rp router\n\nADD_NAMESPACES(sw01)\nADD_VETH(sw01, sw01, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n       \"192.168.1.1\")\ncheck ovn-nbctl lsp-add sw0 sw01 \\\n    -- lsp-set-addresses sw01 \"f0:00:00:01:02:03 192.168.1.2\"\n\nADD_NAMESPACES(sw11)\nADD_VETH(sw11, sw11, br-int, \"192.168.2.2/24\", \"f0:00:00:02:02:03\", \\\n       \"192.168.2.1\")\ncheck ovn-nbctl lsp-add sw1 sw11 \\\n    -- lsp-set-addresses sw11 \"f0:00:00:02:02:03 192.168.2.2\"\n\nNETNS_DAEMONIZE([sw01], [nc -k -l 8000], [nc-sw01.pid])\n\ntest_ping() {\n    NS_CHECK_EXEC([$1],  [ping -q -c 1 $2 -w 2 | FORMAT_PING], \\\n[0], [dnl\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\n])\n}\n\n# Only SNAT\ncheck ovn-nbctl --wait=hv lr-nat-add R1 snat 172.16.1.21 192.168.2.0/24\n\necho \"foo\" > foo\nNS_CHECK_EXEC([sw11], [nc 192.168.1.2 8000 -z], [0], [ignore], [ignore])\ntest_ping sw11 192.168.1.2\n\n# Ensure nat has been hit\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep -v \"n_packets=0\" | grep 'nat(src=172.16.1.21)'])\n# Ensure conntrack entry is present\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>\ntcp,orig=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# SNAT and DNAT. using Logical IP\novn-nbctl --wait=hv lr-nat-add R1 dnat_and_snat 172.16.1.2 192.168.1.2\nNS_CHECK_EXEC([sw11], [nc 192.168.1.2 8000 -z], [0], [ignore], [ignore])\ntest_ping sw11 192.168.1.2\n\n# Ensure conntrack entry is present\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>\ntcp,orig=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# SNAT and DNAT. using floating IP\nNS_CHECK_EXEC([sw11], [nc 172.16.1.2 8000 -z], [0], [ignore], [ignore])\ntest_ping sw11 172.16.1.2\n\n# Ensure conntrack entry is present\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>\ntcp,orig=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Container ping parent port])\nAT_KEYWORDS([container-parent-port])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1\novn-nbctl lsp-set-addresses sw0-p1 \"00:54:00:00:00:03 10.0.0.3\"\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1.2 sw0-p1 2\novn-nbctl lsp-set-addresses sw0-p1.2 \"00:54:00:00:00:04 10.0.0.4\"\ncheck ovn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.3/24\", \"00:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nNS_CHECK_EXEC([sw0-p1], [ip link add link sw0-p1 name sw0-p1.2 type vlan id 2], [0])\nADD_NAMESPACES(sw0-p1.2)\nNS_CHECK_EXEC([sw0-p1], [ip link set sw0-p1.2 netns sw0-p1.2], [0])\nNS_CHECK_EXEC([sw0-p1.2], [ip link set sw0-p1.2 address 00:54:00:00:00:04], [0])\nNS_CHECK_EXEC([sw0-p1.2], [ip link set sw0-p1.2 up], [0])\nNS_CHECK_EXEC([sw0-p1.2], [ip addr add 10.0.0.4/24 dev sw0-p1.2], [0])\nNS_CHECK_EXEC([sw0-p1.2], [ip route add default via 10.0.0.1 dev sw0-p1.2], [0])\n\nNS_CHECK_EXEC([sw0-p1.2], [ping -q -c 3 -i 0.3 -w 2 10.0.0.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([SNAT in gateway router mode])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\ncheck ovs-ofctl add-flow br0 action=normal\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ip link set br0 up\ncheck ovs-vsctl set open . external-ids:ovn-bridge-mappings=provider:br0\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl lsp-add ls1 ls1p1\ncheck ovn-nbctl lsp-set-addresses ls1p1 \"00:00:00:01:01:01 192.168.1.1 2001::1\"\ncheck ovn-nbctl lsp-add ls1 ls1p2\ncheck ovn-nbctl lsp-set-addresses ls1p2 \"00:00:00:01:01:02 192.168.1.2 2001::2\"\n\ncheck ovn-nbctl lr-add lr1\ncheck ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:00:01 192.168.1.254/24 2001::a/64\ncheck ovn-nbctl lsp-add ls1 ls1-lr1\ncheck ovn-nbctl lsp-set-addresses ls1-lr1 \"00:00:00:00:00:01 192.168.1.254 2001::a\"\ncheck ovn-nbctl lsp-set-type ls1-lr1 router\ncheck ovn-nbctl lsp-set-options ls1-lr1 router-port=lr1-ls1\n\ncheck ovn-nbctl set logical_router lr1 options:chassis=hv1\n\ncheck ovn-nbctl lrp-add lr1 lr1-pub 00:00:00:00:0f:01 172.16.1.254/24 1711::a/64\ncheck ovn-nbctl ls-add pub\ncheck ovn-nbctl lsp-add pub pub-lr1\ncheck ovn-nbctl lsp-set-type pub-lr1 router\ncheck ovn-nbctl lsp-set-options pub-lr1 router-port=lr1-pub\ncheck ovn-nbctl lsp-set-addresses pub-lr1 router\n\ncheck ovn-nbctl lsp-add pub ln -- lsp-set-options ln network_name=provider\ncheck ovn-nbctl lsp-set-type ln localnet\ncheck ovn-nbctl lsp-set-addresses ln unknown\n\ncheck ovn-nbctl lr-nat-add lr1 snat 172.16.1.10 192.168.1.0/24\ncheck ovn-nbctl lr-nat-add lr1 snat 1711::10 2001::/64\n\nADD_NAMESPACES(ls1p1)\nADD_VETH(ls1p1, ls1p1, br-int, \"192.168.1.1/24\", \"00:00:00:01:01:01\", \\\n         \"192.168.1.254\", , \"2001::1/64\", \"2001::a\")\n\nADD_NAMESPACES(ls1p2)\nADD_VETH(ls1p2, ls1p2, br-int, \"192.168.1.2/24\", \"00:00:00:01:01:02\", \\\n         \"192.168.1.254\", , \"2001::2/64\", \"2001::a\")\n\nADD_NAMESPACES(ext1)\nADD_VETH(ext1, ext1, br0, \"172.16.1.1/24\", \"00:ee:00:01:01:01\", \\\n         \"172.16.1.254\", , \"1711::1/64\", \"1711::a\")\n\ncheck ovn-nbctl --wait=hv sync\nwait_for_ports_up\nOVS_WAIT_UNTIL([test \"$(ip netns exec ls1p1 ip a | grep 2001::1 | grep tentative)\" = \"\"])\nOVS_WAIT_UNTIL([test \"$(ip netns exec ls1p2 ip a | grep 2002::2 | grep tentative)\" = \"\"])\nOVS_WAIT_UNTIL([test \"$(ip netns exec ext1 ip a | grep 1711::1 | grep tentative)\" = \"\"])\n\nNS_CHECK_EXEC([ls1p1], [ping -q -c 3 -i 0.3 -w 2  172.16.1.1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nNS_CHECK_EXEC([ls1p1], [ping6 -v -q -c 3 -i 0.3 -w 2 1711::1  | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/removing policing failed: No such device/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([mcast flow count])\nAT_KEYWORDS([ovnigmp IP-multicast])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add ls\ncheck ovn-nbctl lsp-add ls vm1\ncheck ovn-nbctl lsp-set-addresses vm1 00:00:00:00:00:01\ncheck ovn-nbctl lsp-add ls vm2\ncheck ovn-nbctl lsp-set-addresses vm2 00:00:00:00:00:02\ncheck ovn-nbctl lsp-add ls vm3\ncheck ovn-nbctl lsp-set-addresses vm3 00:00:00:00:00:03\n\ncheck ovn-nbctl set logical_switch ls other_config:mcast_querier=false other_config:mcast_snoop=true other_config:mcast_query_interval=30 other_config:mcast_eth_src=00:00:00:00:00:05 other_config:mcast_ip4_src=42.42.42.5 other_config:mcast_ip6_src=fe80::1 other_config:mcast_idle_timeout=3000\novn-sbctl list ip_multicast\n\nwait_igmp_flows_installed()\n{\n    OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int table=33 | \\\n    grep 'priority=90' | grep \"nw_dst=$1\"])\n}\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"42.42.42.1/24\", \"00:00:00:00:00:01\", \\\n         \"42.42.42.5\")\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"42.42.42.2/24\", \"00:00:00:00:00:02\")\n\nADD_NAMESPACES(vm3)\nNETNS_DAEMONIZE([vm3], [tcpdump -n -i any -nnleX > vm3.pcap 2>/dev/null], [tcpdump3.pid])\n\nADD_VETH(vm3, vm3, br-int, \"42.42.42.3/24\", \"00:00:00:00:00:03\", \\\n         \"42.42.42.5\")\n\nNS_CHECK_EXEC([vm2], [sysctl -w net.ipv4.igmp_max_memberships=100], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [sysctl -w net.ipv4.igmp_max_memberships=100], [ignore], [ignore])\nwait_for_ports_up\n\nNS_CHECK_EXEC([vm3], [ip addr add 228.0.0.1 dev vm3 autojoin], [0])\nwait_igmp_flows_installed 228.0.0.1\n\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 228.0.0.1], [ignore], [ignore])\n\nOVS_WAIT_UNTIL([\n    requests=`grep \"ICMP echo request\" -c vm3.pcap`\n    test \"${requests}\" -ge \"3\"\n])\n\nNETNS_DAEMONIZE([vm2], [tcpdump -n -i any -nnleX > vm2.pcap 2>/dev/null], [tcpdump2.pid])\n\nfor i in `seq 1 40`;do\n    NS_CHECK_EXEC([vm2], [ip addr add 228.1.$i.1 dev vm2 autojoin &], [0])\n    NS_CHECK_EXEC([vm3], [ip addr add 229.1.$i.1 dev vm3 autojoin &], [0])\n    # Do not go too fast. If going fast, there is a higher chance of sb being busy, causing full recompute (engine has not run)\n    # In this test, we do not want too many recomputes as they might hide I+I related errors\n    sleep 0.2\ndone\n\nfor i in `seq 1 40`;do\n    wait_igmp_flows_installed 228.1.$i.1\n    wait_igmp_flows_installed 229.1.$i.1\ndone\novn-sbctl list multicast_group\n\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 228.1.1.1], [ignore], [ignore])\n\nOVS_WAIT_UNTIL([\n    requests=`grep \"ICMP echo request\" -c vm2.pcap`\n    test \"${requests}\" -ge \"3\"\n])\n\n# The test could succeed thanks to a lucky northd recompute...after hitting too any flows\n# Double check we never hit error condition\nAT_CHECK([grep -qE 'Too many active mcast flows' northd/ovn-northd.log], [1])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/removing policing failed: No such device/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DVR ping router port])\nAT_KEYWORDS([dvr])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-ext])\n\ncheck ovs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovs-vsctl set open . external_ids:ovn-bridge-mappings=phys:br-ext\ncheck ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings=\"phys:ee:00:00:00:00:10\"\n\n\ncheck ovn-nbctl ls-add internal\n\ncheck ovn-nbctl lsp-add internal ln_internal \"\" 100\ncheck ovn-nbctl lsp-set-addresses ln_internal unknown\ncheck ovn-nbctl lsp-set-type ln_internal localnet\ncheck ovn-nbctl lsp-set-options ln_internal network_name=phys\n\ncheck ovn-nbctl lsp-add internal internal-gw\ncheck ovn-nbctl lsp-set-type internal-gw router\ncheck ovn-nbctl lsp-set-addresses internal-gw router\ncheck ovn-nbctl lsp-set-options internal-gw router-port=gw-internal\n\ncheck ovn-nbctl lsp-add internal vif0\n# Set address as unknown so that LRP has to generate ARP request\ncheck ovn-nbctl lsp-set-addresses vif0 unknown\n\ncheck ovn-nbctl lr-add gw\ncheck ovn-nbctl lrp-add gw gw-internal 00:00:00:00:20:00 192.168.20.1/24\n\nADD_NAMESPACES(vif0)\nADD_VETH(vif0, vif0, br-int, \"192.168.20.10/24\", \"00:00:00:00:20:10\", \"192.168.20.1\")\n\ncheck ovn-nbctl --wait=sb sync\ncheck ovn-nbctl --wait=hv sync\n\nNS_CHECK_EXEC([vif0], [ping -q -c 3 -i 0.3 -w 1 192.168.20.1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing affinity sessions - IPv4])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and\n# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected\n# to it.  R2 is a gateway router on which we add load-balancing rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\nADD_NAMESPACES(bar2)\nADD_VETH(bar2, bar2, br-int, \"192.168.2.3/24\", \"e0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar2 \\\n-- lsp-set-addresses bar2 \"e0:00:00:01:02:05 192.168.2.3\"\n\n# Config OVN load-balancer with a VIP.\n\novn-nbctl lb-add lb0 172.16.1.100:8080 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb10 172.16.1.110:8080 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb0-no-aff 172.16.1.100:8081 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb10-no-aff 172.16.1.110:8081 192.168.1.2:80,192.168.2.2:80\novn-nbctl lr-lb-add R2 lb0\novn-nbctl lr-lb-add R2 lb10\novn-nbctl lr-lb-add R2 lb0-no-aff\novn-nbctl lr-lb-add R2 lb10-no-aff\n\n# Start webservers in 'foo1', 'bar1'.\nNETNS_DAEMONIZE([foo1], [nc -l -k 192.168.1.2 80], [nc-foo1.pid])\nNETNS_DAEMONIZE([bar1], [nc -l -k 192.168.2.2 80], [nc-bar1.pid])\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2:80)'])\n\ndnl Should work with the virtual IP address through NAT\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z 172.16.1.100 8080])\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.100) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=172.16.1.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=172.16.1.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# Enable lb affinity\novn-nbctl --wait=sb set load_balancer lb0 options:affinity_timeout=60\novn-nbctl --wait=sb set load_balancer lb10 options:affinity_timeout=60\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z 172.16.1.100 8080])\ndone\n\ndnl here we should have just one entry in the ct table\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.100) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/; s/src=192.168.[[0-9]].2/src=192.168.<cleared>.2/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=172.16.1.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.<cleared>.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndp_key=$(printf \"0x%x\" $(fetch_column datapath tunnel_key external_ids:name=R2))\nAT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=78 --no-stats | sed -e 's/load:0xc0a80[[0-9]]02/load:0xc0a80<cleared>02/'], [0], [dnl\n table=78, idle_timeout=60, tcp,metadata=$dp_key,nw_src=172.16.1.2,nw_dst=172.16.1.100,tp_dst=8080 actions=load:0x1->NXM_NX_REG10[[14]],load:0xc0a80<cleared>02->NXM_NX_REG4[[]],load:0x50->NXM_NX_REG8[[0..15]]\n])\n\ncheck_affinity_flows () {\nn1=$(ovs-ofctl dump-flows br-int table=15 |awk '/priority=150,ct_state=\\+new\\+trk,ip,reg4=0xc0a80102/{print substr($4,11,length($4)-11)}')\nn2=$(ovs-ofctl dump-flows br-int table=15 |awk '/priority=150,ct_state=\\+new\\+trk,ip,reg4=0xc0a80202/{print substr($4,11,length($4)-11)}')\n[[ $n1 -gt 0 -a $n2 -eq 0 ]] || [[ $n1 -eq 0 -a $n2 -gt 0 ]]\necho $?\n}\nAT_CHECK([test $(check_affinity_flows) -eq 0])\nNS_CHECK_EXEC([alice1], [nc -z 172.16.1.100 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\novn-nbctl lb-add lb1 172.16.1.101:8080 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb11 172.16.1.111:8080 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb1-no-aff 172.16.1.101:8081 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb11-no-aff 172.16.1.111:8081 192.168.1.2:80,192.168.2.2:80\n# Enable lb affinity\novn-nbctl --wait=sb set load_balancer lb1 options:affinity_timeout=3\novn-nbctl --wait=sb set load_balancer lb11 options:affinity_timeout=3\novn-nbctl lr-lb-add R2 lb1\novn-nbctl lr-lb-add R2 lb11\novn-nbctl lr-lb-add R2 lb1-no-aff\novn-nbctl lr-lb-add R2 lb11-no-aff\n\n# check we use both backends\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z 172.16.1.101 8080])\n    ovs-ofctl del-flows br-int table=78\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.101) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=172.16.1.101,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=172.16.1.101,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([alice1], [nc -z 172.16.1.101 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nNETNS_DAEMONIZE([bar2], [nc -l -k 192.168.2.3 80], [nc-bar2.pid])\n\novn-nbctl lb-add lb2 192.168.2.100:8080 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb20 192.168.2.120:8080 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb2-no-aff 192.168.2.100:8081 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb20-no-aff 192.168.2.120:8081 192.168.2.2:80,192.168.2.3:80\novn-nbctl --wait=sb set load_balancer lb2 options:affinity_timeout=60\novn-nbctl --wait=sb set load_balancer lb20 options:affinity_timeout=60\novn-nbctl ls-lb-add foo lb2\novn-nbctl ls-lb-add foo lb20\novn-nbctl ls-lb-add foo lb2-no-aff\novn-nbctl ls-lb-add foo lb20-no-aff\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z 192.168.2.100 8080])\ndone\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.100) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/; s/src=192.168.2.[[0-9]]/src=192.168.2.<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=192.168.2.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.<cleared>,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z 192.168.2.100 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\novn-nbctl lb-add lb3 192.168.2.101:8080 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb30 192.168.2.131:8080 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb3-no-aff 192.168.2.101:8081 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb30-no-aff 192.168.2.131:8081 192.168.2.2:80,192.168.2.3:80\novn-nbctl --wait=sb set load_balancer lb3 options:affinity_timeout=3\novn-nbctl --wait=sb set load_balancer lb30 options:affinity_timeout=3\novn-nbctl ls-lb-add foo lb3\novn-nbctl ls-lb-add foo lb30\novn-nbctl ls-lb-add foo lb3-no-aff\novn-nbctl ls-lb-add foo lb30-no-aff\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z 192.168.2.101 8080])\n    ovs-ofctl del-flows br-int table=78\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.101) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=192.168.2.101,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=192.168.2.101,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z 192.168.2.101 8081])\n\nNS_CHECK_EXEC([foo1], [ip neigh add 192.168.1.200 lladdr 00:00:01:01:02:03 dev foo1], [0])\novn-nbctl lb-add lb4 192.168.1.100:8080 192.168.1.2:80\novn-nbctl lb-add lb40 192.168.1.140:8080 192.168.1.2:80\novn-nbctl lb-add lb4-no-aff 192.168.1.100:8081 192.168.1.2:80\novn-nbctl lb-add lb40-no-aff 192.168.1.140:8081 192.168.1.2:80\novn-nbctl --wait=sb set load_balancer lb4 options:affinity_timeout=60 options:hairpin_snat_ip=192.168.1.200\novn-nbctl --wait=sb set load_balancer lb40 options:affinity_timeout=60 options:hairpin_snat_ip=192.168.1.200\novn-nbctl ls-lb-add foo lb4\novn-nbctl ls-lb-add foo lb40\novn-nbctl lr-lb-add R1 lb4\novn-nbctl lr-lb-add R1 lb40\novn-nbctl ls-lb-add foo lb4-no-aff\novn-nbctl ls-lb-add foo lb40-no-aff\novn-nbctl lr-lb-add R1 lb4-no-aff\novn-nbctl lr-lb-add R1 lb40-no-aff\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z 192.168.1.100 8080])\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.1.2) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=192.168.1.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.1.200,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.200,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.1.200,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z 192.168.1.100 8081])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/inactivity probe*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing affinity sessions - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in fd20::/64 network. R1 has switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it. R2 has alice (fd72::/64) connected\n# to it.  R2 is a gateway router on which we add load-balancing rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd72::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 fd72::/64 fd20::2\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip -n foo1 a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd72::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd72::1\")\nOVS_WAIT_UNTIL([test \"$(ip -n alice1 a | grep fd72::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd72::2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n\"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip -n bar1 a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\nADD_NAMESPACES(bar2)\nADD_VETH(bar2, bar2, br-int, \"fd12::3/64\", \"e0:00:00:01:02:05\", \\\n\"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip -n bar2 a | grep fd12::3 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar2 \\\n-- lsp-set-addresses bar2 \"e0:00:00:01:02:05 fd12::3\"\n\novn-nbctl lb-add lb0 [[fd30::1]]:8080 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb10 [[fd30::10]]:8080 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb0-no-aff [[fd30::1]]:8081 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb10-no-aff [[fd30::10]]:8081 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lr-lb-add R2 lb0\novn-nbctl lr-lb-add R2 lb10\novn-nbctl lr-lb-add R2 lb0-no-aff\novn-nbctl lr-lb-add R2 lb10-no-aff\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd11::2\\]]:80)'])\n\n# Start webservers in 'foo1', 'bar1'.\nNETNS_DAEMONIZE([foo1], [nc -l -k fd11::2 80], [nc-foo1.pid])\nNETNS_DAEMONIZE([bar1], [nc -l -k fd12::2 80], [nc-bar1.pid])\n\ndnl Should work with the virtual IP address through NAT\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z fd30::1 8080])\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([alice1], [nc -z fd30::1 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# Enable lb affinity\novn-nbctl --wait=sb set load_balancer lb0 options:affinity_timeout=60\novn-nbctl --wait=sb set load_balancer lb10 options:affinity_timeout=60\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z fd30::1 8080])\ndone\n\ndnl here we should have just one entry in the ct table\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/; s/src=fd1[[0-9]]::2/src=fd1<cleared>::2/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd1<cleared>::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndp_key=$(printf \"0x%x\" $(fetch_column datapath tunnel_key external_ids:name=R2))\nAT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=78 --no-stats | sed -e 's/load:0xfd1[[0-9]]000000000000/load:0xfd1<cleared>000000000000/'], [0], [dnl\n table=78, idle_timeout=60, tcp6,metadata=$dp_key,ipv6_src=fd72::2,ipv6_dst=fd30::1,tp_dst=8080 actions=load:0x1->NXM_NX_REG10[[14]],load:0x2->NXM_NX_XXREG1[[0..63]],load:0xfd1<cleared>000000000000->NXM_NX_XXREG1[[64..127]],load:0x50->NXM_NX_REG8[[0..15]]\n])\n\ncheck_affinity_flows () {\nn1=$(ovs-ofctl dump-flows br-int table=15 |awk '/priority=150,ct_state=\\+new\\+trk,ipv6,reg4=0xfd110000/{print substr($4,11,length($4)-11)}')\nn2=$(ovs-ofctl dump-flows br-int table=15 |awk '/priority=150,ct_state=\\+new\\+trk,ipv6,reg4=0xfd120000/{print substr($4,11,length($4)-11)}')\n[[ $n1 -gt 0 -a $n2 -eq 0 ]] || [[ $n1 -eq 0 -a $n2 -gt 0 ]]\necho $?\n}\nAT_CHECK([test $(check_affinity_flows) -eq 0])\nNS_CHECK_EXEC([alice1], [nc -z fd30::1 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\novn-nbctl lb-add lb1 [[fd30::2]]:8080 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb11 [[fd30::12]]:8080 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb1-no-aff [[fd30::2]]:8081 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb11-no-aff [[fd30::12]]:8081 [[fd11::2]]:80,[[fd12::2]]:80\n# Enable lb affinity\novn-nbctl --wait=sb set load_balancer lb1 options:affinity_timeout=3\novn-nbctl --wait=sb set load_balancer lb11 options:affinity_timeout=3\novn-nbctl lr-lb-add R2 lb1\novn-nbctl lr-lb-add R2 lb11\novn-nbctl lr-lb-add R2 lb1-no-aff\novn-nbctl lr-lb-add R2 lb11-no-aff\n\n# check we use both backends\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z fd30::2 8080])\n    ovs-ofctl del-flows br-int table=78\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::2) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([alice1], [nc -z fd30::2 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nNETNS_DAEMONIZE([bar2], [nc -l -k fd12::3 80], [nc-bar2.pid])\n\novn-nbctl lb-add lb2 [[fd12::a]]:8080 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb20 [[fd12::2a]]:8080 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb2-no-aff [[fd12::a]]:8081 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb20-no-aff [[fd12::2a]]:8081 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl --wait=sb set load_balancer lb2 options:affinity_timeout=60\novn-nbctl --wait=sb set load_balancer lb20 options:affinity_timeout=60\novn-nbctl ls-lb-add foo lb2\novn-nbctl ls-lb-add foo lb20\novn-nbctl ls-lb-add foo lb2-no-aff\novn-nbctl ls-lb-add foo lb20-no-aff\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z fd12::a 8080])\ndone\n\ndnl here we should have just one entry in the ct table\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd12::a) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/; s/src=fd12::[[0-9]]/src=fd12::<cleared>/'], [0], [dnl\ntcp,orig=(src=fd11::2,dst=fd12::a,sport=<cleared>,dport=<cleared>),reply=(src=fd12::<cleared>,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z fd12::a 8081])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\novn-nbctl lb-add lb3 [[fd12::b]]:8080 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb30 [[fd12::3b]]:8080 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb3-no-aff [[fd12::b]]:8081 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb30-no-aff [[fd12::3b]]:8081 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl --wait=sb set load_balancer lb3 options:affinity_timeout=3\novn-nbctl --wait=sb set load_balancer lb30 options:affinity_timeout=3\novn-nbctl ls-lb-add foo lb3\novn-nbctl ls-lb-add foo lb30\novn-nbctl ls-lb-add foo lb3-no-aff\novn-nbctl ls-lb-add foo lb30-no-aff\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z fd12::b 8080])\n    ovs-ofctl del-flows br-int table=78\ndone\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd12::b) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd11::2,dst=fd12::b,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd11::2,dst=fd12::b,sport=<cleared>,dport=<cleared>),reply=(src=fd12::3,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z fd12::b 8081])\n\nNS_CHECK_EXEC([foo1], [ip -6 neigh add fd11::b lladdr 00:00:01:01:02:03 dev foo1], [0])\novn-nbctl --wait=sb lb-add lb4 [[fd11::a]]:8080 [[fd11::2]]:80\novn-nbctl --wait=sb lb-add lb40 [[fd11::a]]:8080 [[fd11::2]]:80\novn-nbctl --wait=sb lb-add lb4-no-aff [[fd11::a]]:8081 [[fd11::2]]:80\novn-nbctl --wait=sb lb-add lb40-no-aff [[fd11::a]]:8081 [[fd11::2]]:80\novn-nbctl --wait=sb set load_balancer lb4 options:affinity_timeout=60 options:hairpin_snat_ip=\"fd11::b\"\novn-nbctl --wait=sb set load_balancer lb40 options:affinity_timeout=60 options:hairpin_snat_ip=\"fd11::b\"\novn-nbctl ls-lb-add foo lb4\novn-nbctl ls-lb-add foo lb40\novn-nbctl lr-lb-add R1 lb4\novn-nbctl lr-lb-add R1 lb40\novn-nbctl ls-lb-add foo lb4-no-aff\novn-nbctl ls-lb-add foo lb40-no-aff\novn-nbctl lr-lb-add R1 lb4-no-aff\novn-nbctl lr-lb-add R1 lb40-no-aff\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z fd11::a 8080])\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd11::2) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd11::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd11::b,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd11::2,dst=fd11::a,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd11::b,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd11::b,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z fd11::a 8081])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/inactivity probe*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([SNAT in separate zone from DNAT])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# The goal of this test is to ensure that when traffic is first DNATted\n# (by way of a load balancer), and then SNATted, the SNAT happens in a\n# separate conntrack zone from the DNAT.\n\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add public\n\ncheck ovn-nbctl lr-add r1\ncheck ovn-nbctl lrp-add r1 r1_public 00:de:ad:ff:00:01 172.16.0.1/16\ncheck ovn-nbctl lrp-add r1 r1_s1 00:de:ad:fe:00:01 173.0.1.1/24\ncheck ovn-nbctl lrp-set-gateway-chassis r1_public hv1\n\ncheck ovn-nbctl lb-add r1_lb 30.0.0.1 172.16.0.102\ncheck ovn-nbctl lr-lb-add r1 r1_lb\n\ncheck ovn-nbctl ls-add s1\ncheck ovn-nbctl lsp-add s1 s1_r1\ncheck ovn-nbctl lsp-set-type s1_r1 router\ncheck ovn-nbctl lsp-set-addresses s1_r1 router\ncheck ovn-nbctl lsp-set-options s1_r1 router-port=r1_s1\n\ncheck ovn-nbctl lsp-add s1 vm1\ncheck ovn-nbctl lsp-set-addresses vm1 \"00:de:ad:01:00:01 173.0.1.2\"\n\ncheck ovn-nbctl lsp-add public public_r1\ncheck ovn-nbctl lsp-set-type public_r1 router\ncheck ovn-nbctl lsp-set-addresses public_r1 router\ncheck ovn-nbctl lsp-set-options public_r1 router-port=r1_public nat-addresses=router\n\ncheck ovn-nbctl lr-add r2\ncheck ovn-nbctl lrp-add r2 r2_public 00:de:ad:ff:00:02 172.16.0.2/16\ncheck ovn-nbctl lrp-add r2 r2_s2 00:de:ad:fe:00:02 173.0.2.1/24\ncheck ovn-nbctl lr-nat-add r2 dnat_and_snat 172.16.0.102 173.0.2.2\ncheck ovn-nbctl lrp-set-gateway-chassis r2_public hv1\n\ncheck ovn-nbctl ls-add s2\ncheck ovn-nbctl lsp-add s2 s2_r2\ncheck ovn-nbctl lsp-set-type s2_r2 router\ncheck ovn-nbctl lsp-set-addresses s2_r2 router\ncheck ovn-nbctl lsp-set-options s2_r2 router-port=r2_s2\n\ncheck ovn-nbctl lsp-add s2 vm2\ncheck ovn-nbctl lsp-set-addresses vm2 \"00:de:ad:01:00:02 173.0.2.2\"\n\ncheck ovn-nbctl lsp-add public public_r2\ncheck ovn-nbctl lsp-set-type public_r2 router\ncheck ovn-nbctl lsp-set-addresses public_r2 router\ncheck ovn-nbctl lsp-set-options public_r2 router-port=r2_public nat-addresses=router\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"173.0.1.2/24\", \"00:de:ad:01:00:01\", \\\n         \"173.0.1.1\")\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"173.0.2.2/24\", \"00:de:ad:01:00:02\", \\\n         \"173.0.2.1\")\n\ncheck ovn-nbctl lr-nat-add r1 dnat_and_snat 172.16.0.101 173.0.1.2 vm1 00:00:00:01:02:03\ncheck ovn-nbctl --wait=hv sync\n\n# Next, make sure that a ping works as expected\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Finally, make sure that conntrack shows two separate zones being used for\n# DNAT and SNAT\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=172.16.0.102,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=2\n])\n\n# The final two entries appear identical here. That is because FORMAT_CT\n# scrubs the zone numbers. In actuality, the zone numbers are different,\n# which is why there are two entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.102) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.0.101,dst=172.16.0.102,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=172.16.0.101,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=173.0.1.2,dst=172.16.0.102,id=<cleared>,type=8,code=0),reply=(src=172.16.0.102,dst=172.16.0.101,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=173.0.1.2,dst=172.16.0.102,id=<cleared>,type=8,code=0),reply=(src=172.16.0.102,dst=172.16.0.101,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([LB - ICMP related traffic])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\nm4_define([WAIT_PACKET], [\npcap=$1\npacket=$2\nOVS_WAIT_UNTIL([test $($PYTHON \"$ovs_srcdir/utilities/ovs-pcap.in\" $pcap |\\\ngrep -c $packet) -eq 1])\n])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\nstart_daemon ovn-controller\n\n# client -- ls0 -- lr -- ls1 -- server\ncheck ovn-nbctl ls-add ls0\ncheck ovn-nbctl ls-add ls1\n\ncheck ovn-nbctl lsp-add ls0 ls0-lr\ncheck ovn-nbctl lsp-set-type ls0-lr router\ncheck ovn-nbctl lsp-set-addresses ls0-lr 00:00:00:00:10:00 router\ncheck ovn-nbctl lsp-set-options ls0-lr router-port=lr-ls0\n\ncheck ovn-nbctl lsp-add ls1 ls1-lr\ncheck ovn-nbctl lsp-set-type ls1-lr router\ncheck ovn-nbctl lsp-set-addresses ls1-lr 00:00:00:00:20:00 router\ncheck ovn-nbctl lsp-set-options ls1-lr router-port=lr-ls1\n\ncheck ovn-nbctl lsp-add ls0 client\ncheck ovn-nbctl lsp-set-addresses client \"00:00:00:00:10:10 192.168.10.10\"\n\ncheck ovn-nbctl lsp-add ls1 server\ncheck ovn-nbctl lsp-set-addresses server \"00:00:00:00:20:10 192.168.20.10\"\n\ncheck ovn-nbctl lr-add lr\ncheck ovn-nbctl lrp-add lr lr-ls0 00:00:00:00:10:00 192.168.10.1/24\ncheck ovn-nbctl lrp-add lr lr-ls1 00:00:00:00:20:00 192.168.20.1/24\n\ncheck ovn-nbctl set logical_router lr options:chassis=hv1\n\nADD_NAMESPACES(client)\nADD_VETH(client, client, br-int, \"192.168.10.10/24\", \"00:00:00:00:10:10\", \\\n         \"192.168.10.1\")\nADD_NAMESPACES(server)\nADD_VETH(server, server, br-int, \"192.168.20.10/24\", \"00:00:00:00:20:10\", \\\n         \"192.168.20.1\")\n\n# Define packets to send\nclient_udp=00000000100000000000101008004500001C000040000A11D162C0A80A0AC0A\\\n814140001000200080000\nserver_udp=00000000200000000000201008004500001C000040000A11D16CC0A8140AC0A\\\n80A0A0002000100080000\nicmp=000000001000000000001010080045000038011F0000FF011B37C0A80A0AC0A814140\\\n304F778000005784500001c000040000911d262c0a81414c0a80a0a0002000100080000\n\n# Define expected packets\nclient_udp_expected=00000000101000000000100008004500001c000040000911d262c0a\\\n81414c0a80a0a0002000100080000\nserver_udp_expected=00000000201000000000200008004500001c000040000911d26cc0a8\\\n0a0ac0a8140a0001000200080000\nicmp_expected=000000002010000000002000080045000038011f0000fe011c41c0a80a0ac0\\\na8140a0304f778000005784500001c000040000911d26cc0a8140ac0a80a0a0002000100080000\n\ntest_related_traffic() {\n    check ovn-nbctl --wait=hv sync\n\n    check ovs-appctl dpctl/flush-conntrack\n\n    NETNS_DAEMONIZE([client], [tcpdump -l -U -i client -w client.pcap 2>client_err], [tcpdump0.pid])\n    NETNS_DAEMONIZE([server], [tcpdump -l -U -i server -w server.pcap 2>server_err], [tcpdump1.pid])\n\n    # Setup a dummy UDP listeners so we don't get \"port unreachable\".\n    NETNS_DAEMONIZE([client], [nc -l -u 1], [nc0.pid])\n    NETNS_DAEMONIZE([server], [nc -l -u 2], [nc1.pid])\n\n    OVS_WAIT_UNTIL([grep \"listening\" client_err])\n    OVS_WAIT_UNTIL([grep \"listening\" server_err])\n\n    # Send UDP client -> server\n    check ovs-ofctl packet-out br-int \"in_port=ovs-client,packet=$client_udp,actions=resubmit(,0)\"\n\n    # Send reply server -> client\n    check ovs-ofctl packet-out br-int \"in_port=ovs-server,packet=$server_udp,actions=resubmit(,0)\"\n\n    # Send ICMP \"need to frag\" client -> server\n    check ovs-ofctl packet-out br-int \"in_port=ovs-client,packet=$icmp,actions=resubmit(,0)\"\n\n    # Check if all packets have arrived\n    WAIT_PACKET([server.pcap], [$server_udp_expected])\n    WAIT_PACKET([client.pcap], [$client_udp_expected])\n    WAIT_PACKET([server.pcap], [$icmp_expected])\n\n    kill $(cat tcpdump0.pid) $(cat tcpdump1.pid)\n    kill $(cat nc0.pid) $(cat nc1.pid)\n\n    rm -f client.pcap server.pcap\n}\n\nAS_BOX([ICMP related on switch, LB without port and protocol])\ncheck ovn-nbctl lb-add lb0 192.168.20.20 192.168.20.10\ncheck ovn-nbctl ls-lb-add ls0 lb0\n\ntest_related_traffic\n\ncheck ovn-nbctl ls-lb-del ls0\ncheck ovn-nbctl lb-del lb0\n\nAS_BOX([ICMP related on switch, LB with port and protocol])\ncheck ovn-nbctl lb-add lb0 192.168.20.20:2 192.168.20.10:2 udp\ncheck ovn-nbctl ls-lb-add ls0 lb0\n\ntest_related_traffic\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nudp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2\n])\n\ncheck ovn-nbctl ls-lb-del ls0\ncheck ovn-nbctl lb-del lb0\n\nAS_BOX([ICMP related on router, LB without port and protocol])\ncheck ovn-nbctl lb-add lb0 192.168.20.20 192.168.20.10\ncheck ovn-nbctl lr-lb-add lr lb0\n\ntest_related_traffic\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nudp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2\n])\n\ncheck ovn-nbctl lr-lb-del lr\ncheck ovn-nbctl lb-del lb0\n\nAS_BOX([ICMP related on switch, LB with port and protocol])\ncheck ovn-nbctl lb-add lb0 192.168.20.20:2 192.168.20.10:2 udp\ncheck ovn-nbctl lr-lb-add lr lb0\n\ntest_related_traffic\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nudp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2\n])\n\ncheck ovn-nbctl lr-lb-del lr\ncheck ovn-nbctl lb-del lb0\n\nAS_BOX([ICMP related force SNAT])\ncheck ovn-nbctl lb-add lb0 192.168.20.20 192.168.20.10\ncheck ovn-nbctl lr-lb-add lr lb0\n\ncheck ovn-nbctl --wait=sb set logical_router lr options:lb_force_snat_ip=\"router_ip\"\n\n# Change the expected packets on server to be with source IP from router\nserver_udp_expected=00000000201000000000200008004500001c000040000911c875c0a8\\\n1401c0a8140a0001000200080000\nicmp_expected=000000002010000000002000080045000038011f0000fe01124ac0a81401c0\\\na8140a0304f778000005784500001c000040000911c875c0a8140ac0a814010002000100080000\n\n# Server should respond to the router IP\nserver_udp=00000000200000000000201008004500001C000040000A11C775C0A8140AC0A8\\\n14010002000100080000\n\ntest_related_traffic\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nudp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancer template IPv4])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([ovnlb templates])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nOVS_CHECK_CT_ZERO_SNAT()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# VM1 -- LS1 -- GW-Router -- LS2 -- VM3\n#         |\n# VM2 ----+\n#\n# Four templated load balancer applied on LS1 and GW-Router with\n# VM1 as backend.  The VIPs should be accessible from both VM2 and VM3.\n\ncheck ovn-nbctl                                                   \\\n    -- lr-add rtr                                                 \\\n    -- set Logical_Router rtr options:chassis=hv1                 \\\n    -- lrp-add rtr rtr-ls1 00:00:00:00:01:00 42.42.42.1/24        \\\n    -- lrp-add rtr rtr-ls2 00:00:00:00:02:00 43.43.43.1/24        \\\n    -- ls-add ls1                                                 \\\n    -- lsp-add ls1 ls1-rtr                                        \\\n    -- lsp-set-addresses ls1-rtr 00:00:00:00:01:00                \\\n    -- lsp-set-type ls1-rtr router                                \\\n    -- lsp-set-options ls1-rtr router-port=rtr-ls1                \\\n    -- lsp-add ls1 vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \\\n    -- lsp-add ls1 vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \\\n    -- ls-add ls2                                                 \\\n    -- lsp-add ls2 ls2-rtr                                        \\\n    -- lsp-set-addresses ls2-rtr 00:00:00:00:02:00                \\\n    -- lsp-set-type ls2-rtr router                                \\\n    -- lsp-set-options ls2-rtr router-port=rtr-ls2                \\\n    -- lsp-add ls2 vm3 -- lsp-set-addresses vm3 00:00:00:00:00:03\n\n# Add a TCP template LB that eventually expands to:\n# VIP=66.66.66.66:666 backends=42.42.42.2:4242 proto=tcp\n# And a UDP template LB that eventually expands to:\n# VIP=66.66.66.66:777 backends=42.42.42.2:4343 proto=udp\n\nAT_CHECK([ovn-nbctl -- create chassis_template_var chassis=\"hv1\" \\\n    variables=\"{vip=66.66.66.66,vport1=666,backends1=\\\"42.42.42.2:4242\\\",vport2=777,backends2=\\\"42.42.42.2:4343\\\",vport3=888,vport4=999}\"],\n         [0], [ignore])\n\ncheck ovn-nbctl --template lb-add lb-test-tcp \"^vip:^vport1\" \"^backends1\" tcp \\\n    -- ls-lb-add ls1 lb-test-tcp                                              \\\n    -- lr-lb-add rtr lb-test-tcp\n\ncheck ovn-nbctl --template lb-add lb-test-udp \"^vip:^vport2\" \"^backends2\" udp \\\n    -- ls-lb-add ls1 lb-test-udp                                              \\\n    -- lr-lb-add rtr lb-test-udp\n\n# Add a TCP template LB with explicit backends that eventually expands to:\n# VIP=66.66.66.66:888 backends=42.42.42.2:4242 proto=tcp\n# And a UDP template LB that eventually expands to:\n# VIP=66.66.66.66:999 backends=42.42.42.2:4343 proto=udp\ncheck ovn-nbctl --template lb-add lb-test-tcp2 \"^vip:^vport3\" \"42.42.42.2:4242\" tcp ipv4 \\\n    -- ls-lb-add ls1 lb-test-tcp2                                                        \\\n    -- lr-lb-add rtr lb-test-tcp2\n\ncheck ovn-nbctl --template lb-add lb-test-udp2 \"^vip:^vport4\" \"42.42.42.2:4343\" udp ipv4 \\\n    -- ls-lb-add ls1 lb-test-udp2                                                        \\\n    -- lr-lb-add rtr lb-test-udp2\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"42.42.42.2/24\", \"00:00:00:00:00:01\", \"42.42.42.1\")\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"42.42.42.3/24\", \"00:00:00:00:00:02\", \"42.42.42.1\")\n\nADD_NAMESPACES(vm3)\nADD_VETH(vm3, vm3, br-int, \"43.43.43.2/24\", \"00:00:00:00:00:03\", \"43.43.43.1\")\n\n# Wait for ovn-controller to catch up.\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\nAT_CHECK([ovn-appctl -t ovn-controller debug/dump-local-template-vars | sort], [0], [dnl\nLocal template vars:\nname: 'backends1' value: '42.42.42.2:4242'\nname: 'backends2' value: '42.42.42.2:4343'\nname: 'vip' value: '66.66.66.66'\nname: 'vport1' value: '666'\nname: 'vport2' value: '777'\nname: 'vport3' value: '888'\nname: 'vport4' value: '999'\n])\n\n# Start IPv4 TCP server on vm1.\nNETNS_DAEMONIZE([vm1], [nc -k -l 42.42.42.2 4242], [nc-vm1.pid])\n\nNETNS_DAEMONIZE([vm1],\n    [tcpdump -n -i vm1 -nnleX -c6 udp and dst 42.42.42.2 and dst port 4343 > vm1.pcap 2>/dev/null],\n    [tcpdump1.pid])\n\n# Make sure connecting to the VIP works (hairpin, via ls and via lr).\nNS_CHECK_EXEC([vm1], [nc 66.66.66.66 666 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [nc 66.66.66.66 666 -z], [0], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [echo a | nc -u 66.66.66.66 777], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [echo a | nc -u 66.66.66.66 777], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [echo a | nc -u 66.66.66.66 777], [ignore], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [nc 66.66.66.66 888 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [nc 66.66.66.66 888 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [nc 66.66.66.66 888 -z], [0], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [echo a | nc -u 66.66.66.66 999], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [echo a | nc -u 66.66.66.66 999], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [echo a | nc -u 66.66.66.66 999], [ignore], [ignore], [ignore])\n\nOVS_WAIT_UNTIL([\n    requests=`grep \"UDP\" -c vm1.pcap`\n    test \"${requests}\" -ge \"6\"\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancer template IPv6])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([ovnlb templates])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nOVS_CHECK_CT_ZERO_SNAT()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# VM1 -- LS1 -- GW-Router -- LS2 -- VM3\n#         |\n# VM2 ----+\n#\n# Four templated load balancer applied on LS1 and GW-Router with\n# VM1 as backend.  The VIPs should be accessible from both VM2 and VM3.\n\ncheck ovn-nbctl                                                   \\\n    -- lr-add rtr                                                 \\\n    -- set Logical_Router rtr options:chassis=hv1                 \\\n    -- lrp-add rtr rtr-ls1 00:00:00:00:01:00 4242::1/64           \\\n    -- lrp-add rtr rtr-ls2 00:00:00:00:02:00 4343::1/64           \\\n    -- ls-add ls1                                                 \\\n    -- lsp-add ls1 ls1-rtr                                        \\\n    -- lsp-set-addresses ls1-rtr 00:00:00:00:01:00                \\\n    -- lsp-set-type ls1-rtr router                                \\\n    -- lsp-set-options ls1-rtr router-port=rtr-ls1                \\\n    -- lsp-add ls1 vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \\\n    -- lsp-add ls1 vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \\\n    -- ls-add ls2                                                 \\\n    -- lsp-add ls2 ls2-rtr                                        \\\n    -- lsp-set-addresses ls2-rtr 00:00:00:00:02:00                \\\n    -- lsp-set-type ls2-rtr router                                \\\n    -- lsp-set-options ls2-rtr router-port=rtr-ls2                \\\n    -- lsp-add ls2 vm3 -- lsp-set-addresses vm3 00:00:00:00:00:03\n\n# Add a template LB that eventually expands to:\n# VIP=[6666::1]:666 backends=[4242::2]:4242 proto=tcp\n# Add a template LB that eventually expands to:\n# VIP=[6666::1]:777 backends=[4242::2]:4343 proto=udp\n\nAT_CHECK([ovn-nbctl -- create chassis_template_var chassis=\"hv1\" \\\n    variables=\"{vip=\\\"6666::1\\\",vport1=666,backends1=\\\"[[4242::2]]:4242\\\",vport2=777,backends2=\\\"[[4242::2]]:4343\\\",vport3=888,vport4=999}\"],\n         [0], [ignore])\n\ncheck ovn-nbctl --template lb-add lb-test-tcp \"^vip:^vport1\" \"^backends1\" tcp ipv6 \\\n    -- ls-lb-add ls1 lb-test-tcp                                                   \\\n    -- lr-lb-add rtr lb-test-tcp\n\ncheck ovn-nbctl --template lb-add lb-test-udp \"^vip:^vport2\" \"^backends2\" udp ipv6 \\\n    -- ls-lb-add ls1 lb-test-udp                                                   \\\n    -- lr-lb-add rtr lb-test-udp\n\n# Add a TCP template LB with explicit backends that eventually expands to:\n# VIP=[6666::1]:888 backends=[4242::2]:4242 proto=tcp\n# And a UDP template LB that eventually expands to:\n# VIP=[6666::1]:999 backends=[4242::2]:4343 proto=udp\ncheck ovn-nbctl --template lb-add lb-test-tcp2 \"^vip:^vport3\" \"[[4242::2]]:4242\" tcp ipv6 \\\n    -- ls-lb-add ls1 lb-test-tcp2                                                         \\\n    -- lr-lb-add rtr lb-test-tcp2\n\ncheck ovn-nbctl --template lb-add lb-test-udp2 \"^vip:^vport4\" \"[[4242::2]]:4343\" udp ipv6 \\\n    -- ls-lb-add ls1 lb-test-udp2                                                         \\\n    -- lr-lb-add rtr lb-test-udp2\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"4242::2/64\", \"00:00:00:00:00:01\", \"4242::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vm1 ip a | grep 4242::2 | grep tentative)\" = \"\"])\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"4242::3/64\", \"00:00:00:00:00:02\", \"4242::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vm2 ip a | grep 4242::3 | grep tentative)\" = \"\"])\n\nADD_NAMESPACES(vm3)\nADD_VETH(vm3, vm3, br-int, \"4343::2/64\", \"00:00:00:00:00:03\", \"4343::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vm3 ip a | grep 4343::2 | grep tentative)\" = \"\"])\n\n# Wait for ovn-controller to catch up.\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\nAT_CHECK([ovn-appctl -t ovn-controller debug/dump-local-template-vars | sort], [0], [dnl\nLocal template vars:\nname: 'backends1' value: '[[4242::2]]:4242'\nname: 'backends2' value: '[[4242::2]]:4343'\nname: 'vip' value: '6666::1'\nname: 'vport1' value: '666'\nname: 'vport2' value: '777'\nname: 'vport3' value: '888'\nname: 'vport4' value: '999'\n])\n\n# Start IPv6 TCP server on vm1.\nNETNS_DAEMONIZE([vm1], [nc -k -l 4242::2 4242], [nc-vm1.pid])\n\nNETNS_DAEMONIZE([vm1],\n    [tcpdump -n -i vm1 -nnleX -c6 udp and dst 4242::2 and dst port 4343 > vm1.pcap 2>/dev/null],\n    [tcpdump1.pid])\n\n# Make sure connecting to the VIP works (hairpin, via ls and via lr).\nNS_CHECK_EXEC([vm1], [nc 6666::1 666 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [nc 6666::1 666 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [nc 6666::1 666 -z], [0], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [echo a | nc -u 6666::1 777], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [echo a | nc -u 6666::1 777], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [echo a | nc -u 6666::1 777], [ignore], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [nc 6666::1 888 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [nc 6666::1 888 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [nc 6666::1 888 -z], [0], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [echo a | nc -u 6666::1 999], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [echo a | nc -u 6666::1 999], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [echo a | nc -u 6666::1 999], [ignore], [ignore], [ignore])\n\nOVS_WAIT_UNTIL([\n    requests=`grep \"UDP\" -c vm1.pcap`\n    test \"${requests}\" -ge \"6\"\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([IP buffering])\nAT_KEYWORDS([ip-buffering])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\n\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\nADD_BR([br-ext])\n\novs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\nADD_NAMESPACES(sw01)\nADD_VETH(sw01, sw01, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\nADD_NAMESPACES(sw11)\nADD_VETH(sw11, sw11, br-int, \"192.168.2.2/24\", \"f0:00:00:02:02:03\", \\\n         \"192.168.2.1\")\nADD_NAMESPACES(remote)\nADD_VETH(remote, remote, br-ext, \"172.16.1.2/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\nADD_NAMESPACES(remote1)\nADD_VETH(remote1, remote1, br-ext, \"172.16.1.4/24\", \"f0:00:00:01:02:06\", \\\n         \"172.16.1.1\")\n\nNETNS_DAEMONIZE([remote], [tcpdump -c 3 -nneei remote -Q in src 192.168.1.2 and dst 172.16.1.2 and icmp > icmp.pcap], [tcpdump0.pid])\nNETNS_DAEMONIZE([remote], [tcpdump -c 1 -nneei remote -Q in arp and arp[[24:4]]==0xac100102 > arp.pcap], [tcpdump1.pid])\nNETNS_DAEMONIZE([remote1], [tcpdump -c 3 -nneei remote1 -Q in src 172.16.1.3 and dst 172.16.1.4 and icmp > icmp1.pcap 2>/dev/null], [tcpdump2.pid])\nNETNS_DAEMONIZE([remote1], [tcpdump -c 1 -nneei remote1 -Q in arp and arp[[24:4]]==0xac100104 > arp1.pcap 2>/dev/null], [tcpdump3.pid])\n\ncheck ovn-nbctl lr-add R1 -- set Logical_Router R1 options:chassis=hv1\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl ls-add public\n\ncheck ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24\ncheck ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24\n\ncheck ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\ncheck ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \\\n    type=router options:router-port=rp-sw1 \\\n    -- lsp-set-addresses sw1-rp router\n\ncheck ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \\\n    type=router options:router-port=rp-public \\\n    -- lsp-set-addresses public-rp router\n\ncheck ovn-nbctl lsp-add sw0 sw01 \\\n    -- lsp-set-addresses sw01 \"f0:00:00:01:02:03 192.168.1.2\"\n\ncheck ovn-nbctl lsp-add sw1 sw11 \\\n    -- lsp-set-addresses sw11 \"f0:00:00:02:02:03 192.168.2.2\"\n\ncheck ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.2.2 sw11 00:00:02:02:03:10\n\nAT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])\ncheck ovn-nbctl lsp-add public public1 \\\n        -- lsp-set-addresses public1 unknown \\\n        -- lsp-set-type public1 localnet \\\n        -- lsp-set-options public1 network_name=phynet\n\nOVN_POPULATE_ARP\n\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\nNS_CHECK_EXEC([sw01], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_WAIT_UNTIL([\n        total_arp_pkts=$(cat arp.pcap | wc -l)\n        test \"${total_arp_pkts}\" = \"1\"\n])\n\nOVS_WAIT_UNTIL([\n        total_icmp_pkts=$(cat icmp.pcap | wc -l)\n        test \"${total_icmp_pkts}\" = \"3\"\n])\n\nNS_CHECK_EXEC([sw11], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_WAIT_UNTIL([\n        total_arp1_pkts=$(cat arp1.pcap | wc -l)\n        test \"${total_arp1_pkts}\" = \"1\"\n])\n\nOVS_WAIT_UNTIL([\n        total_icmp1_pkts=$(cat icmp1.pcap | wc -l)\n        test \"${total_icmp1_pkts}\" = \"3\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\n# For packets that match stateless ACL flows, make sure we bypass\n# connection tracking, even with a LB in the switch. Testing for\n# TCP should suffice. For v4 and v6.\n#\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([omit connection tracking for stateless flows v4])\n\nCHECK_CONNTRACK()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),\n#\n#    foo -- R1 -- bar\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:04\", \\\n         \"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 192.168.2.2\"\n\n# Config OVN load-balancer with a VIP.\novn-nbctl lb-add lb1 30.30.30.30:80 \"192.168.2.2:80\" tcp\novn-nbctl ls-lb-add foo lb1\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2:80)'])\n\nzone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep foo1 | cut -d ' ' -f2)\n\nOVS_START_L7([bar1], [http])\n\nAT_CHECK([ip netns exec foo1 wget   192.168.2.2 -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(192.168.1.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# now check with VIP\nAT_CHECK([ip netns exec foo1 wget   30.30.30.30  -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(30.30.30.30) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.30.30.30,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# remove lb\novn-nbctl ls-lb-del foo lb1\n\n# add stateless acl\ncheck ovn-nbctl acl-add foo from-lport 1 1 allow-stateless\ncheck ovn-nbctl --wait=hv acl-add foo to-lport 1 1 allow-stateless\n\nAT_CHECK([ip netns exec foo1 wget   192.168.2.2 -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has no tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(192.168.1.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# add lb back\novn-nbctl ls-lb-add foo lb1\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2:80)'])\n\n# should not dnat so will not be able to connect\nAT_CHECK([ip netns exec foo1 wget   30.30.30.30  -t 3 -T 1], [4], [ignore], [ignore])\n\n# check conntrack zone has no tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(30.30.30.30) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([omit connection tracking for stateless flows v6])\n\nCHECK_CONNTRACK()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR - R1 with switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it\n#\n#    foo -- R1 -- bar\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n\"fd12::1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\n# Config OVN load-balancer with a VIP.\novn-nbctl lb-add lb1 [[fd30::2]]:80 [[fd12::2]]:80 tcp\novn-nbctl ls-lb-add foo lb1\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd12::2\\]]:80)'])\n\nzone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep foo1 | cut -d ' ' -f2)\n\nOVS_START_L7([bar1], [http6])\n\nAT_CHECK([ip netns exec foo1  wget http://[[fd12::2]] -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(fd12::2) |  grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd11::2,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# now check with VIP\nAT_CHECK([ip netns exec foo1 wget  http://[[fd30::2]]  -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(fd30::2) |  grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd11::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# remove lb\novn-nbctl ls-lb-del foo lb1\n\n# add stateless acl\ncheck ovn-nbctl acl-add foo from-lport 1 1 allow-stateless\ncheck ovn-nbctl --wait=hv acl-add foo to-lport 1 1 allow-stateless\n\nAT_CHECK([ip netns exec foo1  wget http://[[fd12::2]] -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has no tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(fd12::2) |  grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# add lb back\novn-nbctl ls-lb-add foo lb1\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd12::2\\]]:80)'])\n\n# should not dnat so will not be able to connect\nAT_CHECK([ip netns exec foo1 wget  http://[[fd30::2]]  -t 3 -T 1], [4], [ignore], [ignore])\n#\n# check conntrack zone has no tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(fd30::2) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\n###########################################################\n## ls1 -- cluster-router -- join - gr1 -- public1 -- ln1 ##\n###########################################################\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Gateway router with dynamic_neigh_routers])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-ex], [set Bridge br-ex fail-mode=standalone])\n\ncheck ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=provider:br-ex\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Add routers\ncheck ovn-nbctl lr-add gr1\ncheck ovn-nbctl lr-add cluster-router\n\n# Add switches\ncheck ovn-nbctl ls-add join\ncheck ovn-nbctl ls-add public1\ncheck ovn-nbctl ls-add ls1\n\n# Add ls1 ports\ncheck ovn-nbctl lsp-add ls1 ls1p1 \\\n    -- lsp-set-addresses ls1p1 \"00:00:00:00:01:11 10.244.2.11\"\n\ncheck ovn-nbctl lsp-add ls1 ls1-to-cluster-router \\\n    -- lsp-set-type ls1-to-cluster-router router \\\n    -- lsp-set-options ls1-to-cluster-router router-port=cluster-router-to-ls1 \\\n    -- lsp-set-addresses ls1-to-cluster-router router\n\n# Add cluster-router ports\ncheck ovn-nbctl lrp-add cluster-router cluster-router-to-ls1 \"00:00:00:0f:01:01\" 10.244.2.1/24 \\\n    -- lrp-add cluster-router cluster-router-to-join \"00:00:00:0f:02:01\" 100.64.0.1/16 \\\n    -- lrp-set-gateway-chassis cluster-router-to-ls1 hv1 10 \\\n    -- --policy=src-ip lr-route-add cluster-router 10.244.2.0/24 100.64.0.3\n\n# Add join ports\ncheck ovn-nbctl lsp-add join join-to-cluster-router \\\n    -- lsp-set-type join-to-cluster-router router \\\n    -- lsp-set-options join-to-cluster-router router-port=cluster-router-to-join \\\n    -- lsp-set-addresses join-to-cluster-router router \\\n    -- lsp-add join join-to-gr1 \\\n    -- lsp-set-type join-to-gr1 router \\\n    -- lsp-set-options join-to-gr1 router-port=gr1-to-join \\\n    -- lsp-set-addresses join-to-gr1 router\n\ncheck ovn-nbctl set logical_router gr1 options:lb_force_snat_ip=router_ip \\\n    -- set logical_router gr1 options:snat-ct-zone=0 \\\n    -- set logical_router gr1 options:dynamic_neigh_routers=true\n\n# Add gr1 ports and set natting\ncheck ovn-nbctl lrp-add gr1 gr1-to-join \"00:00:00:0f:02:03\" 100.64.0.3/16 \\\n    -- lr-route-add gr1 10.244.0.0/16 100.64.0.1 \\\n    -- lr-nat-add gr1 snat 10.89.189.12 10.244.0.0/16 \\\n    -- lrp-add gr1 gr1-to-public1 \"0a:0a:b6:fc:03:12\" 10.89.189.12/24 \\\n    -- set logical_router gr1 options:chassis=hv1\n\n# Add public1 ports\ncheck ovn-nbctl lsp-add public1 public1-to-gr1 \\\n    -- lsp-set-type public1-to-gr1 router \\\n    -- lsp-set-options public1-to-gr1 router-port=gr1-to-public1 \\\n    -- lsp-set-addresses public1-to-gr1 router \\\n    -- lsp-add public1 ln1 \\\n    -- lsp-set-type ln1 localnet \\\n    -- lsp-set-options ln1 network_name=provider \\\n    -- lsp-set-addresses ln1 unknown\n\ncheck ovn-nbctl --wait=hv sync\n\nADD_NAMESPACES(ns_ls1p1)\nADD_VETH(ls1p1, ns_ls1p1, br-int, \"10.244.2.11/24\", \"00:00:00:00:01:11\", \"10.244.2.1\")\n\nADD_NAMESPACES(ns_ext1)\nADD_VETH(ln1, ns_ext1, br-ex, \"10.89.189.1/24\", \"0a:0a:b6:fc:03:01\")\n\nNS_CHECK_EXEC([ns_ls1p1], [ping -q -c 3 -i 0.3 -w 2 10.89.189.1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL default_acl_drop])\nAT_KEYWORDS([acl default_acl_drop])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw\n\n# Logical port 'vm1' in switch 'sw'.\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"10.0.0.1/24\", \"f0:00:00:01:02:03\", \\\n         \"10.0.0.254\")\ncheck ovn-nbctl lsp-add sw vm1 \\\n-- lsp-set-addresses vm1 \"f0:00:00:01:02:03 10.0.0.1\"\n\n# Logical port 'vm2' in switch 'sw'.\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"10.0.0.2/24\", \"f0:00:00:01:02:05\", \\\n\"10.0.0.254\")\ncheck ovn-nbctl lsp-add sw vm2 \\\n-- lsp-set-addresses vm2 \"f0:00:00:01:02:05 10.0.0.2\"\n\n# Wait for ovn-controller to catch up.\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([from-lport acl, default_acl_drop false])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=false \\\n    -- acl-add sw from-lport 20 \"ip4 && icmp\" allow-related \\\n    -- acl-add sw from-lport 10 \"ip4\" drop\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAS_BOX([from-lport acl, default_acl_drop true])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=true \\\n    -- acl-add sw from-lport 20 \"ip4 && icmp\" allow-related \\\n    -- acl-add sw from-lport 10 \"arp\" allow \\\n    -- --apply-after-lb acl-add sw from-lport 1 1 allow \\\n    -- acl-add sw to-lport 1 1 allow\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAS_BOX([from-lport acl, after LB, default_acl_drop false])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=false \\\n    -- --apply-after-lb acl-add sw from-lport 20 \"ip4 && icmp\" allow-related \\\n    -- --apply-after-lb acl-add sw from-lport 10 \"ip4\" drop\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAS_BOX([from-lport acl, after LB, default_acl_drop true])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=true \\\n    -- acl-add sw from-lport 1 1 allow \\\n    -- --apply-after-lb acl-add sw from-lport 20 \"ip4 && icmp\" allow-related \\\n    -- --apply-after-lb acl-add sw from-lport 20 \"arp\" allow-related \\\n    -- acl-add sw to-lport 1 1 allow\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAS_BOX([to-lport acl, default_acl_drop false])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=false \\\n    -- acl-add sw to-lport 20 \"ip4 && icmp\" allow-related \\\n    -- acl-add sw to-lport 10 \"ip4\" drop\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAS_BOX([to-lport acl, default_acl_drop true])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=true \\\n    -- acl-add sw from-lport 1 1 allow \\\n    -- --apply-after-lb acl-add sw from-lport 1 1 allow \\\n    -- acl-add sw to-lport 20 \"ip4 && icmp\" allow-related \\\n    -- acl-add sw to-lport 20 \"arp\" allow\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancing CT flush backends])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\ncheck ovs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 2 logical switches \"foo\" (192.168.1.0/24) and \"bar\" (172.16.1.0/24)\n# connected to a router R1.\n# foo has foo1 to act as a client.\n# bar has bar1, bar2, bar3 to act as servers.\n#\n# Loadbalancer VIPs in 30.0.0.0/24 network.\n\ncheck ovn-nbctl lr-add R1\ncheck ovn-nbctl ls-add foo\ncheck ovn-nbctl ls-add bar\n\n# Connect foo to R1\ncheck ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\ncheck ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 172.16.1.1/24\ncheck ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Create logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\ncheck ovn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"172.16.1.2/24\", \"f0:00:0f:01:02:03\", \\\n         \"172.16.1.1\")\ncheck ovn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:0f:01:02:03 172.16.1.2\"\n\nADD_NAMESPACES(bar2)\nADD_VETH(bar2, bar2, br-int, \"172.16.1.3/24\", \"f0:00:0f:01:02:04\", \\\n         \"172.16.1.1\")\ncheck ovn-nbctl lsp-add bar bar2 \\\n-- lsp-set-addresses bar2 \"f0:00:0f:01:02:04 172.16.1.3\"\n\nADD_NAMESPACES(bar3)\nADD_VETH(bar3, bar3, br-int, \"172.16.1.4/24\", \"f0:00:0f:01:02:05\", \\\n         \"172.16.1.1\")\ncheck ovn-nbctl lsp-add bar bar3 \\\n-- lsp-set-addresses bar3 \"f0:00:0f:01:02:05 172.16.1.4\"\n\n# Config OVN load-balancer with a VIP.\ncheck ovn-nbctl lb-add lb1 30.0.0.1 \"172.16.1.2,172.16.1.3,172.16.1.4\" \\\n    -- set load_balancer lb1 options:ct_flush=\"true\"\ncheck ovn-nbctl ls-lb-add foo lb1\n\n# Create another load-balancer with another VIP.\nlb2_uuid=`ovn-nbctl create load_balancer name=lb2 vips:30.0.0.3=\"172.16.1.2,172.16.1.3,172.16.1.4\"`\ncheck ovn-nbctl set load_balancer lb2 options:ct_flush=\"true\"\ncheck ovn-nbctl ls-lb-add foo lb2\n\n# Config OVN load-balancer with another VIP (this time with ports).\ncheck ovn-nbctl set load_balancer $lb2_uuid vips:'\"30.0.0.2:8000\"'='\"172.16.1.2:80,172.16.1.3:80,172.16.1.4:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=172.16.1.4:80)'])\n\n# Start webservers in 'bar1', 'bar2' and 'bar3'.\nOVS_START_L7([bar1], [http])\nOVS_START_L7([bar2], [http])\nOVS_START_L7([bar3], [http])\n\nm4_define([LB1_CT_ENTRIES], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.3 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Remove one backend\ncheck ovn-nbctl set load_balancer lb1 vips='\"30.0.0.1\"=\"172.16.1.2,172.16.1.3\"'\n\nOVS_WAIT_FOR_OUTPUT([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Remove whole LB\ncheck ovn-nbctl lb-del lb1\n\nOVS_WAIT_UNTIL([test \"$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | wc -l)\" = \"0\"])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Remove one VIP\ncheck ovn-nbctl remove load_balancer lb2 vips '\"30.0.0.2:8000\"'\n\nOVS_WAIT_UNTIL([test \"$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | wc -l)\" = \"0\"])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Remove second LB\ncheck ovn-nbctl lb-del lb2\n\nOVS_WAIT_UNTIL([test \"$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | wc -l)\" = \"0\"])\n\n# Check that LB has CT flush disabled by default\ncheck ovn-nbctl lb-add lb1 30.0.0.1 \"172.16.1.2,172.16.1.3,172.16.1.4\"\ncheck ovn-nbctl ls-lb-add foo lb1\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])\n\n# Remove one backend\ncheck ovn-nbctl --wait=hv set load_balancer lb1 vips='\"30.0.0.1\"=\"172.16.1.2,172.16.1.3\"'\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])\n\n# Remove whole LB\ncheck ovn-nbctl --wait=hv lb-del lb1\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL and committing to conntrack])\nAT_KEYWORDS([acl])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add r1\ncheck ovn-nbctl lrp-add r1 r1_s1 00:de:ad:fe:00:01 173.0.1.1/24\ncheck ovn-nbctl lrp-add r1 r1_s2 00:de:ad:fe:00:02 173.0.2.1/24\n\ncheck ovn-nbctl ls-add s1\ncheck ovn-nbctl lsp-add s1 s1_r1\ncheck ovn-nbctl lsp-set-type s1_r1 router\ncheck ovn-nbctl lsp-set-addresses s1_r1 router\ncheck ovn-nbctl lsp-set-options s1_r1 router-port=r1_s1\n\ncheck ovn-nbctl ls-add s2\ncheck ovn-nbctl lsp-add s2 s2_r1\ncheck ovn-nbctl lsp-set-type s2_r1 router\ncheck ovn-nbctl lsp-set-addresses s2_r1 router\ncheck ovn-nbctl lsp-set-options s2_r1 router-port=r1_s2\n\ncheck ovn-nbctl lsp-add s1 vm1\ncheck ovn-nbctl lsp-set-addresses vm1 \"00:de:ad:01:00:01 173.0.1.2\"\n\ncheck ovn-nbctl lsp-add s2 vm2\ncheck ovn-nbctl lsp-set-addresses vm2 \"00:de:ad:01:00:02 173.0.2.2\"\n\ncheck ovn-nbctl lsp-add s2 vm3\ncheck ovn-nbctl lsp-set-addresses vm3 \"00:de:ad:01:00:03 173.0.2.3\"\n\ncheck ovn-nbctl lb-add lb1 30.0.0.1:80 173.0.2.2:80 udp\ncheck ovn-nbctl lb-add lb2 20.0.0.1:80 173.0.1.2:80 udp\ncheck ovn-nbctl lb-add lb1 30.0.0.1 173.0.2.2\ncheck ovn-nbctl lb-add lb2 173.0.2.250 173.0.1.3\ncheck ovn-nbctl ls-lb-add s1 lb1\ncheck ovn-nbctl ls-lb-add s2 lb2\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"173.0.1.2/24\", \"00:de:ad:01:00:01\", \\\n         \"173.0.1.1\")\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"173.0.2.2/24\", \"00:de:ad:01:00:02\", \\\n         \"173.0.2.1\")\nADD_NAMESPACES(vm3)\nADD_VETH(vm3, vm3, br-int, \"173.0.2.250/24\", \"00:de:ad:01:00:03\", \\\n         \"173.0.2.1\")\n\ncheck ovn-nbctl acl-add s1 from-lport 1001 \"ip\" allow\ncheck ovn-nbctl acl-add s1 to-lport 1002 \"ip\" allow\ncheck ovn-nbctl acl-add s2 from-lport 1003 \"ip\" allow\ncheck ovn-nbctl acl-add s2 to-lport 1004 \"ip\" allow\ncheck ovn-nbctl --wait=hv sync\nAS_BOX([initial ping])\n# Send ping in background. Same ping, same flow throughout the test\non_exit 'kill $(pidof ping)'\nNS_EXEC([vm1], [ping -c 10000 -i 0.1 30.0.0.1 > icmp.txt &])\n\n# Check for conntrack entries\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(173.0.1.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=173.0.1.2,dst=173.0.2.2,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=2\n])\n\n# Now check for multiple ct_commits\novs-appctl dpctl/dump-flows > dp_flows\nzone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep vm1 | cut -d ' ' -f2)\nAT_CHECK([test 1 = `cat dp_flows | grep \"commit,zone=$zone_id\" | wc -l`])\n\ncheck ovn-nbctl acl-del s1 from-lport 1001 \"ip\"\ncheck ovn-nbctl acl-del s1 to-lport 1002 \"ip\"\ncheck ovn-nbctl acl-del s2 from-lport 1003 \"ip\"\ncheck ovn-nbctl acl-del s2 to-lport 1004 \"ip\"\n\nAS_BOX([acl drop echo request])\ncheck ovn-nbctl --log --severity=alert --name=drop-flow-s1 acl-add s1 to-lport 2001 icmp4 drop\n# acl-drop to-lport s1 apply to traffic from s1 to vm1 and s1 to r1.\ncheck ovn-nbctl --wait=hv sync\n\n# Check that traffic is blocked\n# Wait for some packets to hit the rule to avoid potential race conditions. Then count packets.\nOVS_WAIT_UNTIL([test `cat ovn-controller.log | grep acl_log | grep -c drop-flow-s1` -gt \"0\"])\ntotal_icmp_pkts=$(cat icmp.txt | grep ttl | wc -l)\n\n# Wait some time and check whether packets went through. In the worse race condition, the sleep is too short\n# and this test will still succeed.\nsleep 1\nOVS_WAIT_UNTIL([\n        total_icmp1_pkts=$(cat icmp.txt | grep ttl | wc -l)\n        test \"${total_icmp1_pkts}\" -eq \"${total_icmp_pkts}\"\n])\n\nAS_BOX([acl allow-related echo request])\ncheck ovn-nbctl acl-add s1 to-lport 2002 \"icmp4 && ip4.src == 173.0.1.2\" allow-related\n# This rule has higher priority than to-lport 2001 icmp4 drop.\n# So traffic from s1 (w/ src=173.0.1.2) to r1 should be accepted\n# (return) traffic from s1 to vm1 should be accepted as return traffic\ncheck ovn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([\n        total_icmp1_pkts=$(cat icmp.txt | grep ttl | wc -l)\n        test \"${total_icmp1_pkts}\" -gt \"${total_icmp_pkts}\"\n])\n\n# Check we did not break handling acl-drop for existing flows\nAS_BOX([acl drop echo request in s2])\ncheck ovn-nbctl acl-del s1 to-lport 2001 icmp4\ncheck ovn-nbctl --log --severity=alert --name=drop-flow-s2 acl-add s2 to-lport 2001 icmp4 drop\ncheck ovn-nbctl --wait=hv sync\n\nOVS_WAIT_UNTIL([test `cat ovn-controller.log | grep acl_log | grep -c drop-flow-s2` -gt \"0\"])\n\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\n      sed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl\nicmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>\n])\ntotal_icmp_pkts=$(cat icmp.txt | grep ttl | wc -l)\n\n# Allow ping again\nAS_BOX([acl allow echo request in s2])\ncheck ovn-nbctl acl-add s2 to-lport 2005 icmp4 allow\ncheck ovn-nbctl --wait=hv sync\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=2\n])\nOVS_WAIT_UNTIL([\n        total_icmp1_pkts=$(cat icmp.txt | grep ttl | wc -l)\n        test \"${total_icmp1_pkts}\" -gt \"${total_icmp_pkts}\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\n# This tests port->up/down and ovn-installed after adding and removing Ports and Interfaces.\n# 3 Conditions x 3 tests:\n# - 3 Conditions:\n#   - In normal conditions\n#   - Remove interface while starting and stopping SB and Controller\n#   - Remove and add back interface while starting and stopping SB and Controller\n# - 3 tests:\n#   - Add/Remove Logical Port\n#   - Add/Remove iface-id\n#   - Add/Remove Interface\n# Each tests/conditions checks for\n# - Port_binding->chassis\n# - Port up or down\n# - ovn-installed\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ovn-install on slow ovsdb])\nAT_KEYWORDS([ovn-install])\n\nOVS_TRAFFIC_VSWITCHD_START()\n# Restart ovsdb-server, this time with tcp\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\nstart_daemon ovsdb-server --remote=punix:\"$OVS_RUNDIR\"/db.sock --remote=ptcp:0:127.0.0.1\n\novn_start\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nPARSE_LISTENING_PORT([$ovs_base/ovsdb-server.log], [TCP_PORT])\nstart_daemon ovn-controller tcp:127.0.0.1:$TCP_PORT\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl set Logical_Switch ls1 other_config:subnet=10.1.0.0/16\n\ncheck ovn-nbctl --wait=hv sync\n\nadd_logical_ports() {\n  echo Adding logical ports\n  check ovn-nbctl lsp-add ls1 lsp1\n  check ovn-nbctl lsp-add ls1 lsp2\n}\n\nremove_logical_ports() {\n  echo Removing logical ports\n  check ovn-nbctl lsp-del lsp1\n  check ovn-nbctl lsp-del lsp2\n}\n\nadd_ovs_interface() {\n  echo Adding interface $1 $2\n  ovs-vsctl --no-wait -- add-port br-int $1 \\\n                      -- set Interface $1 external_ids:iface-id=$2 \\\n                      -- set Interface $1 type=internal\n}\nadd_ovs_interfaces() {\n  add_ovs_interface vif1 lsp1\n  add_ovs_interface vif2 lsp2\n}\nremove_ovs_interface() {\n  echo Removing interface $1\n  check ovs-vsctl --no-wait -- del-port $1\n}\nremove_ovs_interfaces() {\n  remove_ovs_interface vif1\n  remove_ovs_interface vif2\n}\nadd_iface_ids() {\n  echo Adding iface-id vif1 lsp1\n  ovs-vsctl --no-wait -- set Interface vif1 external_ids:iface-id=lsp1\n  echo Adding iface-id vif2 lsp2\n  ovs-vsctl --no-wait -- set Interface vif2 external_ids:iface-id=lsp2\n}\nremove_iface_id() {\n  echo Removing iface-id $1\n  check ovs-vsctl remove Interface $1 external_ids iface-id\n}\nremove_iface_ids() {\n  remove_iface_id vif1\n  remove_iface_id vif2\n}\nwait_for_local_bindings() {\n  OVS_WAIT_UNTIL(\n      [test `ovs-appctl -t ovn-controller debug/dump-local-bindings | grep interface | wc -l` -eq 2],\n      [kill -CONT $(cat ovn-sb/ovsdb-server.pid)]\n  )\n}\nsleep_sb() {\n  echo SB going to sleep\n  AT_CHECK([kill -STOP $(cat ovn-sb/ovsdb-server.pid)])\n}\nwake_up_sb() {\n  echo SB waking up\n  AT_CHECK([kill -CONT $(cat ovn-sb/ovsdb-server.pid)])\n}\nsleep_controller() {\n  echo Controller going to sleep\n  ovn-appctl debug/pause\n  OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) = \"xpaused\"])\n}\n\nstop_ovsdb_controller_updates() {\n  TCP_PORT=$1\n  echo Stopping updates from ovn-controller to ovsdb using port $TCP_PORT\n  on_exit 'iptables -C INPUT -p tcp --destination-port $TCP_PORT -j DROP 2>/dev/null && iptables -D INPUT -p tcp --destination-port $TCP_PORT -j DROP'\n  iptables -A INPUT -p tcp --destination-port $TCP_PORT -j DROP\n}\nrestart_ovsdb_controller_updates() {\n  TCP_PORT=$1\n  echo Restarting updates from ovn-controller to ovsdb\n  iptables -D INPUT -p tcp --destination-port $TCP_PORT  -j DROP\n}\nwake_up_controller() {\n  echo Controller waking up\n  ovn-appctl debug/resume\n}\nensure_controller_run() {\n# We want to make sure controller could run at least one full loop.\n# We can't use wait=hv as sb might be sleeping.\n# Use 2 ovn-appctl to guarentee that ovn-controller run the full loop, and not just the unixctl handling\n  OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) = \"xrunning\"])\n  OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) = \"xrunning\"])\n}\nsleep_ovsdb() {\n  echo OVSDB going to sleep\n  AT_CHECK([kill -STOP $(cat ovsdb-server.pid)])\n}\nwake_up_ovsdb() {\n  echo OVSDB waking up\n  AT_CHECK([kill -CONT $(cat ovsdb-server.pid)])\n}\ncheck_ovn_installed() {\n  OVS_WAIT_UNTIL([test `ovs-vsctl get Interface vif1 external_ids:ovn-installed` = '\"true\"'])\n  OVS_WAIT_UNTIL([test `ovs-vsctl get Interface vif2 external_ids:ovn-installed` = '\"true\"'])\n}\ncheck_ovn_uninstalled() {\n  OVS_WAIT_UNTIL([test x`ovs-vsctl get Interface vif2 external_ids:ovn-installed` = x])\n  OVS_WAIT_UNTIL([test x`ovs-vsctl get Interface vif1 external_ids:ovn-installed` = x])\n}\ncheck_ports_up() {\n  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp1 up` = 'true'])\n  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp2 up` = 'true'])\n}\ncheck_ports_down() {\n  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp1 up` = 'false'])\n  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp2 up` = 'false'])\n}\n\ncheck_ports_bound() {\n  ch=$(fetch_column Chassis _uuid name=hv1)\n  wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch\n  wait_row_count Port_Binding 1 logical_port=lsp2 chassis=$ch\n}\ncheck_ports_unbound() {\n  wait_column \"\" Port_Binding chassis logical_port=lsp1\n  wait_column \"\" Port_Binding chassis logical_port=lsp2\n}\nadd_logical_ports\nadd_ovs_interfaces\nwait_for_local_bindings\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n############################################################\n########## Remove interface while removing iface-id ########\n############################################################\nAS_BOX([\"Remove interface while removing iface-id\"])\nstop_ovsdb_controller_updates $TCP_PORT\nremove_iface_id vif1\nensure_controller_run\n# OVSDB should be seen as ro now\nremove_iface_id vif2\nensure_controller_run\n# Controller delaying ovn-install removal for vif2 as ovsdb ro\nsleep_controller\nrestart_ovsdb_controller_updates $TCP_PORT\nremove_ovs_interface vif2\n# vif2, for which we want to remove ovn-install, is deleted\nwake_up_controller\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\nadd_ovs_interface vif2 lsp2\nadd_iface_ids\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\n############################################################\n################### Add/Remove iface-id ####################\n############################################################\nAS_BOX([\"iface-id removal and added back (no sleeping sb or controller)\"])\nremove_iface_ids\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\nadd_iface_ids\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\n\nAS_BOX([\"iface-id removal\"])\nsleep_sb\nremove_iface_ids\nensure_controller_run\nsleep_controller\nwake_up_sb\nwake_up_controller\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\nadd_iface_ids\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"iface-id removal 2\"])\n# Block IDL from ovn-controller to OVSDB\nstop_ovsdb_controller_updates $TCP_PORT\nremove_iface_id vif2\nensure_controller_run\n\n# OVSDB should now be seen as read-only by ovn-controller\nremove_iface_id vif1\nensure_controller_run\n\n# Restart connection from ovn-controller to OVSDB\nrestart_ovsdb_controller_updates $TCP_PORT\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\n\nadd_iface_ids\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"iface-id removal and added back\"])\nsleep_sb\nremove_iface_ids\nensure_controller_run\nsleep_controller\nadd_iface_ids\nwake_up_sb\nwake_up_controller\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\n############################################################\n###################### Add/Remove Interface ################\n############################################################\nAS_BOX([\"Interface removal and added back (no sleeping sb or controller)\"])\nremove_ovs_interfaces\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\nadd_ovs_interfaces\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"Interface removal\"])\nsleep_sb\nremove_ovs_interfaces\nensure_controller_run\nsleep_controller\nwake_up_sb\nwake_up_controller\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\nadd_ovs_interfaces\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"Interface removal and added back\"])\nsleep_sb\nremove_ovs_interfaces\nensure_controller_run\nsleep_controller\nadd_ovs_interfaces\nwake_up_sb\nwake_up_controller\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\ncheck ovn-nbctl --wait=hv sync\n############################################################\n###################### Add/Remove Logical Port #############\n############################################################\nAS_BOX([\"Logical port removal and added back (no sleeping sb or controller)\"])\nremove_logical_ports\ncheck_ovn_uninstalled\ncheck_ports_unbound\nsleep_ovsdb\nadd_logical_ports\nensure_controller_run\nwake_up_ovsdb\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"Logical port removal\"])\nsleep_sb\nremove_logical_ports\nensure_controller_run\nsleep_controller\nwake_up_sb\nwake_up_controller\ncheck_ovn_uninstalled\ncheck_ports_unbound\nadd_logical_ports\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"Logical port removal and added back\"])\nsleep_sb\nremove_logical_ports\nensure_controller_run\nsleep_controller\nadd_logical_ports\nwake_up_sb\nwake_up_controller\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ovn mirroring])\nAT_KEYWORDS([mirror])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-mirror])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novs-ofctl add-flow br-mirror action=normal\n\novn-nbctl create Logical_Router name=R1 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 2001::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 2002::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"2001::2/64\", \"f0:00:00:01:02:03\", \\\n         \"2001::1\", \"nodad\", \"192.168.1.2/24\", \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2 2001::2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"2002::2/64\", \"f0:00:00:01:02:05\", \\\n         \"2002::1\", \"nodad\", \"192.168.2.2/24\", \"192.168.2.1\")\novn-nbctl --wait=hv lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2 2002::2\"\n\novn-nbctl mirror-add mirror0 gre 1 to-lport 172.16.0.100\novn-nbctl lsp-attach-mirror bar1 mirror0\n\nOVN_POPULATE_ARP\ncheck ovn-nbctl --wait=hv sync\n\nADD_NAMESPACES(mirror)\nADD_VETH(mirror, mirror, br-mirror, \"2003::b/64\", \"f0:00:00:01:07:06\", \\\n         \"2003::1\", \"nodad\", \"172.16.0.100/24\", \"172.16.0.1\")\nAT_CHECK([ip addr add 172.16.0.101/24 dev br-mirror])\nAT_CHECK([ip addr add 2003::a/64 dev br-mirror nodad])\nAT_CHECK([ip link set dev br-mirror up])\n\nNS_CHECK_EXEC([mirror], [tcpdump -l -c 3 -neei mirror proto GRE > gre_mirror4.pcap 2>gre_mirror4_error &])\nOVS_WAIT_UNTIL([grep \"listening\" gre_mirror4_error])\n\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\nOVS_WAIT_UNTIL([\n    n_packets=$(grep \"GRE\" -c gre_mirror4.pcap)\n    test \"${n_packets}\" = \"3\"\n])\n\nkillall tcpdump\n\novn-nbctl mirror-del mirror0\novn-nbctl mirror-add mirror1 gre 2 to-lport 2003::b\n\novn-nbctl --wait=hv lsp-attach-mirror bar1 mirror1\n\nNS_CHECK_EXEC([mirror], [tcpdump -l -c 3 -neei mirror proto GRE > gre_mirror6.pcap 2>gre_mirror6_error &])\nOVS_WAIT_UNTIL([grep \"listening\" gre_mirror6_error])\n\nNS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 2002::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_WAIT_UNTIL([\n    n_packets=$(grep \"GRE\" -c gre_mirror6.pcap)\n    test \"${n_packets}\" = \"3\"\n])\n\nkillall tcpdump\n\novn-nbctl mirror-del mirror1\novn-nbctl mirror-add mirror2 erspan 3 to-lport 172.16.0.100\novn-nbctl --wait=hv lsp-attach-mirror bar1 mirror2\n\nNS_CHECK_EXEC([mirror], [tcpdump -l -c 3 -neei mirror ip[[22:2]]=0x88be > erspan_mirror4.pcap 2>erspan_mirror4_error &])\nOVS_WAIT_UNTIL([grep \"listening\" erspan_mirror4_error])\n\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\nOVS_WAIT_UNTIL([\n    n_packets=$(grep \"gre-proto-0x88be\" -c erspan_mirror4.pcap)\n    test \"${n_packets}\" = \"3\"\n])\n\nkillall tcpdump\n\novn-nbctl mirror-del mirror2\novn-nbctl mirror-add mirror3 erspan 4 to-lport 2003::b\novn-nbctl --wait=hv lsp-attach-mirror bar1 mirror3\n\nNS_CHECK_EXEC([mirror], [tcpdump -l -c 3 -neei mirror ip6[[42:2]]=0x88be > erspan_mirror6.pcap 2>erspan_mirror6_error &])\nOVS_WAIT_UNTIL([grep \"listening\" erspan_mirror6_error])\n\nNS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 2002::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\nOVS_WAIT_UNTIL([\n    n_packets=$(grep \"gre-proto-0x88be\" -c erspan_mirror6.pcap)\n    test \"${n_packets}\" = \"3\"\n])\n\nkillall tcpdump\n\nuuid=$(fetch_column nb:mirror _uuid name=\"mirror3\")\novn-nbctl --wait=hv set mirror $uuid type=gre\n\nNS_CHECK_EXEC([mirror], [tcpdump -c 3 -l -neei mirror proto GRE > gre_mirror6.pcap 2>gre_mirror6_error &])\nOVS_WAIT_UNTIL([grep \"listening\" gre_mirror6_error])\n\nNS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 2002::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_WAIT_UNTIL([\n    n_packets=$(grep \"GRE\" -c gre_mirror6.pcap)\n    test \"${n_packets}\" = \"3\"\n])\n\nkillall tcpdump\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancer with localnet port])\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-phys], [set Bridge br-phys fail-mode=standalone])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add ro\ncheck ovn-nbctl lrp-add ro ro-sw 00:00:00:00:00:01 192.168.0.1/24\ncheck ovn-nbctl lrp-add ro ro-pub 00:00:00:00:01:01 10.0.0.1/24\n\ncheck ovn-nbctl ls-add sw\ncheck ovn-nbctl lsp-add sw sw-vm1 \\\n    -- lsp-set-addresses sw-vm1 \"00:00:00:00:00:02 192.168.0.2\"\ncheck ovn-nbctl lsp-add sw sw-ro \\\n    -- lsp-set-type sw-ro router \\\n    -- lsp-set-addresses sw-ro router \\\n    -- lsp-set-options sw-ro router-port=ro-sw\n\ncheck ovn-nbctl ls-add pub\ncheck ovn-nbctl lsp-add pub sw-ln \\\n    -- lsp-set-type sw-ln localnet \\\n    -- lsp-set-addresses sw-ln unknown \\\n    -- lsp-set-options sw-ln network_name=phys\ncheck ovn-nbctl lsp-add pub pub-ro \\\n    -- lsp-set-type pub-ro router \\\n    -- lsp-set-addresses pub-ro router \\\n    -- lsp-set-options pub-ro router-port=ro-pub\n\ncheck ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys\n\nADD_NAMESPACES(sw-vm1)\nADD_VETH(sw-vm1, sw-vm1, br-int, \"192.168.0.2/24\", \"00:00:00:00:00:02\", \\\n         \"192.168.0.1\")\n\nADD_NAMESPACES(ln)\nADD_VETH(ln, ln, br-phys, \"10.0.0.2/24\", \"00:00:00:00:01:02\", \\\n         \"10.0.0.1\")\n\n# We have the basic network set up. Now let's add a load balancer\n# on the \"pub\" logical switch.\n\ncheck ovn-nbctl lb-add ln-lb 172.16.0.1:80 192.168.0.2:80 tcp\ncheck ovn-nbctl ls-lb-add pub ln-lb\ncheck ovn-nbctl --wait=hv sync\n\n# Add a route so that the localnet port can reach the load balancer\n# VIP.\nNS_CHECK_EXEC([ln], [ip route add 172.16.0.1 via 10.0.0.1])\nNS_CHECK_EXEC([ln], [ip route add 192.168.0.0/24 via 10.0.0.1])\n\nOVS_START_L7([sw-vm1], [http])\n\nNS_CHECK_EXEC([ln], [wget 172.16.0.1 -t 5 -T 1 --retry-connrefused -v -o wget.log])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.0.2,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Traffic to router port via LLA])\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-phys], [set Bridge br-phys fail-mode=standalone])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-ls0 00:00:00:00:00:01 fd00::1/64\n\ncheck ovn-nbctl ls-add ls0\ncheck ovn-nbctl lsp-add ls0 vif0 \\\n    -- lsp-set-addresses vif0 \"00:00:00:00:00:02 fd00::2\"\ncheck ovn-nbctl lsp-add ls0 ls0-lr0 \\\n    -- lsp-set-type ls0-lr0 router \\\n    -- lsp-set-addresses ls0-lr0 router \\\n    -- lsp-set-options ls0-lr0 router-port=lr0-ls0\n\nADD_NAMESPACES(vif0)\nADD_VETH(vif0, vif0, br-int, \"fd00::2/64\", \"00:00:00:00:00:02\", \"fd00::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vif0 ip a | grep fe80:: | grep tentative)\" = \"\"])\n\ncheck ovn-nbctl set logical_router lr0 options:always_learn_from_arp_request=false\n\nOVN_POPULATE_ARP\nwait_for_ports_up\ncheck ovn-nbctl --wait=sb sync\n\nNS_CHECK_EXEC([vif0], [ping -q -c 3 -i 0.3 -w 2 fe80::200:ff:fe00:1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\ncheck_row_count mac_binding 1 mac=\\\"00:00:00:00:00:02\\\"\novn-sbctl --all destroy mac_binding\n\novn-nbctl --wait=hv set logical_router lr0 options:always_learn_from_arp_request=true\n\nNS_CHECK_EXEC([vif0], [ping -q -c 3 -i 0.3 -w 2 fe80::200:ff:fe00:1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\ncheck_row_count mac_binding 1 mac=\\\"00:00:00:00:00:02\\\"\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n"], "fixing_code": ["/* Copyright (c) 2021, Red Hat, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <config.h>\n#include <stdlib.h>\n\n#include \"openvswitch/shash.h\"\n#include \"db-ctl-base.h\"\n#include \"smap.h\"\n#include \"lib/ovn-nb-idl.h\"\n#include \"lib/copp.h\"\n\nstatic char *copp_proto_names[COPP_PROTO_MAX] = {\n    [COPP_ARP]           = \"arp\",\n    [COPP_ARP_RESOLVE]   = \"arp-resolve\",\n    [COPP_DHCPV4_OPTS]   = \"dhcpv4-opts\",\n    [COPP_DHCPV6_OPTS]   = \"dhcpv6-opts\",\n    [COPP_DNS]           = \"dns\",\n    [COPP_EVENT_ELB]     = \"event-elb\",\n    [COPP_ICMP4_ERR]     = \"icmp4-error\",\n    [COPP_ICMP6_ERR]     = \"icmp6-error\",\n    [COPP_IGMP]          = \"igmp\",\n    [COPP_ND_NA]         = \"nd-na\",\n    [COPP_ND_NS]         = \"nd-ns\",\n    [COPP_ND_NS_RESOLVE] = \"nd-ns-resolve\",\n    [COPP_ND_RA_OPTS]    = \"nd-ra-opts\",\n    [COPP_TCP_RESET]     = \"tcp-reset\",\n    [COPP_REJECT]        = \"reject\",\n    [COPP_SVC_MONITOR]   = \"svc-monitor\",\n    [COPP_BFD]           = \"bfd\",\n};\n\nstatic const char *\ncopp_proto_get_name(enum copp_proto proto)\n{\n    if (proto >= COPP_PROTO_MAX) {\n        return \"<Invalid control protocol ID>\";\n    }\n    return copp_proto_names[proto];\n}\n\nconst char *\ncopp_meter_get(enum copp_proto proto, const struct nbrec_copp *copp,\n               const struct shash *meter_groups)\n{\n    if (!copp || proto >= COPP_PROTO_MAX) {\n        return NULL;\n    }\n\n    const char *meter = smap_get(&copp->meters, copp_proto_names[proto]);\n\n    if (meter && shash_find(meter_groups, meter)) {\n        return meter;\n    }\n\n    return NULL;\n}\n\nvoid\ncopp_meter_list(struct ctl_context *ctx, const struct nbrec_copp *copp)\n{\n    if (!copp) {\n        return;\n    }\n\n    struct smap_node *node;\n\n    SMAP_FOR_EACH (node, &copp->meters) {\n        ds_put_format(&ctx->output, \"%s: %s\\n\", node->key, node->value);\n    }\n}\n\nconst struct nbrec_copp *\ncopp_meter_add(struct ctl_context *ctx, const struct nbrec_copp *copp,\n               const char *proto_name, const char *meter)\n{\n    if (!copp) {\n        copp = nbrec_copp_insert(ctx->txn);\n    }\n\n    struct smap meters;\n    smap_init(&meters);\n    smap_clone(&meters, &copp->meters);\n    smap_replace(&meters, proto_name, meter);\n    nbrec_copp_set_meters(copp, &meters);\n    smap_destroy(&meters);\n\n    return copp;\n}\n\nvoid\ncopp_meter_del(const struct nbrec_copp *copp, const char *proto_name)\n{\n    if (!copp) {\n        return;\n    }\n\n    if (proto_name) {\n        if (smap_get(&copp->meters, proto_name)) {\n            struct smap meters;\n            smap_init(&meters);\n            smap_clone(&meters, &copp->meters);\n            smap_remove(&meters, proto_name);\n            nbrec_copp_set_meters(copp, &meters);\n            smap_destroy(&meters);\n        }\n        if (smap_is_empty(&copp->meters)) {\n            nbrec_copp_delete(copp);\n        }\n    } else {\n        nbrec_copp_delete(copp);\n    }\n}\n\nchar *\ncopp_proto_validate(const char *proto_name)\n{\n    for (size_t i = COPP_PROTO_FIRST; i < COPP_PROTO_MAX; i++) {\n        if (!strcmp(proto_name, copp_proto_get_name(i))) {\n            return NULL;\n        }\n    }\n\n    struct ds usage = DS_EMPTY_INITIALIZER;\n\n    ds_put_cstr(&usage, \"Invalid control protocol. Allowed values: \");\n    for (size_t i = COPP_PROTO_FIRST; i < COPP_PROTO_MAX; i++) {\n        ds_put_format(&usage, \"%s, \", copp_proto_get_name(i));\n    }\n    ds_chomp(&usage, ' ');\n    ds_chomp(&usage, ',');\n    ds_put_cstr(&usage, \".\");\n\n    return ds_steal_cstr(&usage);\n}\n\nchar * OVS_WARN_UNUSED_RESULT\ncopp_by_name_or_uuid(struct ctl_context *ctx, const char *id, bool must_exist,\n                     const struct nbrec_copp **copp_p)\n{\n    const struct nbrec_copp *copp = NULL;\n    struct uuid uuid;\n    bool is_uuid = uuid_from_string(&uuid, id);\n\n    *copp_p = NULL;\n    if (is_uuid) {\n        copp = nbrec_copp_get_for_uuid(ctx->idl, &uuid);\n    }\n\n    if (!copp) {\n        const struct nbrec_copp *iter;\n        NBREC_COPP_FOR_EACH (iter, ctx->idl) {\n            if (!strcmp(iter->name, id)) {\n                copp = iter;\n                break;\n            }\n        }\n    }\n\n    if (!copp && must_exist) {\n        return xasprintf(\"%s: copp %s not found\",\n                         id, is_uuid ? \"UUID\" : \"name\");\n    }\n\n    *copp_p = copp;\n    return NULL;\n}\n", "/* Copyright (c) 2021, Red Hat, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef OVN_COPP_H\n#define OVN_COPP_H 1\n\n/*\n * Control plane protection - metered actions.\n */\nenum copp_proto {\n    COPP_PROTO_FIRST,\n    COPP_ARP = COPP_PROTO_FIRST,\n    COPP_ARP_RESOLVE,\n    COPP_DHCPV4_OPTS,\n    COPP_DHCPV6_OPTS,\n    COPP_DNS,\n    COPP_EVENT_ELB,\n    COPP_ICMP4_ERR,\n    COPP_ICMP6_ERR,\n    COPP_IGMP,\n    COPP_ND_NA,\n    COPP_ND_NS,\n    COPP_ND_NS_RESOLVE,\n    COPP_ND_RA_OPTS,\n    COPP_TCP_RESET,\n    COPP_BFD,\n    COPP_REJECT,\n    COPP_SVC_MONITOR,\n    COPP_PROTO_MAX,\n    COPP_PROTO_INVALID = COPP_PROTO_MAX,\n};\n\nstruct nbrec_copp;\nstruct ctl_context;\n\nconst char *copp_meter_get(enum copp_proto proto,\n                           const struct nbrec_copp *copp,\n                           const struct shash *meter_groups);\n\nvoid copp_meter_list(struct ctl_context *ctx, const struct nbrec_copp *copp);\nconst struct nbrec_copp *\ncopp_meter_add(struct ctl_context *ctx, const struct nbrec_copp *copp,\n               const char *proto_name, const char *meter);\nvoid\ncopp_meter_del(const struct nbrec_copp *copp, const char *proto_name);\nchar * copp_proto_validate(const char *proto_name);\nchar * OVS_WARN_UNUSED_RESULT\ncopp_by_name_or_uuid(struct ctl_context *ctx, const char *id, bool must_exist,\n                     const struct nbrec_copp **copp_p);\n\n#endif /* lib/copp.h */\n", "/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at:\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <config.h>\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#include \"debug.h\"\n#include \"bitmap.h\"\n#include \"dirs.h\"\n#include \"ipam.h\"\n#include \"openvswitch/dynamic-string.h\"\n#include \"hash.h\"\n#include \"hmapx.h\"\n#include \"openvswitch/hmap.h\"\n#include \"openvswitch/json.h\"\n#include \"ovn/lex.h\"\n#include \"lib/chassis-index.h\"\n#include \"lib/ip-mcast-index.h\"\n#include \"lib/static-mac-binding-index.h\"\n#include \"lib/copp.h\"\n#include \"lib/mcast-group-index.h\"\n#include \"lib/ovn-l7.h\"\n#include \"lib/ovn-nb-idl.h\"\n#include \"lib/ovn-sb-idl.h\"\n#include \"lib/ovn-util.h\"\n#include \"lib/lb.h\"\n#include \"memory.h\"\n#include \"northd.h\"\n#include \"lib/ovn-parallel-hmap.h\"\n#include \"ovn/actions.h\"\n#include \"ovn/features.h\"\n#include \"ovn/logical-fields.h\"\n#include \"packets.h\"\n#include \"simap.h\"\n#include \"smap.h\"\n#include \"sset.h\"\n#include \"svec.h\"\n#include \"stopwatch.h\"\n#include \"lib/stopwatch-names.h\"\n#include \"stream.h\"\n#include \"timeval.h\"\n#include \"util.h\"\n#include \"uuid.h\"\n#include \"ovs-thread.h\"\n#include \"openvswitch/vlog.h\"\n\nVLOG_DEFINE_THIS_MODULE(northd);\n\nstatic bool controller_event_en;\nstatic bool lflow_hash_lock_initialized = false;\n\nstatic bool check_lsp_is_up;\n\nstatic bool install_ls_lb_from_router;\n\n/* MAC allocated for service monitor usage. Just one mac is allocated\n * for this purpose and ovn-controller's on each chassis will make use\n * of this mac when sending out the packets to monitor the services\n * defined in Service_Monitor Southbound table. Since these packets\n * all locally handled, having just one mac is good enough. */\nstatic char svc_monitor_mac[ETH_ADDR_STRLEN + 1];\nstatic struct eth_addr svc_monitor_mac_ea;\n\n/* If this option is 'true' northd will make use of ct.inv match fields.\n * Otherwise, it will avoid using it.  The default is true. */\nstatic bool use_ct_inv_match = true;\n\n/* If this option is 'true' northd will implicitly add a lowest-priority\n * drop rule in the ACL stage of logical switches that have at least one\n * ACL.\n */\nstatic bool default_acl_drop;\n\n#define MAX_OVN_TAGS 4096\n\f\n/* Pipeline stages. */\n\n/* The two purposes for which ovn-northd uses OVN logical datapaths. */\nenum ovn_datapath_type {\n    DP_SWITCH,                  /* OVN logical switch. */\n    DP_ROUTER                   /* OVN logical router. */\n};\n\n/* Returns an \"enum ovn_stage\" built from the arguments.\n *\n * (It's better to use ovn_stage_build() for type-safety reasons, but inline\n * functions can't be used in enums or switch cases.) */\n#define OVN_STAGE_BUILD(DP_TYPE, PIPELINE, TABLE) \\\n    (((DP_TYPE) << 9) | ((PIPELINE) << 8) | (TABLE))\n\n/* A stage within an OVN logical switch or router.\n *\n * An \"enum ovn_stage\" indicates whether the stage is part of a logical switch\n * or router, whether the stage is part of the ingress or egress pipeline, and\n * the table within that pipeline.  The first three components are combined to\n * form the stage's full name, e.g. S_SWITCH_IN_PORT_SEC_L2,\n * S_ROUTER_OUT_DELIVERY. */\nenum ovn_stage {\n#define PIPELINE_STAGES                                                   \\\n    /* Logical switch ingress stages. */                                  \\\n    PIPELINE_STAGE(SWITCH, IN,  CHECK_PORT_SEC, 0, \"ls_in_check_port_sec\")   \\\n    PIPELINE_STAGE(SWITCH, IN,  APPLY_PORT_SEC, 1, \"ls_in_apply_port_sec\")   \\\n    PIPELINE_STAGE(SWITCH, IN,  LOOKUP_FDB ,    2, \"ls_in_lookup_fdb\")    \\\n    PIPELINE_STAGE(SWITCH, IN,  PUT_FDB,        3, \"ls_in_put_fdb\")       \\\n    PIPELINE_STAGE(SWITCH, IN,  PRE_ACL,        4, \"ls_in_pre_acl\")       \\\n    PIPELINE_STAGE(SWITCH, IN,  PRE_LB,         5, \"ls_in_pre_lb\")        \\\n    PIPELINE_STAGE(SWITCH, IN,  PRE_STATEFUL,   6, \"ls_in_pre_stateful\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  ACL_HINT,       7, \"ls_in_acl_hint\")      \\\n    PIPELINE_STAGE(SWITCH, IN,  ACL,            8, \"ls_in_acl\")           \\\n    PIPELINE_STAGE(SWITCH, IN,  QOS_MARK,       9, \"ls_in_qos_mark\")      \\\n    PIPELINE_STAGE(SWITCH, IN,  QOS_METER,     10, \"ls_in_qos_meter\")     \\\n    PIPELINE_STAGE(SWITCH, IN,  LB_AFF_CHECK,  11, \"ls_in_lb_aff_check\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  LB,            12, \"ls_in_lb\")            \\\n    PIPELINE_STAGE(SWITCH, IN,  LB_AFF_LEARN,  13, \"ls_in_lb_aff_learn\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  PRE_HAIRPIN,   14, \"ls_in_pre_hairpin\")   \\\n    PIPELINE_STAGE(SWITCH, IN,  NAT_HAIRPIN,   15, \"ls_in_nat_hairpin\")   \\\n    PIPELINE_STAGE(SWITCH, IN,  HAIRPIN,       16, \"ls_in_hairpin\")       \\\n    PIPELINE_STAGE(SWITCH, IN,  ACL_AFTER_LB,  17, \"ls_in_acl_after_lb\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  STATEFUL,      18, \"ls_in_stateful\")      \\\n    PIPELINE_STAGE(SWITCH, IN,  ARP_ND_RSP,    19, \"ls_in_arp_rsp\")       \\\n    PIPELINE_STAGE(SWITCH, IN,  DHCP_OPTIONS,  20, \"ls_in_dhcp_options\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  DHCP_RESPONSE, 21, \"ls_in_dhcp_response\") \\\n    PIPELINE_STAGE(SWITCH, IN,  DNS_LOOKUP,    22, \"ls_in_dns_lookup\")    \\\n    PIPELINE_STAGE(SWITCH, IN,  DNS_RESPONSE,  23, \"ls_in_dns_response\")  \\\n    PIPELINE_STAGE(SWITCH, IN,  EXTERNAL_PORT, 24, \"ls_in_external_port\") \\\n    PIPELINE_STAGE(SWITCH, IN,  L2_LKUP,       25, \"ls_in_l2_lkup\")       \\\n    PIPELINE_STAGE(SWITCH, IN,  L2_UNKNOWN,    26, \"ls_in_l2_unknown\")    \\\n                                                                          \\\n    /* Logical switch egress stages. */                                   \\\n    PIPELINE_STAGE(SWITCH, OUT, PRE_ACL,      0, \"ls_out_pre_acl\")        \\\n    PIPELINE_STAGE(SWITCH, OUT, PRE_LB,       1, \"ls_out_pre_lb\")         \\\n    PIPELINE_STAGE(SWITCH, OUT, PRE_STATEFUL, 2, \"ls_out_pre_stateful\")   \\\n    PIPELINE_STAGE(SWITCH, OUT, ACL_HINT,     3, \"ls_out_acl_hint\")       \\\n    PIPELINE_STAGE(SWITCH, OUT, ACL,          4, \"ls_out_acl\")            \\\n    PIPELINE_STAGE(SWITCH, OUT, QOS_MARK,     5, \"ls_out_qos_mark\")       \\\n    PIPELINE_STAGE(SWITCH, OUT, QOS_METER,    6, \"ls_out_qos_meter\")      \\\n    PIPELINE_STAGE(SWITCH, OUT, STATEFUL,     7, \"ls_out_stateful\")       \\\n    PIPELINE_STAGE(SWITCH, OUT, CHECK_PORT_SEC,  8, \"ls_out_check_port_sec\") \\\n    PIPELINE_STAGE(SWITCH, OUT, APPLY_PORT_SEC,  9, \"ls_out_apply_port_sec\") \\\n                                                                      \\\n    /* Logical router ingress stages. */                              \\\n    PIPELINE_STAGE(ROUTER, IN,  ADMISSION,       0, \"lr_in_admission\")    \\\n    PIPELINE_STAGE(ROUTER, IN,  LOOKUP_NEIGHBOR, 1, \"lr_in_lookup_neighbor\") \\\n    PIPELINE_STAGE(ROUTER, IN,  LEARN_NEIGHBOR,  2, \"lr_in_learn_neighbor\") \\\n    PIPELINE_STAGE(ROUTER, IN,  IP_INPUT,        3, \"lr_in_ip_input\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  UNSNAT,          4, \"lr_in_unsnat\")       \\\n    PIPELINE_STAGE(ROUTER, IN,  DEFRAG,          5, \"lr_in_defrag\")       \\\n    PIPELINE_STAGE(ROUTER, IN,  LB_AFF_CHECK,    6, \"lr_in_lb_aff_check\") \\\n    PIPELINE_STAGE(ROUTER, IN,  DNAT,            7, \"lr_in_dnat\")         \\\n    PIPELINE_STAGE(ROUTER, IN,  LB_AFF_LEARN,    8, \"lr_in_lb_aff_learn\") \\\n    PIPELINE_STAGE(ROUTER, IN,  ECMP_STATEFUL,   9, \"lr_in_ecmp_stateful\") \\\n    PIPELINE_STAGE(ROUTER, IN,  ND_RA_OPTIONS,   10, \"lr_in_nd_ra_options\") \\\n    PIPELINE_STAGE(ROUTER, IN,  ND_RA_RESPONSE,  11, \"lr_in_nd_ra_response\") \\\n    PIPELINE_STAGE(ROUTER, IN,  IP_ROUTING_PRE,  12, \"lr_in_ip_routing_pre\")  \\\n    PIPELINE_STAGE(ROUTER, IN,  IP_ROUTING,      13, \"lr_in_ip_routing\")      \\\n    PIPELINE_STAGE(ROUTER, IN,  IP_ROUTING_ECMP, 14, \"lr_in_ip_routing_ecmp\") \\\n    PIPELINE_STAGE(ROUTER, IN,  POLICY,          15, \"lr_in_policy\")          \\\n    PIPELINE_STAGE(ROUTER, IN,  POLICY_ECMP,     16, \"lr_in_policy_ecmp\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  ARP_RESOLVE,     17, \"lr_in_arp_resolve\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  CHK_PKT_LEN,     18, \"lr_in_chk_pkt_len\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  LARGER_PKTS,     19, \"lr_in_larger_pkts\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  GW_REDIRECT,     20, \"lr_in_gw_redirect\")     \\\n    PIPELINE_STAGE(ROUTER, IN,  ARP_REQUEST,     21, \"lr_in_arp_request\")     \\\n                                                                      \\\n    /* Logical router egress stages. */                               \\\n    PIPELINE_STAGE(ROUTER, OUT, CHECK_DNAT_LOCAL,   0,                       \\\n                   \"lr_out_chk_dnat_local\")                                  \\\n    PIPELINE_STAGE(ROUTER, OUT, UNDNAT,             1, \"lr_out_undnat\")      \\\n    PIPELINE_STAGE(ROUTER, OUT, POST_UNDNAT,        2, \"lr_out_post_undnat\") \\\n    PIPELINE_STAGE(ROUTER, OUT, SNAT,               3, \"lr_out_snat\")        \\\n    PIPELINE_STAGE(ROUTER, OUT, POST_SNAT,          4, \"lr_out_post_snat\")   \\\n    PIPELINE_STAGE(ROUTER, OUT, EGR_LOOP,           5, \"lr_out_egr_loop\")    \\\n    PIPELINE_STAGE(ROUTER, OUT, DELIVERY,           6, \"lr_out_delivery\")\n\n#define PIPELINE_STAGE(DP_TYPE, PIPELINE, STAGE, TABLE, NAME)   \\\n    S_##DP_TYPE##_##PIPELINE##_##STAGE                          \\\n        = OVN_STAGE_BUILD(DP_##DP_TYPE, P_##PIPELINE, TABLE),\n    PIPELINE_STAGES\n#undef PIPELINE_STAGE\n};\n\n/* Due to various hard-coded priorities need to implement ACLs, the\n * northbound database supports a smaller range of ACL priorities than\n * are available to logical flows.  This value is added to an ACL\n * priority to determine the ACL's logical flow priority. */\n#define OVN_ACL_PRI_OFFSET 1000\n\n/* Register definitions specific to switches. */\n#define REGBIT_CONNTRACK_DEFRAG   \"reg0[0]\"\n#define REGBIT_CONNTRACK_COMMIT   \"reg0[1]\"\n#define REGBIT_CONNTRACK_NAT      \"reg0[2]\"\n#define REGBIT_DHCP_OPTS_RESULT   \"reg0[3]\"\n#define REGBIT_DNS_LOOKUP_RESULT  \"reg0[4]\"\n#define REGBIT_ND_RA_OPTS_RESULT  \"reg0[5]\"\n#define REGBIT_HAIRPIN            \"reg0[6]\"\n#define REGBIT_ACL_HINT_ALLOW_NEW \"reg0[7]\"\n#define REGBIT_ACL_HINT_ALLOW     \"reg0[8]\"\n#define REGBIT_ACL_HINT_DROP      \"reg0[9]\"\n#define REGBIT_ACL_HINT_BLOCK     \"reg0[10]\"\n#define REGBIT_LKUP_FDB           \"reg0[11]\"\n#define REGBIT_HAIRPIN_REPLY      \"reg0[12]\"\n#define REGBIT_ACL_LABEL          \"reg0[13]\"\n#define REGBIT_FROM_RAMP          \"reg0[14]\"\n#define REGBIT_PORT_SEC_DROP      \"reg0[15]\"\n#define REGBIT_ACL_STATELESS      \"reg0[16]\"\n#define REGBIT_ACL_HINT_ALLOW_REL \"reg0[17]\"\n\n#define REG_ORIG_DIP_IPV4         \"reg1\"\n#define REG_ORIG_DIP_IPV6         \"xxreg1\"\n#define REG_ORIG_TP_DPORT         \"reg2[0..15]\"\n\n/* Register used to store backend ipv6 address\n * for load balancer affinity. */\n#define REG_LB_L2_AFF_BACKEND_IP6 \"xxreg0\"\n\n/* Register definitions for switches and routers. */\n\n/* Register used to store backend ipv4 address\n * for load balancer affinity. */\n#define REG_LB_AFF_BACKEND_IP4  \"reg4\"\n#define REG_LB_AFF_MATCH_PORT   \"reg8[0..15]\"\n\n/* Indicate that this packet has been recirculated using egress\n * loopback.  This allows certain checks to be bypassed, such as a\n * logical router dropping packets with source IP address equals\n * one of the logical router's own IP addresses. */\n#define REGBIT_EGRESS_LOOPBACK  \"reg9[0]\"\n/* Register to store the result of check_pkt_larger action. */\n/* This register is also used by ovn-controller in\n * OFTABLE_OUTPUT_LARGE_PKT_DETECT table, for a similar goal. */\n#define REGBIT_PKT_LARGER        \"reg9[1]\"\n#define REGBIT_LOOKUP_NEIGHBOR_RESULT \"reg9[2]\"\n#define REGBIT_LOOKUP_NEIGHBOR_IP_RESULT \"reg9[3]\"\n#define REGBIT_DST_NAT_IP_LOCAL \"reg9[4]\"\n#define REGBIT_KNOWN_ECMP_NH    \"reg9[5]\"\n#define REGBIT_KNOWN_LB_SESSION \"reg9[6]\"\n\n/* Register to store the eth address associated to a router port for packets\n * received in S_ROUTER_IN_ADMISSION.\n */\n#define REG_INPORT_ETH_ADDR \"xreg0[0..47]\"\n\n/* Register for ECMP bucket selection. */\n#define REG_ECMP_GROUP_ID       \"reg8[0..15]\"\n#define REG_ECMP_MEMBER_ID      \"reg8[16..31]\"\n\n/* Registers used for routing. */\n#define REG_NEXT_HOP_IPV4 \"reg0\"\n#define REG_NEXT_HOP_IPV6 \"xxreg0\"\n#define REG_SRC_IPV4 \"reg1\"\n#define REG_SRC_IPV6 \"xxreg1\"\n#define REG_ROUTE_TABLE_ID \"reg7\"\n\n/* Register used to store backend ipv6 address\n * for load balancer affinity. */\n#define REG_LB_L3_AFF_BACKEND_IP6  \"xxreg1\"\n\n#define REG_ORIG_TP_DPORT_ROUTER   \"reg9[16..31]\"\n\n/* Register used for setting a label for ACLs in a Logical Switch. */\n#define REG_LABEL \"reg3\"\n\n/* Register used for temporarily store ECMP eth.src to avoid masked ct_label\n * access. It doesn't really occupy registers because the content of the\n * register is saved to stack and then restored in the same flow.\n * Note: the bits must match ct_label.ecmp_reply_eth defined in\n * logical-fields.c */\n#define REG_ECMP_ETH_FULL \"xxreg1\"\n#define REG_ECMP_ETH_FIELD REG_ECMP_ETH_FULL \"[\" \\\n    OVN_CT_STR(OVN_CT_ECMP_ETH_1ST_BIT) \\\n    \"..\" \\\n    OVN_CT_STR(OVN_CT_ECMP_ETH_END_BIT) \"]\"\n\n#define FLAGBIT_NOT_VXLAN \"flags[1] == 0\"\n\n/*\n * OVS register usage:\n *\n * Logical Switch pipeline:\n * +----+----------------------------------------------+---+-----------------------------------+\n * | R0 |     REGBIT_{CONNTRACK/DHCP/DNS}              |   |                                   |\n * |    |     REGBIT_{HAIRPIN/HAIRPIN_REPLY}           |   |                                   |\n * |    | REGBIT_ACL_HINT_{ALLOW_NEW/ALLOW/DROP/BLOCK} |   |                                   |\n * |    |     REGBIT_ACL_{LABEL/STATELESS}             | X |                                   |\n * +----+----------------------------------------------+ X |                                   |\n * | R5 |                   UNUSED                     | X |       LB_L2_AFF_BACKEND_IP6       |\n * | R1 |         ORIG_DIP_IPV4 (>= IN_PRE_STATEFUL)   | R |                                   |\n * +----+----------------------------------------------+ E |                                   |\n * | R2 |         ORIG_TP_DPORT (>= IN_PRE_STATEFUL)   | G |                                   |\n * +----+----------------------------------------------+ 0 |                                   |\n * | R3 |                  ACL LABEL                   |   |                                   |\n * +----+----------------------------------------------+---+-----------------------------------+\n * | R4 |            REG_LB_AFF_BACKEND_IP4            |   |                                   |\n * +----+----------------------------------------------+ X |                                   |\n * | R5 |                   UNUSED                     | X | ORIG_DIP_IPV6(>= IN_PRE_STATEFUL) |\n * +----+----------------------------------------------+ R |                                   |\n * | R6 |                   UNUSED                     | E |                                   |\n * +----+----------------------------------------------+ G |                                   |\n * | R7 |                   UNUSED                     | 1 |                                   |\n * +----+----------------------------------------------+---+-----------------------------------+\n * | R8 |              LB_AFF_MATCH_PORT               |\n * +----+----------------------------------------------+\n * | R9 |                   UNUSED                     |\n * +----+----------------------------------------------+\n *\n * Logical Router pipeline:\n * +-----+---------------------------+---+-----------------+---+------------------------------------+\n * | R0  | REGBIT_ND_RA_OPTS_RESULT  |   |                 |   |                                    |\n * |     |   (= IN_ND_RA_OPTIONS)    | X |                 |   |                                    |\n * |     |      NEXT_HOP_IPV4        | R |                 |   |                                    |\n * |     |      (>= IP_INPUT)        | E | INPORT_ETH_ADDR | X |                                    |\n * +-----+---------------------------+ G |   (< IP_INPUT)  | X |                                    |\n * | R1  |   SRC_IPV4 for ARP-REQ    | 0 |                 | R |                                    |\n * |     |      (>= IP_INPUT)        |   |                 | E |     NEXT_HOP_IPV6 (>= DEFRAG )     |\n * +-----+---------------------------+---+-----------------+ G |                                    |\n * | R2  |        UNUSED             | X |                 | 0 |                                    |\n * |     |                           | R |                 |   |                                    |\n * +-----+---------------------------+ E |     UNUSED      |   |                                    |\n * | R3  |        UNUSED             | G |                 |   |                                    |\n * |     |                           | 1 |                 |   |                                    |\n * +-----+---------------------------+---+-----------------+---+------------------------------------+\n * | R4  |  REG_LB_AFF_BACKEND_IP4   | X |                 |   |                                    |\n * |     |                           | R |                 |   |                                    |\n * +-----+---------------------------+ E |     UNUSED      | X |                                    |\n * | R5  |        UNUSED             | G |                 | X |                                    |\n * |     |                           | 2 |                 | R |        LB_L3_AFF_BACKEND_IP6       |\n * +-----+---------------------------+---+-----------------+ E |           (<= IN_DNAT)             |\n * | R6  |        UNUSED             | X |                 | G |                                    |\n * |     |                           | R |                 | 1 |                                    |\n * +-----+---------------------------+ E |     UNUSED      |   |                                    |\n * | R7  |      ROUTE_TABLE_ID       | G |                 |   |                                    |\n * |     | (>= IN_IP_ROUTING_PRE &&  | 3 |                 |   |                                    |\n * |     |  <= IN_IP_ROUTING)        |   |                 |   |                                    |\n * +-----+---------------------------+---+-----------------+---+------------------------------------+\n * | R8  |     ECMP_GROUP_ID         |   |                 |\n * |     |     ECMP_MEMBER_ID        |   |                 |\n * |     |    LB_AFF_MATCH_PORT      | X |                 |\n * +-----+---------------------------+ R |                 |\n * |     | REGBIT_{                  | E |                 |\n * |     |   EGRESS_LOOPBACK/        | G |     UNUSED      |\n * | R9  |   PKT_LARGER/             | 4 |                 |\n * |     |   LOOKUP_NEIGHBOR_RESULT/ |   |                 |\n * |     |   SKIP_LOOKUP_NEIGHBOR/   |   |                 |\n * |     |   KNOWN_ECMP_NH}          |   |                 |\n * |     |                           |   |                 |\n * |     | REG_ORIG_TP_DPORT_ROUTER  |   |                 |\n * |     |                           |   |                 |\n * +-----+---------------------------+---+-----------------+\n *\n */\n\n/*\n * Route offsets implement logic to prioritize traffic for routes with\n * same ip_prefix values:\n *  -  connected route overrides static one;\n *  -  static route overrides connected route. */\n#define ROUTE_PRIO_OFFSET_MULTIPLIER 3\n#define ROUTE_PRIO_OFFSET_STATIC 1\n#define ROUTE_PRIO_OFFSET_CONNECTED 2\n\n/* Returns an \"enum ovn_stage\" built from the arguments. */\nstatic enum ovn_stage\novn_stage_build(enum ovn_datapath_type dp_type, enum ovn_pipeline pipeline,\n                uint8_t table)\n{\n    return OVN_STAGE_BUILD(dp_type, pipeline, table);\n}\n\n/* Returns the pipeline to which 'stage' belongs. */\nstatic enum ovn_pipeline\novn_stage_get_pipeline(enum ovn_stage stage)\n{\n    return (stage >> 8) & 1;\n}\n\n/* Returns the pipeline name to which 'stage' belongs. */\nstatic const char *\novn_stage_get_pipeline_name(enum ovn_stage stage)\n{\n    return ovn_stage_get_pipeline(stage) == P_IN ? \"ingress\" : \"egress\";\n}\n\n/* Returns the table to which 'stage' belongs. */\nstatic uint8_t\novn_stage_get_table(enum ovn_stage stage)\n{\n    return stage & 0xff;\n}\n\n/* Returns a string name for 'stage'. */\nstatic const char *\novn_stage_to_str(enum ovn_stage stage)\n{\n    switch (stage) {\n#define PIPELINE_STAGE(DP_TYPE, PIPELINE, STAGE, TABLE, NAME)       \\\n        case S_##DP_TYPE##_##PIPELINE##_##STAGE: return NAME;\n    PIPELINE_STAGES\n#undef PIPELINE_STAGE\n        default: return \"<unknown>\";\n    }\n}\n\n/* Returns the type of the datapath to which a flow with the given 'stage' may\n * be added. */\nstatic enum ovn_datapath_type\novn_stage_to_datapath_type(enum ovn_stage stage)\n{\n    switch (stage) {\n#define PIPELINE_STAGE(DP_TYPE, PIPELINE, STAGE, TABLE, NAME)       \\\n        case S_##DP_TYPE##_##PIPELINE##_##STAGE: return DP_##DP_TYPE;\n    PIPELINE_STAGES\n#undef PIPELINE_STAGE\n    default: OVS_NOT_REACHED();\n    }\n}\n\f\nstatic void\nbuild_chassis_features(const struct northd_input *input_data,\n                       struct chassis_features *chassis_features)\n{\n    const struct sbrec_chassis *chassis;\n\n    SBREC_CHASSIS_TABLE_FOR_EACH (chassis, input_data->sbrec_chassis) {\n        /* Only consider local AZ chassis.  Remote ones don't install\n         * flows generated by the local northd.\n         */\n        if (smap_get_bool(&chassis->other_config, \"is-remote\", false)) {\n            continue;\n        }\n\n        bool ct_no_masked_label =\n            smap_get_bool(&chassis->other_config,\n                          OVN_FEATURE_CT_NO_MASKED_LABEL,\n                          false);\n        if (!ct_no_masked_label && chassis_features->ct_no_masked_label) {\n            chassis_features->ct_no_masked_label = false;\n        }\n\n        bool mac_binding_timestamp =\n            smap_get_bool(&chassis->other_config,\n                          OVN_FEATURE_MAC_BINDING_TIMESTAMP,\n                          false);\n        if (!mac_binding_timestamp &&\n            chassis_features->mac_binding_timestamp) {\n            chassis_features->mac_binding_timestamp = false;\n        }\n\n        bool ct_lb_related =\n            smap_get_bool(&chassis->other_config,\n                          OVN_FEATURE_CT_LB_RELATED,\n                          false);\n        if (!ct_lb_related &&\n            chassis_features->ct_lb_related) {\n            chassis_features->ct_lb_related = false;\n        }\n    }\n}\n\f\nstruct ovn_chassis_qdisc_queues {\n    struct hmap_node key_node;\n    uint32_t queue_id;\n    struct uuid chassis_uuid;\n};\n\nstatic uint32_t\nhash_chassis_queue(const struct uuid *chassis_uuid, uint32_t queue_id)\n{\n    return hash_2words(uuid_hash(chassis_uuid), queue_id);\n}\n\nstatic void\ndestroy_chassis_queues(struct hmap *set)\n{\n    struct ovn_chassis_qdisc_queues *node;\n    HMAP_FOR_EACH_POP (node, key_node, set) {\n        free(node);\n    }\n    hmap_destroy(set);\n}\n\nstatic void\nadd_chassis_queue(struct hmap *set, const struct uuid *chassis_uuid,\n                  uint32_t queue_id)\n{\n    struct ovn_chassis_qdisc_queues *node = xmalloc(sizeof *node);\n    node->queue_id = queue_id;\n    node->chassis_uuid = *chassis_uuid;\n    hmap_insert(set, &node->key_node,\n                hash_chassis_queue(chassis_uuid, queue_id));\n}\n\nstatic bool\nchassis_queueid_in_use(const struct hmap *set, const struct uuid *chassis_uuid,\n                       uint32_t queue_id)\n{\n    const struct ovn_chassis_qdisc_queues *node;\n    HMAP_FOR_EACH_WITH_HASH (node, key_node,\n                             hash_chassis_queue(chassis_uuid, queue_id), set) {\n        if (uuid_equals(chassis_uuid, &node->chassis_uuid)\n            && node->queue_id == queue_id) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic uint32_t\nallocate_chassis_queueid(struct hmap *set, const struct uuid *uuid, char *name)\n{\n    if (!uuid) {\n        return 0;\n    }\n\n    for (uint32_t queue_id = QDISC_MIN_QUEUE_ID + 1;\n         queue_id <= QDISC_MAX_QUEUE_ID;\n         queue_id++) {\n        if (!chassis_queueid_in_use(set, uuid, queue_id)) {\n            add_chassis_queue(set, uuid, queue_id);\n            return queue_id;\n        }\n    }\n\n    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n    VLOG_WARN_RL(&rl, \"all %s queue ids exhausted\", name);\n    return 0;\n}\n\nstatic void\nfree_chassis_queueid(struct hmap *set, const struct uuid *uuid,\n                     uint32_t queue_id)\n{\n    if (!uuid) {\n        return;\n    }\n\n    struct ovn_chassis_qdisc_queues *node;\n    HMAP_FOR_EACH_WITH_HASH (node, key_node,\n                             hash_chassis_queue(uuid, queue_id), set) {\n        if (uuid_equals(uuid, &node->chassis_uuid)\n            && node->queue_id == queue_id) {\n            hmap_remove(set, &node->key_node);\n            free(node);\n            break;\n        }\n    }\n}\n\nstatic inline bool\nport_has_qos_params(const struct smap *opts)\n{\n    return (smap_get(opts, \"qos_max_rate\") || smap_get(opts, \"qos_min_rate\") ||\n            smap_get(opts, \"qos_burst\"));\n}\n\f\n\nstatic void\ninit_mcast_port_info(struct mcast_port_info *mcast_info,\n                     const struct nbrec_logical_switch_port *nbsp,\n                     const struct nbrec_logical_router_port *nbrp)\n{\n    if (nbsp) {\n        mcast_info->flood =\n            smap_get_bool(&nbsp->options, \"mcast_flood\", false);\n        mcast_info->flood_reports =\n            smap_get_bool(&nbsp->options, \"mcast_flood_reports\",\n                          false);\n    } else if (nbrp) {\n        /* We don't process multicast reports in any special way on logical\n         * routers so just treat them as regular multicast traffic.\n         */\n        mcast_info->flood =\n            smap_get_bool(&nbrp->options, \"mcast_flood\", false);\n        mcast_info->flood_reports = mcast_info->flood;\n    }\n}\n\nstatic uint32_t\novn_mcast_group_allocate_key(struct mcast_info *mcast_info)\n{\n    return ovn_allocate_tnlid(&mcast_info->group_tnlids, \"multicast group\",\n                              OVN_MIN_IP_MULTICAST, OVN_MAX_IP_MULTICAST,\n                              &mcast_info->group_tnlid_hint);\n}\n\n/* Contains a NAT entry with the external addresses pre-parsed. */\nstruct ovn_nat {\n    const struct nbrec_nat *nb;\n    struct lport_addresses ext_addrs;\n    struct ovs_list ext_addr_list_node; /* Linkage in the per-external IP\n                                         * list of nat entries. Currently\n                                         * only used for SNAT.\n                                         */\n};\n\n/* Stores the list of SNAT entries referencing a unique SNAT IP address.\n * The 'snat_entries' list will be empty if the SNAT IP is used only for\n * dnat_force_snat_ip or lb_force_snat_ip.\n */\nstruct ovn_snat_ip {\n    struct ovs_list snat_entries;\n};\n\nstatic bool\nget_force_snat_ip(struct ovn_datapath *od, const char *key_type,\n                  struct lport_addresses *laddrs);\n\n/* Returns true if a 'nat_entry' is valid, i.e.:\n * - parsing was successful.\n * - the string yielded exactly one IPv4 address or exactly one IPv6 address.\n */\nstatic bool\nnat_entry_is_valid(const struct ovn_nat *nat_entry)\n{\n    const struct lport_addresses *ext_addrs = &nat_entry->ext_addrs;\n\n    return (ext_addrs->n_ipv4_addrs == 1 && ext_addrs->n_ipv6_addrs == 0) ||\n        (ext_addrs->n_ipv4_addrs == 0 && ext_addrs->n_ipv6_addrs == 1);\n}\n\nstatic bool\nnat_entry_is_v6(const struct ovn_nat *nat_entry)\n{\n    return nat_entry->ext_addrs.n_ipv6_addrs > 0;\n}\n\nstatic void\nsnat_ip_add(struct ovn_datapath *od, const char *ip, struct ovn_nat *nat_entry)\n{\n    struct ovn_snat_ip *snat_ip = shash_find_data(&od->snat_ips, ip);\n\n    if (!snat_ip) {\n        snat_ip = xzalloc(sizeof *snat_ip);\n        ovs_list_init(&snat_ip->snat_entries);\n        shash_add(&od->snat_ips, ip, snat_ip);\n    }\n\n    if (nat_entry) {\n        ovs_list_push_back(&snat_ip->snat_entries,\n                           &nat_entry->ext_addr_list_node);\n    }\n}\n\nstatic void\ninit_nat_entries(struct ovn_datapath *od)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    shash_init(&od->snat_ips);\n    if (get_force_snat_ip(od, \"dnat\", &od->dnat_force_snat_addrs)) {\n        if (od->dnat_force_snat_addrs.n_ipv4_addrs) {\n            snat_ip_add(od, od->dnat_force_snat_addrs.ipv4_addrs[0].addr_s,\n                        NULL);\n        }\n        if (od->dnat_force_snat_addrs.n_ipv6_addrs) {\n            snat_ip_add(od, od->dnat_force_snat_addrs.ipv6_addrs[0].addr_s,\n                        NULL);\n        }\n    }\n\n    /* Check if 'lb_force_snat_ip' is configured with 'router_ip'. */\n    const char *lb_force_snat =\n        smap_get(&od->nbr->options, \"lb_force_snat_ip\");\n    if (lb_force_snat && !strcmp(lb_force_snat, \"router_ip\")\n            && smap_get(&od->nbr->options, \"chassis\")) {\n        /* Set it to true only if its gateway router and\n         * options:lb_force_snat_ip=router_ip. */\n        od->lb_force_snat_router_ip = true;\n    } else {\n        od->lb_force_snat_router_ip = false;\n\n        /* Check if 'lb_force_snat_ip' is configured with a set of\n         * IP address(es). */\n        if (get_force_snat_ip(od, \"lb\", &od->lb_force_snat_addrs)) {\n            if (od->lb_force_snat_addrs.n_ipv4_addrs) {\n                snat_ip_add(od, od->lb_force_snat_addrs.ipv4_addrs[0].addr_s,\n                            NULL);\n            }\n            if (od->lb_force_snat_addrs.n_ipv6_addrs) {\n                snat_ip_add(od, od->lb_force_snat_addrs.ipv6_addrs[0].addr_s,\n                            NULL);\n            }\n        }\n    }\n\n    if (!od->nbr->n_nat) {\n        return;\n    }\n\n    od->nat_entries = xmalloc(od->nbr->n_nat * sizeof *od->nat_entries);\n\n    for (size_t i = 0; i < od->nbr->n_nat; i++) {\n        const struct nbrec_nat *nat = od->nbr->nat[i];\n        struct ovn_nat *nat_entry = &od->nat_entries[i];\n\n        nat_entry->nb = nat;\n        if (!extract_ip_addresses(nat->external_ip,\n                                  &nat_entry->ext_addrs) ||\n                !nat_entry_is_valid(nat_entry)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n\n            VLOG_WARN_RL(&rl,\n                         \"Bad ip address %s in nat configuration \"\n                         \"for router %s\", nat->external_ip, od->nbr->name);\n            continue;\n        }\n\n        /* If this is a SNAT rule add the IP to the set of unique SNAT IPs. */\n        if (!strcmp(nat->type, \"snat\")) {\n            if (!nat_entry_is_v6(nat_entry)) {\n                snat_ip_add(od, nat_entry->ext_addrs.ipv4_addrs[0].addr_s,\n                            nat_entry);\n            } else {\n                snat_ip_add(od, nat_entry->ext_addrs.ipv6_addrs[0].addr_s,\n                            nat_entry);\n            }\n        }\n\n        if (!strcmp(nat->type, \"dnat_and_snat\")\n            && nat->logical_port && nat->external_mac) {\n            od->has_distributed_nat = true;\n        }\n    }\n    od->n_nat_entries = od->nbr->n_nat;\n}\n\nstatic void\ndestroy_nat_entries(struct ovn_datapath *od)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    shash_destroy_free_data(&od->snat_ips);\n    destroy_lport_addresses(&od->dnat_force_snat_addrs);\n    destroy_lport_addresses(&od->lb_force_snat_addrs);\n\n    for (size_t i = 0; i < od->n_nat_entries; i++) {\n        destroy_lport_addresses(&od->nat_entries[i].ext_addrs);\n    }\n}\n\nstatic void\ninit_router_external_ips(struct ovn_datapath *od)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    sset_init(&od->external_ips);\n    for (size_t i = 0; i < od->nbr->n_nat; i++) {\n        sset_add(&od->external_ips, od->nbr->nat[i]->external_ip);\n    }\n}\n\nstatic void\ndestroy_router_external_ips(struct ovn_datapath *od)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    sset_destroy(&od->external_ips);\n}\n\nstatic bool\nlb_has_vip(const struct nbrec_load_balancer *lb)\n{\n    return !smap_is_empty(&lb->vips);\n}\n\nstatic bool\nlb_group_has_vip(const struct nbrec_load_balancer_group *lb_group)\n{\n    for (size_t i = 0; i < lb_group->n_load_balancer; i++) {\n        if (lb_has_vip(lb_group->load_balancer[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic bool\nls_has_lb_vip(struct ovn_datapath *od)\n{\n    for (size_t i = 0; i < od->nbs->n_load_balancer; i++) {\n        if (lb_has_vip(od->nbs->load_balancer[i])) {\n            return true;\n        }\n    }\n\n    for (size_t i = 0; i < od->nbs->n_load_balancer_group; i++) {\n        if (lb_group_has_vip(od->nbs->load_balancer_group[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic bool\nlr_has_lb_vip(struct ovn_datapath *od)\n{\n    for (size_t i = 0; i < od->nbr->n_load_balancer; i++) {\n        if (lb_has_vip(od->nbr->load_balancer[i])) {\n            return true;\n        }\n    }\n\n    for (size_t i = 0; i < od->nbr->n_load_balancer_group; i++) {\n        if (lb_group_has_vip(od->nbr->load_balancer_group[i])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nstatic void\ninit_lb_for_datapath(struct ovn_datapath *od)\n{\n    if (od->nbs) {\n        od->has_lb_vip = ls_has_lb_vip(od);\n    } else {\n        od->has_lb_vip = lr_has_lb_vip(od);\n    }\n}\n\nstatic void\ndestroy_lb_for_datapath(struct ovn_datapath *od)\n{\n    ovn_lb_ip_set_destroy(od->lb_ips);\n    od->lb_ips = NULL;\n\n    if (!od->nbs && !od->nbr) {\n        return;\n    }\n}\n\n/* A group of logical router datapaths which are connected - either\n * directly or indirectly.\n * Each logical router can belong to only one group. */\nstruct lrouter_group {\n    struct ovn_datapath **router_dps;\n    int n_router_dps;\n    /* Set of ha_chassis_groups which are associated with the router dps. */\n    struct sset ha_chassis_groups;\n    /* Temporary storage for chassis references while computing HA groups. */\n    struct hmapx tmp_ha_chassis;\n};\n\nstatic struct ovn_datapath *\novn_datapath_create(struct hmap *datapaths, const struct uuid *key,\n                    const struct nbrec_logical_switch *nbs,\n                    const struct nbrec_logical_router *nbr,\n                    const struct sbrec_datapath_binding *sb)\n{\n    struct ovn_datapath *od = xzalloc(sizeof *od);\n    od->key = *key;\n    od->sb = sb;\n    od->nbs = nbs;\n    od->nbr = nbr;\n    hmap_init(&od->port_tnlids);\n    hmap_init(&od->nb_pgs);\n    od->port_key_hint = 0;\n    hmap_insert(datapaths, &od->key_node, uuid_hash(&od->key));\n    od->lr_group = NULL;\n    ovs_list_init(&od->port_list);\n    return od;\n}\n\nstatic void ovn_ls_port_group_destroy(struct hmap *nb_pgs);\nstatic void destroy_mcast_info_for_datapath(struct ovn_datapath *od);\n\nstatic void\novn_datapath_destroy(struct hmap *datapaths, struct ovn_datapath *od)\n{\n    if (od) {\n        /* Don't remove od->list.  It is used within build_datapaths() as a\n         * private list and once we've exited that function it is not safe to\n         * use it. */\n        hmap_remove(datapaths, &od->key_node);\n        ovn_destroy_tnlids(&od->port_tnlids);\n        destroy_ipam_info(&od->ipam_info);\n        free(od->router_ports);\n        free(od->ls_peers);\n        destroy_nat_entries(od);\n        destroy_router_external_ips(od);\n        destroy_lb_for_datapath(od);\n        free(od->nat_entries);\n        free(od->localnet_ports);\n        free(od->l3dgw_ports);\n        ovn_ls_port_group_destroy(&od->nb_pgs);\n        destroy_mcast_info_for_datapath(od);\n\n        free(od);\n    }\n}\n\n/* Returns 'od''s datapath type. */\nstatic enum ovn_datapath_type\novn_datapath_get_type(const struct ovn_datapath *od)\n{\n    return od->nbs ? DP_SWITCH : DP_ROUTER;\n}\n\nstatic struct ovn_datapath *\novn_datapath_find(const struct hmap *datapaths,\n                  const struct uuid *uuid)\n{\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH_WITH_HASH (od, key_node, uuid_hash(uuid), datapaths) {\n        if (uuid_equals(uuid, &od->key)) {\n            return od;\n        }\n    }\n    return NULL;\n}\n\nstatic struct ovn_datapath *\novn_datapath_find_by_key(struct hmap *datapaths, uint32_t dp_key)\n{\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (od->tunnel_key == dp_key) {\n            return od;\n        }\n    }\n\n    return NULL;\n}\n\nstatic bool\novn_datapath_is_stale(const struct ovn_datapath *od)\n{\n    return !od->nbr && !od->nbs;\n}\n\nstatic struct ovn_datapath *\novn_datapath_from_sbrec(const struct hmap *datapaths,\n                        const struct sbrec_datapath_binding *sb)\n{\n    struct uuid key;\n\n    if (!smap_get_uuid(&sb->external_ids, \"logical-switch\", &key) &&\n        !smap_get_uuid(&sb->external_ids, \"logical-router\", &key)) {\n        return NULL;\n    }\n    struct ovn_datapath *od = ovn_datapath_find(datapaths, &key);\n    if (od && (od->sb == sb)) {\n        return od;\n    }\n\n    return NULL;\n}\n\nstatic void\novn_datapath_add_router_port(struct ovn_datapath *od, struct ovn_port *op)\n{\n    if (od->n_router_ports == od->n_allocated_router_ports) {\n        od->router_ports = x2nrealloc(od->router_ports,\n                                      &od->n_allocated_router_ports,\n                                      sizeof *od->router_ports);\n    }\n    od->router_ports[od->n_router_ports++] = op;\n}\n\nstatic void\novn_datapath_add_ls_peer(struct ovn_datapath *od, struct ovn_datapath *peer)\n{\n    if (od->n_ls_peers == od->n_allocated_ls_peers) {\n        od->ls_peers = x2nrealloc(od->ls_peers, &od->n_allocated_ls_peers,\n                                  sizeof *od->ls_peers);\n    }\n    od->ls_peers[od->n_ls_peers++] = peer;\n}\n\nstatic bool\nlrouter_is_enabled(const struct nbrec_logical_router *lrouter)\n{\n    return !lrouter->enabled || *lrouter->enabled;\n}\n\nstatic void\ninit_ipam_info_for_datapath(struct ovn_datapath *od)\n{\n    if (!od->nbs) {\n        return;\n    }\n\n    char uuid_s[UUID_LEN + 1];\n    sprintf(uuid_s, UUID_FMT, UUID_ARGS(&od->key));\n    init_ipam_info(&od->ipam_info, &od->nbs->other_config, uuid_s);\n}\n\nstatic void\ninit_mcast_info_for_router_datapath(struct ovn_datapath *od)\n{\n    struct mcast_router_info *mcast_rtr_info = &od->mcast_info.rtr;\n\n    mcast_rtr_info->relay = smap_get_bool(&od->nbr->options, \"mcast_relay\",\n                                          false);\n}\n\nstatic void\ninit_mcast_info_for_switch_datapath(struct ovn_datapath *od)\n{\n    struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n    mcast_sw_info->enabled =\n        smap_get_bool(&od->nbs->other_config, \"mcast_snoop\", false);\n    mcast_sw_info->querier =\n        smap_get_bool(&od->nbs->other_config, \"mcast_querier\", true);\n    mcast_sw_info->flood_unregistered =\n        smap_get_bool(&od->nbs->other_config, \"mcast_flood_unregistered\",\n                      false);\n\n    mcast_sw_info->table_size =\n        smap_get_ullong(&od->nbs->other_config, \"mcast_table_size\",\n                        OVN_MCAST_DEFAULT_MAX_ENTRIES);\n\n    uint32_t idle_timeout =\n        smap_get_ullong(&od->nbs->other_config, \"mcast_idle_timeout\",\n                        OVN_MCAST_DEFAULT_IDLE_TIMEOUT_S);\n    if (idle_timeout < OVN_MCAST_MIN_IDLE_TIMEOUT_S) {\n        idle_timeout = OVN_MCAST_MIN_IDLE_TIMEOUT_S;\n    } else if (idle_timeout > OVN_MCAST_MAX_IDLE_TIMEOUT_S) {\n        idle_timeout = OVN_MCAST_MAX_IDLE_TIMEOUT_S;\n    }\n    mcast_sw_info->idle_timeout = idle_timeout;\n\n    uint32_t query_interval =\n        smap_get_ullong(&od->nbs->other_config, \"mcast_query_interval\",\n                        mcast_sw_info->idle_timeout / 2);\n    if (query_interval < OVN_MCAST_MIN_QUERY_INTERVAL_S) {\n        query_interval = OVN_MCAST_MIN_QUERY_INTERVAL_S;\n    } else if (query_interval > OVN_MCAST_MAX_QUERY_INTERVAL_S) {\n        query_interval = OVN_MCAST_MAX_QUERY_INTERVAL_S;\n    }\n    mcast_sw_info->query_interval = query_interval;\n\n    mcast_sw_info->eth_src =\n        nullable_xstrdup(smap_get(&od->nbs->other_config, \"mcast_eth_src\"));\n    mcast_sw_info->ipv4_src =\n        nullable_xstrdup(smap_get(&od->nbs->other_config, \"mcast_ip4_src\"));\n    mcast_sw_info->ipv6_src =\n        nullable_xstrdup(smap_get(&od->nbs->other_config, \"mcast_ip6_src\"));\n\n    mcast_sw_info->query_max_response =\n        smap_get_ullong(&od->nbs->other_config, \"mcast_query_max_response\",\n                        OVN_MCAST_DEFAULT_QUERY_MAX_RESPONSE_S);\n}\n\nstatic void\ninit_mcast_flow_count(struct ovn_datapath *od)\n{\n    if (od->nbr) {\n        return;\n    }\n\n    struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n    mcast_sw_info->active_v4_flows = ATOMIC_VAR_INIT(0);\n    mcast_sw_info->active_v6_flows = ATOMIC_VAR_INIT(0);\n}\n\nstatic void\ninit_mcast_info_for_datapath(struct ovn_datapath *od)\n{\n    if (!od->nbr && !od->nbs) {\n        return;\n    }\n\n    hmap_init(&od->mcast_info.group_tnlids);\n    od->mcast_info.group_tnlid_hint = OVN_MIN_IP_MULTICAST;\n    ovs_list_init(&od->mcast_info.groups);\n\n    if (od->nbs) {\n        init_mcast_info_for_switch_datapath(od);\n    } else {\n        init_mcast_info_for_router_datapath(od);\n    }\n}\n\nstatic void\ndestroy_mcast_info_for_switch_datapath(struct ovn_datapath *od)\n{\n    struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n    free(mcast_sw_info->eth_src);\n    free(mcast_sw_info->ipv4_src);\n    free(mcast_sw_info->ipv6_src);\n}\n\nstatic void\ndestroy_mcast_info_for_datapath(struct ovn_datapath *od)\n{\n    if (!od->nbr && !od->nbs) {\n        return;\n    }\n\n    if (od->nbs) {\n        destroy_mcast_info_for_switch_datapath(od);\n    }\n\n    ovn_destroy_tnlids(&od->mcast_info.group_tnlids);\n}\n\nstatic void\nstore_mcast_info_for_switch_datapath(const struct sbrec_ip_multicast *sb,\n                                     struct ovn_datapath *od)\n{\n    struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n    sbrec_ip_multicast_set_datapath(sb, od->sb);\n    sbrec_ip_multicast_set_enabled(sb, &mcast_sw_info->enabled, 1);\n    sbrec_ip_multicast_set_querier(sb, &mcast_sw_info->querier, 1);\n    sbrec_ip_multicast_set_table_size(sb, &mcast_sw_info->table_size, 1);\n    sbrec_ip_multicast_set_idle_timeout(sb, &mcast_sw_info->idle_timeout, 1);\n    sbrec_ip_multicast_set_query_interval(sb,\n                                          &mcast_sw_info->query_interval, 1);\n    sbrec_ip_multicast_set_query_max_resp(sb,\n                                          &mcast_sw_info->query_max_response,\n                                          1);\n\n    if (mcast_sw_info->eth_src) {\n        sbrec_ip_multicast_set_eth_src(sb, mcast_sw_info->eth_src);\n    }\n\n    if (mcast_sw_info->ipv4_src) {\n        sbrec_ip_multicast_set_ip4_src(sb, mcast_sw_info->ipv4_src);\n    }\n\n    if (mcast_sw_info->ipv6_src) {\n        sbrec_ip_multicast_set_ip6_src(sb, mcast_sw_info->ipv6_src);\n    }\n}\n\nstatic void\novn_datapath_update_external_ids(struct ovn_datapath *od)\n{\n    /* Get the logical-switch or logical-router UUID to set in\n     * external-ids. */\n    char uuid_s[UUID_LEN + 1];\n    sprintf(uuid_s, UUID_FMT, UUID_ARGS(&od->key));\n    const char *key = od->nbs ? \"logical-switch\" : \"logical-router\";\n\n    /* Get names to set in external-ids. */\n    const char *name = od->nbs ? od->nbs->name : od->nbr->name;\n    const char *name2 = (od->nbs\n                         ? smap_get(&od->nbs->external_ids,\n                                    \"neutron:network_name\")\n                         : smap_get(&od->nbr->external_ids,\n                                    \"neutron:router_name\"));\n\n    /* Set external-ids. */\n    struct smap ids = SMAP_INITIALIZER(&ids);\n    smap_add(&ids, key, uuid_s);\n    smap_add(&ids, \"name\", name);\n    if (name2 && name2[0]) {\n        smap_add(&ids, \"name2\", name2);\n    }\n\n    /* Set interconn-ts. */\n    if (od->nbs) {\n        const char *ts = smap_get(&od->nbs->other_config, \"interconn-ts\");\n        if (ts) {\n            smap_add(&ids, \"interconn-ts\", ts);\n        }\n    }\n\n    /* Set snat-ct-zone */\n    if (od->nbr) {\n        int nat_default_ct = smap_get_int(&od->nbr->options,\n                                           \"snat-ct-zone\", -1);\n        if (nat_default_ct >= 0) {\n            smap_add_format(&ids, \"snat-ct-zone\", \"%d\", nat_default_ct);\n        }\n\n        bool learn_from_arp_request =\n            smap_get_bool(&od->nbr->options, \"always_learn_from_arp_request\",\n                          true);\n        if (!learn_from_arp_request) {\n            smap_add(&ids, \"always_learn_from_arp_request\", \"false\");\n        }\n    }\n\n    sbrec_datapath_binding_set_external_ids(od->sb, &ids);\n    smap_destroy(&ids);\n}\n\nstatic void\njoin_datapaths(struct northd_input *input_data,\n               struct ovsdb_idl_txn *ovnsb_txn,\n               struct hmap *datapaths, struct ovs_list *sb_only,\n               struct ovs_list *nb_only, struct ovs_list *both,\n               struct ovs_list *lr_list)\n{\n    ovs_list_init(sb_only);\n    ovs_list_init(nb_only);\n    ovs_list_init(both);\n\n    const struct sbrec_datapath_binding *sb;\n    SBREC_DATAPATH_BINDING_TABLE_FOR_EACH_SAFE (sb,\n                            input_data->sbrec_datapath_binding_table) {\n        struct uuid key;\n        if (!smap_get_uuid(&sb->external_ids, \"logical-switch\", &key) &&\n            !smap_get_uuid(&sb->external_ids, \"logical-router\", &key)) {\n            ovsdb_idl_txn_add_comment(\n                ovnsb_txn,\n                \"deleting Datapath_Binding \"UUID_FMT\" that lacks \"\n                \"external-ids:logical-switch and \"\n                \"external-ids:logical-router\",\n                UUID_ARGS(&sb->header_.uuid));\n            sbrec_datapath_binding_delete(sb);\n            continue;\n        }\n\n        if (ovn_datapath_find(datapaths, &key)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_INFO_RL(\n                &rl, \"deleting Datapath_Binding \"UUID_FMT\" with \"\n                \"duplicate external-ids:logical-switch/router \"UUID_FMT,\n                UUID_ARGS(&sb->header_.uuid), UUID_ARGS(&key));\n            sbrec_datapath_binding_delete(sb);\n            continue;\n        }\n\n        struct ovn_datapath *od = ovn_datapath_create(datapaths, &key,\n                                                      NULL, NULL, sb);\n        ovs_list_push_back(sb_only, &od->list);\n    }\n\n    const struct nbrec_logical_switch *nbs;\n    NBREC_LOGICAL_SWITCH_TABLE_FOR_EACH (nbs,\n                              input_data->nbrec_logical_switch) {\n        struct ovn_datapath *od = ovn_datapath_find(datapaths,\n                                                    &nbs->header_.uuid);\n        if (od) {\n            od->nbs = nbs;\n            ovs_list_remove(&od->list);\n            ovs_list_push_back(both, &od->list);\n            ovn_datapath_update_external_ids(od);\n        } else {\n            od = ovn_datapath_create(datapaths, &nbs->header_.uuid,\n                                     nbs, NULL, NULL);\n            ovs_list_push_back(nb_only, &od->list);\n        }\n\n        init_ipam_info_for_datapath(od);\n        init_mcast_info_for_datapath(od);\n        init_lb_for_datapath(od);\n    }\n\n    const struct nbrec_logical_router *nbr;\n    NBREC_LOGICAL_ROUTER_TABLE_FOR_EACH (nbr,\n                               input_data->nbrec_logical_router) {\n        if (!lrouter_is_enabled(nbr)) {\n            continue;\n        }\n\n        struct ovn_datapath *od = ovn_datapath_find(datapaths,\n                                                    &nbr->header_.uuid);\n        if (od) {\n            if (!od->nbs) {\n                od->nbr = nbr;\n                ovs_list_remove(&od->list);\n                ovs_list_push_back(both, &od->list);\n                ovn_datapath_update_external_ids(od);\n            } else {\n                /* Can't happen! */\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n                VLOG_WARN_RL(&rl,\n                             \"duplicate UUID \"UUID_FMT\" in OVN_Northbound\",\n                             UUID_ARGS(&nbr->header_.uuid));\n                continue;\n            }\n        } else {\n            od = ovn_datapath_create(datapaths, &nbr->header_.uuid,\n                                     NULL, nbr, NULL);\n            ovs_list_push_back(nb_only, &od->list);\n        }\n        init_mcast_info_for_datapath(od);\n        init_nat_entries(od);\n        init_router_external_ips(od);\n        init_lb_for_datapath(od);\n        if (smap_get(&od->nbr->options, \"chassis\")) {\n            od->is_gw_router = true;\n        }\n        ovs_list_push_back(lr_list, &od->lr_list);\n    }\n}\n\nstatic bool\nis_vxlan_mode(struct northd_input *input_data)\n{\n    const struct sbrec_chassis *chassis;\n    SBREC_CHASSIS_TABLE_FOR_EACH (chassis, input_data->sbrec_chassis) {\n        for (int i = 0; i < chassis->n_encaps; i++) {\n            if (!strcmp(chassis->encaps[i]->type, \"vxlan\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nstatic uint32_t\nget_ovn_max_dp_key_local(struct northd_input *input_data)\n{\n    if (is_vxlan_mode(input_data)) {\n        /* OVN_MAX_DP_GLOBAL_NUM doesn't apply for vxlan mode. */\n        return OVN_MAX_DP_VXLAN_KEY;\n    }\n    return OVN_MAX_DP_KEY - OVN_MAX_DP_GLOBAL_NUM;\n}\n\nstatic void\novn_datapath_allocate_key(struct northd_input *input_data,\n                          struct hmap *datapaths, struct hmap *dp_tnlids,\n                          struct ovn_datapath *od, uint32_t *hint)\n{\n    if (!od->tunnel_key) {\n        od->tunnel_key = ovn_allocate_tnlid(dp_tnlids, \"datapath\",\n                                    OVN_MIN_DP_KEY_LOCAL,\n                                    get_ovn_max_dp_key_local(input_data),\n                                    hint);\n        if (!od->tunnel_key) {\n            if (od->sb) {\n                sbrec_datapath_binding_delete(od->sb);\n            }\n            ovs_list_remove(&od->list);\n            ovn_datapath_destroy(datapaths, od);\n        }\n    }\n}\n\nstatic void\novn_datapath_assign_requested_tnl_id(struct northd_input *input_data,\n                                     struct hmap *dp_tnlids,\n                                     struct ovn_datapath *od)\n{\n    const struct smap *other_config = (od->nbs\n                                       ? &od->nbs->other_config\n                                       : &od->nbr->options);\n    uint32_t tunnel_key = smap_get_int(other_config, \"requested-tnl-key\", 0);\n    if (tunnel_key) {\n        const char *interconn_ts = smap_get(other_config, \"interconn-ts\");\n        if (!interconn_ts && is_vxlan_mode(input_data) &&\n            tunnel_key >= 1 << 12) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"Tunnel key %\"PRIu32\" for datapath %s is \"\n                         \"incompatible with VXLAN\", tunnel_key,\n                         od->nbs ? od->nbs->name : od->nbr->name);\n            return;\n        }\n        if (ovn_add_tnlid(dp_tnlids, tunnel_key)) {\n            od->tunnel_key = tunnel_key;\n        } else {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"Logical %s %s requests same tunnel key \"\n                         \"%\"PRIu32\" as another logical switch or router\",\n                         od->nbs ? \"switch\" : \"router\",\n                         od->nbs ? od->nbs->name : od->nbr->name, tunnel_key);\n        }\n    }\n}\n\n/* Array of all datapaths, with 'od->index' being their index in the array. */\nstatic struct ovn_datapath **datapaths_array = NULL;\nstatic size_t n_datapaths = 0; /* Size of the 'datapaths_array'. */\n\n/* Updates the southbound Datapath_Binding table so that it contains the\n * logical switches and routers specified by the northbound database.\n *\n * Initializes 'datapaths' to contain a \"struct ovn_datapath\" for every logical\n * switch and router. */\nstatic void\nbuild_datapaths(struct northd_input *input_data,\n                struct ovsdb_idl_txn *ovnsb_txn,\n                struct hmap *datapaths,\n                struct ovs_list *lr_list)\n{\n    struct ovs_list sb_only, nb_only, both;\n\n    join_datapaths(input_data, ovnsb_txn,\n                   datapaths, &sb_only, &nb_only, &both, lr_list);\n\n    /* Assign explicitly requested tunnel ids first. */\n    struct hmap dp_tnlids = HMAP_INITIALIZER(&dp_tnlids);\n    struct ovn_datapath *od;\n    LIST_FOR_EACH (od, list, &both) {\n        ovn_datapath_assign_requested_tnl_id(input_data, &dp_tnlids, od);\n    }\n    LIST_FOR_EACH (od, list, &nb_only) {\n        ovn_datapath_assign_requested_tnl_id(input_data, &dp_tnlids, od);\n    }\n\n    /* Keep nonconflicting tunnel IDs that are already assigned. */\n    LIST_FOR_EACH (od, list, &both) {\n        if (!od->tunnel_key && ovn_add_tnlid(&dp_tnlids, od->sb->tunnel_key)) {\n            od->tunnel_key = od->sb->tunnel_key;\n        }\n    }\n\n    /* Assign new tunnel ids where needed. */\n    uint32_t hint = 0;\n    LIST_FOR_EACH_SAFE (od, list, &both) {\n        ovn_datapath_allocate_key(input_data,\n                                  datapaths, &dp_tnlids, od, &hint);\n    }\n    LIST_FOR_EACH_SAFE (od, list, &nb_only) {\n        ovn_datapath_allocate_key(input_data,\n                                  datapaths, &dp_tnlids, od, &hint);\n    }\n\n    /* Sync tunnel ids from nb to sb. */\n    LIST_FOR_EACH (od, list, &both) {\n        if (od->sb->tunnel_key != od->tunnel_key) {\n            sbrec_datapath_binding_set_tunnel_key(od->sb, od->tunnel_key);\n        }\n        ovn_datapath_update_external_ids(od);\n    }\n    LIST_FOR_EACH (od, list, &nb_only) {\n        od->sb = sbrec_datapath_binding_insert(ovnsb_txn);\n        ovn_datapath_update_external_ids(od);\n        sbrec_datapath_binding_set_tunnel_key(od->sb, od->tunnel_key);\n    }\n    ovn_destroy_tnlids(&dp_tnlids);\n\n    /* Delete southbound records without northbound matches. */\n    LIST_FOR_EACH_SAFE (od, list, &sb_only) {\n        ovs_list_remove(&od->list);\n        sbrec_datapath_binding_delete(od->sb);\n        ovn_datapath_destroy(datapaths, od);\n    }\n\n    /* Assign unique sequential indexes to all datapaths.  These are not\n     * visible outside of the northd loop, so, unlike the tunnel keys, it\n     * doesn't matter if they are different on every iteration. */\n    size_t index = 0;\n\n    n_datapaths = hmap_count(datapaths);\n    datapaths_array = xrealloc(datapaths_array,\n                               n_datapaths * sizeof *datapaths_array);\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        od->index = index;\n        datapaths_array[index++] = od;\n    }\n}\n\n/* Structure representing logical router port\n * routable addresses. This includes DNAT and Load Balancer\n * addresses. This structure will only be filled in if the\n * router port is a gateway router port. Otherwise, all pointers\n * will be NULL and n_addrs will be 0.\n */\nstruct ovn_port_routable_addresses {\n    /* The parsed routable addresses */\n    struct lport_addresses *laddrs;\n    /* Number of items in the laddrs array */\n    size_t n_addrs;\n};\n\n/* A logical switch port or logical router port.\n *\n * In steady state, an ovn_port points to a northbound Logical_Switch_Port\n * record (via 'nbsp') *or* a Logical_Router_Port record (via 'nbrp'), and to a\n * southbound Port_Binding record (via 'sb').  As the state of the system\n * changes, join_logical_ports() may determine that there is a new LSP or LRP\n * that has no corresponding Port_Binding record (in which case build_ports())\n * will create the missing Port_Binding) or that a Port_Binding record exists\n * that has no coresponding LSP (in which case build_ports() will delete the\n * spurious Port_Binding).  Thus, after build_ports() runs, any given ovn_port\n * will have 'sb' nonnull, and 'nbsp' xor 'nbrp' nonnull.\n *\n * Ordinarily there is only one ovn_port that points to a given LSP or LRP (but\n * distributed gateway ports point a \"derived\" ovn_port to a duplicate LRP).\n */\nstruct ovn_port {\n    /* Port name aka key.\n     *\n     * This is ordinarily the same as nbsp->name or nbrp->name and\n     * sb->logical_port.  (A distributed gateway port creates a \"derived\"\n     * ovn_port with key \"cr-%s\" % nbrp->name.) */\n    struct hmap_node key_node;  /* Index on 'key'. */\n    char *key;                  /* nbsp->name, nbrp->name, sb->logical_port. */\n    char *json_key;             /* 'key', quoted for use in JSON. */\n\n    const struct sbrec_port_binding *sb;         /* May be NULL. */\n\n    uint32_t tunnel_key;\n\n    /* Logical switch port data. */\n    const struct nbrec_logical_switch_port *nbsp; /* May be NULL. */\n\n    struct lport_addresses *lsp_addrs;  /* Logical switch port addresses. */\n    unsigned int n_lsp_addrs;  /* Total length of lsp_addrs. */\n    unsigned int n_lsp_non_router_addrs; /* Number of elements from the\n                                          * beginning of 'lsp_addrs' extracted\n                                          * directly from LSP 'addresses'. */\n\n    struct lport_addresses *ps_addrs;   /* Port security addresses. */\n    unsigned int n_ps_addrs;\n\n    /* Logical router port data. */\n    const struct nbrec_logical_router_port *nbrp; /* May be NULL. */\n\n    struct lport_addresses lrp_networks;\n\n    struct ovn_port_routable_addresses routables;\n\n    /* Logical port multicast data. */\n    struct mcast_port_info mcast_info;\n\n    /* At most one of l3dgw_port and cr_port can be not NULL. */\n\n    /* This is set to a distributed gateway port if and only if this ovn_port\n     * is \"derived\" from it. Otherwise this is set to NULL. The derived\n     * ovn_port represents the instance of distributed gateway port on the\n     * gateway chassis.*/\n    struct ovn_port *l3dgw_port;\n\n    /* This is set to the \"derived\" chassis-redirect port of this port if and\n     * only if this port is a distributed gateway port. Otherwise this is set\n     * to NULL. */\n    struct ovn_port *cr_port;\n\n    bool has_unknown; /* If the addresses have 'unknown' defined. */\n\n    bool has_bfd;\n\n    /* The port's peer:\n     *\n     *     - A switch port S of type \"router\" has a router port R as a peer,\n     *       and R in turn has S has its peer.\n     *\n     *     - Two connected logical router ports have each other as peer.\n     *\n     *     - Other kinds of ports have no peer. */\n    struct ovn_port *peer;\n\n    struct ovn_datapath *od;\n\n    struct ovs_list list;       /* In list of similar records. */\n\n    struct ovs_list dp_node;\n};\n\nstatic bool\nis_l3dgw_port(const struct ovn_port *op)\n{\n    return op->cr_port;\n}\n\nstatic bool\nis_cr_port(const struct ovn_port *op)\n{\n    return op->l3dgw_port;\n}\n\nstatic void\ndestroy_routable_addresses(struct ovn_port_routable_addresses *ra)\n{\n    for (size_t i = 0; i < ra->n_addrs; i++) {\n        destroy_lport_addresses(&ra->laddrs[i]);\n    }\n    free(ra->laddrs);\n}\n\nstatic char **get_nat_addresses(const struct ovn_port *op, size_t *n,\n                                bool routable_only, bool include_lb_ips);\n\nstatic void\nassign_routable_addresses(struct ovn_port *op)\n{\n    size_t n;\n    char **nats = get_nat_addresses(op, &n, true, true);\n\n    if (!nats) {\n        return;\n    }\n\n    struct lport_addresses *laddrs = xcalloc(n, sizeof(*laddrs));\n    size_t n_addrs = 0;\n    for (size_t i = 0; i < n; i++) {\n        int ofs;\n        if (!extract_addresses(nats[i], &laddrs[n_addrs], &ofs)) {\n            free(nats[i]);\n            continue;\n        }\n        n_addrs++;\n        free(nats[i]);\n    }\n    free(nats);\n\n    /* Everything seems to have worked out */\n    op->routables.laddrs = laddrs;\n    op->routables.n_addrs = n_addrs;\n}\n\n\nstatic void\novn_port_set_nb(struct ovn_port *op,\n                const struct nbrec_logical_switch_port *nbsp,\n                const struct nbrec_logical_router_port *nbrp)\n{\n    op->nbsp = nbsp;\n    op->nbrp = nbrp;\n    init_mcast_port_info(&op->mcast_info, op->nbsp, op->nbrp);\n}\n\nstatic struct ovn_port *\novn_port_create(struct hmap *ports, const char *key,\n                const struct nbrec_logical_switch_port *nbsp,\n                const struct nbrec_logical_router_port *nbrp,\n                const struct sbrec_port_binding *sb)\n{\n    struct ovn_port *op = xzalloc(sizeof *op);\n\n    struct ds json_key = DS_EMPTY_INITIALIZER;\n    json_string_escape(key, &json_key);\n    op->json_key = ds_steal_cstr(&json_key);\n\n    op->key = xstrdup(key);\n    op->sb = sb;\n    ovn_port_set_nb(op, nbsp, nbrp);\n    op->l3dgw_port = op->cr_port = NULL;\n    hmap_insert(ports, &op->key_node, hash_string(op->key, 0));\n    return op;\n}\n\nstatic void\novn_port_destroy(struct hmap *ports, struct ovn_port *port)\n{\n    if (port) {\n        /* Don't remove port->list.  It is used within build_ports() as a\n         * private list and once we've exited that function it is not safe to\n         * use it. */\n        hmap_remove(ports, &port->key_node);\n\n        if (port->peer) {\n            port->peer->peer = NULL;\n        }\n\n        for (int i = 0; i < port->n_lsp_addrs; i++) {\n            destroy_lport_addresses(&port->lsp_addrs[i]);\n        }\n        free(port->lsp_addrs);\n\n        for (int i = 0; i < port->n_ps_addrs; i++) {\n            destroy_lport_addresses(&port->ps_addrs[i]);\n        }\n        free(port->ps_addrs);\n\n        destroy_routable_addresses(&port->routables);\n\n        destroy_lport_addresses(&port->lrp_networks);\n        free(port->json_key);\n        free(port->key);\n        free(port);\n    }\n}\n\n/* Returns the ovn_port that matches 'name'.  If 'prefer_bound' is true and\n * multiple ports share the same name, gives precendence to ports bound to\n * an ovn_datapath.\n */\nstatic struct ovn_port *\novn_port_find__(const struct hmap *ports, const char *name,\n                bool prefer_bound)\n{\n    struct ovn_port *matched_op = NULL;\n    struct ovn_port *op;\n\n    HMAP_FOR_EACH_WITH_HASH (op, key_node, hash_string(name, 0), ports) {\n        if (!strcmp(op->key, name)) {\n            matched_op = op;\n            if (!prefer_bound || op->od) {\n                return op;\n            }\n        }\n    }\n    return matched_op;\n}\n\nstatic struct ovn_port *\novn_port_find(const struct hmap *ports, const char *name)\n{\n    return ovn_port_find__(ports, name, false);\n}\n\nstatic struct ovn_port *\novn_port_find_bound(const struct hmap *ports, const char *name)\n{\n    return ovn_port_find__(ports, name, true);\n}\n\n/* Returns true if the logical switch port 'enabled' column is empty or\n * set to true.  Otherwise, returns false. */\nstatic bool\nlsp_is_enabled(const struct nbrec_logical_switch_port *lsp)\n{\n    return !lsp->n_enabled || *lsp->enabled;\n}\n\n/* Returns true only if the logical switch port 'up' column is set to true.\n * Otherwise, if the column is not set or set to false, returns false. */\nstatic bool\nlsp_is_up(const struct nbrec_logical_switch_port *lsp)\n{\n    return lsp->n_up && *lsp->up;\n}\n\nstatic bool\nlsp_is_external(const struct nbrec_logical_switch_port *nbsp)\n{\n    return !strcmp(nbsp->type, \"external\");\n}\n\nstatic bool\nlsp_is_router(const struct nbrec_logical_switch_port *nbsp)\n{\n    return !strcmp(nbsp->type, \"router\");\n}\n\nstatic bool\nlsp_is_remote(const struct nbrec_logical_switch_port *nbsp)\n{\n    return !strcmp(nbsp->type, \"remote\");\n}\n\nstatic bool\nlsp_is_localnet(const struct nbrec_logical_switch_port *nbsp)\n{\n    return !strcmp(nbsp->type, \"localnet\");\n}\n\nstatic bool\nlsp_is_vtep(const struct nbrec_logical_switch_port *nbsp)\n{\n    return !strcmp(nbsp->type, \"vtep\");\n}\n\nstatic bool\nlocalnet_can_learn_mac(const struct nbrec_logical_switch_port *nbsp)\n{\n    return smap_get_bool(&nbsp->options, \"localnet_learn_fdb\", false);\n}\n\nstatic bool\nlsp_is_type_changed(const struct sbrec_port_binding *sb,\n                const struct nbrec_logical_switch_port *nbsp,\n                bool *update_sbrec)\n{\n    *update_sbrec = false;\n    if (!sb || !nbsp) {\n        return false;\n    }\n\n    if (!sb->type[0] && !nbsp->type[0]) {\n        /* Two \"VIF's\" interface make sure both have parent_port\n         * set or both have parent_port unset, otherwisre they are\n         * different ports type.\n         */\n        if ((!sb->parent_port && nbsp->parent_name) ||\n                        (sb->parent_port && !nbsp->parent_name)) {\n            *update_sbrec = true;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /* Cover cases where port changed to/from virtual port */\n    if (!strcmp(sb->type, \"virtual\") ||\n                !strcmp(nbsp->type, \"virtual\")) {\n        *update_sbrec = true;\n    }\n\n    /* Both lports are not \"VIF's\" it is safe to use strcmp. */\n    if (sb->type[0] && nbsp->type[0]) {\n        return strcmp(sb->type, nbsp->type);\n    }\n\n    return true;\n}\n\nstatic bool\nlrport_is_enabled(const struct nbrec_logical_router_port *lrport)\n{\n    return !lrport->enabled || *lrport->enabled;\n}\n\nstatic struct ovn_port *\novn_port_get_peer(const struct hmap *ports, struct ovn_port *op)\n{\n    if (!op->nbsp || !lsp_is_router(op->nbsp) || op->l3dgw_port) {\n        return NULL;\n    }\n\n    if (op->peer) {\n        return op->peer;\n    }\n\n    const char *peer_name = smap_get(&op->nbsp->options, \"router-port\");\n    if (!peer_name) {\n        return NULL;\n    }\n\n    return ovn_port_find(ports, peer_name);\n}\n\nstatic void\nipam_insert_ip_for_datapath(struct ovn_datapath *od, uint32_t ip)\n{\n    if (!od) {\n        return;\n    }\n\n    ipam_insert_ip(&od->ipam_info, ip);\n}\n\nstatic void\nipam_insert_lsp_addresses(struct ovn_datapath *od,\n                          struct lport_addresses *laddrs)\n{\n    ipam_insert_mac(&laddrs->ea, true);\n\n    /* IP is only added to IPAM if the switch's subnet option\n     * is set, whereas MAC is always added to MACAM. */\n    if (!od->ipam_info.allocated_ipv4s) {\n        return;\n    }\n\n    for (size_t j = 0; j < laddrs->n_ipv4_addrs; j++) {\n        uint32_t ip = ntohl(laddrs->ipv4_addrs[j].addr);\n        ipam_insert_ip_for_datapath(od, ip);\n    }\n}\n\nstatic void\nipam_add_port_addresses(struct ovn_datapath *od, struct ovn_port *op)\n{\n    if (!od || !op) {\n        return;\n    }\n\n    if (op->n_lsp_non_router_addrs) {\n        /* Add all the port's addresses to address data structures. */\n        for (size_t i = 0; i < op->n_lsp_non_router_addrs; i++) {\n            ipam_insert_lsp_addresses(od, &op->lsp_addrs[i]);\n        }\n    } else if (op->lrp_networks.ea_s[0]) {\n        ipam_insert_mac(&op->lrp_networks.ea, true);\n\n        if (!op->peer || !op->peer->nbsp || !op->peer->od || !op->peer->od->nbs\n            || !smap_get(&op->peer->od->nbs->other_config, \"subnet\")) {\n            return;\n        }\n\n        for (size_t i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            uint32_t ip = ntohl(op->lrp_networks.ipv4_addrs[i].addr);\n            /* If the router has the first IP address of the subnet, don't add\n             * it to IPAM. We already added this when we initialized IPAM for\n             * the datapath. This will just result in an erroneous message\n             * about a duplicate IP address.\n             */\n            if (ip != op->peer->od->ipam_info.start_ipv4) {\n                ipam_insert_ip_for_datapath(op->peer->od, ip);\n            }\n        }\n    }\n}\n\nstatic const char *find_lrp_member_ip(const struct ovn_port *op,\n                                      const char *ip_s);\n\n/* Returns true if the given router port 'op' (assumed to be a distributed\n * gateway port) is the relevant DGP where the NAT rule of the router needs to\n * be applied. */\nstatic bool\nis_nat_gateway_port(const struct nbrec_nat *nat, const struct ovn_port *op)\n{\n    if (op->od->n_l3dgw_ports > 1\n        && ((!nat->gateway_port && !find_lrp_member_ip(op, nat->external_ip))\n            || (nat->gateway_port && nat->gateway_port != op->nbrp))) {\n        return false;\n    }\n    return true;\n}\n\nenum dynamic_update_type {\n    NONE,    /* No change to the address */\n    REMOVE,  /* Address is no longer dynamic */\n    STATIC,  /* Use static address (MAC only) */\n    DYNAMIC, /* Assign a new dynamic address */\n};\n\nstruct dynamic_address_update {\n    struct ovs_list node;       /* In build_ipam()'s list of updates. */\n\n    struct ovn_datapath *od;\n    struct ovn_port *op;\n\n    struct lport_addresses current_addresses;\n    struct eth_addr static_mac;\n    ovs_be32 static_ip;\n    struct in6_addr static_ipv6;\n    enum dynamic_update_type mac;\n    enum dynamic_update_type ipv4;\n    enum dynamic_update_type ipv6;\n};\n\nstatic enum dynamic_update_type\ndynamic_mac_changed(const char *lsp_addresses,\n                    struct dynamic_address_update *update)\n{\n   struct eth_addr ea;\n\n   if (ovs_scan(lsp_addresses, ETH_ADDR_SCAN_FMT, ETH_ADDR_SCAN_ARGS(ea))) {\n       if (eth_addr_equals(ea, update->current_addresses.ea)) {\n           return NONE;\n       } else {\n           /* MAC is still static, but it has changed */\n           update->static_mac = ea;\n           return STATIC;\n       }\n   }\n\n   uint64_t mac64 = eth_addr_to_uint64(update->current_addresses.ea);\n   uint64_t prefix = eth_addr_to_uint64(get_mac_prefix());\n\n   if ((mac64 ^ prefix) >> 24) {\n       return DYNAMIC;\n   } else {\n       return NONE;\n   }\n}\n\nstatic enum dynamic_update_type\ndynamic_ip4_changed(const char *lsp_addrs,\n                    struct dynamic_address_update *update)\n{\n    const struct ipam_info *ipam = &update->op->od->ipam_info;\n    const struct lport_addresses *cur_addresses = &update->current_addresses;\n    bool dynamic_ip4 = ipam->allocated_ipv4s != NULL;\n\n    if (!dynamic_ip4) {\n        if (update->current_addresses.n_ipv4_addrs) {\n            return REMOVE;\n        } else {\n            return NONE;\n        }\n    }\n\n    if (!cur_addresses->n_ipv4_addrs) {\n        /* IPv4 was previously static but now is dynamic */\n        return DYNAMIC;\n    }\n\n    uint32_t ip4 = ntohl(cur_addresses->ipv4_addrs[0].addr);\n    if (ip4 < ipam->start_ipv4) {\n        return DYNAMIC;\n    }\n\n    uint32_t index = ip4 - ipam->start_ipv4;\n    if (index >= ipam->total_ipv4s - 1 ||\n        bitmap_is_set(ipam->allocated_ipv4s, index)) {\n        /* Previously assigned dynamic IPv4 address can no longer be used.\n         * It's either outside the subnet, conflicts with an excluded IP,\n         * or conflicts with a statically-assigned address on the switch\n         */\n        return DYNAMIC;\n    } else {\n        char ipv6_s[IPV6_SCAN_LEN + 1];\n        ovs_be32 new_ip;\n        int n = 0;\n\n        if ((ovs_scan(lsp_addrs, \"dynamic \"IP_SCAN_FMT\"%n\",\n                     IP_SCAN_ARGS(&new_ip), &n)\n             && lsp_addrs[n] == '\\0') ||\n            (ovs_scan(lsp_addrs, \"dynamic \"IP_SCAN_FMT\" \"IPV6_SCAN_FMT\"%n\",\n                      IP_SCAN_ARGS(&new_ip), ipv6_s, &n)\n             && lsp_addrs[n] == '\\0')) {\n            index = ntohl(new_ip) - ipam->start_ipv4;\n            if (ntohl(new_ip) < ipam->start_ipv4 ||\n                index > ipam->total_ipv4s ||\n                bitmap_is_set(ipam->allocated_ipv4s, index)) {\n                /* new static ip is not valid */\n                return DYNAMIC;\n            } else if (cur_addresses->ipv4_addrs[0].addr != new_ip) {\n                update->ipv4 = STATIC;\n                update->static_ip = new_ip;\n                return STATIC;\n            }\n        }\n        return NONE;\n    }\n}\n\nstatic enum dynamic_update_type\ndynamic_ip6_changed(const char *lsp_addrs,\n                    struct dynamic_address_update *update)\n{\n    bool dynamic_ip6 = update->op->od->ipam_info.ipv6_prefix_set;\n    struct eth_addr ea;\n\n    if (!dynamic_ip6) {\n        if (update->current_addresses.n_ipv6_addrs) {\n            /* IPv6 was dynamic but now is not */\n            return REMOVE;\n        } else {\n            /* IPv6 has never been dynamic */\n            return NONE;\n        }\n    }\n\n    if (!update->current_addresses.n_ipv6_addrs ||\n        ovs_scan(lsp_addrs, ETH_ADDR_SCAN_FMT, ETH_ADDR_SCAN_ARGS(ea))) {\n        /* IPv6 was previously static but now is dynamic */\n        return DYNAMIC;\n    }\n\n    const struct lport_addresses *cur_addresses;\n    char ipv6_s[IPV6_SCAN_LEN + 1];\n    ovs_be32 new_ip;\n    int n = 0;\n\n    if ((ovs_scan(lsp_addrs, \"dynamic \"IPV6_SCAN_FMT\"%n\",\n                  ipv6_s, &n) && lsp_addrs[n] == '\\0') ||\n        (ovs_scan(lsp_addrs, \"dynamic \"IP_SCAN_FMT\" \"IPV6_SCAN_FMT\"%n\",\n                  IP_SCAN_ARGS(&new_ip), ipv6_s, &n)\n         && lsp_addrs[n] == '\\0')) {\n        struct in6_addr ipv6;\n\n        if (!ipv6_parse(ipv6_s, &ipv6)) {\n            return DYNAMIC;\n        }\n\n        struct in6_addr masked = ipv6_addr_bitand(&ipv6,\n                &update->op->od->ipam_info.ipv6_prefix);\n        if (!IN6_ARE_ADDR_EQUAL(&masked,\n                                &update->op->od->ipam_info.ipv6_prefix)) {\n            return DYNAMIC;\n        }\n\n        cur_addresses = &update->current_addresses;\n\n        if (!IN6_ARE_ADDR_EQUAL(&cur_addresses->ipv6_addrs[0].addr,\n                                &ipv6)) {\n            update->static_ipv6 = ipv6;\n            return STATIC;\n        }\n    } else if (update->mac != NONE) {\n        return DYNAMIC;\n    }\n\n    return NONE;\n}\n\n/* Check previously assigned dynamic addresses for validity. This will\n * check if the assigned addresses need to change.\n *\n * Returns true if any changes to dynamic addresses are required\n */\nstatic bool\ndynamic_addresses_check_for_updates(const char *lsp_addrs,\n                                    struct dynamic_address_update *update)\n{\n    update->mac = dynamic_mac_changed(lsp_addrs, update);\n    update->ipv4 = dynamic_ip4_changed(lsp_addrs, update);\n    update->ipv6 = dynamic_ip6_changed(lsp_addrs, update);\n    if (update->mac == NONE &&\n        update->ipv4 == NONE &&\n        update->ipv6 == NONE) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n/* For addresses that do not need to be updated, go ahead and insert them\n * into IPAM. This way, their addresses will be claimed and cannot be assigned\n * elsewhere later.\n */\nstatic void\nupdate_unchanged_dynamic_addresses(struct dynamic_address_update *update)\n{\n    if (update->mac == NONE) {\n        ipam_insert_mac(&update->current_addresses.ea, false);\n    }\n    if (update->ipv4 == NONE && update->current_addresses.n_ipv4_addrs) {\n        ipam_insert_ip_for_datapath(update->op->od,\n                       ntohl(update->current_addresses.ipv4_addrs[0].addr));\n    }\n}\n\nstatic void\nset_lsp_dynamic_addresses(const char *dynamic_addresses, struct ovn_port *op)\n{\n    extract_lsp_addresses(dynamic_addresses, &op->lsp_addrs[op->n_lsp_addrs]);\n    op->n_lsp_addrs++;\n}\n\n/* Determines which components (MAC, IPv4, and IPv6) of dynamic\n * addresses need to be assigned. This is used exclusively for\n * ports that do not have dynamic addresses already assigned.\n */\nstatic void\nset_dynamic_updates(const char *addrspec,\n                    struct dynamic_address_update *update)\n{\n    bool has_ipv4 = false, has_ipv6 = false;\n    char ipv6_s[IPV6_SCAN_LEN + 1];\n    struct eth_addr mac;\n    ovs_be32 ip;\n    int n = 0;\n    if (ovs_scan(addrspec, ETH_ADDR_SCAN_FMT\" dynamic%n\",\n                 ETH_ADDR_SCAN_ARGS(mac), &n)\n        && addrspec[n] == '\\0') {\n        update->mac = STATIC;\n        update->static_mac = mac;\n    } else {\n        update->mac = DYNAMIC;\n    }\n\n    if ((ovs_scan(addrspec, \"dynamic \"IP_SCAN_FMT\"%n\",\n                 IP_SCAN_ARGS(&ip), &n) && addrspec[n] == '\\0')) {\n        has_ipv4 = true;\n    } else if ((ovs_scan(addrspec, \"dynamic \"IPV6_SCAN_FMT\"%n\",\n                         ipv6_s, &n) && addrspec[n] == '\\0')) {\n        has_ipv6 = true;\n    } else if ((ovs_scan(addrspec, \"dynamic \"IP_SCAN_FMT\" \"IPV6_SCAN_FMT\"%n\",\n                         IP_SCAN_ARGS(&ip), ipv6_s, &n)\n               && addrspec[n] == '\\0')) {\n        has_ipv4 = has_ipv6 = true;\n    }\n\n    if (has_ipv4) {\n        update->ipv4 = STATIC;\n        update->static_ip = ip;\n    } else if (update->op->od->ipam_info.allocated_ipv4s) {\n        update->ipv4 = DYNAMIC;\n    } else {\n        update->ipv4 = NONE;\n    }\n\n    if (has_ipv6 && ipv6_parse(ipv6_s, &update->static_ipv6)) {\n        update->ipv6 = STATIC;\n    } else if (update->op->od->ipam_info.ipv6_prefix_set) {\n        update->ipv6 = DYNAMIC;\n    } else {\n        update->ipv6 = NONE;\n    }\n}\n\nstatic void\nupdate_dynamic_addresses(struct dynamic_address_update *update)\n{\n    ovs_be32 ip4 = 0;\n    switch (update->ipv4) {\n    case NONE:\n        if (update->current_addresses.n_ipv4_addrs) {\n            ip4 = update->current_addresses.ipv4_addrs[0].addr;\n        }\n        break;\n    case REMOVE:\n        break;\n    case STATIC:\n        ip4 = update->static_ip;\n        break;\n    case DYNAMIC:\n        ip4 = htonl(ipam_get_unused_ip(&update->od->ipam_info));\n        VLOG_INFO(\"Assigned dynamic IPv4 address '\"IP_FMT\"' to port '%s'\",\n                  IP_ARGS(ip4), update->op->nbsp->name);\n    }\n\n    struct eth_addr mac;\n    switch (update->mac) {\n    case NONE:\n        mac = update->current_addresses.ea;\n        break;\n    case REMOVE:\n        OVS_NOT_REACHED();\n    case STATIC:\n        mac = update->static_mac;\n        break;\n    case DYNAMIC:\n        eth_addr_from_uint64(ipam_get_unused_mac(ip4), &mac);\n        VLOG_INFO(\"Assigned dynamic MAC address '\"ETH_ADDR_FMT\"' to port '%s'\",\n                  ETH_ADDR_ARGS(mac), update->op->nbsp->name);\n        break;\n    }\n\n    struct in6_addr ip6 = in6addr_any;\n    switch (update->ipv6) {\n    case NONE:\n        if (update->current_addresses.n_ipv6_addrs) {\n            ip6 = update->current_addresses.ipv6_addrs[0].addr;\n        }\n        break;\n    case REMOVE:\n        break;\n    case STATIC:\n        ip6 = update->static_ipv6;\n        break;\n    case DYNAMIC:\n        in6_generate_eui64(mac, &update->od->ipam_info.ipv6_prefix, &ip6);\n        struct ds ip6_ds = DS_EMPTY_INITIALIZER;\n        ipv6_format_addr(&ip6, &ip6_ds);\n        VLOG_INFO(\"Assigned dynamic IPv6 address '%s' to port '%s'\",\n                  ip6_ds.string, update->op->nbsp->name);\n        ds_destroy(&ip6_ds);\n        break;\n    }\n\n    struct ds new_addr = DS_EMPTY_INITIALIZER;\n    ds_put_format(&new_addr, ETH_ADDR_FMT, ETH_ADDR_ARGS(mac));\n    ipam_insert_mac(&mac, true);\n\n    if (ip4) {\n        ipam_insert_ip_for_datapath(update->od, ntohl(ip4));\n        ds_put_format(&new_addr, \" \"IP_FMT, IP_ARGS(ip4));\n    }\n    if (!IN6_ARE_ADDR_EQUAL(&ip6, &in6addr_any)) {\n        char ip6_s[INET6_ADDRSTRLEN + 1];\n        ipv6_string_mapped(ip6_s, &ip6);\n        ds_put_format(&new_addr, \" %s\", ip6_s);\n    }\n    nbrec_logical_switch_port_set_dynamic_addresses(update->op->nbsp,\n                                                    ds_cstr(&new_addr));\n    set_lsp_dynamic_addresses(ds_cstr(&new_addr), update->op);\n    ds_destroy(&new_addr);\n}\n\nstatic void\nbuild_ipam(struct hmap *datapaths, struct hmap *ports)\n{\n    /* IPAM generally stands for IP address management.  In non-virtualized\n     * world, MAC addresses come with the hardware.  But, with virtualized\n     * workloads, they need to be assigned and managed.  This function\n     * does both IP address management (ipam) and MAC address management\n     * (macam). */\n\n    /* If the switch's other_config:subnet is set, allocate new addresses for\n     * ports that have the \"dynamic\" keyword in their addresses column. */\n    struct ovn_datapath *od;\n    struct ovs_list updates;\n\n    ovs_list_init(&updates);\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs) {\n            continue;\n        }\n\n        for (size_t i = 0; i < od->nbs->n_ports; i++) {\n            const struct nbrec_logical_switch_port *nbsp = od->nbs->ports[i];\n\n            if (!od->ipam_info.allocated_ipv4s &&\n                !od->ipam_info.ipv6_prefix_set &&\n                !od->ipam_info.mac_only) {\n                if (nbsp->dynamic_addresses) {\n                    nbrec_logical_switch_port_set_dynamic_addresses(nbsp,\n                                                                    NULL);\n                }\n                continue;\n            }\n\n            struct ovn_port *op = ovn_port_find(ports, nbsp->name);\n            if (!op || op->nbsp != nbsp || op->peer) {\n                /* Do not allocate addresses for logical switch ports that\n                 * have a peer. */\n                continue;\n            }\n\n            int num_dynamic_addresses = 0;\n            for (size_t j = 0; j < nbsp->n_addresses; j++) {\n                if (!is_dynamic_lsp_address(nbsp->addresses[j])) {\n                    continue;\n                }\n                if (num_dynamic_addresses) {\n                    static struct vlog_rate_limit rl\n                        = VLOG_RATE_LIMIT_INIT(1, 1);\n                    VLOG_WARN_RL(&rl, \"More than one dynamic address \"\n                                 \"configured for logical switch port '%s'\",\n                                 nbsp->name);\n                    continue;\n                }\n                num_dynamic_addresses++;\n                struct dynamic_address_update *update\n                    = xzalloc(sizeof *update);\n                update->op = op;\n                update->od = od;\n                if (nbsp->dynamic_addresses) {\n                    bool any_changed;\n                    extract_lsp_addresses(nbsp->dynamic_addresses,\n                                          &update->current_addresses);\n                    any_changed = dynamic_addresses_check_for_updates(\n                        nbsp->addresses[j], update);\n                    update_unchanged_dynamic_addresses(update);\n                    if (any_changed) {\n                        ovs_list_push_back(&updates, &update->node);\n                    } else {\n                        /* No changes to dynamic addresses */\n                        set_lsp_dynamic_addresses(nbsp->dynamic_addresses, op);\n                        destroy_lport_addresses(&update->current_addresses);\n                        free(update);\n                    }\n                } else {\n                    set_dynamic_updates(nbsp->addresses[j], update);\n                    ovs_list_push_back(&updates, &update->node);\n                }\n            }\n\n            if (!num_dynamic_addresses && nbsp->dynamic_addresses) {\n                nbrec_logical_switch_port_set_dynamic_addresses(nbsp, NULL);\n            }\n        }\n\n    }\n\n    /* After retaining all unchanged dynamic addresses, now assign\n     * new ones.\n     */\n    struct dynamic_address_update *update;\n    LIST_FOR_EACH_POP (update, node, &updates) {\n        update_dynamic_addresses(update);\n        destroy_lport_addresses(&update->current_addresses);\n        free(update);\n    }\n}\n\f\n/* Tag allocation for nested containers.\n *\n * For a logical switch port with 'parent_name' and a request to allocate tags,\n * keeps a track of all allocated tags. */\nstruct tag_alloc_node {\n    struct hmap_node hmap_node;\n    char *parent_name;\n    unsigned long *allocated_tags;  /* A bitmap to track allocated tags. */\n};\n\nstatic void\ntag_alloc_destroy(struct hmap *tag_alloc_table)\n{\n    struct tag_alloc_node *node;\n    HMAP_FOR_EACH_POP (node, hmap_node, tag_alloc_table) {\n        bitmap_free(node->allocated_tags);\n        free(node->parent_name);\n        free(node);\n    }\n    hmap_destroy(tag_alloc_table);\n}\n\nstatic struct tag_alloc_node *\ntag_alloc_get_node(struct hmap *tag_alloc_table, const char *parent_name)\n{\n    /* If a node for the 'parent_name' exists, return it. */\n    struct tag_alloc_node *tag_alloc_node;\n    HMAP_FOR_EACH_WITH_HASH (tag_alloc_node, hmap_node,\n                             hash_string(parent_name, 0),\n                             tag_alloc_table) {\n        if (!strcmp(tag_alloc_node->parent_name, parent_name)) {\n            return tag_alloc_node;\n        }\n    }\n\n    /* Create a new node. */\n    tag_alloc_node = xmalloc(sizeof *tag_alloc_node);\n    tag_alloc_node->parent_name = xstrdup(parent_name);\n    tag_alloc_node->allocated_tags = bitmap_allocate(MAX_OVN_TAGS);\n    /* Tag 0 is invalid for nested containers. */\n    bitmap_set1(tag_alloc_node->allocated_tags, 0);\n    hmap_insert(tag_alloc_table, &tag_alloc_node->hmap_node,\n                hash_string(parent_name, 0));\n\n    return tag_alloc_node;\n}\n\nstatic void\ntag_alloc_add_existing_tags(struct hmap *tag_alloc_table,\n                            const struct nbrec_logical_switch_port *nbsp)\n{\n    /* Add the tags of already existing nested containers.  If there is no\n     * 'nbsp->parent_name' or no 'nbsp->tag' set, there is nothing to do. */\n    if (!nbsp->parent_name || !nbsp->parent_name[0] || !nbsp->tag) {\n        return;\n    }\n\n    struct tag_alloc_node *tag_alloc_node;\n    tag_alloc_node = tag_alloc_get_node(tag_alloc_table, nbsp->parent_name);\n    bitmap_set1(tag_alloc_node->allocated_tags, *nbsp->tag);\n}\n\nstatic void\ntag_alloc_create_new_tag(struct hmap *tag_alloc_table,\n                         const struct nbrec_logical_switch_port *nbsp)\n{\n    if (!nbsp->tag_request) {\n        return;\n    }\n\n    if (nbsp->parent_name && nbsp->parent_name[0]\n        && *nbsp->tag_request == 0) {\n        /* For nested containers that need allocation, do the allocation. */\n\n        if (nbsp->tag) {\n            /* This has already been allocated. */\n            return;\n        }\n\n        struct tag_alloc_node *tag_alloc_node;\n        int64_t tag;\n        tag_alloc_node = tag_alloc_get_node(tag_alloc_table,\n                                            nbsp->parent_name);\n        tag = bitmap_scan(tag_alloc_node->allocated_tags, 0, 1, MAX_OVN_TAGS);\n        if (tag == MAX_OVN_TAGS) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_ERR_RL(&rl, \"out of vlans for logical switch ports with \"\n                        \"parent %s\", nbsp->parent_name);\n            return;\n        }\n        bitmap_set1(tag_alloc_node->allocated_tags, tag);\n        nbrec_logical_switch_port_set_tag(nbsp, &tag, 1);\n    } else if (*nbsp->tag_request != 0) {\n        /* For everything else, copy the contents of 'tag_request' to 'tag'. */\n        nbrec_logical_switch_port_set_tag(nbsp, nbsp->tag_request, 1);\n    }\n}\n\f\n\nstatic void\njoin_logical_ports(struct northd_input *input_data,\n                   struct hmap *datapaths, struct hmap *ports,\n                   struct hmap *chassis_qdisc_queues,\n                   struct hmap *tag_alloc_table, struct ovs_list *sb_only,\n                   struct ovs_list *nb_only, struct ovs_list *both)\n{\n    ovs_list_init(sb_only);\n    ovs_list_init(nb_only);\n    ovs_list_init(both);\n\n    const struct sbrec_port_binding *sb;\n    SBREC_PORT_BINDING_TABLE_FOR_EACH (sb,\n                                 input_data->sbrec_port_binding_table) {\n        struct ovn_port *op = ovn_port_create(ports, sb->logical_port,\n                                              NULL, NULL, sb);\n        ovs_list_push_back(sb_only, &op->list);\n    }\n\n    struct ovn_datapath *od;\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (od->nbs) {\n            size_t n_allocated_localnet_ports = 0;\n            for (size_t i = 0; i < od->nbs->n_ports; i++) {\n                const struct nbrec_logical_switch_port *nbsp\n                    = od->nbs->ports[i];\n                struct ovn_port *op = ovn_port_find_bound(ports, nbsp->name);\n                if (op && (op->od || op->nbsp || op->nbrp)) {\n                    static struct vlog_rate_limit rl\n                        = VLOG_RATE_LIMIT_INIT(5, 1);\n                    VLOG_WARN_RL(&rl, \"duplicate logical port %s\", nbsp->name);\n                    continue;\n                } else if (op && (!op->sb || op->sb->datapath == od->sb)) {\n                    /*\n                     * Handle cases where lport type was explicitly changed\n                     * in the NBDB, in such cases:\n                     * 1. remove the current sbrec of the affected lport from\n                     *    the port_binding table.\n                     *\n                     * 2. create a new sbrec with the same logical_port as the\n                     *    deleted lport and add it to the nb_only list which\n                     *    will make the northd handle this lport as a new\n                     *    created one and recompute everything that is needed\n                     *    for this lport.\n                     *\n                     * This change will affect container/virtual lport type\n                     * changes only for now, this change is needed in\n                     * contaier/virtual lport cases to avoid port type\n                     * conflicts in the ovn-controller when the user clears\n                     * the parent_port field in the container lport or updated\n                     * the lport type.\n                     *\n                     */\n                    bool update_sbrec = false;\n                    if (op->sb && lsp_is_type_changed(op->sb, nbsp,\n                                                      &update_sbrec)\n                                   && update_sbrec) {\n                        ovs_list_remove(&op->list);\n                        sbrec_port_binding_delete(op->sb);\n                        ovn_port_destroy(ports, op);\n                        op = ovn_port_create(ports, nbsp->name, nbsp,\n                                             NULL, NULL);\n                        ovs_list_push_back(nb_only, &op->list);\n                    } else {\n                        ovn_port_set_nb(op, nbsp, NULL);\n                        ovs_list_remove(&op->list);\n\n                        uint32_t queue_id = smap_get_int(&op->sb->options,\n                                                         \"qdisc_queue_id\", 0);\n                        if (queue_id && op->sb->chassis) {\n                            add_chassis_queue(\n                                 chassis_qdisc_queues,\n                                 &op->sb->chassis->header_.uuid,\n                                 queue_id);\n                        }\n\n                        ovs_list_push_back(both, &op->list);\n\n                        /* This port exists due to a SB binding, but should\n                         * not have been initialized fully. */\n                        ovs_assert(!op->n_lsp_addrs && !op->n_ps_addrs);\n                    }\n                } else {\n                    op = ovn_port_create(ports, nbsp->name, nbsp, NULL, NULL);\n                    ovs_list_push_back(nb_only, &op->list);\n                }\n\n                if (lsp_is_localnet(nbsp)) {\n                   if (od->n_localnet_ports >= n_allocated_localnet_ports) {\n                       od->localnet_ports = x2nrealloc(\n                           od->localnet_ports, &n_allocated_localnet_ports,\n                           sizeof *od->localnet_ports);\n                   }\n                   od->localnet_ports[od->n_localnet_ports++] = op;\n                }\n\n                if (lsp_is_vtep(nbsp)) {\n                    od->has_vtep_lports = true;\n                }\n\n                op->lsp_addrs\n                    = xmalloc(sizeof *op->lsp_addrs * nbsp->n_addresses);\n                for (size_t j = 0; j < nbsp->n_addresses; j++) {\n                    if (!strcmp(nbsp->addresses[j], \"unknown\")) {\n                        op->has_unknown = true;\n                        continue;\n                    }\n                    if (!strcmp(nbsp->addresses[j], \"router\")) {\n                        continue;\n                    }\n                    if (is_dynamic_lsp_address(nbsp->addresses[j])) {\n                        continue;\n                    } else if (!extract_lsp_addresses(nbsp->addresses[j],\n                                           &op->lsp_addrs[op->n_lsp_addrs])) {\n                        static struct vlog_rate_limit rl\n                            = VLOG_RATE_LIMIT_INIT(1, 1);\n                        VLOG_INFO_RL(&rl, \"invalid syntax '%s' in logical \"\n                                          \"switch port addresses. No MAC \"\n                                          \"address found\",\n                                          op->nbsp->addresses[j]);\n                        continue;\n                    }\n                    op->n_lsp_addrs++;\n                }\n                op->n_lsp_non_router_addrs = op->n_lsp_addrs;\n\n                op->ps_addrs\n                    = xmalloc(sizeof *op->ps_addrs * nbsp->n_port_security);\n                for (size_t j = 0; j < nbsp->n_port_security; j++) {\n                    if (!extract_lsp_addresses(nbsp->port_security[j],\n                                               &op->ps_addrs[op->n_ps_addrs])) {\n                        static struct vlog_rate_limit rl\n                            = VLOG_RATE_LIMIT_INIT(1, 1);\n                        VLOG_INFO_RL(&rl, \"invalid syntax '%s' in port \"\n                                          \"security. No MAC address found\",\n                                          op->nbsp->port_security[j]);\n                        continue;\n                    }\n                    op->n_ps_addrs++;\n                }\n\n                op->od = od;\n                ovs_list_push_back(&od->port_list, &op->dp_node);\n                tag_alloc_add_existing_tags(tag_alloc_table, nbsp);\n            }\n        } else {\n            size_t n_allocated_l3dgw_ports = 0;\n            for (size_t i = 0; i < od->nbr->n_ports; i++) {\n                const struct nbrec_logical_router_port *nbrp\n                    = od->nbr->ports[i];\n\n                struct lport_addresses lrp_networks;\n                if (!extract_lrp_networks(nbrp, &lrp_networks)) {\n                    static struct vlog_rate_limit rl\n                        = VLOG_RATE_LIMIT_INIT(5, 1);\n                    VLOG_WARN_RL(&rl, \"bad 'mac' %s\", nbrp->mac);\n                    continue;\n                }\n\n                if (!lrp_networks.n_ipv4_addrs && !lrp_networks.n_ipv6_addrs) {\n                    continue;\n                }\n\n                struct ovn_port *op = ovn_port_find_bound(ports, nbrp->name);\n                if (op && (op->od || op->nbsp || op->nbrp)) {\n                    static struct vlog_rate_limit rl\n                        = VLOG_RATE_LIMIT_INIT(5, 1);\n                    VLOG_WARN_RL(&rl, \"duplicate logical router port %s\",\n                                 nbrp->name);\n                    destroy_lport_addresses(&lrp_networks);\n                    continue;\n                } else if (op && (!op->sb || op->sb->datapath == od->sb)) {\n                    ovn_port_set_nb(op, NULL, nbrp);\n                    ovs_list_remove(&op->list);\n                    ovs_list_push_back(both, &op->list);\n\n                    /* This port exists but should not have been\n                     * initialized fully. */\n                    ovs_assert(!op->lrp_networks.n_ipv4_addrs\n                               && !op->lrp_networks.n_ipv6_addrs);\n                } else {\n                    op = ovn_port_create(ports, nbrp->name, NULL, nbrp, NULL);\n                    ovs_list_push_back(nb_only, &op->list);\n                }\n\n                op->lrp_networks = lrp_networks;\n                op->od = od;\n                ovs_list_push_back(&od->port_list, &op->dp_node);\n\n                if (!od->redirect_bridged) {\n                    const char *redirect_type =\n                        smap_get(&nbrp->options, \"redirect-type\");\n                    od->redirect_bridged =\n                        redirect_type && !strcasecmp(redirect_type, \"bridged\");\n                }\n\n                if (op->nbrp->ha_chassis_group ||\n                    op->nbrp->n_gateway_chassis) {\n                    /* Additional \"derived\" ovn_port crp represents the\n                     * instance of op on the gateway chassis. */\n                    const char *gw_chassis = smap_get(&op->od->nbr->options,\n                                                   \"chassis\");\n                    if (gw_chassis) {\n                        static struct vlog_rate_limit rl\n                            = VLOG_RATE_LIMIT_INIT(1, 1);\n                        VLOG_WARN_RL(&rl, \"Bad configuration: distributed \"\n                                     \"gateway port configured on port %s \"\n                                     \"on L3 gateway router\", nbrp->name);\n                        continue;\n                    }\n\n                    char *redirect_name =\n                        ovn_chassis_redirect_name(nbrp->name);\n                    struct ovn_port *crp = ovn_port_find(ports, redirect_name);\n                    if (crp && crp->sb && crp->sb->datapath == od->sb) {\n                        ovn_port_set_nb(crp, NULL, nbrp);\n                        ovs_list_remove(&crp->list);\n                        ovs_list_push_back(both, &crp->list);\n                    } else {\n                        crp = ovn_port_create(ports, redirect_name,\n                                              NULL, nbrp, NULL);\n                        ovs_list_push_back(nb_only, &crp->list);\n                    }\n                    crp->l3dgw_port = op;\n                    op->cr_port = crp;\n                    crp->od = od;\n                    free(redirect_name);\n\n                    /* Add to l3dgw_ports in od, for later use during flow\n                     * creation. */\n                    if (od->n_l3dgw_ports == n_allocated_l3dgw_ports) {\n                        od->l3dgw_ports = x2nrealloc(od->l3dgw_ports,\n                                                     &n_allocated_l3dgw_ports,\n                                                     sizeof *od->l3dgw_ports);\n                    }\n                    od->l3dgw_ports[od->n_l3dgw_ports++] = op;\n\n                    assign_routable_addresses(op);\n                }\n            }\n        }\n    }\n\n    /* Connect logical router ports, and logical switch ports of type \"router\",\n     * to their peers. */\n    struct ovn_port *op;\n    HMAP_FOR_EACH (op, key_node, ports) {\n        if (op->nbsp && lsp_is_router(op->nbsp) && !op->l3dgw_port) {\n            struct ovn_port *peer = ovn_port_get_peer(ports, op);\n            if (!peer || !peer->nbrp) {\n                continue;\n            }\n\n            ovn_datapath_add_router_port(op->od, op);\n            ovn_datapath_add_ls_peer(peer->od, op->od);\n            peer->peer = op;\n            op->peer = peer;\n\n            /* Fill op->lsp_addrs for op->nbsp->addresses[] with\n             * contents \"router\", which was skipped in the loop above. */\n            for (size_t j = 0; j < op->nbsp->n_addresses; j++) {\n                if (!strcmp(op->nbsp->addresses[j], \"router\")) {\n                    if (extract_lrp_networks(peer->nbrp,\n                                            &op->lsp_addrs[op->n_lsp_addrs])) {\n                        op->n_lsp_addrs++;\n                    }\n                    break;\n                }\n            }\n\n            /* If the router is multicast enabled then set relay on the switch\n             * datapath.\n             */\n            if (peer->od && peer->od->mcast_info.rtr.relay) {\n                op->od->mcast_info.sw.flood_relay = true;\n            }\n        } else if (op->nbrp && op->nbrp->peer && !op->l3dgw_port) {\n            struct ovn_port *peer = ovn_port_find(ports, op->nbrp->peer);\n            if (peer) {\n                if (peer->nbrp) {\n                    op->peer = peer;\n                } else if (peer->nbsp) {\n                    /* An ovn_port for a switch port of type \"router\" does have\n                     * a router port as its peer (see the case above for\n                     * \"router\" ports), but this is set via options:router-port\n                     * in Logical_Switch_Port and does not involve the\n                     * Logical_Router_Port's 'peer' column. */\n                    static struct vlog_rate_limit rl =\n                            VLOG_RATE_LIMIT_INIT(5, 1);\n                    VLOG_WARN_RL(&rl, \"Bad configuration: The peer of router \"\n                                 \"port %s is a switch port\", op->key);\n                }\n            }\n        }\n    }\n\n    /* Wait until all ports have been connected to add to IPAM since\n     * it relies on proper peers to be set\n     */\n    HMAP_FOR_EACH (op, key_node, ports) {\n        ipam_add_port_addresses(op->od, op);\n    }\n}\n\n/* Returns an array of strings, each consisting of a MAC address followed\n * by one or more IP addresses, and if the port is a distributed gateway\n * port, followed by 'is_chassis_resident(\"LPORT_NAME\")', where the\n * LPORT_NAME is the name of the L3 redirect port or the name of the\n * logical_port specified in a NAT rule. These strings include the\n * external IP addresses of NAT rules defined on that router whose\n * gateway_port is router port 'op', and all of the IP addresses used in\n * load balancer VIPs defined on that router.\n *\n * The caller must free each of the n returned strings with free(),\n * and must free the returned array when it is no longer needed. */\nstatic char **\nget_nat_addresses(const struct ovn_port *op, size_t *n, bool routable_only,\n                  bool include_lb_ips)\n{\n    size_t n_nats = 0;\n    struct eth_addr mac;\n    if (!op || !op->nbrp || !op->od || !op->od->nbr\n        || (!op->od->nbr->n_nat && !op->od->has_lb_vip)\n        || !eth_addr_from_string(op->nbrp->mac, &mac)) {\n        *n = n_nats;\n        return NULL;\n    }\n\n    struct ds c_addresses = DS_EMPTY_INITIALIZER;\n    ds_put_format(&c_addresses, ETH_ADDR_FMT, ETH_ADDR_ARGS(mac));\n    bool central_ip_address = false;\n\n    char **addresses;\n    addresses = xmalloc(sizeof *addresses * (op->od->nbr->n_nat + 1));\n\n    /* Get NAT IP addresses. */\n    for (size_t i = 0; i < op->od->nbr->n_nat; i++) {\n        const struct nbrec_nat *nat = op->od->nbr->nat[i];\n        ovs_be32 ip, mask;\n\n        if (routable_only &&\n            (!strcmp(nat->type, \"snat\") ||\n             !smap_get_bool(&nat->options, \"add_route\", false))) {\n            continue;\n        }\n\n        char *error = ip_parse_masked(nat->external_ip, &ip, &mask);\n        if (error || mask != OVS_BE32_MAX) {\n            free(error);\n            continue;\n        }\n\n        /* Not including external IP of NAT rules whose gateway_port is\n         * not 'op'. */\n        if (!is_nat_gateway_port(nat, op)) {\n            continue;\n        }\n\n        /* Determine whether this NAT rule satisfies the conditions for\n         * distributed NAT processing. */\n        if (op->od->n_l3dgw_ports && !strcmp(nat->type, \"dnat_and_snat\")\n            && nat->logical_port && nat->external_mac) {\n            /* Distributed NAT rule. */\n            if (eth_addr_from_string(nat->external_mac, &mac)) {\n                struct ds address = DS_EMPTY_INITIALIZER;\n                ds_put_format(&address, ETH_ADDR_FMT, ETH_ADDR_ARGS(mac));\n                ds_put_format(&address, \" %s\", nat->external_ip);\n                ds_put_format(&address, \" is_chassis_resident(\\\"%s\\\")\",\n                              nat->logical_port);\n                addresses[n_nats++] = ds_steal_cstr(&address);\n            }\n        } else {\n            /* Centralized NAT rule, either on gateway router or distributed\n             * router.\n             * Check if external_ip is same as router ip. If so, then there\n             * is no need to add this to the nat_addresses. The router IPs\n             * will be added separately. */\n            bool is_router_ip = false;\n            for (size_t j = 0; j < op->lrp_networks.n_ipv4_addrs; j++) {\n                if (!strcmp(nat->external_ip,\n                            op->lrp_networks.ipv4_addrs[j].addr_s)) {\n                    is_router_ip = true;\n                    break;\n                }\n            }\n            if (!is_router_ip) {\n                for (size_t j = 0; j < op->lrp_networks.n_ipv6_addrs; j++) {\n                    if (!strcmp(nat->external_ip,\n                                op->lrp_networks.ipv6_addrs[j].addr_s)) {\n                        is_router_ip = true;\n                        break;\n                    }\n                }\n            }\n\n            if (!is_router_ip) {\n                ds_put_format(&c_addresses, \" %s\", nat->external_ip);\n                central_ip_address = true;\n            }\n        }\n    }\n\n    if (include_lb_ips) {\n        const char *ip_address;\n        if (routable_only) {\n            SSET_FOR_EACH (ip_address, &op->od->lb_ips->ips_v4_routable) {\n                ds_put_format(&c_addresses, \" %s\", ip_address);\n                central_ip_address = true;\n            }\n            SSET_FOR_EACH (ip_address, &op->od->lb_ips->ips_v6_routable) {\n                ds_put_format(&c_addresses, \" %s\", ip_address);\n                central_ip_address = true;\n            }\n        } else {\n            SSET_FOR_EACH (ip_address, &op->od->lb_ips->ips_v4) {\n                ds_put_format(&c_addresses, \" %s\", ip_address);\n                central_ip_address = true;\n            }\n            SSET_FOR_EACH (ip_address, &op->od->lb_ips->ips_v6) {\n                ds_put_format(&c_addresses, \" %s\", ip_address);\n                central_ip_address = true;\n            }\n        }\n    }\n\n    if (central_ip_address) {\n        /* Gratuitous ARP for centralized NAT rules on distributed gateway\n         * ports should be restricted to the gateway chassis. */\n        if (is_l3dgw_port(op)) {\n            ds_put_format(&c_addresses, \" is_chassis_resident(%s)\",\n                          op->cr_port->json_key);\n        }\n\n        addresses[n_nats++] = ds_steal_cstr(&c_addresses);\n    }\n\n    *n = n_nats;\n    ds_destroy(&c_addresses);\n\n    return addresses;\n}\n\nstatic bool\nsbpb_gw_chassis_needs_update(\n    const struct sbrec_port_binding *pb,\n    const struct nbrec_logical_router_port *lrp,\n    struct ovsdb_idl_index *sbrec_chassis_by_name)\n{\n    if (!lrp || !pb) {\n        return false;\n    }\n\n    if (lrp->n_gateway_chassis && !pb->ha_chassis_group) {\n        /* If there are gateway chassis in the NB DB, but there is\n         * no corresponding HA chassis group in SB DB we need to\n         * create the HA chassis group in SB DB for this lrp. */\n        return true;\n    }\n\n    if (strcmp(pb->ha_chassis_group->name, lrp->name)) {\n        /* Name doesn't match. */\n        return true;\n    }\n\n    if (lrp->n_gateway_chassis != pb->ha_chassis_group->n_ha_chassis) {\n        return true;\n    }\n\n    for (size_t i = 0; i < lrp->n_gateway_chassis; i++) {\n        struct nbrec_gateway_chassis *nbgw_ch = lrp->gateway_chassis[i];\n        bool found = false;\n        for (size_t j = 0; j < pb->ha_chassis_group->n_ha_chassis; j++) {\n            struct sbrec_ha_chassis *sbha_ch =\n                pb->ha_chassis_group->ha_chassis[j];\n            const char *chassis_name = smap_get(&sbha_ch->external_ids,\n                                                \"chassis-name\");\n            if (!chassis_name) {\n                return true;\n            }\n\n            if (strcmp(chassis_name, nbgw_ch->chassis_name)) {\n                continue;\n            }\n\n            found = true;\n\n            if (nbgw_ch->priority != sbha_ch->priority) {\n                return true;\n            }\n\n            if (sbha_ch->chassis &&\n                strcmp(nbgw_ch->chassis_name, sbha_ch->chassis->name)) {\n                /* sbha_ch->chassis's name is different from the one\n                 * in sbha_ch->external_ids:chassis-name. */\n                return true;\n            }\n\n            if (!sbha_ch->chassis &&\n                chassis_lookup_by_name(sbrec_chassis_by_name,\n                                       nbgw_ch->chassis_name)) {\n                /* sbha_ch->chassis is NULL, but the chassis is\n                 * present in Chassis table. */\n                return true;\n            }\n        }\n\n        if (!found) {\n            return true;\n        }\n    }\n\n    /* No need to update SB DB. Its in sync. */\n    return false;\n}\n\nstatic struct sbrec_ha_chassis *\ncreate_sb_ha_chassis(struct ovsdb_idl_txn *ovnsb_txn,\n                     const struct sbrec_chassis *chassis,\n                     const char *chassis_name, int priority)\n{\n    struct sbrec_ha_chassis *sb_ha_chassis =\n        sbrec_ha_chassis_insert(ovnsb_txn);\n    sbrec_ha_chassis_set_chassis(sb_ha_chassis, chassis);\n    sbrec_ha_chassis_set_priority(sb_ha_chassis, priority);\n    /* Store the chassis_name in external_ids. If the chassis\n     * entry doesn't exist in the Chassis table then we can\n     * figure out the chassis to which this ha_chassis\n     * maps to. */\n    const struct smap external_ids =\n        SMAP_CONST1(&external_ids, \"chassis-name\", chassis_name);\n    sbrec_ha_chassis_set_external_ids(sb_ha_chassis, &external_ids);\n    return sb_ha_chassis;\n}\n\nstatic bool\nchassis_group_list_changed(\n    const struct nbrec_ha_chassis_group *nb_ha_grp,\n    const struct sbrec_ha_chassis_group *sb_ha_grp,\n    struct ovsdb_idl_index *sbrec_chassis_by_name)\n{\n    if (nb_ha_grp->n_ha_chassis != sb_ha_grp->n_ha_chassis) {\n        return true;\n    }\n\n    struct shash nb_ha_chassis_list = SHASH_INITIALIZER(&nb_ha_chassis_list);\n    for (size_t i = 0; i < nb_ha_grp->n_ha_chassis; i++) {\n        shash_add(&nb_ha_chassis_list,\n                  nb_ha_grp->ha_chassis[i]->chassis_name,\n                  nb_ha_grp->ha_chassis[i]);\n    }\n\n    bool changed = false;\n    const struct sbrec_ha_chassis *sb_ha_chassis;\n    const struct nbrec_ha_chassis *nb_ha_chassis;\n    for (size_t i = 0; i < sb_ha_grp->n_ha_chassis; i++) {\n        sb_ha_chassis = sb_ha_grp->ha_chassis[i];\n        const char *chassis_name = smap_get(&sb_ha_chassis->external_ids,\n                                            \"chassis-name\");\n\n        if (!chassis_name) {\n            changed = true;\n            break;\n        }\n\n        nb_ha_chassis = shash_find_and_delete(&nb_ha_chassis_list,\n                                              chassis_name);\n        if (!nb_ha_chassis ||\n            nb_ha_chassis->priority != sb_ha_chassis->priority) {\n            changed = true;\n            break;\n        }\n\n        if (sb_ha_chassis->chassis &&\n            strcmp(sb_ha_chassis->chassis->name, chassis_name)) {\n            /* sb_ha_chassis->chassis's name is different from the one\n             * in sb_ha_chassis->external_ids:chassis-name. */\n            changed = true;\n            break;\n        }\n\n        if (!sb_ha_chassis->chassis &&\n            chassis_lookup_by_name(sbrec_chassis_by_name,\n                                   chassis_name)) {\n            /* sb_ha_chassis->chassis is NULL, but the chassis is\n             * present in Chassis table. */\n            changed = true;\n            break;\n        }\n    }\n\n    struct shash_node *node;\n    SHASH_FOR_EACH_SAFE (node, &nb_ha_chassis_list) {\n        shash_delete(&nb_ha_chassis_list, node);\n        changed = true;\n    }\n    shash_destroy(&nb_ha_chassis_list);\n\n    return changed;\n}\n\nstatic void\nsync_ha_chassis_group_for_sbpb(struct northd_input *input_data,\n                               struct ovsdb_idl_txn *ovnsb_txn,\n                               const struct nbrec_ha_chassis_group *nb_ha_grp,\n                               struct ovsdb_idl_index *sbrec_chassis_by_name,\n                               const struct sbrec_port_binding *pb)\n{\n    bool new_sb_chassis_group = false;\n    const struct sbrec_ha_chassis_group *sb_ha_grp =\n        ha_chassis_group_lookup_by_name(\n            input_data->sbrec_ha_chassis_grp_by_name, nb_ha_grp->name);\n\n    if (!sb_ha_grp) {\n        sb_ha_grp = sbrec_ha_chassis_group_insert(ovnsb_txn);\n        sbrec_ha_chassis_group_set_name(sb_ha_grp, nb_ha_grp->name);\n        new_sb_chassis_group = true;\n    }\n\n    if (new_sb_chassis_group ||\n        chassis_group_list_changed(nb_ha_grp, sb_ha_grp,\n                                   sbrec_chassis_by_name)) {\n        struct sbrec_ha_chassis **sb_ha_chassis = NULL;\n        size_t n_ha_chassis = nb_ha_grp->n_ha_chassis;\n        sb_ha_chassis = xcalloc(n_ha_chassis, sizeof *sb_ha_chassis);\n        for (size_t i = 0; i < nb_ha_grp->n_ha_chassis; i++) {\n            const struct nbrec_ha_chassis *nb_ha_chassis\n                = nb_ha_grp->ha_chassis[i];\n            const struct sbrec_chassis *chassis =\n                chassis_lookup_by_name(sbrec_chassis_by_name,\n                                       nb_ha_chassis->chassis_name);\n            sb_ha_chassis[i] = sbrec_ha_chassis_insert(ovnsb_txn);\n            /* It's perfectly ok if the chassis is NULL. This could\n             * happen when ovn-controller exits and removes its row\n             * from the chassis table in OVN SB DB. */\n            sbrec_ha_chassis_set_chassis(sb_ha_chassis[i], chassis);\n            sbrec_ha_chassis_set_priority(sb_ha_chassis[i],\n                                          nb_ha_chassis->priority);\n            const struct smap external_ids =\n                SMAP_CONST1(&external_ids, \"chassis-name\",\n                            nb_ha_chassis->chassis_name);\n            sbrec_ha_chassis_set_external_ids(sb_ha_chassis[i], &external_ids);\n        }\n        sbrec_ha_chassis_group_set_ha_chassis(sb_ha_grp, sb_ha_chassis,\n                                              n_ha_chassis);\n        free(sb_ha_chassis);\n    }\n\n    sbrec_port_binding_set_ha_chassis_group(pb, sb_ha_grp);\n}\n\n/* This functions translates the gw chassis on the nb database\n * to HA chassis group in the sb database entries.\n */\nstatic void\ncopy_gw_chassis_from_nbrp_to_sbpb(\n        struct northd_input *input_data,\n        struct ovsdb_idl_txn *ovnsb_txn,\n        struct ovsdb_idl_index *sbrec_chassis_by_name,\n        const struct nbrec_logical_router_port *lrp,\n        const struct sbrec_port_binding *port_binding)\n{\n\n    /* Make use of the new HA chassis group table to support HA\n     * for the distributed gateway router port. */\n    const struct sbrec_ha_chassis_group *sb_ha_chassis_group =\n        ha_chassis_group_lookup_by_name(\n            input_data->sbrec_ha_chassis_grp_by_name, lrp->name);\n    if (!sb_ha_chassis_group) {\n        sb_ha_chassis_group = sbrec_ha_chassis_group_insert(ovnsb_txn);\n        sbrec_ha_chassis_group_set_name(sb_ha_chassis_group, lrp->name);\n    }\n\n    struct sbrec_ha_chassis **sb_ha_chassis = xcalloc(lrp->n_gateway_chassis,\n                                                      sizeof *sb_ha_chassis);\n    size_t n_sb_ha_ch = 0;\n    for (size_t n = 0; n < lrp->n_gateway_chassis; n++) {\n        struct nbrec_gateway_chassis *lrp_gwc = lrp->gateway_chassis[n];\n        if (!lrp_gwc->chassis_name) {\n            continue;\n        }\n\n        const struct sbrec_chassis *chassis =\n            chassis_lookup_by_name(sbrec_chassis_by_name,\n                                   lrp_gwc->chassis_name);\n\n        sb_ha_chassis[n_sb_ha_ch] =\n            create_sb_ha_chassis(ovnsb_txn, chassis, lrp_gwc->chassis_name,\n                                 lrp_gwc->priority);\n        n_sb_ha_ch++;\n    }\n\n    sbrec_ha_chassis_group_set_ha_chassis(sb_ha_chassis_group,\n                                          sb_ha_chassis, n_sb_ha_ch);\n    sbrec_port_binding_set_ha_chassis_group(port_binding, sb_ha_chassis_group);\n    free(sb_ha_chassis);\n}\n\nstatic const char*\nop_get_name(const struct ovn_port *op)\n{\n    ovs_assert(op->nbsp || op->nbrp);\n    const char *name = op->nbsp ? op->nbsp->name\n                                : op->nbrp->name;\n    return name;\n}\n\nstatic void\novn_update_ipv6_prefix(struct hmap *ports)\n{\n    const struct ovn_port *op;\n    HMAP_FOR_EACH (op, key_node, ports) {\n        if (!op->nbrp) {\n            continue;\n        }\n\n        if (!smap_get_bool(&op->nbrp->options, \"prefix\", false)) {\n            continue;\n        }\n\n        char prefix[IPV6_SCAN_LEN + 6];\n        unsigned aid;\n        const char *ipv6_pd_list = smap_get(&op->sb->options,\n                                            \"ipv6_ra_pd_list\");\n        if (!ipv6_pd_list ||\n            !ovs_scan(ipv6_pd_list, \"%u:%s\", &aid, prefix)) {\n            continue;\n        }\n\n        const char *prefix_ptr = prefix;\n        nbrec_logical_router_port_set_ipv6_prefix(op->nbrp, &prefix_ptr, 1);\n    }\n}\n\nstatic const struct sbrec_chassis *\nchassis_lookup(struct ovsdb_idl_index *sbrec_chassis_by_name,\n               struct ovsdb_idl_index *sbrec_chassis_by_hostname,\n               const char *name_or_hostname)\n{\n    const struct sbrec_chassis *chassis; /* May be NULL. */\n    chassis = chassis_lookup_by_name(sbrec_chassis_by_name,\n                                     name_or_hostname);\n    return chassis ? chassis : chassis_lookup_by_hostname(\n                    sbrec_chassis_by_hostname, name_or_hostname);\n}\n\nstatic void\novn_port_update_sbrec_chassis(\n        struct ovsdb_idl_index *sbrec_chassis_by_name,\n        struct ovsdb_idl_index *sbrec_chassis_by_hostname,\n        const struct ovn_port *op)\n{\n    const char *requested_chassis; /* May be NULL. */\n\n    size_t n_requested_chassis = 0;\n    struct sbrec_chassis **requested_chassis_sb = xcalloc(\n        n_requested_chassis, sizeof *requested_chassis_sb);\n\n    requested_chassis = smap_get(&op->nbsp->options,\n                                 \"requested-chassis\");\n    if (requested_chassis) {\n        char *tokstr = xstrdup(requested_chassis);\n        char *save_ptr = NULL;\n        char *chassis;\n        for (chassis = strtok_r(tokstr, \",\", &save_ptr); chassis != NULL;\n             chassis = strtok_r(NULL, \",\", &save_ptr)) {\n            const struct sbrec_chassis *chassis_sb = chassis_lookup(\n                sbrec_chassis_by_name, sbrec_chassis_by_hostname, chassis);\n            if (chassis_sb) {\n                requested_chassis_sb = xrealloc(\n                    requested_chassis_sb,\n                    ++n_requested_chassis * (sizeof *requested_chassis_sb));\n                requested_chassis_sb[n_requested_chassis - 1] = (\n                    (struct sbrec_chassis *) chassis_sb);\n            } else {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(\n                    1, 1);\n                VLOG_WARN_RL(\n                    &rl,\n                    \"Unknown chassis '%s' set in \"\n                    \"options:requested-chassis on LSP '%s'.\",\n                    chassis, op->nbsp->name);\n            }\n        }\n        free(tokstr);\n    }\n\n    if (n_requested_chassis > 0) {\n        sbrec_port_binding_set_requested_chassis(op->sb,\n                                                 *requested_chassis_sb);\n    } else {\n        sbrec_port_binding_set_requested_chassis(op->sb, NULL);\n    }\n    if (n_requested_chassis > 1) {\n        sbrec_port_binding_set_requested_additional_chassis(\n            op->sb, &requested_chassis_sb[1], n_requested_chassis - 1);\n    } else {\n        sbrec_port_binding_set_requested_additional_chassis(op->sb, NULL, 0);\n    }\n    free(requested_chassis_sb);\n}\n\nstatic void\ncheck_and_do_sb_mirror_deletion(const struct ovn_port *op)\n{\n    size_t i = 0;\n    struct shash nb_mirror_rules = SHASH_INITIALIZER(&nb_mirror_rules);\n\n    for (i = 0; i < op->nbsp->n_mirror_rules; i++) {\n        shash_add(&nb_mirror_rules,\n                  op->nbsp->mirror_rules[i]->name,\n                  op->nbsp->mirror_rules[i]);\n    }\n\n    for (i = 0; i < op->sb->n_mirror_rules; i++) {\n        if (!shash_find(&nb_mirror_rules,\n                        op->sb->mirror_rules[i]->name)) {\n            /* Delete from SB since its not present in NB*/\n            sbrec_port_binding_update_mirror_rules_delvalue(op->sb,\n                                             op->sb->mirror_rules[i]);\n        }\n    }\n\n    struct shash_node *node, *next;\n    SHASH_FOR_EACH_SAFE (node, next, &nb_mirror_rules) {\n        shash_delete(&nb_mirror_rules, node);\n    }\n    shash_destroy(&nb_mirror_rules);\n}\n\nstatic void\ncheck_and_do_sb_mirror_addition(struct northd_input *input_data,\n                                const struct ovn_port *op)\n{\n    for (size_t i = 0; i < op->nbsp->n_mirror_rules; i++) {\n        const struct sbrec_mirror *sb_mirror;\n        SBREC_MIRROR_TABLE_FOR_EACH (sb_mirror,\n                                     input_data->sbrec_mirror_table) {\n            if (!strcmp(sb_mirror->name,\n                        op->nbsp->mirror_rules[i]->name)) {\n                /* Add the value to SB */\n                sbrec_port_binding_update_mirror_rules_addvalue(op->sb,\n                                                                sb_mirror);\n            }\n        }\n    }\n}\n\nstatic void\nsbrec_port_binding_update_mirror_rules(struct northd_input *input_data,\n                                       const struct ovn_port *op)\n{\n    check_and_do_sb_mirror_deletion(op);\n    check_and_do_sb_mirror_addition(input_data, op);\n}\n\n/* Return true if given ovn_port has peer and this peer's ovn_datapath\n * has_vtep_lports set to true. False otherwise. */\nstatic bool\nl3dgw_port_has_associated_vtep_lports(const struct ovn_port *op)\n{\n    return op->peer && op->peer->od->has_vtep_lports;\n}\n\nstatic void\novn_port_update_sbrec(struct northd_input *input_data,\n                      struct ovsdb_idl_txn *ovnsb_txn,\n                      struct ovsdb_idl_index *sbrec_chassis_by_name,\n                      struct ovsdb_idl_index *sbrec_chassis_by_hostname,\n                      const struct ovn_port *op,\n                      struct hmap *chassis_qdisc_queues,\n                      struct sset *active_ha_chassis_grps)\n{\n    sbrec_port_binding_set_datapath(op->sb, op->od->sb);\n    if (op->nbrp) {\n        /* If the router is for l3 gateway, it resides on a chassis\n         * and its port type is \"l3gateway\". */\n        const char *chassis_name = smap_get(&op->od->nbr->options, \"chassis\");\n        if (is_cr_port(op)) {\n            sbrec_port_binding_set_type(op->sb, \"chassisredirect\");\n        } else if (chassis_name) {\n            sbrec_port_binding_set_type(op->sb, \"l3gateway\");\n        } else {\n            sbrec_port_binding_set_type(op->sb, \"patch\");\n        }\n\n        struct smap new;\n        smap_init(&new);\n        if (is_cr_port(op)) {\n            const char *redirect_type = smap_get(&op->nbrp->options,\n                                                 \"redirect-type\");\n\n            if (op->nbrp->ha_chassis_group) {\n                if (op->nbrp->n_gateway_chassis) {\n                    static struct vlog_rate_limit rl\n                        = VLOG_RATE_LIMIT_INIT(1, 1);\n                    VLOG_WARN_RL(&rl, \"Both ha_chassis_group and \"\n                                 \"gateway_chassis configured on port %s; \"\n                                 \"ignoring the latter.\", op->nbrp->name);\n                }\n\n                /* HA Chassis group is set. Ignore 'gateway_chassis'. */\n                sync_ha_chassis_group_for_sbpb(input_data, ovnsb_txn,\n                                               op->nbrp->ha_chassis_group,\n                                               sbrec_chassis_by_name, op->sb);\n                sset_add(active_ha_chassis_grps,\n                         op->nbrp->ha_chassis_group->name);\n            } else if (op->nbrp->n_gateway_chassis) {\n                /* Legacy gateway_chassis support.\n                 * Create ha_chassis_group for the Northbound gateway_chassis\n                 * associated with the lrp. */\n                if (sbpb_gw_chassis_needs_update(op->sb, op->nbrp,\n                                                 sbrec_chassis_by_name)) {\n                    copy_gw_chassis_from_nbrp_to_sbpb(input_data,\n                                                      ovnsb_txn,\n                                                      sbrec_chassis_by_name,\n                                                      op->nbrp, op->sb);\n                }\n\n                sset_add(active_ha_chassis_grps, op->nbrp->name);\n            } else {\n                /* Nothing is set. Clear ha_chassis_group  from pb. */\n                if (op->sb->ha_chassis_group) {\n                    sbrec_port_binding_set_ha_chassis_group(op->sb, NULL);\n                }\n            }\n\n            if (op->sb->n_gateway_chassis) {\n                /* Delete the legacy gateway_chassis from the pb. */\n                sbrec_port_binding_set_gateway_chassis(op->sb, NULL, 0);\n            }\n            smap_add(&new, \"distributed-port\", op->nbrp->name);\n\n            bool always_redirect =\n                !op->od->has_distributed_nat &&\n                !l3dgw_port_has_associated_vtep_lports(op->l3dgw_port);\n\n            if (redirect_type) {\n                smap_add(&new, \"redirect-type\", redirect_type);\n                /* XXX Why can't we enable always-redirect when redirect-type\n                 * is bridged? */\n                if (!strcmp(redirect_type, \"bridged\")) {\n                    always_redirect = false;\n                }\n            }\n\n            if (always_redirect) {\n                smap_add(&new, \"always-redirect\", \"true\");\n            }\n        } else {\n            if (op->peer) {\n                smap_add(&new, \"peer\", op->peer->key);\n                if (op->nbrp->ha_chassis_group ||\n                    op->nbrp->n_gateway_chassis) {\n                    char *redirect_name =\n                        ovn_chassis_redirect_name(op->nbrp->name);\n                    smap_add(&new, \"chassis-redirect-port\", redirect_name);\n                    free(redirect_name);\n                }\n            }\n            if (chassis_name) {\n                smap_add(&new, \"l3gateway-chassis\", chassis_name);\n            }\n        }\n\n        const char *ipv6_pd_list = smap_get(&op->sb->options,\n                                            \"ipv6_ra_pd_list\");\n        if (ipv6_pd_list) {\n            smap_add(&new, \"ipv6_ra_pd_list\", ipv6_pd_list);\n        }\n\n        sbrec_port_binding_set_options(op->sb, &new);\n        smap_destroy(&new);\n\n        sbrec_port_binding_set_parent_port(op->sb, NULL);\n        sbrec_port_binding_set_tag(op->sb, NULL, 0);\n\n        struct ds s = DS_EMPTY_INITIALIZER;\n        ds_put_cstr(&s, op->nbrp->mac);\n        for (int i = 0; i < op->nbrp->n_networks; ++i) {\n            ds_put_format(&s, \" %s\", op->nbrp->networks[i]);\n        }\n        const char *addresses = ds_cstr(&s);\n        sbrec_port_binding_set_mac(op->sb, &addresses, 1);\n        ds_destroy(&s);\n\n        sbrec_port_binding_set_external_ids(op->sb, &op->nbrp->external_ids);\n\n        sbrec_port_binding_set_nat_addresses(op->sb, NULL, 0);\n    } else {\n        if (!lsp_is_router(op->nbsp)) {\n            uint32_t queue_id = smap_get_int(\n                    &op->sb->options, \"qdisc_queue_id\", 0);\n            bool has_qos = port_has_qos_params(&op->nbsp->options);\n            const struct uuid *uuid = NULL;\n            struct smap options;\n            char *name = \"\";\n\n            if (lsp_is_localnet(op->nbsp)) {\n                uuid = &op->sb->header_.uuid;\n                name = \"localnet\";\n            } else if (op->sb->chassis) {\n                uuid = &op->sb->chassis->header_.uuid;\n                name = op->sb->chassis->name;\n            }\n\n            if (has_qos && !queue_id) {\n                queue_id = allocate_chassis_queueid(chassis_qdisc_queues,\n                                                    uuid, name);\n            } else if (!has_qos && queue_id) {\n                free_chassis_queueid(chassis_qdisc_queues, uuid, queue_id);\n                queue_id = 0;\n            }\n\n            smap_clone(&options, &op->nbsp->options);\n            if (queue_id) {\n                smap_add_format(&options,\n                                \"qdisc_queue_id\", \"%d\", queue_id);\n            }\n\n            if (smap_get_bool(&op->od->nbs->other_config, \"vlan-passthru\", false)) {\n                smap_add(&options, \"vlan-passthru\", \"true\");\n            }\n\n            /* Retain activated chassis flags. */\n            if (op->sb->requested_additional_chassis) {\n                const char *activated_str = smap_get(\n                    &op->sb->options, \"additional-chassis-activated\");\n                if (activated_str) {\n                    smap_add(&options, \"additional-chassis-activated\",\n                             activated_str);\n                }\n            }\n\n            sbrec_port_binding_set_options(op->sb, &options);\n            smap_destroy(&options);\n            if (ovn_is_known_nb_lsp_type(op->nbsp->type)) {\n                sbrec_port_binding_set_type(op->sb, op->nbsp->type);\n            } else {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n                VLOG_WARN_RL(\n                    &rl, \"Unknown port type '%s' set on logical switch '%s'.\",\n                    op->nbsp->type, op->nbsp->name);\n            }\n\n            sbrec_port_binding_set_nat_addresses(op->sb, NULL, 0);\n\n            if (!strcmp(op->nbsp->type, \"external\")) {\n                if (op->nbsp->ha_chassis_group) {\n                    sync_ha_chassis_group_for_sbpb(\n                        input_data,\n                        ovnsb_txn, op->nbsp->ha_chassis_group,\n                        sbrec_chassis_by_name, op->sb);\n                    sset_add(active_ha_chassis_grps,\n                             op->nbsp->ha_chassis_group->name);\n                } else {\n                    sbrec_port_binding_set_ha_chassis_group(op->sb, NULL);\n                }\n            } else if (op->sb->ha_chassis_group) {\n                /* Clear the port bindings ha_chassis_group if the type is\n                 * not external and if this column is set.  This can happen\n                 * when an external port is reset to type normal and\n                 * ha_chassis_group cleared in the same transaction. */\n                sbrec_port_binding_set_ha_chassis_group(op->sb, NULL);\n            }\n\n            ovn_port_update_sbrec_chassis(sbrec_chassis_by_name,\n                                          sbrec_chassis_by_hostname, op);\n        } else {\n            const char *chassis = NULL;\n            if (op->peer && op->peer->od && op->peer->od->nbr) {\n                chassis = smap_get(&op->peer->od->nbr->options, \"chassis\");\n            }\n\n            /* A switch port connected to a gateway router is also of\n             * type \"l3gateway\". */\n            if (chassis) {\n                sbrec_port_binding_set_type(op->sb, \"l3gateway\");\n            } else {\n                sbrec_port_binding_set_type(op->sb, \"patch\");\n            }\n\n            const char *router_port = smap_get(&op->nbsp->options,\n                                               \"router-port\");\n            if (router_port || chassis) {\n                struct smap new;\n                smap_init(&new);\n                if (router_port) {\n                    smap_add(&new, \"peer\", router_port);\n                }\n                if (chassis) {\n                    smap_add(&new, \"l3gateway-chassis\", chassis);\n                }\n                sbrec_port_binding_set_options(op->sb, &new);\n                smap_destroy(&new);\n            } else {\n                sbrec_port_binding_set_options(op->sb, NULL);\n            }\n            const char *nat_addresses = smap_get(&op->nbsp->options,\n                                           \"nat-addresses\");\n            size_t n_nats = 0;\n            char **nats = NULL;\n            bool l3dgw_ports = op->peer && op->peer->od &&\n                               op->peer->od->n_l3dgw_ports;\n            if (nat_addresses && !strcmp(nat_addresses, \"router\")) {\n                if (op->peer && op->peer->od\n                    && (chassis || op->peer->od->n_l3dgw_ports)) {\n                    bool exclude_lb_vips = smap_get_bool(&op->nbsp->options,\n                            \"exclude-lb-vips-from-garp\", false);\n                    nats = get_nat_addresses(op->peer, &n_nats, false,\n                                             !exclude_lb_vips);\n                }\n            } else if (nat_addresses && (chassis || l3dgw_ports)) {\n                struct lport_addresses laddrs;\n                if (!extract_lsp_addresses(nat_addresses, &laddrs)) {\n                    static struct vlog_rate_limit rl =\n                        VLOG_RATE_LIMIT_INIT(1, 1);\n                    VLOG_WARN_RL(&rl, \"Error extracting nat-addresses.\");\n                } else {\n                    destroy_lport_addresses(&laddrs);\n                    n_nats = 1;\n                    nats = xcalloc(1, sizeof *nats);\n                    struct ds nat_addr = DS_EMPTY_INITIALIZER;\n                    ds_put_format(&nat_addr, \"%s\", nat_addresses);\n                    if (l3dgw_ports) {\n                        const struct ovn_port *l3dgw_port = (\n                            is_l3dgw_port(op->peer)\n                            ? op->peer\n                            : op->peer->od->l3dgw_ports[0]);\n                        ds_put_format(&nat_addr, \" is_chassis_resident(%s)\",\n                            l3dgw_port->cr_port->json_key);\n                    }\n                    nats[0] = xstrdup(ds_cstr(&nat_addr));\n                    ds_destroy(&nat_addr);\n                }\n            }\n\n            /* Add the router mac and IPv4 addresses to\n             * Port_Binding.nat_addresses so that GARP is sent for these\n             * IPs by the ovn-controller on which the distributed gateway\n             * router port resides if:\n             *\n             * -  op->peer has 'reside-on-redirect-chassis' set and the\n             *    the logical router datapath has distributed router port.\n             *\n             * -  op->peer is distributed gateway router port.\n             *\n             * -  op->peer's router is a gateway router and op has a localnet\n             *    port.\n             *\n             * Note: Port_Binding.nat_addresses column is also used for\n             * sending the GARPs for the router port IPs.\n             * */\n            bool add_router_port_garp = false;\n            if (op->peer && op->peer->nbrp && op->peer->od->n_l3dgw_ports) {\n                if (is_l3dgw_port(op->peer)) {\n                    add_router_port_garp = true;\n                } else if (smap_get_bool(&op->peer->nbrp->options,\n                               \"reside-on-redirect-chassis\", false)) {\n                    if (op->peer->od->n_l3dgw_ports == 1) {\n                        add_router_port_garp = true;\n                    } else {\n                        static struct vlog_rate_limit rl =\n                            VLOG_RATE_LIMIT_INIT(1, 1);\n                        VLOG_WARN_RL(&rl, \"\\\"reside-on-redirect-chassis\\\" is \"\n                                     \"set on logical router port %s, which \"\n                                     \"is on logical router %s, which has %\"\n                                     PRIuSIZE\" distributed gateway ports. This\"\n                                     \"option can only be used when there is \"\n                                     \"a single distributed gateway port.\",\n                                     op->peer->key, op->peer->od->nbr->name,\n                                     op->peer->od->n_l3dgw_ports);\n                    }\n                }\n            } else if (chassis && op->od->n_localnet_ports) {\n                add_router_port_garp = true;\n            }\n\n            if (add_router_port_garp) {\n                struct ds garp_info = DS_EMPTY_INITIALIZER;\n                ds_put_format(&garp_info, \"%s\", op->peer->lrp_networks.ea_s);\n\n                for (size_t i = 0; i < op->peer->lrp_networks.n_ipv4_addrs;\n                     i++) {\n                    ds_put_format(&garp_info, \" %s\",\n                                  op->peer->lrp_networks.ipv4_addrs[i].addr_s);\n                }\n\n                if (op->peer->od->n_l3dgw_ports) {\n                    const struct ovn_port *l3dgw_port = (\n                        is_l3dgw_port(op->peer)\n                        ? op->peer\n                        : op->peer->od->l3dgw_ports[0]);\n                    ds_put_format(&garp_info, \" is_chassis_resident(%s)\",\n                                  l3dgw_port->cr_port->json_key);\n                }\n\n                n_nats++;\n                nats = xrealloc(nats, (n_nats * sizeof *nats));\n                nats[n_nats - 1] = ds_steal_cstr(&garp_info);\n                ds_destroy(&garp_info);\n            }\n            sbrec_port_binding_set_nat_addresses(op->sb,\n                                                 (const char **) nats, n_nats);\n            for (size_t i = 0; i < n_nats; i++) {\n                free(nats[i]);\n            }\n            free(nats);\n        }\n\n        sbrec_port_binding_set_parent_port(op->sb, op->nbsp->parent_name);\n        sbrec_port_binding_set_tag(op->sb, op->nbsp->tag, op->nbsp->n_tag);\n        sbrec_port_binding_set_mac(op->sb, (const char **) op->nbsp->addresses,\n                                   op->nbsp->n_addresses);\n        sbrec_port_binding_set_port_security(\n            op->sb, (const char **) op->nbsp->port_security,\n            op->nbsp->n_port_security);\n\n        struct smap ids = SMAP_INITIALIZER(&ids);\n        smap_clone(&ids, &op->nbsp->external_ids);\n        const char *name = smap_get(&ids, \"neutron:port_name\");\n        if (name && name[0]) {\n            smap_add(&ids, \"name\", name);\n        }\n        sbrec_port_binding_set_external_ids(op->sb, &ids);\n        smap_destroy(&ids);\n\n        if (!op->nbsp->n_mirror_rules) {\n            /* Nothing is set. Clear mirror_rules from pb. */\n            sbrec_port_binding_set_mirror_rules(op->sb, NULL, 0);\n        } else {\n            /* Check if SB DB update needed */\n            sbrec_port_binding_update_mirror_rules(input_data, op);\n        }\n\n    }\n    if (op->tunnel_key != op->sb->tunnel_key) {\n        sbrec_port_binding_set_tunnel_key(op->sb, op->tunnel_key);\n    }\n\n    /* ovn-controller will update 'Port_Binding.up' only if it was explicitly\n     * set to 'false'.\n     */\n    if (!op->sb->n_up) {\n        bool up = false;\n        sbrec_port_binding_set_up(op->sb, &up, 1);\n    }\n}\n\n/* Remove mac_binding entries that refer to logical_ports which are\n * deleted. */\nstatic void\ncleanup_mac_bindings(struct northd_input *input_data,\n                     struct hmap *datapaths,\n                     struct hmap *ports)\n{\n    const struct sbrec_mac_binding *b;\n    SBREC_MAC_BINDING_TABLE_FOR_EACH_SAFE (b,\n                             input_data->sbrec_mac_binding_table) {\n        const struct ovn_datapath *od =\n            ovn_datapath_from_sbrec(datapaths, b->datapath);\n\n        if (!od || ovn_datapath_is_stale(od) ||\n                !ovn_port_find(ports, b->logical_port)) {\n            sbrec_mac_binding_delete(b);\n        }\n    }\n}\n\nstatic void\ncleanup_sb_ha_chassis_groups(struct northd_input *input_data,\n                             struct sset *active_ha_chassis_groups)\n{\n    const struct sbrec_ha_chassis_group *b;\n    SBREC_HA_CHASSIS_GROUP_TABLE_FOR_EACH_SAFE (b,\n                                input_data->sbrec_ha_chassis_group_table) {\n        if (!sset_contains(active_ha_chassis_groups, b->name)) {\n            sbrec_ha_chassis_group_delete(b);\n        }\n    }\n}\n\nstatic void\ncleanup_stale_fdb_entries(struct northd_input *input_data,\n                          struct hmap *datapaths)\n{\n    const struct sbrec_fdb *fdb_e;\n    SBREC_FDB_TABLE_FOR_EACH_SAFE (fdb_e,\n                         input_data->sbrec_fdb_table) {\n        bool delete = true;\n        struct ovn_datapath *od\n            = ovn_datapath_find_by_key(datapaths, fdb_e->dp_key);\n        if (od) {\n            if (ovn_tnlid_present(&od->port_tnlids, fdb_e->port_key)) {\n                delete = false;\n            }\n        }\n\n        if (delete) {\n            sbrec_fdb_delete(fdb_e);\n        }\n    }\n}\n\nstruct service_monitor_info {\n    struct hmap_node hmap_node;\n    const struct sbrec_service_monitor *sbrec_mon;\n    bool required;\n};\n\n\nstatic struct service_monitor_info *\ncreate_or_get_service_mon(struct ovsdb_idl_txn *ovnsb_txn,\n                          struct hmap *monitor_map,\n                          const char *ip, const char *logical_port,\n                          uint16_t service_port, const char *protocol)\n{\n    uint32_t hash = service_port;\n    hash = hash_string(ip, hash);\n    hash = hash_string(logical_port, hash);\n    struct service_monitor_info *mon_info;\n\n    HMAP_FOR_EACH_WITH_HASH (mon_info, hmap_node, hash, monitor_map) {\n        if (mon_info->sbrec_mon->port == service_port &&\n            !strcmp(mon_info->sbrec_mon->ip, ip) &&\n            !strcmp(mon_info->sbrec_mon->protocol, protocol) &&\n            !strcmp(mon_info->sbrec_mon->logical_port, logical_port)) {\n            return mon_info;\n        }\n    }\n\n    struct sbrec_service_monitor *sbrec_mon =\n        sbrec_service_monitor_insert(ovnsb_txn);\n    sbrec_service_monitor_set_ip(sbrec_mon, ip);\n    sbrec_service_monitor_set_port(sbrec_mon, service_port);\n    sbrec_service_monitor_set_logical_port(sbrec_mon, logical_port);\n    sbrec_service_monitor_set_protocol(sbrec_mon, protocol);\n    mon_info = xzalloc(sizeof *mon_info);\n    mon_info->sbrec_mon = sbrec_mon;\n    hmap_insert(monitor_map, &mon_info->hmap_node, hash);\n    return mon_info;\n}\n\nstatic void\novn_lb_svc_create(struct ovsdb_idl_txn *ovnsb_txn, struct ovn_northd_lb *lb,\n                  struct hmap *monitor_map, struct hmap *ports)\n{\n    if (lb->template) {\n        return;\n    }\n\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n        struct ovn_northd_lb_vip *lb_vip_nb = &lb->vips_nb[i];\n\n        for (size_t j = 0; j < lb_vip->n_backends; j++) {\n            struct ovn_lb_backend *backend = &lb_vip->backends[j];\n            struct ovn_northd_lb_backend *backend_nb =\n                &lb_vip_nb->backends_nb[j];\n\n            struct ovn_port *op = NULL;\n            char *svc_mon_src_ip = NULL;\n\n            struct ds key = DS_EMPTY_INITIALIZER;\n            ds_put_format(&key,\n                          IN6_IS_ADDR_V4MAPPED(&lb_vip->vip)\n                          ? \"%s\" : \"[%s]\", backend->ip_str);\n\n            const char *s = smap_get(&lb->nlb->ip_port_mappings,\n                                     ds_cstr(&key));\n            if (s) {\n                char *port_name = xstrdup(s);\n                char *p = strstr(port_name, \":\");\n                if (p) {\n                    *p = 0;\n                    p++;\n                    op = ovn_port_find(ports, port_name);\n                    struct sockaddr_storage svc_mon_src_addr;\n                    if (!inet_parse_address(p, &svc_mon_src_addr)) {\n                        static struct vlog_rate_limit rl =\n                            VLOG_RATE_LIMIT_INIT(5, 1);\n                        VLOG_WARN_RL(&rl, \"Invalid svc mon src IP %s\", p);\n                    } else {\n                        struct ds src_ip_s = DS_EMPTY_INITIALIZER;\n                        ss_format_address_nobracks(&svc_mon_src_addr,\n                                                   &src_ip_s);\n                        svc_mon_src_ip = ds_steal_cstr(&src_ip_s);\n                    }\n                }\n                free(port_name);\n            }\n            ds_destroy(&key);\n\n            backend_nb->op = op;\n            backend_nb->svc_mon_src_ip = svc_mon_src_ip;\n\n            if (!lb_vip_nb->lb_health_check || !op || !svc_mon_src_ip ||\n                !lsp_is_enabled(op->nbsp)) {\n                continue;\n            }\n\n            const char *protocol = lb->nlb->protocol;\n            if (!protocol || !protocol[0]) {\n                protocol = \"tcp\";\n            }\n            backend_nb->health_check = true;\n            struct service_monitor_info *mon_info =\n                create_or_get_service_mon(ovnsb_txn, monitor_map,\n                                          backend->ip_str,\n                                          backend_nb->op->nbsp->name,\n                                          backend->port,\n                                          protocol);\n            ovs_assert(mon_info);\n            sbrec_service_monitor_set_options(\n                mon_info->sbrec_mon, &lb_vip_nb->lb_health_check->options);\n            struct eth_addr ea;\n            if (!mon_info->sbrec_mon->src_mac ||\n                !eth_addr_from_string(mon_info->sbrec_mon->src_mac, &ea) ||\n                !eth_addr_equals(ea, svc_monitor_mac_ea)) {\n                sbrec_service_monitor_set_src_mac(mon_info->sbrec_mon,\n                                                  svc_monitor_mac);\n            }\n\n            if (!mon_info->sbrec_mon->src_ip ||\n                strcmp(mon_info->sbrec_mon->src_ip,\n                       backend_nb->svc_mon_src_ip)) {\n                sbrec_service_monitor_set_src_ip(\n                    mon_info->sbrec_mon,\n                    backend_nb->svc_mon_src_ip);\n            }\n\n            if ((!op->sb->n_up || !op->sb->up[0])\n                && mon_info->sbrec_mon->status\n                && !strcmp(mon_info->sbrec_mon->status, \"online\")) {\n                sbrec_service_monitor_set_status(mon_info->sbrec_mon,\n                                                 \"offline\");\n            }\n\n            backend_nb->sbrec_monitor = mon_info->sbrec_mon;\n            mon_info->required = true;\n        }\n    }\n}\n\nstatic bool\nbuild_lb_vip_actions(struct ovn_lb_vip *lb_vip,\n                     struct ovn_northd_lb_vip *lb_vip_nb,\n                     struct ds *action, char *selection_fields,\n                     struct ds *skip_snat_action, struct ds *force_snat_action,\n                     bool ls_dp, const struct chassis_features *features)\n{\n    const char *ct_lb_action =\n        features->ct_no_masked_label ? \"ct_lb_mark\" : \"ct_lb\";\n    bool reject = !lb_vip->n_backends && lb_vip->empty_backend_rej;\n    bool drop = !lb_vip->n_backends && !lb_vip->empty_backend_rej;\n\n    if (lb_vip_nb->lb_health_check) {\n        ds_put_format(action, \"%s(backends=\", ct_lb_action);\n\n        size_t n_active_backends = 0;\n        for (size_t i = 0; i < lb_vip->n_backends; i++) {\n            struct ovn_lb_backend *backend = &lb_vip->backends[i];\n            struct ovn_northd_lb_backend *backend_nb =\n                &lb_vip_nb->backends_nb[i];\n            if (!backend_nb->health_check ||\n                (backend_nb->health_check && backend_nb->sbrec_monitor &&\n                 backend_nb->sbrec_monitor->status &&\n                 strcmp(backend_nb->sbrec_monitor->status, \"online\"))) {\n                continue;\n            }\n\n            n_active_backends++;\n            bool ipv6 = !IN6_IS_ADDR_V4MAPPED(&backend->ip);\n            ds_put_format(action, ipv6 ? \"[%s]:%\"PRIu16\",\" : \"%s:%\"PRIu16\",\",\n                          backend->ip_str, backend->port);\n        }\n        ds_chomp(action, ',');\n\n        drop = !n_active_backends && !lb_vip->empty_backend_rej;\n        reject = !n_active_backends && lb_vip->empty_backend_rej;\n    } else {\n        ds_put_format(action, \"%s(backends=%s\", ct_lb_action,\n                      lb_vip_nb->backend_ips);\n    }\n\n    if (reject) {\n        int stage = ls_dp ? ovn_stage_get_table(S_SWITCH_OUT_QOS_MARK)\n                          : ovn_stage_get_table(S_ROUTER_OUT_SNAT);\n        ds_clear(action);\n        ds_put_format(action, \"reg0 = 0; reject { outport <-> inport; \"\n                              \"next(pipeline=egress,table=%d);};\", stage);\n    } else if (drop) {\n        ds_clear(action);\n        ds_put_cstr(action, debug_drop_action());\n    } else if (selection_fields && selection_fields[0]) {\n        ds_put_format(action, \"; hash_fields=\\\"%s\\\"\", selection_fields);\n    }\n\n    bool is_lb_action = !(reject || drop);\n    const char *enclose = is_lb_action ? \");\" : \"\";\n\n    if (!ls_dp) {\n        bool flag_supported = is_lb_action && features->ct_lb_related;\n        ds_put_format(skip_snat_action, \"flags.skip_snat_for_lb = 1; %s%s\",\n                      ds_cstr(action),\n                      flag_supported ? \"; skip_snat);\" : enclose);\n        ds_put_format(force_snat_action, \"flags.force_snat_for_lb = 1; %s%s\",\n                      ds_cstr(action),\n                      flag_supported ? \"; force_snat);\" : enclose);\n    }\n\n    ds_put_cstr(action, enclose);\n\n    return reject;\n}\n\nstatic void\nbuild_lrouter_lb_ips(struct ovn_lb_ip_set *lb_ips,\n                     const struct ovn_northd_lb *lb)\n{\n    const char *ip_address;\n\n    SSET_FOR_EACH (ip_address, &lb->ips_v4) {\n        sset_add(&lb_ips->ips_v4, ip_address);\n        if (lb->routable) {\n            sset_add(&lb_ips->ips_v4_routable, ip_address);\n        }\n    }\n    SSET_FOR_EACH (ip_address, &lb->ips_v6) {\n        sset_add(&lb_ips->ips_v6, ip_address);\n        if (lb->routable) {\n            sset_add(&lb_ips->ips_v6_routable, ip_address);\n        }\n    }\n}\n\nstatic void\nbuild_lbs(struct northd_input *input_data, struct hmap *datapaths,\n          struct hmap *lbs, struct hmap *lb_groups)\n{\n    const struct nbrec_load_balancer_group *nbrec_lb_group;\n    struct ovn_lb_group *lb_group;\n    struct ovn_northd_lb *lb;\n\n    hmap_init(lbs);\n    hmap_init(lb_groups);\n\n    const struct nbrec_load_balancer *nbrec_lb;\n    NBREC_LOAD_BALANCER_TABLE_FOR_EACH (nbrec_lb,\n                               input_data->nbrec_load_balancer_table) {\n        struct ovn_northd_lb *lb_nb = ovn_northd_lb_create(nbrec_lb,\n                                                           n_datapaths);\n        hmap_insert(lbs, &lb_nb->hmap_node,\n                    uuid_hash(&nbrec_lb->header_.uuid));\n    }\n\n    NBREC_LOAD_BALANCER_GROUP_TABLE_FOR_EACH (nbrec_lb_group,\n                               input_data->nbrec_load_balancer_group_table) {\n        lb_group = ovn_lb_group_create(nbrec_lb_group, lbs,\n                                       hmap_count(datapaths));\n\n        for (size_t i = 0; i < lb_group->n_lbs; i++) {\n            build_lrouter_lb_ips(lb_group->lb_ips, lb_group->lbs[i]);\n        }\n\n        hmap_insert(lb_groups, &lb_group->hmap_node,\n                    uuid_hash(&lb_group->uuid));\n    }\n\n    struct ovn_datapath *od;\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs) {\n            continue;\n        }\n\n        for (size_t i = 0; i < od->nbs->n_load_balancer; i++) {\n            const struct uuid *lb_uuid =\n                &od->nbs->load_balancer[i]->header_.uuid;\n            lb = ovn_northd_lb_find(lbs, lb_uuid);\n            ovn_northd_lb_add_ls(lb, 1, &od);\n        }\n\n        for (size_t i = 0; i < od->nbs->n_load_balancer_group; i++) {\n            nbrec_lb_group = od->nbs->load_balancer_group[i];\n            lb_group = ovn_lb_group_find(lb_groups,\n                                         &nbrec_lb_group->header_.uuid);\n            ovn_lb_group_add_ls(lb_group, 1, &od);\n        }\n    }\n\n    HMAP_FOR_EACH (lb_group, hmap_node, lb_groups) {\n        for (size_t j = 0; j < lb_group->n_lbs; j++) {\n            ovn_northd_lb_add_ls(lb_group->lbs[j], lb_group->n_ls,\n                                 lb_group->ls);\n        }\n    }\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbr) {\n            continue;\n        }\n\n        /* Checking load balancer groups first, starting from the largest one,\n         * to more efficiently copy IP sets. */\n        size_t largest_group = 0;\n\n        for (size_t i = 1; i < od->nbr->n_load_balancer_group; i++) {\n            if (od->nbr->load_balancer_group[i]->n_load_balancer >\n                od->nbr->load_balancer_group[largest_group]->n_load_balancer) {\n                largest_group = i;\n            }\n        }\n\n        for (size_t i = 0; i < od->nbr->n_load_balancer_group; i++) {\n            size_t idx = (i + largest_group) % od->nbr->n_load_balancer_group;\n\n            nbrec_lb_group = od->nbr->load_balancer_group[idx];\n            lb_group = ovn_lb_group_find(lb_groups,\n                                         &nbrec_lb_group->header_.uuid);\n            ovn_lb_group_add_lr(lb_group, od);\n\n            if (!od->lb_ips) {\n                od->lb_ips = ovn_lb_ip_set_clone(lb_group->lb_ips);\n            } else {\n                for (size_t j = 0; j < lb_group->n_lbs; j++) {\n                    build_lrouter_lb_ips(od->lb_ips, lb_group->lbs[j]);\n                }\n            }\n        }\n\n        if (!od->lb_ips) {\n            od->lb_ips = ovn_lb_ip_set_create();\n        }\n\n        for (size_t i = 0; i < od->nbr->n_load_balancer; i++) {\n            const struct uuid *lb_uuid =\n                &od->nbr->load_balancer[i]->header_.uuid;\n            lb = ovn_northd_lb_find(lbs, lb_uuid);\n            ovn_northd_lb_add_lr(lb, 1, &od);\n            build_lrouter_lb_ips(od->lb_ips, lb);\n        }\n    }\n\n    HMAP_FOR_EACH (lb_group, hmap_node, lb_groups) {\n        for (size_t j = 0; j < lb_group->n_lbs; j++) {\n            ovn_northd_lb_add_lr(lb_group->lbs[j], lb_group->n_lr,\n                                 lb_group->lr);\n        }\n    }\n}\n\nstatic void\nbuild_lb_svcs(struct northd_input *input_data,\n              struct ovsdb_idl_txn *ovnsb_txn,\n              struct hmap *ports,\n              struct hmap *lbs)\n{\n    struct hmap monitor_map = HMAP_INITIALIZER(&monitor_map);\n\n    const struct sbrec_service_monitor *sbrec_mon;\n    SBREC_SERVICE_MONITOR_TABLE_FOR_EACH (sbrec_mon,\n                            input_data->sbrec_service_monitor_table) {\n        uint32_t hash = sbrec_mon->port;\n        hash = hash_string(sbrec_mon->ip, hash);\n        hash = hash_string(sbrec_mon->logical_port, hash);\n        struct service_monitor_info *mon_info = xzalloc(sizeof *mon_info);\n        mon_info->sbrec_mon = sbrec_mon;\n        mon_info->required = false;\n        hmap_insert(&monitor_map, &mon_info->hmap_node, hash);\n    }\n\n    struct ovn_northd_lb *lb;\n    HMAP_FOR_EACH (lb, hmap_node, lbs) {\n        ovn_lb_svc_create(ovnsb_txn, lb, &monitor_map, ports);\n    }\n\n    struct service_monitor_info *mon_info;\n    HMAP_FOR_EACH_POP (mon_info, hmap_node, &monitor_map) {\n        if (!mon_info->required) {\n            sbrec_service_monitor_delete(mon_info->sbrec_mon);\n        }\n\n        free(mon_info);\n    }\n    hmap_destroy(&monitor_map);\n}\n\nstatic bool lrouter_port_ipv4_reachable(const struct ovn_port *op,\n                                        ovs_be32 addr);\nstatic bool lrouter_port_ipv6_reachable(const struct ovn_port *op,\n                                        const struct in6_addr *addr);\nstatic void\nbuild_lrouter_lb_reachable_ips(struct ovn_datapath *od,\n                               const struct ovn_northd_lb *lb)\n{\n    /* If configured to not reply to any neighbor requests for all VIPs\n     * return early.\n     */\n    if (lb->neigh_mode == LB_NEIGH_RESPOND_NONE) {\n        return;\n    }\n\n    /* If configured to reply to neighbor requests for all VIPs force them\n     * all to be considered \"reachable\".\n     */\n    if (lb->neigh_mode == LB_NEIGH_RESPOND_ALL) {\n        for (size_t i = 0; i < lb->n_vips; i++) {\n            if (lb->vips[i].address_family == AF_INET) {\n                sset_add(&od->lb_ips->ips_v4_reachable, lb->vips[i].vip_str);\n            } else {\n                sset_add(&od->lb_ips->ips_v6_reachable, lb->vips[i].vip_str);\n            }\n        }\n        return;\n    }\n\n    /* Otherwise, a VIP is reachable if there's at least one router\n     * subnet that includes it.\n     */\n    ovs_assert(lb->neigh_mode == LB_NEIGH_RESPOND_REACHABLE);\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        if (lb->vips[i].address_family == AF_INET) {\n            ovs_be32 vip_ip4 = in6_addr_get_mapped_ipv4(&lb->vips[i].vip);\n            struct ovn_port *op;\n\n            LIST_FOR_EACH (op, dp_node, &od->port_list) {\n                if (lrouter_port_ipv4_reachable(op, vip_ip4)) {\n                    sset_add(&od->lb_ips->ips_v4_reachable,\n                             lb->vips[i].vip_str);\n                    break;\n                }\n            }\n        } else {\n            struct ovn_port *op;\n\n            LIST_FOR_EACH (op, dp_node, &od->port_list) {\n                if (lrouter_port_ipv6_reachable(op, &lb->vips[i].vip)) {\n                    sset_add(&od->lb_ips->ips_v6_reachable,\n                             lb->vips[i].vip_str);\n                    break;\n                }\n            }\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_lbs_check(const struct hmap *datapaths)\n{\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbr) {\n            continue;\n        }\n\n        if (od->has_lb_vip && od->n_l3dgw_ports > 1\n                && !smap_get(&od->nbr->options, \"chassis\")) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"Load-balancers are configured on logical \"\n                         \"router %s, which has %\"PRIuSIZE\" distributed \"\n                         \"gateway ports. Load-balancer is not supported \"\n                         \"yet when there is more than one distributed \"\n                         \"gateway port on the router.\",\n                         od->nbr->name, od->n_l3dgw_ports);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_lbs_reachable_ips(struct hmap *datapaths, struct hmap *lbs,\n                                struct hmap *lb_groups)\n{\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbr) {\n            continue;\n        }\n\n        for (size_t i = 0; i < od->nbr->n_load_balancer; i++) {\n            struct ovn_northd_lb *lb =\n                ovn_northd_lb_find(lbs,\n                                   &od->nbr->load_balancer[i]->header_.uuid);\n            build_lrouter_lb_reachable_ips(od, lb);\n        }\n\n        for (size_t i = 0; i < od->nbr->n_load_balancer_group; i++) {\n            const struct nbrec_load_balancer_group *nbrec_lb_group =\n                od->nbr->load_balancer_group[i];\n            struct ovn_lb_group *lb_group;\n\n            lb_group = ovn_lb_group_find(lb_groups,\n                                         &nbrec_lb_group->header_.uuid);\n            for (size_t j = 0; j < lb_group->n_lbs; j++) {\n                build_lrouter_lb_reachable_ips(od, lb_group->lbs[j]);\n            }\n        }\n    }\n}\n\nstatic void\nbuild_lswitch_lbs_from_lrouter(struct hmap *lbs, struct hmap *lb_groups)\n{\n    if (!install_ls_lb_from_router) {\n        return;\n    }\n\n    struct ovn_northd_lb *lb;\n    size_t index;\n\n    HMAP_FOR_EACH (lb, hmap_node, lbs) {\n        BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {\n            struct ovn_datapath *od = datapaths_array[index];\n            ovn_northd_lb_add_ls(lb, od->n_ls_peers, od->ls_peers);\n        }\n    }\n\n    struct ovn_lb_group *lb_group;\n    HMAP_FOR_EACH (lb_group, hmap_node, lb_groups) {\n        for (size_t i = 0; i < lb_group->n_lr; i++) {\n            struct ovn_datapath *od = lb_group->lr[i];\n            ovn_lb_group_add_ls(lb_group, od->n_ls_peers, od->ls_peers);\n            for (size_t j = 0; j < lb_group->n_lbs; j++) {\n                ovn_northd_lb_add_ls(lb_group->lbs[j], od->n_ls_peers,\n                                     od->ls_peers);\n            }\n        }\n    }\n}\n\nstatic void\nbuild_lb_count_dps(struct hmap *lbs)\n{\n    struct ovn_northd_lb *lb;\n\n    HMAP_FOR_EACH (lb, hmap_node, lbs) {\n        lb->n_nb_lr = bitmap_count1(lb->nb_lr_map, n_datapaths);\n        lb->n_nb_ls = bitmap_count1(lb->nb_ls_map, n_datapaths);\n    }\n}\n\n/* This must be called after all ports have been processed, i.e., after\n * build_ports() because the reachability check requires the router ports\n * networks to have been parsed.\n */\nstatic void\nbuild_lb_port_related_data(struct hmap *datapaths, struct hmap *ports,\n                           struct hmap *lbs, struct hmap *lb_groups,\n                           struct northd_input *input_data,\n                           struct ovsdb_idl_txn *ovnsb_txn)\n{\n    build_lrouter_lbs_check(datapaths);\n    build_lrouter_lbs_reachable_ips(datapaths, lbs, lb_groups);\n    build_lb_svcs(input_data, ovnsb_txn, ports, lbs);\n    build_lswitch_lbs_from_lrouter(lbs, lb_groups);\n}\n\n\nstruct ovn_dp_group {\n    unsigned long *bitmap;\n    struct sbrec_logical_dp_group *dp_group;\n    struct hmap_node node;\n};\n\nstatic struct ovn_dp_group *\novn_dp_group_find(const struct hmap *dp_groups,\n                  const unsigned long *dpg_bitmap, uint32_t hash)\n{\n    struct ovn_dp_group *dpg;\n\n    HMAP_FOR_EACH_WITH_HASH (dpg, node, hash, dp_groups) {\n        if (bitmap_equal(dpg->bitmap, dpg_bitmap, n_datapaths)) {\n            return dpg;\n        }\n    }\n    return NULL;\n}\n\nstatic struct sbrec_logical_dp_group *\novn_sb_insert_logical_dp_group(struct ovsdb_idl_txn *ovnsb_txn,\n                               const unsigned long *dpg_bitmap)\n{\n    struct sbrec_logical_dp_group *dp_group;\n    const struct sbrec_datapath_binding **sb;\n    size_t n = 0, index;\n\n    sb = xmalloc(bitmap_count1(dpg_bitmap, n_datapaths) * sizeof *sb);\n    BITMAP_FOR_EACH_1 (index, n_datapaths, dpg_bitmap) {\n        sb[n++] = datapaths_array[index]->sb;\n    }\n    dp_group = sbrec_logical_dp_group_insert(ovnsb_txn);\n    sbrec_logical_dp_group_set_datapaths(\n        dp_group, (struct sbrec_datapath_binding **) sb, n);\n    free(sb);\n\n    return dp_group;\n}\n\n/* Syncs relevant load balancers (applied to logical switches) to the\n * Southbound database.\n */\nstatic void\nsync_lbs(struct northd_input *input_data, struct ovsdb_idl_txn *ovnsb_txn,\n         struct hmap *datapaths, struct hmap *lbs)\n{\n    struct hmap dp_groups = HMAP_INITIALIZER(&dp_groups);\n    struct ovn_northd_lb *lb;\n\n    /* Delete any stale SB load balancer rows and collect existing valid\n     * datapath groups. */\n    struct hmapx existing_sb_dp_groups =\n        HMAPX_INITIALIZER(&existing_sb_dp_groups);\n    struct hmapx existing_lbs = HMAPX_INITIALIZER(&existing_lbs);\n    const struct sbrec_load_balancer *sbrec_lb;\n    SBREC_LOAD_BALANCER_TABLE_FOR_EACH_SAFE (sbrec_lb,\n                            input_data->sbrec_load_balancer_table) {\n        const char *nb_lb_uuid = smap_get(&sbrec_lb->external_ids, \"lb_id\");\n        struct uuid lb_uuid;\n        if (!nb_lb_uuid || !uuid_from_string(&lb_uuid, nb_lb_uuid)) {\n            sbrec_load_balancer_delete(sbrec_lb);\n            continue;\n        }\n\n        /* Delete any SB load balancer entries that refer to NB load balancers\n         * that don't exist anymore or are not applied to switches anymore.\n         *\n         * There is also a special case in which duplicate LBs might be created\n         * in the SB, e.g., due to the fact that OVSDB only ensures\n         * \"at-least-once\" consistency for clustered database tables that\n         * are not indexed in any way.\n         */\n        lb = ovn_northd_lb_find(lbs, &lb_uuid);\n        if (!lb || !lb->n_nb_ls || !hmapx_add(&existing_lbs, lb)) {\n            sbrec_load_balancer_delete(sbrec_lb);\n            continue;\n        }\n\n        lb->slb = sbrec_lb;\n\n        /* Collect the datapath group. */\n        struct sbrec_logical_dp_group *dp_group = sbrec_lb->datapath_group;\n\n        if (!dp_group || !hmapx_add(&existing_sb_dp_groups, dp_group)) {\n            continue;\n        }\n\n        struct ovn_dp_group *dpg = xzalloc(sizeof *dpg);\n        size_t i, n = 0;\n\n        dpg->bitmap = bitmap_allocate(n_datapaths);\n        for (i = 0; i < dp_group->n_datapaths; i++) {\n            struct ovn_datapath *datapath_od;\n\n            datapath_od = ovn_datapath_from_sbrec(datapaths,\n                                                  dp_group->datapaths[i]);\n            if (!datapath_od || ovn_datapath_is_stale(datapath_od)) {\n                break;\n            }\n            bitmap_set1(dpg->bitmap, datapath_od->index);\n            n++;\n        }\n        if (i == dp_group->n_datapaths) {\n            uint32_t hash = hash_int(n, 0);\n\n            if (!ovn_dp_group_find(&dp_groups, dpg->bitmap, hash)) {\n                dpg->dp_group = dp_group;\n                hmap_insert(&dp_groups, &dpg->node, hash);\n                continue;\n            }\n        }\n        bitmap_free(dpg->bitmap);\n        free(dpg);\n    }\n    hmapx_destroy(&existing_lbs);\n    hmapx_destroy(&existing_sb_dp_groups);\n\n    /* Create SB Load balancer records if not present and sync\n     * the SB load balancer columns. */\n    HMAP_FOR_EACH (lb, hmap_node, lbs) {\n\n        if (!lb->n_nb_ls) {\n            continue;\n        }\n\n        /* Store the fact that northd provides the original (destination IP +\n         * transport port) tuple.\n         */\n        struct smap options;\n        smap_clone(&options, &lb->nlb->options);\n        smap_replace(&options, \"hairpin_orig_tuple\", \"true\");\n\n        if (!lb->slb) {\n            sbrec_lb = sbrec_load_balancer_insert(ovnsb_txn);\n            lb->slb = sbrec_lb;\n            char *lb_id = xasprintf(\n                UUID_FMT, UUID_ARGS(&lb->nlb->header_.uuid));\n            const struct smap external_ids =\n                SMAP_CONST1(&external_ids, \"lb_id\", lb_id);\n            sbrec_load_balancer_set_external_ids(sbrec_lb, &external_ids);\n            free(lb_id);\n        }\n\n        /* Find datapath group for this load balancer. */\n        struct ovn_dp_group *dpg;\n        uint32_t hash;\n\n        hash = hash_int(lb->n_nb_ls, 0);\n        dpg = ovn_dp_group_find(&dp_groups, lb->nb_ls_map, hash);\n        if (!dpg) {\n            dpg = xzalloc(sizeof *dpg);\n            dpg->dp_group = ovn_sb_insert_logical_dp_group(ovnsb_txn,\n                                                           lb->nb_ls_map);\n            dpg->bitmap = bitmap_clone(lb->nb_ls_map, n_datapaths);\n            hmap_insert(&dp_groups, &dpg->node, hash);\n        }\n\n        /* Update columns. */\n        sbrec_load_balancer_set_name(lb->slb, lb->nlb->name);\n        sbrec_load_balancer_set_vips(lb->slb, ovn_northd_lb_get_vips(lb));\n        sbrec_load_balancer_set_protocol(lb->slb, lb->nlb->protocol);\n        sbrec_load_balancer_set_datapath_group(lb->slb, dpg->dp_group);\n        sbrec_load_balancer_set_options(lb->slb, &options);\n        /* Clearing 'datapaths' column, since 'dp_group' is in use. */\n        sbrec_load_balancer_set_datapaths(lb->slb, NULL, 0);\n        smap_destroy(&options);\n    }\n\n    struct ovn_dp_group *dpg;\n    HMAP_FOR_EACH_POP (dpg, node, &dp_groups) {\n        bitmap_free(dpg->bitmap);\n        free(dpg);\n    }\n    hmap_destroy(&dp_groups);\n\n    /* Datapath_Binding.load_balancers is not used anymore, it's still in the\n     * schema for compatibility reasons.  Reset it to empty, just in case.\n     */\n    struct ovn_datapath *od;\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs) {\n            continue;\n        }\n\n        if (od->sb->n_load_balancers) {\n            sbrec_datapath_binding_set_load_balancers(od->sb, NULL, 0);\n        }\n    }\n}\n\nstatic bool\novn_port_add_tnlid(struct ovn_port *op, uint32_t tunnel_key)\n{\n    bool added = ovn_add_tnlid(&op->od->port_tnlids, tunnel_key);\n    if (added) {\n        op->tunnel_key = tunnel_key;\n        if (tunnel_key > op->od->port_key_hint) {\n            op->od->port_key_hint = tunnel_key;\n        }\n    }\n    return added;\n}\n\nstatic void\novn_port_assign_requested_tnl_id(struct northd_input *input_data,\n                                 struct ovn_port *op)\n{\n    const struct smap *options = (op->nbsp\n                                  ? &op->nbsp->options\n                                  : &op->nbrp->options);\n    uint32_t tunnel_key = smap_get_int(options, \"requested-tnl-key\", 0);\n    if (tunnel_key) {\n        if (is_vxlan_mode(input_data) &&\n                tunnel_key >= OVN_VXLAN_MIN_MULTICAST) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"Tunnel key %\"PRIu32\" for port %s \"\n                         \"is incompatible with VXLAN\",\n                         tunnel_key, op_get_name(op));\n            return;\n        }\n        if (!ovn_port_add_tnlid(op, tunnel_key)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"Logical %s port %s requests same tunnel key \"\n                         \"%\"PRIu32\" as another LSP or LRP\",\n                         op->nbsp ? \"switch\" : \"router\",\n                         op_get_name(op), tunnel_key);\n        }\n    }\n}\n\nstatic void\novn_port_allocate_key(struct northd_input *input_data,\n                      struct hmap *ports,\n                      struct ovn_port *op)\n{\n    if (!op->tunnel_key) {\n        uint8_t key_bits = is_vxlan_mode(input_data)? 12 : 16;\n        op->tunnel_key = ovn_allocate_tnlid(&op->od->port_tnlids, \"port\",\n                                            1, (1u << (key_bits - 1)) - 1,\n                                            &op->od->port_key_hint);\n        if (!op->tunnel_key) {\n            if (op->sb) {\n                sbrec_port_binding_delete(op->sb);\n            }\n            ovs_list_remove(&op->list);\n            ovn_port_destroy(ports, op);\n        }\n    }\n}\n\n/* Updates the southbound Port_Binding table so that it contains the logical\n * switch ports specified by the northbound database.\n *\n * Initializes 'ports' to contain a \"struct ovn_port\" for every logical port,\n * using the \"struct ovn_datapath\"s in 'datapaths' to look up logical\n * datapaths. */\nstatic void\nbuild_ports(struct northd_input *input_data,\n            struct ovsdb_idl_txn *ovnsb_txn,\n            struct ovsdb_idl_index *sbrec_chassis_by_name,\n            struct ovsdb_idl_index *sbrec_chassis_by_hostname,\n            struct hmap *datapaths, struct hmap *ports)\n{\n    struct ovs_list sb_only, nb_only, both;\n    struct hmap tag_alloc_table = HMAP_INITIALIZER(&tag_alloc_table);\n    struct hmap chassis_qdisc_queues = HMAP_INITIALIZER(&chassis_qdisc_queues);\n\n    /* sset which stores the set of ha chassis group names used. */\n    struct sset active_ha_chassis_grps =\n        SSET_INITIALIZER(&active_ha_chassis_grps);\n\n    join_logical_ports(input_data,\n                       datapaths, ports, &chassis_qdisc_queues,\n                       &tag_alloc_table, &sb_only, &nb_only, &both);\n\n    /* Purge stale Mac_Bindings if ports are deleted. */\n    bool remove_mac_bindings = !ovs_list_is_empty(&sb_only);\n\n    /* Assign explicitly requested tunnel ids first. */\n    struct ovn_port *op;\n    LIST_FOR_EACH (op, list, &both) {\n        ovn_port_assign_requested_tnl_id(input_data, op);\n    }\n    LIST_FOR_EACH (op, list, &nb_only) {\n        ovn_port_assign_requested_tnl_id(input_data, op);\n    }\n\n    /* Keep nonconflicting tunnel IDs that are already assigned. */\n    LIST_FOR_EACH (op, list, &both) {\n        if (!op->tunnel_key) {\n            ovn_port_add_tnlid(op, op->sb->tunnel_key);\n        }\n    }\n\n    /* Assign new tunnel ids where needed. */\n    LIST_FOR_EACH_SAFE (op, list, &both) {\n        ovn_port_allocate_key(input_data, ports, op);\n    }\n    LIST_FOR_EACH_SAFE (op, list, &nb_only) {\n        ovn_port_allocate_key(input_data, ports, op);\n    }\n\n    /* For logical ports that are in both databases, update the southbound\n     * record based on northbound data.\n     * For logical ports that are in NB database, do any tag allocation\n     * needed. */\n    LIST_FOR_EACH_SAFE (op, list, &both) {\n        /* When reusing stale Port_Bindings, make sure that stale\n         * Mac_Bindings are purged.\n         */\n        if (op->od->sb != op->sb->datapath) {\n            remove_mac_bindings = true;\n        }\n        if (op->nbsp) {\n            tag_alloc_create_new_tag(&tag_alloc_table, op->nbsp);\n        }\n        ovn_port_update_sbrec(input_data,\n                              ovnsb_txn, sbrec_chassis_by_name,\n                              sbrec_chassis_by_hostname,\n                              op, &chassis_qdisc_queues,\n                              &active_ha_chassis_grps);\n    }\n\n    /* Add southbound record for each unmatched northbound record. */\n    LIST_FOR_EACH_SAFE (op, list, &nb_only) {\n        op->sb = sbrec_port_binding_insert(ovnsb_txn);\n        ovn_port_update_sbrec(input_data,\n                              ovnsb_txn, sbrec_chassis_by_name,\n                              sbrec_chassis_by_hostname, op,\n                              &chassis_qdisc_queues,\n                              &active_ha_chassis_grps);\n        sbrec_port_binding_set_logical_port(op->sb, op->key);\n    }\n\n    /* Delete southbound records without northbound matches. */\n    if (!ovs_list_is_empty(&sb_only)) {\n        LIST_FOR_EACH_SAFE (op, list, &sb_only) {\n            ovs_list_remove(&op->list);\n            sbrec_port_binding_delete(op->sb);\n            ovn_port_destroy(ports, op);\n        }\n    }\n    if (remove_mac_bindings) {\n        cleanup_mac_bindings(input_data, datapaths, ports);\n    }\n\n    tag_alloc_destroy(&tag_alloc_table);\n    destroy_chassis_queues(&chassis_qdisc_queues);\n    cleanup_sb_ha_chassis_groups(input_data, &active_ha_chassis_grps);\n    sset_destroy(&active_ha_chassis_grps);\n}\n\nstruct multicast_group {\n    const char *name;\n    uint16_t key;               /* OVN_MIN_MULTICAST...OVN_MAX_MULTICAST. */\n};\n\n#define MC_FLOOD \"_MC_flood\"\nstatic const struct multicast_group mc_flood =\n    { MC_FLOOD, OVN_MCAST_FLOOD_TUNNEL_KEY };\n\n#define MC_MROUTER_FLOOD \"_MC_mrouter_flood\"\nstatic const struct multicast_group mc_mrouter_flood =\n    { MC_MROUTER_FLOOD, OVN_MCAST_MROUTER_FLOOD_TUNNEL_KEY };\n\n#define MC_STATIC \"_MC_static\"\nstatic const struct multicast_group mc_static =\n    { MC_STATIC, OVN_MCAST_STATIC_TUNNEL_KEY };\n\n#define MC_UNKNOWN \"_MC_unknown\"\nstatic const struct multicast_group mc_unknown =\n    { MC_UNKNOWN, OVN_MCAST_UNKNOWN_TUNNEL_KEY };\n\n#define MC_FLOOD_L2 \"_MC_flood_l2\"\nstatic const struct multicast_group mc_flood_l2 =\n    { MC_FLOOD_L2, OVN_MCAST_FLOOD_L2_TUNNEL_KEY };\n\nstatic bool\nmulticast_group_equal(const struct multicast_group *a,\n                      const struct multicast_group *b)\n{\n    return !strcmp(a->name, b->name) && a->key == b->key;\n}\n\n/* Multicast group entry. */\nstruct ovn_multicast {\n    struct hmap_node hmap_node; /* Index on 'datapath' and 'key'. */\n    struct ovn_datapath *datapath;\n    const struct multicast_group *group;\n\n    struct ovn_port **ports;\n    size_t n_ports, allocated_ports;\n};\n\nstatic uint32_t\novn_multicast_hash(const struct ovn_datapath *datapath,\n                   const struct multicast_group *group)\n{\n    return hash_pointer(datapath, group->key);\n}\n\nstatic struct ovn_multicast *\novn_multicast_find(struct hmap *mcgroups, struct ovn_datapath *datapath,\n                   const struct multicast_group *group)\n{\n    struct ovn_multicast *mc;\n\n    HMAP_FOR_EACH_WITH_HASH (mc, hmap_node,\n                             ovn_multicast_hash(datapath, group), mcgroups) {\n        if (mc->datapath == datapath\n            && multicast_group_equal(mc->group, group)) {\n            return mc;\n        }\n    }\n    return NULL;\n}\n\nstatic void\novn_multicast_add_ports(struct hmap *mcgroups, struct ovn_datapath *od,\n                        const struct multicast_group *group,\n                        struct ovn_port **ports, size_t n_ports)\n{\n    struct ovn_multicast *mc = ovn_multicast_find(mcgroups, od, group);\n    if (!mc) {\n        mc = xmalloc(sizeof *mc);\n        hmap_insert(mcgroups, &mc->hmap_node, ovn_multicast_hash(od, group));\n        mc->datapath = od;\n        mc->group = group;\n        mc->n_ports = 0;\n        mc->allocated_ports = 4;\n        mc->ports = xmalloc(mc->allocated_ports * sizeof *mc->ports);\n    }\n\n    size_t n_ports_total = mc->n_ports + n_ports;\n\n    if (n_ports_total > 2 * mc->allocated_ports) {\n        mc->allocated_ports = n_ports_total;\n        mc->ports = xrealloc(mc->ports,\n                             mc->allocated_ports * sizeof *mc->ports);\n    } else if (n_ports_total > mc->allocated_ports) {\n        mc->ports = x2nrealloc(mc->ports, &mc->allocated_ports,\n                               sizeof *mc->ports);\n    }\n\n    memcpy(&mc->ports[mc->n_ports], &ports[0], n_ports * sizeof *ports);\n    mc->n_ports += n_ports;\n}\n\nstatic void\novn_multicast_add(struct hmap *mcgroups, const struct multicast_group *group,\n                  struct ovn_port *port)\n{\n    /* Store the chassis redirect port otherwise traffic will not be tunneled\n     * properly.\n     */\n    if (port->cr_port) {\n        port = port->cr_port;\n    }\n    ovn_multicast_add_ports(mcgroups, port->od, group, &port, 1);\n}\n\nstatic void\novn_multicast_destroy(struct hmap *mcgroups, struct ovn_multicast *mc)\n{\n    if (mc) {\n        hmap_remove(mcgroups, &mc->hmap_node);\n        free(mc->ports);\n        free(mc);\n    }\n}\n\nstatic void\novn_multicast_update_sbrec(const struct ovn_multicast *mc,\n                           const struct sbrec_multicast_group *sb)\n{\n    struct sbrec_port_binding **ports = xmalloc(mc->n_ports * sizeof *ports);\n    for (size_t i = 0; i < mc->n_ports; i++) {\n        ports[i] = CONST_CAST(struct sbrec_port_binding *, mc->ports[i]->sb);\n    }\n    sbrec_multicast_group_set_ports(sb, ports, mc->n_ports);\n    free(ports);\n}\n\n/*\n * IGMP group entry (1:1 mapping to SB database).\n */\nstruct ovn_igmp_group_entry {\n    struct ovs_list list_node; /* Linkage in the list of entries. */\n    size_t n_ports;\n    struct ovn_port **ports;\n};\n\n/*\n * IGMP group entry (aggregate of all entries from the SB database\n * corresponding to the multicast group).\n */\nstruct ovn_igmp_group {\n    struct hmap_node hmap_node; /* Index on 'datapath' and 'address'. */\n    struct ovs_list list_node;  /* Linkage in the per-dp igmp group list. */\n\n    struct ovn_datapath *datapath;\n    struct in6_addr address; /* Multicast IPv6-mapped-IPv4 or IPv4 address. */\n    struct multicast_group mcgroup;\n\n    struct ovs_list entries; /* List of SB entries for this group. */\n};\n\nstatic uint32_t\novn_igmp_group_hash(const struct ovn_datapath *datapath,\n                    const struct in6_addr *address)\n{\n    return hash_pointer(datapath, hash_bytes(address, sizeof *address, 0));\n}\n\nstatic struct ovn_igmp_group *\novn_igmp_group_find(struct hmap *igmp_groups,\n                    const struct ovn_datapath *datapath,\n                    const struct in6_addr *address)\n{\n    struct ovn_igmp_group *group;\n\n    HMAP_FOR_EACH_WITH_HASH (group, hmap_node,\n                             ovn_igmp_group_hash(datapath, address),\n                             igmp_groups) {\n        if (group->datapath == datapath &&\n                ipv6_addr_equals(&group->address, address)) {\n            return group;\n        }\n    }\n    return NULL;\n}\n\nstatic struct ovn_igmp_group *\novn_igmp_group_add(struct lflow_input *input_data,\n                   struct hmap *igmp_groups,\n                   struct ovn_datapath *datapath,\n                   const struct in6_addr *address,\n                   const char *address_s)\n{\n    struct ovn_igmp_group *igmp_group =\n        ovn_igmp_group_find(igmp_groups, datapath, address);\n\n    if (!igmp_group) {\n        igmp_group = xmalloc(sizeof *igmp_group);\n\n        const struct sbrec_multicast_group *mcgroup =\n            mcast_group_lookup(input_data->sbrec_mcast_group_by_name_dp,\n                               address_s,\n                               datapath->sb);\n\n        igmp_group->datapath = datapath;\n        igmp_group->address = *address;\n        if (mcgroup) {\n            igmp_group->mcgroup.key = mcgroup->tunnel_key;\n            ovn_add_tnlid(&datapath->mcast_info.group_tnlids,\n                          mcgroup->tunnel_key);\n        } else {\n            igmp_group->mcgroup.key = 0;\n        }\n        igmp_group->mcgroup.name = address_s;\n        ovs_list_init(&igmp_group->entries);\n\n        hmap_insert(igmp_groups, &igmp_group->hmap_node,\n                    ovn_igmp_group_hash(datapath, address));\n        ovs_list_push_back(&datapath->mcast_info.groups,\n                           &igmp_group->list_node);\n    }\n\n    return igmp_group;\n}\n\nstatic bool\novn_igmp_group_get_address(const struct sbrec_igmp_group *sb_igmp_group,\n                           struct in6_addr *address)\n{\n    ovs_be32 ipv4;\n\n    if (ip_parse(sb_igmp_group->address, &ipv4)) {\n        *address = in6_addr_mapped_ipv4(ipv4);\n        return true;\n    }\n    if (!ipv6_parse(sb_igmp_group->address, address)) {\n        return false;\n    }\n    return true;\n}\n\nstatic struct ovn_port **\novn_igmp_group_get_ports(const struct sbrec_igmp_group *sb_igmp_group,\n                         size_t *n_ports, const struct hmap *ovn_ports)\n{\n    struct ovn_port **ports = NULL;\n\n     *n_ports = 0;\n     for (size_t i = 0; i < sb_igmp_group->n_ports; i++) {\n        struct ovn_port *port =\n            ovn_port_find(ovn_ports, sb_igmp_group->ports[i]->logical_port);\n\n        if (!port || !port->nbsp) {\n            continue;\n        }\n\n        /* If this is already a flood port skip it for the group. */\n        if (port->mcast_info.flood) {\n            continue;\n        }\n\n        /* If this is already a port of a router on which relay is enabled,\n         * skip it for the group. Traffic is flooded there anyway.\n         */\n        if (port->peer && port->peer->od &&\n                port->peer->od->mcast_info.rtr.relay) {\n            continue;\n        }\n\n        if (ports == NULL) {\n            ports = xmalloc(sb_igmp_group->n_ports * sizeof *ports);\n        }\n\n        ports[(*n_ports)] = port;\n        (*n_ports)++;\n    }\n\n    return ports;\n}\n\nstatic void\novn_igmp_group_add_entry(struct ovn_igmp_group *igmp_group,\n                         struct ovn_port **ports, size_t n_ports)\n{\n    struct ovn_igmp_group_entry *entry = xmalloc(sizeof *entry);\n\n    entry->ports = ports;\n    entry->n_ports = n_ports;\n    ovs_list_push_back(&igmp_group->entries, &entry->list_node);\n}\n\nstatic void\novn_igmp_group_destroy_entry(struct ovn_igmp_group_entry *entry)\n{\n    free(entry->ports);\n}\n\nstatic bool\novn_igmp_group_allocate_id(struct ovn_igmp_group *igmp_group)\n{\n    if (igmp_group->mcgroup.key == 0) {\n        struct mcast_info *mcast_info = &igmp_group->datapath->mcast_info;\n        igmp_group->mcgroup.key = ovn_mcast_group_allocate_key(mcast_info);\n    }\n\n    if (igmp_group->mcgroup.key == 0) {\n        return false;\n    }\n\n    return true;\n}\n\nstatic void\novn_igmp_mrouter_aggregate_ports(struct ovn_igmp_group *igmp_group,\n                                 struct hmap *mcast_groups)\n{\n    struct ovn_igmp_group_entry *entry;\n\n    LIST_FOR_EACH_POP (entry, list_node, &igmp_group->entries) {\n        ovn_multicast_add_ports(mcast_groups, igmp_group->datapath,\n                                &mc_mrouter_flood, entry->ports,\n                                entry->n_ports);\n\n        ovn_igmp_group_destroy_entry(entry);\n        free(entry);\n    }\n}\n\nstatic void\novn_igmp_group_aggregate_ports(struct ovn_igmp_group *igmp_group,\n                               struct hmap *mcast_groups)\n{\n    struct ovn_igmp_group_entry *entry;\n\n    LIST_FOR_EACH_POP (entry, list_node, &igmp_group->entries) {\n        ovn_multicast_add_ports(mcast_groups, igmp_group->datapath,\n                                &igmp_group->mcgroup, entry->ports,\n                                entry->n_ports);\n\n        ovn_igmp_group_destroy_entry(entry);\n        free(entry);\n    }\n\n    if (igmp_group->datapath->n_localnet_ports) {\n        ovn_multicast_add_ports(mcast_groups, igmp_group->datapath,\n                                &igmp_group->mcgroup,\n                                igmp_group->datapath->localnet_ports,\n                                igmp_group->datapath->n_localnet_ports);\n    }\n}\n\nstatic void\novn_igmp_group_destroy(struct hmap *igmp_groups,\n                       struct ovn_igmp_group *igmp_group)\n{\n    if (igmp_group) {\n        struct ovn_igmp_group_entry *entry;\n\n        LIST_FOR_EACH_POP (entry, list_node, &igmp_group->entries) {\n            ovn_igmp_group_destroy_entry(entry);\n            free(entry);\n        }\n        hmap_remove(igmp_groups, &igmp_group->hmap_node);\n        ovs_list_remove(&igmp_group->list_node);\n        free(igmp_group);\n    }\n}\n\n/* Logical flow generation.\n *\n * This code generates the Logical_Flow table in the southbound database, as a\n * function of most of the northbound database.\n */\n\nstruct ovn_lflow {\n    struct hmap_node hmap_node;\n\n    struct ovn_datapath *od;     /* 'logical_datapath' in SB schema.  */\n    unsigned long *dpg_bitmap;   /* Bitmap of all datapaths by their 'index'.*/\n    enum ovn_stage stage;\n    uint16_t priority;\n    char *match;\n    char *actions;\n    char *io_port;\n    char *stage_hint;\n    char *ctrl_meter;\n    struct ovn_dp_group *dpg;    /* Link to unique Sb datapath group. */\n    const char *where;\n};\n\nstatic void ovn_lflow_destroy(struct hmap *lflows, struct ovn_lflow *lflow);\nstatic struct ovn_lflow *ovn_lflow_find(const struct hmap *lflows,\n                                        const struct ovn_datapath *od,\n                                        enum ovn_stage stage,\n                                        uint16_t priority, const char *match,\n                                        const char *actions,\n                                        const char *ctrl_meter, uint32_t hash);\n\nstatic char *\novn_lflow_hint(const struct ovsdb_idl_row *row)\n{\n    if (!row) {\n        return NULL;\n    }\n    return xasprintf(\"%08x\", row->uuid.parts[0]);\n}\n\nstatic bool\novn_lflow_equal(const struct ovn_lflow *a, const struct ovn_datapath *od,\n                enum ovn_stage stage, uint16_t priority, const char *match,\n                const char *actions, const char *ctrl_meter)\n{\n    return (a->od == od\n            && a->stage == stage\n            && a->priority == priority\n            && !strcmp(a->match, match)\n            && !strcmp(a->actions, actions)\n            && nullable_string_is_equal(a->ctrl_meter, ctrl_meter));\n}\n\nenum {\n    STATE_NULL,               /* parallelization is off */\n    STATE_INIT_HASH_SIZES,    /* parallelization is on; hashes sizing needed */\n    STATE_USE_PARALLELIZATION /* parallelization is on */\n};\nstatic int parallelization_state = STATE_NULL;\n\nstatic void\novn_lflow_init(struct ovn_lflow *lflow, struct ovn_datapath *od,\n               enum ovn_stage stage, uint16_t priority,\n               char *match, char *actions, char *io_port, char *ctrl_meter,\n               char *stage_hint, const char *where)\n{\n    lflow->dpg_bitmap = bitmap_allocate(n_datapaths);\n    lflow->od = od;\n    lflow->stage = stage;\n    lflow->priority = priority;\n    lflow->match = match;\n    lflow->actions = actions;\n    lflow->io_port = io_port;\n    lflow->stage_hint = stage_hint;\n    lflow->ctrl_meter = ctrl_meter;\n    lflow->dpg = NULL;\n    lflow->where = where;\n}\n\n/* The lflow_hash_lock is a mutex array that protects updates to the shared\n * lflow table across threads when parallel lflow build and dp-group are both\n * enabled. To avoid high contention between threads, a big array of mutexes\n * are used instead of just one. This is possible because when parallel build\n * is used we only use hmap_insert_fast() to update the hmap, which would not\n * touch the bucket array but only the list in a single bucket. We only need to\n * make sure that when adding lflows to the same hash bucket, the same lock is\n * used, so that no two threads can add to the bucket at the same time.  It is\n * ok that the same lock is used to protect multiple buckets, so a fixed sized\n * mutex array is used instead of 1-1 mapping to the hash buckets. This\n * simplies the implementation while effectively reduces lock contention\n * because the chance that different threads contending the same lock amongst\n * the big number of locks is very low. */\n#define LFLOW_HASH_LOCK_MASK 0xFFFF\nstatic struct ovs_mutex lflow_hash_locks[LFLOW_HASH_LOCK_MASK + 1];\n\nstatic void\nlflow_hash_lock_init(void)\n{\n    if (!lflow_hash_lock_initialized) {\n        for (size_t i = 0; i < LFLOW_HASH_LOCK_MASK + 1; i++) {\n            ovs_mutex_init(&lflow_hash_locks[i]);\n        }\n        lflow_hash_lock_initialized = true;\n    }\n}\n\nstatic void\nlflow_hash_lock_destroy(void)\n{\n    if (lflow_hash_lock_initialized) {\n        for (size_t i = 0; i < LFLOW_HASH_LOCK_MASK + 1; i++) {\n            ovs_mutex_destroy(&lflow_hash_locks[i]);\n        }\n    }\n    lflow_hash_lock_initialized = false;\n}\n\n/* Full thread safety analysis is not possible with hash locks, because\n * they are taken conditionally based on the 'parallelization_state' and\n * a flow hash.  Also, the order in which two hash locks are taken is not\n * predictable during the static analysis.\n *\n * Since the order of taking two locks depends on a random hash, to avoid\n * ABBA deadlocks, no two hash locks can be nested.  In that sense an array\n * of hash locks is similar to a single mutex.\n *\n * Using a fake mutex to partially simulate thread safety restrictions, as\n * if it were actually a single mutex.\n *\n * OVS_NO_THREAD_SAFETY_ANALYSIS below allows us to ignore conditional\n * nature of the lock.  Unlike other attributes, it applies to the\n * implementation and not to the interface.  So, we can define a function\n * that acquires the lock without analysing the way it does that.\n */\nextern struct ovs_mutex fake_hash_mutex;\n\nstatic struct ovs_mutex *\nlflow_hash_lock(const struct hmap *lflow_map, uint32_t hash)\n    OVS_ACQUIRES(fake_hash_mutex)\n    OVS_NO_THREAD_SAFETY_ANALYSIS\n{\n    struct ovs_mutex *hash_lock = NULL;\n\n    if (parallelization_state == STATE_USE_PARALLELIZATION) {\n        hash_lock =\n            &lflow_hash_locks[hash & lflow_map->mask & LFLOW_HASH_LOCK_MASK];\n        ovs_mutex_lock(hash_lock);\n    }\n    return hash_lock;\n}\n\nstatic void\nlflow_hash_unlock(struct ovs_mutex *hash_lock)\n    OVS_RELEASES(fake_hash_mutex)\n    OVS_NO_THREAD_SAFETY_ANALYSIS\n{\n    if (hash_lock) {\n        ovs_mutex_unlock(hash_lock);\n    }\n}\n\n\n/* This thread-local var is used for parallel lflow building when dp-groups is\n * enabled. It maintains the number of lflows inserted by the current thread to\n * the shared lflow hmap in the current iteration. It is needed because the\n * lflow_hash_lock cannot protect current update of the hmap's size (hmap->n)\n * by different threads.\n *\n * When all threads complete the tasks of an iteration, the counters of all the\n * threads are collected to fix the lflow hmap's size (by the function\n * fix_flow_map_size()).\n * */\nstatic thread_local size_t thread_lflow_counter = 0;\n\n/* Adds an OVN datapath to a datapath group of existing logical flow.\n * Version to use when hash bucket locking is NOT required or the corresponding\n * hash lock is already taken. */\nstatic void\novn_dp_group_add_with_reference(struct ovn_lflow *lflow_ref,\n                                const struct ovn_datapath *od,\n                                const unsigned long *dp_bitmap)\n    OVS_REQUIRES(fake_hash_mutex)\n{\n    if (od) {\n        bitmap_set1(lflow_ref->dpg_bitmap, od->index);\n    }\n    if (dp_bitmap) {\n        bitmap_or(lflow_ref->dpg_bitmap, dp_bitmap, n_datapaths);\n    }\n}\n\n/* Adds a row with the specified contents to the Logical_Flow table.\n * Version to use when hash bucket locking is NOT required.\n */\nstatic void\ndo_ovn_lflow_add(struct hmap *lflow_map, const struct ovn_datapath *od,\n                 const unsigned long *dp_bitmap,\n                 uint32_t hash, enum ovn_stage stage, uint16_t priority,\n                 const char *match, const char *actions, const char *io_port,\n                 const struct ovsdb_idl_row *stage_hint,\n                 const char *where, const char *ctrl_meter)\n    OVS_REQUIRES(fake_hash_mutex)\n{\n\n    struct ovn_lflow *old_lflow;\n    struct ovn_lflow *lflow;\n\n    old_lflow = ovn_lflow_find(lflow_map, NULL, stage, priority, match,\n                               actions, ctrl_meter, hash);\n    if (old_lflow) {\n        ovn_dp_group_add_with_reference(old_lflow, od, dp_bitmap);\n        return;\n    }\n\n    lflow = xmalloc(sizeof *lflow);\n    /* While adding new logical flows we're not setting single datapath, but\n     * collecting a group.  'od' will be updated later for all flows with only\n     * one datapath in a group, so it could be hashed correctly. */\n    ovn_lflow_init(lflow, NULL, stage, priority,\n                   xstrdup(match), xstrdup(actions),\n                   io_port ? xstrdup(io_port) : NULL,\n                   nullable_xstrdup(ctrl_meter),\n                   ovn_lflow_hint(stage_hint), where);\n\n    ovn_dp_group_add_with_reference(lflow, od, dp_bitmap);\n\n    if (parallelization_state != STATE_USE_PARALLELIZATION) {\n        hmap_insert(lflow_map, &lflow->hmap_node, hash);\n    } else {\n        hmap_insert_fast(lflow_map, &lflow->hmap_node, hash);\n        thread_lflow_counter++;\n    }\n}\n\n/* Adds a row with the specified contents to the Logical_Flow table. */\nstatic void\novn_lflow_add_at(struct hmap *lflow_map, const struct ovn_datapath *od,\n                 const unsigned long *dp_bitmap,\n                 enum ovn_stage stage, uint16_t priority,\n                 const char *match, const char *actions, const char *io_port,\n                 const char *ctrl_meter,\n                 const struct ovsdb_idl_row *stage_hint, const char *where)\n    OVS_EXCLUDED(fake_hash_mutex)\n{\n    struct ovs_mutex *hash_lock;\n    uint32_t hash;\n\n    ovs_assert(!od ||\n               ovn_stage_to_datapath_type(stage) == ovn_datapath_get_type(od));\n\n    hash = ovn_logical_flow_hash(ovn_stage_get_table(stage),\n                                 ovn_stage_get_pipeline(stage),\n                                 priority, match,\n                                 actions);\n\n    hash_lock = lflow_hash_lock(lflow_map, hash);\n    do_ovn_lflow_add(lflow_map, od, dp_bitmap, hash, stage, priority,\n                     match, actions, io_port, stage_hint, where, ctrl_meter);\n    lflow_hash_unlock(hash_lock);\n}\n\nstatic void\n__ovn_lflow_add_default_drop(struct hmap *lflow_map,\n                             struct ovn_datapath *od,\n                             enum ovn_stage stage,\n                             const char *where)\n{\n        ovn_lflow_add_at(lflow_map, od, NULL, stage, 0, \"1\",\n                         debug_drop_action(),\n                         NULL, NULL, NULL, where );\n}\n\n/* Adds a row with the specified contents to the Logical_Flow table. */\n#define ovn_lflow_add_with_hint__(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, \\\n                                  ACTIONS, IN_OUT_PORT, CTRL_METER, \\\n                                  STAGE_HINT) \\\n    ovn_lflow_add_at(LFLOW_MAP, OD, NULL, STAGE, PRIORITY, MATCH, ACTIONS, \\\n                     IN_OUT_PORT, CTRL_METER, STAGE_HINT, OVS_SOURCE_LOCATOR)\n\n#define ovn_lflow_add_with_hint(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, \\\n                                ACTIONS, STAGE_HINT) \\\n    ovn_lflow_add_at(LFLOW_MAP, OD, NULL, STAGE, PRIORITY, MATCH, ACTIONS, \\\n                     NULL, NULL, STAGE_HINT, OVS_SOURCE_LOCATOR)\n\n#define ovn_lflow_add_with_dp_group(LFLOW_MAP, DP_BITMAP, STAGE, PRIORITY, \\\n                                    MATCH, ACTIONS, STAGE_HINT) \\\n    ovn_lflow_add_at(LFLOW_MAP, NULL, DP_BITMAP, STAGE, PRIORITY, MATCH, \\\n                     ACTIONS, NULL, NULL, STAGE_HINT, OVS_SOURCE_LOCATOR)\n\n#define ovn_lflow_add_default_drop(LFLOW_MAP, OD, STAGE)                    \\\n    __ovn_lflow_add_default_drop(LFLOW_MAP, OD, STAGE, OVS_SOURCE_LOCATOR)\n\n\n/* This macro is similar to ovn_lflow_add_with_hint, except that it requires\n * the IN_OUT_PORT argument, which tells the lport name that appears in the\n * MATCH, which helps ovn-controller to bypass lflows parsing when the lport is\n * not local to the chassis. The critiera of the lport to be added using this\n * argument:\n *\n * - For ingress pipeline, the lport that is used to match \"inport\".\n * - For egress pipeline, the lport that is used to match \"outport\".\n *\n * For now, only LS pipelines should use this macro.  */\n#define ovn_lflow_add_with_lport_and_hint(LFLOW_MAP, OD, STAGE, PRIORITY, \\\n                                          MATCH, ACTIONS, IN_OUT_PORT, \\\n                                          STAGE_HINT) \\\n    ovn_lflow_add_at(LFLOW_MAP, OD, NULL, STAGE, PRIORITY, MATCH, ACTIONS, \\\n                     IN_OUT_PORT, NULL, STAGE_HINT, OVS_SOURCE_LOCATOR)\n\n#define ovn_lflow_add(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, ACTIONS) \\\n    ovn_lflow_add_at(LFLOW_MAP, OD, NULL, STAGE, PRIORITY, MATCH, ACTIONS, \\\n                     NULL, NULL, NULL, OVS_SOURCE_LOCATOR)\n\n#define ovn_lflow_metered(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, ACTIONS, \\\n                          CTRL_METER) \\\n    ovn_lflow_add_with_hint__(LFLOW_MAP, OD, STAGE, PRIORITY, MATCH, \\\n                              ACTIONS, NULL, CTRL_METER, NULL)\n\nstatic struct ovn_lflow *\novn_lflow_find(const struct hmap *lflows, const struct ovn_datapath *od,\n               enum ovn_stage stage, uint16_t priority,\n               const char *match, const char *actions, const char *ctrl_meter,\n               uint32_t hash)\n{\n    struct ovn_lflow *lflow;\n    HMAP_FOR_EACH_WITH_HASH (lflow, hmap_node, hash, lflows) {\n        if (ovn_lflow_equal(lflow, od, stage, priority, match, actions,\n                            ctrl_meter)) {\n            return lflow;\n        }\n    }\n    return NULL;\n}\n\nstatic void\novn_lflow_destroy(struct hmap *lflows, struct ovn_lflow *lflow)\n{\n    if (lflow) {\n        if (lflows) {\n            hmap_remove(lflows, &lflow->hmap_node);\n        }\n        bitmap_free(lflow->dpg_bitmap);\n        free(lflow->match);\n        free(lflow->actions);\n        free(lflow->io_port);\n        free(lflow->stage_hint);\n        free(lflow->ctrl_meter);\n        free(lflow);\n    }\n}\n\nstatic bool\nbuild_dhcpv4_action(struct ovn_port *op, ovs_be32 offer_ip,\n                    struct ds *options_action, struct ds *response_action,\n                    struct ds *ipv4_addr_match)\n{\n    if (!op->nbsp->dhcpv4_options) {\n        /* CMS has disabled native DHCPv4 for this lport. */\n        return false;\n    }\n\n    ovs_be32 host_ip, mask;\n    char *error = ip_parse_masked(op->nbsp->dhcpv4_options->cidr, &host_ip,\n                                  &mask);\n    if (error || ((offer_ip ^ host_ip) & mask)) {\n       /* Either\n        *  - cidr defined is invalid or\n        *  - the offer ip of the logical port doesn't belong to the cidr\n        *    defined in the DHCPv4 options.\n        *  */\n        free(error);\n        return false;\n    }\n\n    const char *server_ip = smap_get(\n        &op->nbsp->dhcpv4_options->options, \"server_id\");\n    const char *server_mac = smap_get(\n        &op->nbsp->dhcpv4_options->options, \"server_mac\");\n    const char *lease_time = smap_get(\n        &op->nbsp->dhcpv4_options->options, \"lease_time\");\n\n    if (!(server_ip && server_mac && lease_time)) {\n        /* \"server_id\", \"server_mac\" and \"lease_time\" should be\n         * present in the dhcp_options. */\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n        VLOG_WARN_RL(&rl, \"Required DHCPv4 options not defined for lport - %s\",\n                     op->json_key);\n        return false;\n    }\n\n    struct smap dhcpv4_options = SMAP_INITIALIZER(&dhcpv4_options);\n    smap_clone(&dhcpv4_options, &op->nbsp->dhcpv4_options->options);\n\n    /* server_mac is not DHCPv4 option, delete it from the smap. */\n    smap_remove(&dhcpv4_options, \"server_mac\");\n    char *netmask = xasprintf(IP_FMT, IP_ARGS(mask));\n    smap_add(&dhcpv4_options, \"netmask\", netmask);\n    free(netmask);\n\n    ds_put_format(options_action,\n                  REGBIT_DHCP_OPTS_RESULT\" = put_dhcp_opts(offerip = \"\n                  IP_FMT\", \", IP_ARGS(offer_ip));\n\n    /* Try to get hostname DHCP option from ovn_port as it can be passed there\n     * instead of DHCP_Options set. Logical_Switch_Port options:hostname takes\n     precedence over DHCP_Options options:hostname. */\n    const char *hostname = smap_get(&op->nbsp->options, \"hostname\");\n    if (hostname) {\n        smap_replace(&dhcpv4_options, \"hostname\", hostname);\n    }\n\n    /* We're not using SMAP_FOR_EACH because we want a consistent order of the\n     * options on different architectures (big or little endian, SSE4.2) */\n    const struct smap_node **sorted_opts = smap_sort(&dhcpv4_options);\n    for (size_t i = 0; i < smap_count(&dhcpv4_options); i++) {\n        const struct smap_node *node = sorted_opts[i];\n        ds_put_format(options_action, \"%s = %s, \", node->key, node->value);\n    }\n    free(sorted_opts);\n\n    ds_chomp(options_action, ' ');\n    ds_chomp(options_action, ',');\n    ds_put_cstr(options_action, \"); next;\");\n\n    ds_put_format(response_action, \"eth.dst = eth.src; eth.src = %s; \"\n                  \"ip4.src = %s; udp.src = 67; udp.dst = 68; \"\n                  \"outport = inport; flags.loopback = 1; output;\",\n                  server_mac, server_ip);\n\n    ds_put_format(ipv4_addr_match,\n                  \"ip4.src == \"IP_FMT\" && ip4.dst == {%s, 255.255.255.255}\",\n                  IP_ARGS(offer_ip), server_ip);\n    smap_destroy(&dhcpv4_options);\n    return true;\n}\n\nstatic bool\nbuild_dhcpv6_action(struct ovn_port *op, struct in6_addr *offer_ip,\n                    struct ds *options_action, struct ds *response_action)\n{\n    if (!op->nbsp->dhcpv6_options) {\n        /* CMS has disabled native DHCPv6 for this lport. */\n        return false;\n    }\n\n    struct in6_addr host_ip, mask;\n\n    char *error = ipv6_parse_masked(op->nbsp->dhcpv6_options->cidr, &host_ip,\n                                        &mask);\n    if (error) {\n        free(error);\n        return false;\n    }\n    struct in6_addr ip6_mask = ipv6_addr_bitxor(offer_ip, &host_ip);\n    ip6_mask = ipv6_addr_bitand(&ip6_mask, &mask);\n    if (!ipv6_mask_is_any(&ip6_mask)) {\n        /* offer_ip doesn't belongs to the cidr defined in lport's DHCPv6\n         * options.*/\n        return false;\n    }\n\n    const struct smap *options_map = &op->nbsp->dhcpv6_options->options;\n    /* \"server_id\" should be the MAC address. */\n    const char *server_mac = smap_get(options_map, \"server_id\");\n    struct eth_addr ea;\n    if (!server_mac || !eth_addr_from_string(server_mac, &ea)) {\n        /* \"server_id\" should be present in the dhcpv6_options. */\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"server_id not present in the DHCPv6 options\"\n                          \" for lport %s\", op->json_key);\n        return false;\n    }\n\n    /* Get the link local IP of the DHCPv6 server from the server MAC. */\n    struct in6_addr lla;\n    in6_generate_lla(ea, &lla);\n\n    char server_ip[INET6_ADDRSTRLEN + 1];\n    ipv6_string_mapped(server_ip, &lla);\n\n    char ia_addr[INET6_ADDRSTRLEN + 1];\n    ipv6_string_mapped(ia_addr, offer_ip);\n\n    ds_put_format(options_action,\n                  REGBIT_DHCP_OPTS_RESULT\" = put_dhcpv6_opts(\");\n\n    /* Check whether the dhcpv6 options should be configured as stateful.\n     * Only reply with ia_addr option for dhcpv6 stateful address mode. */\n    if (!smap_get_bool(options_map, \"dhcpv6_stateless\", false)) {\n        ipv6_string_mapped(ia_addr, offer_ip);\n        ds_put_format(options_action, \"ia_addr = %s, \", ia_addr);\n    }\n\n    /* We're not using SMAP_FOR_EACH because we want a consistent order of the\n     * options on different architectures (big or little endian, SSE4.2) */\n    const struct smap_node **sorted_opts = smap_sort(options_map);\n    for (size_t i = 0; i < smap_count(options_map); i++) {\n        const struct smap_node *node = sorted_opts[i];\n        if (strcmp(node->key, \"dhcpv6_stateless\")) {\n            ds_put_format(options_action, \"%s = %s, \", node->key, node->value);\n        }\n    }\n    free(sorted_opts);\n\n    ds_chomp(options_action, ' ');\n    ds_chomp(options_action, ',');\n    ds_put_cstr(options_action, \"); next;\");\n\n    ds_put_format(response_action, \"eth.dst = eth.src; eth.src = %s; \"\n                  \"ip6.dst = ip6.src; ip6.src = %s; udp.src = 547; \"\n                  \"udp.dst = 546; outport = inport; flags.loopback = 1; \"\n                  \"output;\",\n                  server_mac, server_ip);\n\n    return true;\n}\n\nstruct ovn_port_group_ls {\n    struct hmap_node key_node;  /* Index on 'key'. */\n    struct uuid key;            /* nb_ls->header_.uuid. */\n    struct ovn_datapath *od;\n\n    struct ovn_port **ports; /* Ports in 'od' referrenced by the PG. */\n    size_t n_ports;\n    size_t n_allocated_ports;\n};\n\nstruct ovn_port_group {\n    struct hmap_node key_node;  /* Index on 'key'. */\n    struct uuid key;            /* nb_pg->header_.uuid. */\n    const struct nbrec_port_group *nb_pg;\n    struct hmap nb_lswitches;   /* NB lswitches related to the port group */\n};\n\nstatic struct ovn_port_group_ls *\novn_port_group_ls_add(struct ovn_port_group *pg, struct ovn_datapath *od)\n{\n    struct ovn_port_group_ls *pg_ls = xzalloc(sizeof *pg_ls);\n    pg_ls->key = od->nbs->header_.uuid;\n    pg_ls->od = od;\n    hmap_insert(&pg->nb_lswitches, &pg_ls->key_node, uuid_hash(&pg_ls->key));\n    return pg_ls;\n}\n\nstatic struct ovn_port_group_ls *\novn_port_group_ls_find(struct ovn_port_group *pg, const struct uuid *ls_uuid)\n{\n    struct ovn_port_group_ls *pg_ls;\n\n    HMAP_FOR_EACH_WITH_HASH (pg_ls, key_node, uuid_hash(ls_uuid),\n                             &pg->nb_lswitches) {\n        if (uuid_equals(ls_uuid, &pg_ls->key)) {\n            return pg_ls;\n        }\n    }\n    return NULL;\n}\n\nstatic void\novn_port_group_ls_add_port(struct ovn_port_group_ls *pg_ls,\n                           struct ovn_port *op)\n{\n    if (pg_ls->n_ports == pg_ls->n_allocated_ports) {\n        pg_ls->ports = x2nrealloc(pg_ls->ports,\n                                  &pg_ls->n_allocated_ports,\n                                  sizeof *pg_ls->ports);\n    }\n    pg_ls->ports[pg_ls->n_ports++] = op;\n}\n\nstruct ovn_ls_port_group {\n    struct hmap_node key_node;  /* Index on 'key'. */\n    struct uuid key;            /* nb_pg->header_.uuid. */\n    const struct nbrec_port_group *nb_pg;\n};\n\nstatic void\novn_ls_port_group_add(struct hmap *nb_pgs,\n                      const struct nbrec_port_group *nb_pg)\n{\n    struct ovn_ls_port_group *ls_pg = xzalloc(sizeof *ls_pg);\n    ls_pg->key = nb_pg->header_.uuid;\n    ls_pg->nb_pg = nb_pg;\n    hmap_insert(nb_pgs, &ls_pg->key_node, uuid_hash(&ls_pg->key));\n}\n\nstatic void\novn_ls_port_group_destroy(struct hmap *nb_pgs)\n{\n    struct ovn_ls_port_group *ls_pg;\n    HMAP_FOR_EACH_POP (ls_pg, key_node, nb_pgs) {\n        free(ls_pg);\n    }\n    hmap_destroy(nb_pgs);\n}\n\nstatic void\nls_get_acl_flags(struct ovn_datapath *od)\n{\n    od->has_acls = false;\n    od->has_stateful_acl = false;\n\n    if (od->nbs->n_acls) {\n        od->has_acls = true;\n\n        for (size_t i = 0; i < od->nbs->n_acls; i++) {\n            struct nbrec_acl *acl = od->nbs->acls[i];\n            if (!strcmp(acl->action, \"allow-related\")) {\n                od->has_stateful_acl = true;\n                return;\n            }\n        }\n    }\n\n    struct ovn_ls_port_group *ls_pg;\n    HMAP_FOR_EACH (ls_pg, key_node, &od->nb_pgs) {\n        if (ls_pg->nb_pg->n_acls) {\n            od->has_acls = true;\n\n            for (size_t i = 0; i < ls_pg->nb_pg->n_acls; i++) {\n                struct nbrec_acl *acl = ls_pg->nb_pg->acls[i];\n                if (!strcmp(acl->action, \"allow-related\")) {\n                    od->has_stateful_acl = true;\n                    return;\n                }\n            }\n        }\n    }\n}\n\n/* Adds the logical flows in the (in/out) check port sec stage only if\n *   - the lport is disabled or\n *   - lport is of type vtep - to skip the ingress pipeline.\n *   - lport has qdisc queue id is configured.\n *\n * For all the other logical ports,  generic flow added in\n * build_lswitch_lflows_admission_control() handles the port security.\n */\nstatic void\nbuild_lswitch_port_sec_op(struct ovn_port *op, struct hmap *lflows,\n                                struct ds *actions, struct ds *match)\n{\n    if (!op->nbsp) {\n        return;\n    }\n\n    if (lsp_is_external(op->nbsp)) {\n        return;\n    }\n\n    ds_clear(match);\n    ds_clear(actions);\n    ds_put_format(match, \"inport == %s\", op->json_key);\n    if (!lsp_is_enabled(op->nbsp)) {\n        /* Drop packets from disabled logical ports. */\n        ovn_lflow_add_with_lport_and_hint(\n            lflows, op->od, S_SWITCH_IN_CHECK_PORT_SEC,\n            100, ds_cstr(match), REGBIT_PORT_SEC_DROP\" = 1; next;\",\n            op->key, &op->nbsp->header_);\n\n        ds_clear(match);\n        ds_put_format(match, \"outport == %s\", op->json_key);\n        ovn_lflow_add_with_lport_and_hint(\n            lflows, op->od, S_SWITCH_IN_L2_UNKNOWN, 50, ds_cstr(match),\n            debug_drop_action(), op->key, &op->nbsp->header_);\n        return;\n    }\n\n    const char *queue_id = smap_get(&op->sb->options, \"qdisc_queue_id\");\n    if (queue_id) {\n        ds_put_format(actions, \"set_queue(%s); \", queue_id);\n    }\n\n    if (lsp_is_vtep(op->nbsp)) {\n        ds_put_format(actions, REGBIT_FROM_RAMP\" = 1; \");\n        ds_put_format(actions, \"next(pipeline=ingress, table=%d);\",\n                      ovn_stage_get_table(S_SWITCH_IN_HAIRPIN));\n        ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                          S_SWITCH_IN_CHECK_PORT_SEC, 70,\n                                          ds_cstr(match), ds_cstr(actions),\n                                          op->key, &op->nbsp->header_);\n    } else if (queue_id) {\n        ds_put_cstr(actions,\n                    REGBIT_PORT_SEC_DROP\" = check_in_port_sec(); next;\");\n        ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                          S_SWITCH_IN_CHECK_PORT_SEC, 70,\n                                          ds_cstr(match), ds_cstr(actions),\n                                          op->key, &op->nbsp->header_);\n\n        if (lsp_is_localnet(op->nbsp)) {\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match, \"outport == %s\", op->json_key);\n            ds_put_format(actions, \"set_queue(%s); output;\", queue_id);\n            ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                            S_SWITCH_OUT_APPLY_PORT_SEC, 100,\n                                            ds_cstr(match), ds_cstr(actions),\n                                            op->key, &op->nbsp->header_);\n        }\n    }\n}\n\nstatic void\nbuild_lswitch_learn_fdb_op(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *actions, struct ds *match)\n{\n    if (!op->nbsp) {\n        return;\n    }\n\n    if (!op->n_ps_addrs && op->has_unknown && (!strcmp(op->nbsp->type, \"\") ||\n        (lsp_is_localnet(op->nbsp) && localnet_can_learn_mac(op->nbsp)))) {\n        ds_clear(match);\n        ds_clear(actions);\n        ds_put_format(match, \"inport == %s\", op->json_key);\n        ds_put_format(actions, REGBIT_LKUP_FDB\n                      \" = lookup_fdb(inport, eth.src); next;\");\n        ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                          S_SWITCH_IN_LOOKUP_FDB, 100,\n                                          ds_cstr(match), ds_cstr(actions),\n                                          op->key, &op->nbsp->header_);\n\n        ds_put_cstr(match, \" && \"REGBIT_LKUP_FDB\" == 0\");\n        ds_clear(actions);\n        ds_put_cstr(actions, \"put_fdb(inport, eth.src); next;\");\n        ovn_lflow_add_with_lport_and_hint(lflows, op->od, S_SWITCH_IN_PUT_FDB,\n                                          100, ds_cstr(match),\n                                          ds_cstr(actions), op->key,\n                                          &op->nbsp->header_);\n    }\n}\n\nstatic void\nbuild_lswitch_learn_fdb_od(\n        struct ovn_datapath *od, struct hmap *lflows)\n{\n\n    if (od->nbs) {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_LOOKUP_FDB, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_PUT_FDB, 0, \"1\", \"next;\");\n    }\n}\n\n/* Egress tables 8: Egress port security - IP (priority 0)\n * Egress table 9: Egress port security L2 - multicast/broadcast\n *                 (priority 100). */\nstatic void\nbuild_lswitch_output_port_sec_od(struct ovn_datapath *od,\n                              struct hmap *lflows)\n{\n    if (od->nbs) {\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_CHECK_PORT_SEC, 100,\n                      \"eth.mcast\", REGBIT_PORT_SEC_DROP\" = 0; next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_CHECK_PORT_SEC, 0, \"1\",\n                      REGBIT_PORT_SEC_DROP\" = check_out_port_sec(); next;\");\n\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_APPLY_PORT_SEC, 50,\n                      REGBIT_PORT_SEC_DROP\" == 1\", debug_drop_action());\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_APPLY_PORT_SEC, 0,\n                      \"1\", \"output;\");\n\n    }\n}\n\nstatic void\nskip_port_from_conntrack(struct ovn_datapath *od, struct ovn_port *op,\n                         enum ovn_stage in_stage, enum ovn_stage out_stage,\n                         uint16_t priority, struct hmap *lflows)\n{\n    /* Can't use ct() for router ports. Consider the following configuration:\n     * lp1(10.0.0.2) on hostA--ls1--lr0--ls2--lp2(10.0.1.2) on hostB, For a\n     * ping from lp1 to lp2, First, the response will go through ct() with a\n     * zone for lp2 in the ls2 ingress pipeline on hostB.  That ct zone knows\n     * about this connection. Next, it goes through ct() with the zone for the\n     * router port in the egress pipeline of ls2 on hostB.  This zone does not\n     * know about the connection, as the icmp request went through the logical\n     * router on hostA, not hostB. This would only work with distributed\n     * conntrack state across all chassis. */\n\n    const char *ingress_action = \"next;\";\n    const char *egress_action = od->has_stateful_acl\n                                ? \"next;\"\n                                : \"ct_clear; next;\";\n\n    char *ingress_match = xasprintf(\"ip && inport == %s\", op->json_key);\n    char *egress_match = xasprintf(\"ip && outport == %s\", op->json_key);\n\n    ovn_lflow_add_with_lport_and_hint(lflows, od, in_stage, priority,\n                                      ingress_match, ingress_action,\n                                      op->key, &op->nbsp->header_);\n    ovn_lflow_add_with_lport_and_hint(lflows, od, out_stage, priority,\n                                      egress_match, egress_action,\n                                      op->key, &op->nbsp->header_);\n\n    free(ingress_match);\n    free(egress_match);\n}\n\nstatic void\nbuild_stateless_filter(struct ovn_datapath *od,\n                       const struct nbrec_acl *acl,\n                       struct hmap *lflows)\n{\n    const char *action = REGBIT_ACL_STATELESS\" = 1; next;\";\n    if (!strcmp(acl->direction, \"from-lport\")) {\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_PRE_ACL,\n                                acl->priority + OVN_ACL_PRI_OFFSET,\n                                acl->match,\n                                action,\n                                &acl->header_);\n    } else {\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_OUT_PRE_ACL,\n                                acl->priority + OVN_ACL_PRI_OFFSET,\n                                acl->match,\n                                action,\n                                &acl->header_);\n    }\n}\n\nstatic void\nbuild_stateless_filters(struct ovn_datapath *od,\n                        const struct hmap *port_groups,\n                        struct hmap *lflows)\n{\n    for (size_t i = 0; i < od->nbs->n_acls; i++) {\n        const struct nbrec_acl *acl = od->nbs->acls[i];\n        if (!strcmp(acl->action, \"allow-stateless\")) {\n            build_stateless_filter(od, acl, lflows);\n        }\n    }\n\n    struct ovn_port_group *pg;\n    HMAP_FOR_EACH (pg, key_node, port_groups) {\n        if (ovn_port_group_ls_find(pg, &od->nbs->header_.uuid)) {\n            for (size_t i = 0; i < pg->nb_pg->n_acls; i++) {\n                const struct nbrec_acl *acl = pg->nb_pg->acls[i];\n                if (!strcmp(acl->action, \"allow-stateless\")) {\n                    build_stateless_filter(od, acl, lflows);\n                }\n            }\n        }\n    }\n}\n\nstatic void\nbuild_pre_acls(struct ovn_datapath *od, const struct hmap *port_groups,\n               struct hmap *lflows)\n{\n    /* Ingress and Egress Pre-ACL Table (Priority 0): Packets are\n     * allowed by default. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_ACL, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_ACL, 0, \"1\", \"next;\");\n\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_ACL, 110,\n                  \"eth.dst == $svc_monitor_mac\", \"next;\");\n\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_ACL, 110,\n                  \"eth.src == $svc_monitor_mac\", \"next;\");\n\n    /* If there are any stateful ACL rules in this datapath, we may\n     * send IP packets for some (allow) filters through the conntrack action,\n     * which handles defragmentation, in order to match L4 headers. */\n    if (od->has_stateful_acl) {\n        for (size_t i = 0; i < od->n_router_ports; i++) {\n            skip_port_from_conntrack(od, od->router_ports[i],\n                                     S_SWITCH_IN_PRE_ACL, S_SWITCH_OUT_PRE_ACL,\n                                     110, lflows);\n        }\n        for (size_t i = 0; i < od->n_localnet_ports; i++) {\n            skip_port_from_conntrack(od, od->localnet_ports[i],\n                                     S_SWITCH_IN_PRE_ACL,\n                                     S_SWITCH_OUT_PRE_ACL,\n                                     110, lflows);\n        }\n\n        /* stateless filters always take precedence over stateful ACLs. */\n        build_stateless_filters(od, port_groups, lflows);\n\n        /* Ingress and Egress Pre-ACL Table (Priority 110).\n         *\n         * Not to do conntrack on ND and ICMP destination\n         * unreachable packets. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_ACL, 110,\n                      \"nd || nd_rs || nd_ra || mldv1 || mldv2 || \"\n                      \"(udp && udp.src == 546 && udp.dst == 547)\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_ACL, 110,\n                      \"nd || nd_rs || nd_ra || mldv1 || mldv2 || \"\n                      \"(udp && udp.src == 546 && udp.dst == 547)\", \"next;\");\n\n        /* Do not send multicast packets to conntrack. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_ACL, 110, \"eth.mcast\",\n                      \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_ACL, 110, \"eth.mcast\",\n                      \"next;\");\n\n        /* Ingress and Egress Pre-ACL Table (Priority 100).\n         *\n         * Regardless of whether the ACL is \"from-lport\" or \"to-lport\",\n         * we need rules in both the ingress and egress table, because\n         * the return traffic needs to be followed.\n         *\n         * 'REGBIT_CONNTRACK_DEFRAG' is set to let the pre-stateful table send\n         * it to conntrack for tracking and defragmentation. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_ACL, 100, \"ip\",\n                      REGBIT_CONNTRACK_DEFRAG\" = 1; next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_ACL, 100, \"ip\",\n                      REGBIT_CONNTRACK_DEFRAG\" = 1; next;\");\n    } else if (od->has_lb_vip) {\n        /* We'll build stateless filters if there are LB rules so that\n         * the stateless flows are not tracked in pre-lb. */\n         build_stateless_filters(od, port_groups, lflows);\n    }\n}\n\n/*\n * Returns true if logical switch is configured with DNS records, false\n * otherwise.\n */\nstatic bool\nls_has_dns_records(const struct nbrec_logical_switch *nbs)\n{\n    for (size_t i = 0; i < nbs->n_dns_records; i++) {\n        if (!smap_is_empty(&nbs->dns_records[i]->records)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nstatic bool\nbuild_empty_lb_event_flow(struct ovn_lb_vip *lb_vip,\n                          const struct ovn_northd_lb *lb,\n                          struct ds *match, struct ds *action)\n{\n    bool controller_event = lb->controller_event ||\n                            controller_event_en; /* deprecated */\n    if (!controller_event || lb_vip->n_backends ||\n        lb_vip->empty_backend_rej) {\n        return false;\n    }\n\n    ds_clear(action);\n    ds_clear(match);\n\n    bool ipv4 = lb_vip->address_family == AF_INET;\n\n    ds_put_format(match, \"ip%s.dst == %s && %s\",\n                  ipv4 ? \"4\": \"6\", lb_vip->vip_str, lb->proto);\n\n    char *vip = lb_vip->vip_str;\n    if (lb_vip->port_str) {\n        ds_put_format(match, \" && %s.dst == %s\", lb->proto, lb_vip->port_str);\n        vip = xasprintf(\"%s%s%s:%s\", ipv4 ? \"\" : \"[\", lb_vip->vip_str,\n                        ipv4 ? \"\" : \"]\", lb_vip->port_str);\n    }\n\n    ds_put_format(action,\n                  \"trigger_event(event = \\\"%s\\\", \"\n                  \"vip = \\\"%s\\\", \"\n                  \"protocol = \\\"%s\\\", \"\n                  \"load_balancer = \\\"\" UUID_FMT \"\\\");\",\n                  event_to_string(OVN_EVENT_EMPTY_LB_BACKENDS),\n                  vip, lb->proto,\n                  UUID_ARGS(&lb->nlb->header_.uuid));\n    if (lb_vip->port_str) {\n        free(vip);\n    }\n    return true;\n}\n\nstatic void\nbuild_interconn_mcast_snoop_flows(struct ovn_datapath *od,\n                                  const struct shash *meter_groups,\n                                  struct hmap *lflows)\n{\n    struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n    if (!mcast_sw_info->enabled\n        || !smap_get(&od->nbs->other_config, \"interconn-ts\")) {\n        return;\n    }\n\n    struct ovn_port *op;\n\n    LIST_FOR_EACH (op, dp_node, &od->port_list) {\n        if (!lsp_is_remote(op->nbsp)) {\n            continue;\n        }\n        /* Punt IGMP traffic to controller. */\n        char *match = xasprintf(\"inport == %s && igmp\", op->json_key);\n        ovn_lflow_metered(lflows, od, S_SWITCH_OUT_PRE_LB, 120, match,\n                          \"clone { igmp; }; next;\",\n                          copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                         meter_groups));\n        free(match);\n\n        /* Punt MLD traffic to controller. */\n        match = xasprintf(\"inport == %s && (mldv1 || mldv2)\", op->json_key);\n        ovn_lflow_metered(lflows, od, S_SWITCH_OUT_PRE_LB, 120, match,\n                          \"clone { igmp; }; next;\",\n                          copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                         meter_groups));\n        free(match);\n    }\n}\n\nstatic void\nbuild_pre_lb(struct ovn_datapath *od, const struct shash *meter_groups,\n             struct hmap *lflows)\n{\n    /* Handle IGMP/MLD packets crossing AZs. */\n    build_interconn_mcast_snoop_flows(od, meter_groups, lflows);\n\n    /* Do not send multicast packets to conntrack */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB, 110, \"eth.mcast\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB, 110, \"eth.mcast\", \"next;\");\n\n    /* Do not send ND packets to conntrack */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB, 110,\n                  \"nd || nd_rs || nd_ra || mldv1 || mldv2\",\n                  \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB, 110,\n                  \"nd || nd_rs || nd_ra || mldv1 || mldv2\",\n                  \"next;\");\n\n    /* Do not send service monitor packets to conntrack. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB, 110,\n                  \"eth.dst == $svc_monitor_mac\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB, 110,\n                  \"eth.src == $svc_monitor_mac\", \"next;\");\n\n    /* Allow all packets to go to next tables by default. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB, 0, \"1\", \"next;\");\n\n    for (size_t i = 0; i < od->n_router_ports; i++) {\n        skip_port_from_conntrack(od, od->router_ports[i],\n                                 S_SWITCH_IN_PRE_LB, S_SWITCH_OUT_PRE_LB,\n                                 110, lflows);\n    }\n    /* Localnet ports have no need for going through conntrack, unless\n     * the logical switch has a load balancer. Then, conntrack is necessary\n     * so that traffic arriving via the localnet port can be load\n     * balanced.\n     */\n    if (!od->has_lb_vip) {\n        for (size_t i = 0; i < od->n_localnet_ports; i++) {\n            skip_port_from_conntrack(od, od->localnet_ports[i],\n                                     S_SWITCH_IN_PRE_LB, S_SWITCH_OUT_PRE_LB,\n                                     110, lflows);\n        }\n    }\n\n    /* Do not sent statless flows via conntrack */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB, 110,\n                  REGBIT_ACL_STATELESS\" == 1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB, 110,\n                  REGBIT_ACL_STATELESS\" == 1\", \"next;\");\n\n    /* 'REGBIT_CONNTRACK_NAT' is set to let the pre-stateful table send\n     * packet to conntrack for defragmentation and possibly for unNATting.\n     *\n     * Send all the packets to conntrack in the ingress pipeline if the\n     * logical switch has a load balancer with VIP configured. Earlier\n     * we used to set the REGBIT_CONNTRACK_DEFRAG flag in the ingress\n     * pipeline if the IP destination matches the VIP. But this causes\n     * few issues when a logical switch has no ACLs configured with\n     * allow-related.\n     * To understand the issue, lets a take a TCP load balancer -\n     * 10.0.0.10:80=10.0.0.3:80.\n     * If a logical port - p1 with IP - 10.0.0.5 opens a TCP connection\n     * with the VIP - 10.0.0.10, then the packet in the ingress pipeline\n     * of 'p1' is sent to the p1's conntrack zone id and the packet is\n     * load balanced to the backend - 10.0.0.3. For the reply packet from\n     * the backend lport, it is not sent to the conntrack of backend\n     * lport's zone id. This is fine as long as the packet is valid.\n     * Suppose the backend lport sends an invalid TCP packet (like\n     * incorrect sequence number), the packet gets * delivered to the\n     * lport 'p1' without unDNATing the packet to the VIP - 10.0.0.10.\n     * And this causes the connection to be reset by the lport p1's VIF.\n     *\n     * We can't fix this issue by adding a logical flow to drop ct.inv\n     * packets in the egress pipeline since it will drop all other\n     * connections not destined to the load balancers.\n     *\n     * To fix this issue, we send all the packets to the conntrack in the\n     * ingress pipeline if a load balancer is configured. We can now\n     * add a lflow to drop ct.inv packets.\n     */\n    if (od->has_lb_vip) {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_LB,\n                      100, \"ip\", REGBIT_CONNTRACK_NAT\" = 1; next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_LB,\n                      100, \"ip\", REGBIT_CONNTRACK_NAT\" = 1; next;\");\n    }\n}\n\nstatic void\nbuild_pre_stateful(struct ovn_datapath *od,\n                   const struct chassis_features *features,\n                   struct hmap *lflows)\n{\n    /* Ingress and Egress pre-stateful Table (Priority 0): Packets are\n     * allowed by default. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_STATEFUL, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_STATEFUL, 0, \"1\", \"next;\");\n\n    /* Note: priority-120 flows are added in build_lb_rules_pre_stateful(). */\n\n    const char *ct_lb_action = features->ct_no_masked_label\n                               ? \"ct_lb_mark;\"\n                               : \"ct_lb;\";\n\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_STATEFUL, 110,\n                  REGBIT_CONNTRACK_NAT\" == 1\", ct_lb_action);\n\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_STATEFUL, 110,\n                  REGBIT_CONNTRACK_NAT\" == 1\", ct_lb_action);\n\n    /* If REGBIT_CONNTRACK_DEFRAG is set as 1, then the packets should be\n     * sent to conntrack for tracking and defragmentation. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_STATEFUL, 100,\n                  REGBIT_CONNTRACK_DEFRAG\" == 1\", \"ct_next;\");\n\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_PRE_STATEFUL, 100,\n                  REGBIT_CONNTRACK_DEFRAG\" == 1\", \"ct_next;\");\n\n}\n\nstatic void\nbuild_acl_hints(struct ovn_datapath *od,\n                const struct chassis_features *features,\n                struct hmap *lflows)\n{\n    /* This stage builds hints for the IN/OUT_ACL stage. Based on various\n     * combinations of ct flags packets may hit only a subset of the logical\n     * flows in the IN/OUT_ACL stage.\n     *\n     * Populating ACL hints first and storing them in registers simplifies\n     * the logical flow match expressions in the IN/OUT_ACL stage and\n     * generates less openflows.\n     *\n     * Certain combinations of ct flags might be valid matches for multiple\n     * types of ACL logical flows (e.g., allow/drop). In such cases hints\n     * corresponding to all potential matches are set.\n     */\n\n    enum ovn_stage stages[] = {\n        S_SWITCH_IN_ACL_HINT,\n        S_SWITCH_OUT_ACL_HINT,\n    };\n\n    for (size_t i = 0; i < ARRAY_SIZE(stages); i++) {\n        enum ovn_stage stage = stages[i];\n        const char *match;\n\n        /* In any case, advance to the next stage. */\n        if (!od->has_acls && !od->has_lb_vip) {\n            ovn_lflow_add(lflows, od, stage, UINT16_MAX, \"1\", \"next;\");\n        } else {\n            ovn_lflow_add(lflows, od, stage, 0, \"1\", \"next;\");\n        }\n\n        if (!od->has_stateful_acl && !od->has_lb_vip) {\n            continue;\n        }\n\n        /* New, not already established connections, may hit either allow\n         * or drop ACLs. For allow ACLs, the connection must also be committed\n         * to conntrack so we set REGBIT_ACL_HINT_ALLOW_NEW.\n         */\n        ovn_lflow_add(lflows, od, stage, 7, \"ct.new && !ct.est\",\n                      REGBIT_ACL_HINT_ALLOW_NEW \" = 1; \"\n                      REGBIT_ACL_HINT_DROP \" = 1; \"\n                      \"next;\");\n\n        /* Already established connections in the \"request\" direction that\n         * are already marked as \"blocked\" may hit either:\n         * - allow ACLs for connections that were previously allowed by a\n         *   policy that was deleted and is being readded now. In this case\n         *   the connection should be recommitted so we set\n         *   REGBIT_ACL_HINT_ALLOW_NEW.\n         * - drop ACLs.\n         */\n        match = features->ct_no_masked_label\n                ? \"!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1\"\n                : \"!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1\";\n        ovn_lflow_add(lflows, od, stage, 6, match,\n                      REGBIT_ACL_HINT_ALLOW_NEW \" = 1; \"\n                      REGBIT_ACL_HINT_DROP \" = 1; \"\n                      \"next;\");\n\n        /* Not tracked traffic can either be allowed or dropped. */\n        ovn_lflow_add(lflows, od, stage, 5, \"!ct.trk\",\n                      REGBIT_ACL_HINT_ALLOW \" = 1; \"\n                      REGBIT_ACL_HINT_DROP \" = 1; \"\n                      \"next;\");\n\n        /* Already established connections in the \"request\" direction may hit\n         * either:\n         * - allow ACLs in which case the traffic should be allowed so we set\n         *   REGBIT_ACL_HINT_ALLOW.\n         * - drop ACLs in which case the traffic should be blocked and the\n         *   connection must be committed with ct_mark.blocked set so we set\n         *   REGBIT_ACL_HINT_BLOCK.\n         */\n        match = features->ct_no_masked_label\n                ? \"!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0\"\n                : \"!ct.new && ct.est && !ct.rpl && ct_label.blocked == 0\";\n        ovn_lflow_add(lflows, od, stage, 4, match,\n                      REGBIT_ACL_HINT_ALLOW \" = 1; \"\n                      REGBIT_ACL_HINT_BLOCK \" = 1; \"\n                      \"next;\");\n\n        /* Not established or established and already blocked connections may\n         * hit drop ACLs.\n         */\n        ovn_lflow_add(lflows, od, stage, 3, \"!ct.est\",\n                      REGBIT_ACL_HINT_DROP \" = 1; \"\n                      \"next;\");\n        match = features->ct_no_masked_label\n                ? \"ct.est && ct_mark.blocked == 1\"\n                : \"ct.est && ct_label.blocked == 1\";\n        ovn_lflow_add(lflows, od, stage, 2, match,\n                      REGBIT_ACL_HINT_DROP \" = 1; \"\n                      \"next;\");\n\n        /* Established connections that were previously allowed might hit\n         * drop ACLs in which case the connection must be committed with\n         * ct_mark.blocked set.\n         */\n        match = features->ct_no_masked_label\n                ? \"ct.est && ct_mark.blocked == 0\"\n                : \"ct.est && ct_label.blocked == 0\";\n        ovn_lflow_add(lflows, od, stage, 1, match,\n                      REGBIT_ACL_HINT_BLOCK \" = 1; \"\n                      \"next;\");\n    }\n}\n\nstatic const struct nbrec_meter*\nfair_meter_lookup_by_name(const struct shash *meter_groups,\n                          const char *meter_name)\n{\n    const struct nbrec_meter *nb_meter =\n        meter_name ? shash_find_data(meter_groups, meter_name) : NULL;\n    if (nb_meter) {\n        return (nb_meter->fair && *nb_meter->fair) ? nb_meter : NULL;\n    }\n    return NULL;\n}\n\nstatic char*\nalloc_acl_log_unique_meter_name(const struct nbrec_acl *acl)\n{\n    return xasprintf(\"%s__\" UUID_FMT,\n                     acl->meter, UUID_ARGS(&acl->header_.uuid));\n}\n\nstatic void\nbuild_acl_log_meter(struct ds *actions, const struct nbrec_acl *acl,\n                    const struct shash *meter_groups)\n{\n    if (!acl->meter) {\n        return;\n    }\n\n    /* If ACL log meter uses a fair meter, use unique Meter name. */\n    if (fair_meter_lookup_by_name(meter_groups, acl->meter)) {\n        char *meter_name = alloc_acl_log_unique_meter_name(acl);\n        ds_put_format(actions, \"meter=\\\"%s\\\", \", meter_name);\n        free(meter_name);\n    } else {\n        ds_put_format(actions, \"meter=\\\"%s\\\", \", acl->meter);\n    }\n}\n\nstatic void\nbuild_acl_log(struct ds *actions, const struct nbrec_acl *acl,\n              const struct shash *meter_groups)\n{\n    if (!acl->log) {\n        return;\n    }\n\n    ds_put_cstr(actions, \"log(\");\n\n    if (acl->name) {\n        ds_put_format(actions, \"name=\\\"%s\\\", \", acl->name);\n    }\n\n    /* If a severity level isn't specified, default to \"info\". */\n    if (acl->severity) {\n        ds_put_format(actions, \"severity=%s, \", acl->severity);\n    } else {\n        ds_put_format(actions, \"severity=info, \");\n    }\n\n    if (!strcmp(acl->action, \"drop\")) {\n        ds_put_cstr(actions, \"verdict=drop, \");\n    } else if (!strcmp(acl->action, \"reject\")) {\n        ds_put_cstr(actions, \"verdict=reject, \");\n    } else if (!strcmp(acl->action, \"allow\")\n        || !strcmp(acl->action, \"allow-related\")\n        || !strcmp(acl->action, \"allow-stateless\")) {\n        ds_put_cstr(actions, \"verdict=allow, \");\n    }\n\n    build_acl_log_meter(actions, acl, meter_groups);\n\n    ds_chomp(actions, ' ');\n    ds_chomp(actions, ',');\n    ds_put_cstr(actions, \"); \");\n}\n\nstatic void\nbuild_reject_acl_rules(struct ovn_datapath *od, struct hmap *lflows,\n                       enum ovn_stage stage, struct nbrec_acl *acl,\n                       struct ds *extra_match, struct ds *extra_actions,\n                       const struct ovsdb_idl_row *stage_hint,\n                       const struct shash *meter_groups)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n    bool ingress = (ovn_stage_get_pipeline(stage) == P_IN);\n\n    char *next_action =\n        xasprintf(\"next(pipeline=%s,table=%d);\",\n                  ingress ? \"egress\": \"ingress\",\n                  ingress ? ovn_stage_get_table(S_SWITCH_OUT_QOS_MARK)\n                          : ovn_stage_get_table(S_SWITCH_IN_L2_LKUP));\n\n    build_acl_log(&actions, acl, meter_groups);\n    if (extra_match->length > 0) {\n        ds_put_format(&match, \"(%s) && \", extra_match->string);\n    }\n    ds_put_cstr(&match, acl->match);\n\n    if (extra_actions->length > 0) {\n        ds_put_format(&actions, \"%s \", extra_actions->string);\n    }\n\n    ds_put_format(&actions, \"reg0 = 0; \"\n                  \"reject { \"\n                  \"/* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ \"\n                  \"outport <-> inport; %s };\", next_action);\n    ovn_lflow_add_with_hint__(lflows, od, stage,\n                              acl->priority + OVN_ACL_PRI_OFFSET,\n                              ds_cstr(&match), ds_cstr(&actions), NULL,\n                              copp_meter_get(COPP_REJECT, od->nbs->copp,\n                                             meter_groups),\n                              stage_hint);\n\n    free(next_action);\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic void\nconsider_acl(struct hmap *lflows, struct ovn_datapath *od,\n             struct nbrec_acl *acl, bool has_stateful, bool ct_masked_mark,\n             const struct shash *meter_groups, struct ds *match,\n             struct ds *actions)\n{\n    const char *ct_blocked_match = ct_masked_mark\n                                   ? \"ct_mark.blocked\"\n                                   : \"ct_label.blocked\";\n    bool ingress = !strcmp(acl->direction, \"from-lport\") ? true :false;\n    enum ovn_stage stage;\n\n    if (ingress && smap_get_bool(&acl->options, \"apply-after-lb\", false)) {\n        stage = S_SWITCH_IN_ACL_AFTER_LB;\n    } else if (ingress) {\n        stage = S_SWITCH_IN_ACL;\n    } else {\n        stage = S_SWITCH_OUT_ACL;\n    }\n\n    if (!strcmp(acl->action, \"allow-stateless\")) {\n        ds_clear(actions);\n        build_acl_log(actions, acl, meter_groups);\n        ds_put_cstr(actions, \"next;\");\n        ovn_lflow_add_with_hint(lflows, od, stage,\n                                acl->priority + OVN_ACL_PRI_OFFSET,\n                                acl->match, ds_cstr(actions),\n                                &acl->header_);\n    } else if (!strcmp(acl->action, \"allow\")\n        || !strcmp(acl->action, \"allow-related\")) {\n        /* If there are any stateful flows, we must even commit \"allow\"\n         * actions.  This is because, while the initiater's\n         * direction may not have any stateful rules, the server's\n         * may and then its return traffic would not have an\n         * associated conntrack entry and would return \"+invalid\". */\n        if (!has_stateful) {\n            ds_clear(actions);\n            build_acl_log(actions, acl, meter_groups);\n            ds_put_cstr(actions, \"next;\");\n            ovn_lflow_add_with_hint(lflows, od, stage,\n                                    acl->priority + OVN_ACL_PRI_OFFSET,\n                                    acl->match, ds_cstr(actions),\n                                    &acl->header_);\n        } else {\n            /* Commit the connection tracking entry if it's a new\n             * connection that matches this ACL.  After this commit,\n             * the reply traffic is allowed by a flow we create at\n             * priority 65535, defined earlier.\n             *\n             * It's also possible that a known connection was marked for\n             * deletion after a policy was deleted, but the policy was\n             * re-added while that connection is still known.  We catch\n             * that case here and un-set ct_mark.blocked (which will be done\n             * by ct_commit in the \"stateful\" stage) to indicate that the\n             * connection should be allowed to resume.\n             */\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match, REGBIT_ACL_HINT_ALLOW_NEW \" == 1 && (%s)\",\n                          acl->match);\n\n            ds_put_cstr(actions, REGBIT_CONNTRACK_COMMIT\" = 1; \");\n            if (acl->label) {\n                ds_put_format(actions, REGBIT_ACL_LABEL\" = 1; \"\n                              REG_LABEL\" = %\"PRId64\"; \", acl->label);\n            }\n            build_acl_log(actions, acl, meter_groups);\n            ds_put_cstr(actions, \"next;\");\n            ovn_lflow_add_with_hint(lflows, od, stage,\n                                    acl->priority + OVN_ACL_PRI_OFFSET,\n                                    ds_cstr(match),\n                                    ds_cstr(actions),\n                                    &acl->header_);\n\n            /* Match on traffic in the request direction for an established\n             * connection tracking entry that has not been marked for\n             * deletion. We use this to ensure that this\n             * connection is still allowed by the currently defined\n             * policy. Match untracked packets too.\n             * Commit the connection only if the ACL has a label. This is done\n             * to update the connection tracking entry label in case the ACL\n             * allowing the connection changes. */\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match, REGBIT_ACL_HINT_ALLOW \" == 1 && (%s)\",\n                          acl->match);\n            if (acl->label) {\n                ds_put_cstr(actions, REGBIT_CONNTRACK_COMMIT\" = 1; \");\n                ds_put_format(actions, REGBIT_ACL_LABEL\" = 1; \"\n                              REG_LABEL\" = %\"PRId64\"; \", acl->label);\n            }\n            build_acl_log(actions, acl, meter_groups);\n            ds_put_cstr(actions, \"next;\");\n            ovn_lflow_add_with_hint(lflows, od, stage,\n                                    acl->priority + OVN_ACL_PRI_OFFSET,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &acl->header_);\n\n            /* Related and reply traffic are universally allowed by priority\n             * 65532 flows created in build_acls(). If logging is enabled on\n             * the ACL, then we need to ensure that the related and reply\n             * traffic is logged, so we install a slightly higher-priority\n             * flow that matches the ACL, allows the traffic, and logs it.\n             *\n             * Note: Matching the ct_label.label may prevent OVS flow HW\n             * offloading to work for some NICs because masked-access of\n             * ct_label is not supported on those NICs due to HW\n             * limitations. In such case the user may choose to avoid using the\n             * \"log-related\" option.\n             */\n            bool log_related = smap_get_bool(&acl->options, \"log-related\",\n                                             false);\n            if (acl->log && acl->label && log_related) {\n                /* Related/reply flows need to be set on the opposite pipeline\n                 * from where the ACL itself is set.\n                 */\n                enum ovn_stage log_related_stage = ingress ?\n                    S_SWITCH_OUT_ACL :\n                    S_SWITCH_IN_ACL;\n                ds_clear(match);\n                ds_clear(actions);\n\n                ds_put_format(match, \"ct.est && !ct.rel && !ct.new%s && \"\n                              \"ct.rpl && %s == 0 && \"\n                              \"ct_label.label == %\" PRId64,\n                              use_ct_inv_match ? \" && !ct.inv\" : \"\",\n                              ct_blocked_match, acl->label);\n                build_acl_log(actions, acl, meter_groups);\n                ds_put_cstr(actions, \"next;\");\n                ovn_lflow_add_with_hint(lflows, od, log_related_stage,\n                                        UINT16_MAX - 2,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &acl->header_);\n\n                ds_clear(match);\n                ds_put_format(match, \"!ct.est && ct.rel && !ct.new%s && \"\n                                     \"%s == 0 && \"\n                                     \"ct_label.label == %\" PRId64,\n                                     use_ct_inv_match ? \" && !ct.inv\" : \"\",\n                                     ct_blocked_match, acl->label);\n                ovn_lflow_add_with_hint(lflows, od, log_related_stage,\n                                        UINT16_MAX - 2,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &acl->header_);\n            }\n\n        }\n    } else if (!strcmp(acl->action, \"drop\")\n               || !strcmp(acl->action, \"reject\")) {\n        /* The implementation of \"drop\" differs if stateful ACLs are in\n         * use for this datapath.  In that case, the actions differ\n         * depending on whether the connection was previously committed\n         * to the connection tracker with ct_commit. */\n        if (has_stateful) {\n            /* If the packet is not tracked or not part of an established\n             * connection, then we can simply reject/drop it. */\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_cstr(match, REGBIT_ACL_HINT_DROP \" == 1\");\n            if (!strcmp(acl->action, \"reject\")) {\n                build_reject_acl_rules(od, lflows, stage, acl, match,\n                                       actions, &acl->header_, meter_groups);\n            } else {\n                ds_put_format(match, \" && (%s)\", acl->match);\n                build_acl_log(actions, acl, meter_groups);\n                ds_put_cstr(actions, debug_implicit_drop_action());\n                ovn_lflow_add_with_hint(lflows, od, stage,\n                                        acl->priority + OVN_ACL_PRI_OFFSET,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &acl->header_);\n            }\n            /* For an existing connection without ct_mark.blocked set, we've\n             * encountered a policy change. ACLs previously allowed\n             * this connection and we committed the connection tracking\n             * entry.  Current policy says that we should drop this\n             * connection.  First, we set ct_mark.blocked to indicate\n             * that this connection is set for deletion.  By not\n             * specifying \"next;\", we implicitly drop the packet after\n             * updating conntrack state.  We would normally defer\n             * ct_commit() to the \"stateful\" stage, but since we're\n             * rejecting/dropping the packet, we go ahead and do it here.\n             */\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_cstr(match, REGBIT_ACL_HINT_BLOCK \" == 1\");\n            ds_put_format(actions, \"ct_commit { %s = 1; }; \",\n                          ct_blocked_match);\n            if (!strcmp(acl->action, \"reject\")) {\n                build_reject_acl_rules(od, lflows, stage, acl, match,\n                                       actions, &acl->header_, meter_groups);\n            } else {\n                ds_put_format(match, \" && (%s)\", acl->match);\n                build_acl_log(actions, acl, meter_groups);\n                ds_put_cstr(actions, debug_implicit_drop_action());\n                ovn_lflow_add_with_hint(lflows, od, stage,\n                                        acl->priority + OVN_ACL_PRI_OFFSET,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &acl->header_);\n            }\n        } else {\n            /* There are no stateful ACLs in use on this datapath,\n             * so a \"reject/drop\" ACL is simply the \"reject/drop\"\n             * logical flow action in all cases. */\n            ds_clear(match);\n            ds_clear(actions);\n            if (!strcmp(acl->action, \"reject\")) {\n                build_reject_acl_rules(od, lflows, stage, acl, match,\n                                       actions, &acl->header_, meter_groups);\n            } else {\n                build_acl_log(actions, acl, meter_groups);\n                ds_put_cstr(actions, debug_implicit_drop_action());\n                ovn_lflow_add_with_hint(lflows, od, stage,\n                                        acl->priority + OVN_ACL_PRI_OFFSET,\n                                        acl->match, ds_cstr(actions),\n                                        &acl->header_);\n            }\n        }\n    }\n}\n\nstatic struct ovn_port_group *\novn_port_group_create(struct hmap *pgs,\n                      const struct nbrec_port_group *nb_pg)\n{\n    struct ovn_port_group *pg = xzalloc(sizeof *pg);\n    pg->key = nb_pg->header_.uuid;\n    pg->nb_pg = nb_pg;\n    hmap_init(&pg->nb_lswitches);\n    hmap_insert(pgs, &pg->key_node, uuid_hash(&pg->key));\n    return pg;\n}\n\nstatic void\novn_port_group_destroy(struct hmap *pgs, struct ovn_port_group *pg)\n{\n    if (pg) {\n        hmap_remove(pgs, &pg->key_node);\n        struct ovn_port_group_ls *ls;\n        HMAP_FOR_EACH_POP (ls, key_node, &pg->nb_lswitches) {\n            free(ls->ports);\n            free(ls);\n        }\n        hmap_destroy(&pg->nb_lswitches);\n        free(pg);\n    }\n}\n\nstatic void\ncopy_ra_to_sb(struct ovn_port *op, const char *address_mode);\n\nstatic void\novn_update_ipv6_options(struct hmap *ports)\n{\n    struct ovn_port *op;\n    HMAP_FOR_EACH (op, key_node, ports) {\n        if (!op->nbrp || op->nbrp->peer || !op->peer) {\n            continue;\n        }\n\n        if (!op->lrp_networks.n_ipv6_addrs) {\n            continue;\n        }\n\n        struct smap options;\n        smap_clone(&options, &op->sb->options);\n\n        /* enable IPv6 prefix delegation */\n        bool prefix_delegation = smap_get_bool(&op->nbrp->options,\n                                           \"prefix_delegation\", false);\n        if (!lrport_is_enabled(op->nbrp)) {\n            prefix_delegation = false;\n        }\n        if (smap_get_bool(&options, \"ipv6_prefix_delegation\",\n                          false) != prefix_delegation) {\n            smap_add(&options, \"ipv6_prefix_delegation\",\n                     prefix_delegation ? \"true\" : \"false\");\n        }\n\n        bool ipv6_prefix = smap_get_bool(&op->nbrp->options,\n                                     \"prefix\", false);\n        if (!lrport_is_enabled(op->nbrp)) {\n            ipv6_prefix = false;\n        }\n        if (smap_get_bool(&options, \"ipv6_prefix\", false) != ipv6_prefix) {\n            smap_add(&options, \"ipv6_prefix\",\n                     ipv6_prefix ? \"true\" : \"false\");\n        }\n        sbrec_port_binding_set_options(op->sb, &options);\n\n        smap_destroy(&options);\n\n        const char *address_mode = smap_get(\n            &op->nbrp->ipv6_ra_configs, \"address_mode\");\n\n        if (!address_mode) {\n            continue;\n        }\n        if (strcmp(address_mode, \"slaac\") &&\n            strcmp(address_mode, \"dhcpv6_stateful\") &&\n            strcmp(address_mode, \"dhcpv6_stateless\")) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n            VLOG_WARN_RL(&rl, \"Invalid address mode [%s] defined\",\n                         address_mode);\n            continue;\n        }\n\n        if (smap_get_bool(&op->nbrp->ipv6_ra_configs, \"send_periodic\",\n                          false)) {\n            copy_ra_to_sb(op, address_mode);\n        }\n    }\n}\n\nstatic void\nbuild_port_group_lswitches(struct northd_input *input_data,\n                           struct hmap *pgs,\n                           struct hmap *ports)\n{\n    hmap_init(pgs);\n\n    const struct nbrec_port_group *nb_pg;\n    NBREC_PORT_GROUP_TABLE_FOR_EACH (nb_pg,\n                                  input_data->nbrec_port_group_table) {\n        struct ovn_port_group *pg = ovn_port_group_create(pgs, nb_pg);\n        for (size_t i = 0; i < nb_pg->n_ports; i++) {\n            struct ovn_port *op = ovn_port_find(ports, nb_pg->ports[i]->name);\n            if (!op) {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n                VLOG_ERR_RL(&rl, \"lport %s in port group %s not found.\",\n                            nb_pg->ports[i]->name,\n                            nb_pg->name);\n                continue;\n            }\n\n            if (!op->od->nbs) {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n                VLOG_WARN_RL(&rl, \"lport %s in port group %s has no lswitch.\",\n                             nb_pg->ports[i]->name,\n                             nb_pg->name);\n                continue;\n            }\n\n            struct ovn_port_group_ls *pg_ls =\n                ovn_port_group_ls_find(pg, &op->od->nbs->header_.uuid);\n            if (!pg_ls) {\n                pg_ls = ovn_port_group_ls_add(pg, op->od);\n                ovn_ls_port_group_add(&op->od->nb_pgs, nb_pg);\n            }\n            ovn_port_group_ls_add_port(pg_ls, op);\n        }\n    }\n}\n\n#define IPV6_CT_OMIT_MATCH \"nd || nd_ra || nd_rs || mldv1 || mldv2\"\n\nstatic void\nbuild_acls(struct ovn_datapath *od, const struct chassis_features *features,\n           struct hmap *lflows, const struct hmap *port_groups,\n           const struct shash *meter_groups)\n{\n    const char *default_acl_action = default_acl_drop ? debug_drop_action() :\n                                                        \"next;\";\n    bool has_stateful = od->has_stateful_acl || od->has_lb_vip;\n    const char *ct_blocked_match = features->ct_no_masked_label\n                                   ? \"ct_mark.blocked\"\n                                   : \"ct_label.blocked\";\n    struct ds match   = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    /* Ingress and Egress ACL Table (Priority 0): Packets are allowed by\n     * default.  If the logical switch has no ACLs or no load balancers,\n     * then add 65535-priority flow to advance the packet to next\n     * stage.\n     *\n     * A related rule at priority 1 is added below if there\n     * are any stateful ACLs in this datapath. */\n    if (!od->has_acls) {\n        if (!od->has_lb_vip) {\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, UINT16_MAX, \"1\",\n                          \"next;\");\n            ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, UINT16_MAX, \"1\",\n                          \"next;\");\n        } else {\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, 0, \"1\", \"next;\");\n            ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, 0, \"1\", \"next;\");\n        }\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL_AFTER_LB, 0, \"1\", \"next;\");\n    } else {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, 0, \"1\",\n                      default_acl_action);\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, 0, \"1\",\n                      default_acl_action);\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL_AFTER_LB, 0, \"1\",\n                      default_acl_action);\n    }\n\n\n    if (has_stateful) {\n        /* Ingress and Egress ACL Table (Priority 1).\n         *\n         * By default, traffic is allowed (if default_acl_drop is 'false') or\n         * dropped (if default_acl_drop is 'true').  This is partially\n         * handled by the Priority 0 ACL flows added earlier, but we also\n         * need to commit IP flows.  This is because, while the initiater's\n         * direction may not have any stateful rules, the server's may\n         * and then its return traffic would not have an associated\n         * conntrack entry and would return \"+invalid\".\n         *\n         * We use \"ct_commit\" for a connection that is not already known\n         * by the connection tracker.  Once a connection is committed,\n         * subsequent packets will hit the flow at priority 0 that just\n         * uses \"next;\"\n         *\n         * We also check for established connections that have ct_mark.blocked\n         * set on them.  That's a connection that was disallowed, but is\n         * now allowed by policy again since it hit this default-allow flow.\n         * We need to set ct_mark.blocked=0 to let the connection continue,\n         * which will be done by ct_commit() in the \"stateful\" stage.\n         * Subsequent packets will hit the flow at priority 0 that just\n         * uses \"next;\". */\n        ds_clear(&match);\n        ds_put_format(&match, \"ip && ct.est && %s == 1\", ct_blocked_match);\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, 1,\n                      ds_cstr(&match),\n                      REGBIT_CONNTRACK_COMMIT\" = 1; next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, 1,\n                      ds_cstr(&match),\n                      REGBIT_CONNTRACK_COMMIT\" = 1; next;\");\n\n        default_acl_action = default_acl_drop\n                             ? debug_drop_action()\n                             : REGBIT_CONNTRACK_COMMIT\" = 1; next;\";\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, 1, \"ip && !ct.est\",\n                      default_acl_action);\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, 1, \"ip && !ct.est\",\n                      default_acl_action);\n\n        /* Ingress and Egress ACL Table (Priority 65532).\n         *\n         * Always drop traffic that's in an invalid state.  Also drop\n         * reply direction packets for connections that have been marked\n         * for deletion (ct_mark.blocked is set).\n         *\n         * This is enforced at a higher priority than ACLs can be defined. */\n        ds_clear(&match);\n        ds_put_format(&match, \"%s(ct.est && ct.rpl && %s == 1)\",\n                      use_ct_inv_match ? \"ct.inv || \" : \"\",\n                      ct_blocked_match);\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match), debug_drop_action());\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match),  debug_drop_action());\n\n        /* Ingress and Egress ACL Table (Priority 65535 - 3).\n         *\n         * Allow reply traffic that is part of an established\n         * conntrack entry that has not been marked for deletion\n         * (ct_mark.blocked).  We only match traffic in the\n         * reply direction because we want traffic in the request\n         * direction to hit the currently defined policy from ACLs.\n         *\n         * This is enforced at a higher priority than ACLs can be defined. */\n        ds_clear(&match);\n        ds_put_format(&match, \"ct.est && !ct.rel && !ct.new%s && \"\n                      \"ct.rpl && %s == 0\",\n                      use_ct_inv_match ? \" && !ct.inv\" : \"\",\n                      ct_blocked_match);\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match), REGBIT_ACL_HINT_DROP\" = 0; \"\n                      REGBIT_ACL_HINT_BLOCK\" = 0; \"\n                      REGBIT_ACL_HINT_ALLOW_REL\" = 1; next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match), \"next;\");\n\n        /* Ingress and Egress ACL Table (Priority 65535).\n         *\n         * Allow traffic that is related to an existing conntrack entry that\n         * has not been marked for deletion (ct_mark.blocked). At the same\n         * time apply NAT on this traffic.\n         *\n         * This is enforced at a higher priority than ACLs can be defined.\n         *\n         * NOTE: This does not support related data sessions (eg,\n         * a dynamically negotiated FTP data channel), but will allow\n         * related traffic such as an ICMP Port Unreachable through\n         * that's generated from a non-listening UDP port.  */\n        const char *ct_in_acl_action =\n            features->ct_lb_related\n            ? REGBIT_ACL_HINT_ALLOW_REL\" = 1; ct_commit_nat;\"\n            : REGBIT_ACL_HINT_ALLOW_REL\" = 1; next;\";\n        const char *ct_out_acl_action = features->ct_lb_related\n                                        ? \"ct_commit_nat;\"\n                                        : \"next;\";\n        ds_clear(&match);\n        ds_put_format(&match, \"!ct.est && ct.rel && !ct.new%s && %s == 0\",\n                      use_ct_inv_match ? \" && !ct.inv\" : \"\",\n                      ct_blocked_match);\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match), ct_in_acl_action);\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, UINT16_MAX - 3,\n                      ds_cstr(&match), ct_out_acl_action);\n\n        /* Reply and related traffic matched by an \"allow-related\" ACL\n         * should be allowed in the ls_in_acl_after_lb stage too. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL_AFTER_LB, UINT16_MAX - 3,\n                      REGBIT_ACL_HINT_ALLOW_REL\" == 1\", \"next;\");\n    }\n\n    /* Ingress and Egress ACL Table (Priority 65532).\n     *\n     * Always allow service IPv6 protocols regardless of other ACLs defined.\n     *\n     * Also, don't send them to conntrack because session tracking\n     * for these protocols is not working properly:\n     * https://bugzilla.kernel.org/show_bug.cgi?id=11797. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, UINT16_MAX - 3,\n                  IPV6_CT_OMIT_MATCH, \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, UINT16_MAX - 3,\n                  IPV6_CT_OMIT_MATCH, \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL_AFTER_LB, UINT16_MAX - 3,\n                  IPV6_CT_OMIT_MATCH, \"next;\");\n\n    /* Ingress or Egress ACL Table (Various priorities). */\n    for (size_t i = 0; i < od->nbs->n_acls; i++) {\n        struct nbrec_acl *acl = od->nbs->acls[i];\n        consider_acl(lflows, od, acl, has_stateful,\n                     features->ct_no_masked_label,\n                     meter_groups, &match, &actions);\n    }\n    struct ovn_port_group *pg;\n    HMAP_FOR_EACH (pg, key_node, port_groups) {\n        if (ovn_port_group_ls_find(pg, &od->nbs->header_.uuid)) {\n            for (size_t i = 0; i < pg->nb_pg->n_acls; i++) {\n                consider_acl(lflows, od, pg->nb_pg->acls[i], has_stateful,\n                             features->ct_no_masked_label,\n                             meter_groups, &match, &actions);\n            }\n        }\n    }\n\n    /* Add 34000 priority flow to allow DHCP reply from ovn-controller to all\n     * logical ports of the datapath if the CMS has configured DHCPv4 options.\n     * */\n    for (size_t i = 0; i < od->nbs->n_ports; i++) {\n        if (lsp_is_external(od->nbs->ports[i])) {\n            continue;\n        }\n\n        if (od->nbs->ports[i]->dhcpv4_options) {\n            const char *server_id = smap_get(\n                &od->nbs->ports[i]->dhcpv4_options->options, \"server_id\");\n            const char *server_mac = smap_get(\n                &od->nbs->ports[i]->dhcpv4_options->options, \"server_mac\");\n            const char *lease_time = smap_get(\n                &od->nbs->ports[i]->dhcpv4_options->options, \"lease_time\");\n            if (server_id && server_mac && lease_time) {\n                const char *dhcp_actions =\n                    has_stateful ? \"ct_commit; next;\" : \"next;\";\n                ds_clear(&match);\n                ds_put_format(&match, \"outport == \\\"%s\\\" && eth.src == %s \"\n                              \"&& ip4.src == %s && udp && udp.src == 67 \"\n                              \"&& udp.dst == 68\", od->nbs->ports[i]->name,\n                              server_mac, server_id);\n                ovn_lflow_add_with_lport_and_hint(\n                    lflows, od, S_SWITCH_OUT_ACL, 34000, ds_cstr(&match),\n                    dhcp_actions, od->nbs->ports[i]->name,\n                    &od->nbs->ports[i]->dhcpv4_options->header_);\n            }\n        }\n\n        if (od->nbs->ports[i]->dhcpv6_options) {\n            const char *server_mac = smap_get(\n                &od->nbs->ports[i]->dhcpv6_options->options, \"server_id\");\n            struct eth_addr ea;\n            if (server_mac && eth_addr_from_string(server_mac, &ea)) {\n                /* Get the link local IP of the DHCPv6 server from the\n                 * server MAC. */\n                struct in6_addr lla;\n                in6_generate_lla(ea, &lla);\n\n                char server_ip[INET6_ADDRSTRLEN + 1];\n                ipv6_string_mapped(server_ip, &lla);\n\n                const char *dhcp6_actions = has_stateful ? \"ct_commit; next;\" :\n                    \"next;\";\n                ds_clear(&match);\n                ds_put_format(&match, \"outport == \\\"%s\\\" && eth.src == %s \"\n                              \"&& ip6.src == %s && udp && udp.src == 547 \"\n                              \"&& udp.dst == 546\", od->nbs->ports[i]->name,\n                              server_mac, server_ip);\n                ovn_lflow_add_with_lport_and_hint(\n                    lflows, od, S_SWITCH_OUT_ACL, 34000, ds_cstr(&match),\n                    dhcp6_actions, od->nbs->ports[i]->name,\n                    &od->nbs->ports[i]->dhcpv6_options->header_);\n            }\n        }\n    }\n\n    /* Add a 34000 priority flow to advance the DNS reply from ovn-controller,\n     * if the CMS has configured DNS records for the datapath.\n     */\n    if (ls_has_dns_records(od->nbs)) {\n        const char *dns_actions = has_stateful ? \"ct_commit; next;\" : \"next;\";\n        ovn_lflow_add(\n            lflows, od, S_SWITCH_OUT_ACL, 34000, \"udp.src == 53\",\n            dns_actions);\n    }\n\n    if (od->has_acls || od->has_lb_vip) {\n        /* Add a 34000 priority flow to advance the service monitor reply\n        * packets to skip applying ingress ACLs. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ACL, 34000,\n                    \"eth.dst == $svc_monitor_mac\", \"next;\");\n\n        /* Add a 34000 priority flow to advance the service monitor packets\n        * generated by ovn-controller to skip applying egress ACLs. */\n        ovn_lflow_add(lflows, od, S_SWITCH_OUT_ACL, 34000,\n                    \"eth.src == $svc_monitor_mac\", \"next;\");\n    }\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_qos(struct ovn_datapath *od, struct hmap *lflows) {\n    struct ds action = DS_EMPTY_INITIALIZER;\n\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_QOS_MARK, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_QOS_MARK, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_QOS_METER, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_QOS_METER, 0, \"1\", \"next;\");\n\n    for (size_t i = 0; i < od->nbs->n_qos_rules; i++) {\n        struct nbrec_qos *qos = od->nbs->qos_rules[i];\n        bool ingress = !strcmp(qos->direction, \"from-lport\") ? true :false;\n        enum ovn_stage stage = ingress ? S_SWITCH_IN_QOS_MARK : S_SWITCH_OUT_QOS_MARK;\n        int64_t rate = 0;\n        int64_t burst = 0;\n\n        for (size_t j = 0; j < qos->n_action; j++) {\n            if (!strcmp(qos->key_action[j], \"dscp\")) {\n                ds_clear(&action);\n                ds_put_format(&action, \"ip.dscp = %\"PRId64\"; next;\",\n                              qos->value_action[j]);\n                ovn_lflow_add_with_hint(lflows, od, stage,\n                                        qos->priority,\n                                        qos->match, ds_cstr(&action),\n                                        &qos->header_);\n            }\n        }\n\n        for (size_t n = 0; n < qos->n_bandwidth; n++) {\n            if (!strcmp(qos->key_bandwidth[n], \"rate\")) {\n                rate = qos->value_bandwidth[n];\n            } else if (!strcmp(qos->key_bandwidth[n], \"burst\")) {\n                burst = qos->value_bandwidth[n];\n            }\n        }\n        if (rate) {\n            stage = ingress ? S_SWITCH_IN_QOS_METER : S_SWITCH_OUT_QOS_METER;\n            ds_clear(&action);\n            if (burst) {\n                ds_put_format(&action,\n                              \"set_meter(%\"PRId64\", %\"PRId64\"); next;\",\n                              rate, burst);\n            } else {\n                ds_put_format(&action,\n                              \"set_meter(%\"PRId64\"); next;\",\n                              rate);\n            }\n\n            /* Ingress and Egress QoS Meter Table.\n             *\n             * We limit the bandwidth of this flow by adding a meter table.\n             */\n            ovn_lflow_add_with_hint(lflows, od, stage,\n                                    qos->priority,\n                                    qos->match, ds_cstr(&action),\n                                    &qos->header_);\n        }\n    }\n    ds_destroy(&action);\n}\n\nstatic void\nbuild_lb_rules_pre_stateful(struct hmap *lflows, struct ovn_northd_lb *lb,\n                            bool ct_lb_mark, struct ds *match,\n                            struct ds *action)\n{\n    if (!lb->n_nb_ls) {\n        return;\n    }\n\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n        ds_clear(action);\n        ds_clear(match);\n        const char *ip_match = NULL;\n\n        /* Store the original destination IP to be used when generating\n         * hairpin flows.\n         */\n        if (lb->vips[i].address_family == AF_INET) {\n            ip_match = \"ip4\";\n            ds_put_format(action, REG_ORIG_DIP_IPV4 \" = %s; \",\n                          lb_vip->vip_str);\n        } else {\n            ip_match = \"ip6\";\n            ds_put_format(action, REG_ORIG_DIP_IPV6 \" = %s; \",\n                          lb_vip->vip_str);\n        }\n\n        const char *proto = NULL;\n        if (lb_vip->port_str) {\n            proto = \"tcp\";\n            if (lb->nlb->protocol) {\n                if (!strcmp(lb->nlb->protocol, \"udp\")) {\n                    proto = \"udp\";\n                } else if (!strcmp(lb->nlb->protocol, \"sctp\")) {\n                    proto = \"sctp\";\n                }\n            }\n\n            /* Store the original destination port to be used when generating\n             * hairpin flows.\n             */\n            ds_put_format(action, REG_ORIG_TP_DPORT \" = %s; \",\n                          lb_vip->port_str);\n        }\n        ds_put_format(action, \"%s;\", ct_lb_mark ? \"ct_lb_mark\" : \"ct_lb\");\n\n        ds_put_format(match, REGBIT_CONNTRACK_NAT\" == 1 && %s.dst == %s\",\n                      ip_match, lb_vip->vip_str);\n        if (lb_vip->port_str) {\n            ds_put_format(match, \" && %s.dst == %s\", proto, lb_vip->port_str);\n        }\n\n        ovn_lflow_add_with_dp_group(\n            lflows, lb->nb_ls_map, S_SWITCH_IN_PRE_STATEFUL, 120,\n            ds_cstr(match), ds_cstr(action), &lb->nlb->header_);\n    }\n}\n\n/* Builds the logical router flows related to load balancer affinity.\n * For a LB configured with 'vip=V:VP' and backends 'B1:BP1,B2:BP2' and\n * affinity timeout set to T, it generates the following logical flows:\n * - load balancing affinity check:\n *   table=lr_in_lb_aff_check, priority=100\n *      match=(new_lb_match)\n *      action=(REG_NEXT_HOP_IPV4 = ip4.dst;\n *              REG_ORIG_TP_DPORT_ROUTER = tcp.dst;\n *              REGBIT_KNOWN_LB_SESSION = chk_lb_aff(); next;)\n *\n * - load balancing:\n *   table=lr_in_dnat, priority=150\n *      match=(REGBIT_KNOWN_LB_SESSION == 1 && ct.new && ip4\n *             && REG_LB_AFF_BACKEND_IP4 == B1 && REG_LB_AFF_MATCH_PORT == BP1)\n *      action=(REG_NEXT_HOP_IPV4 = V; lb_action;\n *              ct_lb_mark(backends=B1:BP1; ct_flag);)\n *   table=lr_in_dnat, priority=150\n *      match=(REGBIT_KNOWN_LB_SESSION == 1 && ct.new && ip4\n *             && REG_LB_AFF_BACKEND_IP4 == B2 && REG_LB_AFF_MATCH_PORT == BP2)\n *      action=(REG_NEXT_HOP_IPV4 = V; lb_action;\n *              ct_lb_mark(backends=B2:BP2; ct_flag);)\n *\n * - load balancing affinity learn:\n *   table=lr_in_lb_aff_learn, priority=100\n *      match=(REGBIT_KNOWN_LB_SESSION == 0\n *             && ct.new && ip4\n *             && REG_NEXT_HOP_IPV4 == V && REG_ORIG_TP_DPORT_ROUTER = VP\n *             && ip4.dst == B1 && tcp.dst == BP1)\n *      action=(commit_lb_aff(vip = \"V:VP\", backend = \"B1:BP1\",\n *                            proto = tcp, timeout = T));\n *   table=lr_in_lb_aff_learn, priority=100\n *      match=(REGBIT_KNOWN_LB_SESSION == 0\n *             && ct.new && ip4\n *             && REG_NEXT_HOP_IPV4 == V && REG_ORIG_TP_DPORT_ROUTER = VP\n *             && ip4.dst == B2 && tcp.dst == BP2)\n *      action=(commit_lb_aff(vip = \"V:VP\", backend = \"B2:BP2\",\n *                            proto = tcp, timeout = T));\n *\n */\nstatic void\nbuild_lb_affinity_lr_flows(struct hmap *lflows, struct ovn_northd_lb *lb,\n                           struct ovn_lb_vip *lb_vip, char *new_lb_match,\n                           char *lb_action, const unsigned long *dp_bitmap)\n{\n    if (!lb->affinity_timeout ||\n        bitmap_is_all_zeros(dp_bitmap, n_datapaths)) {\n        return;\n    }\n\n    struct ds aff_action = DS_EMPTY_INITIALIZER;\n    struct ds aff_action_learn = DS_EMPTY_INITIALIZER;\n    struct ds aff_match = DS_EMPTY_INITIALIZER;\n    struct ds aff_match_learn = DS_EMPTY_INITIALIZER;\n    struct ds aff_check_action = DS_EMPTY_INITIALIZER;\n\n    bool ipv6 = !IN6_IS_ADDR_V4MAPPED(&lb_vip->vip);\n    const char *ip_match = ipv6 ? \"ip6\" : \"ip4\";\n\n    const char *reg_vip = ipv6 ? REG_NEXT_HOP_IPV6 : REG_NEXT_HOP_IPV4;\n    const char *reg_backend =\n        ipv6 ? REG_LB_L3_AFF_BACKEND_IP6 : REG_LB_AFF_BACKEND_IP4;\n    const char *ct_flag = NULL;\n    if (lb_action && !strcmp(lb_action, \"flags.skip_snat_for_lb = 1; \")) {\n        ct_flag = \"; skip_snat\";\n    } else if (lb_action &&\n               !strcmp(lb_action, \"flags.force_snat_for_lb = 1; \")) {\n        ct_flag = \"; force_snat\";\n    }\n\n    /* Create affinity check flow. */\n    ds_put_format(&aff_check_action, \"%s = %s.dst; \", reg_vip, ip_match);\n\n    if (lb_vip->port_str) {\n        ds_put_format(&aff_check_action, REG_ORIG_TP_DPORT_ROUTER\" = %s.dst; \",\n                      lb->proto);\n    }\n    ds_put_cstr(&aff_check_action, REGBIT_KNOWN_LB_SESSION\n                \" = chk_lb_aff(); next;\");\n\n    ovn_lflow_add_with_dp_group(\n        lflows, dp_bitmap, S_ROUTER_IN_LB_AFF_CHECK, 100,\n        new_lb_match, ds_cstr(&aff_check_action), &lb->nlb->header_);\n\n    /* Prepare common part of affinity LB and affinity learn action. */\n    ds_put_format(&aff_action, \"%s = %s; \", reg_vip, lb_vip->vip_str);\n    ds_put_cstr(&aff_action_learn, \"commit_lb_aff(vip = \\\"\");\n\n    if (lb_vip->port_str) {\n        ds_put_format(&aff_action_learn, ipv6 ? \"[%s]:%s\" : \"%s:%s\",\n                      lb_vip->vip_str, lb_vip->port_str);\n    } else {\n        ds_put_cstr(&aff_action_learn, lb_vip->vip_str);\n    }\n\n    if (lb_action) {\n        ds_put_cstr(&aff_action, lb_action);\n    }\n    ds_put_cstr(&aff_action, \"ct_lb_mark(backends=\");\n    ds_put_cstr(&aff_action_learn, \"\\\", backend = \\\"\");\n\n    /* Prepare common part of affinity learn match. */\n    if (lb_vip->port_str) {\n        ds_put_format(&aff_match_learn, REGBIT_KNOWN_LB_SESSION\" == 0 && \"\n                      \"ct.new && %s && %s == %s && \"\n                      REG_ORIG_TP_DPORT_ROUTER\" == %s && \"\n                      \"%s.dst == \", ip_match, reg_vip, lb_vip->vip_str,\n                      lb_vip->port_str, ip_match);\n    } else {\n        ds_put_format(&aff_match_learn, REGBIT_KNOWN_LB_SESSION\" == 0 && \"\n                      \"ct.new && %s && %s == %s && %s.dst == \", ip_match,\n                      reg_vip, lb_vip->vip_str, ip_match);\n    }\n\n    /* Prepare common part of affinity match. */\n    ds_put_format(&aff_match, REGBIT_KNOWN_LB_SESSION\" == 1 && \"\n                  \"ct.new && %s && %s == \", ip_match, reg_backend);\n\n    /* Store the common part length. */\n    size_t aff_action_len = aff_action.length;\n    size_t aff_action_learn_len = aff_action_learn.length;\n    size_t aff_match_len = aff_match.length;\n    size_t aff_match_learn_len = aff_match_learn.length;\n\n\n    for (size_t i = 0; i < lb_vip->n_backends; i++) {\n        struct ovn_lb_backend *backend = &lb_vip->backends[i];\n\n        ds_put_cstr(&aff_match_learn, backend->ip_str);\n        ds_put_cstr(&aff_match, backend->ip_str);\n\n        if (backend->port) {\n            ds_put_format(&aff_action, ipv6 ? \"[%s]:%d\" : \"%s:%d\",\n                          backend->ip_str, backend->port);\n            ds_put_format(&aff_action_learn, ipv6 ? \"[%s]:%d\" : \"%s:%d\",\n                          backend->ip_str, backend->port);\n\n            ds_put_format(&aff_match_learn, \" && %s.dst == %d\",\n                          lb->proto, backend->port);\n            ds_put_format(&aff_match, \" && \"REG_LB_AFF_MATCH_PORT\" == %d\",\n                          backend->port);\n        } else {\n            ds_put_cstr(&aff_action, backend->ip_str);\n            ds_put_cstr(&aff_action_learn, backend->ip_str);\n        }\n\n        if (ct_flag) {\n            ds_put_cstr(&aff_action, ct_flag);\n        }\n\n        ds_put_cstr(&aff_action, \");\");\n        ds_put_char(&aff_action_learn, '\"');\n\n        if (lb_vip->port_str) {\n            ds_put_format(&aff_action_learn, \", proto = %s\", lb->proto);\n        }\n\n        ds_put_format(&aff_action_learn, \", timeout = %d); /* drop */\",\n                      lb->affinity_timeout);\n\n        /* Forward to OFTABLE_CHK_LB_AFFINITY table to store flow tuple. */\n        ovn_lflow_add_with_dp_group(\n            lflows, dp_bitmap, S_ROUTER_IN_LB_AFF_LEARN, 100,\n            ds_cstr(&aff_match_learn), ds_cstr(&aff_action_learn),\n            &lb->nlb->header_);\n\n        /* Use already selected backend within affinity timeslot. */\n        ovn_lflow_add_with_dp_group(\n            lflows, dp_bitmap, S_ROUTER_IN_DNAT, 150,\n            ds_cstr(&aff_match), ds_cstr(&aff_action), &lb->nlb->header_);\n\n        ds_truncate(&aff_action, aff_action_len);\n        ds_truncate(&aff_action_learn, aff_action_learn_len);\n        ds_truncate(&aff_match, aff_match_len);\n        ds_truncate(&aff_match_learn, aff_match_learn_len);\n    }\n\n    ds_destroy(&aff_action);\n    ds_destroy(&aff_action_learn);\n    ds_destroy(&aff_match);\n    ds_destroy(&aff_match_learn);\n    ds_destroy(&aff_check_action);\n}\n\n/* Builds the logical switch flows related to load balancer affinity.\n * For a LB configured with 'vip=V:VP' and backends 'B1:BP1,B2:BP2' and\n * affinity timeout set to T, it generates the following logical flows:\n * - load balancing affinity check:\n *   table=ls_in_lb_aff_check, priority=100\n *      match=(ct.new && ip4\n *             && REG_ORIG_DIP_IPV4 == V && REG_ORIG_TP_DPORT == VP)\n *      action=(REGBIT_KNOWN_LB_SESSION = chk_lb_aff(); next;)\n *\n * - load balancing:\n *   table=ls_in_lb, priority=150\n *      match=(REGBIT_KNOWN_LB_SESSION == 1 && ct.new && ip4\n *             && REG_LB_AFF_BACKEND_IP4 == B1 && REG_LB_AFF_MATCH_PORT == BP1)\n *      action=(REGBIT_CONNTRACK_COMMIT = 0;\n *              REG_ORIG_DIP_IPV4 = V; REG_ORIG_TP_DPORT = VP;\n *              ct_lb_mark(backends=B1:BP1);)\n *   table=ls_in_lb, priority=150\n *      match=(REGBIT_KNOWN_LB_SESSION == 1 && ct.new && ip4\n *             && REG_LB_AFF_BACKEND_IP4 == B2 && REG_LB_AFF_MATCH_PORT == BP2)\n *      action=(REGBIT_CONNTRACK_COMMIT = 0;\n *              REG_ORIG_DIP_IPV4 = V;\n *              REG_ORIG_TP_DPORT = VP;\n *              ct_lb_mark(backends=B1:BP2);)\n *\n * - load balancing affinity learn:\n *   table=ls_in_lb_aff_learn, priority=100\n *      match=(REGBIT_KNOWN_LB_SESSION == 0\n *             && ct.new && ip4\n *             && REG_ORIG_DIP_IPV4 == V && REG_ORIG_TP_DPORT == VP\n *             && ip4.dst == B1 && tcp.dst == BP1)\n *      action=(commit_lb_aff(vip = \"V:VP\", backend = \"B1:BP1\",\n *                            proto = tcp, timeout = T));\n *   table=ls_in_lb_aff_learn, priority=100\n *      match=(REGBIT_KNOWN_LB_SESSION == 0\n *             && ct.new && ip4\n *             && REG_ORIG_DIP_IPV4 == V && REG_ORIG_TP_DPORT == VP\n *             && ip4.dst == B2 && tcp.dst == BP2)\n *      action=(commit_lb_aff(vip = \"V:VP\", backend = \"B2:BP2\",\n *                            proto = tcp, timeout = T));\n *\n */\nstatic void\nbuild_lb_affinity_ls_flows(struct hmap *lflows, struct ovn_northd_lb *lb,\n                           struct ovn_lb_vip *lb_vip)\n{\n    if (!lb->affinity_timeout || !lb->n_nb_ls) {\n        return;\n    }\n\n    struct ds new_lb_match = DS_EMPTY_INITIALIZER;\n    if (IN6_IS_ADDR_V4MAPPED(&lb_vip->vip)) {\n        ds_put_format(&new_lb_match,\n                      \"ct.new && ip4 && \"REG_ORIG_DIP_IPV4 \" == %s\",\n                      lb_vip->vip_str);\n    } else {\n        ds_put_format(&new_lb_match,\n                      \"ct.new && ip6 && \"REG_ORIG_DIP_IPV6 \" == %s\",\n                      lb_vip->vip_str);\n    }\n\n    if (lb_vip->port_str) {\n        ds_put_format(&new_lb_match, \" && \"REG_ORIG_TP_DPORT \" == %s\",\n                      lb_vip->port_str);\n    }\n\n    static char *aff_check = REGBIT_KNOWN_LB_SESSION\" = chk_lb_aff(); next;\";\n\n    ovn_lflow_add_with_dp_group(\n        lflows, lb->nb_ls_map, S_SWITCH_IN_LB_AFF_CHECK, 100,\n        ds_cstr(&new_lb_match), aff_check, &lb->nlb->header_);\n    ds_destroy(&new_lb_match);\n\n    struct ds aff_action = DS_EMPTY_INITIALIZER;\n    struct ds aff_action_learn = DS_EMPTY_INITIALIZER;\n    struct ds aff_match = DS_EMPTY_INITIALIZER;\n    struct ds aff_match_learn = DS_EMPTY_INITIALIZER;\n\n    bool ipv6 = !IN6_IS_ADDR_V4MAPPED(&lb_vip->vip);\n    const char *ip_match = ipv6 ? \"ip6\" : \"ip4\";\n\n    const char *reg_vip = ipv6 ? REG_ORIG_DIP_IPV6 : REG_ORIG_DIP_IPV4;\n    const char *reg_backend =\n        ipv6 ? REG_LB_L2_AFF_BACKEND_IP6 : REG_LB_AFF_BACKEND_IP4;\n\n    /* Prepare common part of affinity LB and affinity learn action. */\n    ds_put_format(&aff_action, REGBIT_CONNTRACK_COMMIT\" = 0; %s = %s; \",\n                  reg_vip, lb_vip->vip_str);\n    ds_put_cstr(&aff_action_learn, \"commit_lb_aff(vip = \\\"\");\n\n    if (lb_vip->port_str) {\n        ds_put_format(&aff_action, REG_ORIG_TP_DPORT\" = %s; \",\n                      lb_vip->port_str);\n        ds_put_format(&aff_action_learn, ipv6 ? \"[%s]:%s\" : \"%s:%s\",\n                      lb_vip->vip_str, lb_vip->port_str);\n    } else {\n        ds_put_cstr(&aff_action_learn, lb_vip->vip_str);\n    }\n\n    ds_put_cstr(&aff_action, \"ct_lb_mark(backends=\");\n    ds_put_cstr(&aff_action_learn, \"\\\", backend = \\\"\");\n\n    /* Prepare common part of affinity learn match. */\n    if (lb_vip->port_str) {\n        ds_put_format(&aff_match_learn, REGBIT_KNOWN_LB_SESSION\" == 0 && \"\n                      \"ct.new && %s && %s == %s && \"\n                      REG_ORIG_TP_DPORT\" == %s && %s.dst == \",\n                      ip_match, reg_vip, lb_vip->vip_str,\n                      lb_vip->port_str, ip_match);\n    } else {\n        ds_put_format(&aff_match_learn, REGBIT_KNOWN_LB_SESSION\" == 0 && \"\n                      \"ct.new && %s && %s == %s && %s.dst == \",\n                      ip_match, reg_vip, lb_vip->vip_str, ip_match);\n    }\n\n    /* Prepare common part of affinity match. */\n    ds_put_format(&aff_match, REGBIT_KNOWN_LB_SESSION\" == 1 && \"\n                  \"ct.new && %s && %s == \", ip_match, reg_backend);\n\n    /* Store the common part length. */\n    size_t aff_action_len = aff_action.length;\n    size_t aff_action_learn_len = aff_action_learn.length;\n    size_t aff_match_len = aff_match.length;\n    size_t aff_match_learn_len = aff_match_learn.length;\n\n    for (size_t i = 0; i < lb_vip->n_backends; i++) {\n        struct ovn_lb_backend *backend = &lb_vip->backends[i];\n\n        ds_put_cstr(&aff_match_learn, backend->ip_str);\n        ds_put_cstr(&aff_match, backend->ip_str);\n\n        if (backend->port) {\n            ds_put_format(&aff_action, ipv6 ? \"[%s]:%d\" : \"%s:%d\",\n                          backend->ip_str, backend->port);\n            ds_put_format(&aff_action_learn, ipv6 ? \"[%s]:%d\" : \"%s:%d\",\n                          backend->ip_str, backend->port);\n\n            ds_put_format(&aff_match_learn, \" && %s.dst == %d\",\n                          lb->proto, backend->port);\n            ds_put_format(&aff_match, \" && \"REG_LB_AFF_MATCH_PORT\" == %d\",\n                          backend->port);\n        } else {\n            ds_put_cstr(&aff_action, backend->ip_str);\n            ds_put_cstr(&aff_action_learn, backend->ip_str);\n        }\n\n        ds_put_cstr(&aff_action, \");\");\n        ds_put_char(&aff_action_learn, '\"');\n\n        if (lb_vip->port_str) {\n            ds_put_format(&aff_action_learn, \", proto = %s\", lb->proto);\n        }\n\n        ds_put_format(&aff_action_learn, \", timeout = %d); /* drop */\",\n                      lb->affinity_timeout);\n\n        /* Forward to OFTABLE_CHK_LB_AFFINITY table to store flow tuple. */\n        ovn_lflow_add_with_dp_group(\n            lflows, lb->nb_ls_map, S_SWITCH_IN_LB_AFF_LEARN, 100,\n            ds_cstr(&aff_match_learn), ds_cstr(&aff_action_learn),\n            &lb->nlb->header_);\n\n        /* Use already selected backend within affinity timeslot. */\n        ovn_lflow_add_with_dp_group(\n            lflows, lb->nb_ls_map, S_SWITCH_IN_LB, 150,\n            ds_cstr(&aff_match), ds_cstr(&aff_action), &lb->nlb->header_);\n\n        ds_truncate(&aff_action, aff_action_len);\n        ds_truncate(&aff_action_learn, aff_action_learn_len);\n        ds_truncate(&aff_match, aff_match_len);\n        ds_truncate(&aff_match_learn, aff_match_learn_len);\n    }\n\n    ds_destroy(&aff_action);\n    ds_destroy(&aff_action_learn);\n    ds_destroy(&aff_match);\n    ds_destroy(&aff_match_learn);\n}\n\nstatic void\nbuild_lb_affinity_default_flows(struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (od->nbs) {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_LB_AFF_CHECK, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_LB_AFF_LEARN, 0, \"1\", \"next;\");\n    }\n    if (od->nbr) {\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LB_AFF_CHECK, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LB_AFF_LEARN, 0, \"1\", \"next;\");\n    }\n}\n\nstatic void\nbuild_lb_rules(struct hmap *lflows, struct ovn_northd_lb *lb,\n               const struct chassis_features *features, struct ds *match,\n               struct ds *action, const struct shash *meter_groups)\n{\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n        struct ovn_northd_lb_vip *lb_vip_nb = &lb->vips_nb[i];\n        const char *ip_match = NULL;\n        if (lb_vip->address_family == AF_INET) {\n            ip_match = \"ip4\";\n        } else {\n            ip_match = \"ip6\";\n        }\n\n        ds_clear(action);\n        ds_clear(match);\n\n        /* Make sure that we clear the REGBIT_CONNTRACK_COMMIT flag.  Otherwise\n         * the load balanced packet will be committed again in\n         * S_SWITCH_IN_STATEFUL. */\n        ds_put_format(action, REGBIT_CONNTRACK_COMMIT\" = 0; \");\n\n        /* New connections in Ingress table. */\n        const char *meter = NULL;\n        bool reject = build_lb_vip_actions(lb_vip, lb_vip_nb, action,\n                                           lb->selection_fields, NULL,\n                                           NULL, true, features);\n\n        ds_put_format(match, \"ct.new && %s.dst == %s\", ip_match,\n                      lb_vip->vip_str);\n        int priority = 110;\n        if (lb_vip->port_str) {\n            ds_put_format(match, \" && %s.dst == %s\", lb->proto,\n                          lb_vip->port_str);\n            priority = 120;\n        }\n\n        build_lb_affinity_ls_flows(lflows, lb, lb_vip);\n\n        unsigned long *dp_non_meter = NULL;\n        bool build_non_meter = false;\n        if (reject) {\n            size_t index;\n\n            dp_non_meter = bitmap_clone(lb->nb_ls_map, n_datapaths);\n            BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_ls_map) {\n                struct ovn_datapath *od = datapaths_array[index];\n\n                meter = copp_meter_get(COPP_REJECT, od->nbs->copp,\n                                       meter_groups);\n                if (!meter) {\n                    build_non_meter = true;\n                    continue;\n                }\n                bitmap_set0(dp_non_meter, index);\n                ovn_lflow_add_with_hint__(\n                        lflows, od, S_SWITCH_IN_LB, priority,\n                        ds_cstr(match), ds_cstr(action),\n                        NULL, meter, &lb->nlb->header_);\n            }\n        }\n        if (!reject || build_non_meter) {\n            ovn_lflow_add_with_dp_group(\n                lflows, dp_non_meter ? dp_non_meter : lb->nb_ls_map,\n                S_SWITCH_IN_LB, priority,\n                ds_cstr(match), ds_cstr(action), &lb->nlb->header_);\n        }\n        bitmap_free(dp_non_meter);\n    }\n}\n\nstatic void\nbuild_stateful(struct ovn_datapath *od,\n               const struct chassis_features *features,\n               struct hmap *lflows)\n{\n    const char *ct_block_action = features->ct_no_masked_label\n                                  ? \"ct_mark.blocked\"\n                                  : \"ct_label.blocked\";\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    /* Ingress LB, Ingress and Egress stateful Table (Priority 0): Packets are\n     * allowed by default. */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_LB, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_STATEFUL, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_STATEFUL, 0, \"1\", \"next;\");\n\n    /* If REGBIT_CONNTRACK_COMMIT is set as 1 and\n     * REGBIT_CONNTRACK_SET_LABEL is set to 1, then the packets should be\n     * committed to conntrack.\n     * We always set ct_mark.blocked to 0 here as\n     * any packet that makes it this far is part of a connection we\n     * want to allow to continue. */\n    ds_put_format(&actions, \"ct_commit { %s = 0; \"\n                            \"ct_label.label = \" REG_LABEL \"; }; next;\",\n                  ct_block_action);\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_STATEFUL, 100,\n                  REGBIT_CONNTRACK_COMMIT\" == 1 && \"\n                  REGBIT_ACL_LABEL\" == 1\",\n                  ds_cstr(&actions));\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_STATEFUL, 100,\n                  REGBIT_CONNTRACK_COMMIT\" == 1 && \"\n                  REGBIT_ACL_LABEL\" == 1\",\n                  ds_cstr(&actions));\n\n    /* If REGBIT_CONNTRACK_COMMIT is set as 1, then the packets should be\n     * committed to conntrack. We always set ct_mark.blocked to 0 here as\n     * any packet that makes it this far is part of a connection we\n     * want to allow to continue. */\n    ds_clear(&actions);\n    ds_put_format(&actions, \"ct_commit { %s = 0; }; next;\", ct_block_action);\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_STATEFUL, 100,\n                  REGBIT_CONNTRACK_COMMIT\" == 1 && \"\n                  REGBIT_ACL_LABEL\" == 0\",\n                  ds_cstr(&actions));\n    ovn_lflow_add(lflows, od, S_SWITCH_OUT_STATEFUL, 100,\n                  REGBIT_CONNTRACK_COMMIT\" == 1 && \"\n                  REGBIT_ACL_LABEL\" == 0\",\n                  ds_cstr(&actions));\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_lb_hairpin(struct ovn_datapath *od, struct hmap *lflows)\n{\n    /* Ingress Pre-Hairpin/Nat-Hairpin/Hairpin tabled (Priority 0).\n     * Packets that don't need hairpinning should continue processing.\n     */\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_PRE_HAIRPIN, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_NAT_HAIRPIN, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_HAIRPIN, 0, \"1\", \"next;\");\n\n    if (od->has_lb_vip) {\n        /* Check if the packet needs to be hairpinned.\n         * Set REGBIT_HAIRPIN in the original direction and\n         * REGBIT_HAIRPIN_REPLY in the reply direction.\n         */\n        ovn_lflow_add_with_hint(\n            lflows, od, S_SWITCH_IN_PRE_HAIRPIN, 100, \"ip && ct.trk\",\n            REGBIT_HAIRPIN \" = chk_lb_hairpin(); \"\n            REGBIT_HAIRPIN_REPLY \" = chk_lb_hairpin_reply(); \"\n            \"next;\",\n            &od->nbs->header_);\n\n        /* If packet needs to be hairpinned, snat the src ip with the VIP\n         * for new sessions. */\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_NAT_HAIRPIN, 100,\n                                \"ip && ct.new && ct.trk\"\n                                \" && \"REGBIT_HAIRPIN \" == 1\",\n                                \"ct_snat_to_vip; next;\",\n                                &od->nbs->header_);\n\n        /* If packet needs to be hairpinned, for established sessions there\n         * should already be an SNAT conntrack entry.\n         */\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_NAT_HAIRPIN, 100,\n                                \"ip && ct.est && ct.trk\"\n                                \" && \"REGBIT_HAIRPIN \" == 1\",\n                                \"ct_snat;\",\n                                &od->nbs->header_);\n\n        /* For the reply of hairpinned traffic, snat the src ip to the VIP. */\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_NAT_HAIRPIN, 90,\n                                \"ip && \"REGBIT_HAIRPIN_REPLY \" == 1\",\n                                \"ct_snat;\",\n                                &od->nbs->header_);\n\n        /* Ingress Hairpin table.\n        * - Priority 1: Packets that were SNAT-ed for hairpinning should be\n        *   looped back (i.e., swap ETH addresses and send back on inport).\n        */\n        ovn_lflow_add(\n            lflows, od, S_SWITCH_IN_HAIRPIN, 1,\n            \"(\"REGBIT_HAIRPIN \" == 1 || \" REGBIT_HAIRPIN_REPLY \" == 1)\",\n            \"eth.dst <-> eth.src; outport = inport; flags.loopback = 1; \"\n            \"output;\");\n    }\n}\n\nstatic void\nbuild_vtep_hairpin(struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (!od->has_vtep_lports) {\n        /* There is no need in these flows if datapath has no vtep lports. */\n        return;\n    }\n\n    /* Ingress Pre-ARP flows for VTEP hairpining traffic. Priority 1000:\n     * Packets received from VTEP ports must go directly to L2LKP table.\n     */\n    char *action = xasprintf(\"next(pipeline=ingress, table=%d);\",\n                             ovn_stage_get_table(S_SWITCH_IN_L2_LKUP));\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_HAIRPIN, 1000,\n                  REGBIT_FROM_RAMP\" == 1\", action);\n    free(action);\n\n    /* Ingress pre-arp flow for traffic from VTEP (ramp) switch.\n    * Priority 2000: Packets, that were received from VTEP (ramp) switch and\n    * router ports of current datapath are l3dgw ports and they reside on\n    * current chassis, should be passed to next table for ARP/ND hairpin\n    * processing. */\n    struct ds match = DS_EMPTY_INITIALIZER;\n    for (int i = 0; i < od->n_router_ports; i++) {\n        struct ovn_port *op = od->router_ports[i]->peer;\n        if (is_l3dgw_port(op)) {\n            ds_clear(&match);\n            ds_put_format(&match,\n                          REGBIT_FROM_RAMP\" == 1 && is_chassis_resident(%s)\",\n                          op->cr_port->json_key);\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_HAIRPIN, 2000,\n                          ds_cstr(&match), \"next;\");\n        }\n    }\n    ds_destroy(&match);\n}\n\n/* Build logical flows for the forwarding groups */\nstatic void\nbuild_fwd_group_lflows(struct ovn_datapath *od, struct hmap *lflows)\n{\n\n    if (!(!od->nbs || !od->nbs->n_forwarding_groups)) {\n        struct ds match = DS_EMPTY_INITIALIZER;\n        struct ds actions = DS_EMPTY_INITIALIZER;\n        struct ds group_ports = DS_EMPTY_INITIALIZER;\n\n        for (int i = 0; i < od->nbs->n_forwarding_groups; ++i) {\n            const struct nbrec_forwarding_group *fwd_group = NULL;\n            fwd_group = od->nbs->forwarding_groups[i];\n            if (!fwd_group->n_child_port) {\n                continue;\n            }\n\n            /* ARP responder for the forwarding group's virtual IP */\n            ds_put_format(&match, \"arp.tpa == %s && arp.op == 1\",\n                          fwd_group->vip);\n            ds_put_format(&actions,\n                \"eth.dst = eth.src; \"\n                \"eth.src = %s; \"\n                \"arp.op = 2; /* ARP reply */ \"\n                \"arp.tha = arp.sha; \"\n                \"arp.sha = %s; \"\n                \"arp.tpa = arp.spa; \"\n                \"arp.spa = %s; \"\n                \"outport = inport; \"\n                \"flags.loopback = 1; \"\n                \"output;\",\n                fwd_group->vmac, fwd_group->vmac, fwd_group->vip);\n\n            ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_ARP_ND_RSP, 50,\n                                    ds_cstr(&match), ds_cstr(&actions),\n                                    &fwd_group->header_);\n\n            /* L2 lookup for the forwarding group's virtual MAC */\n            ds_clear(&match);\n            ds_put_format(&match, \"eth.dst == %s\", fwd_group->vmac);\n\n            /* Create a comma separated string of child ports */\n            ds_clear(&group_ports);\n            if (fwd_group->liveness) {\n                ds_put_cstr(&group_ports, \"liveness=\\\"true\\\",\");\n            }\n            ds_put_cstr(&group_ports, \"childports=\");\n            for (i = 0; i < (fwd_group->n_child_port - 1); ++i) {\n                ds_put_format(&group_ports, \"\\\"%s\\\",\",\n                             fwd_group->child_port[i]);\n            }\n            ds_put_format(&group_ports, \"\\\"%s\\\"\",\n                          fwd_group->child_port[fwd_group->n_child_port - 1]);\n\n            ds_clear(&actions);\n            ds_put_format(&actions, \"fwd_group(%s);\", ds_cstr(&group_ports));\n            ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_L2_LKUP, 50,\n                                    ds_cstr(&match), ds_cstr(&actions),\n                                    &fwd_group->header_);\n        }\n\n        ds_destroy(&match);\n        ds_destroy(&actions);\n        ds_destroy(&group_ports);\n    }\n}\n\nstatic void\nbuild_lrouter_groups__(struct hmap *ports, struct ovn_datapath *od)\n{\n    ovs_assert((od && od->nbr && od->lr_group));\n\n    /* For logical router with distributed gateway ports. If it\n     * has HA_Chassis_Group associated to it in SB DB, then store the\n     * ha chassis group name. */\n    for (size_t i = 0; i < od->n_l3dgw_ports; i++) {\n        struct ovn_port *crp = od->l3dgw_ports[i]->cr_port;\n        if (crp->sb->ha_chassis_group &&\n            crp->sb->ha_chassis_group->n_ha_chassis > 1) {\n            sset_add(&od->lr_group->ha_chassis_groups,\n                     crp->sb->ha_chassis_group->name);\n        }\n    }\n\n    for (size_t i = 0; i < od->nbr->n_ports; i++) {\n        struct ovn_port *router_port =\n            ovn_port_find(ports, od->nbr->ports[i]->name);\n\n        if (!router_port || !router_port->peer) {\n            continue;\n        }\n\n        /* Get the peer logical switch/logical router datapath. */\n        struct ovn_datapath *peer_dp = router_port->peer->od;\n        if (peer_dp->nbr) {\n            if (!peer_dp->lr_group) {\n                peer_dp->lr_group = od->lr_group;\n                od->lr_group->router_dps[od->lr_group->n_router_dps++]\n                    = peer_dp;\n                build_lrouter_groups__(ports, peer_dp);\n            }\n        } else {\n            for (size_t j = 0; j < peer_dp->n_router_ports; j++) {\n                if (!peer_dp->router_ports[j]->peer) {\n                    /* If there is no peer port connecting to the\n                    * router port, ignore it. */\n                    continue;\n                }\n\n                struct ovn_datapath *router_dp;\n                router_dp = peer_dp->router_ports[j]->peer->od;\n                if (router_dp == od) {\n                    continue;\n                }\n\n                if (router_dp->lr_group == od->lr_group) {\n                    /* 'router_dp' and 'od' already belong to the same\n                    * lrouter group. Nothing to be done. */\n                    continue;\n                }\n\n                router_dp->lr_group = od->lr_group;\n                od->lr_group->router_dps[od->lr_group->n_router_dps++]\n                    = router_dp;\n                build_lrouter_groups__(ports, router_dp);\n            }\n        }\n    }\n}\n\n/* Adds each logical router into a logical router group. All the\n * logical routers which belong to a group are connected to\n * each other either directly or indirectly (via transit logical switches\n * in between).\n *\n * Suppose if 'lr_list' has lr0, lr1, lr2, lr3, lr4, lr5\n * and the topology is like\n *  sw0 <-> lr0 <-> sw1 <-> lr1 <->sw2 <-> lr2\n *  sw3 <-> lr3 <-> lr4 <-> sw5\n *  sw6 <-> lr5 <-> sw7\n * Then 3 groups are created.\n * Group 1 -> lr0, lr1 and lr2\n *            lr0, lr1 and lr2's ovn_datapath->lr_group will point to this\n *            group. This means sw0's logical ports can send packets to sw2's\n *            logical ports if proper static route's are added.\n * Group 2 -> lr3 and lr4\n *            lr3 and lr4's ovn_datapath->lr_group will point to this group.\n * Group 3 -> lr5\n *\n * Each logical router can belong to only one group.\n */\nstatic void\nbuild_lrouter_groups(struct hmap *ports, struct ovs_list *lr_list)\n{\n    struct ovn_datapath *od;\n    size_t n_router_dps = ovs_list_size(lr_list);\n\n    LIST_FOR_EACH (od, lr_list, lr_list) {\n        if (!od->lr_group) {\n            od->lr_group = xzalloc(sizeof *od->lr_group);\n            /* Each logical router group can have max\n             * 'n_router_dps'. So allocate enough memory. */\n            od->lr_group->router_dps =\n                xcalloc(n_router_dps, sizeof *od->lr_group->router_dps);\n            od->lr_group->router_dps[0] = od;\n            od->lr_group->n_router_dps = 1;\n            sset_init(&od->lr_group->ha_chassis_groups);\n            hmapx_init(&od->lr_group->tmp_ha_chassis);\n            build_lrouter_groups__(ports, od);\n        }\n    }\n}\n\n/*\n * Ingress table 25: Flows that flood self originated ARP/RARP/ND packets in\n * the switching domain.\n */\nstatic void\nbuild_lswitch_rport_arp_req_self_orig_flow(struct ovn_port *op,\n                                           uint32_t priority,\n                                           struct ovn_datapath *od,\n                                           struct hmap *lflows)\n{\n    struct sset all_eth_addrs = SSET_INITIALIZER(&all_eth_addrs);\n    struct ds eth_src = DS_EMPTY_INITIALIZER;\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    sset_add(&all_eth_addrs, op->lrp_networks.ea_s);\n\n    for (size_t i = 0; i < op->od->nbr->n_nat; i++) {\n        struct ovn_nat *nat_entry = &op->od->nat_entries[i];\n        const struct nbrec_nat *nat = nat_entry->nb;\n\n        if (!nat_entry_is_valid(nat_entry)) {\n            continue;\n        }\n\n        if (!strcmp(nat->type, \"snat\")) {\n            continue;\n        }\n\n        if (!nat->external_mac) {\n            continue;\n        }\n        sset_add(&all_eth_addrs, nat->external_mac);\n    }\n\n    /* Self originated ARP requests/RARP/ND need to be flooded to the L2 domain\n     * (except on router ports).  Determine that packets are self originated\n     * by also matching on source MAC. Matching on ingress port is not\n     * reliable in case this is a VLAN-backed network.\n     * Priority: 75.\n     */\n    const char *eth_addr;\n\n    ds_put_cstr(&eth_src, \"{\");\n    SSET_FOR_EACH (eth_addr, &all_eth_addrs) {\n        ds_put_format(&eth_src, \"%s, \", eth_addr);\n    }\n    ds_chomp(&eth_src, ' ');\n    ds_chomp(&eth_src, ',');\n    ds_put_cstr(&eth_src, \"}\");\n\n    ds_put_format(&match,\n                  \"eth.src == %s && (arp.op == 1 || rarp.op == 3 || nd_ns)\",\n                  ds_cstr(&eth_src));\n    ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, priority, ds_cstr(&match),\n                  \"outport = \\\"\"MC_FLOOD_L2\"\\\"; output;\");\n\n    sset_destroy(&all_eth_addrs);\n    ds_destroy(&eth_src);\n    ds_destroy(&match);\n}\n\nstatic void\narp_nd_ns_match(const char *ips, int addr_family, struct ds *match)\n{\n    /* Packets received from VXLAN tunnels have already been through the\n     * router pipeline so we should skip them. Normally this is done by the\n     * multicast_group implementation (VXLAN packets skip table 32 which\n     * delivers to patch ports) but we're bypassing multicast_groups.\n     */\n    ds_put_cstr(match, FLAGBIT_NOT_VXLAN \" && \");\n\n    if (addr_family == AF_INET) {\n        ds_put_format(match, \"arp.op == 1 && arp.tpa == %s\", ips);\n    } else {\n        ds_put_format(match, \"nd_ns && nd.target == %s\", ips);\n    }\n}\n\n/* Returns 'true' if the IPv4 'addr' is on the same subnet with one of the\n * IPs configured on the router port.\n */\nstatic bool\nlrouter_port_ipv4_reachable(const struct ovn_port *op, ovs_be32 addr)\n{\n    for (size_t i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n        struct ipv4_netaddr *op_addr = &op->lrp_networks.ipv4_addrs[i];\n\n        if ((addr & op_addr->mask) == op_addr->network) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/* Returns 'true' if the IPv6 'addr' is on the same subnet with one of the\n * IPs configured on the router port.\n */\nstatic bool\nlrouter_port_ipv6_reachable(const struct ovn_port *op,\n                            const struct in6_addr *addr)\n{\n    for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n        struct ipv6_netaddr *op_addr = &op->lrp_networks.ipv6_addrs[i];\n\n        struct in6_addr nat_addr6_masked =\n            ipv6_addr_bitand(addr, &op_addr->mask);\n\n        if (ipv6_addr_equals(&nat_addr6_masked, &op_addr->network)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/*\n * Ingress table 25: Flows that forward ARP/ND requests only to the routers\n * that own the addresses. Other ARP/ND packets are still flooded in the\n * switching domain as regular broadcast.\n */\nstatic void\nbuild_lswitch_rport_arp_req_flow(const char *ips,\n    int addr_family, struct ovn_port *patch_op, struct ovn_datapath *od,\n    uint32_t priority, struct hmap *lflows,\n    const struct ovsdb_idl_row *stage_hint)\n{\n    struct ds match   = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    arp_nd_ns_match(ips, addr_family, &match);\n\n    /* Send a the packet to the router pipeline.  If the switch has non-router\n     * ports then flood it there as well.\n     */\n    if (od->n_router_ports != od->nbs->n_ports) {\n        ds_put_format(&actions, \"clone {outport = %s; output; }; \"\n                                \"outport = \\\"\"MC_FLOOD_L2\"\\\"; output;\",\n                      patch_op->json_key);\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_L2_LKUP,\n                                priority, ds_cstr(&match),\n                                ds_cstr(&actions), stage_hint);\n    } else {\n        ds_put_format(&actions, \"outport = %s; output;\", patch_op->json_key);\n        ovn_lflow_add_with_hint(lflows, od, S_SWITCH_IN_L2_LKUP, priority,\n                                ds_cstr(&match), ds_cstr(&actions),\n                                stage_hint);\n    }\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\n/*\n * Ingress table 25: Flows that forward ARP/ND requests only to the routers\n * that own the addresses.\n * Priorities:\n * - 80: self originated GARPs that need to follow regular processing.\n * - 75: ARP requests to router owned IPs (interface IP/LB/NAT).\n */\nstatic void\nbuild_lswitch_rport_arp_req_flows(struct ovn_port *op,\n                                  struct ovn_datapath *sw_od,\n                                  struct ovn_port *sw_op,\n                                  struct hmap *lflows,\n                                  const struct ovsdb_idl_row *stage_hint)\n{\n    if (!op || !op->nbrp) {\n        return;\n    }\n\n    if (!lrport_is_enabled(op->nbrp)) {\n        return;\n    }\n\n    /* Forward ARP requests for owned IP addresses (L3, VIP, NAT) only to this\n     * router port.\n     * Priority: 80.\n     */\n\n    const char *ip_addr;\n    SSET_FOR_EACH (ip_addr, &op->od->lb_ips->ips_v4) {\n        ovs_be32 ipv4_addr;\n\n        /* Check if the ovn port has a network configured on which we could\n         * expect ARP requests for the LB VIP.\n         */\n        if (ip_parse(ip_addr, &ipv4_addr) &&\n            lrouter_port_ipv4_reachable(op, ipv4_addr)) {\n            build_lswitch_rport_arp_req_flow(\n                ip_addr, AF_INET, sw_op, sw_od, 80, lflows,\n                stage_hint);\n        }\n    }\n    SSET_FOR_EACH (ip_addr, &op->od->lb_ips->ips_v6) {\n        struct in6_addr ipv6_addr;\n\n        /* Check if the ovn port has a network configured on which we could\n         * expect NS requests for the LB VIP.\n         */\n        if (ipv6_parse(ip_addr, &ipv6_addr) &&\n            lrouter_port_ipv6_reachable(op, &ipv6_addr)) {\n            build_lswitch_rport_arp_req_flow(\n                ip_addr, AF_INET6, sw_op, sw_od, 80, lflows,\n                stage_hint);\n        }\n    }\n\n    for (size_t i = 0; i < op->od->nbr->n_nat; i++) {\n        struct ovn_nat *nat_entry = &op->od->nat_entries[i];\n        const struct nbrec_nat *nat = nat_entry->nb;\n\n        if (!nat_entry_is_valid(nat_entry)) {\n            continue;\n        }\n\n        if (!strcmp(nat->type, \"snat\")) {\n            continue;\n        }\n\n        /* Check if the ovn port has a network configured on which we could\n         * expect ARP requests/NS for the DNAT external_ip.\n         */\n        if (nat_entry_is_v6(nat_entry)) {\n            if (!sset_contains(&op->od->lb_ips->ips_v6, nat->external_ip)) {\n                build_lswitch_rport_arp_req_flow(\n                    nat->external_ip, AF_INET6, sw_op, sw_od, 80, lflows,\n                    stage_hint);\n            }\n        } else {\n            if (!sset_contains(&op->od->lb_ips->ips_v4, nat->external_ip)) {\n                build_lswitch_rport_arp_req_flow(\n                    nat->external_ip, AF_INET, sw_op, sw_od, 80, lflows,\n                    stage_hint);\n            }\n        }\n    }\n\n    for (size_t i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n        build_lswitch_rport_arp_req_flow(\n            op->lrp_networks.ipv4_addrs[i].addr_s, AF_INET, sw_op, sw_od, 80,\n            lflows, stage_hint);\n    }\n    for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n        build_lswitch_rport_arp_req_flow(\n            op->lrp_networks.ipv6_addrs[i].addr_s, AF_INET6, sw_op, sw_od, 80,\n            lflows, stage_hint);\n    }\n\n    /* Self originated ARP requests/RARP/ND need to be flooded as usual.\n     *\n     * However, if the switch doesn't have any non-router ports we shouldn't\n     * even try to flood.\n     *\n     * Priority: 75.\n     */\n    if (sw_od->n_router_ports != sw_od->nbs->n_ports) {\n        build_lswitch_rport_arp_req_self_orig_flow(op, 75, sw_od, lflows);\n    }\n}\n\nstatic void\nbuild_dhcpv4_options_flows(struct ovn_port *op,\n                           struct lport_addresses *lsp_addrs,\n                           struct ovn_port *inport, bool is_external,\n                           const struct shash *meter_groups,\n                           struct hmap *lflows)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    for (size_t j = 0; j < lsp_addrs->n_ipv4_addrs; j++) {\n        struct ds options_action = DS_EMPTY_INITIALIZER;\n        struct ds response_action = DS_EMPTY_INITIALIZER;\n        struct ds ipv4_addr_match = DS_EMPTY_INITIALIZER;\n        if (build_dhcpv4_action(\n                op, lsp_addrs->ipv4_addrs[j].addr,\n                &options_action, &response_action, &ipv4_addr_match)) {\n            ds_clear(&match);\n            ds_put_format(\n                &match, \"inport == %s && eth.src == %s && \"\n                \"ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && \"\n                \"udp.src == 68 && udp.dst == 67\",\n                inport->json_key, lsp_addrs->ea_s);\n\n            if (is_external) {\n                ds_put_format(&match, \" && is_chassis_resident(%s)\",\n                              op->json_key);\n            }\n\n            ovn_lflow_add_with_hint__(lflows, op->od,\n                                      S_SWITCH_IN_DHCP_OPTIONS, 100,\n                                      ds_cstr(&match),\n                                      ds_cstr(&options_action),\n                                      inport->key,\n                                      copp_meter_get(COPP_DHCPV4_OPTS,\n                                                     op->od->nbs->copp,\n                                                     meter_groups),\n                                      &op->nbsp->dhcpv4_options->header_);\n            ds_clear(&match);\n            /* Allow ip4.src = OFFER_IP and\n             * ip4.dst = {SERVER_IP, 255.255.255.255} for the below\n             * cases\n             *  -  When the client wants to renew the IP by sending\n             *     the DHCPREQUEST to the server ip.\n             *  -  When the client wants to renew the IP by\n             *     broadcasting the DHCPREQUEST.\n             */\n            ds_put_format(\n                &match, \"inport == %s && eth.src == %s && \"\n                \"%s && udp.src == 68 && udp.dst == 67\",\n                inport->json_key, lsp_addrs->ea_s, ds_cstr(&ipv4_addr_match));\n\n            if (is_external) {\n                ds_put_format(&match, \" && is_chassis_resident(%s)\",\n                              op->json_key);\n            }\n\n            ovn_lflow_add_with_hint__(lflows, op->od,\n                                      S_SWITCH_IN_DHCP_OPTIONS, 100,\n                                      ds_cstr(&match),\n                                      ds_cstr(&options_action),\n                                      inport->key,\n                                      copp_meter_get(COPP_DHCPV4_OPTS,\n                                                     op->od->nbs->copp,\n                                                     meter_groups),\n                                      &op->nbsp->dhcpv4_options->header_);\n            ds_clear(&match);\n\n            /* If REGBIT_DHCP_OPTS_RESULT is set, it means the\n             * put_dhcp_opts action is successful. */\n            ds_put_format(\n                &match, \"inport == %s && eth.src == %s && \"\n                \"ip4 && udp.src == 68 && udp.dst == 67\"\n                \" && \"REGBIT_DHCP_OPTS_RESULT,\n                inport->json_key, lsp_addrs->ea_s);\n\n            if (is_external) {\n                ds_put_format(&match, \" && is_chassis_resident(%s)\",\n                              op->json_key);\n            }\n\n            ovn_lflow_add_with_lport_and_hint(\n                lflows, op->od, S_SWITCH_IN_DHCP_RESPONSE, 100,\n                ds_cstr(&match), ds_cstr(&response_action), inport->key,\n                &op->nbsp->dhcpv4_options->header_);\n            ds_destroy(&options_action);\n            ds_destroy(&response_action);\n            ds_destroy(&ipv4_addr_match);\n            break;\n        }\n    }\n    ds_destroy(&match);\n}\n\nstatic void\nbuild_dhcpv6_options_flows(struct ovn_port *op,\n                           struct lport_addresses *lsp_addrs,\n                           struct ovn_port *inport, bool is_external,\n                           const struct shash *meter_groups,\n                           struct hmap *lflows)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    for (size_t j = 0; j < lsp_addrs->n_ipv6_addrs; j++) {\n        struct ds options_action = DS_EMPTY_INITIALIZER;\n        struct ds response_action = DS_EMPTY_INITIALIZER;\n        if (build_dhcpv6_action(\n                op, &lsp_addrs->ipv6_addrs[j].addr,\n                &options_action, &response_action)) {\n            ds_clear(&match);\n            ds_put_format(\n                &match, \"inport == %s && eth.src == %s\"\n                \" && ip6.dst == ff02::1:2 && udp.src == 546 &&\"\n                \" udp.dst == 547\",\n                inport->json_key, lsp_addrs->ea_s);\n\n            if (is_external) {\n                ds_put_format(&match, \" && is_chassis_resident(%s)\",\n                              op->json_key);\n            }\n\n            ovn_lflow_add_with_hint__(lflows, op->od,\n                                      S_SWITCH_IN_DHCP_OPTIONS, 100,\n                                      ds_cstr(&match),\n                                      ds_cstr(&options_action),\n                                      inport->key,\n                                      copp_meter_get(COPP_DHCPV6_OPTS,\n                                                     op->od->nbs->copp,\n                                                     meter_groups),\n                                      &op->nbsp->dhcpv6_options->header_);\n\n            /* If REGBIT_DHCP_OPTS_RESULT is set to 1, it means the\n             * put_dhcpv6_opts action is successful */\n            ds_put_cstr(&match, \" && \"REGBIT_DHCP_OPTS_RESULT);\n            ovn_lflow_add_with_lport_and_hint(\n                lflows, op->od, S_SWITCH_IN_DHCP_RESPONSE, 100,\n                ds_cstr(&match), ds_cstr(&response_action), inport->key,\n                &op->nbsp->dhcpv6_options->header_);\n            ds_destroy(&options_action);\n            ds_destroy(&response_action);\n            break;\n        }\n    }\n    ds_destroy(&match);\n}\n\nstatic void\nbuild_drop_arp_nd_flows_for_unbound_router_ports(struct ovn_port *op,\n                                                 const struct ovn_port *port,\n                                                 struct hmap *lflows)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    for (size_t i = 0; i < op->n_lsp_addrs; i++) {\n        for (size_t j = 0; j < op->od->n_router_ports; j++) {\n            struct ovn_port *rp = op->od->router_ports[j];\n            for (size_t k = 0; k < rp->n_lsp_addrs; k++) {\n                for (size_t l = 0; l < rp->lsp_addrs[k].n_ipv4_addrs; l++) {\n                    ds_clear(&match);\n                    ds_put_format(\n                        &match, \"inport == %s && eth.src == %s\"\n                        \" && !is_chassis_resident(%s)\"\n                        \" && arp.tpa == %s && arp.op == 1\",\n                        port->json_key,\n                        op->lsp_addrs[i].ea_s, op->json_key,\n                        rp->lsp_addrs[k].ipv4_addrs[l].addr_s);\n                    ovn_lflow_add_with_lport_and_hint(\n                        lflows, op->od, S_SWITCH_IN_EXTERNAL_PORT, 100,\n                        ds_cstr(&match),  debug_drop_action(), port->key,\n                        &op->nbsp->header_);\n                }\n                for (size_t l = 0; l < rp->lsp_addrs[k].n_ipv6_addrs; l++) {\n                    ds_clear(&match);\n                    ds_put_format(\n                        &match, \"inport == %s && eth.src == %s\"\n                        \" && !is_chassis_resident(%s)\"\n                        \" && nd_ns && ip6.dst == {%s, %s} && nd.target == %s\",\n                        port->json_key,\n                        op->lsp_addrs[i].ea_s, op->json_key,\n                        rp->lsp_addrs[k].ipv6_addrs[l].addr_s,\n                        rp->lsp_addrs[k].ipv6_addrs[l].sn_addr_s,\n                        rp->lsp_addrs[k].ipv6_addrs[l].addr_s);\n                    ovn_lflow_add_with_lport_and_hint(\n                        lflows, op->od, S_SWITCH_IN_EXTERNAL_PORT, 100,\n                        ds_cstr(&match), debug_drop_action(), port->key,\n                        &op->nbsp->header_);\n                }\n\n                ds_clear(&match);\n                ds_put_format(\n                    &match, \"inport == %s && eth.src == %s\"\n                    \" && eth.dst == %s\"\n                    \" && !is_chassis_resident(%s)\",\n                    port->json_key,\n                    op->lsp_addrs[i].ea_s, rp->lsp_addrs[k].ea_s,\n                    op->json_key);\n                ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                                  S_SWITCH_IN_EXTERNAL_PORT,\n                                                  100, ds_cstr(&match),\n                                                  debug_drop_action(),\n                                                  port->key,\n                                                  &op->nbsp->header_);\n            }\n        }\n    }\n    ds_destroy(&match);\n}\n\nstatic bool\nis_vlan_transparent(const struct ovn_datapath *od)\n{\n    return smap_get_bool(&od->nbs->other_config, \"vlan-passthru\", false);\n}\n\nstatic void\nbuild_lswitch_flows(const struct hmap *datapaths,\n                    struct hmap *lflows)\n{\n    /* This flow table structure is documented in ovn-northd(8), so please\n     * update ovn-northd.8.xml if you change anything. */\n\n    struct ovn_datapath *od;\n\n    /* Ingress table 25/26: Destination lookup for unknown MACs\n     * (priority 0). */\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs) {\n            continue;\n        }\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 0, \"1\",\n                      \"outport = get_fdb(eth.dst); next;\");\n\n        if (od->has_unknown) {\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_UNKNOWN, 50,\n                          \"outport == \\\"none\\\"\",\n                          \"outport = \\\"\"MC_UNKNOWN \"\\\"; output;\");\n        } else {\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_UNKNOWN, 50,\n                          \"outport == \\\"none\\\"\",  debug_drop_action());\n        }\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_UNKNOWN, 0, \"1\",\n                      \"output;\");\n    }\n\n}\n\n/* Build pre-ACL and ACL tables for both ingress and egress.\n * Ingress tables 3 through 10.  Egress tables 0 through 7. */\nstatic void\nbuild_lswitch_lflows_pre_acl_and_acl(struct ovn_datapath *od,\n                                     const struct hmap *port_groups,\n                                     const struct chassis_features *features,\n                                     struct hmap *lflows,\n                                     const struct shash *meter_groups)\n{\n    if (od->nbs) {\n        ls_get_acl_flags(od);\n\n        build_pre_acls(od, port_groups, lflows);\n        build_pre_lb(od, meter_groups, lflows);\n        build_pre_stateful(od, features, lflows);\n        build_acl_hints(od, features, lflows);\n        build_acls(od, features, lflows, port_groups, meter_groups);\n        build_qos(od, lflows);\n        build_stateful(od, features, lflows);\n        build_lb_hairpin(od, lflows);\n        build_vtep_hairpin(od, lflows);\n    }\n}\n\n/* Logical switch ingress table 0: Admission control framework (priority\n * 100). */\nstatic void\nbuild_lswitch_lflows_admission_control(struct ovn_datapath *od,\n                                       struct hmap *lflows)\n{\n    if (od->nbs) {\n        /* Logical VLANs not supported. */\n        if (!is_vlan_transparent(od)) {\n            /* Block logical VLANs. */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_CHECK_PORT_SEC, 100,\n                          \"vlan.present\", debug_drop_action());\n        }\n\n        /* Broadcast/multicast source address is invalid. */\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_CHECK_PORT_SEC, 100,\n                      \"eth.src[40]\", debug_drop_action());\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_CHECK_PORT_SEC, 50, \"1\",\n                      REGBIT_PORT_SEC_DROP\" = check_in_port_sec(); next;\");\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_APPLY_PORT_SEC, 50,\n                      REGBIT_PORT_SEC_DROP\" == 1\", debug_drop_action());\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_APPLY_PORT_SEC, 0, \"1\", \"next;\");\n    }\n}\n\n/* Ingress table 19: ARP/ND responder, skip requests coming from localnet\n * ports. (priority 100); see ovn-northd.8.xml for the rationale. */\n\nstatic void\nbuild_lswitch_arp_nd_responder_skip_local(struct ovn_port *op,\n                                          struct hmap *lflows,\n                                          struct ds *match)\n{\n    if (op->nbsp && lsp_is_localnet(op->nbsp)) {\n        ds_clear(match);\n        ds_put_format(match, \"inport == %s\", op->json_key);\n        ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                          S_SWITCH_IN_ARP_ND_RSP, 100,\n                                          ds_cstr(match), \"next;\", op->key,\n                                          &op->nbsp->header_);\n    }\n}\n\n/* Ingress table 19: ARP/ND responder, reply for known IPs.\n * (priority 50). */\nstatic void\nbuild_lswitch_arp_nd_responder_known_ips(struct ovn_port *op,\n                                         struct hmap *lflows,\n                                         const struct hmap *ports,\n                                         const struct shash *meter_groups,\n                                         struct ds *actions,\n                                         struct ds *match)\n{\n    if (op->nbsp) {\n        if (!strcmp(op->nbsp->type, \"virtual\")) {\n            /* Handle\n             *  - GARPs for virtual ip which belongs to a logical port\n             *    of type 'virtual' and bind that port.\n             *\n             *  - ARP reply from the virtual ip which belongs to a logical\n             *    port of type 'virtual' and bind that port.\n             *\n             *  - IPv6 Neighbor Solicitations requests that targets virtual\n             *    ip which belongs to a logical port of type 'virtual' and\n             *    bind that port.\n             *\n             *  - IPv6 unsolicited Neighbor Advertisements that targets\n             *    ip which belongs to a logical port of type 'virtual'\n             *    and bind that port.\n             * */\n            struct in6_addr ip;\n\n            const char *virtual_ip = smap_get(&op->nbsp->options,\n                                              \"virtual-ip\");\n            const char *virtual_parents = smap_get(&op->nbsp->options,\n                                                   \"virtual-parents\");\n            if (!virtual_ip || !virtual_parents) {\n                return;\n            }\n\n            bool is_ipv4 = strchr(virtual_ip, '.') ? true : false;\n            if (is_ipv4) {\n                ovs_be32 ipv4;\n                if (!ip_parse(virtual_ip, &ipv4)) {\n                     return;\n                }\n            } else {\n                if (!ipv6_parse(virtual_ip, &ip)) {\n                     return;\n                }\n            }\n\n            char *tokstr = xstrdup(virtual_parents);\n            char *save_ptr = NULL;\n            char *vparent;\n            for (vparent = strtok_r(tokstr, \",\", &save_ptr); vparent != NULL;\n                 vparent = strtok_r(NULL, \",\", &save_ptr)) {\n                struct ovn_port *vp = ovn_port_find(ports, vparent);\n                if (!vp || vp->od != op->od) {\n                    /* vparent name should be valid and it should belong\n                     * to the same logical switch. */\n                    continue;\n                }\n\n                if (is_ipv4) {\n                    ds_clear(match);\n                    ds_put_format(match, \"inport == \\\"%s\\\" && \"\n                            \"((arp.op == 1 && arp.spa == %s && \"\n                            \"arp.tpa == %s) || (arp.op == 2 && \"\n                            \"arp.spa == %s))\",\n                            vparent, virtual_ip, virtual_ip,\n                            virtual_ip);\n                } else {\n                    struct ipv6_netaddr na;\n                    /* Find VIP multicast group */\n                    in6_addr_solicited_node(&na.sn_addr, &ip);\n                    inet_ntop(AF_INET6, &na.sn_addr, na.sn_addr_s,\n                              sizeof na.sn_addr_s);\n\n                    ds_clear(match);\n                    ds_put_format(match, \"inport == \\\"%s\\\" && \"\n                            \"((nd_ns && ip6.dst == {%s, %s} && \"\n                            \"nd.target == %s) ||\"\n                            \"(nd_na && nd.target == %s))\",\n                            vparent,\n                            virtual_ip,\n                            na.sn_addr_s,\n                            virtual_ip,\n                            virtual_ip);\n                }\n\n                ds_clear(actions);\n                ds_put_format(actions,\n                    \"bind_vport(%s, inport); \"\n                    \"next;\",\n                    op->json_key);\n                ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                                  S_SWITCH_IN_ARP_ND_RSP, 100,\n                                                  ds_cstr(match),\n                                                  ds_cstr(actions), vparent,\n                                                  &vp->nbsp->header_);\n            }\n\n            free(tokstr);\n        } else {\n            /*\n             * Add ARP/ND reply flows if either the\n             *  - port is up and it doesn't have 'unknown' address defined or\n             *  - port type is router or\n             *  - port type is localport\n             */\n            if (check_lsp_is_up &&\n                !lsp_is_up(op->nbsp) && !lsp_is_router(op->nbsp) &&\n                strcmp(op->nbsp->type, \"localport\")) {\n                return;\n            }\n\n            if (lsp_is_external(op->nbsp) || op->has_unknown) {\n                return;\n            }\n\n            if (is_vlan_transparent(op->od)) {\n                return;\n            }\n\n            for (size_t i = 0; i < op->n_lsp_addrs; i++) {\n                for (size_t j = 0; j < op->lsp_addrs[i].n_ipv4_addrs; j++) {\n                    ds_clear(match);\n                    ds_put_format(match, \"arp.tpa == %s && arp.op == 1\",\n                                op->lsp_addrs[i].ipv4_addrs[j].addr_s);\n                    ds_clear(actions);\n                    ds_put_format(actions,\n                        \"eth.dst = eth.src; \"\n                        \"eth.src = %s; \"\n                        \"arp.op = 2; /* ARP reply */ \"\n                        \"arp.tha = arp.sha; \"\n                        \"arp.sha = %s; \"\n                        \"arp.tpa = arp.spa; \"\n                        \"arp.spa = %s; \"\n                        \"outport = inport; \"\n                        \"flags.loopback = 1; \"\n                        \"output;\",\n                        op->lsp_addrs[i].ea_s, op->lsp_addrs[i].ea_s,\n                        op->lsp_addrs[i].ipv4_addrs[j].addr_s);\n                    ovn_lflow_add_with_hint(lflows, op->od,\n                                            S_SWITCH_IN_ARP_ND_RSP, 50,\n                                            ds_cstr(match),\n                                            ds_cstr(actions),\n                                            &op->nbsp->header_);\n\n                    /* Do not reply to an ARP request from the port that owns\n                     * the address (otherwise a DHCP client that ARPs to check\n                     * for a duplicate address will fail).  Instead, forward\n                     * it the usual way.\n                     *\n                     * (Another alternative would be to simply drop the packet.\n                     * If everything is working as it is configured, then this\n                     * would produce equivalent results, since no one should\n                     * reply to the request.  But ARPing for one's own IP\n                     * address is intended to detect situations where the\n                     * network is not working as configured, so dropping the\n                     * request would frustrate that intent.) */\n                    ds_put_format(match, \" && inport == %s\", op->json_key);\n                    ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                                      S_SWITCH_IN_ARP_ND_RSP,\n                                                      100, ds_cstr(match),\n                                                      \"next;\", op->key,\n                                                      &op->nbsp->header_);\n                }\n\n                /* For ND solicitations, we need to listen for both the\n                 * unicast IPv6 address and its all-nodes multicast address,\n                 * but always respond with the unicast IPv6 address. */\n                for (size_t j = 0; j < op->lsp_addrs[i].n_ipv6_addrs; j++) {\n                    ds_clear(match);\n                    ds_put_format(match,\n                            \"nd_ns && ip6.dst == {%s, %s} && nd.target == %s\",\n                            op->lsp_addrs[i].ipv6_addrs[j].addr_s,\n                            op->lsp_addrs[i].ipv6_addrs[j].sn_addr_s,\n                            op->lsp_addrs[i].ipv6_addrs[j].addr_s);\n\n                    ds_clear(actions);\n                    ds_put_format(actions,\n                            \"%s { \"\n                            \"eth.src = %s; \"\n                            \"ip6.src = %s; \"\n                            \"nd.target = %s; \"\n                            \"nd.tll = %s; \"\n                            \"outport = inport; \"\n                            \"flags.loopback = 1; \"\n                            \"output; \"\n                            \"};\",\n                            lsp_is_router(op->nbsp) ? \"nd_na_router\" : \"nd_na\",\n                            op->lsp_addrs[i].ea_s,\n                            op->lsp_addrs[i].ipv6_addrs[j].addr_s,\n                            op->lsp_addrs[i].ipv6_addrs[j].addr_s,\n                            op->lsp_addrs[i].ea_s);\n                    ovn_lflow_add_with_hint__(lflows, op->od,\n                                              S_SWITCH_IN_ARP_ND_RSP, 50,\n                                              ds_cstr(match),\n                                              ds_cstr(actions),\n                                              NULL,\n                                              copp_meter_get(COPP_ND_NA,\n                                                  op->od->nbs->copp,\n                                                  meter_groups),\n                                              &op->nbsp->header_);\n\n                    /* Do not reply to a solicitation from the port that owns\n                     * the address (otherwise DAD detection will fail). */\n                    ds_put_format(match, \" && inport == %s\", op->json_key);\n                    ovn_lflow_add_with_lport_and_hint(lflows, op->od,\n                                                      S_SWITCH_IN_ARP_ND_RSP,\n                                                      100, ds_cstr(match),\n                                                      \"next;\", op->key,\n                                                      &op->nbsp->header_);\n                }\n            }\n        }\n\n        if (op->peer) {\n            const char *arp_proxy = smap_get(&op->nbsp->options,\"arp_proxy\");\n\n            struct lport_addresses proxy_arp_addrs;\n            int i = 0;\n\n            /* Add responses for ARP proxies. */\n            if (arp_proxy && extract_ip_addresses(arp_proxy,\n                                                  &proxy_arp_addrs) &&\n                proxy_arp_addrs.n_ipv4_addrs) {\n                /* Match rule on all proxy ARP IPs. */\n                ds_clear(match);\n                ds_put_cstr(match, \"arp.op == 1 && arp.tpa == {\");\n\n                for (i = 0; i < proxy_arp_addrs.n_ipv4_addrs; i++) {\n                    ds_put_format(match, \"%s,\",\n                                  proxy_arp_addrs.ipv4_addrs[i].addr_s);\n                }\n\n                ds_chomp(match, ',');\n                ds_put_cstr(match, \"}\");\n                destroy_lport_addresses(&proxy_arp_addrs);\n\n                ds_clear(actions);\n                ds_put_format(actions,\n                    \"eth.dst = eth.src; \"\n                    \"eth.src = %s; \"\n                    \"arp.op = 2; /* ARP reply */ \"\n                    \"arp.tha = arp.sha; \"\n                    \"arp.sha = %s; \"\n                    \"arp.tpa <-> arp.spa; \"\n                    \"outport = inport; \"\n                    \"flags.loopback = 1; \"\n                    \"output;\",\n                    op->peer->lrp_networks.ea_s,\n                    op->peer->lrp_networks.ea_s);\n\n                ovn_lflow_add_with_hint(lflows, op->od, S_SWITCH_IN_ARP_ND_RSP,\n                    50, ds_cstr(match), ds_cstr(actions), &op->nbsp->header_);\n            }\n        }\n    }\n}\n\n/* Ingress table 19: ARP/ND responder, by default goto next.\n * (priority 0)*/\nstatic void\nbuild_lswitch_arp_nd_responder_default(struct ovn_datapath *od,\n                                       struct hmap *lflows)\n{\n    if (od->nbs) {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_ARP_ND_RSP, 0, \"1\", \"next;\");\n    }\n}\n\n/* Ingress table 19: ARP/ND responder for service monitor source ip.\n * (priority 110)*/\nstatic void\nbuild_lswitch_arp_nd_service_monitor(struct ovn_northd_lb *lb,\n                                     struct hmap *lflows,\n                                     struct ds *actions,\n                                     struct ds *match)\n{\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_northd_lb_vip *lb_vip_nb = &lb->vips_nb[i];\n        if (!lb_vip_nb->lb_health_check) {\n            continue;\n        }\n\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n        for (size_t j = 0; j < lb_vip_nb->n_backends; j++) {\n            struct ovn_northd_lb_backend *backend_nb =\n                &lb_vip_nb->backends_nb[j];\n            if (!backend_nb->op || !backend_nb->svc_mon_src_ip) {\n                continue;\n            }\n\n            ds_clear(match);\n            ds_clear(actions);\n            if (IN6_IS_ADDR_V4MAPPED(&lb_vip->vip)) {\n                ds_put_format(match, \"arp.tpa == %s && arp.op == 1\",\n                              backend_nb->svc_mon_src_ip);\n                ds_put_format(actions,\n                    \"eth.dst = eth.src; \"\n                    \"eth.src = %s; \"\n                    \"arp.op = 2; /* ARP reply */ \"\n                    \"arp.tha = arp.sha; \"\n                    \"arp.sha = %s; \"\n                    \"arp.tpa = arp.spa; \"\n                    \"arp.spa = %s; \"\n                    \"outport = inport; \"\n                    \"flags.loopback = 1; \"\n                    \"output;\",\n                    svc_monitor_mac, svc_monitor_mac,\n                    backend_nb->svc_mon_src_ip);\n            } else {\n                ds_put_format(match, \"nd_ns && nd.target == %s\",\n                              backend_nb->svc_mon_src_ip);\n                ds_put_format(actions,\n                        \"nd_na { \"\n                        \"eth.dst = eth.src; \"\n                        \"eth.src = %s; \"\n                        \"ip6.src = %s; \"\n                        \"nd.target = %s; \"\n                        \"nd.tll = %s; \"\n                        \"outport = inport; \"\n                        \"flags.loopback = 1; \"\n                        \"output; \"\n                        \"};\",\n                        svc_monitor_mac,\n                        backend_nb->svc_mon_src_ip,\n                        backend_nb->svc_mon_src_ip,\n                        svc_monitor_mac);\n            }\n            ovn_lflow_add_with_hint(lflows,\n                                    backend_nb->op->od,\n                                    S_SWITCH_IN_ARP_ND_RSP, 110,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &lb->nlb->header_);\n        }\n    }\n}\n\n\n/* Logical switch ingress table 20 and 21: DHCP options and response\n * priority 100 flows. */\nstatic void\nbuild_lswitch_dhcp_options_and_response(struct ovn_port *op,\n                                        struct hmap *lflows,\n                                        const struct shash *meter_groups)\n{\n    if (op->nbsp) {\n        if (!lsp_is_enabled(op->nbsp) || lsp_is_router(op->nbsp)) {\n            /* Don't add the DHCP flows if the port is not enabled or if the\n             * port is a router port. */\n            return;\n        }\n\n        if (!op->nbsp->dhcpv4_options && !op->nbsp->dhcpv6_options) {\n            /* CMS has disabled both native DHCPv4 and DHCPv6 for this lport.\n             */\n            return;\n        }\n\n        bool is_external = lsp_is_external(op->nbsp);\n        if (is_external && (!op->od->n_localnet_ports ||\n                            !op->nbsp->ha_chassis_group)) {\n            /* If it's an external port and there are no localnet ports\n             * and if it doesn't belong to an HA chassis group ignore it. */\n            return;\n        }\n\n        for (size_t i = 0; i < op->n_lsp_addrs; i++) {\n            if (is_external) {\n                for (size_t j = 0; j < op->od->n_localnet_ports; j++) {\n                    build_dhcpv4_options_flows(\n                        op, &op->lsp_addrs[i],\n                        op->od->localnet_ports[j], is_external,\n                        meter_groups, lflows);\n                    build_dhcpv6_options_flows(\n                        op, &op->lsp_addrs[i],\n                        op->od->localnet_ports[j], is_external,\n                        meter_groups, lflows);\n                }\n            } else {\n                build_dhcpv4_options_flows(op, &op->lsp_addrs[i], op,\n                                           is_external, meter_groups,\n                                           lflows);\n                build_dhcpv6_options_flows(op, &op->lsp_addrs[i], op,\n                                           is_external, meter_groups,\n                                           lflows);\n            }\n        }\n    }\n}\n\n/* Ingress table 20 and 21: DHCP options and response, by default goto\n * next. (priority 0).\n * Ingress table 22 and 23: DNS lookup and response, by default goto next.\n * (priority 0).\n * Ingress table 24 - External port handling, by default goto next.\n * (priority 0). */\nstatic void\nbuild_lswitch_dhcp_and_dns_defaults(struct ovn_datapath *od,\n                                        struct hmap *lflows)\n{\n    if (od->nbs) {\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DHCP_OPTIONS, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DHCP_RESPONSE, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DNS_LOOKUP, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DNS_RESPONSE, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_EXTERNAL_PORT, 0, \"1\", \"next;\");\n    }\n}\n\n/* Logical switch ingress table 22 and 23: DNS lookup and response\n* priority 100 flows.\n*/\nstatic void\nbuild_lswitch_dns_lookup_and_response(struct ovn_datapath *od,\n                                      struct hmap *lflows,\n                                      const struct shash *meter_groups)\n{\n    if (od->nbs && ls_has_dns_records(od->nbs)) {\n        ovn_lflow_metered(lflows, od, S_SWITCH_IN_DNS_LOOKUP, 100,\n                          \"udp.dst == 53\",\n                          REGBIT_DNS_LOOKUP_RESULT\" = dns_lookup(); next;\",\n                          copp_meter_get(COPP_DNS, od->nbs->copp,\n                                         meter_groups));\n        const char *dns_action = \"eth.dst <-> eth.src; ip4.src <-> ip4.dst; \"\n                      \"udp.dst = udp.src; udp.src = 53; outport = inport; \"\n                      \"flags.loopback = 1; output;\";\n        const char *dns_match = \"udp.dst == 53 && \"REGBIT_DNS_LOOKUP_RESULT;\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DNS_RESPONSE, 100,\n                      dns_match, dns_action);\n        dns_action = \"eth.dst <-> eth.src; ip6.src <-> ip6.dst; \"\n                      \"udp.dst = udp.src; udp.src = 53; outport = inport; \"\n                      \"flags.loopback = 1; output;\";\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_DNS_RESPONSE, 100,\n                      dns_match, dns_action);\n    }\n}\n\n/* Table 24: External port. Drop ARP request for router ips from\n * external ports  on chassis not binding those ports.\n * This makes the router pipeline to be run only on the chassis\n * binding the external ports. */\nstatic void\nbuild_lswitch_external_port(struct ovn_port *op,\n                            struct hmap *lflows)\n{\n    if (op->nbsp && lsp_is_external(op->nbsp)) {\n\n        for (size_t i = 0; i < op->od->n_localnet_ports; i++) {\n            build_drop_arp_nd_flows_for_unbound_router_ports(\n                op, op->od->localnet_ports[i], lflows);\n        }\n    }\n}\n\n/* Ingress table 25: Destination lookup, broadcast and multicast handling\n * (priority 70 - 100). */\nstatic void\nbuild_lswitch_destination_lookup_bmcast(struct ovn_datapath *od,\n                                        struct hmap *lflows,\n                                        struct ds *actions,\n                                        const struct shash *meter_groups)\n{\n    if (od->nbs) {\n\n        ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 110, \"eth.dst == \"\n                          \"$svc_monitor_mac && (tcp || icmp || icmp6)\",\n                          \"handle_svc_check(inport);\",\n                          copp_meter_get(COPP_SVC_MONITOR, od->nbs->copp,\n                                         meter_groups));\n\n        struct mcast_switch_info *mcast_sw_info = &od->mcast_info.sw;\n\n        if (mcast_sw_info->enabled) {\n            ds_clear(actions);\n            ds_put_cstr(actions, \"igmp;\");\n            /* Punt IGMP traffic to controller. */\n            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,\n                              \"igmp\", ds_cstr(actions),\n                              copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                             meter_groups));\n\n            /* Punt MLD traffic to controller. */\n            ovn_lflow_metered(lflows, od, S_SWITCH_IN_L2_LKUP, 100,\n                              \"mldv1 || mldv2\", ds_cstr(actions),\n                              copp_meter_get(COPP_IGMP, od->nbs->copp,\n                                             meter_groups));\n\n            /* Flood all IP multicast traffic destined to 224.0.0.X to all\n             * ports - RFC 4541, section 2.1.2, item 2.\n             */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,\n                          \"ip4.mcast && ip4.dst == 224.0.0.0/24\",\n                          \"outport = \\\"\"MC_FLOOD_L2\"\\\"; output;\");\n\n            /* Flood all IPv6 multicast traffic destined to reserved\n             * multicast IPs (RFC 4291, 2.7.1).\n             */\n            ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 85,\n                          \"ip6.mcast_flood\",\n                          \"outport = \\\"\"MC_FLOOD\"\\\"; output;\");\n\n            /* Forward uregistered IP multicast to routers with relay enabled\n             * and to any ports configured to flood IP multicast traffic.\n             * If configured to flood unregistered traffic this will be\n             * handled by the L2 multicast flow.\n             */\n            if (!mcast_sw_info->flood_unregistered) {\n                ds_clear(actions);\n\n                if (mcast_sw_info->flood_relay) {\n                    ds_put_cstr(actions,\n                                \"clone { \"\n                                    \"outport = \\\"\"MC_MROUTER_FLOOD\"\\\"; \"\n                                    \"output; \"\n                                \"}; \");\n                }\n\n                if (mcast_sw_info->flood_static) {\n                    ds_put_cstr(actions, \"outport =\\\"\"MC_STATIC\"\\\"; output;\");\n                }\n\n                /* Explicitly drop the traffic if relay or static flooding\n                 * is not configured.\n                 */\n                if (!mcast_sw_info->flood_relay &&\n                        !mcast_sw_info->flood_static) {\n                    ds_put_cstr(actions, debug_drop_action());\n                }\n\n                ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 80,\n                              \"ip4.mcast || ip6.mcast\",\n                              ds_cstr(actions));\n            }\n        }\n\n        ovn_lflow_add(lflows, od, S_SWITCH_IN_L2_LKUP, 70, \"eth.mcast\",\n                      \"outport = \\\"\"MC_FLOOD\"\\\"; output;\");\n    }\n}\n\n\n/* Ingress table 25: Add IP multicast flows learnt from IGMP/MLD\n * (priority 90). */\nstatic void\nbuild_lswitch_ip_mcast_igmp_mld(struct ovn_igmp_group *igmp_group,\n                                struct hmap *lflows,\n                                struct ds *actions,\n                                struct ds *match)\n{\n    uint64_t dummy;\n\n    if (igmp_group->datapath) {\n\n        ds_clear(match);\n        ds_clear(actions);\n\n        struct mcast_switch_info *mcast_sw_info =\n            &igmp_group->datapath->mcast_info.sw;\n        uint64_t table_size = mcast_sw_info->table_size;\n\n        if (IN6_IS_ADDR_V4MAPPED(&igmp_group->address)) {\n            /* RFC 4541, section 2.1.2, item 2: Skip groups in the 224.0.0.X\n             * range.\n             */\n            ovs_be32 group_address =\n                in6_addr_get_mapped_ipv4(&igmp_group->address);\n            if (ip_is_local_multicast(group_address)) {\n                return;\n            }\n            if (atomic_compare_exchange_strong(\n                        &mcast_sw_info->active_v4_flows, &table_size,\n                        mcast_sw_info->table_size)) {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n\n                VLOG_INFO_RL(&rl, \"Too many active mcast flows: %\"PRIu64,\n                             mcast_sw_info->active_v4_flows);\n                return;\n            }\n            atomic_add(&mcast_sw_info->active_v4_flows, 1, &dummy);\n            ds_put_format(match, \"eth.mcast && ip4 && ip4.dst == %s \",\n                          igmp_group->mcgroup.name);\n        } else {\n            /* RFC 4291, section 2.7.1: Skip groups that correspond to all\n             * hosts, all link-local routers and all site routers.\n             */\n            if (ipv6_is_all_hosts(&igmp_group->address) ||\n                ipv6_is_all_router(&igmp_group->address) ||\n                ipv6_is_all_site_router(&igmp_group->address)) {\n                return;\n            }\n            if (atomic_compare_exchange_strong(\n                        &mcast_sw_info->active_v6_flows, &table_size,\n                        mcast_sw_info->table_size)) {\n                return;\n            }\n            atomic_add(&mcast_sw_info->active_v6_flows, 1, &dummy);\n            ds_put_format(match, \"eth.mcast && ip6 && ip6.dst == %s \",\n                          igmp_group->mcgroup.name);\n        }\n\n        /* Also flood traffic to all multicast routers with relay enabled. */\n        if (mcast_sw_info->flood_relay) {\n            ds_put_cstr(actions,\n                        \"clone { \"\n                            \"outport = \\\"\"MC_MROUTER_FLOOD \"\\\"; \"\n                            \"output; \"\n                        \"};\");\n        }\n        if (mcast_sw_info->flood_static) {\n            ds_put_cstr(actions,\n                        \"clone { \"\n                            \"outport =\\\"\"MC_STATIC\"\\\"; \"\n                            \"output; \"\n                        \"};\");\n        }\n        ds_put_format(actions, \"outport = \\\"%s\\\"; output; \",\n                      igmp_group->mcgroup.name);\n\n        ovn_lflow_add(lflows, igmp_group->datapath, S_SWITCH_IN_L2_LKUP,\n                      90, ds_cstr(match), ds_cstr(actions));\n    }\n}\n\nstatic struct ovs_mutex mcgroup_mutex = OVS_MUTEX_INITIALIZER;\n\n/* Ingress table 25: Destination lookup, unicast handling (priority 50), */\nstatic void\nbuild_lswitch_ip_unicast_lookup(struct ovn_port *op,\n                                struct hmap *lflows,\n                                struct hmap *mcgroups,\n                                struct ds *actions,\n                                struct ds *match)\n{\n    if (op->nbsp && (!lsp_is_external(op->nbsp))) {\n\n        /* For ports connected to logical routers add flows to bypass the\n         * broadcast flooding of ARP/ND requests in table 19. We direct the\n         * requests only to the router port that owns the IP address.\n         */\n        if (lsp_is_router(op->nbsp)) {\n            build_lswitch_rport_arp_req_flows(op->peer, op->od, op, lflows,\n                                              &op->nbsp->header_);\n        }\n\n        for (size_t i = 0; i < op->nbsp->n_addresses; i++) {\n            /* Addresses are owned by the logical port.\n             * Ethernet address followed by zero or more IPv4\n             * or IPv6 addresses (or both). */\n            struct eth_addr mac;\n            bool lsp_enabled = lsp_is_enabled(op->nbsp);\n            const char *action = lsp_enabled ? \"outport = %s; output;\" :\n                                               debug_drop_action();\n            if (ovs_scan(op->nbsp->addresses[i],\n                        ETH_ADDR_SCAN_FMT, ETH_ADDR_SCAN_ARGS(mac))) {\n                ds_clear(match);\n                ds_put_format(match, \"eth.dst == \"ETH_ADDR_FMT,\n                              ETH_ADDR_ARGS(mac));\n\n                ds_clear(actions);\n                ds_put_format(actions, action, op->json_key);\n                ovn_lflow_add_with_hint(lflows, op->od, S_SWITCH_IN_L2_LKUP,\n                                        50, ds_cstr(match),\n                                        ds_cstr(actions),\n                                        &op->nbsp->header_);\n            } else if (!strcmp(op->nbsp->addresses[i], \"unknown\")) {\n                if (lsp_enabled) {\n                    ovs_mutex_lock(&mcgroup_mutex);\n                    ovn_multicast_add(mcgroups, &mc_unknown, op);\n                    ovs_mutex_unlock(&mcgroup_mutex);\n                    op->od->has_unknown = true;\n                }\n            } else if (is_dynamic_lsp_address(op->nbsp->addresses[i])) {\n                if (!op->nbsp->dynamic_addresses\n                    || !ovs_scan(op->nbsp->dynamic_addresses,\n                            ETH_ADDR_SCAN_FMT, ETH_ADDR_SCAN_ARGS(mac))) {\n                    continue;\n                }\n                ds_clear(match);\n                ds_put_format(match, \"eth.dst == \"ETH_ADDR_FMT,\n                              ETH_ADDR_ARGS(mac));\n\n                ds_clear(actions);\n                ds_put_format(actions, action, op->json_key);\n                ovn_lflow_add_with_hint(lflows, op->od, S_SWITCH_IN_L2_LKUP,\n                                        50, ds_cstr(match),\n                                        ds_cstr(actions),\n                                        &op->nbsp->header_);\n            } else if (!strcmp(op->nbsp->addresses[i], \"router\")) {\n                if (!op->peer || !op->peer->nbrp\n                    || !ovs_scan(op->peer->nbrp->mac,\n                            ETH_ADDR_SCAN_FMT, ETH_ADDR_SCAN_ARGS(mac))) {\n                    continue;\n                }\n                ds_clear(match);\n                ds_put_format(match, \"eth.dst == \"ETH_ADDR_FMT,\n                              ETH_ADDR_ARGS(mac));\n                if (op->peer->od->n_l3dgw_ports\n                    && op->od->n_localnet_ports) {\n                    bool add_chassis_resident_check = false;\n                    const char *json_key;\n                    if (is_l3dgw_port(op->peer)) {\n                        /* The peer of this port represents a distributed\n                         * gateway port. The destination lookup flow for the\n                         * router's distributed gateway port MAC address should\n                         * only be programmed on the gateway chassis. */\n                        add_chassis_resident_check = true;\n                        json_key = op->peer->cr_port->json_key;\n                    } else {\n                        /* Check if the option 'reside-on-redirect-chassis'\n                         * is set to true on the peer port. If set to true\n                         * and if the logical switch has a localnet port, it\n                         * means the router pipeline for the packets from\n                         * this logical switch should be run on the chassis\n                         * hosting the gateway port.\n                         */\n                        add_chassis_resident_check = smap_get_bool(\n                            &op->peer->nbrp->options,\n                            \"reside-on-redirect-chassis\", false) &&\n                            op->peer->od->n_l3dgw_ports == 1;\n                        json_key =\n                            op->peer->od->l3dgw_ports[0]->cr_port->json_key;\n                    }\n\n                    if (add_chassis_resident_check) {\n                        ds_put_format(match, \" && is_chassis_resident(%s)\",\n                                      json_key);\n                    }\n                }\n\n                ds_clear(actions);\n                ds_put_format(actions, action, op->json_key);\n                ovn_lflow_add_with_hint(lflows, op->od,\n                                        S_SWITCH_IN_L2_LKUP, 50,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbsp->header_);\n\n                /* Add ethernet addresses specified in NAT rules on\n                 * distributed logical routers. */\n                if (is_l3dgw_port(op->peer)) {\n                    for (int j = 0; j < op->peer->od->nbr->n_nat; j++) {\n                        const struct nbrec_nat *nat\n                                                  = op->peer->od->nbr->nat[j];\n                        if (!strcmp(nat->type, \"dnat_and_snat\")\n                            && nat->logical_port && nat->external_mac\n                            && eth_addr_from_string(nat->external_mac, &mac)) {\n\n                            ds_clear(match);\n                            ds_put_format(match, \"eth.dst == \"ETH_ADDR_FMT\n                                          \" && is_chassis_resident(\\\"%s\\\")\",\n                                          ETH_ADDR_ARGS(mac),\n                                          nat->logical_port);\n\n                            ds_clear(actions);\n                            ds_put_format(actions, action, op->json_key);\n                            ovn_lflow_add_with_hint(lflows, op->od,\n                                                    S_SWITCH_IN_L2_LKUP, 50,\n                                                    ds_cstr(match),\n                                                    ds_cstr(actions),\n                                                    &op->nbsp->header_);\n                        }\n                    }\n                }\n            } else {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n\n                VLOG_INFO_RL(&rl,\n                             \"%s: invalid syntax '%s' in addresses column\",\n                             op->nbsp->name, op->nbsp->addresses[i]);\n            }\n        }\n    }\n}\n\nstruct bfd_entry {\n    struct hmap_node hmap_node;\n\n    const struct sbrec_bfd *sb_bt;\n\n    bool ref;\n};\n\nstatic struct bfd_entry *\nbfd_port_lookup(const struct hmap *bfd_map, const char *logical_port,\n                const char *dst_ip)\n{\n    struct bfd_entry *bfd_e;\n    uint32_t hash;\n\n    hash = hash_string(dst_ip, 0);\n    hash = hash_string(logical_port, hash);\n    HMAP_FOR_EACH_WITH_HASH (bfd_e, hmap_node, hash, bfd_map) {\n        if (!strcmp(bfd_e->sb_bt->logical_port, logical_port) &&\n            !strcmp(bfd_e->sb_bt->dst_ip, dst_ip)) {\n            return bfd_e;\n        }\n    }\n    return NULL;\n}\n\nvoid\nbfd_cleanup_connections(struct lflow_input *input_data,\n                        struct hmap *bfd_map)\n{\n    const struct nbrec_bfd *nb_bt;\n    struct bfd_entry *bfd_e;\n\n    NBREC_BFD_TABLE_FOR_EACH (nb_bt, input_data->nbrec_bfd_table) {\n        bfd_e = bfd_port_lookup(bfd_map, nb_bt->logical_port, nb_bt->dst_ip);\n        if (!bfd_e) {\n            continue;\n        }\n\n        if (!bfd_e->ref && strcmp(nb_bt->status, \"admin_down\")) {\n            /* no user for this bfd connection */\n            nbrec_bfd_set_status(nb_bt, \"admin_down\");\n        }\n    }\n\n    HMAP_FOR_EACH_POP (bfd_e, hmap_node, bfd_map) {\n        free(bfd_e);\n    }\n}\n\n#define BFD_DEF_MINTX       1000 /* 1s */\n#define BFD_DEF_MINRX       1000 /* 1s */\n#define BFD_DEF_DETECT_MULT 5\n\nstatic void\nbuild_bfd_update_sb_conf(const struct nbrec_bfd *nb_bt,\n                         const struct sbrec_bfd *sb_bt)\n{\n    if (strcmp(nb_bt->dst_ip, sb_bt->dst_ip)) {\n        sbrec_bfd_set_dst_ip(sb_bt, nb_bt->dst_ip);\n    }\n\n    if (strcmp(nb_bt->logical_port, sb_bt->logical_port)) {\n        sbrec_bfd_set_logical_port(sb_bt, nb_bt->logical_port);\n    }\n\n    if (strcmp(nb_bt->status, sb_bt->status)) {\n        sbrec_bfd_set_status(sb_bt, nb_bt->status);\n    }\n\n    int detect_mult = nb_bt->n_detect_mult ? nb_bt->detect_mult[0]\n                                           : BFD_DEF_DETECT_MULT;\n    if (detect_mult != sb_bt->detect_mult) {\n        sbrec_bfd_set_detect_mult(sb_bt, detect_mult);\n    }\n\n    int min_tx = nb_bt->n_min_tx ? nb_bt->min_tx[0] : BFD_DEF_MINTX;\n    if (min_tx != sb_bt->min_tx) {\n        sbrec_bfd_set_min_tx(sb_bt, min_tx);\n    }\n\n    int min_rx = nb_bt->n_min_rx ? nb_bt->min_rx[0] : BFD_DEF_MINRX;\n    if (min_rx != sb_bt->min_rx) {\n        sbrec_bfd_set_min_rx(sb_bt, min_rx);\n    }\n}\n\n/* RFC 5881 section 4\n * The source port MUST be in the range 49152 through 65535.\n * The same UDP source port number MUST be used for all BFD\n * Control packets associated with a particular session.\n * The source port number SHOULD be unique among all BFD\n * sessions on the system\n */\n#define BFD_UDP_SRC_PORT_START  49152\n#define BFD_UDP_SRC_PORT_LEN    (65535 - BFD_UDP_SRC_PORT_START)\n\nstatic int bfd_get_unused_port(unsigned long *bfd_src_ports)\n{\n    int port;\n\n    port = bitmap_scan(bfd_src_ports, 0, 0, BFD_UDP_SRC_PORT_LEN);\n    if (port == BFD_UDP_SRC_PORT_LEN) {\n        return -ENOSPC;\n    }\n    bitmap_set1(bfd_src_ports, port);\n\n    return port + BFD_UDP_SRC_PORT_START;\n}\n\nvoid\nbuild_bfd_table(struct lflow_input *input_data,\n                struct ovsdb_idl_txn *ovnsb_txn,\n                struct hmap *bfd_connections, struct hmap *ports)\n{\n    struct hmap sb_only = HMAP_INITIALIZER(&sb_only);\n    const struct sbrec_bfd *sb_bt;\n    unsigned long *bfd_src_ports;\n    struct bfd_entry *bfd_e;\n    uint32_t hash;\n\n    bfd_src_ports = bitmap_allocate(BFD_UDP_SRC_PORT_LEN);\n\n    SBREC_BFD_TABLE_FOR_EACH (sb_bt, input_data->sbrec_bfd_table) {\n        bfd_e = xmalloc(sizeof *bfd_e);\n        bfd_e->sb_bt = sb_bt;\n        hash = hash_string(sb_bt->dst_ip, 0);\n        hash = hash_string(sb_bt->logical_port, hash);\n        hmap_insert(&sb_only, &bfd_e->hmap_node, hash);\n        bitmap_set1(bfd_src_ports, sb_bt->src_port - BFD_UDP_SRC_PORT_START);\n    }\n\n    const struct nbrec_bfd *nb_bt;\n    NBREC_BFD_TABLE_FOR_EACH (nb_bt, input_data->nbrec_bfd_table) {\n        if (!nb_bt->status) {\n            /* default state is admin_down */\n            nbrec_bfd_set_status(nb_bt, \"admin_down\");\n        }\n\n        bfd_e = bfd_port_lookup(&sb_only, nb_bt->logical_port, nb_bt->dst_ip);\n        if (!bfd_e) {\n            int udp_src = bfd_get_unused_port(bfd_src_ports);\n            if (udp_src < 0) {\n                continue;\n            }\n\n            sb_bt = sbrec_bfd_insert(ovnsb_txn);\n            sbrec_bfd_set_logical_port(sb_bt, nb_bt->logical_port);\n            sbrec_bfd_set_dst_ip(sb_bt, nb_bt->dst_ip);\n            sbrec_bfd_set_disc(sb_bt, 1 + random_uint32());\n            sbrec_bfd_set_src_port(sb_bt, udp_src);\n            sbrec_bfd_set_status(sb_bt, nb_bt->status);\n\n            int min_tx = nb_bt->n_min_tx ? nb_bt->min_tx[0] : BFD_DEF_MINTX;\n            sbrec_bfd_set_min_tx(sb_bt, min_tx);\n            int min_rx = nb_bt->n_min_rx ? nb_bt->min_rx[0] : BFD_DEF_MINRX;\n            sbrec_bfd_set_min_rx(sb_bt, min_rx);\n            int d_mult = nb_bt->n_detect_mult ? nb_bt->detect_mult[0]\n                                              : BFD_DEF_DETECT_MULT;\n            sbrec_bfd_set_detect_mult(sb_bt, d_mult);\n        } else {\n            if (strcmp(bfd_e->sb_bt->status, nb_bt->status)) {\n                if (!strcmp(nb_bt->status, \"admin_down\") ||\n                    !strcmp(bfd_e->sb_bt->status, \"admin_down\")) {\n                    sbrec_bfd_set_status(bfd_e->sb_bt, nb_bt->status);\n                } else {\n                    nbrec_bfd_set_status(nb_bt, bfd_e->sb_bt->status);\n                }\n            }\n            build_bfd_update_sb_conf(nb_bt, bfd_e->sb_bt);\n\n            hmap_remove(&sb_only, &bfd_e->hmap_node);\n            bfd_e->ref = false;\n            hash = hash_string(bfd_e->sb_bt->dst_ip, 0);\n            hash = hash_string(bfd_e->sb_bt->logical_port, hash);\n            hmap_insert(bfd_connections, &bfd_e->hmap_node, hash);\n        }\n\n        struct ovn_port *op = ovn_port_find(ports, nb_bt->logical_port);\n        if (op) {\n            op->has_bfd = true;\n        }\n    }\n\n    HMAP_FOR_EACH_POP (bfd_e, hmap_node, &sb_only) {\n        struct ovn_port *op = ovn_port_find(ports, bfd_e->sb_bt->logical_port);\n        if (op) {\n            op->has_bfd = false;\n        }\n        sbrec_bfd_delete(bfd_e->sb_bt);\n        free(bfd_e);\n    }\n    hmap_destroy(&sb_only);\n\n    bitmap_free(bfd_src_ports);\n}\n\n/* Returns a string of the IP address of the router port 'op' that\n * overlaps with 'ip_s\".  If one is not found, returns NULL.\n *\n * The caller must not free the returned string. */\nstatic const char *\nfind_lrp_member_ip(const struct ovn_port *op, const char *ip_s)\n{\n    return find_lport_address(&op->lrp_networks, ip_s);\n}\n\nstatic struct ovn_port*\nget_outport_for_routing_policy_nexthop(struct ovn_datapath *od,\n                                       const struct hmap *ports,\n                                       int priority, const char *nexthop)\n{\n    if (nexthop == NULL) {\n        return NULL;\n    }\n\n    /* Find the router port matching the next hop. */\n    for (int i = 0; i < od->nbr->n_ports; i++) {\n       struct nbrec_logical_router_port *lrp = od->nbr->ports[i];\n\n       struct ovn_port *out_port = ovn_port_find(ports, lrp->name);\n       if (out_port && find_lrp_member_ip(out_port, nexthop)) {\n           return out_port;\n       }\n    }\n\n    static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n    VLOG_WARN_RL(&rl, \"No path for routing policy priority %d; next hop %s\",\n                 priority, nexthop);\n    return NULL;\n}\n\nstatic void\nbuild_routing_policy_flow(struct hmap *lflows, struct ovn_datapath *od,\n                          const struct hmap *ports,\n                          const struct nbrec_logical_router_policy *rule,\n                          const struct ovsdb_idl_row *stage_hint)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    if (!strcmp(rule->action, \"reroute\")) {\n        ovs_assert(rule->n_nexthops <= 1);\n\n        char *nexthop =\n            (rule->n_nexthops == 1 ? rule->nexthops[0] : rule->nexthop);\n        struct ovn_port *out_port = get_outport_for_routing_policy_nexthop(\n             od, ports, rule->priority, nexthop);\n        if (!out_port) {\n            return;\n        }\n\n        const char *lrp_addr_s = find_lrp_member_ip(out_port, nexthop);\n        if (!lrp_addr_s) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"lrp_addr not found for routing policy \"\n                         \" priority %\"PRId64\" nexthop %s\",\n                         rule->priority, nexthop);\n            return;\n        }\n        uint32_t pkt_mark = ovn_smap_get_uint(&rule->options, \"pkt_mark\", 0);\n        if (pkt_mark) {\n            ds_put_format(&actions, \"pkt.mark = %u; \", pkt_mark);\n        }\n\n        bool is_ipv4 = strchr(nexthop, '.') ? true : false;\n        ds_put_format(&actions, \"%s = %s; \"\n                      \"%s = %s; \"\n                      \"eth.src = %s; \"\n                      \"outport = %s; \"\n                      \"flags.loopback = 1; \"\n                      REG_ECMP_GROUP_ID\" = 0; \"\n                      \"next;\",\n                      is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6,\n                      nexthop,\n                      is_ipv4 ? REG_SRC_IPV4 : REG_SRC_IPV6,\n                      lrp_addr_s,\n                      out_port->lrp_networks.ea_s,\n                      out_port->json_key);\n\n    } else if (!strcmp(rule->action, \"drop\")) {\n        ds_put_cstr(&actions, debug_drop_action());\n    } else if (!strcmp(rule->action, \"allow\")) {\n        uint32_t pkt_mark = ovn_smap_get_uint(&rule->options, \"pkt_mark\", 0);\n        if (pkt_mark) {\n            ds_put_format(&actions, \"pkt.mark = %u; \", pkt_mark);\n        }\n        ds_put_cstr(&actions, REG_ECMP_GROUP_ID\" = 0; next;\");\n    }\n    ds_put_format(&match, \"%s\", rule->match);\n\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_POLICY, rule->priority,\n                            ds_cstr(&match), ds_cstr(&actions), stage_hint);\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_ecmp_routing_policy_flows(struct hmap *lflows, struct ovn_datapath *od,\n                                const struct hmap *ports,\n                                const struct nbrec_logical_router_policy *rule,\n                                uint16_t ecmp_group_id)\n{\n    ovs_assert(rule->n_nexthops > 1);\n\n    bool nexthops_is_ipv4 = true;\n\n    /* Check that all the nexthops belong to the same addr family before\n     * adding logical flows. */\n    for (uint16_t i = 0; i < rule->n_nexthops; i++) {\n        bool is_ipv4 = strchr(rule->nexthops[i], '.') ? true : false;\n\n        if (i == 0) {\n            nexthops_is_ipv4 = is_ipv4;\n        }\n\n        if (is_ipv4 != nexthops_is_ipv4) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"nexthop [%s] of the router policy with \"\n                         \"the match [%s] do not belong to the same address \"\n                         \"family as other next hops\",\n                         rule->nexthops[i], rule->match);\n            return;\n        }\n    }\n\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    for (size_t i = 0; i < rule->n_nexthops; i++) {\n        struct ovn_port *out_port = get_outport_for_routing_policy_nexthop(\n             od, ports, rule->priority, rule->nexthops[i]);\n        if (!out_port) {\n            goto cleanup;\n        }\n\n        const char *lrp_addr_s =\n            find_lrp_member_ip(out_port, rule->nexthops[i]);\n        if (!lrp_addr_s) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"lrp_addr not found for routing policy \"\n                            \" priority %\"PRId64\" nexthop %s\",\n                            rule->priority, rule->nexthops[i]);\n            goto cleanup;\n        }\n\n        ds_clear(&actions);\n        uint32_t pkt_mark = ovn_smap_get_uint(&rule->options, \"pkt_mark\", 0);\n        if (pkt_mark) {\n            ds_put_format(&actions, \"pkt.mark = %u; \", pkt_mark);\n        }\n\n        bool is_ipv4 = strchr(rule->nexthops[i], '.') ? true : false;\n\n        ds_put_format(&actions, \"%s = %s; \"\n                      \"%s = %s; \"\n                      \"eth.src = %s; \"\n                      \"outport = %s; \"\n                      \"flags.loopback = 1; \"\n                      \"next;\",\n                      is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6,\n                      rule->nexthops[i],\n                      is_ipv4 ? REG_SRC_IPV4 : REG_SRC_IPV6,\n                      lrp_addr_s,\n                      out_port->lrp_networks.ea_s,\n                      out_port->json_key);\n\n        ds_clear(&match);\n        ds_put_format(&match, REG_ECMP_GROUP_ID\" == %\"PRIu16\" && \"\n                      REG_ECMP_MEMBER_ID\" == %\"PRIuSIZE,\n                      ecmp_group_id, i + 1);\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_POLICY_ECMP,\n                                100, ds_cstr(&match),\n                                ds_cstr(&actions), &rule->header_);\n    }\n\n    ds_clear(&actions);\n    ds_put_format(&actions, \"%s = %\"PRIu16\n                  \"; %s = select(\", REG_ECMP_GROUP_ID, ecmp_group_id,\n                  REG_ECMP_MEMBER_ID);\n\n    for (size_t i = 0; i < rule->n_nexthops; i++) {\n        if (i > 0) {\n            ds_put_cstr(&actions, \", \");\n        }\n\n        ds_put_format(&actions, \"%\"PRIuSIZE, i + 1);\n    }\n    ds_put_cstr(&actions, \");\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_POLICY,\n                            rule->priority, rule->match,\n                            ds_cstr(&actions), &rule->header_);\n\ncleanup:\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic uint32_t\nroute_table_add(struct simap *route_tables, const char *route_table_name)\n{\n    /* route table ids start from 1 */\n    uint32_t rtb_id = simap_count(route_tables) + 1;\n\n    if (rtb_id == UINT16_MAX) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"too many route tables for Logical Router.\");\n        return 0;\n    }\n\n    if (!simap_put(route_tables, route_table_name, rtb_id)) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"Route table id unexpectedly appeared\");\n    }\n\n    return rtb_id;\n}\n\nstatic uint32_t\nget_route_table_id(struct simap *route_tables, const char *route_table_name)\n{\n    if (!route_table_name || !route_table_name[0]) {\n        return 0;\n    }\n\n    uint32_t rtb_id = simap_get(route_tables, route_table_name);\n    if (!rtb_id) {\n        rtb_id = route_table_add(route_tables, route_table_name);\n    }\n\n    return rtb_id;\n}\n\nstatic void\nbuild_route_table_lflow(struct ovn_datapath *od, struct hmap *lflows,\n                        struct nbrec_logical_router_port *lrp,\n                        struct simap *route_tables)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    const char *route_table_name = smap_get(&lrp->options, \"route_table\");\n    uint32_t rtb_id = get_route_table_id(route_tables, route_table_name);\n    if (!rtb_id) {\n        return;\n    }\n\n    ds_put_format(&match, \"inport == \\\"%s\\\"\", lrp->name);\n    ds_put_format(&actions, \"%s = %d; next;\",\n                  REG_ROUTE_TABLE_ID, rtb_id);\n\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING_PRE, 100,\n                  ds_cstr(&match), ds_cstr(&actions));\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstruct parsed_route {\n    struct ovs_list list_node;\n    struct in6_addr prefix;\n    unsigned int plen;\n    bool is_src_route;\n    uint32_t route_table_id;\n    uint32_t hash;\n    const struct nbrec_logical_router_static_route *route;\n    bool ecmp_symmetric_reply;\n    bool is_discard_route;\n};\n\nstatic uint32_t\nroute_hash(struct parsed_route *route)\n{\n    return hash_bytes(&route->prefix, sizeof route->prefix,\n                      (uint32_t)route->plen);\n}\n\nstatic struct ovs_mutex bfd_lock = OVS_MUTEX_INITIALIZER;\n\nstatic bool\nfind_static_route_outport(struct ovn_datapath *od, const struct hmap *ports,\n    const struct nbrec_logical_router_static_route *route, bool is_ipv4,\n    const char **p_lrp_addr_s, struct ovn_port **p_out_port);\n\n/* Parse and validate the route. Return the parsed route if successful.\n * Otherwise return NULL. */\nstatic struct parsed_route *\nparsed_routes_add(struct ovn_datapath *od, const struct hmap *ports,\n                  struct ovs_list *routes, struct simap *route_tables,\n                  const struct nbrec_logical_router_static_route *route,\n                  const struct hmap *bfd_connections)\n{\n    /* Verify that the next hop is an IP address with an all-ones mask. */\n    struct in6_addr nexthop;\n    unsigned int plen;\n    bool is_discard_route = !strcmp(route->nexthop, \"discard\");\n    bool valid_nexthop = route->nexthop[0] && !is_discard_route;\n    if (valid_nexthop) {\n        if (!ip46_parse_cidr(route->nexthop, &nexthop, &plen)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad 'nexthop' %s in static route \"\n                         UUID_FMT, route->nexthop,\n                         UUID_ARGS(&route->header_.uuid));\n            return NULL;\n        }\n        if ((IN6_IS_ADDR_V4MAPPED(&nexthop) && plen != 32) ||\n            (!IN6_IS_ADDR_V4MAPPED(&nexthop) && plen != 128)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad next hop mask %s in static route \"\n                         UUID_FMT, route->nexthop,\n                         UUID_ARGS(&route->header_.uuid));\n            return NULL;\n        }\n    }\n\n    /* Parse ip_prefix */\n    struct in6_addr prefix;\n    if (!ip46_parse_cidr(route->ip_prefix, &prefix, &plen)) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"bad 'ip_prefix' %s in static route \"\n                     UUID_FMT, route->ip_prefix,\n                     UUID_ARGS(&route->header_.uuid));\n        return NULL;\n    }\n\n    /* Verify that ip_prefix and nexthop have same address familiy. */\n    if (valid_nexthop) {\n        if (IN6_IS_ADDR_V4MAPPED(&prefix) != IN6_IS_ADDR_V4MAPPED(&nexthop)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"Address family doesn't match between 'ip_prefix'\"\n                         \" %s and 'nexthop' %s in static route \"UUID_FMT,\n                         route->ip_prefix, route->nexthop,\n                         UUID_ARGS(&route->header_.uuid));\n            return NULL;\n        }\n    }\n\n    /* Verify that ip_prefix and nexthop are on the same network. */\n    if (!is_discard_route &&\n        !find_static_route_outport(od, ports, route,\n                                   IN6_IS_ADDR_V4MAPPED(&prefix),\n                                   NULL, NULL)) {\n        return NULL;\n    }\n\n    const struct nbrec_bfd *nb_bt = route->bfd;\n    if (nb_bt && !strcmp(nb_bt->dst_ip, route->nexthop)) {\n        struct bfd_entry *bfd_e;\n\n        bfd_e = bfd_port_lookup(bfd_connections, nb_bt->logical_port,\n                                nb_bt->dst_ip);\n        ovs_mutex_lock(&bfd_lock);\n        if (bfd_e) {\n            bfd_e->ref = true;\n        }\n\n        if (!strcmp(nb_bt->status, \"admin_down\")) {\n            nbrec_bfd_set_status(nb_bt, \"down\");\n        }\n\n        if (!strcmp(nb_bt->status, \"down\")) {\n            ovs_mutex_unlock(&bfd_lock);\n            return NULL;\n        }\n        ovs_mutex_unlock(&bfd_lock);\n    }\n\n    struct parsed_route *pr = xzalloc(sizeof *pr);\n    pr->prefix = prefix;\n    pr->plen = plen;\n    pr->route_table_id = get_route_table_id(route_tables, route->route_table);\n    pr->is_src_route = (route->policy && !strcmp(route->policy,\n                                                 \"src-ip\"));\n    pr->hash = route_hash(pr);\n    pr->route = route;\n    pr->ecmp_symmetric_reply = smap_get_bool(&route->options,\n                                             \"ecmp_symmetric_reply\", false);\n    pr->is_discard_route = is_discard_route;\n    ovs_list_insert(routes, &pr->list_node);\n    return pr;\n}\n\nstatic void\nparsed_routes_destroy(struct ovs_list *routes)\n{\n    struct parsed_route *pr;\n    LIST_FOR_EACH_SAFE (pr, list_node, routes) {\n        ovs_list_remove(&pr->list_node);\n        free(pr);\n    }\n}\n\nstruct ecmp_route_list_node {\n    struct ovs_list list_node;\n    uint16_t id; /* starts from 1 */\n    const struct parsed_route *route;\n};\n\nstruct ecmp_groups_node {\n    struct hmap_node hmap_node; /* In ecmp_groups */\n    uint16_t id; /* starts from 1 */\n    struct in6_addr prefix;\n    unsigned int plen;\n    bool is_src_route;\n    const char *origin;\n    uint32_t route_table_id;\n    uint16_t route_count;\n    struct ovs_list route_list; /* Contains ecmp_route_list_node */\n};\n\nstatic void\necmp_groups_add_route(struct ecmp_groups_node *group,\n                      const struct parsed_route *route)\n{\n    if (group->route_count == UINT16_MAX) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"too many routes in a single ecmp group.\");\n        return;\n    }\n\n    struct ecmp_route_list_node *er = xmalloc(sizeof *er);\n    er->route = route;\n    er->id = ++group->route_count;\n    ovs_list_insert(&group->route_list, &er->list_node);\n}\n\nstatic struct ecmp_groups_node *\necmp_groups_add(struct hmap *ecmp_groups,\n                const struct parsed_route *route)\n{\n    if (hmap_count(ecmp_groups) == UINT16_MAX) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"too many ecmp groups.\");\n        return NULL;\n    }\n\n    struct ecmp_groups_node *eg = xzalloc(sizeof *eg);\n    hmap_insert(ecmp_groups, &eg->hmap_node, route->hash);\n\n    eg->id = hmap_count(ecmp_groups);\n    eg->prefix = route->prefix;\n    eg->plen = route->plen;\n    eg->is_src_route = route->is_src_route;\n    eg->origin = smap_get_def(&route->route->options, \"origin\", \"\");\n    eg->route_table_id = route->route_table_id;\n    ovs_list_init(&eg->route_list);\n    ecmp_groups_add_route(eg, route);\n\n    return eg;\n}\n\nstatic struct ecmp_groups_node *\necmp_groups_find(struct hmap *ecmp_groups, struct parsed_route *route)\n{\n    struct ecmp_groups_node *eg;\n    HMAP_FOR_EACH_WITH_HASH (eg, hmap_node, route->hash, ecmp_groups) {\n        if (ipv6_addr_equals(&eg->prefix, &route->prefix) &&\n            eg->plen == route->plen &&\n            eg->is_src_route == route->is_src_route &&\n            eg->route_table_id == route->route_table_id) {\n            return eg;\n        }\n    }\n    return NULL;\n}\n\nstatic void\necmp_groups_destroy(struct hmap *ecmp_groups)\n{\n    struct ecmp_groups_node *eg;\n    HMAP_FOR_EACH_SAFE (eg, hmap_node, ecmp_groups) {\n        struct ecmp_route_list_node *er;\n        LIST_FOR_EACH_SAFE (er, list_node, &eg->route_list) {\n            ovs_list_remove(&er->list_node);\n            free(er);\n        }\n        hmap_remove(ecmp_groups, &eg->hmap_node);\n        free(eg);\n    }\n    hmap_destroy(ecmp_groups);\n}\n\nstruct unique_routes_node {\n    struct hmap_node hmap_node;\n    const struct parsed_route *route;\n};\n\nstatic void\nunique_routes_add(struct hmap *unique_routes,\n                  const struct parsed_route *route)\n{\n    struct unique_routes_node *ur = xmalloc(sizeof *ur);\n    ur->route = route;\n    hmap_insert(unique_routes, &ur->hmap_node, route->hash);\n}\n\n/* Remove the unique_routes_node from the hmap, and return the parsed_route\n * pointed by the removed node. */\nstatic const struct parsed_route *\nunique_routes_remove(struct hmap *unique_routes,\n                     const struct parsed_route *route)\n{\n    struct unique_routes_node *ur;\n    HMAP_FOR_EACH_WITH_HASH (ur, hmap_node, route->hash, unique_routes) {\n        if (ipv6_addr_equals(&route->prefix, &ur->route->prefix) &&\n            route->plen == ur->route->plen &&\n            route->is_src_route == ur->route->is_src_route &&\n            route->route_table_id == ur->route->route_table_id) {\n            hmap_remove(unique_routes, &ur->hmap_node);\n            const struct parsed_route *existed_route = ur->route;\n            free(ur);\n            return existed_route;\n        }\n    }\n    return NULL;\n}\n\nstatic void\nunique_routes_destroy(struct hmap *unique_routes)\n{\n    struct unique_routes_node *ur;\n    HMAP_FOR_EACH_SAFE (ur, hmap_node, unique_routes) {\n        hmap_remove(unique_routes, &ur->hmap_node);\n        free(ur);\n    }\n    hmap_destroy(unique_routes);\n}\n\nstatic char *\nbuild_route_prefix_s(const struct in6_addr *prefix, unsigned int plen)\n{\n    char *prefix_s;\n    if (IN6_IS_ADDR_V4MAPPED(prefix)) {\n        prefix_s = xasprintf(IP_FMT, IP_ARGS(in6_addr_get_mapped_ipv4(prefix) &\n                                             be32_prefix_mask(plen)));\n    } else {\n        struct in6_addr mask = ipv6_create_mask(plen);\n        struct in6_addr network = ipv6_addr_bitand(prefix, &mask);\n        prefix_s = xmalloc(INET6_ADDRSTRLEN);\n        inet_ntop(AF_INET6, &network, prefix_s, INET6_ADDRSTRLEN);\n    }\n    return prefix_s;\n}\n\nstatic void\nbuild_route_match(const struct ovn_port *op_inport, uint32_t rtb_id,\n                  const char *network_s, int plen, bool is_src_route,\n                  bool is_ipv4, struct ds *match, uint16_t *priority, int ofs)\n{\n    const char *dir;\n    /* The priority here is calculated to implement longest-prefix-match\n     * routing. */\n    if (is_src_route) {\n        dir = \"src\";\n        ofs = 0;\n    } else {\n        dir = \"dst\";\n    }\n\n    *priority = (plen * ROUTE_PRIO_OFFSET_MULTIPLIER) + ofs;\n\n    if (op_inport) {\n        ds_put_format(match, \"inport == %s && \", op_inport->json_key);\n    }\n    if (rtb_id || ofs == ROUTE_PRIO_OFFSET_STATIC) {\n        ds_put_format(match, \"%s == %d && \", REG_ROUTE_TABLE_ID, rtb_id);\n    }\n    ds_put_format(match, \"ip%s.%s == %s/%d\", is_ipv4 ? \"4\" : \"6\", dir,\n                  network_s, plen);\n}\n\n/* Output: p_lrp_addr_s and p_out_port. */\nstatic bool\nfind_static_route_outport(struct ovn_datapath *od, const struct hmap *ports,\n    const struct nbrec_logical_router_static_route *route, bool is_ipv4,\n    const char **p_lrp_addr_s, struct ovn_port **p_out_port)\n{\n    const char *lrp_addr_s = NULL;\n    struct ovn_port *out_port = NULL;\n    if (route->output_port) {\n        out_port = ovn_port_find(ports, route->output_port);\n        if (!out_port) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"Bad out port %s for static route %s\",\n                         route->output_port, route->ip_prefix);\n            return false;\n        }\n        if (route->nexthop[0]) {\n            lrp_addr_s = find_lrp_member_ip(out_port, route->nexthop);\n        }\n        if (!lrp_addr_s) {\n            /* There are no IP networks configured on the router's port via\n             * which 'route->nexthop' is theoretically reachable.  But since\n             * 'out_port' has been specified, we honor it by trying to reach\n             * 'route->nexthop' via the first IP address of 'out_port'.\n             * (There are cases, e.g in GCE, where each VM gets a /32 IP\n             * address and the default gateway is still reachable from it.) */\n            if (is_ipv4) {\n                if (out_port->lrp_networks.n_ipv4_addrs) {\n                    lrp_addr_s = out_port->lrp_networks.ipv4_addrs[0].addr_s;\n                }\n            } else {\n                if (out_port->lrp_networks.n_ipv6_addrs) {\n                    lrp_addr_s = out_port->lrp_networks.ipv6_addrs[0].addr_s;\n                }\n            }\n        }\n    } else {\n        /* output_port is not specified, find the\n         * router port matching the next hop. */\n        int i;\n        for (i = 0; i < od->nbr->n_ports; i++) {\n            struct nbrec_logical_router_port *lrp = od->nbr->ports[i];\n            out_port = ovn_port_find(ports, lrp->name);\n            if (!out_port) {\n                /* This should not happen. */\n                continue;\n            }\n\n            if (route->nexthop[0]) {\n                lrp_addr_s = find_lrp_member_ip(out_port, route->nexthop);\n            }\n            if (lrp_addr_s) {\n                break;\n            }\n        }\n    }\n    if (!out_port || !lrp_addr_s) {\n        /* There is no matched out port. */\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"No path for static route %s; next hop %s\",\n                     route->ip_prefix, route->nexthop);\n        return false;\n    }\n    if (p_out_port) {\n        *p_out_port = out_port;\n    }\n    if (p_lrp_addr_s) {\n        *p_lrp_addr_s = lrp_addr_s;\n    }\n\n    return true;\n}\n\nstatic void\nadd_ecmp_symmetric_reply_flows(struct hmap *lflows,\n                               struct ovn_datapath *od,\n                               bool ct_masked_mark,\n                               const char *port_ip,\n                               struct ovn_port *out_port,\n                               const struct parsed_route *route,\n                               struct ds *route_match)\n{\n    const struct nbrec_logical_router_static_route *st_route = route->route;\n    struct ds base_match = DS_EMPTY_INITIALIZER;\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n    struct ds ecmp_reply = DS_EMPTY_INITIALIZER;\n    char *cidr = normalize_v46_prefix(&route->prefix, route->plen);\n    const char *ct_ecmp_reply_port_match = ct_masked_mark\n                                           ? \"ct_mark.ecmp_reply_port\"\n                                           : \"ct_label.ecmp_reply_port\";\n\n    /* If symmetric ECMP replies are enabled, then packets that arrive over\n     * an ECMP route need to go through conntrack.\n     */\n    ds_put_format(&base_match, \"inport == %s && ip%s.%s == %s\",\n                  out_port->json_key,\n                  IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"4\" : \"6\",\n                  route->is_src_route ? \"dst\" : \"src\",\n                  cidr);\n    free(cidr);\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_DEFRAG, 100,\n            ds_cstr(&base_match),\n            REGBIT_KNOWN_ECMP_NH\" = chk_ecmp_nh_mac(); ct_next;\",\n            &st_route->header_);\n\n    /* And packets that go out over an ECMP route need conntrack */\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_DEFRAG, 100,\n            ds_cstr(route_match),\n            REGBIT_KNOWN_ECMP_NH\" = chk_ecmp_nh(); ct_next;\",\n            &st_route->header_);\n\n    /* Save src eth and inport in ct_label for packets that arrive over\n     * an ECMP route.\n     *\n     * NOTE: we purposely are not clearing match before this\n     * ds_put_cstr() call. The previous contents are needed.\n     */\n    ds_put_format(&match, \"%s && (ct.new && !ct.est) && tcp\",\n                  ds_cstr(&base_match));\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = tcp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n    ds_clear(&match);\n    ds_put_format(&match, \"%s && (ct.new && !ct.est) && udp\",\n                  ds_cstr(&base_match));\n    ds_clear(&actions);\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = udp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n    ds_clear(&match);\n    ds_put_format(&match, \"%s && (ct.new && !ct.est) && sctp\",\n                  ds_cstr(&base_match));\n    ds_clear(&actions);\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = sctp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n\n    ds_clear(&match);\n    ds_put_format(&match,\n            \"%s && (!ct.rpl && ct.est) && tcp && \"REGBIT_KNOWN_ECMP_NH\" == 0\",\n            ds_cstr(&base_match));\n    ds_clear(&actions);\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = tcp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n\n    ds_clear(&match);\n    ds_put_format(&match,\n            \"%s && (!ct.rpl && ct.est) && udp && \"REGBIT_KNOWN_ECMP_NH\" == 0\",\n            ds_cstr(&base_match));\n    ds_clear(&actions);\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = udp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n    ds_clear(&match);\n    ds_put_format(&match,\n            \"%s && (!ct.rpl && ct.est) && sctp && \"REGBIT_KNOWN_ECMP_NH\" == 0\",\n            ds_cstr(&base_match));\n    ds_clear(&actions);\n    ds_put_format(&actions,\n            \"ct_commit { ct_label.ecmp_reply_eth = eth.src; \"\n            \" %s = %\" PRId64 \";}; \"\n            \"commit_ecmp_nh(ipv6 = %s, proto = sctp); next;\",\n            ct_ecmp_reply_port_match, out_port->sb->tunnel_key,\n            IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"false\" : \"true\");\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 100,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            &st_route->header_);\n\n    /* Bypass ECMP selection if we already have ct_label information\n     * for where to route the packet.\n     */\n    ds_put_format(&ecmp_reply,\n                  \"ct.rpl && \"REGBIT_KNOWN_ECMP_NH\" == 1 && %s == %\"PRId64,\n                  ct_ecmp_reply_port_match, out_port->sb->tunnel_key);\n    ds_clear(&match);\n    ds_put_format(&match, \"%s && %s\", ds_cstr(&ecmp_reply),\n                  ds_cstr(route_match));\n    ds_clear(&actions);\n    ds_put_format(&actions, \"ip.ttl--; flags.loopback = 1; \"\n                  \"eth.src = %s; %sreg1 = %s; outport = %s; next;\",\n                  out_port->lrp_networks.ea_s,\n                  IN6_IS_ADDR_V4MAPPED(&route->prefix) ? \"\" : \"xx\",\n                  port_ip, out_port->json_key);\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_ROUTING, 10300,\n                           ds_cstr(&match), ds_cstr(&actions),\n                           &st_route->header_);\n\n    /* Egress reply traffic for symmetric ECMP routes skips router policies. */\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_POLICY, 65535,\n                            ds_cstr(&ecmp_reply), \"next;\",\n                            &st_route->header_);\n\n    /* Use REG_ECMP_ETH_FULL to pass the eth field from ct_label to eth.dst to\n     * avoid masked access to ct_label. Otherwise it may prevent OVS flow\n     * HW offloading to work for some NICs because masked-access of ct_label is\n     * not supported on those NICs due to HW limitations.\n     *\n     * Use push/pop to save the value of the register before using it and\n     * restore it immediately afterwards, so that the use of the register is\n     * temporary and doesn't interfere with other stages. */\n    const char *action = \"push(\" REG_ECMP_ETH_FULL \"); \"\n                         REG_ECMP_ETH_FULL \" = ct_label;\"\n                         \" eth.dst = \" REG_ECMP_ETH_FIELD \";\"\n                         \" pop(\" REG_ECMP_ETH_FULL \"); next;\";\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_ARP_RESOLVE,\n                            200, ds_cstr(&ecmp_reply),\n                            action, &st_route->header_);\n\n    ds_destroy(&base_match);\n    ds_destroy(&match);\n    ds_destroy(&actions);\n    ds_destroy(&ecmp_reply);\n}\n\nstatic void\nbuild_ecmp_route_flow(struct hmap *lflows, struct ovn_datapath *od,\n                      bool ct_masked_mark, const struct hmap *ports,\n                      struct ecmp_groups_node *eg)\n\n{\n    bool is_ipv4 = IN6_IS_ADDR_V4MAPPED(&eg->prefix);\n    uint16_t priority;\n    struct ecmp_route_list_node *er;\n    struct ds route_match = DS_EMPTY_INITIALIZER;\n\n    char *prefix_s = build_route_prefix_s(&eg->prefix, eg->plen);\n    int ofs = !strcmp(eg->origin, ROUTE_ORIGIN_CONNECTED) ?\n        ROUTE_PRIO_OFFSET_CONNECTED: ROUTE_PRIO_OFFSET_STATIC;\n    build_route_match(NULL, eg->route_table_id, prefix_s, eg->plen,\n                      eg->is_src_route, is_ipv4, &route_match, &priority, ofs);\n    free(prefix_s);\n\n    struct ds actions = DS_EMPTY_INITIALIZER;\n    ds_put_format(&actions, \"ip.ttl--; flags.loopback = 1; %s = %\"PRIu16\n                  \"; %s = select(\", REG_ECMP_GROUP_ID, eg->id,\n                  REG_ECMP_MEMBER_ID);\n\n    bool is_first = true;\n    LIST_FOR_EACH (er, list_node, &eg->route_list) {\n        if (is_first) {\n            is_first = false;\n        } else {\n            ds_put_cstr(&actions, \", \");\n        }\n        ds_put_format(&actions, \"%\"PRIu16, er->id);\n    }\n\n    ds_put_cstr(&actions, \");\");\n\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, priority,\n                  ds_cstr(&route_match), ds_cstr(&actions));\n\n    /* Add per member flow */\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct sset visited_ports = SSET_INITIALIZER(&visited_ports);\n    LIST_FOR_EACH (er, list_node, &eg->route_list) {\n        const struct parsed_route *route_ = er->route;\n        const struct nbrec_logical_router_static_route *route = route_->route;\n        /* Find the outgoing port. */\n        const char *lrp_addr_s = NULL;\n        struct ovn_port *out_port = NULL;\n        if (!find_static_route_outport(od, ports, route, is_ipv4, &lrp_addr_s,\n                                       &out_port)) {\n            continue;\n        }\n        /* Symmetric ECMP reply is only usable on gateway routers.\n         * It is NOT usable on distributed routers with a gateway port.\n         */\n        if (smap_get(&od->nbr->options, \"chassis\") &&\n            route_->ecmp_symmetric_reply && sset_add(&visited_ports,\n                                                     out_port->key)) {\n            add_ecmp_symmetric_reply_flows(lflows, od, ct_masked_mark,\n                                           lrp_addr_s, out_port,\n                                           route_, &route_match);\n        }\n        ds_clear(&match);\n        ds_put_format(&match, REG_ECMP_GROUP_ID\" == %\"PRIu16\" && \"\n                      REG_ECMP_MEMBER_ID\" == %\"PRIu16,\n                      eg->id, er->id);\n        ds_clear(&actions);\n        ds_put_format(&actions, \"%s = %s; \"\n                      \"%s = %s; \"\n                      \"eth.src = %s; \"\n                      \"outport = %s; \"\n                      \"next;\",\n                      is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6,\n                      route->nexthop,\n                      is_ipv4 ? REG_SRC_IPV4 : REG_SRC_IPV6,\n                      lrp_addr_s,\n                      out_port->lrp_networks.ea_s,\n                      out_port->json_key);\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_ROUTING_ECMP, 100,\n                                ds_cstr(&match), ds_cstr(&actions),\n                                &route->header_);\n    }\n    sset_destroy(&visited_ports);\n    ds_destroy(&match);\n    ds_destroy(&route_match);\n    ds_destroy(&actions);\n}\n\nstatic void\nadd_route(struct hmap *lflows, struct ovn_datapath *od,\n          const struct ovn_port *op, const char *lrp_addr_s,\n          const char *network_s, int plen, const char *gateway,\n          bool is_src_route, const uint32_t rtb_id,\n          const struct ovsdb_idl_row *stage_hint, bool is_discard_route,\n          int ofs)\n{\n    bool is_ipv4 = strchr(network_s, '.') ? true : false;\n    struct ds match = DS_EMPTY_INITIALIZER;\n    uint16_t priority;\n    const struct ovn_port *op_inport = NULL;\n\n    /* IPv6 link-local addresses must be scoped to the local router port. */\n    if (!is_ipv4) {\n        struct in6_addr network;\n        ovs_assert(ipv6_parse(network_s, &network));\n        if (in6_is_lla(&network)) {\n            op_inport = op;\n        }\n    }\n    build_route_match(op_inport, rtb_id, network_s, plen, is_src_route,\n                      is_ipv4, &match, &priority, ofs);\n\n    struct ds common_actions = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n    if (is_discard_route) {\n        ds_put_cstr(&actions, debug_drop_action());\n    } else {\n        ds_put_format(&common_actions, REG_ECMP_GROUP_ID\" = 0; %s = \",\n                      is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6);\n        if (gateway && gateway[0]) {\n            ds_put_cstr(&common_actions, gateway);\n        } else {\n            ds_put_format(&common_actions, \"ip%s.dst\", is_ipv4 ? \"4\" : \"6\");\n        }\n        ds_put_format(&common_actions, \"; \"\n                      \"%s = %s; \"\n                      \"eth.src = %s; \"\n                      \"outport = %s; \"\n                      \"flags.loopback = 1; \"\n                      \"next;\",\n                      is_ipv4 ? REG_SRC_IPV4 : REG_SRC_IPV6,\n                      lrp_addr_s,\n                      op->lrp_networks.ea_s,\n                      op->json_key);\n        ds_put_format(&actions, \"ip.ttl--; %s\", ds_cstr(&common_actions));\n    }\n\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_ROUTING, priority,\n                            ds_cstr(&match), ds_cstr(&actions),\n                            stage_hint);\n    if (op && op->has_bfd) {\n        ds_put_format(&match, \" && udp.dst == 3784\");\n        ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_ROUTING,\n                                priority + 1, ds_cstr(&match),\n                                ds_cstr(&common_actions), stage_hint);\n    }\n    ds_destroy(&match);\n    ds_destroy(&common_actions);\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_static_route_flow(struct hmap *lflows, struct ovn_datapath *od,\n                        const struct hmap *ports,\n                        const struct parsed_route *route_)\n{\n    const char *lrp_addr_s = NULL;\n    struct ovn_port *out_port = NULL;\n\n    const struct nbrec_logical_router_static_route *route = route_->route;\n\n    /* Find the outgoing port. */\n    if (!route_->is_discard_route) {\n        if (!find_static_route_outport(od, ports, route,\n                                       IN6_IS_ADDR_V4MAPPED(&route_->prefix),\n                                       &lrp_addr_s, &out_port)) {\n            return;\n        }\n    }\n\n    int ofs = !strcmp(smap_get_def(&route->options, \"origin\", \"\"),\n                      ROUTE_ORIGIN_CONNECTED) ? ROUTE_PRIO_OFFSET_CONNECTED\n                                              : ROUTE_PRIO_OFFSET_STATIC;\n\n    char *prefix_s = build_route_prefix_s(&route_->prefix, route_->plen);\n    add_route(lflows, route_->is_discard_route ? od : out_port->od, out_port,\n              lrp_addr_s, prefix_s, route_->plen, route->nexthop,\n              route_->is_src_route, route_->route_table_id, &route->header_,\n              route_->is_discard_route, ofs);\n\n    free(prefix_s);\n}\n\nstatic void\nop_put_v4_networks(struct ds *ds, const struct ovn_port *op, bool add_bcast)\n{\n    if (!add_bcast && op->lrp_networks.n_ipv4_addrs == 1) {\n        ds_put_format(ds, \"%s\", op->lrp_networks.ipv4_addrs[0].addr_s);\n        return;\n    }\n\n    ds_put_cstr(ds, \"{\");\n    for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n        ds_put_format(ds, \"%s, \", op->lrp_networks.ipv4_addrs[i].addr_s);\n        if (add_bcast) {\n            ds_put_format(ds, \"%s, \", op->lrp_networks.ipv4_addrs[i].bcast_s);\n        }\n    }\n    ds_chomp(ds, ' ');\n    ds_chomp(ds, ',');\n    ds_put_cstr(ds, \"}\");\n}\n\nstatic void\nop_put_v6_networks(struct ds *ds, const struct ovn_port *op)\n{\n    if (op->lrp_networks.n_ipv6_addrs == 1) {\n        ds_put_format(ds, \"%s\", op->lrp_networks.ipv6_addrs[0].addr_s);\n        return;\n    }\n\n    ds_put_cstr(ds, \"{\");\n    for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n        ds_put_format(ds, \"%s, \", op->lrp_networks.ipv6_addrs[i].addr_s);\n    }\n    ds_chomp(ds, ' ');\n    ds_chomp(ds, ',');\n    ds_put_cstr(ds, \"}\");\n}\n\nstatic bool\nget_force_snat_ip(struct ovn_datapath *od, const char *key_type,\n                  struct lport_addresses *laddrs)\n{\n    char *key = xasprintf(\"%s_force_snat_ip\", key_type);\n    const char *addresses = smap_get(&od->nbr->options, key);\n    free(key);\n\n    if (!addresses) {\n        return false;\n    }\n\n    if (!extract_ip_address(addresses, laddrs)) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n        VLOG_WARN_RL(&rl, \"bad ip %s in options of router \"UUID_FMT\"\",\n                     addresses, UUID_ARGS(&od->key));\n        return false;\n    }\n\n    return true;\n}\n\nenum lrouter_nat_lb_flow_type {\n    LROUTER_NAT_LB_FLOW_NORMAL = 0,\n    LROUTER_NAT_LB_FLOW_SKIP_SNAT,\n    LROUTER_NAT_LB_FLOW_FORCE_SNAT,\n    LROUTER_NAT_LB_FLOW_MAX,\n};\n\nstruct lrouter_nat_lb_flows_ctx {\n    const char *new_action[LROUTER_NAT_LB_FLOW_MAX];\n\n    struct ds *new_match;\n    struct ds *undnat_match;\n\n    struct ovn_lb_vip *lb_vip;\n    struct ovn_northd_lb *lb;\n    bool reject;\n\n    int prio;\n\n    struct hmap *lflows;\n    const struct shash *meter_groups;\n};\n\nstatic void\nbuild_distr_lrouter_nat_flows_for_lb(struct lrouter_nat_lb_flows_ctx *ctx,\n                                     enum lrouter_nat_lb_flow_type type,\n                                     struct ovn_datapath *od)\n{\n    const char *undnat_action;\n\n    switch (type) {\n    case LROUTER_NAT_LB_FLOW_FORCE_SNAT:\n        undnat_action = \"flags.force_snat_for_lb = 1; next;\";\n        break;\n    case LROUTER_NAT_LB_FLOW_SKIP_SNAT:\n        undnat_action = \"flags.skip_snat_for_lb = 1; next;\";\n        break;\n    case LROUTER_NAT_LB_FLOW_NORMAL:\n    case LROUTER_NAT_LB_FLOW_MAX:\n        undnat_action = od->is_gw_router ? \"ct_dnat;\" : \"ct_dnat_in_czone;\";\n        break;\n    }\n    /* Store the match lengths, so we can reuse the ds buffer. */\n    size_t new_match_len = ctx->new_match->length;\n    size_t undnat_match_len = ctx->undnat_match->length;\n\n\n    const char *meter = NULL;\n\n    if (ctx->reject) {\n        meter = copp_meter_get(COPP_REJECT, od->nbr->copp, ctx->meter_groups);\n    }\n\n    if (ctx->lb_vip->n_backends || !ctx->lb_vip->empty_backend_rej) {\n        ds_put_format(ctx->new_match, \" && is_chassis_resident(%s)\",\n                      od->l3dgw_ports[0]->cr_port->json_key);\n    }\n\n    ovn_lflow_add_with_hint__(ctx->lflows, od, S_ROUTER_IN_DNAT, ctx->prio,\n                              ds_cstr(ctx->new_match), ctx->new_action[type],\n                              NULL, meter, &ctx->lb->nlb->header_);\n\n    ds_truncate(ctx->new_match, new_match_len);\n\n    if (!ctx->lb_vip->n_backends) {\n        return;\n    }\n\n    ds_put_format(ctx->undnat_match,\n                  \") && outport == %s && is_chassis_resident(%s)\",\n                  od->l3dgw_ports[0]->json_key,\n                  od->l3dgw_ports[0]->cr_port->json_key);\n    ovn_lflow_add_with_hint(ctx->lflows, od, S_ROUTER_OUT_UNDNAT, 120,\n                            ds_cstr(ctx->undnat_match), undnat_action,\n                            &ctx->lb->nlb->header_);\n    ds_truncate(ctx->undnat_match, undnat_match_len);\n}\n\nstatic void\nbuild_gw_lrouter_nat_flows_for_lb(struct lrouter_nat_lb_flows_ctx *ctx,\n                                  enum lrouter_nat_lb_flow_type type,\n                                  const unsigned long *dp_bitmap)\n{\n    unsigned long *dp_non_meter = NULL;\n    bool build_non_meter = false;\n    size_t index;\n\n    if (bitmap_is_all_zeros(dp_bitmap, n_datapaths)) {\n        return;\n    }\n\n    if (ctx->reject) {\n        dp_non_meter = bitmap_clone(dp_bitmap, n_datapaths);\n        BITMAP_FOR_EACH_1 (index, n_datapaths, dp_bitmap) {\n            struct ovn_datapath *od = datapaths_array[index];\n            const char *meter;\n\n            meter = copp_meter_get(COPP_REJECT, od->nbr->copp,\n                                   ctx->meter_groups);\n            if (!meter) {\n                build_non_meter = true;\n                continue;\n            }\n            bitmap_set0(dp_non_meter, index);\n            ovn_lflow_add_with_hint__(ctx->lflows, od, S_ROUTER_IN_DNAT,\n                    ctx->prio, ds_cstr(ctx->new_match), ctx->new_action[type],\n                    NULL, meter, &ctx->lb->nlb->header_);\n        }\n    }\n    if (!ctx->reject || build_non_meter) {\n        ovn_lflow_add_with_dp_group(ctx->lflows,\n            dp_non_meter ? dp_non_meter : dp_bitmap,\n            S_ROUTER_IN_DNAT, ctx->prio, ds_cstr(ctx->new_match),\n            ctx->new_action[type], &ctx->lb->nlb->header_);\n    }\n    bitmap_free(dp_non_meter);\n}\n\nstatic void\nbuild_lrouter_nat_flows_for_lb(struct ovn_lb_vip *lb_vip,\n                               struct ovn_northd_lb *lb,\n                               struct ovn_northd_lb_vip *vips_nb,\n                               struct hmap *lflows,\n                               struct ds *match, struct ds *action,\n                               const struct shash *meter_groups,\n                               const struct chassis_features *features)\n{\n    bool ipv4 = lb_vip->address_family == AF_INET;\n    const char *ip_match = ipv4 ? \"ip4\" : \"ip6\";\n\n    int prio = 110;\n\n    struct ds skip_snat_act = DS_EMPTY_INITIALIZER;\n    struct ds force_snat_act = DS_EMPTY_INITIALIZER;\n    struct ds undnat_match = DS_EMPTY_INITIALIZER;\n    struct ds unsnat_match = DS_EMPTY_INITIALIZER;\n\n    ds_clear(match);\n    ds_clear(action);\n\n    bool reject = build_lb_vip_actions(lb_vip, vips_nb, action,\n                                       lb->selection_fields, &skip_snat_act,\n                                       &force_snat_act, false, features);\n\n    /* Higher priority rules are added for load-balancing in DNAT\n     * table.  For every match (on a VIP[:port]), we add two flows.\n     * One flow is for specific matching on ct.new with an action\n     * of \"ct_lb_mark($targets);\". The other flow is for ct.est with\n     * an action of \"next;\".\n     */\n    ds_put_format(match, \"ct.new && !ct.rel && %s && %s.dst == %s\",\n                  ip_match, ip_match, lb_vip->vip_str);\n    if (lb_vip->port_str) {\n        prio = 120;\n        ds_put_format(match, \" && %s && %s.dst == %s\",\n                      lb->proto, lb->proto, lb_vip->port_str);\n    }\n\n    /* Add logical flows to UNDNAT the load balanced reverse traffic in\n     * the router egress pipleine stage - S_ROUTER_OUT_UNDNAT if the logical\n     * router has a gateway router port associated.\n     */\n    ds_put_format(&undnat_match, \"%s && (\", ip_match);\n\n    for (size_t i = 0; i < lb_vip->n_backends; i++) {\n        struct ovn_lb_backend *backend = &lb_vip->backends[i];\n        ds_put_format(&undnat_match, \"(%s.src == %s\", ip_match,\n                      backend->ip_str);\n\n        if (backend->port_str) {\n            ds_put_format(&undnat_match, \" && %s.src == %s) || \",\n                          lb->proto, backend->port_str);\n        } else {\n            ds_put_cstr(&undnat_match, \") || \");\n        }\n    }\n    /* Remove the trailing \" || \". */\n    ds_truncate(&undnat_match, undnat_match.length - 4);\n\n    ds_put_format(&unsnat_match, \"%s && %s.dst == %s && %s\",\n                  ip_match, ip_match, lb_vip->vip_str, lb->proto);\n    if (lb_vip->port_str) {\n        ds_put_format(&unsnat_match, \" && %s.dst == %s\", lb->proto,\n                      lb_vip->port_str);\n    }\n\n    struct lrouter_nat_lb_flows_ctx ctx = {\n        .lb_vip = lb_vip,\n        .lb = lb,\n        .reject = reject,\n        .prio = prio,\n        .lflows = lflows,\n        .meter_groups = meter_groups,\n        .new_match = match,\n        .undnat_match = &undnat_match\n    };\n\n    ctx.new_action[LROUTER_NAT_LB_FLOW_NORMAL] = ds_cstr(action);\n    ctx.new_action[LROUTER_NAT_LB_FLOW_SKIP_SNAT] = ds_cstr(&skip_snat_act);\n    ctx.new_action[LROUTER_NAT_LB_FLOW_FORCE_SNAT] = ds_cstr(&force_snat_act);\n\n    enum {\n        LROUTER_NAT_LB_AFF            = LROUTER_NAT_LB_FLOW_MAX,\n        LROUTER_NAT_LB_AFF_FORCE_SNAT = LROUTER_NAT_LB_FLOW_MAX + 1,\n    };\n    unsigned long *dp_bitmap[LROUTER_NAT_LB_FLOW_MAX + 2];\n\n    for (size_t i = 0; i < LROUTER_NAT_LB_FLOW_MAX + 2; i++) {\n        dp_bitmap[i] = bitmap_allocate(n_datapaths);\n    }\n\n    /* Group gw router since we do not have datapath dependency in\n     * lflow generation for them.\n     */\n    size_t index;\n    BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {\n        struct ovn_datapath *od = datapaths_array[index];\n        enum lrouter_nat_lb_flow_type type;\n\n        if (lb->skip_snat) {\n            type = LROUTER_NAT_LB_FLOW_SKIP_SNAT;\n        } else if (!lport_addresses_is_empty(&od->lb_force_snat_addrs) ||\n                   od->lb_force_snat_router_ip) {\n            type = LROUTER_NAT_LB_FLOW_FORCE_SNAT;\n        } else {\n            type = LROUTER_NAT_LB_FLOW_NORMAL;\n        }\n\n        if (!od->n_l3dgw_ports) {\n            bitmap_set1(dp_bitmap[type], index);\n        } else {\n            build_distr_lrouter_nat_flows_for_lb(&ctx, type, od);\n        }\n\n        if (lb->affinity_timeout) {\n            if (!lport_addresses_is_empty(&od->lb_force_snat_addrs) ||\n                od->lb_force_snat_router_ip) {\n                bitmap_set1(dp_bitmap[LROUTER_NAT_LB_AFF_FORCE_SNAT], index);\n            } else {\n                bitmap_set1(dp_bitmap[LROUTER_NAT_LB_AFF], index);\n            }\n        }\n\n        if (sset_contains(&od->external_ips, lb_vip->vip_str)) {\n            /* The load balancer vip is also present in the NAT entries.\n             * So add a high priority lflow to advance the the packet\n             * destined to the vip (and the vip port if defined)\n             * in the S_ROUTER_IN_UNSNAT stage.\n             * There seems to be an issue with ovs-vswitchd. When the new\n             * connection packet destined for the lb vip is received,\n             * it is dnat'ed in the S_ROUTER_IN_DNAT stage in the dnat\n             * conntrack zone. For the next packet, if it goes through\n             * unsnat stage, the conntrack flags are not set properly, and\n             * it doesn't hit the established state flows in\n             * S_ROUTER_IN_DNAT stage. */\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT, 120,\n                                    ds_cstr(&unsnat_match), \"next;\",\n                                    &lb->nlb->header_);\n        }\n    }\n\n    for (size_t type = 0; type < LROUTER_NAT_LB_FLOW_MAX; type++) {\n        build_gw_lrouter_nat_flows_for_lb(&ctx, type, dp_bitmap[type]);\n    }\n\n    /* LB affinity flows for datapaths where CMS has specified\n     * force_snat_for_lb floag option.\n     */\n    build_lb_affinity_lr_flows(lflows, lb, lb_vip, ds_cstr(match),\n                               \"flags.force_snat_for_lb = 1; \",\n                               dp_bitmap[LROUTER_NAT_LB_AFF_FORCE_SNAT]);\n\n    /* LB affinity flows for datapaths where CMS has specified\n     * skip_snat_for_lb floag option or regular datapaths.\n     */\n    char *lb_aff_action =\n        lb->skip_snat ? \"flags.skip_snat_for_lb = 1; \" : NULL;\n    build_lb_affinity_lr_flows(lflows, lb, lb_vip, ds_cstr(match),\n                               lb_aff_action, dp_bitmap[LROUTER_NAT_LB_AFF]);\n\n    ds_destroy(&unsnat_match);\n    ds_destroy(&undnat_match);\n    ds_destroy(&skip_snat_act);\n    ds_destroy(&force_snat_act);\n\n    for (size_t i = 0; i < LROUTER_NAT_LB_FLOW_MAX + 2; i++) {\n        bitmap_free(dp_bitmap[i]);\n    }\n}\n\nstatic void\nbuild_lswitch_flows_for_lb(struct ovn_northd_lb *lb, struct hmap *lflows,\n                           const struct shash *meter_groups,\n                           const struct chassis_features *features,\n                           struct ds *match, struct ds *action)\n{\n    if (!lb->n_nb_ls) {\n        return;\n    }\n\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n\n        /* pre-stateful lb */\n        if (!build_empty_lb_event_flow(lb_vip, lb, match, action)) {\n            continue;\n        }\n\n        size_t index;\n        BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_ls_map) {\n            struct ovn_datapath *od = datapaths_array[index];\n\n            ovn_lflow_add_with_hint__(lflows, od,\n                                      S_SWITCH_IN_PRE_LB, 130, ds_cstr(match),\n                                      ds_cstr(action),\n                                      NULL,\n                                      copp_meter_get(COPP_EVENT_ELB,\n                                                     od->nbs->copp,\n                                                     meter_groups),\n                                      &lb->nlb->header_);\n        }\n        /* Ignore L4 port information in the key because fragmented packets\n         * may not have L4 information.  The pre-stateful table will send\n         * the packet through ct() action to de-fragment. In stateful\n         * table, we will eventually look at L4 information. */\n    }\n\n    /* stateful lb\n     * Load balancing rules for new connections get committed to conntrack\n     * table.  So even if REGBIT_CONNTRACK_COMMIT is set in a previous table\n     * a higher priority rule for load balancing below also commits the\n     * connection, so it is okay if we do not hit the above match on\n     * REGBIT_CONNTRACK_COMMIT. */\n    build_lb_rules_pre_stateful(lflows, lb, features->ct_no_masked_label,\n                                match, action);\n    build_lb_rules(lflows, lb, features, match, action, meter_groups);\n}\n\n/* If there are any load balancing rules, we should send the packet to\n * conntrack for defragmentation and tracking.  This helps with two things.\n *\n * 1. With tracking, we can send only new connections to pick a DNAT ip address\n *    from a group.\n * 2. If there are L4 ports in load balancing rules, we need the\n *    defragmentation to match on L4 ports.\n */\nstatic void\nbuild_lrouter_defrag_flows_for_lb(struct ovn_northd_lb *lb,\n                                  struct hmap *lflows,\n                                  struct ds *match)\n{\n    if (!lb->n_nb_lr) {\n        return;\n    }\n\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n        bool ipv6 = lb_vip->address_family == AF_INET6;\n        int prio = 100;\n\n        ds_clear(match);\n        ds_put_format(match, \"ip && ip%c.dst == %s\", ipv6 ? '6' : '4',\n                      lb_vip->vip_str);\n\n        ovn_lflow_add_with_dp_group(\n            lflows, lb->nb_lr_map, S_ROUTER_IN_DEFRAG, prio,\n            ds_cstr(match), \"ct_dnat;\", &lb->nlb->header_);\n    }\n}\n\nstatic void\nbuild_lrouter_flows_for_lb(struct ovn_northd_lb *lb, struct hmap *lflows,\n                           const struct shash *meter_groups,\n                           const struct chassis_features *features,\n                           struct ds *match, struct ds *action)\n{\n    size_t index;\n\n    if (!lb->n_nb_lr) {\n        return;\n    }\n\n    for (size_t i = 0; i < lb->n_vips; i++) {\n        struct ovn_lb_vip *lb_vip = &lb->vips[i];\n\n        build_lrouter_nat_flows_for_lb(lb_vip, lb, &lb->vips_nb[i],\n                                       lflows, match, action, meter_groups,\n                                       features);\n\n        if (!build_empty_lb_event_flow(lb_vip, lb, match, action)) {\n            continue;\n        }\n\n        BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {\n            struct ovn_datapath *od = datapaths_array[index];\n\n            ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_DNAT,\n                                      130, ds_cstr(match), ds_cstr(action),\n                                      NULL,\n                                      copp_meter_get(COPP_EVENT_ELB,\n                                                     od->nbr->copp,\n                                                     meter_groups),\n                                      &lb->nlb->header_);\n        }\n    }\n\n    if (lb->skip_snat) {\n        BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {\n            struct ovn_datapath *od = datapaths_array[index];\n\n            ovn_lflow_add(lflows, od, S_ROUTER_OUT_SNAT, 120,\n                          \"flags.skip_snat_for_lb == 1 && ip\", \"next;\");\n        }\n    }\n}\n\n#define ND_RA_MAX_INTERVAL_MAX 1800\n#define ND_RA_MAX_INTERVAL_MIN 4\n\n#define ND_RA_MIN_INTERVAL_MAX(max) ((max) * 3 / 4)\n#define ND_RA_MIN_INTERVAL_MIN 3\n\nstatic void\ncopy_ra_to_sb(struct ovn_port *op, const char *address_mode)\n{\n    struct smap options;\n    smap_clone(&options, &op->sb->options);\n\n    smap_add(&options, \"ipv6_ra_send_periodic\", \"true\");\n    smap_add(&options, \"ipv6_ra_address_mode\", address_mode);\n\n    int max_interval = smap_get_int(&op->nbrp->ipv6_ra_configs,\n            \"max_interval\", ND_RA_MAX_INTERVAL_DEFAULT);\n    if (max_interval > ND_RA_MAX_INTERVAL_MAX) {\n        max_interval = ND_RA_MAX_INTERVAL_MAX;\n    }\n    if (max_interval < ND_RA_MAX_INTERVAL_MIN) {\n        max_interval = ND_RA_MAX_INTERVAL_MIN;\n    }\n    smap_add_format(&options, \"ipv6_ra_max_interval\", \"%d\", max_interval);\n\n    int min_interval = smap_get_int(&op->nbrp->ipv6_ra_configs,\n            \"min_interval\", nd_ra_min_interval_default(max_interval));\n    if (min_interval > ND_RA_MIN_INTERVAL_MAX(max_interval)) {\n        min_interval = ND_RA_MIN_INTERVAL_MAX(max_interval);\n    }\n    if (min_interval < ND_RA_MIN_INTERVAL_MIN) {\n        min_interval = ND_RA_MIN_INTERVAL_MIN;\n    }\n    smap_add_format(&options, \"ipv6_ra_min_interval\", \"%d\", min_interval);\n\n    int mtu = smap_get_int(&op->nbrp->ipv6_ra_configs, \"mtu\", ND_MTU_DEFAULT);\n    /* RFC 2460 requires the MTU for IPv6 to be at least 1280 */\n    if (mtu && mtu >= 1280) {\n        smap_add_format(&options, \"ipv6_ra_mtu\", \"%d\", mtu);\n    }\n\n    struct ds s = DS_EMPTY_INITIALIZER;\n    for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; ++i) {\n        struct ipv6_netaddr *addrs = &op->lrp_networks.ipv6_addrs[i];\n        if (in6_is_lla(&addrs->network)) {\n            smap_add(&options, \"ipv6_ra_src_addr\", addrs->addr_s);\n            continue;\n        }\n        ds_put_format(&s, \"%s/%u \", addrs->network_s, addrs->plen);\n    }\n\n    const char *ra_pd_list = smap_get(&op->sb->options, \"ipv6_ra_pd_list\");\n    if (ra_pd_list) {\n        ds_put_cstr(&s, ra_pd_list);\n    }\n    /* Remove trailing space */\n    ds_chomp(&s, ' ');\n    smap_add(&options, \"ipv6_ra_prefixes\", ds_cstr(&s));\n    ds_destroy(&s);\n\n    const char *rdnss = smap_get(&op->nbrp->ipv6_ra_configs, \"rdnss\");\n    if (rdnss) {\n        smap_add(&options, \"ipv6_ra_rdnss\", rdnss);\n    }\n    const char *dnssl = smap_get(&op->nbrp->ipv6_ra_configs, \"dnssl\");\n    if (dnssl) {\n        smap_add(&options, \"ipv6_ra_dnssl\", dnssl);\n    }\n\n    smap_add(&options, \"ipv6_ra_src_eth\", op->lrp_networks.ea_s);\n\n    const char *prf = smap_get(&op->nbrp->ipv6_ra_configs,\n                               \"router_preference\");\n    if (!prf || (strcmp(prf, \"HIGH\") && strcmp(prf, \"LOW\"))) {\n        smap_add(&options, \"ipv6_ra_prf\", \"MEDIUM\");\n    } else {\n        smap_add(&options, \"ipv6_ra_prf\", prf);\n    }\n\n    const char *route_info = smap_get(&op->nbrp->ipv6_ra_configs,\n                                      \"route_info\");\n    if (route_info) {\n        smap_add(&options, \"ipv6_ra_route_info\", route_info);\n    }\n\n    sbrec_port_binding_set_options(op->sb, &options);\n    smap_destroy(&options);\n}\n\nstatic inline bool\nlrouter_dnat_and_snat_is_stateless(const struct nbrec_nat *nat)\n{\n    return smap_get_bool(&nat->options, \"stateless\", false) &&\n           !strcmp(nat->type, \"dnat_and_snat\");\n}\n\n/* Handles the match criteria and actions in logical flow\n * based on external ip based NAT rule filter.\n *\n * For ALLOWED_EXT_IPs, we will add an additional match criteria\n * of comparing ip*.src/dst with the allowed external ip address set.\n *\n * For EXEMPTED_EXT_IPs, we will have an additional logical flow\n * where we compare ip*.src/dst with the exempted external ip address set\n * and action says \"next\" instead of ct*.\n */\nstatic inline void\nlrouter_nat_add_ext_ip_match(struct ovn_datapath *od,\n                             struct hmap *lflows, struct ds *match,\n                             const struct nbrec_nat *nat,\n                             bool is_v6, bool is_src, int cidr_bits)\n{\n    struct nbrec_address_set *allowed_ext_ips = nat->allowed_ext_ips;\n    struct nbrec_address_set *exempted_ext_ips = nat->exempted_ext_ips;\n\n    ovs_assert(allowed_ext_ips || exempted_ext_ips);\n\n    if (allowed_ext_ips) {\n        ds_put_format(match, \" && ip%s.%s == $%s\",\n                      is_v6 ? \"6\" : \"4\",\n                      is_src ? \"src\" : \"dst\",\n                      allowed_ext_ips->name);\n    } else if (exempted_ext_ips) {\n        struct ds match_exempt = DS_EMPTY_INITIALIZER;\n        enum ovn_stage stage = is_src ? S_ROUTER_IN_DNAT : S_ROUTER_OUT_SNAT;\n        uint16_t priority;\n\n        /* Priority of logical flows corresponding to exempted_ext_ips is\n         * +2 of the corresponding regular NAT rule.\n         * For example, if we have following NAT rule and we associate\n         * exempted external ips to it:\n         * \"ovn-nbctl lr-nat-add router dnat_and_snat 10.15.24.139 50.0.0.11\"\n         *\n         * And now we associate exempted external ip address set to it.\n         * Now corresponding to above rule we will have following logical\n         * flows:\n         * lr_out_snat...priority=163, match=(..ip4.dst == $exempt_range),\n         *                             action=(next;)\n         * lr_out_snat...priority=161, match=(..), action=(ct_snat(....);)\n         *\n         */\n        if (is_src) {\n            /* S_ROUTER_IN_DNAT uses priority 100 */\n            priority = 100 + 2;\n        } else {\n            /* S_ROUTER_OUT_SNAT uses priority (mask + 1 + 128 + 1) */\n            priority = cidr_bits + 3;\n\n            if (!od->is_gw_router) {\n                priority += 128;\n           }\n        }\n\n        ds_clone(&match_exempt, match);\n        ds_put_format(&match_exempt, \" && ip%s.%s == $%s\",\n                      is_v6 ? \"6\" : \"4\",\n                      is_src ? \"src\" : \"dst\",\n                      exempted_ext_ips->name);\n\n        ovn_lflow_add_with_hint(lflows, od, stage, priority,\n                                ds_cstr(&match_exempt), \"next;\",\n                                &nat->header_);\n        ds_destroy(&match_exempt);\n    }\n}\n\n/* Builds the logical flow that replies to ARP requests for an 'ip_address'\n * owned by the router. The flow is inserted in table S_ROUTER_IN_IP_INPUT\n * with the given priority.\n */\nstatic void\nbuild_lrouter_arp_flow(struct ovn_datapath *od, struct ovn_port *op,\n                       const char *ip_address, const char *eth_addr,\n                       struct ds *extra_match, bool drop, uint16_t priority,\n                       const struct ovsdb_idl_row *hint,\n                       struct hmap *lflows)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    if (op) {\n        ds_put_format(&match, \"inport == %s && \", op->json_key);\n    }\n\n    ds_put_format(&match, \"arp.op == 1 && arp.tpa == %s\", ip_address);\n\n    if (extra_match && ds_last(extra_match) != EOF) {\n        ds_put_format(&match, \" && %s\", ds_cstr(extra_match));\n    }\n    if (drop) {\n        ds_put_cstr(&actions, debug_drop_action());\n    } else {\n        ds_put_format(&actions,\n                      \"eth.dst = eth.src; \"\n                      \"eth.src = %s; \"\n                      \"arp.op = 2; /* ARP reply */ \"\n                      \"arp.tha = arp.sha; \"\n                      \"arp.sha = %s; \"\n                      \"arp.tpa <-> arp.spa; \"\n                      \"outport = inport; \"\n                      \"flags.loopback = 1; \"\n                      \"output;\",\n                      eth_addr,\n                      eth_addr);\n    }\n\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_INPUT, priority,\n                            ds_cstr(&match), ds_cstr(&actions), hint);\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\n/* Builds the logical flow that replies to NS requests for an 'ip_address'\n * owned by the router. The flow is inserted in table S_ROUTER_IN_IP_INPUT\n * with the given priority. If 'sn_ip_address' is non-NULL, requests are\n * restricted only to packets with IP destination 'ip_address' or\n * 'sn_ip_address'.\n */\nstatic void\nbuild_lrouter_nd_flow(struct ovn_datapath *od, struct ovn_port *op,\n                      const char *action, const char *ip_address,\n                      const char *sn_ip_address, const char *eth_addr,\n                      struct ds *extra_match, bool drop, uint16_t priority,\n                      const struct ovsdb_idl_row *hint,\n                      struct hmap *lflows, const struct shash *meter_groups)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n\n    if (op) {\n        ds_put_format(&match, \"inport == %s && \", op->json_key);\n    }\n\n    if (sn_ip_address) {\n        ds_put_format(&match, \"ip6.dst == {%s, %s} && \",\n                      ip_address, sn_ip_address);\n    }\n\n    ds_put_format(&match, \"nd_ns && nd.target == %s\", ip_address);\n\n    if (extra_match && ds_last(extra_match) != EOF) {\n        ds_put_format(&match, \" && %s\", ds_cstr(extra_match));\n    }\n\n    if (drop) {\n        ds_put_cstr(&actions, debug_drop_action());\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_INPUT, priority,\n                                ds_cstr(&match), ds_cstr(&actions), hint);\n    } else {\n        ds_put_format(&actions,\n                      \"%s { \"\n                        \"eth.src = %s; \"\n                        \"ip6.src = nd.target; \"\n                        \"nd.tll = %s; \"\n                        \"outport = inport; \"\n                        \"flags.loopback = 1; \"\n                        \"output; \"\n                      \"};\",\n                      action,\n                      eth_addr,\n                      eth_addr);\n        ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_IP_INPUT, priority,\n                                  ds_cstr(&match), ds_cstr(&actions), NULL,\n                                  copp_meter_get(COPP_ND_NA, od->nbr->copp,\n                                                 meter_groups),\n                                  hint);\n    }\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_lrouter_nat_arp_nd_flow(struct ovn_datapath *od,\n                              struct ovn_nat *nat_entry,\n                              struct hmap *lflows,\n                              const struct shash *meter_groups)\n{\n    struct lport_addresses *ext_addrs = &nat_entry->ext_addrs;\n    const struct nbrec_nat *nat = nat_entry->nb;\n\n    if (nat_entry_is_v6(nat_entry)) {\n        build_lrouter_nd_flow(od, NULL, \"nd_na\",\n                              ext_addrs->ipv6_addrs[0].addr_s,\n                              ext_addrs->ipv6_addrs[0].sn_addr_s,\n                              REG_INPORT_ETH_ADDR, NULL, false, 90,\n                              &nat->header_, lflows, meter_groups);\n    } else {\n        build_lrouter_arp_flow(od, NULL,\n                               ext_addrs->ipv4_addrs[0].addr_s,\n                               REG_INPORT_ETH_ADDR, NULL, false, 90,\n                               &nat->header_, lflows);\n    }\n}\n\nstatic void\nbuild_lrouter_port_nat_arp_nd_flow(struct ovn_port *op,\n                                   struct ovn_nat *nat_entry,\n                                   struct hmap *lflows,\n                                   const struct shash *meter_groups)\n{\n    struct lport_addresses *ext_addrs = &nat_entry->ext_addrs;\n    const struct nbrec_nat *nat = nat_entry->nb;\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    /* ARP/ND should be sent from distributed gateway port where the NAT rule\n     * will be applied. */\n    if (!is_nat_gateway_port(nat, op)) {\n        return;\n    }\n\n    /* Mac address to use when replying to ARP/NS. */\n    const char *mac_s = REG_INPORT_ETH_ADDR;\n    struct eth_addr mac;\n\n    if (nat->external_mac &&\n        eth_addr_from_string(nat->external_mac, &mac)\n        && nat->logical_port) {\n        /* distributed NAT case, use nat->external_mac */\n        mac_s = nat->external_mac;\n        /* Traffic with eth.src = nat->external_mac should only be\n         * sent from the chassis where nat->logical_port is\n         * resident, so that upstream MAC learning points to the\n         * correct chassis.  Also need to avoid generation of\n         * multiple ARP responses from different chassis. */\n        ds_put_format(&match, \"is_chassis_resident(\\\"%s\\\")\",\n                      nat->logical_port);\n    } else {\n        mac_s = REG_INPORT_ETH_ADDR;\n        /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s\n         * should only be sent from the gateway chassis, so that\n         * upstream MAC learning points to the gateway chassis.\n         * Also need to avoid generation of multiple ARP responses\n         * from different chassis. */\n        ovs_assert(is_l3dgw_port(op));\n        ds_put_format(&match, \"is_chassis_resident(%s)\",\n                      op->cr_port->json_key);\n    }\n\n    /* Respond to ARP/NS requests on the chassis that binds the gw\n     * port. Drop the ARP/NS requests on other chassis.\n     */\n    if (nat_entry_is_v6(nat_entry)) {\n        build_lrouter_nd_flow(op->od, op, \"nd_na\",\n                              ext_addrs->ipv6_addrs[0].addr_s,\n                              ext_addrs->ipv6_addrs[0].sn_addr_s,\n                              mac_s, &match, false, 92,\n                              &nat->header_, lflows, meter_groups);\n        build_lrouter_nd_flow(op->od, op, \"nd_na\",\n                              ext_addrs->ipv6_addrs[0].addr_s,\n                              ext_addrs->ipv6_addrs[0].sn_addr_s,\n                              mac_s, NULL, true, 91,\n                              &nat->header_, lflows, meter_groups);\n    } else {\n        build_lrouter_arp_flow(op->od, op,\n                               ext_addrs->ipv4_addrs[0].addr_s,\n                               mac_s, &match, false, 92,\n                               &nat->header_, lflows);\n        build_lrouter_arp_flow(op->od, op,\n                               ext_addrs->ipv4_addrs[0].addr_s,\n                               mac_s, NULL, true, 91,\n                               &nat->header_, lflows);\n    }\n\n    ds_destroy(&match);\n}\n\nstatic void\nbuild_lrouter_drop_own_dest(struct ovn_port *op, enum ovn_stage stage,\n                            uint16_t priority, bool drop_snat_ip,\n                            struct hmap *lflows)\n{\n    struct ds match_ips = DS_EMPTY_INITIALIZER;\n\n    if (op->lrp_networks.n_ipv4_addrs) {\n        for (size_t i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            const char *ip = op->lrp_networks.ipv4_addrs[i].addr_s;\n\n            bool router_ip_in_snat_ips = !!shash_find(&op->od->snat_ips, ip);\n            bool router_ip_in_lb_ips =\n                    !!sset_find(&op->od->lb_ips->ips_v4, ip);\n            bool drop_router_ip = (drop_snat_ip == (router_ip_in_snat_ips ||\n                                                    router_ip_in_lb_ips));\n\n            if (drop_router_ip) {\n                ds_put_format(&match_ips, \"%s, \", ip);\n            }\n        }\n\n        if (ds_last(&match_ips) != EOF) {\n            ds_chomp(&match_ips, ' ');\n            ds_chomp(&match_ips, ',');\n\n            char *match = xasprintf(\"ip4.dst == {%s}\", ds_cstr(&match_ips));\n            ovn_lflow_add_with_hint(lflows, op->od, stage, priority,\n                                    match, debug_drop_action(),\n                                    &op->nbrp->header_);\n            free(match);\n        }\n    }\n\n    if (op->lrp_networks.n_ipv6_addrs) {\n        ds_clear(&match_ips);\n\n        for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n            const char *ip = op->lrp_networks.ipv6_addrs[i].addr_s;\n\n            bool router_ip_in_snat_ips = !!shash_find(&op->od->snat_ips, ip);\n            bool router_ip_in_lb_ips =\n                    !!sset_find(&op->od->lb_ips->ips_v6, ip);\n            bool drop_router_ip = (drop_snat_ip == (router_ip_in_snat_ips ||\n                                                    router_ip_in_lb_ips));\n\n            if (drop_router_ip) {\n                ds_put_format(&match_ips, \"%s, \", ip);\n            }\n        }\n\n        if (ds_last(&match_ips) != EOF) {\n            ds_chomp(&match_ips, ' ');\n            ds_chomp(&match_ips, ',');\n\n            char *match = xasprintf(\"ip6.dst == {%s}\", ds_cstr(&match_ips));\n            ovn_lflow_add_with_hint(lflows, op->od, stage, priority,\n                                    match, debug_drop_action(),\n                                    &op->nbrp->header_);\n            free(match);\n        }\n    }\n    ds_destroy(&match_ips);\n}\n\nstatic void\nbuild_lrouter_force_snat_flows(struct hmap *lflows, struct ovn_datapath *od,\n                               const char *ip_version, const char *ip_addr,\n                               const char *context)\n{\n    struct ds match = DS_EMPTY_INITIALIZER;\n    struct ds actions = DS_EMPTY_INITIALIZER;\n    ds_put_format(&match, \"ip%s && ip%s.dst == %s\",\n                  ip_version, ip_version, ip_addr);\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_UNSNAT, 110,\n                  ds_cstr(&match), \"ct_snat;\");\n\n    /* Higher priority rules to force SNAT with the IP addresses\n     * configured in the Gateway router.  This only takes effect\n     * when the packet has already been DNATed or load balanced once. */\n    ds_clear(&match);\n    ds_put_format(&match, \"flags.force_snat_for_%s == 1 && ip%s\",\n                  context, ip_version);\n    ds_put_format(&actions, \"ct_snat(%s);\", ip_addr);\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_SNAT, 100,\n                  ds_cstr(&match), ds_cstr(&actions));\n\n    ds_destroy(&match);\n    ds_destroy(&actions);\n}\n\nstatic void\nbuild_lrouter_force_snat_flows_op(struct ovn_port *op,\n                                  struct hmap *lflows,\n                                  struct ds *match, struct ds *actions)\n{\n    if (!op->nbrp || !op->peer || !op->od->lb_force_snat_router_ip) {\n        return;\n    }\n\n    if (op->lrp_networks.n_ipv4_addrs) {\n        ds_clear(match);\n        ds_clear(actions);\n\n        ds_put_format(match, \"inport == %s && ip4.dst == %s\",\n                      op->json_key, op->lrp_networks.ipv4_addrs[0].addr_s);\n        ovn_lflow_add(lflows, op->od, S_ROUTER_IN_UNSNAT, 110,\n                      ds_cstr(match), \"ct_snat;\");\n\n        ds_clear(match);\n\n        /* Higher priority rules to force SNAT with the router port ip.\n         * This only takes effect when the packet has already been\n         * load balanced once. */\n        ds_put_format(match, \"flags.force_snat_for_lb == 1 && ip4 && \"\n                      \"outport == %s\", op->json_key);\n        ds_put_format(actions, \"ct_snat(%s);\",\n                      op->lrp_networks.ipv4_addrs[0].addr_s);\n        ovn_lflow_add(lflows, op->od, S_ROUTER_OUT_SNAT, 110,\n                      ds_cstr(match), ds_cstr(actions));\n        if (op->lrp_networks.n_ipv4_addrs > 1) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n            VLOG_WARN_RL(&rl, \"Logical router port %s is configured with \"\n                              \"multiple IPv4 addresses.  Only the first \"\n                              \"IP [%s] is considered as SNAT for load \"\n                              \"balancer\", op->json_key,\n                              op->lrp_networks.ipv4_addrs[0].addr_s);\n        }\n    }\n\n    /* op->lrp_networks.ipv6_addrs will always have LLA and that will be\n     * last in the list. So add the flows only if n_ipv6_addrs > 1. */\n    if (op->lrp_networks.n_ipv6_addrs > 1) {\n        ds_clear(match);\n        ds_clear(actions);\n\n        ds_put_format(match, \"inport == %s && ip6.dst == %s\",\n                      op->json_key, op->lrp_networks.ipv6_addrs[0].addr_s);\n        ovn_lflow_add(lflows, op->od, S_ROUTER_IN_UNSNAT, 110,\n                      ds_cstr(match), \"ct_snat;\");\n\n        ds_clear(match);\n\n        /* Higher priority rules to force SNAT with the router port ip.\n         * This only takes effect when the packet has already been\n         * load balanced once. */\n        ds_put_format(match, \"flags.force_snat_for_lb == 1 && ip6 && \"\n                      \"outport == %s\", op->json_key);\n        ds_put_format(actions, \"ct_snat(%s);\",\n                      op->lrp_networks.ipv6_addrs[0].addr_s);\n        ovn_lflow_add(lflows, op->od, S_ROUTER_OUT_SNAT, 110,\n                      ds_cstr(match), ds_cstr(actions));\n        if (op->lrp_networks.n_ipv6_addrs > 2) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n            VLOG_WARN_RL(&rl, \"Logical router port %s is configured with \"\n                              \"multiple IPv6 addresses.  Only the first \"\n                              \"IP [%s] is considered as SNAT for load \"\n                              \"balancer\", op->json_key,\n                              op->lrp_networks.ipv6_addrs[0].addr_s);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_bfd_flows(struct hmap *lflows, struct ovn_port *op,\n                        const struct shash *meter_groups)\n{\n    if (!op->has_bfd) {\n        return;\n    }\n\n    struct ds ip_list = DS_EMPTY_INITIALIZER;\n    struct ds match = DS_EMPTY_INITIALIZER;\n\n    if (op->lrp_networks.n_ipv4_addrs) {\n        op_put_v4_networks(&ip_list, op, false);\n        ds_put_format(&match, \"ip4.src == %s && udp.dst == 3784\",\n                      ds_cstr(&ip_list));\n        ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 110,\n                                ds_cstr(&match), \"next; \",\n                                &op->nbrp->header_);\n        ds_clear(&match);\n        ds_put_format(&match, \"ip4.dst == %s && udp.dst == 3784\",\n                      ds_cstr(&ip_list));\n        ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT, 110,\n                                  ds_cstr(&match), \"handle_bfd_msg(); \", NULL,\n                                  copp_meter_get(COPP_BFD, op->od->nbr->copp,\n                                                 meter_groups),\n                                  &op->nbrp->header_);\n    }\n    if (op->lrp_networks.n_ipv6_addrs) {\n        ds_clear(&ip_list);\n        ds_clear(&match);\n\n        op_put_v6_networks(&ip_list, op);\n        ds_put_format(&match, \"ip6.src == %s && udp.dst == 3784\",\n                      ds_cstr(&ip_list));\n        ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 110,\n                                ds_cstr(&match), \"next; \",\n                                &op->nbrp->header_);\n        ds_clear(&match);\n        ds_put_format(&match, \"ip6.dst == %s && udp.dst == 3784\",\n                      ds_cstr(&ip_list));\n        ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT, 110,\n                                  ds_cstr(&match), \"handle_bfd_msg(); \", NULL,\n                                  copp_meter_get(COPP_BFD, op->od->nbr->copp,\n                                                 meter_groups),\n                                  &op->nbrp->header_);\n    }\n\n    ds_destroy(&ip_list);\n    ds_destroy(&match);\n}\n\n/* Logical router ingress Table 0: L2 Admission Control\n * Generic admission control flows (without inport check).\n */\nstatic void\nbuild_adm_ctrl_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (od->nbr) {\n        /* Logical VLANs not supported.\n         * Broadcast/multicast source address is invalid. */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ADMISSION, 100,\n                      \"vlan.present || eth.src[40]\", debug_drop_action());\n\n        /* Default action for L2 security is to drop. */\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_ADMISSION);\n    }\n}\n\nstatic int\nbuild_gateway_get_l2_hdr_size(struct ovn_port *op)\n{\n    struct ovn_port *peer = op->peer;\n\n    if (peer && peer->od && peer->od->nbs) {\n        /* Check if vlans are enabled on a localnet port running the logical\n         * switch connected to this logical router.\n         */\n        for (size_t i = 0; i < peer->od->n_localnet_ports; i++) {\n            struct ovn_port *localnet_port = peer->od->localnet_ports[i];\n            const struct nbrec_logical_switch_port *nbsp = localnet_port->nbsp;\n\n            if (nbsp && nbsp->n_tag_request > 0) {\n                return VLAN_ETH_HEADER_LEN;\n            }\n        }\n    }\n\n    return ETH_HEADER_LEN;\n}\n\n/* All 'gateway_mtu' and 'gateway_mtu_bypass' flows should be built with this\n * function.\n */\nstatic void OVS_PRINTF_FORMAT(9, 10)\nbuild_gateway_mtu_flow(struct hmap *lflows, struct ovn_port *op,\n                       enum ovn_stage stage, uint16_t prio_low,\n                       uint16_t prio_high, struct ds *match,\n                       struct ds *actions, const struct ovsdb_idl_row *hint,\n                       const char *extra_actions_fmt, ...)\n{\n    int gw_mtu = smap_get_int(&op->nbrp->options, \"gateway_mtu\", 0);\n\n    va_list extra_actions_args;\n    va_start(extra_actions_args, extra_actions_fmt);\n\n    ds_clear(actions);\n    if (gw_mtu > 0) {\n        int l2_hdr_size = build_gateway_get_l2_hdr_size(op);\n        ds_put_format(actions, REGBIT_PKT_LARGER\" = check_pkt_larger(%d); \",\n                      gw_mtu + l2_hdr_size);\n    }\n\n    ds_put_format_valist(actions, extra_actions_fmt, extra_actions_args);\n    ovn_lflow_add_with_hint(lflows, op->od, stage, prio_low,\n                            ds_cstr(match), ds_cstr(actions),\n                            hint);\n\n    if (gw_mtu > 0) {\n        const char *gw_mtu_bypass = smap_get(&op->nbrp->options,\n                                             \"gateway_mtu_bypass\");\n        if (gw_mtu_bypass) {\n            ds_clear(actions);\n            ds_put_format_valist(actions, extra_actions_fmt,\n                                 extra_actions_args);\n            ds_put_format(match, \" && (%s)\", gw_mtu_bypass);\n            ovn_lflow_add_with_hint(lflows, op->od, stage, prio_high,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    hint);\n        }\n    }\n    va_end(extra_actions_args);\n}\n\nstatic bool\nconsider_l3dgw_port_is_centralized(struct ovn_port *op)\n{\n    if (l3dgw_port_has_associated_vtep_lports(op)) {\n        return false;\n    }\n\n    if (is_l3dgw_port(op)) {\n        /* Traffic with eth.dst = l3dgw_port->lrp_networks.ea_s\n         * should only be received on the gateway chassis. */\n        return true;\n    }\n\n    return false;\n}\n\n/* Logical router ingress Table 0: L2 Admission Control\n * This table drops packets that the router shouldn\u2019t see at all based\n * on their Ethernet headers.\n */\nstatic void\nbuild_adm_ctrl_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match, struct ds *actions)\n{\n    if (op->nbrp) {\n        if (!lrport_is_enabled(op->nbrp)) {\n            /* Drop packets from disabled logical ports (since logical flow\n             * tables are default-drop). */\n            return;\n        }\n\n        if (is_cr_port(op)) {\n            /* No ingress packets should be received on a chassisredirect\n             * port. */\n            return;\n        }\n\n        /* Store the ethernet address of the port receiving the packet.\n         * This will save us from having to match on inport further down in\n         * the pipeline.\n         */\n        ds_clear(match);\n        ds_put_format(match, \"eth.mcast && inport == %s\", op->json_key);\n        build_gateway_mtu_flow(lflows, op, S_ROUTER_IN_ADMISSION, 50, 55,\n                               match, actions, &op->nbrp->header_,\n                               REG_INPORT_ETH_ADDR \" = %s; next;\",\n                               op->lrp_networks.ea_s);\n\n        ds_clear(match);\n        ds_put_format(match, \"eth.dst == %s && inport == %s\",\n                      op->lrp_networks.ea_s, op->json_key);\n        if (consider_l3dgw_port_is_centralized(op)) {\n            ds_put_format(match, \" && is_chassis_resident(%s)\",\n                          op->cr_port->json_key);\n        }\n        build_gateway_mtu_flow(lflows, op, S_ROUTER_IN_ADMISSION, 50, 55,\n                               match, actions, &op->nbrp->header_,\n                               REG_INPORT_ETH_ADDR \" = %s; next;\",\n                               op->lrp_networks.ea_s);\n    }\n}\n\n\n/* Logical router ingress Table 1 and 2: Neighbor lookup and learning\n * lflows for logical routers. */\nstatic void\nbuild_neigh_learning_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        struct ds *match, struct ds *actions,\n        const struct shash *meter_groups)\n{\n    if (od->nbr) {\n\n        /* Learn MAC bindings from ARP/IPv6 ND.\n         *\n         * For ARP packets, table LOOKUP_NEIGHBOR does a lookup for the\n         * (arp.spa, arp.sha) in the mac binding table using the 'lookup_arp'\n         * action and stores the result in REGBIT_LOOKUP_NEIGHBOR_RESULT bit.\n         * If \"always_learn_from_arp_request\" is set to false, it will also\n         * lookup for the (arp.spa) in the mac binding table using the\n         * \"lookup_arp_ip\" action for ARP request packets, and stores the\n         * result in REGBIT_LOOKUP_NEIGHBOR_IP_RESULT bit; or set that bit\n         * to \"1\" directly for ARP response packets.\n         *\n         * For IPv6 ND NA packets, table LOOKUP_NEIGHBOR does a lookup\n         * for the (nd.target, nd.tll) in the mac binding table using the\n         * 'lookup_nd' action and stores the result in\n         * REGBIT_LOOKUP_NEIGHBOR_RESULT bit. If\n         * \"always_learn_from_arp_request\" is set to false,\n         * REGBIT_LOOKUP_NEIGHBOR_IP_RESULT bit is set.\n         *\n         * For IPv6 ND NS packets, table LOOKUP_NEIGHBOR does a lookup\n         * for the (ip6.src, nd.sll) in the mac binding table using the\n         * 'lookup_nd' action and stores the result in\n         * REGBIT_LOOKUP_NEIGHBOR_RESULT bit. If\n         * \"always_learn_from_arp_request\" is set to false, it will also lookup\n         * for the (ip6.src) in the mac binding table using the \"lookup_nd_ip\"\n         * action and stores the result in REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\n         * bit.\n         *\n         * Table LEARN_NEIGHBOR learns the mac-binding using the action\n         * - 'put_arp/put_nd'. Learning mac-binding is skipped if\n         *   REGBIT_LOOKUP_NEIGHBOR_RESULT bit is set or\n         *   REGBIT_LOOKUP_NEIGHBOR_IP_RESULT is not set.\n         *\n         * */\n\n        /* Flows for LOOKUP_NEIGHBOR. */\n        bool learn_from_arp_request = smap_get_bool(&od->nbr->options,\n            \"always_learn_from_arp_request\", true);\n        ds_clear(actions);\n        ds_put_format(actions, REGBIT_LOOKUP_NEIGHBOR_RESULT\n                      \" = lookup_arp(inport, arp.spa, arp.sha); %snext;\",\n                      learn_from_arp_request ? \"\" :\n                      REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\" = 1; \");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LOOKUP_NEIGHBOR, 100,\n                      \"arp.op == 2\", ds_cstr(actions));\n\n        ds_clear(actions);\n        ds_put_format(actions, REGBIT_LOOKUP_NEIGHBOR_RESULT\n                      \" = lookup_nd(inport, nd.target, nd.tll); %snext;\",\n                      learn_from_arp_request ? \"\" :\n                      REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\" = 1; \");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LOOKUP_NEIGHBOR, 100, \"nd_na\",\n                      ds_cstr(actions));\n\n        if (!learn_from_arp_request) {\n            /* Add flow to skip GARP LLA if we don't know it already.\n             * From RFC 2461, section 4.4, Neighbor Advertisement Message\n             * Format, the Destination Address should be:\n             *   For solicited advertisements, the Source Address of\n             *   an invoking Neighbor Solicitation or, if the\n             *   solicitation's Source Address is the unspecified\n             *   address, the all-nodes multicast address. */\n            ds_clear(actions);\n            ds_put_format(actions, REGBIT_LOOKUP_NEIGHBOR_RESULT\n                                   \" = lookup_nd(inport, ip6.src, nd.tll); \"\n                                   REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\n                                   \" = lookup_nd_ip(inport, ip6.src); next;\");\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_LOOKUP_NEIGHBOR, 110,\n                          \"nd_na && ip6.src == fe80::/10 \"\n                          \"&& ip6.dst == ff00::/8\",\n                          ds_cstr(actions));\n        }\n\n        ds_clear(actions);\n        ds_put_format(actions, REGBIT_LOOKUP_NEIGHBOR_RESULT\n                      \" = lookup_nd(inport, ip6.src, nd.sll); %snext;\",\n                      learn_from_arp_request ? \"\" :\n                      REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\n                      \" = lookup_nd_ip(inport, ip6.src); \");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LOOKUP_NEIGHBOR, 100, \"nd_ns\",\n                      ds_cstr(actions));\n\n        /* For other packet types, we can skip neighbor learning.\n         * So set REGBIT_LOOKUP_NEIGHBOR_RESULT to 1. */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LOOKUP_NEIGHBOR, 0, \"1\",\n                      REGBIT_LOOKUP_NEIGHBOR_RESULT\" = 1; next;\");\n\n        /* Flows for LEARN_NEIGHBOR. */\n        /* Skip Neighbor learning if not required. */\n        ds_clear(match);\n        ds_put_format(match, REGBIT_LOOKUP_NEIGHBOR_RESULT\" == 1%s\",\n                      learn_from_arp_request ? \"\" :\n                      \" || \"REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\" == 0\");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 100,\n                      ds_cstr(match), \"next;\");\n\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 90,\n                          \"arp\", \"put_arp(inport, arp.spa, arp.sha); next;\",\n                          copp_meter_get(COPP_ARP, od->nbr->copp,\n                                         meter_groups));\n\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 95,\n                      \"nd_ns && (ip6.src == 0 || nd.sll == 0)\", \"next;\");\n\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 95,\n                          \"nd_na && nd.tll == 0\",\n                          \"put_nd(inport, nd.target, eth.src); next;\",\n                          copp_meter_get(COPP_ND_NA, od->nbr->copp,\n                                         meter_groups));\n\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 90,\n                          \"nd_na\", \"put_nd(inport, nd.target, nd.tll); next;\",\n                          copp_meter_get(COPP_ND_NA, od->nbr->copp,\n                                         meter_groups));\n\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR, 90,\n                          \"nd_ns\", \"put_nd(inport, ip6.src, nd.sll); next;\",\n                          copp_meter_get(COPP_ND_NS, od->nbr->copp,\n                                         meter_groups));\n\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_LEARN_NEIGHBOR);\n    }\n\n}\n\n/* Logical router ingress Table 1: Neighbor lookup lflows\n * for logical router ports. */\nstatic void\nbuild_neigh_learning_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match, struct ds *actions)\n{\n    if (op->nbrp) {\n\n        bool learn_from_arp_request = smap_get_bool(&op->od->nbr->options,\n            \"always_learn_from_arp_request\", true);\n\n        /* Check if we need to learn mac-binding from ARP requests. */\n        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            if (!learn_from_arp_request) {\n                /* ARP request to this address should always get learned,\n                 * so add a priority-110 flow to set\n                 * REGBIT_LOOKUP_NEIGHBOR_IP_RESULT to 1. */\n                ds_clear(match);\n                ds_put_format(match,\n                              \"inport == %s && arp.spa == %s/%u && \"\n                              \"arp.tpa == %s && arp.op == 1\",\n                              op->json_key,\n                              op->lrp_networks.ipv4_addrs[i].network_s,\n                              op->lrp_networks.ipv4_addrs[i].plen,\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n                if (is_l3dgw_port(op)) {\n                    ds_put_format(match, \" && is_chassis_resident(%s)\",\n                                  op->cr_port->json_key);\n                }\n                const char *actions_s = REGBIT_LOOKUP_NEIGHBOR_RESULT\n                                  \" = lookup_arp(inport, arp.spa, arp.sha); \"\n                                  REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\" = 1;\"\n                                  \" next;\";\n                ovn_lflow_add_with_hint(lflows, op->od,\n                                        S_ROUTER_IN_LOOKUP_NEIGHBOR, 110,\n                                        ds_cstr(match), actions_s,\n                                        &op->nbrp->header_);\n            }\n            ds_clear(match);\n            ds_put_format(match,\n                          \"inport == %s && arp.spa == %s/%u && arp.op == 1\",\n                          op->json_key,\n                          op->lrp_networks.ipv4_addrs[i].network_s,\n                          op->lrp_networks.ipv4_addrs[i].plen);\n            if (is_l3dgw_port(op)) {\n                ds_put_format(match, \" && is_chassis_resident(%s)\",\n                              op->cr_port->json_key);\n            }\n            ds_clear(actions);\n            ds_put_format(actions, REGBIT_LOOKUP_NEIGHBOR_RESULT\n                          \" = lookup_arp(inport, arp.spa, arp.sha); %snext;\",\n                          learn_from_arp_request ? \"\" :\n                          REGBIT_LOOKUP_NEIGHBOR_IP_RESULT\n                          \" = lookup_arp_ip(inport, arp.spa); \");\n            ovn_lflow_add_with_hint(lflows, op->od,\n                                    S_ROUTER_IN_LOOKUP_NEIGHBOR, 100,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &op->nbrp->header_);\n        }\n    }\n}\n\n/* Logical router ingress table ND_RA_OPTIONS & ND_RA_RESPONSE: IPv6 Router\n * Adv (RA) options and response. */\nstatic void\nbuild_ND_RA_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match, struct ds *actions,\n        const struct shash *meter_groups)\n{\n    if (!op->nbrp || op->nbrp->peer || !op->peer) {\n        return;\n    }\n\n    if (!op->lrp_networks.n_ipv6_addrs) {\n        return;\n    }\n\n    const char *address_mode = smap_get(\n        &op->nbrp->ipv6_ra_configs, \"address_mode\");\n\n    if (!address_mode) {\n        return;\n    }\n    if (strcmp(address_mode, \"slaac\") &&\n        strcmp(address_mode, \"dhcpv6_stateful\") &&\n        strcmp(address_mode, \"dhcpv6_stateless\")) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);\n        VLOG_WARN_RL(&rl, \"Invalid address mode [%s] defined\",\n                     address_mode);\n        return;\n    }\n\n    ds_clear(match);\n    ds_put_format(match, \"inport == %s && ip6.dst == ff02::2 && nd_rs\",\n                          op->json_key);\n    ds_clear(actions);\n\n    const char *mtu_s = smap_get(\n        &op->nbrp->ipv6_ra_configs, \"mtu\");\n\n    /* As per RFC 2460, 1280 is minimum IPv6 MTU. */\n    uint32_t mtu = (mtu_s && atoi(mtu_s) >= 1280) ? atoi(mtu_s) : 0;\n\n    ds_put_format(actions, REGBIT_ND_RA_OPTS_RESULT\" = put_nd_ra_opts(\"\n                  \"addr_mode = \\\"%s\\\", slla = %s\",\n                  address_mode, op->lrp_networks.ea_s);\n    if (mtu > 0) {\n        ds_put_format(actions, \", mtu = %u\", mtu);\n    }\n\n    const char *prf = smap_get_def(\n        &op->nbrp->ipv6_ra_configs, \"router_preference\", \"MEDIUM\");\n    if (strcmp(prf, \"MEDIUM\")) {\n        ds_put_format(actions, \", router_preference = \\\"%s\\\"\", prf);\n    }\n\n    const char *ra_rdnss = smap_get(&op->nbrp->ipv6_ra_configs, \"rdnss\");\n    if (ra_rdnss) {\n        ds_put_format(actions, \", rdnss = %s\", ra_rdnss);\n    }\n\n    const char *ra_dnssl = smap_get(&op->nbrp->ipv6_ra_configs, \"dnssl\");\n    if (ra_dnssl) {\n        ds_put_format(actions, \", dnssl = \\\"%s\\\"\", ra_dnssl);\n    }\n\n    const char *route_info = smap_get(&op->nbrp->ipv6_ra_configs,\n                                      \"route_info\");\n    if (route_info) {\n        ds_put_format(actions, \", route_info = \\\"%s\\\"\", route_info);\n    }\n\n    bool add_rs_response_flow = false;\n\n    for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n        if (in6_is_lla(&op->lrp_networks.ipv6_addrs[i].network)) {\n            continue;\n        }\n\n        ds_put_format(actions, \", prefix = %s/%u\",\n                      op->lrp_networks.ipv6_addrs[i].network_s,\n                      op->lrp_networks.ipv6_addrs[i].plen);\n\n        add_rs_response_flow = true;\n    }\n\n    if (add_rs_response_flow) {\n        ds_put_cstr(actions, \"); next;\");\n        ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_ND_RA_OPTIONS,\n                                  50, ds_cstr(match), ds_cstr(actions), NULL,\n                                  copp_meter_get(COPP_ND_RA_OPTS,\n                                                 op->od->nbr->copp,\n                                                 meter_groups),\n                                  &op->nbrp->header_);\n        ds_clear(actions);\n        ds_clear(match);\n        ds_put_format(match, \"inport == %s && ip6.dst == ff02::2 && \"\n                      \"nd_ra && \"REGBIT_ND_RA_OPTS_RESULT, op->json_key);\n\n        char ip6_str[INET6_ADDRSTRLEN + 1];\n        struct in6_addr lla;\n        in6_generate_lla(op->lrp_networks.ea, &lla);\n        memset(ip6_str, 0, sizeof(ip6_str));\n        ipv6_string_mapped(ip6_str, &lla);\n        ds_put_format(actions, \"eth.dst = eth.src; eth.src = %s; \"\n                      \"ip6.dst = ip6.src; ip6.src = %s; \"\n                      \"outport = inport; flags.loopback = 1; \"\n                      \"output;\",\n                      op->lrp_networks.ea_s, ip6_str);\n        ovn_lflow_add_with_hint(lflows, op->od,\n                                S_ROUTER_IN_ND_RA_RESPONSE, 50,\n                                ds_cstr(match), ds_cstr(actions),\n                                &op->nbrp->header_);\n    }\n}\n\n/* Logical router ingress table ND_RA_OPTIONS & ND_RA_RESPONSE: RS\n * responder, by default goto next. (priority 0). */\nstatic void\nbuild_ND_RA_flows_for_lrouter(struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (od->nbr) {\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ND_RA_OPTIONS, 0, \"1\", \"next;\");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ND_RA_RESPONSE, 0, \"1\", \"next;\");\n    }\n}\n\n/* Logical router ingress table IP_ROUTING_PRE:\n * by default goto next. (priority 0). */\nstatic void\nbuild_ip_routing_pre_flows_for_lrouter(struct ovn_datapath *od,\n                                       struct hmap *lflows)\n{\n    if (od->nbr) {\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING_PRE, 0, \"1\",\n                      REG_ROUTE_TABLE_ID\" = 0; next;\");\n    }\n}\n\n/* Logical router ingress table IP_ROUTING : IP Routing.\n *\n * A packet that arrives at this table is an IP packet that should be\n * routed to the address in 'ip[46].dst'.\n *\n * For regular routes without ECMP, table IP_ROUTING sets outport to the\n * correct output port, eth.src to the output port's MAC address, and\n * REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6 to the next-hop IP address\n * (leaving 'ip[46].dst', the packet\u2019s final destination, unchanged), and\n * advances to the next table.\n *\n * For ECMP routes, i.e. multiple routes with same policy and prefix, table\n * IP_ROUTING remembers ECMP group id and selects a member id, and advances\n * to table IP_ROUTING_ECMP, which sets outport, eth.src and\n * REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6 for the selected ECMP member.\n */\nstatic void\nbuild_ip_routing_flows_for_lrouter_port(\n        struct ovn_port *op, const struct hmap *ports, struct hmap *lflows)\n{\n    if (op->nbrp) {\n\n        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            add_route(lflows, op->od, op, op->lrp_networks.ipv4_addrs[i].addr_s,\n                      op->lrp_networks.ipv4_addrs[i].network_s,\n                      op->lrp_networks.ipv4_addrs[i].plen, NULL, false, 0,\n                      &op->nbrp->header_, false, ROUTE_PRIO_OFFSET_CONNECTED);\n        }\n\n        for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n            add_route(lflows, op->od, op, op->lrp_networks.ipv6_addrs[i].addr_s,\n                      op->lrp_networks.ipv6_addrs[i].network_s,\n                      op->lrp_networks.ipv6_addrs[i].plen, NULL, false, 0,\n                      &op->nbrp->header_, false, ROUTE_PRIO_OFFSET_CONNECTED);\n        }\n    } else if (lsp_is_router(op->nbsp)) {\n        struct ovn_port *peer = ovn_port_get_peer(ports, op);\n        if (!peer || !peer->nbrp || !peer->lrp_networks.n_ipv4_addrs) {\n            return;\n        }\n\n        for (int i = 0; i < op->od->n_router_ports; i++) {\n            struct ovn_port *router_port = ovn_port_get_peer(\n                    ports, op->od->router_ports[i]);\n            if (!router_port || !router_port->nbrp || router_port == peer) {\n                continue;\n            }\n\n            struct ovn_port_routable_addresses *ra = &router_port->routables;\n            for (size_t j = 0; j < ra->n_addrs; j++) {\n                struct lport_addresses *laddrs = &ra->laddrs[j];\n                for (size_t k = 0; k < laddrs->n_ipv4_addrs; k++) {\n                    add_route(lflows, peer->od, peer,\n                              peer->lrp_networks.ipv4_addrs[0].addr_s,\n                              laddrs->ipv4_addrs[k].network_s,\n                              laddrs->ipv4_addrs[k].plen, NULL, false, 0,\n                              &peer->nbrp->header_, false,\n                              ROUTE_PRIO_OFFSET_CONNECTED);\n                }\n            }\n        }\n    }\n}\n\nstatic void\nbuild_static_route_flows_for_lrouter(\n        struct ovn_datapath *od, const struct chassis_features *features,\n        struct hmap *lflows, const struct hmap *ports,\n        const struct hmap *bfd_connections)\n{\n    if (od->nbr) {\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_IP_ROUTING_ECMP);\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_IP_ROUTING);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING_ECMP, 150,\n                      REG_ECMP_GROUP_ID\" == 0\", \"next;\");\n\n        struct hmap ecmp_groups = HMAP_INITIALIZER(&ecmp_groups);\n        struct hmap unique_routes = HMAP_INITIALIZER(&unique_routes);\n        struct ovs_list parsed_routes = OVS_LIST_INITIALIZER(&parsed_routes);\n        struct simap route_tables = SIMAP_INITIALIZER(&route_tables);\n        struct ecmp_groups_node *group;\n\n        for (int i = 0; i < od->nbr->n_ports; i++) {\n            build_route_table_lflow(od, lflows, od->nbr->ports[i],\n                                    &route_tables);\n        }\n\n        for (int i = 0; i < od->nbr->n_static_routes; i++) {\n            struct parsed_route *route =\n                parsed_routes_add(od, ports, &parsed_routes, &route_tables,\n                                  od->nbr->static_routes[i], bfd_connections);\n            if (!route) {\n                continue;\n            }\n            group = ecmp_groups_find(&ecmp_groups, route);\n            if (group) {\n                ecmp_groups_add_route(group, route);\n            } else {\n                const struct parsed_route *existed_route =\n                    unique_routes_remove(&unique_routes, route);\n                if (existed_route) {\n                    group = ecmp_groups_add(&ecmp_groups, existed_route);\n                    if (group) {\n                        ecmp_groups_add_route(group, route);\n                    }\n                } else {\n                    unique_routes_add(&unique_routes, route);\n                }\n            }\n        }\n        HMAP_FOR_EACH (group, hmap_node, &ecmp_groups) {\n            /* add a flow in IP_ROUTING, and one flow for each member in\n             * IP_ROUTING_ECMP. */\n            build_ecmp_route_flow(lflows, od, features->ct_no_masked_label,\n                                  ports, group);\n        }\n        const struct unique_routes_node *ur;\n        HMAP_FOR_EACH (ur, hmap_node, &unique_routes) {\n            build_static_route_flow(lflows, od, ports, ur->route);\n        }\n        ecmp_groups_destroy(&ecmp_groups);\n        unique_routes_destroy(&unique_routes);\n        parsed_routes_destroy(&parsed_routes);\n        simap_destroy(&route_tables);\n    }\n}\n\n/* IP Multicast lookup. Here we set the output port, adjust TTL and\n * advance to next table (priority 500).\n */\nstatic void\nbuild_mcast_lookup_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        struct ds *match, struct ds *actions)\n{\n    if (od->nbr) {\n\n        /* Drop IPv6 multicast traffic that shouldn't be forwarded,\n         * i.e., router solicitation and router advertisement.\n         */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10550,\n                      \"nd_rs || nd_ra\", debug_drop_action());\n        if (!od->mcast_info.rtr.relay) {\n            return;\n        }\n\n        struct ovn_igmp_group *igmp_group;\n\n        LIST_FOR_EACH (igmp_group, list_node, &od->mcast_info.groups) {\n            ds_clear(match);\n            ds_clear(actions);\n            if (IN6_IS_ADDR_V4MAPPED(&igmp_group->address)) {\n                ds_put_format(match, \"ip4 && ip4.dst == %s \",\n                            igmp_group->mcgroup.name);\n            } else {\n                ds_put_format(match, \"ip6 && ip6.dst == %s \",\n                            igmp_group->mcgroup.name);\n            }\n            if (od->mcast_info.rtr.flood_static) {\n                ds_put_cstr(actions,\n                            \"clone { \"\n                                \"outport = \\\"\"MC_STATIC\"\\\"; \"\n                                \"ip.ttl--; \"\n                                \"next; \"\n                            \"};\");\n            }\n            ds_put_format(actions, \"outport = \\\"%s\\\"; ip.ttl--; next;\",\n                          igmp_group->mcgroup.name);\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10500,\n                          ds_cstr(match), ds_cstr(actions));\n        }\n\n        /* If needed, flood unregistered multicast on statically configured\n         * ports. Otherwise drop any multicast traffic.\n         */\n        if (od->mcast_info.rtr.flood_static) {\n            /* MLD and IGMP packets that need to be flooded statically\n             * should be flooded without decrementing TTL (it's always\n             * 1).  To prevent packets looping for ever (to some extent),\n             * drop IGMP/MLD packets that are received from the router's\n             * own mac addresses.\n             */\n            struct ovn_port *op;\n            LIST_FOR_EACH (op, dp_node, &od->port_list) {\n                ds_clear(match);\n                ds_put_format(match, \"eth.src == %s && igmp\",\n                              op->lrp_networks.ea_s);\n                ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10550,\n                              ds_cstr(match), debug_drop_action());\n\n                ds_clear(match);\n                ds_put_format(match, \"eth.src == %s && (mldv1 || mldv2)\",\n                              op->lrp_networks.ea_s);\n                ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10550,\n                              ds_cstr(match), debug_drop_action());\n            }\n\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10460,\n                          \"igmp\",\n                          \"clone { \"\n                                \"outport = \\\"\"MC_STATIC\"\\\"; \"\n                                \"next; \"\n                          \"};\");\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10460,\n                          \"mldv1 || mldv2\",\n                          \"clone { \"\n                                \"outport = \\\"\"MC_STATIC\"\\\"; \"\n                                \"next; \"\n                          \"};\");\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10450,\n                          \"ip4.mcast || ip6.mcast\",\n                          \"clone { \"\n                                \"outport = \\\"\"MC_STATIC\"\\\"; \"\n                                \"ip.ttl--; \"\n                                \"next; \"\n                          \"};\");\n        } else {\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10450,\n                          \"ip4.mcast || ip6.mcast\", debug_drop_action());\n        }\n    }\n}\n\n/* Logical router ingress table POLICY: Policy.\n *\n * A packet that arrives at this table is an IP packet that should be\n * permitted/denied/rerouted to the address in the rule's nexthop.\n * This table sets outport to the correct out_port,\n * eth.src to the output port's MAC address,\n * and REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6 to the next-hop IP address\n * (leaving 'ip[46].dst', the packet\u2019s final destination, unchanged), and\n * advances to the next table for ARP/ND resolution. */\nstatic void\nbuild_ingress_policy_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        const struct hmap *ports)\n{\n    if (od->nbr) {\n        /* This is a catch-all rule. It has the lowest priority (0)\n         * does a match-all(\"1\") and pass-through (next) */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_POLICY, 0, \"1\",\n                      REG_ECMP_GROUP_ID\" = 0; next;\");\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_POLICY_ECMP, 150,\n                      REG_ECMP_GROUP_ID\" == 0\", \"next;\");\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_POLICY_ECMP);\n\n        /* Convert routing policies to flows. */\n        uint16_t ecmp_group_id = 1;\n        for (int i = 0; i < od->nbr->n_policies; i++) {\n            const struct nbrec_logical_router_policy *rule\n                = od->nbr->policies[i];\n            bool is_ecmp_reroute =\n                (!strcmp(rule->action, \"reroute\") && rule->n_nexthops > 1);\n\n            if (is_ecmp_reroute) {\n                build_ecmp_routing_policy_flows(lflows, od, ports, rule,\n                                                ecmp_group_id);\n                ecmp_group_id++;\n            } else {\n                build_routing_policy_flow(lflows, od, ports, rule,\n                                          &rule->header_);\n            }\n        }\n    }\n}\n\n/* Local router ingress table ARP_RESOLVE: ARP Resolution. */\nstatic void\nbuild_arp_resolve_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (od->nbr) {\n        /* Multicast packets already have the outport set so just advance to\n         * next table (priority 500). */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ARP_RESOLVE, 500,\n                      \"ip4.mcast || ip6.mcast\", \"next;\");\n\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ARP_RESOLVE, 1, \"ip4\",\n                      \"get_arp(outport, \" REG_NEXT_HOP_IPV4 \"); next;\");\n\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ARP_RESOLVE, 1, \"ip6\",\n                      \"get_nd(outport, \" REG_NEXT_HOP_IPV6 \"); next;\");\n\n        ovn_lflow_add_default_drop(lflows, od, S_ROUTER_IN_ARP_RESOLVE);\n    }\n}\n\nstatic void\nroutable_addresses_to_lflows(struct hmap *lflows, struct ovn_port *router_port,\n                             struct ovn_port *peer, struct ds *match,\n                             struct ds *actions)\n{\n    struct ovn_port_routable_addresses *ra = &router_port->routables;\n    if (!ra->n_addrs) {\n        return;\n    }\n\n    for (size_t i = 0; i < ra->n_addrs; i++) {\n        ds_clear(match);\n        ds_put_format(match, \"outport == %s && \"REG_NEXT_HOP_IPV4\" == {\",\n                      peer->json_key);\n        bool first = true;\n        for (size_t j = 0; j < ra->laddrs[i].n_ipv4_addrs; j++) {\n            if (!first) {\n                ds_put_cstr(match, \", \");\n            }\n            ds_put_cstr(match, ra->laddrs[i].ipv4_addrs[j].addr_s);\n            first = false;\n        }\n        ds_put_cstr(match, \"}\");\n\n        ds_clear(actions);\n        ds_put_format(actions, \"eth.dst = %s; next;\", ra->laddrs[i].ea_s);\n        ovn_lflow_add(lflows, peer->od, S_ROUTER_IN_ARP_RESOLVE, 100,\n                      ds_cstr(match), ds_cstr(actions));\n    }\n}\n\n/* Local router ingress table ARP_RESOLVE: ARP Resolution.\n *\n * Any unicast packet that reaches this table is an IP packet whose\n * next-hop IP address is in REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6\n * (ip4.dst/ipv6.dst is the final destination).\n * This table resolves the IP address in\n * REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6 into an output port in outport and\n * an Ethernet address in eth.dst.\n */\nstatic void\nbuild_arp_resolve_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        const struct hmap *ports,\n        struct ds *match, struct ds *actions)\n{\n    if (op->nbsp && !lsp_is_enabled(op->nbsp)) {\n        return;\n    }\n\n    if (op->nbrp) {\n        /* This is a logical router port. If next-hop IP address in\n         * REG_NEXT_HOP_IPV4/REG_NEXT_HOP_IPV6 matches IP address of this\n         * router port, then the packet is intended to eventually be sent\n         * to this logical port. Set the destination mac address using\n         * this port's mac address.\n         *\n         * The packet is still in peer's logical pipeline. So the match\n         * should be on peer's outport. */\n        if (op->peer && op->nbrp->peer) {\n            if (op->lrp_networks.n_ipv4_addrs) {\n                ds_clear(match);\n                ds_put_format(match, \"outport == %s && \"\n                              REG_NEXT_HOP_IPV4 \"== \",\n                              op->peer->json_key);\n                op_put_v4_networks(match, op, false);\n\n                ds_clear(actions);\n                ds_put_format(actions, \"eth.dst = %s; next;\",\n                              op->lrp_networks.ea_s);\n                ovn_lflow_add_with_hint(lflows, op->peer->od,\n                                        S_ROUTER_IN_ARP_RESOLVE, 100,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbrp->header_);\n            }\n\n            if (op->lrp_networks.n_ipv6_addrs) {\n                ds_clear(match);\n                ds_put_format(match, \"outport == %s && \"\n                              REG_NEXT_HOP_IPV6 \" == \",\n                              op->peer->json_key);\n                op_put_v6_networks(match, op);\n\n                ds_clear(actions);\n                ds_put_format(actions, \"eth.dst = %s; next;\",\n                              op->lrp_networks.ea_s);\n                ovn_lflow_add_with_hint(lflows, op->peer->od,\n                                        S_ROUTER_IN_ARP_RESOLVE, 100,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbrp->header_);\n            }\n        }\n\n        if (is_l3dgw_port(op)) {\n            const char *redirect_type = smap_get(&op->nbrp->options,\n                                                 \"redirect-type\");\n            if (redirect_type && !strcasecmp(redirect_type, \"bridged\")) {\n                /* Packet is on a non gateway chassis and\n                 * has an unresolved ARP on a network behind gateway\n                 * chassis attached router port. Since, redirect type\n                 * is \"bridged\", instead of calling \"get_arp\"\n                 * on this node, we will redirect the packet to gateway\n                 * chassis, by setting destination mac router port mac.*/\n                ds_clear(match);\n                ds_put_format(match, \"outport == %s && \"\n                              \"!is_chassis_resident(%s)\", op->json_key,\n                              op->cr_port->json_key);\n                ds_clear(actions);\n                ds_put_format(actions, \"eth.dst = %s; next;\",\n                              op->lrp_networks.ea_s);\n\n                ovn_lflow_add_with_hint(lflows, op->od,\n                                        S_ROUTER_IN_ARP_RESOLVE, 50,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbrp->header_);\n            }\n        }\n\n        /* Drop IP traffic destined to router owned IPs. Part of it is dropped\n         * in stage \"lr_in_ip_input\" but traffic that could have been unSNATed\n         * but didn't match any existing session might still end up here.\n         *\n         * Priority 2.\n         */\n        build_lrouter_drop_own_dest(op, S_ROUTER_IN_ARP_RESOLVE, 2, true,\n                                    lflows);\n    } else if (op->od->n_router_ports && !lsp_is_router(op->nbsp)\n               && strcmp(op->nbsp->type, \"virtual\")) {\n        /* This is a logical switch port that backs a VM or a container.\n         * Extract its addresses. For each of the address, go through all\n         * the router ports attached to the switch (to which this port\n         * connects) and if the address in question is reachable from the\n         * router port, add an ARP/ND entry in that router's pipeline. */\n\n        for (size_t i = 0; i < op->n_lsp_addrs; i++) {\n            const char *ea_s = op->lsp_addrs[i].ea_s;\n            for (size_t j = 0; j < op->lsp_addrs[i].n_ipv4_addrs; j++) {\n                const char *ip_s = op->lsp_addrs[i].ipv4_addrs[j].addr_s;\n                for (size_t k = 0; k < op->od->n_router_ports; k++) {\n                    /* Get the Logical_Router_Port that the\n                     * Logical_Switch_Port is connected to, as\n                     * 'peer'. */\n                    struct ovn_port *peer = ovn_port_get_peer(\n                            ports, op->od->router_ports[k]);\n                    if (!peer || !peer->nbrp) {\n                        continue;\n                    }\n\n                    if (!find_lrp_member_ip(peer, ip_s)) {\n                        continue;\n                    }\n\n                    ds_clear(match);\n                    ds_put_format(match, \"outport == %s && \"\n                                  REG_NEXT_HOP_IPV4 \" == %s\",\n                                  peer->json_key, ip_s);\n\n                    ds_clear(actions);\n                    ds_put_format(actions, \"eth.dst = %s; next;\", ea_s);\n                    ovn_lflow_add_with_hint(lflows, peer->od,\n                                            S_ROUTER_IN_ARP_RESOLVE, 100,\n                                            ds_cstr(match),\n                                            ds_cstr(actions),\n                                            &op->nbsp->header_);\n                }\n            }\n\n            for (size_t j = 0; j < op->lsp_addrs[i].n_ipv6_addrs; j++) {\n                const char *ip_s = op->lsp_addrs[i].ipv6_addrs[j].addr_s;\n                for (size_t k = 0; k < op->od->n_router_ports; k++) {\n                    /* Get the Logical_Router_Port that the\n                     * Logical_Switch_Port is connected to, as\n                     * 'peer'. */\n                    struct ovn_port *peer = ovn_port_get_peer(\n                            ports, op->od->router_ports[k]);\n                    if (!peer || !peer->nbrp) {\n                        continue;\n                    }\n\n                    if (!find_lrp_member_ip(peer, ip_s)) {\n                        continue;\n                    }\n\n                    ds_clear(match);\n                    ds_put_format(match, \"outport == %s && \"\n                                  REG_NEXT_HOP_IPV6 \" == %s\",\n                                  peer->json_key, ip_s);\n\n                    ds_clear(actions);\n                    ds_put_format(actions, \"eth.dst = %s; next;\", ea_s);\n                    ovn_lflow_add_with_hint(lflows, peer->od,\n                                            S_ROUTER_IN_ARP_RESOLVE, 100,\n                                            ds_cstr(match),\n                                            ds_cstr(actions),\n                                            &op->nbsp->header_);\n                }\n            }\n        }\n    } else if (op->od->n_router_ports && !lsp_is_router(op->nbsp)\n               && !strcmp(op->nbsp->type, \"virtual\")) {\n        /* This is a virtual port. Add ARP replies for the virtual ip with\n         * the mac of the present active virtual parent.\n         * If the logical port doesn't have virtual parent set in\n         * Port_Binding table, then add the flow to set eth.dst to\n         * 00:00:00:00:00:00 and advance to next table so that ARP is\n         * resolved by router pipeline using the arp{} action.\n         * The MAC_Binding entry for the virtual ip might be invalid. */\n\n        const char *vip = smap_get(&op->nbsp->options,\n                                   \"virtual-ip\");\n        const char *virtual_parents = smap_get(&op->nbsp->options,\n                                               \"virtual-parents\");\n\n        if (!vip || !virtual_parents || !op->sb) {\n            return;\n        }\n\n        bool is_ipv4 = strchr(vip, '.') ? true : false;\n        if (is_ipv4) {\n            ovs_be32 ipv4;\n            if (!ip_parse(vip, &ipv4)) {\n                 return;\n            }\n        } else {\n            struct in6_addr ipv6;\n            if (!ipv6_parse(vip, &ipv6)) {\n                 return;\n            }\n        }\n\n        if (!op->sb->virtual_parent || !op->sb->virtual_parent[0] ||\n            !op->sb->chassis) {\n            /* The virtual port is not claimed yet. */\n            for (size_t i = 0; i < op->od->n_router_ports; i++) {\n                struct ovn_port *peer = ovn_port_get_peer(\n                        ports, op->od->router_ports[i]);\n                if (!peer || !peer->nbrp) {\n                    continue;\n                }\n\n                if (find_lrp_member_ip(peer, vip)) {\n                    ds_clear(match);\n                    ds_put_format(\n                        match, \"outport == %s && \" \"%s == %s\", peer->json_key,\n                        is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6, vip);\n\n                    const char *arp_actions =\n                                  \"eth.dst = 00:00:00:00:00:00; next;\";\n                    ovn_lflow_add_with_hint(lflows, peer->od,\n                                            S_ROUTER_IN_ARP_RESOLVE, 100,\n                                            ds_cstr(match),\n                                            arp_actions,\n                                            &op->nbsp->header_);\n                    break;\n                }\n            }\n        } else {\n            struct ovn_port *vp =\n                ovn_port_find(ports, op->sb->virtual_parent);\n            if (!vp || !vp->nbsp) {\n                return;\n            }\n\n            for (size_t i = 0; i < vp->n_lsp_addrs; i++) {\n                bool found_vip_network = false;\n                const char *ea_s = vp->lsp_addrs[i].ea_s;\n                for (size_t j = 0; j < vp->od->n_router_ports; j++) {\n                    /* Get the Logical_Router_Port that the\n                    * Logical_Switch_Port is connected to, as\n                    * 'peer'. */\n                    struct ovn_port *peer =\n                        ovn_port_get_peer(ports, vp->od->router_ports[j]);\n                    if (!peer || !peer->nbrp) {\n                        continue;\n                    }\n\n                    if (!find_lrp_member_ip(peer, vip)) {\n                        continue;\n                    }\n\n                    ds_clear(match);\n                    ds_put_format(\n                        match, \"outport == %s && \" \"%s == %s\", peer->json_key,\n                        is_ipv4 ? REG_NEXT_HOP_IPV4 : REG_NEXT_HOP_IPV6, vip);\n\n                    ds_clear(actions);\n                    ds_put_format(actions, \"eth.dst = %s; next;\", ea_s);\n                    ovn_lflow_add_with_hint(lflows, peer->od,\n                                            S_ROUTER_IN_ARP_RESOLVE, 100,\n                                            ds_cstr(match),\n                                            ds_cstr(actions),\n                                            &op->nbsp->header_);\n                    found_vip_network = true;\n                    break;\n                }\n\n                if (found_vip_network) {\n                    break;\n                }\n            }\n        }\n    } else if (lsp_is_router(op->nbsp)) {\n        /* This is a logical switch port that connects to a router. */\n\n        /* The peer of this switch port is the router port for which\n         * we need to add logical flows such that it can resolve\n         * ARP entries for all the other router ports connected to\n         * the switch in question. */\n        struct ovn_port *peer = ovn_port_get_peer(ports, op);\n        if (!peer || !peer->nbrp) {\n            return;\n        }\n\n        if (peer->od->nbr &&\n            smap_get_bool(&peer->od->nbr->options,\n                          \"dynamic_neigh_routers\", false)) {\n            return;\n        }\n\n        for (size_t i = 0; i < op->od->n_router_ports; i++) {\n            const char *router_port_name = smap_get(\n                                &op->od->router_ports[i]->nbsp->options,\n                                \"router-port\");\n            struct ovn_port *router_port = ovn_port_find(ports,\n                                                         router_port_name);\n            if (!router_port || !router_port->nbrp) {\n                continue;\n            }\n\n            /* Skip the router port under consideration. */\n            if (router_port == peer) {\n               continue;\n            }\n\n            if (router_port->lrp_networks.n_ipv4_addrs) {\n                ds_clear(match);\n                ds_put_format(match, \"outport == %s && \"\n                              REG_NEXT_HOP_IPV4 \" == \",\n                              peer->json_key);\n                op_put_v4_networks(match, router_port, false);\n\n                ds_clear(actions);\n                ds_put_format(actions, \"eth.dst = %s; next;\",\n                                          router_port->lrp_networks.ea_s);\n                ovn_lflow_add_with_hint(lflows, peer->od,\n                                        S_ROUTER_IN_ARP_RESOLVE, 100,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbsp->header_);\n            }\n\n            if (router_port->lrp_networks.n_ipv6_addrs) {\n                ds_clear(match);\n                ds_put_format(match, \"outport == %s && \"\n                              REG_NEXT_HOP_IPV6 \" == \",\n                              peer->json_key);\n                op_put_v6_networks(match, router_port);\n\n                ds_clear(actions);\n                ds_put_format(actions, \"eth.dst = %s; next;\",\n                              router_port->lrp_networks.ea_s);\n                ovn_lflow_add_with_hint(lflows, peer->od,\n                                        S_ROUTER_IN_ARP_RESOLVE, 100,\n                                        ds_cstr(match), ds_cstr(actions),\n                                        &op->nbsp->header_);\n            }\n\n            if (smap_get(&peer->od->nbr->options, \"chassis\")\n                || peer->cr_port) {\n                routable_addresses_to_lflows(lflows, router_port, peer,\n                                             match, actions);\n            }\n        }\n    }\n\n}\n\nstatic void\nbuild_icmperr_pkt_big_flows(struct ovn_port *op, int mtu, struct hmap *lflows,\n                            const struct shash *meter_groups, struct ds *match,\n                            struct ds *actions, enum ovn_stage stage,\n                            struct ovn_port *outport)\n{\n    char *outport_match = outport ? xasprintf(\"outport == %s && \",\n                                              outport->json_key)\n                                  : NULL;\n\n    if (op->lrp_networks.ipv4_addrs) {\n        ds_clear(match);\n        ds_put_format(match, \"inport == %s && %sip4 && \"REGBIT_PKT_LARGER\n                      \" && \"REGBIT_EGRESS_LOOPBACK\" == 0\", op->json_key,\n                      outport ? outport_match : \"\");\n\n        ds_clear(actions);\n        /* Set icmp4.frag_mtu to gw_mtu */\n        ds_put_format(actions,\n            \"icmp4_error {\"\n            REGBIT_EGRESS_LOOPBACK\" = 1; \"\n            REGBIT_PKT_LARGER\" = 0; \"\n            \"eth.dst = %s; \"\n            \"ip4.dst = ip4.src; \"\n            \"ip4.src = %s; \"\n            \"ip.ttl = 255; \"\n            \"icmp4.type = 3; /* Destination Unreachable. */ \"\n            \"icmp4.code = 4; /* Frag Needed and DF was Set. */ \"\n            \"icmp4.frag_mtu = %d; \"\n            \"next(pipeline=ingress, table=%d); };\",\n            op->lrp_networks.ea_s,\n            op->lrp_networks.ipv4_addrs[0].addr_s,\n            mtu, ovn_stage_get_table(S_ROUTER_IN_ADMISSION));\n        ovn_lflow_add_with_hint__(lflows, op->od, stage, 150,\n                                  ds_cstr(match), ds_cstr(actions),\n                                  NULL,\n                                  copp_meter_get(\n                                        COPP_ICMP4_ERR,\n                                        op->od->nbr->copp,\n                                        meter_groups),\n                                  &op->nbrp->header_);\n    }\n\n    if (op->lrp_networks.ipv6_addrs) {\n        ds_clear(match);\n        ds_put_format(match, \"inport == %s && %sip6 && \"REGBIT_PKT_LARGER\n                      \" && \"REGBIT_EGRESS_LOOPBACK\" == 0\", op->json_key,\n                      outport ? outport_match : \"\");\n\n        ds_clear(actions);\n        /* Set icmp6.frag_mtu to gw_mtu */\n        ds_put_format(actions,\n            \"icmp6_error {\"\n            REGBIT_EGRESS_LOOPBACK\" = 1; \"\n            REGBIT_PKT_LARGER\" = 0; \"\n            \"eth.dst = %s; \"\n            \"ip6.dst = ip6.src; \"\n            \"ip6.src = %s; \"\n            \"ip.ttl = 255; \"\n            \"icmp6.type = 2; /* Packet Too Big. */ \"\n            \"icmp6.code = 0; \"\n            \"icmp6.frag_mtu = %d; \"\n            \"next(pipeline=ingress, table=%d); };\",\n            op->lrp_networks.ea_s,\n            op->lrp_networks.ipv6_addrs[0].addr_s,\n            mtu, ovn_stage_get_table(S_ROUTER_IN_ADMISSION));\n        ovn_lflow_add_with_hint__(lflows, op->od, stage, 150,\n                                  ds_cstr(match), ds_cstr(actions),\n                                  NULL,\n                                  copp_meter_get(\n                                        COPP_ICMP6_ERR,\n                                        op->od->nbr->copp,\n                                        meter_groups),\n                                  &op->nbrp->header_);\n    }\n    free(outport_match);\n}\n\nstatic void\nbuild_check_pkt_len_flows_for_lrp(struct ovn_port *op,\n                                  struct hmap *lflows,\n                                  const struct hmap *ports,\n                                  const struct shash *meter_groups,\n                                  struct ds *match,\n                                  struct ds *actions)\n{\n    int gw_mtu = smap_get_int(&op->nbrp->options, \"gateway_mtu\", 0);\n    if (gw_mtu <= 0) {\n        return;\n    }\n\n    ds_clear(match);\n    ds_put_format(match, \"outport == %s\", op->json_key);\n    build_gateway_mtu_flow(lflows, op, S_ROUTER_IN_CHK_PKT_LEN, 50, 55,\n                           match, actions, &op->nbrp->header_, \"next;\");\n\n    /* ingress traffic */\n    build_icmperr_pkt_big_flows(op, gw_mtu, lflows, meter_groups,\n                                match, actions, S_ROUTER_IN_IP_INPUT,\n                                NULL);\n\n    for (size_t i = 0; i < op->od->nbr->n_ports; i++) {\n        struct ovn_port *rp = ovn_port_find(ports,\n                                            op->od->nbr->ports[i]->name);\n        if (!rp || rp == op) {\n            continue;\n        }\n\n        /* egress traffic */\n        build_icmperr_pkt_big_flows(rp, gw_mtu, lflows, meter_groups,\n                                    match, actions, S_ROUTER_IN_LARGER_PKTS,\n                                    op);\n    }\n}\n\n/* Local router ingress table CHK_PKT_LEN: Check packet length.\n *\n * Any IPv4 packet with outport set to the distributed gateway\n * router port, check the packet length and store the result in the\n * 'REGBIT_PKT_LARGER' register bit.\n *\n * Local router ingress table LARGER_PKTS: Handle larger packets.\n *\n * Any IPv4 packet with outport set to the distributed gateway\n * router port and the 'REGBIT_PKT_LARGER' register bit is set,\n * generate ICMPv4 packet with type 3 (Destination Unreachable) and\n * code 4 (Fragmentation needed).\n * */\nstatic void\nbuild_check_pkt_len_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        const struct hmap *ports,\n        struct ds *match, struct ds *actions,\n        const struct shash *meter_groups)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    /* Packets are allowed by default. */\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_CHK_PKT_LEN, 0, \"1\",\n                  \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_LARGER_PKTS, 0, \"1\",\n                  \"next;\");\n\n    for (size_t i = 0; i < od->nbr->n_ports; i++) {\n        struct ovn_port *rp = ovn_port_find(ports,\n                                            od->nbr->ports[i]->name);\n        if (!rp || !rp->nbrp) {\n            continue;\n        }\n        build_check_pkt_len_flows_for_lrp(rp, lflows, ports, meter_groups,\n                                          match, actions);\n    }\n}\n\n/* Logical router ingress table GW_REDIRECT: Gateway redirect. */\nstatic void\nbuild_gateway_redirect_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        struct ds *match, struct ds *actions)\n{\n    if (!od->nbr) {\n        return;\n    }\n    for (size_t i = 0; i < od->n_l3dgw_ports; i++) {\n        if (l3dgw_port_has_associated_vtep_lports(od->l3dgw_ports[i])) {\n            /* Skip adding redirect lflow for vtep-enabled l3dgw ports.\n             * Traffic from hypervisor to VTEP (ramp) switch should go in\n             * distributed manner. Only returning routed traffic must go\n             * through centralized gateway (or ha-chassis-group).\n             * This assumes that attached logical switch with vtep lport(s) has\n             * no localnet port(s) for NAT. Otherwise centralized NAT will not\n             * work. */\n            continue;\n        }\n\n        const struct ovsdb_idl_row *stage_hint = NULL;\n        bool add_def_flow = true;\n\n        if (od->l3dgw_ports[i]->nbrp) {\n            stage_hint = &od->l3dgw_ports[i]->nbrp->header_;\n        }\n\n        /* For traffic with outport == l3dgw_port, if the\n         * packet did not match any higher priority redirect\n         * rule, then the traffic is redirected to the central\n         * instance of the l3dgw_port. */\n        ds_clear(match);\n        ds_put_format(match, \"outport == %s\",\n                      od->l3dgw_ports[i]->json_key);\n        ds_clear(actions);\n        ds_put_format(actions, \"outport = %s; next;\",\n                      od->l3dgw_ports[i]->cr_port->json_key);\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_GW_REDIRECT, 50,\n                                ds_cstr(match), ds_cstr(actions),\n                                stage_hint);\n        for (int j = 0; j < od->n_nat_entries; j++) {\n            const struct ovn_nat *nat = &od->nat_entries[j];\n\n            if (!lrouter_dnat_and_snat_is_stateless(nat->nb) ||\n                (!nat->nb->allowed_ext_ips && !nat->nb->exempted_ext_ips)) {\n                continue;\n            }\n\n            struct ds match_ext = DS_EMPTY_INITIALIZER;\n            struct nbrec_address_set  *as = nat->nb->allowed_ext_ips\n                ? nat->nb->allowed_ext_ips : nat->nb->exempted_ext_ips;\n            ds_put_format(&match_ext, \"%s && ip%s.src == $%s\",\n                          ds_cstr(match), nat_entry_is_v6(nat) ? \"6\" : \"4\",\n                          as->name);\n\n            if (nat->nb->allowed_ext_ips) {\n                ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_GW_REDIRECT,\n                                        75, ds_cstr(&match_ext),\n                                        ds_cstr(actions), stage_hint);\n                if (add_def_flow) {\n                    ds_clear(&match_ext);\n                    ds_put_format(&match_ext, \"ip && ip%s.dst == %s\",\n                                  nat_entry_is_v6(nat) ? \"6\" : \"4\",\n                                  nat->nb->external_ip);\n                    ovn_lflow_add(lflows, od, S_ROUTER_IN_GW_REDIRECT, 70,\n                                  ds_cstr(&match_ext), debug_drop_action());\n                    add_def_flow = false;\n                }\n            } else if (nat->nb->exempted_ext_ips) {\n                ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_GW_REDIRECT,\n                                        75, ds_cstr(&match_ext),\n                                        debug_drop_action(),\n                                        stage_hint);\n            }\n            ds_destroy(&match_ext);\n        }\n    }\n\n    /* Packets are allowed by default. */\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_GW_REDIRECT, 0, \"1\", \"next;\");\n}\n\n/* Local router ingress table ARP_REQUEST: ARP request.\n *\n * In the common case where the Ethernet destination has been resolved,\n * this table outputs the packet (priority 0).  Otherwise, it composes\n * and sends an ARP/IPv6 NA request (priority 100). */\nstatic void\nbuild_arp_request_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows,\n        struct ds *match, struct ds *actions,\n        const struct shash *meter_groups)\n{\n    if (od->nbr) {\n        for (int i = 0; i < od->nbr->n_static_routes; i++) {\n            const struct nbrec_logical_router_static_route *route;\n\n            route = od->nbr->static_routes[i];\n            struct in6_addr gw_ip6;\n            unsigned int plen;\n            char *error = ipv6_parse_cidr(route->nexthop, &gw_ip6, &plen);\n            if (error || plen != 128) {\n                free(error);\n                continue;\n            }\n\n            ds_clear(match);\n            ds_put_format(match, \"eth.dst == 00:00:00:00:00:00 && \"\n                          \"ip6 && \" REG_NEXT_HOP_IPV6 \" == %s\",\n                          route->nexthop);\n            struct in6_addr sn_addr;\n            struct eth_addr eth_dst;\n            in6_addr_solicited_node(&sn_addr, &gw_ip6);\n            ipv6_multicast_to_ethernet(&eth_dst, &sn_addr);\n\n            char sn_addr_s[INET6_ADDRSTRLEN + 1];\n            ipv6_string_mapped(sn_addr_s, &sn_addr);\n\n            ds_clear(actions);\n            ds_put_format(actions,\n                          \"nd_ns { \"\n                          \"eth.dst = \"ETH_ADDR_FMT\"; \"\n                          \"ip6.dst = %s; \"\n                          \"nd.target = %s; \"\n                          \"output; \"\n                          \"};\", ETH_ADDR_ARGS(eth_dst), sn_addr_s,\n                          route->nexthop);\n\n            ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_ARP_REQUEST, 200,\n                                      ds_cstr(match), ds_cstr(actions), NULL,\n                                      copp_meter_get(COPP_ND_NS_RESOLVE,\n                                                     od->nbr->copp,\n                                                     meter_groups),\n                                      &route->header_);\n        }\n\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_ARP_REQUEST, 100,\n                          \"eth.dst == 00:00:00:00:00:00 && ip4\",\n                          \"arp { \"\n                          \"eth.dst = ff:ff:ff:ff:ff:ff; \"\n                          \"arp.spa = \" REG_SRC_IPV4 \"; \"\n                          \"arp.tpa = \" REG_NEXT_HOP_IPV4 \"; \"\n                          \"arp.op = 1; \" /* ARP request */\n                          \"output; \"\n                          \"};\",\n                          copp_meter_get(COPP_ARP_RESOLVE, od->nbr->copp,\n                                         meter_groups));\n        ovn_lflow_metered(lflows, od, S_ROUTER_IN_ARP_REQUEST, 100,\n                          \"eth.dst == 00:00:00:00:00:00 && ip6\",\n                          \"nd_ns { \"\n                          \"nd.target = \" REG_NEXT_HOP_IPV6 \"; \"\n                          \"output; \"\n                          \"};\",\n                          copp_meter_get(COPP_ND_NS_RESOLVE, od->nbr->copp,\n                                         meter_groups));\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_ARP_REQUEST, 0, \"1\", \"output;\");\n    }\n}\n\n/* Logical router egress table DELIVERY: Delivery (priority 100-110).\n *\n * Priority 100 rules deliver packets to enabled logical ports.\n * Priority 110 rules match multicast packets and update the source\n * mac before delivering to enabled logical ports. IP multicast traffic\n * bypasses S_ROUTER_IN_IP_ROUTING route lookups.\n */\nstatic void\nbuild_egress_delivery_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match, struct ds *actions)\n{\n    if (op->nbrp) {\n        if (!lrport_is_enabled(op->nbrp)) {\n            /* Drop packets to disabled logical ports (since logical flow\n             * tables are default-drop). */\n            return;\n        }\n\n        if (is_cr_port(op)) {\n            /* No egress packets should be processed in the context of\n             * a chassisredirect port.  The chassisredirect port should\n             * be replaced by the l3dgw port in the local output\n             * pipeline stage before egress processing. */\n            return;\n        }\n\n        /* If multicast relay is enabled then also adjust source mac for IP\n         * multicast traffic.\n         */\n        if (op->od->mcast_info.rtr.relay) {\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match, \"(ip4.mcast || ip6.mcast) && outport == %s\",\n                          op->json_key);\n            ds_put_format(actions, \"eth.src = %s; output;\",\n                          op->lrp_networks.ea_s);\n            ovn_lflow_add(lflows, op->od, S_ROUTER_OUT_DELIVERY, 110,\n                          ds_cstr(match), ds_cstr(actions));\n        }\n\n        ds_clear(match);\n        ds_put_format(match, \"outport == %s\", op->json_key);\n        ovn_lflow_add(lflows, op->od, S_ROUTER_OUT_DELIVERY, 100,\n                      ds_cstr(match), \"output;\");\n\n        ovn_lflow_add_default_drop(lflows, op->od, S_ROUTER_OUT_DELIVERY);\n    }\n\n}\n\nstatic void\nbuild_misc_local_traffic_drop_flows_for_lrouter(\n        struct ovn_datapath *od, struct hmap *lflows)\n{\n    if (od->nbr) {\n        /* Allow IGMP and MLD packets (with TTL = 1) if the router is\n         * configured to flood them statically on some ports.\n         */\n        if (od->mcast_info.rtr.flood_static) {\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 120,\n                          \"igmp && ip.ttl == 1\", \"next;\");\n            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 120,\n                          \"(mldv1 || mldv2) && ip.ttl == 1\", \"next;\");\n        }\n\n        /* L3 admission control: drop multicast and broadcast source, localhost\n         * source or destination, and zero network source or destination\n         * (priority 100). */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 100,\n                      \"ip4.src_mcast ||\"\n                      \"ip4.src == 255.255.255.255 || \"\n                      \"ip4.src == 127.0.0.0/8 || \"\n                      \"ip4.dst == 127.0.0.0/8 || \"\n                      \"ip4.src == 0.0.0.0/8 || \"\n                      \"ip4.dst == 0.0.0.0/8\",\n                      debug_drop_action());\n\n        /* Drop ARP packets (priority 85). ARP request packets for router's own\n         * IPs are handled with priority-90 flows.\n         * Drop IPv6 ND packets (priority 85). ND NA packets for router's own\n         * IPs are handled with priority-90 flows.\n         */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 85,\n                      \"arp || nd\", debug_drop_action());\n\n        /* Allow IPv6 multicast traffic that's supposed to reach the\n         * router pipeline (e.g., router solicitations).\n         */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 84, \"nd_rs || nd_ra\",\n                      \"next;\");\n\n        /* Drop other reserved multicast. */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 83,\n                      \"ip6.mcast_rsvd\", debug_drop_action());\n\n        /* Allow other multicast if relay enabled (priority 82). */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 82,\n                      \"ip4.mcast || ip6.mcast\",\n                      (od->mcast_info.rtr.relay ? \"next;\" :\n                                                  debug_drop_action()));\n\n        /* Drop Ethernet local broadcast.  By definition this traffic should\n         * not be forwarded.*/\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 50,\n                      \"eth.bcast\", debug_drop_action());\n\n        /* Avoid ICMP time exceeded for multicast, silent drop instead.\n         * See RFC1812 section 5.3.1:\n         *  If the TTL is reduced to zero (or less), the packet MUST be\n         *  discarded, and if the destination is NOT A MULTICAST address the\n         *  router MUST send an ICMP Time Exceeded message ...\n         *\n         * The reason behind is that TTL has special meanings for multicast.\n         * For example, TTL = 1 means restricted to the same subnet, not\n         * forwarded by the router. So it is very common to see multicast\n         * packets with ttl = 1, and generating ICMP for such packets is\n         * harmful from both slowpath performance and functionality point of\n         * view.\n         *\n         * (priority-31 flows will send ICMP time exceeded) */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 32,\n                      \"ip.ttl == {0, 1} && !ip.later_frag && \"\n                      \"(ip4.mcast || ip6.mcast)\", debug_drop_action());\n\n        /* TTL discard */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 30,\n                      \"ip.ttl == {0, 1}\", debug_drop_action());\n\n        /* Pass other traffic not already handled to the next table for\n         * routing. */\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_INPUT, 0, \"1\", \"next;\");\n    }\n}\n\nstatic void\nbuild_dhcpv6_reply_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match)\n{\n    if (op->nbrp && (!op->l3dgw_port)) {\n        for (size_t i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n            ds_clear(match);\n            ds_put_format(match, \"ip6.dst == %s && udp.src == 547 &&\"\n                          \" udp.dst == 546\",\n                          op->lrp_networks.ipv6_addrs[i].addr_s);\n            ovn_lflow_add(lflows, op->od, S_ROUTER_IN_IP_INPUT, 100,\n                          ds_cstr(match),\n                          \"reg0 = 0; handle_dhcpv6_reply;\");\n        }\n    }\n\n}\n\nstatic void\nbuild_ipv6_input_flows_for_lrouter_port(\n        struct ovn_port *op, struct hmap *lflows,\n        struct ds *match, struct ds *actions,\n        const struct shash *meter_groups)\n{\n    if (op->nbrp && !is_cr_port(op)) {\n        /* No ingress packets are accepted on a chassisredirect\n         * port, so no need to program flows for that port. */\n        if (op->lrp_networks.n_ipv6_addrs) {\n            /* ICMPv6 echo reply.  These flows reply to echo requests\n             * received for the router's IP address. */\n            ds_clear(match);\n            ds_put_cstr(match, \"ip6.dst == \");\n            op_put_v6_networks(match, op);\n            ds_put_cstr(match, \" && icmp6.type == 128 && icmp6.code == 0\");\n\n            const char *lrp_actions =\n                        \"ip6.dst <-> ip6.src; \"\n                        \"ip.ttl = 255; \"\n                        \"icmp6.type = 129; \"\n                        \"flags.loopback = 1; \"\n                        \"next; \";\n            ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 90,\n                                    ds_cstr(match), lrp_actions,\n                                    &op->nbrp->header_);\n        }\n\n        /* ND reply.  These flows reply to ND solicitations for the\n         * router's own IP address. */\n        for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n            ds_clear(match);\n            if (is_l3dgw_port(op)) {\n                /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s\n                 * should only be sent from the gateway chassi, so that\n                 * upstream MAC learning points to the gateway chassis.\n                 * Also need to avoid generation of multiple ND replies\n                 * from different chassis. */\n                ds_put_format(match, \"is_chassis_resident(%s)\",\n                              op->cr_port->json_key);\n            }\n\n            build_lrouter_nd_flow(op->od, op, \"nd_na_router\",\n                                  op->lrp_networks.ipv6_addrs[i].addr_s,\n                                  op->lrp_networks.ipv6_addrs[i].sn_addr_s,\n                                  REG_INPORT_ETH_ADDR, match, false, 90,\n                                  &op->nbrp->header_, lflows, meter_groups);\n        }\n\n        /* UDP/TCP/SCTP port unreachable */\n        if (!op->od->is_gw_router && !op->od->n_l3dgw_ports) {\n            for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip6 && ip6.dst == %s && !ip.later_frag && tcp\",\n                              op->lrp_networks.ipv6_addrs[i].addr_s);\n                const char *action = \"tcp_reset {\"\n                                     \"eth.dst <-> eth.src; \"\n                                     \"ip6.dst <-> ip6.src; \"\n                                     \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_TCP_RESET,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip6 && ip6.dst == %s && !ip.later_frag && sctp\",\n                              op->lrp_networks.ipv6_addrs[i].addr_s);\n                action = \"sctp_abort {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip6.dst <-> ip6.src; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_TCP_RESET,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip6 && ip6.dst == %s && !ip.later_frag && udp\",\n                              op->lrp_networks.ipv6_addrs[i].addr_s);\n                action = \"icmp6 {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip6.dst <-> ip6.src; \"\n                         \"ip.ttl = 255; \"\n                         \"icmp6.type = 1; \"\n                         \"icmp6.code = 4; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_ICMP6_ERR,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip6 && ip6.dst == %s && !ip.later_frag\",\n                              op->lrp_networks.ipv6_addrs[i].addr_s);\n                action = \"icmp6 {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip6.dst <-> ip6.src; \"\n                         \"ip.ttl = 255; \"\n                         \"icmp6.type = 1; \"\n                         \"icmp6.code = 3; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          70, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_ICMP6_ERR,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n            }\n        }\n\n        /* ICMPv6 time exceeded */\n        struct ds ip_ds = DS_EMPTY_INITIALIZER;\n        for (int i = 0; i < op->lrp_networks.n_ipv6_addrs; i++) {\n            /* skip link-local address */\n            if (in6_is_lla(&op->lrp_networks.ipv6_addrs[i].network)) {\n                continue;\n            }\n\n            ds_clear(match);\n            ds_clear(actions);\n            ds_clear(&ip_ds);\n            if (is_l3dgw_port(op)) {\n                ds_put_cstr(&ip_ds, \"ip6.dst <-> ip6.src\");\n            } else {\n                ds_put_format(&ip_ds, \"ip6.dst = ip6.src; ip6.src = %s\",\n                              op->lrp_networks.ipv6_addrs[i].addr_s);\n            }\n            ds_put_format(match,\n                          \"inport == %s && ip6 && \"\n                          \"ip6.src == %s/%d && \"\n                          \"ip.ttl == {0, 1} && !ip.later_frag\",\n                          op->json_key,\n                          op->lrp_networks.ipv6_addrs[i].network_s,\n                          op->lrp_networks.ipv6_addrs[i].plen);\n            ds_put_format(actions,\n                          \"icmp6 {\"\n                          \"eth.dst <-> eth.src; \"\n                          \"%s ; ip.ttl = 254; \"\n                          \"icmp6.type = 3; /* Time exceeded */ \"\n                          \"icmp6.code = 0; /* TTL exceeded in transit */ \"\n                          \"outport = %s; flags.loopback = 1; output; };\",\n                          ds_cstr(&ip_ds), op->json_key);\n            ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                    31, ds_cstr(match), ds_cstr(actions), NULL,\n                    copp_meter_get(COPP_ICMP6_ERR, op->od->nbr->copp,\n                                   meter_groups),\n                    &op->nbrp->header_);\n        }\n        ds_destroy(&ip_ds);\n    }\n\n}\n\nstatic void\nbuild_lrouter_arp_nd_for_datapath(struct ovn_datapath *od,\n                                  struct hmap *lflows,\n                                  const struct shash *meter_groups)\n{\n    if (od->nbr) {\n\n        /* Priority-90-92 flows handle ARP requests and ND packets. Most are\n         * per logical port but DNAT addresses can be handled per datapath\n         * for non gateway router ports.\n         *\n         * Priority 91 and 92 flows are added for each gateway router\n         * port to handle the special cases. In case we get the packet\n         * on a regular port, just reply with the port's ETH address.\n         */\n        for (int i = 0; i < od->nbr->n_nat; i++) {\n            struct ovn_nat *nat_entry = &od->nat_entries[i];\n\n            /* Skip entries we failed to parse. */\n            if (!nat_entry_is_valid(nat_entry)) {\n                continue;\n            }\n\n            /* Skip SNAT entries for now, we handle unique SNAT IPs separately\n             * below.\n             */\n            if (!strcmp(nat_entry->nb->type, \"snat\")) {\n                continue;\n            }\n            build_lrouter_nat_arp_nd_flow(od, nat_entry, lflows, meter_groups);\n        }\n\n        /* Now handle SNAT entries too, one per unique SNAT IP. */\n        struct shash_node *snat_snode;\n        SHASH_FOR_EACH (snat_snode, &od->snat_ips) {\n            struct ovn_snat_ip *snat_ip = snat_snode->data;\n\n            if (ovs_list_is_empty(&snat_ip->snat_entries)) {\n                continue;\n            }\n\n            struct ovn_nat *nat_entry =\n                CONTAINER_OF(ovs_list_front(&snat_ip->snat_entries),\n                             struct ovn_nat, ext_addr_list_node);\n            build_lrouter_nat_arp_nd_flow(od, nat_entry, lflows, meter_groups);\n        }\n    }\n}\n\n/* Logical router ingress table 3: IP Input for IPv4. */\nstatic void\nbuild_lrouter_ipv4_ip_input(struct ovn_port *op,\n                            struct hmap *lflows,\n                            struct ds *match, struct ds *actions,\n                            const struct shash *meter_groups)\n{\n    /* No ingress packets are accepted on a chassisredirect\n     * port, so no need to program flows for that port. */\n    if (op->nbrp && !is_cr_port(op)) {\n        if (op->lrp_networks.n_ipv4_addrs) {\n            /* L3 admission control: drop packets that originate from an\n             * IPv4 address owned by the router or a broadcast address\n             * known to the router (priority 100). */\n            ds_clear(match);\n            ds_put_cstr(match, \"ip4.src == \");\n            op_put_v4_networks(match, op, true);\n            ds_put_cstr(match, \" && \"REGBIT_EGRESS_LOOPBACK\" == 0\");\n            ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 100,\n                                    ds_cstr(match), debug_drop_action(),\n                                    &op->nbrp->header_);\n\n            /* ICMP echo reply.  These flows reply to ICMP echo requests\n             * received for the router's IP address. Since packets only\n             * get here as part of the logical router datapath, the inport\n             * (i.e. the incoming locally attached net) does not matter.\n             * The ip.ttl also does not matter (RFC1812 section 4.2.2.9) */\n            ds_clear(match);\n            ds_put_cstr(match, \"ip4.dst == \");\n            op_put_v4_networks(match, op, false);\n            ds_put_cstr(match, \" && icmp4.type == 8 && icmp4.code == 0\");\n\n            const char * icmp_actions = \"ip4.dst <-> ip4.src; \"\n                          \"ip.ttl = 255; \"\n                          \"icmp4.type = 0; \"\n                          \"flags.loopback = 1; \"\n                          \"next; \";\n            ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 90,\n                                    ds_cstr(match), icmp_actions,\n                                    &op->nbrp->header_);\n        }\n\n        /* BFD msg handling */\n        build_lrouter_bfd_flows(lflows, op, meter_groups);\n\n        /* ICMP time exceeded */\n        struct ds ip_ds = DS_EMPTY_INITIALIZER;\n        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            ds_clear(match);\n            ds_clear(actions);\n            ds_clear(&ip_ds);\n            if (is_l3dgw_port(op)) {\n                ds_put_cstr(&ip_ds, \"ip4.dst <-> ip4.src\");\n            } else {\n                ds_put_format(&ip_ds, \"ip4.dst = ip4.src; ip4.src = %s\",\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n            }\n            ds_put_format(match,\n                          \"inport == %s && ip4 && \"\n                          \"ip.ttl == {0, 1} && !ip.later_frag\", op->json_key);\n            ds_put_format(actions,\n                          \"icmp4 {\"\n                          \"eth.dst <-> eth.src; \"\n                          \"icmp4.type = 11; /* Time exceeded */ \"\n                          \"icmp4.code = 0; /* TTL exceeded in transit */ \"\n                          \"%s ; ip.ttl = 254; \"\n                          \"outport = %s; flags.loopback = 1; output; };\",\n                          ds_cstr(&ip_ds), op->json_key);\n            ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                    31, ds_cstr(match), ds_cstr(actions), NULL,\n                    copp_meter_get(COPP_ICMP4_ERR, op->od->nbr->copp,\n                                   meter_groups),\n                    &op->nbrp->header_);\n\n        }\n        ds_destroy(&ip_ds);\n\n        /* ARP reply.  These flows reply to ARP requests for the router's own\n         * IP address. */\n        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n            ds_clear(match);\n            ds_put_format(match, \"arp.spa == %s/%u\",\n                          op->lrp_networks.ipv4_addrs[i].network_s,\n                          op->lrp_networks.ipv4_addrs[i].plen);\n\n            if (op->od->n_l3dgw_ports && op->peer\n                && op->peer->od->n_localnet_ports) {\n                bool add_chassis_resident_check = false;\n                const char *json_key;\n                if (is_l3dgw_port(op)) {\n                    /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s\n                     * should only be sent from the gateway chassis, so that\n                     * upstream MAC learning points to the gateway chassis.\n                     * Also need to avoid generation of multiple ARP responses\n                     * from different chassis. */\n                    add_chassis_resident_check = true;\n                    json_key = op->cr_port->json_key;\n                } else {\n                    /* Check if the option 'reside-on-redirect-chassis'\n                     * is set to true on the router port. If set to true\n                     * and if peer's logical switch has a localnet port, it\n                     * means the router pipeline for the packets from\n                     * peer's logical switch is be run on the chassis\n                     * hosting the gateway port and it should reply to the\n                     * ARP requests for the router port IPs.\n                     */\n                    add_chassis_resident_check = smap_get_bool(\n                        &op->nbrp->options,\n                        \"reside-on-redirect-chassis\", false) &&\n                        op->od->n_l3dgw_ports == 1;\n                    json_key = op->od->l3dgw_ports[0]->cr_port->json_key;\n                }\n\n                if (add_chassis_resident_check) {\n                    ds_put_format(match, \" && is_chassis_resident(%s)\",\n                                  json_key);\n                }\n            }\n\n            build_lrouter_arp_flow(op->od, op,\n                                   op->lrp_networks.ipv4_addrs[i].addr_s,\n                                   REG_INPORT_ETH_ADDR, match, false, 90,\n                                   &op->nbrp->header_, lflows);\n        }\n\n        if (sset_count(&op->od->lb_ips->ips_v4_reachable)) {\n            ds_clear(match);\n            if (is_l3dgw_port(op)) {\n                ds_put_format(match, \"is_chassis_resident(%s)\",\n                              op->cr_port->json_key);\n            }\n\n            /* Create a single ARP rule for all IPs that are used as VIPs. */\n            char *lb_ips_v4_as = lr_lb_address_set_ref(op->od->tunnel_key,\n                                                       AF_INET);\n            build_lrouter_arp_flow(op->od, op, lb_ips_v4_as,\n                                   REG_INPORT_ETH_ADDR,\n                                   match, false, 90, NULL, lflows);\n            free(lb_ips_v4_as);\n        }\n\n        if (sset_count(&op->od->lb_ips->ips_v6_reachable)) {\n            ds_clear(match);\n\n            if (is_l3dgw_port(op)) {\n                ds_put_format(match, \"is_chassis_resident(%s)\",\n                              op->cr_port->json_key);\n            }\n\n            /* Create a single ND rule for all IPs that are used as VIPs. */\n            char *lb_ips_v6_as = lr_lb_address_set_ref(op->od->tunnel_key,\n                                                       AF_INET6);\n            build_lrouter_nd_flow(op->od, op, \"nd_na\", lb_ips_v6_as, NULL,\n                                  REG_INPORT_ETH_ADDR, match, false, 90,\n                                  NULL, lflows, meter_groups);\n            free(lb_ips_v6_as);\n        }\n\n        if (!op->od->is_gw_router && !op->od->n_l3dgw_ports) {\n            /* UDP/TCP/SCTP port unreachable. */\n            for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip4 && ip4.dst == %s && !ip.later_frag && udp\",\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n                const char *action = \"icmp4 {\"\n                                     \"eth.dst <-> eth.src; \"\n                                     \"ip4.dst <-> ip4.src; \"\n                                     \"ip.ttl = 255; \"\n                                     \"icmp4.type = 3; \"\n                                     \"icmp4.code = 3; \"\n                                     \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_ICMP4_ERR,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip4 && ip4.dst == %s && !ip.later_frag && tcp\",\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n                action = \"tcp_reset {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip4.dst <-> ip4.src; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_TCP_RESET,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip4 && ip4.dst == %s && !ip.later_frag && sctp\",\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n                action = \"sctp_abort {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip4.dst <-> ip4.src; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          80, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_TCP_RESET,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n\n                ds_clear(match);\n                ds_put_format(match,\n                              \"ip4 && ip4.dst == %s && !ip.later_frag\",\n                              op->lrp_networks.ipv4_addrs[i].addr_s);\n                action = \"icmp4 {\"\n                         \"eth.dst <-> eth.src; \"\n                         \"ip4.dst <-> ip4.src; \"\n                         \"ip.ttl = 255; \"\n                         \"icmp4.type = 3; \"\n                         \"icmp4.code = 2; \"\n                         \"next; };\";\n                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,\n                                          70, ds_cstr(match), action, NULL,\n                                          copp_meter_get(\n                                              COPP_ICMP4_ERR,\n                                              op->od->nbr->copp,\n                                              meter_groups),\n                                          &op->nbrp->header_);\n            }\n        }\n\n        /* Drop IP traffic destined to router owned IPs except if the IP is\n         * also a SNAT IP. Those are dropped later, in stage\n         * \"lr_in_arp_resolve\", if unSNAT was unsuccessful.\n         *\n         * If op->od->lb_force_snat_router_ip is true, it means the IP of the\n         * router port is also SNAT IP.\n         *\n         * Priority 60.\n         */\n        if (!op->od->lb_force_snat_router_ip) {\n            build_lrouter_drop_own_dest(op, S_ROUTER_IN_IP_INPUT, 60, false,\n                                        lflows);\n        }\n        /* ARP / ND handling for external IP addresses.\n         *\n         * DNAT and SNAT IP addresses are external IP addresses that need ARP\n         * handling.\n         *\n         * These are already taken care globally, per router. The only\n         * exception is on the l3dgw_port where we might need to use a\n         * different ETH address.\n         */\n        if (!is_l3dgw_port(op)) {\n            return;\n        }\n\n        for (size_t i = 0; i < op->od->nbr->n_nat; i++) {\n            struct ovn_nat *nat_entry = &op->od->nat_entries[i];\n\n            /* Skip entries we failed to parse. */\n            if (!nat_entry_is_valid(nat_entry)) {\n                continue;\n            }\n\n            /* Skip SNAT entries for now, we handle unique SNAT IPs separately\n             * below.\n             */\n            if (!strcmp(nat_entry->nb->type, \"snat\")) {\n                continue;\n            }\n            build_lrouter_port_nat_arp_nd_flow(op, nat_entry, lflows,\n                                               meter_groups);\n        }\n\n        /* Now handle SNAT entries too, one per unique SNAT IP. */\n        struct shash_node *snat_snode;\n        SHASH_FOR_EACH (snat_snode, &op->od->snat_ips) {\n            struct ovn_snat_ip *snat_ip = snat_snode->data;\n\n            if (ovs_list_is_empty(&snat_ip->snat_entries)) {\n                continue;\n            }\n\n            struct ovn_nat *nat_entry =\n                CONTAINER_OF(ovs_list_front(&snat_ip->snat_entries),\n                             struct ovn_nat, ext_addr_list_node);\n            build_lrouter_port_nat_arp_nd_flow(op, nat_entry, lflows,\n                                               meter_groups);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_in_unsnat_flow(struct hmap *lflows, struct ovn_datapath *od,\n                             const struct nbrec_nat *nat, struct ds *match,\n                             struct ds *actions, bool distributed, bool is_v6,\n                             struct ovn_port *l3dgw_port)\n{\n    /* Ingress UNSNAT table: It is for already established connections'\n    * reverse traffic. i.e., SNAT has already been done in egress\n    * pipeline and now the packet has entered the ingress pipeline as\n    * part of a reply. We undo the SNAT here.\n    *\n    * Undoing SNAT has to happen before DNAT processing.  This is\n    * because when the packet was DNATed in ingress pipeline, it did\n    * not know about the possibility of eventual additional SNAT in\n    * egress pipeline. */\n    if (strcmp(nat->type, \"snat\") && strcmp(nat->type, \"dnat_and_snat\")) {\n        return;\n    }\n\n    bool stateless = lrouter_dnat_and_snat_is_stateless(nat);\n    if (od->is_gw_router) {\n        ds_clear(match);\n        ds_clear(actions);\n        ds_put_format(match, \"ip && ip%s.dst == %s\",\n                      is_v6 ? \"6\" : \"4\", nat->external_ip);\n        if (stateless) {\n            ds_put_format(actions, \"next;\");\n        } else {\n            ds_put_cstr(actions, \"ct_snat;\");\n        }\n\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT,\n                                90, ds_cstr(match), ds_cstr(actions),\n                                &nat->header_);\n    } else {\n        /* Distributed router. */\n\n        /* Traffic received on l3dgw_port is subject to NAT. */\n        ds_clear(match);\n        ds_clear(actions);\n        ds_put_format(match, \"ip && ip%s.dst == %s && inport == %s && \"\n                      \"flags.loopback == 0\", is_v6 ? \"6\" : \"4\",\n                      nat->external_ip, l3dgw_port->json_key);\n        if (!distributed && od->n_l3dgw_ports) {\n            /* Flows for NAT rules that are centralized are only\n            * programmed on the gateway chassis. */\n            ds_put_format(match, \" && is_chassis_resident(%s)\",\n                          l3dgw_port->cr_port->json_key);\n        }\n\n        if (stateless) {\n            ds_put_format(actions, \"next;\");\n        } else {\n            ds_put_cstr(actions, \"ct_snat_in_czone;\");\n        }\n\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT,\n                                100, ds_cstr(match), ds_cstr(actions),\n                                &nat->header_);\n\n        if (!stateless) {\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match, \"ip && ip%s.dst == %s && inport == %s && \"\n                          \"flags.loopback == 1 && flags.use_snat_zone == 1\",\n                          is_v6 ? \"6\" : \"4\", nat->external_ip,\n                          l3dgw_port->json_key);\n            if (!distributed && od->n_l3dgw_ports) {\n                /* Flows for NAT rules that are centralized are only\n                * programmed on the gateway chassis. */\n                ds_put_format(match, \" && is_chassis_resident(%s)\",\n                            l3dgw_port->cr_port->json_key);\n            }\n            ds_put_cstr(actions, \"ct_snat;\");\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT,\n                                    100, ds_cstr(match), ds_cstr(actions),\n                                    &nat->header_);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_in_dnat_flow(struct hmap *lflows, struct ovn_datapath *od,\n                           const struct nbrec_nat *nat, struct ds *match,\n                           struct ds *actions, bool distributed,\n                           int cidr_bits, bool is_v6,\n                           struct ovn_port *l3dgw_port)\n{\n    /* Ingress DNAT table: Packets enter the pipeline with destination\n    * IP address that needs to be DNATted from a external IP address\n    * to a logical IP address. */\n    if (!strcmp(nat->type, \"dnat\") || !strcmp(nat->type, \"dnat_and_snat\")) {\n        bool stateless = lrouter_dnat_and_snat_is_stateless(nat);\n\n        if (od->is_gw_router) {\n            /* Packet when it goes from the initiator to destination.\n             * We need to set flags.loopback because the router can\n             * send the packet back through the same interface. */\n            ds_clear(match);\n            ds_put_format(match, \"ip && ip%s.dst == %s\",\n                          is_v6 ? \"6\" : \"4\", nat->external_ip);\n            ds_clear(actions);\n            if (nat->allowed_ext_ips || nat->exempted_ext_ips) {\n                lrouter_nat_add_ext_ip_match(od, lflows, match, nat,\n                                             is_v6, true, cidr_bits);\n            }\n\n            if (!lport_addresses_is_empty(&od->dnat_force_snat_addrs)) {\n                /* Indicate to the future tables that a DNAT has taken\n                 * place and a force SNAT needs to be done in the\n                 * Egress SNAT table. */\n                ds_put_format(actions, \"flags.force_snat_for_dnat = 1; \");\n            }\n\n            if (stateless) {\n                ds_put_format(actions, \"flags.loopback = 1; \"\n                              \"ip%s.dst=%s; next;\",\n                              is_v6 ? \"6\" : \"4\", nat->logical_ip);\n            } else {\n                ds_put_format(actions, \"flags.loopback = 1; ct_dnat(%s\",\n                              nat->logical_ip);\n\n                if (nat->external_port_range[0]) {\n                    ds_put_format(actions, \",%s\", nat->external_port_range);\n                }\n                ds_put_format(actions, \");\");\n            }\n\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_DNAT, 100,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &nat->header_);\n        } else {\n            /* Distributed router. */\n\n            /* Traffic received on l3dgw_port is subject to NAT. */\n            ds_clear(match);\n            ds_put_format(match, \"ip && ip%s.dst == %s && inport == %s\",\n                          is_v6 ? \"6\" : \"4\", nat->external_ip,\n                          l3dgw_port->json_key);\n            if (!distributed && od->n_l3dgw_ports) {\n                /* Flows for NAT rules that are centralized are only\n                * programmed on the gateway chassis. */\n                ds_put_format(match, \" && is_chassis_resident(%s)\",\n                              l3dgw_port->cr_port->json_key);\n            }\n            ds_clear(actions);\n            if (nat->allowed_ext_ips || nat->exempted_ext_ips) {\n                lrouter_nat_add_ext_ip_match(od, lflows, match, nat,\n                                             is_v6, true, cidr_bits);\n            }\n\n            if (!strcmp(nat->type, \"dnat_and_snat\") && stateless) {\n                ds_put_format(actions, \"ip%s.dst=%s; next;\",\n                              is_v6 ? \"6\" : \"4\", nat->logical_ip);\n            } else {\n                ds_put_format(actions, \"ct_dnat_in_czone(%s\", nat->logical_ip);\n                if (nat->external_port_range[0]) {\n                    ds_put_format(actions, \",%s\", nat->external_port_range);\n                }\n                ds_put_format(actions, \");\");\n            }\n\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_DNAT, 100,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &nat->header_);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_out_undnat_flow(struct hmap *lflows, struct ovn_datapath *od,\n                              const struct nbrec_nat *nat, struct ds *match,\n                              struct ds *actions, bool distributed,\n                              struct eth_addr mac, bool is_v6,\n                              struct ovn_port *l3dgw_port)\n{\n    /* Egress UNDNAT table: It is for already established connections'\n    * reverse traffic. i.e., DNAT has already been done in ingress\n    * pipeline and now the packet has entered the egress pipeline as\n    * part of a reply. We undo the DNAT here.\n    *\n    * Note that this only applies for NAT on a distributed router.\n    */\n    if (!od->n_l3dgw_ports ||\n        (strcmp(nat->type, \"dnat\") && strcmp(nat->type, \"dnat_and_snat\"))) {\n        return;\n    }\n\n    ds_clear(match);\n    ds_put_format(match, \"ip && ip%s.src == %s && outport == %s\",\n                  is_v6 ? \"6\" : \"4\", nat->logical_ip,\n                  l3dgw_port->json_key);\n    if (!distributed && od->n_l3dgw_ports) {\n        /* Flows for NAT rules that are centralized are only\n        * programmed on the gateway chassis. */\n        ds_put_format(match, \" && is_chassis_resident(%s)\",\n                      l3dgw_port->cr_port->json_key);\n    }\n    ds_clear(actions);\n    if (distributed) {\n        ds_put_format(actions, \"eth.src = \"ETH_ADDR_FMT\"; \",\n                      ETH_ADDR_ARGS(mac));\n    }\n\n    if (lrouter_dnat_and_snat_is_stateless(nat)) {\n        ds_put_format(actions, \"next;\");\n    } else {\n        ds_put_format(actions,\n                      od->is_gw_router ? \"ct_dnat;\" : \"ct_dnat_in_czone;\");\n    }\n\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_UNDNAT, 100,\n                            ds_cstr(match), ds_cstr(actions),\n                            &nat->header_);\n}\n\nstatic void\nbuild_lrouter_out_is_dnat_local(struct hmap *lflows, struct ovn_datapath *od,\n                                const struct nbrec_nat *nat, struct ds *match,\n                                struct ds *actions, bool distributed,\n                                bool is_v6, struct ovn_port *l3dgw_port)\n{\n    /* Note that this only applies for NAT on a distributed router.\n     */\n    if (!od->n_l3dgw_ports) {\n        return;\n    }\n\n    ds_clear(match);\n    ds_put_format(match, \"ip && ip%s.dst == %s && \",\n                  is_v6 ? \"6\" : \"4\", nat->external_ip);\n    if (distributed) {\n        ds_put_format(match, \"is_chassis_resident(\\\"%s\\\")\", nat->logical_port);\n    } else {\n        ds_put_format(match, \"is_chassis_resident(%s)\",\n                      l3dgw_port->cr_port->json_key);\n    }\n\n    ds_clear(actions);\n    ds_put_cstr(actions, REGBIT_DST_NAT_IP_LOCAL\" = 1; next;\");\n\n    ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_CHECK_DNAT_LOCAL,\n                            50, ds_cstr(match), ds_cstr(actions),\n                            &nat->header_);\n}\n\nstatic void\nbuild_lrouter_out_snat_flow(struct hmap *lflows, struct ovn_datapath *od,\n                            const struct nbrec_nat *nat, struct ds *match,\n                            struct ds *actions, bool distributed,\n                            struct eth_addr mac, int cidr_bits, bool is_v6,\n                            struct ovn_port *l3dgw_port)\n{\n    /* Egress SNAT table: Packets enter the egress pipeline with\n    * source ip address that needs to be SNATted to a external ip\n    * address. */\n    if (strcmp(nat->type, \"snat\") && strcmp(nat->type, \"dnat_and_snat\")) {\n        return;\n    }\n\n    bool stateless = lrouter_dnat_and_snat_is_stateless(nat);\n    if (od->is_gw_router) {\n        ds_clear(match);\n        ds_put_format(match, \"ip && ip%s.src == %s\",\n                      is_v6 ? \"6\" : \"4\", nat->logical_ip);\n        ds_clear(actions);\n\n        if (nat->allowed_ext_ips || nat->exempted_ext_ips) {\n            lrouter_nat_add_ext_ip_match(od, lflows, match, nat,\n                                         is_v6, false, cidr_bits);\n        }\n\n        if (!strcmp(nat->type, \"dnat_and_snat\") && stateless) {\n            ds_put_format(actions, \"ip%s.src=%s; next;\",\n                          is_v6 ? \"6\" : \"4\", nat->external_ip);\n        } else {\n            ds_put_format(match, \" && (!ct.trk || !ct.rpl)\");\n            ds_put_format(actions, \"ct_snat(%s\", nat->external_ip);\n\n            if (nat->external_port_range[0]) {\n                ds_put_format(actions, \",%s\",\n                              nat->external_port_range);\n            }\n            ds_put_format(actions, \");\");\n        }\n\n        /* The priority here is calculated such that the\n        * nat->logical_ip with the longest mask gets a higher\n        * priority. */\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_SNAT,\n                                cidr_bits + 1, ds_cstr(match),\n                                ds_cstr(actions), &nat->header_);\n    } else {\n        uint16_t priority = cidr_bits + 1;\n\n        /* Distributed router. */\n        ds_clear(match);\n        ds_put_format(match, \"ip && ip%s.src == %s && outport == %s\",\n                      is_v6 ? \"6\" : \"4\", nat->logical_ip,\n                      l3dgw_port->json_key);\n        if (od->n_l3dgw_ports) {\n            if (distributed) {\n                ovs_assert(nat->logical_port);\n                priority += 128;\n                ds_put_format(match, \" && is_chassis_resident(\\\"%s\\\")\",\n                              nat->logical_port);\n            } else {\n                /* Flows for NAT rules that are centralized are only\n                * programmed on the gateway chassis. */\n                priority += 128;\n                ds_put_format(match, \" && is_chassis_resident(%s)\",\n                              l3dgw_port->cr_port->json_key);\n            }\n        }\n        ds_clear(actions);\n\n        if (nat->allowed_ext_ips || nat->exempted_ext_ips) {\n            lrouter_nat_add_ext_ip_match(od, lflows, match, nat,\n                                         is_v6, false, cidr_bits);\n        }\n\n        if (distributed) {\n            ds_put_format(actions, \"eth.src = \"ETH_ADDR_FMT\"; \",\n                          ETH_ADDR_ARGS(mac));\n        }\n\n        if (stateless) {\n            ds_put_format(actions, \"ip%s.src=%s; next;\",\n                          is_v6 ? \"6\" : \"4\", nat->external_ip);\n        } else {\n            ds_put_format(actions, \"ct_snat_in_czone(%s\",\n                        nat->external_ip);\n            if (nat->external_port_range[0]) {\n                ds_put_format(actions, \",%s\", nat->external_port_range);\n            }\n            ds_put_format(actions, \");\");\n        }\n\n        /* The priority here is calculated such that the\n        * nat->logical_ip with the longest mask gets a higher\n        * priority. */\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_SNAT,\n                                priority, ds_cstr(match),\n                                ds_cstr(actions), &nat->header_);\n\n        if (!stateless) {\n            ds_put_cstr(match, \" && \"REGBIT_DST_NAT_IP_LOCAL\" == 1\");\n            ds_clear(actions);\n            if (distributed) {\n                ds_put_format(actions, \"eth.src = \"ETH_ADDR_FMT\"; \",\n                              ETH_ADDR_ARGS(mac));\n            }\n            ds_put_format(actions,  REGBIT_DST_NAT_IP_LOCAL\" = 0; ct_snat(%s\",\n                          nat->external_ip);\n            if (nat->external_port_range[0]) {\n                ds_put_format(actions, \",%s\", nat->external_port_range);\n            }\n            ds_put_format(actions, \");\");\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_SNAT,\n                                    priority + 1, ds_cstr(match),\n                                    ds_cstr(actions), &nat->header_);\n        }\n    }\n}\n\nstatic void\nbuild_lrouter_ingress_nat_check_pkt_len(struct hmap *lflows,\n                                        const struct nbrec_nat *nat,\n                                        struct ovn_datapath *od, bool is_v6,\n                                        struct ds *match, struct ds *actions,\n                                        int mtu, struct ovn_port *l3dgw_port,\n                                        const struct shash *meter_groups)\n{\n        ds_clear(match);\n        ds_put_format(match, \"inport == %s && \"REGBIT_PKT_LARGER\n                      \" && \"REGBIT_EGRESS_LOOPBACK\" == 0\",\n                      l3dgw_port->json_key);\n\n        ds_clear(actions);\n        if (!is_v6) {\n            ds_put_format(match, \" && ip4 && ip4.dst == %s\", nat->external_ip);\n            /* Set icmp4.frag_mtu to gw_mtu */\n            ds_put_format(actions,\n                \"icmp4_error {\"\n                REGBIT_EGRESS_LOOPBACK\" = 1; \"\n                REGBIT_PKT_LARGER\" = 0; \"\n                \"eth.dst = eth.src; \"\n                \"eth.src = %s; \"\n                \"ip4.dst = ip4.src; \"\n                \"ip4.src = %s; \"\n                \"ip.ttl = 254; \"\n                \"icmp4.type = 3; /* Destination Unreachable. */ \"\n                \"icmp4.code = 4; /* Frag Needed and DF was Set. */ \"\n                \"icmp4.frag_mtu = %d; \"\n                \"outport = %s; flags.loopback = 1; output; };\",\n                nat->external_mac,\n                nat->external_ip,\n                mtu, l3dgw_port->json_key);\n            ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_IP_INPUT, 160,\n                                      ds_cstr(match), ds_cstr(actions),\n                                      NULL,\n                                      copp_meter_get(\n                                            COPP_ICMP4_ERR,\n                                            od->nbr->copp,\n                                            meter_groups),\n                                      &nat->header_);\n        } else {\n            ds_put_format(match, \" && ip6 && ip6.dst == %s\", nat->external_ip);\n            /* Set icmp6.frag_mtu to gw_mtu */\n            ds_put_format(actions,\n                \"icmp6_error {\"\n                REGBIT_EGRESS_LOOPBACK\" = 1; \"\n                REGBIT_PKT_LARGER\" = 0; \"\n                \"eth.dst = eth.src; \"\n                \"eth.src = %s; \"\n                \"ip6.dst = ip6.src; \"\n                \"ip6.src = %s; \"\n                \"ip.ttl = 254; \"\n                \"icmp6.type = 2; /* Packet Too Big. */ \"\n                \"icmp6.code = 0; \"\n                \"icmp6.frag_mtu = %d; \"\n                \"outport = %s; flags.loopback = 1; output; };\",\n                nat->external_mac,\n                nat->external_ip,\n                mtu, l3dgw_port->json_key);\n            ovn_lflow_add_with_hint__(lflows, od, S_ROUTER_IN_IP_INPUT, 160,\n                                      ds_cstr(match), ds_cstr(actions),\n                                      NULL,\n                                      copp_meter_get(\n                                            COPP_ICMP6_ERR,\n                                            od->nbr->copp,\n                                            meter_groups),\n                                      &nat->header_);\n        }\n}\n\nstatic void\nbuild_lrouter_ingress_flow(struct hmap *lflows, struct ovn_datapath *od,\n                           const struct nbrec_nat *nat, struct ds *match,\n                           struct ds *actions, struct eth_addr mac,\n                           bool distributed, bool is_v6,\n                           struct ovn_port *l3dgw_port,\n                           const struct shash *meter_groups)\n{\n    if (od->n_l3dgw_ports && !strcmp(nat->type, \"snat\")) {\n        ds_clear(match);\n        ds_put_format(\n            match, \"inport == %s && %s == %s\",\n            l3dgw_port->json_key,\n            is_v6 ? \"ip6.src\" : \"ip4.src\", nat->external_ip);\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_IP_INPUT,\n                                120, ds_cstr(match), \"next;\",\n                                &nat->header_);\n    }\n    /* Logical router ingress table 0:\n    * For NAT on a distributed router, add rules allowing\n    * ingress traffic with eth.dst matching nat->external_mac\n    * on the l3dgw_port instance where nat->logical_port is\n    * resident. */\n    if (distributed) {\n        /* Store the ethernet address of the port receiving the packet.\n        * This will save us from having to match on inport further\n        * down in the pipeline.\n        */\n        int gw_mtu = smap_get_int(&l3dgw_port->nbrp->options,\n                                  \"gateway_mtu\", 0);\n        ds_clear(match);\n        ds_put_format(match,\n                      \"eth.dst == \"ETH_ADDR_FMT\" && inport == %s\"\n                      \" && is_chassis_resident(\\\"%s\\\")\",\n                      ETH_ADDR_ARGS(mac),\n                      l3dgw_port->json_key,\n                      nat->logical_port);\n        build_gateway_mtu_flow(lflows, l3dgw_port,\n                               S_ROUTER_IN_ADMISSION, 50, 55,\n                               match, actions, &nat->header_,\n                               REG_INPORT_ETH_ADDR \" = %s; next;\",\n                               l3dgw_port->lrp_networks.ea_s);\n        if (gw_mtu) {\n            build_lrouter_ingress_nat_check_pkt_len(lflows, nat, od, is_v6,\n                                                    match, actions, gw_mtu,\n                                                    l3dgw_port, meter_groups);\n        }\n    }\n}\n\nstatic int\nlrouter_check_nat_entry(struct ovn_datapath *od, const struct nbrec_nat *nat,\n                        const struct hmap *ports, ovs_be32 *mask,\n                        bool *is_v6, int *cidr_bits, struct eth_addr *mac,\n                        bool *distributed, struct ovn_port **nat_l3dgw_port)\n{\n    struct in6_addr ipv6, mask_v6, v6_exact = IN6ADDR_EXACT_INIT;\n    ovs_be32 ip;\n\n    if (nat->allowed_ext_ips && nat->exempted_ext_ips) {\n        static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n        VLOG_WARN_RL(&rl, \"NAT rule: \"UUID_FMT\" not applied, since \"\n                    \"both allowed and exempt external ips set\",\n                    UUID_ARGS(&(nat->header_.uuid)));\n        return -EINVAL;\n    }\n\n    char *error = ip_parse_masked(nat->external_ip, &ip, mask);\n    *is_v6 = false;\n\n    if (error || *mask != OVS_BE32_MAX) {\n        free(error);\n        error = ipv6_parse_masked(nat->external_ip, &ipv6, &mask_v6);\n        if (error || memcmp(&mask_v6, &v6_exact, sizeof(mask_v6))) {\n            /* Invalid for both IPv4 and IPv6 */\n            static struct vlog_rate_limit rl =\n                VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad external ip %s for nat\",\n                        nat->external_ip);\n            free(error);\n            return -EINVAL;\n        }\n        /* It was an invalid IPv4 address, but valid IPv6.\n        * Treat the rest of the handling of this NAT rule\n        * as IPv6. */\n        *is_v6 = true;\n    }\n\n    /* Validate gateway_port of NAT rule. */\n    *nat_l3dgw_port = NULL;\n    if (nat->gateway_port == NULL) {\n        if (od->n_l3dgw_ports == 1) {\n            *nat_l3dgw_port = od->l3dgw_ports[0];\n        } else if (od->n_l3dgw_ports > 1) {\n            /* Find the DGP reachable for the NAT external IP. */\n            for (size_t i = 0; i < od->n_l3dgw_ports; i++) {\n               if (find_lrp_member_ip(od->l3dgw_ports[i], nat->external_ip)) {\n                   *nat_l3dgw_port = od->l3dgw_ports[i];\n                   break;\n               }\n            }\n            if (*nat_l3dgw_port == NULL) {\n                static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n                VLOG_WARN_RL(&rl, \"Unable to determine gateway_port for NAT \"\n                             \"with external_ip: %s configured on logical \"\n                             \"router: %s with multiple distributed gateway \"\n                             \"ports\", nat->external_ip, od->nbr->name);\n                return -EINVAL;\n            }\n        }\n    } else {\n        *nat_l3dgw_port = ovn_port_find(ports, nat->gateway_port->name);\n\n        if (!(*nat_l3dgw_port) || (*nat_l3dgw_port)->od != od ||\n            !is_l3dgw_port(*nat_l3dgw_port)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"gateway_port: %s of NAT configured on \"\n                         \"logical router: %s is not a valid distributed \"\n                         \"gateway port on that router\",\n                         nat->gateway_port->name, od->nbr->name);\n            return -EINVAL;\n        }\n    }\n\n    /* Check the validity of nat->logical_ip. 'logical_ip' can\n    * be a subnet when the type is \"snat\". */\n    if (*is_v6) {\n        error = ipv6_parse_masked(nat->logical_ip, &ipv6, &mask_v6);\n        *cidr_bits = ipv6_count_cidr_bits(&mask_v6);\n    } else {\n        error = ip_parse_masked(nat->logical_ip, &ip, mask);\n        *cidr_bits = ip_count_cidr_bits(*mask);\n    }\n    if (!strcmp(nat->type, \"snat\")) {\n        if (error) {\n            /* Invalid for both IPv4 and IPv6 */\n            static struct vlog_rate_limit rl =\n                VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad ip network or ip %s for snat \"\n                        \"in router \"UUID_FMT\"\",\n                        nat->logical_ip, UUID_ARGS(&od->key));\n            free(error);\n            return -EINVAL;\n        }\n    } else {\n        if (error || (*is_v6 == false && *mask != OVS_BE32_MAX)\n            || (*is_v6 && memcmp(&mask_v6, &v6_exact,\n                                sizeof mask_v6))) {\n            /* Invalid for both IPv4 and IPv6 */\n            static struct vlog_rate_limit rl =\n                VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad ip %s for dnat in router \"\n                \"\"UUID_FMT\"\", nat->logical_ip, UUID_ARGS(&od->key));\n            free(error);\n            return -EINVAL;\n        }\n    }\n\n    /* For distributed router NAT, determine whether this NAT rule\n     * satisfies the conditions for distributed NAT processing. */\n    *distributed = false;\n    if (od->n_l3dgw_ports && !strcmp(nat->type, \"dnat_and_snat\") &&\n        nat->logical_port && nat->external_mac) {\n        if (eth_addr_from_string(nat->external_mac, mac)) {\n            *distributed = true;\n        } else {\n            static struct vlog_rate_limit rl =\n                VLOG_RATE_LIMIT_INIT(5, 1);\n            VLOG_WARN_RL(&rl, \"bad mac %s for dnat in router \"\n                \"\"UUID_FMT\"\", nat->external_mac, UUID_ARGS(&od->key));\n            return -EINVAL;\n        }\n    }\n\n    return 0;\n}\n\n/* NAT, Defrag and load balancing. */\nstatic void\nbuild_lrouter_nat_defrag_and_lb(struct ovn_datapath *od, struct hmap *lflows,\n                                const struct hmap *ports, struct ds *match,\n                                struct ds *actions,\n                                const struct shash *meter_groups,\n                                const struct chassis_features *features)\n{\n    if (!od->nbr) {\n        return;\n    }\n\n    /* Packets are allowed by default. */\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_DEFRAG, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_UNSNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_CHECK_DNAT_LOCAL, 0, \"1\",\n                  REGBIT_DST_NAT_IP_LOCAL\" = 0; next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_SNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_UNDNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_POST_UNDNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_POST_SNAT, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_EGR_LOOP, 0, \"1\", \"next;\");\n    ovn_lflow_add(lflows, od, S_ROUTER_IN_ECMP_STATEFUL, 0, \"1\", \"next;\");\n\n    const char *ct_flag_reg = features->ct_no_masked_label\n                              ? \"ct_mark\"\n                              : \"ct_label\";\n    /* Ingress DNAT (Priority 50/70).\n     *\n     * Allow traffic that is related to an existing conntrack entry.\n     * At the same time apply NAT for this traffic.\n     *\n     * NOTE: This does not support related data sessions (eg,\n     * a dynamically negotiated FTP data channel), but will allow\n     * related traffic such as an ICMP Port Unreachable through\n     * that's generated from a non-listening UDP port.  */\n    if (od->has_lb_vip && features->ct_lb_related) {\n        ds_clear(match);\n\n        ds_put_cstr(match, \"ct.rel && !ct.est && !ct.new\");\n        size_t match_len = match->length;\n\n        ds_put_format(match, \" && %s.skip_snat == 1\", ct_flag_reg);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 70, ds_cstr(match),\n                      \"flags.skip_snat_for_lb = 1; ct_commit_nat;\");\n\n        ds_truncate(match, match_len);\n        ds_put_format(match, \" && %s.force_snat == 1\", ct_flag_reg);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 70, ds_cstr(match),\n                      \"flags.force_snat_for_lb = 1; ct_commit_nat;\");\n\n        ds_truncate(match, match_len);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 50, ds_cstr(match),\n                      \"ct_commit_nat;\");\n    }\n\n    /* Ingress DNAT (Priority 50/70).\n     *\n     * Pass the traffic that is already established to the next table with\n     * proper flags set.\n     */\n    if (od->has_lb_vip) {\n        ds_clear(match);\n\n        ds_put_format(match, \"ct.est && !ct.rel && !ct.new && %s.natted\",\n                      ct_flag_reg);\n        size_t match_len = match->length;\n\n        ds_put_format(match, \" && %s.skip_snat == 1\", ct_flag_reg);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 70, ds_cstr(match),\n                      \"flags.skip_snat_for_lb = 1; next;\");\n\n        ds_truncate(match, match_len);\n        ds_put_format(match, \" && %s.force_snat == 1\", ct_flag_reg);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 70, ds_cstr(match),\n                      \"flags.force_snat_for_lb = 1; next;\");\n\n        ds_truncate(match, match_len);\n        ovn_lflow_add(lflows, od, S_ROUTER_IN_DNAT, 50, ds_cstr(match),\n                      \"next;\");\n    }\n\n    /* If the router has load balancer or DNAT rules, re-circulate every packet\n     * through the DNAT zone so that packets that need to be unDNATed in the\n     * reverse direction get unDNATed.\n     *\n     * We also commit newly initiated connections in the reply direction to the\n     * DNAT zone. This ensures that these flows are tracked. If the flow was\n     * not committed, it would produce ongoing datapath flows with the ct.new\n     * flag set. Some NICs are unable to offload these flows.\n     */\n    if (od->is_gw_router && (od->nbr->n_nat || od->has_lb_vip)) {\n        /* Do not send ND or ICMP packets to connection tracking. */\n        ovn_lflow_add(lflows, od, S_ROUTER_OUT_UNDNAT, 100,\n                      \"nd || nd_rs || nd_ra\", \"next;\");\n        ovn_lflow_add(lflows, od, S_ROUTER_OUT_UNDNAT, 50,\n                      \"ip\", \"flags.loopback = 1; ct_dnat;\");\n        ovn_lflow_add(lflows, od, S_ROUTER_OUT_POST_UNDNAT, 50,\n                      \"ip && ct.new\", \"ct_commit { } ; next; \");\n    }\n\n    /* Send the IPv6 NS packets to next table. When ovn-controller\n     * generates IPv6 NS (for the action - nd_ns{}), the injected\n     * packet would go through conntrack - which is not required. */\n    ovn_lflow_add(lflows, od, S_ROUTER_OUT_SNAT, 120, \"nd_ns\", \"next;\");\n\n    /* NAT rules are only valid on Gateway routers and routers with\n     * l3dgw_ports (router has port(s) with gateway chassis\n     * specified). */\n    if (!od->is_gw_router && !od->n_l3dgw_ports) {\n        return;\n    }\n\n    struct sset nat_entries = SSET_INITIALIZER(&nat_entries);\n\n    bool dnat_force_snat_ip =\n        !lport_addresses_is_empty(&od->dnat_force_snat_addrs);\n    bool lb_force_snat_ip =\n        !lport_addresses_is_empty(&od->lb_force_snat_addrs);\n\n    for (int i = 0; i < od->nbr->n_nat; i++) {\n        const struct nbrec_nat *nat = nat = od->nbr->nat[i];\n        struct eth_addr mac = eth_addr_broadcast;\n        bool is_v6, distributed;\n        ovs_be32 mask;\n        int cidr_bits;\n        struct ovn_port *l3dgw_port;\n\n        if (lrouter_check_nat_entry(od, nat, ports, &mask, &is_v6, &cidr_bits,\n                                    &mac, &distributed, &l3dgw_port) < 0) {\n            continue;\n        }\n\n        /* S_ROUTER_IN_UNSNAT */\n        build_lrouter_in_unsnat_flow(lflows, od, nat, match, actions, distributed,\n                                     is_v6, l3dgw_port);\n        /* S_ROUTER_IN_DNAT */\n        build_lrouter_in_dnat_flow(lflows, od, nat, match, actions, distributed,\n                                   cidr_bits, is_v6, l3dgw_port);\n\n        /* ARP resolve for NAT IPs. */\n        if (od->is_gw_router) {\n            /* Add the NAT external_ip to the nat_entries for\n             * gateway routers. This is required for adding load balancer\n             * flows.*/\n            sset_add(&nat_entries, nat->external_ip);\n        } else {\n            if (!sset_contains(&nat_entries, nat->external_ip)) {\n                /* Drop packets coming in from external that still has\n                 * destination IP equals to the NAT external IP, to avoid loop.\n                 * The packets must have gone through DNAT/unSNAT stage but\n                 * failed to convert the destination. */\n                ds_clear(match);\n                ds_put_format(\n                    match, \"inport == %s && outport == %s && ip%s.dst == %s\",\n                    l3dgw_port->json_key, l3dgw_port->json_key,\n                    is_v6 ? \"6\" : \"4\", nat->external_ip);\n                ovn_lflow_add_with_hint(lflows, od,\n                                        S_ROUTER_IN_ARP_RESOLVE,\n                                        150, ds_cstr(match),\n                                        debug_drop_action(),\n                                        &nat->header_);\n                /* Now for packets coming from other (downlink) LRPs, allow ARP\n                 * resolve for the NAT IP, so that such packets can be\n                 * forwarded for E/W NAT. */\n                ds_clear(match);\n                ds_put_format(\n                    match, \"outport == %s && %s == %s\",\n                    l3dgw_port->json_key,\n                    is_v6 ? REG_NEXT_HOP_IPV6 : REG_NEXT_HOP_IPV4,\n                    nat->external_ip);\n                ds_clear(actions);\n                ds_put_format(\n                    actions, \"eth.dst = %s; next;\",\n                    distributed ? nat->external_mac :\n                    l3dgw_port->lrp_networks.ea_s);\n                ovn_lflow_add_with_hint(lflows, od,\n                                        S_ROUTER_IN_ARP_RESOLVE,\n                                        100, ds_cstr(match),\n                                        ds_cstr(actions),\n                                        &nat->header_);\n                if (od->redirect_bridged && distributed) {\n                    ds_clear(match);\n                    ds_put_format(\n                            match,\n                            \"outport == %s && ip%s.src == %s \"\n                            \"&& is_chassis_resident(\\\"%s\\\")\",\n                            od->l3dgw_ports[0]->json_key,\n                            is_v6 ? \"6\" : \"4\", nat->logical_ip,\n                            nat->logical_port);\n                    ds_clear(actions);\n                    if (is_v6) {\n                        ds_put_cstr(actions,\n                            \"get_nd(outport, \" REG_NEXT_HOP_IPV6 \"); next;\");\n                    } else {\n                        ds_put_cstr(actions,\n                            \"get_arp(outport, \" REG_NEXT_HOP_IPV4 \"); next;\");\n                    }\n                    ovn_lflow_add_with_hint(lflows, od,\n                                            S_ROUTER_IN_ARP_RESOLVE, 90,\n                                            ds_cstr(match), ds_cstr(actions),\n                                            &nat->header_);\n                }\n                sset_add(&nat_entries, nat->external_ip);\n            }\n        }\n\n        /* S_ROUTER_OUT_DNAT_LOCAL */\n        build_lrouter_out_is_dnat_local(lflows, od, nat, match, actions,\n                                        distributed, is_v6, l3dgw_port);\n\n        /* S_ROUTER_OUT_UNDNAT */\n        build_lrouter_out_undnat_flow(lflows, od, nat, match, actions, distributed,\n                                      mac, is_v6, l3dgw_port);\n        /* S_ROUTER_OUT_SNAT */\n        build_lrouter_out_snat_flow(lflows, od, nat, match, actions, distributed,\n                                    mac, cidr_bits, is_v6, l3dgw_port);\n\n        /* S_ROUTER_IN_ADMISSION - S_ROUTER_IN_IP_INPUT */\n        build_lrouter_ingress_flow(lflows, od, nat, match, actions, mac,\n                                   distributed, is_v6, l3dgw_port,\n                                   meter_groups);\n\n        /* Ingress Gateway Redirect Table: For NAT on a distributed\n         * router, add flows that are specific to a NAT rule.  These\n         * flows indicate the presence of an applicable NAT rule that\n         * can be applied in a distributed manner.\n         * In particulr REG_SRC_IPV4/REG_SRC_IPV6 and eth.src are set to\n         * NAT external IP and NAT external mac so the ARP request\n         * generated in the following stage is sent out with proper IP/MAC\n         * src addresses.\n         */\n        if (distributed) {\n            ds_clear(match);\n            ds_clear(actions);\n            ds_put_format(match,\n                          \"ip%s.src == %s && outport == %s\",\n                          is_v6 ? \"6\" : \"4\", nat->logical_ip,\n                          l3dgw_port->json_key);\n            /* Add a rule to drop traffic from a distributed NAT if\n             * the virtual port has not claimed yet becaused otherwise\n             * the traffic will be centralized misconfiguring the TOR switch.\n             */\n            struct ovn_port *op = ovn_port_find(ports, nat->logical_port);\n            if (op && op->nbsp && !strcmp(op->nbsp->type, \"virtual\")) {\n                ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_GW_REDIRECT,\n                                        80, ds_cstr(match),\n                                        debug_drop_action(), &nat->header_);\n            }\n            ds_put_format(match, \" && is_chassis_resident(\\\"%s\\\")\",\n                          nat->logical_port);\n            ds_put_format(actions, \"eth.src = %s; %s = %s; next;\",\n                          nat->external_mac,\n                          is_v6 ? REG_SRC_IPV6 : REG_SRC_IPV4,\n                          nat->external_ip);\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_GW_REDIRECT,\n                                    100, ds_cstr(match),\n                                    ds_cstr(actions), &nat->header_);\n        }\n\n        /* Egress Loopback table: For NAT on a distributed router.\n         * If packets in the egress pipeline on the distributed\n         * gateway port have ip.dst matching a NAT external IP, then\n         * loop a clone of the packet back to the beginning of the\n         * ingress pipeline with inport = outport. */\n        if (od->n_l3dgw_ports) {\n            /* Distributed router. */\n            ds_clear(match);\n            ds_put_format(match, \"ip%s.dst == %s && outport == %s\",\n                          is_v6 ? \"6\" : \"4\",\n                          nat->external_ip,\n                          l3dgw_port->json_key);\n            if (!distributed) {\n                ds_put_format(match, \" && is_chassis_resident(%s)\",\n                              l3dgw_port->cr_port->json_key);\n            } else {\n                ds_put_format(match, \" && is_chassis_resident(\\\"%s\\\")\",\n                              nat->logical_port);\n            }\n\n            ds_clear(actions);\n            ds_put_format(actions,\n                          \"clone { ct_clear; \"\n                          \"inport = outport; outport = \\\"\\\"; \"\n                          \"eth.dst <-> eth.src; \"\n                          \"flags = 0; flags.loopback = 1; \"\n                          \"flags.use_snat_zone = \"REGBIT_DST_NAT_IP_LOCAL\"; \");\n            for (int j = 0; j < MFF_N_LOG_REGS; j++) {\n                ds_put_format(actions, \"reg%d = 0; \", j);\n            }\n            ds_put_format(actions, REGBIT_EGRESS_LOOPBACK\" = 1; \"\n                          \"next(pipeline=ingress, table=%d); };\",\n                          ovn_stage_get_table(S_ROUTER_IN_ADMISSION));\n            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_EGR_LOOP, 100,\n                                    ds_cstr(match), ds_cstr(actions),\n                                    &nat->header_);\n        }\n    }\n\n    if (od->nbr->n_nat) {\n        ds_clear(match);\n        const char *ct_natted = features->ct_no_masked_label ?\n                                \"ct_mark.natted\" :\n                                \"ct_label.natted\";\n        ds_put_format(match, \"ip && %s == 1\", ct_natted);\n        /* This flow is unique since it is in the egress pipeline but checks\n         * the value of ct_label.natted, which would have been set in the\n         * ingress pipeline. If a change is ever introduced that clears or\n         * otherwise invalidates the ct_label between the ingress and egress\n         * pipelines, then an alternative will need to be devised.\n         */\n        ds_clear(actions);\n        ds_put_cstr(actions, REGBIT_DST_NAT_IP_LOCAL\" = 1; next;\");\n        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_CHECK_DNAT_LOCAL,\n                                50, ds_cstr(match), ds_cstr(actions),\n                                &od->nbr->header_);\n\n    }\n\n    /* Handle force SNAT options set in the gateway router. */\n    if (od->is_gw_router) {\n        if (dnat_force_snat_ip) {\n            if (od->dnat_force_snat_addrs.n_ipv4_addrs) {\n                build_lrouter_force_snat_flows(lflows, od, \"4\",\n                    od->dnat_force_snat_addrs.ipv4_addrs[0].addr_s,\n                    \"dnat\");\n            }\n            if (od->dnat_force_snat_addrs.n_ipv6_addrs) {\n                build_lrouter_force_snat_flows(lflows, od, \"6\",\n                    od->dnat_force_snat_addrs.ipv6_addrs[0].addr_s,\n                    \"dnat\");\n            }\n        }\n        if (lb_force_snat_ip) {\n            if (od->lb_force_snat_addrs.n_ipv4_addrs) {\n                build_lrouter_force_snat_flows(lflows, od, \"4\",\n                    od->lb_force_snat_addrs.ipv4_addrs[0].addr_s, \"lb\");\n            }\n            if (od->lb_force_snat_addrs.n_ipv6_addrs) {\n                build_lrouter_force_snat_flows(lflows, od, \"6\",\n                    od->lb_force_snat_addrs.ipv6_addrs[0].addr_s, \"lb\");\n            }\n        }\n    }\n\n    sset_destroy(&nat_entries);\n}\n\n\n\nstruct lswitch_flow_build_info {\n    const struct hmap *datapaths;\n    const struct hmap *ports;\n    const struct hmap *port_groups;\n    struct hmap *lflows;\n    struct hmap *mcgroups;\n    struct hmap *igmp_groups;\n    const struct shash *meter_groups;\n    const struct hmap *lbs;\n    const struct hmap *bfd_connections;\n    const struct chassis_features *features;\n    char *svc_check_match;\n    struct ds match;\n    struct ds actions;\n    size_t thread_lflow_counter;\n};\n\n/* Helper function to combine all lflow generation which is iterated by\n * datapath.\n *\n * When extending the function new \"work data\" must be added to the lsi\n * struct, not passed as an argument.\n */\n\nstatic void\nbuild_lswitch_and_lrouter_iterate_by_od(struct ovn_datapath *od,\n                                        struct lswitch_flow_build_info *lsi)\n{\n    /* Build Logical Switch Flows. */\n    build_lswitch_lflows_pre_acl_and_acl(od, lsi->port_groups,\n                                         lsi->features,\n                                         lsi->lflows,\n                                         lsi->meter_groups);\n\n    build_fwd_group_lflows(od, lsi->lflows);\n    build_lswitch_lflows_admission_control(od, lsi->lflows);\n    build_lswitch_learn_fdb_od(od, lsi->lflows);\n    build_lswitch_arp_nd_responder_default(od, lsi->lflows);\n    build_lswitch_dns_lookup_and_response(od, lsi->lflows, lsi->meter_groups);\n    build_lswitch_dhcp_and_dns_defaults(od, lsi->lflows);\n    build_lswitch_destination_lookup_bmcast(od, lsi->lflows, &lsi->actions,\n                                            lsi->meter_groups);\n    build_lswitch_output_port_sec_od(od, lsi->lflows);\n\n    /* Build Logical Router Flows. */\n    build_adm_ctrl_flows_for_lrouter(od, lsi->lflows);\n    build_neigh_learning_flows_for_lrouter(od, lsi->lflows, &lsi->match,\n                                           &lsi->actions, lsi->meter_groups);\n    build_ND_RA_flows_for_lrouter(od, lsi->lflows);\n    build_ip_routing_pre_flows_for_lrouter(od, lsi->lflows);\n    build_static_route_flows_for_lrouter(od, lsi->features,\n                                         lsi->lflows, lsi->ports,\n                                         lsi->bfd_connections);\n    build_mcast_lookup_flows_for_lrouter(od, lsi->lflows, &lsi->match,\n                                         &lsi->actions);\n    build_ingress_policy_flows_for_lrouter(od, lsi->lflows, lsi->ports);\n    build_arp_resolve_flows_for_lrouter(od, lsi->lflows);\n    build_check_pkt_len_flows_for_lrouter(od, lsi->lflows, lsi->ports,\n                                          &lsi->match, &lsi->actions,\n                                          lsi->meter_groups);\n    build_gateway_redirect_flows_for_lrouter(od, lsi->lflows, &lsi->match,\n                                             &lsi->actions);\n    build_arp_request_flows_for_lrouter(od, lsi->lflows, &lsi->match,\n                                        &lsi->actions, lsi->meter_groups);\n    build_misc_local_traffic_drop_flows_for_lrouter(od, lsi->lflows);\n    build_lrouter_arp_nd_for_datapath(od, lsi->lflows, lsi->meter_groups);\n    build_lrouter_nat_defrag_and_lb(od, lsi->lflows, lsi->ports, &lsi->match,\n                                    &lsi->actions, lsi->meter_groups,\n                                    lsi->features);\n    build_lb_affinity_default_flows(od, lsi->lflows);\n}\n\n/* Helper function to combine all lflow generation which is iterated by port.\n */\nstatic void\nbuild_lswitch_and_lrouter_iterate_by_op(struct ovn_port *op,\n                                        struct lswitch_flow_build_info *lsi)\n{\n    /* Build Logical Switch Flows. */\n    build_lswitch_port_sec_op(op, lsi->lflows, &lsi->actions, &lsi->match);\n    build_lswitch_learn_fdb_op(op, lsi->lflows, &lsi->actions,\n                               &lsi->match);\n    build_lswitch_arp_nd_responder_skip_local(op, lsi->lflows,\n                                              &lsi->match);\n    build_lswitch_arp_nd_responder_known_ips(op, lsi->lflows,\n                                             lsi->ports,\n                                             lsi->meter_groups,\n                                             &lsi->actions,\n                                             &lsi->match);\n    build_lswitch_dhcp_options_and_response(op, lsi->lflows,\n                                            lsi->meter_groups);\n    build_lswitch_external_port(op, lsi->lflows);\n    build_lswitch_ip_unicast_lookup(op, lsi->lflows, lsi->mcgroups,\n                                    &lsi->actions, &lsi->match);\n\n    /* Build Logical Router Flows. */\n    build_adm_ctrl_flows_for_lrouter_port(op, lsi->lflows, &lsi->match,\n                                          &lsi->actions);\n    build_neigh_learning_flows_for_lrouter_port(op, lsi->lflows, &lsi->match,\n                                                &lsi->actions);\n    build_ip_routing_flows_for_lrouter_port(op, lsi->ports, lsi->lflows);\n    build_ND_RA_flows_for_lrouter_port(op, lsi->lflows, &lsi->match,\n                                       &lsi->actions, lsi->meter_groups);\n    build_arp_resolve_flows_for_lrouter_port(op, lsi->lflows, lsi->ports,\n                                             &lsi->match, &lsi->actions);\n    build_egress_delivery_flows_for_lrouter_port(op, lsi->lflows, &lsi->match,\n                                                 &lsi->actions);\n    build_dhcpv6_reply_flows_for_lrouter_port(op, lsi->lflows, &lsi->match);\n    build_ipv6_input_flows_for_lrouter_port(op, lsi->lflows,\n                                            &lsi->match, &lsi->actions,\n                                            lsi->meter_groups);\n    build_lrouter_ipv4_ip_input(op, lsi->lflows,\n                                &lsi->match, &lsi->actions, lsi->meter_groups);\n    build_lrouter_force_snat_flows_op(op, lsi->lflows, &lsi->match,\n                                      &lsi->actions);\n}\n\nstatic void *\nbuild_lflows_thread(void *arg)\n{\n    struct worker_control *control = (struct worker_control *) arg;\n    struct lswitch_flow_build_info *lsi;\n\n    struct ovn_datapath *od;\n    struct ovn_port *op;\n    struct ovn_northd_lb *lb;\n    struct ovn_igmp_group *igmp_group;\n    int bnum;\n\n    while (!stop_parallel_processing()) {\n        wait_for_work(control);\n        lsi = (struct lswitch_flow_build_info *) control->data;\n        if (stop_parallel_processing()) {\n            return NULL;\n        }\n        thread_lflow_counter = 0;\n        if (lsi) {\n            /* Iterate over bucket ThreadID, ThreadID+size, ... */\n            for (bnum = control->id;\n                    bnum <= lsi->datapaths->mask;\n                    bnum += control->pool->size)\n            {\n                HMAP_FOR_EACH_IN_PARALLEL (od, key_node, bnum, lsi->datapaths) {\n                    if (stop_parallel_processing()) {\n                        return NULL;\n                    }\n                    build_lswitch_and_lrouter_iterate_by_od(od, lsi);\n                }\n            }\n            for (bnum = control->id;\n                    bnum <= lsi->ports->mask;\n                    bnum += control->pool->size)\n            {\n                HMAP_FOR_EACH_IN_PARALLEL (op, key_node, bnum, lsi->ports) {\n                    if (stop_parallel_processing()) {\n                        return NULL;\n                    }\n                    build_lswitch_and_lrouter_iterate_by_op(op, lsi);\n                }\n            }\n            for (bnum = control->id;\n                    bnum <= lsi->lbs->mask;\n                    bnum += control->pool->size)\n            {\n                HMAP_FOR_EACH_IN_PARALLEL (lb, hmap_node, bnum, lsi->lbs) {\n                    if (stop_parallel_processing()) {\n                        return NULL;\n                    }\n                    build_lswitch_arp_nd_service_monitor(lb, lsi->lflows,\n                                                         &lsi->match,\n                                                         &lsi->actions);\n                    build_lrouter_defrag_flows_for_lb(lb, lsi->lflows,\n                                                      &lsi->match);\n                    build_lrouter_flows_for_lb(lb, lsi->lflows,\n                                               lsi->meter_groups,\n                                               lsi->features,\n                                               &lsi->match, &lsi->actions);\n                    build_lswitch_flows_for_lb(lb, lsi->lflows,\n                                               lsi->meter_groups,\n                                               lsi->features,\n                                               &lsi->match, &lsi->actions);\n                }\n            }\n            for (bnum = control->id;\n                    bnum <= lsi->igmp_groups->mask;\n                    bnum += control->pool->size)\n            {\n                HMAP_FOR_EACH_IN_PARALLEL (\n                        igmp_group, hmap_node, bnum, lsi->igmp_groups) {\n                    if (stop_parallel_processing()) {\n                        return NULL;\n                    }\n                    build_lswitch_ip_mcast_igmp_mld(igmp_group, lsi->lflows,\n                                                    &lsi->match,\n                                                    &lsi->actions);\n                }\n            }\n        }\n        lsi->thread_lflow_counter = thread_lflow_counter;\n        post_completed_work(control);\n    }\n    return NULL;\n}\n\nstatic struct worker_pool *build_lflows_pool = NULL;\n\nstatic void\nnoop_callback(struct worker_pool *pool OVS_UNUSED,\n              void *fin_result OVS_UNUSED,\n              void *result_frags OVS_UNUSED,\n              size_t index OVS_UNUSED)\n{\n    /* Do nothing */\n}\n\n/* Fixes the hmap size (hmap->n) after parallel building the lflow_map when\n * dp-groups is enabled, because in that case all threads are updating the\n * global lflow hmap. Although the lflow_hash_lock prevents currently inserting\n * to the same hash bucket, the hmap->n is updated currently by all threads and\n * may not be accurate at the end of each iteration. This function collects the\n * thread-local lflow counters maintained by each thread and update the hmap\n * size with the aggregated value. This function must be called immediately\n * after the worker threads complete the tasks in each iteration before any\n * future operations on the lflow map. */\nstatic void\nfix_flow_map_size(struct hmap *lflow_map,\n                  struct lswitch_flow_build_info *lsiv,\n                  size_t n_lsiv)\n{\n    size_t total = 0;\n    for (size_t i = 0; i < n_lsiv; i++) {\n        total += lsiv[i].thread_lflow_counter;\n    }\n    lflow_map->n = total;\n}\n\nstatic void\nbuild_lswitch_and_lrouter_flows(const struct hmap *datapaths,\n                                const struct hmap *ports,\n                                const struct hmap *port_groups,\n                                struct hmap *lflows,\n                                struct hmap *mcgroups,\n                                struct hmap *igmp_groups,\n                                const struct shash *meter_groups,\n                                const struct hmap *lbs,\n                                const struct hmap *bfd_connections,\n                                const struct chassis_features *features)\n{\n\n    char *svc_check_match = xasprintf(\"eth.dst == %s\", svc_monitor_mac);\n\n    if (parallelization_state == STATE_USE_PARALLELIZATION) {\n        struct lswitch_flow_build_info *lsiv;\n        int index;\n\n        lsiv = xcalloc(sizeof(*lsiv), build_lflows_pool->size);\n\n        /* Set up \"work chunks\" for each thread to work on. */\n\n        for (index = 0; index < build_lflows_pool->size; index++) {\n            /* dp_groups are in use so we lock a shared lflows hash\n             * on a per-bucket level.\n             */\n            lsiv[index].lflows = lflows;\n            lsiv[index].datapaths = datapaths;\n            lsiv[index].ports = ports;\n            lsiv[index].port_groups = port_groups;\n            lsiv[index].mcgroups = mcgroups;\n            lsiv[index].igmp_groups = igmp_groups;\n            lsiv[index].meter_groups = meter_groups;\n            lsiv[index].lbs = lbs;\n            lsiv[index].bfd_connections = bfd_connections;\n            lsiv[index].features = features;\n            lsiv[index].svc_check_match = svc_check_match;\n            lsiv[index].thread_lflow_counter = 0;\n            ds_init(&lsiv[index].match);\n            ds_init(&lsiv[index].actions);\n\n            build_lflows_pool->controls[index].data = &lsiv[index];\n        }\n\n        /* Run thread pool. */\n        run_pool_callback(build_lflows_pool, NULL, NULL, noop_callback);\n        fix_flow_map_size(lflows, lsiv, build_lflows_pool->size);\n\n        for (index = 0; index < build_lflows_pool->size; index++) {\n            ds_destroy(&lsiv[index].match);\n            ds_destroy(&lsiv[index].actions);\n        }\n        free(lsiv);\n    } else {\n        struct ovn_datapath *od;\n        struct ovn_port *op;\n        struct ovn_northd_lb *lb;\n        struct ovn_igmp_group *igmp_group;\n        struct lswitch_flow_build_info lsi = {\n            .datapaths = datapaths,\n            .ports = ports,\n            .port_groups = port_groups,\n            .lflows = lflows,\n            .mcgroups = mcgroups,\n            .igmp_groups = igmp_groups,\n            .meter_groups = meter_groups,\n            .lbs = lbs,\n            .bfd_connections = bfd_connections,\n            .features = features,\n            .svc_check_match = svc_check_match,\n            .match = DS_EMPTY_INITIALIZER,\n            .actions = DS_EMPTY_INITIALIZER,\n        };\n\n        /* Combined build - all lflow generation from lswitch and lrouter\n         * will move here and will be reogranized by iterator type.\n         */\n        stopwatch_start(LFLOWS_DATAPATHS_STOPWATCH_NAME, time_msec());\n        HMAP_FOR_EACH (od, key_node, datapaths) {\n            build_lswitch_and_lrouter_iterate_by_od(od, &lsi);\n        }\n        stopwatch_stop(LFLOWS_DATAPATHS_STOPWATCH_NAME, time_msec());\n        stopwatch_start(LFLOWS_PORTS_STOPWATCH_NAME, time_msec());\n        HMAP_FOR_EACH (op, key_node, ports) {\n            build_lswitch_and_lrouter_iterate_by_op(op, &lsi);\n        }\n        stopwatch_stop(LFLOWS_PORTS_STOPWATCH_NAME, time_msec());\n        stopwatch_start(LFLOWS_LBS_STOPWATCH_NAME, time_msec());\n        HMAP_FOR_EACH (lb, hmap_node, lbs) {\n            build_lswitch_arp_nd_service_monitor(lb, lsi.lflows,\n                                                 &lsi.actions,\n                                                 &lsi.match);\n            build_lrouter_defrag_flows_for_lb(lb, lsi.lflows, &lsi.match);\n            build_lrouter_flows_for_lb(lb, lsi.lflows, lsi.meter_groups,\n                                       lsi.features, &lsi.match, &lsi.actions);\n            build_lswitch_flows_for_lb(lb, lsi.lflows, lsi.meter_groups,\n                                       lsi.features, &lsi.match, &lsi.actions);\n        }\n        stopwatch_stop(LFLOWS_LBS_STOPWATCH_NAME, time_msec());\n        stopwatch_start(LFLOWS_IGMP_STOPWATCH_NAME, time_msec());\n        HMAP_FOR_EACH (igmp_group, hmap_node, igmp_groups) {\n            build_lswitch_ip_mcast_igmp_mld(igmp_group,\n                                            lsi.lflows,\n                                            &lsi.actions,\n                                            &lsi.match);\n        }\n        stopwatch_stop(LFLOWS_IGMP_STOPWATCH_NAME, time_msec());\n\n        ds_destroy(&lsi.match);\n        ds_destroy(&lsi.actions);\n    }\n\n    free(svc_check_match);\n    build_lswitch_flows(datapaths, lflows);\n}\n\nstatic void\novn_sb_set_lflow_logical_dp_group(\n    struct ovsdb_idl_txn *ovnsb_txn,\n    struct hmap *dp_groups,\n    const struct sbrec_logical_flow *sbflow,\n    const unsigned long *dpg_bitmap)\n{\n    struct ovn_dp_group *dpg;\n    size_t n_ods;\n\n    n_ods = bitmap_count1(dpg_bitmap, n_datapaths);\n\n    if (!n_ods) {\n        sbrec_logical_flow_set_logical_dp_group(sbflow, NULL);\n        return;\n    }\n\n    ovs_assert(n_ods != 1);\n\n    dpg = ovn_dp_group_find(dp_groups, dpg_bitmap, hash_int(n_ods, 0));\n    ovs_assert(dpg != NULL);\n\n    if (!dpg->dp_group) {\n        dpg->dp_group = ovn_sb_insert_logical_dp_group(ovnsb_txn, dpg->bitmap);\n    }\n    sbrec_logical_flow_set_logical_dp_group(sbflow, dpg->dp_group);\n}\n\nstatic ssize_t max_seen_lflow_size = 128;\n\nvoid run_update_worker_pool(int n_threads)\n{\n    /* If number of threads has been updated (or initially set),\n     * update the worker pool. */\n    if (update_worker_pool(n_threads, &build_lflows_pool,\n                           build_lflows_thread) != POOL_UNCHANGED) {\n        /* worker pool was updated */\n        if (get_worker_pool_size() <= 1) {\n            /* destroy potentially created lflow_hash_lock */\n            lflow_hash_lock_destroy();\n            parallelization_state = STATE_NULL;\n        } else if (parallelization_state != STATE_USE_PARALLELIZATION) {\n            lflow_hash_lock_init();\n            parallelization_state = STATE_INIT_HASH_SIZES;\n        }\n    }\n}\n\nstatic void\nbuild_mcast_groups(struct lflow_input *data,\n                   const struct hmap *datapaths,\n                   const struct hmap *ports,\n                   struct hmap *mcast_groups,\n                   struct hmap *igmp_groups);\n\n/* Updates the Logical_Flow and Multicast_Group tables in the OVN_SB database,\n * constructing their contents based on the OVN_NB database. */\nvoid build_lflows(struct lflow_input *input_data,\n                  struct ovsdb_idl_txn *ovnsb_txn)\n{\n    struct hmap lflows;\n    struct hmap mcast_groups;\n    struct hmap igmp_groups;\n\n    build_mcast_groups(input_data, input_data->datapaths, input_data->ports,\n                       &mcast_groups, &igmp_groups);\n\n    fast_hmap_size_for(&lflows, max_seen_lflow_size);\n\n    build_lswitch_and_lrouter_flows(input_data->datapaths, input_data->ports,\n                                    input_data->port_groups, &lflows,\n                                    &mcast_groups, &igmp_groups,\n                                    input_data->meter_groups, input_data->lbs,\n                                    input_data->bfd_connections,\n                                    input_data->features);\n\n    if (parallelization_state == STATE_INIT_HASH_SIZES) {\n        parallelization_state = STATE_USE_PARALLELIZATION;\n    }\n\n    /* Parallel build may result in a suboptimal hash. Resize the\n     * hash to a correct size before doing lookups */\n\n    hmap_expand(&lflows);\n\n    if (hmap_count(&lflows) > max_seen_lflow_size) {\n        max_seen_lflow_size = hmap_count(&lflows);\n    }\n\n    stopwatch_start(LFLOWS_DP_GROUPS_STOPWATCH_NAME, time_msec());\n    /* Collecting all unique datapath groups. */\n    struct hmap dp_groups = HMAP_INITIALIZER(&dp_groups);\n    struct hmap single_dp_lflows;\n\n    /* Single dp_flows will never grow bigger than lflows,\n     * thus the two hmaps will remain the same size regardless\n     * of how many elements we remove from lflows and add to\n     * single_dp_lflows.\n     * Note - lflows is always sized for at least 128 flows.\n     */\n    fast_hmap_size_for(&single_dp_lflows, max_seen_lflow_size);\n\n    struct ovn_lflow *lflow;\n    HMAP_FOR_EACH_SAFE (lflow, hmap_node, &lflows) {\n        struct ovn_dp_group *dpg;\n        uint32_t hash, n_ods;\n\n        n_ods = bitmap_count1(lflow->dpg_bitmap, n_datapaths);\n\n        ovs_assert(n_ods);\n\n        if (n_ods == 1) {\n            /* There is only one datapath, so it should be moved out of the\n             * group to a single 'od'. */\n            size_t index = bitmap_scan(lflow->dpg_bitmap, true, 0,\n                                       n_datapaths);\n\n            bitmap_set0(lflow->dpg_bitmap, index);\n            lflow->od = datapaths_array[index];\n\n            /* Logical flow should be re-hashed to allow lookups. */\n            hash = hmap_node_hash(&lflow->hmap_node);\n            /* Remove from lflows. */\n            hmap_remove(&lflows, &lflow->hmap_node);\n            hash = ovn_logical_flow_hash_datapath(&lflow->od->sb->header_.uuid,\n                                                  hash);\n            /* Add to single_dp_lflows. */\n            hmap_insert_fast(&single_dp_lflows, &lflow->hmap_node, hash);\n            continue;\n        }\n\n        hash = hash_int(n_ods, 0);\n        dpg = ovn_dp_group_find(&dp_groups, lflow->dpg_bitmap, hash);\n        if (!dpg) {\n            dpg = xzalloc(sizeof *dpg);\n            dpg->bitmap = bitmap_clone(lflow->dpg_bitmap, n_datapaths);\n            hmap_insert(&dp_groups, &dpg->node, hash);\n        }\n        lflow->dpg = dpg;\n    }\n\n    /* Merge multiple and single dp hashes. */\n\n    fast_hmap_merge(&lflows, &single_dp_lflows);\n\n    hmap_destroy(&single_dp_lflows);\n\n    stopwatch_stop(LFLOWS_DP_GROUPS_STOPWATCH_NAME, time_msec());\n    stopwatch_start(LFLOWS_TO_SB_STOPWATCH_NAME, time_msec());\n\n    /* Push changes to the Logical_Flow table to database. */\n    const struct sbrec_logical_flow *sbflow;\n    SBREC_LOGICAL_FLOW_TABLE_FOR_EACH_SAFE (sbflow,\n                                     input_data->sbrec_logical_flow_table) {\n        struct sbrec_logical_dp_group *dp_group = sbflow->logical_dp_group;\n        struct ovn_datapath *logical_datapath_od = NULL;\n        size_t i;\n\n        /* Find one valid datapath to get the datapath type. */\n        struct sbrec_datapath_binding *dp = sbflow->logical_datapath;\n        if (dp) {\n            logical_datapath_od = ovn_datapath_from_sbrec(\n                                            input_data->datapaths, dp);\n            if (logical_datapath_od\n                && ovn_datapath_is_stale(logical_datapath_od)) {\n                logical_datapath_od = NULL;\n            }\n        }\n        for (i = 0; dp_group && i < dp_group->n_datapaths; i++) {\n            logical_datapath_od = ovn_datapath_from_sbrec(\n                             input_data->datapaths, dp_group->datapaths[i]);\n            if (logical_datapath_od\n                && !ovn_datapath_is_stale(logical_datapath_od)) {\n                break;\n            }\n            logical_datapath_od = NULL;\n        }\n\n        if (!logical_datapath_od) {\n            /* This lflow has no valid logical datapaths. */\n            sbrec_logical_flow_delete(sbflow);\n            continue;\n        }\n\n        enum ovn_pipeline pipeline\n            = !strcmp(sbflow->pipeline, \"ingress\") ? P_IN : P_OUT;\n\n        lflow = ovn_lflow_find(\n            &lflows, dp_group ? NULL : logical_datapath_od,\n            ovn_stage_build(ovn_datapath_get_type(logical_datapath_od),\n                            pipeline, sbflow->table_id),\n            sbflow->priority, sbflow->match, sbflow->actions,\n            sbflow->controller_meter, sbflow->hash);\n        if (lflow) {\n            if (input_data->ovn_internal_version_changed) {\n                const char *stage_name = smap_get_def(&sbflow->external_ids,\n                                                  \"stage-name\", \"\");\n                const char *stage_hint = smap_get_def(&sbflow->external_ids,\n                                                  \"stage-hint\", \"\");\n                const char *source = smap_get_def(&sbflow->external_ids,\n                                                  \"source\", \"\");\n\n                if (strcmp(stage_name, ovn_stage_to_str(lflow->stage))) {\n                    sbrec_logical_flow_update_external_ids_setkey(sbflow,\n                     \"stage-name\", ovn_stage_to_str(lflow->stage));\n                }\n                if (lflow->stage_hint) {\n                    if (strcmp(stage_hint, lflow->stage_hint)) {\n                        sbrec_logical_flow_update_external_ids_setkey(sbflow,\n                        \"stage-hint\", lflow->stage_hint);\n                    }\n                }\n                if (lflow->where) {\n                    if (strcmp(source, lflow->where)) {\n                        sbrec_logical_flow_update_external_ids_setkey(sbflow,\n                        \"source\", lflow->where);\n                    }\n                }\n            }\n\n            /* This is a valid lflow.  Checking if the datapath group needs\n             * updates. */\n            bool update_dp_group = false;\n\n            if ((!lflow->dpg && dp_group) || (lflow->dpg && !dp_group)) {\n                /* Need to add or delete datapath group. */\n                update_dp_group = true;\n            } else if (!lflow->dpg && !dp_group) {\n                /* No datapath group and not needed. */\n            } else if (lflow->dpg->dp_group) {\n                /* We know the datapath group in Sb that should be used. */\n                if (lflow->dpg->dp_group != dp_group) {\n                    /* Flow has different datapath group in the database.  */\n                    update_dp_group = true;\n                }\n                /* Datapath group is already up to date. */\n            } else {\n                /* There is a datapath group and we need to perform\n                 * a full comparison. */\n                unsigned long *dpg_bitmap;\n                struct ovn_datapath *od;\n\n                dpg_bitmap = bitmap_allocate(n_datapaths);\n                /* Check all logical datapaths from the group. */\n                for (i = 0; i < dp_group->n_datapaths; i++) {\n                    od = ovn_datapath_from_sbrec(\n                            input_data->datapaths, dp_group->datapaths[i]);\n                    if (!od || ovn_datapath_is_stale(od)) {\n                        continue;\n                    }\n                    bitmap_set1(dpg_bitmap, od->index);\n                }\n\n                update_dp_group = !bitmap_equal(dpg_bitmap, lflow->dpg_bitmap,\n                                                n_datapaths);\n                bitmap_free(dpg_bitmap);\n            }\n\n            if (update_dp_group) {\n                ovn_sb_set_lflow_logical_dp_group(ovnsb_txn, &dp_groups,\n                                                  sbflow, lflow->dpg_bitmap);\n            } else if (lflow->dpg && !lflow->dpg->dp_group) {\n                /* Setting relation between unique datapath group and\n                 * Sb DB datapath goup. */\n                lflow->dpg->dp_group = dp_group;\n            }\n\n            /* This lflow updated.  Not needed anymore. */\n            ovn_lflow_destroy(&lflows, lflow);\n        } else {\n            sbrec_logical_flow_delete(sbflow);\n        }\n    }\n\n    HMAP_FOR_EACH_SAFE (lflow, hmap_node, &lflows) {\n        const char *pipeline = ovn_stage_get_pipeline_name(lflow->stage);\n        uint8_t table = ovn_stage_get_table(lflow->stage);\n\n        sbflow = sbrec_logical_flow_insert(ovnsb_txn);\n        if (lflow->od) {\n            sbrec_logical_flow_set_logical_datapath(sbflow, lflow->od->sb);\n        }\n        ovn_sb_set_lflow_logical_dp_group(ovnsb_txn, &dp_groups,\n                                          sbflow, lflow->dpg_bitmap);\n        sbrec_logical_flow_set_pipeline(sbflow, pipeline);\n        sbrec_logical_flow_set_table_id(sbflow, table);\n        sbrec_logical_flow_set_priority(sbflow, lflow->priority);\n        sbrec_logical_flow_set_match(sbflow, lflow->match);\n        sbrec_logical_flow_set_actions(sbflow, lflow->actions);\n        if (lflow->io_port) {\n            struct smap tags = SMAP_INITIALIZER(&tags);\n            smap_add(&tags, \"in_out_port\", lflow->io_port);\n            sbrec_logical_flow_set_tags(sbflow, &tags);\n            smap_destroy(&tags);\n        }\n        sbrec_logical_flow_set_controller_meter(sbflow, lflow->ctrl_meter);\n\n        /* Trim the source locator lflow->where, which looks something like\n         * \"ovn/northd/northd.c:1234\", down to just the part following the\n         * last slash, e.g. \"northd.c:1234\". */\n        const char *slash = strrchr(lflow->where, '/');\n#if _WIN32\n        const char *backslash = strrchr(lflow->where, '\\\\');\n        if (!slash || backslash > slash) {\n            slash = backslash;\n        }\n#endif\n        const char *where = slash ? slash + 1 : lflow->where;\n\n        struct smap ids = SMAP_INITIALIZER(&ids);\n        smap_add(&ids, \"stage-name\", ovn_stage_to_str(lflow->stage));\n        smap_add(&ids, \"source\", where);\n        if (lflow->stage_hint) {\n            smap_add(&ids, \"stage-hint\", lflow->stage_hint);\n        }\n        sbrec_logical_flow_set_external_ids(sbflow, &ids);\n        smap_destroy(&ids);\n\n        ovn_lflow_destroy(&lflows, lflow);\n    }\n    hmap_destroy(&lflows);\n\n    stopwatch_stop(LFLOWS_TO_SB_STOPWATCH_NAME, time_msec());\n    struct ovn_dp_group *dpg;\n    HMAP_FOR_EACH_POP (dpg, node, &dp_groups) {\n        bitmap_free(dpg->bitmap);\n        free(dpg);\n    }\n    hmap_destroy(&dp_groups);\n\n    /* Push changes to the Multicast_Group table to database. */\n    const struct sbrec_multicast_group *sbmc;\n    SBREC_MULTICAST_GROUP_TABLE_FOR_EACH_SAFE (sbmc,\n                                input_data->sbrec_multicast_group_table) {\n        struct ovn_datapath *od = ovn_datapath_from_sbrec(\n                               input_data->datapaths, sbmc->datapath);\n\n        if (!od || ovn_datapath_is_stale(od)) {\n            sbrec_multicast_group_delete(sbmc);\n            continue;\n        }\n\n        struct multicast_group group = { .name = sbmc->name,\n                                         .key = sbmc->tunnel_key };\n        struct ovn_multicast *mc = ovn_multicast_find(&mcast_groups,\n                                                      od, &group);\n        if (mc) {\n            ovn_multicast_update_sbrec(mc, sbmc);\n            ovn_multicast_destroy(&mcast_groups, mc);\n        } else {\n            sbrec_multicast_group_delete(sbmc);\n        }\n    }\n    struct ovn_multicast *mc;\n    HMAP_FOR_EACH_SAFE (mc, hmap_node, &mcast_groups) {\n        if (!mc->datapath) {\n            ovn_multicast_destroy(&mcast_groups, mc);\n            continue;\n        }\n        sbmc = sbrec_multicast_group_insert(ovnsb_txn);\n        sbrec_multicast_group_set_datapath(sbmc, mc->datapath->sb);\n        sbrec_multicast_group_set_name(sbmc, mc->group->name);\n        sbrec_multicast_group_set_tunnel_key(sbmc, mc->group->key);\n        ovn_multicast_update_sbrec(mc, sbmc);\n        ovn_multicast_destroy(&mcast_groups, mc);\n    }\n\n    struct ovn_igmp_group *igmp_group;\n\n    HMAP_FOR_EACH_SAFE (igmp_group, hmap_node, &igmp_groups) {\n        ovn_igmp_group_destroy(&igmp_groups, igmp_group);\n    }\n\n    hmap_destroy(&igmp_groups);\n    hmap_destroy(&mcast_groups);\n}\n\n/* Each port group in Port_Group table in OVN_Northbound has a corresponding\n * entry in Port_Group table in OVN_Southbound. In OVN_Northbound the entries\n * contains lport uuids, while in OVN_Southbound we store the lport names.\n */\nstatic void\nsync_port_groups(struct northd_input *input_data,\n                struct ovsdb_idl_txn *ovnsb_txn,\n                 struct hmap *pgs)\n{\n    struct shash sb_port_groups = SHASH_INITIALIZER(&sb_port_groups);\n\n    const struct sbrec_port_group *sb_port_group;\n    SBREC_PORT_GROUP_TABLE_FOR_EACH (sb_port_group,\n                               input_data->sbrec_port_group_table) {\n        shash_add(&sb_port_groups, sb_port_group->name, sb_port_group);\n    }\n\n    struct ds sb_name = DS_EMPTY_INITIALIZER;\n\n    struct ovn_port_group *pg;\n    HMAP_FOR_EACH (pg, key_node, pgs) {\n\n        struct ovn_port_group_ls *pg_ls;\n        HMAP_FOR_EACH (pg_ls, key_node, &pg->nb_lswitches) {\n            get_sb_port_group_name(pg->nb_pg->name, pg_ls->od->sb->tunnel_key,\n                                   &sb_name);\n            sb_port_group = shash_find_and_delete(&sb_port_groups,\n                                                  ds_cstr(&sb_name));\n            if (!sb_port_group) {\n                sb_port_group = sbrec_port_group_insert(ovnsb_txn);\n                sbrec_port_group_set_name(sb_port_group, ds_cstr(&sb_name));\n            }\n\n            const char **nb_port_names = xcalloc(pg_ls->n_ports,\n                                                 sizeof *nb_port_names);\n            for (size_t i = 0; i < pg_ls->n_ports; i++) {\n                nb_port_names[i] = pg_ls->ports[i]->nbsp->name;\n            }\n            sbrec_port_group_set_ports(sb_port_group,\n                                       nb_port_names,\n                                       pg_ls->n_ports);\n            free(nb_port_names);\n        }\n    }\n    ds_destroy(&sb_name);\n\n    struct shash_node *node;\n    SHASH_FOR_EACH_SAFE (node, &sb_port_groups) {\n        sbrec_port_group_delete(node->data);\n        shash_delete(&sb_port_groups, node);\n    }\n    shash_destroy(&sb_port_groups);\n}\n\nstruct band_entry {\n    int64_t rate;\n    int64_t burst_size;\n    const char *action;\n};\n\nstatic int\nband_cmp(const void *band1_, const void *band2_)\n{\n    const struct band_entry *band1p = band1_;\n    const struct band_entry *band2p = band2_;\n\n    if (band1p->rate != band2p->rate) {\n        return band1p->rate > band2p->rate ? -1 : 1;\n    } else if (band1p->burst_size != band2p->burst_size) {\n        return band1p->burst_size > band2p->burst_size ? -1 : 1;\n    } else {\n        return strcmp(band1p->action, band2p->action);\n    }\n}\n\nstatic bool\nbands_need_update(const struct nbrec_meter *nb_meter,\n                  const struct sbrec_meter *sb_meter)\n{\n    if (nb_meter->n_bands != sb_meter->n_bands) {\n        return true;\n    }\n\n    /* A single band is the most common scenario, so speed up that\n     * check. */\n    if (nb_meter->n_bands == 1) {\n        struct nbrec_meter_band *nb_band = nb_meter->bands[0];\n        struct sbrec_meter_band *sb_band = sb_meter->bands[0];\n\n        return !(nb_band->rate == sb_band->rate\n                 && nb_band->burst_size == sb_band->burst_size\n                 && !strcmp(sb_band->action, nb_band->action));\n    }\n\n    /* Place the Northbound entries in sorted order. */\n    struct band_entry *nb_bands;\n    nb_bands = xmalloc(sizeof *nb_bands * nb_meter->n_bands);\n    for (size_t i = 0; i < nb_meter->n_bands; i++) {\n        struct nbrec_meter_band *nb_band = nb_meter->bands[i];\n\n        nb_bands[i].rate = nb_band->rate;\n        nb_bands[i].burst_size = nb_band->burst_size;\n        nb_bands[i].action = nb_band->action;\n    }\n    qsort(nb_bands, nb_meter->n_bands, sizeof *nb_bands, band_cmp);\n\n    /* Place the Southbound entries in sorted order. */\n    struct band_entry *sb_bands;\n    sb_bands = xmalloc(sizeof *sb_bands * sb_meter->n_bands);\n    for (size_t i = 0; i < sb_meter->n_bands; i++) {\n        struct sbrec_meter_band *sb_band = sb_meter->bands[i];\n\n        sb_bands[i].rate = sb_band->rate;\n        sb_bands[i].burst_size = sb_band->burst_size;\n        sb_bands[i].action = sb_band->action;\n    }\n    qsort(sb_bands, sb_meter->n_bands, sizeof *sb_bands, band_cmp);\n\n    bool need_update = false;\n    for (size_t i = 0; i < nb_meter->n_bands; i++) {\n        if (nb_bands[i].rate != sb_bands[i].rate\n            || nb_bands[i].burst_size != sb_bands[i].burst_size\n            || strcmp(nb_bands[i].action, sb_bands[i].action)) {\n            need_update = true;\n            goto done;\n        }\n    }\n\ndone:\n    free(nb_bands);\n    free(sb_bands);\n\n    return need_update;\n}\n\nstatic void\nsync_meters_iterate_nb_meter(struct ovsdb_idl_txn *ovnsb_txn,\n                             const char *meter_name,\n                             const struct nbrec_meter *nb_meter,\n                             struct shash *sb_meters,\n                             struct sset *used_sb_meters)\n{\n    const struct sbrec_meter *sb_meter;\n    bool new_sb_meter = false;\n\n    sb_meter = shash_find_data(sb_meters, meter_name);\n    if (!sb_meter) {\n        sb_meter = sbrec_meter_insert(ovnsb_txn);\n        sbrec_meter_set_name(sb_meter, meter_name);\n        shash_add(sb_meters, sb_meter->name, sb_meter);\n        new_sb_meter = true;\n    }\n    sset_add(used_sb_meters, meter_name);\n\n    if (new_sb_meter || bands_need_update(nb_meter, sb_meter)) {\n        struct sbrec_meter_band **sb_bands;\n        sb_bands = xcalloc(nb_meter->n_bands, sizeof *sb_bands);\n        for (size_t i = 0; i < nb_meter->n_bands; i++) {\n            const struct nbrec_meter_band *nb_band = nb_meter->bands[i];\n\n            sb_bands[i] = sbrec_meter_band_insert(ovnsb_txn);\n\n            sbrec_meter_band_set_action(sb_bands[i], nb_band->action);\n            sbrec_meter_band_set_rate(sb_bands[i], nb_band->rate);\n            sbrec_meter_band_set_burst_size(sb_bands[i],\n                                            nb_band->burst_size);\n        }\n        sbrec_meter_set_bands(sb_meter, sb_bands, nb_meter->n_bands);\n        free(sb_bands);\n    }\n\n    sbrec_meter_set_unit(sb_meter, nb_meter->unit);\n}\n\nstatic void\nsync_acl_fair_meter(struct ovsdb_idl_txn *ovnsb_txn,\n                    struct shash *meter_groups,\n                    const struct nbrec_acl *acl, struct shash *sb_meters,\n                    struct sset *used_sb_meters)\n{\n    const struct nbrec_meter *nb_meter =\n        fair_meter_lookup_by_name(meter_groups, acl->meter);\n\n    if (!nb_meter) {\n        return;\n    }\n\n    char *meter_name = alloc_acl_log_unique_meter_name(acl);\n    sync_meters_iterate_nb_meter(ovnsb_txn, meter_name, nb_meter, sb_meters,\n                                 used_sb_meters);\n    free(meter_name);\n}\n\n/* Each entry in the Meter and Meter_Band tables in OVN_Northbound have\n * a corresponding entries in the Meter and Meter_Band tables in\n * OVN_Southbound. Additionally, ACL logs that use fair meters have\n * a private copy of its meter in the SB table.\n */\nstatic void\nsync_meters(struct northd_input *input_data,\n            struct ovsdb_idl_txn *ovnsb_txn,\n            struct shash *meter_groups)\n{\n    struct shash sb_meters = SHASH_INITIALIZER(&sb_meters);\n    struct sset used_sb_meters = SSET_INITIALIZER(&used_sb_meters);\n\n    const struct sbrec_meter *sb_meter;\n    SBREC_METER_TABLE_FOR_EACH (sb_meter, input_data->sbrec_meter_table) {\n        shash_add(&sb_meters, sb_meter->name, sb_meter);\n    }\n\n    const struct nbrec_meter *nb_meter;\n    NBREC_METER_TABLE_FOR_EACH (nb_meter, input_data->nbrec_meter_table) {\n        sync_meters_iterate_nb_meter(ovnsb_txn, nb_meter->name, nb_meter,\n                                     &sb_meters, &used_sb_meters);\n    }\n\n    /*\n     * In addition to creating Meters in the SB from the block above, check\n     * and see if additional rows are needed to get ACLs logs individually\n     * rate-limited.\n     */\n    const struct nbrec_acl *acl;\n    NBREC_ACL_TABLE_FOR_EACH (acl, input_data->nbrec_acl_table) {\n        sync_acl_fair_meter(ovnsb_txn, meter_groups, acl,\n                            &sb_meters, &used_sb_meters);\n    }\n\n    const char *used_meter;\n    SSET_FOR_EACH_SAFE (used_meter, &used_sb_meters) {\n        shash_find_and_delete(&sb_meters, used_meter);\n        sset_delete(&used_sb_meters, SSET_NODE_FROM_NAME(used_meter));\n    }\n    sset_destroy(&used_sb_meters);\n\n    struct shash_node *node;\n    SHASH_FOR_EACH_SAFE (node, &sb_meters) {\n        sbrec_meter_delete(node->data);\n        shash_delete(&sb_meters, node);\n    }\n    shash_destroy(&sb_meters);\n}\n\nstatic bool\nmirror_needs_update(const struct nbrec_mirror *nb_mirror,\n                    const struct sbrec_mirror *sb_mirror)\n{\n\n    if (nb_mirror->index != sb_mirror->index) {\n        return true;\n    } else if (strcmp(nb_mirror->sink, sb_mirror->sink)) {\n        return true;\n    } else if (strcmp(nb_mirror->type, sb_mirror->type)) {\n        return true;\n    } else if (strcmp(nb_mirror->filter, sb_mirror->filter)) {\n        return true;\n    }\n\n    return false;\n}\n\nstatic void\nsync_mirrors_iterate_nb_mirror(struct ovsdb_idl_txn *ovnsb_txn,\n                               const char *mirror_name,\n                               const struct nbrec_mirror *nb_mirror,\n                               struct shash *sb_mirrors)\n{\n    const struct sbrec_mirror *sb_mirror;\n    bool new_sb_mirror = false;\n\n    sb_mirror = shash_find_data(sb_mirrors, mirror_name);\n    if (!sb_mirror) {\n        sb_mirror = sbrec_mirror_insert(ovnsb_txn);\n        sbrec_mirror_set_name(sb_mirror, mirror_name);\n        shash_add(sb_mirrors, sb_mirror->name, sb_mirror);\n        new_sb_mirror = true;\n    }\n\n    if (new_sb_mirror || mirror_needs_update(nb_mirror, sb_mirror)) {\n        sbrec_mirror_set_filter(sb_mirror, nb_mirror->filter);\n        sbrec_mirror_set_index(sb_mirror, nb_mirror->index);\n        sbrec_mirror_set_sink(sb_mirror, nb_mirror->sink);\n        sbrec_mirror_set_type(sb_mirror, nb_mirror->type);\n    }\n}\n\nstatic void\nsync_mirrors(struct northd_input *input_data,\n             struct ovsdb_idl_txn *ovnsb_txn)\n{\n    struct shash sb_mirrors = SHASH_INITIALIZER(&sb_mirrors);\n\n    const struct sbrec_mirror *sb_mirror;\n    SBREC_MIRROR_TABLE_FOR_EACH (sb_mirror, input_data->sbrec_mirror_table) {\n        shash_add(&sb_mirrors, sb_mirror->name, sb_mirror);\n    }\n\n    const struct nbrec_mirror *nb_mirror;\n    NBREC_MIRROR_TABLE_FOR_EACH (nb_mirror, input_data->nbrec_mirror_table) {\n        sync_mirrors_iterate_nb_mirror(ovnsb_txn, nb_mirror->name, nb_mirror,\n                                       &sb_mirrors);\n        shash_find_and_delete(&sb_mirrors, nb_mirror->name);\n    }\n\n    struct shash_node *node, *next;\n    SHASH_FOR_EACH_SAFE (node, next, &sb_mirrors) {\n        sbrec_mirror_delete(node->data);\n        shash_delete(&sb_mirrors, node);\n    }\n    shash_destroy(&sb_mirrors);\n}\n\n/*\n * struct 'dns_info' is used to sync the DNS records between OVN Northbound db\n * and Southbound db.\n */\nstruct dns_info {\n    struct hmap_node hmap_node;\n    const struct nbrec_dns *nb_dns; /* DNS record in the Northbound db. */\n    const struct sbrec_dns *sb_dns; /* DNS record in the Southbound db. */\n\n    /* Datapaths to which the DNS entry is associated with it. */\n    const struct sbrec_datapath_binding **sbs;\n    size_t n_sbs;\n};\n\nstatic inline struct dns_info *\nget_dns_info_from_hmap(struct hmap *dns_map, struct uuid *uuid)\n{\n    struct dns_info *dns_info;\n    size_t hash = uuid_hash(uuid);\n    HMAP_FOR_EACH_WITH_HASH (dns_info, hmap_node, hash, dns_map) {\n        if (uuid_equals(&dns_info->nb_dns->header_.uuid, uuid)) {\n            return dns_info;\n        }\n    }\n\n    return NULL;\n}\n\nstatic void\nsync_dns_entries(struct northd_input *input_data,\n                 struct ovsdb_idl_txn *ovnsb_txn,\n                 struct hmap *datapaths)\n{\n    struct hmap dns_map = HMAP_INITIALIZER(&dns_map);\n    struct ovn_datapath *od;\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs || !od->nbs->n_dns_records) {\n            continue;\n        }\n\n        for (size_t i = 0; i < od->nbs->n_dns_records; i++) {\n            struct dns_info *dns_info = get_dns_info_from_hmap(\n                &dns_map, &od->nbs->dns_records[i]->header_.uuid);\n            if (!dns_info) {\n                size_t hash = uuid_hash(\n                    &od->nbs->dns_records[i]->header_.uuid);\n                dns_info = xzalloc(sizeof *dns_info);;\n                dns_info->nb_dns = od->nbs->dns_records[i];\n                hmap_insert(&dns_map, &dns_info->hmap_node, hash);\n            }\n\n            dns_info->n_sbs++;\n            dns_info->sbs = xrealloc(dns_info->sbs,\n                                     dns_info->n_sbs * sizeof *dns_info->sbs);\n            dns_info->sbs[dns_info->n_sbs - 1] = od->sb;\n        }\n    }\n\n    const struct sbrec_dns *sbrec_dns;\n    SBREC_DNS_TABLE_FOR_EACH_SAFE (sbrec_dns, input_data->sbrec_dns_table) {\n        const char *nb_dns_uuid = smap_get(&sbrec_dns->external_ids, \"dns_id\");\n        struct uuid dns_uuid;\n        if (!nb_dns_uuid || !uuid_from_string(&dns_uuid, nb_dns_uuid)) {\n            sbrec_dns_delete(sbrec_dns);\n            continue;\n        }\n\n        struct dns_info *dns_info =\n            get_dns_info_from_hmap(&dns_map, &dns_uuid);\n        if (dns_info) {\n            dns_info->sb_dns = sbrec_dns;\n        } else {\n            sbrec_dns_delete(sbrec_dns);\n        }\n    }\n\n    struct dns_info *dns_info;\n    HMAP_FOR_EACH_POP (dns_info, hmap_node, &dns_map) {\n        if (!dns_info->sb_dns) {\n            sbrec_dns = sbrec_dns_insert(ovnsb_txn);\n            dns_info->sb_dns = sbrec_dns;\n            char *dns_id = xasprintf(\n                UUID_FMT, UUID_ARGS(&dns_info->nb_dns->header_.uuid));\n            const struct smap external_ids =\n                SMAP_CONST1(&external_ids, \"dns_id\", dns_id);\n            sbrec_dns_set_external_ids(sbrec_dns, &external_ids);\n            free(dns_id);\n        }\n\n        /* Set the datapaths and records. If nothing has changed, then\n         * this will be a no-op.\n         */\n        sbrec_dns_set_datapaths(\n            dns_info->sb_dns,\n            (struct sbrec_datapath_binding **)dns_info->sbs,\n            dns_info->n_sbs);\n\n        /* DNS lookups are case-insensitive. Convert records to lowercase so\n         * we can do consistent lookups when DNS requests arrive\n         */\n        struct smap lower_records = SMAP_INITIALIZER(&lower_records);\n        struct smap_node *node;\n        SMAP_FOR_EACH (node, &dns_info->nb_dns->records) {\n            smap_add_nocopy(&lower_records, xstrdup(node->key),\n                            str_tolower(node->value));\n        }\n\n        sbrec_dns_set_records(dns_info->sb_dns, &lower_records);\n\n        smap_destroy(&lower_records);\n        free(dns_info->sbs);\n        free(dns_info);\n    }\n    hmap_destroy(&dns_map);\n}\n\nstatic void\nsync_template_vars(struct northd_input *input_data,\n                   struct ovsdb_idl_txn *ovnsb_txn)\n{\n    struct shash nb_tvs = SHASH_INITIALIZER(&nb_tvs);\n\n    const struct nbrec_chassis_template_var *nb_tv;\n    const struct sbrec_chassis_template_var *sb_tv;\n\n    NBREC_CHASSIS_TEMPLATE_VAR_TABLE_FOR_EACH (\n            nb_tv, input_data->nbrec_chassis_template_var_table) {\n        shash_add(&nb_tvs, nb_tv->chassis, nb_tv);\n    }\n\n    SBREC_CHASSIS_TEMPLATE_VAR_TABLE_FOR_EACH_SAFE (\n            sb_tv, input_data->sbrec_chassis_template_var_table) {\n        nb_tv = shash_find_and_delete(&nb_tvs, sb_tv->chassis);\n        if (!nb_tv) {\n            sbrec_chassis_template_var_delete(sb_tv);\n            continue;\n        }\n        if (!smap_equal(&sb_tv->variables, &nb_tv->variables)) {\n            sbrec_chassis_template_var_set_variables(sb_tv,\n                                                     &nb_tv->variables);\n        }\n    }\n\n    struct shash_node *node;\n    SHASH_FOR_EACH (node, &nb_tvs) {\n        nb_tv = node->data;\n        sb_tv = sbrec_chassis_template_var_insert(ovnsb_txn);\n        sbrec_chassis_template_var_set_chassis(sb_tv, nb_tv->chassis);\n        sbrec_chassis_template_var_set_variables(sb_tv, &nb_tv->variables);\n    }\n    shash_destroy(&nb_tvs);\n}\n\f\nstatic void\ndestroy_datapaths_and_ports(struct hmap *datapaths, struct hmap *ports,\n                            struct ovs_list *lr_list)\n{\n    struct ovn_datapath *router_dp;\n    LIST_FOR_EACH_POP (router_dp, lr_list, lr_list) {\n        if (router_dp->lr_group) {\n            struct lrouter_group *lr_group = router_dp->lr_group;\n\n            for (size_t i = 0; i < lr_group->n_router_dps; i++) {\n                lr_group->router_dps[i]->lr_group = NULL;\n            }\n\n            free(lr_group->router_dps);\n            sset_destroy(&lr_group->ha_chassis_groups);\n            hmapx_destroy(&lr_group->tmp_ha_chassis);\n            free(lr_group);\n        }\n    }\n\n    struct ovn_datapath *dp;\n    HMAP_FOR_EACH_SAFE (dp, key_node, datapaths) {\n        ovn_datapath_destroy(datapaths, dp);\n    }\n    hmap_destroy(datapaths);\n\n    struct ovn_port *port;\n    HMAP_FOR_EACH_SAFE (port, key_node, ports) {\n        ovn_port_destroy(ports, port);\n    }\n    hmap_destroy(ports);\n}\n\nstatic void\nbuild_ip_mcast(struct northd_input *input_data,\n               struct ovsdb_idl_txn *ovnsb_txn,\n               struct hmap *datapaths)\n{\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        if (!od->nbs) {\n            continue;\n        }\n\n        const struct sbrec_ip_multicast *ip_mcast =\n            ip_mcast_lookup(input_data->sbrec_ip_mcast_by_dp, od->sb);\n\n        if (!ip_mcast) {\n            ip_mcast = sbrec_ip_multicast_insert(ovnsb_txn);\n        }\n        store_mcast_info_for_switch_datapath(ip_mcast, od);\n    }\n\n    /* Delete southbound records without northbound matches. */\n    const struct sbrec_ip_multicast *sb;\n\n    SBREC_IP_MULTICAST_TABLE_FOR_EACH_SAFE (sb,\n                                   input_data->sbrec_ip_multicast_table) {\n        od = ovn_datapath_from_sbrec(datapaths, sb->datapath);\n        if (!od || ovn_datapath_is_stale(od)) {\n            sbrec_ip_multicast_delete(sb);\n        }\n    }\n}\n\nstatic void\nbuild_mcast_groups(struct lflow_input *input_data,\n                   const struct hmap *datapaths,\n                   const struct hmap *ports,\n                   struct hmap *mcast_groups,\n                   struct hmap *igmp_groups)\n{\n    struct ovn_port *op;\n\n    hmap_init(mcast_groups);\n    hmap_init(igmp_groups);\n    struct ovn_datapath *od;\n\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n        init_mcast_flow_count(od);\n    }\n\n    HMAP_FOR_EACH (op, key_node, ports) {\n        if (op->nbrp && lrport_is_enabled(op->nbrp)) {\n            /* If this port is configured to always flood multicast traffic\n             * add it to the MC_STATIC group.\n             */\n            if (op->mcast_info.flood) {\n                ovn_multicast_add(mcast_groups, &mc_static, op);\n                op->od->mcast_info.rtr.flood_static = true;\n            }\n        } else if (op->nbsp && lsp_is_enabled(op->nbsp)) {\n            ovn_multicast_add(mcast_groups, &mc_flood, op);\n\n            if (!lsp_is_router(op->nbsp)) {\n                ovn_multicast_add(mcast_groups, &mc_flood_l2, op);\n            }\n\n            /* If this port is connected to a multicast router then add it\n             * to the MC_MROUTER_FLOOD group.\n             */\n            if (op->od->mcast_info.sw.flood_relay && op->peer &&\n                    op->peer->od && op->peer->od->mcast_info.rtr.relay) {\n                ovn_multicast_add(mcast_groups, &mc_mrouter_flood, op);\n            }\n\n            /* If this port is configured to always flood multicast reports\n             * add it to the MC_MROUTER_FLOOD group (all reports must be\n             * flooded to statically configured or learned mrouters).\n             */\n            if (op->mcast_info.flood_reports) {\n                ovn_multicast_add(mcast_groups, &mc_mrouter_flood, op);\n                op->od->mcast_info.sw.flood_reports = true;\n            }\n\n            /* If this port is configured to always flood multicast traffic\n             * add it to the MC_STATIC group.\n             */\n            if (op->mcast_info.flood) {\n                ovn_multicast_add(mcast_groups, &mc_static, op);\n                op->od->mcast_info.sw.flood_static = true;\n            }\n        }\n    }\n\n    const struct sbrec_igmp_group *sb_igmp;\n\n    SBREC_IGMP_GROUP_TABLE_FOR_EACH_SAFE (sb_igmp,\n                                     input_data->sbrec_igmp_group_table) {\n        /* If this is a stale group (e.g., controller had crashed,\n         * purge it).\n         */\n        if (!sb_igmp->chassis || !sb_igmp->datapath) {\n            sbrec_igmp_group_delete(sb_igmp);\n            continue;\n        }\n\n        /* If the datapath value is stale, purge the group. */\n        od = ovn_datapath_from_sbrec(datapaths, sb_igmp->datapath);\n\n        if (!od || ovn_datapath_is_stale(od)) {\n            sbrec_igmp_group_delete(sb_igmp);\n            continue;\n        }\n\n        struct in6_addr group_address;\n        if (!strcmp(sb_igmp->address, OVN_IGMP_GROUP_MROUTERS)) {\n            /* Use all-zeros IP to denote a group corresponding to mrouters. */\n            memset(&group_address, 0, sizeof group_address);\n        } else if (!ovn_igmp_group_get_address(sb_igmp, &group_address)) {\n            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);\n            VLOG_WARN_RL(&rl, \"invalid IGMP group address: %s\",\n                         sb_igmp->address);\n            continue;\n        }\n\n        /* Extract the IGMP group ports from the SB entry. */\n        size_t n_igmp_ports;\n        struct ovn_port **igmp_ports =\n            ovn_igmp_group_get_ports(sb_igmp, &n_igmp_ports, ports);\n\n        /* It can be that all ports in the IGMP group record already have\n         * mcast_flood=true and then we can skip the group completely.\n         */\n        if (!igmp_ports) {\n            continue;\n        }\n\n        /* Add the IGMP group entry. Will also try to allocate an ID for it\n         * if the multicast group already exists.\n         */\n        struct ovn_igmp_group *igmp_group =\n            ovn_igmp_group_add(input_data, igmp_groups, od, &group_address,\n                               sb_igmp->address);\n\n        /* Add the extracted ports to the IGMP group. */\n        ovn_igmp_group_add_entry(igmp_group, igmp_ports, n_igmp_ports);\n    }\n\n    /* Build IGMP groups for multicast routers with relay enabled. The router\n     * IGMP groups are based on the groups learnt by their multicast enabled\n     * peers.\n     */\n    HMAP_FOR_EACH (od, key_node, datapaths) {\n\n        if (ovs_list_is_empty(&od->mcast_info.groups)) {\n            continue;\n        }\n\n        for (size_t i = 0; i < od->n_router_ports; i++) {\n            struct ovn_port *router_port = od->router_ports[i]->peer;\n\n            /* If the router the port connects to doesn't have multicast\n             * relay enabled or if it was already configured to flood\n             * multicast traffic then skip it.\n             */\n            if (!router_port || !router_port->od ||\n                    !router_port->od->mcast_info.rtr.relay ||\n                    router_port->mcast_info.flood) {\n                continue;\n            }\n\n            struct ovn_igmp_group *igmp_group;\n            LIST_FOR_EACH (igmp_group, list_node, &od->mcast_info.groups) {\n                struct in6_addr *address = &igmp_group->address;\n\n                /* Skip mrouter entries. */\n                if (!strcmp(igmp_group->mcgroup.name,\n                            OVN_IGMP_GROUP_MROUTERS)) {\n                    continue;\n                }\n\n                /* For IPv6 only relay routable multicast groups\n                 * (RFC 4291 2.7).\n                 */\n                if (!IN6_IS_ADDR_V4MAPPED(address) &&\n                        !ipv6_addr_is_routable_multicast(address)) {\n                    continue;\n                }\n\n                struct ovn_igmp_group *igmp_group_rtr =\n                    ovn_igmp_group_add(input_data,\n                                       igmp_groups, router_port->od,\n                                       address, igmp_group->mcgroup.name);\n                struct ovn_port **router_igmp_ports =\n                    xmalloc(sizeof *router_igmp_ports);\n                /* Store the chassis redirect port  otherwise traffic will not\n                 * be tunneled properly.\n                 */\n                router_igmp_ports[0] = router_port->cr_port\n                                       ? router_port->cr_port\n                                       : router_port;\n                ovn_igmp_group_add_entry(igmp_group_rtr, router_igmp_ports, 1);\n            }\n        }\n    }\n\n    /* Walk the aggregated IGMP groups and allocate IDs for new entries.\n     * Then store the ports in the associated multicast group.\n     * Mrouter entries are also stored as IGMP groups, deal with those\n     * explicitly.\n     */\n    struct ovn_igmp_group *igmp_group;\n    HMAP_FOR_EACH_SAFE (igmp_group, hmap_node, igmp_groups) {\n\n        /* If this is a mrouter entry just aggregate the mrouter ports\n         * into the MC_MROUTER mcast_group and destroy the igmp_group;\n         * no more processing needed. */\n        if (!strcmp(igmp_group->mcgroup.name, OVN_IGMP_GROUP_MROUTERS)) {\n            ovn_igmp_mrouter_aggregate_ports(igmp_group, mcast_groups);\n            ovn_igmp_group_destroy(igmp_groups, igmp_group);\n            continue;\n        }\n\n        if (!ovn_igmp_group_allocate_id(igmp_group)) {\n            /* If we ran out of keys just destroy the entry. */\n            ovn_igmp_group_destroy(igmp_groups, igmp_group);\n            continue;\n        }\n\n        /* Aggregate the ports from all entries corresponding to this\n         * group.\n         */\n        ovn_igmp_group_aggregate_ports(igmp_group, mcast_groups);\n    }\n}\n\nstatic void\nbuild_meter_groups(struct northd_input *input_data,\n                   struct shash *meter_groups)\n{\n    const struct nbrec_meter *nb_meter;\n    NBREC_METER_TABLE_FOR_EACH (nb_meter, input_data->nbrec_meter_table) {\n        shash_add(meter_groups, nb_meter->name, nb_meter);\n    }\n}\n\nstatic const struct nbrec_static_mac_binding *\nstatic_mac_binding_by_port_ip(struct northd_input *input_data,\n                       const char *logical_port, const char *ip)\n{\n    const struct nbrec_static_mac_binding *nb_smb = NULL;\n\n    NBREC_STATIC_MAC_BINDING_TABLE_FOR_EACH (\n        nb_smb, input_data->nbrec_static_mac_binding_table) {\n        if (!strcmp(nb_smb->logical_port, logical_port) &&\n            !strcmp(nb_smb->ip, ip)) {\n            break;\n        }\n    }\n\n    return nb_smb;\n}\n\nstatic void\nbuild_static_mac_binding_table(struct northd_input *input_data,\n                               struct ovsdb_idl_txn *ovnsb_txn,\n                               struct hmap *ports)\n{\n    /* Cleanup SB Static_MAC_Binding entries which do not have corresponding\n     * NB Static_MAC_Binding entries. */\n    const struct nbrec_static_mac_binding *nb_smb;\n    const struct sbrec_static_mac_binding *sb_smb;\n    SBREC_STATIC_MAC_BINDING_TABLE_FOR_EACH_SAFE (sb_smb,\n        input_data->sbrec_static_mac_binding_table) {\n        nb_smb = static_mac_binding_by_port_ip(input_data,\n                                               sb_smb->logical_port,\n                                               sb_smb->ip);\n        if (!nb_smb) {\n            sbrec_static_mac_binding_delete(sb_smb);\n        }\n    }\n\n    /* Create/Update SB Static_MAC_Binding entries with corresponding values\n     * from NB Static_MAC_Binding entries. */\n    NBREC_STATIC_MAC_BINDING_TABLE_FOR_EACH (\n        nb_smb, input_data->nbrec_static_mac_binding_table) {\n        struct ovn_port *op = ovn_port_find(ports, nb_smb->logical_port);\n        if (op && op->nbrp) {\n            struct ovn_datapath *od = op->od;\n            if (od && od->sb) {\n                const struct sbrec_static_mac_binding *mb =\n                    static_mac_binding_lookup(\n                        input_data->sbrec_static_mac_binding_by_lport_ip,\n                        nb_smb->logical_port, nb_smb->ip);\n                if (!mb) {\n                    /* Create new entry */\n                    mb = sbrec_static_mac_binding_insert(ovnsb_txn);\n                    sbrec_static_mac_binding_set_logical_port(\n                        mb, nb_smb->logical_port);\n                    sbrec_static_mac_binding_set_ip(mb, nb_smb->ip);\n                    sbrec_static_mac_binding_set_mac(mb, nb_smb->mac);\n                    sbrec_static_mac_binding_set_override_dynamic_mac(mb,\n                        nb_smb->override_dynamic_mac);\n                    sbrec_static_mac_binding_set_datapath(mb, od->sb);\n                } else {\n                    /* Update existing entry if there is a change*/\n                    if (strcmp(mb->mac, nb_smb->mac)) {\n                        sbrec_static_mac_binding_set_mac(mb, nb_smb->mac);\n                    }\n                    if (mb->override_dynamic_mac !=\n                        nb_smb->override_dynamic_mac) {\n                        sbrec_static_mac_binding_set_override_dynamic_mac(mb,\n                            nb_smb->override_dynamic_mac);\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid\nnorthd_init(struct northd_data *data)\n{\n    hmap_init(&data->datapaths);\n    hmap_init(&data->ports);\n    hmap_init(&data->port_groups);\n    shash_init(&data->meter_groups);\n    hmap_init(&data->lbs);\n    hmap_init(&data->lb_groups);\n    hmap_init(&data->bfd_connections);\n    ovs_list_init(&data->lr_list);\n    data->features = (struct chassis_features) {\n        .ct_no_masked_label = true,\n        .mac_binding_timestamp = true,\n        .ct_lb_related = true,\n    };\n    data->ovn_internal_version_changed = false;\n}\n\nvoid\nnorthd_destroy(struct northd_data *data)\n{\n    struct ovn_northd_lb *lb;\n    HMAP_FOR_EACH_POP (lb, hmap_node, &data->lbs) {\n        ovn_northd_lb_destroy(lb);\n    }\n    hmap_destroy(&data->lbs);\n\n    struct ovn_lb_group *lb_group;\n    HMAP_FOR_EACH_POP (lb_group, hmap_node, &data->lb_groups) {\n        ovn_lb_group_destroy(lb_group);\n    }\n    hmap_destroy(&data->lb_groups);\n\n    struct ovn_port_group *pg;\n    HMAP_FOR_EACH_SAFE (pg, key_node, &data->port_groups) {\n        ovn_port_group_destroy(&data->port_groups, pg);\n    }\n\n    hmap_destroy(&data->port_groups);\n    hmap_destroy(&data->bfd_connections);\n\n    struct shash_node *node;\n    SHASH_FOR_EACH_SAFE (node, &data->meter_groups) {\n        shash_delete(&data->meter_groups, node);\n    }\n    shash_destroy(&data->meter_groups);\n\n    /* XXX Having to explicitly clean up macam here\n     * is a bit strange. We don't explicitly initialize\n     * macam in this module, but this is the logical place\n     * to clean it up. Ideally, more IPAM logic can be factored\n     * out of ovn-northd and this can be taken care of there\n     * as well.\n     */\n    cleanup_macam();\n\n    destroy_datapaths_and_ports(&data->datapaths, &data->ports,\n                                &data->lr_list);\n    destroy_debug_config();\n}\n\nstatic void\novnnb_db_run(struct northd_input *input_data,\n             struct northd_data *data,\n             struct ovsdb_idl_txn *ovnnb_txn,\n             struct ovsdb_idl_txn *ovnsb_txn,\n             struct ovsdb_idl_index *sbrec_chassis_by_name,\n             struct ovsdb_idl_index *sbrec_chassis_by_hostname)\n{\n    if (!ovnsb_txn || !ovnnb_txn) {\n        return;\n    }\n    stopwatch_start(BUILD_LFLOWS_CTX_STOPWATCH_NAME, time_msec());\n\n    /* Sync ipsec configuration.\n     * Copy nb_cfg from northbound to southbound database.\n     * Also set up to update sb_cfg once our southbound transaction commits. */\n    const struct nbrec_nb_global *nb = nbrec_nb_global_table_first(\n                                       input_data->nbrec_nb_global_table);\n    if (!nb) {\n        nb = nbrec_nb_global_insert(ovnnb_txn);\n    }\n\n    const char *mac_addr_prefix = set_mac_prefix(smap_get(&nb->options,\n                                                          \"mac_prefix\"));\n\n    const char *monitor_mac = smap_get(&nb->options, \"svc_monitor_mac\");\n    if (monitor_mac) {\n        if (eth_addr_from_string(monitor_mac, &svc_monitor_mac_ea)) {\n            snprintf(svc_monitor_mac, sizeof svc_monitor_mac,\n                     ETH_ADDR_FMT, ETH_ADDR_ARGS(svc_monitor_mac_ea));\n        } else {\n            monitor_mac = NULL;\n        }\n    }\n\n    struct smap options;\n    smap_clone(&options, &nb->options);\n\n    smap_replace(&options, \"mac_prefix\", mac_addr_prefix);\n\n    if (!monitor_mac) {\n        eth_addr_random(&svc_monitor_mac_ea);\n        snprintf(svc_monitor_mac, sizeof svc_monitor_mac,\n                 ETH_ADDR_FMT, ETH_ADDR_ARGS(svc_monitor_mac_ea));\n        smap_replace(&options, \"svc_monitor_mac\", svc_monitor_mac);\n    }\n\n    char *max_tunid = xasprintf(\"%d\", get_ovn_max_dp_key_local(input_data));\n    smap_replace(&options, \"max_tunid\", max_tunid);\n    free(max_tunid);\n\n    char *ovn_internal_version = ovn_get_internal_version();\n    if (!strcmp(ovn_internal_version,\n                smap_get_def(&options, \"northd_internal_version\", \"\"))) {\n        data->ovn_internal_version_changed = false;\n    } else {\n        smap_replace(&options, \"northd_internal_version\",\n                     ovn_internal_version);\n    }\n    free(ovn_internal_version);\n\n    if (!smap_equal(&nb->options, &options)) {\n        nbrec_nb_global_verify_options(nb);\n        nbrec_nb_global_set_options(nb, &options);\n    }\n\n    use_ct_inv_match = smap_get_bool(&nb->options,\n                                     \"use_ct_inv_match\", true);\n\n    /* deprecated, use --event instead */\n    controller_event_en = smap_get_bool(&nb->options,\n                                        \"controller_event\", false);\n    check_lsp_is_up = !smap_get_bool(&nb->options,\n                                     \"ignore_lsp_down\", true);\n    default_acl_drop = smap_get_bool(&nb->options, \"default_acl_drop\", false);\n\n    install_ls_lb_from_router = smap_get_bool(&nb->options,\n                                              \"install_ls_lb_from_router\",\n                                              false);\n\n    build_chassis_features(input_data, &data->features);\n\n    init_debug_config(nb);\n\n    build_datapaths(input_data, ovnsb_txn, &data->datapaths, &data->lr_list);\n    build_lbs(input_data, &data->datapaths, &data->lbs, &data->lb_groups);\n    build_ports(input_data, ovnsb_txn, sbrec_chassis_by_name,\n                sbrec_chassis_by_hostname,\n                &data->datapaths, &data->ports);\n    build_lb_port_related_data(&data->datapaths, &data->ports, &data->lbs,\n                               &data->lb_groups, input_data, ovnsb_txn);\n    build_lb_count_dps(&data->lbs);\n    build_ipam(&data->datapaths, &data->ports);\n    build_port_group_lswitches(input_data, &data->port_groups, &data->ports);\n    build_lrouter_groups(&data->ports, &data->lr_list);\n    build_ip_mcast(input_data, ovnsb_txn, &data->datapaths);\n    build_meter_groups(input_data, &data->meter_groups);\n    build_static_mac_binding_table(input_data, ovnsb_txn, &data->ports);\n    stopwatch_stop(BUILD_LFLOWS_CTX_STOPWATCH_NAME, time_msec());\n    stopwatch_start(CLEAR_LFLOWS_CTX_STOPWATCH_NAME, time_msec());\n    ovn_update_ipv6_options(&data->ports);\n    ovn_update_ipv6_prefix(&data->ports);\n\n    sync_lbs(input_data, ovnsb_txn, &data->datapaths, &data->lbs);\n    sync_port_groups(input_data, ovnsb_txn, &data->port_groups);\n    sync_meters(input_data, ovnsb_txn, &data->meter_groups);\n    sync_mirrors(input_data, ovnsb_txn);\n    sync_dns_entries(input_data, ovnsb_txn, &data->datapaths);\n    sync_template_vars(input_data, ovnsb_txn);\n\n    cleanup_stale_fdb_entries(input_data, &data->datapaths);\n    stopwatch_stop(CLEAR_LFLOWS_CTX_STOPWATCH_NAME, time_msec());\n\n    /* Set up SB_Global (depends on chassis features). */\n    const struct sbrec_sb_global *sb = sbrec_sb_global_table_first(\n                                       input_data->sbrec_sb_global_table);\n    if (!sb) {\n        sb = sbrec_sb_global_insert(ovnsb_txn);\n    }\n    if (nb->ipsec != sb->ipsec) {\n        sbrec_sb_global_set_ipsec(sb, nb->ipsec);\n    }\n\n    /* Inform ovn-controllers whether LB flows will use ct_mark (i.e., only\n     * if all chassis support it).  If not explicitly present in the database\n     * the default value to be used for this option is 'true'.\n     */\n    if (!data->features.ct_no_masked_label) {\n        smap_replace(&options, \"lb_hairpin_use_ct_mark\", \"false\");\n    } else {\n        smap_remove(&options, \"lb_hairpin_use_ct_mark\");\n    }\n    if (!smap_equal(&sb->options, &options)) {\n        sbrec_sb_global_set_options(sb, &options);\n    }\n    smap_destroy(&options);\n}\n\n/* Stores the set of chassis which references an ha_chassis_group.\n */\nstruct ha_ref_chassis_info {\n    const struct sbrec_ha_chassis_group *ha_chassis_group;\n    struct hmapx ref_chassis;\n};\n\nstatic void\nadd_to_ha_ref_chassis_info(struct ha_ref_chassis_info *ref_ch_info,\n                           const struct hmapx *chassis)\n{\n    if (!hmapx_count(&ref_ch_info->ref_chassis)) {\n        hmapx_destroy(&ref_ch_info->ref_chassis);\n        hmapx_clone(&ref_ch_info->ref_chassis, chassis);\n    } else {\n        struct hmapx_node *node;\n\n        HMAPX_FOR_EACH (node, chassis) {\n            hmapx_add(&ref_ch_info->ref_chassis, node->data);\n        }\n    }\n}\n\nstruct ha_chassis_group_node {\n    struct hmap_node hmap_node;\n    const struct sbrec_ha_chassis_group *ha_ch_grp;\n};\n\nstatic void\nupdate_sb_ha_group_ref_chassis(struct northd_input *input_data,\n                               struct shash *ha_ref_chassis_map)\n{\n    struct hmap ha_ch_grps = HMAP_INITIALIZER(&ha_ch_grps);\n    struct ha_chassis_group_node *ha_ch_grp_node;\n\n    /* Initialize a set of all ha_chassis_groups in SB. */\n    const struct sbrec_ha_chassis_group *ha_ch_grp;\n    SBREC_HA_CHASSIS_GROUP_TABLE_FOR_EACH (ha_ch_grp,\n                                    input_data->sbrec_ha_chassis_group_table) {\n        ha_ch_grp_node = xzalloc(sizeof *ha_ch_grp_node);\n        ha_ch_grp_node->ha_ch_grp = ha_ch_grp;\n        hmap_insert(&ha_ch_grps, &ha_ch_grp_node->hmap_node,\n                    uuid_hash(&ha_ch_grp->header_.uuid));\n    }\n\n    /* Update each group and remove it from the set. */\n    struct shash_node *node;\n    SHASH_FOR_EACH_SAFE (node, ha_ref_chassis_map) {\n        struct ha_ref_chassis_info *ha_ref_info = node->data;\n        size_t n = hmapx_count(&ha_ref_info->ref_chassis);\n        struct sbrec_chassis **ref_chassis;\n        struct hmapx_node *chassis_node;\n\n        ref_chassis = xmalloc(n * sizeof *ref_chassis);\n\n        n = 0;\n        HMAPX_FOR_EACH (chassis_node, &ha_ref_info->ref_chassis) {\n            ref_chassis[n++] = chassis_node->data;\n        }\n\n        sbrec_ha_chassis_group_set_ref_chassis(ha_ref_info->ha_chassis_group,\n                                               ref_chassis, n);\n        free(ref_chassis);\n\n        /* Remove the updated group from the set. */\n        HMAP_FOR_EACH_WITH_HASH (ha_ch_grp_node, hmap_node,\n            uuid_hash(&ha_ref_info->ha_chassis_group->header_.uuid),\n            &ha_ch_grps) {\n            if (ha_ch_grp_node->ha_ch_grp == ha_ref_info->ha_chassis_group) {\n                hmap_remove(&ha_ch_grps, &ha_ch_grp_node->hmap_node);\n                free(ha_ch_grp_node);\n                break;\n            }\n        }\n        hmapx_destroy(&ha_ref_info->ref_chassis);\n        free(ha_ref_info);\n        shash_delete(ha_ref_chassis_map, node);\n    }\n\n    /* Now the rest of the groups don't have any ref-chassis, so clear the SB\n     * field for those records. */\n    HMAP_FOR_EACH_SAFE (ha_ch_grp_node, hmap_node, &ha_ch_grps) {\n        sbrec_ha_chassis_group_set_ref_chassis(ha_ch_grp_node->ha_ch_grp,\n                                               NULL, 0);\n        hmap_remove(&ha_ch_grps, &ha_ch_grp_node->hmap_node);\n        free(ha_ch_grp_node);\n    }\n\n    hmap_destroy(&ha_ch_grps);\n}\n\n/* This function checks if the port binding 'sb' references\n * a HA chassis group.\n * Eg. Suppose a distributed logical router port - lr0-public\n * uses an HA chassis group - hagrp1 and if hagrp1 has 3 ha\n * chassis - gw1, gw2 and gw3.\n * Or\n * If the distributed logical router port - lr0-public has\n * 3 gateway chassis - gw1, gw2 and gw3.\n * ovn-northd creates ha chassis group - hagrp1 in SB DB\n * and adds gw1, gw2 and gw3 to its ha_chassis list.\n *\n * If port binding 'sb' represents a logical switch port 'p1'\n * and its logical switch is connected to the logical router\n * 'lr0' directly or indirectly (i.e p1's logical switch is\n *  connected to a router 'lr1' and 'lr1' has a path to lr0 via\n *  transit logical switches) and 'sb' is claimed by chassis - 'c1' then\n * this function adds c1 to the list of the reference chassis\n *  - 'ref_chassis' of hagrp1.\n */\nstatic void\ncollect_lb_groups_for_ha_chassis_groups(const struct sbrec_port_binding *sb,\n                                        struct ovn_port *op,\n                                        struct hmapx *lr_groups)\n{\n    struct lrouter_group *lr_group = NULL;\n    for (size_t i = 0; i < op->od->n_router_ports; i++) {\n        if (!op->od->router_ports[i]->peer) {\n            continue;\n        }\n\n        lr_group = op->od->router_ports[i]->peer->od->lr_group;\n        /* If a logical switch has multiple router ports, then\n         * all the logical routers belong to the same logical\n         * router group. */\n        break;\n    }\n\n    if (!lr_group) {\n        return;\n    }\n\n    hmapx_add(lr_groups, lr_group);\n    hmapx_add(&lr_group->tmp_ha_chassis, sb->chassis);\n}\n\nstatic void\nbuild_ha_chassis_group_ref_chassis(struct ovsdb_idl_index *ha_ch_grp_by_name,\n                                   struct hmapx *lr_groups,\n                                   struct shash *ha_ref_chassis_map)\n{\n    struct hmapx_node *node;\n\n    HMAPX_FOR_EACH (node, lr_groups) {\n        struct lrouter_group *lr_group = node->data;\n        const char *ha_group_name;\n\n        SSET_FOR_EACH (ha_group_name, &lr_group->ha_chassis_groups) {\n            const struct sbrec_ha_chassis_group *sb_ha_chassis_grp;\n\n            sb_ha_chassis_grp = ha_chassis_group_lookup_by_name(\n                                    ha_ch_grp_by_name, ha_group_name);\n            if (!sb_ha_chassis_grp) {\n                continue;\n            }\n\n            struct ha_ref_chassis_info *ref_ch_info =\n                shash_find_data(ha_ref_chassis_map, sb_ha_chassis_grp->name);\n            ovs_assert(ref_ch_info);\n\n            add_to_ha_ref_chassis_info(ref_ch_info, &lr_group->tmp_ha_chassis);\n        }\n\n        hmapx_destroy(&lr_group->tmp_ha_chassis);\n        hmapx_init(&lr_group->tmp_ha_chassis);\n    }\n}\n\n/* Handle changes to the 'chassis' column of the 'Port_Binding' table.  When\n * this column is not empty, it means we need to set the corresponding logical\n * port as 'up' in the northbound DB. */\nstatic void\nhandle_port_binding_changes(struct northd_input *input_data,\n                            struct ovsdb_idl_txn *ovnsb_txn,\n                            struct hmap *ports,\n                            struct shash *ha_ref_chassis_map)\n{\n    struct hmapx lr_groups = HMAPX_INITIALIZER(&lr_groups);\n    const struct sbrec_port_binding *sb;\n    bool build_ha_chassis_ref = false;\n\n    if (ovnsb_txn) {\n        const struct sbrec_ha_chassis_group *ha_ch_grp;\n        SBREC_HA_CHASSIS_GROUP_TABLE_FOR_EACH (ha_ch_grp,\n                                    input_data->sbrec_ha_chassis_group_table) {\n            if (ha_ch_grp->n_ha_chassis > 1) {\n                struct ha_ref_chassis_info *ref_ch_info;\n\n                ref_ch_info = xzalloc(sizeof *ref_ch_info);\n                ref_ch_info->ha_chassis_group = ha_ch_grp;\n                hmapx_init(&ref_ch_info->ref_chassis);\n                build_ha_chassis_ref = true;\n                shash_add(ha_ref_chassis_map, ha_ch_grp->name, ref_ch_info);\n            }\n        }\n    }\n\n    SBREC_PORT_BINDING_TABLE_FOR_EACH (sb,\n                                       input_data->sbrec_port_binding_table) {\n        struct ovn_port *op = ovn_port_find(ports, sb->logical_port);\n\n        if (!op || !op->nbsp) {\n            /* The logical port doesn't exist for this port binding.  This can\n             * happen under normal circumstances when ovn-northd hasn't gotten\n             * around to pruning the Port_Binding yet. */\n            continue;\n        }\n\n        bool up = false;\n\n        if (lsp_is_router(op->nbsp)) {\n            up = true;\n        } else if (sb->chassis) {\n            up = smap_get_bool(&sb->chassis->other_config,\n                               OVN_FEATURE_PORT_UP_NOTIF, false)\n                 ? sb->n_up && sb->up[0]\n                 : true;\n        }\n\n        if (!op->nbsp->up || *op->nbsp->up != up) {\n            nbrec_logical_switch_port_set_up(op->nbsp, &up, 1);\n        }\n\n        if (build_ha_chassis_ref && ovnsb_txn && sb->chassis) {\n            /* Check and collect the chassis which has claimed this 'sb'\n             * in relation to LR groups. */\n            collect_lb_groups_for_ha_chassis_groups(sb, op, &lr_groups);\n        }\n    }\n\n    /* Update ha chassis group's ref_chassis if required. */\n    build_ha_chassis_group_ref_chassis(\n                            input_data->sbrec_ha_chassis_grp_by_name,\n                            &lr_groups, ha_ref_chassis_map);\n    hmapx_destroy(&lr_groups);\n}\n\n/* Handle a fairly small set of changes in the southbound database. */\nstatic void\novnsb_db_run(struct northd_input *input_data,\n             struct ovsdb_idl_txn *ovnnb_txn,\n             struct ovsdb_idl_txn *ovnsb_txn,\n             struct hmap *ports)\n{\n    if (!ovnnb_txn ||\n        !ovsdb_idl_has_ever_connected(ovsdb_idl_txn_get_idl(ovnsb_txn))) {\n        return;\n    }\n\n    struct shash ha_ref_chassis_map = SHASH_INITIALIZER(&ha_ref_chassis_map);\n    handle_port_binding_changes(input_data,\n                                ovnsb_txn, ports, &ha_ref_chassis_map);\n    if (ovnsb_txn) {\n        update_sb_ha_group_ref_chassis(input_data,\n                                       &ha_ref_chassis_map);\n    }\n    shash_destroy(&ha_ref_chassis_map);\n}\n\nvoid northd_run(struct northd_input *input_data,\n                struct northd_data *data,\n                struct ovsdb_idl_txn *ovnnb_txn,\n                struct ovsdb_idl_txn *ovnsb_txn)\n{\n    stopwatch_start(OVNNB_DB_RUN_STOPWATCH_NAME, time_msec());\n    ovnnb_db_run(input_data, data, ovnnb_txn, ovnsb_txn,\n                 input_data->sbrec_chassis_by_name,\n                 input_data->sbrec_chassis_by_hostname);\n    stopwatch_stop(OVNNB_DB_RUN_STOPWATCH_NAME, time_msec());\n    stopwatch_start(OVNSB_DB_RUN_STOPWATCH_NAME, time_msec());\n    ovnsb_db_run(input_data, ovnnb_txn, ovnsb_txn, &data->ports);\n    stopwatch_stop(OVNSB_DB_RUN_STOPWATCH_NAME, time_msec());\n}\n\nconst char *\nnorthd_get_svc_monitor_mac(void)\n{\n    return svc_monitor_mac;\n}\n", "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<database name=\"ovn-nb\" title=\"OVN Northbound Database\">\n  <p>\n    This database is the interface between OVN and the cloud management system\n    (CMS), such as OpenStack, running above it.  The CMS produces almost all of\n    the contents of the database.  The <code>ovn-northd</code> program\n    monitors the database contents, transforms it, and stores it into the <ref\n    db=\"OVN_Southbound\"/> database.\n  </p>\n\n  <p>\n    We generally speak of ``the'' CMS, but one can imagine scenarios in\n    which multiple CMSes manage different parts of an OVN deployment.\n  </p>\n\n  <h2>External IDs</h2>\n\n  <p>\n    Each of the tables in this database contains a special column, named\n    <code>external_ids</code>.  This column has the same form and purpose each\n    place it appears.\n  </p>\n\n  <dl>\n    <dt><code>external_ids</code>: map of string-string pairs</dt>\n    <dd>\n      Key-value pairs for use by the CMS.  The CMS might use certain pairs, for\n      example, to identify entities in its own configuration that correspond to\n      those in this database.\n    </dd>\n  </dl>\n\n  <table name=\"NB_Global\" title=\"Northbound configuration\">\n    <p>\n      Northbound configuration for an OVN system.  This table must have exactly\n      one row.\n    </p>\n\n    <group title=\"Identity\">\n      <column name=\"name\">\n        The name of the OVN cluster, which uniquely identifies the OVN cluster\n        throughout all OVN clusters supposed to interconnect with each other.\n      </column>\n    </group>\n\n    <group title=\"Status\">\n      These columns allow a client to track the overall configuration state of\n      the system.\n\n      <column name=\"nb_cfg\">\n        Sequence number for client to increment.  When a client modifies any\n        part of the northbound database configuration and wishes to wait for\n        <code>ovn-northd</code> and possibly all of the hypervisors to finish\n        applying the changes, it may increment this sequence number.\n      </column>\n\n      <column name=\"nb_cfg_timestamp\">\n        <p>\n          The timestamp, in milliseconds since the epoch, when\n          <code>ovn-northd</code> sees the latest <code>nb_cfg</code> and starts\n          processing.\n        </p>\n\n        <p>\n          To print the timestamp as a human-readable date:\n        </p>\n\n        <pre>\n          date -d \"@$(ovn-nbctl get NB_Global . nb_cfg_timestamp | sed 's/...$//')\"\n        </pre>\n      </column>\n\n      <column name=\"sb_cfg\">\n        Sequence number that <code>ovn-northd</code> sets to the value of <ref\n        column=\"nb_cfg\"/> after it finishes applying the corresponding\n        configuration changes to the <ref db=\"OVN_Southbound\"/> database.\n      </column>\n\n      <column name=\"sb_cfg_timestamp\">\n        The timestamp, in milliseconds since the epoch, when\n        <code>ovn-northd</code> finishes applying the\n        corresponding configuration changes to the <ref db=\"OVN_Southbound\"/>\n        database successfully.\n      </column>\n\n      <column name=\"hv_cfg\">\n        <p>\n          Sequence number that <code>ovn-northd</code> sets to the smallest\n          sequence number of all the chassis in the system, as reported in the\n          <code>Chassis_Private</code> table in the southbound database.  Thus,\n          <ref column=\"hv_cfg\"/> equals <ref column=\"nb_cfg\"/> if all chassis\n          are caught up with the northbound configuration (which may never\n          happen, if any chassis is down).  This value can regress, if a\n          chassis was removed from the system and rejoins before catching up.\n        </p>\n\n        <p>\n          If there are no chassis, then <code>ovn-northd</code> copies\n          <code>nb_cfg</code> to <ref column=\"hv_cfg\"/>.  Thus, in this case,\n          the (nonexistent) hypervisors are always considered to be caught up.\n          This means that hypervisors can be \"caught up\" even in cases where\n          <ref column=\"sb_cfg\"/> would show that the southbound database is\n          not.  To detect when both the hypervisors and the southbound database\n          are caught up, a client should take the smaller of <ref\n          column=\"sb_cfg\"/> and <ref column=\"hv_cfg\"/>.\n        </p>\n      </column>\n\n      <column name=\"hv_cfg_timestamp\">\n        The largest timestamp, in milliseconds since the epoch, of the smallest\n        sequence number of all the\n        chassis in the system, as reported in the <code>Chassis_Private</code>\n        table in the southbound database.  In other words, this timestamp\n        reflects the time when the slowest chassis catches up with the\n        northbound configuration, which is useful for end-to-end control plane\n        latency measurement.\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n\n    <group title=\"Common options\">\n      <column name=\"options\">\n        This column provides general key/value settings. The supported\n        options are described individually below.\n      </column>\n\n      <group title=\"Options for configuring OVS BFD\">\n        <p>\n          These options apply when <code>ovn-controller</code> configures\n          OVS BFD on tunnels interfaces. Please note these parameters refer\n          to legacy OVS BFD implementation and not to OVN BFD one.\n        </p>\n\n        <column name=\"options\" key=\"bfd-min-rx\">\n          BFD option <code>min-rx</code> value to use when configuring BFD on\n          tunnel interfaces.\n        </column>\n\n        <column name=\"options\" key=\"bfd-decay-min-rx\">\n          BFD option <code>decay-min-rx</code> value to use when configuring\n          BFD on tunnel interfaces.\n        </column>\n\n        <column name=\"options\" key=\"bfd-min-tx\">\n          BFD option <code>min-tx</code> value to use when configuring BFD on\n          tunnel interfaces.\n        </column>\n\n        <column name=\"options\" key=\"bfd-mult\">\n          BFD option <code>mult</code> value to use when configuring BFD on\n          tunnel interfaces.\n        </column>\n      </group>\n\n      <column name=\"options\" key=\"mac_prefix\">\n        Configure a given OUI to be used as prefix when L2 address is\n        dynamically assigned, e.g. <code>00:11:22</code>\n      </column>\n\n      <column name=\"options\" key=\"mac_binding_removal_limit\"\n              type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 4294967295}'>\n        MAC binding aging bulk removal limit. This limits how many rows\n        can expire in a single transaction. Default value is 0 which\n        is unlimited. When we hit the limit next batch removal is delayed by\n        5 s.\n      </column>\n\n      <column name=\"options\" key=\"controller_event\" type='{\"type\": \"boolean\"}'>\n        Value set by the CMS to enable/disable ovn-controller event reporting.\n        Traffic into OVS can raise a 'controller' event that results in a\n        Controller_Event being written to the <ref table=\"Controller_Event\"/>\n        table in SBDB. When the CMS has seen the event and taken appropriate\n        action, it can remove the corresponding row in\n        <ref table=\"Controller_Event\"/> table.\n        The intention is for a CMS to see the events and take some sort of\n        action. Please see the <ref table=\"Controller_Event\"/> table in SBDB.\n        It is possible to associate a meter to each controller event type\n        in order to not overload the pinctrl thread under heavy load.\n        Each event type relies on a meter with a defined name:\n\n        <ul>\n          <li>empty_lb_backends: event-elb</li>\n        </ul>\n\n      </column>\n\n      <column name=\"options\" key=\"northd_probe_interval\">\n        <p>\n          The inactivity probe interval of the connection to the OVN Northbound\n          and Southbound databases from <code>ovn-northd</code>, in milliseconds.\n          If the value is zero, it disables the connection keepalive feature.\n        </p>\n\n        <p>\n          If the value is nonzero, then it will be forced to a value of\n          at least 1000 ms.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"northd_trim_timeout\">\n        <p>\n          When used, this configuration value specifies the time, in\n          milliseconds, since the last <code>ovn-northd</code> active operation\n          after which memory trimming is performed.  By default this is set to\n          30000 (30 seconds).\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"use_logical_dp_groups\">\n        <p>\n          Note: This option is deprecated, the only behavior is to always\n          combine logical flows by datapath groups.  Changing the value or\n          removing this option all toghether will have no effect.\n        </p>\n        <p>\n          <code>ovn-northd</code> combines logical flows that differs\n          only by logical datapath into a single logical flow with\n          logical datapath group attached.\n        </p>\n      </column>\n      <column name=\"options\" key=\"use_parallel_build\">\n        <p>\n          If set to <code>true</code>, <code>ovn-northd</code> will attempt\n          to compute logical flows in parallel.\n        </p>\n        <p>\n          Parallel computation is enabled only if the system has 4 or more\n          cores/threads available to be used by ovn-northd.\n        </p>\n        <p>\n          The default value is <code>false</code>.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"ignore_lsp_down\">\n        <p>\n          If set to false, ARP/ND reply flows for logical switch ports will be\n          installed only if the port is up, i.e. claimed by a Chassis. If set\n          to true, these flows are installed regardless of the status of the\n          port, which can result in a situation that ARP request to an IP is\n          resolved even before the relevant VM/container is running. For\n          environments where this is not an issue, setting it to\n          <code>true</code> can reduce the load and latency of the control\n          plane. The default value is <code>true</code>.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"use_ct_inv_match\">\n        <p>\n          If set to false, <code>ovn-northd</code> will not use the\n          <code>ct.inv</code> field in any of the logical flow matches.\n          The default value is true.  If the NIC supports offloading\n          OVS datapath flows but doesn't support offloading ct_state\n          <code>inv</code> flag, then the datapath flows matching on this flag\n          (either <code>+inv</code> or <code>-inv</code>) will not be\n          offloaded.  CMS should consider setting <code>use_ct_inv_match</code>\n          to <code>false</code> in such cases.  This results in a side effect\n          of the invalid packets getting delivered to the destination VIF,\n          which otherwise would have been dropped by <code>OVN</code>.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"default_acl_drop\">\n        <p>\n          If set to <code>true</code>., <code>ovn-northd</code> will\n          generate a logical flow to drop all traffic in the ACL stages.\n          By default this option is set to <code>false</code>.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"debug_drop_domain_id\">\n        <p>\n          If set to a 8-bit number and if\n          <code>debug_drop_collector_set</code> is also configured,\n          <code>ovn-northd</code> will add a <code>sample</code> action to\n          every logical flow that contains a 'drop' action.\n          The 8 most significant bits of the observation_domain_id field will\n          be those specified in the\n          <code> debug_drop_domain_id</code>.\n          The 24 least significant bits of the observation_domain_id field will\n          be the datapath's key.\n        </p>\n        <p>\n          The observation_point_id will be set to the first 32 bits of the\n          logical flow's UUID.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"debug_drop_collector_set\">\n        <p>\n          If set to a 32-bit number <code>ovn-northd</code> will add a\n          <code>sample</code> action to every logical flow that contains a\n          'drop' action. The sample action will have the specified\n          collector_set_id. The value must match that of the local OVS\n          configuration as described in <code>ovs-actions</code>(7).\n        </p>\n      </column>\n\n      <group title=\"Options for configuring interconnection route advertisement\">\n        <p>\n          These options control how routes are advertised between OVN\n          deployments for interconnection.  If enabled, <code>ovn-ic</code>\n          from different OVN deployments exchanges routes between each other\n          through the global <ref db=\"OVN_IC_Southbound\"/> database.  Only\n          routers with ports connected to interconnection transit switches\n          participate in route advertisement.  For each of these routers, there\n          are two types of routes to be advertised:\n        </p>\n\n        <p>\n          Firstly, the static routes configured in the router are advertised.\n        </p>\n\n        <p>\n          Secondly, the <code>networks</code> configured in the logical router\n          ports that are not on the transit switches are advertised.  These\n          are considered as directly connected subnets on the router.\n        </p>\n\n        <p>\n          Link local prefixes (IPv4 169.254.0.0/16 and IPv6 FE80::/10)\n          are never advertised.\n        </p>\n\n        <p>\n          The learned routes are added to the\n          <ref column=\"static_routes\" table=\"Logical_Router\"/> column of the\n          <ref table=\"Logical_Router\"/> table, with\n          <code>external_ids:ic-learned-route</code> set to the uuid\n          of the row in <ref table=\"Route\" db=\"OVN_IC_Southbound\"/>\n          table of the <ref db=\"OVN_IC_Southbound\"/> database.\n        </p>\n\n        <column name=\"options\" key=\"ic-route-adv\">\n          A boolean value that enables route advertisement to the global\n          <ref db=\"OVN_IC_Southbound\"/> database.  Default is\n          <code>false</code>.\n        </column>\n\n        <column name=\"options\" key=\"ic-route-learn\">\n          A boolean value that enables route learning from the global\n          <ref db=\"OVN_IC_Southbound\"/> database.  Default is\n          <code>false</code>.\n        </column>\n\n        <column name=\"options\" key=\"ic-route-adv-default\">\n          A boolean value that enables advertising default route to the global\n          <ref db=\"OVN_IC_Southbound\"/> database.  Default is\n          <code>false</code>.  This option takes effect only when option\n          <code>ic-route-adv</code> is <code>true</code>.\n        </column>\n\n        <column name=\"options\" key=\"ic-route-learn-default\">\n          A boolean value that enables learning default route from the global\n          <ref db=\"OVN_IC_Southbound\"/> database.  Default is\n          <code>false</code>.  This option takes effect only when option\n          <code>ic-route-learn</code> is <code>true</code>.\n        </column>\n\n        <column name=\"options\" key=\"ic-route-blacklist\">\n          A string value contains a list of CIDRs delimited by \",\".  A route\n          will not be advertised or learned if the route's prefix belongs to\n          any of the CIDRs listed.\n        </column>\n      </group>\n\n    </group>\n\n    <group title=\"Connection Options\">\n      <column name=\"connections\">\n        Database clients to which the Open vSwitch database server should\n        connect or on which it should listen, along with options for how these\n        connections should be configured.  See the <ref table=\"Connection\"/>\n        table for more information.\n      </column>\n      <column name=\"ssl\">\n        Global SSL configuration.\n      </column>\n    </group>\n    <group title=\"Security Configurations\">\n      <column name=\"ipsec\">\n        Tunnel encryption configuration. If this column is set to be true, all\n        OVN tunnels will be encrypted with IPsec.\n      </column>\n    </group>\n\n    <group title=\"Read-only Options\">\n      <column name=\"options\" key=\"max_tunid\">\n        <p>\n          The maximum supported tunnel ID. Depends on types of encapsulation\n          enabled in the cluster.\n        </p>\n      </column>\n    </group>\n\n  </table>\n\n  <table name=\"Copp\" title=\"Control plane protection\">\n    <p>\n      This table is used to define control plane protection policies, i.e.,\n      associate entries from table <ref table=\"Meter\"/> to control protocol\n      names.\n    </p>\n    <column name=\"name\">\n      CoPP name.\n    </column>\n    <column name=\"meters\" key=\"arp\">\n      Rate limiting meter for ARP packets (request/reply) used for learning\n      neighbors.\n    </column>\n    <column name=\"meters\" key=\"arp-resolve\">\n      Rate limiting meter for packets that require resolving the next-hop\n      (through ARP).\n    </column>\n    <column name=\"meters\" key=\"dhcpv4-opts\">\n      Rate limiting meter for packets that require adding DHCPv4 options.\n    </column>\n    <column name=\"meters\" key=\"dhcpv6-opts\">\n      Rate limiting meter for packets that require adding DHCPv6 options.\n    </column>\n    <column name=\"meters\" key=\"dns\">\n      Rate limiting meter for DNS query packets that need to be replied to.\n    </column>\n    <column name=\"meters\" key=\"event-elb\">\n      Rate limiting meter for empty load balancer events.\n    </column>\n    <column name=\"meters\" key=\"icmp4-error\">\n      Rate limiting meter for packets that require replying with an ICMP\n      error.\n    </column>\n    <column name=\"meters\" key=\"icmp6-error\">\n      Rate limiting meter for packets that require replying with an ICMPv6\n      error.\n    </column>\n    <column name=\"meters\" key=\"igmp\">\n      Rate limiting meter for IGMP packets.\n    </column>\n    <column name=\"meters\" key=\"nd-na\">\n      Rate limiting meter for ND neighbor advertisement packets used for\n      learning neighbors.\n    </column>\n    <column name=\"meters\" key=\"nd-ns\">\n      Rate limiting meter for ND neighbor solicitation packets used for\n      learning neighbors.\n    </column>\n    <column name=\"meters\" key=\"nd-ns-resolve\">\n      Rate limiting meter for packets that require resolving the next-hop\n      (through ND).\n    </column>\n    <column name=\"meters\" key=\"nd-ra-opts\">\n      Rate limiting meter for packets that require adding ND router\n      advertisement options.\n    </column>\n    <column name=\"meters\" key=\"tcp-reset\">\n      Rate limiting meter for packets that require replying with TCP RST\n      packet.\n    </column>\n    <column name=\"meters\" key=\"bfd\">\n      Rate limiting meter for BFD packets.\n    </column>\n    <column name=\"meters\" key=\"reject\">\n      Rate limiting meter for packets that trigger a reject action\n    </column>\n    <column name=\"meters\" key=\"svc-monitor\">\n      Rate limiting meter for packets that are arriving to service\n      monitor MAC address.\n    </column>\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n\n  <table name=\"Logical_Switch\" title=\"L2 logical switch\">\n    <p>\n      Each row represents one L2 logical switch.\n    </p>\n\n    <p>\n      There are two kinds of logical switches, that is, ones that fully\n      virtualize the network (overlay logical switches) and ones that provide\n      simple connectivity to physical networks (bridged logical switches).\n      They work in the same way when providing connectivity between logical\n      ports on same chassis, but differently when connecting remote logical\n      ports.  Overlay logical switches connect remote logical ports by tunnels,\n      while bridged logical switches provide connectivity to remote ports by\n      bridging the packets to directly connected physical L2 segments with the\n      help of <code>localnet</code> ports.  Each bridged logical switch has\n      one or more <code>localnet</code> ports, which have only one special\n      address <code>unknown</code>.\n    </p>\n\n    <column name=\"ports\">\n      <p>\n        The logical ports connected to the logical switch.\n      </p>\n\n      <p>\n        It is an error for multiple logical switches to include the same\n        logical port.\n      </p>\n    </column>\n\n    <column name=\"load_balancer\">\n      Set of load balancers associated to this logical switch.\n    </column>\n\n    <column name=\"load_balancer_group\">\n      Set of load balancers groups associated to this logical switch.\n    </column>\n\n    <column name=\"acls\">\n      Access control rules that apply to packets within the logical switch.\n    </column>\n\n    <column name=\"qos_rules\">\n      QoS marking and metering rules that apply to packets within the\n      logical switch.\n    </column>\n\n    <column name=\"dns_records\">\n      This column defines the DNS records to be used for resolving internal\n      DNS queries within the logical switch by the native DNS resolver.\n      Please see the <ref table=\"DNS\"/> table.\n    </column>\n\n    <column name=\"forwarding_groups\">\n      Groups a set of logical port endpoints for traffic going out of the\n      logical switch.\n    </column>\n\n    <group title=\"Naming\">\n      <p>\n        These columns provide names for the logical switch.  From OVN's\n        perspective, these names have no special meaning or purpose other than\n        to provide convenience for human interaction with the  database.\n        There is no requirement for the name to be unique.  (For a unique\n        identifier for a logical switch, use its row UUID.)\n      </p>\n\n      <p>\n        (Originally, <ref column=\"name\"/> was intended to serve the purpose of\n        a human-friendly name, but the Neutron integration used it to uniquely\n        identify its own switch object, in the format\n        <code>neutron-<var>uuid</var></code>.  Later on, Neutron started\n        propagating the friendly name of a switch as <ref column=\"external_ids\"\n        key=\"neutron:network_name\"/>.  Perhaps this can be cleaned up someday.)\n      </p>\n\n      <column name=\"name\">\n        A name for the logical switch.\n      </column>\n\n      <column name=\"external_ids\" key=\"neutron:network_name\">\n        Another name for the logical switch.\n      </column>\n    </group>\n\n    <group title=\"IP Address Assignment\">\n      <p>\n        These options control automatic IP address management (IPAM) for ports\n        attached to the logical switch.  To enable IPAM for IPv4, set <ref\n        column=\"other_config\" key=\"subnet\"/> and optionally <ref\n        column=\"other_config:exclude_ips\"/>.  To enable IPAM for IPv6, set\n        <ref column=\"other_config\" key=\"ipv6_prefix\"/>.  IPv4 and IPv6 may\n        be enabled together or separately.\n      </p>\n\n      <p>\n        To request dynamic address assignment for a particular port, use the\n        <code>dynamic</code> keyword in the <ref table=\"Logical_Switch_Port\"\n        column=\"addresses\"/> column of the port's <ref\n        table=\"Logical_Switch_Port\"/> row.  This requests both an IPv4 and an\n        IPv6 address, if IPAM for IPv4 and IPv6 are both enabled.\n      </p>\n\n      <column name=\"other_config\" key=\"subnet\">\n        Set this to an IPv4 subnet, e.g. <code>192.168.0.0/24</code>, to enable\n        <code>ovn-northd</code> to automatically assign IP addresses within\n        that subnet.\n      </column>\n\n      <column name=\"other_config\" key=\"exclude_ips\">\n        <p>\n          To exclude some addresses from automatic IP address management, set\n          this to a list of the IPv4 addresses or <code>..</code>-delimited\n          ranges to exclude.  The addresses or ranges should be a subset of\n          those in <ref column=\"other_config\" key=\"subnet\"/>.\n        </p>\n        <p>\n          Whether listed or not, <code>ovn-northd</code> will never allocate\n          the first or last address in a subnet, such as 192.168.0.0 or\n          192.168.0.255 in 192.168.0.0/24.\n        </p>\n        <p>\n          Examples:\n        </p>\n        <ul>\n          <li><code>192.168.0.2 192.168.0.10</code></li>\n          <li><code>192.168.0.4 192.168.0.30..192.168.0.60 192.168.0.110..192.168.0.120</code></li>\n          <li><code>192.168.0.110..192.168.0.120 192.168.0.25..192.168.0.30 192.168.0.144</code></li>\n        </ul>\n      </column>\n\n      <column name=\"other_config\" key=\"ipv6_prefix\">\n        Set this to an IPv6 prefix to enable <code>ovn-northd</code> to\n        automatically assign IPv6 addresses using this prefix.  The assigned\n        IPv6 address will be generated using the IPv6 prefix and the MAC\n        address (converted to an IEEE EUI64 identifier) of the port.  The IPv6\n        prefix defined here should be a valid IPv6 address ending with\n        <code>::</code>.\n        <p>\n          Examples:\n        </p>\n        <ul>\n          <li><code>aef0::</code></li>\n          <li><code>bef0:1234:a890:5678::</code></li>\n          <li><code>8230:5678::</code></li>\n        </ul>\n      </column>\n\n      <column name=\"other_config\" key=\"mac_only\" type='{\"type\": \"boolean\"}'>\n        Value used to request to assign L2 address only if neither subnet\n        nor ipv6_prefix are specified\n      </column>\n    </group>\n\n    <group title=\"IP Multicast Snooping Options\">\n      <p>\n        These options control IP Multicast Snooping configuration of the\n        logical switch. To enable IP Multicast Snooping set\n        <ref column=\"other_config\" key=\"mcast_snoop\"/> to true. To enable IP\n        Multicast Querier set <ref column=\"other_config\" key=\"mcast_querier\"/>\n        to true. If IP Multicast Querier is enabled\n        <ref column=\"other_config\" key=\"mcast_eth_src\"/> and\n        <ref column=\"other_config\" key=\"mcast_ip4_src\"/> must be set.\n      </p>\n      <column name=\"other_config\" key=\"mcast_snoop\"\n          type='{\"type\": \"boolean\"}'>\n        Enables/disables IP Multicast Snooping on the logical switch.\n        Default: <code>false</code>.\n      </column>\n      <column name=\"other_config\" key=\"mcast_querier\"\n          type='{\"type\": \"boolean\"}'>\n        Enables/disables IP Multicast Querier on the logical switch.\n        Only applicable if <ref column=\"other_config\" key=\"mcast_snoop\"/>\n        is enabled.\n        Default: <code>true</code>.\n      </column>\n      <column name=\"other_config\" key=\"mcast_flood_unregistered\"\n          type='{\"type\": \"boolean\"}'>\n        Determines whether unregistered multicast traffic should be flooded\n        or not. Only applicable if\n        <ref column=\"other_config\" key=\"mcast_snoop\"/> is enabled.\n        Default: <code>false</code>.\n      </column>\n      <column name=\"other_config\" key=\"mcast_table_size\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 32766}'>\n        Number of multicast groups to be stored. Default: 2048.\n      </column>\n      <column name=\"other_config\" key=\"mcast_idle_timeout\"\n          type='{\"type\": \"integer\", \"minInteger\": 15, \"maxInteger\": 3600}'>\n        Configures the IP Multicast Snooping group idle timeout (in seconds).\n        Default: 300 seconds.\n      </column>\n      <column name=\"other_config\" key=\"mcast_query_interval\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 3600}'>\n        Configures the IP Multicast Querier interval between queries (in\n        seconds). Default:\n        <ref column=\"other_config\" key=\"mcast_idle_timeout\"/> / 2.\n      </column>\n      <column name=\"other_config\" key=\"mcast_query_max_response\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 10}'>\n        Configures the value of the \"max-response\" field in the multicast\n        queries originated by the logical switch. Default: 1 second.\n      </column>\n      <column name=\"other_config\" key=\"mcast_eth_src\">\n        Configures the source Ethernet address for queries originated by the\n        logical switch.\n      </column>\n      <column name=\"other_config\" key=\"mcast_ip4_src\">\n        Configures the source IPv4 address for queries originated by the\n        logical switch.\n      </column>\n      <column name=\"other_config\" key=\"mcast_ip6_src\">\n        Configures the source IPv6 address for queries originated by the\n        logical switch.\n      </column>\n    </group>\n\n    <group title=\"Interconnection\">\n      <column name=\"other_config\" key=\"interconn-ts\"\n          type='{\"type\": \"string\"}'>\n        The <ref table=\"Transit_Switch\" column=\"name\" db=\"OVN_IC_Northbound\"/>\n        of corresponding transit switch in <ref db=\"OVN_IC_Northbound\"/>\n        database.  This kind of logical switch is created and controlled\n        by <code>ovn-ic</code>.\n      </column>\n    </group>\n\n    <group title=\"Tunnel Key\">\n      <column name=\"other_config\" key=\"requested-tnl-key\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 16777215}'>\n        Configures the datapath tunnel key for the logical switch.  Usually\n        this is not needed because <code>ovn-northd</code> will assign an\n        unique key for each datapath by itself.  However, if it is configured,\n        <code>ovn-northd</code> honors the configured value.  The typical use\n        case is for interconnection: the tunnel keys for transit switches need\n        to be unique globally, so they are maintained in the global\n        <ref db=\"OVN_IC_Southbound\"/> database, and <code>ovn-ic</code> simply\n        syncs the value from <ref db=\"OVN_IC_Southbound\"/> through this config.\n      </column>\n    </group>\n\n    <column name=\"copp\">\n      <p>\n        The control plane protection policy from table <ref table=\"Copp\"/>\n        used for metering packets sent to <code>ovn-controller</code> from\n        ports of this logical switch.\n      </p>\n    </column>\n\n    <group title=\"Other options\">\n      <column name=\"other_config\" key=\"vlan-passthru\"\n          type='{\"type\": \"boolean\"}'>\n        Determines whether VLAN tagged incoming traffic should be allowed. Note\n        that this may have security implications when enabled for a logical\n        switch with a tag=0 localnet port. If not properly isolated from other\n        localnet ports, fabric traffic that belongs to other tagged networks may\n        be passed through such a port.\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Logical_Switch_Port\" title=\"L2 logical switch port\">\n    <p>\n      A port within an L2 logical switch.\n    </p>\n\n    <group title=\"Core Features\">\n      <column name=\"name\">\n        <p>\n          The logical port name.\n        </p>\n\n        <p>\n          For entities (VMs or containers) that are spawned in the hypervisor,\n          the name used here must match those used in the <ref key=\"iface-id\"\n          table=\"Interface\" column=\"external_ids\" db=\"Open_vSwitch\"/> in the\n          <ref db=\"Open_vSwitch\"/> database's <ref table=\"Interface\"\n          db=\"Open_vSwitch\"/> table, because hypervisors use <ref key=\"iface-id\"\n          table=\"Interface\" column=\"external_ids\" db=\"Open_vSwitch\"/> as a lookup\n          key to identify the network interface of that entity.\n        </p>\n\n        <p>\n          For containers that share a VIF within a VM, the name can be any\n          unique identifier.  See <code>Containers</code>, below, for more\n          information.\n        </p>\n\n        <p>\n          A logical switch port may not have the same name as a logical router\n          port, but the database schema cannot enforce this.\n        </p>\n      </column>\n\n      <column name=\"type\">\n        <p>\n          Specify a type for this logical port.  Logical ports can be used to\n          model other types of connectivity into an OVN logical switch.  The\n          following types are defined:\n        </p>\n\n        <dl>\n          <dt>(empty string)</dt>\n          <dd>\n            A VM (or VIF) interface.\n          </dd>\n\n          <dt><code>router</code></dt>\n          <dd>\n            A connection to a logical router.  The value of <ref\n            column=\"options\" key=\"router-port\"/> specifies the <ref\n            column=\"name\"/> of the <ref table=\"Logical_Router_Port\"/>\n            to which this logical switch port is connected.\n          </dd>\n\n          <dt><code>localnet</code></dt>\n          <dd>\n            A connection to a locally accessible network from\n            <code>ovn-controller</code> instances that have a corresponding\n            bridge mapping.  A logical switch can have multiple\n            <code>localnet</code> ports attached.  This type is used to model\n            direct connectivity to existing networks.  In this case, each\n            chassis should have a mapping for one of the physical networks\n            only.  Note: nothing said above implies that a chassis cannot be\n            plugged to multiple physical networks as long as they belong to\n            different switches.\n          </dd>\n\n          <dt><code>localport</code></dt>\n          <dd>\n            A connection to a local VIF. Traffic that arrives on a\n            <code>localport</code> is never forwarded over a tunnel to another\n            chassis. These ports are present on every chassis and have the same\n            address in all of them. This is used to model connectivity to local\n            services that run on every hypervisor.\n          </dd>\n\n          <dt><code>l2gateway</code></dt>\n          <dd>\n            A connection to a physical network.\n          </dd>\n\n          <dt><code>vtep</code></dt>\n          <dd>\n            A port to a logical switch on a VTEP gateway.\n          </dd>\n\n          <dt><code>external</code></dt>\n          <dd>\n            <p>\n              Represents a logical port which is external and not having\n              an OVS port in the integration bridge.\n              <code>OVN</code> will never receive any traffic from this port or\n              send any traffic to this port. <code>OVN</code> can support\n              native services like DHCPv4/DHCPv6/DNS for this port.\n              If <ref column=\"ha_chassis_group\"/> is defined,\n              <code>ovn-controller</code> running in the master chassis of\n              the HA chassis group will bind this port to provide these native\n              services. It is expected that this port belong to a bridged\n              logical switch (with a <code>localnet</code> port).\n            </p>\n\n            <p>\n              It is recommended to use the same HA chassis group for all the\n              external ports of a logical switch. Otherwise, the physical\n              switch might see MAC flap issue when different chassis provide\n              the native services. For example when supporting native DHCPv4\n              service, DHCPv4 server mac (configured in\n              <ref column=\"options:server_mac\" table=\"DHCP_Options\"\n              db=\"OVN_NB\"/> column in table <ref table=\"DHCP_Options\"/>)\n              originating from different ports can cause MAC flap issue.\n              The MAC of the logical router IP(s) can also flap if the\n              same HA chassis group is not set for all the external ports\n              of a logical switch.\n            </p>\n\n            <p>\n              Below are some of the use cases where <code>external</code>\n              ports can be used.\n            </p>\n\n            <ul>\n              <li>\n                VMs connected to SR-IOV nics - Traffic from these VMs by passes\n                the kernel stack and local <code>ovn-controller</code> do not\n                bind these ports and cannot serve the native services.\n              </li>\n\n              <li>\n                When CMS supports provisioning baremetal servers.\n              </li>\n            </ul>\n          </dd>\n\n          <dt><code>virtual</code></dt>\n          <dd>\n            <p>\n              Represents a logical port which does not have an OVS\n              port in the integration bridge and has a virtual ip configured\n              in the <ref column=\"options:virtual-ip\"/> column. This virtual ip\n              can move around between the logical ports configured in\n              the <ref column=\"options:virtual-parents\"/> column.\n            </p>\n\n            <p>\n              One of the use case where <code>virtual</code>\n              ports can be used is.\n            </p>\n\n            <ul>\n              <li>\n                The <code>virtual ip</code> represents a load balancer vip\n                and the <code>virtual parents</code> provide load balancer\n                service in an active-standby setup with the active virtual\n                parent owning the <code>virtual ip</code>.\n              </li>\n            </ul>\n          </dd>\n\n          <dt><code>remote</code></dt>\n          <dd>\n            A remote port is to model a port that resides remotely on another\n            OVN, which is on the other side of a transit logical switch for OVN\n            interconnection.  This type of ports are created by\n            <code>ovn-ic</code> instead of by CMS.  Any change to the port will\n            be automatically overwritten by <code>ovn-ic</code>.\n          </dd>\n        </dl>\n      </column>\n    </group>\n\n    <group title=\"Options\">\n      <column name=\"options\">\n        This column provides key/value settings specific to the logical port\n        <ref column=\"type\"/>.  The type-specific options are described\n        individually below.\n      </column>\n\n      <group title=\"Options for router ports\">\n        <p>\n          These options apply when <ref column=\"type\"/> is <code>router</code>.\n        </p>\n\n        <column name=\"options\" key=\"router-port\">\n          Required.  The <ref column=\"name\"/> of the <ref\n          table=\"Logical_Router_Port\"/> to which this logical switch port is\n          connected.\n        </column>\n\n        <column name=\"options\" key=\"nat-addresses\">\n          <p>\n            This is used to send gratuitous ARPs for SNAT and DNAT IP\n            addresses via the <code>localnet</code> port that is attached\n            to the same logical switch as this type <code>router</code>\n            port.  This option is specified on a logical switch port that is\n            connected to a gateway router, or a logical switch port that is\n            connected to a distributed gateway port on a logical router.\n          </p>\n\n          <p>\n            This must take one of the following forms:\n          </p>\n\n          <dl>\n            <dt><code>router</code></dt>\n            <dd>\n              <p>\n                Gratuitous ARPs will be sent for all SNAT and DNAT external IP\n                addresses and for all load balancer IP addresses defined on the\n                <ref column=\"options\" key=\"router-port\"/>'s logical router,\n                using the <ref column=\"options\" key=\"router-port\"/>'s MAC\n                address.\n              </p>\n\n              <p>\n                This form of <ref column=\"options\" key=\"nat-addresses\"/> is\n                valid for logical switch ports where <ref column=\"options\"\n                key=\"router-port\"/> is the name of a port on a gateway router,\n                or the name of a distributed gateway port.\n              </p>\n\n              <p>\n                Supported only in OVN 2.8 and later.  Earlier versions required\n                NAT addresses to be manually synchronized.\n              </p>\n            </dd>\n\n            <dt><code>Ethernet address followed by one or more IPv4 addresses</code></dt>\n            <dd>\n              <p>\n                Example: <code>80:fa:5b:06:72:b7 158.36.44.22\n                158.36.44.24</code>. This would result in generation of\n                gratuitous ARPs for IP addresses 158.36.44.22 and 158.36.44.24\n                with a MAC address of 80:fa:5b:06:72:b7.\n              </p>\n\n              <p>\n                This form of <ref column=\"options\" key=\"nat-addresses\"/> is\n                only valid for logical switch ports where <ref column=\"options\"\n                key=\"router-port\"/> is the name of a port on a gateway router.\n              </p>\n            </dd>\n          </dl>\n        </column>\n\n        <column name=\"options\" key=\"exclude-lb-vips-from-garp\">\n          If <ref column=\"options\" key=\"nat-addresses\"/> is set to\n          <code>router</code>, Gratuitous ARPs will be sent for all\n          SNAT and DNAT external IP addresses defined on the\n          <ref column=\"options\" key=\"router-port\"/>'s logical router,\n          using the <ref column=\"options\" key=\"router-port\"/>'s MAC address,\n          not cosidering configured load balancers.\n        </column>\n\n        <column name=\"options\" key=\"arp_proxy\">\n          Optional. A list of IPv4 addresses that this\n          logical switch <code>router</code> port will reply to ARP requests.\n          Example: <code>169.254.239.254 169.254.239.2</code>. The\n          <ref column=\"options\" key=\"router-port\"/>'s logical router should\n          have a route to forward packets sent to configured proxy ARP IPs to\n          an appropriate destination.\n        </column>\n      </group>\n\n      <group title=\"Options for localnet ports\">\n        <p>\n          These options apply when <ref column=\"type\"/> is\n          <code>localnet</code>.\n        </p>\n\n        <column name=\"options\" key=\"network_name\">\n          Required.  The name of the network to which the <code>localnet</code>\n          port is connected.  Each hypervisor, via <code>ovn-controller</code>,\n          uses its local configuration to determine exactly how to connect to\n          this locally accessible network, if at all.\n        </column>\n\n        <column name=\"options\" key=\"ethtype\">\n          Optional. VLAN EtherType field value for encapsulating VLAN\n          headers. Supported values: 802.11q (default), 802.11ad.\n        </column>\n\n        <column name=\"options\" key=\"localnet_learn_fdb\"\n                type='{\"type\": \"boolean\"}'>\n          Optional. Allows localnet port to learn MACs and store them in FDB\n          table if set to <code>true</code>. The default value is\n          <code>false</code>.\n        </column>\n\n      </group>\n\n      <group title=\"Options for l2gateway ports\">\n        <p>\n          These options apply when <ref column=\"type\"/> is\n          <code>l2gateway</code>.\n        </p>\n\n        <column name=\"options\" key=\"network_name\">\n          Required.  The name of the network to which the <code>l2gateway</code>\n          port is connected.  The L2 gateway, via <code>ovn-controller</code>,\n          uses its local configuration to determine exactly how to connect to\n          this network.\n        </column>\n\n        <column name=\"options\" key=\"l2gateway-chassis\">\n          Required. The chassis on which the <code>l2gateway</code> logical\n          port should be bound to. <code>ovn-controller</code> running on the\n          defined chassis will connect this logical port to the physical network.\n        </column>\n\n      </group>\n\n      <group title=\"Options for vtep ports\">\n        <p>\n          These options apply when <ref column=\"type\"/> is <code>vtep</code>.\n        </p>\n\n        <column name=\"options\" key=\"vtep-physical-switch\">\n          Required.  The name of the VTEP gateway.\n        </column>\n\n        <column name=\"options\" key=\"vtep-logical-switch\">\n          Required.  A logical switch name connected by the VTEP gateway.\n        </column>\n      </group>\n\n      <group title=\"VMI (or VIF) Options\">\n        <p>\n          These options apply to logical ports with <ref column=\"type\"/> having\n          (empty string)\n        </p>\n\n        <column name=\"options\" key=\"requested-chassis\">\n          <p>\n            If set, identifies a specific chassis (by name or hostname) that\n            is allowed to bind this port. Using this option will prevent\n            thrashing between two chassis trying to bind the same port during\n            a live migration. It can also prevent similar thrashing due to a\n            mis-configuration, if a port is accidentally created on more than\n            one chassis.\n          </p>\n\n          <p>\n            If set to a comma separated list, the first entry identifies the\n            main chassis and the rest are one or more additional chassis that\n            are allowed to bind the same port.\n          </p>\n\n          <p>\n            When multiple chassis are set for the port, and the logical switch\n            is connected to an external network through a <code>localnet</code>\n            port, tunneling is enforced for the port to guarantee delivery of\n            packets directed to the port to all its locations. This has MTU\n            implications because the network used for tunneling must have MTU\n            larger than <code>localnet</code> for stable connectivity.\n          </p>\n\n          <p>\n            If the same host co-hosts more than one controller instance\n            (either belonging to the same or separate clusters), special\n            attention should be given to consistently using unique chassis\n            names used in this option. It is advised that chassis names -\n            and not host names - are used for this option.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"activation-strategy\">\n          If used with multiple chassis set in\n          <ref column=\"requested-chassis\"/>, specifies an activation strategy\n          for all additional chassis. By default, no activation strategy is\n          used, meaning additional port locations are immediately available for\n          use. When set to \"rarp\", the port is blocked for ingress and egress\n          communication until a RARP packet is sent from a new location. The\n          \"rarp\" strategy is useful in live migration scenarios for virtual\n          machines.\n        </column>\n\n        <column name=\"options\" key=\"iface-id-ver\">\n          If set, this port will be bound by <code>ovn-controller</code>\n          only if this same key and value is configured in the\n          <ref table=\"Interface\" column=\"external_ids\" db=\"Open_vSwitch\"/>\n          column in the Open_vSwitch database's\n          <ref table=\"Interface\" db=\"Open_vSwitch\"/> table.\n        </column>\n\n        <column name=\"options\" key=\"qos_min_rate\">\n          If set, indicates the minimum guaranteed rate available for data sent\n          from this interface, in bit/s.\n        </column>\n\n        <column name=\"options\" key=\"qos_max_rate\">\n          If set, indicates the maximum rate for data sent from this interface,\n          in bit/s. The traffic will be shaped according to this limit.\n        </column>\n\n        <column name=\"options\" key=\"qos_burst\">\n          If set, indicates the maximum burst size for data sent from this\n          interface, in bits.\n        </column>\n\n        <column name=\"options\" key=\"hostname\">\n          <p>\n            If set, indicates the DHCPv4 option \"Hostname\" (option code 12)\n            associated for this Logical Switch Port. If DHCPv4 is enabled for\n            this Logical Switch Port, hostname dhcp option will be included in\n            DHCP reply.\n          </p>\n        </column>\n\n        <group title=\"VIF Plugging Options\">\n          <column name=\"options\" key=\"vif-plug-type\">\n            If set, OVN will attempt to perform plugging of this VIF.  In order\n            to get this port plugged by the OVN controller, OVN must be built\n            with support for VIF plugging.  The default behavior is for the CMS\n            to do the VIF plugging.  Each VIF plug provider have their own\n            options namespaced by name, for example \"vif-plug:representor:key\".\n\n            Please refer to the VIF plug provider documentation located in\n            Documentation/topics/vif-plug-providers/ for more information.\n          </column>\n\n          <column name=\"options\" key=\"vif-plug-mtu-request\">\n            Requested MTU for plugged interfaces.  When set the OVN controller\n            will fill the <ref table=\"Interface\" column=\"mtu_request\"/> column\n            of the Open vSwitch database's\n            <ref table=\"Interface\" db=\"vswitch\"/> table.  This in turn will\n            make OVS vswitchd update the MTU of the linked interface.\n          </column>\n        </group>\n      </group>\n\n      <group title=\"Virtual port Options\">\n        <p>\n          These options apply when <ref column=\"type\"/> is\n          <code>virtual</code>.\n        </p>\n\n        <column name=\"options\" key=\"virtual-ip\">\n          This option represents the virtual IPv4 address.\n        </column>\n\n        <column name=\"options\" key=\"virtual-parents\">\n          This options represents a set of logical port names (with in the same\n          logical switch) which can own the <code>virtual ip</code> configured\n          in the <ref column=\"options:virtual-ip\"/>. All these virtual parents\n          should add the <code>virtual ip</code> in the\n          <ref column=\"port_security\"/> if port security addressed are enabled.\n        </column>\n      </group>\n\n      <group title=\"IP Multicast Snooping Options\">\n        <p>\n          These options apply when the port is part of a logical switch\n          which has <ref table=\"Logical_Switch\" column=\"other_config\"/>\n          :mcast_snoop set to <code>true</code>.\n        </p>\n\n        <column name=\"options\" key=\"mcast_flood\"\n                type='{\"type\": \"boolean\"}'>\n          If set to <code>true</code>, multicast packets (except reports) are\n          unconditionally forwarded to the specific port.\n          Default: <code>false</code>.\n        </column>\n\n        <column name=\"options\" key=\"mcast_flood_reports\"\n                type='{\"type\": \"boolean\"}'>\n          If set to <code>true</code>, multicast reports are unconditionally\n          forwarded to the specific port.  Default: <code>false</code>.\n        </column>\n      </group>\n\n    </group>\n\n    <group title=\"Containers\">\n      <p>\n        When a large number of containers are nested within a VM, it may be too\n        expensive to dedicate a VIF to each container.  OVN can use VLAN tags\n        to support such cases.  Each container is assigned a VLAN ID and each\n        packet that passes between the hypervisor and the VM is tagged with the\n        appropriate ID for the container.  Such VLAN IDs never appear on a\n        physical wire, even inside a tunnel, so they need not be unique except\n        relative to a single VM on a hypervisor.\n      </p>\n\n      <p>\n        These columns are used for VIFs that represent nested containers using\n        shared VIFs.  For VMs and for containers that have dedicated VIFs, they\n        are empty.\n      </p>\n\n      <column name=\"parent_name\">\n        The VM interface through which the nested container sends its network\n        traffic.  This must match the <ref column=\"name\"/> column for some\n        other <ref table=\"Logical_Switch_Port\"/>.\n      </column>\n\n      <column name=\"tag_request\">\n        <p>\n          The VLAN tag in the network traffic associated with a container's\n          network interface.  The client can request <code>ovn-northd</code>\n          to allocate a tag that is unique within the scope of a specific\n          parent (specified in <ref column=\"parent_name\"/>) by setting a value\n          of <code>0</code> in this column.  The allocated value is written\n          by <code>ovn-northd</code> in the <ref column=\"tag\"/> column.\n          (Note that these tags are allocated and managed locally in\n          <code>ovn-northd</code>, so they cannot be reconstructed in the event\n          that the database is lost.)  The client can also request a specific\n          non-zero tag and <code>ovn-northd</code> will honor it and copy that\n          value to the <ref column=\"tag\"/> column.\n        </p>\n\n        <p>\n          When <ref column=\"type\"/> is set to <code>localnet</code> or\n          <code>l2gateway</code>, this can\n          be set to indicate that the port represents a connection to a\n          specific VLAN on a locally accessible network. The VLAN ID is used\n          to match incoming traffic and is also added to outgoing traffic.\n        </p>\n      </column>\n\n      <column name=\"tag\">\n        <p>\n          The VLAN tag allocated by <code>ovn-northd</code> based on the\n          contents of the <ref column=\"tag_request\"/> column.\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Port State\">\n      <column name=\"up\">\n        <p>\n          This column is populated by <code>ovn-northd</code>, rather\n          than by the CMS plugin as is most of this database.  When a\n          logical port is bound to a physical location in the OVN\n          Southbound database <ref db=\"OVN_Southbound\"\n          table=\"Binding\"/> table, <code>ovn-northd</code> sets this\n          column to <code>true</code>; otherwise, or if the port\n          becomes unbound later, it sets it to <code>false</code>.\n          If this column is empty, the port is not considered up.\n          This allows the CMS to wait for a VM's (or container's)\n          networking to become active before it allows the VM (or\n          container) to start.\n        </p>\n\n        <p>\n          Logical ports of router type are an exception to this rule.\n          They are considered to be always up, that is this column is\n          always set to <code>true</code>.\n        </p>\n      </column>\n\n      <column name=\"enabled\">\n        This column is used to administratively set port state.  If this column\n        is empty or is set to <code>true</code>, the port is enabled.  If this\n        column is set to <code>false</code>, the port is disabled.  A disabled\n        port has all ingress and egress traffic dropped.\n      </column>\n\n    </group>\n\n    <group title=\"Addressing\">\n      <column name=\"addresses\">\n        <p>\n          Addresses owned by the logical port.\n        </p>\n\n        <p>\n          Each element in the set must take one of the following forms:\n        </p>\n\n        <dl>\n          <dt><code>Ethernet address followed by zero or more IPv4 or IPv6 addresses (or both)</code></dt>\n          <dd>\n            <p>\n              An Ethernet address defined is owned by the logical port.\n              Like a physical Ethernet NIC, a logical port ordinarily has\n              a single fixed Ethernet address.\n            </p>\n\n            <p>\n              When a OVN logical switch processes a unicast Ethernet frame\n              whose destination MAC address is in a logical port's <ref\n              column=\"addresses\"/> column, it delivers it only to that port, as\n              if a MAC learning process had learned that MAC address on the\n              port.\n            </p>\n\n            <p>\n              If IPv4 or IPv6 address(es) (or both) are defined, it indicates\n              that the logical port owns the given IP addresses.\n            </p>\n\n            <p>\n              If IPv4 address(es) are defined, the OVN logical switch uses this\n              information to synthesize responses to ARP requests without\n              traversing the physical network. The OVN logical router connected\n              to the logical switch, if any, uses this information to avoid\n              issuing ARP requests for logical switch ports.\n            </p>\n\n            <p>\n              Note that the order here is important. The Ethernet address must\n              be listed before the IP address(es) if defined.\n            </p>\n\n            <p>\n              Examples:\n            </p>\n\n            <dl>\n              <dt><code>80:fa:5b:06:72:b7</code></dt>\n              <dd>\n                This indicates that the logical port owns the above mac address.\n              </dd>\n\n              <dt><code>80:fa:5b:06:72:b7 10.0.0.4 20.0.0.4</code></dt>\n              <dd>\n                This indicates that the logical port owns the mac address and two\n                IPv4 addresses.\n              </dd>\n\n              <dt><code>80:fa:5b:06:72:b7 fdaa:15f2:72cf:0:f816:3eff:fe20:3f41</code></dt>\n              <dd>\n                This indicates that the logical port owns the mac address and\n                1 IPv6 address.\n              </dd>\n\n              <dt><code>80:fa:5b:06:72:b7 10.0.0.4 fdaa:15f2:72cf:0:f816:3eff:fe20:3f41</code></dt>\n              <dd>\n                This indicates that the logical port owns the mac address and\n                1 IPv4 address and 1 IPv6 address.\n              </dd>\n            </dl>\n          </dd>\n\n          <dt><code>unknown</code></dt>\n          <dd>\n            This indicates that the logical port has an unknown set of Ethernet\n            addresses.  When an OVN logical switch processes a unicast Ethernet\n            frame whose destination MAC address is not in any logical port's\n            <ref column=\"addresses\"/> column, it delivers it to the port (or\n            ports) whose <ref column=\"addresses\"/> columns include\n            <code>unknown</code>.\n          </dd>\n\n          <dt><code>dynamic</code></dt>\n          <dd>\n            <p>\n              Use <code>dynamic</code> to make <code>ovn-northd</code> generate\n              a globally unique MAC address, choose an unused IPv4 address with\n              the logical port's subnet (if <ref table=\"Logical_Switch\"\n              column=\"other_config\" key=\"subnet\"/> is set in the port's <ref\n              table=\"Logical_Switch\"/>), and generate an IPv6 address from the\n              MAC address (if <ref table=\"Logical_Switch\" column=\"other_config\"\n              key=\"ipv6_prefix\"/> is set in the port's <ref\n              table=\"Logical_Switch\"/>) and store them in the port's <ref\n              column=\"dynamic_addresses\"/> column.\n            </p>\n\n            <p>\n              Only one element containing <code>dynamic</code> may appear in\n              <ref column=\"addresses\"/>.\n            </p>\n          </dd>\n\n          <dt><code>dynamic</code> <var>ip</var></dt>\n          <dt><code>dynamic</code> <var>ipv6</var></dt>\n          <dt><code>dynamic</code> <var>ip</var> <var>ipv6</var></dt>\n          <dd>\n            These act like <code>dynamic</code> alone but specify particular\n            IPv4 or IPv6 addresses to use.  OVN IPAM will still automatically\n            allocate the other address if configured appropriately.  Example:\n            <code>dynamic 192.168.0.1 2001::1</code>.\n          </dd>\n\n          <dt><var>mac</var> <code>dynamic</code></dt>\n          <dd>\n            This acts like <code>dynamic</code> alone but specifies a\n            particular MAC address to use.  OVN IPAM will still automatically\n            allocate IPv4 or IPv6 addresses, or both, if configured\n            appropriately.  Example: <code>80:fa:5b:06:72:b7 dynamic</code>\n          </dd>\n\n          <dt><code>router</code></dt>\n          <dd>\n            <p>\n              Accepted only when <ref column=\"type\"/> is <code>router</code>.\n              This indicates that the Ethernet, IPv4, and IPv6 addresses for\n              this logical switch port should be obtained from the connected\n              logical router port, as specified by <code>router-port</code> in\n              <ref column=\"options\"/>.\n            </p>\n\n            <p>\n              The resulting addresses are used to populate the logical\n              switch's destination lookup, and also for the logical switch\n              to generate ARP and ND replies.\n            </p>\n\n            <p>\n              If the connected logical router port has a\n              distributed gateway port specified and the logical router\n              has rules specified in <ref column=\"nat\" table=\"Logical_Router\"/>\n              with <ref column=\"external_mac\" table=\"NAT\"/>, then those\n              addresses are also used to populate the switch's destination\n              lookup.\n            </p>\n\n            <p>\n              Supported only in OVN 2.7 and later.  Earlier versions required\n              router addresses to be manually synchronized.\n            </p>\n          </dd>\n\n        </dl>\n      </column>\n\n      <column name=\"dynamic_addresses\">\n        <p>\n          Addresses assigned to the logical port by <code>ovn-northd</code>, if\n          <code>dynamic</code> is specified in <ref column=\"addresses\"/>.\n          Addresses will be of the same format as those that populate the <ref\n          column=\"addresses\"/> column.  Note that dynamically assigned\n          addresses are constructed and managed locally in ovn-northd, so they\n          cannot be reconstructed in the event that the database is lost.\n        </p>\n      </column>\n\n      <column name=\"port_security\">\n        <p>\n          This column controls the addresses from which the host attached to the\n          logical port (``the host'') is allowed to send packets and to which it\n          is allowed to receive packets.  If this column is empty, all addresses\n          are permitted.\n        </p>\n\n        <p>\n          Each element in the set must begin with one Ethernet address.\n          This would restrict the host to sending packets from and receiving\n          packets to the ethernet addresses defined in the logical port's\n          <ref column=\"port_security\"/> column. It also restricts the inner\n          source MAC addresses that the host may send in ARP and IPv6\n          Neighbor Discovery packets. The host is always allowed to receive packets\n          to multicast and broadcast Ethernet addresses.\n        </p>\n\n        <p>\n          Each element in the set may additionally contain one or more IPv4 or\n          IPv6 addresses (or both), with optional masks.  If a mask is given, it\n          must be a CIDR mask.  In addition to the restrictions described for\n          Ethernet addresses above, such an element restricts the IPv4 or IPv6\n          addresses from which the host may send and to which it may receive\n          packets to the specified addresses.  A masked address, if the host part\n          is zero, indicates that the host is allowed to use any address in the\n          subnet; if the host part is nonzero, the mask simply indicates the size\n          of the subnet. In addition:\n        </p>\n\n        <ul>\n          <li>\n            <p>\n              If any IPv4 address is given, the host is also allowed to receive\n              packets to the IPv4 local broadcast address 255.255.255.255 and to\n              IPv4 multicast addresses (224.0.0.0/4).  If an IPv4 address with a\n              mask is given, the host is also allowed to receive packets to the\n              broadcast address in that specified subnet.\n            </p>\n\n            <p>\n              If any IPv4 address is given, the host is additionally restricted\n              to sending ARP packets with the specified source IPv4 address.\n              (RARP is not restricted.)\n            </p>\n          </li>\n\n          <li>\n            <p>\n              If any IPv6 address is given, the host is also allowed to receive\n              packets to IPv6 multicast addresses (ff00::/8).\n            </p>\n\n            <p>\n              If any IPv6 address is given, the host is additionally restricted\n              to sending IPv6 Neighbor Discovery Solicitation or Advertisement\n              packets with the specified source address or, for solicitations,\n              the unspecified address.\n            </p>\n          </li>\n        </ul>\n\n        <p>\n          If an element includes an IPv4 address, but no IPv6 addresses, then\n          IPv6 traffic is not allowed.  If an element includes an IPv6 address,\n          but no IPv4 address, then IPv4 and ARP traffic is not allowed.\n        </p>\n\n        <p>\n          This column uses the same lexical syntax as the <ref column=\"match\"\n          table=\"Pipeline\" db=\"OVN_Southbound\"/> column in the OVN Southbound\n          database's <ref table=\"Pipeline\" db=\"OVN_Southbound\"/> table.  Multiple\n          addresses within an element may be space or comma separated.\n        </p>\n\n        <p>\n          This column is provided as a convenience to cloud management systems,\n          but all of the features that it implements can be implemented as ACLs\n          using the <ref table=\"ACL\"/> table.\n        </p>\n\n        <p>\n          Examples:\n        </p>\n\n        <dl>\n          <dt><code>80:fa:5b:06:72:b7</code></dt>\n          <dd>\n            The host may send traffic from and receive traffic to the specified\n            MAC address, and to receive traffic to Ethernet multicast and\n            broadcast addresses, but not otherwise.  The host may not send ARP or\n            IPv6 Neighbor Discovery packets with inner source Ethernet addresses\n            other than the one specified.\n          </dd>\n\n          <dt><code>80:fa:5b:06:72:b7 192.168.1.10/24</code></dt>\n          <dd>\n            This adds further restrictions to the first example.  The host may\n            send IPv4 packets from or receive IPv4 packets to only 192.168.1.10,\n            except that it may also receive IPv4 packets to 192.168.1.255 (based\n            on the subnet mask), 255.255.255.255, and any address in 224.0.0.0/4.\n            The host may not send ARPs with a source Ethernet address other than\n            80:fa:5b:06:72:b7 or source IPv4 address other than 192.168.1.10.\n            The host may not send or receive any IPv6 (including IPv6 Neighbor\n            Discovery) traffic.\n          </dd>\n\n          <dt><code>\"80:fa:5b:12:42:ba\", \"80:fa:5b:06:72:b7 192.168.1.10/24\"</code></dt>\n          <dd>\n            The host may send traffic from and receive traffic to the\n            specified MAC addresses, and\n            to receive traffic to Ethernet multicast and broadcast addresses,\n            but not otherwise.   With MAC 80:fa:5b:12:42:ba, the host may\n            send traffic from and receive traffic to any L3 address.\n            With MAC 80:fa:5b:06:72:b7, the host may send IPv4 packets from or\n            receive IPv4 packets to only 192.168.1.10, except that it may also\n            receive IPv4 packets to 192.168.1.255 (based on the subnet mask),\n            255.255.255.255, and any address in 224.0.0.0/4.  The host may not\n            send or receive any IPv6 (including IPv6 Neighbor Discovery) traffic.\n          </dd>\n        </dl>\n      </column>\n    </group>\n\n    <group title=\"DHCP\">\n      <column name=\"dhcpv4_options\">\n        This column defines the DHCPv4 Options to be included by the\n        <code>ovn-controller</code> when it replies to the DHCPv4 requests.\n        Please see the <ref table=\"DHCP_Options\"/> table.\n      </column>\n\n      <column name=\"dhcpv6_options\">\n        This column defines the DHCPv6 Options to be included by the\n        <code>ovn-controller</code> when it replies to the DHCPv6 requests.\n        Please see the <ref table=\"DHCP_Options\"/> table.\n      </column>\n    </group>\n\n    <column name=\"mirror_rules\">\n        Mirror rules that apply to logical switch port which is the source.\n        Please see the <ref table=\"Mirror\"/> table.\n    </column>\n\n    <column name=\"ha_chassis_group\">\n      References a row in the OVN Northbound database's\n      <ref table=\"HA_Chassis_Group\" db=\"OVN_Northbound\"/> table.\n      It indicates the HA chassis group to use if the\n      <ref column=\"type\"/> is set to <code>external</code>.\n      If <ref column=\"type\"/> is not <code>external</code>, this\n      column is ignored.\n    </column>\n\n    <group title=\"Naming\">\n      <column name=\"external_ids\" key=\"neutron:port_name\">\n        <p>\n          This column gives an optional human-friendly name for the port.  This\n          name has no special meaning or purpose other than to provide\n          convenience for human interaction with the northbound database.\n        </p>\n\n        <p>\n          Neutron copies this from its own port object's name.  (Neutron ports\n          do are not assigned human-friendly names by default, so it will often\n          be empty.)\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Tunnel Key\">\n      <column name=\"options\" key=\"requested-tnl-key\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 32767}'>\n        Configures the port binding tunnel key for the port.  Usually\n        this is not needed because <code>ovn-northd</code> will assign an\n        unique key for each port by itself.  However, if it is configured,\n        <code>ovn-northd</code> honors the configured value.  The typical use\n        case is for interconnection: the tunnel keys for ports on transit\n        switches need to be unique globally, so they are maintained in the\n        global <ref db=\"OVN_IC_Southbound\"/> database, and <code>ovn-ic</code>\n        simply syncs the value from <ref db=\"OVN_IC_Southbound\"/> through this\n        config.\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        <p>\n          See <em>External IDs</em> at the beginning of this document.\n        </p>\n\n        <p>\n          The <code>ovn-northd</code> program copies all these pairs into the\n          <ref column=\"external_ids\"/> column of the\n          <ref table=\"Port_Binding\"/> table in <ref db=\"OVN_Southbound\"/>\n          database.\n        </p>\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Forwarding_Group\" title=\"forwarding group\">\n    <p>\n      Each row represents one forwarding group.\n    </p>\n\n    <column name=\"name\">\n      A name for the forwarding group.  This name has no special meaning or\n      purpose other than to provide convenience for human interaction with\n      the ovn-nb database.\n    </column>\n\n    <column name=\"vip\">\n      The virtual IP address assigned to the forwarding group. It will respond\n      with vmac when an ARP request is sent for vip.\n    </column>\n\n    <column name=\"vmac\">\n      The virtual MAC address assigned to the forwarding group.\n    </column>\n\n    <column name=\"liveness\">\n      If set to <code>true</code>, liveness is enabled for child ports\n      otherwise it is disabled.\n    </column>\n\n    <column name=\"child_port\">\n      List of child ports in the forwarding group.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Address_Set\" title=\"Address Sets\">\n    <p>\n      Each row in this table represents a named set of addresses.\n      An address set may contain Ethernet, IPv4, or IPv6 addresses\n      with optional bitwise or CIDR masks.\n      Address set may ultimately be used in ACLs to compare against\n      fields such as <code>ip4.src</code> or <code>ip6.src</code>.\n      A single address set must contain addresses of the\n      same type. As an example, the following would create an address set\n      with three IP addresses:\n    </p>\n\n    <pre>\n      ovn-nbctl create Address_Set name=set1 addresses='10.0.0.1 10.0.0.2 10.0.0.3'\n    </pre>\n\n    <p>\n      Address sets may be used in the <ref column=\"match\" table=\"ACL\"/> column\n      of the <ref table=\"ACL\"/> table.  For syntax information, see the details\n      of the expression language used for the <ref column=\"match\"\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> column in the <ref\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table of the <ref\n      db=\"OVN_Southbound\"/> database.\n    </p>\n\n    <column name=\"name\">\n      A name for the address set.  Names are ASCII and must match\n      <code>[a-zA-Z_.][a-zA-Z_.0-9]*</code>.\n    </column>\n\n    <column name=\"addresses\">\n      The set of addresses in string form.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Port_Group\" title=\"Port Groups\">\n    <p>\n      Each row in this table represents a named group of logical switch ports.\n    </p>\n\n    <p>\n      Port groups may be used in the <ref column=\"match\" table=\"ACL\"/> column\n      of the <ref table=\"ACL\"/> table.  For syntax information, see the details\n      of the expression language used for the <ref column=\"match\"\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> column in the <ref\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table of the <ref\n      db=\"OVN_Southbound\"/> database.\n    </p>\n\n    <p>\n      For each port group, there are two address sets generated to the\n      <ref table=\"Address_Set\" db=\"OVN_Southbound\"/> table of the\n      <ref db=\"OVN_Southbound\"/> database, containing the IP addresses\n      of the group of ports, one for IPv4, and the other for IPv6, with\n      <ref column=\"name\" table=\"Address_Set\" db=\"OVN_Southbound\"/> being\n      the <ref column=\"name\" table=\"Port_Group\" db=\"OVN_Northbound\"/>\n      of the <ref table=\"Port_Group\" db=\"OVN_Northbound\"/> followed by\n      a suffix <code>_ip4</code> for IPv4 and <code>_ip6</code> for IPv6.\n      The generated address sets can be used in the same way as regular\n      address sets in the <ref column=\"match\" table=\"ACL\"/> column\n      of the <ref table=\"ACL\"/> table. For syntax information, see the details\n      of the expression language used for the <ref column=\"match\"\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> column in the <ref\n      table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table of the <ref\n      db=\"OVN_Southbound\"/> database.\n    </p>\n\n    <column name=\"name\">\n      A name for the port group.  Names are ASCII and must match\n      <code>[a-zA-Z_.][a-zA-Z_.0-9]*</code>.\n    </column>\n\n    <column name=\"ports\">\n      The logical switch ports belonging to the group in uuids.\n    </column>\n\n    <column name=\"acls\">\n      Access control rules that apply to the port group. Applying an ACL\n      to a port group has the same effect as applying the ACL to all logical\n      lswitches that the ports of the port group belong to.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Load_Balancer\" title=\"load balancer\">\n    <p>\n      Each row represents one load balancer.\n    </p>\n\n    <column name=\"name\">\n      A name for the load balancer.  This name has no special meaning or\n      purpose other than to provide convenience for human interaction with\n      the ovn-nb database.\n    </column>\n\n    <column name=\"vips\">\n      <p>\n        A map of virtual IP addresses (and an optional port number with\n        <code>:</code> as a separator) associated with this load balancer and\n        their corresponding endpoint IP addresses (and optional port numbers\n        with <code>:</code> as separators) separated by commas.  If\n        the destination IP address (and port number) of a packet leaving a\n        container or a VM matches the virtual IP address (and port number)\n        provided here as a key, then OVN will statefully replace the\n        destination IP address by one of the provided IP address (and port\n        number) in this map as a value.  IPv4 and IPv6 addresses are supported\n        for load balancing; however a VIP of one address family may not be\n        mapped to a destination IP address of a different family.  If\n        specifying an IPv6 address with a port, the address portion must be\n        enclosed in square brackets.  Examples for keys are \"192.168.1.4\" and\n        \"[fd0f::1]:8800\".  Examples for value are \"10.0.0.1, 10.0.0.2\" and\n        \"20.0.0.10:8800, 20.0.0.11:8800\".\n      </p>\n      <p>\n        When the <code>Load_Balancer</code> is added to the\n        <code>logical_switch</code>, the VIP has to be in a different subnet\n        than the one used for the <code>logical_switch</code>.  Since VIP is\n        in a different subnet, you should connect your logical switch to\n        either a OVN logical router or a real router (this is because the\n        client can now send a packet with VIP as the destination IP address\n        and router's mac address as the destination MAC address).\n      </p>\n    </column>\n\n    <column name=\"protocol\">\n      <p>\n        Valid protocols are <code>tcp</code>, <code>udp</code>, or\n        <code>sctp</code>.  This column is useful when a port number is\n        provided as part of the <code>vips</code> column.  If this column is\n        empty and a port number is provided as part of <code>vips</code>\n        column, OVN assumes the protocol to be <code>tcp</code>.\n      </p>\n    </column>\n\n    <group title=\"Health Checks\">\n      <p>\n        OVN supports health checks for load balancer endpoints. When health\n        checks are enabled, the load balancer uses only healthy endpoints.\n      </p>\n\n      <p>\n        Suppose that <ref column=\"vips\"/> contains a key-value pair\n        <code>10.0.0.10:80</code>=<code>10.0.0.4:8080,20.0.0.4:8080</code>.  To\n        enable health checks for this virtual's endpoints, add two key-value\n        pairs to <ref column=\"ip_port_mappings\"/>, with keys\n        <code>10.0.0.4</code> and <code>20.0.0.4</code>, and add to <ref\n        column=\"health_check\"/> a reference to a <ref\n        table=\"Load_Balancer_Health_Check\"/> row whose <ref\n        table=\"Load_Balancer_Health_Check\" column=\"vip\"/> is set to\n        <code>10.0.0.10</code>. The same approach can be used for IPv6 as well.\n      </p>\n\n      <column name=\"health_check\">\n        Load balancer health checks associated with this load balancer.\n      </column>\n\n      <column name=\"ip_port_mappings\">\n        <p>\n          Maps from endpoint IP to a colon-separated pair of logical port name\n          and source IP,\n          e.g. <code><var>port_name</var>:<var>sourc_ip</var></code> for IPv4.\n          Health checks are sent to this port with the specified source IP.\n          For IPv6 square brackets must be used around IP address, e.g:\n          <code><var>port_name</var>:<var>[sourc_ip]</var></code>\n        </p>\n\n        <p>\n          For example, in the example above, IP to port mappings might be\n          defined as <code>10.0.0.4</code>=<code>sw0-p1:10.0.0.2</code> and\n          <code>20.0.0.4</code>=<code>sw1-p1:20.0.0.2</code>, if the values\n          given were suitable ports and IP addresses.\n        </p>\n\n        <p>\n          For IPv6 IP to port mappings might be defined as\n          <code>[2001::1]</code>=<code>sw0-p1:[2002::1]</code>.\n        </p>\n      </column>\n    </group>\n\n    <column name=\"selection_fields\">\n      <p>\n        OVN native load balancers are supported using the OpenFlow groups\n        of type <code>select</code>. OVS supports two selection methods:\n        <code>dp_hash</code> and <code>hash (with optional fields\n        specified)</code> in selecting the buckets of a group.\n        Please see the OVS documentation (man ovs-ofctl)\n        for more details on the selection methods. Each endpoint IP (and port\n        if set) is mapped to a bucket in the group flow.\n      </p>\n\n      <p>\n        CMS can choose the <code>hash</code> selection method by setting the\n        selection fields in this column. <code>ovs-vswitchd</code> uses the\n        specified fields in generating the hash.\n      </p>\n\n      <p>\n        <code>dp_hash</code> selection method uses the assistance of\n        datapath to calculate the hash and it is expected to be\n        faster than <code>hash</code> selection method. So CMS should take\n        this into consideration before using the <code>hash</code> method.\n        Please consult the OVS documentation and OVS sources for the\n        implementation details.\n      </p>\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n    <group title=\"Load_Balancer options\">\n      <column name=\"options\" key=\"reject\" type='{\"type\": \"boolean\"}'>\n        If the load balancer is created with <code>--reject</code> option and\n        it has no active backends, a TCP reset segment (for tcp) or an ICMP\n        port unreachable packet (for all other kind of traffic) will be sent\n        whenever an incoming packet is received for this load-balancer.\n        Please note using <code>--reject</code> option will disable empty_lb\n        SB controller event for this load balancer.\n      </column>\n\n      <column name=\"options\" key=\"hairpin_snat_ip\">\n        IP to be used as source IP for packets that have been hair-pinned\n        after load balancing.  The default behavior when the option is not set\n        is to use the load balancer VIP as source IP.  This option may have\n        exactly one IPv4 and/or one IPv6 address on it, separated by a space\n        character.\n      </column>\n\n      <column name=\"options\" key=\"skip_snat\">\n        If the load balancing rule is configured with <code>skip_snat</code>\n        option, the option lb_force_snat_ip configured for the logical router\n        that references this load balancer will not be applied for this load\n        balancer.\n      </column>\n\n      <column name=\"options\" key=\"add_route\">\n        If set to <code>true</code>, then neighbor routers will have logical\n        flows added that will allow for routing to the VIP IP. It also will\n        have ARP resolution logical flows added. By setting this option, it\n        means there is no reason to create a\n        <ref table=\"Logical_Router_Static_Route\"/> from neighbor routers to\n        this NAT address. It also means that no ARP request is required for\n        neighbor routers to learn the IP-MAC mapping for this VIP IP. For\n        more information about what flows are added for IP routes, please\n        see the <code>ovn-northd</code> manpage section on IP Routing.\n      </column>\n\n      <column name=\"options\" key=\"neighbor_responder\">\n        If set to <code>all</code>, then routers on which the load balancer\n        is applied reply to ARP/neighbor discovery requests for all VIPs\n        of the load balancer.  If set to <code>reachable</code>, then routers\n        on which the load balancer is applied reply to ARP/neighbor discovery\n        requests only for VIPs that are part of a router's subnet.  If set to\n        <code>none</code>, then routers on which the load balancer is applied\n        never reply to ARP/neighbor discovery requests for any of the load\n        balancer VIPs. Load balancers with <code>options:template=true</code>\n        do not support <code>reachable</code> as a valid mode.  The default\n        value of this option, if not specified, is <code>reachable</code> for\n        regular load balancers and <code>none</code> for template load\n        balancers.\n      </column>\n\n      <column name=\"options\" key=\"template\">\n        <p>\n          Option to be set to <code>true</code>, if the load balancer is a\n          template.  The load balancer VIPs and backends must be using\n          <ref table=\"Chassis_Template_Var\"/> in their definitions.\n        </p>\n\n        <p>\n          Load balancer template VIP supported formats are:\n        </p>\n        <pre>\n^VIP_VAR[:^PORT_VAR|:port]\n        </pre>\n\n        <p>\n          where <code>VIP_VAR</code> and <code>PORT_VAR</code> are keys of\n          the <ref table=\"Chassis_Template_Var\"/> <ref column=\"variables\"/>\n          records.\n        </p>\n\n        <p>\n          Note: The VIP and PORT cannot be combined into a single template\n          variable. For example, a <ref table=\"Chassis_Template_Var\"/>\n          variable expanding to <code>10.0.0.1:8080</code> is not valid\n          if used as VIP.\n        </p>\n\n        <p>\n          Load balancer template backend supported formats are:\n        </p>\n        <pre>\n^BACKEND_VAR1[:^PORT_VAR1|:port],^BACKEND_VAR2[:^PORT_VAR2|:port]\n\nor\n\n^BACKENDS_VAR1,^BACKENDS_VAR2\n        </pre>\n        <p>\n          where <code>BACKEND_VAR1</code>, <code>PORT_VAR1</code>,\n          <code>BACKEND_VAR2</code>, <code>PORT_VAR2</code>,\n          <code>BACKENDS_VAR1</code> and <code>BACKENDS_VAR2</code> are keys\n          of the <ref table=\"Chassis_Template_Var\"/> <ref column=\"variables\"/>\n          records.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"address-family\">\n        Address family used by the load balancer.  Supported values are\n        <code>ipv4</code> and <code>ipv6</code>.  The address-family is\n        only used for load balancers with <code>options:template=true</code>.\n        For explicit load balancers, setting the address-family has no\n        effect.\n      </column>\n\n      <column name=\"options\" key=\"affinity_timeout\">\n        If the CMS provides a positive value (in seconds) for\n        <code>affinity_timeout</code>, OVN will dnat connections received\n        from the same client to this lb to the same backend if received in\n        the affinity timeslot. Max supported affinity_timeout is 65535\n        seconds.\n      </column>\n\n      <column name=\"options\" key=\"ct_flush\" type='{\"type\": \"boolean\"}'>\n        The value indicates whether ovn-controller should flush CT entries\n        that are related to this LB. The flush happens if the LB is removed,\n        any of the backends is updated/removed or the LB is not considered\n        local anymore by the ovn-controller. This option is set to\n        <code>false</code> by default.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Load_Balancer_Group\" title=\"load balancer group\">\n    <p>\n      Each row represents a logical grouping of load balancers.  It is up to\n      the CMS to decide the criteria on which load balancers are grouped\n      together.  To simplify configuration and to optimize its processing\n      load balancers that must be associated to the same set of logical\n      switches and/or logical routers should be grouped together.\n    </p>\n\n    <column name=\"name\">\n      A name for the load balancer group.  This name has no special meaning or\n      purpose other than to provide convenience for human interaction with\n      the ovn-nb database.\n    </column>\n\n    <column name=\"load_balancer\">\n      A set of load balancers.\n    </column>\n  </table>\n\n  <table name=\"Load_Balancer_Health_Check\" title=\"load balancer\">\n    <p>\n      Each row represents one load balancer health check.\n    </p>\n\n    <column name=\"vip\">\n      <code>vip</code> whose endpoints should be monitored for health check.\n    </column>\n\n    <group title=\"Health check options\">\n      <column name=\"options\" key=\"interval\" type='{\"type\": \"integer\"}'>\n        The interval, in seconds, between health checks.\n      </column>\n\n      <column name=\"options\" key=\"timeout\" type='{\"type\": \"integer\"}'>\n        The time, in seconds, after which a health check times out.\n      </column>\n\n      <column name=\"options\" key=\"success_count\" type='{\"type\": \"integer\"}'>\n        The number of successful checks after which the endpoint is\n        considered online.\n      </column>\n\n      <column name=\"options\" key=\"failure_count\" type='{\"type\": \"integer\"}'>\n        The number of failure checks after which the endpoint is considered\n        offline.\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"ACL\" title=\"Access Control List (ACL) rule\">\n    <p>\n      Each row in this table represents one ACL rule for a logical switch\n      or a port group that points to it through its <ref column=\"acls\"/>\n      column.  The <ref column=\"action\"/> column for the\n      highest-<ref column=\"priority\"/> matching row in this table determines a\n      packet's treatment.  If no row matches, packets are allowed by default.\n      (Default-deny treatment is possible: add a rule with\n      <ref column=\"priority\"/> 0, <code>1</code> as <ref column=\"match\"/>,\n      and <code>deny</code> as <ref column=\"action\"/>.)\n    </p>\n\n    <column name=\"label\">\n      <p>\n        Associates an identifier with the ACL.\n        The same value will be written to corresponding connection\n        tracker entry. The value should be a valid 32-bit unsigned integer.\n        This value can help in debugging from connection tracker side.\n        For example, through this \"label\" we can backtrack to the ACL rule\n        which is causing a \"leaked\" connection. Connection tracker entries are\n        created only for allowed connections so the label is valid only\n        for allow and allow-related actions.\n      </p>\n    </column>\n    <column name=\"priority\">\n      <p>\n        The ACL rule's priority.  Rules with numerically higher priority\n        take precedence over those with lower.  If two ACL rules with\n        the same priority both match, then the one actually applied to a\n        packet is undefined.\n      </p>\n\n      <p>\n        Return traffic from an <code>allow-related</code> flow is always\n        allowed and cannot be changed through an ACL.\n      </p>\n\n      <p>\n        <code>allow-stateless</code> flows always take precedence before\n        stateful ACLs, regardless of their priority. (Both\n        <code>allow</code> and <code>allow-related</code> ACLs can be\n        stateful.)\n      </p>\n    </column>\n\n    <column name=\"direction\">\n      <p>Direction of the traffic to which this rule should apply:</p>\n      <ul>\n        <li>\n          <code>from-lport</code>: Used to implement filters on traffic\n          arriving from a logical port.  These rules are applied to the\n          logical switch's ingress pipeline.\n        </li>\n        <li>\n          <code>to-lport</code>: Used to implement filters on traffic\n          forwarded to a logical port.  These rules are applied to the\n          logical switch's egress pipeline.\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"match\">\n      <p>\n        The packets that the ACL should match, in the same expression\n        language used for the <ref column=\"match\" table=\"Logical_Flow\"\n        db=\"OVN_Southbound\"/> column in the OVN Southbound database's\n        <ref table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table.  The\n        <code>outport</code> logical port is only available in the\n        <code>to-lport</code> direction (the <code>inport</code> is\n        available in both directions).\n      </p>\n\n      <p>\n        By default all traffic is allowed.  When writing a more\n        restrictive policy, it is important to remember to allow flows\n        such as ARP and IPv6 neighbor discovery packets.\n      </p>\n\n      <p>\n        Note that you can not create an ACL matching on a port with\n        type=router or type=localnet.\n      </p>\n    </column>\n\n    <column name=\"action\">\n      <p>The action to take when the ACL rule matches:</p>\n      <ul>\n        <li>\n          <code>allow-stateless</code>: Always forward the packet in stateless\n          manner, omitting connection tracking mechanism, regardless of other\n          rules defined for the switch.  May require defining additional rules\n          for inbound replies.  For example, if you define a rule to allow\n          outgoing TCP traffic directed to an IP address, then you probably\n          also want to define another rule to allow incoming TCP traffic coming\n          from this same IP address.\n          In addition, traffic that matches stateless ACLs will bypass\n          load-balancer DNAT/un-DNAT processing. Stateful ACLs should be\n          used instead if the traffic is supposed to be load-balanced.\n        </li>\n\n        <li>\n          <code>allow</code>: Forward the packet. It will also send the\n          packets through connection tracking when\n          <code>allow-related</code> rules exist on the logical switch.\n          Otherwise, it's equivalent to <code>allow-stateless</code>.\n        </li>\n\n        <li>\n          <code>allow-related</code>: Forward the packet and related traffic\n          (e.g. inbound replies to an outbound connection).\n        </li>\n\n        <li>\n          <code>drop</code>: Silently drop the packet.\n        </li>\n\n        <li>\n          <code>reject</code>: Drop the packet, replying with a RST for TCP or\n          ICMPv4/ICMPv6 unreachable message for other IPv4/IPv6-based\n          protocols.\n        </li>\n      </ul>\n    </column>\n\n    <group title=\"options\">\n      <p>\n        ACLs options.\n      </p>\n      <column name=\"options\" key=\"apply-after-lb\">\n        <p>\n          If set to true, the ACL will be applied after load balancing\n          stage.  Supported only for <code>from-lport</code> direction.\n        </p>\n\n        <p>\n          The main use case of this option is to support ACLs matching on\n          the destination IP address of the packet for the backend IPs\n          of load balancers.\n        </p>\n\n        <p>\n          <code>OVN</code> will apply the <code>from-lport</code> ACLs in two\n          stages.  ACLs without this option <code>apply-after-lb</code>\n          set, will be applied before the load balancer stage and ACLs\n          with this option set will be applied after the load balancer\n          stage.  The priorities are indepedent between these stages and\n          may not be obvious to the CMS.  Hence CMS should be extra careful\n          when using this option and should carefully evaluate the priorities\n          of all the ACLs and the default deny/allow ACLs if any.\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Logging\">\n      <p>\n        These columns control whether and how OVN logs packets that match an\n        ACL.\n      </p>\n\n      <column name=\"log\">\n        <p>\n          If set to <code>true</code>, packets that match the ACL will trigger\n          a log message on the transport node or nodes that perform ACL\n          processing.  Logging may be combined with any <ref column=\"action\"/>.\n        </p>\n\n        <p>\n          If set to <code>false</code>, the remaining columns in this group\n          have no significance.\n        </p>\n      </column>\n\n      <column name=\"name\">\n        <p>\n          This name, if it is provided, is included in log records.  It\n          provides the administrator and the cloud management system a way to\n          associate a log record with a particular ACL.\n        </p>\n      </column>\n\n      <column name=\"severity\">\n        <p>\n          The severity of the ACL.  The severity levels match those of syslog,\n          in decreasing level of severity: <code>alert</code>,\n          <code>warning</code>, <code>notice</code>, <code>info</code>, or\n          <code>debug</code>.  When the column is empty, the default is\n          <code>info</code>.\n        </p>\n      </column>\n\n      <column name=\"meter\">\n        <p>\n            The name of a meter to rate-limit log messages for the ACL.\n            The string must match the <ref column=\"name\" table=\"meter\"/>\n            column of a row in the <ref table=\"Meter\"/> table.  By\n            default, log messages are not rate-limited. In order to ensure\n            that the same <ref table=\"Meter\"/> rate limits multiple ACL logs\n            separately, set the <ref column=\"fair\" table=\"meter\"/> column.\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"options\">\n        This column provides general key/value settings. The supported\n        options are described individually below.\n      </column>\n\n      <group title=\"ACL configuration options\">\n        <column name=\"options\" key=\"log-related\">\n          If set to <code>true</code>, then log when reply or related\n          traffic is admitted from a stateful ACL. In order for this\n          option to function, the <ref column=\"log\"/> option must be\n          set to <code>true</code> and a <ref column=\"label\"/> must\n          be set, and it must be unique to the ACL. The label is necessary\n          as it is the only means to associate the reply traffic with the\n          ACL to which it belongs. It must be unique, because otherwise it\n          is ambiguous which ACL will be matched.\n\n          Note: If this option is enabled, an extra flow is installed in\n          order to log the related traffic. Therefore, if this is enabled\n          on all ACLs, then the total number of flows necessary to log the\n          ACL traffic is doubled, compared to if this option is not enabled.\n        </column>\n      </group>\n\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Logical_Router\" title=\"L3 logical router\">\n    <p>\n      Each row represents one L3 logical router.\n    </p>\n\n    <column name=\"ports\">\n      The router's ports.\n    </column>\n\n    <column name=\"static_routes\">\n      Zero or more static routes for the router.\n    </column>\n\n    <column name=\"policies\">\n      Zero or more routing policies for the router.\n    </column>\n\n    <column name=\"enabled\">\n      This column is used to administratively set router state.  If this column\n      is empty or is set to <code>true</code>, the router is enabled.  If this\n      column is set to <code>false</code>, the router is disabled.  A disabled\n      router has all ingress and egress traffic dropped.\n    </column>\n\n    <column name=\"nat\">\n      One or more NAT rules for the router.  NAT rules only work on\n      Gateway routers, and on distributed routers with one and only one\n      distributed gateway port.\n    </column>\n\n    <column name=\"load_balancer\">\n      Set of load balancers associated to this logical router.  Load balancer\n      Load balancer rules only work on the Gateway routers or routers with one\n      and only one distributed gateway port.\n    </column>\n\n    <column name=\"load_balancer_group\">\n      Set of load balancers groups associated to this logical router.\n    </column>\n\n    <group title=\"Naming\">\n      <p>\n        These columns provide names for the logical router.  From OVN's\n        perspective, these names have no special meaning or purpose other than\n        to provide convenience for human interaction with the northbound\n        database.  There is no requirement for the name to be unique.  (For a\n        unique identifier for a logical router, use its row UUID.)\n      </p>\n\n      <p>\n        (Originally, <ref column=\"name\"/> was intended to serve the purpose of\n        a human-friendly name, but the Neutron integration used it to uniquely\n        identify its own router object, in the format\n        <code>neutron-<var>uuid</var></code>.  Later on, Neutron started\n        propagating the friendly name of a router as <ref column=\"external_ids\"\n        key=\"neutron:router_name\"/>.  Perhaps this can be cleaned up someday.)\n      </p>\n\n      <column name=\"name\">\n        A name for the logical router.\n      </column>\n\n      <column name=\"external_ids\" key=\"neutron:router_name\">\n        Another name for the logical router.\n      </column>\n    </group>\n\n    <column name=\"copp\">\n      <p>\n        The control plane protection policy from table <ref table=\"Copp\"/>\n        used for metering packets sent to <code>ovn-controller</code> from\n        logical ports of this router.\n      </p>\n    </column>\n\n    <group title=\"Options\">\n      <p>\n        Additional options for the logical router.\n      </p>\n\n      <column name=\"options\" key=\"chassis\">\n        <p>\n          If set, indicates that the logical router in question is a Gateway\n          router (which is centralized) and resides in the set chassis.  The\n          same value is also used by <code>ovn-controller</code> to\n          uniquely identify the chassis in the OVN deployment and\n          comes from <code>external_ids:system-id</code> in the\n          <code>Open_vSwitch</code> table of Open_vSwitch database.\n        </p>\n\n        <p>\n          The Gateway router can only be connected to a distributed router\n          via a switch if SNAT and DNAT are to be configured in the Gateway\n          router.\n        </p>\n      </column>\n      <column name=\"options\" key=\"dnat_force_snat_ip\">\n        <p>\n          If set, indicates a set of IP addresses to use to force SNAT a\n          packet that has already been DNATed in the gateway router.  When\n          multiple gateway routers are configured, a packet can potentially\n          enter any of the gateway router, get DNATted and eventually reach the\n          logical switch port.  For the return traffic to go back to the same\n          gateway router (for unDNATing), the packet needs a SNAT in the first\n          place. This can be achieved by setting the above option with a\n          gateway specific set of IP addresses. This option may have exactly\n          one IPv4 and/or one IPv6 address on it, separated by a a space.\n        </p>\n      </column>\n      <column name=\"options\" key=\"lb_force_snat_ip\">\n        <p>\n          If set, this option can take two possible type of values.  Either\n          a set of IP addresses or the string value - <code>router_ip</code>.\n        </p>\n\n        <p>\n          If a set of IP addresses are configured, it indicates to use to\n          force SNAT a packet that has already been load-balanced in the\n          gateway router.  When multiple gateway routers are configured, a\n          packet can potentially enter any of the gateway routers, get\n          DNATted as part of the load-balancing and eventually reach the\n          logical switch port.  For the return traffic to go back to the\n          same gateway router (for unDNATing), the packet needs a SNAT in the\n          first place.  This can be achieved by setting the above option with\n          a gateway specific set of IP addresses. This option may have exactly\n          one IPv4 and/or one IPv6 address on it, separated by a space\n          character.\n        </p>\n\n        <p>\n          If it is configured with the value <code>router_ip</code>, then\n          the load balanced packet is SNATed with the IP of router port\n          (attached to the gateway router) selected as the destination after\n          taking the routing decision.\n        </p>\n      </column>\n      <column name=\"options\" key=\"mcast_relay\" type='{\"type\": \"boolean\"}'>\n        <p>\n          Enables/disables IP multicast relay between logical switches\n          connected to the logical router. Default: False.\n        </p>\n      </column>\n      <column name=\"options\" key=\"dynamic_neigh_routers\" type='{\"type\": \"boolean\"}'>\n        <p>\n          If set to <code>true</code>, the router will resolve neighbor\n          routers' MAC addresses only by dynamic ARP/ND, instead of\n          prepopulating static mappings for all neighbor routers in the ARP/ND\n          Resolution stage.  This reduces number of flows, but requires ARP/ND\n          messages to resolve the IP-MAC bindings when needed.  It is\n          <code>false</code> by default.  It is recommended to set to\n          <code>true</code> when a large number of logical routers are\n          connected to the same logical switch but most of them never need to\n          send traffic between each other. By default, ovn-northd does not\n          create mappings to NAT and load balancer addresess. However, for NAT\n          and load balancer addresses that have the <code>add_route</code>\n          option added, ovn-northd will create logical flows that map NAT and\n          load balancer IP addresses to the appropriate MAC address. Setting\n          <var>dynamic_neigh_routers</var> to <code>true</code> will prevent\n          the automatic creation of these logical flows.\n        </p>\n      </column>\n      <column name=\"options\" key=\"always_learn_from_arp_request\" type='{\"type\": \"boolean\"}'>\n        <p>\n          This option controls the behavior when handling IPv4 ARP requests or\n          IPv6 ND-NS packets - whether a dynamic neighbor (MAC binding) entry\n          is added/updated.\n        </p>\n\n        <p>\n          <code>true</code> - Always learn the MAC-IP binding, and add/update\n          the MAC binding entry.\n        </p>\n\n        <p>\n          <code>false</code> - If there is a MAC binding for that IP and the\n          MAC is different, or, if TPA of ARP request belongs to any router\n          port on this router, then update/add that MAC-IP binding. Otherwise,\n          don't update/add entries.\n        </p>\n\n        <p>\n          It is <code>true</code> by default.  It is recommended to set to\n          <code>false</code> when a large number of logical routers are\n          connected to the same logical switch but most of them never need to\n          send traffic between each other, to reduce the size of the MAC\n          binding table.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"requested-tnl-key\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 16777215}'>\n        Configures the datapath tunnel key for the logical router.\n        This is not needed because <code>ovn-northd</code> will assign an\n        unique key for each datapath by itself.  However, if it is configured,\n        <code>ovn-northd</code> honors the configured value.\n      </column>\n      <column name=\"options\" key=\"snat-ct-zone\"\n          type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 65535}'>\n        Use the requested conntrack zone for SNAT with this router. This can be\n        useful if egress traffic from the host running OVN comes from both OVN\n        and other sources. This way, OVN and the other sources can make use of\n        the same conntrack zone.\n      </column>\n\n      <column name=\"options\" key=\"mac_binding_age_threshold\"\n              type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 4294967295}'>\n        MAC binding aging <code>threshold</code> value in seconds. MAC binding\n        exceeding this timeout will be automatically removed. The value\n        defaults to 0, which means disabled.\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"QoS\" title=\"QoS rule\">\n    <p>\n      Each row in this table represents one QoS rule for a logical switch\n      that points to it through its <ref column=\"qos_rules\"/> column.\n      Two types of QoS are supported: DSCP marking and metering.  A\n      <ref column=\"match\"/> with the highest-<ref column=\"priority\"/>\n      will have QoS applied to it.  If the <ref column=\"action\"/> column is\n      specified, then matching packets will have DSCP marking applied.\n      If the <ref column=\"bandwidth\"/> column is specified, then matching\n      packets will have metering applied.  <ref column=\"action\"/> and\n      <ref column=\"bandwidth\"/> are not exclusive, so both marking and\n      metering by defined for the same QoS entry. If no row matches,\n      packets will not have any QoS applied.\n    </p>\n\n    <column name=\"priority\">\n      <p>\n        The QoS rule's priority.  Rules with numerically higher priority\n        take precedence over those with lower.  If two QoS rules with\n        the same priority both match, then the one actually applied to a\n        packet is undefined.\n      </p>\n    </column>\n\n    <column name=\"direction\">\n      <p>\n        The value of this field is similar to <ref colun=\"direction\"\n        table=\"ACL\" db=\"OVN_Northbound\"/> column in the OVN Northbound\n        database's <ref table=\"ACL\" db=\"OVN_Northbound\"/> table.\n      </p>\n    </column>\n\n    <column name=\"match\">\n      <p>\n        The packets that the QoS rules should match, in the same expression\n        language used for the <ref column=\"match\" table=\"Logical_Flow\"\n        db=\"OVN_Southbound\"/> column in the OVN Southbound database's\n        <ref table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table.  The\n        <code>outport</code> logical port is only available in the\n        <code>to-lport</code> direction (the <code>inport</code> is\n        available in both directions).\n      </p>\n    </column>\n\n    <column name=\"action\">\n      <p>When specified, matching flows will have DSCP marking applied.</p>\n      <ul>\n        <li>\n          <code>dscp</code>: The value of this action should be in the\n          range of 0 to 63 (inclusive).\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"bandwidth\">\n      <p>\n         When specified, matching packets will have bandwidth metering\n         applied.  Traffic over the limit will be dropped.\n      </p>\n      <ul>\n        <li>\n          <code>rate</code>: The value of rate limit in kbps.\n        </li>\n        <li>\n          <code>burst</code>: The value of burst rate limit in kilobits.\n          This is optional and needs to specify the <code>rate</code>.\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n\n  <table name=\"Mirror\" title=\"Mirror Entry\">\n    <p>\n      Each row in this table represents a mirror that can be used for\n      port mirroring. These mirrors are referenced by the\n      <ref column=\"mirror_rules\" table=\"Logical_Switch_Port\"/> column in\n      the <ref table=\"Logical_Switch_Port\"/> table.\n    </p>\n\n    <column name=\"name\">\n      <p>\n        Represents the name of the mirror.\n      </p>\n    </column>\n\n    <column name=\"filter\">\n      <p>\n        The value of this field represents selection criteria of the mirror.\n        <code>to-lport</code> mirrors the packets coming into logical port.\n        <code>from-lport</code> mirrors the packets going out of logical port.\n      </p>\n    </column>\n\n    <column name=\"sink\">\n      <p>\n        The value of this field represents the destination/sink of the mirror.\n        The value it takes is an IP address of the sink port.\n      </p>\n    </column>\n\n    <column name=\"type\">\n      <p>\n        The value of this field represents the type of the tunnel used for\n        sending the mirrored packets.\n      </p>\n    </column>\n\n    <column name=\"index\">\n      <p>\n        The value of this field represents the tunnel ID. If the configured\n        tunnel type is <code>gre</code>, this field represents the\n        <code>GRE</code> key value and if the configured tunnel type is\n        <code>erspan</code> it represents the <code>erspan_idx</code> value.\n      </p>\n    </column>\n\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n\n  <table name=\"Meter\" title=\"Meter entry\">\n    <p>\n      Each row in this table represents a meter that can be used for QoS or\n      rate-limiting.\n    </p>\n\n    <column name=\"name\">\n      <p>\n        A name for this meter.\n      </p>\n\n      <p>\n        Names that begin with \"__\" (two underscores) are reserved for\n        OVN internal use and should not be added manually.\n      </p>\n    </column>\n\n    <column name=\"unit\">\n      <p>\n        The unit for <ref column=\"rate\" table=\"Meter_Band\"/> and\n        <ref column=\"burst_rate\" table=\"Meter_Band\"/> parameters in\n        the <ref column=\"bands\"/> entry.  <code>kbps</code> specifies\n        kilobits per second, and <code>pktps</code> specifies packets\n        per second.\n      </p>\n    </column>\n\n    <column name=\"bands\">\n      <p>\n        The bands associated with this meter.  Each band specifies a\n        rate above which the band is to take the action\n        <code>action</code>.  If multiple bands' rates are exceeded,\n        then the band with the highest rate among the exceeded bands is\n        selected.\n      </p>\n    </column>\n\n    <column name=\"fair\">\n      <p>\n        This column is used to further describe the desired behavior\n        of the meter when there are multiple references to it. If this\n        column is empty or is set to <code>false</code>, the rate will\n        be shared across all rows that refer to the same Meter\n        <ref column=\"name\" table=\"meter\"/>. Conversely, when this column\n        is set to <code>true</code>, each user of the same Meter will be\n        rate-limited on its own.\n      </p>\n    </column>\n\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n\n  <table name=\"Meter_Band\" title=\"Band for meter entries\">\n    <p>\n      Each row in this table represents a meter band which specifies the\n      rate above which the configured action should be applied.  These bands\n      are referenced by the <ref column=\"bands\" table=\"Meter\"/> column in\n      the <ref table=\"Meter\"/> table.\n    </p>\n\n    <column name=\"action\">\n      <p>\n        The action to execute when this band matches.  The only supported\n        action is <code>drop</code>.\n      </p>\n    </column>\n\n    <column name=\"rate\">\n      <p>\n        The rate limit for this band, in kilobits per second or bits per\n        second, depending on whether the parent <ref table=\"Meter\"/>\n        entry's <ref column=\"unit\" table=\"Meter\"/> column specified\n        <code>kbps</code> or <code>pktps</code>.\n      </p>\n    </column>\n\n    <column name=\"burst_size\">\n      <p>\n        The maximum burst allowed for the band in kilobits or packets,\n        depending on whether <code>kbps</code> or <code>pktps</code> was\n        selected in the parent <ref table=\"Meter\"/> entry's\n        <ref column=\"unit\" table=\"Meter\"/> column.  If the size is zero,\n        the switch is free to select some reasonable value depending on\n        its configuration.\n      </p>\n    </column>\n\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n\n  <table name=\"Logical_Router_Port\" title=\"L3 logical router port\">\n    <p>\n      A port within an L3 logical router.\n    </p>\n\n    <p>\n      Exactly one <ref table=\"Logical_Router\"/> row must reference a given\n      logical router port.\n    </p>\n\n    <column name=\"name\">\n      <p>\n        A name for the logical router port.\n      </p>\n\n      <p>\n        In addition to provide convenience for human interaction with the\n        northbound database, this column is used as reference by its patch port\n        in <ref table=\"Logical_Switch_Port\"/> or another logical router port in\n        <ref table=\"Logical_Router_Port\"/>.\n      </p>\n\n        <p>\n          A logical router port may not have the same name as a logical switch\n          port, but the database schema cannot enforce this.\n        </p>\n    </column>\n\n    <column name=\"networks\">\n      <p>\n        The IP addresses and netmasks of the router.  For example,\n        <code>192.168.0.1/24</code> indicates that the router's IP\n        address is 192.168.0.1 and that packets destined to\n        192.168.0.<var>x</var> should be routed to this port.\n      </p>\n\n      <p>\n        A logical router port always adds a link-local IPv6 address\n        (fe80::/64) automatically generated from the interface's MAC\n        address using the modified EUI-64 format.\n      </p>\n    </column>\n\n    <column name=\"mac\">\n      The Ethernet address that belongs to this router port.\n    </column>\n\n    <column name=\"enabled\">\n      This column is used to administratively set port state.  If this column\n      is empty or is set to <code>true</code>, the port is enabled.  If this\n      column is set to <code>false</code>, the port is disabled.  A disabled\n      port has all ingress and egress traffic dropped.\n    </column>\n\n    <group title=\"Distributed Gateway Ports\">\n      <p>\n        Gateways, as documented under <code>Gateways</code> in the OVN\n        architecture guide, provide limited connectivity between\n        logical networks and physical ones.  OVN support multiple\n        kinds of gateways.  The <ref table=\"Logical_Router_Port\"/>\n        table can be used two different ways to configure\n        <dfn>distributed gateway ports</dfn>, which are one kind of\n        gateway.  These two forms of configuration exist for\n        historical reasons.  Both of them produce the same kind of OVN\n        southbound records and the same behavior in practice.\n      </p>\n\n      <p>\n        If either of these are set, this logical router port represents a\n        distributed gateway port that connects this router to a\n        logical switch with a <code>localnet</code> port or a\n        connection to another OVN deployment.\n      </p>\n\n      <p>\n        Also mentioned in the OVN architecture guide, distributed gateway ports\n        can also be used for scalability reasons in deployments where logical\n        switches are dedicated to chassises rather than distributed.\n      </p>\n\n      <p>\n        The preferred way to configure a gateway is <ref\n        column=\"ha_chassis_group\"/>, but <ref\n        column=\"gateway_chassis\"/> is also supported for backward\n        compatibility.  Only one of these should be set at a time on a\n        given LRP, since they configure the same features.\n      </p>\n\n      <p>\n        Even when a gateway is configured, the logical router port\n        still effectively resides on each chassis.  However, due to\n        the implications of the use of L2 learning in the physical\n        network, as well as the need to support advanced features such\n        as one-to-many NAT (aka IP masquerading), a subset of the\n        logical router processing is handled in a centralized manner\n        on the gateway chassis.\n      </p>\n\n      <p>\n        There can be more than one distributed gateway ports configured\n        on each logical router, each connecting to different L2 segments.\n        Load-balancing is not yet supported on logical routers with more\n        than one distributed gateway ports.\n      </p>\n\n      <p>\n        For each distributed gateway port, it may have more than one gateway\n        chassises. When more than one gateway chassis is specified, OVN only\n        uses one at a time.  OVN can rely on OVS BFD implementation to monitor\n        gateway connectivity, preferring the highest-priority gateway\n        that is online.  Priorities are specified in the <code>priority</code>\n        column of <ref table=\"Gateway_Chassis\"/> or <ref table=\"HA_Chassis\"/>.\n      </p>\n\n      <p>\n        <code>ovn-northd</code> programs the <ref\n        column=\"external_mac\" table=\"NAT\"/> rules specified in the\n        LRP's LR into the peer logical switch's destination lookup on\n        the chassis where the <ref column=\"logical_port\" table=\"NAT\"/>\n        resides.  In addition, the logical router's MAC address is\n        automatically programmed in the peer logical switch's\n        destination lookup flow on the gateway chasssis.  If it is\n        desired to generate gratuitous ARPs for NAT addresses, then\n        set the peer LSP's <ref column=\"options\" key=\"nat-addresses\"\n        table=\"Logical_Switch_Port\"/> to <code>router</code>.\n      </p>\n\n      <p>\n        OVN 20.03 and earlier supported a third way to configure\n        distributed gateway ports using\n        <code>options:redirect-chassis</code> to specify the gateway\n        chassis.  This method is no longer supported.  Any remaining\n        users should switch to one of the newer methods instead.  A\n        <ref column=\"gateway_chassis\"/> may be easily configured from\n        the command line, e.g. <code>ovn-nbctl lrp-set-gateway-chassis\n        <var>lrp</var> <var>chassis</var></code>.\n      </p>\n\n      <column name=\"ha_chassis_group\">\n        Designates an <ref table=\"HA_Chassis_Group\"/> to provide\n        gateway high availability.\n      </column>\n\n      <column name=\"gateway_chassis\">\n        Designates one or more <ref table=\"Gateway_Chassis\"/> for the\n        logical router port.\n      </column>\n\n      <group title=\"Options for Physical VLAN MTU Issues\">\n        <p>\n          MTU issues arise in mixing tunnels with logical networks that are\n          bridged to a physical VLAN.  For an explanation of the MTU issues,\n          see <code>Physical VLAN MTU Issues</code> in the OVN architecture\n          document.  The following options, which are alternatives, provide\n          solutions.  Both of them cause packets to be sent over\n          <code>localnet</code> instead of tunnels, but they differ in whether\n          some or all packets are sent this way.  The most prominent\n          tradeoff between these options is that\n          <code>reside-on-redirect-chassis</code> is easier to configure and\n          that <code>redirect-type</code> performs better for east-west\n          traffic.\n        </p>\n\n        <column name=\"options\" key=\"reside-on-redirect-chassis\"\n                type='{\"type\": \"boolean\"}'>\n          <p>\n            If set to <code>true</code>, this option forces all traffic across\n            the logical router port to pass through the gateway chassis using a\n            hop across a <code>localnet</code> port.  This changes behavior in\n            two ways:\n          </p>\n\n          <ul>\n            <li>\n              Without this option, east-west traffic passes directly between\n              source and destination chassis (or even within a single chassis,\n              for co-located VMs).  With this option, all east-west traffic\n              passes through the gateway chassis.\n            </li>\n\n            <li>\n              Without this option, traffic between the gateway chassis and\n              other chassis is encapsulated in tunnels.  With this option,\n              traffic passes over a <code>localnet</code> interface.\n            </li>\n          </ul>\n\n          <p>\n            This option may usefully be set only on logical router ports that\n            connect a distributed logical router to a logical switch with VIFs.\n            It should not be set on a distributed gateway port.\n          </p>\n\n          <p>\n            OVN honors this option only if the logical router has one and only\n            one distributed gateway port and if the LRP's peer switch has a\n            <code>localnet</code> port.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"redirect-type\"\n                type='{\"type\": \"string\", \"enum\": [\"set\", [\"overlay\", \"bridged\"]]}'>\n          <p>\n            If set to <code>bridged</code> on a distributed gateway port, this\n            option causes OVN to redirect packets to the gateway chassis over a\n            <code>localnet</code> port instead of a tunnel.  The relevant\n            chassis must share a <code>localnet</code> port.\n          </p>\n\n          <p>\n            This feature requires the administrator or the CMS to configure\n            each participating chassis with a unique Ethernet address for the\n            logical router by setting <code>ovn-chassis-mac-mappings</code> in\n            the Open vSwitch database, for use by <code>ovn-controller</code>.\n          </p>\n\n          <p>\n            Setting this option to <code>overlay</code> or leaving it unset has\n            no effect.  This option may usefully be set only on a distributed\n            gateway port when there is one and only one distributed gateway\n            port on the logical router.  It is otherwise ignored.\n          </p>\n        </column>\n      </group>\n    </group>\n\n    <column name=\"ipv6_prefix\">\n       This column contains IPv6 prefix obtained by prefix delegation\n       router according to RFC 3633\n    </column>\n\n    <group title=\"ipv6_ra_configs\">\n      <p>\n        This column defines the IPv6 ND RA address mode and ND MTU Option to be\n        included by <code>ovn-controller</code> when it replies to the IPv6\n        Router solicitation requests.\n      </p>\n\n      <column name=\"ipv6_ra_configs\" key=\"address_mode\">\n        The address mode to be used for IPv6 address configuration.\n        The supported values are:\n        <ul>\n          <li>\n            <code>slaac</code>: Address configuration using Router\n            Advertisement (RA) packet. The IPv6 prefixes defined in the\n            <ref table=\"Logical_Router_Port\"/> table's\n            <ref table=\"Logical_Router_Port\" column=\"networks\"/> column will\n            be included in the RA's ICMPv6 option - Prefix information.\n          </li>\n\n          <li>\n            <code>dhcpv6_stateful</code>: Address configuration using DHCPv6.\n          </li>\n\n          <li>\n            <code>dhcpv6_stateless</code>: Address configuration using Router\n            Advertisement (RA) packet. Other IPv6 options are provided by\n            DHCPv6.\n          </li>\n        </ul>\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"router_preference\">\n        Default Router Preference (PRF) indicates whether to prefer this\n        router over other default routers (RFC 4191).\n        Possible values are:\n\n        <ul>\n          <li>HIGH: mapped to 0x01 in RA PRF field</li>\n          <li>MEDIUM: mapped to 0x00 in RA PRF field</li>\n          <li>LOW: mapped to 0x11 in RA PRF field</li>\n        </ul>\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"route_info\">\n        Route Info is used to configure Route Info Option sent in Router\n        Advertisement according to RFC 4191. Route Info is a comma\n        separated string where each field provides PRF and prefix for a\n        given route (e.g: HIGH-aef1::11/48,LOW-aef2::11/96)\n        Possible PRF values are:\n\n        <ul>\n          <li>HIGH: mapped to 0x01 in RA PRF field</li>\n          <li>MEDIUM: mapped to 0x00 in RA PRF field</li>\n          <li>LOW: mapped to 0x11 in RA PRF field</li>\n        </ul>\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"mtu\">\n        The recommended MTU for the link. Default is 0, which means no MTU\n        Option will be included in RA packet replied by ovn-controller.\n        Per RFC 2460, the mtu value is recommended no less than 1280, so\n        any mtu value less than 1280 will be considered as no MTU Option.\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"send_periodic\">\n        If set to true, then this router interface will send router\n        advertisements periodically.  The default is false.\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"max_interval\">\n        The maximum number of seconds to wait between sending periodic router\n        advertisements.  This option has no effect if <ref\n        column=\"ipv6_ra_configs\" key=\"send_periodic\"/> is false.  The default\n        is 600.\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"min_interval\">\n        The minimum number of seconds to wait between sending periodic router\n        advertisements.  This option has no effect if <ref\n        column=\"ipv6_ra_configs\" key=\"send_periodic\"/> is false.  The default\n        is one-third of <ref column=\"ipv6_ra_configs\" key=\"max_interval\"/>,\n        i.e. 200 seconds if that key is unset.\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"rdnss\">\n        IPv6 address of RDNSS server announced in RA packets. At the moment\n        OVN supports just one RDNSS server.\n      </column>\n\n      <column name=\"ipv6_ra_configs\" key=\"dnssl\">\n        DNS Search List announced in RA packets. Multiple DNS Search List\n        must be 'comma' separated (e.g. \"a.b.c, d.e.f\")\n      </column>\n    </group>\n\n    <group title=\"Options\">\n      <p>\n        Additional options for the logical router port.\n      </p>\n\n      <column name=\"options\" key=\"mcast_flood\"\n              type='{\"type\": \"boolean\"}'>\n        <p>\n          If set to <code>true</code>, multicast traffic (including reports)\n          are unconditionally forwarded to the specific port.\n        </p>\n\n        <p>\n          This option applies when the port is part of a logical router which\n          has <ref table=\"Logical_Router\" column=\"options\"/>:mcast_relay set\n          to <code>true</code>.\n        </p>\n\n        <p>\n          Default: <code>false</code>.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"requested-tnl-key\"\n          type='{\"type\": \"integer\", \"minInteger\": 1, \"maxInteger\": 32767}'>\n        Configures the port binding tunnel key for the port.  Usually\n        this is not needed because <code>ovn-northd</code> will assign an\n        unique key for each port by itself.  However, if it is configured,\n        <code>ovn-northd</code> honors the configured value.\n      </column>\n\n      <column name=\"options\" key=\"prefix_delegation\"\n              type='{\"type\": \"boolean\"}'>\n        <p>\n          If set to <code>true</code>, enable IPv6 prefix delegation state\n          machine on this logical router port (RFC3633). IPv6 prefix\n          delegation is available just on a gateway router or on a gateway\n          router port.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"prefix\" type='{\"type\": \"boolean\"}'>\n        <p>\n          If set to <code>true</code>, this interface will receive an IPv6\n          prefix according to RFC3663\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"route_table\">\n        Designates lookup Logical_Router_Static_Routes with specified\n        <code>route_table</code> value. Routes to directly connected networks\n        from same Logical Router and routes without <code>route_table</code>\n        option set have higher priority than routes with\n        <code>route_table</code> option set.\n      </column>\n\n      <column name=\"options\" key=\"gateway_mtu\"\n          type='{\"type\": \"integer\", \"minInteger\": 68, \"maxInteger\": 65535}'>\n        <p>\n          If set, logical flows will be added to router pipeline to check\n          packet length.  If packet length is greater than the value set,\n          ICMPv4 type 3 (Destination Unreachable) code 4 (Fragmentation Needed\n          and Don't Fragment was Set) or ICMPv6 type 2 (Packet Too Big)\n          code 0 (no route to destination) packets will be generated.\n\n          This allows for Path MTU Discovery.\n        </p>\n      </column>\n\n      <column name=\"options\" key=\"gateway_mtu_bypass\">\n        <p>\n          When configured, represents a match expression, in the same\n          expression language used for the <ref column=\"match\"\n          table=\"Logical_Flow\" db=\"OVN_Southbound\"/> column in the OVN\n          Southbound database's <ref table=\"Logical_Flow\" db=\"OVN_Southbound\"/>\n          table.  Packets matching this expression will bypass the length\n          check configured through the\n          <ref column=\"options\" key=\"gateway_mtu\"/> option.\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Attachment\">\n      <p>\n        A given router port serves one of two purposes:\n      </p>\n\n      <ul>\n        <li>\n          To attach a logical switch to a logical router.  A logical router\n          port of this type is referenced by exactly one <ref\n          table=\"Logical_Switch_Port\"/> of type <code>router</code>.\n          The value of <ref column=\"name\"/> is set as\n          <code>router-port</code> in column <ref column=\"options\"/> of\n          <ref table=\"Logical_Switch_Port\"/>.  In this case <ref\n          column=\"peer\"/> column is empty.\n        </li>\n\n        <li>\n          To connect one logical router to another.  This requires a pair of\n          logical router ports, each connected to a different router.  Each\n          router port in the pair specifies the other in its <ref\n          column=\"peer\"/> column.  No <ref table=\"Logical_Switch\"/> refers to\n          the router port.\n        </li>\n      </ul>\n\n      <column name=\"peer\">\n        <p>\n          For a router port used to connect two logical routers, this\n          identifies the other router port in the pair by <ref column=\"name\"/>.\n        </p>\n\n        <p>\n          For a router port attached to a logical switch, this column is empty.\n        </p>\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n        <p>\n          The <code>ovn-northd</code> program copies all these pairs into the\n          <ref column=\"external_ids\"/> column of the\n          <ref table=\"Port_Binding\"/> table in <ref db=\"OVN_Southbound\"/>\n          database.\n        </p>\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Logical_Router_Static_Route\" title=\"Logical router static routes\">\n    <p>\n      Each record represents a static route.\n    </p>\n\n    <p>\n      When multiple routes match a packet, the longest-prefix match is chosen.\n      For a given prefix length, a <code>dst-ip</code> route is preferred over\n      a <code>src-ip</code> route.\n    </p>\n\n    <p>\n      When there are ECMP routes, i.e. multiple routes with same prefix and\n      policy, one of them will be selected based on the 5-tuple hashing of the\n      packet header.\n    </p>\n\n    <column name=\"ip_prefix\">\n      <p>\n        IP prefix of this route (e.g. 192.168.100.0/24).\n      </p>\n    </column>\n\n    <column name=\"policy\">\n      <p>\n        If it is specified, this setting describes the policy used to make\n        routing decisions.  This setting must be one of the following strings:\n      </p>\n      <ul>\n        <li>\n          <code>src-ip</code>: This policy sends the packet to the\n          <ref column=\"nexthop\"/> when the packet's source IP address matches\n          <ref column=\"ip_prefix\"/>.\n       </li>\n        <li>\n          <code>dst-ip</code>: This policy sends the packet to the\n          <ref column=\"nexthop\"/> when the packet's destination IP address\n          matches <ref column=\"ip_prefix\"/>.\n        </li>\n      </ul>\n      <p>\n        If not specified, the default is <code>dst-ip</code>.\n     </p>\n    </column>\n\n    <column name=\"nexthop\">\n      <p>\n        Nexthop IP address for this route.  Nexthop IP address should be the IP\n        address of a connected router port or the IP address of a logical port\n        or can be set to <code>discard</code> for dropping packets which match\n        the given route.\n      </p>\n    </column>\n\n    <column name=\"output_port\">\n      <p>\n        The name of the <ref table=\"Logical_Router_Port\"/> via which the packet\n        needs to be sent out.  This is optional and when not specified,\n        OVN will automatically figure this out based on the\n        <ref column=\"nexthop\"/>.  When this is specified and there are\n        multiple IP addresses on the router port and none of them are in the\n        same subnet of <ref column=\"nexthop\"/>, OVN chooses the first IP\n        address as the one via which the <ref column=\"nexthop\"/> is reachable.\n      </p>\n    </column>\n\n    <column name=\"bfd\">\n      <p>\n        Reference to <ref table=\"BFD\"/> row if the route has associated a\n        BFD session\n      </p>\n    </column>\n\n    <column name=\"route_table\">\n      <p>\n        Any string to place route to separate routing table. If Logical Router\n        Port has configured value in <ref table=\"Logical_Router_Port\"\n        column=\"options\" key=\"route_table\"/> other than empty string, OVN\n        performs route lookup for all packets entering Logical Router ingress\n        pipeline from this port in the following manner:\n      </p>\n\n      <ul>\n        <li>\n          1. First lookup among \"global\" routes: routes without\n          <code>route_table</code> value set and routes to directly connected\n          networks.\n        </li>\n        <li>\n          2. Next lookup among routes with same <code>route_table</code> value\n          as specified in LRP's options:route_table field.\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"external_ids\" key=\"ic-learned-route\">\n      <code>ovn-ic</code> populates this key if the route is learned from the\n      global <ref db=\"OVN_IC_Southbound\"/> database.  In this case the value\n      will be set to the uuid of the row in <ref table=\"Route\"\n      db=\"OVN_IC_Southbound\"/> table of the <ref db=\"OVN_IC_Southbound\"/>\n      database.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n\n    <group title=\"Common options\">\n      <column name=\"options\">\n        This column provides general key/value settings. The supported\n        options are described individually below.\n      </column>\n\n      <column name=\"options\" key=\"ecmp_symmetric_reply\">\n        If true, then new traffic that arrives over this route will have\n        its reply traffic bypass ECMP route selection and will be sent out\n        this route instead. Note that this option overrides any rules set\n        in the <ref table=\"Logical_Router_policy\" /> table. This option\n        only works on gateway routers (routers that have\n        <ref column=\"options\" key=\"chassis\" table=\"Logical_Router\" /> set).\n      </column>\n\n      <column name=\"options\" key=\"origin\">\n        In case ovn-interconnection has been learned this route, it will have\n        its origin set: either \"connected\" or \"static\".  This key is supposed\n        to be written only by <code>ovn-ic</code> daemon.  ovn-northd then\n        checks this value when generating Logical Flows.  <ref\n        table=\"Logical_Router_Static_Route\"/> records with same\n        <ref column=\"ip_prefix\"/> within same Logical Router will have next\n        lookup order based on <code>origin</code> key value:\n        <ol>\n          <li>connected</li>\n          <li>static</li>\n        </ol>\n      </column>\n    </group>\n\n  </table>\n\n  <table name=\"Logical_Router_Policy\" title=\"Logical router policies\">\n    <p>\n      Each row in this table represents one routing policy for a logical router\n      that points to it through its <ref column=\"policies\"/> column.  The <ref\n      column=\"action\"/> column for the highest-<ref column=\"priority\"/>\n      matching row in this table determines a packet's treatment.  If no row\n      matches, packets are allowed by default. (Default-deny treatment is\n      possible: add a rule with <ref column=\"priority\"/> 0, <code>1</code> as\n      <ref column=\"match\"/>, and <code>drop</code> as <ref column=\"action\"/>.)\n    </p>\n\n    <column name=\"priority\">\n      <p>\n        The routing policy's priority.  Rules with numerically higher priority\n        take precedence over those with lower. A rule is uniquely identified\n        by the priority and match string.\n      </p>\n    </column>\n\n    <column name=\"match\">\n      <p>\n        The packets that the routing policy should match,\n        in the same expression language used for the\n        <ref column=\"match\" table=\"Logical_Flow\" db=\"OVN_Southbound\"/>\n        column in the OVN Southbound database's\n        <ref table=\"Logical_Flow\" db=\"OVN_Southbound\"/> table.\n      </p>\n\n      <p>\n        By default all traffic is allowed.  When writing a more\n        restrictive policy, it is important to remember to allow flows\n        such as ARP and IPv6 neighbor discovery packets.\n      </p>\n    </column>\n\n    <column name=\"action\">\n      <p>The action to take when the routing policy matches:</p>\n      <ul>\n        <li>\n          <code>allow</code>: Forward the packet.\n        </li>\n\n        <li>\n          <code>drop</code>: Silently drop the packet.\n        </li>\n\n        <li>\n          <code>reroute</code>: Reroute packet to <ref column=\"nexthop\"/> or\n          <ref column=\"nexthops\"/>.\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"nexthop\">\n      <p>\n        Note: This column is deprecated in favor of <ref column=\"nexthops\"/>.\n      </p>\n      <p>\n        Next-hop IP address for this route, which should be the IP\n        address of a connected router port or the IP address of a logical port.\n      </p>\n    </column>\n\n    <column name=\"nexthops\">\n      <p>\n        Next-hop ECMP IP addresses for this route. Each IP in the list should\n        be the IP address of a connected router port or the IP address of a\n        logical port.\n      </p>\n\n      <p>\n        One IP from the list is selected as next hop.\n      </p>\n    </column>\n\n    <column name=\"options\" key=\"pkt_mark\">\n      <p>\n        Marks the packet with the value specified when the router policy\n        is applied. CMS can inspect this packet marker and take some decisions\n        if desired. This value is not preserved when the packet goes out on the\n        wire.\n      </p>\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"NAT\" title=\"NAT rules\">\n    <p>\n      Each record represents a NAT rule.\n    </p>\n\n    <column name=\"type\">\n      <p>Type of the NAT rule.</p>\n      <ul>\n        <li>\n          When <ref column=\"type\"/> is <code>dnat</code>, the externally\n          visible IP address <ref column=\"external_ip\"/> is DNATted to the IP\n          address <ref column=\"logical_ip\"/> in the logical space.\n        </li>\n        <li>\n          When <ref column=\"type\"/> is <code>snat</code>, IP packets\n          with their source IP address that either matches the IP address\n          in <ref column=\"logical_ip\"/> or is in the network provided by\n          <ref column=\"logical_ip\"/> is SNATed into the IP address in\n          <ref column=\"external_ip\"/>.\n        </li>\n        <li>\n          When <ref column=\"type\"/> is <code>dnat_and_snat</code>, the\n          externally visible IP address <ref column=\"external_ip\"/> is\n          DNATted to the IP address <ref column=\"logical_ip\"/> in the\n          logical space. In addition, IP packets with the source IP\n          address that matches <ref column=\"logical_ip\"/> is SNATed into\n          the IP address in <ref column=\"external_ip\"/>.\n        </li>\n      </ul>\n    </column>\n\n    <column name=\"external_ip\">\n      An IPv4 address.\n    </column>\n\n    <column name=\"external_mac\">\n      <p>\n        A MAC address.\n      </p>\n\n      <p>\n        This is only used on the gateway port on distributed routers.\n        This must be specified in order for the NAT rule to be\n        processed in a distributed manner on all chassis.  If this is\n        not specified for a NAT rule on a distributed router, then\n        this NAT rule will be processed in a centralized manner on\n        the gateway port instance on the gateway chassis.\n      </p>\n\n      <p>\n        This MAC address must be unique on the logical switch that the\n        gateway port is attached to.  If the MAC address used on the\n        <ref column=\"logical_port\"/> is globally unique, then that MAC\n        address can be specified as this <ref column=\"external_mac\"/>.\n      </p>\n    </column>\n\n    <column name=\"external_port_range\">\n      <p>\n        L4 source port range\n      </p>\n\n      <p>\n        Range of ports, from which a port number will be picked that will\n        replace the source port of to be NATed packet. This is basically\n        PAT (port address translation).\n      </p>\n\n      <p>\n        Value of the column is in the format, port_lo-port_hi.\n        For example:\n        external_port_range : \"1-30000\"\n      </p>\n\n      <p>\n        Valid range of ports is 1-65535.\n      </p>\n\n    </column>\n\n    <column name=\"logical_ip\">\n      An IPv4 network (e.g 192.168.1.0/24) or an IPv4 address.\n    </column>\n\n    <column name=\"logical_port\">\n      <p>\n        The name of the logical port where the <ref column=\"logical_ip\"/>\n        resides.\n      </p>\n\n      <p>\n        This is only used on distributed routers.  This must be\n        specified in order for the NAT rule to be processed in a\n        distributed manner on all chassis.  If this is not specified\n        for a NAT rule on a distributed router, then this NAT rule\n        will be processed in a centralized manner on the gateway\n        port instance on the gateway chassis.\n      </p>\n    </column>\n\n    <column name=\"allowed_ext_ips\">\n      It represents Address Set of external ips that NAT rule is applicable to.\n      For SNAT type NAT rules, this refers to destination addresses.\n      For DNAT type NAT rules, this refers to source addresses.\n\n      <p>\n        This configuration overrides the default NAT behavior of applying a\n        rule solely based on internal IP. Without this configuration, NAT\n        happens without considering the external IP (i.e dest/source for\n        snat/dnat type rule). With this configuration NAT rule is applied\n        ONLY if external ip is in the input Address Set.\n      </p>\n    </column>\n\n    <column name=\"exempted_ext_ips\">\n      It represents Address Set of external ips that NAT rule is NOT\n      applicable to.\n      For SNAT type NAT rules, this refers to destination addresses.\n      For DNAT type NAT rules, this refers to source addresses.\n\n      <p>\n        This configuration overrides the default NAT behavior of applying a\n        rule solely based on internal IP. Without this configuration, NAT\n        happens without considering the external IP (i.e dest/source for\n        snat/dnat type rule). With this configuration NAT rule is NOT applied\n        if external ip is in the input Address Set.\n      </p>\n\n      <p>\n        If there are NAT rules in a logical router with overlapping IP prefixes\n        (including /32), then usage of <var>exempted_ext_ips</var> should be\n        avoided in following scenario.\n        a. SNAT rule (let us say RULE1) with logical_ip PREFIX/MASK\n           (let us say 50.0.0.0/24).\n        b. SNAT rule (let us say RULE2) with logical_ip PREFIX/MASK+1\n           (let us say 50.0.0.0/25).\n        c. Now, if exempted_ext_ips is associated with RULE2, then a logical\n           ip which matches both 50.0.0.0/24 and 50.0.0.0/25 may get the RULE2\n           applied to it instead of RULE1.\n      </p>\n\n      <p>\n        <var>allowed_ext_ips</var> and <var>exempted_ext_ips</var> are mutually\n        exclusive to each other. If both Address Sets are set for a rule,\n        then the NAT rule is not considered.\n      </p>\n    </column>\n\n    <column name=\"gateway_port\">\n      <p>\n        A distributed gateway port in the <ref table=\"Logical_Router_Port\"/>\n        table where the NAT rule needs to be applied.\n      </p>\n\n      <p>\n        When multiple distributed gateway ports are configured on a\n        <ref table=\"Logical_Router\"/>, applying a NAT rule at each of the\n        distributed gateway ports might not be desired. Consider the case\n        where a logical router has 2 distributed gateway port, one with\n        <ref column=\"networks\" table=\"Logical_Router_Port\"/>\n        <code>50.0.0.10/24</code> and the other with\n        <ref column=\"networks\" table=\"Logical_Router_Port\"/>\n        <code>60.0.0.10/24</code>. If the logical router has a\n        NAT rule of <ref column=\"type\"/> <code>snat</code>,\n        <ref column=\"logical_ip\"/> <code>10.1.1.0/24</code> and\n        <ref column=\"external_ip\"/> <code>50.1.1.20/24</code>, the rule needs\n        to be selectively applied on matching packets entering/leaving\n        through the distributed gateway port with\n        <ref column=\"networks\" table=\"Logical_Router_Port\"/>\n        <code>50.0.0.10/24</code>.\n      </p>\n\n      <p>\n        When a logical router has multiple distributed gateway ports and this\n        column is not set for a NAT rule, then the rule will be applied at the\n        distributed gateway port which is in the same network as the\n        <ref column=\"external_ip\"/> of the NAT rule, if such a router port\n        exists. If logical router has a single distributed gateway port and\n        this column is not set for a NAT rule, the rule will be applied at the\n        distributed gateway port even if the router port is not in the same\n        network as the <ref column=\"external_ip\"/> of the NAT rule.\n      </p>\n    </column>\n\n    <column name=\"options\" key=\"stateless\">\n      Indicates if a dnat_and_snat rule should lead to connection\n      tracking state or not.\n    </column>\n\n    <column name=\"options\" key=\"add_route\">\n      If set to <code>true</code>, then neighbor routers will have logical\n      flows added that will allow for routing to the NAT address. It also will\n      have ARP resolution logical flows added. By setting this option, it means\n      there is no reason to create a <ref table=\"Logical_Router_Static_Route\"/>\n      from neighbor routers to this NAT address. It also means that no ARP\n      request is required for neighbor routers to learn the IP-MAC mapping for\n      this NAT address. This option only applies to NATs of type\n      <code>dnat</code> and <code>dnat_and_snat</code>. For more information\n      about what flows are added for IP routes, please see the\n      <code>ovn-northd</code> manpage section on IP Routing.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n\n  </table>\n\n  <table name=\"DHCP_Options\" title=\"DHCP options\">\n    <p>\n      OVN implements native DHCPv4 support which caters to the common\n      use case of providing an IPv4 address to a booting instance by\n      providing stateless replies to DHCPv4 requests based on statically\n      configured address mappings. To do this it allows a short list of\n      DHCPv4 options to be configured and applied at each compute host\n      running <code>ovn-controller</code>.\n    </p>\n\n    <p>\n      OVN also implements native DHCPv6 support which provides stateless\n      replies to DHCPv6 requests.\n    </p>\n\n    <column name=\"cidr\">\n      <p>\n        The DHCPv4/DHCPv6 options will be included if the logical port has its\n        IP address in this <ref column=\"cidr\"/>.\n      </p>\n    </column>\n\n    <group title=\"DHCPv4 options\">\n      <p>\n        The CMS should define the set of DHCPv4 options as key/value pairs\n        in the <ref column=\"options\"/> column of this table. For\n        <code>ovn-controller</code> to include these DHCPv4 options, the\n        <ref column=\"dhcpv4_options\"/> of <ref table=\"Logical_Switch_Port\"/>\n        should refer to an entry in this table.\n      </p>\n\n      <group title=\"Mandatory DHCPv4 options\">\n        <p>\n          The following options must be defined.\n        </p>\n\n        <column name=\"options\" key=\"server_id\">\n          The IP address for the DHCP server to use.  This should be in the\n          subnet of the offered IP.  This is also included in the DHCP offer as\n          option 54, ``server identifier.''\n        </column>\n\n        <column name=\"options\" key=\"server_mac\">\n          The Ethernet address for the DHCP server to use.\n        </column>\n\n        <column name=\"options\" key=\"lease_time\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 4294967295}'>\n          <p>\n            The offered lease time in seconds,\n          </p>\n\n          <p>\n            The DHCPv4 option code for this option is 51.\n          </p>\n        </column>\n      </group>\n\n      <group title=\"IPv4 DHCP Options\">\n        <p>\n          Below are the supported DHCPv4 options whose values are an IPv4\n          address, e.g. <code>192.168.1.1</code>.  Some options accept multiple\n          IPv4 addresses enclosed within curly braces, e.g. <code>{192.168.1.2,\n          192.168.1.3}</code>. Please refer to RFC 2132 for more details on\n          DHCPv4 options and their codes.\n        </p>\n\n        <column name=\"options\" key=\"router\">\n          <p>\n            The IP address of a gateway for the client to use.  This should be\n            in the subnet of the offered IP.  The DHCPv4 option code for this\n            option is 3.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"netmask\">\n          <p>\n            The DHCPv4 option code for this option is 1.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"dns_server\">\n          <p>\n            The DHCPv4 option code for this option is 6.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"log_server\">\n          <p>\n            The DHCPv4 option code for this option is 7.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"lpr_server\">\n          <p>\n            The DHCPv4 option code for this option is 9.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"swap_server\">\n          <p>\n            The DHCPv4 option code for this option is 16.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"policy_filter\">\n          <p>\n            The DHCPv4 option code for this option is 21.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"router_solicitation\">\n          <p>\n            The DHCPv4 option code for this option is 32.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"nis_server\">\n          <p>\n            The DHCPv4 option code for this option is 41.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"ntp_server\">\n          <p>\n            The DHCPv4 option code for this option is 42.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"netbios_name_server\">\n          <p>\n            The DHCPv4 option code for this option is 44.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"classless_static_route\">\n          <p>\n            The DHCPv4 option code for this option is 121.\n          </p>\n\n          <p>\n             This option can contain one or more static routes, each of which\n             consists of a destination descriptor and the IP address of the\n             router that should be used to reach that destination. Please see\n             RFC 3442 for more details.\n          </p>\n\n          <p>\n            Example: <code>{30.0.0.0/24,10.0.0.10, 0.0.0.0/0,10.0.0.1}</code>\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"ms_classless_static_route\">\n          <p>\n            The DHCPv4 option code for this option is 249. This option is\n            similar to <code>classless_static_route</code> supported by\n            Microsoft Windows DHCPv4 clients.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"next_server\">\n          <p>\n            The DHCPv4 option code for setting the \"Next server IP\n            address\" field in the DHCP header.\n          </p>\n        </column>\n\n      </group>\n\n      <group title=\"Boolean DHCP Options\">\n        <p>\n          These options accept a Boolean value, expressed as <code>0</code> for\n          false or <code>1</code> for true.\n        </p>\n\n        <column name=\"options\" key=\"ip_forward_enable\"\n                type='{\"type\": \"string\", \"enum\": [\"set\", [\"0\", \"1\"]]}'>\n          <p>\n            The DHCPv4 option code for this option is 19.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"router_discovery\"\n                type='{\"type\": \"string\", \"enum\": [\"set\", [\"0\", \"1\"]]}'>\n          <p>\n            The DHCPv4 option code for this option is 31.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"ethernet_encap\"\n                type='{\"type\": \"string\", \"enum\": [\"set\", [\"0\", \"1\"]]}'>\n          <p>\n            The DHCPv4 option code for this option is 36.\n          </p>\n        </column>\n      </group>\n\n      <group title=\"Integer DHCP Options\">\n        <p>\n          These options accept a nonnegative integer value.\n        </p>\n\n        <column name=\"options\" key=\"default_ttl\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 255}'>\n          The DHCPv4 option code for this option is 23.\n        </column>\n\n        <column name=\"options\" key=\"tcp_ttl\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 255}'>\n          The DHCPv4 option code for this option is 37.\n        </column>\n\n        <column name=\"options\" key=\"mtu\"\n                type='{\"type\": \"integer\", \"minInteger\": 68, \"maxInteger\": 65535}'>\n          The DHCPv4 option code for this option is 26.\n        </column>\n\n        <column name=\"options\" key=\"T1\"\n                type='{\"type\": \"integer\", \"minInteger\": 68, \"maxInteger\": 4294967295}'>\n          This specifies the time interval from address assignment until the\n          client begins trying to renew its address.  The DHCPv4 option code\n          for this option is 58.\n        </column>\n\n        <column name=\"options\" key=\"T2\"\n                type='{\"type\": \"integer\", \"minInteger\": 68, \"maxInteger\": 4294967295}'>\n          This specifies the time interval from address assignment until the\n          client begins trying to rebind its address.  The DHCPv4 option code\n          for this option is 59.\n        </column>\n\n        <column name=\"options\" key=\"arp_cache_timeout\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 255}'>\n          The DHCPv4 option code for this option is 35. This option\n          specifies the timeout in seconds for ARP cache entries.\n        </column>\n\n        <column name=\"options\" key=\"tcp_keepalive_interval\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 255}'>\n          The DHCPv4 option code for this option is 38. This option\n          specifies the interval that the client TCP should wait before\n          sending a keepalive message on a TCP connection.\n        </column>\n\n        <column name=\"options\" key=\"netbios_node_type\"\n                type='{\"type\": \"integer\", \"minInteger\": 0, \"maxInteger\": 255}'>\n          <p>\n            The DHCPv4 option code for this option is 46.\n          </p>\n        </column>\n      </group>\n\n      <group title=\"String DHCP Options\">\n        <p>\n          These options accept a string value.\n        </p>\n\n        <column name=\"options\" key=\"wpad\">\n          <p>\n            The DHCPv4 option code for this option is 252. This option is used\n            as part of web proxy auto discovery to provide a URL for a web\n            proxy.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"bootfile_name\">\n          <p>\n            The DHCPv4 option code for this option is 67. This option is used\n            to identify a bootfile.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"path_prefix\">\n          <p>\n            The DHCPv4 option code for this option is 210. In PXELINUX'\n            case this option is used to set a common path prefix,\n            instead of deriving it from the bootfile name.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"tftp_server_address\">\n          <p>\n            The DHCPv4 option code for this option is 150. The option\n            contains one or more IPv4 addresses that the client MAY\n            use. This option is Cisco proprietary, the IEEE standard\n            that matches with this requirement is option 66 (tftp_server).\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"hostname\">\n          <p>\n            The DHCPv4 option code for this option is 12.\n            If set, indicates the DHCPv4 option \"Hostname\".\n            Alternatively, this option can be configured in\n            <ref column=\"options:hostname\" table=\"Logical_Switch_Port\"\n            db=\"OVN_NB\"/> column in table <ref table=\"Logical_Switch_Port\"/>.\n            If Hostname option value is set in both conflicting\n            <ref table=\"Logical_Switch_Port\"/> and\n            <ref table=\"DHCP_Options\"/> tables,\n            <ref table=\"Logical_Switch_Port\"/> takes precedence.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"domain_name\">\n          <p>\n            The DHCPv4 option code for this option is 15. This option\n            specifies the domain name that client should use when\n            resolving hostnames via the Domain Name System.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"bootfile_name_alt\">\n          <p>\n          </p>\n            \"bootfile_name_alt\" option is used to support iPXE.\n            When both \"bootfile_name\" and \"bootfile_name_alt\" are provided\n            by the CMS, \"bootfile_name\" will be used for option 67 if the\n            dhcp request contains etherboot option (175), otherwise\n            \"bootfile_name_alt\" will be used.\n        </column>\n\n        <column name=\"options\" key=\"broadcast_address\">\n          <p>\n            The DHCPv4 option code for this option is 28. This option\n            specifies the IP address used as a broadcast address.\n          </p>\n        </column>\n      </group>\n\n      <group title=\"DHCP Options of type host_id\">\n        <p>\n          These options accept either an IPv4 address or a string value.\n        </p>\n\n        <column name=\"options\" key=\"tftp_server\">\n          <p>\n            The DHCPv4 option code for this option is 66.\n          </p>\n        </column>\n      </group>\n\n      <group title=\" DHCP Options of type domains\">\n        <p>\n          These options accept string value which is a comma separated\n          list of domain names. The domain names are encoded based on RFC 1035.\n        </p>\n\n        <column name=\"options\" key=\"domain_search_list\">\n          <p>\n            The DHCPv4 option code for this option is 119.\n          </p>\n        </column>\n      </group>\n    </group>\n\n    <group title=\"DHCPv6 options\">\n      <p>\n        OVN also implements native DHCPv6 support. The CMS should define\n        the set of DHCPv6 options as key/value pairs. The define DHCPv6\n        options will be included in the DHCPv6 response to the DHCPv6\n        Solicit/Request/Confirm packet from the logical ports having the\n        IPv6 addresses in the <ref column=\"cidr\"/>.\n      </p>\n\n      <group title=\"Mandatory DHCPv6 options\">\n        <p>\n          The following options must be defined.\n        </p>\n\n        <column name=\"options\" key=\"server_id\">\n          <p>\n            The Ethernet address for the DHCP server to use. This is also\n            included in the DHCPv6 reply as option 2, ``Server Identifier''\n            to carry a DUID identifying a server between a client and a server.\n            <code>ovn-controller</code> defines DUID based on\n            Link-layer Address [DUID-LL].\n          </p>\n        </column>\n      </group>\n\n      <group title=\"IPv6 DHCPv6 options\">\n        <p>\n          Below are the supported DHCPv6 options whose values are an IPv6\n          address, e.g. <code>aef0::4</code>.  Some options accept multiple\n          IPv6 addresses enclosed within curly braces, e.g. <code>{aef0::4,\n          aef0::5}</code>. Please refer to RFC 3315 for more details on\n          DHCPv6 options and their codes.\n        </p>\n\n        <column name=\"options\" key=\"dns_server\">\n          <p>\n            The DHCPv6 option code for this option is 23. This option specifies\n            the DNS servers that the VM should use.\n          </p>\n        </column>\n      </group>\n\n      <group title=\"String DHCPv6 options\">\n        <p>\n          These options accept string values.\n        </p>\n\n        <column name=\"options\" key=\"domain_search\">\n          <p>\n            The DHCPv6 option code for this option is 24. This option specifies\n            the domain search list the client should use to resolve hostnames\n            with DNS.\n          </p>\n\n          <p>\n            Example: <code>\"ovn.org\"</code>.\n          </p>\n        </column>\n\n        <column name=\"options\" key=\"dhcpv6_stateless\">\n          <p>\n            This option specifies the OVN native DHCPv6 will work in stateless\n            mode, which means OVN native DHCPv6 will not offer IPv6 addresses\n            for VM/VIF ports, but only reply other configurations, such as\n            DNS and domain search list. When setting this option with string\n            value \"true\", VM/VIF will configure IPv6 addresses by stateless\n            way. Default value for this option is false.\n          </p>\n        </column>\n      </group>\n    </group>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Connection\" title=\"OVSDB client connections.\">\n    <p>\n      Configuration for a database connection to an Open vSwitch database\n      (OVSDB) client.\n    </p>\n\n    <p>\n      This table primarily configures the Open vSwitch database server\n      (<code>ovsdb-server</code>).\n    </p>\n\n    <p>\n      The Open vSwitch database server can initiate and maintain active\n      connections to remote clients.  It can also listen for database\n      connections.\n    </p>\n\n    <group title=\"Core Features\">\n      <column name=\"target\">\n        <p>Connection methods for clients.</p>\n        <p>\n          The following connection methods are currently supported:\n        </p>\n        <dl>\n          <dt><code>ssl:<var>host</var></code>[<code>:<var>port</var></code>]</dt>\n          <dd>\n            <p>\n              The specified SSL <var>port</var> on the host at the given\n              <var>host</var>, which can either be a DNS name (if built with\n              unbound library) or an IP address. A valid SSL configuration must\n              be provided when this form is used, this configuration can be\n              specified via command-line options or the <ref table=\"SSL\"/> table.\n            </p>\n            <p>\n              If <var>port</var> is not specified, it defaults to 6640.\n            </p>\n            <p>\n              SSL support is an optional feature that is not always\n              built as part of Open vSwitch.\n            </p>\n          </dd>\n\n          <dt><code>tcp:<var>host</var></code>[<code>:<var>port</var></code>]</dt>\n          <dd>\n            <p>\n              The specified TCP <var>port</var> on the host at the given\n              <var>host</var>, which can either be a DNS name (if built with\n              unbound library) or an IP address.  If <var>host</var> is an IPv6\n              address, wrap it in square brackets, e.g. <code>tcp:[::1]:6640</code>.\n            </p>\n            <p>\n              If <var>port</var> is not specified, it defaults to 6640.\n            </p>\n          </dd>\n          <dt><code>pssl:</code>[<var>port</var>][<code>:<var>host</var></code>]</dt>\n          <dd>\n            <p>\n              Listens for SSL connections on the specified TCP <var>port</var>.\n              Specify 0 for <var>port</var> to have the kernel automatically\n              choose an available port.  If <var>host</var>, which can either\n              be a DNS name (if built with unbound library) or an IP address,\n              is specified, then connections are restricted to the resolved or\n              specified local IPaddress (either IPv4 or IPv6 address).  If\n              <var>host</var> is an IPv6 address, wrap in square brackets,\n              e.g. <code>pssl:6640:[::1]</code>.  If <var>host</var> is not\n              specified then it listens only on IPv4 (but not IPv6) addresses.\n              A valid SSL configuration must be provided when this form is used,\n             this can be specified either via command-line options or the\n             <ref table=\"SSL\"/> table.\n            </p>\n            <p>\n              If <var>port</var> is not specified, it defaults to 6640.\n            </p>\n            <p>\n              SSL support is an optional feature that is not always built as\n              part of Open vSwitch.\n            </p>\n          </dd>\n          <dt><code>ptcp:</code>[<var>port</var>][<code>:<var>host</var></code>]</dt>\n          <dd>\n            <p>\n              Listens for connections on the specified TCP <var>port</var>.\n              Specify 0 for <var>port</var> to have the kernel automatically\n              choose an available port.  If <var>host</var>, which can either\n              be a DNS name (if built with unbound library) or an IP address,\n              is specified, then connections are restricted to the resolved or\n              specified local IP address (either IPv4 or IPv6 address).  If\n              <var>host</var> is an IPv6 address, wrap it in square brackets,\n              e.g. <code>ptcp:6640:[::1]</code>.  If <var>host</var> is not\n              specified then it listens only on IPv4 addresses.\n            </p>\n            <p>\n              If <var>port</var> is not specified, it defaults to 6640.\n            </p>\n          </dd>\n        </dl>\n        <p>When multiple clients are configured, the <ref column=\"target\"/>\n        values must be unique.  Duplicate <ref column=\"target\"/> values yield\n        unspecified results.</p>\n      </column>\n    </group>\n\n    <group title=\"Client Failure Detection and Handling\">\n      <column name=\"max_backoff\">\n        Maximum number of milliseconds to wait between connection attempts.\n        Default is implementation-specific.\n      </column>\n\n      <column name=\"inactivity_probe\">\n        Maximum number of milliseconds of idle time on connection to the client\n        before sending an inactivity probe message.  If Open vSwitch does not\n        communicate with the client for the specified number of seconds, it\n        will send a probe.  If a response is not received for the same\n        additional amount of time, Open vSwitch assumes the connection has been\n        broken and attempts to reconnect.  Default is implementation-specific.\n        A value of 0 disables inactivity probes.\n      </column>\n    </group>\n\n    <group title=\"Status\">\n      <p>\n        Key-value pair of <ref column=\"is_connected\"/> is always updated.\n        Other key-value pairs in the status columns may be updated depends\n        on the <ref column=\"target\"/> type.\n      </p>\n\n      <p>\n        When <ref column=\"target\"/> specifies a connection method that\n        listens for inbound connections (e.g. <code>ptcp:</code> or\n        <code>punix:</code>), both <ref column=\"n_connections\"/> and\n        <ref column=\"is_connected\"/> may also be updated while the\n        remaining key-value pairs are omitted.\n      </p>\n\n      <p>\n        On the other hand, when <ref column=\"target\"/> specifies an\n        outbound connection, all key-value pairs may be updated, except\n        the above-mentioned two key-value pairs associated with inbound\n        connection targets. They are omitted.\n      </p>\n\n    <column name=\"is_connected\">\n        <code>true</code> if currently connected to this client,\n        <code>false</code> otherwise.\n      </column>\n\n      <column name=\"status\" key=\"last_error\">\n        A human-readable description of the last error on the connection\n        to the manager; i.e. <code>strerror(errno)</code>.  This key\n        will exist only if an error has occurred.\n      </column>\n\n      <column name=\"status\" key=\"state\"\n              type='{\"type\": \"string\", \"enum\": [\"set\", [\"VOID\", \"BACKOFF\", \"CONNECTING\", \"ACTIVE\", \"IDLE\"]]}'>\n        <p>\n          The state of the connection to the manager:\n        </p>\n        <dl>\n          <dt><code>VOID</code></dt>\n          <dd>Connection is disabled.</dd>\n\n          <dt><code>BACKOFF</code></dt>\n          <dd>Attempting to reconnect at an increasing period.</dd>\n\n          <dt><code>CONNECTING</code></dt>\n          <dd>Attempting to connect.</dd>\n\n          <dt><code>ACTIVE</code></dt>\n          <dd>Connected, remote host responsive.</dd>\n\n          <dt><code>IDLE</code></dt>\n          <dd>Connection is idle.  Waiting for response to keep-alive.</dd>\n        </dl>\n        <p>\n          These values may change in the future.  They are provided only for\n          human consumption.\n        </p>\n      </column>\n\n      <column name=\"status\" key=\"sec_since_connect\"\n              type='{\"type\": \"integer\", \"minInteger\": 0}'>\n        The amount of time since this client last successfully connected\n        to the database (in seconds). Value is empty if client has never\n        successfully been connected.\n      </column>\n\n      <column name=\"status\" key=\"sec_since_disconnect\"\n              type='{\"type\": \"integer\", \"minInteger\": 0}'>\n        The amount of time since this client last disconnected from the\n        database (in seconds). Value is empty if client has never\n        disconnected.\n      </column>\n\n      <column name=\"status\" key=\"locks_held\">\n        Space-separated list of the names of OVSDB locks that the connection\n        holds.  Omitted if the connection does not hold any locks.\n      </column>\n\n      <column name=\"status\" key=\"locks_waiting\">\n        Space-separated list of the names of OVSDB locks that the connection is\n        currently waiting to acquire.  Omitted if the connection is not waiting\n        for any locks.\n      </column>\n\n      <column name=\"status\" key=\"locks_lost\">\n        Space-separated list of the names of OVSDB locks that the connection\n        has had stolen by another OVSDB client.  Omitted if no locks have been\n        stolen from this connection.\n      </column>\n\n      <column name=\"status\" key=\"n_connections\"\n              type='{\"type\": \"integer\", \"minInteger\": 2}'>\n        When <ref column=\"target\"/> specifies a connection method that\n        listens for inbound connections (e.g. <code>ptcp:</code> or\n        <code>pssl:</code>) and more than one connection is actually active,\n        the value is the number of active connections.  Otherwise, this\n        key-value pair is omitted.\n      </column>\n\n      <column name=\"status\" key=\"bound_port\" type='{\"type\": \"integer\"}'>\n        When <ref column=\"target\"/> is <code>ptcp:</code> or\n        <code>pssl:</code>, this is the TCP port on which the OVSDB server is\n        listening.  (This is particularly useful when <ref\n        column=\"target\"/> specifies a port of 0, allowing the kernel to\n        choose any available port.)\n      </column>\n    </group>\n\n    <group title=\"Common Columns\">\n      The overall purpose of these columns is described under <code>Common\n      Columns</code> at the beginning of this document.\n\n      <column name=\"external_ids\"/>\n      <column name=\"other_config\"/>\n    </group>\n  </table>\n  <table name=\"DNS\" title=\"Native DNS resolution\">\n    <p>\n      Each row in this table stores the DNS records. The\n      <ref table=\"Logical_Switch\"/> table's <ref table=\"Logical_Switch\"\n      column=\"dns_records\"/> references these records.\n    </p>\n\n    <column name=\"records\">\n      Key-value pair of DNS records with <code>DNS query name</code> as the key\n      and value as a string of IP address(es) separated by comma or space.\n\n      For PTR requests, the key-value pair can be\n      <code>Reverse IPv4 address.in-addr.arpa</code> and the value\n      <code>DNS domain name</code>.  For IPv6 addresses, the key\n      has to be <code>Reverse IPv6 address.ip6.arpa</code>.\n\n      <p><b>Example: </b> \"vm1.ovn.org\" = \"10.0.0.4 aef0::4\"</p>\n      <p><b>Example: </b> \"4.0.0.10.in-addr.arpa\" = \"vm1.ovn.org\"</p>\n    </column>\n\n    <column name=\"external_ids\">\n      See <em>External IDs</em> at the beginning of this document.\n    </column>\n  </table>\n  <table name=\"SSL\">\n    SSL configuration for ovn-nb database access.\n\n    <column name=\"private_key\">\n      Name of a PEM file containing the private key used as the switch's\n      identity for SSL connections to the controller.\n    </column>\n\n    <column name=\"certificate\">\n      Name of a PEM file containing a certificate, signed by the\n      certificate authority (CA) used by the controller and manager,\n      that certifies the switch's private key, identifying a trustworthy\n      switch.\n    </column>\n\n    <column name=\"ca_cert\">\n      Name of a PEM file containing the CA certificate used to verify\n      that the switch is connected to a trustworthy controller.\n    </column>\n\n    <column name=\"bootstrap_ca_cert\">\n      If set to <code>true</code>, then Open vSwitch will attempt to\n      obtain the CA certificate from the controller on its first SSL\n      connection and save it to the named PEM file. If it is successful,\n      it will immediately drop the connection and reconnect, and from then\n      on all SSL connections must be authenticated by a certificate signed\n      by the CA certificate thus obtained.  <em>This option exposes the\n      SSL connection to a man-in-the-middle attack obtaining the initial\n      CA certificate.</em>  It may still be useful for bootstrapping.\n    </column>\n\n    <column name=\"ssl_protocols\">\n      List of SSL protocols to be enabled for SSL connections. The default\n      when this option is omitted is <code>TLSv1,TLSv1.1,TLSv1.2</code>.\n    </column>\n\n    <column name=\"ssl_ciphers\">\n      List of ciphers (in OpenSSL cipher string format) to be supported\n      for SSL connections. The default when this option is omitted is\n      <code>HIGH:!aNULL:!MD5</code>.\n    </column>\n\n    <group title=\"Common Columns\">\n      The overall purpose of these columns is described under <code>Common\n      Columns</code> at the beginning of this document.\n\n      <column name=\"external_ids\"/>\n    </group>\n  </table>\n  <table name=\"Gateway_Chassis\">\n    <p>\n      Association of a chassis to a logical router port. The traffic\n      going out through an specific router port will be redirected to a\n      chassis, or a set of them in high availability configurations.\n    </p>\n\n    <column name=\"name\">\n      <p>\n        Name of the <ref table=\"Gateway_Chassis\"/>.\n      </p>\n      <p>\n        A suggested, but not required naming convention is\n        <code>${port_name}_${chassis_name}</code>.\n      </p>\n    </column>\n\n    <column name=\"chassis_name\">\n      <p>\n        Name of the chassis that we want to redirect traffic through for the\n        associated logical router port.  The value must match the\n        <ref db=\"OVN_Southbound\" table=\"Chassis\" column=\"name\"/> column\n        of the <ref db=\"OVN_Southbound\" table=\"Chassis\"/> table in the\n        <ref db=\"OVN_Southbound\"/> database.\n      </p>\n    </column>\n\n    <column name=\"priority\">\n      <p>\n        This is the priority of a chassis among all\n        <ref table=\"Gateway_Chassis\"/> belonging to the same logical router\n        port.\n      </p>\n    </column>\n\n    <column name=\"options\">\n      Reserved for future use.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"HA_Chassis_Group\">\n    <p>\n      Table representing a group of chassis which can provide high availability\n      services. Each chassis in the group is represented by the table\n      <ref table=\"HA_Chassis\"/>. The HA chassis with highest priority will\n      be the master of this group. If the master chassis failover is detected,\n      the HA chassis with the next higher priority takes over the\n      responsibility of providing the HA. If a distributed gateway router port\n      references a row in this table, then the master HA chassis in this group\n      provides the gateway functionality.\n    </p>\n\n    <column name=\"name\">\n      Name of the <ref table=\"HA_Chassis_Group\"/>. Name should be unique.\n    </column>\n\n    <column name=\"ha_chassis\">\n      A list of HA chassis which belongs to this group.\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"HA_Chassis\">\n    <column name=\"chassis_name\">\n      <p>\n        Name of the chassis which is part of the HA chassis group.\n        The value must match the\n        <ref db=\"OVN_Southbound\" table=\"Chassis\" column=\"name\"/> column\n        of the <ref db=\"OVN_Southbound\" table=\"Chassis\"/> table in the\n        <ref db=\"OVN_Southbound\"/> database.\n      </p>\n    </column>\n\n    <column name=\"priority\">\n      <p>\n        Priority of the chassis. Chassis with highest priority will be\n        the master.\n      </p>\n    </column>\n\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"BFD\">\n    <p>\n      Contains BFD parameter for ovn-controller BFD configuration.\n      OVN BFD implementation is used to provide detection of failures in the\n      path between adjacent forwarding engines, including the OVN interfaces.\n      OVN BFD provides link status info to OVN northd in order to update\n      logical flows according to the status of BFD endpoints. In the current\n      implementation OVN BFD is used to check next-hop status for ECMP routes.\n      Please note BFD table refers to OVN BFD implementation and not to OVS\n      legacy one.\n    </p>\n\n    <group title=\"Configuration\">\n      <p>\n        <code>ovn-northd</code> reads configuration from these columns.\n      </p>\n\n      <column name=\"logical_port\">\n        OVN logical port when BFD engine is running.\n      </column>\n\n      <column name=\"dst_ip\">\n        BFD peer IP address.\n      </column>\n\n      <column name=\"min_tx\">\n        This is the minimum interval, in milliseconds, that the local\n        system would like to use when transmitting BFD Control packets,\n        less any jitter applied. The value zero is reserved. Default\n        value is 1000 ms.\n      </column>\n\n      <column name=\"min_rx\">\n        This is the minimum interval, in milliseconds, between received\n        BFD Control packets that this system is capable of supporting,\n        less any jitter applied by the sender. If this value is zero,\n        the transmitting system does not want the remote system to send\n        any periodic BFD Control packets.\n      </column>\n\n      <column name=\"detect_mult\">\n        Detection time multiplier.  The negotiated transmit interval,\n        multiplied by this value, provides the Detection Time for the\n        receiving system in Asynchronous mode. Default value is 5.\n      </column>\n\n      <column name=\"options\">\n        Reserved for future use.\n      </column>\n\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n\n    <group title=\"Status Reporting\">\n      <p>\n        <code>ovn-northd</code> writes BFD status into these columns.\n      </p>\n\n      <column name=\"status\">\n        <p>\n          BFD port logical states. Possible values are:\n          <ul>\n            <li>\n              <code>admin_down</code>\n            </li>\n            <li>\n              <code>down</code>\n            </li>\n            <li>\n              <code>init</code>\n            </li>\n            <li>\n              <code>up</code>\n            </li>\n          </ul>\n        </p>\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Static_MAC_Binding\">\n    <p>\n      Each record represents a Static_MAC_Binding entry for a logical router.\n    </p>\n\n    <group title=\"Configuration\">\n      <p>\n        <code>ovn-northd</code> reads configuration from these columns\n        and propagates the value to SBDB.\n      </p>\n\n      <column name=\"logical_port\">\n        The logical router port for the binding.\n      </column>\n\n      <column name=\"ip\">\n        The bound IP address.\n      </column>\n\n      <column name=\"mac\">\n        The Ethernet address to which the IP is bound.\n      </column>\n\n      <column name=\"override_dynamic_mac\">\n        Override dynamically learnt MACs.\n      </column>\n    </group>\n  </table>\n\n  <table name=\"Chassis_Template_Var\">\n    <p>\n      One record per chassis, each containing a map, <code>variables</code>,\n      between template variable names and their value for that specific\n      chassis.  A template variable has a name and potentially different\n      values on different hypervisors in the OVN cluster.  For example,\n      two rows, <code>R1 = (.chassis=C1, variables={(N: V1)}</code> and\n      <code>R2 = (.chassis=C2, variables={(N: V2)}</code> will make\n      <code>ovn-controller</code> running on chassis <code>C1</code> and\n      <code>C2</code> interpret the token <code>N</code> either as\n      <code>V1</code> (on <code>C1</code>) or as <code>V2</code> (on\n      <code>C2</code>).  Users can refer to template variables from\n      within other logical components, e.g., within ACL, QoS or\n      Logical_Router_Policy matches or from Load_Balancer VIP and\n      backend definitions.\n    </p>\n    <p>\n      If a template variable is referenced on a chassis for which that\n      variable is not defined then <code>ovn-controller</code> running\n      on that chassis will just interpret it as a raw string literal.\n    </p>\n    <column name=\"chassis\">\n      The chassis this set of variable values applies to.\n    </column>\n    <column name=\"variables\">\n      The set of variable values for a given chassis.\n    </column>\n    <group title=\"Common Columns\">\n      <column name=\"external_ids\">\n        See <em>External IDs</em> at the beginning of this document.\n      </column>\n    </group>\n  </table>\n</database>\n", "AT_BANNER([OVN northd])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check from NBDB to SBDB])\novn_start\n\novn-nbctl create Logical_Router name=R1\novn-sbctl chassis-add gw1 geneve 127.0.0.1\novn-sbctl chassis-add gw2 geneve 1.2.4.8\n\n# Connect alice to R1 as distributed router gateway port on hv2\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24\n\novn-nbctl --wait=sb \\\n    --id=@gc0 create Gateway_Chassis name=alice_gw1 \\\n                                     chassis_name=gw1 \\\n                                     priority=20 -- \\\n    --id=@gc1 create Gateway_Chassis name=alice_gw2 \\\n                                     chassis_name=gw2 \\\n                                     priority=10 -- \\\n    set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]'\n\nnb_gwc1_uuid=`ovn-nbctl --bare --columns _uuid find Gateway_Chassis name=\"alice_gw1\"`\n\n# With the new ha_chassis_group table added, there should be no rows in\n# gateway_chassis table in SB DB.\ncheck_row_count Gateway_Chassis 0\n\n# There should be one ha_chassis_group with the name \"alice\"\ncheck_row_count HA_Chassis_Group 1 name=alice\nha_chgrp_uuid=$(fetch_column HA_Chassis_Group _uuid name=alice)\ncheck_row_count Port_Binding 1 logical_port=cr-alice ha_chassis_group=$ha_chgrp_uuid\n\nha_ch=$(fetch_column HA_Chassis_Group ha_chassis name=alice)\ncheck_column \"$ha_ch\" HA_Chassis _uuid\n\novn-sbctl list ha_chassis_group\n\n# Delete chassis - gw2 in SB DB.\n# ovn-northd should not recreate ha_chassis rows\n# repeatedly when gw2 is deleted.\novn-sbctl chassis-del gw2\n\nha_ch_list=$(fetch_column HA_Chassis _uuid)\ncheck_column \"$ha_ch_list\" HA_Chassis _uuid\n\n# Add back the gw2 chassis\novn-sbctl chassis-add gw2 geneve 1.2.4.8\n\n# delete the 2nd Gateway_Chassis on NBDB for alice port\ncheck_column '' Port_Binding gateway_chassis logical_port=cr-alice\n\nha_ch=$(fetch_column HA_Chassis_Group ha_chassis)\ncheck_column \"$ha_ch\" HA_Chassis _uuid\n\n# delete the 2nd Gateway_Chassis on NBDB for alice port\novn-nbctl --wait=sb set Logical_Router_Port alice gateway_chassis=${nb_gwc1_uuid}\n\n# There should be only 1 row in ha_chassis SB DB table.\ncheck_row_count HA_Chassis 1\ncheck_row_count Gateway_Chassis 0\n\n# delete all the gateway_chassis on NBDB for alice port\novn-nbctl --wait=sb clear Logical_Router_Port alice gateway_chassis\n\n# expect that the ha_chassis doesn't exist anymore\ncheck_row_count HA_Chassis 0\ncheck_row_count Gateway_Chassis 0\ncheck_row_count Ha_Chassis_Group 0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check up state of VIF LSP])\novn_start\n\novn-nbctl ls-add S1\novn-nbctl --wait=sb lsp-add S1 S1-vm1\nwait_row_count nb:Logical_Switch_Port 1 name=S1-vm1 'up!=true'\n\novn-sbctl chassis-add hv1 geneve 127.0.0.1\novn-sbctl lsp-bind S1-vm1 hv1\nwait_row_count nb:Logical_Switch_Port 1 name=S1-vm1 'up=true'\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check up state of router LSP linked to a distributed LR])\novn_start\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01\novn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1\nAT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check up state of router LSP linked to a gateway LR])\novn_start\n\novn-sbctl chassis-add gw1 geneve 127.0.0.1\n\novn-nbctl create Logical_Router name=R1 options:chassis=gw1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01\novn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1\n\novn-sbctl lsp-bind S1-R1 gw1\nAT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check up state of router LSP linked to an LRP with set Gateway Chassis])\novn_start\n\novn-sbctl chassis-add gw1 geneve 127.0.0.1\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\novn-nbctl lrp-set-gateway-chassis R1-S1 gw1\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 router\novn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1\nAT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check LRP external id propagation to SBDB])\novn_start\n\novn-nbctl lr-add ro\novn-nbctl lrp-add ro lrp0 00:00:00:00:00:01 192.168.1.1/24\novn-nbctl --wait=sb set logical_router_port lrp0 external_ids=test=123\ncheck_column \"test=123\" sb:Port_Binding external_ids logical_port=lrp0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check IPv6 RA config propagation to SBDB])\novn_start\n\novn-nbctl lr-add ro\novn-nbctl lrp-add ro ro-sw 00:00:00:00:00:01 aef0:0:0:0:0:0:0:1/64\novn-nbctl ls-add sw\novn-nbctl lsp-add sw sw-ro\novn-nbctl lsp-set-type sw-ro router\novn-nbctl lsp-set-options sw-ro router-port=ro-sw\novn-nbctl lsp-set-addresses sw-ro 00:00:00:00:00:01\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:send_periodic=true\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=slaac\novn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:mtu=1280\n\nuuid=$(ovn-sbctl --columns=_uuid --bare find Port_Binding logical_port=ro-sw)\n\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_send_periodic],\n[0], [\"true\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_address_mode],\n[0], [slaac\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[0], [\"600\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[0], [\"200\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_mtu],\n[0], [\"1280\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_eth],\n[0], [\"00:00:00:00:00:01\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_addr],\n[0], [\"fe80::200:ff:fe00:1\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_prefixes],\n[0], [\"aef0::/64\"\n])\n\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=300\novn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=600\n\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[0], [\"300\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[0], [\"225\"\n])\n\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=300\novn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=250\n\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[0], [\"300\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[0], [\"225\"\n])\n\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=0\novn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=0\n\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[0], [\"4\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[0], [\"3\"\n])\n\novn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=3600\novn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=2400\n\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[0], [\"1800\"\n])\nAT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[0], [\"1350\"\n])\n\novn-nbctl --wait=sb set Logical_Router_port ro-sw ipv6_ra_configs:send_periodic=false\n\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_send_periodic],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_send_periodic\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_max_interval\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_min_interval\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_mtu],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_mtu\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_address_mode],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_address_mode\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_eth],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_src_eth\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_addr],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_src_addr\" in Port_Binding record \"${uuid}\" column options\n])\nAT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_prefixes],\n[1], [], [ovn-sbctl: no key \"ipv6_ra_prefixes\" in Port_Binding record \"${uuid}\" column options\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([test unixctl])\novn_init_db ovn-sb; ovn-sbctl init\novn_init_db ovn-nb; ovn-nbctl init\n\n# test unixctl option\nmkdir \"$ovs_base\"/northd\nas northd start_daemon NORTHD_TYPE --unixctl=\"$ovs_base\"/northd/NORTHD_TYPE[].ctl --ovnnb-db=unix:\"$ovs_base\"/ovn-nb/ovn-nb.sock --ovnsb-db=unix:\"$ovs_base\"/ovn-sb/ovn-sb.sock\novn-nbctl ls-add sw\novn-nbctl --wait=sb lsp-add sw p1\n# northd created with unixctl option successfully created port_binding entry\ncheck_row_count Port_Binding 1 logical_port=p1\nAT_CHECK([ovn-nbctl --wait=sb lsp-del p1])\n\n# ovs-appctl exit with unixctl option\nOVS_APP_EXIT_AND_WAIT_BY_TARGET([\"$ovs_base\"/northd/]NORTHD_TYPE[.ctl], [\"$ovs_base\"/northd/]NORTHD_TYPE[.pid])\n\n# Check no port_binding entry for new port as ovn-northd is not running\n#\n# 142 is 128+14, the exit status that the shell reports when a\n# process exits due to SIGARLM (signal 14).\novn-nbctl lsp-add sw p2\nAT_CHECK([ovn-nbctl --timeout=10 --wait=sb sync], [142], [], [ignore])\ncheck_row_count Port_Binding 0 logical_port=p2\n\n# test default unixctl path\nas northd start_daemon NORTHD_TYPE --ovnnb-db=unix:\"$ovs_base\"/ovn-nb/ovn-nb.sock --ovnsb-db=unix:\"$ovs_base\"/ovn-sb/ovn-sb.sock\novn-nbctl --wait=sb lsp-add sw p3\n# northd created with default unixctl path successfully created port_binding entry\ncheck_row_count Port_Binding 1 logical_port=p3\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check HA_Chassis_Group propagation from NBDB to SBDB])\novn_start\n\ncheck ovn-nbctl --wait=sb ha-chassis-group-add hagrp1\n\n# ovn-northd should not create HA chassis group and HA chassis rows\n# unless the HA chassis group in OVN NB DB is associated to\n# a logical router port or logical port of type external.\ncheck_row_count HA_Chassis_Group 0 name=hagrp1\n\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 30\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 20\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch3 10\n\n# There should be no HA_Chassis rows in SB DB.\ncheck_row_count HA_Chassis 0\n\n# Add chassis ch1.\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.2\n\nwait_row_count Chassis 1 name=ch1\n\n# There should be no HA_Chassis rows\ncheck_row_count HA_Chassis 0\n\n# Create a logical router port and attach ha chassis group.\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl --wait=sb lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24\n\nhagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp1`\necho \"hagrp1_uuid=$hagrp1_uuid\"\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-public ha_chassis_group=$hagrp1_uuid\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\n\ncheck_row_count HA_Chassis 3\n\n# ovn-northd has a weird history regarding HA_Chassis and missing\n# Chassis records, see commit f879850b5f2c (\"ovn-northd: Fix the\n# HA_Chassis sync issue in OVN SB DB\").\n#\n# Make sure that ovn-northd doesn't recreate the ha_chassis\n# records if the chassis record is missing in SB DB.\nha_ch_list=$(fetch_column HA_Chassis _uuid)\ncheck_column \"$ha_ch_list\" HA_Chassis _uuid\n\n# 2 HA chassis should be created with 'chassis' column empty because\n# we have not added hv1 and hv2 chassis to the SB DB.\ncheck_row_count HA_Chassis 2 'chassis=[[]]'\n\n# We should have 1 ha chassis with 'chassis' column set for hv1\ncheck_row_count HA_Chassis 1 'chassis!=[[]]'\n\n# Create another logical router port and associate to the same ha_chasis_group\ncheck ovn-nbctl lr-add lr1\ncheck ovn-nbctl lrp-add lr1 lr1-public 00:00:20:20:12:14 182.168.0.100/24\n\ncheck ovn-nbctl set logical_router_port lr1-public ha_chassis_group=$hagrp1_uuid\n\n# We should still have 1 HA chassis group and 3 HA chassis in SB DB.\nwait_row_count HA_Chassis_Group 1 name=hagrp1\ncheck_row_count HA_Chassis 3\n\n# Change the priority of ch1 - ha chassis in NB DB. It should get\n# reflected in SB DB.\novn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 100\n\nwait_row_count HA_Chassis 1 priority=100\n\n# Delete ch1 HA chassis in NB DB.\novn-nbctl --wait=sb ha-chassis-group-remove-chassis hagrp1 ch1\n\nwait_row_count HA_Chassis 2\n\n# Add back the ha chassis\novn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 40\nwait_row_count HA_Chassis 3\n\n# Delete lr0-public. We should still have 1 HA chassis group and\n# 3 HA chassis in SB DB.\novn-nbctl --wait=sb lrp-del lr0-public\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\nwait_row_count HA_Chassis 3\n\n# Delete lr1-public. There should be no HA chassis group in SB DB.\novn-nbctl --wait=sb lrp-del lr1-public\n\nwait_row_count HA_Chassis_Group 0 name=hagrp1\nwait_row_count HA_Chassis 0\n\n# Add lr0-public again\novn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24\novn-nbctl set logical_router_port lr0-public ha_chassis_group=$hagrp1_uuid\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\nwait_row_count HA_Chassis 3\n\n# Create a Gateway chassis. ovn-northd should ignore this.\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis lr0-public ch1 20\n\n# There should be only 1 HA chassis group in SB DB with the\n# name hagrp1.\nwait_row_count HA_Chassis_Group 1\nwait_row_count HA_Chassis_Group 1 name=hagrp1\nwait_row_count HA_Chassis 3\n\n# Now delete HA chassis group. ovn-northd should create HA chassis group\n# with the Gateway chassis name\novn-nbctl clear logical_router_port lr0-public ha_chassis_group\novn-nbctl ha-chassis-group-del hagrp1\n\nwait_row_count HA_Chassis_Group 0 name=hagrp1\nwait_row_count HA_Chassis_Group 1 name=lr0-public\nwait_row_count HA_Chassis 1\n\novn-nbctl lrp-set-gateway-chassis lr0-public ch2 10\n\nwait_row_count HA_Chassis_Group 1 name=lr0-public\n\novn-sbctl --bare --columns _uuid find ha_chassis\nwait_row_count HA_Chassis 2\n\n# Test if 'ref_chassis' column is properly set or not in\n# SB DB ha_chassis_group.\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1\n\ncheck ovn-sbctl chassis-add ch2 geneve 127.0.0.3\ncheck ovn-sbctl chassis-add ch3 geneve 127.0.0.4\ncheck ovn-sbctl chassis-add comp1 geneve 127.0.0.5\ncheck ovn-sbctl chassis-add comp2 geneve 127.0.0.6\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:20:20:12:14 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw0-lr0 router-port=lr0-sw0\n\novn-sbctl lsp-bind sw0-p1 comp1\nwait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 up=true\n\ncomp1_ch_uuid=$(fetch_column Chassis _uuid name=comp1)\ncomp2_ch_uuid=$(fetch_column Chassis _uuid name=comp2)\nch2_ch_uuid=$comp1_ch_uuid\n\n# Check ref_chassis.\necho \"comp1_ch_uuid = $comp1_ch_uuid\"\nwait_column \"$comp1_ch_uuid\" HA_Chassis_Group ref_chassis\n\n# unbind sw0-p1\novn-sbctl lsp-unbind sw0-p1\nwait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 up=false\nwait_column \"\" HA_Chassis_Group ref_chassis\n\n# Bind sw0-p1 in comp2\novn-sbctl lsp-bind sw0-p1 comp2\nwait_column \"$comp2_ch_uuid\" HA_Chassis_Group ref_chassis\n\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-p1\novn-nbctl lr-add lr1\novn-nbctl lrp-add lr1 lr1-sw1 00:00:20:20:12:15 20.0.0.1/24\novn-nbctl lsp-add sw1 sw1-lr1\novn-nbctl lsp-set-type sw1-lr1 router\novn-nbctl lsp-set-addresses sw1-lr1 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw1-lr1 router-port=lr1-sw1\n\n# Bind sw1-p1 in comp1.\ncheck ovn-sbctl lsp-bind sw1-p1 comp1\n# Wait until sw1-p1 is up\nwait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 up=true\n\n# sw1-p1 is not connected to lr0. So comp1 should not be in 'ref_chassis'\nwait_column \"$comp2_ch_uuid\" HA_Chassis_Group ref_chassis\n\n# Now attach sw0 to lr1\ncheck ovn-nbctl lrp-add lr1 lr1-sw0 00:00:20:20:12:16 10.0.0.10/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr1\ncheck ovn-nbctl lsp-set-type sw0-lr1 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr1 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw0-lr1 router-port=lr1-sw0\n\n# Both comp1 and comp2 should be in 'ref_chassis' as sw1 is indirectly\n# connected to lr0\nexp_ref_ch_list=\"$comp1_ch_uuid $comp2_ch_uuid\"\n\nwait_column \"$exp_ref_ch_list\" HA_Chassis_Group ref_chassis\n\n# Unind sw1-p1. comp2 should not be in the ref_chassis.\novn-sbctl lsp-unbind sw1-p1\nwait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 up=false\nwait_column \"$comp2_ch_uuid\" HA_Chassis_Group ref_chassis\n\n# Create sw2 and attach it to lr2\ncheck ovn-nbctl ls-add sw2\ncheck ovn-nbctl lsp-add sw2 sw2-p1\ncheck ovn-nbctl lr-add lr2\ncheck ovn-nbctl lrp-add lr2 lr2-sw2 00:00:20:20:12:17 30.0.0.1/24\ncheck ovn-nbctl lsp-add sw2 sw2-lr2\ncheck ovn-nbctl lsp-set-type sw2-lr2 router\ncheck ovn-nbctl lsp-set-addresses sw2-lr2 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw2-lr2 router-port=lr2-sw2\n\n# Bind sw2-p1 to comp1\ncheck ovn-sbctl lsp-bind sw2-p1 comp1\n# Wait until sw2-p1 is up\nwait_row_count nb:Logical_Switch_Port 1 name=sw2-p1 up=true\n\n# sw2-p1 is not connected to lr0. So comp1 should not be in 'ref_chassis'\nwait_column \"$comp2_ch_uuid\" HA_Chassis_Group ref_chassis\n\n# Now attach sw1 to lr2. With this sw2-p1 is indirectly connected to lr0.\ncheck ovn-nbctl lrp-add lr2 lr2-sw1 00:00:20:20:12:18 20.0.0.10/24\ncheck ovn-nbctl lsp-add sw1 sw1-lr2\ncheck ovn-nbctl lsp-set-type sw1-lr2 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr2 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw1-lr2 router-port=lr2-sw1\n\n# sw2-p1 is indirectly connected to lr0. So comp1 (and comp2) should be in\n# 'ref_chassis'\nwait_column \"$exp_ref_ch_list\" HA_Chassis_Group ref_chassis\n\n# Create sw0-p2 and bind it to comp1\ncheck ovn-nbctl --wait=sb lsp-add sw0 sw0-p2\novn-sbctl lsp-bind sw0-p2 comp1\nwait_row_count nb:Logical_Switch_Port 1 name=sw0-p2 up=true\nwait_column \"$exp_ref_ch_list\" HA_Chassis_Group ref_chassis\n\n# unbind sw0-p2\novn-sbctl lsp-unbind sw0-p2\nwait_row_count nb:Logical_Switch_Port 1 name=sw0-p2 up=false\nwait_column \"$exp_ref_ch_list\" HA_Chassis_Group ref_chassis\n\n# Delete lr1-sw0. comp1 should be deleted from ref_chassis as there is no link\n# from sw1 and sw2 to lr0.\ncheck ovn-nbctl lrp-del lr1-sw0\n\nwait_column \"$comp2_ch_uuid\" HA_Chassis_Group ref_chassis\n\n# Delete one of the gateway chassises making the ha_chassis_group has only one\n# chassis. In this case ref_chassis field should be empty for this\n# ha_chassis_group. (ref_chassis is calculated only if there are more than 1\n# chassises in the ha_chassis_group.\ncheck ovn-nbctl --wait=sb lrp-del-gateway-chassis lr0-public ch2\nwait_column \"\" HA_Chassis_Group ref_chassis\n\n# Set redirect-chassis option to lr0-public. It should be ignored\n# (because redirect-chassis is obsolete).\ncheck ovn-nbctl set logical_router_port lr0-public options:redirect-chassis=ch1\n\nwait_row_count HA_Chassis_Group 1\nwait_row_count HA_Chassis_Group 1 name=lr0-public\n\nwait_row_count HA_Chassis 1\n\n# Delete the gateway chassis.\ncheck ovn-nbctl clear logical_router_port lr0-public gateway_chassis\n\nwait_row_count HA_Chassis_Group 0\ncheck_row_count HA_Chassis 0\n\n# Delete old sw0.\ncheck ovn-nbctl --wait=sb ls-del sw0\n\n# Create external logical ports and associate ha_chassis_group\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-pext1\ncheck ovn-nbctl lsp-add sw0 sw0-pext2\ncheck ovn-nbctl lsp-add sw0 sw0-p1\n\ncheck ovn-nbctl lsp-set-addresses sw0-pext1 \"00:00:00:00:00:03 10.0.0.3\"\ncheck ovn-nbctl lsp-set-addresses sw0-pext2 \"00:00:00:00:00:03 10.0.0.4\"\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"00:00:00:00:00:03 10.0.0.5\"\n\ncheck ovn-nbctl --wait=sb ha-chassis-group-add hagrp1\n\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 30\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 20\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch3 10\n\n# ovn-northd should not create HA chassis group and HA chassis rows\n# unless the HA chassis group in OVN NB DB is associated to\n# a logical router port or logical port of type external.\nwait_row_count HA_Chassis_Group 0\ncheck_row_count HA_Chassis 0\n\nhagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group \\\nname=hagrp1`\n\n# The type of the lsp - sw0-pext1 is still not set to external.\n# So ha_chassis_group should be ignored.\novn-nbctl set logical_switch_port sw0-pext1 ha_chassis_group=$hagrp1_uuid\n\nwait_row_count HA_Chassis_Group 0 name=hagrp1\ncheck_row_count HA_Chassis 0\n\n# Set the type of sw0-pext1 to external\novn-nbctl lsp-set-type sw0-pext1 external\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\ncheck_row_count HA_Chassis 3\n\nsb_hagrp1_uuid=`ovn-sbctl --bare --columns _uuid find ha_chassis_group \\\nname=hagrp1`\n\ncheck_row_count Port_Binding 1 logical_port=sw0-pext1 ha_chassis_group=$sb_hagrp1_uuid\n\n# Set the type of sw0-pext2 to external and associate ha_chassis_group\novn-nbctl lsp-set-type sw0-pext2 external\novn-nbctl set logical_switch_port sw0-pext2 ha_chassis_group=$hagrp1_uuid\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\ncheck_row_count HA_Chassis 3\ncheck_row_count Port_Binding 1 logical_port=sw0-pext1 ha_chassis_group=$sb_hagrp1_uuid\nwait_row_count Port_Binding 1 logical_port=sw0-pext2 ha_chassis_group=$sb_hagrp1_uuid\n\n# sw0-p1 is a normal port. So ha_chassis_group should not be set\n# in port_binding.\novn-nbctl --wait=sb set logical_switch_port sw0-p1 \\\nha_chassis_group=$hagrp1_uuid\n\nwait_row_count Port_Binding 0 logical_port=sw0-p1 'chassis!=[[]]'\n\n# Clear ha_chassis_group for sw0-pext1\ncheck ovn-nbctl --wait=sb clear logical_switch_port sw0-pext1 ha_chassis_group\n\nwait_row_count Port_Binding 0 logical_port=sw0-pext1 'chassis!=[[]]'\n\nwait_row_count HA_Chassis_Group 1 name=hagrp1\nwait_row_count HA_Chassis 3\n\nAS_BOX([Clear ha_chassis_group for sw0-pext2 and reset port type to normal in the same txn])\n\ncheck ovn-nbctl  --wait=sb clear logical_switch_port sw0-pext2 \\\nha_chassis_group -- set logical_switch_port sw0-pext2 'type=\"\"'\nwait_row_count HA_Chassis_Group 0\nwait_row_count Port_Binding 0 logical_port=sw0-pext2 'chassis!=[[]]'\ncheck_row_count HA_Chassis 0\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd pause and resume])\n# By starting the backup northd paused, we ensure that the primary\n# northd is active; otherwise, there's a race.  (We also test that\n# the ovn-northd --dry-run option works.)\novn_start --backup-northd=paused\n\nget_northd_status() {\n    as northd ovn-appctl -t NORTHD_TYPE is-paused\n    as northd ovn-appctl -t NORTHD_TYPE status\n    as northd-backup ovn-appctl -t NORTHD_TYPE is-paused\n    as northd-backup ovn-appctl -t NORTHD_TYPE status\n}\n\nAS_BOX([Check that the backup is paused])\nOVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false\nStatus: active\ntrue\nStatus: paused\n])\n\nAS_BOX([Resume the backup])\ncheck as northd-backup ovs-appctl -t NORTHD_TYPE resume\nOVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false\nStatus: active\nfalse\nStatus: standby\n])\n\nAS_BOX([Check that ovn-northd is active])\n# Check that ovn-northd is active, by verifying that it creates and\n# destroys southbound datapaths as one would expect.\ncheck_row_count Datapath_Binding 0\ncheck ovn-nbctl --wait=sb ls-add sw0\ncheck_row_count Datapath_Binding 1\ncheck ovn-nbctl --wait=sb ls-del sw0\ncheck_row_count Datapath_Binding 0\n\nAS_BOX([Pause the main northd])\ncheck as northd ovs-appctl -t NORTHD_TYPE pause\ncheck as northd-backup ovs-appctl -t NORTHD_TYPE pause\nAT_CHECK([get_northd_status], [0], [true\nStatus: paused\ntrue\nStatus: paused\n])\n\nAS_BOX([Verify that ovn-northd is paused])\n# Now ovn-northd won't respond by adding a datapath, because it's paused.\ncheck ovn-nbctl ls-add sw0\ncheck sleep 5\ncheck_row_count Datapath_Binding 0\n\n# Do not resume both main and backup right after each other\n# as there would be no guarentee of which one would become active\nAS_BOX([Resume the main northd])\ncheck as northd ovs-appctl -t NORTHD_TYPE resume\nOVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false\nStatus: active\ntrue\nStatus: paused\n])\n\nAS_BOX([Resume the backup northd])\ncheck as northd-backup ovs-appctl -t NORTHD_TYPE resume\nOVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false\nStatus: active\nfalse\nStatus: standby\n])\n\ncheck ovn-nbctl --wait=sb sync\ncheck_row_count Datapath_Binding 1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd restart])\novn_start --backup-northd=none\n\n# Check that ovn-northd is active, by verifying that it creates and\n# destroys southbound datapaths as one would expect.\ncheck_row_count Datapath_Binding 0\ncheck ovn-nbctl --wait=sb ls-add sw0\ncheck_row_count Datapath_Binding 1\n\n# Kill northd.\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\n# With ovn-northd gone, changes to nbdb won't be reflected into sbdb.\n# Make sure.\ncheck ovn-nbctl ls-add sw1\nsleep 5\ncheck_row_count Datapath_Binding 1\n\n# Now resume ovn-northd.  Changes should catch up.\novn_start_northd primary\nwait_row_count Datapath_Binding 2\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([northbound database reconnection])\n\novn_start --backup-northd=none\n\n# Check that ovn-northd is active, by verifying that it creates and\n# destroys southbound datapaths as one would expect.\ncheck_row_count Datapath_Binding 0\ncheck ovn-nbctl --wait=sb ls-add sw0\ncheck_row_count Datapath_Binding 1\ndp1=$(fetch_column Datapath_Binding _uuid external_ids:name=sw0)\n\n# Make nbdb ovsdb-server drop connection from ovn-northd.\nconn=$(as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/list-remotes|grep ^punix)\ncheck as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/remove-remote \"$conn\"\nconn2=punix:`pwd`/special.sock\ncheck as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/add-remote \"$conn2\"\n\n# ovn-northd won't respond to changes (because the nbdb connection dropped).\ncheck ovn-nbctl --db=\"${conn2#p}\" ls-add sw1\nsleep 5\ncheck_row_count Datapath_Binding 1\n\n# Now re-enable the nbdb connection and observe ovn-northd catch up.\ncheck as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/add-remote \"$conn\"\nwait_row_count Datapath_Binding 2\ndp2=$(fetch_column Datapath_Binding _uuid external_ids:name=sw1)\nwait_column \"$dp1 $dp2\" Logical_DP_Group datapaths\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([southbound database reconnection])\n\novn_start --backup-northd=none\n\n# Check that ovn-northd is active, by verifying that it creates and\n# destroys southbound datapaths as one would expect.\ncheck_row_count Datapath_Binding 0\ncheck ovn-nbctl --wait=sb ls-add sw0\ncheck_row_count Datapath_Binding 1\ndp1=$(fetch_column Datapath_Binding _uuid external_ids:name=sw0)\n\n# Make sbdb ovsdb-server drop connection from ovn-northd.\nconn=$(as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/list-remotes|grep ^punix)\ncheck as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/remove-remote \"$conn\"\nconn2=punix:`pwd`/special.sock\ncheck as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/add-remote \"$conn2\"\n\n# ovn-northd can't respond to changes (because the sbdb connection dropped).\ncheck ovn-nbctl ls-add sw1\nsleep 5\nOVN_SB_DB=${conn2#p} check_row_count Datapath_Binding 1\n\n# Now re-enable the sbdb connection and observe ovn-northd catch up.\n#\n# It's important to check both Datapath_Binding and Logical_Flow.\ncheck as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/add-remote \"$conn\"\nwait_row_count Datapath_Binding 2\ndp2=$(fetch_column Datapath_Binding _uuid external_ids:name=sw1)\nwait_column \"$dp1 $dp2\" Logical_DP_Group datapaths\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check Redirect Chassis propagation from NB to SB])\novn_start\n\novn-sbctl chassis-add gw1 geneve 127.0.0.1\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 router\novn-nbctl lsp-set-options S1-R1 router-port=R1-S1\n\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1\n\novn-nbctl lrp-set-redirect-type R1-S1 bridged\nwait_row_count Port_Binding 1 logical_port=cr-R1-S1 options:redirect-type=bridged\n\novn-nbctl lrp-set-redirect-type R1-S1 overlay\nwait_row_count Port_Binding 1 logical_port=cr-R1-S1 options:redirect-type=overlay\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check stateless dnat_and_snat rule])\novn_start\n\novn-sbctl chassis-add gw1 geneve 127.0.0.1\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 router\novn-nbctl lsp-set-options S1-R1 router-port=R1-S1\n\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1\n\ncheck_flow_matches() {\n    local regex=$1 count=$2\n    local found=$(grep -c \"$1\" r1-flows)\n    echo \"checking for $count flows matching $regex... found $found\"\n    AT_FAIL_IF([test $found != $count])\n}\n\ncheck_flow_match_sets() {\n    ovn-sbctl dump-flows R1 > r1-flows\n    AT_CAPTURE_FILE([r1-flows])\n\n    for regex in lr_in_unsnat ct_snat ct_dnat ip4.dst= ip4.src= ip6.dst= ip6.src=; do\n        check_flow_matches $regex $1\n        shift\n    done\n}\n\necho\necho \"IPv4: stateful\"\novn-nbctl --wait=sb lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11\ncheck_flow_match_sets 3 4 2 0 0 0 0\novn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1\n\necho\necho \"IPv4: stateless\"\novn-nbctl --wait=sb --stateless lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11\ncheck_flow_match_sets 2 0 0 1 1 0 0\novn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1\n\necho\necho \"IPv6: stateful\"\novn-nbctl --wait=sb lr-nat-add R1 dnat_and_snat fd01::1 fd11::2\ncheck_flow_match_sets 3 4 2 0 0 0 0\novn-nbctl lr-nat-del R1 dnat_and_snat  fd01::1\n\necho\necho \"IPv6: stateless\"\novn-nbctl --wait=sb --stateless lr-nat-add R1 dnat_and_snat fd01::1 fd11::2\ncheck_flow_match_sets 2 0 0 0 0 1 1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check portrange dnat, snat and dnat_and_snat rules])\novn_start\n\novn-sbctl chassis-add gw1 geneve 127.0.0.1\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 router\novn-nbctl lsp-set-options S1-R1 router-port=R1-S1\n\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1\n\nuuid=`ovn-sbctl --columns=_uuid --bare find Port_Binding logical_port=cr-R1-S1`\necho \"CR-LRP UUID is: \" $uuid\n\n# IPV4\novn-nbctl --portrange lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11 1-3000\n\nAT_CAPTURE_FILE([sbflows])\nOVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows && test 3 = `grep -c lr_in_unsnat sbflows`])\nAT_CHECK([grep -c 'ct_snat.*3000' sbflows && grep -c 'ct_dnat.*3000' sbflows],\n  [0], [2\n1\n])\n\novn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1\novn-nbctl --wait=sb --portrange lr-nat-add R1 snat  172.16.1.1 50.0.0.11 1-3000\n\nAT_CAPTURE_FILE([sbflows2])\nOVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows2 && test 3 = `grep -c lr_in_unsnat sbflows`])\nAT_CHECK([grep -c 'ct_snat.*3000' sbflows2 && grep -c 'ct_dnat.*3000' sbflows2],\n  [1], [2\n0\n])\n\novn-nbctl lr-nat-del R1 snat  172.16.1.1\novn-nbctl --wait=sb --portrange --stateless lr-nat-add R1 dnat_and_snat  172.16.1.2 50.0.0.12 1-3000\n\nAT_CAPTURE_FILE([sbflows3])\nOVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows3 && test 4 = `grep -c lr_in_unsnat sbflows3`])\nAT_CHECK([grep 'ct_[s]dnat.*172\\.16\\.1\\.2.*3000' sbflows3], [1])\n\novn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check allowed/disallowed external dnat, snat and dnat_and_snat rules])\novn_start\n\n# Logical network:\n# 2 LRs - CR and DR\n# CR ==> Centralized router\n# DR ==> Distributed router\n#\n# DR is connected to S1 and CR is connected to S2\n\ncheck ovn-sbctl chassis-add gw1 geneve 127.0.0.1\n\ncheck ovn-nbctl lr-add DR\ncheck ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24\n\ncr_uuid=$(ovn-nbctl create Logical_Router name=CR)\ncheck ovn-nbctl lrp-add CR CR-S2 02:ac:10:01:00:01 172.16.1.1/24\n\ncheck ovn-nbctl ls-add S1\ncheck ovn-nbctl lsp-add S1 S1-DR\ncheck ovn-nbctl lsp-set-type S1-DR router\ncheck ovn-nbctl lsp-set-addresses S1-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1\n\ncheck ovn-nbctl ls-add S2\ncheck ovn-nbctl lsp-add S2 S2-CR\ncheck ovn-nbctl lsp-set-type S2-CR router\ncheck ovn-nbctl lsp-set-addresses S2-CR router\ncheck ovn-nbctl --wait=sb lsp-set-options S2-CR router-port=CR-S2\n\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S1 gw1\n\nuuid=$(fetch_column Port_Binding _uuid logical_port=cr-DR-S1)\necho \"CR-LRP UUID is: \" $uuid\n\ncheck ovn-nbctl set Logical_Router $cr_uuid options:chassis=gw1\ncheck ovn-nbctl --wait=sb sync\n\novn-nbctl create Address_Set name=allowed_range addresses=\\\"1.1.1.1\\\"\novn-nbctl create Address_Set name=disallowed_range addresses=\\\"2.2.2.2\\\"\n\n# SNAT with ALLOWED_IPs\ncheck ovn-nbctl lr-nat-add DR snat  172.16.1.1 50.0.0.11\ncheck ovn-nbctl lr-nat-update-ext-ip DR snat 50.0.0.11 allowed_range\n\ncheck ovn-nbctl lr-nat-add CR snat  172.16.1.1 50.0.0.11\ncheck ovn-nbctl lr-nat-update-ext-ip CR snat 50.0.0.11 allowed_range\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > drflows\nAT_CAPTURE_FILE([drflows])\novn-sbctl dump-flows CR > crflows\nAT_CAPTURE_FILE([crflows])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $allowed_range), action=(ct_snat_in_czone(172.16.1.1);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $allowed_range && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.1);)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $allowed_range && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.1);)\n])\n\n\n# SNAT with DISALLOWED_IPs\ncheck ovn-nbctl lr-nat-del DR snat  50.0.0.11\ncheck ovn-nbctl lr-nat-del CR snat  50.0.0.11\n\ncheck ovn-nbctl lr-nat-add DR snat  172.16.1.1 50.0.0.11\ncheck ovn-nbctl lr-nat-add CR snat  172.16.1.1 50.0.0.11\n\ncheck ovn-nbctl --is-exempted lr-nat-update-ext-ip DR snat 50.0.0.11 disallowed_range\ncheck ovn-nbctl --is-exempted lr-nat-update-ext-ip CR snat 50.0.0.11 disallowed_range\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > drflows2\nAT_CAPTURE_FILE([drflows2])\novn-sbctl dump-flows CR > crflows2\nAT_CAPTURE_FILE([crflows2])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows2 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone(172.16.1.1);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.1);)\n  table=??(lr_out_snat        ), priority=163  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $disallowed_range), action=(next;)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows2 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.1);)\n  table=??(lr_out_snat        ), priority=35   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $disallowed_range), action=(next;)\n])\n\n# Stateful FIP with ALLOWED_IPs\ncheck ovn-nbctl lr-nat-del DR snat  50.0.0.11\ncheck ovn-nbctl lr-nat-del CR snat  50.0.0.11\n\ncheck ovn-nbctl lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11\ncheck ovn-nbctl lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11\n\ncheck ovn-nbctl lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 allowed_range\ncheck ovn-nbctl --wait=sb lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 allowed_range\n\novn-sbctl dump-flows DR > drflows3\nAT_CAPTURE_FILE([drflows2])\novn-sbctl dump-flows CR > crflows3\nAT_CAPTURE_FILE([crflows2])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows3 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $allowed_range), action=(ct_snat_in_czone(172.16.1.2);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $allowed_range && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.2);)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows3 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $allowed_range && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.2);)\n])\n\n# Stateful FIP with DISALLOWED_IPs\novn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2\novn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2\n\novn-nbctl lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11\novn-nbctl lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11\n\novn-nbctl --is-exempted lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 disallowed_range\ncheck ovn-nbctl --wait=sb --is-exempted lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 disallowed_range\n\novn-sbctl dump-flows DR > drflows4\nAT_CAPTURE_FILE([drflows2])\novn-sbctl dump-flows CR > crflows4\nAT_CAPTURE_FILE([crflows2])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows4 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone(172.16.1.2);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.2);)\n  table=??(lr_out_snat        ), priority=163  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $disallowed_range), action=(next;)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows4 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.2);)\n  table=??(lr_out_snat        ), priority=35   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $disallowed_range), action=(next;)\n])\n\n# Stateless FIP with DISALLOWED_IPs\novn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2\novn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2\n\novn-nbctl --stateless lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11\novn-nbctl --stateless lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11\n\novn-nbctl lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 allowed_range\ncheck ovn-nbctl --wait=sb lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 allowed_range\n\novn-sbctl dump-flows DR > drflows5\nAT_CAPTURE_FILE([drflows2])\novn-sbctl dump-flows CR > crflows5\nAT_CAPTURE_FILE([crflows2])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows5 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $allowed_range), action=(ip4.src=172.16.1.2; next;)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows5 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $allowed_range), action=(ip4.src=172.16.1.2; next;)\n])\n\n# Stateful FIP with DISALLOWED_IPs\novn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2\novn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2\n\novn-nbctl --stateless lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11\novn-nbctl --stateless lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11\n\novn-nbctl --is-exempted lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 disallowed_range\novn-nbctl --is-exempted lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 disallowed_range\n\novn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > drflows6\nAT_CAPTURE_FILE([drflows2])\novn-sbctl dump-flows CR > crflows6\nAT_CAPTURE_FILE([crflows2])\n\nAT_CHECK([grep -e \"lr_out_snat\" drflows6 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ip4.src=172.16.1.2; next;)\n  table=??(lr_out_snat        ), priority=163  , match=(ip && ip4.src == 50.0.0.11 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && ip4.dst == $disallowed_range), action=(next;)\n])\n\nAT_CHECK([grep -e \"lr_out_snat\" crflows6 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11), action=(ip4.src=172.16.1.2; next;)\n  table=??(lr_out_snat        ), priority=35   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $disallowed_range), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check Load balancer health check and Service Monitor sync])\novn_start NORTHD_TYPE\ncheck ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80\n\ncheck ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1\ncheck ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1\n\nwait_row_count Service_Monitor 0\n\nAT_CHECK([ovn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer . \\\nhealth_check @hc | uuidfilt], [0], [<0>\n])\n\nwait_row_count Service_Monitor 0\n\nAS_BOX([create logical switches and ports])\novn-nbctl ls-add sw0\novn-nbctl --wait=sb lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \\\n\"00:00:00:00:00:03 10.0.0.3\"\n\nwait_row_count Service_Monitor 0\n\novn-nbctl ls-add sw1\novn-nbctl --wait=sb lsp-add sw1 sw1-p1 -- lsp-set-addresses sw1-p1 \\\n\"02:00:00:00:00:03 20.0.0.3\"\n\n# service_monitors state online requires corresponding port_binding to be \"up\"\novn-sbctl chassis-add hv1 geneve 127.0.0.1\novn-sbctl lsp-bind sw0-p1 hv1\novn-sbctl lsp-bind sw1-p1 hv1\nwait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 'up=true'\nwait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 'up=true'\n\nwait_row_count Service_Monitor 0\n\novn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2\nwait_row_count Service_Monitor 1\n\novn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2\nwait_row_count Service_Monitor 2\n\ncheck ovn-nbctl --wait=sb ls-lb-add sw0 lb1\n\nAT_CAPTURE_FILE([sbflows])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows | grep 'priority=120.*backends' | sed 's/table=..//'], 0, [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\n\n# disabled LSPs should not be a backend of Load Balancer\ncheck ovn-nbctl lsp-set-enabled sw0-p1 disabled\n\nAT_CAPTURE_FILE([sbflows])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows | grep 'priority=120.*backends' | sed 's/table=..//'], 0, [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=20.0.0.3:80);)\n])\nwait_row_count Service_Monitor 1\n\ncheck ovn-nbctl lsp-set-enabled sw0-p1 enabled\n\nAT_CAPTURE_FILE([sbflows])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows | grep 'priority=120.*backends' | sed 's/table=..//'], 0, [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\nwait_row_count Service_Monitor 2\n\nAS_BOX([Delete the Load_Balancer_Health_Check])\novn-nbctl --wait=sb clear load_balancer . health_check\nwait_row_count Service_Monitor 0\n\nAT_CAPTURE_FILE([sbflows2])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows2 | grep 'priority=120.*backends' | sed 's/table=..//'], [0],\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\n\nAS_BOX([Create the Load_Balancer_Health_Check again.])\novn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer . \\\nhealth_check @hc\nwait_row_count Service_Monitor 2\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows sw0 | grep backends | grep priority=120 > lflows.txt\nAT_CHECK([cat lflows.txt | sed 's/table=..//'], [0], [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\n\nAS_BOX([Get the uuid of both the service_monitor])\nsm_sw0_p1=$(fetch_column Service_Monitor _uuid logical_port=sw0-p1)\nsm_sw1_p1=$(fetch_column Service_Monitor _uuid logical_port=sw1-p1)\n\nAT_CAPTURE_FILE([sbflows3])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows 3 | grep 'priority=120.*backends' | sed 's/table=..//'], [0],\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\n\nAS_BOX([Set the service monitor for sw1-p1 to offline])\ncheck ovn-sbctl set service_monitor sw1-p1 status=offline\nwait_row_count Service_Monitor 1 logical_port=sw1-p1 status=offline\ncheck ovn-nbctl --wait=sb sync\n\nAT_CAPTURE_FILE([sbflows4])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows4 | grep 'priority=120.*backends' | sed 's/table=..//'], [0],\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80);)\n])\n\nAS_BOX([Set the service monitor for sw0-p1 to offline])\novn-sbctl set service_monitor $sm_sw0_p1 status=offline\n\nwait_row_count Service_Monitor 1 logical_port=sw0-p1 status=offline\ncheck ovn-nbctl --wait=sb sync\n\nAT_CAPTURE_FILE([sbflows5])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows5 | grep 'priority=120.*backends'], 1)\n\nAT_CAPTURE_FILE([sbflows6])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows6 | grep \"ip4.dst == 10.0.0.10 && tcp.dst == 80\" | grep priority=120 | grep ls_in_lb | sed 's/table=..//'], [0], [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(drop;)\n])\n\nAS_BOX([Set the service monitor for sw0-p1 and sw1-p1 to online])\novn-sbctl set service_monitor $sm_sw0_p1 status=online\novn-sbctl set service_monitor $sm_sw1_p1 status=online\n\nwait_row_count Service_Monitor 1 logical_port=sw1-p1 status=online\ncheck ovn-nbctl --wait=sb sync\n\nAT_CAPTURE_FILE([sbflows7])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows7 | grep backends | grep priority=120 | sed 's/table=..//'], 0,\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n])\n\nAS_BOX([Set the service monitor for sw1-p1 to error])\novn-sbctl set service_monitor $sm_sw1_p1 status=error\nwait_row_count Service_Monitor 1 logical_port=sw1-p1 status=error\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows sw0 | grep \"ip4.dst == 10.0.0.10 && tcp.dst == 80\" \\\n| grep priority=120 > lflows.txt\nAT_CHECK([cat lflows.txt | grep ls_in_lb | sed 's/table=..//'], [0], [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80);)\n])\n\nAS_BOX([Add one more vip to lb1])\ncheck ovn-nbctl set load_balancer . vip:10.0.0.40\\\\:1000=10.0.0.3:1000,20.0.0.3:80\n\nAS_BOX([create health_check for new vip - 10.0.0.40])\nAT_CHECK(\n  [ovn-nbctl --wait=sb \\\n          -- --id=@hc create Load_Balancer_Health_Check vip=10.0.0.40\\\\:1000 \\\n          -- add Load_Balancer . health_check @hc | uuidfilt], [0], [<0>\n])\n\n# There should be totally 3 rows in service_monitor for -\n#    * 10.0.0.3:80\n#    * 10.0.0.3:1000\n#    * 20.0.0.3:80\n\nwait_row_count Service_Monitor 3\nwait_row_count Service_Monitor 2 logical_port=sw0-p1\nwait_row_count Service_Monitor 1 port=1000\n\nAT_CAPTURE_FILE([sbflows9])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows9 | grep backends | grep priority=120 | sed 's/table=..//' | sort],\n  0,\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80);)\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:1000);)\n])\n\nAS_BOX([Set the service monitor for sw1-p1 to online])\ncheck ovn-sbctl set service_monitor sw1-p1 status=online\n\nwait_row_count Service_Monitor 1 logical_port=sw1-p1 status=online\ncheck ovn-nbctl --wait=sb sync\n\nAT_CAPTURE_FILE([sbflows10])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows10 | grep backends | grep priority=120 | sed 's/table=..//' | sort],\n  0,\n[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:1000,20.0.0.3:80);)\n])\n\nAS_BOX([Associate lb1 to sw1])\ncheck ovn-nbctl --wait=sb ls-lb-add sw1 lb1\nAT_CAPTURE_FILE([sbflows11])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw1 | tee sbflows11 | grep backends | grep priority=120 | sed 's/table=..//' | sort],\n  0, [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(reg0[[1]] = 0; ct_lb(backends=10.0.0.3:1000,20.0.0.3:80);)\n])\n\nAS_BOX([Now create lb2 same as lb1 but udp protocol.])\ncheck ovn-nbctl lb-add lb2 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80 udp\ncheck ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2\ncheck ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2\n\nAT_CHECK([ovn-nbctl -- --id=@hc create Load_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer lb2 health_check @hc | uuidfilt],\n         [0], [<0>\n])\n\ncheck ovn-nbctl ls-lb-add sw0 lb2\ncheck ovn-nbctl ls-lb-add sw1 lb2\ncheck ovn-nbctl --wait=sb sync\n\nwait_row_count Service_Monitor 5\n\nAS_BOX([Change the svc_monitor_mac.])\n# This should get reflected in service_monitor table rows.\ncheck ovn-nbctl set NB_Global . options:svc_monitor_mac=\"fe:a0:65:a2:01:03\"\n\nwait_row_count Service_Monitor 5 src_mac='\"fe:a0:65:a2:01:03\"'\n\nAS_BOX([Change the source ip for 10.0.0.3 backend ip in lb2])\ncheck ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.100\n\nwait_row_count Service_Monitor 1 logical_port=sw0-p1 src_ip=10.0.0.100\n\novn-nbctl --wait=sb lb-del lb1\nwait_row_count Service_Monitor 2\n\novn-nbctl --wait=sb lb-del lb2\nwait_row_count Service_Monitor 0\n\ncheck ovn-nbctl --reject lb-add lb3 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80\ncheck ovn-nbctl --wait=sb set load_balancer lb3 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2\ncheck ovn-nbctl --wait=sb set load_balancer lb3 ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2\nwait_row_count Service_Monitor 0\n\ncheck ovn-nbctl --wait=sb ls-lb-add sw0 lb3\nAT_CHECK([ovn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer lb3 \\\nhealth_check @hc | uuidfilt], [0], [<0>\n])\nwait_row_count Service_Monitor 2\n\n# Set the service monitor for sw0-p1 and sw1-p1 to online\nsm_sw0_p1=$(fetch_column Service_Monitor _uuid logical_port=sw0-p1)\nsm_sw1_p1=$(fetch_column Service_Monitor _uuid logical_port=sw1-p1)\n\novn-sbctl set service_monitor $sm_sw0_p1 status=offline\novn-sbctl set service_monitor $sm_sw1_p1 status=offline\n\nAT_CAPTURE_FILE([sbflows12])\nOVS_WAIT_FOR_OUTPUT(\n  [ovn-sbctl dump-flows sw0 | tee sbflows12 | grep \"ip4.dst == 10.0.0.10 && tcp.dst == 80\" | grep priority=120 | grep ls_in_lb | sed 's/table=..//'], [0], [dnl\n  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=5);};)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load balancer VIP in NAT entries])\nAT_SKIP_IF([test $HAVE_PYTHON = no])\novn_start\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:01:01:02:04 192.168.2.1/24\ncheck ovn-nbctl lrp-add lr0 lr0-join 00:00:01:01:02:04 10.10.0.1/24\n\ncheck ovn-nbctl set logical_router lr0 options:chassis=ch1\n\ncheck ovn-nbctl lb-add lb1 \"192.168.2.1:8080\" \"10.0.0.4:8080\"\ncheck ovn-nbctl lb-add lb2 \"192.168.2.4:8080\" \"10.0.0.5:8080\" udp\ncheck ovn-nbctl lb-add lb3 \"192.168.2.5:8080\" \"10.0.0.6:8080\"\ncheck ovn-nbctl lb-add lb4 \"192.168.2.6:8080\" \"10.0.0.7:8080\"\n\ncheck ovn-nbctl lr-lb-add lr0 lb1\ncheck ovn-nbctl lr-lb-add lr0 lb2\ncheck ovn-nbctl lr-lb-add lr0 lb3\ncheck ovn-nbctl lr-lb-add lr0 lb4\n\ncheck ovn-nbctl lr-nat-add lr0 snat 192.168.2.1 10.0.0.0/24\ncheck ovn-nbctl lr-nat-add lr0 dnat_and_snat 192.168.2.4 10.0.0.4\ncheck ovn-nbctl --wait=sb lr-nat-add lr0 dnat 192.168.2.5 10.0.0.5\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no flows for LB VIPs in lr_in_unsnat if the VIP is not a\n# dnat_and_snat or snat entry.\nAT_CHECK([grep \"lr_in_unsnat\" sbflows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.1 && tcp && tcp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.4 && udp && udp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.5 && tcp && tcp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.4), action=(ct_snat;)\n])\n\nAS_BOX([Check behavior with LB Groups])\ncheck ovn-nbctl lr-lb-del lr0 lb1\ncheck ovn-nbctl lr-lb-del lr0 lb2\ncheck ovn-nbctl lr-lb-del lr0 lb3\ncheck ovn-nbctl lr-lb-del lr0 lb4\n\nlb1=$(fetch_column nb:load_balancer _uuid name=lb1)\nlb2=$(fetch_column nb:load_balancer _uuid name=lb2)\nlb3=$(fetch_column nb:load_balancer _uuid name=lb3)\nlb4=$(fetch_column nb:load_balancer _uuid name=lb4)\n\nlbg=$(ovn-nbctl create load_balancer_group name=lbg -- \\\n  add load_balancer_group lbg load_balancer $lb1 -- \\\n  add load_balancer_group lbg load_balancer $lb2 -- \\\n  add load_balancer_group lbg load_balancer $lb3 -- \\\n  add load_balancer_group lbg load_balancer $lb4)\n\ncheck ovn-nbctl --wait=sb add logical_router lr0 load_balancer_group $lbg\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no flows for LB VIPs in lr_in_unsnat if the VIP is not a\n# dnat_and_snat or snat entry.\nAT_CHECK([grep \"lr_in_unsnat\" sbflows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.1 && tcp && tcp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.4 && udp && udp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.5 && tcp && tcp.dst == 8080), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.4), action=(ct_snat;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LRP same IP as VIP or SNAT])\novn_start\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:00:00:00:10 192.168.0.1/24 2000::1/64\ncheck ovn-nbctl --wait=sb lrp-add lr0 lr0-join 00:00:00:00:00:20 10.10.0.1/24 192.168.1.1/24\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be drop lflows for all IPs of both LRPs\nAT_CHECK([grep \"lr_in_ip_input\" sbflows | grep 'ip.\\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {2000::1, fe80::200:ff:fe00:10}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)\n])\n\n# create SNAT with external IP equal to LRP's IP\ncheck ovn-nbctl --wait=sb lr-nat-add lr0 snat 192.168.0.1 10.10.0.0/24\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no drop lflow for 192.168.0.1\nAT_CHECK([grep \"lr_in_ip_input\" sbflows | grep 'ip.\\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {2000::1, fe80::200:ff:fe00:10}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)\n])\n\ncheck ovn-nbctl lr-nat-del lr0\n\n# create SNAT with external IPv6 equal to LRP's IPv6\ncheck ovn-nbctl --wait=sb lr-nat-add lr0 snat 2000::1 2aaa::/64\novn-nbctl show lr0\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no drop lflow for 2000::1\nAT_CHECK([grep \"lr_in_ip_input\" sbflows | grep 'ip.\\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:10}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)\n])\n\ncheck ovn-nbctl lr-nat-del lr0\n\n# create LB with VIP equal to LRP's IP and assign it to LR\ncheck ovn-nbctl lb-add lb1 \"192.168.1.1:8080\" \"10.0.0.4:8080\"\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb1\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no drop lflow for 192.168.1.1\nAT_CHECK([grep \"lr_in_ip_input\" sbflows | grep 'ip.\\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {2000::1, fe80::200:ff:fe00:10}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)\n])\n\ncheck ovn-nbctl lb-del lb1\n\n# create LB with VIP equal to LRP's IPv6 and assign it to LR\ncheck ovn-nbctl lb-add lb1 [[2000::1]]:8080 [[2aaa::10]]:8080\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb1\n\novn-sbctl dump-flows lr0 > sbflows\nAT_CAPTURE_FILE([sbflows])\n\n# There should be no drop lflow for 2000::1\nAT_CHECK([grep \"lr_in_ip_input\" sbflows | grep 'ip.\\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:10}), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([DNAT force snat IP])\novn_start\n\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-public 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lrp-add lr0 lr0-join 00:00:01:01:02:04 10.10.0.1/24\n\novn-nbctl set logical_router lr0 options:chassis=ch1\novn-nbctl lr-nat-add lr0 dnat 192.168.2.2 10.0.0.5\novn-nbctl set logical_router lr0 options:dnat_force_snat_ip=192.168.2.3\novn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list lr0 | grep lr_in_unsnat | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(ip4 && ip4.dst == 192.168.2.3), action=(ct_snat;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check reconcile stale Datapath_Binding])\novn_start\n\ncheck ovn-nbctl lr-add lr\ncheck ovn-nbctl lrp-add lr p 00:00:00:00:00:01 1.1.1.1/24\ncheck ovn-nbctl --wait=sb sync\n\n# Create a MAC_Binding referring the router datapath.\nAT_CHECK([ovn-sbctl --id=@dp get datapath . -- create mac_binding logical_port=p ip=1.1.1.2 datapath=@dp | uuidfilt], [0], [<0>\n])\n\ncheck ovn-nbctl --wait=sb \\\n             -- lrp-del p \\\n             -- lr-del lr \\\n             -- lr-add lr \\\n             -- lrp-add lr p 00:00:00:00:00:01 1.1.1.1/24\n\ncheck_row_count Datapath_Binding 1\n\nnb_uuid=$(ovn-sbctl get Datapath_Binding . external_ids:logical-router)\nlr_uuid=\\\"$(ovn-nbctl get Logical_Router . _uuid)\\\"\necho nb_uuid=\"$nb_uuid\" lr_uuid=\"$lr_uuid\"\nAT_CHECK([test \"${nb_uuid}\" = \"${lr_uuid}\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check reconcile stale tunnel keys])\novn_start\n\novn-nbctl ls-add ls1\novn-nbctl ls-add ls2\novn-nbctl lsp-add ls1 lsp1\novn-nbctl lsp-add ls2 lsp2\nAT_CHECK([ovn-nbctl --wait=sb sync], [0])\n\n# Ports are bound on different datapaths so it's expected that they both\n# get tunnel_key == 1.\ncheck_column 1 Port_Binding tunnel_key logical_port=lsp1\ncheck_column 1 Port_Binding tunnel_key logical_port=lsp2\n\novn-nbctl lsp-del lsp2 -- lsp-add ls1 lsp2\nAT_CHECK([ovn-nbctl --wait=sb sync], [0])\n\ncheck_column 1 Port_Binding tunnel_key logical_port=lsp1\ncheck_column 2 Port_Binding tunnel_key logical_port=lsp2\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check reconcile stale Ha_Chassis_Group])\novn_start\n\novn-nbctl ls-add ls1\novn-nbctl ls-add ls2\novn-nbctl lsp-add ls1 lsp1\novn-nbctl lsp-add ls2 lsp2\n\novn-nbctl lsp-set-type lsp2 external\n\novn-nbctl ha-chassis-group-add chg1\novn-nbctl ha-chassis-group-add-chassis chg1 chassis-1 30\n\nchg1_uuid=$(ovn-nbctl --bare --columns _uuid list Ha_Chassis_Group .)\novn-nbctl set logical_switch_port lsp2 ha_chassis_group=${chg1_uuid}\nAT_CHECK([ovn-nbctl --wait=sb sync], [0])\n\n# Move lsp2 from ls2 to ls1. This should also remove the SB HA_Chassis_Group\n# record.\novn-nbctl lsp-del lsp2 -- lsp-add ls1 lsp2\nAT_CHECK([ovn-nbctl --wait=sb sync], [0])\n\ncheck_row_count HA_Chassis_Group 0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check NB/SB Port_Group translation (lsp add/del)])\novn_start\n\novn-nbctl ls-add ls1\novn-nbctl ls-add ls2\novn-nbctl lsp-add ls1 lsp1\novn-nbctl lsp-add ls2 lsp2\novn-nbctl --wait=sb sync\nls1_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls1)\nls2_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls2)\n\n# Add an empty port group. This should generate no entry in the SB.\novn-nbctl --wait=sb pg-add pg_test\nAT_CHECK([test 0 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])\n\n# Add lsp1 to the port group. This should generate an entry in the SB only\n# for ls1.\novn-nbctl --wait=sb pg-set-ports pg_test lsp1\nAT_CHECK([test 1 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])\nAT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls1_key}_pg_test], [0], [dnl\nlsp1\n])\n\n# Add lsp2 to the port group. This should generate a new entry in the SB, for\n# ls2.\novn-nbctl --wait=sb pg-set-ports pg_test lsp1 lsp2\nAT_CHECK([test 2 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])\nAT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls1_key}_pg_test], [0], [dnl\nlsp1\n])\nAT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls2_key}_pg_test], [0], [dnl\nlsp2\n])\n\n# Remove lsp1 from the port group. The SB Port_Group for ls1 should be\n# removed.\novn-nbctl --wait=sb pg-set-ports pg_test lsp2\nAT_CHECK([test 1 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])\nAT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls2_key}_pg_test], [0], [dnl\nlsp2\n])\n\n# Remove lsp2 from the port group. All SB Port_Groups should be purged.\novn-nbctl --wait=sb clear Port_Group pg_test ports\nAT_CHECK([test 0 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check NB/SB Port_Group translation (ls del)])\novn_start\n\novn-nbctl ls-add ls1\novn-nbctl ls-add ls2\novn-nbctl lsp-add ls1 lsp1\novn-nbctl lsp-add ls2 lsp2\novn-nbctl --wait=sb sync\nls1_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls1)\nls2_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls2)\n\n# Add lsp1 & lsp2 to a port group. This should generate two entries in the\n# SB (one per logical switch).\novn-nbctl --wait=sb pg-add pg_test lsp1 lsp2\nwait_row_count Port_Group 2\ncheck_row_count Port_Group 1 name=${ls1_key}_pg_test\ncheck_row_count Port_Group 1 name=${ls2_key}_pg_test\n\n# Delete logical switch ls1. This should remove the associated SB Port_Group.\novn-nbctl --wait=sb ls-del ls1\nwait_row_count Port_Group 1\ncheck_row_count Port_Group 1 name=${ls2_key}_pg_test\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check router ARP/NS responder])\novn_start\n\novn-sbctl chassis-add ch geneve 127.0.0.1\n\novn-nbctl lr-add lr\novn-nbctl lrp-add lr lrp-public 00:00:00:00:01:00 43.43.43.1/24 4343::1/64\novn-nbctl lrp-add lr lrp 00:00:00:00:00:01 42.42.42.1/24\n\novn-nbctl ls-add ls\novn-nbctl lsp-add ls ls-rp\novn-nbctl lsp-set-type ls-rp router\novn-nbctl lsp-set-addresses ls-rp router\novn-nbctl lsp-set-options ls-rp router-port=lrp\novn-nbctl lsp-add ls ls-vm\n\novn-nbctl set logical_router lr options:chassis=ch\novn-nbctl lr-nat-add lr dnat_and_snat 43.43.43.2 42.42.42.2\novn-nbctl lr-nat-add lr dnat 43.43.43.3 42.42.42.3\novn-nbctl lr-nat-add lr dnat_and_snat 43.43.43.4 42.42.42.4 ls-vm 00:00:00:00:00:02\novn-nbctl lr-nat-add lr snat 43.43.43.150 43.43.43.50\novn-nbctl lr-nat-add lr snat 43.43.43.150 43.43.43.51\n\novn-nbctl lb-add lb1 \"192.168.2.1:8080\" \"10.0.0.4:8080\"\novn-nbctl lb-add lb2 \"192.168.2.4:8080\" \"10.0.0.5:8080\" udp\novn-nbctl lb-add lb3 \"192.168.2.5:8080\" \"10.0.0.6:8080\"\novn-nbctl lb-add lb4 \"192.168.2.6:8080\" \"10.0.0.7:8080\"\novn-nbctl lb-add lb5 \"[[fe80::200:ff:fe00:101]]:8080\" \"[[fe02::200:ff:fe00:101]]:8080\"\novn-nbctl lb-add lb5 \"[[fe80::200:ff:fe00:102]]:8080\" \"[[fe02::200:ff:fe00:102]]:8080\"\novn-nbctl lb-add lb6 \"43.43.43.43:8080\" \"10.0.0.8:8080\" udp\novn-nbctl lb-add lb7 \"[[4343::4343]]:8080\" \"[[10::10]]:8080\" udp\novn-nbctl lb-add lb8 \"44.44.44.44:8080\" \"10.0.0.8:8080\" udp\novn-nbctl set Load_Balancer lb8 options:neighbor_responder=all\novn-nbctl lb-add lb9 \"[[4444::4444]]:8080\" \"[[10::10]]:8080\" udp\novn-nbctl set Load_Balancer lb9 options:neighbor_responder=all\n\novn-nbctl lb-add lb10 \"55.55.55.55:8080\" \"10.0.0.8:8080\" udp\novn-nbctl set Load_Balancer lb10 options:neighbor_responder=none\novn-nbctl lb-add lb11 \"[[5555::5555]]:8080\" \"[[10::10]]:8080\" udp\novn-nbctl set Load_Balancer lb11 options:neighbor_responder=none\n\novn-nbctl lr-lb-add lr lb1\novn-nbctl lr-lb-add lr lb2\novn-nbctl lr-lb-add lr lb3\novn-nbctl lr-lb-add lr lb4\novn-nbctl lr-lb-add lr lb5\novn-nbctl lr-lb-add lr lb6\novn-nbctl lr-lb-add lr lb7\novn-nbctl lr-lb-add lr lb8\novn-nbctl lr-lb-add lr lb9\novn-nbctl lr-lb-add lr lb10\novn-nbctl lr-lb-add lr lb11\n\novn-nbctl --wait=sb sync\nlr_key=$(fetch_column sb:datapath_binding tunnel_key external_ids:name=lr)\nlb_as_v4=\"_rtr_lb_${lr_key}_ip4\"\nlb_as_v6=\"_rtr_lb_${lr_key}_ip6\"\n\n# Check generated VIP address sets (only reachable IPs).\ncheck_column '43.43.43.43 44.44.44.44' Address_Set addresses name=${lb_as_v4}\ncheck_column '4343::4343 4444::4444 fe80::200:ff:fe00:101 fe80::200:ff:fe00:102' Address_Set addresses name=${lb_as_v6}\n\n# Ingress router port ETH address is stored in lr_in_admission.\nAT_CHECK([ovn-sbctl lflow-list | grep -E \"lr_in_admission.*xreg0\\[[0..47\\]]\" | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.dst == 00:00:00:00:01:00 && inport == \"lrp-public\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.mcast && inport == \"lrp\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.mcast && inport == \"lrp-public\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)\n])\n\n# Ingress router port ETH address is used for ARP reply/NA in lr_in_ip_input.\nAT_CHECK_UNQUOTED([ovn-sbctl lflow-list | grep -E \"lr_in_ip_input.*priority=90\" | grep \"arp\\|nd\" | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.150), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.2), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.3), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.4), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && arp.op == 1 && arp.tpa == \\$${lb_as_v4}), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && arp.op == 1 && arp.tpa == 42.42.42.1 && arp.spa == 42.42.42.0/24), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && ip6.dst == {fe80::200:ff:fe00:1, ff02::1:ff00:1} && nd_ns && nd.target == fe80::200:ff:fe00:1), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && nd_ns && nd.target == \\$${lb_as_v6}), dnl\naction=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == \\$${lb_as_v4}), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.1 && arp.spa == 43.43.43.0/24), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && ip6.dst == {4343::1, ff02::1:ff00:1} && nd_ns && nd.target == 4343::1), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && ip6.dst == {fe80::200:ff:fe00:100, ff02::1:ff00:100} && nd_ns && nd.target == fe80::200:ff:fe00:100), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && nd_ns && nd.target == \\$${lb_as_v6}), dnl\naction=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n])\n\n# xreg0[0..47] isn't used anywhere else.\nAT_CHECK([ovn-sbctl lflow-list | grep \"xreg0\\[[0..47\\]]\" | grep -vE 'lr_in_admission|lr_in_ip_input'], [1], [])\n\n# Test chassis redirect port.\novn-nbctl remove logical_router lr options chassis\novn-nbctl lrp-set-gateway-chassis lrp-public ch\novn-nbctl --wait=sb sync\n\n# Ingress router port ETH address is stored in lr_in_admission.\nAT_CHECK([ovn-sbctl lflow-list | grep -E \"lr_in_admission.*xreg0\\[[0..47\\]]\" | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.dst == 00:00:00:00:00:02 && inport == \"lrp-public\" && is_chassis_resident(\"ls-vm\")), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.dst == 00:00:00:00:01:00 && inport == \"lrp-public\" && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.mcast && inport == \"lrp\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , dnl\nmatch=(eth.mcast && inport == \"lrp-public\"), dnl\naction=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)\n])\n\n# Ingress router port is used for ARP reply/NA in lr_in_ip_input.\n# xxreg0[0..47] is used unless external_mac is set.\n# Priority 90 flows (per router).\nAT_CHECK_UNQUOTED([ovn-sbctl lflow-list | grep -E \"lr_in_ip_input.*priority=90\" | grep \"arp\\|nd\" | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.150), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.2), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.3), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(arp.op == 1 && arp.tpa == 43.43.43.4), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && arp.op == 1 && arp.tpa == \\$${lb_as_v4}), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && arp.op == 1 && arp.tpa == 42.42.42.1 && arp.spa == 42.42.42.0/24), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && ip6.dst == {fe80::200:ff:fe00:1, ff02::1:ff00:1} && nd_ns && nd.target == fe80::200:ff:fe00:1), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp\" && nd_ns && nd.target == \\$${lb_as_v6}), dnl\naction=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == \\$${lb_as_v4} && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.1 && arp.spa == 43.43.43.0/24), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && ip6.dst == {4343::1, ff02::1:ff00:1} && nd_ns && nd.target == 4343::1 && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && ip6.dst == {fe80::200:ff:fe00:100, ff02::1:ff00:100} && nd_ns && nd.target == fe80::200:ff:fe00:100 && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n  table=3 (lr_in_ip_input     ), priority=90   , dnl\nmatch=(inport == \"lrp-public\" && nd_ns && nd.target == \\$${lb_as_v6} && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)\n])\n\n# Priority 91 drop flows (per distributed gw port), if port is not resident.\nAT_CHECK([ovn-sbctl lflow-list | grep -E \"lr_in_ip_input.*priority=91\" | grep \"arp\\|nd\" | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=91   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.150), action=(drop;)\n  table=3 (lr_in_ip_input     ), priority=91   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.2), dnl\naction=(drop;)\n  table=3 (lr_in_ip_input     ), priority=91   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.3), dnl\naction=(drop;)\n  table=3 (lr_in_ip_input     ), priority=91   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.4), dnl\naction=(drop;)\n])\n\n# Priority 92 ARP/NS responders (per distributed gw port), if port is resident.\nAT_CHECK([ovn-sbctl lflow-list | grep -E \"lr_in_ip_input.*priority=92\" | grep \"arp\\|nd\" | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=92   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.150 && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=92   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.2 && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=92   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.3 && is_chassis_resident(\"cr-lrp-public\")), dnl\naction=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=3 (lr_in_ip_input     ), priority=92   , dnl\nmatch=(inport == \"lrp-public\" && arp.op == 1 && arp.tpa == 43.43.43.4 && is_chassis_resident(\"ls-vm\")), dnl\naction=(eth.dst = eth.src; eth.src = 00:00:00:00:00:02; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = 00:00:00:00:00:02; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n])\n\n# xreg0[0..47] isn't used anywhere else.\nAT_CHECK([ovn-sbctl lflow-list | grep \"xreg0\\[[0..47\\]]\" | grep -vE 'lr_in_admission|lr_in_ip_input'], [1], [])\n\nAT_CLEANUP\n])\n\n# This test case tests that when a logical switch has load balancers associated\n# (with VIPs configured), the below logical flow is added by ovn-northd.\n# table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n# This test case is added for the BZ -\n# https://bugzilla.redhat.com/show_bug.cgi?id=1849162\n#\n# ovn-northd was not adding the above lflow if the last load balancer associated\n# to the logical switch doesn't have the VIP configured even if other load\n# balancers before the last one in the last have VIPs configured.\n# So make sure that the above lflow is added even if one load balancer has VIP\n# associated.\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load balancer - missing ls_out_pre_lb flows])\novn_start\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1\n\novn-nbctl lb-add lb1 \"10.0.0.10\" \"10.0.0.3\"\novn-nbctl lb-add lb2 \"10.0.0.11\" \"10.0.0.4\"\n\novn-nbctl lb-add lb3 \"10.0.0.12\" \"10.0.0.5\"\novn-nbctl lb-add lb4 \"10.0.0.13\" \"10.0.0.6\"\n\nlb1=$(fetch_column nb:load_balancer _uuid name=lb1)\nlb2=$(fetch_column nb:load_balancer _uuid name=lb2)\nlb3=$(fetch_column nb:load_balancer _uuid name=lb3)\nlb4=$(fetch_column nb:load_balancer _uuid name=lb4)\n\nlbg=$(ovn-nbctl create load_balancer_group name=lbg)\ncheck ovn-nbctl add logical_switch  sw0 load_balancer_group $lbg\n\novn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n])\n\ncheck ovn-nbctl ls-lb-add sw0 lb1\ncheck ovn-nbctl add load_balancer_group $lbg load_balancer $lb3\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl ls-lb-add sw0 lb2\ncheck ovn-nbctl add load_balancer_group $lbg load_balancer $lb4\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl clear load_balancer $lb1 vips\ncheck ovn-nbctl clear load_balancer $lb3 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl clear load_balancer $lb2 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl clear load_balancer $lb4 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n])\n\ncheck ovn-nbctl set load_balancer $lb1 vips:\"10.0.0.10\"=\"10.0.0.3\"\ncheck ovn-nbctl set load_balancer $lb2 vips:\"10.0.0.11\"=\"10.0.0.4\"\ncheck ovn-nbctl set load_balancer $lb3 vips:\"10.0.0.12\"=\"10.0.0.5\"\ncheck ovn-nbctl set load_balancer $lb4 vips:\"10.0.0.13\"=\"10.0.0.6\"\n\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\n# Now reverse the order of clearing the vip.\ncheck ovn-nbctl clear load_balancer $lb2 vips\ncheck ovn-nbctl clear load_balancer $lb4 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl clear load_balancer $lb1 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n])\n\ncheck ovn-nbctl clear load_balancer $lb3 vips\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep \"ls_out_pre_lb.*priority=100\" | grep reg0 | sort], [0], [dnl\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ignore_lsp_down])\novn_start\n\novn-nbctl set NB_Global . options:ignore_lsp_down=false\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \"aa:aa:aa:aa:aa:aa 10.0.0.1\"\n\novn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep arp | grep 10\\.0\\.0\\.1], [1], [ignore])\n\novn-nbctl --wait=sb set NB_Global . options:ignore_lsp_down=true\nAT_CHECK([ovn-sbctl lflow-list | grep arp | grep 10\\.0\\.0\\.1], [0], [ignore])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd -- reject ACL])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1\n\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-p1\n\ncheck ovn-nbctl pg-add pg0 sw0-p1 sw1-p1\ncheck ovn-nbctl acl-add pg0 from-lport 1002 \"inport == @pg0 && ip4 && tcp && tcp.dst == 80\" reject\ncheck ovn-nbctl acl-add pg0 to-lport 1003 \"outport == @pg0 && ip6 && udp\" reject\n\ncheck ovn-nbctl --wait=sb sync\n\nAS_BOX([1])\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\novn-sbctl dump-flows sw1 > sw1flows\nAT_CAPTURE_FILE([sw1flows])\n\nAT_CHECK(\n  [grep -E 'ls_(in|out)_acl' sw0flows sw1flows | grep pg0 | sort], [0], [dnl\nsw0flows:  table=4 (ls_out_acl         ), priority=2003 , match=(outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw0flows:  table=8 (ls_in_acl          ), priority=2002 , match=(inport == @pg0 && ip4 && tcp && tcp.dst == 80), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=5); };)\nsw1flows:  table=4 (ls_out_acl         ), priority=2003 , match=(outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows:  table=8 (ls_in_acl          ), priority=2002 , match=(inport == @pg0 && ip4 && tcp && tcp.dst == 80), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=5); };)\n])\n\nAS_BOX([2])\n\novn-nbctl --wait=sb acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && udp\" reject\n\novn-sbctl dump-flows sw0 > sw0flows2\nAT_CAPTURE_FILE([sw0flows2])\novn-sbctl dump-flows sw1 > sw1flows2\nAT_CAPTURE_FILE([sw1flows2])\n\nAT_CHECK([grep \"ls_out_acl\" sw0flows2 sw1flows2 | grep pg0 | sort], [0], [dnl\nsw0flows2:  table=4 (ls_out_acl         ), priority=2002 , match=(outport == @pg0 && ip4 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw0flows2:  table=4 (ls_out_acl         ), priority=2003 , match=(outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows2:  table=4 (ls_out_acl         ), priority=2002 , match=(outport == @pg0 && ip4 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows2:  table=4 (ls_out_acl         ), priority=2003 , match=(outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\n])\n\nAS_BOX([3])\n\novn-nbctl --wait=sb acl-add pg0 to-lport 1001 \"outport == @pg0 && ip\" allow-related\n\novn-sbctl dump-flows sw0 > sw0flows3\nAT_CAPTURE_FILE([sw0flows3])\novn-sbctl dump-flows sw1 > sw1flows3\nAT_CAPTURE_FILE([sw1flows3])\n\nAT_CHECK([grep \"ls_out_acl\" sw0flows3 sw1flows3 | grep pg0 | sort], [0], [dnl\nsw0flows3:  table=4 (ls_out_acl         ), priority=2001 , match=(reg0[[7]] == 1 && (outport == @pg0 && ip)), action=(reg0[[1]] = 1; next;)\nsw0flows3:  table=4 (ls_out_acl         ), priority=2001 , match=(reg0[[8]] == 1 && (outport == @pg0 && ip)), action=(next;)\nsw0flows3:  table=4 (ls_out_acl         ), priority=2002 , match=((reg0[[10]] == 1) && outport == @pg0 && ip4 && udp), action=(ct_commit { ct_mark.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw0flows3:  table=4 (ls_out_acl         ), priority=2002 , match=((reg0[[9]] == 1) && outport == @pg0 && ip4 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw0flows3:  table=4 (ls_out_acl         ), priority=2003 , match=((reg0[[10]] == 1) && outport == @pg0 && ip6 && udp), action=(ct_commit { ct_mark.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw0flows3:  table=4 (ls_out_acl         ), priority=2003 , match=((reg0[[9]] == 1) && outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2001 , match=(reg0[[7]] == 1 && (outport == @pg0 && ip)), action=(reg0[[1]] = 1; next;)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2001 , match=(reg0[[8]] == 1 && (outport == @pg0 && ip)), action=(next;)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2002 , match=((reg0[[10]] == 1) && outport == @pg0 && ip4 && udp), action=(ct_commit { ct_mark.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2002 , match=((reg0[[9]] == 1) && outport == @pg0 && ip4 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2003 , match=((reg0[[10]] == 1) && outport == @pg0 && ip6 && udp), action=(ct_commit { ct_mark.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\nsw1flows3:  table=4 (ls_out_acl         ), priority=2003 , match=((reg0[[9]] == 1) && outport == @pg0 && ip6 && udp), action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=25); };)\n])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL fair Meters])\nAT_KEYWORDS([acl log meter fair])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \"50:54:00:00:00:01 10.0.0.11\"\ncheck ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 \"50:54:00:00:00:02 10.0.0.12\"\ncheck ovn-nbctl lsp-add sw1 sw1-p3 -- lsp-set-addresses sw1-p3 \"50:54:00:00:00:03 10.0.0.13\"\ncheck ovn-nbctl pg-add pg0 sw0-p1 sw0-p2 sw1-p3\n\ncheck ovn-nbctl meter-add meter_me drop 1 pktps\nnb_meter_uuid=$(fetch_column nb:Meter _uuid name=meter_me)\n\ncheck ovn-nbctl acl-add sw0 to-lport 1002 'outport == \"sw0-p1\" && ip4.src == 10.0.0.12' allow\ncheck ovn-nbctl acl-add sw0 to-lport 1002 'outport == \"sw0-p1\" && ip4.src == 10.0.0.13' allow\ncheck ovn-nbctl acl-add pg0 to-lport 1002 'outport == \"pg0\" && ip4.src == 10.0.0.11' drop\n\nacl1=$(ovn-nbctl --bare --column _uuid,match find acl | grep -F -B1 '10.0.0.12' | head -1)\nacl2=$(ovn-nbctl --bare --column _uuid,match find acl | grep -F -B1 '10.0.0.13' | head -1)\nacl3=$(ovn-nbctl --bare --column _uuid,match find acl | grep -F -B1 '10.0.0.11' | head -1)\ncheck ovn-nbctl set acl $acl1 log=true severity=alert meter=meter_me name=acl_one\ncheck ovn-nbctl set acl $acl2 log=true severity=info  meter=meter_me name=acl_two\ncheck ovn-nbctl set acl $acl3 log=true severity=info  meter=meter_me name=acl_three\ncheck ovn-nbctl --wait=sb sync\n\ncheck_row_count nb:meter 1\ncheck_column meter_me nb:meter name\n\ncheck_acl_lflow() {\n    acl_log_name=$1\n    meter_name=$2\n    ls=$3\n    echo \"checking that logical flow for acl log $acl_log_name has $meter_name\"\n    ovn-sbctl dump-flows $ls > sbflows\n    AT_CAPTURE_FILE([sbflows])\n    AT_CHECK([grep ls_out_acl sbflows | \\\n              grep \"\\\"${acl_log_name}\\\"\" | \\\n              grep -c \"meter=\\\"${meter_name}\\\"\"], [0], [1\n])\n}\n\ncheck_meter_by_name() {\n    [test \"$1\" = \"NOT\"] && { expected_count=0; shift; } || expected_count=1\n    for meter_name in $* ; do\n        # echo checking for $expected_count $meter_name in sb meter table\n        check_row_count meter $expected_count name=$meter_name\n    done\n}\n\nAS_BOX([Make sure 'fair' value properly affects the Meters in SB])\ncheck_meter_by_name meter_me\ncheck_meter_by_name NOT meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}\n\ncheck ovn-nbctl --wait=sb set Meter $nb_meter_uuid fair=true\ncheck_meter_by_name meter_me meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}\n\ncheck ovn-nbctl --wait=sb set Meter $nb_meter_uuid fair=false\ncheck_meter_by_name meter_me\ncheck_meter_by_name NOT meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}\n\ncheck ovn-nbctl --wait=sb set Meter $nb_meter_uuid fair=true\ncheck_meter_by_name meter_me meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}\n\nAS_BOX([Change template meter and make sure that is reflected on acl meters])\ntemplate_band=$(fetch_column nb:meter bands name=meter_me)\ncheck ovn-nbctl --wait=sb set meter_band $template_band rate=123\nAS_BOX([Make sure that every Meter_Band has the right rate.])\n# ovn-northd creates 4 identical Meter_Band rows, all identical;\nn_meter_bands=$(count_rows meter_band)\nAT_FAIL_IF([test \"$n_meter_bands\" != 4])\ncheck_row_count meter_band $n_meter_bands rate=123\n\nAS_BOX([Check meter in logical flows for acl logs])\ncheck_acl_lflow acl_one meter_me__${acl1} sw0\ncheck_acl_lflow acl_two meter_me__${acl2} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw1\n\nAS_BOX([Stop using meter for acl1])\ncheck ovn-nbctl --wait=sb clear acl $acl1 meter\ncheck_meter_by_name meter_me meter_me__${acl2}\ncheck_meter_by_name NOT meter_me__${acl1}\ncheck_acl_lflow acl_two meter_me__${acl2} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw1\n\nAS_BOX([Remove template Meter should remove all others as well])\ncheck ovn-nbctl --wait=sb meter-del meter_me\ncheck_row_count meter 0\nAS_BOX([Check that logical flow remains but uses non-unique meter])\ncheck_acl_lflow acl_two meter_me sw0\ncheck_acl_lflow acl_three meter_me sw0\ncheck_acl_lflow acl_three meter_me sw1\n\nAS_BOX([Re-add template meter and make sure acl2's meter is back in sb])\ncheck ovn-nbctl --wait=sb --fair meter-add meter_me drop 1 pktps\ncheck_meter_by_name meter_me meter_me__${acl2}\ncheck_meter_by_name NOT meter_me__${acl1}\ncheck_acl_lflow acl_two meter_me__${acl2} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw0\ncheck_acl_lflow acl_three meter_me__${acl3} sw1\n\nAS_BOX([Remove acl2])\nsw0=$(fetch_column nb:logical_switch _uuid name=sw0)\ncheck ovn-nbctl --wait=sb remove logical_switch $sw0 acls $acl2\ncheck_meter_by_name meter_me meter_me__${acl3}\ncheck_meter_by_name NOT meter_me__${acl1} meter_me__${acl2}\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Check NB-SB mirrors sync])\nAT_KEYWORDS([mirrors])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-port1\ncheck ovn-nbctl lsp-add sw0 sw0-port2\ncheck ovn-nbctl --wait=sb mirror-add mirror1 erspan 1 from-lport 10.10.10.2\ncheck_column mirror1 Mirror name\ncheck_column 10.10.10.2 Mirror sink\ncheck_column erspan Mirror type\ncheck_column 1 Mirror index\ncheck_column from-lport Mirror filter\n\ncheck ovn-nbctl --wait=sb set mirror . sink=192.168.1.13\n\ncheck_column 192.168.1.13 Mirror sink\ncheck_column erspan Mirror type\ncheck_column 1 Mirror index\ncheck_column from-lport Mirror filter\n\ncheck ovn-nbctl --wait=sb set mirror . type=gre\n\ncheck_column 192.168.1.13 Mirror sink\ncheck_column gre Mirror type\ncheck_column 1 Mirror index\ncheck_column from-lport Mirror filter\n\ncheck ovn-nbctl --wait=sb set mirror . index=12\n\ncheck_column 192.168.1.13 Mirror sink\ncheck_column gre Mirror type\ncheck_column 12 Mirror index\ncheck_column from-lport Mirror filter\n\ncheck ovn-nbctl --wait=sb set mirror . filter=to-lport\n\ncheck_column 192.168.1.13 Mirror sink\ncheck_column gre Mirror type\ncheck_column 12 Mirror index\ncheck_column to-lport Mirror filter\n\n# Verify mirror attach\ncheck ovn-nbctl --wait=sb lsp-attach-mirror sw0-port1 mirror1\n\nmirror1uuid=$(fetch_column sb:Mirror _uuid name=mirror1)\ncheck_column \"$mirror1uuid\" sb:Port_Binding mirror_rules logical_port=sw0-port1\n\ncheck ovn-nbctl --wait=sb mirror-add mirror2 gre 2 from-lport 10.10.10.2\ncheck_row_count sb:Mirror 2\n\n# Verify mirror detach (and another attach)\ncheck ovn-nbctl lsp-attach-mirror sw0-port1 mirror2\ncheck ovn-nbctl lsp-detach-mirror sw0-port1 mirror1\ncheck ovn-nbctl --wait=sb sync\n\nmirror2uuid=$(fetch_column sb:Mirror _uuid name=mirror2)\ncheck_column \"$mirror2uuid\" sb:Port_Binding mirror_rules logical_port=sw0-port1\n\n# Verify mirror-del (one by one)\ncheck ovn-nbctl --wait=sb mirror-del mirror2\ncheck_row_count sb:Mirror 1\ncheck ovn-nbctl --wait=sb mirror-del mirror1\ncheck_row_count sb:Mirror 0\ncheck_column \"\" sb:Port_Binding mirror_rules logical_port=sw0-port1\n\n# Verify mirror-add\ncheck ovn-nbctl --wait=sb mirror-add mirror2 gre 2 to-lport 10.10.10.2\ncheck_row_count sb:Mirror 1\n\ncheck_column 10.10.10.2 Mirror sink\ncheck_column gre Mirror type\ncheck_column 2 Mirror index\ncheck_column to-lport Mirror filter\n\n# Verify same attached to multiple ports\ncheck ovn-nbctl --wait=sb lsp-attach-mirror sw0-port1 mirror2\ncheck ovn-nbctl --wait=sb lsp-attach-mirror sw0-port2 mirror2\n\nmirror2uuid=$(fetch_column sb:Mirror _uuid name=mirror2)\ncheck_column \"$mirror2uuid\" sb:Port_Binding mirror_rules logical_port=sw0-port1\ncheck_column \"$mirror2uuid\" sb:Port_Binding mirror_rules logical_port=sw0-port2\n\n# Verify same port attached to multiple mirrors\ncheck ovn-nbctl --wait=sb mirror-add mirror1 erspan 1 to-lport 10.10.10.2\ncheck ovn-nbctl --wait=sb lsp-attach-mirror sw0-port1 mirror1\ncheck_row_count sb:Mirror 2\ncheck_row_count nb:Mirror 2\n\nmirror1uuid=$(fetch_column sb:Mirror _uuid name=mirror1)\ncheck_column \"$mirror2uuid $mirror1uuid\" sb:Port_Binding mirror_rules logical_port=sw0-port1\n\n# Verify delete (bulk)\ncheck ovn-nbctl --wait=sb mirror-del\ncheck_row_count nb:Mirror 0\ncheck_column \"\" nb:Logical_Switch_Port mirror_rules name=sw0-port1\ncheck_column \"\" nb:Logical_Switch_Port mirror_rules name=sw0-port2\ncheck_row_count sb:Mirror 0\ncheck_column \"\" sb:Port_Binding mirror_rules logical_port=sw0-port1\ncheck_column \"\" sb:Port_Binding mirror_rules logical_port=sw0-port2\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL skip hints for stateless config])\nAT_KEYWORDS([acl])\novn_start\n\ncheck ovn-nbctl --wait=sb \\\n    -- ls-add ls \\\n    -- lsp-add ls lsp \\\n    -- acl-add ls from-lport 1 \"ip\" allow \\\n    -- acl-add ls to-lport 1 \"ip\" allow\n\nAS_BOX([Check no match on ct_state with stateless ACLs])\nAT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl -e ls_out_acl | grep 'ct\\.' | sort], [0], [dnl\n])\n\nAS_BOX([Check match ct_state with stateful ACLs])\ncheck ovn-nbctl --wait=sb \\\n    -- acl-add ls from-lport 2 \"udp\" allow-related \\\n    -- acl-add ls to-lport 2 \"udp\" allow-related\nAT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl -e ls_out_acl | grep 'ct\\.' | sort], [0], [dnl\n  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n])\n\nAS_BOX([Check match ct_state with load balancer])\ncheck ovn-nbctl --wait=sb \\\n    -- acl-del ls from-lport 2 \"udp\" \\\n    -- acl-del ls to-lport 2 \"udp\" \\\n    -- lb-add lb \"10.0.0.1\" \"10.0.0.2\" \\\n    -- ls-lb-add ls lb\n\nAT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl -e ls_out_acl | sort], [0], [dnl\n  table=17(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=17(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=17(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=3 (ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=1001 , match=(reg0[[7]] == 1 && (ip)), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=1001 , match=(reg0[[8]] == 1 && (ip)), action=(next;)\n  table=4 (ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=4 (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=7 (ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=1001 , match=(reg0[[7]] == 1 && (ip)), action=(reg0[[1]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=1001 , match=(reg0[[8]] == 1 && (ip)), action=(next;)\n  table=8 (ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=8 (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\novn-nbctl --wait=sb clear logical_switch ls acls\novn-nbctl --wait=sb clear logical_switch ls load_balancer\n\nAT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl -e ls_out_acl | sort], [0], [dnl\n  table=17(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=17(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=3 (ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=4 (ls_out_acl         ), priority=65535, match=(1), action=(next;)\n  table=7 (ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=8 (ls_in_acl          ), priority=65535, match=(1), action=(next;)\n])\n\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([datapath requested-tnl-key])\nAT_KEYWORDS([requested tnl tunnel key keys])\novn_start\n\nget_tunnel_keys() {\n    set $(ovn-sbctl get datapath_binding ls0 tunnel_key \\\n                 -- get datapath_binding ls1 tunnel_key \\\n                 -- get datapath_binding ls2 tunnel_key)\n    echo \"ls0=$ls0 ls1=$ls1 ls2=$ls2\"\n    ls0=$1 ls1=$2 ls2=$3\n    AT_CHECK([test \"$ls0\" != \"$ls1\" && \\\n              test \"$ls1\" != \"$ls2\" && \\\n              test \"$ls0\" != \"$ls2\"])\n}\n\necho\necho \"__file__:__line__: Add three logical switches, check tunnel ids\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb ls-add ls0\n   ovn-nbctl --wait=sb ls-add ls1\n   ovn-nbctl --wait=sb ls-add ls2])\nget_tunnel_keys\nAT_CHECK([test $ls0 = 1 && test $ls1 = 2 && test $ls2 = 3])\n\necho\necho \"__file__:__line__: Assign ls0 new tunnel key, others don't change.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch ls0 other-config:requested-tnl-key=4])\nget_tunnel_keys\nAT_CHECK([test $ls0 = 4 && test $ls1 = 2 && test $ls2 = 3])\n\necho\necho \"__file__:__line__: Assign ls0 a conflict with ls1, which moves aside.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch ls0 other-config:requested-tnl-key=2])\nget_tunnel_keys\nAT_CHECK([test $ls0 = 2 && test $ls2 = 3])\n\necho\necho \"__file__:__line__: Assign ls0 and ls1 conflicts and verify that they end up different and ls2 doesn't change.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch ls1 other-config:requested-tnl-key=2])\nget_tunnel_keys\nAT_CHECK([test $ls2 = 3])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LR requested-tnl-key])\novn_start\n\novn-nbctl --wait=sb lr-add lr0\nAT_CHECK([test 1 = $(ovn-sbctl get datapath_binding lr0 tunnel_key)])\n\novn-nbctl --wait=sb lr-add lr1\nAT_CHECK([test 2 = $(ovn-sbctl get datapath_binding lr1 tunnel_key)])\n\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-router lr0 options:requested-tnl-key=100])\nAT_CHECK([test 100 = $(ovn-sbctl get datapath_binding lr0 tunnel_key)])\n\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-router lr1 options:requested-tnl-key=100])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([port requested-tnl-key])\nAT_KEYWORDS([requested tnl tunnel key keys])\novn_start\n\nget_tunnel_keys() {\n    set $(ovn-sbctl get port_binding lsp00 tunnel_key \\\n                 -- get port_binding lsp01 tunnel_key \\\n                 -- get port_binding lsp02 tunnel_key \\\n                 -- get port_binding lsp10 tunnel_key \\\n                 -- get port_binding lsp11 tunnel_key \\\n                 -- get port_binding lsp12 tunnel_key)\n    lsp00=$1 lsp01=$2 lsp02=$3 lsp10=$4 lsp11=$5 lsp12=$6\n    ls0=$1$2$3 ls1=$4$5$6\n    echo \"ls0=$1$2$3 ls1=$4$5$6\"\n    AT_CHECK([test \"$lsp00\" != \"$lsp01\" && \\\n              test \"$lsp01\" != \"$lsp02\" && \\\n              test \"$lsp00\" != \"$lsp02\"])\n    AT_CHECK([test \"$lsp10\" != \"$lsp11\" && \\\n              test \"$lsp11\" != \"$lsp12\" && \\\n              test \"$lsp10\" != \"$lsp12\"])\n}\n\necho\necho \"__file__:__line__: Add two logical switches with three ports each, check tunnel ids\"\nAT_CHECK(\n  [for i in 0 1; do\n       ovn-nbctl --wait=sb ls-add ls$i || exit $?\n       for j in 0 1 2; do\n           ovn-nbctl --wait=sb lsp-add ls$i lsp$i$j || exit $?\n       done\n   done])\nget_tunnel_keys\nAT_CHECK([test $ls0 = 123 && test $ls1 = 123])\n\necho\necho \"__file__:__line__: Assign lsp00 new tunnel key, others don't change.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch-port lsp00 options:requested-tnl-key=4])\nget_tunnel_keys\nAT_CHECK([test $ls0 = 423 && test $ls1 = 123])\n\necho\necho \"__file__:__line__: Assign lsp00 a conflict with lsp01, which moves aside.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch-port lsp00 options:requested-tnl-key=2])\nget_tunnel_keys\nAT_CHECK([test $lsp00 = 2 && test $lsp02 = 3 && test $ls1 = 123])\n\necho\necho \"__file__:__line__: Assign lsp00 and lsp01 conflicts and verify that they end up different and lsp02 doesn't change.\"\nAT_CHECK(\n  [ovn-nbctl --wait=sb set logical-switch-port lsp01 options:requested-tnl-key=2])\nget_tunnel_keys\nAT_CHECK([test $lsp02 = 3 && test $ls1 = 123])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([NB to SB load balancer sync])\novn_start\n\ncheck ovn-nbctl lb-add lb0 10.0.0.10:80 10.0.0.4:8080\ncheck ovn-nbctl --wait=sb lb-add lbg0 20.0.0.10:80 20.0.0.4:8080\ncheck_row_count nb:load_balancer 2\n\necho\necho \"__file__:__line__: Check that there are no SB load balancer rows.\"\ncheck_row_count sb:load_balancer 0\n\nlbg0=$(fetch_column nb:load_balancer _uuid name=lbg0)\nlbg=$(ovn-nbctl create load_balancer_group name=lbg)\ncheck ovn-nbctl add load_balancer_group $lbg load_balancer $lbg0\ncheck ovn-nbctl ls-add sw0 -- add logical_switch sw0 load_balancer_group $lbg\ncheck ovn-nbctl --wait=sb ls-lb-add sw0 lb0\nsw0_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw0)\n\necho\necho \"__file__:__line__: Check that there is one SB load balancer row for lb0 and one for lbg0\"\ncheck_row_count sb:load_balancer 2\ncheck_column \"10.0.0.10:80=10.0.0.4:8080 tcp\" sb:load_balancer vips,protocol name=lb0\ncheck_column \"20.0.0.10:80=20.0.0.4:8080 tcp\" sb:load_balancer vips,protocol name=lbg0\n\nlb0_uuid=$(fetch_column sb:load_balancer _uuid name=lb0)\nlbg0_uuid=$(fetch_column sb:load_balancer _uuid name=lbg0)\n\necho\necho \"__file__:__line__: Check that SB lb0 has sw0 in datapaths column.\"\n\nlb0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lb0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lb0_dp_group | tail -1], [0], [dnl\n$sw0_sb_uuid\n])\n\ncheck_column \"\" sb:datapath_binding load_balancers external_ids:name=sw0\n\necho\necho \"__file__:__line__: Check that SB lbg0 has sw0 in datapaths column.\"\n\nlbg0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lbg0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lbg0_dp_group | tail -1], [0], [dnl\n$sw0_sb_uuid\n])\n\ncheck_column \"\" sb:datapath_binding load_balancers external_ids:name=sw0\n\ncheck ovn-nbctl --wait=sb set load_balancer lb0 vips:\"10.0.0.20\\:90\"=\"20.0.0.4:8080,30.0.0.4:8080\"\n\necho\necho \"__file__:__line__: Check that SB lb0 has vips and protocol columns are set properly.\"\n\ncheck_column \"10.0.0.10:80=10.0.0.4:8080 10.0.0.20:90=20.0.0.4:8080,30.0.0.4:8080 tcp\" \\\nsb:load_balancer vips,protocol name=lb0\n\ncheck ovn-nbctl --wait=sb set load_balancer lbg0 vips:\"20.0.0.20\\:90\"=\"20.0.0.4:8080,30.0.0.4:8080\"\n\necho\necho \"__file__:__line__: Check that SB lbg0 has vips and protocol columns are set properly.\"\n\ncheck_column \"20.0.0.10:80=20.0.0.4:8080 20.0.0.20:90=20.0.0.4:8080,30.0.0.4:8080 tcp\" \\\nsb:load_balancer vips,protocol name=lbg0\n\ncheck ovn-nbctl lr-add lr0 -- add logical_router lr0 load_balancer_group $lbg\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb0\n\necho\necho \"__file__:__line__: Check that SB lb0 has only sw0 in datapaths column.\"\nlb0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lb0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lb0_dp_group | tail -1], [0], [dnl\n$sw0_sb_uuid\n])\n\necho\necho \"__file__:__line__: Check that SB lbg0 has only sw0 in datapaths column.\"\nlbg0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lbg0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lbg0_dp_group | tail -1], [0], [dnl\n$sw0_sb_uuid\n])\n\ncheck ovn-nbctl ls-add sw1 -- add logical_switch sw1 load_balancer_group $lbg\ncheck ovn-nbctl --wait=sb ls-lb-add sw1 lb0\nsw1_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw1)\n\necho \"$sw0_sb_uuid\" > sw_sb_uuids\necho \"$sw1_sb_uuid\" >> sw_sb_uuids\n\necho\necho \"__file__:__line__: Check that SB lb0 has sw0 and sw1 in datapaths column.\"\nlb0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lb0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lb0_dp_group | tail -1 | tr ' ' '\\n' | sort], [0], [dnl\n$(cat sw_sb_uuids | sort)\n])\n\necho\necho \"__file__:__line__: Check that SB lbg0 has sw0 and sw1 in datapaths column.\"\nlbg0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lbg0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lbg0_dp_group | tail -1 | tr ' ' '\\n' | sort], [0], [dnl\n$(cat sw_sb_uuids | sort)\n])\n\ncheck_column \"\" sb:datapath_binding load_balancers external_ids:name=sw1\n\ncheck ovn-nbctl --wait=sb lb-add lb1 10.0.0.30:80 20.0.0.50:8080 udp\ncheck ovn-nbctl --wait=sb lb-add lbg1 20.0.0.30:80 20.0.0.50:8080 udp\ncheck_row_count sb:load_balancer 2\n\nlbg1=$(fetch_column nb:load_balancer _uuid name=lbg1)\ncheck ovn-nbctl add load_balancer_group $lbg load_balancer $lbg1\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb1\ncheck_row_count sb:load_balancer 3\n\necho\necho \"__file__:__line__: Associate lb1 to sw1 and check that lb1 is created in SB DB.\"\n\ncheck ovn-nbctl --wait=sb ls-lb-add sw1 lb1\ncheck_row_count sb:load_balancer 4\n\necho\necho \"__file__:__line__: Check that SB lb1 has vips and protocol columns are set properly.\"\ncheck_column \"10.0.0.30:80=20.0.0.50:8080 udp\" sb:load_balancer vips,protocol name=lb1\n\necho\necho \"__file__:__line__: Check that SB lbg1 has vips and protocol columns are set properly.\"\ncheck_column \"20.0.0.30:80=20.0.0.50:8080 udp\" sb:load_balancer vips,protocol name=lbg1\n\nlb1_uuid=$(fetch_column sb:load_balancer _uuid name=lb1)\nlb1_dp_group=$(fetch_column sb:load_balancer datapath_group name=lb1)\n\necho\necho \"__file__:__line__: Check that SB lb1 has sw1 in datapaths column.\"\n\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lb1_dp_group | tail -1], [0], [dnl\n$sw1_sb_uuid\n])\n\nlbg1_uuid=$(fetch_column sb:load_balancer _uuid name=lbg1)\nlbg1_dp_group=$(fetch_column sb:load_balancer datapath_group name=lbg1)\n\necho\necho \"__file__:__line__: Check that SB lbg1 has sw0 and sw1 in datapaths column.\"\n\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lbg1_dp_group | tail -1 | tr ' ' '\\n' | sort], [0], [dnl\n$(cat sw_sb_uuids | sort)\n])\n\necho\necho \"__file__:__line__: check that datapath sw1 has no entry in the load_balancers column.\"\ncheck_column \"\" sb:datapath_binding load_balancers external_ids:name=sw1\n\necho\necho \"__file__:__line__: Set hairpin_snat_ip on lb1 and check that SB DB is updated.\"\ncheck ovn-nbctl --wait=sb set Load_Balancer lb1 options:hairpin_snat_ip=\"42.42.42.42 4242::4242\"\ncheck_column \"$lb1_uuid\" sb:load_balancer _uuid name=lb1 options='{hairpin_orig_tuple=\"true\", hairpin_snat_ip=\"42.42.42.42 4242::4242\"}'\n\necho\necho \"__file__:__line__: Delete load balancers lb1 and lbg1 and check that datapath sw1's load_balancers is still empty.\"\n\novn-nbctl --wait=sb lb-del lb1 -- lb-del lbg1\ncheck_column \"\" sb:datapath_binding load_balancers external_ids:name=sw1\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LS load balancer hairpin logical flows])\novn_start\n\nlbg=$(ovn-nbctl create load_balancer_group name=lbg)\n\ncheck ovn-nbctl \\\n    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080\n\nlb0=$(fetch_column nb:load_balancer _uuid name=lb0)\n\ncheck ovn-nbctl \\\n    -- ls-add sw0 -- \\\n    -- add logical_switch sw0 load_balancer_group $lbg \\\n    -- ls-lb-add sw0 lb0\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_pre_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_pre_hairpin  ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_hairpin  ), priority=100  , match=(ip && ct.trk), action=(reg0[[6]] = chk_lb_hairpin(); reg0[[12]] = chk_lb_hairpin_reply(); next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_nat_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_nat_hairpin  ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.est && ct.trk && reg0[[6]] == 1), action=(ct_snat;)\n  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.new && ct.trk && reg0[[6]] == 1), action=(ct_snat_to_vip; next;)\n  table=??(ls_in_nat_hairpin  ), priority=90   , match=(ip && reg0[[12]] == 1), action=(ct_snat;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_hairpin | sort | sed 's/table=../table=??/g'], [0], [dnl\n  table=??(ls_in_hairpin      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_hairpin      ), priority=1    , match=((reg0[[6]] == 1 || reg0[[12]] == 1)), action=(eth.dst <-> eth.src; outport = inport; flags.loopback = 1; output;)\n])\n\ncheck ovn-nbctl -- ls-lb-del sw0 lb0\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_pre_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_pre_hairpin  ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_nat_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_nat_hairpin  ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_hairpin | sort | sed 's/table=../table=??/g'], [0], [dnl\n  table=??(ls_in_hairpin      ), priority=0    , match=(1), action=(next;)\n])\n\ncheck ovn-nbctl -- add load_balancer_group $lbg load_balancer $lb0\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_pre_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_pre_hairpin  ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_hairpin  ), priority=100  , match=(ip && ct.trk), action=(reg0[[6]] = chk_lb_hairpin(); reg0[[12]] = chk_lb_hairpin_reply(); next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_nat_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_nat_hairpin  ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.est && ct.trk && reg0[[6]] == 1), action=(ct_snat;)\n  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.new && ct.trk && reg0[[6]] == 1), action=(ct_snat_to_vip; next;)\n  table=??(ls_in_nat_hairpin  ), priority=90   , match=(ip && reg0[[12]] == 1), action=(ct_snat;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_hairpin | sort | sed 's/table=../table=??/g'], [0], [dnl\n  table=??(ls_in_hairpin      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_hairpin      ), priority=1    , match=((reg0[[6]] == 1 || reg0[[12]] == 1)), action=(eth.dst <-> eth.src; outport = inport; flags.loopback = 1; output;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Router policies - ECMP reroute])\nAT_KEYWORDS([router policies ecmp reroute])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-port1\ncheck ovn-nbctl lsp-set-addresses sw0-port1 \"50:54:00:00:00:03 10.0.0.3\"\n\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-port1\ncheck ovn-nbctl lsp-set-addresses sw1-port1 \"40:54:00:00:00:03 20.0.0.3\"\n\n# Create a logical router and attach both logical switches\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64\ncheck ovn-nbctl lsp-add sw1 sw1-lr0\ncheck ovn-nbctl lsp-set-type sw1-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options sw1-lr0 router-port=lr-sw1\n\ncheck ovn-nbctl ls-add public\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24\ncheck ovn-nbctl lsp-add public public-lr0\ncheck ovn-nbctl lsp-set-type public-lr0 router\ncheck ovn-nbctl lsp-set-addresses public-lr0 router\ncheck ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public\n\ncheck ovn-nbctl --wait=sb lr-policy-add lr0  10 \"ip4.src == 10.0.0.3\" reroute 172.168.0.101,172.168.0.102\n\novn-nbctl lr-policy-list lr0 > policy-list\nAT_CAPTURE_FILE([policy-list])\nAT_CHECK([cat policy-list], [0], [dnl\nRouting Policies\n        10                                ip4.src == 10.0.0.3         reroute             172.168.0.101, 172.168.0.102\n])\n\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = 0; next;)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.3), action=(reg8[[0..15]] = 1; reg8[[16..31]] = select(1, 2);)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb lr-policy-add lr0  10 \"ip4.src == 10.0.0.4\" reroute 172.168.0.101,172.168.0.102,172.168.0.103\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 |  \\\nsed 's/reg8\\[[0..15\\]] = [[0-9]]*/reg8\\[[0..15\\]] = <cleared>/' | \\\nsed 's/reg8\\[[0..15\\]] == [[0-9]]*/reg8\\[[0..15\\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.3), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2);)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.4), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2, 3);)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 3), action=(reg0 = 172.168.0.103; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb lr-policy-add lr0  10 \"ip4.src == 10.0.0.5\" reroute 172.168.0.110\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 |  \\\nsed 's/reg8\\[[0..15\\]] = [[0-9]]*/reg8\\[[0..15\\]] = <cleared>/' | \\\nsed 's/reg8\\[[0..15\\]] == [[0-9]]*/reg8\\[[0..15\\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.3), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2);)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.4), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2, 3);)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.5), action=(reg0 = 172.168.0.110; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 3), action=(reg0 = 172.168.0.103; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb lr-policy-del lr0  10 \"ip4.src == 10.0.0.3\"\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 |  \\\nsed 's/reg8\\[[0..15\\]] = [[0-9]]*/reg8\\[[0..15\\]] = <cleared>/' | \\\nsed 's/reg8\\[[0..15\\]] == [[0-9]]*/reg8\\[[0..15\\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.4), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2, 3);)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.5), action=(reg0 = 172.168.0.110; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 3), action=(reg0 = 172.168.0.103; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb lr-policy-del lr0  10 \"ip4.src == 10.0.0.4\"\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 |  \\\nsed 's/reg8\\[[0..15\\]] = [[0-9]]*/reg8\\[[0..15\\]] = <cleared>/' | \\\nsed 's/reg8\\[[0..15\\]] == [[0-9]]*/reg8\\[[0..15\\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.5), action=(reg0 = 172.168.0.110; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb add logical_router_policy . nexthops \"2000\\:\\:b\"\novn-sbctl dump-flows lr0 > lr0flows3\nAT_CAPTURE_FILE([lr0flows3])\n\nAT_CHECK([grep \"lr_in_policy\" lr0flows3 |  \\\nsed 's/reg8\\[[0..15\\]] = [[0-9]]*/reg8\\[[0..15\\]] = <cleared>/' | \\\nsed 's/reg8\\[[0..15\\]] == [[0-9]]*/reg8\\[[0..15\\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)\n  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL allow-stateless omit conntrack - Logical_Switch])\novn_start\n\novn-nbctl ls-add ls\novn-nbctl lsp-add ls lsp1\novn-nbctl lsp-set-addresses lsp1 00:00:00:00:00:01\novn-nbctl lsp-add ls lsp2\novn-nbctl lsp-set-addresses lsp2 00:00:00:00:00:02\n\nfor direction in from to; do\n    ovn-nbctl acl-add ls ${direction}-lport 3 \"tcp\" allow-related\n    ovn-nbctl acl-add ls ${direction}-lport 2 \"udp\" allow-related\n    ovn-nbctl acl-add ls ${direction}-lport 1 \"ip\" drop\ndone\novn-nbctl --wait=sb sync\n\nflow_eth='eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02'\nflow_ip='ip.ttl==64 && ip4.src == 42.42.42.1 && ip4.dst == 66.66.66.66'\nflow_tcp='tcp && tcp.dst == 80'\nflow_udp='udp && udp.dst == 80'\n\nlsp1_inport=$(fetch_column Port_Binding tunnel_key logical_port=lsp1)\n\n# TCP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# UDP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# Allow stateless for TCP.\nfor direction in from to; do\n    ovn-nbctl acl-add ls ${direction}-lport 4 tcp allow-stateless\ndone\novn-nbctl --wait=sb sync\n\n# TCP packets should not go to conntrack anymore.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\n# UDP packets still go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# Add a load balancer.\novn-nbctl lb-add lb-tcp 66.66.66.66:80 42.42.42.2:8080 tcp\novn-nbctl lb-add lb-udp 66.66.66.66:80 42.42.42.2:8080 udp\novn-nbctl ls-lb-add ls lb-tcp\novn-nbctl ls-lb-add ls lb-udp\n\n# Remove stateless for TCP.\novn-nbctl acl-del ls\novn-nbctl --wait=sb sync\n\n# TCP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\n# UDP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\n# Allow stateless for TCP.\nfor direction in from to; do\n    ovn-nbctl acl-add ls ${direction}-lport 4 tcp allow-stateless\ndone\novn-nbctl --wait=sb sync\n\n# TCP packets should not go to conntrack for load balancing.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\n# UDP packets still go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL allow-stateless omit conntrack - Port_Group])\novn_start\n\novn-nbctl ls-add ls\novn-nbctl lsp-add ls lsp1\novn-nbctl lsp-set-addresses lsp1 00:00:00:00:00:01\novn-nbctl lsp-add ls lsp2\novn-nbctl lsp-set-addresses lsp2 00:00:00:00:00:02\n\novn-nbctl pg-add pg lsp1 lsp2\n\nfor direction in from to; do\n    ovn-nbctl acl-add pg ${direction}-lport 3 \"tcp\" allow-related\n    ovn-nbctl acl-add pg ${direction}-lport 2 \"udp\" allow-related\n    ovn-nbctl acl-add pg ${direction}-lport 1 \"ip\" drop\ndone\novn-nbctl --wait=sb sync\n\nlsp1_inport=$(fetch_column Port_Binding tunnel_key logical_port=lsp1)\necho $lsp1_inport\n\nflow_eth='eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02'\nflow_ip='ip.ttl==64 && ip4.src == 42.42.42.1 && ip4.dst == 66.66.66.66'\nflow_tcp='tcp && tcp.dst == 80'\nflow_udp='udp && udp.dst == 80'\n\n# TCP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# UDP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# Allow stateless for TCP.\nfor direction in from to; do\n    ovn-nbctl acl-add pg ${direction}-lport 4 tcp allow-stateless\ndone\novn-nbctl --wait=sb sync\n\n# TCP packets should not go to conntrack anymore.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\n# UDP packets still go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# Add a load balancer.\novn-nbctl lb-add lb-tcp 66.66.66.66:80 42.42.42.2:8080 tcp\novn-nbctl lb-add lb-udp 66.66.66.66:80 42.42.42.2:8080 udp\novn-nbctl ls-lb-add ls lb-tcp\novn-nbctl ls-lb-add ls lb-udp\n\n# Remove stateless for TCP.\novn-nbctl acl-del pg\novn-nbctl --wait=sb sync\n\n# TCP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\n# UDP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\n# Allow stateless for TCP.\nfor direction in from to; do\n    ovn-nbctl acl-add pg ${direction}-lport 4 tcp allow-stateless\ndone\novn-nbctl --wait=sb sync\n\n# TCP packets should not go to conntrack for load balancing.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\n# UDP packets still go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_lb_mark {\n    ct_lb_mark {\n        reg0[[6]] = 0;\n        reg0[[12]] = 0;\n        ct_lb_mark /* default (use --ct to customize) */ {\n            output(\"lsp2\");\n        };\n    };\n};\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL allow-stateless overrides stateful rules with higher priority - Logical_Switch])\novn_start\n\novn-nbctl ls-add ls\novn-nbctl lsp-add ls lsp1\novn-nbctl lsp-set-addresses lsp1 00:00:00:00:00:01\novn-nbctl lsp-add ls lsp2\novn-nbctl lsp-set-addresses lsp2 00:00:00:00:00:02\n\nfor direction in from to; do\n    ovn-nbctl acl-add ls ${direction}-lport 3 \"tcp\" allow-related\n    ovn-nbctl acl-add ls ${direction}-lport 3 \"udp\" allow\ndone\novn-nbctl --wait=sb sync\n\nflow_eth='eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02'\nflow_ip='ip.ttl==64 && ip4.src == 42.42.42.1 && ip4.dst == 66.66.66.66'\nflow_tcp='tcp && tcp.dst == 80'\nflow_udp='udp && udp.dst == 80'\n\nlsp1_inport=$(fetch_column Port_Binding tunnel_key logical_port=lsp1)\n\n# TCP packets should go to conntrack.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk) {\n    ct_next(ct_state=new|trk) {\n        output(\"lsp2\");\n    };\n};\n])\n\n# Allow stateless with *lower* priority. It always beats stateful rules.\nfor direction in from to; do\n    ovn-nbctl acl-add ls ${direction}-lport 1 tcp allow-stateless\n    ovn-nbctl acl-add ls ${direction}-lport 1 udp allow-stateless\ndone\novn-nbctl --wait=sb sync\n\n# TCP packets should not go to conntrack anymore.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}\"\nAT_CHECK_UNQUOTED([ovn_trace --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\n# UDP packets should not go to conntrack anymore.\nflow=\"inport == \\\"lsp1\\\" && ${flow_eth} && ${flow_ip} && ${flow_udp}\"\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check BFD config propagation to SBDB])\nAT_KEYWORDS([northd-bfd])\novn_start\n\ncheck ovn-nbctl --wait=sb lr-add r0\nfor i in $(seq 1 7); do\n    check ovn-nbctl --wait=sb lrp-add r0 r0-sw$i 00:00:00:00:00:0$i 192.168.$i.1/24\n    check ovn-nbctl --wait=sb ls-add sw$i\n    check ovn-nbctl --wait=sb lsp-add sw$i sw$i-r0\n    check ovn-nbctl --wait=sb lsp-set-type sw$i-r0 router\n    check ovn-nbctl --wait=sb lsp-set-options sw$i-r0 router-port=r0-sw$i\n    check ovn-nbctl --wait=sb lsp-set-addresses sw$i-r0 00:00:00:00:00:0$i\ndone\n\nuuid=$(ovn-nbctl create bfd logical_port=r0-sw1 dst_ip=192.168.1.2 status=down min_tx=250 min_rx=250 detect_mult=10)\novn-nbctl create bfd logical_port=r0-sw2 dst_ip=192.168.2.2 status=down min_tx=500 min_rx=500 detect_mult=20\novn-nbctl create bfd logical_port=r0-sw3 dst_ip=192.168.3.2 status=down\novn-nbctl create bfd logical_port=r0-sw4 dst_ip=192.168.4.2 status=down min_tx=0 detect_mult=0\n\nwait_row_count bfd 1 logical_port=r0-sw1 detect_mult=10 dst_ip=192.168.1.2 \\\n                     min_rx=250 min_tx=250 status=admin_down\nwait_row_count bfd 1 logical_port=r0-sw2 detect_mult=20 dst_ip=192.168.2.2 \\\n                     min_rx=500 min_tx=500 status=admin_down\nwait_row_count bfd 1 logical_port=r0-sw3 detect_mult=5 dst_ip=192.168.3.2 \\\n                     min_rx=1000 min_tx=1000 status=admin_down\n\nuuid=$(fetch_column nb:bfd _uuid logical_port=r0-sw1)\ncheck ovn-nbctl set bfd $uuid min_tx=1000 min_rx=1000 detect_mult=100\n\nuuid_2=$(fetch_column nb:bfd _uuid logical_port=r0-sw2)\ncheck ovn-nbctl clear bfd $uuid_2 min_rx\nwait_row_count bfd 1 logical_port=r0-sw2 min_rx=1000\nwait_row_count bfd 1 logical_port=r0-sw1 min_rx=1000 min_tx=1000 detect_mult=100\n\ncheck ovn-nbctl --bfd=$uuid lr-route-add r0 100.0.0.0/8 192.168.1.2\nwait_column down bfd status logical_port=r0-sw1\nAT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.1.2 | grep -q bfd],[0])\n\ncheck ovn-nbctl --bfd lr-route-add r0 200.0.0.0/8 192.168.2.2\nwait_column down bfd status logical_port=r0-sw2\nAT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.2.2 | grep -q bfd],[0])\n\ncheck ovn-nbctl --bfd lr-route-add r0 240.0.0.0/8 192.168.5.2 r0-sw5\nwait_column down bfd status logical_port=r0-sw5\nAT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.5.2 | grep -q bfd],[0])\n\ncheck ovn-nbctl --bfd --policy=src-ip lr-route-add r0 192.168.6.1/32 192.168.10.10 r0-sw6\nwait_column down bfd status logical_port=r0-sw6\nAT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.6.1 | grep -q bfd],[0])\n\ncheck ovn-nbctl --bfd --policy=src-ip lr-route-add r0 192.168.7.1/32 192.168.10.10 r0-sw7\nwait_column down bfd status logical_port=r0-sw7\nAT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.7.1 | grep -q bfd],[0])\n\nroute_uuid=$(fetch_column nb:logical_router_static_route _uuid ip_prefix=\"100.0.0.0/8\")\ncheck ovn-nbctl clear logical_router_static_route $route_uuid bfd\nwait_column admin_down bfd status logical_port=r0-sw1\n\novn-nbctl destroy bfd $uuid\nwait_row_count bfd 5\n\n# Simulate BFD up in Southbound for an automatically created entry.\n# This entry is referenced so the state in the Northbound should also\n# become \"up\".\nwait_column down nb:bfd status logical_port=r0-sw2\nbfd2_uuid=$(fetch_column bfd _uuid logical_port=r0-sw2)\ncheck ovn-sbctl set bfd $bfd2_uuid status=up\nwait_column up nb:bfd status logical_port=r0-sw2\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- check CoPP config])\nAT_KEYWORDS([northd-CoPP])\n\novn_start\n\ncheck ovn-nbctl --wait=sb lr-add r0\ncheck ovn-nbctl --wait=sb lrp-add r0 r0-sw1 00:00:00:00:00:01 192.168.1.1/24\ncheck ovn-nbctl --wait=sb ls-add sw1\ncheck ovn-nbctl --wait=sb lsp-add sw1 sw1-r0\ncheck ovn-nbctl --wait=sb lsp-set-type sw1-r0 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw1-r0 router-port=r0-sw1\ncheck ovn-nbctl --wait=sb lsp-set-addresses sw1-r0 00:00:00:00:00:01\n\ncheck ovn-nbctl --event lb-add lb0 192.168.1.100:80 \"\"\ncheck ovn-nbctl ls-lb-add sw1 lb0\ncheck ovn-nbctl --wait=hv meter-add meter0 drop 100 pktps 10\ncheck ovn-nbctl --wait=hv copp-add copp0 event-elb meter0\ncheck ovn-nbctl --wait=hv ls-copp-add copp0 sw1\nAT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl\nevent-elb: meter0\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep trigger_event -A 2 | grep -q meter0])\n\ncheck ovn-nbctl --wait=hv meter-add meter1 drop 300 pktps 10\nAT_CHECK([ovn-nbctl meter-list |grep meter1 -A 1], [0], [dnl\nmeter1: bands:\n  drop: 300 pktps, 10 packet burst\n])\ncheck ovn-nbctl --wait=hv --may-exist meter-add meter1 drop 200 pktps 10\nAT_CHECK([ovn-nbctl meter-list |grep meter1 -A 1], [0], [dnl\nmeter1: bands:\n  drop: 200 pktps, 10 packet burst\n])\ncheck ovn-nbctl --wait=hv copp-add copp1 arp meter1\ncheck ovn-nbctl --wait=hv lr-copp-add copp1 r0\nAT_CHECK([ovn-nbctl copp-list copp1], [0], [dnl\narp: meter1\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep arp -A 2 | grep -q meter1])\n\ncheck ovn-nbctl --wait=hv copp-del copp1 arp\nAT_CHECK([ovn-nbctl copp-list copp1], [0], [dnl\n])\nAT_CHECK([ovn-sbctl list logical_flow | grep arp -A 2 | grep -q meter1],[1])\n\ncheck ovn-nbctl --wait=hv meter-add meter2 drop 400 pktps 10\ncheck ovn-nbctl --wait=hv copp-add copp2 icmp4-error meter2\ncheck ovn-nbctl --wait=hv lr-copp-add copp2 r0\nAT_CHECK([ovn-nbctl copp-list copp2], [0], [dnl\nicmp4-error: meter2\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep icmp4 -A 2 | grep -q meter2])\n\ncheck ovn-nbctl --wait=hv copp-del copp2 icmp4-error\nAT_CHECK([ovn-nbctl copp-list copp2], [0], [dnl\n])\n\ncheck ovn-nbctl --wait=hv copp-add copp3 icmp6-error meter2\ncheck ovn-nbctl --wait=hv lr-copp-add copp3 r0\nAT_CHECK([ovn-nbctl copp-list copp3], [0], [dnl\nicmp6-error: meter2\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep icmp6 -A 2 | grep -q meter2])\n\ncheck ovn-nbctl --wait=hv copp-del copp3 icmp6-error\nAT_CHECK([ovn-nbctl copp-list copp3], [0], [dnl\n])\n\ncheck ovn-nbctl --wait=hv copp-add copp4 tcp-reset meter2\ncheck ovn-nbctl --wait=hv lr-copp-add copp4 r0\nAT_CHECK([ovn-nbctl copp-list copp4], [0], [dnl\ntcp-reset: meter2\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep tcp -A 2 | grep -q meter2])\n\ncheck ovn-nbctl --wait=hv copp-del copp4 tcp-reset\nAT_CHECK([ovn-nbctl copp-list copp4], [0], [dnl\n])\n\ncheck ovn-nbctl --wait=hv copp-del copp0 event-elb\nAT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl\n])\n\nAT_CHECK([ovn-sbctl list logical_flow | grep trigger_event -A 2 | grep -q meter0],[1])\n\n# let's try to add an usupported protocol \"dhcp\"\nAT_CHECK([ovn-nbctl --wait=hv copp-add copp5 dhcp meter1],[1],[],[dnl\novn-nbctl: Invalid control protocol. Allowed values: arp, arp-resolve, dhcpv4-opts, dhcpv6-opts, dns, event-elb, icmp4-error, icmp6-error, igmp, nd-na, nd-ns, nd-ns-resolve, nd-ra-opts, tcp-reset, bfd, reject, svc-monitor.\n])\n\n#Let's try to add a valid protocol to an unknown datapath\ncheck ovn-nbctl --wait=hv copp-add copp6 arp meter1\nAT_CHECK([ovn-nbctl --wait=hv ls-copp-add copp6 sw10],[1],[],[dnl\novn-nbctl: sw10: switch name not found\n])\n\ncheck ovn-nbctl --bfd lr-route-add r0 240.0.0.0/8 192.168.50.2 r0-sw1\ncheck ovn-nbctl --wait=hv copp-add copp7 bfd meter0\ncheck ovn-nbctl --wait=hv lr-copp-add copp7 r0\nAT_CHECK([ovn-nbctl copp-list copp7], [0], [dnl\nbfd: meter0\n])\nAT_CHECK([ovn-sbctl list logical_flow | grep bfd -A 2 | grep -q meter0])\n\ncheck ovn-nbctl --wait=hv set Logical_Switch sw1 \\\n    other_config:mcast_querier=\"false\" \\\n    other_config:mcast_snoop=\"true\"\ncheck ovn-nbctl --wait=hv copp-add copp8 igmp meter1\ncheck ovn-nbctl --wait=hv ls-copp-add copp8 sw1\nAT_CHECK([ovn-nbctl copp-list copp8], [0], [dnl\nigmp: meter1\n])\nAT_CHECK([ovn-sbctl list logical_flow | grep igmp -A 2 | grep -q meter1])\n\ncheck ovn-nbctl copp-del copp8\nAT_CHECK([ovn-nbctl copp-list copp8], [0], [dnl\n])\n\n# let's add igmp meter1 twice\nAT_CHECK([ovn-nbctl --wait=hv copp-add copp9 igmp meter1])\nAT_CHECK([ovn-nbctl copp-list copp9], [0], [dnl\nigmp: meter1\n])\n\n# let's delete a wrong meter\nAT_CHECK([ovn-nbctl --wait=hv copp-del copp9 event-elb])\nAT_CHECK([ovn-nbctl copp-list copp9], [0], [dnl\nigmp: meter1\n])\n\ncheck ovn-nbctl copp-del copp9\nAT_CHECK([ovn-nbctl copp-list copp9], [0], [dnl\n])\n\ncheck ovn-nbctl copp-del copp6\ncheck ovn-nbctl copp-del copp7\nAT_CHECK([ovn-nbctl list copp], [0], [dnl\n])\n\ncheck ovn-nbctl --wait=hv copp-add copp0 arp meter0\ncheck ovn-nbctl --wait=hv lr-copp-add copp0 r0\nAT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl\narp: meter0\n])\n\nAT_CHECK([fetch_column nb:CoPP name], [0], [dnl\ncopp0\n])\n\ncopp_uuid=$(fetch_column nb:CoPP _uuid)\ncheck ovn-nbctl --wait=hv copp-add copp0 arp meter0\ncheck ovn-nbctl --wait=hv ls-copp-add copp0 sw1\n\nls_copp_uuid=$(fetch_column nb:Logical_Switch copp)\nAT_CHECK([test \"$ls_copp_uuid\" = \"$copp_uuid\"])\n\ncheck ovn-nbctl --wait=hv copp-add $copp_uuid igmp meter0\nAT_CHECK([ovn-nbctl copp-list copp0 | sort], [0], [dnl\narp: meter0\nigmp: meter0\n])\n\ncheck ovn-nbctl --wait=sb lrp-add r0 r0-sw2 00:00:00:00:00:03 192.168.2.1/24\ncheck ovn-nbctl --wait=sb ls-add sw2\ncheck ovn-nbctl --wait=sb lsp-add sw2 sw2-r0\ncheck ovn-nbctl --wait=sb lsp-set-type sw2-r0 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw2-r0 router-port=r0-sw2\ncheck ovn-nbctl --wait=sb lsp-set-addresses sw2-r0 00:00:00:00:00:02\n\ncheck ovn-nbctl --wait=hv copp-add copp0 event-elb meter0\ncheck ovn-nbctl --wait=hv ls-copp-add copp0 sw2\nls2_copp_uuid=$(ovn-nbctl get Logical_Switch sw2 copp)\nAT_CHECK([test \"$ls2_copp_uuid\" = \"$copp_uuid\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check LSP attached to multiple LS])\novn_start\n\ncheck ovn-nbctl ls-add ls1 \\\n    -- ls-add ls2 \\\n    -- lsp-add ls1 p1\ncheck ovn-nbctl --wait=sb sync\n\nuuid=$(fetch_column nb:Logical_Switch_Port _uuid name=p1)\ncheck ovn-nbctl set Logical_Switch ls2 ports=$uuid\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([grep -qE 'duplicate logical port p1' northd/ovn-northd.log], [0])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check LRP attached to multiple LR])\novn_start\n\ncheck ovn-nbctl lr-add lr1 \\\n    -- lr-add lr2 \\\n    -- lrp-add lr1 p1 00:00:00:00:00:01 10.0.0.1/24\ncheck ovn-nbctl --wait=sb sync\n\nuuid=$(fetch_column nb:Logical_Router_Port _uuid name=p1)\ncheck ovn-nbctl set Logical_Router lr2 ports=$uuid\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([grep -qE 'duplicate logical router port p1' northd/ovn-northd.log], [0])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check duplicate LSP/LRP])\novn_start\n\ncheck ovn-nbctl ls-add ls \\\n    -- lsp-add ls p1 \\\n    -- lr-add lr \\\n    -- lrp-add lr p1 00:00:00:00:00:01 10.0.0.1/24\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([grep -qE 'duplicate logical.*port p1' northd/ovn-northd.log], [0])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Port_Binding.up backwards compatibility])\novn_start\n\novn-nbctl ls-add ls1\novn-nbctl --wait=sb lsp-add ls1 lsp1\n\n# Simulate the fact that lsp1 had been previously bound on hv1 by an\n# ovn-controller running an older version.\novn-sbctl \\\n    --id=@e create encap chassis_name=hv1 ip=\"192.168.0.1\" type=\"geneve\" \\\n    -- --id=@c create chassis name=hv1 encaps=@e \\\n    -- set Port_Binding lsp1 chassis=@c\n\nwait_for_ports_up lsp1\n\n# Simulate the fact that hv1 is aware of Port_Binding.up, ovn-northd\n# should transition the port state to down.\ncheck ovn-sbctl set chassis hv1 other_config:port-up-notif=true\nwait_row_count nb:Logical_Switch_Port 1 up=false name=lsp1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load Balancers and lb_force_snat_ip for Gateway Routers])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\n\n# Create a logical router and attach both logical switches\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\ncheck ovn-nbctl lsp-add sw1 sw1-lr0\ncheck ovn-nbctl lsp-set-type sw1-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\ncheck ovn-nbctl ls-add public\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24\ncheck ovn-nbctl lsp-add public public-lr0\ncheck ovn-nbctl lsp-set-type public-lr0 router\ncheck ovn-nbctl lsp-set-addresses public-lr0 router\ncheck ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public\n\nlbg=$(ovn-nbctl create load_balancer_group name=lbg)\n\ncheck ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.4:8080\ncheck ovn-nbctl lb-add lbg1 10.0.0.100:80 10.0.0.40:8080\nlbg1=$(fetch_column nb:load_balancer _uuid name=lbg1)\ncheck ovn-nbctl add load_balancer_group $lbg load_balancer $lbg1\ncheck ovn-nbctl lr-lb-add lr0 lb1\ncheck ovn-nbctl add logical_router lr0 load_balancer_group $lbg\ncheck ovn-nbctl set logical_router lr0 options:chassis=ch1\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.4:8080);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.40:8080);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\n\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip=\"20.0.0.4 aef0::4\"\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(ip4 && ip4.dst == 20.0.0.4), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(ip6 && ip6.dst == aef0::4), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=100  , match=(flags.force_snat_for_lb == 1 && ip4), action=(ct_snat(20.0.0.4);)\n  table=? (lr_out_snat        ), priority=100  , match=(flags.force_snat_for_lb == 1 && ip6), action=(ct_snat(aef0::4);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip=\"router_ip\"\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_ip_input\" lr0flows | grep \"priority=60\" | sort], [0], [dnl\n])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.100), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw1\" && ip4.dst == 20.0.0.1), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-public\"), action=(ct_snat(172.168.0.100);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw0\"), action=(ct_snat(10.0.0.1);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw1\"), action=(ct_snat(20.0.0.1);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\ncheck ovn-nbctl --wait=sb remove logical_router lr0 options chassis\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\ncheck ovn-nbctl set logical_router lr0 options:chassis=ch1\ncheck ovn-nbctl --wait=sb add logical_router_port lr0-sw1 networks \"bef0\\:\\:1/64\"\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.100), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw1\" && ip4.dst == 20.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw1\" && ip6.dst == bef0::1), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-public\"), action=(ct_snat(172.168.0.100);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw0\"), action=(ct_snat(10.0.0.1);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw1\"), action=(ct_snat(20.0.0.1);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip6 && outport == \"lr0-sw1\"), action=(ct_snat(bef0::1);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\ncheck ovn-nbctl --wait=sb lb-add lb2 10.0.0.20:80 10.0.0.40:8080\ncheck ovn-nbctl --wait=sb set load_balancer lb2 options:skip_snat=true\ncheck ovn-nbctl lr-lb-add lr0 lb2\ncheck ovn-nbctl --wait=sb lb-del lb1\novn-sbctl dump-flows lr0 > lr0flows\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.100), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw1\" && ip4.dst == 20.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw1\" && ip6.dst == bef0::1), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.20), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | grep skip_snat_for_lb | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.20 && tcp && tcp.dst == 80), action=(flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; skip_snat);)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | grep skip_snat_for_lb | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=120  , match=(flags.skip_snat_for_lb == 1 && ip), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([HA chassis group cleanup for external port ])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-type sw0-p1 external\n\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.1\ncheck ovn-sbctl chassis-add ch2 geneve 127.0.0.2\n\ncheck ovn-nbctl ha-chassis-group-add hagrp1\ncheck ovn-nbctl ha-chassis-group-add-chassis hagrp1 ch1 20\ncheck ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 10\n\nha_grp1_uuid=$(fetch_column nb:ha_chassis_group _uuid)\necho \"ha grp1 uuid = $ha_grp1_uuid\"\novn-nbctl list ha_chassis_group\ncheck ovn-nbctl set logical_switch_port sw0-p1 ha_chassis_group=$ha_grp1_uuid\n\nwait_row_count ha_chassis_group 1\ncheck ovn-nbctl clear logical_switch_port sw0-p1 ha_chassis_group\nwait_row_count ha_chassis_group 0\n\ncheck ovn-nbctl set logical_switch_port sw0-p1 ha_chassis_group=$ha_grp1_uuid\nwait_row_count ha_chassis_group 1\nsb_ha_grp1_uuid=$(fetch_column ha_chassis_group _uuid)\n\necho\necho \"__file__:__line__:Check that port_binding sw0-p1 has ha_chassis_group set\"\n\ncheck_column \"$sb_ha_grp1_uuid\" Port_Binding ha_chassis_group logical_port=sw0-p1\n\nAS_BOX([Clear ha_chassis_group for sw0-p1 and reset port type to normal port in the same txn])\n\ncheck ovn-nbctl clear logical_switch_port sw0-p1 ha_chassis_group -- set logical_switch_port sw0-p1 'type=\"\"'\nwait_row_count ha_chassis_group 0\ncheck_column \"\" Port_Binding chassis logical_port=sw0-p1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([FDB cleanup])\n\novn_start\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1\novn-nbctl lsp-add sw0 sw0-p2\novn-nbctl lsp-add sw0 sw0-p3\n\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-p1\novn-nbctl lsp-add sw1 sw1-p2\novn-nbctl --wait=sb lsp-add sw1 sw1-p3\n\nsw0_key=$(fetch_column datapath_binding tunnel_key external_ids:name=sw0)\nsw1_key=$(fetch_column datapath_binding tunnel_key external_ids:name=sw1)\nsw0p1_key=$(fetch_column port_binding tunnel_key logical_port=sw0-p1)\nsw0p2_key=$(fetch_column port_binding tunnel_key logical_port=sw0-p2)\nsw1p1_key=$(fetch_column port_binding tunnel_key logical_port=sw1-p1)\n\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:00\\:01\" dp_key=$sw0_key port_key=$sw0p1_key\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:00\\:02\" dp_key=$sw0_key port_key=$sw0p1_key\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:00\\:03\" dp_key=$sw0_key port_key=$sw0p2_key\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:01\\:01\" dp_key=$sw1_key port_key=$sw1p1_key\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:01\\:02\" dp_key=$sw1_key port_key=$sw1p1_key\novn-sbctl create FDB mac=\"00\\:00\\:00\\:00\\:01\\:03\" dp_key=$sw1_key port_key=$sw1p1_key\n\nwait_row_count FDB 6\n\novn-sbctl create fdb mac=\"00\\:00\\:00\\:00\\:01\\:03\" dp_key=$sw1_key port_key=10\nwait_row_count FDB 6\novn-sbctl create fdb mac=\"00\\:00\\:00\\:00\\:01\\:03\" dp_key=4 port_key=10\nwait_row_count FDB 6\n\novn-nbctl --wait=sb ls-del sw1\nwait_row_count FDB 3\n\novn-nbctl lsp-del sw0-p3\nwait_row_count FDB 3\n\novn-nbctl lsp-del sw0-p1\nwait_row_count FDB 1\n\ncheck_column '00:00:00:00:00:03' FDB mac\novn-sbctl list fdb\n\ncheck_column $sw0_key FDB dp_key\ncheck_column $sw0p2_key FDB port_key\n\novn-nbctl --wait=sb lsp-add sw0-p1\nwait_row_count FDB 1\n\novn-nbctl lsp-del sw0-p2\novn-nbctl lsp-add sw0-p2\nwait_row_count FDB 0\n\novn-sbctl list FDB\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LS load balancer logical flows])\novn_start\n\nlbg=$(ovn-nbctl create load_balancer_group name=lbg)\ncheck ovn-nbctl \\\n    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080 \\\n    -- lb-add lbg0 10.0.0.20:80 10.0.0.40:8080\nlbg0=$(fetch_column nb:load_balancer _uuid name=lbg0)\n\ncheck ovn-nbctl \\\n    -- ls-add sw0 \\\n    -- add logical_switch sw0 load_balancer_group $lbg \\\n    -- ls-lb-add sw0 lb0 \\\n    -- add load_balancer_group $lbg load_balancer $lbg0\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl --wait=sb sync\n\ncheck_stateful_flows() {\n    action=$1\n    ovn-sbctl dump-flows sw0 > sw0flows\n    AT_CAPTURE_FILE([sw0flows])\n\n    AT_CHECK([grep \"ls_in_pre_lb\" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_pre_lb       ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.mcast), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(ip && inport == \"sw0-lr0\"), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(reg0[[16]] == 1), action=(next;)\n])\n\n    AT_CHECK([grep \"ls_in_pre_stateful\" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_pre_stateful ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_pre_stateful ), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)\n  table=? (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n  table=? (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg1 = 10.0.0.10; reg2[[0..15]] = 80; ct_lb_mark;)\n  table=? (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 10.0.0.20 && tcp.dst == 80), action=(reg1 = 10.0.0.20; reg2[[0..15]] = 80; ct_lb_mark;)\n])\n\n    AT_CHECK([grep \"ls_in_lb \" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.4:8080);)\n  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.20 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.40:8080);)\n])\n\n    AT_CHECK([grep \"ls_in_stateful\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\n    AT_CHECK_UNQUOTED([grep \"ls_out_pre_lb\" sw0flows | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=0    , match=(1), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.mcast), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.src == \\$svc_monitor_mac), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(ip && outport == \"sw0-lr0\"), action=($action)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(reg0[[16]] == 1), action=(next;)\n])\n\n    AT_CHECK([grep \"ls_out_pre_stateful\" sw0flows | sort], [0], [dnl\n  table=2 (ls_out_pre_stateful), priority=0    , match=(1), action=(next;)\n  table=2 (ls_out_pre_stateful), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)\n  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n])\n\n    AT_CHECK([grep \"ls_out_lb\" sw0flows | sort], [0], [])\n\n    AT_CHECK([grep \"ls_out_stateful\" sw0flows | sort], [0], [dnl\n  table=7 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n}\n\ncheck_stateful_flows \"ct_clear; next;\"\n\n# Add few ACLs\ncheck ovn-nbctl --wait=sb acl-add sw0 from-lport 1002 \"ip4 && tcp && tcp.dst == 80\" allow-related\ncheck ovn-nbctl --wait=sb acl-add sw0 to-lport 1002 \"ip4 && tcp && tcp.src == 80\" drop\n\ncheck_stateful_flows \"next;\"\n\n# Remove load balancers from sw0\ncheck ovn-nbctl ls-lb-del sw0 lb0\ncheck ovn-nbctl clear logical_switch sw0 load_balancer_group\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep \"ls_in_pre_lb\" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_pre_lb       ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.mcast), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(ip && inport == \"sw0-lr0\"), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)\n  table=? (ls_in_pre_lb       ), priority=110  , match=(reg0[[16]] == 1), action=(next;)\n])\n\nAT_CHECK([grep \"ls_in_pre_stateful\" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_pre_stateful ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_pre_stateful ), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)\n  table=? (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n])\n\nAT_CHECK([grep \"ls_in_lb \" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"ls_in_stateful\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAT_CHECK([grep \"ls_out_pre_lb\" sw0flows | sort], [0], [dnl\n  table=1 (ls_out_pre_lb      ), priority=0    , match=(1), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.mcast), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(ip && outport == \"sw0-lr0\"), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)\n  table=1 (ls_out_pre_lb      ), priority=110  , match=(reg0[[16]] == 1), action=(next;)\n])\n\nAT_CHECK([grep \"ls_out_pre_stateful\" sw0flows | sort], [0], [dnl\n  table=2 (ls_out_pre_stateful), priority=0    , match=(1), action=(next;)\n  table=2 (ls_out_pre_stateful), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)\n  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n])\n\nAT_CHECK([grep \"ls_out_stateful\" sw0flows | sort], [0], [dnl\n  table=7 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\n# LB with event=false and reject=false\nAT_CHECK([ovn-nbctl create load_balancer name=lb1 options:reject=false options:event=false vips:\\\"10.0.0.20\\\"=\\\"\\\" protocol=tcp], [0], [ignore])\ncheck ovn-nbctl --wait=sb ls-lb-add sw0 lb1\n\nAT_CHECK([ovn-sbctl dump-flows sw0 | grep \"ls_in_lb \" | sort ], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=12(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.20), action=(drop;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- ACL label usage])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0p1\n\ncheck ovn-nbctl --wait=sb --label=1234 acl-add sw0 to-lport 1002 tcp allow-related\ncheck ovn-nbctl --wait=sb --label=1234 acl-add sw0 from-lport 1002 tcp allow-related\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 2002 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n])\nAT_CHECK([grep \"ls_in_stateful\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 2002 | sort], [0], [dnl\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n])\nAT_CHECK([grep \"ls_out_stateful\" sw0flows | sort], [0], [dnl\n  table=7 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\n# Add new ACL without label\ncheck ovn-nbctl --wait=sb acl-add sw0 to-lport 1002 udp allow-related\ncheck ovn-nbctl --wait=sb acl-add sw0 from-lport 1002 udp allow-related\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 2002 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg0[[1]] = 1; next;)\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(next;)\n])\nAT_CHECK([grep \"ls_in_stateful\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 2002 | sort], [0], [dnl\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(next;)\n])\nAT_CHECK([grep \"ls_out_stateful\" sw0flows | sort], [0], [dnl\n  table=7 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\n# Delete new ACL with label\ncheck ovn-nbctl --wait=sb acl-del sw0 to-lport 1002 tcp\ncheck ovn-nbctl --wait=sb acl-del sw0 from-lport 1002 tcp\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 2002 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg0[[1]] = 1; next;)\n  table=? (ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(next;)\n])\nAT_CHECK([grep \"ls_in_stateful\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 2002 | sort], [0], [dnl\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg0[[1]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(next;)\n])\nAT_CHECK([grep \"ls_out_stateful\" sw0flows | sort], [0], [dnl\n  table=7 (ls_out_stateful    ), priority=0    , match=(1), action=(next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=7 (ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- ct.inv usage])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0p1\n\ncheck ovn-nbctl --wait=sb acl-add sw0 to-lport 1002 ip allow-related\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\n# Disable ct.inv usage.\ncheck ovn-nbctl --wait=sb set NB_Global . options:use_ct_inv_match=false\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=? (ls_in_acl          ), priority=65532, match=((ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=? (ls_out_acl         ), priority=65532, match=((ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\nAT_CHECK([grep -c \"ct.inv\" sw0flows], [1], [dnl\n0\n])\n\n# Enable ct.inv usage.\ncheck ovn-nbctl --wait=sb set NB_Global . options:use_ct_inv_match=true\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\nAT_CHECK([grep -w \"ls_out_acl\" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n])\n\nAT_CHECK([grep -c \"ct.inv\" sw0flows], [0], [dnl\n6\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([northd ssl file change])\nAT_SKIP_IF([test \"$HAVE_OPENSSL\" = no])\nPKIDIR=\"$(cd $abs_top_builddir/tests && pwd)\"\nAT_SKIP_IF([expr \"$PKIDIR\" : \".*[[ \t'\\\"\n\\\\]]\"])\novn_start --backup-northd=none\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nkey_server=testpki-test-privkey.pem\ncert_server=testpki-test-cert.pem\ncacert=testpki-cacert.pem\n\ncd ovn-sb\nrm ovsdb-server.log\nssl_options=\"--remote=pssl:0:127.0.0.1 ovn-sb.db -p $PKIDIR/$key_server -c $PKIDIR/$cert_server -C $PKIDIR/$cacert\"\nAT_CHECK([ovsdb-server --detach --no-chdir --pidfile --log-file $ssl_options], [0], [], [stderr])\non_exit \"kill `cat ovsdb-server.pid`\"\nPARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])\ncd ..\n\nkey=testpki-hv1-privkey.pem\ncert=testpki-hv1-cert.pem\n\nkey2=testpki-hv2-privkey.pem\ncert3=testpki-hv3-cert.pem\n\n# Use mismatched key and cert when restarting using SSL options\ncp $PKIDIR/$key2 $key\ncp $PKIDIR/$cert3 $cert\ncp $PKIDIR/$cacert $cacert\nas northd\nstart_daemon ovn$NORTHD_TYPE -vjsonrpc \\\n    --ovnnb-db=$OVN_NB_DB --ovnsb-db=ssl:127.0.0.1:$TCP_PORT \\\n    -p $key -c $cert -C $cacert\n\n# SSL should not connect because of key and cert mismatch\nAT_FAIL_IF([ovn-nbctl --timeout=3 --wait=sb sync])\n\n# Modify the files with the correct key and cert, and reconnect should succeed\ncp $PKIDIR/$key $key\ncp $PKIDIR/$cert $cert\ncheck ovn-nbctl --wait=sb sync\n\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([trace with IPv4 dnat])\nAT_KEYWORDS([dnat])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-port1\ncheck ovn-nbctl lsp-set-addresses sw0-port1 \"50:54:00:00:00:01 192.168.0.2\"\n\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-port1\ncheck ovn-nbctl lsp-set-addresses sw1-port1 \"50:54:00:00:00:03 11.0.0.2\"\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lrp0 00:00:00:00:ff:01 192.168.0.1/24\ncheck ovn-nbctl lsp-add sw0 lrp0-attachment\ncheck ovn-nbctl lsp-set-type lrp0-attachment router\ncheck ovn-nbctl lsp-set-addresses lrp0-attachment 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options lrp0-attachment router-port=lrp0\ncheck ovn-nbctl lrp-add lr0 lrp1 00:00:00:00:ff:02 11.0.0.1/24 -- lrp-set-gateway-chassis lrp1 chassis-1\ncheck ovn-nbctl lsp-add sw1 lrp1-attachment\ncheck ovn-nbctl lsp-set-type lrp1-attachment router\ncheck ovn-nbctl lsp-set-addresses lrp1-attachment 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options lrp1-attachment router-port=lrp1\n\ncheck ovn-nbctl lr-nat-add lr0 dnat 42.42.42.42 192.168.0.2\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn_trace --minimal 'inport == \"sw1-port1\" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip4.dst == 42.42.42.42 && ip4.src == 11.0.0.2 && ip.ttl == 64' | grep \"output(\\\"sw0-port1\\\")\"], [0], [ignore])\n\ndnl If we remove the DNAT entry we will be unable to trace to the DNAT address\ncheck ovn-nbctl lr-nat-del lr0 dnat 42.42.42.42\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn_trace --minimal 'inport == \"sw1-port1\" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip4.dst == 42.42.42.42 && ip4.src == 11.0.0.2 && ip.ttl == 64' | grep \"output(\\\"sw0-port1\\\")\"], [1], [ignore])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([trace with IPv6 dnat])\nAT_KEYWORDS([dnat])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-port1\ncheck ovn-nbctl lsp-set-addresses sw0-port1 \"50:54:00:00:00:01 fd68::2\"\n\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-port1\ncheck ovn-nbctl lsp-set-addresses sw1-port1 \"50:54:00:00:00:03 fd11::2\"\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lrp0 00:00:00:00:ff:01 fd68::1/64\ncheck ovn-nbctl lsp-add sw0 lrp0-attachment\ncheck ovn-nbctl lsp-set-type lrp0-attachment router\ncheck ovn-nbctl lsp-set-addresses lrp0-attachment 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options lrp0-attachment router-port=lrp0\ncheck ovn-nbctl lrp-add lr0 lrp1 00:00:00:00:ff:02 fd11::1/64 -- lrp-set-gateway-chassis lrp1 chassis-1\ncheck ovn-nbctl lsp-add sw1 lrp1-attachment\ncheck ovn-nbctl lsp-set-type lrp1-attachment router\ncheck ovn-nbctl lsp-set-addresses lrp1-attachment 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options lrp1-attachment router-port=lrp1\n\ncheck ovn-nbctl lr-nat-add lr0 dnat fd42::42 fd68::2\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn_trace --minimal 'inport == \"sw1-port1\" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip6.dst == fd42::42 && ip6.src == fd11::2 && ip.ttl == 64' | grep \"output(\\\"sw0-port1\\\")\"], [0], [ignore])\n\ndnl If we remove the DNAT entry we will be unable to trace to the DNAT address\ncheck ovn-nbctl lr-nat-del lr0 dnat fd42::42\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn_trace --minimal 'inport == \"sw1-port1\" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip6.dst == fd42::42 && ip6.src == fd11::2 && ip.ttl == 64' | grep \"output(\\\"sw0-port1\\\")\"], [1], [ignore])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([DHCP options])\nAT_KEYWORDS([dnat])\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-port1\ncheck ovn-nbctl lsp-set-addresses sw0-port1 \"50:54:00:00:00:01 10.0.0.2\"\ncheck ovn-nbctl lsp-add sw0 sw0-port2\ncheck ovn-nbctl lsp-set-addresses sw0-port2 \"50:54:00:00:00:02 10.0.0.3\"\n\novn-nbctl dhcp-options-create 10.0.0.0/24\n\nCIDR_UUID=$(ovn-nbctl --bare --columns=_uuid find dhcp_options cidr=\"10.0.0.0/24\")\novn-nbctl dhcp-options-set-options $CIDR_UUID   lease_time=3600   router=10.0.0.1   server_id=10.0.0.1   server_mac=c0:ff:ee:00:00:01 hostname=\"\\\"foo\\\"\"\novn-nbctl --wait=sb lsp-set-dhcpv4-options sw0-port1 $CIDR_UUID\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_dhcp_options\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_dhcp_options ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"foo\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 10.0.0.2 && ip4.dst == {10.0.0.1, 255.255.255.255} && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"foo\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n])\n\ncheck ovn-nbctl --wait=sb lsp-set-options sw0-port1 hostname=\"\\\"port1\\\"\"\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_dhcp_options\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_dhcp_options ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"port1\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 10.0.0.2 && ip4.dst == {10.0.0.1, 255.255.255.255} && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"port1\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n])\n\novn-nbctl dhcp-options-set-options $CIDR_UUID  lease_time=3600   router=10.0.0.1   server_id=10.0.0.1   server_mac=c0:ff:ee:00:00:01\ncheck ovn-nbctl --wait=sb lsp-set-options sw0-port1 hostname=\"\\\"bar\\\"\"\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([grep -w \"ls_in_dhcp_options\" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_dhcp_options ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"bar\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == \"sw0-port1\" && eth.src == 50:54:00:00:00:01 && ip4.src == 10.0.0.2 && ip4.dst == {10.0.0.1, 255.255.255.255} && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = \"bar\", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- NAT and Load Balancer flows])\n\n# Determine if expected flows are present. The only parameter to this\n# function is the number of expected flows per NAT destination address.\n# This should always be either 0 or 1. 0 means that we do not expect\n# lflows to be present. 1 means we expect an lflow to be present\ncheck_lflows() {\n    expected=$1\n    ro1_flows=$(ovn-sbctl lflow-list ro1)\n\n    ro1_ip_routing=$(grep lr_in_ip_routing <<< \"$ro1_flows\")\n    match=$(grep -c \"match=(ip4.dst == 20.0.0.100/32)\" <<< \"$ro1_ip_routing\")\n    AT_CHECK([test \"$expected\" = \"$match\"])\n\n    ro1_arp_resolve=$(grep lr_in_arp_resolve <<< \"$ro1_flows\")\n    match=$(grep -c 'match=(outport == \"ro1-sw\" && reg0 == {20.0.0.100})' <<< \"$ro1_arp_resolve\")\n    AT_CHECK([test \"$expected\" = \"$match\"])\n\n    ro2_flows=$(ovn-sbctl lflow-list ro2)\n\n    ro2_ip_routing=$(grep lr_in_ip_routing <<< \"$ro2_flows\")\n    match=$(grep -c \"match=(ip4.dst == 10.0.0.100/32)\" <<< \"$ro2_ip_routing\")\n    AT_CHECK([test \"$expected\" = \"$match\"])\n\n    ro2_arp_resolve=$(grep lr_in_arp_resolve <<< \"$ro2_flows\")\n    match=$(grep -c 'match=(outport == \"ro2-sw\" && reg0 == {10.0.0.100})' <<< \"$ro2_arp_resolve\")\n    AT_CHECK([test \"$expected\" = \"$match\"])\n}\n\novn_start\n\nAS_BOX([Setting up the logical network])\n\ncheck ovn-nbctl ls-add sw\n\ncheck ovn-nbctl lr-add ro1\ncheck ovn-nbctl lrp-add ro1 ro1-sw 00:00:00:00:00:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw sw-ro1\n\ncheck ovn-nbctl lr-add ro2\ncheck ovn-nbctl lrp-add ro2 ro2-sw 00:00:00:00:00:02 20.0.0.1/24\ncheck ovn-nbctl --wait=sb lsp-add sw sw-ro2\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl lsp-add ls1 vm1\ncheck ovn-nbctl lsp-set-addresses vm1 \"00:00:00:00:01:02 192.168.1.2\"\ncheck ovn-nbctl lrp-add ro1 ro1-ls1 00:00:00:00:01:01 192.168.1.1/24\ncheck ovn-nbctl lsp-add ls1 ls1-ro1\ncheck ovn-nbctl lsp-set-type ls1-ro1 router\ncheck ovn-nbctl lsp-set-addresses ls1-ro1 router\ncheck ovn-nbctl lsp-set-options ls1-ro1 router-port=ro1-ls1\n\ncheck ovn-nbctl ls-add ls2\ncheck ovn-nbctl lsp-add ls2 vm2\ncheck ovn-nbctl lsp-set-addresses vm2 \"00:00:00:00:02:02 192.168.2.2\"\ncheck ovn-nbctl lrp-add ro2 ro2-ls2 00:00:00:00:02:01 192.168.2.1/24\ncheck ovn-nbctl lsp-add ls2 ls2-ro2\ncheck ovn-nbctl lsp-set-type ls2-ro2 router\ncheck ovn-nbctl lsp-set-addresses ls2-ro2 router\ncheck ovn-nbctl lsp-set-options ls2-ro2 router-port=ro2-ls2\n\ncheck ovn-nbctl ha-chassis-group-add grp1\ncheck ovn-nbctl ha-chassis-group-add-chassis grp1 hv1 100\ngrp1_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp1)\n\ncheck ovn-nbctl ha-chassis-group-add grp2\ncheck ovn-nbctl ha-chassis-group-add-chassis grp2 hv2 100\ngrp2_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp2)\n\nAS_BOX([Checking that unconnected logical switch ports generate no lflows])\n\ncheck_lflows 0\n\nAS_BOX([Checking that connected logical switch ports have no lflows for non-gateway ports])\n\ncheck ovn-nbctl lsp-set-type sw-ro1 router\ncheck ovn-nbctl lsp-set-addresses sw-ro1 router\ncheck ovn-nbctl lsp-set-options sw-ro1 router-port=ro1-sw\n\ncheck ovn-nbctl lsp-set-type sw-ro2 router\ncheck ovn-nbctl lsp-set-addresses sw-ro2 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw-ro2 router-port=ro2-sw\n\ncheck_lflows 0\n\nAS_BOX([Checking that NAT flows are not installed for non-gateway routers])\n\ncheck ovn-nbctl lr-nat-add ro1 dnat 10.0.0.100 192.168.1.100\ncheck ovn-nbctl lr-nat-add ro2 dnat 20.0.0.100 192.168.2.100\n\ncheck_lflows 0\n\nAS_BOX([Checking that non-routable NAT flows are not installed for gateway routers])\n\ncheck ovn-nbctl lrp-set-gateway-chassis ro1-sw hv1 100\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis ro2-sw hv2 100\n\ncheck_lflows 0\n\nAS_BOX([Checking that routable NAT flows are installed when gateway chassis exists])\n\ncheck ovn-nbctl lr-nat-del ro1\ncheck ovn-nbctl lr-nat-del ro2\ncheck ovn-nbctl --add-route lr-nat-add ro1 dnat 10.0.0.100 192.168.1.100\ncheck ovn-nbctl --wait=sb --add-route lr-nat-add ro2 dnat 20.0.0.100 192.168.2.100\n\ncheck_lflows 1\n\nAS_BOX([Checking that NAT flows are not installed for routers with gateway chassis removed])\n\ncheck ovn-nbctl lrp-del-gateway-chassis ro1-sw hv1\ncheck ovn-nbctl --wait=sb lrp-del-gateway-chassis ro2-sw hv2\n\ncheck_lflows 0\n\nAS_BOX([Checking that NAT flows are installed for routers with HA_Chassis_Group])\n\ncheck ovn-nbctl set logical_router_port ro1-sw ha_chassis_group=\"$grp1_uuid\"\ncheck ovn-nbctl --wait=sb set logical_router_port ro2-sw ha_chassis_group=\"$grp2_uuid\"\n\ncheck_lflows 1\n\nAS_BOX([Checking that NAT flows are not installed for routers with HA_Chassis_Group removed])\n\ncheck ovn-nbctl clear logical_router_port ro1-sw ha_chassis_group\ncheck ovn-nbctl --wait=sb clear logical_router_port ro2-sw ha_chassis_group\n\ncheck_lflows 0\n\nAS_BOX([Checking that Floating IP NAT flows are not installed with no gateway port set])\n\ncheck ovn-nbctl lr-nat-del ro1\ncheck ovn-nbctl lr-nat-del ro2\n\ncheck ovn-nbctl lr-nat-add ro1 dnat_and_snat 10.0.0.100 192.168.1.2 vm1 00:00:00:00:00:01\ncheck ovn-nbctl --wait=sb lr-nat-add ro2 dnat_and_snat 20.0.0.100 192.168.2.2 vm2 00:00:00:00:00:02\n\ncheck_lflows 0\n\nAS_BOX([Checking that non-routable Floating IP NAT flows are not installed for gateway routers])\n\ncheck ovn-nbctl lrp-set-gateway-chassis ro1-sw hv1 100\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis ro2-sw hv2 100\n\ncheck_lflows 0\n\nAS_BOX([Checking that routable Floating IP NAT flows are installed for gateway routers])\ncheck ovn-nbctl lr-nat-del ro1\ncheck ovn-nbctl lr-nat-del ro2\n\ncheck ovn-nbctl --add-route lr-nat-add ro1 dnat_and_snat 10.0.0.100 192.168.1.2 vm1 00:00:00:00:00:01\ncheck ovn-nbctl --wait=sb --add-route lr-nat-add ro2 dnat_and_snat 20.0.0.100 192.168.2.2 vm2 00:00:00:00:00:02\n\ncheck_lflows 1\n\nAS_BOX([Checking that Floating IP NAT flows are not installed for routers with gateway chassis removed])\n\ncheck ovn-nbctl lrp-del-gateway-chassis ro1-sw hv1\ncheck ovn-nbctl --wait=sb lrp-del-gateway-chassis ro2-sw hv2\n\ncheck_lflows 0\n\nAS_BOX([Checking that Floating IP NAT flows are installed for routers with ha_chassis_group])\n\ngrp1_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp1)\ncheck ovn-nbctl set logical_router_port ro1-sw ha_chassis_group=\"$grp1_uuid\"\n\ngrp2_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp2)\ncheck ovn-nbctl --wait=sb set logical_router_port ro2-sw ha_chassis_group=\"$grp2_uuid\"\n\ncheck_lflows 1\n\nAS_BOX([Checking that Floating IP NAT flows are not installed for routers with HA_Chassis_Group removed])\n\ncheck ovn-nbctl clear logical_router_port ro1-sw ha_chassis_group\ncheck ovn-nbctl --wait=sb clear logical_router_port ro2-sw ha_chassis_group\n\ncheck_lflows 0\n\nAS_BOX([Checking that Load Balancer VIP flows are not installed for routers with no gateway port])\n\ncheck ovn-nbctl lr-nat-del ro1\ncheck ovn-nbctl lr-nat-del ro2\n\ncheck ovn-nbctl lb-add lb1 10.0.0.100 192.168.1.2\ncheck ovn-nbctl lr-lb-add ro1 lb1\n\ncheck ovn-nbctl lb-add lb2 20.0.0.100 192.168.2.2\ncheck ovn-nbctl --wait=sb lr-lb-add ro2 lb2\n\ncheck_lflows 0\n\nAS_BOX([Checking that non-routable Load Balancer VIP flows are not installed for gateway routers])\n\ncheck ovn-nbctl lrp-set-gateway-chassis ro1-sw hv1 100\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis ro2-sw hv2 100\n\ncheck_lflows 0\n\nAS_BOX([Checking that routable Load Balancer VIP flows are installed for gateway routers])\n\ncheck ovn-nbctl lr-lb-del ro1 lb1\ncheck ovn-nbctl lr-lb-del ro2 lb2\ncheck ovn-nbctl lb-del lb1\ncheck ovn-nbctl lb-del lb2\n\ncheck ovn-nbctl --add-route lb-add lb1 10.0.0.100 192.168.1.2\ncheck ovn-nbctl --add-route lb-add lb2 20.0.0.100 192.168.2.2\ncheck ovn-nbctl lr-lb-add ro1 lb1\ncheck ovn-nbctl --wait=sb lr-lb-add ro2 lb2\n\ncheck_lflows 1\n\nAS_BOX([Checking that Load Balancer VIP flows are not installed for routers with gateway chassis removed])\n\ncheck ovn-nbctl lrp-del-gateway-chassis ro1-sw hv1\ncheck ovn-nbctl --wait=sb lrp-del-gateway-chassis ro2-sw hv2\n\ncheck_lflows 0\n\nAS_BOX([Checking that Load Balancer VIP flows are installed for routers with ha_chassis_group])\n\ngrp1_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp1)\ncheck ovn-nbctl set logical_router_port ro1-sw ha_chassis_group=\"$grp1_uuid\"\n\ngrp2_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp2)\ncheck ovn-nbctl --wait=sb set logical_router_port ro2-sw ha_chassis_group=\"$grp2_uuid\"\n\ncheck_lflows 1\n\nAS_BOX([Checking that Load Balancer VIP flows are not iinstalled for routers with HA_Chassis_Group removed])\n\ncheck ovn-nbctl clear logical_router_port ro1-sw ha_chassis_group\ncheck ovn-nbctl --wait=sb clear logical_router_port ro2-sw ha_chassis_group\n\ncheck_lflows 0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- ARP flows for unreachable addresses - NAT and LB])\novn_start\n\nAS_BOX([Setting up the logical network])\n\n# This network is the same as the one from \"Router Address Propagation\"\ncheck ovn-nbctl ls-add sw\n\ncheck ovn-nbctl lr-add ro1\ncheck ovn-nbctl lrp-add ro1 ro1-sw 00:00:00:00:00:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw sw-ro1\ncheck ovn-nbctl lsp-set-type sw-ro1 router\ncheck ovn-nbctl lsp-set-addresses sw-ro1 router\ncheck ovn-nbctl lsp-set-options sw-ro1 router-port=ro1-sw\n\ncheck ovn-nbctl lr-add ro2\ncheck ovn-nbctl lrp-add ro2 ro2-sw 00:00:00:00:00:02 20.0.0.1/24\ncheck ovn-nbctl lsp-add sw sw-ro2\ncheck ovn-nbctl lsp-set-type sw-ro2 router\ncheck ovn-nbctl lsp-set-addresses sw-ro2 router\ncheck ovn-nbctl --wait=sb lsp-set-options sw-ro2 router-port=ro2-sw\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl lsp-add ls1 vm1\ncheck ovn-nbctl lsp-set-addresses vm1 \"00:00:00:00:01:02 192.168.1.2\"\ncheck ovn-nbctl lrp-add ro1 ro1-ls1 00:00:00:00:01:01 192.168.1.1/24\ncheck ovn-nbctl lsp-add ls1 ls1-ro1\ncheck ovn-nbctl lsp-set-type ls1-ro1 router\ncheck ovn-nbctl lsp-set-addresses ls1-ro1 router\ncheck ovn-nbctl lsp-set-options ls1-ro1 router-port=ro1-ls1\n\ncheck ovn-nbctl ls-add ls2\ncheck ovn-nbctl lsp-add ls2 vm2\ncheck ovn-nbctl lsp-set-addresses vm2 \"00:00:00:00:02:02 192.168.2.2\"\ncheck ovn-nbctl lrp-add ro2 ro2-ls2 00:00:00:00:02:01 192.168.2.1/24\ncheck ovn-nbctl lsp-add ls2 ls2-ro2\ncheck ovn-nbctl lsp-set-type ls2-ro2 router\ncheck ovn-nbctl lsp-set-addresses ls2-ro2 router\ncheck ovn-nbctl lsp-set-options ls2-ro2 router-port=ro2-ls2\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\novn-sbctl lflow-list ls2 > ls2_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls2_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:01), action=(outport = \"ls2-ro2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:02), action=(outport = \"vm2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:02:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.2.1), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:201), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\nAS_BOX([Adding some reachable NAT addresses])\n\ncheck ovn-nbctl lr-nat-add ro1 dnat 10.0.0.100 192.168.1.100\ncheck ovn-nbctl lr-nat-add ro1 snat 10.0.0.200 192.168.1.200/30\n\ncheck ovn-nbctl lr-nat-add ro2 dnat 20.0.0.100 192.168.2.100\ncheck ovn-nbctl --wait=sb lr-nat-add ro2 snat 20.0.0.200 192.168.2.200/30\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\novn-sbctl lflow-list ls2 > ls2_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls2_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:01), action=(outport = \"ls2-ro2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:02), action=(outport = \"vm2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:02:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.2.1), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 20.0.0.100), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:201), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\nAS_BOX([Adding some unreachable NAT addresses])\n\ncheck ovn-nbctl lr-nat-add ro1 dnat 30.0.0.100 192.168.1.130\ncheck ovn-nbctl lr-nat-add ro1 snat 30.0.0.200 192.168.1.148/30\n\ncheck ovn-nbctl lr-nat-add ro2 dnat 40.0.0.100 192.168.2.130\ncheck ovn-nbctl --wait=sb lr-nat-add ro2 snat 40.0.0.200 192.168.2.148/30\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\novn-sbctl lflow-list ls2 > ls2_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls2_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:01), action=(outport = \"ls2-ro2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:02), action=(outport = \"vm2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:02:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.2.1), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 20.0.0.100), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 40.0.0.100), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:201), action=(clone {outport = \"ls2-ro2\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\nAS_BOX([Adding load balancer reachable VIPs to ro1])\n\novn-nbctl lb-add lb1 192.168.1.100:80 10.0.0.10:80\novn-nbctl --wait=sb lr-lb-add ro1 lb1\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\nAS_BOX([Adding load balancer unreachable VIPs to ro1])\novn-nbctl --wait=sb lb-add lb1 192.168.4.100:80 10.0.0.10:80\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\n# Make sure that there is no flow for VIP 192.168.4.100 as ro1-ls1 doesn't\n# have a gw router port or is not a gateway router.\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | grep \"192.168.4.100\" | grep \"_MC_flood\" -c], [1], [0\n])\n\nAS_BOX([Configuring ro1-ls1 router port as a gateway router port])\n\novn-nbctl --wait=sb lrp-set-gateway-chassis ro1-ls1 chassis-1 30\n\novn-sbctl lflow-list ls1 > ls1_lflows\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = \"ls1-ro1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = \"vm1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = \"ls1-ro1\"; output; }; outport = \"_MC_flood_l2\"; output;)\n])\n\n\n# Make sure that there is no flow for VIP 192.168.4.100 as it is unreachable.\nAT_CHECK([grep \"ls_in_l2_lkup\" ls1_lflows | grep \"192.168.4.100\" | grep -v clone | grep \"_MC_flood\" -c], [1], [0\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- LR NAT flows])\novn_start\n\ncheck ovn-nbctl \\\n    -- ls-add sw0 \\\n    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080 \\\n    -- ls-lb-add sw0 lb0\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\n# Create few dnat_and_snat entries\n\ncheck ovn-nbctl lr-nat-add lr0 snat 172.168.0.10 10.0.0.0/24\ncheck ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.168.0.20 10.0.0.3\ncheck ovn-nbctl lr-nat-add lr0 snat 172.168.0.30 10.0.0.10\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\ncheck ovn-sbctl chassis-add gw1 geneve 127.0.0.1 \\\n  -- set chassis gw1 other_config:ct-no-masked-label=\"true\" \\\n  -- set chassis gw1 other_config:ovn-ct-lb-related=\"true\"\n\n# Create a distributed gw port on lr0\ncheck ovn-nbctl ls-add public\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:00:00:ff:02 172.168.0.10/24\ncheck ovn-nbctl lrp-set-gateway-chassis lr0-public gw1\n\novn-nbctl lsp-add public public-lr0 -- set Logical_Switch_Port public-lr0 \\\n    type=router options:router-port=lr0-public \\\n    -- lsp-set-addresses public-lr0 router\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone(10.0.0.3);)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.10 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.20 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.30 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=153  , match=(ip && ip4.src == 10.0.0.0/24 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=154  , match=(ip && ip4.src == 10.0.0.0/24 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.10 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.20);)\n  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.10 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.20);)\n])\n\n# Associate load balancer to lr0\n\ncheck ovn-nbctl lb-add lb0 172.168.0.100:8082 \"10.0.0.50:82,10.0.0.60:82\"\n\n# No L4\ncheck ovn-nbctl lb-add lb1 172.168.0.200 \"10.0.0.80,10.0.0.81\"\ncheck ovn-nbctl lb-add lb2 172.168.0.210:60 \"10.0.0.50:6062,10.0.0.60:6062\" udp\n\ncheck ovn-nbctl lr-lb-add lr0 lb0\ncheck ovn-nbctl lr-lb-add lr0 lb1\ncheck ovn-nbctl lr-lb-add lr0 lb2\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == \"lr0-public\" && flags.loopback == 0 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone;)\n  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == \"lr0-public\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone(10.0.0.3);)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_lb_mark(backends=10.0.0.80,10.0.0.81);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_lb_mark(backends=10.0.0.4:8080);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60 && is_chassis_resident(\"cr-lr0-public\")), action=(ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.10 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.20 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.30 && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.4 && tcp.src == 8080)) && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.50 && tcp.src == 82) || (ip4.src == 10.0.0.60 && tcp.src == 82)) && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.50 && udp.src == 6062) || (ip4.src == 10.0.0.60 && udp.src == 6062)) && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.80) || (ip4.src == 10.0.0.81)) && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_dnat_in_czone;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=153  , match=(ip && ip4.src == 10.0.0.0/24 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=154  , match=(ip && ip4.src == 10.0.0.0/24 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.10 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(ct_snat_in_czone(172.168.0.20);)\n  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.10 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.3 && outport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.20);)\n])\n\n# Make the logical router as Gateway router\ncheck ovn-nbctl clear logical_router_port lr0-public gateway_chassis\ncheck ovn-nbctl set logical_router lr0 options:chassis=gw1\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(ct_lb_mark(backends=10.0.0.80,10.0.0.81);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.4:8080);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)\n])\n\n\n# Set lb force snat logical router.\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip=\"router_ip\"\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.80,10.0.0.81; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-public\"), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw0\"), action=(ct_snat(10.0.0.1);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)\n])\n\n# Add a LB VIP same as router ip.\ncheck ovn-nbctl lb-add lb0 172.168.0.10:9082 \"10.0.0.50:82,10.0.0.60:82\"\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.80,10.0.0.81; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-public\"), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw0\"), action=(ct_snat(10.0.0.1);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)\n])\n\n# Add IPv6 router port and LB.\ncheck ovn-nbctl lrp-del lr0-sw0\ncheck ovn-nbctl lrp-del lr0-public\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 aef0::1\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:00:00:ff:02 172.168.0.10/24 def0::10\n\nlb1_uuid=$(fetch_column nb:Load_Balancer _uuid name=lb1)\novn-nbctl set load_balancer $lb1_uuid vips:'\"[[def0::2]]:8000\"'='\"@<:@aef0::2@:>@:80,@<:@aef0::3@:>@:80\"'\n\novn-nbctl list load_Balancer\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-public\" && ip6.dst == def0::10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip4.dst == 10.0.0.1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == \"lr0-sw0\" && ip6.dst == aef0::1), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(next;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)\n  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip6.dst == def0::2), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.80,10.0.0.81; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip6 && ip6.dst == def0::2 && tcp && tcp.dst == 8000), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=[[aef0::2]]:80,[[aef0::3]]:80; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-public\"), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == \"lr0-sw0\"), action=(ct_snat(10.0.0.1);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip6 && outport == \"lr0-public\"), action=(ct_snat(def0::10);)\n  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip6 && outport == \"lr0-sw0\"), action=(ct_snat(aef0::1);)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)\n  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)\n])\n\ncheck ovn-nbctl lrp-del lr0-sw0\ncheck ovn-nbctl lrp-del lr0-public\ncheck ovn-nbctl lr-lb-del lr0\ncheck ovn-nbctl lr-nat-del lr0\n\ncheck ovn-nbctl lb-add lb3 172.168.0.210:60 \"10.0.0.50:6062,10.0.0.60:6062\" udp\ncheck ovn-nbctl lb-add lb4 172.168.0.210:60 \"10.0.0.50:6062,10.0.0.60:6062\" tcp\ncheck ovn-nbctl lr-lb-add lr0 lb3\ncheck ovn-nbctl lr-lb-add lr0 lb4\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep \"lr_in_unsnat\" lr0flows | sort], [0], [dnl\n  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_defrag\" lr0flows | sort], [0], [dnl\n  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_in_dnat\" lr0flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && tcp && tcp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep \"lr_out_chk_dnat_local\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)\n])\n\nAT_CHECK([grep \"lr_out_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)\n  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)\n])\n\nAT_CHECK([grep \"lr_out_post_undnat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )\n])\n\nAT_CHECK([grep \"lr_out_snat\" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl\n  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)\n  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)\n])\n\n# LB with reject configured\ncheck ovn-nbctl --wait=sb remove logical_router lr0 options lb_force_snat_ip\ncheck ovn-nbctl --wait=sb sync\n\ncheck ovn-nbctl lr-lb-del lr0\ncheck ovn-nbctl lsp-add sw0 vip1\ncheck ovn-nbctl lsp-add sw0 vip2\ncheck ovn-nbctl --reject lb-add lb5 172.168.10.10 10.0.20.10,10.0.20.20\ncheck ovn-nbctl --wait=sb set load_balancer lb5 ip_port_mappings:10.0.20.10=vip1:10.0.0.2\ncheck ovn-nbctl --wait=sb set load_balancer lb5 ip_port_mappings:10.0.20.20=vip2:20.0.0.2\n\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb5\nAT_CHECK([ovn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"172.168.10.10\" -- add Load_Balancer lb5 \\\nhealth_check @hc | uuidfilt], [0], [<0>\n])\nwait_row_count Service_Monitor 2\n\n# Set the service monitor for vip1 and vip2 to offline\nsm_vip1=$(fetch_column Service_Monitor _uuid logical_port=vip1)\nsm_vip2=$(fetch_column Service_Monitor _uuid logical_port=vip2)\n\novn-sbctl set service_monitor $sm_vip1 status=offline\novn-sbctl set service_monitor $sm_vip2 status=offline\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.10), action=(reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=3);};)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\n# LB with reject and skip_snat\ncheck ovn-nbctl --wait=sb set load_balancer lb5 options:skip_snat=true\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.10), action=(flags.skip_snat_for_lb = 1; reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=3);};)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\ncheck ovn-nbctl --wait=sb remove load_balancer lb5 options skip_snat\n\n# LB with reject and force_snat\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip=\"router_ip\"\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.10), action=(flags.force_snat_for_lb = 1; reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=3);};)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\n# LB with event=false and reject=false\ncheck ovn-nbctl lr-lb-del lr0\ncheck ovn-nbctl remove logical_router lr0 options lb_force_snat_ip\nAT_CHECK([ovn-nbctl create load_balancer name=lb6 options:reject=false options:event=false vips:\\\"172.168.10.30\\\"=\\\"\\\" protocol=tcp], [0], [ignore])\ncheck ovn-nbctl --wait=sb lr-lb-add lr0 lb6\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.30), action=(drop;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\n# LB with event=false, reject=false and skip_snat\ncheck ovn-nbctl --wait=sb set load_balancer lb6 options:skip_snat=true\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.30), action=(flags.skip_snat_for_lb = 1; drop;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\ncheck ovn-nbctl remove load_balancer lb6 options skip_snat\n\n# LB with event=false, reject=false and force_snat\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip=\"router_ip\"\n\nAT_CHECK([ovn-sbctl dump-flows lr0 | grep \"lr_in_dnat\" | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.30), action=(flags.force_snat_for_lb = 1; drop;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load Balancer SB duplicates])\novn_start\n\ncheck ovn-nbctl ls-add ls -- lb-add lb1 10.0.0.1:80 10.0.0.2:80 -- ls-lb-add ls lb1\ncheck ovn-nbctl --wait=sb sync\n\ndps=$(fetch_column Load_Balancer datapath_group)\nnlb=$(fetch_column nb:Load_Balancer _uuid)\nAT_CHECK([ovn-sbctl create Load_Balancer name=lb1 datapath_group=\"$dps\" external_ids=\"lb_id=$nlb\"], [0], [ignore])\n\ncheck ovn-nbctl --wait=sb sync\ncheck_row_count Load_Balancer 1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- Add tags to logical flows])\novn_start\n\ncheck ovn-nbctl \\\n    -- ls-add sw0 \\\n    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080 \\\n    -- ls-lb-add sw0 lb0\n\ncheck ovn-nbctl lsp-add sw0 lsp0 \\\n    -- lsp-set-addresses lsp0 \"00:00:00:00:ff:01 1.2.3.4\" \\\n    -- lsp-set-port-security lsp0 \"00:00:00:00:ff:01 1.2.3.4\"\n\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl --columns=tags list logical_flow | grep lsp0 -c], [0], [dnl\n1\n])\n\ncheck ovn-nbctl set logical_switch_port lsp0 enabled=false\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl --columns=tags list logical_flow | grep lsp0 -c], [0], [dnl\n3\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- gateway mtu check pkt larger flows])\novn_start\n\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.1\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\n\n# Create a logical router and attach both logical switches\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\ncheck ovn-nbctl lsp-add sw1 sw1-lr0\ncheck ovn-nbctl lsp-set-type sw1-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\ncheck ovn-nbctl ls-add public\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24\ncheck ovn-nbctl lsp-add public public-lr0\ncheck ovn-nbctl lsp-set-type public-lr0 router\ncheck ovn-nbctl lsp-set-addresses public-lr0 router\ncheck ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public\n\ncheck ovn-nbctl --wait=sb lrp-set-gateway-chassis lr0-public ch1\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-public options:gateway_mtu=1500\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\n\nAT_CHECK([grep -E \"lr_in_admission.*check_pkt_larger\" lr0flows | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\" && is_chassis_resident(\"cr-lr0-public\")), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n])\n\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp4_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp6_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\n\n# Clear the gateway-chassis for lr0-public\ncheck ovn-nbctl --wait=sb clear logical_router_port lr0-public gateway_chassis\n\n# Make lr0 as a gateway router.\ncheck ovn-nbctl --wait=sb set logical_router lr0 options:chassis=ch1\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\n\nAT_CHECK([grep -E \"lr_in_admission.*check_pkt_larger\" lr0flows | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n])\n\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp4_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp6_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\n\n# Set gateway_mtu_bypass to avoid check_pkt_larger() for tcp on lr0-public.\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-public options:gateway_mtu_bypass=tcp\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == \"lr0-public\" && (tcp)), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n])\n\nAT_CHECK([grep \"lr_in_admission\" lr0flows | grep -e \"check_pkt_larger\" -e \"tcp\" | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.mcast && inport == \"lr0-public\" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n])\n\n# Set gateway_mtu option on lr0-sw0\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-sw0 options:gateway_mtu=1400\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == \"lr0-public\" && (tcp)), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n])\n\nAT_CHECK([grep \"lr_in_admission.*check_pkt_larger\" lr0flows | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:ff:01 && inport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n])\n\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp4_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n])\nAT_CHECK([grep -E \"lr_in_ip_input.*icmp6_error\" lr0flows | sort], [0], [dnl\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n])\n\n# Set gateway_mtu_bypass to avoid check_pkt_larger() for tcp on lr0-sw0.\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-sw0 options:gateway_mtu_bypass=tcp\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == \"lr0-public\" && (tcp)), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == \"lr0-sw0\" && (tcp)), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw0\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-public\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n])\n\nAT_CHECK([grep \"lr_in_admission\" lr0flows | grep -e \"check_pkt_larger\" -e \"tcp\" | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:ff:01 && inport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.dst == 00:00:00:00:ff:01 && inport == \"lr0-sw0\" && (tcp)), action=(xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.mcast && inport == \"lr0-public\" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=55   , match=(eth.mcast && inport == \"lr0-sw0\" && (tcp)), action=(xreg0[[0..47]] = 00:00:00:00:ff:01; next;)\n])\n\n# Clear gateway_mtu option on lr0-public\ncheck ovn-nbctl --wait=sb clear logical_router_port lr0-public options\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"chk_pkt_len\" -e \"lr_in_larger_pkts\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == \"lr0-sw0\"), action=(reg9[[1]] = check_pkt_larger(1414); next;)\n  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == \"lr0-sw0\" && (tcp)), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-public\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == \"lr0-sw1\" && outport == \"lr0-sw0\" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)\n])\n\ncheck ovn-nbctl --wait=sb clear logical_router_port lr0-sw0 options\ncheck ovn-nbctl --wait=sb set logical_router_port lr0-public options:gateway_mtu=1500\ncheck ovn-nbctl lsp-add public ext-port\ncheck ovn-nbctl lsp-set-addresses ext-port unknown\ncheck ovn-nbctl lsp-set-type ext-port localnet\ncheck ovn-nbctl --wait=sb set Logical_Switch_Port ext-port tag_request=2\novn-sbctl dump-flows lr0 > lr0flows\n\nAT_CHECK([grep \"lr_in_admission\" lr0flows | grep -e \"check_pkt_larger\" | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1518); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lr0-public\"), action=(reg9[[1]] = check_pkt_larger(1518); xreg0[[0..47]] = 00:00:20:20:12:13; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn -- static routes flows])\nAT_KEYWORDS([static-routes-flows])\novn_start\n\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.1\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl set logical_router lr0 options:chassis=ch1\ncheck ovn-nbctl ls-add public\ncheck ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 192.168.0.1/24\ncheck ovn-nbctl lsp-add public public-lr0\ncheck ovn-nbctl lsp-set-type public-lr0 router\ncheck ovn-nbctl lsp-set-addresses public-lr0 router\ncheck ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public\n\ncheck ovn-nbctl --wait=sb --ecmp-symmetric-reply lr-route-add lr0 1.0.0.1 192.168.0.10\n\novn-sbctl dump-flows lr0 > lr0flows\n\nAT_CHECK([grep -e \"lr_in_ip_routing.*select\" lr0flows |sort], [0], [dnl\n])\nAT_CHECK([grep -e \"lr_in_ip_routing_ecmp\" lr0flows | sed 's/table=../table=??/' |sort], [0], [dnl\n  table=??(lr_in_ip_routing_ecmp), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_ip_routing_ecmp), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb --ecmp-symmetric-reply lr-route-add lr0 1.0.0.1 192.168.0.20\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CHECK([grep -e \"lr_in_ip_routing.*select\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=97   , match=(reg7 == 0 && ip4.dst == 1.0.0.1/32), action=(ip.ttl--; flags.loopback = 1; reg8[[0..15]] = 1; reg8[[16..31]] = select(1, 2);)\n])\nAT_CHECK([grep -e \"lr_in_ip_routing_ecmp\" lr0flows | sed 's/192\\.168\\.0\\..0/192.168.0.??/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing_ecmp), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 1), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; next;)\n  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 2), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; next;)\n  table=??(lr_in_ip_routing_ecmp), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)\n])\n\nAT_CHECK([grep -e \"lr_in_ecmp_stateful\".*commit_ecmp_nh lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (!ct.rpl && ct.est) && sctp && reg9[[5]] == 0), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = sctp); next;)\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (!ct.rpl && ct.est) && tcp && reg9[[5]] == 0), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = tcp); next;)\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (!ct.rpl && ct.est) && udp && reg9[[5]] == 0), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = udp); next;)\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (ct.new && !ct.est) && sctp), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = sctp); next;)\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (ct.new && !ct.est) && tcp), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = tcp); next;)\n  table=??(lr_in_ecmp_stateful), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1 && (ct.new && !ct.est) && udp), action=(ct_commit { ct_label.ecmp_reply_eth = eth.src;  ct_label.ecmp_reply_port = 1;}; commit_ecmp_nh(ipv6 = false, proto = udp); next;)\n])\n\nAT_CHECK([grep -e \"lr_in_defrag\".*chk_ecmp_nh* lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_defrag       ), priority=100  , match=(inport == \"lr0-public\" && ip4.src == 1.0.0.1), action=(reg9[[5]] = chk_ecmp_nh_mac(); ct_next;)\n  table=??(lr_in_defrag       ), priority=100  , match=(reg7 == 0 && ip4.dst == 1.0.0.1/32), action=(reg9[[5]] = chk_ecmp_nh(); ct_next;)\n])\n\ndnl The chassis was created with other_config:ct-no-masked-label=false, the flows\ndnl should be using ct_label.ecmp_reply_port.\nAT_CHECK([grep -e \"lr_in_arp_resolve.*ecmp\" lr0flows | sed 's/table=../table=??/'], [0], [dnl\n  table=??(lr_in_arp_resolve  ), priority=200  , match=(ct.rpl && reg9[[5]] == 1 && ct_label.ecmp_reply_port == 1), action=(push(xxreg1); xxreg1 = ct_label; eth.dst = xxreg1[[32..79]]; pop(xxreg1); next;)\n])\n\ndnl Simulate an ovn-controller upgrade to a version that supports\ndnl ct-no-masked-label.  ovn-northd should start using ct_mark.ecmp_reply_port.\n\ncheck ovn-sbctl set chassis ch1 other_config:ct-no-masked-label=true\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows lr0 > lr0flows\nAT_CHECK([grep -e \"lr_in_arp_resolve.*ecmp\" lr0flows | sed 's/table=../table=??/'], [0], [dnl\n  table=??(lr_in_arp_resolve  ), priority=200  , match=(ct.rpl && reg9[[5]] == 1 && ct_mark.ecmp_reply_port == 1), action=(push(xxreg1); xxreg1 = ct_label; eth.dst = xxreg1[[32..79]]; pop(xxreg1); next;)\n])\n\n# add ecmp route with wrong nexthop\ncheck ovn-nbctl --wait=sb --ecmp-symmetric-reply lr-route-add lr0 1.0.0.1 192.168.1.20\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CHECK([grep -e \"lr_in_ip_routing.*select\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=97   , match=(reg7 == 0 && ip4.dst == 1.0.0.1/32), action=(ip.ttl--; flags.loopback = 1; reg8[[0..15]] = 1; reg8[[16..31]] = select(1, 2);)\n])\nAT_CHECK([grep -e \"lr_in_ip_routing_ecmp\" lr0flows | sed 's/192\\.168\\.0\\..0/192.168.0.??/' | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing_ecmp), priority=0    , match=(1), action=(drop;)\n  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 1), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; next;)\n  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 2), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; next;)\n  table=??(lr_in_ip_routing_ecmp), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)\n])\n\ncheck ovn-nbctl lr-route-del lr0\nwait_row_count nb:Logical_Router_Static_Route 0\n\ncheck ovn-nbctl --wait=sb lr-route-add lr0 1.0.0.0/24 192.168.0.10\novn-sbctl dump-flows lr0 > lr0flows\n\nAT_CHECK([grep -e \"lr_in_ip_routing.*192.168.0.10\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=73   , match=(reg7 == 0 && ip4.dst == 1.0.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.10; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n])\n\ncheck ovn-nbctl --wait=sb lr-route-add lr0 2.0.0.0/24 lr0-public\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CHECK([grep -e \"lr_in_ip_routing.*2.0.0.0\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=73   , match=(reg7 == 0 && ip4.dst == 2.0.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = \"lr0-public\"; flags.loopback = 1; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd -- lr multiple gw ports])\nAT_KEYWORDS([multiple-l3dgw-ports])\novn_start\n\n# Logical network:\n# 1 Logical Router, 3 bridged Logical Switches,\n# 1 gateway chassis attached to each corresponding LRP.\n#\n#                | S1 (gw1)\n#                |\n#      ls  ----  DR -- S3 (gw3)\n# (20.0.0.0/24)  |\n#                | S2 (gw2)\n#\n# Validate basic LR logical flows.\n\ncheck ovn-sbctl chassis-add gw1 geneve 127.0.0.1\ncheck ovn-sbctl chassis-add gw2 geneve 128.0.0.1\ncheck ovn-sbctl chassis-add gw3 geneve 129.0.0.1\n\ncheck ovn-nbctl lr-add DR\ncheck ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24\ncheck ovn-nbctl lrp-add DR DR-S2 03:ac:10:01:00:01 172.16.2.1/24\ncheck ovn-nbctl lrp-add DR DR-S3 04:ac:10:01:00:01 172.16.3.1/24\ncheck ovn-nbctl lrp-add DR DR-ls 05:ac:10:01:00:01 20.0.0.1/24\n\ncheck ovn-nbctl ls-add S1\ncheck ovn-nbctl lsp-add S1 S1-DR\ncheck ovn-nbctl lsp-set-type S1-DR router\ncheck ovn-nbctl lsp-set-addresses S1-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1\n\ncheck ovn-nbctl ls-add S2\ncheck ovn-nbctl lsp-add S2 S2-DR\ncheck ovn-nbctl lsp-set-type S2-DR router\ncheck ovn-nbctl lsp-set-addresses S2-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S2-DR router-port=DR-S2\n\ncheck ovn-nbctl ls-add S3\ncheck ovn-nbctl lsp-add S3 S3-DR\ncheck ovn-nbctl lsp-set-type S3-DR router\ncheck ovn-nbctl lsp-set-addresses S3-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S3-DR router-port=DR-S3\n\ncheck ovn-nbctl ls-add  ls\ncheck ovn-nbctl lsp-add ls ls-DR\ncheck ovn-nbctl lsp-set-type ls-DR router\ncheck ovn-nbctl lsp-set-addresses ls-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options ls-DR router-port=DR-ls\n\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S1 gw1\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S2 gw2\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S3 gw3\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > lrflows\nAT_CAPTURE_FILE([lrflows])\n\n# Check the flows in lr_in_admission stage\nAT_CHECK([grep lr_in_admission lrflows | grep cr-DR | sort], [0], [dnl\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 02:ac:10:01:00:01 && inport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(xreg0[[0..47]] = 02:ac:10:01:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 03:ac:10:01:00:01 && inport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(xreg0[[0..47]] = 03:ac:10:01:00:01; next;)\n  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 04:ac:10:01:00:01 && inport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(xreg0[[0..47]] = 04:ac:10:01:00:01; next;)\n])\n# Check the flows in lr_in_lookup_neighbor stage\nAT_CHECK([grep lr_in_lookup_neighbor lrflows | grep cr-DR | sort], [0], [dnl\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(inport == \"DR-S1\" && arp.spa == 172.16.1.0/24 && arp.op == 1 && is_chassis_resident(\"cr-DR-S1\")), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(inport == \"DR-S2\" && arp.spa == 172.16.2.0/24 && arp.op == 1 && is_chassis_resident(\"cr-DR-S2\")), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(inport == \"DR-S3\" && arp.spa == 172.16.3.0/24 && arp.op == 1 && is_chassis_resident(\"cr-DR-S3\")), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)\n])\n# Check the flows in lr_in_gw_redirect stage\nAT_CHECK([grep lr_in_gw_redirect lrflows | grep cr-DR | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == \"DR-S1\"), action=(outport = \"cr-DR-S1\"; next;)\n  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == \"DR-S2\"), action=(outport = \"cr-DR-S2\"; next;)\n  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == \"DR-S3\"), action=(outport = \"cr-DR-S3\"; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd -- lrp with chassis-redirect and ls with vtep lport])\nAT_KEYWORDS([multiple-l3dgw-ports])\novn_start NORTHD_TYPE\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.2\n\ncheck ovn-nbctl lr-add lr1\ncheck ovn-nbctl lrp-add lr1 lrp1 00:00:00:00:00:01 10.0.0.1/24\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl lsp-add ls1 lsp1 -- \\\n    lsp-set-addresses lsp1 router -- \\\n    lsp-set-type lsp1 router -- \\\n    lsp-set-options lsp1 router-port=lrp1\n\n# ensure initial flows are installed without is_chassis_resident match part\novn-nbctl --wait=sb sync\novn-sbctl dump-flows lr1 > lrflows\nAT_CAPTURE_FILE([lrflows])\n\n# Check the flows in lr_in_admission stage\nAT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n])\n\n# Check the flows in lr_in_gw_redirect stage\nAT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [])\n\nwait_row_count Port_Binding 0 logical_port=cr-lrp1 options:always-redirect=\"true\"\n\n# make lrp a cr-port and check its flows\ncheck ovn-nbctl lrp-set-gateway-chassis lrp1 ch1\n\novn-nbctl --wait=sb sync\novn-sbctl dump-flows lr1 > lrflows\nAT_CAPTURE_FILE([lrflows])\n\n# Check the flows in lr_in_admission stage\nAT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp1\" && is_chassis_resident(\"cr-lrp1\")), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n])\n\n# Check the flows in lr_in_gw_redirect stage\nAT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == \"lrp1\"), action=(outport = \"cr-lrp1\"; next;)\n])\n\nwait_row_count Port_Binding 1 logical_port=cr-lrp1 options:always-redirect=\"true\"\n\n# attach vtep logical port to logical switch and check flows.\n# there should not be is_chassis_resident part.\ncheck ovn-nbctl lsp-add ls1 lsp-vtep -- lsp-set-type lsp-vtep vtep\n\novn-nbctl --wait=sb sync\novn-sbctl dump-flows lr1 > lrflows\nAT_CAPTURE_FILE([lrflows])\n\n# Check the flows in lr_in_admission stage\nAT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n])\n\n# Check the flows in lr_in_gw_redirect stage\nAT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [])\n\nwait_row_count Port_Binding 0 logical_port=cr-lrp1 options:always-redirect=\"true\"\n\n# delete vtep lport and check lrp has is_chassis_resident match part again.\ncheck ovn-nbctl lsp-del lsp-vtep\n\novn-nbctl --wait=sb sync\novn-sbctl dump-flows lr1 > lrflows\nAT_CAPTURE_FILE([lrflows])\n\n# Check the flows in lr_in_admission stage\nAT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == \"lrp1\" && is_chassis_resident(\"cr-lrp1\")), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == \"lrp1\"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)\n])\n\n# Check the flows in lr_in_gw_redirect stage\nAT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == \"lrp1\"), action=(outport = \"cr-lrp1\"; next;)\n])\n\nwait_row_count Port_Binding 1 logical_port=cr-lrp1 options:always-redirect=\"true\"\n\nAT_CLEANUP\n])\n\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check options:requested-chassis fills requested_chassis col])\novn_start NORTHD_TYPE\n\n# Add chassis ch1.\ncheck ovn-sbctl chassis-add ch1 geneve 127.0.0.2\ncheck ovn-sbctl chassis-add ch2 geneve 127.0.0.3\n\nwait_row_count Chassis 2\n\nch1_uuid=`ovn-sbctl --bare --columns _uuid find Chassis name=\"ch1\"`\nch2_uuid=`ovn-sbctl --bare --columns _uuid find Chassis name=\"ch2\"`\n\ncheck ovn-sbctl set chassis $ch2_uuid hostname=ch2-hostname\n\novn-nbctl ls-add S1\novn-nbctl --wait=sb lsp-add S1 S1-vm1\novn-nbctl --wait=sb lsp-add S1 S1-vm2\n\nwait_row_count Port_Binding 1 logical_port=S1-vm1 requested_chassis!=$ch1_uuid\nwait_row_count Port_Binding 1 logical_port=S1-vm2 requested_chassis!=$ch2_uuid\n\novn-nbctl --wait=sb set logical_switch_port S1-vm1 \\\n    options:requested-chassis=ch1\n\nwait_row_count Port_Binding 1 logical_port=S1-vm1 requested_chassis=$ch1_uuid\n\novn-nbctl --wait=sb set logical_switch_port S1-vm2 \\\n    options:requested-chassis=ch2-hostname\n\nwait_row_count Port_binding 1 logical-port=S1-vm2 requested_chassis=$ch2_uuid\n\novn-nbctl --wait=sb remove logical_switch_port S1-vm2 \\\n    options requested-chassis=ch2-hostname\n\nwait_row_count Port_binding 1 logical-port=S1-vm2 requested_chassis!=$ch2_uuid\n\novn-nbctl --wait=sb set logical_switch_port S1-vm2 \\\n    options:requested-chassis=ch2\n\nwait_row_count Port_binding 1 logical-port=S1-vm2 requested_chassis=$ch2_uuid\n\nAT_CLEANUP\n])\n\n# Duplicated datapaths shouldn't be created, but in case it is created because\n# of bug or dirty data, it should be properly deleted instead of causing\n# permanent failure in northd.\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([handling duplicated datapaths])\novn_start\n\ncheck ovn-nbctl --wait=sb ls-add ls1\nls1_uuid=$(fetch_column nb:Logical_Switch _uuid)\n\n# create a duplicated sb datapath (and an IP_Mulicast record that references\n# it) on purpose.\nAT_CHECK([ovn-sbctl --id=@dp create Datapath_Binding external_ids:logical-switch=$ls1_uuid external_ids:name=ls1 tunnel_key=123 -- create IP_Multicast datapath=@dp], [0], [ignore])\n\n# northd should delete one of the datapaths in the end\nwait_row_count Datapath_Binding 1\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([conntrack nat implies conntrack])\novn_start\n\ncheck ovn-nbctl lr-add rtr \\\n  -- set logical_router rtr options:chassis=hv \\\n  -- lrp-add rtr rtr-ls 00:00:00:00:01:00 42.42.42.1/24 \\\n  -- lb-add lb-test 43.43.43.43:4343 42.42.42.2:4242 tcp \\\n  -- lr-lb-add rtr lb-test\ncheck ovn-nbctl --wait=sb sync\n\nflow=\"eth.dst == 00:00:00:00:01:00 && inport == \\\"rtr-ls\\\" && ip4.src == 42.42.42.42 && ip4.dst == 43.43.43.43 && ip.ttl == 64 && tcp && tcp.dst == 4343\"\n\nAT_CHECK_UNQUOTED([ovn_trace --ct new --minimal \"${flow}\" --lb-dst 42.42.42.42:4242], [0], [dnl\nct_dnat /* assuming no un-dnat entry, so no change */ {\n    ct_lb_mark /* default (use --ct to customize) */ {\n        ip.ttl--;\n        eth.src = 00:00:00:00:01:00;\n        eth.dst = 00:00:00:00:00:00;\n        arp {\n            eth.dst = ff:ff:ff:ff:ff:ff;\n            arp.spa = 0x2a2a2a01;\n            arp.tpa = 0x2a2a2a02;\n            arp.op = 1;\n            output(\"rtr-ls\");\n        };\n    };\n};\n])\n\nAT_CHECK_UNQUOTED([ovn_trace --minimal \"${flow}\" --lb-dst 42.42.42.42:4242], [0], [dnl\nct_dnat /* assuming no un-dnat entry, so no change */ /* default (use --ct to customize) */;\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([route tables -- flows])\nAT_KEYWORDS([route-tables-flows])\novn_start\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lrp0 00:00:00:00:00:01 192.168.0.1/24\ncheck ovn-nbctl lrp-add lr0 lrp1 00:00:00:00:01:01 192.168.1.1/24\ncheck ovn-nbctl lrp-add lr0 lrp2 00:00:00:00:02:01 192.168.2.1/24\ncheck ovn-nbctl lrp-set-options lrp1 route_table=rtb-1\ncheck ovn-nbctl lrp-set-options lrp2 route_table=rtb-2\n\ncheck ovn-nbctl lr-route-add lr0 0.0.0.0/0 192.168.0.10\ncheck ovn-nbctl --route-table=rtb-1 lr-route-add lr0 192.168.0.0/24 192.168.1.10\ncheck ovn-nbctl --route-table=rtb-2 lr-route-add lr0 0.0.0.0/0 192.168.0.10\ncheck ovn-nbctl --route-table=rtb-2 lr-route-add lr0 1.1.1.1/32 192.168.0.20\ncheck ovn-nbctl --route-table=rtb-2 lr-route-add lr0 2.2.2.2/32 192.168.0.30\ncheck ovn-nbctl --route-table=rtb-2 --ecmp lr-route-add lr0 2.2.2.2/32 192.168.0.31\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr0 > lr0flows\nAT_CAPTURE_FILE([lr0flows])\n\nAT_CHECK([grep -e \"lr_in_ip_routing_pre.*match=(1)\" lr0flows | sed 's/table=../table=??/'], [0], [dnl\n  table=??(lr_in_ip_routing_pre), priority=0    , match=(1), action=(reg7 = 0; next;)\n])\n\np1_reg=$(grep -oP \"lr_in_ip_routing_pre.*lrp1.*action=\\(reg7 = \\K.\" lr0flows)\np2_reg=$(grep -oP \"lr_in_ip_routing_pre.*lrp2.*action=\\(reg7 = \\K.\" lr0flows)\necho $p1_reg\necho $p2_reg\n\n# exact register values are not predictable\nif [[ $p1_reg -eq 2 ] && [ $p2_reg -eq 1 ]]; then\n  echo \"swap reg values in dump\"\n  sed -i -r s'/^(.*lrp2.*action=\\(reg7 = )(1)(.*)/\\12\\3/g' lr0flows  # \"reg7 = 1\" -> \"reg7 = 2\"\n  sed -i -r s'/^(.*lrp1.*action=\\(reg7 = )(2)(.*)/\\11\\3/g' lr0flows  # \"reg7 = 2\" -> \"reg7 = 1\"\n  sed -i -r s'/^(.*match=\\(reg7 == )(2)( &&.*lrp1.*)/\\11\\3/g' lr0flows  # \"reg7 == 2\" -> \"reg7 == 1\"\n  sed -i -r s'/^(.*match=\\(reg7 == )(1)( &&.*lrp0.*)/\\12\\3/g' lr0flows  # \"reg7 == 1\" -> \"reg7 == 2\"\nfi\n\ncheck test \"$p1_reg\" != \"$p2_reg\" -a $((p1_reg * p2_reg)) -eq 2\n\nAT_CHECK([grep \"lr_in_ip_routing_pre\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing_pre), priority=0    , match=(1), action=(reg7 = 0; next;)\n  table=??(lr_in_ip_routing_pre), priority=100  , match=(inport == \"lrp1\"), action=(reg7 = 1; next;)\n  table=??(lr_in_ip_routing_pre), priority=100  , match=(inport == \"lrp2\"), action=(reg7 = 2; next;)\n])\n\ngrep -e \"(lr_in_ip_routing   ).*outport\" lr0flows\n\nAT_CHECK([grep -e \"(lr_in_ip_routing   ).*outport\" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=1    , match=(reg7 == 0 && ip4.dst == 0.0.0.0/0), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.10; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = \"lrp0\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=1    , match=(reg7 == 2 && ip4.dst == 0.0.0.0/0), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.10; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = \"lrp0\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=194  , match=(inport == \"lrp0\" && ip6.dst == fe80::/64), action=(ip.ttl--; reg8[[0..15]] = 0; xxreg0 = ip6.dst; xxreg1 = fe80::200:ff:fe00:1; eth.src = 00:00:00:00:00:01; outport = \"lrp0\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=194  , match=(inport == \"lrp1\" && ip6.dst == fe80::/64), action=(ip.ttl--; reg8[[0..15]] = 0; xxreg0 = ip6.dst; xxreg1 = fe80::200:ff:fe00:101; eth.src = 00:00:00:00:01:01; outport = \"lrp1\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=194  , match=(inport == \"lrp2\" && ip6.dst == fe80::/64), action=(ip.ttl--; reg8[[0..15]] = 0; xxreg0 = ip6.dst; xxreg1 = fe80::200:ff:fe00:201; eth.src = 00:00:00:00:02:01; outport = \"lrp2\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=73   , match=(reg7 == 1 && ip4.dst == 192.168.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.1.10; reg1 = 192.168.1.1; eth.src = 00:00:00:00:01:01; outport = \"lrp1\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=74   , match=(ip4.dst == 192.168.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = \"lrp0\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=74   , match=(ip4.dst == 192.168.1.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.1.1; eth.src = 00:00:00:00:01:01; outport = \"lrp1\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=74   , match=(ip4.dst == 192.168.2.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.2.1; eth.src = 00:00:00:00:02:01; outport = \"lrp2\"; flags.loopback = 1; next;)\n  table=??(lr_in_ip_routing   ), priority=97   , match=(reg7 == 2 && ip4.dst == 1.1.1.1/32), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.20; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = \"lrp0\"; flags.loopback = 1; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check exclude-lb-vips-from-garp option])\novn_start\n\novn-nbctl lr-add R1\novn-nbctl set logical_router R1 options:chassis=hv1\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01\novn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1 nat-addresses=\"router\"\n\novn-nbctl lr-nat-add R1 snat 172.16.1.1 10.0.0.0/24\novn-nbctl lr-nat-add R1 dnat 172.16.1.2 10.0.0.1\n# Add load balancers\novn-nbctl lb-add lb0 172.16.1.10:80 10.0.0.1:80\novn-nbctl lr-lb-add R1 lb0\novn-nbctl lb-add lb1 172.16.1.10:8080 10.0.0.1:8080\novn-nbctl lr-lb-add R1 lb1\novn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl get Port_Binding S1-R1 nat_addresses |grep -q 172.16.1.10], [0])\n\novn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1 nat-addresses=\"router\" \\\n                    exclude-lb-vips-from-garp=\"true\"\n\nAT_CHECK([ovn-sbctl get Port_Binding S1-R1 nat_addresses |grep -q 172.16.1.10], [1])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL log replies -- flows])\n\nset_acl_options() {\n    local acl_name=$1\n    local label=$2\n    local log_related=$3\n\n    local acl_uuid=$(fetch_column nb:ACL _uuid name=$acl_name)\n    check ovn-nbctl set ACL $acl_uuid label=$label options:log-related=$log_related\n}\n\nrecord_log_flows() {\n    ovn-sbctl lflow-list sw0 | grep -E 'ls_(out|in)_acl.*, priority=65533' | sed 's/table=../table=??/' | sort > log_flows\n}\n\ncheck_log_flows_count() {\n    local expected=$1\n    local table=$2\n    local count=\n\n    echo $table\n    if test -f log_flows; then\n        count=$(grep -c -E ls_${table}_acl log_flows)\n    else\n        count=$(ovn-sbctl lflow-list sw0 | grep -c -E \"ls_$table_acl.*, priority=65533\")\n    fi\n\n    check test \"$count\" -eq \"$expected\"\n}\n\novn_start\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \"00:00:00:00:00:01 10.0.0.1\"\ncheck ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 \"00:00:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl pg-add pg1 sw0-p1 sw0-p2\ncheck ovn-nbctl pg-add pg2 sw0-p1 sw0-p2\ncheck ovn-nbctl pg-add pg3 sw0-p1 sw0-p2\n\ncheck ovn-nbctl --log --name=allow_acl acl-add pg1 from-lport 100 'inport=@pg1 && ip4' allow\nset_acl_options allow_acl 1 true\n\ncheck ovn-nbctl --wait=sb sync\n\n# An allow ACL should *not* result in a priority 65533 log flow being installed\n# since there are no stateful ACLs on the system.\ncheck_log_flows_count 0 in\ncheck_log_flows_count 0 out\n\n# Now add an allow-related ACL. This should result in both the allow-related\n# ACL and the allow ACL having priority 65533 log flows added.\ncheck ovn-nbctl --log --name=allow_related_acl acl-add pg2 from-lport 100 'inport=@pg2 && ip4' allow-related\nset_acl_options allow_related_acl 2 true\ncheck ovn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count will be 4 since we have\n# 2 flows for reply traffic for each ACL\n# 2 flows for related traffic for each ACL\ncheck_log_flows_count 4 out\n# Since the ACLs are ingress, the ingress table\n# should have no log flows\ncheck_log_flows_count 0 in\n\n# Now ensure the flows are what we expect them to be for the ACLs we created\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# Now add a stateless-allow ACL.\ncheck ovn-nbctl --log --name=allow_stateless_acl acl-add pg3 from-lport 100 'inport=@pg3 && ip4' allow-stateless\nset_acl_options allow_stateless_acl 3 true\ncheck ovn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count will still be 4 since the stateless ACL should not have special log flows created\ncheck_log_flows_count 4 out\ncheck_log_flows_count 0 in\n\n# And the log flows will remain the same since the stateless ACL will not be represented.\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# Now remove the label from the allow-related ACL.\nset_acl_options allow_related_acl 0 true\novn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count should now be 2 since the allow_related ACL will not have special\n# log flows created. But since there there is an allow-related ACL present, the\n# allow ACL will be stateful and have special log flows created.\ncheck_log_flows_count 2 out\ncheck_log_flows_count 0 in\n\n# And make sure only the allow ACL has the log flows installed\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# And now add the label back, but disable log_related on the allow-related ACL.\nset_acl_options allow_related_acl 2 false\n\nrecord_log_flows\n\n# The count will again be 2 because only the allow ACL will have log flows installed.\ncheck_log_flows_count 2 out\ncheck_log_flows_count 0 in\n\n# And make sure only the allow ACL has the log flows installed\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_out_acl         ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_out_acl         ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# And just for sanity's sake, let's remove the allow-related ACL and make sure\n# all the special log messages are gone.\ncheck ovn-nbctl acl-del pg2\ncheck ovn-nbctl --wait=sb sync\n\ncheck_log_flows_count 0 out\ncheck_log_flows_count 0 in\n\n# Now let's clear out all the ACLs, and re-do everything but with egress ACLs.\ncheck ovn-nbctl acl-del pg1\ncheck ovn-nbctl acl-del pg3\ncheck_row_count nb:ACL 0\n\n# Start again with an allow_acl only\ncheck ovn-nbctl --log --name=allow_acl acl-add pg1 to-lport 100 'inport=@pg1 && ip4' allow\nset_acl_options allow_acl 1 true\n\ncheck ovn-nbctl --wait=sb sync\n\n# Again, the allow ACL is stateless, so no related log flows.\ncheck_log_flows_count 0 in\ncheck_log_flows_count 0 out\n\n# Adding a new allow-related ACL...\ncheck ovn-nbctl --log --name=allow_related_acl acl-add pg2 to-lport 100 'inport=@pg2 && ip4' allow-related\nset_acl_options allow_related_acl 2 true\ncheck ovn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count will be 4 since we have\n# 2 flows for reply traffic for each ACL\n# 2 flows for related traffic for each ACL\ncheck_log_flows_count 4 in\n# And this time, we should have no egress flows\ncheck_log_flows_count 0 out\n\n# Now ensure the flows are what we expect them to be for the ACLs we created\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# Now add a stateless-allow ACL.\ncheck ovn-nbctl --log --name=allow_stateless_acl acl-add pg3 from-lport 100 'inport=@pg3 && ip4' allow-stateless\nset_acl_options allow_stateless_acl 3 true\ncheck ovn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count will still be 4 since the stateless ACL should not have special log flows created\ncheck_log_flows_count 4 in\ncheck_log_flows_count 0 out\n\n# And the log flows will remain the same since the stateless ACL will not be represented.\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name=\"allow_related_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# Now remove the label from the allow-related ACL.\nset_acl_options allow_related_acl 0 true\novn-nbctl --wait=sb sync\n\nrecord_log_flows\n\n# The count should now be 2 since the allow_related ACL will not have special\n# log flows created. But since there there is an allow-related ACL present, the\n# allow ACL will be stateful and have special log flows created.\ncheck_log_flows_count 2 in\ncheck_log_flows_count 0 out\n\n# And make sure only the allow ACL has the log flows installed\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# And now add the label back, but disable log_related on the allow-related ACL.\nset_acl_options allow_related_acl 2 false\n\nrecord_log_flows\n\n# The count will again be 2 because only the allow ACL will have log flows installed.\ncheck_log_flows_count 2 in\ncheck_log_flows_count 0 out\n\n# And make sure only the allow ACL has the log flows installed\nAT_CHECK([cat log_flows], [0], [dnl\n  table=??(ls_in_acl          ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n  table=??(ls_in_acl          ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name=\"allow_acl\", severity=info, verdict=allow); next;)\n])\n\nrm log_flows\n\n# And just for sanity's sake, let's remove the allow-related ACL and make sure\n# all the special log messages are gone.\ncheck ovn-nbctl acl-del pg2\ncheck ovn-nbctl --wait=sb sync\n\ncheck_log_flows_count 0 out\ncheck_log_flows_count 0 in\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Static IP multicast report forwarding])\n\novn_start\n\ncheck ovn-nbctl lr-add lr\ncheck ovn-nbctl lrp-add lr lrp1 00:00:00:00:00:01 10.10.10.1/24 1010::1/64\ncheck ovn-nbctl lrp-add lr lrp2 00:00:00:00:00:02 20.20.20.1/24 2020::1/64\ncheck ovn-nbctl set logical_router lr options:mcast_relay=\"true\"\ncheck ovn-nbctl set logical_router_port lrp1 options:mcast_flood=\"true\"\ncheck ovn-nbctl set logical_router_port lrp2 options:mcast_flood=\"true\"\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows lr > lrflows\nAT_CAPTURE_FILE([lrflows])\n\ndnl Flows to skip TTL == {0, 1} check for IGMP and MLD packets.\nAT_CHECK([grep -e 'lr_in_ip_input    ' lrflows | grep -e 'igmp' -e 'mld' -e 'ip.ttl == {0, 1}' | sed 's/table=../table=??/'], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=120  , match=((mldv1 || mldv2) && ip.ttl == 1), action=(next;)\n  table=??(lr_in_ip_input     ), priority=120  , match=(igmp && ip.ttl == 1), action=(next;)\n  table=??(lr_in_ip_input     ), priority=32   , match=(ip.ttl == {0, 1} && !ip.later_frag && (ip4.mcast || ip6.mcast)), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=31   , match=(inport == \"lrp1\" && ip4 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp4 {eth.dst <-> eth.src; icmp4.type = 11; /* Time exceeded */ icmp4.code = 0; /* TTL exceeded in transit */ ip4.dst = ip4.src; ip4.src = 10.10.10.1 ; ip.ttl = 254; outport = \"lrp1\"; flags.loopback = 1; output; };)\n  table=??(lr_in_ip_input     ), priority=31   , match=(inport == \"lrp1\" && ip6 && ip6.src == 1010::/64 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp6 {eth.dst <-> eth.src; ip6.dst = ip6.src; ip6.src = 1010::1 ; ip.ttl = 254; icmp6.type = 3; /* Time exceeded */ icmp6.code = 0; /* TTL exceeded in transit */ outport = \"lrp1\"; flags.loopback = 1; output; };)\n  table=??(lr_in_ip_input     ), priority=31   , match=(inport == \"lrp2\" && ip4 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp4 {eth.dst <-> eth.src; icmp4.type = 11; /* Time exceeded */ icmp4.code = 0; /* TTL exceeded in transit */ ip4.dst = ip4.src; ip4.src = 20.20.20.1 ; ip.ttl = 254; outport = \"lrp2\"; flags.loopback = 1; output; };)\n  table=??(lr_in_ip_input     ), priority=31   , match=(inport == \"lrp2\" && ip6 && ip6.src == 2020::/64 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp6 {eth.dst <-> eth.src; ip6.dst = ip6.src; ip6.src = 2020::1 ; ip.ttl = 254; icmp6.type = 3; /* Time exceeded */ icmp6.code = 0; /* TTL exceeded in transit */ outport = \"lrp2\"; flags.loopback = 1; output; };)\n  table=??(lr_in_ip_input     ), priority=30   , match=(ip.ttl == {0, 1}), action=(drop;)\n])\n\ndnl Flows to \"route\" (statically forward) without decrementing TTL for\ndnl IGMP and MLD packets.  Also, flows to drop potentially looping IGMP/MLD\ndnl packets.\nAT_CHECK([grep -e 'lr_in_ip_routing   ' lrflows | grep -e 'igmp' -e 'mld' | sed 's/table=../table=??/'], [0], [dnl\n  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:01 && (mldv1 || mldv2)), action=(drop;)\n  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:01 && igmp), action=(drop;)\n  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:02 && (mldv1 || mldv2)), action=(drop;)\n  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:02 && igmp), action=(drop;)\n  table=??(lr_in_ip_routing   ), priority=10460, match=(igmp), action=(clone { outport = \"_MC_static\"; next; };)\n  table=??(lr_in_ip_routing   ), priority=10460, match=(mldv1 || mldv2), action=(clone { outport = \"_MC_static\"; next; };)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACLs after lb])\nAT_KEYWORDS([acl])\novn_start\n\ncheck ovn-nbctl --wait=sb \\\n    -- ls-add ls \\\n    -- lsp-add ls lsp\n\ncheck ovn-nbctl pg-add pg0 lsp\n\ncheck ovn-nbctl acl-add pg0 from-lport 1004 \"ip4 && ip4.dst == 10.0.0.2\" drop\ncheck ovn-nbctl acl-add pg0 from-lport 1002 \"ip4 && tcp\" allow-related\ncheck ovn-nbctl acl-add pg0 from-lport 1003 \"ip4 && icmp\" allow-related\ncheck ovn-nbctl acl-add pg0 from-lport 1001 \"ip4\" drop\n\ncheck ovn-nbctl lb-add lb0 10.0.0.2 10.0.0.10\ncheck ovn-nbctl ls-lb-add ls lb0\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows ls > lsflows\nAT_CAPTURE_FILE([lsflows])\n\nAT_CHECK([grep -e \"ls_in_acl\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2001 , match=(reg0[[10]] == 1 && (ip4)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl          ), priority=2001 , match=(reg0[[9]] == 1 && (ip4)), action=(/* drop */)\n  table=??(ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_in_acl          ), priority=2003 , match=(reg0[[7]] == 1 && (ip4 && icmp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2003 , match=(reg0[[8]] == 1 && (ip4 && icmp)), action=(next;)\n  table=??(ls_in_acl          ), priority=2004 , match=(reg0[[10]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl          ), priority=2004 , match=(reg0[[9]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(/* drop */)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n])\n\nAT_CHECK([grep -e \"ls_in_lb \" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.2), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.10);)\n])\n\nAT_CHECK([grep -e \"ls_in_stateful\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAS_BOX([Remove and add the ACLs back with the apply-after-lb option])\n\ncheck ovn-nbctl clear port_group . acls\n\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1004 \"ip4 && ip4.dst == 10.0.0.2\" drop\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"ip4 && tcp\" allow-related\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1003 \"ip4 && icmp\" allow-related\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1001 \"ip4\" drop\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows ls > lsflows\nAT_CAPTURE_FILE([lsflows])\n\nAT_CHECK([grep -e \"ls_in_acl\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=2001 , match=(reg0[[10]] == 1 && (ip4)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2001 , match=(reg0[[9]] == 1 && (ip4)), action=(/* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2002 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl_after_lb ), priority=2002 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=2003 , match=(reg0[[7]] == 1 && (ip4 && icmp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl_after_lb ), priority=2003 , match=(reg0[[8]] == 1 && (ip4 && icmp)), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=2004 , match=(reg0[[10]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2004 , match=(reg0[[9]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(/* drop */)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n])\n\nAT_CHECK([grep -e \"ls_in_lb \" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.2), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.10);)\n])\n\nAT_CHECK([grep -e \"ls_in_stateful\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAS_BOX([Remove and add the ACLs back with a few ACLs with apply-after-lb option])\n\ncheck ovn-nbctl clear port_group . acls\n\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1004 \"ip4 && ip4.dst == 10.0.0.2\" drop\ncheck ovn-nbctl acl-add pg0 from-lport 1002 \"ip4 && tcp\" allow-related\ncheck ovn-nbctl acl-add pg0 from-lport 1003 \"ip4 && icmp\" allow-related\ncheck ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1001 \"ip4\" drop\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows ls > lsflows\nAT_CAPTURE_FILE([lsflows])\n\nAT_CHECK([grep -e \"ls_in_acl\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2002 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2002 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_in_acl          ), priority=2003 , match=(reg0[[7]] == 1 && (ip4 && icmp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=2003 , match=(reg0[[8]] == 1 && (ip4 && icmp)), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=2001 , match=(reg0[[10]] == 1 && (ip4)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2001 , match=(reg0[[9]] == 1 && (ip4)), action=(/* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2004 , match=(reg0[[10]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(ct_commit { ct_mark.blocked = 1; }; /* drop */)\n  table=??(ls_in_acl_after_lb ), priority=2004 , match=(reg0[[9]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(/* drop */)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n])\n\nAT_CHECK([grep -e \"ls_in_lb \" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.2), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.10);)\n])\n\nAT_CHECK([grep -e \"ls_in_stateful\" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)\n  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ovn-northd -- lr multiple gw ports NAT])\nAT_KEYWORDS([multiple-l3dgw-ports])\novn_start\n\n# Logical network:\n# 1 Logical Router, 3 bridged Logical Switches,\n# 1 gateway chassis attached to each corresponding LRP.\n#\n#                | S1 (gw1)\n#                |\n#      ls  ----  DR -- S3 (gw3)\n# (20.0.0.0/24)  |\n#                | S2 (gw2)\n#\n# Validate SNAT, DNAT and DNAT_AND_SNAT behavior with multiple\n# distributed gateway LRPs.\n\ncheck ovn-sbctl chassis-add gw1 geneve 127.0.0.1\ncheck ovn-sbctl chassis-add gw2 geneve 128.0.0.1\ncheck ovn-sbctl chassis-add gw3 geneve 129.0.0.1\n\ncheck ovn-nbctl lr-add DR\ncheck ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24\ncheck ovn-nbctl lrp-add DR DR-S2 03:ac:10:01:00:01 10.0.0.1/24\ncheck ovn-nbctl lrp-add DR DR-S3 04:ac:10:01:00:01 192.168.0.1/24\ncheck ovn-nbctl lrp-add DR DR-ls 05:ac:10:01:00:01 20.0.0.1/24\n\ncheck ovn-nbctl ls-add S1\ncheck ovn-nbctl lsp-add S1 S1-DR\ncheck ovn-nbctl lsp-set-type S1-DR router\ncheck ovn-nbctl lsp-set-addresses S1-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1\n\ncheck ovn-nbctl ls-add S2\ncheck ovn-nbctl lsp-add S2 S2-DR\ncheck ovn-nbctl lsp-set-type S2-DR router\ncheck ovn-nbctl lsp-set-addresses S2-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S2-DR router-port=DR-S2\n\ncheck ovn-nbctl ls-add S3\ncheck ovn-nbctl lsp-add S3 S3-DR\ncheck ovn-nbctl lsp-set-type S3-DR router\ncheck ovn-nbctl lsp-set-addresses S3-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options S3-DR router-port=DR-S3\n\ncheck ovn-nbctl ls-add  ls\ncheck ovn-nbctl lsp-add ls ls-DR\ncheck ovn-nbctl lsp-set-type ls-DR router\ncheck ovn-nbctl lsp-set-addresses ls-DR router\ncheck ovn-nbctl --wait=sb lsp-set-options ls-DR router-port=DR-ls\n\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S1 gw1\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S2 gw2\ncheck ovn-nbctl lrp-set-gateway-chassis DR-S3 gw3\n\n# Configure SNAT with and without setting \"gateway_port\" column\ncheck ovn-nbctl                      lr-nat-add DR snat  172.16.1.10    20.0.0.10\ncheck ovn-nbctl --gateway-port=DR-S2 lr-nat-add DR snat  10.0.0.10      20.0.0.10\ncheck ovn-nbctl                      lr-nat-add DR snat  192.168.0.10   20.0.0.10\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > lrflows\nAT_CAPTURE_FILE([lrflows])\n\nAT_CHECK([grep lr_in_ip_input lrflows | grep arp | grep -e 172.16.1.10 -e 10.0.0.10 -e 192.168.0.10 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 10.0.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 172.16.1.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 192.168.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 192.168.0.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident(\"cr-DR-S1\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10 && is_chassis_resident(\"cr-DR-S2\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 192.168.0.10 && is_chassis_resident(\"cr-DR-S3\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n])\n\nAT_CHECK([grep lr_in_unsnat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == \"DR-S3\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == \"DR-S3\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat;)\n])\n\nAT_CHECK([grep lr_out_snat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone(172.16.1.10);)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat_in_czone(10.0.0.10);)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat_in_czone(192.168.0.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(10.0.0.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(192.168.0.10);)\n])\n\ncheck ovn-nbctl --wait=sb lr-nat-del DR snat 20.0.0.10\nAT_CHECK([ovn-sbctl dump-flows DR | grep -e lr_in_unsnat -e lr_out_snat | grep ct_snat | wc -l], [0], [0\n])\n\n# Configure DNAT - 2 gateway_ports configured for same external IP\ncheck ovn-nbctl                      lr-nat-add DR dnat  172.16.1.10    20.0.0.10\ncheck ovn-nbctl --gateway-port=DR-S2 lr-nat-add DR dnat  10.0.0.10      20.0.0.10\ncheck ovn-nbctl --gateway-port=DR-S3 lr-nat-add DR dnat  172.16.1.10    20.0.0.10\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > lrflows\nAT_CAPTURE_FILE([lrflows])\n\nAT_CHECK([grep lr_in_ip_input lrflows | grep arp | grep -e 172.16.1.10 -e 10.0.0.10 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 10.0.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 172.16.1.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident(\"cr-DR-S1\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10 && is_chassis_resident(\"cr-DR-S2\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident(\"cr-DR-S3\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n])\n\nAT_CHECK([grep lr_in_dnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_dnat_in_czone(20.0.0.10);)\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_dnat_in_czone(20.0.0.10);)\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_dnat_in_czone(20.0.0.10);)\n])\n\nAT_CHECK([grep lr_out_undnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_dnat_in_czone;)\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_dnat_in_czone;)\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_dnat_in_czone;)\n])\n\ncheck ovn-nbctl --wait=sb lr-nat-del DR dnat\n\nAT_CHECK([ovn-sbctl dump-flows DR | grep -e lr_in_dnat -e lr_out_undnat | grep ct_dnat | wc -l], [0], [0\n])\n\n# Configure DNAT_AND_SNAT\ncheck ovn-nbctl --gateway-port=DR-S1 lr-nat-add DR dnat_and_snat  172.16.1.10    20.0.0.10\ncheck ovn-nbctl                      lr-nat-add DR dnat_and_snat  10.0.0.10      20.0.0.10\ncheck ovn-nbctl --gateway-port=DR-S3 lr-nat-add DR dnat_and_snat  192.168.0.10   20.0.0.10\n\ncheck ovn-nbctl --wait=sb sync\n\novn-sbctl dump-flows DR > lrflows\nAT_CAPTURE_FILE([lrflows])\n\nAT_CHECK([grep lr_in_ip_input lrflows | grep arp | grep -e 172.16.1.10 -e 10.0.0.10 -e 192.168.0.10 | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 10.0.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 172.16.1.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 192.168.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=91   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 192.168.0.10), action=(drop;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S1\" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident(\"cr-DR-S1\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S2\" && arp.op == 1 && arp.tpa == 10.0.0.10 && is_chassis_resident(\"cr-DR-S2\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n  table=??(lr_in_ip_input     ), priority=92   , match=(inport == \"DR-S3\" && arp.op == 1 && arp.tpa == 192.168.0.10 && is_chassis_resident(\"cr-DR-S3\")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)\n])\n\nAT_CHECK([grep lr_in_unsnat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == \"DR-S3\" && flags.loopback == 0 && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat_in_czone;)\n  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == \"DR-S3\" && flags.loopback == 1 && flags.use_snat_zone == 1 && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat;)\n])\n\nAT_CHECK([grep lr_out_snat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_snat_in_czone(172.16.1.10);)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_snat_in_czone(10.0.0.10);)\n  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_snat_in_czone(192.168.0.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.16.1.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(10.0.0.10);)\n  table=??(lr_out_snat        ), priority=162  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(192.168.0.10);)\n])\n\nAT_CHECK([grep lr_in_dnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_dnat_in_czone(20.0.0.10);)\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_dnat_in_czone(20.0.0.10);)\n  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_dnat_in_czone(20.0.0.10);)\n])\n\nAT_CHECK([grep lr_out_undnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S1\" && is_chassis_resident(\"cr-DR-S1\")), action=(ct_dnat_in_czone;)\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S2\" && is_chassis_resident(\"cr-DR-S2\")), action=(ct_dnat_in_czone;)\n  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == \"DR-S3\" && is_chassis_resident(\"cr-DR-S3\")), action=(ct_dnat_in_czone;)\n])\n\ncheck ovn-nbctl --wait=sb lr-nat-del DR dnat_and_snat\n\nAT_CHECK([ovn-sbctl dump-flows DR | grep -e lr_in_unsnat -e lr_out_snat -e lr_in_dnat -e lr_out_undnat | grep ct_snat| wc -l], [0], [0\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LR NB Static_MAC_Binding table])\novn_start\n\n# Create logical routers\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-p0 00:00:01:01:02:03 192.168.10.1/24\novn-nbctl lrp-add lr0 lr0-p1 00:00:02:02:03:04 192.168.11.1/24\n\novn-nbctl static-mac-binding-add lr0-p0 192.168.10.10 00:00:11:22:33:44\novn-nbctl static-mac-binding-add lr0-p0 192.168.10.100 00:00:22:33:44:55\n\nwait_row_count nb:Static_MAC_Binding 2 logical_port=lr0-p0\nwait_row_count Static_MAC_Binding 1 logical_port=lr0-p0 ip=192.168.10.10 mac=\"00\\:00\\:11\\:22\\:33\\:44\"\nwait_row_count Static_MAC_Binding 1 logical_port=lr0-p0 ip=192.168.10.100 mac=\"00\\:00\\:22\\:33\\:44\\:55\"\n\novn-nbctl static-mac-binding-add lr0-p1 10.0.0.10 00:00:33:44:55:66\nwait_row_count nb:Static_MAC_Binding 1 logical_port=lr0-p1\nwait_row_count Static_MAC_Binding 1 logical_port=lr0-p1 ip=10.0.0.10 mac=\"00\\:00\\:33\\:44\\:55\\:66\"\n\novn-nbctl --may-exist static-mac-binding-add lr0-p0 192.168.10.100 00:00:22:33:55:66\nwait_row_count Static_MAC_Binding 1 logical_port=lr0-p0 ip=192.168.10.100 mac=\"00\\:00\\:22\\:33\\:55\\:66\"\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LR neighbor lookup and learning flows])\novn_start\n\n# Create logical routers\novn-nbctl --wait=sb lr-add lr0\n\novn-sbctl dump-flows lr0 > lrflows\nAT_CAPTURE_FILE([lrflows])\n\nAT_CHECK([cat lrflows | grep -e lr_in_lookup_neighbor -e lr_in_learn_neighbor | sort], [0], [dnl\n  table=1 (lr_in_lookup_neighbor), priority=0    , match=(1), action=(reg9[[2]] = 1; next;)\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(arp.op == 2), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(nd_na), action=(reg9[[2]] = lookup_nd(inport, nd.target, nd.tll); next;)\n  table=1 (lr_in_lookup_neighbor), priority=100  , match=(nd_ns), action=(reg9[[2]] = lookup_nd(inport, ip6.src, nd.sll); next;)\n  table=2 (lr_in_learn_neighbor), priority=0    , match=(1), action=(drop;)\n  table=2 (lr_in_learn_neighbor), priority=100  , match=(reg9[[2]] == 1), action=(next;)\n  table=2 (lr_in_learn_neighbor), priority=90   , match=(arp), action=(put_arp(inport, arp.spa, arp.sha); next;)\n  table=2 (lr_in_learn_neighbor), priority=90   , match=(nd_na), action=(put_nd(inport, nd.target, nd.tll); next;)\n  table=2 (lr_in_learn_neighbor), priority=90   , match=(nd_ns), action=(put_nd(inport, ip6.src, nd.sll); next;)\n  table=2 (lr_in_learn_neighbor), priority=95   , match=(nd_na && nd.tll == 0), action=(put_nd(inport, nd.target, eth.src); next;)\n  table=2 (lr_in_learn_neighbor), priority=95   , match=(nd_ns && (ip6.src == 0 || nd.sll == 0)), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([LS default ACL drop])\nAT_KEYWORDS([acl])\n\novn_start\n\ncheck ovn-nbctl ls-add ls\ncheck ovn-nbctl lsp-add ls lsp1 -- lsp-set-addresses lsp1 00:00:00:00:00:01\ncheck ovn-nbctl lsp-add ls lsp2 -- lsp-set-addresses lsp2 00:00:00:00:00:02\n\nflow=\"inport == \\\"lsp1\\\" && eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02 && ip.ttl == 64 && ip4.src == 42.42.42.42 && ip4.dst == 42.42.42.43 && udp && udp.src == 42 && udp.dst == 84\"\n\nAS_BOX([No ACL, default_acl_drop not set])\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl          ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl         ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([No ACL, default_acl_drop false])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl          ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl         ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([No ACL, default_acl_drop true])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl          ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl         ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([from-lport ACL])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl acl-add ls from-lport 1 \"ip4 && tcp\" allow\n\nAS_BOX([from-lport ACL, default_acl_drop not set])\ncheck ovn-nbctl --wait=sb remove NB_Global . options default_acl_drop\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([from-lport ACL, default_acl_drop false])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([from-lport ACL, default_acl_drop true])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\n])\n\nAS_BOX([from-lport ACL allow-related, default_acl_drop true])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl --wait=sb acl-add ls from-lport 1 \"ip4 && tcp\" allow-related\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=1001 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=1001 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk);\n])\n\nAS_BOX([from-lport --apply-after-lb ACL])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl --apply-after-lb acl-add ls from-lport 1 \"ip4 && tcp\" allow\n\nAS_BOX([from-lport --apply-after-lb ACL, default_acl_drop not set])\ncheck ovn-nbctl --wait=sb remove NB_Global . options default_acl_drop\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([from-lport --apply-after-lb ACL, default_acl_drop false])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([from-lport --apply-after-lb ACL, default_acl_drop true])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\n])\n\nAS_BOX([from-lport --apply-after-lb ACL allow-related, default_acl_drop true])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl --wait=sb --apply-after-lb acl-add ls from-lport 1 \"ip4 && tcp\" allow-related\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=1001 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl_after_lb ), priority=1001 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk);\n])\n\nAS_BOX([to-lport ACL])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl acl-add ls to-lport 1 \"ip4 && tcp\" allow\n\nAS_BOX([to-lport ACL, default_acl_drop not set])\ncheck ovn-nbctl --wait=sb remove NB_Global . options default_acl_drop\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([to-lport ACL, default_acl_drop false])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl         ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be allowed.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\noutput(\"lsp2\");\n])\n\nAS_BOX([to-lport ACL, default_acl_drop true])\ncheck ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=1001 , match=(ip4 && tcp), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\n])\n\nAS_BOX([to-lport ACL allow-related, default_acl_drop true])\ncheck ovn-nbctl acl-del ls\ncheck ovn-nbctl --wait=sb acl-add ls to-lport 1 \"ip4 && tcp\" allow-related\nAT_CHECK([ovn-sbctl dump-flows | grep -E \"ls_.*_acl\" | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_in_acl          ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=??(ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_in_pre_acl      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n  table=??(ls_out_acl         ), priority=0    , match=(1), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && !ct.est), action=(drop;)\n  table=??(ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=??(ls_out_acl         ), priority=1001 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg0[[1]] = 1; next;)\n  table=??(ls_out_acl         ), priority=1001 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(next;)\n  table=??(ls_out_acl         ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=??(ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=??(ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.mcast), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)\n  table=??(ls_out_pre_acl     ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)\n])\n\ndnl UDP traffic should be dropped.\nAT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls \"${flow}\"], [0], [dnl\nct_next(ct_state=new|trk);\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([northd-parallelization unixctl])\novn_start\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1\nOVS_WAIT_FOR_OUTPUT([as northd ovn-appctl -t NORTHD_TYPE parallel-build/get-n-threads], [0], [1\n])\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 4\nOVS_WAIT_FOR_OUTPUT([as northd ovn-appctl -t NORTHD_TYPE parallel-build/get-n-threads], [0], [4\n])\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1\nOVS_WAIT_FOR_OUTPUT([as northd ovn-appctl -t NORTHD_TYPE parallel-build/get-n-threads], [0], [1\n])\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 0], [2], [],\n  [invalid n_threads: 0\novn-appctl: ovn-northd: server returned an error\n])\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads -1], [2], [],\n  [invalid n_threads: -1\novn-appctl: ovn-northd: server returned an error\n])\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 300], [2], [],\n  [invalid n_threads: 300\novn-appctl: ovn-northd: server returned an error\n])\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads], [2], [],\n  [\"parallel-build/set-n-threads\" command requires at least 1 arguments\novn-appctl: ovn-northd: server returned an error\n])\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1 2], [2], [],\n  [\"parallel-build/set-n-threads\" command takes at most 1 arguments\novn-appctl: ovn-northd: server returned an error\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([northd-parallelization runtime])\novn_start\n\nadd_switch_ports() {\n    for port in $(seq $1 $2); do\n        OVN_NBCTL(lsp-add ls1 lsp${port})\n        OVN_NBCTL(lsp-set-addresses lsp${port} dynamic)\n    done\n    RUN_OVN_NBCTL()\n}\n\ndelete_switch_ports() {\n    for port in $(seq $1 $2); do\n        OVN_NBCTL(lsp-del lsp${port})\n    done\n    RUN_OVN_NBCTL()\n}\n\nm4_define([DUMP_FLOWS_SORTED], [sed -e 's/arp.tpa == 10.1.0.[[0-9]]\\{1,3\\}/arp.tpa == 10.1.0.??/;s/eth.dst == ..:..:..:..:..:../??:??:??:??:??:??/' | sort])\n\n# Build some rather heavy config and modify number of threads in the middle\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl set Logical_Switch ls1 other_config:subnet=10.1.0.0/16\ncheck ovn-nbctl set Logical_Switch ls1 other_config:exclude_ips=10.1.255.254\n\ncheck ovn-nbctl lr-add lr1\ncheck ovn-nbctl lsp-add ls1 lsp0 -- set Logical_Switch_Port lsp0 type=router options:router-port=lrp0 addresses=dynamic\ncheck ovn-nbctl lrp-add lr1 lrp0 \"f0:00:00:01:00:01\" 10.1.255.254/16\ncheck ovn-nbctl lr-nat-add lr1 snat 10.2.0.1 10.1.0.0/16\nadd_switch_ports 1 50\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 4\nadd_switch_ports 51 100\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 8\nadd_switch_ports 101 150\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 4\nadd_switch_ports 151 200\n\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1\nadd_switch_ports 201 250\ncheck ovn-nbctl --wait=sb sync\n\n# Run 3 times: one with parallelization enabled, one with disabled, and one while changing\n# Compare the flows produced by the three runs\n# Ignore IP/MAC addresses\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > flows1\n\n# Restart with 1 thread\ndelete_switch_ports 1 250\nadd_switch_ports 1 250\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > flows2\nAT_CHECK([diff flows1 flows2])\n\n# Restart with with 8 threads\ncheck as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 8\ndelete_switch_ports 1 250\nadd_switch_ports 1 250\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > flows3\nAT_CHECK([diff flows1 flows3])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Port security lflows])\novn_start\n\n# Create logical routers\ncheck ovn-nbctl --wait=sb ls-add sw0\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\ncheck ovn-nbctl lsp-add sw0 sw0p1 -- lsp-set-addresses sw0p1 \"00:00:00:00:00:01\"\ncheck ovn-nbctl lsp-add sw0 sw0p2 -- lsp-set-addresses sw0p2 \"00:00:00:00:00:02\"\ncheck ovn-nbctl --wait=sb lsp-add sw0 localnetport -- lsp-set-type localnetport localnet\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = \"sw0p1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = \"sw0p2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\ncheck ovn-nbctl lsp-set-port-security sw0p1 \"00:00:00:00:00:01 10.0.0.3 1000::3\"\ncheck ovn-nbctl --wait=sb lsp-set-port-security sw0p2 \"00:00:00:00:00:02 10.0.0.4 1000::4\"\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = \"sw0p1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = \"sw0p2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\n# Disable sw0p1\ncheck ovn-nbctl --wait=sb set logical_switch_port sw0p1 enabled=false\n\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(inport == \"sw0p1\"), action=(reg0[[15]] = 1; next;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = \"sw0p2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"sw0p1\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\ncheck ovn-nbctl --wait=sb lsp-set-options sw0p2 qdisc_queue_id=10\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(inport == \"sw0p1\"), action=(reg0[[15]] = 1; next;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_check_port_sec), priority=70   , match=(inport == \"sw0p2\"), action=(set_queue(10); reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = \"sw0p2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"sw0p1\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\ncheck ovn-nbctl set logical_switch_port sw0p1 enabled=true\ncheck ovn-nbctl lsp-set-type sw0p1 vtep\ncheck ovn-nbctl --wait=sb lsp-set-options localnetport qdisc_queue_id=10\novn-sbctl dump-flows sw0 > sw0flows\nAT_CAPTURE_FILE([sw0flows])\n\nAT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \\\nsort | sed 's/table=../table=??/' ], [0], [dnl\n  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)\n  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_check_port_sec), priority=70   , match=(inport == \"localnetport\"), action=(set_queue(10); reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_check_port_sec), priority=70   , match=(inport == \"sw0p1\"), action=(reg0[[14]] = 1; next(pipeline=ingress, table=16);)\n  table=??(ls_in_check_port_sec), priority=70   , match=(inport == \"sw0p2\"), action=(set_queue(10); reg0[[15]] = check_in_port_sec(); next;)\n  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)\n  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = \"sw0p1\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = \"sw0p2\"; output;)\n  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = \"_MC_flood\"; output;)\n  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)\n  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == \"none\"), action=(drop;)\n  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)\n  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)\n  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)\n  table=??(ls_out_apply_port_sec), priority=100  , match=(outport == \"localnetport\"), action=(set_queue(10); output;)\n  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)\n])\n\nAT_CLEANUP\n])\n\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load balancer ct_lb_mark backwards compatibility])\nAT_KEYWORDS([lb])\novn_start\n\ncheck ovn-nbctl                                               \\\n  -- ls-add ls                                                \\\n  -- lr-add lr -- set logical_router lr options:chassis=local \\\n  -- lb-add lb-test 66.66.66.66 42.42.42.2                    \\\n  -- ls-lb-add ls lb-test                                     \\\n  -- lr-lb-add lr lb-test\n\nAS_BOX([No chassis registered - use ct_lb_mark and ct_mark.natted])\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep -e natted -e ct_lb], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(ct_lb_mark(backends=42.42.42.2);)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=6 (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 66.66.66.66), action=(reg1 = 66.66.66.66; ct_lb_mark;)\n  table=6 (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n  table=12(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 66.66.66.66), action=(reg0[[1]] = 0; ct_lb_mark(backends=42.42.42.2);)\n  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n])\n\nAS_BOX([Chassis registered that doesn't support ct_lb_mark - use ct_lb and ct_label.natted])\ncheck ovn-sbctl chassis-add hv geneve 127.0.0.1\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep -e natted -e ct_lb], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(ct_lb(backends=42.42.42.2);)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted), action=(next;)\n  table=6 (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 66.66.66.66), action=(reg1 = 66.66.66.66; ct_lb;)\n  table=6 (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb;)\n  table=12(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 66.66.66.66), action=(reg0[[1]] = 0; ct_lb(backends=42.42.42.2);)\n  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb;)\n])\n\nAS_BOX([Chassis upgrades and supports ct_lb_mark - use ct_lb_mark and ct_mark.natted])\ncheck ovn-sbctl set chassis hv other_config:ct-no-masked-label=true\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep -e natted -e ct_lb], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(ct_lb_mark(backends=42.42.42.2);)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=6 (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 66.66.66.66), action=(reg1 = 66.66.66.66; ct_lb_mark;)\n  table=6 (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n  table=12(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 66.66.66.66), action=(reg0[[1]] = 0; ct_lb_mark(backends=42.42.42.2);)\n  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([ACL ct_mark.blocked backwards compatibility])\nAT_KEYWORDS([acl])\novn_start\n\ncheck ovn-nbctl                                               \\\n  -- ls-add ls                                                \\\n  -- acl-add ls from-lport 1 1 allow-related                  \\\n  -- --apply-after-lb acl-add ls from-lport 1 1 allow-related \\\n  -- acl-add ls to-lport 1 1 allow-related\n\nAS_BOX([No chassis registered - use ct_mark.blocked])\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep 'ls.*acl.*blocked' ], [0], [dnl\n  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n])\n\nAS_BOX([Chassis registered that doesn't support ct_mark.blocked - use ct_label.blocked])\ncheck ovn-sbctl chassis-add hv geneve 127.0.0.1\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep 'ls.*acl.*blocked' ], [0], [dnl\n  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_label.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_label.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(drop;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_label.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_label.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_label.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(drop;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_label.blocked == 1), action=(reg0[[1]] = 1; next;)\n])\n\nAS_BOX([Chassis upgrades and supports ct_mark.blocked - use ct_mark.blocked])\ncheck ovn-sbctl set chassis hv other_config:ct-no-masked-label=true\ncheck ovn-nbctl --wait=sb sync\nAT_CHECK([ovn-sbctl lflow-list | grep 'ls.*acl.*blocked' ], [0], [dnl\n  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=8 (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=8 (ls_in_acl          ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)\n  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=4 (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=4 (ls_out_acl         ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Localnet MAC learning option])\novn_start\n\nAT_CHECK([ovn-nbctl ls-add ls0])\n\nAT_CHECK([ovn-nbctl lsp-add ls0 ln_port])\nAT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])\nAT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])\nAT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=phys])\nAT_CHECK([ovn-nbctl --wait=sb sync])\n\n# Check MAC learning flows with 'localnet_learn_fdb' default (false)\nAT_CHECK([ovn-sbctl dump-flows ls0 | grep -e 'ls_in_\\(put\\|lookup\\)_fdb' | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_lookup_fdb   ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_put_fdb      ), priority=0    , match=(1), action=(next;)\n])\n\n# Enable 'localnet_learn_fdb' and check the flows\nAT_CHECK([ovn-nbctl --wait=sb lsp-set-options ln_port localnet_learn_fdb=true])\nAT_CHECK([ovn-sbctl dump-flows ls0 | grep -e 'ls_in_\\(put\\|lookup\\)_fdb' | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_lookup_fdb   ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_lookup_fdb   ), priority=100  , match=(inport == \"ln_port\"), action=(reg0[[11]] = lookup_fdb(inport, eth.src); next;)\n  table=? (ls_in_put_fdb      ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_put_fdb      ), priority=100  , match=(inport == \"ln_port\" && reg0[[11]] == 0), action=(put_fdb(inport, eth.src); next;)\n])\n\n# Disable 'localnet_learn_fdb' and check the flows\nAT_CHECK([ovn-nbctl --wait=sb lsp-set-options ln_port localnet_learn_fdb=false])\nAT_CHECK([ovn-sbctl dump-flows ls0 | grep -e 'ls_in_\\(put\\|lookup\\)_fdb' | sort | sed 's/table=./table=?/'], [0], [dnl\n  table=? (ls_in_lookup_fdb   ), priority=0    , match=(1), action=(next;)\n  table=? (ls_in_put_fdb      ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check install_ls_lb_from_router option])\nAT_KEYWORDS([lb-ls-install-from-lrouter])\novn_start\n\novn-nbctl lr-add R1\novn-nbctl set logical_router R1 options:chassis=hv1\novn-nbctl lrp-add R1 R1-S0 02:ac:10:01:00:01 10.0.0.1/24\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:01:01 20.0.0.1/24\novn-nbctl lrp-add R1 R1-PUB 02:ac:20:01:01:01 172.16.0.1/24\n\novn-nbctl ls-add S0\novn-nbctl lsp-add S0 S0-R1\novn-nbctl lsp-set-type S0-R1 router\novn-nbctl lsp-set-addresses S0-R1 02:ac:10:01:00:01\novn-nbctl lsp-set-options S0-R1 router-port=R1-S0\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:01:01\novn-nbctl lsp-set-options S1-R1 router-port=R1-S1\n\n# Add load balancers on the logical router R1\novn-nbctl lb-add lb0 172.16.0.10:80 10.0.0.2:80\novn-nbctl lr-lb-add R1 lb0\n\novn-nbctl lb-add lb1 172.16.0.11:8080 10.0.0.2:8080\nlb1_uuid=$(fetch_column nb:load_balancer _uuid name=lb1)\nlbg=$(ovn-nbctl create load_balancer_group name=lbg -- \\\n    add load_balancer_group lbg load_balancer $lb1_uuid)\novn-nbctl add logical_router R1 load_balancer_group $lbg\novn-nbctl --wait=sb sync\n\novn-sbctl dump-flows S0 > S0flows\novn-sbctl dump-flows S1 > S1flows\n\nAT_CAPTURE_FILE([S0flows])\nAT_CAPTURE_FILE([S1flows])\n\nAT_CHECK([grep \"ls_in_lb \" S0flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n])\nAT_CHECK([grep \"ls_in_lb \" S1flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n])\n\novn-nbctl --wait=sb set NB_Global . options:install_ls_lb_from_router=true\n\novn-sbctl dump-flows S0 > S0flows\novn-sbctl dump-flows S1 > S1flows\n\nAT_CAPTURE_FILE([S0flows])\nAT_CAPTURE_FILE([S1flows])\n\nAT_CHECK([grep \"ls_in_lb \" S0flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=12(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:80);)\n  table=12(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.11 && tcp.dst == 8080), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:8080);)\n])\nAT_CHECK([grep \"ls_in_lb \" S1flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=12(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:80);)\n  table=12(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.11 && tcp.dst == 8080), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:8080);)\n])\n\novn-sbctl get datapath S0 _uuid > dp_uuids\novn-sbctl get datapath S1 _uuid >> dp_uuids\nlb_dp_group=$(ovn-sbctl --bare --columns datapath_group find Load_Balancer name=lb0)\nAT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl\n                    | grep -A1 $lb_dp_group | tail -1 | tr ' ' '\\n' | sort], [0], [dnl\n$(cat dp_uuids | sort)\n])\n\novn-nbctl --wait=sb set NB_Global . options:install_ls_lb_from_router=false\n\novn-sbctl dump-flows S0 > S0flows\novn-sbctl dump-flows S1 > S1flows\n\nAT_CAPTURE_FILE([S0flows])\nAT_CAPTURE_FILE([S1flows])\n\nAT_CHECK([grep \"ls_in_lb \" S0flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n])\nAT_CHECK([grep \"ls_in_lb \" S1flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n])\n\ncheck_column \"\" sb:load_balancer datapaths name=lb0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check fip flows with redirect-type bridged])\nAT_KEYWORDS([fip-redirect-type-bridged])\novn_start\n\novn-nbctl lr-add R1\novn-nbctl lrp-add R1 R1-S0 02:ac:10:01:00:01 10.0.0.1/24 1000::a/64\novn-nbctl lrp-add R1 R1-PUB 02:ac:20:01:01:01 172.16.0.1/24 3000::a/64\novn-nbctl lrp-set-gateway-chassis R1-PUB hv1 20\n\novn-nbctl ls-add S0\novn-nbctl lsp-add S0 S0-R1\novn-nbctl lsp-set-type S0-R1 router\novn-nbctl lsp-set-addresses S0-R1 02:ac:10:01:00:01\novn-nbctl lsp-set-options S0-R1 router-port=R1-S0\novn-nbctl lsp-add S0 S0-P0\novn-nbctl lsp-set-addresses S0-P0 \"50:54:00:00:00:03 10.0.0.3 1000::3\"\n\novn-nbctl lr-nat-add R1 dnat_and_snat 172.16.0.110 10.0.0.3 S0-P0 30:54:00:00:00:03\novn-nbctl lr-nat-add R1 dnat_and_snat 3000::c 1000::3 S0-P0 40:54:00:00:00:03\n\novn-sbctl dump-flows R1 > R1flows\nAT_CAPTURE_FILE([R1flows])\nAT_CHECK([grep \"lr_in_arp_resolve\" R1flows | grep priority=90 | sort], [0], [dnl\n])\n\novn-nbctl --wait=sb set logical_router_port R1-PUB options:redirect-type=bridged\novn-sbctl dump-flows R1 > R1flows\nAT_CAPTURE_FILE([R1flows])\n\nAT_CHECK([grep \"lr_in_arp_resolve\" R1flows | grep priority=90 | sort], [0], [dnl\n  table=17(lr_in_arp_resolve  ), priority=90   , match=(outport == \"R1-PUB\" && ip4.src == 10.0.0.3 && is_chassis_resident(\"S0-P0\")), action=(get_arp(outport, reg0); next;)\n  table=17(lr_in_arp_resolve  ), priority=90   , match=(outport == \"R1-PUB\" && ip6.src == 1000::3 && is_chassis_resident(\"S0-P0\")), action=(get_nd(outport, xxreg0); next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([check lb-affinity flows])\nAT_KEYWORDS([lb-affinity-flows])\novn_start\n\novn-nbctl lr-add R1\novn-nbctl set logical_router R1 options:chassis=hv1\novn-nbctl lrp-add R1 R1-S0 02:ac:10:01:00:01 10.0.0.1/24\novn-nbctl lrp-add R1 R1-S1 02:ac:10:01:01:01 20.0.0.1/24\novn-nbctl lrp-add R1 R1-PUB 02:ac:20:01:01:01 172.16.0.1/24\n\novn-nbctl ls-add S0\novn-nbctl lsp-add S0 S0-R1\novn-nbctl lsp-set-type S0-R1 router\novn-nbctl lsp-set-addresses S0-R1 02:ac:10:01:00:01\novn-nbctl lsp-set-options S0-R1 router-port=R1-S0\n\novn-nbctl ls-add S1\novn-nbctl lsp-add S1 S1-R1\novn-nbctl lsp-set-type S1-R1 router\novn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:01:01\novn-nbctl lsp-set-options S1-R1 router-port=R1-S1\n\n# Add load balancers on the logical router R1\novn-nbctl lb-add lb0 172.16.0.10:80 10.0.0.2:80,20.0.0.2:80 tcp\novn-nbctl lr-lb-add R1 lb0\novn-nbctl ls-lb-add S0 lb0\novn-nbctl --wait=sb sync\n\novn-sbctl dump-flows S0 > S0flows\novn-sbctl dump-flows R1 > R1flows\n\nAT_CAPTURE_FILE([S0flows])\nAT_CAPTURE_FILE([R1flows])\n\nAT_CHECK([grep \"ls_in_lb_aff_check\" S0flows | sort], [0], [dnl\n  table=11(ls_in_lb_aff_check ), priority=0    , match=(1), action=(next;)\n])\nAT_CHECK([grep \"ls_in_lb_aff_learn\" S0flows | sort], [0], [dnl\n  table=13(ls_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CHECK([grep \"lr_in_lb_aff_check\" R1flows | sort], [0], [dnl\n  table=6 (lr_in_lb_aff_check ), priority=0    , match=(1), action=(next;)\n])\nAT_CHECK([grep \"lr_in_lb_aff_learn\" R1flows | sort], [0], [dnl\n  table=8 (lr_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)\n])\n\novn-nbctl --wait=sb set load_balancer lb0 options:affinity_timeout=60\n\nAS_BOX([Test LS flows])\novn-sbctl dump-flows S0 > S0flows\nAT_CAPTURE_FILE([S0flows])\n\nAT_CHECK([grep \"ls_in_lb_aff_check\" S0flows | sort], [0], [dnl\n  table=11(ls_in_lb_aff_check ), priority=0    , match=(1), action=(next;)\n  table=11(ls_in_lb_aff_check ), priority=100  , match=(ct.new && ip4 && reg1 == 172.16.0.10 && reg2[[0..15]] == 80), action=(reg9[[6]] = chk_lb_aff(); next;)\n])\nAT_CHECK([grep \"ls_in_lb \" S0flows | sort], [0], [dnl\n  table=12(ls_in_lb           ), priority=0    , match=(1), action=(next;)\n  table=12(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80);)\n  table=12(ls_in_lb           ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0[[1]] = 0; reg1 = 172.16.0.10; reg2[[0..15]] = 80; ct_lb_mark(backends=10.0.0.2:80);)\n  table=12(ls_in_lb           ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0[[1]] = 0; reg1 = 172.16.0.10; reg2[[0..15]] = 80; ct_lb_mark(backends=20.0.0.2:80);)\n])\nAT_CHECK([grep \"ls_in_lb_aff_learn\" S0flows | sort], [0], [dnl\n  table=13(ls_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)\n  table=13(ls_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg1 == 172.16.0.10 && reg2[[0..15]] == 80 && ip4.dst == 10.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = \"172.16.0.10:80\", backend = \"10.0.0.2:80\", proto = tcp, timeout = 60); /* drop */)\n  table=13(ls_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg1 == 172.16.0.10 && reg2[[0..15]] == 80 && ip4.dst == 20.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = \"172.16.0.10:80\", backend = \"20.0.0.2:80\", proto = tcp, timeout = 60); /* drop */)\n])\n\nAS_BOX([Test LR flows])\novn-sbctl dump-flows R1 > R1flows\nAT_CAPTURE_FILE([R1flows])\n\nAT_CHECK([grep \"lr_in_lb_aff_check\" R1flows | sort], [0], [dnl\n  table=6 (lr_in_lb_aff_check ), priority=0    , match=(1), action=(next;)\n  table=6 (lr_in_lb_aff_check ), priority=100  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(reg0 = ip4.dst; reg9[[16..31]] = tcp.dst; reg9[[6]] = chk_lb_aff(); next;)\n])\nAT_CHECK([grep \"lr_in_dnat \" R1flows | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; ct_lb_mark(backends=10.0.0.2:80);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; ct_lb_mark(backends=20.0.0.2:80);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\nAT_CHECK([grep \"lr_in_lb_aff_learn\" R1flows | sort], [0], [dnl\n  table=8 (lr_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)\n  table=8 (lr_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg0 == 172.16.0.10 && reg9[[16..31]] == 80 && ip4.dst == 10.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = \"172.16.0.10:80\", backend = \"10.0.0.2:80\", proto = tcp, timeout = 60); /* drop */)\n  table=8 (lr_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg0 == 172.16.0.10 && reg9[[16..31]] == 80 && ip4.dst == 20.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = \"172.16.0.10:80\", backend = \"20.0.0.2:80\", proto = tcp, timeout = 60); /* drop */)\n])\n\nAS_BOX([Test LR flows - skip_snat=true])\ncheck ovn-nbctl --wait=sb set load_balancer lb0 options:skip_snat=true\n\novn-sbctl dump-flows R1 > R1flows_skip_snat\nAT_CAPTURE_FILE([R1flows_skip_snat])\n\nAT_CHECK([grep \"lr_in_dnat \" R1flows_skip_snat | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80; skip_snat);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80; skip_snat);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.skip_snat_for_lb = 1; ct_lb_mark(backends=20.0.0.2:80; skip_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\ncheck ovn-nbctl remove load_balancer lb0 options skip_snat\n\nAS_BOX([Test LR flows - lb_force_snat_ip=\"172.16.0.1\"])\ncheck ovn-nbctl --wait=sb set logical_router R1 options:lb_force_snat_ip=\"172.16.0.1\"\n\novn-sbctl dump-flows R1 > R1flows_force_snat\nAT_CAPTURE_FILE([R1flows_force_snat])\n\nAT_CHECK([grep \"lr_in_dnat \" R1flows_force_snat | sort], [0], [dnl\n  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80; force_snat);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80; force_snat);)\n  table=7 (lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.force_snat_for_lb = 1; ct_lb_mark(backends=20.0.0.2:80; force_snat);)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Address set incremental processing])\novn_start\n\n# Create a few resources.\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \"02:ac:10:01:00:04 20.0.0.4\"\ncheck ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 \"02:ac:10:01:00:05 20.0.0.5\"\n\nfetch_column NB:Logical_Switch_Port _uuid name=sw0-p1\n\novn-nbctl list logical_switch_port name=sw0-p1\n\np1_uuid=$(fetch_column nb:Logical_Switch_Port _uuid name=sw0-p1)\np2_uuid=$(fetch_column nb:Logical_Switch_Port _uuid name=sw0-p2)\n\necho \"p1 uuid - $p1_uuid\"\novn-nbctl --wait=sb sync\n\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\nfoo_as_uuid=$(ovn-nbctl create address_set name=foo addresses=\\\"1.1.1.1\\\",\\\"1.1.1.2\\\")\nwait_column '1.1.1.1 1.1.1.2' Address_Set addresses name=foo\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [1\n])\n\nrm -f northd/ovn-northd.log\ncheck as northd ovn-appctl -t NORTHD_TYPE vlog/reopen\ncheck as northd ovn-appctl -t NORTHD_TYPE vlog/set jsonrpc:dbg\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\ncheck ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.3 -- \\\n                add address_set $foo_as_uuid addresses 1.1.2.1/4\nwait_column '1.1.1.1 1.1.1.2 1.1.1.3 1.1.2.1/4' Address_Set addresses name=foo\n\n# There should be no recompute of the sync_to_sb_addr_set engine node .\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [0\n])\n\nAT_CHECK([grep transact northd/ovn-northd.log | grep Address_Set | \\\ngrep -c mutate], [0], [1\n])\n\ncheck ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.4 -- \\\n                remove address_set $foo_as_uuid addresses 1.1.1.1 -- \\\n                remove address_set $foo_as_uuid addresses 1.1.2.1/4\nwait_column '1.1.1.2 1.1.1.3 1.1.1.4' Address_Set addresses name=foo\n\n# There should be no recompute of the sync_to_sb_addr_set engine node .\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [0\n])\n\nAT_CHECK([grep transact northd/ovn-northd.log | grep Address_Set | \\\ngrep -c mutate], [0], [2\n])\n\n# Pause ovn-northd and add/remove few addresses.  when it is resumed\n# it should use mutate for updating the address sets.\ncheck as northd ovn-appctl -t NORTHD_TYPE pause\ncheck as northd-backup ovn-appctl -t NORTHD_TYPE pause\n\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\ncheck ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.5\ncheck ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.6\ncheck ovn-nbctl remove address_set $foo_as_uuid addresses 1.1.1.2\n\ncheck_column '1.1.1.2 1.1.1.3 1.1.1.4' Address_Set addresses name=foo\n\n# Resume northd now\ncheck as northd ovn-appctl -t NORTHD_TYPE resume\nwait_column '1.1.1.3 1.1.1.4 1.1.1.5 1.1.1.6' Address_Set addresses name=foo\n# There should be recompute of the sync_to_sb_addr_set engine node .\nrecompute_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute)\nAT_CHECK([test $recompute_stat -ge 1])\n\nAT_CHECK([grep transact northd/ovn-northd.log | grep Address_Set | \\\ngrep -c mutate], [0], [3\n])\n\n# Create a port group. This should result in recompute of sb_to_sync_addr_set engine node.\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\ncheck ovn-nbctl pg-add pg1\nwait_column '' Address_Set addresses name=pg1_ip4\nrecompute_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute)\nAT_CHECK([test $recompute_stat -ge 1])\n\n# Add sw0-p1 to port group pg1\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\ncheck ovn-nbctl add port_group pg1 ports ${p1_uuid}\nwait_column '20.0.0.4' Address_Set addresses name=pg1_ip4\n\n# There should be recompute of the sync_to_sb_addr_set engine node since northd engine changes.\n# There will be another recompute when the update message is received from the sb ovsdb-server.\n# Once we add I-P for Port_Groups, there should be no recompute here.\nrecompute_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute)\nAT_CHECK([test $recompute_stat -ge 1])\n\n# Any change to northd engine node should result in full recompute of sync_to_sb_addr_set node.\ncheck as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats\ncheck ovn-nbctl --wait=sb sync\nrecompute_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute)\nAT_CHECK([test $recompute_stat -ge 1])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Check default drop])\nAT_KEYWORDS([drop])\n\novn_start\n\n# Check that there is an explicit drop lflow in for spoecified DP and table.\ncheck_default_lflow() {\n    dp=$1\n    pipeline=$2\n\n    table_len=$(ovn-sbctl --bare --columns table find logical_flow logical_datapath=$dp pipeline=$pipeline | sort | uniq | wc -l)\n    table_len_default=$(ovn-sbctl --bare --columns table find logical_flow logical_datapath=$dp pipeline=$pipeline match=1 | sort | uniq | wc -l)\n\n    echo \"Checking if datapath $dp pipeline $pipeline has default actions\"\n    AT_CHECK([test $table_len -eq $table_len_default], [0], [ignore], [ignore], [echo \"Datapath $dp pipeline $pipeline is missing some default action\"])\n}\n\n# Create LS + LR\ncheck ovn-nbctl --wait=sb \\\n                -- lr-add R1 \\\n                -- lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24 \\\n                -- ls-add S1 \\\n                -- lsp-add S1 S1-R1 \\\n                -- lsp-set-type S1-R1 router \\\n                -- lsp-set-addresses S1-R1 02:ac:10:01:00:01 \\\n                -- lsp-set-options S1-R1 router-port=R1-S1 \\\n                -- lsp-add S1 p1 \\\n                -- lsp-set-addresses p1 \"02:ac:10:01:00:0a 172.16.1.100\"\n\novn-sbctl dump-flows R1 > R1_flows\novn-sbctl dump-flows R1 | grep \"match=(1)\" > R1_default_flows\novn-sbctl dump-flows S1 > S1_flows\novn-sbctl dump-flows S1 | grep \"match=(1)\" > S1_default_flows\n\nAT_CAPTURE_FILE([R1_flows])\nAT_CAPTURE_FILE([R1_default_flows])\nAT_CAPTURE_FILE([S1_flows])\nAT_CAPTURE_FILE([S1_default_flows])\n\nlr_uuid=$(fetch_column datapath _uuid external_ids:name=R1)\nls_uuid=$(fetch_column datapath _uuid external_ids:name=S1)\n\ncheck_default_lflow $lr_uuid ingress\ncheck_default_lflow $lr_uuid egress\n\ncheck_default_lflow $ls_uuid ingress\ncheck_default_lflow $ls_uuid egress\n\n# Add stateless ACL\ncheck ovn-nbctl --wait=sb \\\n                -- acl-add S1 from-lport 100 'inport=p1 && ip4' allow-stateless\n\nAT_CHECK([ovn-sbctl dump-flows | grep \"ls_in_acl\" | grep \"match=(1)\"  | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb acl-del S1\n\n\n# Add stateful ACL\ncheck ovn-nbctl --wait=sb \\\n                -- acl-add S1 from-lport 2 \"udp\" allow-related\n\nAT_CHECK([ovn-sbctl dump-flows | grep \"ls_in_acl\" | grep \"match=(1)\"  | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb acl-del S1\n\n# Add LB\ncheck ovn-nbctl --wait=sb \\\n    -- lb-add lb \"10.0.0.1\" \"10.0.0.2\" \\\n    -- ls-lb-add S1 lb\n\nAT_CHECK([ovn-sbctl dump-flows | grep \"ls_in_acl\" | grep \"match=(1)\"  | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n])\n\n\n# Check LB + stateless ACL\ncheck ovn-nbctl --wait=sb \\\n                -- acl-add S1 from-lport 100 'inport=p1 && ip4' allow-stateless\n\nAT_CHECK([ovn-sbctl dump-flows | grep \"ls_in_acl\" | grep \"match=(1)\"  | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n])\n\ncheck ovn-nbctl --wait=sb acl-del S1\n\n# Check LB + statelful ACL\ncheck ovn-nbctl --wait=sb \\\n                -- acl-add S1 from-lport 2 \"udp\" allow-related\n\nAT_CHECK([ovn-sbctl dump-flows | grep \"ls_in_acl\" | grep \"match=(1)\"  | sed 's/table=../table=??/' | sort], [0], [dnl\n  table=??(ls_in_acl          ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_after_lb ), priority=0    , match=(1), action=(next;)\n  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([NB to SB Chassis_Template_Var propagation])\nAT_KEYWORDS([templates])\novn_start\n\nAT_CHECK([ovn-nbctl create Chassis_Template_Var chassis=\"hv1\"], [0], [ignore])\nAT_CHECK([ovn-nbctl create Chassis_Template_Var chassis=\"hv2\"], [0], [ignore])\n\ncheck ovn-nbctl set Chassis_Template_Var hv1 variables:tv=v1\ncheck ovn-nbctl set Chassis_Template_Var hv2 variables:tv=v2\n\nAS_BOX([Ensure values are propagated to SB])\ncheck ovn-nbctl --wait=sb sync\ncheck_column \"tv=v1\" sb:Chassis_Template_Var variables chassis=\"hv1\"\ncheck_column \"tv=v2\" sb:Chassis_Template_Var variables chassis=\"hv2\"\n\nAS_BOX([Ensure SB is reconciled])\ncheck ovn-sbctl --all destroy Chassis_Template_Var\ncheck ovn-nbctl --wait=sb sync\ncheck_column \"tv=v1\" sb:Chassis_Template_Var variables chassis=\"hv1\"\ncheck_column \"tv=v2\" sb:Chassis_Template_Var variables chassis=\"hv2\"\n\nAS_BOX([Ensure SB is reconciled - deletion])\ncheck ovn-nbctl destroy Chassis_Template_Var hv1\ncheck ovn-nbctl --wait=sb sync\ncheck_column \"tv=v2\" sb:Chassis_Template_Var variables chassis=\"hv2\"\n\nAS_BOX([Ensure SB is reconciled - cleanup])\ncheck ovn-nbctl destroy Chassis_Template_Var hv2\ncheck ovn-nbctl --wait=sb sync\ncheck_row_count sb:Chassis_Template_Var 0\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Load balancer CT related backwards compatibility])\nAT_KEYWORDS([lb])\novn_start\n\ncheck ovn-nbctl                                               \\\n  -- ls-add ls                                                \\\n  -- lr-add lr -- set logical_router lr options:chassis=local \\\n  -- lb-add lb-test 192.168.0.1 192.168.1.10                  \\\n  -- ls-lb-add ls lb-test                                     \\\n  -- lr-lb-add lr lb-test\n\nm4_define([DUMP_FLOWS_SORTED], [sed 's/table=[[0-9]]\\{1,2\\}/table=?/' | sort])\n\nAS_BOX([No chassis registered - CT related flows should be installed])\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > lflows0\n\nAT_CHECK([grep -e \"lr_in_defrag\" -e \"lr_in_dnat\" lflows0], [0], [dnl\n  table=? (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 192.168.0.1), action=(ct_dnat;)\n  table=? (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(ct_lb_mark(backends=192.168.1.10);)\n  table=? (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=? (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep -e \"ls_in_acl\" -e \"ls_out_acl\" lflows0 | grep \"priority=65532\"], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n])\n\n\nAS_BOX([Chassis registered that doesn't support CT related])\ncheck ovn-sbctl chassis-add hv geneve 127.0.0.1\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > lflows1\n\nAT_CHECK([grep -e \"lr_in_defrag\" -e \"lr_in_dnat\" lflows1], [0], [dnl\n  table=? (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 192.168.0.1), action=(ct_dnat;)\n  table=? (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(ct_lb(backends=192.168.1.10);)\n  table=? (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted), action=(next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n])\n\nAT_CHECK([grep -e \"ls_in_acl\" -e \"ls_out_acl\" lflows1 | grep \"priority=65532\"], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n])\n\nAS_BOX([Chassis upgrades and supports CT related])\ncheck ovn-sbctl set chassis hv other_config:ct-no-masked-label=true\ncheck ovn-sbctl set chassis hv other_config:ovn-ct-lb-related=true\ncheck ovn-nbctl --wait=sb sync\novn-sbctl dump-flows | DUMP_FLOWS_SORTED > lflows2\n\nAT_CHECK([grep -e \"lr_in_defrag\" -e \"lr_in_dnat\" lflows2], [0], [dnl\n  table=? (lr_in_defrag       ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 192.168.0.1), action=(ct_dnat;)\n  table=? (lr_in_dnat         ), priority=0    , match=(1), action=(next;)\n  table=? (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(ct_lb_mark(backends=192.168.1.10);)\n  table=? (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)\n  table=? (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)\n  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)\n])\n\nAT_CHECK([grep -e \"ls_in_acl\" -e \"ls_out_acl\" lflows2 | grep \"priority=65532\"], [0], [dnl\n  table=? (ls_in_acl          ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; ct_commit_nat;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; next;)\n  table=? (ls_in_acl          ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_in_acl          ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(ct_commit_nat;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(next;)\n  table=? (ls_out_acl         ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(drop;)\n  table=? (ls_out_acl         ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(next;)\n  table=?(ls_in_acl_after_lb ), priority=65532, match=(reg0[[17]] == 1), action=(next;)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD_NO_HV([\nAT_SETUP([Chassis-feature compatibitility - remote chassis])\novn_start\n\nAS_BOX([Local chassis])\ncheck ovn-sbctl chassis-add hv1 geneve 127.0.0.1 \\\n  -- set chassis hv1 other_config:ct-no-masked-label=true \\\n  -- set chassis hv1 other_config:ovn-ct-lb-related=true \\\n  -- set chassis hv1 other_config:mac-binding-timestamp=true\n\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE debug/chassis-features-list], [0], [dnl\nct_no_masked_label:    true\nct_lb_related:         true\nmac_binding_timestamp: true\n])\n\nAS_BOX([Remote chassis])\ncheck ovn-sbctl chassis-add hv2 geneve 127.0.0.2 \\\n  -- set chassis hv2 other_config:is-remote=true \\\n  -- set chassis hv2 other_config:ct-no-masked-label=false \\\n  -- set chassis hv2 other_config:ovn-ct-lb-related=false \\\n  -- set chassis hv2 other_config:mac-binding-timestamp=false\n\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([as northd ovn-appctl -t NORTHD_TYPE debug/chassis-features-list], [0], [dnl\nct_no_masked_label:    true\nct_lb_related:         true\nmac_binding_timestamp: true\n])\n\nAT_CLEANUP\n])\n\nAT_SETUP([Localnet ports on LS with LB])\novn_start\n# In the past, traffic arriving on localnet ports has skipped conntrack.\n# This test ensures that we still skip conntrack for localnet ports,\n# *except* for the case where the logical switch has a load balancer\n# configured. In this case, the localnet port will not skip conntrack,\n# allowing for traffic to be load balanced on the localnet port.\n\ncheck ovn-nbctl ls-add sw\ncheck ovn-nbctl lsp-add sw sw-ln\ncheck ovn-nbctl lsp-set-type sw-ln localnet\ncheck ovn-nbctl lsp-set-addresses sw-ln unknown\ncheck ovn-nbctl --wait=sb sync\n\n# Since this test is only concerned with logical flows, we don't need to\n# configure anything else that we normally would with regards to localnet\n# ports\n\n\n# First, ensure that conntrack is skipped for the localnet port since there\n# isn't a load balancer configured.\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_in_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_pre_lb       ), priority=110  , match=(ip && inport == \"sw-ln\"), action=(next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_out_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_out_pre_lb      ), priority=110  , match=(ip && outport == \"sw-ln\"), action=(ct_clear; next;)\n])\n\n# Now add a load balancer and ensure that we no longer are skipping conntrack\n# for the localnet port\n\ncheck ovn-nbctl lb-add lb 10.0.0.1:80 10.0.0.100:8080 tcp\ncheck ovn-nbctl ls-lb-add sw lb\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_in_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_out_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n])\n\n# And ensure that removing the load balancer from the switch results in skipping\n# conntrack again\ncheck ovn-nbctl ls-lb-del sw lb\ncheck ovn-nbctl --wait=sb sync\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_in_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_in_pre_lb       ), priority=110  , match=(ip && inport == \"sw-ln\"), action=(next;)\n])\n\nAT_CHECK([ovn-sbctl lflow-list sw | grep ls_out_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl\n  table=??(ls_out_pre_lb      ), priority=110  , match=(ip && outport == \"sw-ln\"), action=(ct_clear; next;)\n])\n\nAT_CLEANUP\n])\n", "AT_BANNER([system-ovn])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([2 LRs connected via LS, gateway router, SNAT and DNAT])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switches foo (192.168.1.0/24) and\n# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected\n# to it.  R2 is a gateway router on which we add NAT rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.2 -- add logical_router R2 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.2.2 \\\n    external_ip=30.0.0.1 -- add logical_router R2 nat @nat\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.1)'])\n\n# 'alice1' should be able to ping 'foo1' directly.\nNS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 192.168.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# North-South DNAT: 'alice1' should also be able to ping 'foo1' via 30.0.0.2\nNS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=172.16.1.2,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic\n# from 30.0.0.1\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# Add static routes to handle east-west NAT.\novn-nbctl lr-route-add R1 30.0.0.0/24 20.0.0.2\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# East-west DNAT and SNAT: 'bar1' pings 30.0.0.2. 'foo1' receives it.\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# As we have a static route that sends all packets with destination\n# 30.0.0.2 to R2, it hits the DNAT rule and converts 30.0.0.2 to 192.168.1.2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# As we have a SNAT rule that converts 192.168.2.2 to 30.0.0.1, the source is\n# SNATted and 'foo1' receives it.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([2 LRs connected via LS, gateway router, SNAT and DNAT - IPv6])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in fd00::/64 network. R1 has switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it. R2 has alice (fd21::/64) connected\n# to it.  R2 is a gateway router on which we add NAT rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd21::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd00::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd00::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 fd21::/64 fd00::2\novn-nbctl lr-route-add R2 fd11::/64 fd00::1\novn-nbctl lr-route-add R2 fd12::/64 fd00::1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd21::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd21::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd21::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd21::2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n         \"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=\\\"fd11::2\\\" \\\n    external_ip=\\\"fd30::2\\\" -- add logical_router R2 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=\\\"fd12::2\\\" \\\n    external_ip=\\\"fd30::1\\\" -- add logical_router R2 nat @nat\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd30::1)'])\n\n# 'alice1' should be able to ping 'foo1' directly.\nNS_CHECK_EXEC([alice1], [ping6 -v -q -c 3 -i 0.3 -w 2 fd11::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# North-South DNAT: 'alice1' should also be able to ping 'foo1' via fd30::2\nNS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd21::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd21::2,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd21::2,id=<cleared>,type=129,code=0),zone=<cleared>\nicmpv6,orig=(src=fd21::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd21::2,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic\n# from fd30::1\nNS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd21::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd21::2,id=<cleared>,type=128,code=0),reply=(src=fd21::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# Add static routes to handle east-west NAT.\novn-nbctl lr-route-add R1 fd30::/64 fd00::2\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# East-west DNAT and SNAT: 'bar1' pings fd30::2. 'foo1' receives it.\nNS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# As we have a static route that sends all packets with destination\n# fd30::2 to R2, it hits the DNAT rule and converts fd30::2 to fd11::2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd12::2,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# As we have a SNAT rule that converts fd12::2 to fd30::1, the source is\n# SNATted and 'foo1' receives it.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([2 LRs connected via LS, gateway router, easy SNAT])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) connected\n# to it.  R2 has alice (172.16.1.0/24) connected to it.\n# R2 is a gateway router on which we add NAT rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n\novn-nbctl lr-add R1\novn-nbctl lr-add R2 -- set Logical_Router R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect alice to R2\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.2\"\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.1.2 \\\n    external_ip=172.16.1.1 -- add logical_router R2 nat @nat\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])\n\n# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic\n# from 172.16.1.1\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([2 LRs connected via LS, gateway router, easy SNAT - IPv6])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in fd20::/64 network. R1 has switchess foo (fd10::/64) connected\n# to it.  R2 has alice (fd30::/64) connected to it.\n# R2 is a gateway router on which we add NAT rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n\novn-nbctl lr-add R1\novn-nbctl lr-add R2 -- set Logical_Router R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd10::1/64\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd30::1/64\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect alice to R2\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 fd30::/64 fd20::2\novn-nbctl lr-route-add R2 fd10::/64 fd20::1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd10::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd10::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo1 ip a | grep fd10::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd10::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd30::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd30::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd30::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd30::2\"\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=\\\"fd10::2\\\" \\\n    external_ip=\\\"fd30::1\\\" -- add logical_router R2 nat @nat\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd30::1)'])\n\n# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic\n# from fd30::1\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd10::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd30::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, SNAT and DNAT])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and\n# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected\n# to it.  R3 has bob (172.16.1.0/24) connected to it. Note how both alice and\n# bob have the same subnet behind it.  We are trying to simulate external\n# network via those 2 switches. In real world the switch ports of these\n# switches will have addresses set as \"unknown\" to make them learning switches.\n# Or those switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.1.0/24 20.0.0.2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.2.0/24 20.0.0.3\n\n# Static routes.\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\novn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:dnat_force_snat_ip=20.0.0.2\novn-nbctl set logical_router R3 options:dnat_force_snat_ip=20.0.0.3\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.3/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"172.16.1.4/24\", \"f0:00:00:01:02:06\", \\\n         \"172.16.1.2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 172.16.1.4\"\n\n# Router R2\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.2 -- add logical_router R2 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.1 -- add logical_router R2 nat @nat\n\n# Router R3\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.3 -- add logical_router R3 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.2.2 \\\n    external_ip=30.0.0.4 -- add logical_router R3 nat @nat\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.4)'])\n\n# North-South DNAT: 'alice1' should be able to ping 'foo1' via 30.0.0.2\nNS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.3,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from 20.0.0.2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.3,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# North-South DNAT: 'bob1' should be able to ping 'foo1' via 30.0.0.3\nNS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.4,dst=30.0.0.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from 20.0.0.3\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.4,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic\n# from 30.0.0.4\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=30.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic\n# from 30.0.0.1\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=172.16.1.3,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, SNAT and DNAT - IPv6])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in fd20::/64 network. R1 has switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it. R2 has alice (fd30::/64) connected\n# to it.  R3 has bob (fd30::/64) connected to it. Note how both alice and\n# bob have the same subnet behind it.  We are trying to simulate external\n# network via those 2 switches. In real world the switch ports of these\n# switches will have addresses set as \"unknown\" to make them learning switches.\n# Or those switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd30::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 fd30::2/64\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 fd20::3/64\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd11::/64 fd20::2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd12::/64 fd20::3\n\n# Static routes.\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\novn-nbctl lr-route-add R3 fd11::/64 fd20::1\novn-nbctl lr-route-add R3 fd12::/64 fd20::1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:dnat_force_snat_ip=fd20::2\novn-nbctl set logical_router R3 options:dnat_force_snat_ip=fd20::3\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd30::3/64\", \"f0:00:00:01:02:04\", \\\n         \"fd30::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd30::3 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd30::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n         \"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"fd30::4/64\", \"f0:00:00:01:02:06\", \\\n         \"fd30::2\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bob1 ip a | grep fd30::4 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 fd30::4\"\n\n# External IPs -- 30.0.0.N --> fd40::N (from IPv4 version of test case)\n\n# Router R2\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::2\"' -- add logical_router R2 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::1\"' -- add logical_router R2 nat @nat\n\n# Router R3\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::3\"' -- add logical_router R3 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip='\"fd12::2\"' \\\n    external_ip='\"fd40::4\"' -- add logical_router R3 nat @nat\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd40::4)'])\n\n# North-South DNAT: 'alice1' should be able to ping 'foo1' via fd30::2\nNS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd40::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::3,dst=fd40::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::3,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from fd20::2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::3,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# North-South DNAT: 'bob1' should be able to ping 'foo1' via fd40::3\nNS_CHECK_EXEC([bob1], [ping6 -q -c 3 -i 0.3 -w 2 fd40::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::4,dst=fd40::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::4,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from fd20::3\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::4,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic\n# from fd40::4\nNS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd30::4,id=<cleared>,type=128,code=0),reply=(src=fd30::4,dst=fd40::4,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic\n# from fd40::1\nNS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd11::2,dst=fd30::3,id=<cleared>,type=128,code=0),reply=(src=fd30::3,dst=fd40::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, SNAT and DNAT - Dual Stack])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 and fd20::/64 networks. R1 has switches foo (192.168.1.0/24\n# and fd11::/64) and bar (192.168.2.0/24 and fd12::/64) connected to it. R2\n# has alice (172.16.1.0/24 and fd30::/64) connected to it.  R3 has bob\n# (172.16.1.0/24 andfd30::/64) connected to it. Note how both alice and bob\n# have the same subnets behind them.  We are trying to simulate external network\n# via those 2 switches. In real world the switch ports of these switches will\n# have addresses set as \"unknown\" to make them learning switches. Or those\n# switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24 fd30::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24 fd30::2/64\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24 fd20::3/64\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd11::/64 fd20::2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd12::/64 fd20::3\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.1.0/24 20.0.0.2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.2.0/24 20.0.0.3\n\n# Static routes.\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\novn-nbctl lr-route-add R3 fd11::/64 fd20::1\novn-nbctl lr-route-add R3 fd12::/64 fd20::1\novn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:dnat_force_snat_ip=\"20.0.0.2 fd20::2\"\novn-nbctl set logical_router R3 options:dnat_force_snat_ip=\"20.0.0.3 fd20::3\"\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\nADD_NAMESPACES(foo16)\nADD_VETH(foo16, foo16, br-int, \"fd11::2/64\", \"f0:00:00:02:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo16 ip a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo16 \\\n-- lsp-set-addresses foo16 \"f0:00:00:02:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.3/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.3\"\n\nADD_NAMESPACES(alice16)\nADD_VETH(alice16, alice16, br-int, \"fd30::3/64\", \"f0:00:00:02:02:04\", \\\n         \"fd30::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice16 ip a | grep fd30::3 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice16 \\\n-- lsp-set-addresses alice16 \"f0:00:00:02:02:04 fd30::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\nADD_NAMESPACES(bar16)\nADD_VETH(bar16, bar16, br-int, \"fd12::2/64\", \"f0:00:00:02:02:05\", \\\n         \"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bar16 ip a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar16 \\\n-- lsp-set-addresses bar16 \"f0:00:00:02:02:05 fd12::2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"172.16.1.4/24\", \"f0:00:00:01:02:06\", \\\n         \"172.16.1.2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 172.16.1.4\"\n\nADD_NAMESPACES(bob16)\nADD_VETH(bob16, bob16, br-int, \"fd30::4/64\", \"f0:00:00:02:02:06\", \\\n         \"fd30::2\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bob16 ip a | grep fd30::4 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bob bob16 \\\n-- lsp-set-addresses bob16 \"f0:00:00:02:02:06 fd30::4\"\n\n# Router R2\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.2 -- add logical_router R2 nat @nat\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::2\"' -- add logical_router R2 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.1 -- add logical_router R2 nat @nat\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::1\"' -- add logical_router R2 nat @nat\n\n# Router R3\n# Add a DNAT rule.\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip=192.168.1.2 \\\n    external_ip=30.0.0.3 -- add logical_router R3 nat @nat\novn-nbctl -- --id=@nat create nat type=\"dnat\" logical_ip='\"fd11::2\"' \\\n    external_ip='\"fd40::3\"' -- add logical_router R3 nat @nat\n\n# Add a SNAT rule\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.2.2 \\\n    external_ip=30.0.0.4 -- add logical_router R3 nat @nat\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip='\"fd12::2\"' \\\n    external_ip='\"fd40::4\"' -- add logical_router R3 nat @nat\n\n# wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd40::4)'])\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.4)'])\n\n# North-South DNAT: 'alice1' should be able to ping 'foo1' via 30.0.0.2\nNS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# North-South DNAT: 'alice16' should be able to ping 'foo16' via fd30::2\nNS_CHECK_EXEC([alice16], [ping6 -q -c 3 -i 0.3 -w 2 fd40::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.3,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::3,dst=fd40::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::3,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from 20.0.0.2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.3,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n# But foo16 should receive traffic from fd20::2\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::3,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# North-South DNAT: 'bob1' should be able to ping 'foo1' via 30.0.0.3\nNS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# North-South DNAT: 'bob16' should be able to ping 'foo16' via fd40::3\nNS_CHECK_EXEC([bob16], [ping6 -q -c 3 -i 0.3 -w 2 fd40::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.4,dst=30.0.0.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::4,dst=fd40::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::4,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# But foo1 should receive traffic from 20.0.0.3\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.4,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# But foo16 should receive traffic from fd20::3\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd30::4,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic\n# from 30.0.0.4\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n# South-North SNAT: 'bar16' pings 'bob16'. But 'bob16' receives traffic\n# from fd40::4\nNS_CHECK_EXEC([bar16], [ping6 -q -c 3 -i 0.3 -w 2 fd30::4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=30.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd30::4,id=<cleared>,type=128,code=0),reply=(src=fd30::4,dst=fd40::4,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic\n# from 30.0.0.1\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# South-North SNAT: 'foo16' pings 'alice16'. But 'alice16' receives traffic\n# from fd40::1\nNS_CHECK_EXEC([foo16], [ping6 -q -c 3 -i 0.3 -w 2 fd30::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=172.16.1.3,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd11::2,dst=fd30::3,id=<cleared>,type=128,code=0),reply=(src=fd30::3,dst=fd40::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancing])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 2 logical switches \"foo\" (192.168.1.0/24) and \"bar\" (172.16.1.0/24)\n# connected to a router R1.\n# foo has foo1 to act as a client.\n# bar has bar1, bar2, bar3 to act as servers.\n#\n# Loadbalancer VIPs in 30.0.0.0/24 network.\n\novn-nbctl create Logical_Router name=R1\novn-nbctl ls-add foo\novn-nbctl ls-add bar\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 172.16.1.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Create logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"172.16.1.2/24\", \"f0:00:0f:01:02:03\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:0f:01:02:03 172.16.1.2\"\n\nADD_NAMESPACES(bar2)\nADD_VETH(bar2, bar2, br-int, \"172.16.1.3/24\", \"f0:00:0f:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add bar bar2 \\\n-- lsp-set-addresses bar2 \"f0:00:0f:01:02:04 172.16.1.3\"\n\nADD_NAMESPACES(bar3)\nADD_VETH(bar3, bar3, br-int, \"172.16.1.4/24\", \"f0:00:0f:01:02:05\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add bar bar3 \\\n-- lsp-set-addresses bar3 \"f0:00:0f:01:02:05 172.16.1.4\"\n\n# Config OVN load-balancer with a VIP.\novn-nbctl lb-add lb1 30.0.0.1 \"172.16.1.2,172.16.1.3,172.16.1.4\"\novn-nbctl ls-lb-add foo lb1\n\n# Create another load-balancer with another VIP.\nlb2_uuid=`ovn-nbctl create load_balancer name=lb2 vips:30.0.0.3=\"172.16.1.2,172.16.1.3,172.16.1.4\"`\novn-nbctl ls-lb-add foo lb2\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $lb2_uuid vips:'\"30.0.0.2:8000\"'='\"172.16.1.2:80,172.16.1.3:80,172.16.1.4:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=172.16.1.4:80)'])\n\n# Start webservers in 'bar1', 'bar2' and 'bar3'.\nOVS_START_L7([bar1], [http])\nOVS_START_L7([bar2], [http])\nOVS_START_L7([bar3], [http])\n\n# Add ACLs (after lb) to drop the traffic if destined to backend  ips.\ncheck ovn-nbctl --apply-after-lb acl-add foo from-lport 1002 \"ip4 && ip4.dst == {172.16.1.2,172.16.1.3,172.16.1.4} && ct.new\" drop\ncheck ovn-nbctl --wait=hv sync\n\nAT_CHECK([ip netns exec foo1 wget 30.0.0.1 -t 3 -T 1], [4], [ignore], [ignore])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# Clear the apply-after-lb option.  The traffic will be allowed.\ncheck ovn-nbctl clear acl . options\novn-nbctl --wait=hv sync\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\novn-nbctl acl-del foo from-lport 1002 \"ip4 && ip4.dst == {172.16.1.2,172.16.1.3,172.16.1.4} && ct.new\"\novn-nbctl --wait=hv sync\n\ndnl Should work with the virtual IP 30.0.0.1 address through NAT\ndnl Each server should have at least one connection.\ndnl With 20 requests, one server might not receive any connection\ndnl in 0.3% of cases, so run a few times.\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Should work with the virtual IP 30.0.0.3 address through NAT\ndnl Each server should have at least one connection.\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.3 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\ndnl Each server should have at least one connection.\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Configure selection_fields.\novn-nbctl set load_balancer $lb2_uuid selection_fields=\"ip_src,ip_dst,tp_src,tp_dst\"\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)\" -c) -eq 2\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\ndnl Test load-balancing that includes L4 ports in NAT.\ndnl Each server should have at least one connection.\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\necho \"foo\" > foo\nfor i in `seq 1 20`; do\n    echo Request $i\n    ip netns exec foo1 nc -p 30000 30.0.0.2 8000 < foo\ndone\n\ndnl Only one backend should be chosen.\nAT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 -c) -eq 1])\n\novn-nbctl set load_balancer $lb2_uuid selection_fields=\"ip_src\"\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields=ip_src\" -c) -eq 2\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\nfor i in `seq 1 20`; do\n    echo Request $i\n    ip netns exec foo1 nc 30.0.0.2 8000 < foo\ndone\n\ndnl Only one backend should be chosen as eth_src and ip_src is fixed.\nbar1_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.2 -c)\nbar2_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.3 -c)\nbar3_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.4 -c)\n\nAT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1 -c) -ne 0])\n\nif [[ \"$bar1_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar2_ct -eq 0])\n    AT_CHECK([test $bar3_ct -eq 0])\nelse\n    AT_CHECK([test $bar1_ct -eq 0])\nfi\n\nif [[ \"$bar2_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar1_ct -eq 0])\n    AT_CHECK([test $bar3_ct -eq 0])\nelse\n    AT_CHECK([test $bar2_ct -eq 0])\nfi\n\nif [[ \"$bar3_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar1_ct -eq 0])\n    AT_CHECK([test $bar2_ct -eq 0])\nelse\n    AT_CHECK([test $bar3_ct -eq 0])\nfi\n\n# Change the protocol of lb2 to udp and set tp_src and tp_dst.\novn-nbctl set load_balancer $lb2_uuid selection_fields=\"ip_src,ip_dst,tp_src,tp_dst\"\n\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)\" -c) -eq 2\n])\n\novn-nbctl set load_balancer $lb2_uuid protocol=udp\n\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(ip_src,ip_dst,udp_src,udp_dst)\" -c) -eq 2\n])\n\n# Change the protocol of lb2 to sctp.\novn-nbctl set load_balancer $lb2_uuid protocol=sctp\n\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(ip_src,ip_dst,sctp_src,sctp_dst)\" -c) -eq 2\n])\n\novn-nbctl --reject lb-add lb3 30.0.0.10:80 \"\"\novn-nbctl ls-lb-add foo lb3\n# Filter reset segments\nNS_CHECK_EXEC([foo1], [tcpdump -l -c 1 -neei foo1 ip[[33:1]]=0x14 > rst.pcap 2>tcpdump_err &])\nOVS_WAIT_UNTIL([grep \"listening\" tcpdump_err])\nNS_CHECK_EXEC([foo1], [wget -q 30.0.0.10],[4])\n\nOVS_WAIT_UNTIL([\n    n_reset=$(cat rst.pcap | wc -l)\n    test \"${n_reset}\" = \"1\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancing - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 2 logical switches \"foo\" (fd01::/64) and \"bar\" (fd02::/64)\n# connected to a router R1.\n# foo has foo1 to act as a client.\n# bar has bar1, bar2, bar3 to act as servers.\n#\n# Loadbalancer VIPs in fd03::/64 network.\n\novn-nbctl create Logical_Router name=R1\novn-nbctl ls-add foo\novn-nbctl ls-add bar\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd02::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Create logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd01::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd01::1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd01::2\"\n\n# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd02::2/64\", \"f0:00:0f:01:02:03\", \\\n         \"fd02::1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:0f:01:02:03 fd02::2\"\n\nADD_NAMESPACES(bar2)\nADD_VETH(bar2, bar2, br-int, \"fd02::3/64\", \"f0:00:0f:01:02:04\", \\\n         \"fd02::1\")\novn-nbctl lsp-add bar bar2 \\\n-- lsp-set-addresses bar2 \"f0:00:0f:01:02:04 fd02::3\"\n\nADD_NAMESPACES(bar3)\nADD_VETH(bar3, bar3, br-int, \"fd02::4/64\", \"f0:00:0f:01:02:05\", \\\n         \"fd02::1\")\novn-nbctl lsp-add bar bar3 \\\n-- lsp-set-addresses bar3 \"f0:00:0f:01:02:05 fd02::4\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:\\\"fd03::1\\\"=\\\"fd02::2,fd02::3,fd02::4\\\"`\novn-nbctl set logical_switch foo load_balancer=$uuid\n\n# Create another load-balancer with another VIP.\nlb2_uuid=`ovn-nbctl create load_balancer vips:\\\"fd03::3\\\"=\\\"fd02::2,fd02::3,fd02::4\\\"`\novn-nbctl add logical_switch foo load_balancer $lb2_uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $lb2_uuid vips:'\"[[fd03::2]]:8000\"'='\"@<:@fd02::2@:>@:80,@<:@fd02::3@:>@:80,@<:@fd02::4@:>@:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd02::4\\]]:80)'])\n\n# Start webservers in 'bar1', 'bar2' and 'bar3'.\nOVS_START_L7([bar1], [http6])\nOVS_START_L7([bar2], [http6])\nOVS_START_L7([bar3], [http6])\n\ndnl Should work with the virtual IP fd03::1 address through NAT\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log || (ovs-ofctl -O OpenFlow13 dump-flows br-int && false)])\ndone\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::1) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Should work with the virtual IP fd03::3 address through NAT\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::3]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::3) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_WAIT_FOR_OUTPUT([\ndnl Test load-balancing that includes L4 ports in NAT.\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Configure selection_fields.\novn-nbctl set load_balancer $lb2_uuid selection_fields=\"ip_src,ip_dst,tp_src,tp_dst\"\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)\" -c) -eq 2\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nOVS_WAIT_FOR_OUTPUT([\ndnl Test load-balancing that includes L4 ports in NAT.\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\necho \"foo\" > foo\nfor i in `seq 1 20`; do\n    echo Request $i\n    ip netns exec foo1 nc -6 -p 30000 fd03::2 8000 < foo\ndone\n\n# Only one backend should be chosen. Since the source port is fixed,\n# there should be only one conntrack entry.\nAT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep fd03::2 -c) -eq 1])\n\novn-nbctl set load_balancer $lb2_uuid selection_fields=\"eth_src,ip_src\"\nOVS_WAIT_UNTIL([\n    test $(ovs-ofctl dump-groups br-int | \\\n    grep \"selection_method=hash,fields(eth_src,ip_src)\" -c) -eq 2\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\nfor i in `seq 1 20`; do\n    echo Request $i\n    ip netns exec foo1 nc -6 fd03::2 8000 < foo\ndone\n\ndnl Only one backend should be chosen as eth_src and ip_src is fixed.\nbar1_ct=$(ovs-appctl dpctl/dump-conntrack | grep fd03::2 | grep fd02::2 -c)\nbar2_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep fd02::3 -c)\nbar3_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep fd02::4 -c)\n\nAT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep fd03::2 | grep fd02 -c) -ne 0])\n\nif [[ \"$bar1_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar1_ct -eq 20])\n    AT_CHECK([test $bar2_ct -eq 0])\n    AT_CHECK([test $bar3_ct -eq 0])\nelse\n    AT_CHECK([test $bar1_ct -eq 0])\nfi\n\nif [[ \"$bar2_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar1_ct -eq 20])\n    AT_CHECK([test $bar2_ct -eq 0])\n    AT_CHECK([test $bar3_ct -eq 0])\nelse\n    AT_CHECK([test $bar2_ct -eq 0])\nfi\n\nif [[ \"$bar3_ct\" == \"20\" ]]; then\n    AT_CHECK([test $bar1_ct -eq 20])\n    AT_CHECK([test $bar2_ct -eq 0])\n    AT_CHECK([test $bar3_ct -eq 0])\nelse\n    AT_CHECK([test $bar3_ct -eq 0])\nfi\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancing - same subnet.])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 1 logical switch \"foo\" (192.168.1.0/24) connected to router R1.\n# foo has foo1, foo2, foo3, foo4 as logical ports.\n#\n# Loadbalancer VIPs in 30.0.0.0/24 network. Router is needed for default\n# gateway. We will test load-balancing with foo1 as a client and foo2, foo3 and\n# foo4 as servers.\n\novn-nbctl create Logical_Router name=R1\novn-nbctl ls-add foo\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Create logical port 'foo1', 'foo2', 'foo3' and 'foo4' in switch 'foo'.\nADD_NAMESPACES(foo1, foo2, foo3, foo4)\nfor i in `seq 1 4`; do\n    j=`expr $i + 1`\n    ADD_VETH(foo$i, foo$i, br-int, \"192.168.1.$j/24\", \"f0:00:00:01:02:0$j\", \\\n             \"192.168.1.1\")\n    ovn-nbctl lsp-add foo foo$i \\\n        -- lsp-set-addresses foo$i \"f0:00:00:01:02:0$j 192.168.1.$j\"\ndone\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.3,192.168.1.4,192.168.1.5\"`\novn-nbctl set logical_switch foo load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"30.0.0.2:8000\"'='\"192.168.1.3:80,192.168.1.4:80,192.168.1.5:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.1.5:80)'])\n\n# Start webservers in 'foo2', 'foo3' and 'foo4'.\nOVS_START_L7([foo2], [http])\nOVS_START_L7([foo3], [http])\nOVS_START_L7([foo4], [http])\n\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.5,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.5,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancing - same subnet. - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 1 logical switch \"foo\" (fd01::/64) connected to router R1.\n# foo has foo1, foo2, foo3, foo4 as logical ports.\n#\n# Loadbalancer VIPs in fd03::/64 network. Router is needed for default\n# gateway. We will test load-balancing with foo1 as a client and foo2, foo3 and\n# foo4 as servers.\n\novn-nbctl create Logical_Router name=R1\novn-nbctl ls-add foo\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Create logical port 'foo1', 'foo2', 'foo3' and 'foo4' in switch 'foo'.\nADD_NAMESPACES(foo1, foo2, foo3, foo4)\nfor i in `seq 1 4`; do\n    j=`expr $i + 1`\n    ADD_VETH(foo$i, foo$i, br-int, \"fd01::$j/64\", \"f0:00:00:01:02:0$j\", \\\n             \"fd01::1\")\n    ovn-nbctl lsp-add foo foo$i \\\n        -- lsp-set-addresses foo$i \"f0:00:00:01:02:0$j fd01::$j\"\ndone\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:\\\"fd03::1\\\"=\\\"fd01::3,fd01::4,fd01::5\\\"`\novn-nbctl set logical_switch foo load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"[[fd03::2]]:8000\"'='\"@<:@fd01::3@:>@:80,@<:@fd01::4@:>@:80,@<:@fd01::5@:>@:80\"'\n\novn-nbctl list load_balancer\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd01::5\\]]:80)'])\n\n# Start webservers in 'foo2', 'foo3' and 'foo4'.\nOVS_START_L7([foo2], [http6])\nOVS_START_L7([foo3], [http6])\nOVS_START_L7([foo4], [http6])\n\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::1) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::5,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::5,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing in gateway router])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and\n# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected\n# to it.  R2 is a gateway router on which we add load-balancing rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.2,192.168.2.2\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"30.0.0.2:8000\"'='\"192.168.1.2:80,192.168.2.2:80\"'\n\n# Add SNAT rule to make sure that Load-balancing still works with a SNAT rule.\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=192.168.2.2 \\\n    external_ip=30.0.0.2 -- add logical_router R2 nat @nat\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2:80)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http])\nOVS_START_L7([bar1], [http])\n\ncheck ovs-appctl dpctl/flush-conntrack\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ncheck ovs-appctl dpctl/flush-conntrack\nOVS_WAIT_FOR_OUTPUT([\ndnl Test load-balancing that includes L4 ports in NAT.\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ncheck_est_flows () {\n    n=$(ovs-ofctl dump-flows br-int table=13 | grep \\\n\"priority=100,tcp,metadata=0x2,nw_dst=30.0.0.2\" | grep nat |\nsed -n 's/.*n_packets=\\([[0-9]]\\{1,\\}\\).*/\\1/p')\n\n    echo \"n_packets=$n\"\n    test ! -z $n\n    test \"$n\" != 0\n}\n\nOVS_WAIT_UNTIL([check_est_flows], [check established flows])\n\n\novn-nbctl set logical_router R2 options:lb_force_snat_ip=\"20.0.0.2\"\n\n# Destroy the load balancer and create again. ovn-controller will\n# clear the OF flows and re add again and clears the n_packets\n# for these flows.\novn-nbctl destroy load_balancer $uuid\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.2,192.168.2.2\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"30.0.0.2:8000\"'='\"192.168.1.2:80,192.168.2.2:80\"'\n\novn-nbctl list load_balancer\novn-sbctl dump-flows R2\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-flows br-int table=45 | \\\ngrep 'nat(src=20.0.0.2)'])\n\ncheck ovs-appctl dpctl/flush-conntrack\nexp_ct1=\"tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\"\nexp_ct2=\"tcp,orig=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\nct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\nct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\n\ntest \"x$ct1 = x$exp_ct1\" && test \"x$ct2 = x$exp_ct2\"\n], [0], [dnl\n])\n\nOVS_WAIT_UNTIL([check_est_flows], [check established flows])\n\novn-nbctl set logical_router R2 options:lb_force_snat_ip=router_ip\n\n# Destroy the load balancer and create again. ovn-controller will\n# clear the OF flows and re add again and clears the n_packets\n# for these flows.\novn-nbctl destroy load_balancer $uuid\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.2,192.168.2.2\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"30.0.0.2:8000\"'='\"192.168.1.2:80,192.168.2.2:80\"'\n\novn-nbctl list load_balancer\novn-sbctl dump-flows R2\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-flows br-int table=45 | \\\ngrep 'nat(src=20.0.0.2)'])\n\nrm -f wget*.log\n\ncheck ovs-appctl dpctl/flush-conntrack\ndnl Test load-balancing that includes L4 ports in NAT.\nexp_ct1=\"tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\"\nexp_ct2=\"tcp,orig=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\n\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\nct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\nct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ntest \"x$ct1 = x$exp_ct1\" && test \"x$ct2 = x$exp_ct2\"\n], [0], [dnl\n])\n\nOVS_WAIT_UNTIL([check_est_flows], [check established flows])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing in gateway router hairpin scenario])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-ext], [set Bridge br-ext fail-mode=standalone])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add R1\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add public\n\ncheck ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24\n\ncheck ovn-nbctl set logical_router R1 options:chassis=hv1\n\ncheck ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\n\ncheck ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \\\n    type=router options:router-port=rp-public \\\n    -- lsp-set-addresses public-rp router\n\ncheck ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext\n\ncheck ovn-nbctl lsp-add public public1 \\\n        -- lsp-set-addresses public1 unknown \\\n        -- lsp-set-type public1 localnet \\\n        -- lsp-set-options public1 network_name=phynet\n\nADD_NAMESPACES(server)\nADD_VETH(s1, server, br-ext, \"172.16.1.100/24\", \"1a:00:00:00:00:01\", \\\n         \"172.16.1.1\")\n\nOVS_WAIT_UNTIL([test \"$(ip netns exec server ip a | grep fe80 | grep tentative)\" = \"\"])\n\nADD_NAMESPACES(client)\nADD_VETH(c1, client, br-ext, \"172.16.1.110/24\", \"1a:00:00:00:00:02\", \\\n         \"172.16.1.1\")\n\nOVS_WAIT_UNTIL([test \"$(ip netns exec client ip a | grep fe80 | grep tentative)\" = \"\"])\n\n# Start webservers in 'server'.\nOVS_START_L7([server], [http])\n\n# Create a load balancer and associate to R1\ncheck ovn-nbctl lb-add lb1 172.16.1.150:80 172.16.1.100:80\ncheck ovn-nbctl lr-lb-add R1 lb1\n\ncheck ovn-nbctl --wait=hv sync\n\nfor i in $(seq 1 5); do\n    echo Request $i\n    NS_CHECK_EXEC([client], [wget 172.16.1.100 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\n# Now send the traffic from client to the VIP - 172.16.1.150\ncheck ovn-nbctl set logical_router R1 options:lb_force_snat_ip=router_ip\ncheck ovn-nbctl --wait=hv sync\n\nfor i in $(seq 1 5); do\n    echo Request $i\n    NS_CHECK_EXEC([client], [wget 172.16.1.150 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/Failed to acquire.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing in gateway router - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in fd20::/64 network. R1 has switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it. R2 has alice (fd72::/64) connected\n# to it.  R2 is a gateway router on which we add load-balancing rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd72::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 fd72::/64 fd20::2\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd72::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd72::1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd72::2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n\"fd12::1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:\\\"fd30::1\\\"=\\\"fd11::2,fd12::2\\\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"[[fd30::2]]:8000\"'='\"@<:@fd11::2@:>@:80,@<:@fd12::2@:>@:80\"'\n\novn-nbctl list load_balancer\n\n# Add SNAT rule to make sure that Load-balancing still works with a SNAT rule.\novn-nbctl -- --id=@nat create nat type=\"snat\" logical_ip=\\\"fd12::2\\\" \\\n    external_ip=\\\"fd30::2\\\" -- add logical_router R2 nat @nat\n\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd12::2\\]]:80)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http6])\nOVS_START_L7([bar1], [http6])\n\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget http://[[fd30::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::2) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, load-balancing])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and\n# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected\n# to it.  R3 has bob (172.16.1.0/24) connected to it. Note how both alice and\n# bob have the same subnet behind it.  We are trying to simulate external\n# network via those 2 switches. In real world the switch ports of these\n# switches will have addresses set as \"unknown\" to make them learning switches.\n# Or those switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.1.0/24 20.0.0.2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.2.0/24 20.0.0.3\n\n# Static routes.\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\novn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:lb_force_snat_ip=20.0.0.2\novn-nbctl set logical_router R3 options:lb_force_snat_ip=20.0.0.3\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.3/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"172.16.1.4/24\", \"f0:00:00:01:02:06\", \\\n         \"172.16.1.2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 172.16.1.4\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.2,192.168.2.2\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\novn-nbctl set logical_router R3 load_balancer=$uuid\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http])\nOVS_START_L7([bar1], [http])\n\ndnl Should work with the virtual IP address through NAT\nexp_ct1=\"tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\"\nexp_ct2=\"tcp,orig=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.3,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\n\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\nct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ndnl Force SNAT should have worked.\nct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ntest \"x$ct1 = x$exp_ct1\" && test \"x$ct2 = x$exp_ct2\"\n], [0], [dnl\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, load-balancing - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in fd20::/64 network. R1 has switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it. R2 has alice (fd72::/64) connected\n# to it.  R3 has bob (fd72::/64) connected to it. Note how both alice and\n# bob have the same subnet behind it.  We are trying to simulate external\n# network via those 2 switches. In real world the switch ports of these\n# switches will have addresses set as \"unknown\" to make them learning switches.\n# Or those switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd72::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 fd72::2/64\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 fd20::3/64\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd11::/64 fd20::2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd12::/64 fd20::3\n\n# Static routes.\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\novn-nbctl lr-route-add R3 fd11::/64 fd20::1\novn-nbctl lr-route-add R3 fd12::/64 fd20::1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:lb_force_snat_ip=fd20::2\novn-nbctl set logical_router R3 options:lb_force_snat_ip=fd20::3\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd72::3/64\", \"f0:00:00:01:02:04\", \\\n         \"fd72::1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd72::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n\"fd12::1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"fd72::4/64\", \"f0:00:00:01:02:06\", \\\n         \"fd72::2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 fd72::4\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl create load_balancer vips:\\\"fd30::1\\\"=\\\"fd11::2,fd12::2\\\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\novn-nbctl set logical_router R3 load_balancer=$uuid\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=fd12::2)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http6])\nOVS_START_L7([bar1], [http6])\n\ndnl Should work with the virtual IP address through NAT\nexp_ct1=\"tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\nexp_ct2=tcp,orig=(src=fd72::3,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::3,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\n\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\nct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ndnl Force SNAT should have worked.\nct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ntest \"x$ct1 = x$exp_ct1\" && test \"x$ct2 = x$exp_ct2\"\n], [0], [dnl\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([multiple gateway routers, load-balancing - Dual Stack])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Three LRs - R1, R2 and R3 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 and fd20::/64 networks. R1 has switches foo (192.168.1.0/24\n# and fd11::/64) and bar (192.168.2.0/24 and fd12::/64) connected to it. R2\n# has alice (172.16.1.0/24 and fd72::/64) connected to it.  R3 has bob\n# (172.16.1.0/24 and fd72::/64) connected to it. Note how both alice and\n# bob have the same subnets behind them.  We are trying to simulate external\n# network via those 2 switches. In real world the switch ports of these\n# switches will have addresses set as \"unknown\" to make them learning switches.\n# Or those switches will be \"localnet\" ones.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |          |\n#    bar ----          - R3 --- bob\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\novn-nbctl create Logical_Router name=R3 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24 fd72::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect bob to R3\novn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24 fd72::2/64\novn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \\\n    type=router options:router-port=bob addresses=\\\"00:00:03:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to join\novn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24 fd20::3/64\novn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \\\n    type=router options:router-port=R3_join addresses='\"00:00:04:01:02:05\"'\n\n# Install static routes with source ip address as the policy for routing.\n# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.1.0/24 20.0.0.2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 192.168.2.0/24 20.0.0.3\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd11::/64 fd20::2\novn-nbctl --policy=\"src-ip\" lr-route-add R1 fd12::/64 fd20::3\n\n# Static routes.\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\novn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\novn-nbctl lr-route-add R3 fd11::/64 fd20::1\novn-nbctl lr-route-add R3 fd12::/64 fd20::1\n\n# For gateway routers R2 and R3, set a force SNAT rule.\novn-nbctl set logical_router R2 options:lb_force_snat_ip=\"20.0.0.2 fd20::2\"\novn-nbctl set logical_router R3 options:lb_force_snat_ip=\"20.0.0.3 fd20::3\"\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'foo16' in switch 'foo'.\nADD_NAMESPACES(foo16)\nADD_VETH(foo16, foo16, br-int, \"fd11::2/64\", \"f0:00:06:01:02:03\", \\\n         \"fd11::1\")\novn-nbctl lsp-add foo foo16 \\\n-- lsp-set-addresses foo16 \"f0:00:06:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.3/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.3\"\n\n# Logical port 'alice16' in switch 'alice'.\nADD_NAMESPACES(alice16)\nADD_VETH(alice16, alice16, br-int, \"fd72::3/64\", \"f0:00:06:01:02:04\", \\\n         \"fd72::1\")\novn-nbctl lsp-add alice alice16 \\\n-- lsp-set-addresses alice16 \"f0:00:06:01:02:04 fd72::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\n# Logical port 'bar16' in switch 'bar'.\nADD_NAMESPACES(bar16)\nADD_VETH(bar16, bar16, br-int, \"fd12::2/64\", \"f0:00:06:01:02:05\", \\\n\"fd12::1\")\novn-nbctl lsp-add bar bar16 \\\n-- lsp-set-addresses bar16 \"f0:00:06:01:02:05 fd12::2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"172.16.1.4/24\", \"f0:00:00:01:02:06\", \\\n         \"172.16.1.2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 172.16.1.4\"\n\n# Logical port 'bob16' in switch 'bob'.\nADD_NAMESPACES(bob16)\nADD_VETH(bob16, bob16, br-int, \"fd72::4/64\", \"f0:00:06:01:02:06\", \\\n         \"fd72::2\")\novn-nbctl lsp-add bob bob16 \\\n-- lsp-set-addresses bob16 \"f0:00:06:01:02:06 fd72::4\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:30.0.0.1=\"192.168.1.2,192.168.2.2\" \\\nvips:\\\"fd30::1\\\"=\\\"fd11::2,fd12::2\\\"`\novn-nbctl set logical_router R2 load_balancer=$uuid\novn-nbctl set logical_router R3 load_balancer=$uuid\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2)'])\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=fd12::2)'])\n\n# Start webservers in 'foo1', 'foo16, 'bar1', and 'bar16'.\nOVS_START_L7([foo1], [http])\nOVS_START_L7([bar1], [http])\nOVS_START_L7([foo16], [http6])\nOVS_START_L7([bar16], [http6])\n\ndnl Should work with the virtual IP address through NAT\nexp_ct1=\"tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\"\nexp_ct2=\"tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10,protoinfo=(state=<cleared>)\"\nexp_ct3=\"tcp,orig=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.3,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\nexp_ct4=\"tcp,orig=(src=fd72::3,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::3,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\"\n\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\n    NS_EXEC([alice16], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget${i}_6.log])\ndone\n\ndnl Each server should have at least one connection.\nct1=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\nct2=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\n\ndnl Force SNAT should have worked.\nct3=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\nct4=$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | grep -v fe80 | sed -e 's/zone=[[0-9]]*/zone=<cleared>/')\ntest \"x$ct1 = x$exp_ct1\" && test \"x$ct2 = x$exp_ct2\" && test \"x$ct3 = x$exp_ct3\" && test \"x$ct4 = x$exp_ct4\"\n], [0], [dnl\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing in router with gateway router port])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),\n# and alice (172.16.1.0/24) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 LB rules are applied.\n#\n#    foo -- R1 -- bar\n#           |\n#    alice ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"192.168.1.3/24\", \"f0:00:00:01:02:06\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 192.168.1.3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:04\", \\\n         \"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 192.168.2.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 172.16.1.2\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:172.16.1.10=\"192.168.1.2,192.168.2.2\"`\novn-nbctl set logical_router R1 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"172.16.1.11:8000\"'='\"192.168.1.2:80,192.168.2.2:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2:80)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http])\nOVS_START_L7([bar1], [http])\n\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 172.16.1.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.10) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=172.16.1.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=172.16.1.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget 172.16.1.11:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.11) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=172.16.1.11,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=172.16.1.11,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing in router with gateway router port - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (fd01::/64), bar (fd02::/64),\n# and alice (fd72::/64) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 LB rules are applied.\n#\n#    foo -- R1 -- bar\n#           |\n#    alice ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd02::1/64\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd72::1/64 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd01::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd01::1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd01::2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"fd01::3/64\", \"f0:00:00:01:02:06\", \\\n         \"fd01::1\")\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 fd01::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd02::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd02::1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 fd02::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd72::2/64\", \"f0:00:00:01:02:05\", \\\n         \"fd72::1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 fd72::2\"\n\n# Config OVN load-balancer with a VIP.\nuuid=`ovn-nbctl  create load_balancer vips:\\\"fd72::10\\\"=\\\"fd01::2,fd02::2\\\"`\novn-nbctl set logical_router R1 load_balancer=$uuid\n\n# Config OVN load-balancer with another VIP (this time with ports).\novn-nbctl set load_balancer $uuid vips:'\"[[fd72::11]]:8000\"'='\"@<:@fd01::2@:>@:80,@<:@fd02::2@:>@:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd02::2\\]]:80)'])\n\n# Start webservers in 'foo1', 'bar1'.\nOVS_START_L7([foo1], [http6])\nOVS_START_L7([bar1], [http6])\n\ndnl Should work with the virtual IP address through NAT\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget http://[[fd72::10]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd72::10) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd72::10,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd72::10,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndnl Test load-balancing that includes L4 ports in NAT.\nOVS_WAIT_FOR_OUTPUT_UNQUOTED([\nfor i in `seq 1 10`; do\n    NS_EXEC([alice1], [wget http://[[fd72::11]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\novs-appctl dpctl/dump-conntrack | FORMAT_CT(fd72::11) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd72::11,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd72::11,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DNAT and SNAT on distributed router - N/S])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),\n# and alice (172.16.1.0/24) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 NAT rules are applied.\n#\n#    foo -- R1 -- alice\n#           |\n#    bar ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"192.168.1.3/24\", \"f0:00:00:01:02:06\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 192.168.1.3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:04\", \\\n         \"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 192.168.2.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 172.16.1.2\"\n\n# Add external network\nADD_NAMESPACES(ext-net)\nAT_CHECK([ip link add alice-ext netns alice1 type veth peer name ext-veth netns ext-net])\nNS_CHECK_EXEC([ext-net], [ip link set dev ext-veth up], [0], [])\nNS_CHECK_EXEC([ext-net], [ip addr add 10.0.0.1/24 dev ext-veth], [0], [])\nNS_CHECK_EXEC([ext-net], [ip route add default via 10.0.0.2], [0], [])\n\nNS_CHECK_EXEC([alice1], [ip link set dev alice-ext up], [0], [])\nNS_CHECK_EXEC([alice1], [ip addr add 10.0.0.2/24 dev alice-ext], [0], [])\nNS_CHECK_EXEC([alice1], [sysctl -w net.ipv4.conf.all.forwarding=1],[0], [dnl\nnet.ipv4.conf.all.forwarding = 1\n])\n\n# Add DNAT rules\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.1.2 foo1 00:00:02:02:03:04])\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.4 192.168.1.3 foo2 00:00:02:02:03:05])\n\n# Add a SNAT rule\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.0.0/16])\n\n# Add default route to ext-net\nAT_CHECK([ovn-nbctl lr-route-add R1 10.0.0.0/24 172.16.1.2])\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])\n\n# North-South DNAT: 'alice1' pings 'foo1' using 172.16.1.3.\nNS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that DNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# South-North SNAT: 'foo2' pings 'alice1'. But 'alice1' receives traffic\n# from 172.16.1.4\nNS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.3,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic\n# from 172.16.1.1\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# Try to ping external network\nNS_CHECK_EXEC([ext-net], [tcpdump -l -n -c 3 -i ext-veth dst 172.16.1.3 and icmp > ext-net.pcap 2>tcpdump_err &])\nOVS_WAIT_UNTIL([grep \"listening\" tcpdump_err])\nAT_CHECK([ovn-nbctl lr-nat-del R1 snat])\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_WAIT_UNTIL([\n    total_pkts=$(cat ext-net.pcap | wc -l)\n    test \"${total_pkts}\" = \"3\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DNAT and SNAT on distributed router - N/S - IPv6])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (fd11::/64), bar (fd12::/64),\n# and alice (fd20::/64) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 NAT rules are applied.\n#\n#    foo -- R1 -- alice\n#           |\n#    bar ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd20::1/64 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"fd11::3/64\", \"f0:00:00:01:02:06\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo2 ip a | grep fd11::3 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 fd11::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 fd12::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd20::2/64\", \"f0:00:00:01:02:05\", \\\n         \"fd20::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd20::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 fd20::2\"\n\novn-nbctl --wait=hv sync\n\n# Add DNAT rules\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::3 fd11::2 foo1 00:00:02:02:03:04])\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::4 fd11::3 foo2 00:00:02:02:03:05])\n\n# Add a SNAT rule\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd11::/64])\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd12::/64])\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd20::1)'])\n\n# North-South DNAT: 'alice1' pings 'foo1' using fd20::3\nNS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd20::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that DNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd20::2,dst=fd20::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# South-North SNAT: 'foo2' pings 'alice1'. But 'alice1' receives traffic\n# from fd20::4\nNS_CHECK_EXEC([foo2], [ping6 -q -c 3 -i 0.3 -w 2 fd20::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\novs-appctl dpctl/dump-conntrack | grep icmpv6\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd11::3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd11::3,dst=fd20::2,id=<cleared>,type=128,code=0),reply=(src=fd20::2,dst=fd20::4,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic\n# from fd20::1\nNS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd20::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that SNAT indeed happened via 'dump-conntrack' command.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd12::2,dst=fd20::2,id=<cleared>,type=128,code=0),reply=(src=fd20::2,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DNAT and SNAT on distributed router - E/W])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),\n# and alice (172.16.1.0/24) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 NAT rules are applied.\n#\n#    foo -- R1 -- alice\n#           |\n#    bar ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"192.168.1.3/24\", \"f0:00:00:01:02:06\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 192.168.1.3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:04\", \\\n         \"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 192.168.2.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 172.16.1.2\"\n\n# Add DNAT rules\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.1.2 foo1 00:00:02:02:03:04])\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.4 192.168.2.2 bar1 00:00:02:02:03:05])\n\n# Add a SNAT rule\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.0.0/16])\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])\n\necho \"------ hv dump ------\"\novs-ofctl show br-int\novs-ofctl dump-flows br-int\necho \"---------------------\"\n\n# East-West No NAT: 'foo1' pings 'bar1' using 192.168.2.2.\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that the connection is not tracked.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# East-West No NAT: 'foo2' pings 'bar1' using 192.168.2.2.\nNS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that the connection is not tracked.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# East-West No NAT: 'bar1' pings 'foo2' using 192.168.1.3.\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 192.168.1.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# We verify that the connection is not tracked.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# East-West NAT: 'foo1' pings 'bar1' using 172.16.1.4.\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.  First SNAT of 'foo1' address happens.\n# Then DNAT of 'bar1' address happens (listed first below).\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(172.16.1.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.3,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# East-West NAT: 'foo2' pings 'bar1' using 172.16.1.4.\nNS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.  First SNAT of 'foo2' address happens.\n# Then DNAT of 'bar1' address happens (listed first below).\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(172.16.1.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.1.1,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=192.168.1.3,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DNAT and SNAT on distributed router - E/W - IPv6])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (fd11::/64), bar (fd12::/64),\n# and alice (fd20::/64) connected to it.  The port between R1 and\n# alice is the router gateway port where the R1 NAT rules are applied.\n#\n#    foo -- R1 -- alice\n#           |\n#    bar ----\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd20::1/64 \\\n    -- lrp-set-gateway-chassis alice hv1\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Connect alice to R1\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice \\\n    -- lsp-set-addresses rp-alice router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'foo2' in switch 'foo'.\nADD_NAMESPACES(foo2)\nADD_VETH(foo2, foo2, br-int, \"fd11::3/64\", \"f0:00:00:01:02:06\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec foo2 ip a | grep fd11::3 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo2 \\\n-- lsp-set-addresses foo2 \"f0:00:00:01:02:06 fd11::3\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 fd12::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd20::2/64\", \"f0:00:00:01:02:05\", \\\n         \"fd20::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd20::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:05 fd20::2\"\n\n# Add DNAT rules\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::3 fd11::2 foo1 00:00:02:02:03:04])\nAT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::4 fd12::2 bar1 00:00:02:02:03:05])\n\n# Add a SNAT rule\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd11::/64])\nAT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd12::/64])\n\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd20::1)'])\n\necho \"------ hv dump ------\"\novs-ofctl show br-int\novs-ofctl dump-flows br-int\necho \"---------------------\"\n\n# East-West No NAT: 'foo1' pings 'bar1' using fd12::2.\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# East-West No NAT: 'foo2' pings 'bar1' using fd12::2.\nNS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# East-West No NAT: 'bar1' pings 'foo2' using fd11::3.\nNS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 fd11::3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# East-West NAT: 'foo1' pings 'bar1' using fd20::4.\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd20::4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.  First SNAT of 'foo1' address happens.\n# Then DNAT of 'bar1' address happens (listed first below).\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd11::2,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd20::4,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>\nicmpv6,orig=(src=fd20::3,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd12::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# East-West NAT: 'foo2' pings 'bar1' using fd20::4.\nNS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 fd20::4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.  First SNAT of 'foo2' address happens.\n# Then DNAT of 'bar1' address happens (listed first below).\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmpv6,orig=(src=fd11::3,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd20::4,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>\nicmpv6,orig=(src=fd20::1,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd12::2,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([conntrack zone flush after port binding release])\n\nCHECK_CONNTRACK()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LS ls1 with two lports p1 and p2.\n# Stateful ACL is added to ls1.\n#\n#    foo -- R1 -- alice\n#           |\n#    bar ----\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl acl-add ls1 from-lport 1 1 allow-related\n\n# Logical port 'p1' in switch 'ls1'.\nADD_NAMESPACES(p1)\nADD_VETH(p1, p1, br-int, \"192.168.1.10/24\", \"00:00:00:00:00:10\")\novn-nbctl lsp-add ls1 p1 \\\n-- lsp-set-addresses p1 \"00:00:00:00:00:10 192.168.1.10\"\n\n# Logical port 'p2' in switch 'ls1'.\novn-nbctl lsp-add ls1 p2 \\\n-- lsp-set-addresses p2 \"00:00:00:00:00:20 192.168.1.20\"\n\novn-nbctl --wait=hv sync\n\nzone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep p1 | cut -d ' ' -f2)\n\n# ping from p1 to p2\nNS_CHECK_EXEC([p1], [ping -q -c 1 -w1 192.168.1.20 > /dev/null], [1])\n\n# check conntrack zone has icmp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(192.168.1.10) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.10,dst=192.168.1.20,id=<cleared>,type=8,code=0),reply=(src=192.168.1.20,dst=192.168.1.10,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\n# release port binding\ncheck ovs-vsctl clear interface ovs-p1 external_ids\n\n# check conntrack zone is flushed\ncheck ovs-appctl dpctl/dump-conntrack zone=$zone_id\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([2 LSs IGMP and MLD])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_KEYWORDS([ovnigmp IP-multicast])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two independent logical switches (sw1 and sw2).\n# sw1:\n#   - subnet 10.0.0.0/8\n#   - 2 ports (sw1-p1 - sw1-p2)\n# sw2:\n#   - subnet 20.0.0.0/8\n#   - 2 port (sw2-p1 - sw2-p2)\n#   - IGMP Querier from 20.0.0.254\novn-nbctl ls-add sw1\novn-nbctl ls-add sw2\n\nfor i in `seq 1 2`\ndo\n    ADD_NAMESPACES(sw1-p$i)\n# Only send 1 membership report as second one might be received after flushing IGMP groups\n# causing test to fail\n    NS_CHECK_EXEC([sw1-p$i], [sysctl -w net.ipv4.igmp_qrv=1], [0], [dnl\nnet.ipv4.igmp_qrv = 1\n])\n    ADD_VETH(sw1-p$i, sw1-p$i, br-int, \"10.0.0.$i/24\", \"00:00:00:00:01:0$i\", \\\n            \"10.0.0.254\")\n    ovn-nbctl lsp-add sw1 sw1-p$i \\\n        -- lsp-set-addresses sw1-p$i \"00:00:00:00:01:0$i 10.0.0.$i\"\ndone\n\nfor i in `seq 1 2`\ndo\n    ADD_NAMESPACES(sw2-p$i)\n    ADD_VETH(sw2-p$i, sw2-p$i, br-int, \"20.0.0.$i/24\", \"00:00:00:00:02:0$i\", \\\n            \"20.0.0.254\")\n    ovn-nbctl lsp-add sw2 sw2-p$i \\\n        -- lsp-set-addresses sw2-p$i \"00:00:00:00:02:0$i 20.0.0.$i\"\ndone\n\n# Enable IGMP snooping on sw1.\novn-nbctl set Logical_Switch sw1 other_config:mcast_querier=\"false\"\novn-nbctl set Logical_Switch sw1 other_config:mcast_snoop=\"true\"\n\n\ngroup_v4=\"239.0.1.68\"\n# Inject IGMP Join for v4 group on sw1-p1.\nNS_CHECK_EXEC([sw1-p1], [ip addr add dev sw1-p1 ${group_v4}/32 autojoin], [0])\n\n# Inject IGMP Join for v4 group on sw1-p2\nNS_CHECK_EXEC([sw1-p2], [ip addr add dev sw1-p2 ${group_v4}/32 autojoin], [0])\n\n# Check that the IGMP Group is learned.\nOVS_WAIT_UNTIL([\n    total_entries=`ovn-sbctl find IGMP_Group address=\"${group_v4}\" | grep _uuid -c`\n    ports=`ovn-sbctl find IGMP_Group address=\"${group_v4}\" | grep ports | cut -f 2 -d \":\" | wc -w`\n    test \"${total_entries}\" = \"1\"\n    test \"${ports}\" = \"2\"\n])\n\n# Inject IGMP Leave for v4 group on sw1-p2.\nNS_CHECK_EXEC([sw1-p2], [ip addr del dev sw1-p2 ${group_v4}/32], [0])\n\n# Check that only one port is left in the group.\nOVS_WAIT_UNTIL([\n    total_entries=`ovn-sbctl find IGMP_Group address=\"${group_v4}\" | grep _uuid -c`\n    ports=`ovn-sbctl find IGMP_Group address=\"${group_v4}\" | grep ports | cut -f 2 -d \":\" | wc -w`\n    test \"${total_entries}\" = \"1\"\n    test \"${ports}\" = \"1\"\n])\n\n# Flush IGMP groups.\novn-sbctl ip-multicast-flush sw1\novn-nbctl --wait=hv -t 3 sync\nOVS_WAIT_UNTIL([\n    total_entries=`ovn-sbctl find IGMP_Group address=\"${group_v4}\" | grep _uuid -c`\n    test \"${total_entries}\" = \"0\"\n])\n\ngroup_v6=\"ff0a:dead:beef::1\"\ngroup_v6_str=\"ff0a\\:dead\\:beef\\:\\:1\"\n# Inject MLD Join for ff0a:dead:beef::1 on sw1-p1\nNS_CHECK_EXEC([sw1-p1], [ip addr add dev sw1-p1 ${group_v6}/64 autojoin], [0])\n\n# Inject MLD Join for ff0a:dead:beef::1 on sw1-p2\nNS_CHECK_EXEC([sw1-p2], [ip addr add dev sw1-p2 ${group_v6}/64 autojoin], [0])\n\n# Check that the MLD Group is learned.\nOVS_WAIT_UNTIL([\n    total_entries=`ovn-sbctl find IGMP_Group address=\"${group_v6_str}\" | grep _uuid -c`\n    ports=`ovn-sbctl find IGMP_Group address=\"${group_v6_str}\" | grep ports | cut -f 2 -d \":\" | wc -w`\n    test \"${total_entries}\" = \"1\"\n    test \"${ports}\" = \"2\"\n])\n\n# Inject IGMP Leave for v6 group on sw1-p2.\nNS_CHECK_EXEC([sw1-p2], [ip addr del dev sw1-p2 ${group_v6}/64 autojoin], [0])\n\n# Check that only one port is left in the group.\nOVS_WAIT_UNTIL([\n    total_entries=`ovn-sbctl find IGMP_Group address=\"${group_v6_str}\" | grep _uuid -c`\n    ports=`ovn-sbctl find IGMP_Group address=\"${group_v6_str}\" | grep ports | cut -f 2 -d \":\" | wc -w`\n    test \"${total_entries}\" = \"1\"\n    test \"${ports}\" = \"1\"\n])\n\n# Enable IGMP & MLD snooping and querier on sw2 and set query interval to\n# minimum.\novn-nbctl set Logical_Switch sw2 \\\n    other_config:mcast_snoop=\"true\" \\\n    other_config:mcast_querier=\"true\" \\\n    other_config:mcast_query_interval=1 \\\n    other_config:mcast_eth_src=\"00:00:00:00:02:fe\" \\\n    other_config:mcast_ip4_src=\"20.0.0.254\" \\\n    other_config:mcast_ip6_src=\"2000::fe\"\n\n# Check that v4 queries are generated.\nNS_CHECK_EXEC([sw2-p1], [tcpdump -n -c 2 -i sw2-p1 igmp > sw2-p1-v4.pcap &])\n\nOVS_WAIT_UNTIL([\n    total_queries=`grep \"igmp query\" -c sw2-p1-v4.pcap`\n    test \"${total_queries}\" = \"2\"\n])\n\n# Check that v6 queries are generated (ip6 next header == Hop-By-Hop and\n# icmpv6 type == MLD Query).\nNS_CHECK_EXEC([sw2-p1], [tcpdump -n -c 2 -i sw2-p1 ip6[[6]]==0 and ip6[[48]]==0x82 > sw2-p1-v6.pcap &])\n\nOVS_WAIT_UNTIL([\n    total_queries=`grep \"multicast listener query\" -c sw2-p1-v6.pcap`\n    test \"${total_queries}\" = \"2\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Load balancer health checks - IPv4])\nAT_KEYWORDS([lb])\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\n\novn-nbctl lsp-add sw0 sw0-p1\novn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:03\"\novn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:03\"\n\novn-nbctl lsp-add sw0 sw0-p2\novn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:04 10.0.0.4\"\novn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:04 10.0.0.4\"\n\n# Create port group and ACLs for sw0 ports.\novn-nbctl pg-add pg0_drop sw0-p1 sw0-p2\novn-nbctl acl-add pg0_drop from-lport 1001 \"inport == @pg0_drop && ip\" drop\novn-nbctl acl-add pg0_drop to-lport 1001 \"outport == @pg0_drop && ip\" drop\n\novn-nbctl pg-add pg0 sw0-p1 sw0-p2\novn-nbctl acl-add pg0 from-lport 1002 \"inport == @pg0 && ip4\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && icmp4\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80\" allow-related\n\n# Create the second logical switch with one port\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-p1\novn-nbctl lsp-set-addresses sw1-p1 \"40:54:00:00:00:03 20.0.0.3\"\novn-nbctl lsp-set-port-security sw1-p1 \"40:54:00:00:00:03 20.0.0.3\"\n\n# Create port group and ACLs for sw1 ports.\novn-nbctl pg-add pg1_drop sw1-p1\novn-nbctl acl-add pg1_drop from-lport 1001 \"inport == @pg1_drop && ip\" drop\novn-nbctl acl-add pg1_drop to-lport 1001 \"outport == @pg1_drop && ip\" drop\n\novn-nbctl pg-add pg1 sw1-p1\novn-nbctl acl-add pg1 from-lport 1002 \"inport == @pg1 && ip4\" allow-related\novn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && icmp4\" allow-related\novn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80\" allow-related\novn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80\" allow-related\n\n# Create a logical router and attach both logical switches\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\novn-nbctl lsp-add sw0 sw0-lr0\novn-nbctl lsp-set-type sw0-lr0 router\novn-nbctl lsp-set-addresses sw0-lr0 router\novn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\novn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\novn-nbctl lsp-add sw1 sw1-lr0\novn-nbctl lsp-set-type sw1-lr0 router\novn-nbctl lsp-set-addresses sw1-lr0 router\novn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\novn-nbctl --reject lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80\n\novn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2\novn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2\n\novn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer . \\\nhealth_check @hc\n\novn-nbctl --wait=sb ls-lb-add sw0 lb1\novn-nbctl --wait=sb ls-lb-add sw1 lb1\novn-nbctl --wait=sb lr-lb-add lr0 lb1\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw1-p1)\nADD_VETH(sw1-p1, sw1-p1, br-int, \"20.0.0.3/24\", \"40:54:00:00:00:03\", \\\n         \"20.0.0.1\")\n\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\n# Wait until all the services are set to offline.\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor | sed '/^$/d' | grep offline | wc -l`])\n\n# Start webservers in 'sw0-p1' and 'sw1-p1'.\nOVS_START_L7([sw0-p1], [http])\nsw0_p1_pid_file=`cat l7_pid_file`\nOVS_START_L7([sw1-p1], [http])\n\n# Wait until the services are set to online.\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor | sed '/^$/d' | grep online | wc -l`])\n\nOVS_WAIT_UNTIL(\n    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep \"ip4.dst == 10.0.0.10\" > lflows.txt\n     test 1 = `cat lflows.txt | grep \"ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80)\" | wc -l`]\n)\n# From sw0-p2 send traffic to vip - 10.0.0.10\n#dnl Each server should have at least one connection.\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 10`; do\n        NS_EXEC([sw0-p2], [wget 10.0.0.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\n    done\n\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.10) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=20.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Stop webserver in sw0-p1\nkill `cat $sw0_p1_pid_file`\n\n# Wait until service_monitor for sw0-p1 is set to offline\nOVS_WAIT_UNTIL([test 1 = `ovn-sbctl --bare --columns status find \\\nservice_monitor logical_port=sw0-p1 | sed '/^$/d' | grep offline | wc -l`])\n\nOVS_WAIT_UNTIL(\n    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep \"ip4.dst == 10.0.0.10\" > lflows.txt\n     test 1 = `cat lflows.txt | grep \"ct_lb_mark(backends=20.0.0.3:80)\" | wc -l`]\n)\n\novs-appctl dpctl/flush-conntrack\n# From sw0-p2 send traffic to vip - 10.0.0.10\nfor i in `seq 1 20`; do\n    echo Request $i\n    NS_CHECK_EXEC([sw0-p2], [wget 10.0.0.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.10) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=20.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# trigger port binding release and check if status changed to offline\novs-vsctl remove interface ovs-sw1-p1 external_ids iface-id\nwait_row_count Service_Monitor 2\nwait_row_count Service_Monitor 2 status=offline\n\novs-vsctl set interface ovs-sw1-p1 external_ids:iface-id=sw1-p1\nwait_row_count Service_Monitor 2\nwait_row_count Service_Monitor 1 status=online\n\n# Create udp load balancer.\novn-nbctl lb-add lb2 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80 udp\nlb_udp=`ovn-nbctl lb-list | grep udp | awk '{print $1}'`\n\necho \"lb udp uuid = $lb_udp\"\n\novn-nbctl list load_balancer\n\novn-nbctl --wait=sb set load_balancer $lb_udp ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2\novn-nbctl --wait=sb set load_balancer $lb_udp ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2\n\novn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"10.0.0.10\\:80\" -- add Load_Balancer $lb_udp \\\nhealth_check @hc\n\novn-nbctl --wait=sb ls-lb-add sw0 lb2\novn-nbctl --wait=sb ls-lb-add sw1 lb2\novn-nbctl --wait=sb lr-lb-add lr0 lb2\n\nsleep 10\n\novn-nbctl list load_balancer\necho \"*******Next is health check*******\"\novn-nbctl list Load_Balancer_Health_Check\necho \"********************\"\novn-sbctl list service_monitor\n\n# Wait until udp service_monitor are set to offline\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor protocol=udp | sed '/^$/d' | grep offline | wc -l`])\n\n# Stop webserver in sw1-p1\npid_file=$(cat l7_pid_file)\nNS_CHECK_EXEC([sw1-p1], [kill $(cat $pid_file)])\n\nNS_CHECK_EXEC([sw0-p2], [tcpdump -c 1 -neei sw0-p2 ip[[33:1]]=0x14 > rst.pcap &])\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor protocol=tcp | sed '/^$/d' | grep offline | wc -l`])\nNS_CHECK_EXEC([sw0-p2], [wget 10.0.0.10 -v -o wget$i.log],[4])\n\nOVS_WAIT_UNTIL([\n    n_reset=$(cat rst.pcap | wc -l)\n    test \"${n_reset}\" = \"1\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/Service monitor not found.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Load balancer health checks - IPv6])\nAT_KEYWORDS([lb])\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:03 2001::3\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:03 2001::3\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:04 2001::4\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:04 2001::4\"\n\n# Create port group and ACLs for sw0 ports.\ncheck ovn-nbctl pg-add pg0_drop sw0-p1 sw0-p2\ncheck ovn-nbctl acl-add pg0_drop from-lport 1001 \"inport == @pg0_drop && ip\" drop\ncheck ovn-nbctl acl-add pg0_drop to-lport 1001 \"outport == @pg0_drop && ip\" drop\n\ncheck ovn-nbctl pg-add pg0 sw0-p1 sw0-p2\ncheck ovn-nbctl acl-add pg0 from-lport 1002 \"inport == @pg0 && ip6\" allow-related\ncheck ovn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip6 && ip6.src == ::/0 && icmp6\" allow-related\ncheck ovn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip6 && ip6.src == ::/0 && tcp && tcp.dst == 80\" allow-related\ncheck ovn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip6 && ip6.src == ::/0 && udp && udp.dst == 80\" allow-related\n\n# Create the second logical switch with one port\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-p1\ncheck ovn-nbctl lsp-set-addresses sw1-p1 \"40:54:00:00:00:03 2002::3\"\ncheck ovn-nbctl lsp-set-port-security sw1-p1 \"40:54:00:00:00:03 2002::3\"\n\n# Create port group and ACLs for sw1 ports.\ncheck ovn-nbctl pg-add pg1_drop sw1-p1\ncheck ovn-nbctl acl-add pg1_drop from-lport 1001 \"inport == @pg1_drop && ip\" drop\ncheck ovn-nbctl acl-add pg1_drop to-lport 1001 \"outport == @pg1_drop && ip\" drop\n\ncheck ovn-nbctl pg-add pg1 sw1-p1\ncheck ovn-nbctl acl-add pg1 from-lport 1002 \"inport == @pg1 && ip6\" allow-related\ncheck ovn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip6 && ip6.src == ::/0 && icmp6\" allow-related\ncheck ovn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip6 && ip6.src == ::/0 && tcp && tcp.dst == 80\" allow-related\ncheck ovn-nbctl acl-add pg1 to-lport 1002 \"outport == @pg1 && ip6 && ip6.src == ::/0 && udp && udp.dst == 80\" allow-related\n\n# Create a logical router and attach both logical switches\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 2001::1/64\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 router\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 2002::1/64\ncheck ovn-nbctl lsp-add sw1 sw1-lr0\ncheck ovn-nbctl lsp-set-type sw1-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr0 router\ncheck ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\ncheck ovn-nbctl --reject lb-add lb1 [[2001::a]]:80 [[2001::3]]:80,[[2002::3]]:80\n\ncheck ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:\\\"[[2001::3]]\\\"=\\\"sw0-p1:[[2001::2]]\\\"\ncheck ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:\\\"[[2002::3]]\\\"=\\\"sw1-p1:[[2002::2]]\\\"\n\novn-nbctl --wait=sb -- --id=@hc create \\\nLoad_Balancer_Health_Check vip=\"\\[\\[2001\\:\\:a\\]\\]\\:80\" -- add Load_Balancer . \\\nhealth_check @hc\n\ncheck ovn-nbctl ls-lb-add sw0 lb1\ncheck ovn-nbctl ls-lb-add sw1 lb1\ncheck ovn-nbctl lr-lb-add lr0 lb1\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"2001::3/64\", \"50:54:00:00:00:03\", \\\n         \"2001::1\")\n\nADD_NAMESPACES(sw1-p1)\nADD_VETH(sw1-p1, sw1-p1, br-int, \"2002::3/64\", \"40:54:00:00:00:03\", \\\n         \"2002::1\")\n\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"2001::4/64\", \"50:54:00:00:00:04\", \\\n         \"2001::1\")\n\n# Wait until all the services are set to offline.\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor | sed '/^$/d' | grep offline | wc -l`])\n\n# Start webservers in 'sw0-p1' and 'sw1-p1'.\nOVS_START_L7([sw0-p1], [http6])\nsw0_p1_pid_file=$(cat l7_pid_file)\nOVS_START_L7([sw1-p1], [http6])\n\n# Wait until the services are set to online.\nOVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \\\nservice_monitor | sed '/^$/d' | grep online | wc -l`])\n\nOVS_WAIT_UNTIL(\n    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep \"ip6.dst == 2001::a\" > lflows.txt\n     test 1 = `cat lflows.txt | grep \"ct_lb_mark(backends=[\\[2001::3\\]]:80,[\\[2002::3\\]]:80)\" | wc -l`]\n)\n\n# From sw0-p2 send traffic to vip - 2001::a\nfor i in `seq 1 20`; do\n    echo Request $i\n    ovn-sbctl list service_monitor\n    NS_CHECK_EXEC([sw0-p2], [wget http://[[2001::a]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(2001::a) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=2001::4,dst=2001::a,sport=<cleared>,dport=<cleared>),reply=(src=2001::3,dst=2001::4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=2001::4,dst=2001::a,sport=<cleared>,dport=<cleared>),reply=(src=2002::3,dst=2001::4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Stop webserver in sw0-p1\nkill `cat $sw0_p1_pid_file`\n\n# Wait until service_monitor for sw0-p1 is set to offline\nOVS_WAIT_UNTIL([test 1 = `ovn-sbctl --bare --columns status find \\\nservice_monitor logical_port=sw0-p1 | sed '/^$/d' | grep offline | wc -l`])\n\nOVS_WAIT_UNTIL(\n    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep \"ip6.dst == 2001::a\" > lflows.txt\n     test 1 = `cat lflows.txt | grep \"ct_lb_mark(backends=[\\[2002::3\\]]:80)\" | wc -l`]\n)\n\novs-appctl dpctl/flush-conntrack\n# From sw0-p2 send traffic to vip - 2001::a\nfor i in `seq 1 20`; do\n    echo Request $i\n    NS_CHECK_EXEC([sw0-p2], [wget http://[[2001::a]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])\ndone\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(2001::a) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=2001::4,dst=2001::a,sport=<cleared>,dport=<cleared>),reply=(src=2002::3,dst=2001::4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# trigger port binding release and check if status changed to offline\novs-vsctl remove interface ovs-sw1-p1 external_ids iface-id\nwait_row_count Service_Monitor 2\nwait_row_count Service_Monitor 2 status=offline\n\novs-vsctl set interface ovs-sw1-p1 external_ids:iface-id=sw1-p1\nwait_row_count Service_Monitor 2\nwait_row_count Service_Monitor 1 status=online\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/Service monitor not found.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Load Balancer LS hairpin IPv4])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One logical switch with IPv4 load balancers that hairpin the traffic.\novn-nbctl ls-add sw\novn-nbctl lsp-add sw lsp -- lsp-set-addresses lsp 00:00:00:00:00:01\novn-nbctl lb-add lb-ipv4-tcp     88.88.88.88:8080 42.42.42.1:4041 tcp\novn-nbctl lb-add lb-ipv4-tcp-dup 88.88.88.89:8080 42.42.42.1:4041 tcp\novn-nbctl lb-add lb-ipv4-udp     88.88.88.88:4040 42.42.42.1:2021 udp\novn-nbctl lb-add lb-ipv4-udp-dup 88.88.88.89:4040 42.42.42.1:2021 udp\novn-nbctl lb-add lb-ipv4 88.88.88.90 42.42.42.1\novn-nbctl ls-lb-add sw lb-ipv4-tcp\novn-nbctl ls-lb-add sw lb-ipv4-tcp-dup\novn-nbctl ls-lb-add sw lb-ipv4-udp\novn-nbctl ls-lb-add sw lb-ipv4-udp-dup\novn-nbctl ls-lb-add sw lb-ipv4\n\novn-nbctl lr-add rtr\novn-nbctl lrp-add rtr rtr-sw 00:00:00:00:01:00 42.42.42.254/24\novn-nbctl lsp-add sw sw-rtr                       \\\n    -- lsp-set-type sw-rtr router                 \\\n    -- lsp-set-addresses sw-rtr 00:00:00:00:01:00 \\\n    -- lsp-set-options sw-rtr router-port=rtr-sw\n\nADD_NAMESPACES(lsp)\nADD_VETH(lsp, lsp, br-int, \"42.42.42.1/24\", \"00:00:00:00:00:01\", \\\n         \"42.42.42.254\")\n\novn-nbctl --wait=hv -t 3 sync\n\n# Start IPv4 TCP server on lsp.\nNETNS_DAEMONIZE([lsp], [nc -l -k 42.42.42.1 4041], [lsp0.pid])\n\n# Check that IPv4 TCP hairpin connection succeeds on both VIPs.\nNS_CHECK_EXEC([lsp], [nc 88.88.88.88 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 88.88.88.89 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 88.88.88.90 4041 -z], [0], [ignore], [ignore])\n\n# Capture IPv4 UDP hairpinned packets.\nfilter=\"dst 42.42.42.1 and dst port 2021 and udp\"\nNS_CHECK_EXEC([lsp], [tcpdump -l -nn -c 3 -i lsp ${filter} > lsp.pcap 2>tcpdump_err &])\nOVS_WAIT_UNTIL([grep \"listening\" tcpdump_err])\n\n# Generate IPv4 UDP hairpin traffic.\nNS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.88 4040], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.89 4040], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.90 2021], [ignore], [ignore], [ignore])\n\n# Check hairpin traffic.\nOVS_WAIT_UNTIL([\n    total_pkts=$(cat lsp.pcap | wc -l)\n    test \"${total_pkts}\" = \"3\"\n])\n\novn-nbctl pg-add pg0 lsp\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1004 \"ip4 && ip4.dst == 10.0.0.2\" drop\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"ip4 && tcp\" allow-related\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"ip4 && udp\" allow\novn-nbctl --wait=hv sync\n\n## Check that IPv4 TCP hairpin connection succeeds on both VIPs.\nNS_CHECK_EXEC([lsp], [nc 88.88.88.88 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 88.88.88.89 8080 -z], [0], [ignore], [ignore])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Load Balancer LS hairpin IPv6])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One logical switch with IPv6 load balancers that hairpin the traffic.\novn-nbctl ls-add sw\novn-nbctl lsp-add sw lsp -- lsp-set-addresses lsp 00:00:00:00:00:01\novn-nbctl lb-add lb-ipv6-tcp     [[8800::0088]]:8080 [[4200::1]]:4041 tcp\novn-nbctl lb-add lb-ipv6-tcp-dup [[8800::0089]]:8080 [[4200::1]]:4041 tcp\novn-nbctl lb-add lb-ipv6-udp     [[8800::0088]]:4040 [[4200::1]]:2021 udp\novn-nbctl lb-add lb-ipv6-udp-dup [[8800::0089]]:4040 [[4200::1]]:2021 udp\novn-nbctl lb-add lb-ipv6 8800::0090 4200::1\novn-nbctl ls-lb-add sw lb-ipv6-tcp\novn-nbctl ls-lb-add sw lb-ipv6-tcp-dup\novn-nbctl ls-lb-add sw lb-ipv6-udp\novn-nbctl ls-lb-add sw lb-ipv6-udp-dup\novn-nbctl ls-lb-add sw lb-ipv6\n\novn-nbctl lr-add rtr\novn-nbctl lrp-add rtr rtr-sw 00:00:00:00:01:00 4200::00ff/64\novn-nbctl lsp-add sw sw-rtr                       \\\n    -- lsp-set-type sw-rtr router                 \\\n    -- lsp-set-addresses sw-rtr 00:00:00:00:01:00 \\\n    -- lsp-set-options sw-rtr router-port=rtr-sw\n\nADD_NAMESPACES(lsp)\nADD_VETH(lsp, lsp, br-int, \"4200::1/64\", \"00:00:00:00:00:01\", \"4200::00ff\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec lsp ip a | grep 4200::1 | grep tentative)\" = \"\"])\novn-nbctl --wait=hv -t 3 sync\n\n# Start IPv6 TCP server on lsp.\nNETNS_DAEMONIZE([lsp], [nc -l -k 4200::1 4041], [lsp0.pid])\n\n# Check that IPv6 TCP hairpin connection succeeds on both VIPs.\nNS_CHECK_EXEC([lsp], [nc 8800::0088 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 8800::0089 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 8800::0090 4041 -z], [0], [ignore], [ignore])\n\n# Capture IPv6 UDP hairpinned packets.\nfilter=\"dst 4200::1 and dst port 2021 and udp\"\nNS_CHECK_EXEC([lsp], [tcpdump -l -nn -c 3 -i lsp $filter > lsp.pcap 2>tcpdump_err &])\nOVS_WAIT_UNTIL([grep \"listening\" tcpdump_err])\n\n# Generate IPv6 UDP hairpin traffic.\nNS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0088 4040], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0089 4040], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0090 2021], [ignore], [ignore], [ignore])\n\n# Check hairpin traffic.\nOVS_WAIT_UNTIL([\n    total_pkts=$(cat lsp.pcap | wc -l)\n    test \"${total_pkts}\" = \"3\"\n])\n\novn-nbctl pg-add pg0 lsp\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"ip6 && tcp\" allow-related\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"ip6 && udp\" allow\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1000 \"ip6\" drop\novn-nbctl --wait=hv sync\n\n# Check that IPv6 TCP hairpin connection succeeds on both VIPs.\nNS_CHECK_EXEC([lsp], [nc 8800::0088 8080 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([lsp], [nc 8800::0089 8080 -z], [0], [ignore], [ignore])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL reject])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\n\novn-nbctl lsp-add sw0 sw0-p1-rej\novn-nbctl lsp-set-addresses sw0-p1-rej \"50:54:00:00:00:03 10.0.0.3 aef0::3\"\novn-nbctl lsp-set-port-security sw0-p1-rej \"50:54:00:00:00:03 10.0.0.3 aef0::3\"\n\novn-nbctl lsp-add sw0 sw0-p2-rej\novn-nbctl lsp-set-addresses sw0-p2-rej \"50:54:00:00:00:04 10.0.0.4 aef0::4\"\novn-nbctl lsp-set-port-security sw0-p2-rej \"50:54:00:00:00:04 10.0.0.4 aef0::4\"\n\n# Create port group and ACLs for sw0 ports.\novn-nbctl pg-add pg0_drop sw0-p1-rej sw0-p2-rej\novn-nbctl acl-add pg0_drop from-lport 1001 \"inport == @pg0_drop && ip\" drop\novn-nbctl acl-add pg0_drop to-lport 1001 \"outport == @pg0_drop && ip\" drop\n\novn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej\novn-nbctl acl-add pg0 from-lport 1002 \"inport == @pg0 && ip\" allow-related\novn-nbctl --log acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && tcp && tcp.dst == 80\" reject\novn-nbctl --log acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && udp && udp.dst == 90\" reject\n\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 82\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 82\" allow-related\novn-nbctl --log acl-add pg0 to-lport 1004 \"inport == @pg0 && ip && tcp && tcp.dst == 84\" reject\novn-nbctl --log acl-add pg0 to-lport 1004 \"inport == @pg0 && ip && udp && udp.dst == 94\" reject\n\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-p1-rej\novn-nbctl lsp-set-addresses sw1-p1-rej \"40:54:00:00:00:03 20.0.0.3\"\novn-nbctl lsp-set-port-security sw1-p1-rej \"40:54:00:00:00:03 20.0.0.3\"\n\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\novn-nbctl lsp-add sw0 sw0-lr0\novn-nbctl lsp-set-type sw0-lr0 router\novn-nbctl lsp-set-addresses sw0-lr0 router\novn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\novn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\novn-nbctl lsp-add sw1 sw1-lr0\novn-nbctl lsp-set-type sw1-lr0 router\novn-nbctl lsp-set-addresses sw1-lr0 router\novn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1-rej)\nADD_VETH(sw0-p1-rej, sw0-p1-rej, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw0-p2-rej)\nADD_VETH(sw0-p2-rej, sw0-p2-rej, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\nNS_CHECK_EXEC([sw0-p1-rej], [ip a a aef0::3/64 dev sw0-p1-rej], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [ip a a aef0::4/64 dev sw0-p2-rej], [0])\n\nADD_NAMESPACES(sw1-p1-rej)\nADD_VETH(sw1-p1-rej, sw1-p1-rej, br-int, \"20.0.0.3/24\", \"40:54:00:00:00:03\", \\\n         \"20.0.0.1\")\n\n# Capture packets in sw0-p1-rej.\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej tcp > sw0-p1-rej-ip4.pcap 2> err &], [0])\n\n#Wait for tcpdump to get started before generating first packets\nOVS_WAIT_UNTIL([test 1 = $(cat err | grep -c listening)])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'\n])\n\n# Now send traffic to port 84\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'\n])\n\nOVS_WAIT_UNTIL([\n    n_pkt=$(ovs-ofctl dump-flows br-int table=46 | grep -v n_packets=0 | \\\ngrep controller | grep tp_dst=84 -c)\n    test $n_pkt -eq 1\n])\n\nOVS_WAIT_UNTIL([\n    total=`cat sw0-p1-rej-ip4.pcap |  grep \"10\\.0\\.0\\.3\" | wc -l`\n    echo \"total = $total\"\n    test \"${total}\" = \"4\"\n])\n\nkill $(pidof tcpdump)\n\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej tcp port 80 > sw0-p2-rej-ip6.pcap 2> err &], [0])\n\n#Wait for tcpdump to get started before generating first packets\nOVS_WAIT_UNTIL([test 1 = $(cat err | grep -c listening)])\n\nOVS_WAIT_UNTIL([test \"$(ip netns exec sw0-p1-rej ip a | grep aef0::3 | grep tentative)\" = \"\"])\nOVS_WAIT_UNTIL([test \"$(ip netns exec sw0-p2-rej ip a | grep aef0::4 | grep tentative)\" = \"\"])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'\n])\n\n\nOVS_WAIT_UNTIL([\n    total=`cat sw0-p2-rej-ip6.pcap |  grep \"aef0::3\\.80\" |wc -l`\n    echo \"total = $total\"\n    test \"${total}\" = \"2\"\n])\novn-nbctl acl-add sw1 from-lport 1004 \"ip\" allow-related\novn-nbctl acl-add sw1 to-lport 1004 \"ip\" allow-related\novn-nbctl --log acl-add pg0 to-lport 1004 \"outport == @pg0 && ip && tcp && tcp.dst == 84\" reject\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw1-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'\n])\n\nkill $(pidof tcpdump)\n\n\n# Now test for IPv4 UDP.\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej udp port 90 > sw0-p1-rej-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nprintf '.%.0s' {1..100} > foo\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej udp port 94 > sw0-p1-rej-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 94 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 94 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\nkill $(pidof tcpdump)\n\n# Now test for IPv6 UDP.\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej udp port 90 > sw0-p2-rej-ip6-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 90\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej udp port 94 > sw0-p2-rej-ip6-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 94 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 94\" | uniq | wc -l)\n    test $c -ge 1\n])\nkill $(pidof tcpdump)\n\n# Delete all the ACLs of pg0 and add the ACL with a generic match with reject action.\novn-nbctl pg-del pg0\novn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej\novn-nbctl --log acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && (tcp || udp)\" reject\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'\n])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'\n])\n\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nprintf '.%.0s' {1..100} > foo\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n# Now test for IPv6 UDP.\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 90\" | uniq | wc -l)\n    test $c -ge 1\n])\nkill $(pidof tcpdump)\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL after lb - reject])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\n\novn-nbctl lsp-add sw0 sw0-p1-rej\novn-nbctl lsp-set-addresses sw0-p1-rej \"50:54:00:00:00:03 10.0.0.3 aef0::3\"\novn-nbctl lsp-set-port-security sw0-p1-rej \"50:54:00:00:00:03 10.0.0.3 aef0::3\"\n\novn-nbctl lsp-add sw0 sw0-p2-rej\novn-nbctl lsp-set-addresses sw0-p2-rej \"50:54:00:00:00:04 10.0.0.4 aef0::4\"\novn-nbctl lsp-set-port-security sw0-p2-rej \"50:54:00:00:00:04 10.0.0.4 aef0::4\"\n\n# Create port group and ACLs for sw0 ports.\novn-nbctl pg-add pg0_drop sw0-p1-rej sw0-p2-rej\novn-nbctl --apply-after-lb acl-add pg0_drop from-lport 1001 \"inport == @pg0_drop && ip\" drop\novn-nbctl acl-add pg0_drop to-lport 1001 \"outport == @pg0_drop && ip\" drop\n\novn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej\novn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 \"inport == @pg0 && ip\" allow-related\novn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && tcp && tcp.dst == 80\" reject\novn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && udp && udp.dst == 90\" reject\n\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 82\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 82\" allow-related\novn-nbctl --log acl-add pg0 to-lport 1004 \"inport == @pg0 && ip && tcp && tcp.dst == 84\" reject\novn-nbctl --log acl-add pg0 to-lport 1004 \"inport == @pg0 && ip && udp && udp.dst == 94\" reject\n\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-p1-rej\novn-nbctl lsp-set-addresses sw1-p1-rej \"40:54:00:00:00:03 20.0.0.3\"\novn-nbctl lsp-set-port-security sw1-p1-rej \"40:54:00:00:00:03 20.0.0.3\"\n\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\novn-nbctl lsp-add sw0 sw0-lr0\novn-nbctl lsp-set-type sw0-lr0 router\novn-nbctl lsp-set-addresses sw0-lr0 router\novn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\novn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\novn-nbctl lsp-add sw1 sw1-lr0\novn-nbctl lsp-set-type sw1-lr0 router\novn-nbctl lsp-set-addresses sw1-lr0 router\novn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1-rej)\nADD_VETH(sw0-p1-rej, sw0-p1-rej, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw0-p2-rej)\nADD_VETH(sw0-p2-rej, sw0-p2-rej, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\nNS_CHECK_EXEC([sw0-p1-rej], [ip a a aef0::3/64 dev sw0-p1-rej], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [ip a a aef0::4/64 dev sw0-p2-rej], [0])\n\nADD_NAMESPACES(sw1-p1-rej)\nADD_VETH(sw1-p1-rej, sw1-p1-rej, br-int, \"20.0.0.3/24\", \"40:54:00:00:00:03\", \\\n         \"20.0.0.1\")\n\n# Capture packets in sw0-p1-rej.\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej tcp > sw0-p1-rej-ip4.pcap 2> err &], [0])\n\n#Wait for tcpdump to get started before generating first packets\nOVS_WAIT_UNTIL([test 1 = $(cat err | grep -c listening)])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'\n])\n\n# Now send traffic to port 84\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'\n])\n\nOVS_WAIT_UNTIL([\n    n_pkt=$(ovs-ofctl dump-flows br-int table=46 | grep -v n_packets=0 | \\\ngrep controller | grep tp_dst=84 -c)\n    test $n_pkt -eq 1\n])\n\nOVS_WAIT_UNTIL([\n    total=`cat sw0-p1-rej-ip4.pcap |  grep \"10\\.0\\.0\\.4\" | wc -l`\n    echo \"total = $total\"\n    test \"${total}\" = \"4\"\n])\n\nkill $(pidof tcpdump)\n\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej tcp port 80 > sw0-p2-rej-ip6.pcap 2> err &], [0])\n\n#Wait for tcpdump to get started before generating first packets\nOVS_WAIT_UNTIL([test 1 = $(cat err | grep -c listening)])\n\nOVS_WAIT_UNTIL([test \"$(ip netns exec sw0-p1-rej ip a | grep aef0::3 | grep tentative)\" = \"\"])\nOVS_WAIT_UNTIL([test \"$(ip netns exec sw0-p2-rej ip a | grep aef0::4 | grep tentative)\" = \"\"])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'\n])\n\n\nOVS_WAIT_UNTIL([\n    total=`cat sw0-p2-rej-ip6.pcap | grep \"aef0::3\\.80\" | wc -l`\n    echo \"total = $total\"\n    test \"${total}\" = \"2\"\n])\n\nkill $(pidof tcpdump)\n\novn-nbctl --apply-after-lb acl-add sw1 from-lport 1004 \"ip\" allow-related\novn-nbctl acl-add sw1 to-lport 1004 \"ip\" allow-related\novn-nbctl --log acl-add pg0 to-lport 1004 \"outport == @pg0 && ip && tcp && tcp.dst == 84\" reject\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw1-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'\n])\n\n# Now test for IPv4 UDP.\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej udp port 90 > sw0-p1-rej-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nprintf '.%.0s' {1..100} > foo\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej udp port 94 > sw0-p1-rej-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 94 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 94 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\n\n# Now test for IPv6 UDP.\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej udp port 90 > sw0-p2-rej-ip6-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 90\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej udp port 94 > sw0-p2-rej-ip6-udp.pcap 2> err &], [0])\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 94 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 94\" | uniq | wc -l)\n    test $c -ge 1\n])\n\n# Delete all the ACLs of pg0 and add the ACL with a generic match with reject action.\novn-nbctl pg-del pg0\novn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej\novn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 \"inport == @pg0 && ip && (tcp || udp)\" reject\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'\n])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n\nNS_CHECK_EXEC([sw0-p1-rej], [tcpdump -l -nn -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap 2> err &], [0])\n\nprintf '.%.0s' {1..100} > foo\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo\n    c=$(cat sw0-p1-rej-icmp.pcap | grep \\\n\"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\nrm -f *.pcap\n# Now test for IPv6 UDP.\nNS_CHECK_EXEC([sw0-p2-rej], [tcpdump -l -nn -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap 2> err &], [0])\n\nOVS_WAIT_UNTIL([\n    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo\n    c=$(cat sw0-p2-rej-icmp6.pcap | grep \\\n\"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \\\naef0::3 udp port 90\" | uniq | wc -l)\n    test $c -ge 1\n])\n\nkill $(pidof tcpdump)\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([IPv6 prefix delegation - distributed router])\nAT_SKIP_IF([test $HAVE_DHCPD = no])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_KEYWORDS([ovn-ipv6-prefix_d])\n\nOVN_TEST_IPV6_PREFIX_DELEGATION(DGP)\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([IPv6 prefix delegation - gw router])\nAT_SKIP_IF([test $HAVE_DHCPD = no])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_KEYWORDS([ovn-ipv6-prefix_d])\n\nOVN_TEST_IPV6_PREFIX_DELEGATION(GR)\nAT_CLEANUP\n])\n\n# Tests that when an established connection sends TCP reset,\n# the conntrack entry is not in established state.\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([conntrack TCP reset])\nAT_KEYWORDS([conntrack])\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\n\novn-nbctl lsp-add sw0 rst-p1\novn-nbctl lsp-set-addresses rst-p1 \"50:54:00:00:00:03\"\novn-nbctl lsp-set-port-security rst-p1 \"50:54:00:00:00:03\"\n\novn-nbctl lsp-add sw0 rst-p2\novn-nbctl lsp-set-addresses rst-p2 \"50:54:00:00:00:04 10.0.0.4\"\novn-nbctl lsp-set-port-security rst-p2 \"50:54:00:00:00:04 10.0.0.4\"\n\n# Create port group and ACLs for sw0 ports.\novn-nbctl pg-add pg0_drop rst-p1 rst-p2\novn-nbctl acl-add pg0_drop from-lport 1001 \"inport == @pg0_drop && ip\" drop\novn-nbctl acl-add pg0_drop to-lport 1001 \"outport == @pg0_drop && ip\" drop\n\novn-nbctl pg-add pg0 rst-p1 rst-p2\novn-nbctl acl-add pg0 from-lport 1002 \"inport == @pg0 && ip4\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && icmp4\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80\" allow-related\novn-nbctl acl-add pg0 to-lport 1002 \"outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80\" allow-related\n\n# Create a logical router and attach to logical switch.\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\novn-nbctl lsp-add sw0 sw0-lr0\novn-nbctl lsp-set-type sw0-lr0 router\novn-nbctl lsp-set-addresses sw0-lr0 router\novn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\novn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80\novn-nbctl --wait=sb ls-lb-add sw0 lb1\novn-nbctl --wait=sb lr-lb-add lr0 lb1\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(rst-p1)\nADD_VETH(rst-p1, rst-p1, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(rst-p2)\nADD_VETH(rst-p2, rst-p2, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up rst-p1) = xup])\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up rst-p2) = xup])\n\n# Start webservers in 'rst-p1'.\nOVS_START_L7([rst-p1], [http])\n\nNS_CHECK_EXEC([rst-p2], [$PYTHON $srcdir/test-tcp-rst.py --dst-port 80 --dst-ip 10.0.0.10])\n\n# When tcp reset is sent, conntrack entry should be in the state - CLOSED or CLOSING.\n# But there is a bug where tcp reset packet was not sent to the conntrack.\n# This test case checks that the tcp reset packet is sent to conntrack\n# and the state is not in established state.\nAT_CHECK([\n    ct_est_count=$(ovs-appctl dpctl/dump-conntrack | grep 10.0.0.10 | grep state=ESTABLISHED -c)\n    test $ct_est_count -eq 0\n\n    ct_est_count=$(ovs-appctl dpctl/dump-conntrack | grep 10.0.0.10 | grep state='CLOS\\|TIME_WAIT' -c)\n    test $ct_est_count -eq 1\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/Service monitor not found.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Load balancer for container ports])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1-lbc\novn-nbctl lsp-set-addresses sw0-port1 \"10:54:00:00:00:03 10.0.0.3\"\n\novn-nbctl lsp-add sw0 sw0-p2-lbc\novn-nbctl lsp-set-addresses sw0-port2 \"10:54:00:00:00:04 10.0.0.4\"\n\novn-nbctl ls-add sw1\novn-nbctl lsp-add sw1 sw1-port1 sw0-p1-lbc 10\novn-nbctl lsp-set-addresses sw1-port1 \"40:54:00:00:00:03 20.0.0.3\"\n\novn-nbctl lsp-add sw1 sw1-port2 sw0-p2-lbc 20\novn-nbctl lsp-set-addresses sw1-port2 \"40:54:00:00:00:04 20.0.0.4\"\n\n\novn-nbctl lr-add lr0\novn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\novn-nbctl lsp-add sw1 sw1-lr0\novn-nbctl lsp-set-type sw1-lr0 router\novn-nbctl lsp-set-addresses sw1-lr0 router\novn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\n\novn-nbctl ls-add sw2\novn-nbctl lsp-add sw2 sw2-port1\novn-nbctl lsp-set-addresses sw2-port1 \"50:54:00:00:00:03 30.0.0.3\"\n\novn-nbctl lrp-add lr0 lr0-sw2 00:00:00:00:ff:03 30.0.0.1/24\novn-nbctl lsp-add sw2 sw2-lr0\novn-nbctl lsp-set-type sw2-lr0 router\novn-nbctl lsp-set-addresses sw2-lr0 router\novn-nbctl lsp-set-options sw2-lr0 router-port=lr0-sw2\n\n\novn-nbctl lb-add lb0 \"30.0.0.10:80\" \"20.0.0.4:80\"\n\novn-nbctl ls-lb-add sw1 lb0\novn-nbctl ls-lb-add sw2 lb0\n\nADD_NAMESPACES(sw0-p1-lbc)\nADD_VETH(sw0-p1-lbc, sw0-p1-lbc, br-int, \"10.0.0.3/24\", \"10:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw0-p2-lbc)\nADD_VETH(sw0-p2-lbc, sw0-p2-lbc, br-int, \"10.0.0.4/24\", \"10:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\n# Create the interface for lport sw1-port1\nNS_CHECK_EXEC([sw0-p1-lbc], [ip link add link sw0-p1-lbc name sw1p1 type vlan id 10], [0])\nNS_CHECK_EXEC([sw0-p1-lbc], [ip link set sw1p1 address 40:54:00:00:00:03], [0])\nNS_CHECK_EXEC([sw0-p1-lbc], [ip link set sw1p1 up], [0])\nNS_CHECK_EXEC([sw0-p1-lbc], [ip addr add 20.0.0.3/24 dev sw1p1], [0])\nNS_CHECK_EXEC([sw0-p1-lbc], [ip route delete default via 10.0.0.1 dev sw0-p1-lbc], [0])\nNS_CHECK_EXEC([sw0-p1-lbc], [ip route add default via 20.0.0.1 dev sw1p1], [0])\n\n# Create the interface for lport sw1-port2\nNS_CHECK_EXEC([sw0-p2-lbc], [ip link add link sw0-p2-lbc name sw1p2 type vlan id 20], [0])\nNS_CHECK_EXEC([sw0-p2-lbc], [ip link set sw1p2 address 40:54:00:00:00:04], [0])\nNS_CHECK_EXEC([sw0-p2-lbc], [ip link set sw1p2 up], [0])\nNS_CHECK_EXEC([sw0-p2-lbc], [ip addr add 20.0.0.4/24 dev sw1p2], [0])\nNS_CHECK_EXEC([sw0-p2-lbc], [ip route delete default via 10.0.0.1 dev sw0-p2-lbc], [0])\nNS_CHECK_EXEC([sw0-p2-lbc], [ip route add default via 20.0.0.1 dev sw1p2], [0])\n\n# Start nc server on sw1p2 (sw0-p2-lbc is the parent)\nNETNS_DAEMONIZE([sw0-p2-lbc], [nc -l -k 20.0.0.4 80], [nc0.pid])\n\n# Send the packet to backend\nNS_CHECK_EXEC([sw0-p1-lbc], [nc -z 20.0.0.4 80], [0], [ignore], [ignore])\n\n# Send the packet to VIP.\nNS_CHECK_EXEC([sw0-p1-lbc], [nc -z 30.0.0.10 80], [0], [ignore], [ignore])\n\n# Now add an ACL in sw1.\novn-nbctl --wait=hv acl-add sw1 to-lport 2002 \"ip\" allow-related\n# Send the packet to backend\nNS_CHECK_EXEC([sw0-p1-lbc], [nc -z 20.0.0.4 80], [0], [ignore], [ignore])\n\n# Send the packet to VIP.\nNS_CHECK_EXEC([sw0-p1-lbc], [nc -z 30.0.0.10 80], [0], [ignore], [ignore])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancer and firewall tuple conflict IPv4])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nOVS_CHECK_CT_ZERO_SNAT()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 1 logical switch connetected to one logical router.\n# 2 VMs, one used as backend for a load balancer.\n\ncheck ovn-nbctl                                                  \\\n    -- lr-add rtr                                                \\\n    -- lrp-add rtr rtr-ls 00:00:00:00:01:00 42.42.42.1/24        \\\n    -- ls-add ls                                                 \\\n    -- lsp-add ls ls-rtr                                         \\\n    -- lsp-set-addresses ls-rtr 00:00:00:00:01:00                \\\n    -- lsp-set-type ls-rtr router                                \\\n    -- lsp-set-options ls-rtr router-port=rtr-ls                 \\\n    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \\\n    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \\\n    -- lb-add lb-test 66.66.66.66:666 42.42.42.2:4242 tcp        \\\n    -- ls-lb-add ls lb-test\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"42.42.42.2/24\", \"00:00:00:00:00:01\", \"42.42.42.1\")\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"42.42.42.3/24\", \"00:00:00:00:00:02\", \"42.42.42.1\")\n\n# Wait for ovn-controller to catch up.\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\n# Start IPv4 TCP server on vm1.\nNETNS_DAEMONIZE([vm1], [nc -k -l 42.42.42.2 4242], [nc-vm1.pid])\n\n# Make sure connecting to the VIP works.\nNS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -p 2000 -z], [0], [ignore], [ignore])\n\n# Start IPv4 TCP connection to VIP from vm2.\nNS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -p 2001 -z], [0], [ignore], [ignore])\n\n# Check conntrack.  We expect two entries:\n# - one in vm1's zone (firewall)\n# - one in vm2's zone (dnat)\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \\\ngrep \"orig=.src=42\\.42\\.42\\.3\" |                                    \\\nsed -e 's/port=2001/port=<clnt_s_port>/g'                           \\\n    -e 's/sport=4242,dport=[[0-9]]\\+/sport=4242,dport=<rnd_port>/g' \\\n    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \\\n    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl\ntcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=42.42.42.3,dst=66.66.66.66,sport=<clnt_s_port>,dport=666),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Start IPv4 TCP connection to backend IP from vm2 which would require\n# additional source port translation to avoid a tuple conflict.\nNS_CHECK_EXEC([vm2], [nc 42.42.42.2 4242 -p 2001 -z], [0], [ignore], [ignore])\n\n# Check conntrack.  We expect three entries:\n# - one in vm1's zone (firewall) - reused from the previous connection.\n# - one in vm2's zone (dnat) - still in TIME_WAIT after the previous connection.\n# - one in vm2's zone (firewall + additional all-zero SNAT)\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \\\ngrep \"orig=.src=42\\.42\\.42\\.3\" |                                    \\\nsed -e 's/port=2001/port=<clnt_s_port>/g'                           \\\n    -e 's/sport=4242,dport=[[0-9]]\\+/sport=4242,dport=<rnd_port>/g' \\\n    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \\\n    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl\ntcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<rnd_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=42.42.42.3,dst=66.66.66.66,sport=<clnt_s_port>,dport=666),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancer and firewall tuple conflict IPv6])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nOVS_CHECK_CT_ZERO_SNAT()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 1 logical switch connetected to one logical router.\n# 2 VMs, one used as backend for a load balancer.\n\ncheck ovn-nbctl                                                  \\\n    -- lr-add rtr                                                \\\n    -- lrp-add rtr rtr-ls 00:00:00:00:01:00 4242::1/64           \\\n    -- ls-add ls                                                 \\\n    -- lsp-add ls ls-rtr                                         \\\n    -- lsp-set-addresses ls-rtr 00:00:00:00:01:00                \\\n    -- lsp-set-type ls-rtr router                                \\\n    -- lsp-set-options ls-rtr router-port=rtr-ls                 \\\n    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \\\n    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \\\n    -- lb-add lb-test [[6666::1]]:666 [[4242::2]]:4242 tcp       \\\n    -- ls-lb-add ls lb-test\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"4242::2/64\", \"00:00:00:00:00:01\", \"4242::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vm1 ip a | grep 4242::2 | grep tentative)\" = \"\"])\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"4242::3/64\", \"00:00:00:00:00:02\", \"4242::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vm2 ip a | grep 4242::3 | grep tentative)\" = \"\"])\n\n# Wait for ovn-controller to catch up.\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\n# Start IPv6 TCP server on vm1.\nNETNS_DAEMONIZE([vm1], [nc -k -l 4242::2 4242], [nc-vm1.pid])\n\n# Make sure connecting to the VIP works.\nNS_CHECK_EXEC([vm2], [nc 6666::1 666 -p 2000 -z], [0], [ignore], [ignore])\n\n# Start IPv6 TCP connection to VIP from vm2.\nNS_CHECK_EXEC([vm2], [nc 6666::1 666 -p 2001 -z], [0], [ignore], [ignore])\n\n# Check conntrack.  We expect two entries:\n# - one in vm1's zone (firewall)\n# - one in vm2's zone (dnat)\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \\\ngrep \"orig=.src=4242::3\" |                                         \\\nsed -e 's/port=2001/port=<clnt_s_port>/g'                           \\\n    -e 's/sport=4242,dport=[[0-9]]\\+/sport=4242,dport=<rnd_port>/g' \\\n    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \\\n    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl\ntcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=4242::3,dst=6666::1,sport=<clnt_s_port>,dport=666),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Start IPv6 TCP connection to backend IP from vm2 which would require\n# additional source port translation to avoid a tuple conflict.\nNS_CHECK_EXEC([vm2], [nc 4242::2 4242 -p 2001 -z], [0], [ignore], [ignore])\n\n# Check conntrack.  We expect three entries:\n# - one in vm1's zone (firewall) - reused from the previous connection.\n# - one in vm2's zone (dnat) - still in TIME_WAIT after the previous connection.\n# - one in vm2's zone (firewall + additional all-zero SNAT)\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \\\ngrep \"orig=.src=4242::3\" |                                          \\\nsed -e 's/port=2001/port=<clnt_s_port>/g'                           \\\n    -e 's/sport=4242,dport=[[0-9]]\\+/sport=4242,dport=<rnd_port>/g' \\\n    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \\\n    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl\ntcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<rnd_port>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=4242::3,dst=6666::1,sport=<clnt_s_port>,dport=666),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CLEANUP\n])\n\n# When a lport is released on a chassis, ovn-controller was\n# not clearing some of the flowss in the table 33 leading\n# to packet drops if ct() is hit.\n# Make sure that those flows are cleared properly.\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Test packet drops due to incorrect flows in physical table 33])\nAT_KEYWORDS([lb])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1-f\novn-nbctl lsp-set-addresses sw0-p1-f \"10:54:00:00:00:03 10.0.0.3\"\n\novn-nbctl lsp-add sw0 sw0-p2-f\novn-nbctl lsp-set-addresses sw0-p2-f \"10:54:00:00:00:04 10.0.0.4\"\n\novn-nbctl lsp-add sw0 sw0-p3-f\novn-nbctl lsp-set-addresses sw0-p3-f \"10:54:00:00:00:05 10.0.0.5\"\n\n# Add ACL with allow-ralated so that conntrack is hit.\n\novn-nbctl acl-add sw0 from-lport 1002 \"ip\" allow-related\novn-nbctl acl-add sw0 to-lport 1002 \"ip\" allow-related\n\nADD_NAMESPACES(sw0-p1-f)\nADD_VETH(sw0-p1-f, sw0-p1-f, br-int, \"10.0.0.3/24\", \"10:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw0-p2-f)\nADD_VETH(sw0-p2-f, sw0-p2-f, br-int, \"10.0.0.4/24\", \"10:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw0-p3-f)\nADD_VETH(sw0-p3-f, sw0-p3-f, br-int, \"10.0.0.5/24\", \"10:54:00:00:00:05\", \\\n         \"10.0.0.1\")\n\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1-f) = xup])\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2-f) = xup])\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xup])\n\n# Send ping from sw0-p1-f to sw0-p3-f\nNS_CHECK_EXEC([sw0-p1-f], [ping -q -c 3 -i 0.3 -w 2 10.0.0.5 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\novs-vsctl remove interface ovs-sw0-p2-f external_ids iface-id\novs-vsctl remove interface ovs-sw0-p3-f external_ids iface-id\n\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2-f) = xdown])\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xdown])\n\novs-vsctl set interface ovs-sw0-p3-f external_ids:iface-id=sw0-p3-f\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xup])\n\n# Send ping from sw0-p1-f to sw0-p3-f again and it should work.\nNS_CHECK_EXEC([sw0-p1-f], [ping -q -c 3 -i 0.3 -w 2 10.0.0.5 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ECMP symmetric reply])\nAT_KEYWORDS([ecmp])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Alice is connected to gateway router R1. R1 is connected to two \"external\"\n# routers, R2 and R3 via an \"ext\" switch.\n# Bob is connected to both R2 and R3. R1 contains two ECMP routes, one through R2\n# and one through R3, to Bob.\n#\n#     alice -- R1 -- ext ---- R2\n#                     |         \\\n#                     |           bob\n#                     |         /\n#                     + ----- R3\n#\n# For this test, Bob sends request traffic through R2 to Alice. We want to ensure that\n# all response traffic from Alice is routed through R2 as well.\n\novn-nbctl create Logical_Router name=R1 options:chassis=hv1\novn-nbctl create Logical_Router name=R2\novn-nbctl create Logical_Router name=R3\n\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add ext\n\n# connect alice to R1\novn-nbctl lrp-add R1 alice 00:00:01:01:02:03 10.0.0.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses='\"00:00:01:01:02:03\"'\n\n# connect bob to R2\novn-nbctl lrp-add R2 R2_bob 00:00:02:01:02:03 172.16.0.2/16\novn-nbctl lsp-add bob rp2-bob -- set Logical_Switch_Port rp2-bob \\\n    type=router options:router-port=R2_bob addresses='\"00:00:02:01:02:03\"'\n\n# connect bob to R3\novn-nbctl lrp-add R3 R3_bob 00:00:02:01:02:04 172.16.0.3/16\novn-nbctl lsp-add bob rp3-bob -- set Logical_Switch_Port rp3-bob \\\n    type=router options:router-port=R3_bob addresses='\"00:00:02:01:02:04\"'\n\n# Connect R1 to ext\novn-nbctl lrp-add R1 R1_ext 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add ext r1-ext -- set Logical_Switch_Port r1-ext \\\n    type=router options:router-port=R1_ext addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to ext\novn-nbctl lrp-add R2 R2_ext 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add ext r2-ext -- set Logical_Switch_Port r2-ext \\\n    type=router options:router-port=R2_ext addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to ext\novn-nbctl lrp-add R3 R3_ext 00:00:04:01:02:05 20.0.0.3/24\novn-nbctl lsp-add ext r3-ext -- set Logical_Switch_Port r3-ext \\\n    type=router options:router-port=R3_ext addresses='\"00:00:04:01:02:05\"'\n\n# Install ECMP routes for alice.\novn-nbctl --ecmp-symmetric-reply --policy=\"src-ip\" lr-route-add R1 10.0.0.0/24 20.0.0.2\novn-nbctl --ecmp-symmetric-reply --policy=\"src-ip\" lr-route-add R1 10.0.0.0/24 20.0.0.3\n\n# Static Routes\novn-nbctl lr-route-add R2 10.0.0.0/24 20.0.0.1\novn-nbctl lr-route-add R3 10.0.0.0/24 20.0.0.1\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"10.0.0.2/24\", \"f0:00:00:01:02:04\", \\\n         \"10.0.0.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 10.0.0.2\"\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\nADD_VETH(bob1, bob1, br-int, \"172.16.0.1/16\", \"f0:00:00:01:02:06\", \\\n         \"172.16.0.2\")\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 172.16.0.1\"\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovs-ofctl dump-flows br-int'\n\nNETNS_DAEMONIZE([alice1], [nc -l -k 80], [alice1.pid])\nNS_CHECK_EXEC([bob1], [nc -z 10.0.0.2 80], [0])\n\n# Ensure conntrack entry is present. We should not try to predict\n# the tunnel key for the output port, so we strip it from the labels\n# and just ensure that the known ethernet address is present.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' |\nsed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.0.1,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x401020400000000,protoinfo=(state=<cleared>)\n])\n\n# Ensure datapaths show conntrack states as expected\n# Like with conntrack entries, we shouldn't try to predict\n# port binding tunnel keys. So omit them from expected labels.\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x401020400000000/.*)' -c], [0], [dnl\n1\n])\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x401020400000000)' -c], [0], [dnl\n1\n])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# Change bob1 L2 address anche check the reply is properly updated.\novn-nbctl set Logical_Router_Port R2_ext mac='\"00:00:10:01:02:04\"'\novn-nbctl set Logical_Switch_Port r2-ext \\\n     type=router options:router-port=R2_ext addresses='\"00:00:10:01:02:04\"'\n\n# Wait for ovn-controller before sending traffic\novn-nbctl --wait=hv sync\n\nNS_CHECK_EXEC([bob1], [nc -z 10.0.0.2 80], [0])\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x1001020400000000/.*)' -c], [0], [dnl\n1\n])\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x1001020400000000)' -c], [0], [dnl\n1\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x1001020400000000 | FORMAT_CT(172.16.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' |\nsed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.0.1,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000,protoinfo=(state=<cleared>)\n])\n# Check entries in table 76 and 77 expires w/o traffic\nOVS_WAIT_UNTIL([\ntest $(ovs-ofctl dump-flows br-int | grep -c 'table=76, n_packets') -eq 0\n])\nOVS_WAIT_UNTIL([\ntest $(ovs-ofctl dump-flows br-int | grep -c 'table=77, n_packets') -eq 0\n])\n\novs-ofctl dump-flows br-int\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ECMP IPv6 symmetric reply])\nAT_KEYWORDS([ecmp])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Alice is connected to gateway router R1. R1 is connected to two \"external\"\n# routers, R2 and R3 via an \"ext\" switch.\n# Bob is connected to both R2 and R3. R1 contains two ECMP routes, one through R2\n# and one through R3, to Bob.\n#\n#     alice -- R1 -- ext ---- R2\n#                     |         \\\n#                     |           bob\n#                     |         /\n#                     + ----- R3\n#\n# For this test, Bob sends request traffic through R2 to Alice. We want to ensure that\n# all response traffic from Alice is routed through R2 as well.\n\novn-nbctl create Logical_Router name=R1 options:chassis=hv1\novn-nbctl create Logical_Router name=R2\novn-nbctl create Logical_Router name=R3\n\novn-nbctl ls-add alice\novn-nbctl ls-add bob\novn-nbctl ls-add ext\n\n# connect alice to R1\novn-nbctl lrp-add R1 alice 00:00:01:01:02:03 fd01::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses='\"00:00:01:01:02:03\"'\n\n# connect bob to R2\novn-nbctl lrp-add R2 R2_bob 00:00:02:01:02:03 fd07::2/64\novn-nbctl lsp-add bob rp2-bob -- set Logical_Switch_Port rp2-bob \\\n    type=router options:router-port=R2_bob addresses='\"00:00:02:01:02:03\"'\n\n# connect bob to R3\novn-nbctl lrp-add R3 R3_bob 00:00:02:01:02:04 fd07::3/64\novn-nbctl lsp-add bob rp3-bob -- set Logical_Switch_Port rp3-bob \\\n    type=router options:router-port=R3_bob addresses='\"00:00:02:01:02:04\"'\n\n# Connect R1 to ext\novn-nbctl lrp-add R1 R1_ext 00:00:04:01:02:03 fd02::1/64\novn-nbctl lsp-add ext r1-ext -- set Logical_Switch_Port r1-ext \\\n    type=router options:router-port=R1_ext addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to ext\novn-nbctl lrp-add R2 R2_ext 00:00:04:01:02:04 fd02::2/64\novn-nbctl lsp-add ext r2-ext -- set Logical_Switch_Port r2-ext \\\n    type=router options:router-port=R2_ext addresses='\"00:00:04:01:02:04\"'\n\n# Connect R3 to ext\novn-nbctl lrp-add R3 R3_ext 00:00:04:01:02:05 fd02::3/64\novn-nbctl lsp-add ext r3-ext -- set Logical_Switch_Port r3-ext \\\n    type=router options:router-port=R3_ext addresses='\"00:00:04:01:02:05\"'\n\n# Install ECMP routes for alice.\novn-nbctl --ecmp-symmetric-reply --policy=\"src-ip\" lr-route-add R1 fd01::/126 fd02::2\novn-nbctl --ecmp-symmetric-reply --policy=\"src-ip\" lr-route-add R1 fd01::/126 fd02::3\n\n# Static Routes\novn-nbctl lr-route-add R2 fd01::/64 fd02::1\novn-nbctl lr-route-add R3 fd01::/64 fd02::1\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\n# Only send 1 router solicitation as any additional ones can cause datapath\n# flows to get evicted, causing unexpected failures below.\nNS_CHECK_EXEC([alice1], [sysctl -w net.ipv6.conf.default.router_solicitations=1], [0], [dnl\nnet.ipv6.conf.default.router_solicitations = 1\n])\nADD_VETH(alice1, alice1, br-int, \"fd01::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd01::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec alice1 ip a | grep fd01::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd01::2\"\n# Add neighbour MAC address to avoid sending IPv6 NS messages which could\n# cause datapath flows to be evicted\nNS_CHECK_EXEC([alice1], [ip -6 neigh add fd01::1 lladdr 00:00:01:01:02:03 dev alice1], [0])\n\n# Logical port 'bob1' in switch 'bob'.\nADD_NAMESPACES(bob1)\n# Only send 1 router solicitation as any additional ones can cause datapath\n# flows to get evicted, causing unexpected failures below.\nNS_CHECK_EXEC([bob1], [sysctl -w net.ipv6.conf.default.router_solicitations=1], [0], [dnl\nnet.ipv6.conf.default.router_solicitations = 1\n])\nADD_VETH(bob1, bob1, br-int, \"fd07::1/64\", \"f0:00:00:01:02:06\", \\\n         \"fd07::2\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec bob1 ip a | grep fd07::1 | grep tentative)\" = \"\"])\n# Add neighbour MAC addresses to avoid sending IPv6 NS messages which could\n# cause datapath flows to be evicted\nNS_CHECK_EXEC([bob1], [ip -6 neigh add fd07::2 lladdr 00:00:02:01:02:03 dev bob1], [0])\nNS_CHECK_EXEC([bob1], [ip -6 neigh add fd07::3 lladdr 00:00:01:01:02:04 dev bob1], [0])\n\novn-nbctl lsp-add bob bob1 \\\n-- lsp-set-addresses bob1 \"f0:00:00:01:02:06 fd07::1\"\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovs-ofctl dump-flows br-int'\n\nNETNS_DAEMONIZE([alice1], [nc -6 -l -k 80], [alice1.pid])\nNS_CHECK_EXEC([bob1], [nc -6 -z fd01::2 80], [0])\n\n# Ensure datapaths show conntrack states as expected\n# Like with conntrack entries, we shouldn't try to predict\n# port binding tunnel keys. So omit them from expected labels.\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x401020400000000/.*)' -c], [0], [dnl\n1\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x401020400000000)' -c], [0], [dnl\n1\n])\n\n# Ensure conntrack entry is present. We should not try to predict\n# the tunnel key for the output port, so we strip it from the labels\n# and just ensure that the known ethernet address is present.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd01::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' |\nsed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd07::1,dst=fd01::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd07::1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x401020400000000,protoinfo=(state=<cleared>)\n])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# Change bob1 L2 address anche check the reply is properly updated.\novn-nbctl set Logical_Router_Port R2_ext mac='\"00:00:10:01:02:04\"'\novn-nbctl --wait=hv set Logical_Switch_Port r2-ext \\\n     type=router options:router-port=R2_ext addresses='\"00:00:10:01:02:04\"'\n\nNS_CHECK_EXEC([bob1], [nc -6 -z fd01::2 80], [0])\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x1001020400000000/.*)' -c], [0], [dnl\n1\n])\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x1001020400000000)' -c], [0], [dnl\n1\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x1001020400000000 | FORMAT_CT(fd01::2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' |\nsed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd07::1,dst=fd01::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd07::1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000,protoinfo=(state=<cleared>)\n])\n\n# Check entries in table 76 and 77 expires w/o traffic\nOVS_WAIT_UNTIL([\ntest $(ovs-ofctl dump-flows br-int | grep -c 'table=76, n_packets') -eq 0\n])\nOVS_WAIT_UNTIL([\ntest $(ovs-ofctl dump-flows br-int | grep -c 'table=77, n_packets') -eq 0\n])\n\novs-ofctl dump-flows br-int\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([controller I-P handling when ovs iface ofport is -1])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-port1\novn-nbctl lsp-set-addresses sw0-port1 \"10:54:00:00:00:03 10.0.0.3\"\n\novs-vsctl add-port br-int p1 -- \\\n    set Interface p1 external_ids:iface-id=sw0-port1 -- \\\n    set Interface p1 type=internal\n\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-port1) = xup])\novs-vsctl set interface p1 type=\\\"\\\"\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-port1) = xdown])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/could not open network device p1*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ARP resolution for SNAT IP])\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\nADD_BR([br-ext])\n\novs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add sw0\novn-nbctl ls-add public\n\novn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 \\\n    -- lrp-set-gateway-chassis rp-public hv1\n\novn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\n\novn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \\\n    type=router options:router-port=rp-public \\\n    -- lsp-set-addresses public-rp router\n\novn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.1.0/24\novn-nbctl lr-nat-add R1 snat 172.16.1.20 192.168.1.2\n\nADD_NAMESPACES(sw01-x)\nADD_VETH(sw01-x, sw01-x, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add sw0 sw01-x \\\n    -- lsp-set-addresses sw01-x \"f0:00:00:01:02:03 192.168.1.2\"\n\nOVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw01-x) = xup])\n\nADD_NAMESPACES(ext-foo)\nADD_VETH(ext-foo, ext-foo, br-ext, \"172.16.1.100/24\", \"00:10:10:01:02:13\", \\\n         \"172.16.1.1\")\n\nOVS_WAIT_UNTIL([test \"$(ip netns exec ext-foo ip a | grep fe80 | grep tentative)\" = \"\"])\n\nAT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])\novn-nbctl lsp-add public public1 \\\n        -- lsp-set-addresses public1 unknown \\\n        -- lsp-set-type public1 localnet \\\n        -- lsp-set-options public1 network_name=phynet\n\novn-nbctl --wait=hv sync\n\n# Send ping from sw01-x to ext-foo.\nNS_CHECK_EXEC([sw01-x], [ping -q -c 3 -i 0.3 -w 2 172.16.1.100 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Check conntrack entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.100) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.1.2,dst=172.16.1.100,id=<cleared>,type=8,code=0),reply=(src=172.16.1.100,dst=172.16.1.20,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/.*error receiving.*/d\n/.*terminating with signal 15.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([egress qos])\nAT_KEYWORDS([ovn-egress-qos])\n\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\nADD_BR([br-ext])\n\novs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\n\nADD_NAMESPACES(sw01)\nADD_VETH(sw01, sw01, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\")\novn-nbctl lsp-add sw0 sw01 \\\n    -- lsp-set-addresses sw01 \"f0:00:00:01:02:03 192.168.1.2\"\n\nADD_NAMESPACES(public)\nADD_VETH(public, public, br-ext, \"192.168.2.2/24\", \"f0:00:00:01:02:05\")\n\nAT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])\novn-nbctl lsp-add sw0 public \\\n        -- lsp-set-addresses public unknown \\\n        -- lsp-set-type public localnet \\\n        -- lsp-set-options public network_name=phynet\n\nAT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_min_rate=200000])\nAT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_max_rate=300000])\nAT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_burst=3000000])\nAT_CHECK([ovs-vsctl set interface ovs-public external-ids:ovn-egress-iface=true])\nOVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-public'])\nOVS_WAIT_UNTIL([tc class show dev ovs-public | \\\n                grep -q 'class htb .* rate 200Kbit ceil 300Kbit burst 375000b cburst 375000b'])\n\n\nAT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_max_rate=300000])\nOVS_WAIT_UNTIL([tc class show dev ovs-public | \\\n                grep -q 'class htb .* rate 200Kbit ceil 34359Mbit burst 375000b .*'])\n\nAT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_min_rate=200000])\nAT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_burst=3000000])\nOVS_WAIT_UNTIL([test \"$(tc qdisc show | grep 'htb 1: dev ovs-public')\" = \"\"])\n\nkill $(pidof ovn-controller)\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/.*error receiving.*/d\n/.*terminating with signal 15.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([BFD])\nAT_SKIP_IF([test $HAVE_BFDD_BEACON = no])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_KEYWORDS([ovn-bfd])\n\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\nADD_BR([br-ext])\n\ncheck ovs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\ncheck ovs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add R1\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl ls-add public\n\ncheck ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24\ncheck ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 1000::a/64 \\\n    -- lrp-set-gateway-chassis rp-public hv1\n\ncheck ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\ncheck ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \\\n    type=router options:router-port=rp-sw1 \\\n    -- lsp-set-addresses sw1-rp router\n\ncheck ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \\\n    type=router options:router-port=rp-public \\\n    -- lsp-set-addresses public-rp router\n\nADD_NAMESPACES(sw01)\nADD_VETH(sw01, sw01, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\ncheck ovn-nbctl lsp-add sw0 sw01 \\\n    -- lsp-set-addresses sw01 \"f0:00:00:01:02:03 192.168.1.2\"\n\nADD_NAMESPACES(sw11)\nADD_VETH(sw11, sw11, br-int, \"192.168.2.2/24\", \"f0:00:00:02:02:03\", \\\n         \"192.168.2.1\")\ncheck ovn-nbctl lsp-add sw1 sw11 \\\n    -- lsp-set-addresses sw11 \"f0:00:00:02:02:03 192.168.2.2\"\n\nADD_NAMESPACES(server)\nNS_CHECK_EXEC([server], [ip link set dev lo up])\nADD_VETH(s1, server, br-ext, \"172.16.1.50/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\nNS_CHECK_EXEC([server], [ip addr add 1000::b/64 dev s1])\n\nAT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])\ncheck ovn-nbctl lsp-add public public1 \\\n        -- lsp-set-addresses public1 unknown \\\n        -- lsp-set-type public1 localnet \\\n        -- lsp-set-options public1 network_name=phynet\n\nNS_CHECK_EXEC([server], [bfdd-beacon --listen=172.16.1.50], [0])\nNS_CHECK_EXEC([server], [bfdd-control allow 172.16.1.1], [0], [dnl\nAllowing connections from 172.16.1.1\n])\n\ncheck ovn-nbctl --bfd lr-route-add R1 100.0.0.0/8 172.16.1.50 rp-public\nuuid=$(fetch_column nb:bfd _uuid logical_port=\"rp-public\")\nroute_uuid=$(fetch_column nb:logical_router_static_route _uuid ip_prefix=\"100.0.0.0/8\")\ncheck ovn-nbctl --wait=hv sync\n\nwait_column \"up\" nb:bfd status logical_port=rp-public\nOVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 | grep 'match=(ip4.dst == 100.0.0.0/8)' | grep -q 172.16.1.50])\n\n# un-associate the bfd connection and the static route\ncheck ovn-nbctl clear logical_router_static_route $route_uuid bfd\nwait_column \"admin_down\" nb:bfd status logical_port=rp-public\nOVS_WAIT_UNTIL([ip netns exec server bfdd-control status | grep -qi state=Down])\nNS_CHECK_EXEC([server], [tcpdump -nni s1 udp port 3784 -Q in > bfd.pcap &])\nsleep 5\nkill $(pidof tcpdump)\nAT_CHECK([grep -qi bfd bfd.pcap],[1])\n\n# restart the connection\ncheck ovn-nbctl set logical_router_static_route $route_uuid bfd=$uuid\nwait_column \"up\" nb:bfd status logical_port=rp-public\n\n# switch to gw router configuration\ncheck ovn-nbctl clear logical_router_static_route $route_uuid bfd\nwait_column \"admin_down\" nb:bfd status logical_port=rp-public\nOVS_WAIT_UNTIL([ip netns exec server bfdd-control status | grep -qi state=Down])\ncheck ovn-nbctl clear logical_router_port rp-public gateway_chassis\ncheck ovn-nbctl set logical_router R1 options:chassis=hv1\ncheck ovn-nbctl set logical_router_static_route $route_uuid bfd=$uuid\nwait_column \"up\" nb:bfd status logical_port=rp-public\n\n# stop bfd endpoint\nNS_CHECK_EXEC([server], [bfdd-control stop], [0], [dnl\nstopping\n])\n\nwait_column \"down\" nb:bfd status logical_port=rp-public\nOVS_WAIT_UNTIL([test \"$(ovn-sbctl dump-flows R1 | grep 'match=(ip4.dst == 100.0.0.0/8)' | grep 172.16.1.50)\" = \"\"])\n\n# remove bfd entry\novn-nbctl destroy bfd $uuid\ncheck_row_count bfd 0\nNS_CHECK_EXEC([server], [tcpdump -nni s1 udp port 3784 -Q in > bfd.pcap &])\nsleep 5\nkill $(pidof tcpdump)\nAT_CHECK([grep -qi bfd bfd.pcap],[1])\n\nuuid_v6=$(ovn-nbctl create bfd logical_port=rp-public dst_ip=\\\"1000::b\\\")\ncheck ovn-nbctl lr-route-add R1 2000::/64 1000::b\nroute_uuid_v6=$(fetch_column nb:logical_router_static_route _uuid ip_prefix=\\\"2000::/64\\\")\novn-nbctl set logical_router_static_route $route_uuid_v6 bfd=$uuid_v6\ncheck ovn-nbctl --wait=hv sync\nNS_CHECK_EXEC([server], [bfdd-beacon --listen=1000::b], [0])\nNS_CHECK_EXEC([server], [bfdd-control allow 1000::a], [0], [dnl\nAllowing connections from 1000::a\n])\n\nwait_column \"up\" nb:bfd status logical_port=rp-public\novn-nbctl destroy bfd $uuid_v6\n\nkill $(pidof ovn-controller)\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/.*error receiving.*/d\n/.*terminating with signal 15.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([No ct_state matches in dp flows when no ACLs in an LS])\nAT_KEYWORDS([no ct_state match])\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:03\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:03\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:04 10.0.0.4\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:04 10.0.0.4\"\n\n\n# Create the second logical switch with one port and configure some ACLs.\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl lsp-add sw1 sw1-p1\n\n# Create port group and ACLs for sw1 ports.\ncheck ovn-nbctl pg-add pg1 sw1-p1\ncheck ovn-nbctl acl-add pg1 from-lport 1002 \"ip\" allow-related\ncheck ovn-nbctl acl-add pg1 to-lport 1002 \"ip\" allow-related\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\n\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\nADD_NAMESPACES(sw1-p1)\nADD_VETH(sw1-p1, sw1-p1, br-int, \"20.0.0.4/24\", \"30:54:00:00:00:04\", \\\n         \"20.0.0.1\")\n\nwait_for_ports_up\n\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\novs-appctl dpctl/dump-flows\n\n# sw1-p1 may send IPv6 traffic.  So filter this out.  Since sw1-p1 has\n# ACLs configured, the datapath flows for the packets from sw1-p1 will have\n# matches on ct_state and ct_label fields.\n# Since sw0 doesn't have any ACLs, there should be no match on ct fields.\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [1], [dnl\n0\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [1], [dnl\n0\n])\n\n# Add an ACL to sw0.\ncheck ovn-nbctl --wait=hv acl-add sw0 to-lport 1002 ip allow-related\n\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\novs-appctl dpctl/dump-flows\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [0], [ignore])\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [0], [ignore])\n\n# Clear ACL for sw0\ncheck ovn-nbctl --wait=hv clear logical_switch sw0 acls\n\ncheck ovs-appctl dpctl/del-flows\n\ncheck ovn-nbctl --wait=hv sync\n\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\novs-appctl dpctl/dump-flows\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [1], [dnl\n0\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [1], [dnl\n0\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DNAT LR hairpin IPv4])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\nstart_daemon ovn-controller\n\n# Logical network:\n# Two VMs\n#   * VM1 with IP address 192.168.100.5\n#   * VM2 with IP address 192.168.100.6\n# The VMs connect to logical switch ls1.\n#\n# An external router with IP address 172.18.1.2. We simulate this with a network namespace.\n# There will be no traffic going here in this test.\n# The external router connects to logical switch ls-pub\n#\n# One logical router (lr1) connects to ls1 and ls-pub. The router port connected to ls-pub is\n# a gateway port.\n#   * The subnet connected to ls1 is 192.168.100.0/24. The Router IP address is 192.168.100.1\n#   * The subnet connected to ls-pub is 172.18.1.0/24. The Router IP address is 172.168.1.1\n# lr1 has the following attributes:\n#   * It has a \"default\" static route that sends traffic out the gateway router port.\n#   * It has a DNAT rule that translates 172.18.2.10 to 192.168.100.6 (VM2)\n#\n# In this test, we want to ensure that a ping from VM1 to IP address 172.18.2.10 reaches VM2.\n\novn-nbctl ls-add ls1\novn-nbctl lsp-add ls1 vm1 -- lsp-set-addresses vm1 \"00:00:00:00:00:05 192.168.100.5\"\novn-nbctl lsp-add ls1 vm2 -- lsp-set-addresses vm2 \"00:00:00:00:00:06 192.168.100.6\"\n\novn-nbctl ls-add ls-pub\novn-nbctl lsp-add ls-pub ext-router -- lsp-set-addresses ext-router \"00:00:00:00:01:02 172.18.1.2\"\n\novn-nbctl lr-add lr1\novn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:00:01 192.168.100.1/24\novn-nbctl lsp-add ls1 ls1-lr1                      \\\n    -- lsp-set-type ls1-lr1 router                 \\\n    -- lsp-set-addresses ls1-lr1 00:00:00:00:00:01 \\\n    -- lsp-set-options ls1-lr1 router-port=lr1-ls1\n\novn-nbctl lrp-add lr1 lr1-ls-pub 00:00:00:00:01:01 172.18.1.1/24\novn-nbctl lrp-set-gateway-chassis lr1-ls-pub hv1\novn-nbctl lsp-add ls-pub ls-pub-lr1                      \\\n    -- lsp-set-type ls-pub-lr1 router                    \\\n    -- lsp-set-addresses ls-pub-lr1 00:00:00:00:01:01    \\\n    -- lsp-set-options ls-pub-lr1 router-port=lr1-ls-pub\n\novn-nbctl lr-nat-add lr1 snat 172.18.1.1 192.168.100.0/24\novn-nbctl lr-nat-add lr1 dnat_and_snat 172.18.2.10 192.168.100.6\novn-nbctl lr-route-add lr1 0.0.0.0/0 172.18.1.2\n\n#ls1_uuid=$(fetch_column Port_Binding datapath logical_port=vm1)\n#ovn-sbctl create MAC_Binding ip=172.18.2.10 datapath=$ls1_uuid logical_port=vm2 mac=\"00:00:00:00:00:06\"\n\nOVN_POPULATE_ARP\novn-nbctl --wait=hv sync\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"192.168.100.5/24\", \"00:00:00:00:00:05\", \\\n         \"192.168.100.1\")\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"192.168.100.6/24\", \"00:00:00:00:00:06\", \\\n         \"192.168.100.1\")\n\nADD_NAMESPACES(ext-router)\nADD_VETH(ext-router, ext-router, br-int, \"172.18.1.2/24\", \"00:00:00:00:01:02\", \\\n         \"172.18.1.1\")\n\n# Let's take a quick look at the logical flows\novn-sbctl lflow-list\n\n# Let's check what ovn-trace says...\novn-trace ls1 'inport == \"vm1\" && eth.src == 00:00:00:00:00:05 && ip4.src == 192.168.100.5 && eth.dst == 00:00:00:00:00:01 && ip4.dst == 172.18.2.10 && ip.ttl == 32'\n\n# A ping from vm1 should hairpin in lr1 and successfully DNAT to vm2\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\ndnat_and_snat_uuid=$(fetch_column nb:NAT _uuid external_ip=172.18.2.10)\novn-nbctl set NAT $dnat_and_snat_uuid options:stateless=true\n\n# A ping from vm1 should hairpin in lr1 and successfully DNAT to vm2\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n# A ping from vm2 should hairpin in lr1 and successfully DNAT to vm2\nNS_CHECK_EXEC([vm2], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nkill $(pidof ovn-controller)\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/.*error receiving.*/d\n/.*terminating with signal 15.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ovn -- Floating IP outside router subnet IPv4])\nAT_KEYWORDS(NAT)\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\nstart_daemon ovn-controller\n\n# Logical network:\n# Two VMs\n#   * VM1 with IP address 192.168.100.5\n#   * VM2 with IP address 192.168.200.5\n#\n# VM1 connects to logical switch ls1. ls1 connects to logical router lr1.\n# VM2 connects to logical switch ls2. ls2 connects to logical router lr2.\n# lr1 and lr2 both connect to logical switch ls-pub.\n# * lr1's interface that connects to ls-pub has IP address 172.18.2.110/24\n# * lr2's interface that connects to ls-pub has IP address 172.18.1.173/24\n#\n# lr1 has the following attributes:\n#   * It has a DNAT rule that translates 172.18.2.11 to 192.168.100.5 (VM1)\n#\n# lr2 has the following attributes:\n#   * It has a DNAT rule that translates 172.18.2.12 to 192.168.200.5 (VM2)\n#\n# In this test, we want to ensure that a ping from VM1 to IP address 172.18.2.12 reaches VM2.\n# When the NAT rules are set up, there should be MAC_Bindings created that allow for traffic\n# to exit lr1, go through ls-pub, and reach the NAT external IP configured on lr2.\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl lsp-add ls1 vm1 -- lsp-set-addresses vm1 \"00:00:00:00:01:05 192.168.100.5\"\n\ncheck ovn-nbctl ls-add ls2\ncheck ovn-nbctl lsp-add ls2 vm2 -- lsp-set-addresses vm2 \"00:00:00:00:02:05 192.168.200.5\"\n\ncheck ovn-nbctl ls-add ls-pub\n\ncheck ovn-nbctl lr-add lr1\ncheck ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:01:01 192.168.100.1/24\ncheck ovn-nbctl lsp-add ls1 ls1-lr1                      \\\n    -- lsp-set-type ls1-lr1 router                 \\\n    -- lsp-set-addresses ls1-lr1 router            \\\n    -- lsp-set-options ls1-lr1 router-port=lr1-ls1\n\ncheck ovn-nbctl lr-add lr2\ncheck ovn-nbctl lrp-add lr2 lr2-ls2 00:00:00:00:02:01 192.168.200.1/24\ncheck ovn-nbctl lsp-add ls2 ls2-lr2                      \\\n    -- lsp-set-type ls2-lr2 router                 \\\n    -- lsp-set-addresses ls2-lr2 router            \\\n    -- lsp-set-options ls2-lr2 router-port=lr2-ls2\n\ncheck ovn-nbctl lrp-add lr1 lr1-ls-pub 00:00:00:00:03:01 172.18.2.110/24\ncheck ovn-nbctl lrp-set-gateway-chassis lr1-ls-pub hv1\ncheck ovn-nbctl lsp-add ls-pub ls-pub-lr1                      \\\n    -- lsp-set-type ls-pub-lr1 router                    \\\n    -- lsp-set-addresses ls-pub-lr1 router               \\\n    -- lsp-set-options ls-pub-lr1 router-port=lr1-ls-pub\n\ncheck ovn-nbctl lrp-add lr2 lr2-ls-pub 00:00:00:00:03:02 172.18.1.173/24\ncheck ovn-nbctl lrp-set-gateway-chassis lr2-ls-pub hv1\ncheck ovn-nbctl lsp-add ls-pub ls-pub-lr2                      \\\n    -- lsp-set-type ls-pub-lr2 router                    \\\n    -- lsp-set-addresses ls-pub-lr2 router               \\\n    -- lsp-set-options ls-pub-lr2 router-port=lr2-ls-pub\n\n# Putting --add-route on these NAT rules means there is no need to\n# add any static routes.\ncheck ovn-nbctl --add-route lr-nat-add lr1 dnat_and_snat 172.18.2.11 192.168.100.5 vm1 00:00:00:00:03:01\ncheck ovn-nbctl --add-route lr-nat-add lr2 dnat_and_snat 172.18.2.12 192.168.200.5 vm2 00:00:00:00:03:02\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"192.168.100.5/24\", \"00:00:00:00:01:05\", \\\n         \"192.168.100.1\")\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"192.168.200.5/24\", \"00:00:00:00:02:05\", \\\n         \"192.168.200.1\")\n\nOVN_POPULATE_ARP\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([Testing a ping])\n\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.12 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ovn -- CoPP])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_SKIP_IF([test $HAVE_SCAPY = no])\nAT_KEYWORDS([ovn-copp])\n\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\nADD_BR([br-ext])\n\ncheck ovs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\ncheck ovs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add R1\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add public\n\ncheck ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 1000::a/64 \\\n    -- lrp-set-gateway-chassis rp-public hv1\n\ncheck ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\n\ncheck ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \\\n    type=router options:router-port=rp-public \\\n    -- lsp-set-addresses public-rp router\n\nADD_NAMESPACES(sw01)\nADD_VETH(sw01, sw01, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\ncheck ovn-nbctl lsp-add sw0 sw01 \\\n    -- lsp-set-addresses sw01 \"f0:00:00:01:02:03 192.168.1.2\"\n\nADD_NAMESPACES(server)\nNS_CHECK_EXEC([server], [ip link set dev lo up])\nADD_VETH(s1, server, br-ext, \"172.16.1.50/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\n\nAT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])\ncheck ovn-nbctl lsp-add public public1 \\\n        -- lsp-set-addresses public1 unknown \\\n        -- lsp-set-type public1 localnet \\\n        -- lsp-set-options public1 network_name=phynet\n\nNS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp -Q in > reject.pcap &])\ncheck ovn-nbctl meter-add acl-meter drop 1 pktps 0\ncheck ovn-nbctl --wait=hv copp-add copp0 reject acl-meter\ncheck ovn-nbctl --wait=hv ls-copp-add copp0 sw0\ncheck ovn-nbctl acl-add sw0 from-lport 1002 'inport == \"sw01\" && ip && udp' reject\n\nAT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl\nreject: acl-meter\n])\n\nip netns exec sw01 scapy -H <<-EOF\np = IP(src=\"192.168.1.2\", dst=\"192.168.1.1\") / UDP(dport = 12345) / Raw(b\"X\"*64)\nsend (p, iface='sw01', loop = 0, verbose = 0, count = 20)\nEOF\n\n# 1pps\nOVS_WAIT_UNTIL([\n    n_reject=$(grep unreachable reject.pcap | wc -l)\n    test \"${n_reject}\" = \"1\"\n])\nkill $(pidof tcpdump)\nrm -f reject.pcap\n\n# Let's update the meter\nNS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp -Q in > reject.pcap &])\ncheck ovn-nbctl --may-exist meter-add acl-meter drop 10 pktps 0\nip netns exec sw01 scapy -H <<-EOF\np = IP(src=\"192.168.1.2\", dst=\"192.168.1.1\") / UDP(dport = 12345) / Raw(b\"X\"*64)\nsend (p, iface='sw01', loop = 0, verbose = 0, count = 40)\nEOF\n\n# 10pps\nOVS_WAIT_UNTIL([\n    n_reject=$(grep unreachable reject.pcap | wc -l)\n    test \"${n_reject}\" = \"10\"\n])\n\nkill $(pidof tcpdump)\nrm -f reject.pcap\n\nNS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp -Q in > reject.pcap &])\ncheck ovn-nbctl --wait=hv copp-del copp0 reject\n\nip netns exec sw01 scapy -H <<-EOF\np = IP(src=\"192.168.1.2\", dst=\"192.168.1.1\") / UDP(dport = 12345) / Raw(b\"X\"*64)\nsend (p, iface='sw01', loop = 0, verbose = 0, count = 20)\nEOF\n\nOVS_WAIT_UNTIL([\n    n_reject=$(grep unreachable reject.pcap | wc -l)\n    test \"${n_reject}\" = \"20\"\n])\nkill $(pidof tcpdump)\n\nNS_EXEC([server], [tcpdump -l -n -i s1 arp[[24:4]]=0xac100164 > arp.pcap &])\ncheck ovn-nbctl meter-add arp-meter drop 1 pktps 0\ncheck ovn-nbctl --wait=hv copp-add copp1 arp-resolve arp-meter\ncheck ovn-nbctl --wait=hv lr-copp-add copp1 R1\nAT_CHECK([ovn-nbctl copp-list copp1], [0], [dnl\narp-resolve: arp-meter\n])\n\nip netns exec sw01 scapy -H <<-EOF\np = IP(src=\"192.168.1.2\", dst=\"172.16.1.100\") / TCP(dport = 80, flags=\"S\") / Raw(b\"X\"*64)\nsend (p, iface='sw01', loop = 0, verbose = 0, count = 100)\nEOF\n\n# 1pps\nOVS_WAIT_UNTIL([\n    n_arp=$(grep ARP arp.pcap | wc -l)\n    test \"${n_arp}\" = \"1\"\n])\nkill $(pidof tcpdump)\n\ncheck ovn-nbctl meter-add icmp-meter drop 1 pktps 0\ncheck ovn-nbctl --wait=hv copp-add copp2 icmp4-error icmp-meter\ncheck ovn-nbctl --wait=hv lr-copp-add copp2 R1\nAT_CHECK([ovn-nbctl copp-list copp2 |grep icmp4-error], [0], [dnl\nicmp4-error: icmp-meter\n])\n\nNS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp > icmp.pcap &])\nip netns exec sw01 scapy -H <<-EOF\np = IP(src=\"192.168.1.2\", dst=\"172.16.1.100\", ttl=1) / TCP(dport = 8080, flags=\"S\") / Raw(b\"X\"*64)\nsend (p, iface='sw01', loop = 0, verbose = 0, count = 100)\nEOF\n\n# 1pps\nOVS_WAIT_UNTIL([\n    n_icmp=$(grep ICMP icmp.pcap | wc -l)\n    test \"${n_icmp}\" = \"1\"\n])\nkill $(pidof tcpdump)\n\ncheck ovn-nbctl meter-add bfd-meter drop 1 pktps 0\ncheck ovn-nbctl --wait=hv copp-add copp3 bfd bfd-meter\ncheck ovn-nbctl --wait=hv lr-copp-add copp3 R1\nAT_CHECK([ovn-nbctl copp-list copp3 |grep bfd], [0], [dnl\nbfd: bfd-meter\n])\n\ncheck ovn-nbctl --wait=hv --bfd lr-route-add R1 240.0.0.0/8 172.16.1.50 rp-public\nprintf \"%08x\" $(ovn-sbctl get bfd . disc) > /tmp/disc\nNS_EXEC([server], [tcpdump -l -nn -i s1 udp port 3784 and ip[[29]]==0x90 -Q in > bfd.pcap &])\nip netns exec server scapy -H <<-EOF\nimport binascii\nf = open(\"/tmp/disc\", \"r\")\n# scapy does not support BFD protocol\n# let's hardcode a BFD payload with the proper my-disc field read from the db\nbfd = binascii.unhexlify(\"20600518a899e77b\" + f.readline().strip() + \"000f4240000f424000000000\")\np = IP(src=\"172.16.1.50\", dst=\"172.16.1.1\") / UDP(dport = 3784, sport = 49152) / Raw(load = bfd)\nsend (p, iface='s1', loop = 0, verbose = 0, count = 100)\nf.close()\nEOF\nrm /tmp/disc\n\n# 1pps\nOVS_WAIT_UNTIL([\n    n_bfd=$(grep 3784 bfd.pcap | wc -l)\n    test \"${n_bfd}\" = \"1\"\n])\nkill $(pidof tcpdump)\n\ncheck ovn-nbctl set nb_global . options:svc_monitor_mac=\"33:33:33:33:33:33\"\ncheck ovn-nbctl meter-add svc-meter drop 1 pktps 0\ncheck ovn-nbctl --wait=hv copp-add copp4 svc-monitor svc-meter\ncheck ovn-nbctl --wait=hv ls-copp-add copp4 sw0\ncheck ovn-appctl -t ovn-controller vlog/set vconn:dbg\nAT_CHECK([ovn-nbctl copp-list copp4], [0], [dnl\nsvc-monitor: svc-meter\n])\n\nip netns exec sw01 scapy -H <<-EOF\np = Ether(dst=\"33:33:33:33:33:33\", src=\"f0:00:00:01:02:03\") /\\\n    IP(dst=\"192.168.1.100\", src=\"192.168.1.2\") / TCP(dport=1234, sport=1234)\nsendp(p, iface='sw01', loop=0, verbose=0, count=20)\nEOF\n\nOVS_WAIT_UNTIL([test \"1\" = \"$(grep -c \"dl_dst=33:33:33:33:33:33\" ovn-controller.log)\"])\n\nkill $(pidof ovn-controller)\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/.*error receiving.*/d\n/.*terminating with signal 15.*/d\n/.*Service monitor not found/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL label - conntrack ct_label])\nAT_KEYWORDS([acl label ct_commit])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p3\ncheck ovn-nbctl lsp-set-addresses sw0-p3 \"50:54:00:00:00:04 10.0.0.4\"\ncheck ovn-nbctl lsp-set-port-security sw0-p3 \"50:54:00:00:00:04 10.0.0.4\"\n\n# ACLs\n# Case 1: sw0-p1 ---> sw0-p3 allowed, label=1234\n# Case 2: sw0-p3 ---> sw0-p1 allowed, label=1235\n# Case 3: sw0-p1 ---> sw0-p2 allowed, no label\n# Case 4: sw0-p2 ---> sw0-p1 allowed, no label\n\ncheck ovn-nbctl --label=1234 acl-add sw0 from-lport 1002 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.4' allow-related\ncheck ovn-nbctl --label=1235 acl-add sw0 to-lport 1002 'ip4 && outport == \"sw0-p1\" && ip4.src == 10.0.0.4' allow-related\ncheck ovn-nbctl acl-add sw0 from-lport 1001 \"ip\" allow-related\ncheck ovn-nbctl acl-add sw0 to-lport 1001 \"ip\" allow-related\n\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.2/24\", \"50:54:00:00:00:02\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p3)\nADD_VETH(sw0-p3, sw0-p3, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovn-nbctl acl-list sw0'\non_exit 'ovn-sbctl lflow-list'\non_exit 'ovs-ofctl dump-flows br-int'\n\nwait_for_ports_up\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p1' should be able to ping 'sw0-p3'.\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.4 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/'], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000\nicmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p3' should be able to ping 'sw0-p1'.\nNS_CHECK_EXEC([sw0-p3], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/'], [0], [dnl\nicmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000\nicmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p1' should be able to ping 'sw0-p2'.\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.3 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is not set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p2' should be able to ping 'sw0-p1'.\nNS_CHECK_EXEC([sw0-p2], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is not set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL label - conntrack ct_label - acl after lb])\nAT_KEYWORDS([acl label ct_commit])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p3\ncheck ovn-nbctl lsp-set-addresses sw0-p3 \"50:54:00:00:00:04 10.0.0.4\"\ncheck ovn-nbctl lsp-set-port-security sw0-p3 \"50:54:00:00:00:04 10.0.0.4\"\n\n# ACLs\n# Case 1: sw0-p1 ---> sw0-p3 allowed, label=1234\n# Case 2: sw0-p3 ---> sw0-p1 allowed, label=1235\n# Case 3: sw0-p1 ---> sw0-p2 allowed, no label\n# Case 4: sw0-p2 ---> sw0-p1 allowed, no label\n\ncheck ovn-nbctl --label=1234 --apply-after-lb acl-add sw0 from-lport 1002 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.4' allow-related\ncheck ovn-nbctl --label=1235 acl-add sw0 to-lport 1002 'ip4 && outport == \"sw0-p1\" && ip4.src == 10.0.0.4' allow-related\ncheck ovn-nbctl --apply-after-lb acl-add sw0 from-lport 1001 \"ip\" allow-related\ncheck ovn-nbctl acl-add sw0 to-lport 1001 \"ip\" allow-related\n\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.2/24\", \"50:54:00:00:00:02\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p3)\nADD_VETH(sw0-p3, sw0-p3, br-int, \"10.0.0.4/24\", \"50:54:00:00:00:04\", \\\n         \"10.0.0.1\")\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovn-nbctl acl-list sw0'\non_exit 'ovn-sbctl lflow-list'\non_exit 'ovs-ofctl dump-flows br-int'\n\nwait_for_ports_up\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p1' should be able to ping 'sw0-p3'.\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.4 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.4) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/'], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000\nicmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p3' should be able to ping 'sw0-p1'.\nNS_CHECK_EXEC([sw0-p3], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/'], [0], [dnl\nicmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000\nicmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p1' should be able to ping 'sw0-p2'.\nNS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.3 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is not set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# 'sw0-p2' should be able to ping 'sw0-p1'.\nNS_CHECK_EXEC([sw0-p2], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n10 packets transmitted, 10 received, 0% packet loss, time 0ms\n])\n\n# Ensure conntrack entry is present and ct_label is not set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL label - conntrack label change])\nAT_KEYWORDS([acl label ct_commit label change])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\n\n# ACLs\n# sw0-p1 ---> sw0-p2 allowed, label=1234\n\ncheck ovn-nbctl --label=1234 acl-add sw0 from-lport 1002 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.3' allow-related\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.2/24\", \"50:54:00:00:00:02\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovn-nbctl acl-list sw0'\non_exit 'ovn-sbctl lflow-list'\non_exit 'ovs-ofctl dump-flows br-int'\n\nwait_for_ports_up\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# start a background ping for ~30 secs.\nNETNS_DAEMONIZE([sw0-p1], [[ping -q -c 100 -i 0.3 -w 15 10.0.0.3]], [ns-sw0-p1.pid])\n\nsleep 3s\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/' | sort], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000\n])\n\n# Add a higher priority ACL with different label.\n# This ACL also allows the ping running in background.\n\ncheck ovn-nbctl --label=1235 acl-add sw0 from-lport 1003 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.3' allow-related\novn-nbctl --wait=hv sync\n\nsleep 3s\n\n# Ensure conntrack entry is updated with new ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/' | sort], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL label - conntrack label change - acl after lb])\nAT_KEYWORDS([acl label ct_commit label change])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0-p1\ncheck ovn-nbctl lsp-set-addresses sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\ncheck ovn-nbctl lsp-set-port-security sw0-p1 \"50:54:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl lsp-add sw0 sw0-p2\ncheck ovn-nbctl lsp-set-addresses sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\ncheck ovn-nbctl lsp-set-port-security sw0-p2 \"50:54:00:00:00:03 10.0.0.3\"\n\n# ACLs\n# sw0-p1 ---> sw0-p2 allowed, label=1234\n\ncheck ovn-nbctl --label=1234 --apply-after-lb acl-add sw0 from-lport 1002 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.3' allow-related\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.2/24\", \"50:54:00:00:00:02\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovn-nbctl acl-list sw0'\non_exit 'ovn-sbctl lflow-list'\non_exit 'ovs-ofctl dump-flows br-int'\n\nwait_for_ports_up\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# start a background ping for ~30 secs.\nNETNS_DAEMONIZE([sw0-p1], [[ping -q -c 100 -i 0.3 -w 15 10.0.0.3]], [ns-sw0-p1.pid])\n\nsleep 3s\n\n# Ensure conntrack entry is present and ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/' | sort], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000\n])\n\n# Add a higher priority ACL with different label.\n# This ACL also allows the ping running in background.\n\ncheck ovn-nbctl --label=1235 --apply-after-lb acl-add sw0 from-lport 1003 'ip4 && inport == \"sw0-p1\" && ip4.dst == 10.0.0.3' allow-related\novn-nbctl --wait=hv sync\n\nsleep 3s\n\n# Ensure conntrack entry is updated with new ct_label is set.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\nsed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/' | sort], [0], [dnl\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL all drop and allow related - acl after lb])\nAT_KEYWORDS([ACL all drop and allow related])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n\n# No ACLs in sw0.\ncheck ovn-nbctl ls-add sw0\n\ncheck ovn-nbctl lsp-add sw0 sw0p1\ncheck ovn-nbctl lsp-set-addresses sw0p1 \"50:54:00:00:00:02 10.0.0.3\"\n\n# ACLs to drop every thing and just allow-related.\ncheck ovn-nbctl ls-add sw1\n\ncheck ovn-nbctl lsp-add sw1 sw1p1\ncheck ovn-nbctl lsp-set-addresses sw1p1 \"50:54:00:00:00:03 20.0.0.3\"\n\ncheck ovn-nbctl --apply-after-lb acl-add sw1 from-lport 1001 'inport == \"sw1p1\" && ip4' drop\n\ncheck ovn-nbctl acl-add sw1 to-lport 1002 'ip4 && tcp && tcp.dst == 80' allow-related\ncheck ovn-nbctl acl-add sw1 to-lport 1001 'ip4' drop\n\nADD_NAMESPACES(sw0p1)\nADD_VETH(sw0p1, sw0p1, br-int, \"10.0.0.3/24\", \"50:54:00:00:00:02\", \\\n         \"10.0.0.1\")\nADD_NAMESPACES(sw1p1)\nADD_VETH(sw1p1, sw1p1, br-int, \"20.0.0.3/24\", \"50:54:00:00:00:03\", \\\n         \"20.0.0.1\")\n\n# Create a logical router and attach both logical switches\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24\ncheck ovn-nbctl lsp-add sw0 sw0-lr0\ncheck ovn-nbctl lsp-set-type sw0-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01\ncheck ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0\n\ncheck ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24\ncheck ovn-nbctl lsp-add sw1 sw1-lr0\ncheck ovn-nbctl lsp-set-type sw1-lr0 router\ncheck ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02\ncheck ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1\n\n# Ensure ovn-controller is caught up\novn-nbctl --wait=hv sync\n\non_exit 'ovn-nbctl acl-list sw0'\non_exit 'ovn-sbctl lflow-list'\non_exit 'ovs-ofctl dump-flows br-int'\n\nwait_for_ports_up\n\n# Start webservers in 'sw1-p1'\nOVS_START_L7([sw1p1], [http])\n\nAT_CHECK([ip netns exec sw0p1 wget 20.0.0.3 -t 3 -T 1], [0], [ignore], [ignore])\n\n# Clear the apply-after-lb option for the ACL\ncheck ovn-nbctl acl-del sw1 from-lport 1001 'inport == \"sw1p1\" && ip4'\ncheck ovn-nbctl acl-add sw1 from-lport 1001 'inport == \"sw1p1\" && ip4' drop\n\ncheck ovn-nbctl --wait=hv sync\n\nAT_CHECK([ip netns exec sw0p1 wget 20.0.0.3 -t 3 -T 1], [0], [ignore], [ignore])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL log_related])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\nset_acl_options() {\n    local acl_name=$1; shift\n\n    local acl_uuid=$(fetch_column nb:ACL _uuid name=$acl_name)\n    check ovn-nbctl set ACL $acl_uuid \"$@\"\n}\n\nclear_log() {\n    ovn-appctl -t ovn-controller vlog/close\n    rm ovn-controller.log\n    ovn-appctl -t ovn-controller vlog/reopen\n}\n\ntest_ping() {\n    NS_CHECK_EXEC([sw0-p1],  [ping -q -c 1 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\n])\n}\n\ncheck_acl_log_count() {\n    local expected_count=$1\n\n    OVS_WAIT_UNTIL([test $expected_count = `cat ovn-controller.log | grep -c acl_log`])\n}\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \"00:00:00:00:00:01 10.0.0.1\"\ncheck ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 \"00:00:00:00:00:02 10.0.0.2\"\n\ncheck ovn-nbctl pg-add pg1 sw0-p1 sw0-p2\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.1/24\", \"00:00:00:00:00:01\")\nADD_NAMESPACES(sw0-p2)\nADD_VETH(sw0-p2, sw0-p2, br-int, \"10.0.0.2/24\", \"00:00:00:00:00:02\")\n\nwait_for_ports_up\n\ncheck ovn-nbctl --log --name=allow_acl acl-add pg1 from-lport 100 'inport == @pg1 && ip4' allow\n\ncheck ovn-nbctl --wait=hv sync\n\ntest_ping\n\n# The allow ACL should match on the request and reply traffic, resulting in 2 logs.\ncheck_acl_log_count 2\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=2 \\\n    --name=allow_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:02 \\\n    --dl_dst=00:00:00:00:00:01 \\\n    --nw_src=10.0.0.2 \\\n    --nw_dst=10.0.0.1 \\\n    --icmp_type=0 \\\n    --icmp_code=0\n\n# Now add a higher-priority stateful ACL that matches on the same\n# parameters. Don't enable reply logging.\ncheck ovn-nbctl --log --name=allow_related_acl acl-add pg1 from-lport 200 'inport == @pg1 && ip4' allow-related\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# Since reply logging is not enabled, the allow-related ACL should match on the\n# request, but the reply will not be logged.\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# As a control, set a label on the allow-related ACL, but still don't enable\n# reply traffic logging.\nset_acl_options allow_related_acl label=1 options:log-related=false\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# This should have the same result as the previous ping\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# As another control, remove the label but enable reply logging.\nset_acl_options allow_related_acl label=0 options:log-related=true\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# This should have the same result as the previous ping\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# This time, add a label and enable reply logging on the allow_related ACL.\nset_acl_options allow_related_acl label=1 options:log-related=true\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# Now we should have the request and reply logged.\ncheck_acl_log_count 2\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=2 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:02 \\\n    --dl_dst=00:00:00:00:00:01 \\\n    --nw_src=10.0.0.2 \\\n    --nw_dst=10.0.0.1 \\\n    --icmp_type=0 \\\n    --icmp_code=0\n\n\n# And now, let's start from scratch but make sure everything works when\n# using egress ACLs.\ncheck ovn-nbctl acl-del pg1\ncheck_row_count nb:ACL 0\n\ncheck ovn-nbctl --log --name=allow_acl acl-add pg1 to-lport 100 'outport == @pg1 && ip4' allow\n\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# The allow ACL should match on the request and reply traffic, resulting in 2 logs.\ncheck_acl_log_count 2\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=2 \\\n    --name=allow_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:02 \\\n    --dl_dst=00:00:00:00:00:01 \\\n    --nw_src=10.0.0.2 \\\n    --nw_dst=10.0.0.1 \\\n    --icmp_type=0 \\\n    --icmp_code=0\n\n# Now add a higher-priority stateful ACL that matches on the same\n# parameters. Don't enable reply logging.\ncheck ovn-nbctl --log --name=allow_related_acl acl-add pg1 to-lport 200 'outport == @pg1 && ip4' allow-related\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# Since reply logging is not enabled, the allow-related ACL should match on the\n# request, but the reply will not be logged.\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# As a control, set a label on the allow-related ACL, but still don't enable\n# reply traffic logging.\nset_acl_options allow_related_acl label=1 options:log-related=false\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# This should have the same result as the previous ping\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# As another control, remove the label but enable reply logging.\nset_acl_options allow_related_acl label=0 options:log-related=true\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# This should have the same result as the previous ping\ncheck_acl_log_count 1\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\n# This time, add a label and enable reply logging on the allow_related ACL.\nset_acl_options allow_related_acl label=1 options:log-related=true\ncheck ovn-nbctl --wait=hv sync\n\nclear_log\ntest_ping\n\n# Now we should have the request and reply logged.\ncheck_acl_log_count 2\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=1 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:01 \\\n    --dl_dst=00:00:00:00:00:02 \\\n    --nw_src=10.0.0.1 \\\n    --nw_dst=10.0.0.2 \\\n    --icmp_type=8 \\\n    --icmp_code=0\n\ncheck $PYTHON $srcdir/check_acl_log.py \\\n    --entry-num=2 \\\n    --name=allow_related_acl \\\n    --verdict=allow \\\n    --protocol=icmp \\\n    --dl_src=00:00:00:00:00:02 \\\n    --dl_dst=00:00:00:00:00:01 \\\n    --nw_src=10.0.0.2 \\\n    --nw_dst=10.0.0.1 \\\n    --icmp_type=0 \\\n    --icmp_code=0\n\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([East-West traffic with gateway router if DNAT configured])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n# Logical network:\n# One LR - R1  has two switches: sw0 and sw1\n#    sw0 -- R1 -- sw1\n# Logical port 'sw01' in switch 'sw0'.\n# Logical port 'sw11' in switch 'sw1'.\n# nc server running in sw01\n# nc client running on sw11\n\ncheck ovn-nbctl lr-add R1\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\n\ncheck ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24\ncheck ovn-nbctl set logical_router R1 options:chassis=hv1\n\ncheck ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\ncheck ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \\\n    type=router options:router-port=rp-sw1 \\\n    -- lsp-set-addresses sw1-rp router\n\nADD_NAMESPACES(sw01)\nADD_VETH(sw01, sw01, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n       \"192.168.1.1\")\ncheck ovn-nbctl lsp-add sw0 sw01 \\\n    -- lsp-set-addresses sw01 \"f0:00:00:01:02:03 192.168.1.2\"\n\nADD_NAMESPACES(sw11)\nADD_VETH(sw11, sw11, br-int, \"192.168.2.2/24\", \"f0:00:00:02:02:03\", \\\n       \"192.168.2.1\")\ncheck ovn-nbctl lsp-add sw1 sw11 \\\n    -- lsp-set-addresses sw11 \"f0:00:00:02:02:03 192.168.2.2\"\n\nNETNS_DAEMONIZE([sw01], [nc -k -l 8000], [nc-sw01.pid])\n\ntest_ping() {\n    NS_CHECK_EXEC([$1],  [ping -q -c 1 $2 -w 2 | FORMAT_PING], \\\n[0], [dnl\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\n])\n}\n\n# Only SNAT\ncheck ovn-nbctl --wait=hv lr-nat-add R1 snat 172.16.1.21 192.168.2.0/24\n\necho \"foo\" > foo\nNS_CHECK_EXEC([sw11], [nc 192.168.1.2 8000 -z], [0], [ignore], [ignore])\ntest_ping sw11 192.168.1.2\n\n# Ensure nat has been hit\nOVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep -v \"n_packets=0\" | grep 'nat(src=172.16.1.21)'])\n# Ensure conntrack entry is present\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>\ntcp,orig=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# SNAT and DNAT. using Logical IP\novn-nbctl --wait=hv lr-nat-add R1 dnat_and_snat 172.16.1.2 192.168.1.2\nNS_CHECK_EXEC([sw11], [nc 192.168.1.2 8000 -z], [0], [ignore], [ignore])\ntest_ping sw11 192.168.1.2\n\n# Ensure conntrack entry is present\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>\ntcp,orig=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# SNAT and DNAT. using floating IP\nNS_CHECK_EXEC([sw11], [nc 172.16.1.2 8000 -z], [0], [ignore], [ignore])\ntest_ping sw11 172.16.1.2\n\n# Ensure conntrack entry is present\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>\ntcp,orig=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Container ping parent port])\nAT_KEYWORDS([container-parent-port])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1\novn-nbctl lsp-set-addresses sw0-p1 \"00:54:00:00:00:03 10.0.0.3\"\n\novn-nbctl ls-add sw0\novn-nbctl lsp-add sw0 sw0-p1.2 sw0-p1 2\novn-nbctl lsp-set-addresses sw0-p1.2 \"00:54:00:00:00:04 10.0.0.4\"\ncheck ovn-nbctl --wait=hv sync\n\nADD_NAMESPACES(sw0-p1)\nADD_VETH(sw0-p1, sw0-p1, br-int, \"10.0.0.3/24\", \"00:54:00:00:00:03\", \\\n         \"10.0.0.1\")\n\nNS_CHECK_EXEC([sw0-p1], [ip link add link sw0-p1 name sw0-p1.2 type vlan id 2], [0])\nADD_NAMESPACES(sw0-p1.2)\nNS_CHECK_EXEC([sw0-p1], [ip link set sw0-p1.2 netns sw0-p1.2], [0])\nNS_CHECK_EXEC([sw0-p1.2], [ip link set sw0-p1.2 address 00:54:00:00:00:04], [0])\nNS_CHECK_EXEC([sw0-p1.2], [ip link set sw0-p1.2 up], [0])\nNS_CHECK_EXEC([sw0-p1.2], [ip addr add 10.0.0.4/24 dev sw0-p1.2], [0])\nNS_CHECK_EXEC([sw0-p1.2], [ip route add default via 10.0.0.1 dev sw0-p1.2], [0])\n\nNS_CHECK_EXEC([sw0-p1.2], [ping -q -c 3 -i 0.3 -w 2 10.0.0.3 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([SNAT in gateway router mode])\nAT_KEYWORDS([ovnnat])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\ncheck ovs-ofctl add-flow br0 action=normal\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ip link set br0 up\ncheck ovs-vsctl set open . external-ids:ovn-bridge-mappings=provider:br0\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl lsp-add ls1 ls1p1\ncheck ovn-nbctl lsp-set-addresses ls1p1 \"00:00:00:01:01:01 192.168.1.1 2001::1\"\ncheck ovn-nbctl lsp-add ls1 ls1p2\ncheck ovn-nbctl lsp-set-addresses ls1p2 \"00:00:00:01:01:02 192.168.1.2 2001::2\"\n\ncheck ovn-nbctl lr-add lr1\ncheck ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:00:01 192.168.1.254/24 2001::a/64\ncheck ovn-nbctl lsp-add ls1 ls1-lr1\ncheck ovn-nbctl lsp-set-addresses ls1-lr1 \"00:00:00:00:00:01 192.168.1.254 2001::a\"\ncheck ovn-nbctl lsp-set-type ls1-lr1 router\ncheck ovn-nbctl lsp-set-options ls1-lr1 router-port=lr1-ls1\n\ncheck ovn-nbctl set logical_router lr1 options:chassis=hv1\n\ncheck ovn-nbctl lrp-add lr1 lr1-pub 00:00:00:00:0f:01 172.16.1.254/24 1711::a/64\ncheck ovn-nbctl ls-add pub\ncheck ovn-nbctl lsp-add pub pub-lr1\ncheck ovn-nbctl lsp-set-type pub-lr1 router\ncheck ovn-nbctl lsp-set-options pub-lr1 router-port=lr1-pub\ncheck ovn-nbctl lsp-set-addresses pub-lr1 router\n\ncheck ovn-nbctl lsp-add pub ln -- lsp-set-options ln network_name=provider\ncheck ovn-nbctl lsp-set-type ln localnet\ncheck ovn-nbctl lsp-set-addresses ln unknown\n\ncheck ovn-nbctl lr-nat-add lr1 snat 172.16.1.10 192.168.1.0/24\ncheck ovn-nbctl lr-nat-add lr1 snat 1711::10 2001::/64\n\nADD_NAMESPACES(ls1p1)\nADD_VETH(ls1p1, ls1p1, br-int, \"192.168.1.1/24\", \"00:00:00:01:01:01\", \\\n         \"192.168.1.254\", , \"2001::1/64\", \"2001::a\")\n\nADD_NAMESPACES(ls1p2)\nADD_VETH(ls1p2, ls1p2, br-int, \"192.168.1.2/24\", \"00:00:00:01:01:02\", \\\n         \"192.168.1.254\", , \"2001::2/64\", \"2001::a\")\n\nADD_NAMESPACES(ext1)\nADD_VETH(ext1, ext1, br0, \"172.16.1.1/24\", \"00:ee:00:01:01:01\", \\\n         \"172.16.1.254\", , \"1711::1/64\", \"1711::a\")\n\ncheck ovn-nbctl --wait=hv sync\nwait_for_ports_up\nOVS_WAIT_UNTIL([test \"$(ip netns exec ls1p1 ip a | grep 2001::1 | grep tentative)\" = \"\"])\nOVS_WAIT_UNTIL([test \"$(ip netns exec ls1p2 ip a | grep 2002::2 | grep tentative)\" = \"\"])\nOVS_WAIT_UNTIL([test \"$(ip netns exec ext1 ip a | grep 1711::1 | grep tentative)\" = \"\"])\n\nNS_CHECK_EXEC([ls1p1], [ping -q -c 3 -i 0.3 -w 2  172.16.1.1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nNS_CHECK_EXEC([ls1p1], [ping6 -v -q -c 3 -i 0.3 -w 2 1711::1  | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/removing policing failed: No such device/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([mcast flow count])\nAT_KEYWORDS([ovnigmp IP-multicast])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add ls\ncheck ovn-nbctl lsp-add ls vm1\ncheck ovn-nbctl lsp-set-addresses vm1 00:00:00:00:00:01\ncheck ovn-nbctl lsp-add ls vm2\ncheck ovn-nbctl lsp-set-addresses vm2 00:00:00:00:00:02\ncheck ovn-nbctl lsp-add ls vm3\ncheck ovn-nbctl lsp-set-addresses vm3 00:00:00:00:00:03\n\ncheck ovn-nbctl set logical_switch ls other_config:mcast_querier=false other_config:mcast_snoop=true other_config:mcast_query_interval=30 other_config:mcast_eth_src=00:00:00:00:00:05 other_config:mcast_ip4_src=42.42.42.5 other_config:mcast_ip6_src=fe80::1 other_config:mcast_idle_timeout=3000\novn-sbctl list ip_multicast\n\nwait_igmp_flows_installed()\n{\n    OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int table=33 | \\\n    grep 'priority=90' | grep \"nw_dst=$1\"])\n}\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"42.42.42.1/24\", \"00:00:00:00:00:01\", \\\n         \"42.42.42.5\")\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"42.42.42.2/24\", \"00:00:00:00:00:02\")\n\nADD_NAMESPACES(vm3)\nNETNS_DAEMONIZE([vm3], [tcpdump -n -i any -nnleX > vm3.pcap 2>/dev/null], [tcpdump3.pid])\n\nADD_VETH(vm3, vm3, br-int, \"42.42.42.3/24\", \"00:00:00:00:00:03\", \\\n         \"42.42.42.5\")\n\nNS_CHECK_EXEC([vm2], [sysctl -w net.ipv4.igmp_max_memberships=100], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [sysctl -w net.ipv4.igmp_max_memberships=100], [ignore], [ignore])\nwait_for_ports_up\n\nNS_CHECK_EXEC([vm3], [ip addr add 228.0.0.1 dev vm3 autojoin], [0])\nwait_igmp_flows_installed 228.0.0.1\n\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 228.0.0.1], [ignore], [ignore])\n\nOVS_WAIT_UNTIL([\n    requests=`grep \"ICMP echo request\" -c vm3.pcap`\n    test \"${requests}\" -ge \"3\"\n])\n\nNETNS_DAEMONIZE([vm2], [tcpdump -n -i any -nnleX > vm2.pcap 2>/dev/null], [tcpdump2.pid])\n\nfor i in `seq 1 40`;do\n    NS_CHECK_EXEC([vm2], [ip addr add 228.1.$i.1 dev vm2 autojoin &], [0])\n    NS_CHECK_EXEC([vm3], [ip addr add 229.1.$i.1 dev vm3 autojoin &], [0])\n    # Do not go too fast. If going fast, there is a higher chance of sb being busy, causing full recompute (engine has not run)\n    # In this test, we do not want too many recomputes as they might hide I+I related errors\n    sleep 0.2\ndone\n\nfor i in `seq 1 40`;do\n    wait_igmp_flows_installed 228.1.$i.1\n    wait_igmp_flows_installed 229.1.$i.1\ndone\novn-sbctl list multicast_group\n\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 228.1.1.1], [ignore], [ignore])\n\nOVS_WAIT_UNTIL([\n    requests=`grep \"ICMP echo request\" -c vm2.pcap`\n    test \"${requests}\" -ge \"3\"\n])\n\n# The test could succeed thanks to a lucky northd recompute...after hitting too any flows\n# Double check we never hit error condition\nAT_CHECK([grep -qE 'Too many active mcast flows' northd/ovn-northd.log], [1])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/removing policing failed: No such device/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([DVR ping router port])\nAT_KEYWORDS([dvr])\n\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-ext])\n\ncheck ovs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\ncheck ovs-vsctl set open . external_ids:ovn-bridge-mappings=phys:br-ext\ncheck ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings=\"phys:ee:00:00:00:00:10\"\n\n\ncheck ovn-nbctl ls-add internal\n\ncheck ovn-nbctl lsp-add internal ln_internal \"\" 100\ncheck ovn-nbctl lsp-set-addresses ln_internal unknown\ncheck ovn-nbctl lsp-set-type ln_internal localnet\ncheck ovn-nbctl lsp-set-options ln_internal network_name=phys\n\ncheck ovn-nbctl lsp-add internal internal-gw\ncheck ovn-nbctl lsp-set-type internal-gw router\ncheck ovn-nbctl lsp-set-addresses internal-gw router\ncheck ovn-nbctl lsp-set-options internal-gw router-port=gw-internal\n\ncheck ovn-nbctl lsp-add internal vif0\n# Set address as unknown so that LRP has to generate ARP request\ncheck ovn-nbctl lsp-set-addresses vif0 unknown\n\ncheck ovn-nbctl lr-add gw\ncheck ovn-nbctl lrp-add gw gw-internal 00:00:00:00:20:00 192.168.20.1/24\n\nADD_NAMESPACES(vif0)\nADD_VETH(vif0, vif0, br-int, \"192.168.20.10/24\", \"00:00:00:00:20:10\", \"192.168.20.1\")\n\ncheck ovn-nbctl --wait=sb sync\ncheck ovn-nbctl --wait=hv sync\n\nNS_CHECK_EXEC([vif0], [ping -q -c 3 -i 0.3 -w 1 192.168.20.1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing affinity sessions - IPv4])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and\n# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected\n# to it.  R2 is a gateway router on which we add load-balancing rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2\novn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"172.16.1.2/24\", \"f0:00:00:01:02:04\", \\\n         \"172.16.1.1\")\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 172.16.1.2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2\"\n\nADD_NAMESPACES(bar2)\nADD_VETH(bar2, bar2, br-int, \"192.168.2.3/24\", \"e0:00:00:01:02:05\", \\\n\"192.168.2.1\")\novn-nbctl lsp-add bar bar2 \\\n-- lsp-set-addresses bar2 \"e0:00:00:01:02:05 192.168.2.3\"\n\n# Config OVN load-balancer with a VIP.\n\novn-nbctl lb-add lb0 172.16.1.100:8080 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb10 172.16.1.110:8080 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb0-no-aff 172.16.1.100:8081 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb10-no-aff 172.16.1.110:8081 192.168.1.2:80,192.168.2.2:80\novn-nbctl lr-lb-add R2 lb0\novn-nbctl lr-lb-add R2 lb10\novn-nbctl lr-lb-add R2 lb0-no-aff\novn-nbctl lr-lb-add R2 lb10-no-aff\n\n# Start webservers in 'foo1', 'bar1'.\nNETNS_DAEMONIZE([foo1], [nc -l -k 192.168.1.2 80], [nc-foo1.pid])\nNETNS_DAEMONIZE([bar1], [nc -l -k 192.168.2.2 80], [nc-bar1.pid])\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2:80)'])\n\ndnl Should work with the virtual IP address through NAT\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z 172.16.1.100 8080])\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.100) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=172.16.1.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=172.16.1.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# Enable lb affinity\novn-nbctl --wait=sb set load_balancer lb0 options:affinity_timeout=60\novn-nbctl --wait=sb set load_balancer lb10 options:affinity_timeout=60\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z 172.16.1.100 8080])\ndone\n\ndnl here we should have just one entry in the ct table\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.100) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/; s/src=192.168.[[0-9]].2/src=192.168.<cleared>.2/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=172.16.1.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.<cleared>.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndp_key=$(printf \"0x%x\" $(fetch_column datapath tunnel_key external_ids:name=R2))\nAT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=78 --no-stats | sed -e 's/load:0xc0a80[[0-9]]02/load:0xc0a80<cleared>02/'], [0], [dnl\n table=78, idle_timeout=60, tcp,metadata=$dp_key,nw_src=172.16.1.2,nw_dst=172.16.1.100,tp_dst=8080 actions=load:0x1->NXM_NX_REG10[[14]],load:0xc0a80<cleared>02->NXM_NX_REG4[[]],load:0x50->NXM_NX_REG8[[0..15]]\n])\n\ncheck_affinity_flows () {\nn1=$(ovs-ofctl dump-flows br-int table=15 |awk '/priority=150,ct_state=\\+new\\+trk,ip,reg4=0xc0a80102/{print substr($4,11,length($4)-11)}')\nn2=$(ovs-ofctl dump-flows br-int table=15 |awk '/priority=150,ct_state=\\+new\\+trk,ip,reg4=0xc0a80202/{print substr($4,11,length($4)-11)}')\n[[ $n1 -gt 0 -a $n2 -eq 0 ]] || [[ $n1 -eq 0 -a $n2 -gt 0 ]]\necho $?\n}\nAT_CHECK([test $(check_affinity_flows) -eq 0])\nNS_CHECK_EXEC([alice1], [nc -z 172.16.1.100 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\novn-nbctl lb-add lb1 172.16.1.101:8080 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb11 172.16.1.111:8080 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb1-no-aff 172.16.1.101:8081 192.168.1.2:80,192.168.2.2:80\novn-nbctl lb-add lb11-no-aff 172.16.1.111:8081 192.168.1.2:80,192.168.2.2:80\n# Enable lb affinity\novn-nbctl --wait=sb set load_balancer lb1 options:affinity_timeout=3\novn-nbctl --wait=sb set load_balancer lb11 options:affinity_timeout=3\novn-nbctl lr-lb-add R2 lb1\novn-nbctl lr-lb-add R2 lb11\novn-nbctl lr-lb-add R2 lb1-no-aff\novn-nbctl lr-lb-add R2 lb11-no-aff\n\n# check we use both backends\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z 172.16.1.101 8080])\n    ovs-ofctl del-flows br-int table=78\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.101) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=172.16.1.2,dst=172.16.1.101,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=172.16.1.2,dst=172.16.1.101,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([alice1], [nc -z 172.16.1.101 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nNETNS_DAEMONIZE([bar2], [nc -l -k 192.168.2.3 80], [nc-bar2.pid])\n\novn-nbctl lb-add lb2 192.168.2.100:8080 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb20 192.168.2.120:8080 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb2-no-aff 192.168.2.100:8081 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb20-no-aff 192.168.2.120:8081 192.168.2.2:80,192.168.2.3:80\novn-nbctl --wait=sb set load_balancer lb2 options:affinity_timeout=60\novn-nbctl --wait=sb set load_balancer lb20 options:affinity_timeout=60\novn-nbctl ls-lb-add foo lb2\novn-nbctl ls-lb-add foo lb20\novn-nbctl ls-lb-add foo lb2-no-aff\novn-nbctl ls-lb-add foo lb20-no-aff\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z 192.168.2.100 8080])\ndone\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.100) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/; s/src=192.168.2.[[0-9]]/src=192.168.2.<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=192.168.2.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.<cleared>,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z 192.168.2.100 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\novn-nbctl lb-add lb3 192.168.2.101:8080 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb30 192.168.2.131:8080 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb3-no-aff 192.168.2.101:8081 192.168.2.2:80,192.168.2.3:80\novn-nbctl lb-add lb30-no-aff 192.168.2.131:8081 192.168.2.2:80,192.168.2.3:80\novn-nbctl --wait=sb set load_balancer lb3 options:affinity_timeout=3\novn-nbctl --wait=sb set load_balancer lb30 options:affinity_timeout=3\novn-nbctl ls-lb-add foo lb3\novn-nbctl ls-lb-add foo lb30\novn-nbctl ls-lb-add foo lb3-no-aff\novn-nbctl ls-lb-add foo lb30-no-aff\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z 192.168.2.101 8080])\n    ovs-ofctl del-flows br-int table=78\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.101) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=192.168.2.101,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=192.168.2.101,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z 192.168.2.101 8081])\n\nNS_CHECK_EXEC([foo1], [ip neigh add 192.168.1.200 lladdr 00:00:01:01:02:03 dev foo1], [0])\novn-nbctl lb-add lb4 192.168.1.100:8080 192.168.1.2:80\novn-nbctl lb-add lb40 192.168.1.140:8080 192.168.1.2:80\novn-nbctl lb-add lb4-no-aff 192.168.1.100:8081 192.168.1.2:80\novn-nbctl lb-add lb40-no-aff 192.168.1.140:8081 192.168.1.2:80\novn-nbctl --wait=sb set load_balancer lb4 options:affinity_timeout=60 options:hairpin_snat_ip=192.168.1.200\novn-nbctl --wait=sb set load_balancer lb40 options:affinity_timeout=60 options:hairpin_snat_ip=192.168.1.200\novn-nbctl ls-lb-add foo lb4\novn-nbctl ls-lb-add foo lb40\novn-nbctl lr-lb-add R1 lb4\novn-nbctl lr-lb-add R1 lb40\novn-nbctl ls-lb-add foo lb4-no-aff\novn-nbctl ls-lb-add foo lb40-no-aff\novn-nbctl lr-lb-add R1 lb4-no-aff\novn-nbctl lr-lb-add R1 lb40-no-aff\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z 192.168.1.100 8080])\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.1.2) |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=192.168.1.100,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.1.200,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.200,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.1.200,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z 192.168.1.100 8081])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/inactivity probe*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancing affinity sessions - IPv6])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# Two LRs - R1 and R2 that are connected to each other via LS \"join\"\n# in fd20::/64 network. R1 has switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it. R2 has alice (fd72::/64) connected\n# to it.  R2 is a gateway router on which we add load-balancing rules.\n#\n#    foo -- R1 -- join - R2 -- alice\n#           |\n#    bar ----\n\novn-nbctl create Logical_Router name=R1\novn-nbctl create Logical_Router name=R2 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\novn-nbctl ls-add alice\novn-nbctl ls-add join\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Connect alice to R2\novn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd72::1/64\novn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \\\n    type=router options:router-port=alice addresses=\\\"00:00:02:01:02:03\\\"\n\n# Connect R1 to join\novn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64\novn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \\\n    type=router options:router-port=R1_join addresses='\"00:00:04:01:02:03\"'\n\n# Connect R2 to join\novn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64\novn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \\\n    type=router options:router-port=R2_join addresses='\"00:00:04:01:02:04\"'\n\n# Static routes.\novn-nbctl lr-route-add R1 fd72::/64 fd20::2\novn-nbctl lr-route-add R2 fd11::/64 fd20::1\novn-nbctl lr-route-add R2 fd12::/64 fd20::1\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\nOVS_WAIT_UNTIL([test \"$(ip -n foo1 a | grep fd11::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'alice1' in switch 'alice'.\nADD_NAMESPACES(alice1)\nADD_VETH(alice1, alice1, br-int, \"fd72::2/64\", \"f0:00:00:01:02:04\", \\\n         \"fd72::1\")\nOVS_WAIT_UNTIL([test \"$(ip -n alice1 a | grep fd72::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add alice alice1 \\\n-- lsp-set-addresses alice1 \"f0:00:00:01:02:04 fd72::2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n\"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip -n bar1 a | grep fd12::2 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\nADD_NAMESPACES(bar2)\nADD_VETH(bar2, bar2, br-int, \"fd12::3/64\", \"e0:00:00:01:02:05\", \\\n\"fd12::1\")\nOVS_WAIT_UNTIL([test \"$(ip -n bar2 a | grep fd12::3 | grep tentative)\" = \"\"])\novn-nbctl lsp-add bar bar2 \\\n-- lsp-set-addresses bar2 \"e0:00:00:01:02:05 fd12::3\"\n\novn-nbctl lb-add lb0 [[fd30::1]]:8080 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb10 [[fd30::10]]:8080 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb0-no-aff [[fd30::1]]:8081 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb10-no-aff [[fd30::10]]:8081 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lr-lb-add R2 lb0\novn-nbctl lr-lb-add R2 lb10\novn-nbctl lr-lb-add R2 lb0-no-aff\novn-nbctl lr-lb-add R2 lb10-no-aff\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd11::2\\]]:80)'])\n\n# Start webservers in 'foo1', 'bar1'.\nNETNS_DAEMONIZE([foo1], [nc -l -k fd11::2 80], [nc-foo1.pid])\nNETNS_DAEMONIZE([bar1], [nc -l -k fd12::2 80], [nc-bar1.pid])\n\ndnl Should work with the virtual IP address through NAT\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z fd30::1 8080])\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([alice1], [nc -z fd30::1 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n# Enable lb affinity\novn-nbctl --wait=sb set load_balancer lb0 options:affinity_timeout=60\novn-nbctl --wait=sb set load_balancer lb10 options:affinity_timeout=60\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z fd30::1 8080])\ndone\n\ndnl here we should have just one entry in the ct table\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/; s/src=fd1[[0-9]]::2/src=fd1<cleared>::2/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd1<cleared>::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\ndp_key=$(printf \"0x%x\" $(fetch_column datapath tunnel_key external_ids:name=R2))\nAT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=78 --no-stats | sed -e 's/load:0xfd1[[0-9]]000000000000/load:0xfd1<cleared>000000000000/'], [0], [dnl\n table=78, idle_timeout=60, tcp6,metadata=$dp_key,ipv6_src=fd72::2,ipv6_dst=fd30::1,tp_dst=8080 actions=load:0x1->NXM_NX_REG10[[14]],load:0x2->NXM_NX_XXREG1[[0..63]],load:0xfd1<cleared>000000000000->NXM_NX_XXREG1[[64..127]],load:0x50->NXM_NX_REG8[[0..15]]\n])\n\ncheck_affinity_flows () {\nn1=$(ovs-ofctl dump-flows br-int table=15 |awk '/priority=150,ct_state=\\+new\\+trk,ipv6,reg4=0xfd110000/{print substr($4,11,length($4)-11)}')\nn2=$(ovs-ofctl dump-flows br-int table=15 |awk '/priority=150,ct_state=\\+new\\+trk,ipv6,reg4=0xfd120000/{print substr($4,11,length($4)-11)}')\n[[ $n1 -gt 0 -a $n2 -eq 0 ]] || [[ $n1 -eq 0 -a $n2 -gt 0 ]]\necho $?\n}\nAT_CHECK([test $(check_affinity_flows) -eq 0])\nNS_CHECK_EXEC([alice1], [nc -z fd30::1 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\novn-nbctl lb-add lb1 [[fd30::2]]:8080 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb11 [[fd30::12]]:8080 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb1-no-aff [[fd30::2]]:8081 [[fd11::2]]:80,[[fd12::2]]:80\novn-nbctl lb-add lb11-no-aff [[fd30::12]]:8081 [[fd11::2]]:80,[[fd12::2]]:80\n# Enable lb affinity\novn-nbctl --wait=sb set load_balancer lb1 options:affinity_timeout=3\novn-nbctl --wait=sb set load_balancer lb11 options:affinity_timeout=3\novn-nbctl lr-lb-add R2 lb1\novn-nbctl lr-lb-add R2 lb11\novn-nbctl lr-lb-add R2 lb1-no-aff\novn-nbctl lr-lb-add R2 lb11-no-aff\n\n# check we use both backends\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([alice1], [nc -z fd30::2 8080])\n    ovs-ofctl del-flows br-int table=78\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::2) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([alice1], [nc -z fd30::2 8081])\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nNETNS_DAEMONIZE([bar2], [nc -l -k fd12::3 80], [nc-bar2.pid])\n\novn-nbctl lb-add lb2 [[fd12::a]]:8080 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb20 [[fd12::2a]]:8080 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb2-no-aff [[fd12::a]]:8081 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb20-no-aff [[fd12::2a]]:8081 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl --wait=sb set load_balancer lb2 options:affinity_timeout=60\novn-nbctl --wait=sb set load_balancer lb20 options:affinity_timeout=60\novn-nbctl ls-lb-add foo lb2\novn-nbctl ls-lb-add foo lb20\novn-nbctl ls-lb-add foo lb2-no-aff\novn-nbctl ls-lb-add foo lb20-no-aff\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z fd12::a 8080])\ndone\n\ndnl here we should have just one entry in the ct table\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd12::a) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/; s/src=fd12::[[0-9]]/src=fd12::<cleared>/'], [0], [dnl\ntcp,orig=(src=fd11::2,dst=fd12::a,sport=<cleared>,dport=<cleared>),reply=(src=fd12::<cleared>,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z fd12::a 8081])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\novn-nbctl lb-add lb3 [[fd12::b]]:8080 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb30 [[fd12::3b]]:8080 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb3-no-aff [[fd12::b]]:8081 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl lb-add lb30-no-aff [[fd12::3b]]:8081 [[fd12::2]]:80,[[fd12::3]]:80\novn-nbctl --wait=sb set load_balancer lb3 options:affinity_timeout=3\novn-nbctl --wait=sb set load_balancer lb30 options:affinity_timeout=3\novn-nbctl ls-lb-add foo lb3\novn-nbctl ls-lb-add foo lb30\novn-nbctl ls-lb-add foo lb3-no-aff\novn-nbctl ls-lb-add foo lb30-no-aff\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z fd12::b 8080])\n    ovs-ofctl del-flows br-int table=78\ndone\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd12::b) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd11::2,dst=fd12::b,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd11::2,dst=fd12::b,sport=<cleared>,dport=<cleared>),reply=(src=fd12::3,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z fd12::b 8081])\n\nNS_CHECK_EXEC([foo1], [ip -6 neigh add fd11::b lladdr 00:00:01:01:02:03 dev foo1], [0])\novn-nbctl --wait=sb lb-add lb4 [[fd11::a]]:8080 [[fd11::2]]:80\novn-nbctl --wait=sb lb-add lb40 [[fd11::a]]:8080 [[fd11::2]]:80\novn-nbctl --wait=sb lb-add lb4-no-aff [[fd11::a]]:8081 [[fd11::2]]:80\novn-nbctl --wait=sb lb-add lb40-no-aff [[fd11::a]]:8081 [[fd11::2]]:80\novn-nbctl --wait=sb set load_balancer lb4 options:affinity_timeout=60 options:hairpin_snat_ip=\"fd11::b\"\novn-nbctl --wait=sb set load_balancer lb40 options:affinity_timeout=60 options:hairpin_snat_ip=\"fd11::b\"\novn-nbctl ls-lb-add foo lb4\novn-nbctl ls-lb-add foo lb40\novn-nbctl lr-lb-add R1 lb4\novn-nbctl lr-lb-add R1 lb40\novn-nbctl ls-lb-add foo lb4-no-aff\novn-nbctl ls-lb-add foo lb40-no-aff\novn-nbctl lr-lb-add R1 lb4-no-aff\novn-nbctl lr-lb-add R1 lb40-no-aff\n\n# Flush conntrack entries for easier output parsing of next test.\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nfor i in $(seq 1 15); do\n    echo Request $i\n    NS_CHECK_EXEC([foo1], [nc -z fd11::a 8080])\ndone\n\ndnl Each server should have at least one connection.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd11::2) | grep -v fe80 |\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd11::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd11::b,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd11::2,dst=fd11::a,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=fd11::b,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd11::b,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\nNS_CHECK_EXEC([foo1], [nc -z fd11::a 8081])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\n/inactivity probe*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([SNAT in separate zone from DNAT])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# The goal of this test is to ensure that when traffic is first DNATted\n# (by way of a load balancer), and then SNATted, the SNAT happens in a\n# separate conntrack zone from the DNAT.\n\nstart_daemon ovn-controller\n\ncheck ovn-nbctl ls-add public\n\ncheck ovn-nbctl lr-add r1\ncheck ovn-nbctl lrp-add r1 r1_public 00:de:ad:ff:00:01 172.16.0.1/16\ncheck ovn-nbctl lrp-add r1 r1_s1 00:de:ad:fe:00:01 173.0.1.1/24\ncheck ovn-nbctl lrp-set-gateway-chassis r1_public hv1\n\ncheck ovn-nbctl lb-add r1_lb 30.0.0.1 172.16.0.102\ncheck ovn-nbctl lr-lb-add r1 r1_lb\n\ncheck ovn-nbctl ls-add s1\ncheck ovn-nbctl lsp-add s1 s1_r1\ncheck ovn-nbctl lsp-set-type s1_r1 router\ncheck ovn-nbctl lsp-set-addresses s1_r1 router\ncheck ovn-nbctl lsp-set-options s1_r1 router-port=r1_s1\n\ncheck ovn-nbctl lsp-add s1 vm1\ncheck ovn-nbctl lsp-set-addresses vm1 \"00:de:ad:01:00:01 173.0.1.2\"\n\ncheck ovn-nbctl lsp-add public public_r1\ncheck ovn-nbctl lsp-set-type public_r1 router\ncheck ovn-nbctl lsp-set-addresses public_r1 router\ncheck ovn-nbctl lsp-set-options public_r1 router-port=r1_public nat-addresses=router\n\ncheck ovn-nbctl lr-add r2\ncheck ovn-nbctl lrp-add r2 r2_public 00:de:ad:ff:00:02 172.16.0.2/16\ncheck ovn-nbctl lrp-add r2 r2_s2 00:de:ad:fe:00:02 173.0.2.1/24\ncheck ovn-nbctl lr-nat-add r2 dnat_and_snat 172.16.0.102 173.0.2.2\ncheck ovn-nbctl lrp-set-gateway-chassis r2_public hv1\n\ncheck ovn-nbctl ls-add s2\ncheck ovn-nbctl lsp-add s2 s2_r2\ncheck ovn-nbctl lsp-set-type s2_r2 router\ncheck ovn-nbctl lsp-set-addresses s2_r2 router\ncheck ovn-nbctl lsp-set-options s2_r2 router-port=r2_s2\n\ncheck ovn-nbctl lsp-add s2 vm2\ncheck ovn-nbctl lsp-set-addresses vm2 \"00:de:ad:01:00:02 173.0.2.2\"\n\ncheck ovn-nbctl lsp-add public public_r2\ncheck ovn-nbctl lsp-set-type public_r2 router\ncheck ovn-nbctl lsp-set-addresses public_r2 router\ncheck ovn-nbctl lsp-set-options public_r2 router-port=r2_public nat-addresses=router\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"173.0.1.2/24\", \"00:de:ad:01:00:01\", \\\n         \"173.0.1.1\")\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"173.0.2.2/24\", \"00:de:ad:01:00:02\", \\\n         \"173.0.2.1\")\n\ncheck ovn-nbctl lr-nat-add r1 dnat_and_snat 172.16.0.101 173.0.1.2 vm1 00:00:00:01:02:03\ncheck ovn-nbctl --wait=hv sync\n\n# Next, make sure that a ping works as expected\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\n# Finally, make sure that conntrack shows two separate zones being used for\n# DNAT and SNAT\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=172.16.0.102,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=2\n])\n\n# The final two entries appear identical here. That is because FORMAT_CT\n# scrubs the zone numbers. In actuality, the zone numbers are different,\n# which is why there are two entries.\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.102) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=172.16.0.101,dst=172.16.0.102,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=172.16.0.101,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=173.0.1.2,dst=172.16.0.102,id=<cleared>,type=8,code=0),reply=(src=172.16.0.102,dst=172.16.0.101,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=173.0.1.2,dst=172.16.0.102,id=<cleared>,type=8,code=0),reply=(src=172.16.0.102,dst=172.16.0.101,id=<cleared>,type=0,code=0),zone=<cleared>\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([LB - ICMP related traffic])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\nm4_define([WAIT_PACKET], [\npcap=$1\npacket=$2\nOVS_WAIT_UNTIL([test $($PYTHON \"$ovs_srcdir/utilities/ovs-pcap.in\" $pcap |\\\ngrep -c $packet) -eq 1])\n])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\nstart_daemon ovn-controller\n\n# client -- ls0 -- lr -- ls1 -- server\ncheck ovn-nbctl ls-add ls0\ncheck ovn-nbctl ls-add ls1\n\ncheck ovn-nbctl lsp-add ls0 ls0-lr\ncheck ovn-nbctl lsp-set-type ls0-lr router\ncheck ovn-nbctl lsp-set-addresses ls0-lr 00:00:00:00:10:00 router\ncheck ovn-nbctl lsp-set-options ls0-lr router-port=lr-ls0\n\ncheck ovn-nbctl lsp-add ls1 ls1-lr\ncheck ovn-nbctl lsp-set-type ls1-lr router\ncheck ovn-nbctl lsp-set-addresses ls1-lr 00:00:00:00:20:00 router\ncheck ovn-nbctl lsp-set-options ls1-lr router-port=lr-ls1\n\ncheck ovn-nbctl lsp-add ls0 client\ncheck ovn-nbctl lsp-set-addresses client \"00:00:00:00:10:10 192.168.10.10\"\n\ncheck ovn-nbctl lsp-add ls1 server\ncheck ovn-nbctl lsp-set-addresses server \"00:00:00:00:20:10 192.168.20.10\"\n\ncheck ovn-nbctl lr-add lr\ncheck ovn-nbctl lrp-add lr lr-ls0 00:00:00:00:10:00 192.168.10.1/24\ncheck ovn-nbctl lrp-add lr lr-ls1 00:00:00:00:20:00 192.168.20.1/24\n\ncheck ovn-nbctl set logical_router lr options:chassis=hv1\n\nADD_NAMESPACES(client)\nADD_VETH(client, client, br-int, \"192.168.10.10/24\", \"00:00:00:00:10:10\", \\\n         \"192.168.10.1\")\nADD_NAMESPACES(server)\nADD_VETH(server, server, br-int, \"192.168.20.10/24\", \"00:00:00:00:20:10\", \\\n         \"192.168.20.1\")\n\n# Define packets to send\nclient_udp=00000000100000000000101008004500001C000040000A11D162C0A80A0AC0A\\\n814140001000200080000\nserver_udp=00000000200000000000201008004500001C000040000A11D16CC0A8140AC0A\\\n80A0A0002000100080000\nicmp=000000001000000000001010080045000038011F0000FF011B37C0A80A0AC0A814140\\\n304F778000005784500001c000040000911d262c0a81414c0a80a0a0002000100080000\n\n# Define expected packets\nclient_udp_expected=00000000101000000000100008004500001c000040000911d262c0a\\\n81414c0a80a0a0002000100080000\nserver_udp_expected=00000000201000000000200008004500001c000040000911d26cc0a8\\\n0a0ac0a8140a0001000200080000\nicmp_expected=000000002010000000002000080045000038011f0000fe011c41c0a80a0ac0\\\na8140a0304f778000005784500001c000040000911d26cc0a8140ac0a80a0a0002000100080000\n\ntest_related_traffic() {\n    check ovn-nbctl --wait=hv sync\n\n    check ovs-appctl dpctl/flush-conntrack\n\n    NETNS_DAEMONIZE([client], [tcpdump -l -U -i client -w client.pcap 2>client_err], [tcpdump0.pid])\n    NETNS_DAEMONIZE([server], [tcpdump -l -U -i server -w server.pcap 2>server_err], [tcpdump1.pid])\n\n    # Setup a dummy UDP listeners so we don't get \"port unreachable\".\n    NETNS_DAEMONIZE([client], [nc -l -u 1], [nc0.pid])\n    NETNS_DAEMONIZE([server], [nc -l -u 2], [nc1.pid])\n\n    OVS_WAIT_UNTIL([grep \"listening\" client_err])\n    OVS_WAIT_UNTIL([grep \"listening\" server_err])\n\n    # Send UDP client -> server\n    check ovs-ofctl packet-out br-int \"in_port=ovs-client,packet=$client_udp,actions=resubmit(,0)\"\n\n    # Send reply server -> client\n    check ovs-ofctl packet-out br-int \"in_port=ovs-server,packet=$server_udp,actions=resubmit(,0)\"\n\n    # Send ICMP \"need to frag\" client -> server\n    check ovs-ofctl packet-out br-int \"in_port=ovs-client,packet=$icmp,actions=resubmit(,0)\"\n\n    # Check if all packets have arrived\n    WAIT_PACKET([server.pcap], [$server_udp_expected])\n    WAIT_PACKET([client.pcap], [$client_udp_expected])\n    WAIT_PACKET([server.pcap], [$icmp_expected])\n\n    kill $(cat tcpdump0.pid) $(cat tcpdump1.pid)\n    kill $(cat nc0.pid) $(cat nc1.pid)\n\n    rm -f client.pcap server.pcap\n}\n\nAS_BOX([ICMP related on switch, LB without port and protocol])\ncheck ovn-nbctl lb-add lb0 192.168.20.20 192.168.20.10\ncheck ovn-nbctl ls-lb-add ls0 lb0\n\ntest_related_traffic\n\ncheck ovn-nbctl ls-lb-del ls0\ncheck ovn-nbctl lb-del lb0\n\nAS_BOX([ICMP related on switch, LB with port and protocol])\ncheck ovn-nbctl lb-add lb0 192.168.20.20:2 192.168.20.10:2 udp\ncheck ovn-nbctl ls-lb-add ls0 lb0\n\ntest_related_traffic\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nudp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2\n])\n\ncheck ovn-nbctl ls-lb-del ls0\ncheck ovn-nbctl lb-del lb0\n\nAS_BOX([ICMP related on router, LB without port and protocol])\ncheck ovn-nbctl lb-add lb0 192.168.20.20 192.168.20.10\ncheck ovn-nbctl lr-lb-add lr lb0\n\ntest_related_traffic\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nudp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2\n])\n\ncheck ovn-nbctl lr-lb-del lr\ncheck ovn-nbctl lb-del lb0\n\nAS_BOX([ICMP related on switch, LB with port and protocol])\ncheck ovn-nbctl lb-add lb0 192.168.20.20:2 192.168.20.10:2 udp\ncheck ovn-nbctl lr-lb-add lr lb0\n\ntest_related_traffic\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nudp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2\n])\n\ncheck ovn-nbctl lr-lb-del lr\ncheck ovn-nbctl lb-del lb0\n\nAS_BOX([ICMP related force SNAT])\ncheck ovn-nbctl lb-add lb0 192.168.20.20 192.168.20.10\ncheck ovn-nbctl lr-lb-add lr lb0\n\ncheck ovn-nbctl --wait=sb set logical_router lr options:lb_force_snat_ip=\"router_ip\"\n\n# Change the expected packets on server to be with source IP from router\nserver_udp_expected=00000000201000000000200008004500001c000040000911c875c0a8\\\n1401c0a8140a0001000200080000\nicmp_expected=000000002010000000002000080045000038011f0000fe01124ac0a81401c0\\\na8140a0304f778000005784500001c000040000911c875c0a8140ac0a814010002000100080000\n\n# Server should respond to the router IP\nserver_udp=00000000200000000000201008004500001C000040000A11C775C0A8140AC0A8\\\n14010002000100080000\n\ntest_related_traffic\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.20.20) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nudp,orig=(src=192.168.10.10,dst=192.168.20.20,sport=<cleared>,dport=<cleared>),reply=(src=192.168.20.10,dst=192.168.10.10,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=10\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancer template IPv4])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([ovnlb templates])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nOVS_CHECK_CT_ZERO_SNAT()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# VM1 -- LS1 -- GW-Router -- LS2 -- VM3\n#         |\n# VM2 ----+\n#\n# Four templated load balancer applied on LS1 and GW-Router with\n# VM1 as backend.  The VIPs should be accessible from both VM2 and VM3.\n\ncheck ovn-nbctl                                                   \\\n    -- lr-add rtr                                                 \\\n    -- set Logical_Router rtr options:chassis=hv1                 \\\n    -- lrp-add rtr rtr-ls1 00:00:00:00:01:00 42.42.42.1/24        \\\n    -- lrp-add rtr rtr-ls2 00:00:00:00:02:00 43.43.43.1/24        \\\n    -- ls-add ls1                                                 \\\n    -- lsp-add ls1 ls1-rtr                                        \\\n    -- lsp-set-addresses ls1-rtr 00:00:00:00:01:00                \\\n    -- lsp-set-type ls1-rtr router                                \\\n    -- lsp-set-options ls1-rtr router-port=rtr-ls1                \\\n    -- lsp-add ls1 vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \\\n    -- lsp-add ls1 vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \\\n    -- ls-add ls2                                                 \\\n    -- lsp-add ls2 ls2-rtr                                        \\\n    -- lsp-set-addresses ls2-rtr 00:00:00:00:02:00                \\\n    -- lsp-set-type ls2-rtr router                                \\\n    -- lsp-set-options ls2-rtr router-port=rtr-ls2                \\\n    -- lsp-add ls2 vm3 -- lsp-set-addresses vm3 00:00:00:00:00:03\n\n# Add a TCP template LB that eventually expands to:\n# VIP=66.66.66.66:666 backends=42.42.42.2:4242 proto=tcp\n# And a UDP template LB that eventually expands to:\n# VIP=66.66.66.66:777 backends=42.42.42.2:4343 proto=udp\n\nAT_CHECK([ovn-nbctl -- create chassis_template_var chassis=\"hv1\" \\\n    variables=\"{vip=66.66.66.66,vport1=666,backends1=\\\"42.42.42.2:4242\\\",vport2=777,backends2=\\\"42.42.42.2:4343\\\",vport3=888,vport4=999}\"],\n         [0], [ignore])\n\ncheck ovn-nbctl --template lb-add lb-test-tcp \"^vip:^vport1\" \"^backends1\" tcp \\\n    -- ls-lb-add ls1 lb-test-tcp                                              \\\n    -- lr-lb-add rtr lb-test-tcp\n\ncheck ovn-nbctl --template lb-add lb-test-udp \"^vip:^vport2\" \"^backends2\" udp \\\n    -- ls-lb-add ls1 lb-test-udp                                              \\\n    -- lr-lb-add rtr lb-test-udp\n\n# Add a TCP template LB with explicit backends that eventually expands to:\n# VIP=66.66.66.66:888 backends=42.42.42.2:4242 proto=tcp\n# And a UDP template LB that eventually expands to:\n# VIP=66.66.66.66:999 backends=42.42.42.2:4343 proto=udp\ncheck ovn-nbctl --template lb-add lb-test-tcp2 \"^vip:^vport3\" \"42.42.42.2:4242\" tcp ipv4 \\\n    -- ls-lb-add ls1 lb-test-tcp2                                                        \\\n    -- lr-lb-add rtr lb-test-tcp2\n\ncheck ovn-nbctl --template lb-add lb-test-udp2 \"^vip:^vport4\" \"42.42.42.2:4343\" udp ipv4 \\\n    -- ls-lb-add ls1 lb-test-udp2                                                        \\\n    -- lr-lb-add rtr lb-test-udp2\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"42.42.42.2/24\", \"00:00:00:00:00:01\", \"42.42.42.1\")\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"42.42.42.3/24\", \"00:00:00:00:00:02\", \"42.42.42.1\")\n\nADD_NAMESPACES(vm3)\nADD_VETH(vm3, vm3, br-int, \"43.43.43.2/24\", \"00:00:00:00:00:03\", \"43.43.43.1\")\n\n# Wait for ovn-controller to catch up.\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\nAT_CHECK([ovn-appctl -t ovn-controller debug/dump-local-template-vars | sort], [0], [dnl\nLocal template vars:\nname: 'backends1' value: '42.42.42.2:4242'\nname: 'backends2' value: '42.42.42.2:4343'\nname: 'vip' value: '66.66.66.66'\nname: 'vport1' value: '666'\nname: 'vport2' value: '777'\nname: 'vport3' value: '888'\nname: 'vport4' value: '999'\n])\n\n# Start IPv4 TCP server on vm1.\nNETNS_DAEMONIZE([vm1], [nc -k -l 42.42.42.2 4242], [nc-vm1.pid])\n\nNETNS_DAEMONIZE([vm1],\n    [tcpdump -n -i vm1 -nnleX -c6 udp and dst 42.42.42.2 and dst port 4343 > vm1.pcap 2>/dev/null],\n    [tcpdump1.pid])\n\n# Make sure connecting to the VIP works (hairpin, via ls and via lr).\nNS_CHECK_EXEC([vm1], [nc 66.66.66.66 666 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [nc 66.66.66.66 666 -z], [0], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [echo a | nc -u 66.66.66.66 777], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [echo a | nc -u 66.66.66.66 777], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [echo a | nc -u 66.66.66.66 777], [ignore], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [nc 66.66.66.66 888 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [nc 66.66.66.66 888 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [nc 66.66.66.66 888 -z], [0], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [echo a | nc -u 66.66.66.66 999], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [echo a | nc -u 66.66.66.66 999], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [echo a | nc -u 66.66.66.66 999], [ignore], [ignore], [ignore])\n\nOVS_WAIT_UNTIL([\n    requests=`grep \"UDP\" -c vm1.pcap`\n    test \"${requests}\" -ge \"6\"\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancer template IPv6])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\nAT_SKIP_IF([test $HAVE_NC = no])\nAT_KEYWORDS([ovnlb templates])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nOVS_CHECK_CT_ZERO_SNAT()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# VM1 -- LS1 -- GW-Router -- LS2 -- VM3\n#         |\n# VM2 ----+\n#\n# Four templated load balancer applied on LS1 and GW-Router with\n# VM1 as backend.  The VIPs should be accessible from both VM2 and VM3.\n\ncheck ovn-nbctl                                                   \\\n    -- lr-add rtr                                                 \\\n    -- set Logical_Router rtr options:chassis=hv1                 \\\n    -- lrp-add rtr rtr-ls1 00:00:00:00:01:00 4242::1/64           \\\n    -- lrp-add rtr rtr-ls2 00:00:00:00:02:00 4343::1/64           \\\n    -- ls-add ls1                                                 \\\n    -- lsp-add ls1 ls1-rtr                                        \\\n    -- lsp-set-addresses ls1-rtr 00:00:00:00:01:00                \\\n    -- lsp-set-type ls1-rtr router                                \\\n    -- lsp-set-options ls1-rtr router-port=rtr-ls1                \\\n    -- lsp-add ls1 vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \\\n    -- lsp-add ls1 vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \\\n    -- ls-add ls2                                                 \\\n    -- lsp-add ls2 ls2-rtr                                        \\\n    -- lsp-set-addresses ls2-rtr 00:00:00:00:02:00                \\\n    -- lsp-set-type ls2-rtr router                                \\\n    -- lsp-set-options ls2-rtr router-port=rtr-ls2                \\\n    -- lsp-add ls2 vm3 -- lsp-set-addresses vm3 00:00:00:00:00:03\n\n# Add a template LB that eventually expands to:\n# VIP=[6666::1]:666 backends=[4242::2]:4242 proto=tcp\n# Add a template LB that eventually expands to:\n# VIP=[6666::1]:777 backends=[4242::2]:4343 proto=udp\n\nAT_CHECK([ovn-nbctl -- create chassis_template_var chassis=\"hv1\" \\\n    variables=\"{vip=\\\"6666::1\\\",vport1=666,backends1=\\\"[[4242::2]]:4242\\\",vport2=777,backends2=\\\"[[4242::2]]:4343\\\",vport3=888,vport4=999}\"],\n         [0], [ignore])\n\ncheck ovn-nbctl --template lb-add lb-test-tcp \"^vip:^vport1\" \"^backends1\" tcp ipv6 \\\n    -- ls-lb-add ls1 lb-test-tcp                                                   \\\n    -- lr-lb-add rtr lb-test-tcp\n\ncheck ovn-nbctl --template lb-add lb-test-udp \"^vip:^vport2\" \"^backends2\" udp ipv6 \\\n    -- ls-lb-add ls1 lb-test-udp                                                   \\\n    -- lr-lb-add rtr lb-test-udp\n\n# Add a TCP template LB with explicit backends that eventually expands to:\n# VIP=[6666::1]:888 backends=[4242::2]:4242 proto=tcp\n# And a UDP template LB that eventually expands to:\n# VIP=[6666::1]:999 backends=[4242::2]:4343 proto=udp\ncheck ovn-nbctl --template lb-add lb-test-tcp2 \"^vip:^vport3\" \"[[4242::2]]:4242\" tcp ipv6 \\\n    -- ls-lb-add ls1 lb-test-tcp2                                                         \\\n    -- lr-lb-add rtr lb-test-tcp2\n\ncheck ovn-nbctl --template lb-add lb-test-udp2 \"^vip:^vport4\" \"[[4242::2]]:4343\" udp ipv6 \\\n    -- ls-lb-add ls1 lb-test-udp2                                                         \\\n    -- lr-lb-add rtr lb-test-udp2\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"4242::2/64\", \"00:00:00:00:00:01\", \"4242::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vm1 ip a | grep 4242::2 | grep tentative)\" = \"\"])\n\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"4242::3/64\", \"00:00:00:00:00:02\", \"4242::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vm2 ip a | grep 4242::3 | grep tentative)\" = \"\"])\n\nADD_NAMESPACES(vm3)\nADD_VETH(vm3, vm3, br-int, \"4343::2/64\", \"00:00:00:00:00:03\", \"4343::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vm3 ip a | grep 4343::2 | grep tentative)\" = \"\"])\n\n# Wait for ovn-controller to catch up.\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\nAT_CHECK([ovn-appctl -t ovn-controller debug/dump-local-template-vars | sort], [0], [dnl\nLocal template vars:\nname: 'backends1' value: '[[4242::2]]:4242'\nname: 'backends2' value: '[[4242::2]]:4343'\nname: 'vip' value: '6666::1'\nname: 'vport1' value: '666'\nname: 'vport2' value: '777'\nname: 'vport3' value: '888'\nname: 'vport4' value: '999'\n])\n\n# Start IPv6 TCP server on vm1.\nNETNS_DAEMONIZE([vm1], [nc -k -l 4242::2 4242], [nc-vm1.pid])\n\nNETNS_DAEMONIZE([vm1],\n    [tcpdump -n -i vm1 -nnleX -c6 udp and dst 4242::2 and dst port 4343 > vm1.pcap 2>/dev/null],\n    [tcpdump1.pid])\n\n# Make sure connecting to the VIP works (hairpin, via ls and via lr).\nNS_CHECK_EXEC([vm1], [nc 6666::1 666 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [nc 6666::1 666 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [nc 6666::1 666 -z], [0], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [echo a | nc -u 6666::1 777], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [echo a | nc -u 6666::1 777], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [echo a | nc -u 6666::1 777], [ignore], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [nc 6666::1 888 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [nc 6666::1 888 -z], [0], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [nc 6666::1 888 -z], [0], [ignore], [ignore])\n\nNS_CHECK_EXEC([vm1], [echo a | nc -u 6666::1 999], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm2], [echo a | nc -u 6666::1 999], [ignore], [ignore], [ignore])\nNS_CHECK_EXEC([vm3], [echo a | nc -u 6666::1 999], [ignore], [ignore], [ignore])\n\nOVS_WAIT_UNTIL([\n    requests=`grep \"UDP\" -c vm1.pcap`\n    test \"${requests}\" -ge \"6\"\n])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([IP buffering])\nAT_KEYWORDS([ip-buffering])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\n\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\n\nADD_BR([br-int])\nADD_BR([br-ext])\n\novs-ofctl add-flow br-ext action=normal\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\nADD_NAMESPACES(sw01)\nADD_VETH(sw01, sw01, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\nADD_NAMESPACES(sw11)\nADD_VETH(sw11, sw11, br-int, \"192.168.2.2/24\", \"f0:00:00:02:02:03\", \\\n         \"192.168.2.1\")\nADD_NAMESPACES(remote)\nADD_VETH(remote, remote, br-ext, \"172.16.1.2/24\", \"f0:00:00:01:02:05\", \\\n         \"172.16.1.1\")\nADD_NAMESPACES(remote1)\nADD_VETH(remote1, remote1, br-ext, \"172.16.1.4/24\", \"f0:00:00:01:02:06\", \\\n         \"172.16.1.1\")\n\nNETNS_DAEMONIZE([remote], [tcpdump -c 3 -nneei remote -Q in src 192.168.1.2 and dst 172.16.1.2 and icmp > icmp.pcap], [tcpdump0.pid])\nNETNS_DAEMONIZE([remote], [tcpdump -c 1 -nneei remote -Q in arp and arp[[24:4]]==0xac100102 > arp.pcap], [tcpdump1.pid])\nNETNS_DAEMONIZE([remote1], [tcpdump -c 3 -nneei remote1 -Q in src 172.16.1.3 and dst 172.16.1.4 and icmp > icmp1.pcap 2>/dev/null], [tcpdump2.pid])\nNETNS_DAEMONIZE([remote1], [tcpdump -c 1 -nneei remote1 -Q in arp and arp[[24:4]]==0xac100104 > arp1.pcap 2>/dev/null], [tcpdump3.pid])\n\ncheck ovn-nbctl lr-add R1 -- set Logical_Router R1 options:chassis=hv1\ncheck ovn-nbctl ls-add sw0\ncheck ovn-nbctl ls-add sw1\ncheck ovn-nbctl ls-add public\n\ncheck ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24\ncheck ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24\n\ncheck ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \\\n    type=router options:router-port=rp-sw0 \\\n    -- lsp-set-addresses sw0-rp router\ncheck ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \\\n    type=router options:router-port=rp-sw1 \\\n    -- lsp-set-addresses sw1-rp router\n\ncheck ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \\\n    type=router options:router-port=rp-public \\\n    -- lsp-set-addresses public-rp router\n\ncheck ovn-nbctl lsp-add sw0 sw01 \\\n    -- lsp-set-addresses sw01 \"f0:00:00:01:02:03 192.168.1.2\"\n\ncheck ovn-nbctl lsp-add sw1 sw11 \\\n    -- lsp-set-addresses sw11 \"f0:00:00:02:02:03 192.168.2.2\"\n\ncheck ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.2.2 sw11 00:00:02:02:03:10\n\nAT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])\ncheck ovn-nbctl lsp-add public public1 \\\n        -- lsp-set-addresses public1 unknown \\\n        -- lsp-set-type public1 localnet \\\n        -- lsp-set-options public1 network_name=phynet\n\nOVN_POPULATE_ARP\n\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\nNS_CHECK_EXEC([sw01], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_WAIT_UNTIL([\n        total_arp_pkts=$(cat arp.pcap | wc -l)\n        test \"${total_arp_pkts}\" = \"1\"\n])\n\nOVS_WAIT_UNTIL([\n        total_icmp_pkts=$(cat icmp.pcap | wc -l)\n        test \"${total_icmp_pkts}\" = \"3\"\n])\n\nNS_CHECK_EXEC([sw11], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_WAIT_UNTIL([\n        total_arp1_pkts=$(cat arp1.pcap | wc -l)\n        test \"${total_arp1_pkts}\" = \"1\"\n])\n\nOVS_WAIT_UNTIL([\n        total_icmp1_pkts=$(cat icmp1.pcap | wc -l)\n        test \"${total_icmp1_pkts}\" = \"3\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\n# For packets that match stateless ACL flows, make sure we bypass\n# connection tracking, even with a LB in the switch. Testing for\n# TCP should suffice. For v4 and v6.\n#\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([omit connection tracking for stateless flows v4])\n\nCHECK_CONNTRACK()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),\n#\n#    foo -- R1 -- bar\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\n\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24\n\n# Connect foo to R1\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo \\\n    -- lsp-set-addresses rp-foo router\n\n# Connect bar to R1\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar \\\n    -- lsp-set-addresses rp-bar router\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"192.168.2.2/24\", \"f0:00:00:01:02:04\", \\\n         \"192.168.2.1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:04 192.168.2.2\"\n\n# Config OVN load-balancer with a VIP.\novn-nbctl lb-add lb1 30.30.30.30:80 \"192.168.2.2:80\" tcp\novn-nbctl ls-lb-add foo lb1\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2:80)'])\n\nzone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep foo1 | cut -d ' ' -f2)\n\nOVS_START_L7([bar1], [http])\n\nAT_CHECK([ip netns exec foo1 wget   192.168.2.2 -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(192.168.1.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# now check with VIP\nAT_CHECK([ip netns exec foo1 wget   30.30.30.30  -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(30.30.30.30) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.30.30.30,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# remove lb\novn-nbctl ls-lb-del foo lb1\n\n# add stateless acl\ncheck ovn-nbctl acl-add foo from-lport 1 1 allow-stateless\ncheck ovn-nbctl --wait=hv acl-add foo to-lport 1 1 allow-stateless\n\nAT_CHECK([ip netns exec foo1 wget   192.168.2.2 -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has no tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(192.168.1.2) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# add lb back\novn-nbctl ls-lb-add foo lb1\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=192.168.2.2:80)'])\n\n# should not dnat so will not be able to connect\nAT_CHECK([ip netns exec foo1 wget   30.30.30.30  -t 3 -T 1], [4], [ignore], [ignore])\n\n# check conntrack zone has no tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(30.30.30.30) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([omit connection tracking for stateless flows v6])\n\nCHECK_CONNTRACK()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# One LR - R1 with switchess foo (fd11::/64) and\n# bar (fd12::/64) connected to it\n#\n#    foo -- R1 -- bar\n\novn-nbctl lr-add R1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"fd11::2/64\", \"f0:00:00:01:02:03\", \\\n         \"fd11::1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 fd11::2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"fd12::2/64\", \"f0:00:00:01:02:05\", \\\n\"fd12::1\")\novn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 fd12::2\"\n\n# Config OVN load-balancer with a VIP.\novn-nbctl lb-add lb1 [[fd30::2]]:80 [[fd12::2]]:80 tcp\novn-nbctl ls-lb-add foo lb1\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd12::2\\]]:80)'])\n\nzone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep foo1 | cut -d ' ' -f2)\n\nOVS_START_L7([bar1], [http6])\n\nAT_CHECK([ip netns exec foo1  wget http://[[fd12::2]] -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(fd12::2) |  grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd11::2,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# now check with VIP\nAT_CHECK([ip netns exec foo1 wget  http://[[fd30::2]]  -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(fd30::2) |  grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=fd11::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd11::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# remove lb\novn-nbctl ls-lb-del foo lb1\n\n# add stateless acl\ncheck ovn-nbctl acl-add foo from-lport 1 1 allow-stateless\ncheck ovn-nbctl --wait=hv acl-add foo to-lport 1 1 allow-stateless\n\nAT_CHECK([ip netns exec foo1  wget http://[[fd12::2]] -t 3 -T 1], [0], [ignore], [ignore])\n\n# check conntrack zone has no tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(fd12::2) |  grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\n# add lb back\novn-nbctl ls-lb-add foo lb1\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\n\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=\\[[fd12::2\\]]:80)'])\n\n# should not dnat so will not be able to connect\nAT_CHECK([ip netns exec foo1 wget  http://[[fd30::2]]  -t 3 -T 1], [4], [ignore], [ignore])\n#\n# check conntrack zone has no tcp entry\nAT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \\\nFORMAT_CT(fd30::2) | grep -v fe80 | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\n])\n\nAT_CHECK([ovs-appctl dpctl/flush-conntrack])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\n###########################################################\n## ls1 -- cluster-router -- join - gr1 -- public1 -- ln1 ##\n###########################################################\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Gateway router with dynamic_neigh_routers])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-ex], [set Bridge br-ex fail-mode=standalone])\n\ncheck ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=provider:br-ex\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Add routers\ncheck ovn-nbctl lr-add gr1\ncheck ovn-nbctl lr-add cluster-router\n\n# Add switches\ncheck ovn-nbctl ls-add join\ncheck ovn-nbctl ls-add public1\ncheck ovn-nbctl ls-add ls1\n\n# Add ls1 ports\ncheck ovn-nbctl lsp-add ls1 ls1p1 \\\n    -- lsp-set-addresses ls1p1 \"00:00:00:00:01:11 10.244.2.11\"\n\ncheck ovn-nbctl lsp-add ls1 ls1-to-cluster-router \\\n    -- lsp-set-type ls1-to-cluster-router router \\\n    -- lsp-set-options ls1-to-cluster-router router-port=cluster-router-to-ls1 \\\n    -- lsp-set-addresses ls1-to-cluster-router router\n\n# Add cluster-router ports\ncheck ovn-nbctl lrp-add cluster-router cluster-router-to-ls1 \"00:00:00:0f:01:01\" 10.244.2.1/24 \\\n    -- lrp-add cluster-router cluster-router-to-join \"00:00:00:0f:02:01\" 100.64.0.1/16 \\\n    -- lrp-set-gateway-chassis cluster-router-to-ls1 hv1 10 \\\n    -- --policy=src-ip lr-route-add cluster-router 10.244.2.0/24 100.64.0.3\n\n# Add join ports\ncheck ovn-nbctl lsp-add join join-to-cluster-router \\\n    -- lsp-set-type join-to-cluster-router router \\\n    -- lsp-set-options join-to-cluster-router router-port=cluster-router-to-join \\\n    -- lsp-set-addresses join-to-cluster-router router \\\n    -- lsp-add join join-to-gr1 \\\n    -- lsp-set-type join-to-gr1 router \\\n    -- lsp-set-options join-to-gr1 router-port=gr1-to-join \\\n    -- lsp-set-addresses join-to-gr1 router\n\ncheck ovn-nbctl set logical_router gr1 options:lb_force_snat_ip=router_ip \\\n    -- set logical_router gr1 options:snat-ct-zone=0 \\\n    -- set logical_router gr1 options:dynamic_neigh_routers=true\n\n# Add gr1 ports and set natting\ncheck ovn-nbctl lrp-add gr1 gr1-to-join \"00:00:00:0f:02:03\" 100.64.0.3/16 \\\n    -- lr-route-add gr1 10.244.0.0/16 100.64.0.1 \\\n    -- lr-nat-add gr1 snat 10.89.189.12 10.244.0.0/16 \\\n    -- lrp-add gr1 gr1-to-public1 \"0a:0a:b6:fc:03:12\" 10.89.189.12/24 \\\n    -- set logical_router gr1 options:chassis=hv1\n\n# Add public1 ports\ncheck ovn-nbctl lsp-add public1 public1-to-gr1 \\\n    -- lsp-set-type public1-to-gr1 router \\\n    -- lsp-set-options public1-to-gr1 router-port=gr1-to-public1 \\\n    -- lsp-set-addresses public1-to-gr1 router \\\n    -- lsp-add public1 ln1 \\\n    -- lsp-set-type ln1 localnet \\\n    -- lsp-set-options ln1 network_name=provider \\\n    -- lsp-set-addresses ln1 unknown\n\ncheck ovn-nbctl --wait=hv sync\n\nADD_NAMESPACES(ns_ls1p1)\nADD_VETH(ls1p1, ns_ls1p1, br-int, \"10.244.2.11/24\", \"00:00:00:00:01:11\", \"10.244.2.1\")\n\nADD_NAMESPACES(ns_ext1)\nADD_VETH(ln1, ns_ext1, br-ex, \"10.89.189.1/24\", \"0a:0a:b6:fc:03:01\")\n\nNS_CHECK_EXEC([ns_ls1p1], [ping -q -c 3 -i 0.3 -w 2 10.89.189.1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL default_acl_drop])\nAT_KEYWORDS([acl default_acl_drop])\n\nCHECK_CONNTRACK()\novn_start\n\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novn-nbctl ls-add sw\n\n# Logical port 'vm1' in switch 'sw'.\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"10.0.0.1/24\", \"f0:00:00:01:02:03\", \\\n         \"10.0.0.254\")\ncheck ovn-nbctl lsp-add sw vm1 \\\n-- lsp-set-addresses vm1 \"f0:00:00:01:02:03 10.0.0.1\"\n\n# Logical port 'vm2' in switch 'sw'.\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"10.0.0.2/24\", \"f0:00:00:01:02:05\", \\\n\"10.0.0.254\")\ncheck ovn-nbctl lsp-add sw vm2 \\\n-- lsp-set-addresses vm2 \"f0:00:00:01:02:05 10.0.0.2\"\n\n# Wait for ovn-controller to catch up.\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([from-lport acl, default_acl_drop false])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=false \\\n    -- acl-add sw from-lport 20 \"ip4 && icmp\" allow-related \\\n    -- acl-add sw from-lport 10 \"ip4\" drop\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAS_BOX([from-lport acl, default_acl_drop true])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=true \\\n    -- acl-add sw from-lport 20 \"ip4 && icmp\" allow-related \\\n    -- acl-add sw from-lport 10 \"arp\" allow \\\n    -- --apply-after-lb acl-add sw from-lport 1 1 allow \\\n    -- acl-add sw to-lport 1 1 allow\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAS_BOX([from-lport acl, after LB, default_acl_drop false])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=false \\\n    -- --apply-after-lb acl-add sw from-lport 20 \"ip4 && icmp\" allow-related \\\n    -- --apply-after-lb acl-add sw from-lport 10 \"ip4\" drop\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAS_BOX([from-lport acl, after LB, default_acl_drop true])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=true \\\n    -- acl-add sw from-lport 1 1 allow \\\n    -- --apply-after-lb acl-add sw from-lport 20 \"ip4 && icmp\" allow-related \\\n    -- --apply-after-lb acl-add sw from-lport 20 \"arp\" allow-related \\\n    -- acl-add sw to-lport 1 1 allow\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAS_BOX([to-lport acl, default_acl_drop false])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=false \\\n    -- acl-add sw to-lport 20 \"ip4 && icmp\" allow-related \\\n    -- acl-add sw to-lport 10 \"ip4\" drop\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nAS_BOX([to-lport acl, default_acl_drop true])\ncheck ovn-nbctl acl-del sw\ncheck ovn-nbctl set NB_Global . options:default_acl_drop=true \\\n    -- acl-add sw from-lport 1 1 allow \\\n    -- --apply-after-lb acl-add sw from-lport 1 1 allow \\\n    -- acl-add sw to-lport 20 \"ip4 && icmp\" allow-related \\\n    -- acl-add sw to-lport 20 \"arp\" allow\ncheck ovn-nbctl --wait=hv sync\n\n# 'vm1' should be able to ping 'vm2' directly.\nNS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load-balancing CT flush backends])\nAT_KEYWORDS([ovnlb])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\ncheck ovs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\n# Logical network:\n# 2 logical switches \"foo\" (192.168.1.0/24) and \"bar\" (172.16.1.0/24)\n# connected to a router R1.\n# foo has foo1 to act as a client.\n# bar has bar1, bar2, bar3 to act as servers.\n#\n# Loadbalancer VIPs in 30.0.0.0/24 network.\n\ncheck ovn-nbctl lr-add R1\ncheck ovn-nbctl ls-add foo\ncheck ovn-nbctl ls-add bar\n\n# Connect foo to R1\ncheck ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24\ncheck ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\ncheck ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 172.16.1.1/24\ncheck ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Create logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"192.168.1.2/24\", \"f0:00:00:01:02:03\", \\\n         \"192.168.1.1\")\ncheck ovn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2\"\n\n# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"172.16.1.2/24\", \"f0:00:0f:01:02:03\", \\\n         \"172.16.1.1\")\ncheck ovn-nbctl lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:0f:01:02:03 172.16.1.2\"\n\nADD_NAMESPACES(bar2)\nADD_VETH(bar2, bar2, br-int, \"172.16.1.3/24\", \"f0:00:0f:01:02:04\", \\\n         \"172.16.1.1\")\ncheck ovn-nbctl lsp-add bar bar2 \\\n-- lsp-set-addresses bar2 \"f0:00:0f:01:02:04 172.16.1.3\"\n\nADD_NAMESPACES(bar3)\nADD_VETH(bar3, bar3, br-int, \"172.16.1.4/24\", \"f0:00:0f:01:02:05\", \\\n         \"172.16.1.1\")\ncheck ovn-nbctl lsp-add bar bar3 \\\n-- lsp-set-addresses bar3 \"f0:00:0f:01:02:05 172.16.1.4\"\n\n# Config OVN load-balancer with a VIP.\ncheck ovn-nbctl lb-add lb1 30.0.0.1 \"172.16.1.2,172.16.1.3,172.16.1.4\" \\\n    -- set load_balancer lb1 options:ct_flush=\"true\"\ncheck ovn-nbctl ls-lb-add foo lb1\n\n# Create another load-balancer with another VIP.\nlb2_uuid=`ovn-nbctl create load_balancer name=lb2 vips:30.0.0.3=\"172.16.1.2,172.16.1.3,172.16.1.4\"`\ncheck ovn-nbctl set load_balancer lb2 options:ct_flush=\"true\"\ncheck ovn-nbctl ls-lb-add foo lb2\n\n# Config OVN load-balancer with another VIP (this time with ports).\ncheck ovn-nbctl set load_balancer $lb2_uuid vips:'\"30.0.0.2:8000\"'='\"172.16.1.2:80,172.16.1.3:80,172.16.1.4:80\"'\n\n# Wait for ovn-controller to catch up.\novn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \\\ngrep 'nat(dst=172.16.1.4:80)'])\n\n# Start webservers in 'bar1', 'bar2' and 'bar3'.\nOVS_START_L7([bar1], [http])\nOVS_START_L7([bar2], [http])\nOVS_START_L7([bar3], [http])\n\nm4_define([LB1_CT_ENTRIES], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.3 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Remove one backend\ncheck ovn-nbctl set load_balancer lb1 vips='\"30.0.0.1\"=\"172.16.1.2,172.16.1.3\"'\n\nOVS_WAIT_FOR_OUTPUT([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Remove whole LB\ncheck ovn-nbctl lb-del lb1\n\nOVS_WAIT_UNTIL([test \"$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | wc -l)\" = \"0\"])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Remove one VIP\ncheck ovn-nbctl remove load_balancer lb2 vips '\"30.0.0.2:8000\"'\n\nOVS_WAIT_UNTIL([test \"$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | wc -l)\" = \"0\"])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\ntcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\n# Remove second LB\ncheck ovn-nbctl lb-del lb2\n\nOVS_WAIT_UNTIL([test \"$(ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | wc -l)\" = \"0\"])\n\n# Check that LB has CT flush disabled by default\ncheck ovn-nbctl lb-add lb1 30.0.0.1 \"172.16.1.2,172.16.1.3,172.16.1.4\"\ncheck ovn-nbctl ls-lb-add foo lb1\n\nOVS_WAIT_FOR_OUTPUT([\n    for i in `seq 1 20`; do\n        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;\n    done\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])\n\n# Remove one backend\ncheck ovn-nbctl --wait=hv set load_balancer lb1 vips='\"30.0.0.1\"=\"172.16.1.2,172.16.1.3\"'\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])\n\n# Remove whole LB\ncheck ovn-nbctl --wait=hv lb-del lb1\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [LB1_CT_ENTRIES])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ACL and committing to conntrack])\nAT_KEYWORDS([acl])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add r1\ncheck ovn-nbctl lrp-add r1 r1_s1 00:de:ad:fe:00:01 173.0.1.1/24\ncheck ovn-nbctl lrp-add r1 r1_s2 00:de:ad:fe:00:02 173.0.2.1/24\n\ncheck ovn-nbctl ls-add s1\ncheck ovn-nbctl lsp-add s1 s1_r1\ncheck ovn-nbctl lsp-set-type s1_r1 router\ncheck ovn-nbctl lsp-set-addresses s1_r1 router\ncheck ovn-nbctl lsp-set-options s1_r1 router-port=r1_s1\n\ncheck ovn-nbctl ls-add s2\ncheck ovn-nbctl lsp-add s2 s2_r1\ncheck ovn-nbctl lsp-set-type s2_r1 router\ncheck ovn-nbctl lsp-set-addresses s2_r1 router\ncheck ovn-nbctl lsp-set-options s2_r1 router-port=r1_s2\n\ncheck ovn-nbctl lsp-add s1 vm1\ncheck ovn-nbctl lsp-set-addresses vm1 \"00:de:ad:01:00:01 173.0.1.2\"\n\ncheck ovn-nbctl lsp-add s2 vm2\ncheck ovn-nbctl lsp-set-addresses vm2 \"00:de:ad:01:00:02 173.0.2.2\"\n\ncheck ovn-nbctl lsp-add s2 vm3\ncheck ovn-nbctl lsp-set-addresses vm3 \"00:de:ad:01:00:03 173.0.2.3\"\n\ncheck ovn-nbctl lb-add lb1 30.0.0.1:80 173.0.2.2:80 udp\ncheck ovn-nbctl lb-add lb2 20.0.0.1:80 173.0.1.2:80 udp\ncheck ovn-nbctl lb-add lb1 30.0.0.1 173.0.2.2\ncheck ovn-nbctl lb-add lb2 173.0.2.250 173.0.1.3\ncheck ovn-nbctl ls-lb-add s1 lb1\ncheck ovn-nbctl ls-lb-add s2 lb2\n\nADD_NAMESPACES(vm1)\nADD_VETH(vm1, vm1, br-int, \"173.0.1.2/24\", \"00:de:ad:01:00:01\", \\\n         \"173.0.1.1\")\nADD_NAMESPACES(vm2)\nADD_VETH(vm2, vm2, br-int, \"173.0.2.2/24\", \"00:de:ad:01:00:02\", \\\n         \"173.0.2.1\")\nADD_NAMESPACES(vm3)\nADD_VETH(vm3, vm3, br-int, \"173.0.2.250/24\", \"00:de:ad:01:00:03\", \\\n         \"173.0.2.1\")\n\ncheck ovn-nbctl acl-add s1 from-lport 1001 \"ip\" allow\ncheck ovn-nbctl acl-add s1 to-lport 1002 \"ip\" allow\ncheck ovn-nbctl acl-add s2 from-lport 1003 \"ip\" allow\ncheck ovn-nbctl acl-add s2 to-lport 1004 \"ip\" allow\ncheck ovn-nbctl --wait=hv sync\nAS_BOX([initial ping])\n# Send ping in background. Same ping, same flow throughout the test\non_exit 'kill $(pidof ping)'\nNS_EXEC([vm1], [ping -c 10000 -i 0.1 30.0.0.1 > icmp.txt &])\n\n# Check for conntrack entries\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(173.0.1.2) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=173.0.1.2,dst=173.0.2.2,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>\nicmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=2\n])\n\n# Now check for multiple ct_commits\novs-appctl dpctl/dump-flows > dp_flows\nzone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep vm1 | cut -d ' ' -f2)\nAT_CHECK([test 1 = `cat dp_flows | grep \"commit,zone=$zone_id\" | wc -l`])\n\ncheck ovn-nbctl acl-del s1 from-lport 1001 \"ip\"\ncheck ovn-nbctl acl-del s1 to-lport 1002 \"ip\"\ncheck ovn-nbctl acl-del s2 from-lport 1003 \"ip\"\ncheck ovn-nbctl acl-del s2 to-lport 1004 \"ip\"\n\nAS_BOX([acl drop echo request])\ncheck ovn-nbctl --log --severity=alert --name=drop-flow-s1 acl-add s1 to-lport 2001 icmp4 drop\n# acl-drop to-lport s1 apply to traffic from s1 to vm1 and s1 to r1.\ncheck ovn-nbctl --wait=hv sync\n\n# Check that traffic is blocked\n# Wait for some packets to hit the rule to avoid potential race conditions. Then count packets.\nOVS_WAIT_UNTIL([test `cat ovn-controller.log | grep acl_log | grep -c drop-flow-s1` -gt \"0\"])\ntotal_icmp_pkts=$(cat icmp.txt | grep ttl | wc -l)\n\n# Wait some time and check whether packets went through. In the worse race condition, the sleep is too short\n# and this test will still succeed.\nsleep 1\nOVS_WAIT_UNTIL([\n        total_icmp1_pkts=$(cat icmp.txt | grep ttl | wc -l)\n        test \"${total_icmp1_pkts}\" -eq \"${total_icmp_pkts}\"\n])\n\nAS_BOX([acl allow-related echo request])\ncheck ovn-nbctl acl-add s1 to-lport 2002 \"icmp4 && ip4.src == 173.0.1.2\" allow-related\n# This rule has higher priority than to-lport 2001 icmp4 drop.\n# So traffic from s1 (w/ src=173.0.1.2) to r1 should be accepted\n# (return) traffic from s1 to vm1 should be accepted as return traffic\ncheck ovn-nbctl --wait=hv sync\nOVS_WAIT_UNTIL([\n        total_icmp1_pkts=$(cat icmp.txt | grep ttl | wc -l)\n        test \"${total_icmp1_pkts}\" -gt \"${total_icmp_pkts}\"\n])\n\n# Check we did not break handling acl-drop for existing flows\nAS_BOX([acl drop echo request in s2])\ncheck ovn-nbctl acl-del s1 to-lport 2001 icmp4\ncheck ovn-nbctl --log --severity=alert --name=drop-flow-s2 acl-add s2 to-lport 2001 icmp4 drop\ncheck ovn-nbctl --wait=hv sync\n\nOVS_WAIT_UNTIL([test `cat ovn-controller.log | grep acl_log | grep -c drop-flow-s2` -gt \"0\"])\n\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \\\n      sed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl\nicmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=<cleared>\n])\ntotal_icmp_pkts=$(cat icmp.txt | grep ttl | wc -l)\n\n# Allow ping again\nAS_BOX([acl allow echo request in s2])\ncheck ovn-nbctl acl-add s2 to-lport 2005 icmp4 allow\ncheck ovn-nbctl --wait=hv sync\nOVS_WAIT_FOR_OUTPUT([\n    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \\\n      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\nicmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=2\n])\nOVS_WAIT_UNTIL([\n        total_icmp1_pkts=$(cat icmp.txt | grep ttl | wc -l)\n        test \"${total_icmp1_pkts}\" -gt \"${total_icmp_pkts}\"\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\n# This tests port->up/down and ovn-installed after adding and removing Ports and Interfaces.\n# 3 Conditions x 3 tests:\n# - 3 Conditions:\n#   - In normal conditions\n#   - Remove interface while starting and stopping SB and Controller\n#   - Remove and add back interface while starting and stopping SB and Controller\n# - 3 tests:\n#   - Add/Remove Logical Port\n#   - Add/Remove iface-id\n#   - Add/Remove Interface\n# Each tests/conditions checks for\n# - Port_binding->chassis\n# - Port up or down\n# - ovn-installed\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ovn-install on slow ovsdb])\nAT_KEYWORDS([ovn-install])\n\nOVS_TRAFFIC_VSWITCHD_START()\n# Restart ovsdb-server, this time with tcp\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\nstart_daemon ovsdb-server --remote=punix:\"$OVS_RUNDIR\"/db.sock --remote=ptcp:0:127.0.0.1\n\novn_start\nADD_BR([br-int])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nPARSE_LISTENING_PORT([$ovs_base/ovsdb-server.log], [TCP_PORT])\nstart_daemon ovn-controller tcp:127.0.0.1:$TCP_PORT\n\ncheck ovn-nbctl ls-add ls1\ncheck ovn-nbctl set Logical_Switch ls1 other_config:subnet=10.1.0.0/16\n\ncheck ovn-nbctl --wait=hv sync\n\nadd_logical_ports() {\n  echo Adding logical ports\n  check ovn-nbctl lsp-add ls1 lsp1\n  check ovn-nbctl lsp-add ls1 lsp2\n}\n\nremove_logical_ports() {\n  echo Removing logical ports\n  check ovn-nbctl lsp-del lsp1\n  check ovn-nbctl lsp-del lsp2\n}\n\nadd_ovs_interface() {\n  echo Adding interface $1 $2\n  ovs-vsctl --no-wait -- add-port br-int $1 \\\n                      -- set Interface $1 external_ids:iface-id=$2 \\\n                      -- set Interface $1 type=internal\n}\nadd_ovs_interfaces() {\n  add_ovs_interface vif1 lsp1\n  add_ovs_interface vif2 lsp2\n}\nremove_ovs_interface() {\n  echo Removing interface $1\n  check ovs-vsctl --no-wait -- del-port $1\n}\nremove_ovs_interfaces() {\n  remove_ovs_interface vif1\n  remove_ovs_interface vif2\n}\nadd_iface_ids() {\n  echo Adding iface-id vif1 lsp1\n  ovs-vsctl --no-wait -- set Interface vif1 external_ids:iface-id=lsp1\n  echo Adding iface-id vif2 lsp2\n  ovs-vsctl --no-wait -- set Interface vif2 external_ids:iface-id=lsp2\n}\nremove_iface_id() {\n  echo Removing iface-id $1\n  check ovs-vsctl remove Interface $1 external_ids iface-id\n}\nremove_iface_ids() {\n  remove_iface_id vif1\n  remove_iface_id vif2\n}\nwait_for_local_bindings() {\n  OVS_WAIT_UNTIL(\n      [test `ovs-appctl -t ovn-controller debug/dump-local-bindings | grep interface | wc -l` -eq 2],\n      [kill -CONT $(cat ovn-sb/ovsdb-server.pid)]\n  )\n}\nsleep_sb() {\n  echo SB going to sleep\n  AT_CHECK([kill -STOP $(cat ovn-sb/ovsdb-server.pid)])\n}\nwake_up_sb() {\n  echo SB waking up\n  AT_CHECK([kill -CONT $(cat ovn-sb/ovsdb-server.pid)])\n}\nsleep_controller() {\n  echo Controller going to sleep\n  ovn-appctl debug/pause\n  OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) = \"xpaused\"])\n}\n\nstop_ovsdb_controller_updates() {\n  TCP_PORT=$1\n  echo Stopping updates from ovn-controller to ovsdb using port $TCP_PORT\n  on_exit 'iptables -C INPUT -p tcp --destination-port $TCP_PORT -j DROP 2>/dev/null && iptables -D INPUT -p tcp --destination-port $TCP_PORT -j DROP'\n  iptables -A INPUT -p tcp --destination-port $TCP_PORT -j DROP\n}\nrestart_ovsdb_controller_updates() {\n  TCP_PORT=$1\n  echo Restarting updates from ovn-controller to ovsdb\n  iptables -D INPUT -p tcp --destination-port $TCP_PORT  -j DROP\n}\nwake_up_controller() {\n  echo Controller waking up\n  ovn-appctl debug/resume\n}\nensure_controller_run() {\n# We want to make sure controller could run at least one full loop.\n# We can't use wait=hv as sb might be sleeping.\n# Use 2 ovn-appctl to guarentee that ovn-controller run the full loop, and not just the unixctl handling\n  OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) = \"xrunning\"])\n  OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) = \"xrunning\"])\n}\nsleep_ovsdb() {\n  echo OVSDB going to sleep\n  AT_CHECK([kill -STOP $(cat ovsdb-server.pid)])\n}\nwake_up_ovsdb() {\n  echo OVSDB waking up\n  AT_CHECK([kill -CONT $(cat ovsdb-server.pid)])\n}\ncheck_ovn_installed() {\n  OVS_WAIT_UNTIL([test `ovs-vsctl get Interface vif1 external_ids:ovn-installed` = '\"true\"'])\n  OVS_WAIT_UNTIL([test `ovs-vsctl get Interface vif2 external_ids:ovn-installed` = '\"true\"'])\n}\ncheck_ovn_uninstalled() {\n  OVS_WAIT_UNTIL([test x`ovs-vsctl get Interface vif2 external_ids:ovn-installed` = x])\n  OVS_WAIT_UNTIL([test x`ovs-vsctl get Interface vif1 external_ids:ovn-installed` = x])\n}\ncheck_ports_up() {\n  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp1 up` = 'true'])\n  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp2 up` = 'true'])\n}\ncheck_ports_down() {\n  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp1 up` = 'false'])\n  OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp2 up` = 'false'])\n}\n\ncheck_ports_bound() {\n  ch=$(fetch_column Chassis _uuid name=hv1)\n  wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch\n  wait_row_count Port_Binding 1 logical_port=lsp2 chassis=$ch\n}\ncheck_ports_unbound() {\n  wait_column \"\" Port_Binding chassis logical_port=lsp1\n  wait_column \"\" Port_Binding chassis logical_port=lsp2\n}\nadd_logical_ports\nadd_ovs_interfaces\nwait_for_local_bindings\nwait_for_ports_up\ncheck ovn-nbctl --wait=hv sync\n############################################################\n########## Remove interface while removing iface-id ########\n############################################################\nAS_BOX([\"Remove interface while removing iface-id\"])\nstop_ovsdb_controller_updates $TCP_PORT\nremove_iface_id vif1\nensure_controller_run\n# OVSDB should be seen as ro now\nremove_iface_id vif2\nensure_controller_run\n# Controller delaying ovn-install removal for vif2 as ovsdb ro\nsleep_controller\nrestart_ovsdb_controller_updates $TCP_PORT\nremove_ovs_interface vif2\n# vif2, for which we want to remove ovn-install, is deleted\nwake_up_controller\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\nadd_ovs_interface vif2 lsp2\nadd_iface_ids\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\n############################################################\n################### Add/Remove iface-id ####################\n############################################################\nAS_BOX([\"iface-id removal and added back (no sleeping sb or controller)\"])\nremove_iface_ids\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\nadd_iface_ids\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\n\nAS_BOX([\"iface-id removal\"])\nsleep_sb\nremove_iface_ids\nensure_controller_run\nsleep_controller\nwake_up_sb\nwake_up_controller\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\nadd_iface_ids\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"iface-id removal 2\"])\n# Block IDL from ovn-controller to OVSDB\nstop_ovsdb_controller_updates $TCP_PORT\nremove_iface_id vif2\nensure_controller_run\n\n# OVSDB should now be seen as read-only by ovn-controller\nremove_iface_id vif1\nensure_controller_run\n\n# Restart connection from ovn-controller to OVSDB\nrestart_ovsdb_controller_updates $TCP_PORT\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\n\nadd_iface_ids\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"iface-id removal and added back\"])\nsleep_sb\nremove_iface_ids\nensure_controller_run\nsleep_controller\nadd_iface_ids\nwake_up_sb\nwake_up_controller\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\n############################################################\n###################### Add/Remove Interface ################\n############################################################\nAS_BOX([\"Interface removal and added back (no sleeping sb or controller)\"])\nremove_ovs_interfaces\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\nadd_ovs_interfaces\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"Interface removal\"])\nsleep_sb\nremove_ovs_interfaces\nensure_controller_run\nsleep_controller\nwake_up_sb\nwake_up_controller\ncheck_ovn_uninstalled\ncheck_ports_down\ncheck_ports_unbound\nadd_ovs_interfaces\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"Interface removal and added back\"])\nsleep_sb\nremove_ovs_interfaces\nensure_controller_run\nsleep_controller\nadd_ovs_interfaces\nwake_up_sb\nwake_up_controller\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\ncheck ovn-nbctl --wait=hv sync\n############################################################\n###################### Add/Remove Logical Port #############\n############################################################\nAS_BOX([\"Logical port removal and added back (no sleeping sb or controller)\"])\nremove_logical_ports\ncheck_ovn_uninstalled\ncheck_ports_unbound\nsleep_ovsdb\nadd_logical_ports\nensure_controller_run\nwake_up_ovsdb\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"Logical port removal\"])\nsleep_sb\nremove_logical_ports\nensure_controller_run\nsleep_controller\nwake_up_sb\nwake_up_controller\ncheck_ovn_uninstalled\ncheck_ports_unbound\nadd_logical_ports\ncheck ovn-nbctl --wait=hv sync\n\nAS_BOX([\"Logical port removal and added back\"])\nsleep_sb\nremove_logical_ports\nensure_controller_run\nsleep_controller\nadd_logical_ports\nwake_up_sb\nwake_up_controller\ncheck_ovn_installed\ncheck_ports_up\ncheck_ports_bound\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([ovn mirroring])\nAT_KEYWORDS([mirror])\nAT_SKIP_IF([test $HAVE_TCPDUMP = no])\n\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-mirror])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\n# Start ovn-controller\nstart_daemon ovn-controller\n\novs-ofctl add-flow br-mirror action=normal\n\novn-nbctl create Logical_Router name=R1 options:chassis=hv1\n\novn-nbctl ls-add foo\novn-nbctl ls-add bar\n\n# Connect foo to R1\novn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 2001::1/64\novn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \\\n    type=router options:router-port=foo addresses=\\\"00:00:01:01:02:03\\\"\n\n# Connect bar to R1\novn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 2002::1/64\novn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \\\n    type=router options:router-port=bar addresses=\\\"00:00:01:01:02:04\\\"\n\n# Logical port 'foo1' in switch 'foo'.\nADD_NAMESPACES(foo1)\nADD_VETH(foo1, foo1, br-int, \"2001::2/64\", \"f0:00:00:01:02:03\", \\\n         \"2001::1\", \"nodad\", \"192.168.1.2/24\", \"192.168.1.1\")\novn-nbctl lsp-add foo foo1 \\\n-- lsp-set-addresses foo1 \"f0:00:00:01:02:03 192.168.1.2 2001::2\"\n\n# Logical port 'bar1' in switch 'bar'.\nADD_NAMESPACES(bar1)\nADD_VETH(bar1, bar1, br-int, \"2002::2/64\", \"f0:00:00:01:02:05\", \\\n         \"2002::1\", \"nodad\", \"192.168.2.2/24\", \"192.168.2.1\")\novn-nbctl --wait=hv lsp-add bar bar1 \\\n-- lsp-set-addresses bar1 \"f0:00:00:01:02:05 192.168.2.2 2002::2\"\n\novn-nbctl mirror-add mirror0 gre 1 to-lport 172.16.0.100\novn-nbctl lsp-attach-mirror bar1 mirror0\n\nOVN_POPULATE_ARP\ncheck ovn-nbctl --wait=hv sync\n\nADD_NAMESPACES(mirror)\nADD_VETH(mirror, mirror, br-mirror, \"2003::b/64\", \"f0:00:00:01:07:06\", \\\n         \"2003::1\", \"nodad\", \"172.16.0.100/24\", \"172.16.0.1\")\nAT_CHECK([ip addr add 172.16.0.101/24 dev br-mirror])\nAT_CHECK([ip addr add 2003::a/64 dev br-mirror nodad])\nAT_CHECK([ip link set dev br-mirror up])\n\nNS_CHECK_EXEC([mirror], [tcpdump -l -c 3 -neei mirror proto GRE > gre_mirror4.pcap 2>gre_mirror4_error &])\nOVS_WAIT_UNTIL([grep \"listening\" gre_mirror4_error])\n\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\nOVS_WAIT_UNTIL([\n    n_packets=$(grep \"GRE\" -c gre_mirror4.pcap)\n    test \"${n_packets}\" = \"3\"\n])\n\nkillall tcpdump\n\novn-nbctl mirror-del mirror0\novn-nbctl mirror-add mirror1 gre 2 to-lport 2003::b\n\novn-nbctl --wait=hv lsp-attach-mirror bar1 mirror1\n\nNS_CHECK_EXEC([mirror], [tcpdump -l -c 3 -neei mirror proto GRE > gre_mirror6.pcap 2>gre_mirror6_error &])\nOVS_WAIT_UNTIL([grep \"listening\" gre_mirror6_error])\n\nNS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 2002::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_WAIT_UNTIL([\n    n_packets=$(grep \"GRE\" -c gre_mirror6.pcap)\n    test \"${n_packets}\" = \"3\"\n])\n\nkillall tcpdump\n\novn-nbctl mirror-del mirror1\novn-nbctl mirror-add mirror2 erspan 3 to-lport 172.16.0.100\novn-nbctl --wait=hv lsp-attach-mirror bar1 mirror2\n\nNS_CHECK_EXEC([mirror], [tcpdump -l -c 3 -neei mirror ip[[22:2]]=0x88be > erspan_mirror4.pcap 2>erspan_mirror4_error &])\nOVS_WAIT_UNTIL([grep \"listening\" erspan_mirror4_error])\n\nNS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\nOVS_WAIT_UNTIL([\n    n_packets=$(grep \"gre-proto-0x88be\" -c erspan_mirror4.pcap)\n    test \"${n_packets}\" = \"3\"\n])\n\nkillall tcpdump\n\novn-nbctl mirror-del mirror2\novn-nbctl mirror-add mirror3 erspan 4 to-lport 2003::b\novn-nbctl --wait=hv lsp-attach-mirror bar1 mirror3\n\nNS_CHECK_EXEC([mirror], [tcpdump -l -c 3 -neei mirror ip6[[42:2]]=0x88be > erspan_mirror6.pcap 2>erspan_mirror6_error &])\nOVS_WAIT_UNTIL([grep \"listening\" erspan_mirror6_error])\n\nNS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 2002::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\nOVS_WAIT_UNTIL([\n    n_packets=$(grep \"gre-proto-0x88be\" -c erspan_mirror6.pcap)\n    test \"${n_packets}\" = \"3\"\n])\n\nkillall tcpdump\n\nuuid=$(fetch_column nb:mirror _uuid name=\"mirror3\")\novn-nbctl --wait=hv set mirror $uuid type=gre\n\nNS_CHECK_EXEC([mirror], [tcpdump -c 3 -l -neei mirror proto GRE > gre_mirror6.pcap 2>gre_mirror6_error &])\nOVS_WAIT_UNTIL([grep \"listening\" gre_mirror6_error])\n\nNS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 2002::2 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\nOVS_WAIT_UNTIL([\n    n_packets=$(grep \"GRE\" -c gre_mirror6.pcap)\n    test \"${n_packets}\" = \"3\"\n])\n\nkillall tcpdump\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([load balancer with localnet port])\nCHECK_CONNTRACK()\nCHECK_CONNTRACK_NAT()\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-phys], [set Bridge br-phys fail-mode=standalone])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add ro\ncheck ovn-nbctl lrp-add ro ro-sw 00:00:00:00:00:01 192.168.0.1/24\ncheck ovn-nbctl lrp-add ro ro-pub 00:00:00:00:01:01 10.0.0.1/24\n\ncheck ovn-nbctl ls-add sw\ncheck ovn-nbctl lsp-add sw sw-vm1 \\\n    -- lsp-set-addresses sw-vm1 \"00:00:00:00:00:02 192.168.0.2\"\ncheck ovn-nbctl lsp-add sw sw-ro \\\n    -- lsp-set-type sw-ro router \\\n    -- lsp-set-addresses sw-ro router \\\n    -- lsp-set-options sw-ro router-port=ro-sw\n\ncheck ovn-nbctl ls-add pub\ncheck ovn-nbctl lsp-add pub sw-ln \\\n    -- lsp-set-type sw-ln localnet \\\n    -- lsp-set-addresses sw-ln unknown \\\n    -- lsp-set-options sw-ln network_name=phys\ncheck ovn-nbctl lsp-add pub pub-ro \\\n    -- lsp-set-type pub-ro router \\\n    -- lsp-set-addresses pub-ro router \\\n    -- lsp-set-options pub-ro router-port=ro-pub\n\ncheck ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys\n\nADD_NAMESPACES(sw-vm1)\nADD_VETH(sw-vm1, sw-vm1, br-int, \"192.168.0.2/24\", \"00:00:00:00:00:02\", \\\n         \"192.168.0.1\")\n\nADD_NAMESPACES(ln)\nADD_VETH(ln, ln, br-phys, \"10.0.0.2/24\", \"00:00:00:00:01:02\", \\\n         \"10.0.0.1\")\n\n# We have the basic network set up. Now let's add a load balancer\n# on the \"pub\" logical switch.\n\ncheck ovn-nbctl lb-add ln-lb 172.16.0.1:80 192.168.0.2:80 tcp\ncheck ovn-nbctl ls-lb-add pub ln-lb\ncheck ovn-nbctl --wait=hv sync\n\n# Add a route so that the localnet port can reach the load balancer\n# VIP.\nNS_CHECK_EXEC([ln], [ip route add 172.16.0.1 via 10.0.0.1])\nNS_CHECK_EXEC([ln], [ip route add 192.168.0.0/24 via 10.0.0.1])\n\nOVS_START_L7([sw-vm1], [http])\n\nNS_CHECK_EXEC([ln], [wget 172.16.0.1 -t 5 -T 1 --retry-connrefused -v -o wget.log])\n\nAT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.1) | \\\nsed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl\ntcp,orig=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.0.2,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)\n])\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n\nOVN_FOR_EACH_NORTHD([\nAT_SETUP([Traffic to router port via LLA])\novn_start\nOVS_TRAFFIC_VSWITCHD_START()\nADD_BR([br-int])\nADD_BR([br-phys], [set Bridge br-phys fail-mode=standalone])\n\n# Set external-ids in br-int needed for ovn-controller\novs-vsctl \\\n        -- set Open_vSwitch . external-ids:system-id=hv1 \\\n        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \\\n        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \\\n        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \\\n        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true\n\nstart_daemon ovn-controller\n\ncheck ovn-nbctl lr-add lr0\ncheck ovn-nbctl lrp-add lr0 lr0-ls0 00:00:00:00:00:01 fd00::1/64\n\ncheck ovn-nbctl ls-add ls0\ncheck ovn-nbctl lsp-add ls0 vif0 \\\n    -- lsp-set-addresses vif0 \"00:00:00:00:00:02 fd00::2\"\ncheck ovn-nbctl lsp-add ls0 ls0-lr0 \\\n    -- lsp-set-type ls0-lr0 router \\\n    -- lsp-set-addresses ls0-lr0 router \\\n    -- lsp-set-options ls0-lr0 router-port=lr0-ls0\n\nADD_NAMESPACES(vif0)\nADD_VETH(vif0, vif0, br-int, \"fd00::2/64\", \"00:00:00:00:00:02\", \"fd00::1\")\nOVS_WAIT_UNTIL([test \"$(ip netns exec vif0 ip a | grep fe80:: | grep tentative)\" = \"\"])\n\ncheck ovn-nbctl set logical_router lr0 options:always_learn_from_arp_request=false\n\nOVN_POPULATE_ARP\nwait_for_ports_up\ncheck ovn-nbctl --wait=sb sync\n\nNS_CHECK_EXEC([vif0], [ping -q -c 3 -i 0.3 -w 2 fe80::200:ff:fe00:1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\ncheck_row_count mac_binding 1 mac=\\\"00:00:00:00:00:02\\\"\novn-sbctl --all destroy mac_binding\n\novn-nbctl --wait=hv set logical_router lr0 options:always_learn_from_arp_request=true\n\nNS_CHECK_EXEC([vif0], [ping -q -c 3 -i 0.3 -w 2 fe80::200:ff:fe00:1 | FORMAT_PING], \\\n[0], [dnl\n3 packets transmitted, 3 received, 0% packet loss, time 0ms\n])\n\ncheck_row_count mac_binding 1 mac=\\\"00:00:00:00:00:02\\\"\n\nOVS_APP_EXIT_AND_WAIT([ovn-controller])\n\nas ovn-sb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas ovn-nb\nOVS_APP_EXIT_AND_WAIT([ovsdb-server])\n\nas northd\nOVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])\n\nas\nOVS_TRAFFIC_VSWITCHD_STOP([\"/failed to query port patch-.*/d\n/connection dropped.*/d\"])\n\nAT_CLEANUP\n])\n"], "filenames": ["lib/copp.c", "lib/copp.h", "northd/northd.c", "ovn-nb.xml", "tests/ovn-northd.at", "tests/system-ovn.at"], "buggy_code_start_loc": [40, 39, 8932, 467, 3547, 7284], "buggy_code_end_loc": [40, 39, 8935, 467, 3548, 7299], "fixing_code_start_loc": [41, 40, 8932, 468, 3547, 7285], "fixing_code_end_loc": [42, 41, 8937, 472, 3548, 7317], "type": "CWE-770", "message": "A flaw was found in Open Virtual Network where the service monitor MAC does not properly rate limit. This issue could allow an attacker to cause a denial of service, including on deployments with CoPP enabled and properly configured.", "other": {"cve": {"id": "CVE-2023-3153", "sourceIdentifier": "secalert@redhat.com", "published": "2023-10-04T12:15:10.503", "lastModified": "2023-11-07T04:18:03.807", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "A flaw was found in Open Virtual Network where the service monitor MAC does not properly rate limit. This issue could allow an attacker to cause a denial of service, including on deployments with CoPP enabled and properly configured."}, {"lang": "es", "value": "Se encontr\u00f3 una falla en Open Virtual Network donde el monitor de servicio MAC no califica correctamente el l\u00edmite. Este problema podr\u00eda permitir que un atacante provoque una denegaci\u00f3n de servicio, incluso en implementaciones con CoPP habilitado y configurado correctamente."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ovn:open_virtual_network:*:*:*:*:*:*:*:*", "versionEndExcluding": "22.03.3", "matchCriteriaId": "5CA7DFF4-C739-4EE8-AC5D-6EC06E387309"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ovn:open_virtual_network:*:*:*:*:*:*:*:*", "versionStartIncluding": "22.03.4", "versionEndExcluding": "22.09.2", "matchCriteriaId": "66B2BA9A-04F3-4E63-B367-E7AE5AD04FB1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ovn:open_virtual_network:*:*:*:*:*:*:*:*", "versionStartIncluding": "22.09.3", "versionEndExcluding": "22.12.1", "matchCriteriaId": "393B5A8F-01A6-48E3-9D04-E9F5EDDCA555"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ovn:open_virtual_network:*:*:*:*:*:*:*:*", "versionStartIncluding": "22.12.2", "versionEndExcluding": "23.03.1", "matchCriteriaId": "20978238-A456-4B17-B7AD-DC006C6B16A2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ovn:open_virtual_network:*:*:*:*:*:*:*:*", "versionStartIncluding": "23.03.2", "versionEndExcluding": "23.06.1", "matchCriteriaId": "D7AF4A0C-4E74-4721-96E0-E5A400B9AF58"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:openshift_container_platform:4.0:*:*:*:*:*:*:*", "matchCriteriaId": "932D137F-528B-4526-9A89-CD59FA1AB0FE"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redhat:fast_datapath:-:*:*:*:*:*:*:*", "matchCriteriaId": "0A63D05D-BFAF-484B-BA49-5F5E399CDA02"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:o:redhat:enterprise_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7F6FB57C-2BC7-487C-96DD-132683AEB35D"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2023-3153", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2213279", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/ovn-org/ovn/commit/9a3f7ed905e525ebdcb14541e775211cbb0203bd", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://github.com/ovn-org/ovn/issues/198", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://mail.openvswitch.org/pipermail/ovs-announce/2023-August/000327.html", "source": "secalert@redhat.com", "tags": ["Mitigation", "Patch"]}, {"url": "https://mail.openvswitch.org/pipermail/ovs-dev/2023-August/407553.html", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/ovn-org/ovn/commit/9a3f7ed905e525ebdcb14541e775211cbb0203bd"}}