{"buggy_code": ["# Redmine - project management software\n# Copyright (C) 2006-2017  Jean-Philippe Lang\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nrequire 'redmine/scm/adapters/abstract_adapter'\nrequire 'cgi'\n\nmodule Redmine\n  module Scm\n    module Adapters\n      class MercurialAdapter < AbstractAdapter\n\n        # Mercurial executable name\n        HG_BIN = Redmine::Configuration['scm_mercurial_command'] || \"hg\"\n        HELPERS_DIR = File.dirname(__FILE__) + \"/mercurial\"\n        HG_HELPER_EXT = \"#{HELPERS_DIR}/redminehelper.py\"\n        TEMPLATE_NAME = \"hg-template\"\n        TEMPLATE_EXTENSION = \"tmpl\"\n\n        # raised if hg command exited with error, e.g. unknown revision.\n        class HgCommandAborted < CommandFailed; end\n        # raised if bad command argument detected before executing hg.\n        class HgCommandArgumentError < CommandFailed; end\n\n        class << self\n          def client_command\n            @@bin    ||= HG_BIN\n          end\n\n          def sq_bin\n            @@sq_bin ||= shell_quote_command\n          end\n\n          def client_version\n            @@client_version ||= (hgversion || [])\n          end\n\n          def client_available\n            client_version_above?([1, 2])\n          end\n\n          def hgversion\n            # The hg version is expressed either as a\n            # release number (eg 0.9.5 or 1.0) or as a revision\n            # id composed of 12 hexa characters.\n            theversion = hgversion_from_command_line.dup.force_encoding('ASCII-8BIT')\n            if m = theversion.match(%r{\\A(.*?)((\\d+\\.)+\\d+)})\n              m[2].scan(%r{\\d+}).collect(&:to_i)\n            end\n          end\n\n          def hgversion_from_command_line\n            shellout(\"#{sq_bin} --version\") { |io| io.read }.to_s\n          end\n\n          def template_path\n            @@template_path ||= template_path_for(client_version)\n          end\n\n          def template_path_for(version)\n            \"#{HELPERS_DIR}/#{TEMPLATE_NAME}-1.0.#{TEMPLATE_EXTENSION}\"\n          end\n        end\n\n        def initialize(url, root_url=nil, login=nil, password=nil, path_encoding=nil)\n          super\n          @path_encoding = path_encoding.blank? ? 'UTF-8' : path_encoding\n        end\n\n        def path_encoding\n          @path_encoding\n        end\n\n        def info\n          tip = summary['repository']['tip']\n          Info.new(:root_url => CGI.unescape(summary['repository']['root']),\n                   :lastrev => Revision.new(:revision => tip['revision'],\n                                            :scmid => tip['node']))\n        # rescue HgCommandAborted\n        rescue Exception => e\n          logger.error \"hg: error during getting info: #{e.message}\"\n          nil\n        end\n\n        def tags\n          as_ary(summary['repository']['tag']).map { |e| e['name'] }\n        end\n\n        # Returns map of {'tag' => 'nodeid', ...}\n        def tagmap\n          alist = as_ary(summary['repository']['tag']).map do |e|\n            e.values_at('name', 'node')\n          end\n          Hash[*alist.flatten]\n        end\n\n        def branches\n          brs = []\n          as_ary(summary['repository']['branch']).each do |e|\n            br = Branch.new(e['name'])\n            br.revision =  e['revision']\n            br.scmid    =  e['node']\n            brs << br\n          end\n          brs\n        end\n\n        # Returns map of {'branch' => 'nodeid', ...}\n        def branchmap\n          alist = as_ary(summary['repository']['branch']).map do |e|\n            e.values_at('name', 'node')\n          end\n          Hash[*alist.flatten]\n        end\n\n        def summary\n          return @summary if @summary\n          hg 'rhsummary' do |io|\n            output = io.read.force_encoding('UTF-8')\n            begin\n              @summary = parse_xml(output)['rhsummary']\n            rescue\n            end\n          end\n        end\n        private :summary\n\n        def entries(path=nil, identifier=nil, options={})\n          p1 = scm_iconv(@path_encoding, 'UTF-8', path)\n          manifest = hg('rhmanifest', '-r', CGI.escape(hgrev(identifier)),\n                        CGI.escape(without_leading_slash(p1.to_s))) do |io|\n            output = io.read.force_encoding('UTF-8')\n            begin\n              parse_xml(output)['rhmanifest']['repository']['manifest']\n            rescue\n            end\n          end\n          path_prefix = path.blank? ? '' : with_trailling_slash(path)\n\n          entries = Entries.new\n          as_ary(manifest['dir']).each do |e|\n            n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name']))\n            p = \"#{path_prefix}#{n}\"\n            entries << Entry.new(:name => n, :path => p, :kind => 'dir')\n          end\n\n          as_ary(manifest['file']).each do |e|\n            n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name']))\n            p = \"#{path_prefix}#{n}\"\n            lr = Revision.new(:revision => e['revision'], :scmid => e['node'],\n                              :identifier => e['node'],\n                              :time => Time.at(e['time'].to_i))\n            entries << Entry.new(:name => n, :path => p, :kind => 'file',\n                                 :size => e['size'].to_i, :lastrev => lr)\n          end\n\n          entries\n        rescue HgCommandAborted\n          nil  # means not found\n        end\n\n        def revisions(path=nil, identifier_from=nil, identifier_to=nil, options={})\n          revs = Revisions.new\n          each_revision(path, identifier_from, identifier_to, options) { |e| revs << e }\n          revs\n        end\n\n        # Iterates the revisions by using a template file that\n        # makes Mercurial produce a xml output.\n        def each_revision(path=nil, identifier_from=nil, identifier_to=nil, options={})\n          hg_args = ['log', '--debug', '-C', '--style', self.class.template_path]\n          hg_args << '-r' << \"#{hgrev(identifier_from)}:#{hgrev(identifier_to)}\"\n          hg_args << '--limit' << options[:limit] if options[:limit]\n          hg_args << hgtarget(path) unless path.blank?\n          log = hg(*hg_args) do |io|\n            output = io.read.force_encoding('UTF-8')\n            begin\n              # Mercurial < 1.5 does not support footer template for '</log>'\n              parse_xml(\"#{output}</log>\")['log']\n            rescue\n            end\n          end\n          as_ary(log['logentry']).each do |le|\n            cpalist = as_ary(le['paths']['path-copied']).map do |e|\n              [e['__content__'], e['copyfrom-path']].map do |s|\n                scm_iconv('UTF-8', @path_encoding, CGI.unescape(s))\n              end\n            end\n            cpmap = Hash[*cpalist.flatten]\n            paths = as_ary(le['paths']['path']).map do |e|\n              p = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['__content__']) )\n              {:action        => e['action'],\n               :path          => with_leading_slash(p),\n               :from_path     => (cpmap.member?(p) ? with_leading_slash(cpmap[p]) : nil),\n               :from_revision => (cpmap.member?(p) ? le['node'] : nil)}\n            end.sort { |a, b| a[:path] <=> b[:path] }\n            parents_ary = []\n            as_ary(le['parents']['parent']).map do |par|\n              parents_ary << par['__content__'] if par['__content__'] != \"0000000000000000000000000000000000000000\"\n            end\n            yield Revision.new(:revision => le['revision'],\n                               :scmid    => le['node'],\n                               :author   => (le['author']['__content__'] rescue ''),\n                               :time     => Time.parse(le['date']['__content__']),\n                               :message  => le['msg']['__content__'],\n                               :paths    => paths,\n                               :parents  => parents_ary)\n          end\n          self\n        end\n\n        # Returns list of nodes in the specified branch\n        def nodes_in_branch(branch, options={})\n          hg_args = ['rhlog', '--template', '{node}\\n', '--rhbranch', CGI.escape(branch)]\n          hg_args << '--from' << CGI.escape(branch)\n          hg_args << '--to'   << '0'\n          hg_args << '--limit' << options[:limit] if options[:limit]\n          hg(*hg_args) { |io| io.readlines.map { |e| e.chomp } }\n        end\n\n        def diff(path, identifier_from, identifier_to=nil)\n          hg_args = %w|rhdiff|\n          if identifier_to\n            hg_args << '-r' << hgrev(identifier_to) << '-r' << hgrev(identifier_from)\n          else\n            hg_args << '-c' << hgrev(identifier_from)\n          end\n          unless path.blank?\n            p = scm_iconv(@path_encoding, 'UTF-8', path)\n            hg_args << CGI.escape(hgtarget(p))\n          end\n          diff = []\n          hg *hg_args do |io|\n            io.each_line do |line|\n              diff << line\n            end\n          end\n          diff\n        rescue HgCommandAborted\n          nil  # means not found\n        end\n\n        def cat(path, identifier=nil)\n          p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path))\n          hg 'rhcat', '-r', CGI.escape(hgrev(identifier)), hgtarget(p) do |io|\n            io.binmode\n            io.read\n          end\n        rescue HgCommandAborted\n          nil  # means not found\n        end\n\n        def annotate(path, identifier=nil)\n          p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path))\n          blame = Annotate.new\n          hg 'rhannotate', '-ncu', '-r', CGI.escape(hgrev(identifier)), hgtarget(p) do |io|\n            io.each_line do |line|\n              line.force_encoding('ASCII-8BIT')\n              next unless line =~ %r{^([^:]+)\\s(\\d+)\\s([0-9a-f]+):\\s(.*)$}\n              r = Revision.new(:author => $1.strip, :revision => $2, :scmid => $3,\n                               :identifier => $3)\n              blame.add_line($4.rstrip, r)\n            end\n          end\n          blame\n        rescue HgCommandAborted\n          # means not found or cannot be annotated\n          Annotate.new\n        end\n\n        class Revision < Redmine::Scm::Adapters::Revision\n          # Returns the readable identifier\n          def format_identifier\n            \"#{revision}:#{scmid}\"\n          end\n        end\n\n        # command options which may be processed earlier, by faulty parser in hg\n        HG_EARLY_BOOL_ARG = /^--(debugger|profile|traceback)$/\n        HG_EARLY_LIST_ARG = /^(--(config|cwd|repo(sitory)?)\\b|-R)/\n        private_constant :HG_EARLY_BOOL_ARG, :HG_EARLY_LIST_ARG\n\n        # Runs 'hg' command with the given args\n        def hg(*args, &block)\n          # as of hg 4.4.1, early parsing of bool options is not terminated at '--'\n          if args.any? { |s| s =~ HG_EARLY_BOOL_ARG }\n            raise HgCommandArgumentError, \"malicious command argument detected\"\n          end\n          if args.take_while { |s| s != '--' }.any? { |s| s =~ HG_EARLY_LIST_ARG }\n            raise HgCommandArgumentError, \"malicious command argument detected\"\n          end\n\n          repo_path = root_url || url\n          full_args = ['-R', repo_path, '--encoding', 'utf-8']\n          full_args << '--config' << \"extensions.redminehelper=#{HG_HELPER_EXT}\"\n          full_args << '--config' << 'diff.git=false'\n          full_args += args\n          ret = shellout(\n                   self.class.sq_bin + ' ' + full_args.map { |e| shell_quote e.to_s }.join(' '),\n                   &block\n                   )\n          if $? && $?.exitstatus != 0\n            raise HgCommandAborted, \"hg exited with non-zero status: #{$?.exitstatus}\"\n          end\n          ret\n        end\n        private :hg\n\n        # Returns correct revision identifier\n        def hgrev(identifier, sq=false)\n          rev = identifier.blank? ? 'tip' : identifier.to_s\n          rev = shell_quote(rev) if sq\n          rev\n        end\n        private :hgrev\n\n        def hgtarget(path)\n          path ||= ''\n          root_url + '/' + without_leading_slash(path)\n        end\n        private :hgtarget\n\n        def as_ary(o)\n          return [] unless o\n          o.is_a?(Array) ? o : Array[o]\n        end\n        private :as_ary\n      end\n    end\n  end\nend\n"], "fixing_code": ["# Redmine - project management software\n# Copyright (C) 2006-2017  Jean-Philippe Lang\n#\n# This program is free software; you can redistribute it and/or\n# modify it under the terms of the GNU General Public License\n# as published by the Free Software Foundation; either version 2\n# of the License, or (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License\n# along with this program; if not, write to the Free Software\n# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n\nrequire 'redmine/scm/adapters/abstract_adapter'\nrequire 'cgi'\n\nmodule Redmine\n  module Scm\n    module Adapters\n      class MercurialAdapter < AbstractAdapter\n\n        # Mercurial executable name\n        HG_BIN = Redmine::Configuration['scm_mercurial_command'] || \"hg\"\n        HELPERS_DIR = File.dirname(__FILE__) + \"/mercurial\"\n        HG_HELPER_EXT = \"#{HELPERS_DIR}/redminehelper.py\"\n        TEMPLATE_NAME = \"hg-template\"\n        TEMPLATE_EXTENSION = \"tmpl\"\n\n        # raised if hg command exited with error, e.g. unknown revision.\n        class HgCommandAborted < CommandFailed; end\n        # raised if bad command argument detected before executing hg.\n        class HgCommandArgumentError < CommandFailed; end\n\n        class << self\n          def client_command\n            @@bin    ||= HG_BIN\n          end\n\n          def sq_bin\n            @@sq_bin ||= shell_quote_command\n          end\n\n          def client_version\n            @@client_version ||= (hgversion || [])\n          end\n\n          def client_available\n            client_version_above?([1, 2])\n          end\n\n          def hgversion\n            # The hg version is expressed either as a\n            # release number (eg 0.9.5 or 1.0) or as a revision\n            # id composed of 12 hexa characters.\n            theversion = hgversion_from_command_line.dup.force_encoding('ASCII-8BIT')\n            if m = theversion.match(%r{\\A(.*?)((\\d+\\.)+\\d+)})\n              m[2].scan(%r{\\d+}).collect(&:to_i)\n            end\n          end\n\n          def hgversion_from_command_line\n            shellout(\"#{sq_bin} --version\") { |io| io.read }.to_s\n          end\n\n          def template_path\n            @@template_path ||= template_path_for(client_version)\n          end\n\n          def template_path_for(version)\n            \"#{HELPERS_DIR}/#{TEMPLATE_NAME}-1.0.#{TEMPLATE_EXTENSION}\"\n          end\n        end\n\n        def initialize(url, root_url=nil, login=nil, password=nil, path_encoding=nil)\n          super\n          @path_encoding = path_encoding.blank? ? 'UTF-8' : path_encoding\n        end\n\n        def path_encoding\n          @path_encoding\n        end\n\n        def info\n          tip = summary['repository']['tip']\n          Info.new(:root_url => CGI.unescape(summary['repository']['root']),\n                   :lastrev => Revision.new(:revision => tip['revision'],\n                                            :scmid => tip['node']))\n        # rescue HgCommandAborted\n        rescue Exception => e\n          logger.error \"hg: error during getting info: #{e.message}\"\n          nil\n        end\n\n        def tags\n          as_ary(summary['repository']['tag']).map { |e| e['name'] }\n        end\n\n        # Returns map of {'tag' => 'nodeid', ...}\n        def tagmap\n          alist = as_ary(summary['repository']['tag']).map do |e|\n            e.values_at('name', 'node')\n          end\n          Hash[*alist.flatten]\n        end\n\n        def branches\n          brs = []\n          as_ary(summary['repository']['branch']).each do |e|\n            br = Branch.new(e['name'])\n            br.revision =  e['revision']\n            br.scmid    =  e['node']\n            brs << br\n          end\n          brs\n        end\n\n        # Returns map of {'branch' => 'nodeid', ...}\n        def branchmap\n          alist = as_ary(summary['repository']['branch']).map do |e|\n            e.values_at('name', 'node')\n          end\n          Hash[*alist.flatten]\n        end\n\n        def summary\n          return @summary if @summary\n          hg 'rhsummary' do |io|\n            output = io.read.force_encoding('UTF-8')\n            begin\n              @summary = parse_xml(output)['rhsummary']\n            rescue\n            end\n          end\n        end\n        private :summary\n\n        def entries(path=nil, identifier=nil, options={})\n          p1 = scm_iconv(@path_encoding, 'UTF-8', path)\n          manifest = hg('rhmanifest', '-r', CGI.escape(hgrev(identifier)),\n                        '--', CGI.escape(without_leading_slash(p1.to_s))) do |io|\n            output = io.read.force_encoding('UTF-8')\n            begin\n              parse_xml(output)['rhmanifest']['repository']['manifest']\n            rescue\n            end\n          end\n          path_prefix = path.blank? ? '' : with_trailling_slash(path)\n\n          entries = Entries.new\n          as_ary(manifest['dir']).each do |e|\n            n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name']))\n            p = \"#{path_prefix}#{n}\"\n            entries << Entry.new(:name => n, :path => p, :kind => 'dir')\n          end\n\n          as_ary(manifest['file']).each do |e|\n            n = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['name']))\n            p = \"#{path_prefix}#{n}\"\n            lr = Revision.new(:revision => e['revision'], :scmid => e['node'],\n                              :identifier => e['node'],\n                              :time => Time.at(e['time'].to_i))\n            entries << Entry.new(:name => n, :path => p, :kind => 'file',\n                                 :size => e['size'].to_i, :lastrev => lr)\n          end\n\n          entries\n        rescue HgCommandAborted\n          nil  # means not found\n        end\n\n        def revisions(path=nil, identifier_from=nil, identifier_to=nil, options={})\n          revs = Revisions.new\n          each_revision(path, identifier_from, identifier_to, options) { |e| revs << e }\n          revs\n        end\n\n        # Iterates the revisions by using a template file that\n        # makes Mercurial produce a xml output.\n        def each_revision(path=nil, identifier_from=nil, identifier_to=nil, options={})\n          hg_args = ['log', '--debug', '-C', '--style', self.class.template_path]\n          hg_args << '-r' << \"#{hgrev(identifier_from)}:#{hgrev(identifier_to)}\"\n          hg_args << '--limit' << options[:limit] if options[:limit]\n          hg_args << '--' << hgtarget(path) unless path.blank?\n          log = hg(*hg_args) do |io|\n            output = io.read.force_encoding('UTF-8')\n            begin\n              # Mercurial < 1.5 does not support footer template for '</log>'\n              parse_xml(\"#{output}</log>\")['log']\n            rescue\n            end\n          end\n          as_ary(log['logentry']).each do |le|\n            cpalist = as_ary(le['paths']['path-copied']).map do |e|\n              [e['__content__'], e['copyfrom-path']].map do |s|\n                scm_iconv('UTF-8', @path_encoding, CGI.unescape(s))\n              end\n            end\n            cpmap = Hash[*cpalist.flatten]\n            paths = as_ary(le['paths']['path']).map do |e|\n              p = scm_iconv('UTF-8', @path_encoding, CGI.unescape(e['__content__']) )\n              {:action        => e['action'],\n               :path          => with_leading_slash(p),\n               :from_path     => (cpmap.member?(p) ? with_leading_slash(cpmap[p]) : nil),\n               :from_revision => (cpmap.member?(p) ? le['node'] : nil)}\n            end.sort { |a, b| a[:path] <=> b[:path] }\n            parents_ary = []\n            as_ary(le['parents']['parent']).map do |par|\n              parents_ary << par['__content__'] if par['__content__'] != \"0000000000000000000000000000000000000000\"\n            end\n            yield Revision.new(:revision => le['revision'],\n                               :scmid    => le['node'],\n                               :author   => (le['author']['__content__'] rescue ''),\n                               :time     => Time.parse(le['date']['__content__']),\n                               :message  => le['msg']['__content__'],\n                               :paths    => paths,\n                               :parents  => parents_ary)\n          end\n          self\n        end\n\n        # Returns list of nodes in the specified branch\n        def nodes_in_branch(branch, options={})\n          hg_args = ['rhlog', '--template', '{node}\\n', '--rhbranch', CGI.escape(branch)]\n          hg_args << '--from' << CGI.escape(branch)\n          hg_args << '--to'   << '0'\n          hg_args << '--limit' << options[:limit] if options[:limit]\n          hg(*hg_args) { |io| io.readlines.map { |e| e.chomp } }\n        end\n\n        def diff(path, identifier_from, identifier_to=nil)\n          hg_args = %w|rhdiff|\n          if identifier_to\n            hg_args << '-r' << hgrev(identifier_to) << '-r' << hgrev(identifier_from)\n          else\n            hg_args << '-c' << hgrev(identifier_from)\n          end\n          unless path.blank?\n            p = scm_iconv(@path_encoding, 'UTF-8', path)\n            hg_args << '--' << CGI.escape(hgtarget(p))\n          end\n          diff = []\n          hg *hg_args do |io|\n            io.each_line do |line|\n              diff << line\n            end\n          end\n          diff\n        rescue HgCommandAborted\n          nil  # means not found\n        end\n\n        def cat(path, identifier=nil)\n          p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path))\n          hg 'rhcat', '-r', CGI.escape(hgrev(identifier)), '--', hgtarget(p) do |io|\n            io.binmode\n            io.read\n          end\n        rescue HgCommandAborted\n          nil  # means not found\n        end\n\n        def annotate(path, identifier=nil)\n          p = CGI.escape(scm_iconv(@path_encoding, 'UTF-8', path))\n          blame = Annotate.new\n          hg 'rhannotate', '-ncu', '-r', CGI.escape(hgrev(identifier)), '--', hgtarget(p) do |io|\n            io.each_line do |line|\n              line.force_encoding('ASCII-8BIT')\n              next unless line =~ %r{^([^:]+)\\s(\\d+)\\s([0-9a-f]+):\\s(.*)$}\n              r = Revision.new(:author => $1.strip, :revision => $2, :scmid => $3,\n                               :identifier => $3)\n              blame.add_line($4.rstrip, r)\n            end\n          end\n          blame\n        rescue HgCommandAborted\n          # means not found or cannot be annotated\n          Annotate.new\n        end\n\n        class Revision < Redmine::Scm::Adapters::Revision\n          # Returns the readable identifier\n          def format_identifier\n            \"#{revision}:#{scmid}\"\n          end\n        end\n\n        # command options which may be processed earlier, by faulty parser in hg\n        HG_EARLY_BOOL_ARG = /^--(debugger|profile|traceback)$/\n        HG_EARLY_LIST_ARG = /^(--(config|cwd|repo(sitory)?)\\b|-R)/\n        private_constant :HG_EARLY_BOOL_ARG, :HG_EARLY_LIST_ARG\n\n        # Runs 'hg' command with the given args\n        def hg(*args, &block)\n          # as of hg 4.4.1, early parsing of bool options is not terminated at '--'\n          if args.any? { |s| s =~ HG_EARLY_BOOL_ARG }\n            raise HgCommandArgumentError, \"malicious command argument detected\"\n          end\n          if args.take_while { |s| s != '--' }.any? { |s| s =~ HG_EARLY_LIST_ARG }\n            raise HgCommandArgumentError, \"malicious command argument detected\"\n          end\n\n          repo_path = root_url || url\n          full_args = ['-R', repo_path, '--encoding', 'utf-8']\n          full_args << '--config' << \"extensions.redminehelper=#{HG_HELPER_EXT}\"\n          full_args << '--config' << 'diff.git=false'\n          full_args += args\n          ret = shellout(\n                   self.class.sq_bin + ' ' + full_args.map { |e| shell_quote e.to_s }.join(' '),\n                   &block\n                   )\n          if $? && $?.exitstatus != 0\n            raise HgCommandAborted, \"hg exited with non-zero status: #{$?.exitstatus}\"\n          end\n          ret\n        end\n        private :hg\n\n        # Returns correct revision identifier\n        def hgrev(identifier, sq=false)\n          rev = identifier.blank? ? 'tip' : identifier.to_s\n          rev = shell_quote(rev) if sq\n          rev\n        end\n        private :hgrev\n\n        def hgtarget(path)\n          path ||= ''\n          root_url + '/' + without_leading_slash(path)\n        end\n        private :hgtarget\n\n        def as_ary(o)\n          return [] unless o\n          o.is_a?(Array) ? o : Array[o]\n        end\n        private :as_ary\n      end\n    end\n  end\nend\n"], "filenames": ["lib/redmine/scm/adapters/mercurial_adapter.rb"], "buggy_code_start_loc": [144], "buggy_code_end_loc": [270], "fixing_code_start_loc": [144], "fixing_code_end_loc": [270], "type": "NVD-CWE-noinfo", "message": "Redmine before 3.2.9, 3.3.x before 3.3.6, and 3.4.x before 3.4.4 does not block the --config and --debugger flags to the Mercurial hg program, which allows remote attackers to execute arbitrary commands (through the Mercurial adapter) via vectors involving a branch whose name begins with a --config= or --debugger= substring, a related issue to CVE-2017-17536.", "other": {"cve": {"id": "CVE-2017-18026", "sourceIdentifier": "cve@mitre.org", "published": "2018-01-10T09:29:00.190", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Redmine before 3.2.9, 3.3.x before 3.3.6, and 3.4.x before 3.4.4 does not block the --config and --debugger flags to the Mercurial hg program, which allows remote attackers to execute arbitrary commands (through the Mercurial adapter) via vectors involving a branch whose name begins with a --config= or --debugger= substring, a related issue to CVE-2017-17536."}, {"lang": "es", "value": "Redmine en versiones anteriores a la 3.2.9, 3.3.x anteriores a 3.3.6 y 3.4.x anteriores a 3.4.4 no bloquea los flags --config y --debugger en el programa Mercurial hg, lo que permite que los atacantes remotos ejecuten comandos arbitrarios (mediante el adaptador Mercurial) por medio de vectores que involucran una rama cuyo nombre empieza con una subcadena --config= o --debugger=. Esta vulnerabilidad est\u00e1 relacionada con CVE-2017-17536."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.9", "matchCriteriaId": "57E15DAF-8ECD-442F-B197-79CEE2D81138"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3.0", "versionEndExcluding": "3.3.6", "matchCriteriaId": "209D5EFB-2B31-4671-95B2-F7652E479373"}, {"vulnerable": true, "criteria": "cpe:2.3:a:redmine:redmine:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.4.0", "versionEndExcluding": "3.4.4", "matchCriteriaId": "C595C3F2-6738-4B76-BB16-F19697A846A2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/redmine/redmine/commit/58ed8655136ff2fe5ff7796859bf6a399c76c678", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/redmine/redmine/commit/9d797400eaec5f9fa7ba9507c82d9c18cb91d02e", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/redmine/redmine/commit/ca87bf766cdc70179cb2dce03015d78ec9c13ebd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2018/dsa-4191", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.redmine.org/issues/27516", "source": "cve@mitre.org", "tags": ["Permissions Required"]}, {"url": "https://www.redmine.org/projects/redmine/wiki/Security_Advisories", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/redmine/redmine/commit/58ed8655136ff2fe5ff7796859bf6a399c76c678"}}