{"buggy_code": ["/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n **/\n\nvar ticketSchema = require('../models/ticket')\nvar async = require('async')\nvar path = require('path')\nvar _ = require('lodash')\nvar winston = require('../logger')\nvar groupSchema = require('../models/group')\nvar departmentSchema = require('../models/department')\nvar permissions = require('../permissions')\nvar xss = require('xss')\n/**\n * @since 1.0\n * @author Chris Brame <polonel@gmail.com>\n * @copyright 2015 Chris Brame\n **/\n\n/**\n * @namespace\n * @description Controller for each Ticket View\n * @requires {@link Ticket}\n * @requires {@link Group}\n * @requires {@link TicketType}\n * @requires {@link Emitter}\n *\n */\nvar ticketsController = {}\n\n/**\n * @name ticketsController.content\n * @description Main Content sent to the view\n */\nticketsController.content = {}\n\nticketsController.pubNewIssue = function (req, res) {\n  var marked = require('marked')\n  var settings = require('../models/setting')\n  settings.getSettingByName('allowPublicTickets:enable', function (err, setting) {\n    if (err) return handleError(res, err)\n    if (setting && setting.value === true) {\n      settings.getSettingByName('legal:privacypolicy', function (err, privacyPolicy) {\n        if (err) return handleError(res, err)\n\n        var content = {}\n        content.title = 'New Issue'\n        content.layout = false\n        content.data = {}\n        if (privacyPolicy === null || _.isUndefined(privacyPolicy.value)) {\n          content.data.privacyPolicy = 'No Privacy Policy has been set.'\n        } else {\n          content.data.privacyPolicy = xss(marked.parse(privacyPolicy.value))\n        }\n\n        return res.render('pub_createTicket', content)\n      })\n    } else {\n      return res.redirect('/')\n    }\n  })\n}\n\n/**\n * Get Ticket View based on ticket status\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getByStatus = function (req, res, next) {\n  var url = require('url')\n  var page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  var processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: []\n  }\n\n  var fullUrl = url.format({\n    protocol: req.protocol,\n    host: req.get('host'),\n    pathname: req.originalUrl\n  })\n\n  var pathname = new url.URL(fullUrl).pathname\n  var arr = pathname.split('/')\n  var tType = 'new'\n  var s = 0\n  if (_.size(arr) > 2) tType = arr[2]\n\n  switch (tType) {\n    case 'open':\n      s = 1\n      break\n    case 'pending':\n      s = 2\n      break\n    case 'closed':\n      s = 3\n      break\n  }\n\n  processor.subnav += tType\n  processor.pagetype = tType\n  processor.object.status.push(s)\n\n  req.processor = processor\n  return next()\n}\n\n/**\n * Get Ticket View based on ticket active tickets\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getActive = function (req, res, next) {\n  var page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  var processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-active'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2]\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getAssigned = function (req, res, next) {\n  var page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  var processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-assigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'assigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    assignedSelf: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getUnassigned = function (req, res, next) {\n  var page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  var processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-unassigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'unassigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    unassigned: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\nticketsController.filter = function (req, res, next) {\n  var page = req.query.page\n  if (_.isUndefined(page)) page = 0\n\n  var queryString = req.query\n  var uid = queryString.uid\n  var subject = queryString.fs\n  var issue = queryString.it\n  var dateStart = queryString.ds\n  var dateEnd = queryString.de\n  var status = queryString.st\n  var priority = queryString.pr\n  var groups = queryString.gp\n  var types = queryString.tt\n  var tags = queryString.tag\n  var assignee = queryString.au\n\n  var rawNoPage = req.originalUrl\n    .replace(new RegExp('[?&]page=[^&#]*(#.*)?$'), '$1')\n    .replace(new RegExp('([?&])page=[^&]*&'), '$1')\n\n  if (!_.isUndefined(status) && !_.isArray(status)) status = [status]\n  if (!_.isUndefined(priority) && !_.isArray(priority)) priority = [priority]\n  if (!_.isUndefined(groups) && !_.isArray(groups)) groups = [groups]\n  if (!_.isUndefined(types) && !_.isArray(types)) types = [types]\n  if (!_.isUndefined(tags) && !_.isArray(tags)) tags = [tags]\n  if (!_.isUndefined(assignee) && !_.isArray(assignee)) assignee = [assignee]\n\n  var filter = {\n    uid: uid,\n    subject: subject,\n    issue: issue,\n    date: {\n      start: dateStart,\n      end: dateEnd\n    },\n    status: status,\n    priority: priority,\n    groups: groups,\n    tags: tags,\n    types: types,\n    assignee: assignee,\n    raw: rawNoPage\n  }\n\n  var processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'filter'\n  processor.filter = filter\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: filter.status,\n    user: req.user._id,\n    filter: filter\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Process the ```req.processor``` object and render the correct view\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Tickets View\n * @see Ticket\n */\nticketsController.processor = function (req, res) {\n  var processor = req.processor\n  if (_.isUndefined(processor)) return res.redirect('/')\n\n  var content = {}\n  content.title = processor.title\n  content.nav = processor.nav\n  content.subnav = processor.subnav\n  content.view = processor.pagetype\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  var object = processor.object\n  content.data.page = object.page\n  content.data.filter = object.filter\n\n  return res.render(processor.renderpage, content)\n}\n\nticketsController.pdf = function (req, res) {\n  var TicketPDFGenerator = require('../pdf/ticketGenerator')\n  var uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.status(404).send('Invalid Ticket UID')\n  }\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n\n    var ticketGenerator = new TicketPDFGenerator(ticket)\n\n    ticketGenerator.generate(function (err, obj) {\n      if (err) return res.redirect('/tickets')\n\n      return res.writeHead(200, obj.headers).end(obj.data)\n    })\n  })\n}\n\n/**\n * Print Ticket View\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Subviews/PrintTicket View\n */\nticketsController.print = function (req, res) {\n  var user = req.user\n  var uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.redirect('/tickets')\n  }\n\n  var content = {}\n  content.title = 'Tickets - ' + req.params.uid\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    var hasPublic = permissions.canThis(user.role, 'tickets:public')\n    var hasAccess = false\n    async.series(\n      [\n        function (next) {\n          if (user.role.isAdmin || user.role.isAgent) {\n            departmentSchema.getDepartmentGroupsOfUser(user._id, function (err, groups) {\n              if (err) return res.redirect('/tickets')\n              var gIds = groups.map(function (g) {\n                return g._id\n              })\n\n              if (_.some(gIds, ticket.group._id)) {\n                if (!permissions.canThis(user.role, 'tickets:notes')) {\n                  ticket.notes = []\n                }\n\n                hasAccess = true\n                return next()\n              } else {\n                return next('UNAUTHORIZED_GROUP_ACCESS')\n              }\n            })\n          } else {\n            return next()\n          }\n        },\n        function (next) {\n          if (hasAccess) return next()\n\n          var members = ticket.group.members.map(function (m) {\n            return m._id.toString()\n          })\n\n          if (!members.includes(user._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              return next('UNAUTHORIZED_GROUP_ACCESS')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) {\n            ticket.notes = []\n          }\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          if (err === 'UNAUTHORIZED_GROUP_ACCESS')\n            winston.warn(\n              'User tried to access ticket outside of group - UserId: ' + user._id + ' (' + user.username + ')'\n            )\n\n          return res.redirect('/tickets')\n        }\n\n        content.data.ticket = ticket\n        content.data.ticket.priorityname = ticket.priority.name\n        content.data.ticket.tagsArray = ticket.tags\n        content.data.ticket.commentCount = _.size(ticket.comments)\n        content.layout = 'layout/print'\n\n        return res.render('subviews/printticket', content)\n      }\n    )\n  })\n}\n\n/**\n * Get Single Ticket view based on UID\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Single Ticket View\n * @see Ticket\n * @example\n * //Content Object\n * content.title = \"Tickets - \" + req.params.id;\n * content.nav = 'tickets';\n *\n * content.data = {};\n * content.data.user = req.user;\n * content.data.common = req.viewdata;\n *\n * //Ticket Data\n * content.data.ticket = ticket;\n * content.data.ticket.priorityname = getPriorityName(ticket.priority);\n * content.data.ticket.tagsArray = ticket.tags;\n * content.data.ticket.commentCount = _.size(ticket.comments);\n */\nticketsController.single = function (req, res) {\n  var user = req.user\n  var uid = req.params.id\n  if (isNaN(uid)) {\n    return res.redirect('/tickets')\n  }\n\n  var content = {}\n  content.title = 'Tickets - ' + req.params.id\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    var departmentSchema = require('../models/department')\n    async.waterfall(\n      [\n        function (next) {\n          if (!req.user.role.isAdmin && !req.user.role.isAgent) {\n            return groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, next)\n          }\n\n          departmentSchema.getUserDepartments(req.user._id, function (err, departments) {\n            if (err) return next(err)\n            if (_.some(departments, { allGroups: true })) {\n              return groupSchema.find({}, next)\n            }\n\n            var groups = _.flattenDeep(\n              departments.map(function (d) {\n                return d.groups\n              })\n            )\n\n            return next(null, groups)\n          })\n        },\n        function (userGroups, next) {\n          var hasPublic = permissions.canThis(user.role, 'tickets:public')\n          var groupIds = userGroups.map(function (g) {\n            return g._id.toString()\n          })\n\n          if (!groupIds.includes(ticket.group._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              winston.warn('User access ticket outside of group - UserId: ' + user._id)\n              return res.redirect('/tickets')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'comments:view')) ticket.comments = []\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) ticket.notes = []\n\n          content.data.ticket = ticket\n          content.data.ticket.priorityname = ticket.priority.name\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          winston.warn(err)\n          return res.redirect('/tickets')\n        }\n\n        return res.render('subviews/singleticket', content)\n      }\n    )\n  })\n}\n\nticketsController.uploadImageMDE = function (req, res) {\n  var Chance = require('chance')\n  var chance = new Chance()\n  var fs = require('fs-extra')\n  var Busboy = require('busboy')\n  var busboy = new Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 5 * 1024 * 1024 // 5mb limit\n    }\n  })\n\n  var object = {}\n  var error\n\n  object.ticketId = req.headers.ticketid\n  if (!object.ticketId) return res.status(400).json({ success: false })\n\n  busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {\n    if (mimetype.indexOf('image/') === -1) {\n      error = {\n        status: 500,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    var ext = path.extname(filename)\n    var allowedExtensions = [\n      '.jpg',\n      '.jpeg',\n      '.jpe',\n      '.jif',\n      '.jfif',\n      '.jfi',\n      '.png',\n      '.gif',\n      '.webp',\n      '.tiff',\n      '.tif',\n      '.bmp',\n      '.dib',\n      '.heif',\n      '.heic',\n      '.svg',\n      '.svgz'\n    ]\n\n    if (!allowedExtensions.includes(ext.toLocaleLowerCase())) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    var savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    // var sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase();\n    var sanitizedFilename = chance.hash({ length: 20 }) + ext\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'inline_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.filename) || _.isUndefined(object.filePath)) {\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    var fileUrl = '/uploads/tickets/' + object.ticketId + '/inline_' + object.filename\n\n    return res.json({ filename: fileUrl, ticketId: object.ticketId })\n  })\n\n  req.pipe(busboy)\n}\n\nticketsController.uploadAttachment = function (req, res) {\n  var fs = require('fs-extra')\n  var Busboy = require('busboy')\n  var busboy = new Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 10 * 1024 * 1024 // 10mb limit\n    }\n  })\n\n  var object = {\n    ownerId: req.user._id\n  }\n  var error\n\n  busboy.on('field', function (fieldname, val) {\n    if (fieldname === 'ticketId') object.ticketId = val\n    if (fieldname === 'ownerId') object.ownerId = val\n  })\n\n  busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {\n    // winston.debug(mimetype);\n\n    if (\n      mimetype.indexOf('image/') === -1 &&\n      mimetype.indexOf('text/plain') === -1 &&\n      mimetype.indexOf('audio/mpeg') === -1 &&\n      mimetype.indexOf('audio/mp3') === -1 &&\n      mimetype.indexOf('audio/wav') === -1 &&\n      mimetype.indexOf('application/x-zip-compressed') === -1 &&\n      mimetype.indexOf('application/pdf') === -1 &&\n      //  Office Mime-Types\n      mimetype.indexOf('application/msword') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.wordprocessingml.document') === -1 &&\n      mimetype.indexOf('application/vnd.ms-excel') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') === -1\n    ) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    var savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    var sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase()\n\n    var ext = path.extname(sanitizedFilename)\n    var badExts = ['.html', '.htm', '.js']\n\n    if (badExts.includes(ext)) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'attachment_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.ownerId) || _.isUndefined(object.filePath)) {\n      fs.unlinkSync(object.filePath)\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    ticketSchema.getTicketById(object.ticketId, function (err, ticket) {\n      if (err) {\n        winston.warn(err)\n        return res.status(500).send(err.message)\n      }\n\n      var attachment = {\n        owner: object.ownerId,\n        name: object.filename,\n        path: '/uploads/tickets/' + object.ticketId + '/attachment_' + object.filename,\n        type: object.mimetype\n      }\n      ticket.attachments.push(attachment)\n\n      var historyItem = {\n        action: 'ticket:added:attachment',\n        description: 'Attachment ' + object.filename + ' was added.',\n        owner: object.ownerId\n      }\n      ticket.history.push(historyItem)\n\n      ticket.updated = Date.now()\n      ticket.save(function (err, t) {\n        if (err) {\n          fs.unlinkSync(object.filePath)\n          winston.warn(err)\n          return res.status(500).send(err.message)\n        }\n\n        var returnData = {\n          ticket: t\n        }\n\n        return res.json(returnData)\n      })\n    })\n  })\n\n  req.pipe(busboy)\n}\n\nfunction handleError (res, err) {\n  if (err) {\n    winston.warn(err)\n    if (!err.status) res.status = 500\n    else res.status = err.status\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\nmodule.exports = ticketsController\n"], "fixing_code": ["/*\n      .                              .o8                     oooo\n   .o8                             \"888                     `888\n .o888oo oooo d8b oooo  oooo   .oooo888   .ooooo.   .oooo.o  888  oooo\n   888   `888\"\"8P `888  `888  d88' `888  d88' `88b d88(  \"8  888 .8P'\n   888    888      888   888  888   888  888ooo888 `\"Y88b.   888888.\n   888 .  888      888   888  888   888  888    .o o.  )88b  888 `88b.\n   \"888\" d888b     `V88V\"V8P' `Y8bod88P\" `Y8bod8P' 8\"\"888P' o888o o888o\n ========================================================================\n **/\n\nvar ticketSchema = require('../models/ticket')\nvar async = require('async')\nvar path = require('path')\nvar _ = require('lodash')\nvar winston = require('../logger')\nvar groupSchema = require('../models/group')\nvar departmentSchema = require('../models/department')\nvar permissions = require('../permissions')\nvar xss = require('xss')\n/**\n * @since 1.0\n * @author Chris Brame <polonel@gmail.com>\n * @copyright 2015 Chris Brame\n **/\n\n/**\n * @namespace\n * @description Controller for each Ticket View\n * @requires {@link Ticket}\n * @requires {@link Group}\n * @requires {@link TicketType}\n * @requires {@link Emitter}\n *\n */\nvar ticketsController = {}\n\n/**\n * @name ticketsController.content\n * @description Main Content sent to the view\n */\nticketsController.content = {}\n\nticketsController.pubNewIssue = function (req, res) {\n  var marked = require('marked')\n  var settings = require('../models/setting')\n  settings.getSettingByName('allowPublicTickets:enable', function (err, setting) {\n    if (err) return handleError(res, err)\n    if (setting && setting.value === true) {\n      settings.getSettingByName('legal:privacypolicy', function (err, privacyPolicy) {\n        if (err) return handleError(res, err)\n\n        var content = {}\n        content.title = 'New Issue'\n        content.layout = false\n        content.data = {}\n        if (privacyPolicy === null || _.isUndefined(privacyPolicy.value)) {\n          content.data.privacyPolicy = 'No Privacy Policy has been set.'\n        } else {\n          content.data.privacyPolicy = xss(marked.parse(privacyPolicy.value))\n        }\n\n        return res.render('pub_createTicket', content)\n      })\n    } else {\n      return res.redirect('/')\n    }\n  })\n}\n\n/**\n * Get Ticket View based on ticket status\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getByStatus = function (req, res, next) {\n  var url = require('url')\n  var page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  var processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: []\n  }\n\n  var fullUrl = url.format({\n    protocol: req.protocol,\n    host: req.get('host'),\n    pathname: req.originalUrl\n  })\n\n  var pathname = new url.URL(fullUrl).pathname\n  var arr = pathname.split('/')\n  var tType = 'new'\n  var s = 0\n  if (_.size(arr) > 2) tType = arr[2]\n\n  switch (tType) {\n    case 'open':\n      s = 1\n      break\n    case 'pending':\n      s = 2\n      break\n    case 'closed':\n      s = 3\n      break\n  }\n\n  processor.subnav += tType\n  processor.pagetype = tType\n  processor.object.status.push(s)\n\n  req.processor = processor\n  return next()\n}\n\n/**\n * Get Ticket View based on ticket active tickets\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {function} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getActive = function (req, res, next) {\n  var page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  var processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-active'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'active'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2]\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getAssigned = function (req, res, next) {\n  var page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  var processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-assigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'assigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    assignedSelf: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Get Ticket View based on tickets assigned to a given user\n * _calls ```next()``` to send to processor_\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @param {callback} next Sends the ```req.processor``` object to the processor\n * @see Ticket\n */\nticketsController.getUnassigned = function (req, res, next) {\n  var page = req.params.page\n  if (_.isUndefined(page)) page = 0\n\n  var processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.subnav = 'tickets-unassigned'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'unassigned'\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: [0, 1, 2],\n    unassigned: true,\n    user: req.user._id\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\nticketsController.filter = function (req, res, next) {\n  var page = req.query.page\n  if (_.isUndefined(page)) page = 0\n\n  var queryString = req.query\n  var uid = queryString.uid\n  var subject = queryString.fs\n  var issue = queryString.it\n  var dateStart = queryString.ds\n  var dateEnd = queryString.de\n  var status = queryString.st\n  var priority = queryString.pr\n  var groups = queryString.gp\n  var types = queryString.tt\n  var tags = queryString.tag\n  var assignee = queryString.au\n\n  var rawNoPage = req.originalUrl\n    .replace(new RegExp('[?&]page=[^&#]*(#.*)?$'), '$1')\n    .replace(new RegExp('([?&])page=[^&]*&'), '$1')\n\n  if (!_.isUndefined(status) && !_.isArray(status)) status = [status]\n  if (!_.isUndefined(priority) && !_.isArray(priority)) priority = [priority]\n  if (!_.isUndefined(groups) && !_.isArray(groups)) groups = [groups]\n  if (!_.isUndefined(types) && !_.isArray(types)) types = [types]\n  if (!_.isUndefined(tags) && !_.isArray(tags)) tags = [tags]\n  if (!_.isUndefined(assignee) && !_.isArray(assignee)) assignee = [assignee]\n\n  var filter = {\n    uid: uid,\n    subject: subject,\n    issue: issue,\n    date: {\n      start: dateStart,\n      end: dateEnd\n    },\n    status: status,\n    priority: priority,\n    groups: groups,\n    tags: tags,\n    types: types,\n    assignee: assignee,\n    raw: rawNoPage\n  }\n\n  var processor = {}\n  processor.title = 'Tickets'\n  processor.nav = 'tickets'\n  processor.renderpage = 'tickets'\n  processor.pagetype = 'filter'\n  processor.filter = filter\n  processor.object = {\n    limit: 50,\n    page: page,\n    status: filter.status,\n    user: req.user._id,\n    filter: filter\n  }\n\n  req.processor = processor\n\n  return next()\n}\n\n/**\n * Process the ```req.processor``` object and render the correct view\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Tickets View\n * @see Ticket\n */\nticketsController.processor = function (req, res) {\n  var processor = req.processor\n  if (_.isUndefined(processor)) return res.redirect('/')\n\n  var content = {}\n  content.title = processor.title\n  content.nav = processor.nav\n  content.subnav = processor.subnav\n  content.view = processor.pagetype\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n\n  var object = processor.object\n  content.data.page = object.page\n  content.data.filter = object.filter\n\n  return res.render(processor.renderpage, content)\n}\n\nticketsController.pdf = function (req, res) {\n  var TicketPDFGenerator = require('../pdf/ticketGenerator')\n  var uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.status(404).send('Invalid Ticket UID')\n  }\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n\n    var ticketGenerator = new TicketPDFGenerator(ticket)\n\n    ticketGenerator.generate(function (err, obj) {\n      if (err) return res.redirect('/tickets')\n\n      return res.writeHead(200, obj.headers).end(obj.data)\n    })\n  })\n}\n\n/**\n * Print Ticket View\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Subviews/PrintTicket View\n */\nticketsController.print = function (req, res) {\n  var user = req.user\n  var uid = null\n  try {\n    uid = parseInt(req.params.uid)\n  } catch (e) {\n    winston.warn(e)\n    return res.redirect('/tickets')\n  }\n\n  var content = {}\n  content.title = 'Tickets - ' + req.params.uid\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = req.user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    var hasPublic = permissions.canThis(user.role, 'tickets:public')\n    var hasAccess = false\n    async.series(\n      [\n        function (next) {\n          if (user.role.isAdmin || user.role.isAgent) {\n            departmentSchema.getDepartmentGroupsOfUser(user._id, function (err, groups) {\n              if (err) return res.redirect('/tickets')\n              var gIds = groups.map(function (g) {\n                return g._id\n              })\n\n              if (_.some(gIds, ticket.group._id)) {\n                if (!permissions.canThis(user.role, 'tickets:notes')) {\n                  ticket.notes = []\n                }\n\n                hasAccess = true\n                return next()\n              } else {\n                return next('UNAUTHORIZED_GROUP_ACCESS')\n              }\n            })\n          } else {\n            return next()\n          }\n        },\n        function (next) {\n          if (hasAccess) return next()\n\n          var members = ticket.group.members.map(function (m) {\n            return m._id.toString()\n          })\n\n          if (!members.includes(user._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              return next('UNAUTHORIZED_GROUP_ACCESS')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) {\n            ticket.notes = []\n          }\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          if (err === 'UNAUTHORIZED_GROUP_ACCESS')\n            winston.warn(\n              'User tried to access ticket outside of group - UserId: ' + user._id + ' (' + user.username + ')'\n            )\n\n          return res.redirect('/tickets')\n        }\n\n        content.data.ticket = ticket\n        content.data.ticket.priorityname = ticket.priority.name\n        content.data.ticket.tagsArray = ticket.tags\n        content.data.ticket.commentCount = _.size(ticket.comments)\n        content.layout = 'layout/print'\n\n        return res.render('subviews/printticket', content)\n      }\n    )\n  })\n}\n\n/**\n * Get Single Ticket view based on UID\n * @param {object} req Express Request\n * @param {object} res Express Response\n * @return {View} Single Ticket View\n * @see Ticket\n * @example\n * //Content Object\n * content.title = \"Tickets - \" + req.params.id;\n * content.nav = 'tickets';\n *\n * content.data = {};\n * content.data.user = req.user;\n * content.data.common = req.viewdata;\n *\n * //Ticket Data\n * content.data.ticket = ticket;\n * content.data.ticket.priorityname = getPriorityName(ticket.priority);\n * content.data.ticket.tagsArray = ticket.tags;\n * content.data.ticket.commentCount = _.size(ticket.comments);\n */\nticketsController.single = function (req, res) {\n  var user = req.user\n  var uid = req.params.id\n  if (isNaN(uid)) {\n    return res.redirect('/tickets')\n  }\n\n  var content = {}\n  content.title = 'Tickets - ' + req.params.id\n  content.nav = 'tickets'\n\n  content.data = {}\n  content.data.user = user\n  content.data.common = req.viewdata\n  content.data.ticket = {}\n\n  ticketSchema.getTicketByUid(uid, function (err, ticket) {\n    if (err) return handleError(res, err)\n    if (_.isNull(ticket) || _.isUndefined(ticket)) return res.redirect('/tickets')\n\n    var departmentSchema = require('../models/department')\n    async.waterfall(\n      [\n        function (next) {\n          if (!req.user.role.isAdmin && !req.user.role.isAgent) {\n            return groupSchema.getAllGroupsOfUserNoPopulate(req.user._id, next)\n          }\n\n          departmentSchema.getUserDepartments(req.user._id, function (err, departments) {\n            if (err) return next(err)\n            if (_.some(departments, { allGroups: true })) {\n              return groupSchema.find({}, next)\n            }\n\n            var groups = _.flattenDeep(\n              departments.map(function (d) {\n                return d.groups\n              })\n            )\n\n            return next(null, groups)\n          })\n        },\n        function (userGroups, next) {\n          var hasPublic = permissions.canThis(user.role, 'tickets:public')\n          var groupIds = userGroups.map(function (g) {\n            return g._id.toString()\n          })\n\n          if (!groupIds.includes(ticket.group._id.toString())) {\n            if (ticket.group.public && hasPublic) {\n              // Blank to bypass\n            } else {\n              winston.warn('User access ticket outside of group - UserId: ' + user._id)\n              return res.redirect('/tickets')\n            }\n          }\n\n          if (!permissions.canThis(user.role, 'comments:view')) ticket.comments = []\n\n          if (!permissions.canThis(user.role, 'tickets:notes')) ticket.notes = []\n\n          content.data.ticket = ticket\n          content.data.ticket.priorityname = ticket.priority.name\n\n          return next()\n        }\n      ],\n      function (err) {\n        if (err) {\n          winston.warn(err)\n          return res.redirect('/tickets')\n        }\n\n        return res.render('subviews/singleticket', content)\n      }\n    )\n  })\n}\n\nticketsController.uploadImageMDE = function (req, res) {\n  var Chance = require('chance')\n  var chance = new Chance()\n  var fs = require('fs-extra')\n  var Busboy = require('busboy')\n  var busboy = new Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 5 * 1024 * 1024 // 5mb limit\n    }\n  })\n\n  var object = {}\n  var error\n\n  object.ticketId = req.headers.ticketid\n  if (!object.ticketId) return res.status(400).json({ success: false })\n\n  busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {\n    if (mimetype.indexOf('image/') === -1) {\n      error = {\n        status: 500,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    var ext = path.extname(filename)\n    var allowedExtensions = [\n      '.jpg',\n      '.jpeg',\n      '.jpe',\n      '.jif',\n      '.jfif',\n      '.jfi',\n      '.png',\n      '.gif',\n      '.webp',\n      '.tiff',\n      '.tif',\n      '.bmp',\n      '.dib',\n      '.heif',\n      '.heic'\n    ]\n\n    if (!allowedExtensions.includes(ext.toLocaleLowerCase())) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    var savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    // var sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase();\n    var sanitizedFilename = chance.hash({ length: 20 }) + ext\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'inline_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.filename) || _.isUndefined(object.filePath)) {\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    var fileUrl = '/uploads/tickets/' + object.ticketId + '/inline_' + object.filename\n\n    return res.json({ filename: fileUrl, ticketId: object.ticketId })\n  })\n\n  req.pipe(busboy)\n}\n\nticketsController.uploadAttachment = function (req, res) {\n  var fs = require('fs-extra')\n  var Busboy = require('busboy')\n  var busboy = new Busboy({\n    headers: req.headers,\n    limits: {\n      files: 1,\n      fileSize: 10 * 1024 * 1024 // 10mb limit\n    }\n  })\n\n  var object = {\n    ownerId: req.user._id\n  }\n  var error\n\n  busboy.on('field', function (fieldname, val) {\n    if (fieldname === 'ticketId') object.ticketId = val\n    if (fieldname === 'ownerId') object.ownerId = val\n  })\n\n  busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {\n    // winston.debug(mimetype);\n\n    if (\n      mimetype.indexOf('image/') === -1 &&\n      mimetype.indexOf('text/plain') === -1 &&\n      mimetype.indexOf('audio/mpeg') === -1 &&\n      mimetype.indexOf('audio/mp3') === -1 &&\n      mimetype.indexOf('audio/wav') === -1 &&\n      mimetype.indexOf('application/x-zip-compressed') === -1 &&\n      mimetype.indexOf('application/pdf') === -1 &&\n      //  Office Mime-Types\n      mimetype.indexOf('application/msword') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.wordprocessingml.document') === -1 &&\n      mimetype.indexOf('application/vnd.ms-excel') === -1 &&\n      mimetype.indexOf('application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') === -1\n    ) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    var savePath = path.join(__dirname, '../../public/uploads/tickets', object.ticketId)\n    var sanitizedFilename = filename.replace(/[^a-z0-9.]/gi, '_').toLowerCase()\n\n    var ext = path.extname(sanitizedFilename)\n    var badExts = ['.html', '.htm', '.js']\n\n    if (badExts.includes(ext)) {\n      error = {\n        status: 400,\n        message: 'Invalid File Type'\n      }\n\n      return file.resume()\n    }\n\n    if (!fs.existsSync(savePath)) fs.ensureDirSync(savePath)\n\n    object.filePath = path.join(savePath, 'attachment_' + sanitizedFilename)\n    object.filename = sanitizedFilename\n    object.mimetype = mimetype\n\n    if (fs.existsSync(object.filePath)) {\n      error = {\n        status: 500,\n        message: 'File already exists'\n      }\n\n      return file.resume()\n    }\n\n    file.on('limit', function () {\n      error = {\n        status: 500,\n        message: 'File too large'\n      }\n\n      // Delete the temp file\n      if (fs.existsSync(object.filePath)) fs.unlinkSync(object.filePath)\n\n      return file.resume()\n    })\n\n    file.pipe(fs.createWriteStream(object.filePath))\n  })\n\n  busboy.on('finish', function () {\n    if (error) return res.status(error.status).send(error.message)\n\n    if (_.isUndefined(object.ticketId) || _.isUndefined(object.ownerId) || _.isUndefined(object.filePath)) {\n      fs.unlinkSync(object.filePath)\n      return res.status(400).send('Invalid Form Data')\n    }\n\n    // Everything Checks out lets make sure the file exists and then add it to the attachments array\n    if (!fs.existsSync(object.filePath)) return res.status(500).send('File Failed to Save to Disk')\n\n    ticketSchema.getTicketById(object.ticketId, function (err, ticket) {\n      if (err) {\n        winston.warn(err)\n        return res.status(500).send(err.message)\n      }\n\n      var attachment = {\n        owner: object.ownerId,\n        name: object.filename,\n        path: '/uploads/tickets/' + object.ticketId + '/attachment_' + object.filename,\n        type: object.mimetype\n      }\n      ticket.attachments.push(attachment)\n\n      var historyItem = {\n        action: 'ticket:added:attachment',\n        description: 'Attachment ' + object.filename + ' was added.',\n        owner: object.ownerId\n      }\n      ticket.history.push(historyItem)\n\n      ticket.updated = Date.now()\n      ticket.save(function (err, t) {\n        if (err) {\n          fs.unlinkSync(object.filePath)\n          winston.warn(err)\n          return res.status(500).send(err.message)\n        }\n\n        var returnData = {\n          ticket: t\n        }\n\n        return res.json(returnData)\n      })\n    })\n  })\n\n  req.pipe(busboy)\n}\n\nfunction handleError (res, err) {\n  if (err) {\n    winston.warn(err)\n    if (!err.status) res.status = 500\n    else res.status = err.status\n    return res.render('error', {\n      layout: false,\n      error: err,\n      message: err.message\n    })\n  }\n}\n\nmodule.exports = ticketsController\n"], "filenames": ["src/controllers/tickets.js"], "buggy_code_start_loc": [578], "buggy_code_end_loc": [581], "fixing_code_start_loc": [578], "fixing_code_end_loc": [579], "type": "CWE-434", "message": "Stored XSS viva .svg file upload in GitHub repository polonel/trudesk prior to v1.2.0.", "other": {"cve": {"id": "CVE-2022-1045", "sourceIdentifier": "security@huntr.dev", "published": "2022-04-11T07:15:08.220", "lastModified": "2022-04-15T03:24:09.447", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Stored XSS viva .svg file upload in GitHub repository polonel/trudesk prior to v1.2.0."}, {"lang": "es", "value": "Una vulnerabilidad de tipo XSS almacenado por medio de una carga de archivos .svg en el repositorio de GitHub polonel/trudesk versiones anteriores a v1.2.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trudesk_project:trudesk:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.0", "matchCriteriaId": "485D4AC2-2B88-49BA-B298-AB78A027FCE8"}]}]}], "references": [{"url": "https://github.com/polonel/trudesk/commit/c4b262c2613d4a8865de0b3252112544bd81997a", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/b0c4f992-4ac8-4479-82f4-367ed1a2a826", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/polonel/trudesk/commit/c4b262c2613d4a8865de0b3252112544bd81997a"}}