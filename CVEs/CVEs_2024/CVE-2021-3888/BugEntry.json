{"buggy_code": ["/** @file read.c\n *  @brief Functions for reading and parsing of MOBI document\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"read.h\"\n#include \"util.h\"\n#include \"index.h\"\n#include \"debug.h\"\n\n/**\n @brief Read palm database header from file into MOBIData structure (MOBIPdbHeader)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_pdbheader(MOBIData *m, FILE *file) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (!file) {\n        return MOBI_FILE_NOT_FOUND;\n    }\n    MOBIBuffer *buf = mobi_buffer_init(PALMDB_HEADER_LEN);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    const size_t len = fread(buf->data, 1, PALMDB_HEADER_LEN, file);\n    if (len != PALMDB_HEADER_LEN) {\n        mobi_buffer_free(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    m->ph = calloc(1, sizeof(MOBIPdbHeader));\n    if (m->ph == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb header failed\\n\");\n        mobi_buffer_free(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    /* parse header */\n    mobi_buffer_getstring(m->ph->name, buf, PALMDB_NAME_SIZE_MAX);\n    m->ph->attributes = mobi_buffer_get16(buf);\n    m->ph->version = mobi_buffer_get16(buf);\n    m->ph->ctime = mobi_buffer_get32(buf);\n    m->ph->mtime = mobi_buffer_get32(buf);\n    m->ph->btime = mobi_buffer_get32(buf);\n    m->ph->mod_num = mobi_buffer_get32(buf);\n    m->ph->appinfo_offset = mobi_buffer_get32(buf);\n    m->ph->sortinfo_offset = mobi_buffer_get32(buf);\n    mobi_buffer_getstring(m->ph->type, buf, 4);\n    mobi_buffer_getstring(m->ph->creator, buf, 4);\n    m->ph->uid = mobi_buffer_get32(buf);\n    m->ph->next_rec = mobi_buffer_get32(buf);\n    m->ph->rec_count = mobi_buffer_get16(buf);\n    mobi_buffer_free(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read list of database records from file into MOBIData structure (MOBIPdbRecord)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_reclist(MOBIData *m, FILE *file) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (!file) {\n        debug_print(\"%s\", \"File not ready\\n\");\n        return MOBI_FILE_NOT_FOUND;\n    }\n    m->rec = calloc(1, sizeof(MOBIPdbRecord));\n    if (m->rec == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb record failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    for (int i = 0; i < m->ph->rec_count; i++) {\n        MOBIBuffer *buf = mobi_buffer_init(PALMDB_RECORD_INFO_SIZE);\n        if (buf == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const size_t len = fread(buf->data, 1, PALMDB_RECORD_INFO_SIZE, file);\n        if (len != PALMDB_RECORD_INFO_SIZE) {\n            mobi_buffer_free(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        if (i > 0) {\n            curr->next = calloc(1, sizeof(MOBIPdbRecord));\n            if (curr->next == NULL) {\n                debug_print(\"%s\", \"Memory allocation for pdb record failed\\n\");\n                mobi_buffer_free(buf);\n                return MOBI_MALLOC_FAILED;\n            }\n            curr = curr->next;\n        }\n        curr->offset = mobi_buffer_get32(buf);\n        curr->attributes = mobi_buffer_get8(buf);\n        const uint8_t h = mobi_buffer_get8(buf);\n        const uint16_t l = mobi_buffer_get16(buf);\n        curr->uid =  (uint32_t) h << 16 | l;\n        curr->next = NULL;\n        mobi_buffer_free(buf);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read record data and size from file into MOBIData structure (MOBIPdbRecord)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_rec(MOBIData *m, FILE *file) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    while (curr != NULL) {\n        MOBIPdbRecord *next;\n        size_t size;\n        if (curr->next != NULL) {\n            next = curr->next;\n            size = next->offset - curr->offset;\n        } else {\n            fseek(file, 0, SEEK_END);\n            long diff = ftell(file) - curr->offset;\n            if (diff <= 0) {\n                debug_print(\"Wrong record size: %li\\n\", diff);\n                return MOBI_DATA_CORRUPT;\n            }\n            size = (size_t) diff;\n            next = NULL;\n        }\n\n        curr->size = size;\n        ret = mobi_load_recdata(curr, file);\n        if (ret  != MOBI_SUCCESS) {\n            debug_print(\"Error loading record uid %i data\\n\", curr->uid);\n            mobi_free_rec(m);\n            return ret;\n        }\n        curr = next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read record data from file into MOBIPdbRecord structure\n \n @param[in,out] rec MOBIPdbRecord structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_recdata(MOBIPdbRecord *rec, FILE *file) {\n    const int ret = fseek(file, rec->offset, SEEK_SET);\n    if (ret != 0) {\n        debug_print(\"Record %i not found\\n\", rec->uid);\n        return MOBI_DATA_CORRUPT;\n    }\n    rec->data = malloc(rec->size);\n    if (rec->data == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb record data failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    const size_t len = fread(rec->data, 1, rec->size, file);\n    if (len < rec->size) {\n        debug_print(\"Truncated data in record %i\\n\", rec->uid);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse EXTH header from Record 0 into MOBIData structure (MOBIExthHeader)\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] buf MOBIBuffer buffer to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_extheader(MOBIData *m, MOBIBuffer *buf) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    char exth_magic[5];\n    const size_t header_length = 12;\n    mobi_buffer_getstring(exth_magic, buf, 4);\n    const size_t exth_length = mobi_buffer_get32(buf) - header_length;\n    const size_t rec_count = mobi_buffer_get32(buf);\n    if (strncmp(exth_magic, EXTH_MAGIC, 4) != 0 ||\n        exth_length + buf->offset > buf->maxlen ||\n        rec_count == 0 || rec_count > MOBI_EXTH_MAXCNT) {\n        debug_print(\"%s\", \"Sanity checks for EXTH header failed\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t saved_maxlen = buf->maxlen;\n    buf->maxlen = exth_length + buf->offset;\n    m->eh = calloc(1, sizeof(MOBIExthHeader));\n    if (m->eh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for EXTH header failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIExthHeader *curr = m->eh;\n    for (size_t i = 0; i < rec_count; i++) {\n        if (curr->data) {\n            curr->next = calloc(1, sizeof(MOBIExthHeader));\n            if (curr->next == NULL) {\n                debug_print(\"%s\", \"Memory allocation for EXTH header failed\\n\");\n                mobi_free_eh(m);\n                return MOBI_MALLOC_FAILED;\n            }\n            curr = curr->next;\n        }\n        curr->tag = mobi_buffer_get32(buf);\n        /* data size = record size minus 8 bytes for uid and size */\n        curr->size = mobi_buffer_get32(buf) - 8;\n        if (curr->size == 0) {\n            debug_print(\"Skip record %i, data too short\\n\", curr->tag);\n            continue;\n        }\n        if (buf->offset + curr->size > buf->maxlen) {\n            debug_print(\"Record %i too long\\n\", curr->tag);\n            mobi_free_eh(m);\n            return MOBI_DATA_CORRUPT;\n        }\n        curr->data = malloc(curr->size);\n        if (curr->data == NULL) {\n            debug_print(\"Memory allocation for EXTH record %i failed\\n\", curr->tag);\n            mobi_free_eh(m);\n            return MOBI_MALLOC_FAILED;\n        }\n        mobi_buffer_getraw(curr->data, buf, curr->size);\n        curr->next = NULL;\n    }    \n    buf->maxlen = saved_maxlen;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse MOBI header from Record 0 into MOBIData structure (MOBIMobiHeader)\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] buf MOBIBuffer buffer to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_mobiheader(MOBIData *m, MOBIBuffer *buf) {\n    int isKF8 = 0;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    m->mh = calloc(1, sizeof(MOBIMobiHeader));\n    if (m->mh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    mobi_buffer_getstring(m->mh->mobi_magic, buf, 4);\n    mobi_buffer_dup32(&m->mh->header_length, buf);\n    if (strcmp(m->mh->mobi_magic, MOBI_MAGIC) != 0 || m->mh->header_length == NULL) {\n        debug_print(\"%s\", \"MOBI header not found\\n\");\n        mobi_free_mh(m->mh);\n        m->mh = NULL;\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t saved_maxlen = buf->maxlen;\n    /* some old files declare zero length mobi header, try to read first 24 bytes anyway */\n    uint32_t header_length = (*m->mh->header_length > 0) ? *m->mh->header_length : 24;\n    /* read only declared MOBI header length (curr offset minus 8 already read bytes) */\n    const size_t left_length = header_length + buf->offset - 8;\n    buf->maxlen = saved_maxlen < left_length ? saved_maxlen : left_length;\n    mobi_buffer_dup32(&m->mh->mobi_type, buf);\n    uint32_t encoding = mobi_buffer_get32(buf);\n    if (encoding == 1252) {\n        m->mh->text_encoding = malloc(sizeof(MOBIEncoding));\n        if (m->mh->text_encoding == NULL) {\n            debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        *m->mh->text_encoding = MOBI_CP1252;\n    }\n    else if (encoding == 65001) {\n        m->mh->text_encoding = malloc(sizeof(MOBIEncoding));\n        if (m->mh->text_encoding == NULL) {\n            debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        *m->mh->text_encoding = MOBI_UTF8;\n    } else {\n        debug_print(\"Unknown encoding in mobi header: %i\\n\", encoding);\n    }\n    mobi_buffer_dup32(&m->mh->uid, buf);\n    mobi_buffer_dup32(&m->mh->version, buf);\n    if (header_length >= MOBI_HEADER_V7_SIZE\n        && m->mh->version && *m->mh->version == 8) {\n        isKF8 = 1;\n    }\n    mobi_buffer_dup32(&m->mh->orth_index, buf);\n    mobi_buffer_dup32(&m->mh->infl_index, buf);\n    mobi_buffer_dup32(&m->mh->names_index, buf);\n    mobi_buffer_dup32(&m->mh->keys_index, buf);\n    mobi_buffer_dup32(&m->mh->extra0_index, buf);\n    mobi_buffer_dup32(&m->mh->extra1_index, buf);\n    mobi_buffer_dup32(&m->mh->extra2_index, buf);\n    mobi_buffer_dup32(&m->mh->extra3_index, buf);\n    mobi_buffer_dup32(&m->mh->extra4_index, buf);\n    mobi_buffer_dup32(&m->mh->extra5_index, buf);\n    mobi_buffer_dup32(&m->mh->non_text_index, buf);\n    mobi_buffer_dup32(&m->mh->full_name_offset, buf);\n    mobi_buffer_dup32(&m->mh->full_name_length, buf);\n    mobi_buffer_dup32(&m->mh->locale, buf);\n    mobi_buffer_dup32(&m->mh->dict_input_lang, buf);\n    mobi_buffer_dup32(&m->mh->dict_output_lang, buf);\n    mobi_buffer_dup32(&m->mh->min_version, buf);\n    mobi_buffer_dup32(&m->mh->image_index, buf);\n    mobi_buffer_dup32(&m->mh->huff_rec_index, buf);\n    mobi_buffer_dup32(&m->mh->huff_rec_count, buf);\n    mobi_buffer_dup32(&m->mh->datp_rec_index, buf);\n    mobi_buffer_dup32(&m->mh->datp_rec_count, buf);\n    mobi_buffer_dup32(&m->mh->exth_flags, buf);\n    mobi_buffer_seek(buf, 32); /* 32 unknown bytes */\n    mobi_buffer_dup32(&m->mh->unknown6, buf);\n    mobi_buffer_dup32(&m->mh->drm_offset, buf);\n    mobi_buffer_dup32(&m->mh->drm_count, buf);\n    mobi_buffer_dup32(&m->mh->drm_size, buf);\n    mobi_buffer_dup32(&m->mh->drm_flags, buf);\n    mobi_buffer_seek(buf, 8); /* 8 unknown bytes */\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->fdst_index, buf);\n    } else {\n        mobi_buffer_dup16(&m->mh->first_text_index, buf);\n        mobi_buffer_dup16(&m->mh->last_text_index, buf);\n    }\n    mobi_buffer_dup32(&m->mh->fdst_section_count, buf);\n    mobi_buffer_dup32(&m->mh->fcis_index, buf);\n    mobi_buffer_dup32(&m->mh->fcis_count, buf);\n    mobi_buffer_dup32(&m->mh->flis_index, buf);\n    mobi_buffer_dup32(&m->mh->flis_count, buf);\n    mobi_buffer_dup32(&m->mh->unknown10, buf);\n    mobi_buffer_dup32(&m->mh->unknown11, buf);\n    mobi_buffer_dup32(&m->mh->srcs_index, buf);\n    mobi_buffer_dup32(&m->mh->srcs_count, buf);\n    mobi_buffer_dup32(&m->mh->unknown12, buf);\n    mobi_buffer_dup32(&m->mh->unknown13, buf);\n    mobi_buffer_seek(buf, 2); /* 2 byte fill */\n    mobi_buffer_dup16(&m->mh->extra_flags, buf);\n    mobi_buffer_dup32(&m->mh->ncx_index, buf);\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->fragment_index, buf);\n        mobi_buffer_dup32(&m->mh->skeleton_index, buf);\n    } else {\n        mobi_buffer_dup32(&m->mh->unknown14, buf);\n        mobi_buffer_dup32(&m->mh->unknown15, buf);\n    }\n    mobi_buffer_dup32(&m->mh->datp_index, buf);\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->guide_index, buf);\n    } else {\n        mobi_buffer_dup32(&m->mh->unknown16, buf);\n    }\n    mobi_buffer_dup32(&m->mh->unknown17, buf);\n    mobi_buffer_dup32(&m->mh->unknown18, buf);\n    mobi_buffer_dup32(&m->mh->unknown19, buf);\n    mobi_buffer_dup32(&m->mh->unknown20, buf);\n    if (buf->maxlen > buf->offset) {\n        debug_print(\"Skipping %zu unknown bytes in MOBI header\\n\", (buf->maxlen - buf->offset));\n        mobi_buffer_setpos(buf, buf->maxlen);\n    }\n    buf->maxlen = saved_maxlen;\n    /* get full name stored at m->mh->full_name_offset */\n    if (m->mh->full_name_offset && m->mh->full_name_length) {\n        const size_t saved_offset = buf->offset;\n        const uint32_t full_name_length = min(*m->mh->full_name_length, MOBI_TITLE_SIZEMAX);\n        mobi_buffer_setpos(buf, *m->mh->full_name_offset);\n        m->mh->full_name = malloc(full_name_length + 1);\n        if (m->mh->full_name == NULL) {\n            debug_print(\"%s\", \"Memory allocation for full name failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        if (full_name_length) {\n            mobi_buffer_getstring(m->mh->full_name, buf, full_name_length);\n        } else {\n            m->mh->full_name[0] = '\\0';\n        }\n        mobi_buffer_setpos(buf, saved_offset);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse Record 0 into MOBIData structure\n \n This function will parse MOBIRecord0Header, MOBIMobiHeader and MOBIExthHeader\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] seqnumber Sequential number of the palm database record\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_record0(MOBIData *m, const size_t seqnumber) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const MOBIPdbRecord *record0 = mobi_get_record_by_seqnumber(m, seqnumber);\n    if (record0 == NULL) {\n        debug_print(\"%s\", \"Record 0 not loaded\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (record0->size < RECORD0_HEADER_LEN) {\n        debug_print(\"%s\", \"Record 0 too short\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(record0->data, record0->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    m->rh = calloc(1, sizeof(MOBIRecord0Header));\n    if (m->rh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for record 0 header failed\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    /* parse palmdoc header */\n    const uint16_t compression = mobi_buffer_get16(buf);\n    mobi_buffer_seek(buf, 2); // unused 2 bytes, zeroes\n    if ((compression != RECORD0_NO_COMPRESSION &&\n         compression != RECORD0_PALMDOC_COMPRESSION &&\n         compression != RECORD0_HUFF_COMPRESSION)) {\n        debug_print(\"Wrong record0 header: %c%c%c%c\\n\", record0->data[0], record0->data[1], record0->data[2], record0->data[3]);\n        mobi_buffer_free_null(buf);\n        free(m->rh);\n        m->rh = NULL;\n        return MOBI_DATA_CORRUPT;\n    }\n    m->rh->compression_type = compression;\n    m->rh->text_length = mobi_buffer_get32(buf);\n    m->rh->text_record_count = mobi_buffer_get16(buf);\n    m->rh->text_record_size = mobi_buffer_get16(buf);\n    m->rh->encryption_type = mobi_buffer_get16(buf);\n    m->rh->unknown1 = mobi_buffer_get16(buf);\n    if (mobi_is_mobipocket(m)) {\n        /* parse mobi header if present  */\n        ret = mobi_parse_mobiheader(m, buf);\n        if (ret == MOBI_SUCCESS) {\n            /* parse exth header if present */\n            mobi_parse_extheader(m, buf);\n        }\n    } \n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Calculate the size of extra bytes at the end of text record\n \n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] flags Flags from MOBI header (extra_flags)\n @return The size of trailing bytes, MOBI_NOTSET on failure\n */\nsize_t mobi_get_record_extrasize(const MOBIPdbRecord *record, const uint16_t flags) {\n    size_t extra_size = 0;\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\", \"Buffer init in extrasize failed\\n\");\n        return MOBI_NOTSET;\n    }\n    /* set pointer at the end of the record data */\n    mobi_buffer_setpos(buf, buf->maxlen - 1);\n    for (int bit = 15; bit > 0; bit--) {\n        if (flags & (1 << bit)) {\n            /* bit is set */\n            size_t len = 0;\n            /* size contains varlen itself and optional data */\n            const uint32_t size = mobi_buffer_get_varlen_dec(buf, &len);\n            /* skip data */\n            /* TODO: read and store in record struct */\n            mobi_buffer_seek(buf, - (int)(size - len));\n            extra_size += size;\n        }\n    };\n    /* check bit 0 */\n    if (flags & 1) {\n            const uint8_t b = mobi_buffer_get8(buf);\n            /* two first bits hold size */\n            extra_size += (b & 0x3) + 1;\n    }\n    mobi_buffer_free_null(buf);\n    return extra_size;\n}\n\n/**\n @brief Calculate the size of extra multibyte section at the end of text record\n \n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] flags Flags from MOBI header (extra_flags)\n @return The size of trailing bytes, MOBI_NOTSET on failure\n */\nsize_t mobi_get_record_mb_extrasize(const MOBIPdbRecord *record, const uint16_t flags) {\n    size_t extra_size = 0;\n    if (flags & 1) {\n        MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n        if (buf == NULL) {\n            debug_print(\"%s\", \"Buffer init in extrasize failed\\n\");\n            return MOBI_NOTSET;\n        }\n        /* set pointer at the end of the record data */\n        mobi_buffer_setpos(buf, buf->maxlen - 1);\n        for (int bit = 15; bit > 0; bit--) {\n            if (flags & (1 << bit)) {\n                /* bit is set */\n                size_t len = 0;\n                /* size contains varlen itself and optional data */\n                const uint32_t size = mobi_buffer_get_varlen_dec(buf, &len);\n                /* skip data */\n                /* TODO: read and store in record struct */\n                mobi_buffer_seek(buf, - (int)(size - len));\n            }\n        };\n        /* read multibyte section */\n        const uint8_t b = mobi_buffer_get8(buf);\n        /* two first bits hold size */\n        extra_size += (b & 0x3) + 1;\n        mobi_buffer_free_null(buf);\n    }\n    return extra_size;\n}\n\n/**\n @brief Parse HUFF record into MOBIHuffCdic structure\n \n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @param[in] record MOBIPdbRecord structure containing the record\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char huff_magic[5];\n    mobi_buffer_getstring(huff_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) {\n        debug_print(\"HUFF wrong magic: %s\\n\", huff_magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t data1_offset = mobi_buffer_get32(buf);\n    const size_t data2_offset = mobi_buffer_get32(buf);\n    /* skip little-endian table offsets */\n    mobi_buffer_setpos(buf, data1_offset);\n    if (buf->offset + (256 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data1 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 256 indices from data1 big-endian */\n    for (int i = 0; i < 256; i++) {\n        huffcdic->table1[i] = mobi_buffer_get32(buf);\n    }\n    mobi_buffer_setpos(buf, data2_offset);\n    if (buf->offset + (64 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data2 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 32 mincode-maxcode pairs from data2 big-endian */\n    huffcdic->mincode_table[0] = 0;\n    huffcdic->maxcode_table[0] = 0xFFFFFFFF;\n    for (int i = 1; i < HUFF_CODETABLE_SIZE; i++) {\n        const uint32_t mincode = mobi_buffer_get32(buf);\n        const uint32_t maxcode = mobi_buffer_get32(buf);\n        huffcdic->mincode_table[i] =  mincode << (32 - i);\n        huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse CDIC record into MOBIHuffCdic structure\n \n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] num Number of CDIC record in a set, starting from zero\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_cdic(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record, const size_t num) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char cdic_magic[5];\n    mobi_buffer_getstring(cdic_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(cdic_magic, CDIC_MAGIC, 4) != 0 || header_length < CDIC_HEADER_LEN) {\n        debug_print(\"CDIC wrong magic: %s or declared header length: %zu\\n\", cdic_magic, header_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* variables in huffcdic initialized to zero with calloc */\n    /* save initial count and length */\n    size_t index_count = mobi_buffer_get32(buf);\n    const size_t code_length = mobi_buffer_get32(buf);\n    if (huffcdic->code_length && huffcdic->code_length != code_length) {\n        debug_print(\"CDIC different code length %zu in record %i, previous was %zu\\n\", huffcdic->code_length, record->uid, code_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (huffcdic->index_count && huffcdic->index_count != index_count) {\n        debug_print(\"CDIC different index count %zu in record %i, previous was %zu\\n\", huffcdic->index_count, record->uid, index_count);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (code_length == 0 || code_length > HUFF_CODELEN_MAX) {\n        debug_print(\"Code length exceeds sanity checks (%zu)\\n\", code_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    huffcdic->code_length = code_length;\n    huffcdic->index_count = index_count;\n    if (index_count == 0) {\n        debug_print(\"%s\", \"CDIC index count is null\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* allocate memory for symbol offsets if not already allocated */\n    if (num == 0) {\n        if (index_count > (1 << HUFF_CODELEN_MAX) * CDIC_RECORD_MAXCNT) {\n            debug_print(\"CDIC index count too large %zu\\n\", index_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        huffcdic->symbol_offsets = malloc(index_count * sizeof(*huffcdic->symbol_offsets));\n        if (huffcdic->symbol_offsets == NULL) {\n            debug_print(\"%s\", \"CDIC cannot allocate memory\");\n            mobi_buffer_free_null(buf);\n            return MOBI_MALLOC_FAILED;\n        }\n    }\n    index_count -= huffcdic->index_read;\n    /* limit number of records read to code_length bits */\n    if (index_count >> code_length) {\n        index_count = (1 << code_length);\n    }\n    if (buf->offset + (index_count * 2) > buf->maxlen) {\n        debug_print(\"%s\", \"CDIC indices data too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read i * 2 byte big-endian indices */\n    while (index_count--) {\n        const uint16_t offset = mobi_buffer_get16(buf);\n        const size_t saved_pos = buf->offset;\n        mobi_buffer_setpos(buf, offset + CDIC_HEADER_LEN);\n        const size_t len = mobi_buffer_get16(buf) & 0x7fff;\n        if (buf->error != MOBI_SUCCESS || buf->offset + len > buf->maxlen) {\n            debug_print(\"%s\", \"CDIC offset beyond buffer\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        mobi_buffer_setpos(buf, saved_pos);\n        huffcdic->symbol_offsets[huffcdic->index_read++] = offset;\n    }\n    if (buf->offset + code_length > buf->maxlen) {\n        debug_print(\"%s\", \"CDIC dictionary data too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* copy pointer to data */\n    huffcdic->symbols[num] = record->data + CDIC_HEADER_LEN;\n    /* free buffer */\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse a set of HUFF and CDIC records into MOBIHuffCdic structure\n \n @param[in] m MOBIData structure with loaded MOBI document\n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    /* allocate memory for symbols data in each CDIC record */\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* get following CDIC records */\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse FDST record into MOBIRawml structure (MOBIFdst member)\n \n @param[in] m MOBIData structure with loaded MOBI document\n @param[in,out] rawml MOBIRawml structure to be filled with parsed data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_fdst(const MOBIData *m, MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t fdst_record_number = mobi_get_fdst_record_number(m);\n    if (fdst_record_number == MOBI_NOTSET) {\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *fdst_record = mobi_get_record_by_seqnumber(m, fdst_record_number);\n    if (fdst_record == NULL) {\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(fdst_record->data, fdst_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char fdst_magic[5];\n    mobi_buffer_getstring(fdst_magic, buf, 4);\n    const size_t data_offset = mobi_buffer_get32(buf);\n    const size_t section_count = mobi_buffer_get32(buf);\n    if (strncmp(fdst_magic, FDST_MAGIC, 4) != 0 ||\n        section_count <= 1 ||\n        section_count != *m->mh->fdst_section_count ||\n        data_offset != 12) {\n        debug_print(\"FDST wrong magic: %s, sections count: %zu or data offset: %zu\\n\", fdst_magic, section_count, data_offset);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if ((buf->maxlen - buf->offset) < section_count * 8) {\n        debug_print(\"%s\", \"Record FDST too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    rawml->fdst = malloc(sizeof(MOBIFdst));\n    if (rawml->fdst == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    rawml->fdst->fdst_section_count = section_count;\n    rawml->fdst->fdst_section_starts = malloc(sizeof(*rawml->fdst->fdst_section_starts) * section_count);\n    if (rawml->fdst->fdst_section_starts == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        free(rawml->fdst);\n        rawml->fdst = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    rawml->fdst->fdst_section_ends = malloc(sizeof(*rawml->fdst->fdst_section_ends) * section_count);\n    if (rawml->fdst->fdst_section_ends == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        free(rawml->fdst->fdst_section_starts);\n        free(rawml->fdst);\n        rawml->fdst = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    while (i < section_count) {\n        rawml->fdst->fdst_section_starts[i] = mobi_buffer_get32(buf);\n        rawml->fdst->fdst_section_ends[i] = mobi_buffer_get32(buf);\n        debug_print(\"FDST[%zu]:\\t%i\\t%i\\n\", i, rawml->fdst->fdst_section_starts[i], rawml->fdst->fdst_section_ends[i]);\n        i++;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read MOBI document from file into MOBIData structure\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file File descriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_file(MOBIData *m, FILE *file) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    ret = mobi_load_pdbheader(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (strcmp(m->ph->type, \"BOOK\") != 0 && strcmp(m->ph->type, \"TEXt\") != 0) {\n        debug_print(\"Unsupported file type: %s\\n\", m->ph->type);\n        return MOBI_FILE_UNSUPPORTED;\n    }\n    if (m->ph->rec_count == 0) {\n        debug_print(\"%s\", \"No records found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_load_reclist(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_load_rec(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_parse_record0(m, 0);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (m->rh && m->rh->encryption_type == RECORD0_OLD_ENCRYPTION) {\n        /* try to set key for encryption type 1 */\n        debug_print(\"Trying to set key for encryption type 1%s\", \"\\n\")\n        mobi_drm_setkey(m, NULL);\n    }\n    /* if EXTH is loaded parse KF8 record0 for hybrid KF7/KF8 file */\n    if (m->eh) {\n        const size_t boundary_rec_number = mobi_get_kf8boundary_seqnumber(m);\n        if (boundary_rec_number != MOBI_NOTSET && boundary_rec_number < UINT32_MAX) {\n            /* it is a hybrid KF7/KF8 file */\n            m->kf8_boundary_offset = (uint32_t) boundary_rec_number;\n            m->next = mobi_init();\n            /* link pdb header and records data to KF8data structure */\n            m->next->ph = m->ph;\n            m->next->rec = m->rec;\n            m->next->drm_key = m->drm_key;\n            /* close next loop */\n            m->next->next = m;\n            ret = mobi_parse_record0(m->next, boundary_rec_number + 1);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            /* swap to kf8 part if use_kf8 flag is set */\n            if (m->use_kf8) {\n                mobi_swap_mobidata(m);\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read MOBI document from a path into MOBIData structure\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] path Path to a MOBI document on disk (eg. /home/me/test.mobi)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_filename(MOBIData *m, const char *path) {\n    FILE *file = fopen(path, \"rb\");\n    if (file == NULL) {\n        debug_print(\"%s\", \"File not found\\n\");\n        return MOBI_FILE_NOT_FOUND;\n    }\n    const MOBI_RET ret = mobi_load_file(m, file);\n    fclose(file);\n    return ret;\n}\n"], "fixing_code": ["/** @file read.c\n *  @brief Functions for reading and parsing of MOBI document\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"read.h\"\n#include \"util.h\"\n#include \"index.h\"\n#include \"debug.h\"\n\n/**\n @brief Read palm database header from file into MOBIData structure (MOBIPdbHeader)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_pdbheader(MOBIData *m, FILE *file) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (!file) {\n        return MOBI_FILE_NOT_FOUND;\n    }\n    MOBIBuffer *buf = mobi_buffer_init(PALMDB_HEADER_LEN);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    const size_t len = fread(buf->data, 1, PALMDB_HEADER_LEN, file);\n    if (len != PALMDB_HEADER_LEN) {\n        mobi_buffer_free(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    m->ph = calloc(1, sizeof(MOBIPdbHeader));\n    if (m->ph == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb header failed\\n\");\n        mobi_buffer_free(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    /* parse header */\n    mobi_buffer_getstring(m->ph->name, buf, PALMDB_NAME_SIZE_MAX);\n    m->ph->attributes = mobi_buffer_get16(buf);\n    m->ph->version = mobi_buffer_get16(buf);\n    m->ph->ctime = mobi_buffer_get32(buf);\n    m->ph->mtime = mobi_buffer_get32(buf);\n    m->ph->btime = mobi_buffer_get32(buf);\n    m->ph->mod_num = mobi_buffer_get32(buf);\n    m->ph->appinfo_offset = mobi_buffer_get32(buf);\n    m->ph->sortinfo_offset = mobi_buffer_get32(buf);\n    mobi_buffer_getstring(m->ph->type, buf, 4);\n    mobi_buffer_getstring(m->ph->creator, buf, 4);\n    m->ph->uid = mobi_buffer_get32(buf);\n    m->ph->next_rec = mobi_buffer_get32(buf);\n    m->ph->rec_count = mobi_buffer_get16(buf);\n    mobi_buffer_free(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read list of database records from file into MOBIData structure (MOBIPdbRecord)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_reclist(MOBIData *m, FILE *file) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (!file) {\n        debug_print(\"%s\", \"File not ready\\n\");\n        return MOBI_FILE_NOT_FOUND;\n    }\n    m->rec = calloc(1, sizeof(MOBIPdbRecord));\n    if (m->rec == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb record failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    for (int i = 0; i < m->ph->rec_count; i++) {\n        MOBIBuffer *buf = mobi_buffer_init(PALMDB_RECORD_INFO_SIZE);\n        if (buf == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const size_t len = fread(buf->data, 1, PALMDB_RECORD_INFO_SIZE, file);\n        if (len != PALMDB_RECORD_INFO_SIZE) {\n            mobi_buffer_free(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        if (i > 0) {\n            curr->next = calloc(1, sizeof(MOBIPdbRecord));\n            if (curr->next == NULL) {\n                debug_print(\"%s\", \"Memory allocation for pdb record failed\\n\");\n                mobi_buffer_free(buf);\n                return MOBI_MALLOC_FAILED;\n            }\n            curr = curr->next;\n        }\n        curr->offset = mobi_buffer_get32(buf);\n        curr->attributes = mobi_buffer_get8(buf);\n        const uint8_t h = mobi_buffer_get8(buf);\n        const uint16_t l = mobi_buffer_get16(buf);\n        curr->uid =  (uint32_t) h << 16 | l;\n        curr->next = NULL;\n        mobi_buffer_free(buf);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read record data and size from file into MOBIData structure (MOBIPdbRecord)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_rec(MOBIData *m, FILE *file) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    while (curr != NULL) {\n        MOBIPdbRecord *next;\n        size_t size;\n        if (curr->next != NULL) {\n            next = curr->next;\n            size = next->offset - curr->offset;\n        } else {\n            fseek(file, 0, SEEK_END);\n            long diff = ftell(file) - curr->offset;\n            if (diff <= 0) {\n                debug_print(\"Wrong record size: %li\\n\", diff);\n                return MOBI_DATA_CORRUPT;\n            }\n            size = (size_t) diff;\n            next = NULL;\n        }\n\n        curr->size = size;\n        ret = mobi_load_recdata(curr, file);\n        if (ret  != MOBI_SUCCESS) {\n            debug_print(\"Error loading record uid %i data\\n\", curr->uid);\n            mobi_free_rec(m);\n            return ret;\n        }\n        curr = next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read record data from file into MOBIPdbRecord structure\n \n @param[in,out] rec MOBIPdbRecord structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_recdata(MOBIPdbRecord *rec, FILE *file) {\n    const int ret = fseek(file, rec->offset, SEEK_SET);\n    if (ret != 0) {\n        debug_print(\"Record %i not found\\n\", rec->uid);\n        return MOBI_DATA_CORRUPT;\n    }\n    rec->data = malloc(rec->size);\n    if (rec->data == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb record data failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    const size_t len = fread(rec->data, 1, rec->size, file);\n    if (len < rec->size) {\n        debug_print(\"Truncated data in record %i\\n\", rec->uid);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse EXTH header from Record 0 into MOBIData structure (MOBIExthHeader)\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] buf MOBIBuffer buffer to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_extheader(MOBIData *m, MOBIBuffer *buf) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    char exth_magic[5];\n    const size_t header_length = 12;\n    mobi_buffer_getstring(exth_magic, buf, 4);\n    const size_t exth_length = mobi_buffer_get32(buf) - header_length;\n    const size_t rec_count = mobi_buffer_get32(buf);\n    if (strncmp(exth_magic, EXTH_MAGIC, 4) != 0 ||\n        exth_length + buf->offset > buf->maxlen ||\n        rec_count == 0 || rec_count > MOBI_EXTH_MAXCNT) {\n        debug_print(\"%s\", \"Sanity checks for EXTH header failed\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t saved_maxlen = buf->maxlen;\n    buf->maxlen = exth_length + buf->offset;\n    m->eh = calloc(1, sizeof(MOBIExthHeader));\n    if (m->eh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for EXTH header failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIExthHeader *curr = m->eh;\n    for (size_t i = 0; i < rec_count; i++) {\n        if (curr->data) {\n            curr->next = calloc(1, sizeof(MOBIExthHeader));\n            if (curr->next == NULL) {\n                debug_print(\"%s\", \"Memory allocation for EXTH header failed\\n\");\n                mobi_free_eh(m);\n                return MOBI_MALLOC_FAILED;\n            }\n            curr = curr->next;\n        }\n        curr->tag = mobi_buffer_get32(buf);\n        /* data size = record size minus 8 bytes for uid and size */\n        curr->size = mobi_buffer_get32(buf) - 8;\n        if (curr->size == 0) {\n            debug_print(\"Skip record %i, data too short\\n\", curr->tag);\n            continue;\n        }\n        if (buf->offset + curr->size > buf->maxlen) {\n            debug_print(\"Record %i too long\\n\", curr->tag);\n            mobi_free_eh(m);\n            return MOBI_DATA_CORRUPT;\n        }\n        curr->data = malloc(curr->size);\n        if (curr->data == NULL) {\n            debug_print(\"Memory allocation for EXTH record %i failed\\n\", curr->tag);\n            mobi_free_eh(m);\n            return MOBI_MALLOC_FAILED;\n        }\n        mobi_buffer_getraw(curr->data, buf, curr->size);\n        curr->next = NULL;\n    }    \n    buf->maxlen = saved_maxlen;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse MOBI header from Record 0 into MOBIData structure (MOBIMobiHeader)\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] buf MOBIBuffer buffer to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_mobiheader(MOBIData *m, MOBIBuffer *buf) {\n    int isKF8 = 0;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    m->mh = calloc(1, sizeof(MOBIMobiHeader));\n    if (m->mh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    mobi_buffer_getstring(m->mh->mobi_magic, buf, 4);\n    mobi_buffer_dup32(&m->mh->header_length, buf);\n    if (strcmp(m->mh->mobi_magic, MOBI_MAGIC) != 0 || m->mh->header_length == NULL) {\n        debug_print(\"%s\", \"MOBI header not found\\n\");\n        mobi_free_mh(m->mh);\n        m->mh = NULL;\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t saved_maxlen = buf->maxlen;\n    /* some old files declare zero length mobi header, try to read first 24 bytes anyway */\n    uint32_t header_length = (*m->mh->header_length > 0) ? *m->mh->header_length : 24;\n    /* read only declared MOBI header length (curr offset minus 8 already read bytes) */\n    const size_t left_length = header_length + buf->offset - 8;\n    buf->maxlen = saved_maxlen < left_length ? saved_maxlen : left_length;\n    mobi_buffer_dup32(&m->mh->mobi_type, buf);\n    uint32_t encoding = mobi_buffer_get32(buf);\n    if (encoding == 1252) {\n        m->mh->text_encoding = malloc(sizeof(MOBIEncoding));\n        if (m->mh->text_encoding == NULL) {\n            debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        *m->mh->text_encoding = MOBI_CP1252;\n    }\n    else if (encoding == 65001) {\n        m->mh->text_encoding = malloc(sizeof(MOBIEncoding));\n        if (m->mh->text_encoding == NULL) {\n            debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        *m->mh->text_encoding = MOBI_UTF8;\n    } else {\n        debug_print(\"Unknown encoding in mobi header: %i\\n\", encoding);\n    }\n    mobi_buffer_dup32(&m->mh->uid, buf);\n    mobi_buffer_dup32(&m->mh->version, buf);\n    if (header_length >= MOBI_HEADER_V7_SIZE\n        && m->mh->version && *m->mh->version == 8) {\n        isKF8 = 1;\n    }\n    mobi_buffer_dup32(&m->mh->orth_index, buf);\n    mobi_buffer_dup32(&m->mh->infl_index, buf);\n    mobi_buffer_dup32(&m->mh->names_index, buf);\n    mobi_buffer_dup32(&m->mh->keys_index, buf);\n    mobi_buffer_dup32(&m->mh->extra0_index, buf);\n    mobi_buffer_dup32(&m->mh->extra1_index, buf);\n    mobi_buffer_dup32(&m->mh->extra2_index, buf);\n    mobi_buffer_dup32(&m->mh->extra3_index, buf);\n    mobi_buffer_dup32(&m->mh->extra4_index, buf);\n    mobi_buffer_dup32(&m->mh->extra5_index, buf);\n    mobi_buffer_dup32(&m->mh->non_text_index, buf);\n    mobi_buffer_dup32(&m->mh->full_name_offset, buf);\n    mobi_buffer_dup32(&m->mh->full_name_length, buf);\n    mobi_buffer_dup32(&m->mh->locale, buf);\n    mobi_buffer_dup32(&m->mh->dict_input_lang, buf);\n    mobi_buffer_dup32(&m->mh->dict_output_lang, buf);\n    mobi_buffer_dup32(&m->mh->min_version, buf);\n    mobi_buffer_dup32(&m->mh->image_index, buf);\n    mobi_buffer_dup32(&m->mh->huff_rec_index, buf);\n    mobi_buffer_dup32(&m->mh->huff_rec_count, buf);\n    mobi_buffer_dup32(&m->mh->datp_rec_index, buf);\n    mobi_buffer_dup32(&m->mh->datp_rec_count, buf);\n    mobi_buffer_dup32(&m->mh->exth_flags, buf);\n    mobi_buffer_seek(buf, 32); /* 32 unknown bytes */\n    mobi_buffer_dup32(&m->mh->unknown6, buf);\n    mobi_buffer_dup32(&m->mh->drm_offset, buf);\n    mobi_buffer_dup32(&m->mh->drm_count, buf);\n    mobi_buffer_dup32(&m->mh->drm_size, buf);\n    mobi_buffer_dup32(&m->mh->drm_flags, buf);\n    mobi_buffer_seek(buf, 8); /* 8 unknown bytes */\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->fdst_index, buf);\n    } else {\n        mobi_buffer_dup16(&m->mh->first_text_index, buf);\n        mobi_buffer_dup16(&m->mh->last_text_index, buf);\n    }\n    mobi_buffer_dup32(&m->mh->fdst_section_count, buf);\n    mobi_buffer_dup32(&m->mh->fcis_index, buf);\n    mobi_buffer_dup32(&m->mh->fcis_count, buf);\n    mobi_buffer_dup32(&m->mh->flis_index, buf);\n    mobi_buffer_dup32(&m->mh->flis_count, buf);\n    mobi_buffer_dup32(&m->mh->unknown10, buf);\n    mobi_buffer_dup32(&m->mh->unknown11, buf);\n    mobi_buffer_dup32(&m->mh->srcs_index, buf);\n    mobi_buffer_dup32(&m->mh->srcs_count, buf);\n    mobi_buffer_dup32(&m->mh->unknown12, buf);\n    mobi_buffer_dup32(&m->mh->unknown13, buf);\n    mobi_buffer_seek(buf, 2); /* 2 byte fill */\n    mobi_buffer_dup16(&m->mh->extra_flags, buf);\n    mobi_buffer_dup32(&m->mh->ncx_index, buf);\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->fragment_index, buf);\n        mobi_buffer_dup32(&m->mh->skeleton_index, buf);\n    } else {\n        mobi_buffer_dup32(&m->mh->unknown14, buf);\n        mobi_buffer_dup32(&m->mh->unknown15, buf);\n    }\n    mobi_buffer_dup32(&m->mh->datp_index, buf);\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->guide_index, buf);\n    } else {\n        mobi_buffer_dup32(&m->mh->unknown16, buf);\n    }\n    mobi_buffer_dup32(&m->mh->unknown17, buf);\n    mobi_buffer_dup32(&m->mh->unknown18, buf);\n    mobi_buffer_dup32(&m->mh->unknown19, buf);\n    mobi_buffer_dup32(&m->mh->unknown20, buf);\n    if (buf->maxlen > buf->offset) {\n        debug_print(\"Skipping %zu unknown bytes in MOBI header\\n\", (buf->maxlen - buf->offset));\n        mobi_buffer_setpos(buf, buf->maxlen);\n    }\n    buf->maxlen = saved_maxlen;\n    /* get full name stored at m->mh->full_name_offset */\n    if (m->mh->full_name_offset && m->mh->full_name_length) {\n        const size_t saved_offset = buf->offset;\n        const uint32_t full_name_length = min(*m->mh->full_name_length, MOBI_TITLE_SIZEMAX);\n        mobi_buffer_setpos(buf, *m->mh->full_name_offset);\n        m->mh->full_name = malloc(full_name_length + 1);\n        if (m->mh->full_name == NULL) {\n            debug_print(\"%s\", \"Memory allocation for full name failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        if (full_name_length) {\n            mobi_buffer_getstring(m->mh->full_name, buf, full_name_length);\n        } else {\n            m->mh->full_name[0] = '\\0';\n        }\n        mobi_buffer_setpos(buf, saved_offset);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse Record 0 into MOBIData structure\n \n This function will parse MOBIRecord0Header, MOBIMobiHeader and MOBIExthHeader\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] seqnumber Sequential number of the palm database record\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_record0(MOBIData *m, const size_t seqnumber) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const MOBIPdbRecord *record0 = mobi_get_record_by_seqnumber(m, seqnumber);\n    if (record0 == NULL) {\n        debug_print(\"%s\", \"Record 0 not loaded\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (record0->size < RECORD0_HEADER_LEN) {\n        debug_print(\"%s\", \"Record 0 too short\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(record0->data, record0->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    m->rh = calloc(1, sizeof(MOBIRecord0Header));\n    if (m->rh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for record 0 header failed\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    /* parse palmdoc header */\n    const uint16_t compression = mobi_buffer_get16(buf);\n    mobi_buffer_seek(buf, 2); // unused 2 bytes, zeroes\n    if ((compression != RECORD0_NO_COMPRESSION &&\n         compression != RECORD0_PALMDOC_COMPRESSION &&\n         compression != RECORD0_HUFF_COMPRESSION)) {\n        debug_print(\"Wrong record0 header: %c%c%c%c\\n\", record0->data[0], record0->data[1], record0->data[2], record0->data[3]);\n        mobi_buffer_free_null(buf);\n        free(m->rh);\n        m->rh = NULL;\n        return MOBI_DATA_CORRUPT;\n    }\n    m->rh->compression_type = compression;\n    m->rh->text_length = mobi_buffer_get32(buf);\n    m->rh->text_record_count = mobi_buffer_get16(buf);\n    m->rh->text_record_size = mobi_buffer_get16(buf);\n    m->rh->encryption_type = mobi_buffer_get16(buf);\n    m->rh->unknown1 = mobi_buffer_get16(buf);\n    if (mobi_is_mobipocket(m)) {\n        /* parse mobi header if present  */\n        ret = mobi_parse_mobiheader(m, buf);\n        if (ret == MOBI_SUCCESS) {\n            /* parse exth header if present */\n            mobi_parse_extheader(m, buf);\n        }\n    } \n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Calculate the size of extra bytes at the end of text record\n \n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] flags Flags from MOBI header (extra_flags)\n @return The size of trailing bytes, MOBI_NOTSET on failure\n */\nsize_t mobi_get_record_extrasize(const MOBIPdbRecord *record, const uint16_t flags) {\n    size_t extra_size = 0;\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\", \"Buffer init in extrasize failed\\n\");\n        return MOBI_NOTSET;\n    }\n    /* set pointer at the end of the record data */\n    mobi_buffer_setpos(buf, buf->maxlen - 1);\n    for (int bit = 15; bit > 0; bit--) {\n        if (flags & (1 << bit)) {\n            /* bit is set */\n            size_t len = 0;\n            /* size contains varlen itself and optional data */\n            const uint32_t size = mobi_buffer_get_varlen_dec(buf, &len);\n            /* skip data */\n            /* TODO: read and store in record struct */\n            mobi_buffer_seek(buf, - (int)(size - len));\n            extra_size += size;\n        }\n    };\n    /* check bit 0 */\n    if (flags & 1) {\n            const uint8_t b = mobi_buffer_get8(buf);\n            /* two first bits hold size */\n            extra_size += (b & 0x3) + 1;\n    }\n    mobi_buffer_free_null(buf);\n    return extra_size;\n}\n\n/**\n @brief Calculate the size of extra multibyte section at the end of text record\n \n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] flags Flags from MOBI header (extra_flags)\n @return The size of trailing bytes, MOBI_NOTSET on failure\n */\nsize_t mobi_get_record_mb_extrasize(const MOBIPdbRecord *record, const uint16_t flags) {\n    size_t extra_size = 0;\n    if (flags & 1) {\n        MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n        if (buf == NULL) {\n            debug_print(\"%s\", \"Buffer init in extrasize failed\\n\");\n            return MOBI_NOTSET;\n        }\n        /* set pointer at the end of the record data */\n        mobi_buffer_setpos(buf, buf->maxlen - 1);\n        for (int bit = 15; bit > 0; bit--) {\n            if (flags & (1 << bit)) {\n                /* bit is set */\n                size_t len = 0;\n                /* size contains varlen itself and optional data */\n                const uint32_t size = mobi_buffer_get_varlen_dec(buf, &len);\n                /* skip data */\n                /* TODO: read and store in record struct */\n                mobi_buffer_seek(buf, - (int)(size - len));\n            }\n        };\n        /* read multibyte section */\n        const uint8_t b = mobi_buffer_get8(buf);\n        /* two first bits hold size */\n        extra_size += (b & 0x3) + 1;\n        mobi_buffer_free_null(buf);\n    }\n    return extra_size;\n}\n\n/**\n @brief Parse HUFF record into MOBIHuffCdic structure\n \n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @param[in] record MOBIPdbRecord structure containing the record\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char huff_magic[5];\n    mobi_buffer_getstring(huff_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) {\n        debug_print(\"HUFF wrong magic: %s\\n\", huff_magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t data1_offset = mobi_buffer_get32(buf);\n    const size_t data2_offset = mobi_buffer_get32(buf);\n    /* skip little-endian table offsets */\n    mobi_buffer_setpos(buf, data1_offset);\n    if (buf->offset + (256 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data1 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 256 indices from data1 big-endian */\n    for (int i = 0; i < 256; i++) {\n        huffcdic->table1[i] = mobi_buffer_get32(buf);\n    }\n    mobi_buffer_setpos(buf, data2_offset);\n    if (buf->offset + (64 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data2 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 32 mincode-maxcode pairs from data2 big-endian */\n    huffcdic->mincode_table[0] = 0;\n    huffcdic->maxcode_table[0] = 0xFFFFFFFF;\n    for (int i = 1; i < HUFF_CODETABLE_SIZE; i++) {\n        const uint32_t mincode = mobi_buffer_get32(buf);\n        const uint32_t maxcode = mobi_buffer_get32(buf);\n        huffcdic->mincode_table[i] =  mincode << (32 - i);\n        huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse CDIC record into MOBIHuffCdic structure\n \n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] num Number of CDIC record in a set, starting from zero\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_cdic(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record, const size_t num) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char cdic_magic[5];\n    mobi_buffer_getstring(cdic_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(cdic_magic, CDIC_MAGIC, 4) != 0 || header_length < CDIC_HEADER_LEN) {\n        debug_print(\"CDIC wrong magic: %s or declared header length: %zu\\n\", cdic_magic, header_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* variables in huffcdic initialized to zero with calloc */\n    /* save initial count and length */\n    size_t index_count = mobi_buffer_get32(buf);\n    const size_t code_length = mobi_buffer_get32(buf);\n    if (huffcdic->code_length && huffcdic->code_length != code_length) {\n        debug_print(\"CDIC different code length %zu in record %i, previous was %zu\\n\", huffcdic->code_length, record->uid, code_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (huffcdic->index_count && huffcdic->index_count != index_count) {\n        debug_print(\"CDIC different index count %zu in record %i, previous was %zu\\n\", huffcdic->index_count, record->uid, index_count);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (code_length == 0 || code_length > HUFF_CODELEN_MAX) {\n        debug_print(\"Code length exceeds sanity checks (%zu)\\n\", code_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    huffcdic->code_length = code_length;\n    huffcdic->index_count = index_count;\n    if (index_count == 0) {\n        debug_print(\"%s\", \"CDIC index count is null\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* allocate memory for symbol offsets if not already allocated */\n    if (num == 0) {\n        if (index_count > (1 << HUFF_CODELEN_MAX) * CDIC_RECORD_MAXCNT) {\n            debug_print(\"CDIC index count too large %zu\\n\", index_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        huffcdic->symbol_offsets = malloc(index_count * sizeof(*huffcdic->symbol_offsets));\n        if (huffcdic->symbol_offsets == NULL) {\n            debug_print(\"%s\", \"CDIC cannot allocate memory\");\n            mobi_buffer_free_null(buf);\n            return MOBI_MALLOC_FAILED;\n        }\n    }\n    index_count -= huffcdic->index_read;\n    /* limit number of records read to code_length bits */\n    if (index_count >> code_length) {\n        index_count = (1 << code_length);\n    }\n    if (buf->offset + (index_count * 2) > buf->maxlen) {\n        debug_print(\"%s\", \"CDIC indices data too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read i * 2 byte big-endian indices */\n    while (index_count--) {\n        const uint16_t offset = mobi_buffer_get16(buf);\n        const size_t saved_pos = buf->offset;\n        mobi_buffer_setpos(buf, offset + CDIC_HEADER_LEN);\n        const size_t len = mobi_buffer_get16(buf) & 0x7fff;\n        if (buf->error != MOBI_SUCCESS || buf->offset + len > buf->maxlen) {\n            debug_print(\"%s\", \"CDIC offset beyond buffer\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        mobi_buffer_setpos(buf, saved_pos);\n        huffcdic->symbol_offsets[huffcdic->index_read++] = offset;\n    }\n    if (buf->offset + code_length > buf->maxlen) {\n        debug_print(\"%s\", \"CDIC dictionary data too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* copy pointer to data */\n    huffcdic->symbols[num] = record->data + CDIC_HEADER_LEN;\n    /* free buffer */\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse a set of HUFF and CDIC records into MOBIHuffCdic structure\n \n @param[in] m MOBIData structure with loaded MOBI document\n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    /* allocate memory for symbols data in each CDIC record */\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* get following CDIC records */\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    if (huffcdic->index_count != huffcdic->index_read) {\n        debug_print(\"CDIC: wrong read index count: %zu, total: %zu\\n\", huffcdic->index_read, huffcdic->index_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse FDST record into MOBIRawml structure (MOBIFdst member)\n \n @param[in] m MOBIData structure with loaded MOBI document\n @param[in,out] rawml MOBIRawml structure to be filled with parsed data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_fdst(const MOBIData *m, MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t fdst_record_number = mobi_get_fdst_record_number(m);\n    if (fdst_record_number == MOBI_NOTSET) {\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *fdst_record = mobi_get_record_by_seqnumber(m, fdst_record_number);\n    if (fdst_record == NULL) {\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(fdst_record->data, fdst_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char fdst_magic[5];\n    mobi_buffer_getstring(fdst_magic, buf, 4);\n    const size_t data_offset = mobi_buffer_get32(buf);\n    const size_t section_count = mobi_buffer_get32(buf);\n    if (strncmp(fdst_magic, FDST_MAGIC, 4) != 0 ||\n        section_count <= 1 ||\n        section_count != *m->mh->fdst_section_count ||\n        data_offset != 12) {\n        debug_print(\"FDST wrong magic: %s, sections count: %zu or data offset: %zu\\n\", fdst_magic, section_count, data_offset);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if ((buf->maxlen - buf->offset) < section_count * 8) {\n        debug_print(\"%s\", \"Record FDST too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    rawml->fdst = malloc(sizeof(MOBIFdst));\n    if (rawml->fdst == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    rawml->fdst->fdst_section_count = section_count;\n    rawml->fdst->fdst_section_starts = malloc(sizeof(*rawml->fdst->fdst_section_starts) * section_count);\n    if (rawml->fdst->fdst_section_starts == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        free(rawml->fdst);\n        rawml->fdst = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    rawml->fdst->fdst_section_ends = malloc(sizeof(*rawml->fdst->fdst_section_ends) * section_count);\n    if (rawml->fdst->fdst_section_ends == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        free(rawml->fdst->fdst_section_starts);\n        free(rawml->fdst);\n        rawml->fdst = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    while (i < section_count) {\n        rawml->fdst->fdst_section_starts[i] = mobi_buffer_get32(buf);\n        rawml->fdst->fdst_section_ends[i] = mobi_buffer_get32(buf);\n        debug_print(\"FDST[%zu]:\\t%i\\t%i\\n\", i, rawml->fdst->fdst_section_starts[i], rawml->fdst->fdst_section_ends[i]);\n        i++;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read MOBI document from file into MOBIData structure\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file File descriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_file(MOBIData *m, FILE *file) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    ret = mobi_load_pdbheader(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (strcmp(m->ph->type, \"BOOK\") != 0 && strcmp(m->ph->type, \"TEXt\") != 0) {\n        debug_print(\"Unsupported file type: %s\\n\", m->ph->type);\n        return MOBI_FILE_UNSUPPORTED;\n    }\n    if (m->ph->rec_count == 0) {\n        debug_print(\"%s\", \"No records found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_load_reclist(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_load_rec(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_parse_record0(m, 0);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (m->rh && m->rh->encryption_type == RECORD0_OLD_ENCRYPTION) {\n        /* try to set key for encryption type 1 */\n        debug_print(\"Trying to set key for encryption type 1%s\", \"\\n\")\n        mobi_drm_setkey(m, NULL);\n    }\n    /* if EXTH is loaded parse KF8 record0 for hybrid KF7/KF8 file */\n    if (m->eh) {\n        const size_t boundary_rec_number = mobi_get_kf8boundary_seqnumber(m);\n        if (boundary_rec_number != MOBI_NOTSET && boundary_rec_number < UINT32_MAX) {\n            /* it is a hybrid KF7/KF8 file */\n            m->kf8_boundary_offset = (uint32_t) boundary_rec_number;\n            m->next = mobi_init();\n            /* link pdb header and records data to KF8data structure */\n            m->next->ph = m->ph;\n            m->next->rec = m->rec;\n            m->next->drm_key = m->drm_key;\n            /* close next loop */\n            m->next->next = m;\n            ret = mobi_parse_record0(m->next, boundary_rec_number + 1);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            /* swap to kf8 part if use_kf8 flag is set */\n            if (m->use_kf8) {\n                mobi_swap_mobidata(m);\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read MOBI document from a path into MOBIData structure\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] path Path to a MOBI document on disk (eg. /home/me/test.mobi)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_filename(MOBIData *m, const char *path) {\n    FILE *file = fopen(path, \"rb\");\n    if (file == NULL) {\n        debug_print(\"%s\", \"File not found\\n\");\n        return MOBI_FILE_NOT_FOUND;\n    }\n    const MOBI_RET ret = mobi_load_file(m, file);\n    fclose(file);\n    return ret;\n}\n"], "filenames": ["src/read.c"], "buggy_code_start_loc": [754], "buggy_code_end_loc": [754], "fixing_code_start_loc": [755], "fixing_code_end_loc": [759], "type": "CWE-119", "message": "libmobi is vulnerable to Use of Out-of-range Pointer Offset", "other": {"cve": {"id": "CVE-2021-3888", "sourceIdentifier": "security@huntr.dev", "published": "2021-10-19T13:15:11.927", "lastModified": "2022-04-25T18:01:06.407", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libmobi is vulnerable to Use of Out-of-range Pointer Offset"}, {"lang": "es", "value": "libmobi es vulnerable a un Uso de Punteros Fuera de Rango"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-823"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libmobi_project:libmobi:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.8", "matchCriteriaId": "FB9BADF8-3FCF-4B8B-8161-00A450C9789A"}]}]}], "references": [{"url": "https://github.com/bfabiszewski/libmobi/commit/c78e186739b50d156cb3da5d08d70294f0490853", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/722b3acb-792b-4429-a98d-bb80efb8938d", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bfabiszewski/libmobi/commit/c78e186739b50d156cb3da5d08d70294f0490853"}}