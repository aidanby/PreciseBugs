{"buggy_code": ["/* radare - LGPL3 - Copyright 2016-2021 - Matthieu (c0riolis) Tardy - l0stb1t*/\n\n#include <r_io.h>\n#include <r_bin.h>\n#include \"marshal.h\"\n#include \"pyc_magic.h\"\n\n// avoiding using r2 internals asserts\n#define if_true_return(cond,ret) if(cond){return(ret);}\n\n// TODO: kill globals\nstatic ut32 magic_int;\nstatic ut32 symbols_ordinal = 0;\nstatic RList *refs = NULL; // If you don't have a good reason, do not change this. And also checkout !refs in get_code_object()\n\n/* interned_table is used to handle TYPE_INTERNED object */\nextern RList *interned_table;\n\nstatic pyc_object *get_object(RBuffer *buffer);\nstatic pyc_object *copy_object(pyc_object *object);\nstatic void free_object(pyc_object *object);\n\nstatic ut8 get_ut8(RBuffer *buffer, bool *error) {\n\tut8 ret = 0;\n\tint size = r_buf_read (buffer, &ret, sizeof (ret));\n\tif (size < sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut16 get_ut16(RBuffer *buffer, bool *error) {\n\tut16 ret = 0;\n\n\tint size = r_buf_read (buffer, (ut8 *)&ret, sizeof (ret));\n\tif (size != sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut32 get_ut32(RBuffer *buffer, bool *error) {\n\tut32 ret = 0;\n\tint size = r_buf_read (buffer, (ut8 *)&ret, sizeof (ret));\n\tif (size != sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic st32 get_st32(RBuffer *buffer, bool *error) {\n\tst32 ret = 0;\n\tint size = r_buf_read (buffer, (ut8 *)&ret, sizeof (ret));\n\tif (size < sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic st64 get_st64(RBuffer *buffer, bool *error) {\n\tst64 ret = 0;\n\tint size = r_buf_read (buffer, (ut8 *)&ret, sizeof (ret));\n\tif (size < sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic double get_float64(RBuffer *buffer, bool *error) {\n\tdouble ret = 0;\n\tint size = r_buf_read (buffer, (ut8 *)&ret, sizeof (ret));\n\tif (size < sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut8 *get_bytes(RBuffer *buffer, ut32 size) {\n\tut8 *ret = R_NEWS0 (ut8, size + 1);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read (buffer, ret, size) < size) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_none_object(void) {\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (ret) {\n\t\tret->type = TYPE_NONE;\n\t\tret->data = strdup (\"None\");\n\t\tif (!ret->data) {\n\t\t\tR_FREE (ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_false_object(void) {\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_FALSE;\n\tret->data = strdup (\"False\");\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_true_object(void) {\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_TRUE;\n\tret->data = strdup (\"True\");\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_int_object(RBuffer *buffer) {\n\tbool error = false;\n\n\tst32 i = get_st32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_INT;\n\tret->data = r_str_newf (\"%d\", i);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_int64_object(RBuffer *buffer) {\n\tbool error = false;\n\tst64 i = get_st64 (buffer, &error);\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (ret) {\n\t\tret->type = TYPE_INT64;\n\t\tret->data = r_str_newf (\"%\"PFMT64d, (st64)i);\n\t\tif (!ret->data) {\n\t\t\tR_FREE (ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* long is used when the number is > MAX_INT64 */\nstatic pyc_object *get_long_object(RBuffer *buffer) {\n\tbool error = false;\n\tbool neg = false;\n\tut32 tmp = 0;\n\tsize_t size;\n\tsize_t i, j = 0, left = 0;\n\tut16 n;\n\tchar *hexstr;\n\tchar digist2hex[] = \"0123456789abcdef\";\n\n\tst32 ndigits = get_st32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_LONG;\n\tif (ndigits < 0) {\n\t\tndigits = -ndigits;\n\t\tneg = true;\n\t}\n\tif (ndigits == 0) {\n\t\tret->data = strdup (\"0x0\");\n\t} else {\n\t\tif (ndigits > 10) {\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize = ndigits * 15;\n\t\tif (size < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tsize = (size - 1) / 4 + 1;\n\t\tif (size < 1) {\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize += 3 + (neg? 1: 0);\n\t\tj = size - 1;\n\t\thexstr = calloc (size, sizeof (char));\n\t\tif (!hexstr) {\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (i = 0; i < ndigits; i++) {\n\t\t\tn = get_ut16 (buffer, &error);\n\t\t\ttmp |= n << left;\n\t\t\tleft += 15;\n\n\t\t\twhile (left >= 4 && j >= 0) {\n\t\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t\t\ttmp >>= 4;\n\t\t\t\tleft -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp) {\n\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t}\n\n\t\tif (j > 0) {\n\t\t\thexstr[--j] = 'x';\n\t\t}\n\t\tif (j > 0) {\n\t\t\thexstr[--j] = '0';\n\t\t}\n\t\tif (neg && j > 0) {\n\t\t\thexstr[--j] = '-';\n\t\t}\n\n\t\tret->data = &hexstr[j];\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_stringref_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_st32 (buffer, &error);\n\tif (n >= r_list_length (interned_table)) {\n\t\teprintf (\"bad marshal data (string ref out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_STRINGREF;\n\tret->data = r_list_get_n (interned_table, n);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_float_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 size = 0;\n\n\tut8 n = get_ut8 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tut8 *s = malloc (n + 1);\n\tif (!s) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tsize = r_buf_read (buffer, s, n);\n\tif (size != n) {\n\t\tR_FREE (s);\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\ts[n] = '\\0';\n\tret->type = TYPE_FLOAT;\n\tret->data = s;\n\treturn ret;\n}\n\nstatic pyc_object *get_binary_float_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tdouble f;\n\n\tf = get_float64 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_FLOAT;\n\tret->data = r_str_newf (\"%.15g\", f);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_complex_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 size = 0;\n\tst32 n1 = 0;\n\tst32 n2 = 0;\n\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif ((magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8 (buffer, &error);\n\t} else {\n\t\tn1 = get_st32 (buffer, &error);\n\t}\n\tif (error || n1 < 1) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc (n1 + 1);\n\tif (!s1) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tsize = r_buf_read (buffer, s1, n1);\n\tif (size != n1) {\n\t\tR_FREE (s1);\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\n\tif ((magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8 (buffer, &error);\n\t} else\n\t\tn2 = get_st32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc (n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tsize = r_buf_read (buffer, s2, n2);\n\tif (size != n2) {\n\t\tR_FREE (s1);\n\t\tR_FREE (s2);\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\n\tret->type = TYPE_COMPLEX;\n\tret->data = r_str_newf (\"%s+%sj\", s1, s2);\n\tR_FREE (s1);\n\tR_FREE (s2);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_binary_complex_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tdouble a, b;\n\n\t//a + bj\n\ta = get_float64 (buffer, &error);\n\tb = get_float64 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_BINARY_COMPLEX;\n\tret->data = r_str_newf (\"%.15g+%.15gj\", a, b);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_string_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (string size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_STRING;\n\tret->data = get_bytes (buffer, n);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_unicode_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (unicode size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tret->type = TYPE_UNICODE;\n\tret->data = get_bytes (buffer, n);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_interned_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (string size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_INTERNED;\n\tret->data = get_bytes (buffer, n);\n\t/* add data pointer to interned table */\n\tr_list_append (interned_table, ret->data);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {\n\tpyc_object *tmp = NULL;\n\tpyc_object *ret = NULL;\n\tut32 i = 0;\n\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = get_object (buffer);\n\t\tif (!tmp) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!r_list_append (ret->data, tmp)) {\n\t\t\tfree_object (tmp);\n\t\t\tr_list_free (ret->data);\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* small TYPE_SMALL_TUPLE doesn't exist in python2 */\n/* */\nstatic pyc_object *get_small_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut8 n = 0;\n\n\tn = get_ut8 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_SMALL_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_dict_object(RBuffer *buffer) {\n\tpyc_object *key = NULL,\n\t\t   *val = NULL;\n\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\tfor (;;) {\n\t\tkey = get_object (buffer);\n\t\tif (!key) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!r_list_append (ret->data, key)) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\tfree_object (key);\n\t\t\treturn NULL;\n\t\t}\n\t\tval = get_object (buffer);\n\t\tif (!val) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!r_list_append (ret->data, val)) {\n\t\t\tfree_object (val);\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tret->type = TYPE_DICT;\n\treturn ret;\n}\n\nstatic pyc_object *get_set_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}\n\nstatic pyc_object *get_ascii_object_generic(RBuffer *buffer, ut32 size, bool interned) {\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_ASCII;\n\tret->data = get_bytes (buffer, size);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_ascii_object(RBuffer *buffer) {\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic (buffer, n, true);\n}\n\nstatic pyc_object *get_ascii_interned_object(RBuffer *buffer) {\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic (buffer, n, true);\n}\n\nstatic pyc_object *get_short_ascii_object(RBuffer *buffer) {\n\tbool error = false;\n\tut8 n = get_ut8 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic (buffer, n, false);\n}\n\nstatic pyc_object *get_short_ascii_interned_object(RBuffer *buffer) {\n\tbool error = false;\n\tut8 n = get_ut8 (buffer, &error);\n\treturn error? NULL: get_ascii_object_generic (buffer, n, true);\n}\n\nstatic pyc_object *get_ref_object(RBuffer *buffer) {\n\tbool error = false;\n\tut32 index = get_ut32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tif (index >= r_list_length (refs)) {\n\t\treturn NULL;\n\t}\n\tpyc_object *obj = r_list_get_n (refs, index);\n\treturn obj? copy_object (obj): NULL;\n}\n\nstatic void free_object(pyc_object *object) {\n\tif (!object) {\n\t\treturn;\n\t}\n\tif ((int)object->type == 0) {\n\t\treturn;\n\t}\n\tswitch (object->type) {\n\tcase TYPE_SMALL_TUPLE:\n\tcase TYPE_TUPLE:\n\t\tr_list_free (object->data);\n\t\tbreak;\n\tcase TYPE_STRING:\n\tcase TYPE_TRUE:\n\tcase TYPE_FALSE:\n\tcase TYPE_INT:\n\tcase TYPE_NONE:\n\tcase TYPE_NULL:\n\tcase TYPE_ASCII_INTERNED:\n\tcase TYPE_SHORT_ASCII:\n\tcase TYPE_ASCII:\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tfree (object->data);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\tcase TYPE_CODE_v1: {\n\t\tpyc_code_object *cobj = object->data;\n\t\tfree_object (cobj->code);\n\t\tfree_object (cobj->consts);\n\t\tfree_object (cobj->names);\n\t\tfree_object (cobj->varnames);\n\t\tfree_object (cobj->freevars);\n\t\tfree_object (cobj->cellvars);\n\t\tfree_object (cobj->filename);\n\t\tfree_object (cobj->name);\n\t\tfree_object (cobj->lnotab);\n\t\tfree (object->data);\n\t\tbreak;\n\t}\n\tcase TYPE_REF:\n\t\tfree_object (object->data);\n\t\tbreak;\n\tcase TYPE_SET:\n\tcase TYPE_FROZENSET:\n\tcase TYPE_ELLIPSIS:\n\tcase TYPE_STOPITER:\n\tcase TYPE_BINARY_COMPLEX:\n\tcase TYPE_BINARY_FLOAT:\n\tcase TYPE_COMPLEX:\n\tcase TYPE_STRINGREF:\n\tcase TYPE_DICT:\n\tcase TYPE_FLOAT:\n\tcase TYPE_INT64:\n\tcase TYPE_INTERNED:\n\tcase TYPE_LIST:\n\tcase TYPE_LONG:\n\tcase TYPE_UNICODE:\n\tcase TYPE_UNKNOWN:\n\t\teprintf (\"Free not implemented for type %x\\n\", object->type);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Undefined type in free_object (%x)\\n\", object->type);\n\t\tbreak;\n\t}\n\tfree (object);\n}\n\nstatic pyc_object *copy_object(pyc_object *object) {\n\tpyc_object *copy = R_NEW0 (pyc_object);\n\tif (!copy || !object) {\n\t\tfree (copy);\n\t\treturn NULL;\n\t}\n\tcopy->type = object->type;\n\tif ((int)object->type == 0) {\n\t\t// do nothing\n\t} else\n\tswitch (object->type) {\n\tcase TYPE_NULL:\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\tcase TYPE_SMALL_TUPLE:\n\t\tcopy->data = r_list_clone (object->data);\n\t\tbreak;\n\tcase TYPE_INT:\n\tcase TYPE_INT64:\n\tcase TYPE_NONE:\n\tcase TYPE_TRUE:\n\tcase TYPE_FALSE:\n\tcase TYPE_STRING:\n\tcase TYPE_ASCII:\n\tcase TYPE_SHORT_ASCII:\n\tcase TYPE_ASCII_INTERNED:\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tcopy->data = strdup (object->data);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\tcase TYPE_CODE_v1: {\n\t\tpyc_code_object *src = object->data;\n\t\tpyc_code_object *dst = R_NEW0 (pyc_code_object);\n\t\tif (!dst) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy (dst, src, sizeof (*dst));\n\t\tdst->code = copy_object (src->code);\n\t\tdst->consts = copy_object (src->consts);\n\t\tdst->names = copy_object (src->names);\n\t\tdst->varnames = copy_object (src->varnames);\n\t\tdst->freevars = copy_object (src->freevars);\n\t\tdst->cellvars = copy_object (src->cellvars);\n\t\tdst->filename = copy_object (src->filename);\n\t\tdst->name = copy_object (src->name);\n\t\tdst->lnotab = copy_object (src->lnotab);\n\t\tcopy->data = dst;\n\t\tbreak;\n\t}\n\tcase TYPE_REF:\n\t\tcopy->data = copy_object (object->data);\n\t\tbreak;\n\tcase TYPE_ELLIPSIS:\n\tcase TYPE_STOPITER:\n\tcase TYPE_BINARY_COMPLEX:\n\tcase TYPE_BINARY_FLOAT:\n\tcase TYPE_COMPLEX:\n\tcase TYPE_STRINGREF:\n\tcase TYPE_DICT:\n\tcase TYPE_FLOAT:\n\tcase TYPE_FROZENSET:\n\tcase TYPE_INTERNED:\n\tcase TYPE_LIST:\n\tcase TYPE_LONG:\n\tcase TYPE_SET:\n\tcase TYPE_UNICODE:\n\tcase TYPE_UNKNOWN:\n\t\teprintf (\"Copy not implemented for type %x\\n\", object->type);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Undefined type in copy_object (%x)\\n\", object->type);\n\t\tbreak;\n\t}\n\tif (!copy->data) {\n\t\tR_FREE (copy);\n\t}\n\treturn copy;\n}\n\nstatic pyc_object *get_code_object(RBuffer *buffer) {\n\tbool error = false;\n\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tpyc_code_object *cobj = R_NEW0 (pyc_code_object);\n\tif (!ret || !cobj) {\n\t\tfree (ret);\n\t\tfree (cobj);\n\t\treturn NULL;\n\t}\n\n\t//ret->type = TYPE_CODE_v1;\n\t// support start from v1.0\n\tret->data = cobj;\n\n\tbool v10_to_12 = magic_int_within (magic_int, 39170, 16679, &error); // 1.0.1 - 1.2\n\tbool v13_to_22 = magic_int_within (magic_int, 11913, 60718, &error); // 1.3b1 - 2.2a1\n\tbool v11_to_14 = magic_int_within (magic_int, 39170, 20117, &error); // 1.0.1 - 1.4\n\tbool v15_to_22 = magic_int_within (magic_int, 20121, 60718, &error); // 1.5a1 - 2.2a1\n\tbool v13_to_20 = magic_int_within (magic_int, 11913, 50824, &error); // 1.3b1 - 2.0b1\n\t//bool v21_to_27 = (!v13_to_20) && magic_int_within (magic_int, 60124, 62212, &error);\n\tbool has_posonlyargcount = magic_int_within (magic_int, 3410, 3424, &error); // v3.8.0a4 - latest\n\tif (error) {\n\t\tfree (ret);\n\t\tfree (cobj);\n\t\treturn NULL;\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->argcount = get_ut16 (buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->argcount = 0;\n\t} else {\n\t\tcobj->argcount = get_ut32 (buffer, &error);\n\t}\n\n\tif (has_posonlyargcount) {\n\t\tcobj->posonlyargcount = get_ut32 (buffer, &error); // Included in argcount\n\t} else {\n\t\tcobj->posonlyargcount = 0; // None\n\t}\n\n\tif (((3020 < (magic_int & 0xffff)) && ((magic_int & 0xffff) < 20121)) && (!v11_to_14)) {\n\t\tcobj->kwonlyargcount = get_ut32 (buffer, &error); // Not included in argcount\n\t} else {\n\t\tcobj->kwonlyargcount = 0;\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->nlocals = get_ut16 (buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->nlocals = 0;\n\t} else {\n\t\tcobj->nlocals = get_ut32 (buffer, &error);\n\t}\n\n\tif (v15_to_22) {\n\t\tcobj->stacksize = get_ut16 (buffer, &error);\n\t} else if (v11_to_14 || v10_to_12) {\n\t\tcobj->stacksize = 0;\n\t} else {\n\t\tcobj->stacksize = get_ut32 (buffer, &error);\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->flags = get_ut16 (buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->flags = 0;\n\t} else {\n\t\tcobj->flags = get_ut32 (buffer, &error);\n\t}\n\n\t//to help disassemble the code\n\tcobj->start_offset = r_buf_tell (buffer) + 5; // 1 from get_object() and 4 from get_string_object()\n\tif (!refs) {\n\t\treturn ret; //return for entried part to get the root object of this file\n\t}\n\tcobj->code = get_object (buffer);\n\tcobj->end_offset = r_buf_tell (buffer);\n\n\tcobj->consts = get_object (buffer);\n\tcobj->names = get_object (buffer);\n\n\tif (v10_to_12) {\n\t\tcobj->varnames = NULL;\n\t} else {\n\t\tcobj->varnames = get_object (buffer);\n\t}\n\n\tif (!(v10_to_12 || v13_to_20)) {\n\t\tcobj->freevars = get_object (buffer);\n\t\tcobj->cellvars = get_object (buffer);\n\t} else {\n\t\tcobj->freevars = NULL;\n\t\tcobj->cellvars = NULL;\n\t}\n\n\tcobj->filename = get_object (buffer);\n\tcobj->name = get_object (buffer);\n\n\tif (v15_to_22) {\n\t\tcobj->firstlineno = get_ut16 (buffer, &error);\n\t} else if (v11_to_14) {\n\t\tcobj->firstlineno = 0;\n\t} else {\n\t\tcobj->firstlineno = get_ut32 (buffer, &error);\n\t}\n\n\tif (v11_to_14) {\n\t\tcobj->lnotab = NULL;\n\t} else {\n\t\tcobj->lnotab = get_object (buffer);\n\t}\n\n\tif (error) {\n\t\tfree_object (cobj->code);\n\t\tfree_object (cobj->consts);\n\t\tfree_object (cobj->names);\n\t\tfree_object (cobj->varnames);\n\t\tfree_object (cobj->freevars);\n\t\tfree_object (cobj->cellvars);\n\t\tfree_object (cobj->filename);\n\t\tfree_object (cobj->name);\n\t\tfree_object (cobj->lnotab);\n\t\tfree (cobj);\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nut64 get_code_object_addr(RBuffer *buffer, ut32 magic) {\n\tmagic_int = magic;\n\tpyc_object *co = get_code_object (buffer);\n\tut64 result = 0;\n\tif (!co) {\n\t\treturn 0;\n\t}\n\n\tpyc_code_object *cobj = co->data;\n\tresult = cobj->start_offset;\n\tfree_object (co);\n\n\treturn result;\n}\n\nstatic pyc_object *get_object(RBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\tut8 code = get_ut8 (buffer, &error);\n\tbool flag = (code & FLAG_REF);\n\tRListIter *ref_idx = NULL;\n\tut8 type = (code & ~FLAG_REF);\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\n\tif (flag) {\n\t\tpyc_object *noneret = get_none_object ();\n\t\tif (noneret) {\n\t\t\tref_idx = r_list_append (refs, noneret);\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase TYPE_NULL:\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase TYPE_TRUE:\n\t\treturn get_true_object ();\n\tcase TYPE_FALSE:\n\t\tfree_object (ret);\n\t\treturn get_false_object ();\n\tcase TYPE_NONE:\n\t\tfree_object (ret);\n\t\treturn get_none_object ();\n\tcase TYPE_REF:\n\t\tfree_object (ret);\n\t\treturn get_ref_object (buffer);\n\tcase TYPE_SMALL_TUPLE:\n\t\tret = get_small_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\t\tret = get_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRING:\n\t\tret = get_string_object (buffer);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v0;\n\t\t}\n\t\tbreak;\n\tcase TYPE_CODE_v1:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v1;\n\t\t}\n\t\tbreak;\n\tcase TYPE_INT:\n\t\tret = get_int_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII_INTERNED:\n\t\tret = get_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII:\n\t\tret = get_short_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII:\n\t\tret = get_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tret = get_short_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_INT64:\n\t\tret = get_int64_object (buffer);\n\t\tbreak;\n\tcase TYPE_INTERNED:\n\t\tret = get_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRINGREF:\n\t\tret = get_stringref_object (buffer);\n\t\tbreak;\n\tcase TYPE_FLOAT:\n\t\tret = get_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_BINARY_FLOAT:\n\t\tret = get_binary_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_COMPLEX:\n\t\tret = get_complex_object (buffer); // behaviour depends on Python version\n\t\tbreak;\n\tcase TYPE_BINARY_COMPLEX:\n\t\tret = get_binary_complex_object (buffer);\n\t\tbreak;\n\tcase TYPE_LIST:\n\t\tret = get_list_object (buffer);\n\t\tbreak;\n\tcase TYPE_LONG:\n\t\tret = get_long_object (buffer);\n\t\tbreak;\n\tcase TYPE_UNICODE:\n\t\tret = get_unicode_object (buffer);\n\t\tbreak;\n\tcase TYPE_DICT:\n\t\tret = get_dict_object (buffer);\n\t\tbreak;\n\tcase TYPE_FROZENSET:\n\tcase TYPE_SET:\n\t\tret = get_set_object (buffer);\n\t\tbreak;\n\tcase TYPE_STOPITER:\n\tcase TYPE_ELLIPSIS:\n\t\tret = R_NEW0 (pyc_object);\n\t\tbreak;\n\tcase TYPE_UNKNOWN:\n\t\teprintf (\"Get not implemented for type 0x%x\\n\", type);\n\t\tr_list_pop (refs);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase 0:\n\t\t// nop\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Undefined type in get_object (0x%x)\\n\", type);\n\t\t// r_list_pop (refs);\n\t\treturn NULL;\n\t}\n\n\tif (ret && flag && ref_idx) {\n\t\tif (ref_idx->data != ret) {\n\t\t\tfree_object (ref_idx->data);\n\t\t}\n\t\tref_idx->data = copy_object (ret);\n\t}\n\tif (ret) {\n\t\treturn ret;\n\t}\n\tret = get_none_object ();\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tr_list_append (refs, ret);\n\treturn ret;\n}\n\nstatic bool extract_sections_symbols(pyc_object *obj, RList *sections, RList *symbols, RList *cobjs, char *prefix) {\n\tpyc_code_object *cobj = NULL;\n\tRBinSection *section = NULL;\n\tRBinSymbol *symbol = NULL;\n\tRListIter *i = NULL;\n\n\t//each code object is a section\n\tif_true_return (!obj || (obj->type != TYPE_CODE_v1 && obj->type != TYPE_CODE_v0), false);\n\n\tcobj = obj->data;\n\n\tif_true_return (!cobj || !cobj->name, false);\n\tif_true_return (cobj->name->type != TYPE_ASCII && cobj->name->type != TYPE_STRING && cobj->name->type != TYPE_INTERNED, false);\n\tif_true_return (!cobj->name->data, false);\n\tif_true_return (!cobj->consts, false);\n\n\t//add the cobj to objs list\n\tif (!r_list_append (cobjs, cobj)) {\n\t\tgoto fail;\n\t}\n\tsection = R_NEW0 (RBinSection);\n\tsymbol = R_NEW0 (RBinSymbol);\n\tprefix = r_str_newf (\"%s%s%s\", r_str_get (prefix),\n\t\tprefix? \".\": \"\", (const char *)cobj->name->data);\n\tif (!prefix || !section || !symbol) {\n\t\tgoto fail;\n\t}\n\tsection->name = strdup (prefix);\n\tif (!section->name) {\n\t\tgoto fail;\n\t}\n\tsection->paddr = cobj->start_offset;\n\tsection->vaddr = cobj->start_offset;\n\tsection->size = cobj->end_offset - cobj->start_offset;\n\tsection->vsize = cobj->end_offset - cobj->start_offset;\n\tif (!r_list_append (sections, section)) {\n\t\tgoto fail;\n\t}\n\t// start building symbol\n\tsymbol->name = strdup (prefix);\n\t//symbol->bind;\n\tsymbol->type = R_BIN_TYPE_FUNC_STR;\n\tsymbol->size = cobj->end_offset - cobj->start_offset;\n\tsymbol->vaddr = cobj->start_offset;\n\tsymbol->paddr = cobj->start_offset;\n\tsymbol->ordinal = symbols_ordinal++;\n\tif (cobj->consts->type != TYPE_TUPLE && cobj->consts->type != TYPE_SMALL_TUPLE) {\n\t\tgoto fail2;\n\t}\n\tif (!r_list_append (symbols, symbol)) {\n\t\tgoto fail2;\n\t}\n\tr_list_foreach (((RList *)(cobj->consts->data)), i, obj) {\n\t\textract_sections_symbols (obj, sections, symbols, cobjs, prefix);\n\t}\n\tfree (prefix);\n\treturn true;\nfail:\n\tfree (section);\n\tfree (prefix);\n\tfree (symbol);\n\treturn false;\nfail2:\n\tfree (prefix);\n\tfree (symbol);\n\treturn false;\n}\n\nbool get_sections_symbols_from_code_objects(RBuffer *buffer, RList *sections, RList *symbols, RList *cobjs, ut32 magic) {\n\tbool ret;\n\tmagic_int = magic;\n\trefs = r_list_newf (NULL); // (RListFree)free_object);\n\tif (!refs) {\n\t\treturn false;\n\t}\n\tret = extract_sections_symbols (get_object (buffer), sections, symbols, cobjs, NULL);\n\tr_list_free (refs);\n\trefs = NULL;\n\treturn ret;\n}\n"], "fixing_code": ["/* radare - LGPL3 - Copyright 2016-2021 - Matthieu (c0riolis) Tardy - l0stb1t*/\n\n#include <r_io.h>\n#include <r_bin.h>\n#include \"marshal.h\"\n#include \"pyc_magic.h\"\n\n// avoiding using r2 internals asserts\n#define if_true_return(cond,ret) if(cond){return(ret);}\n\n// TODO: kill globals\nstatic ut32 magic_int;\nstatic ut32 symbols_ordinal = 0;\nstatic RList *refs = NULL; // If you don't have a good reason, do not change this. And also checkout !refs in get_code_object()\n\n/* interned_table is used to handle TYPE_INTERNED object */\nextern RList *interned_table;\n\nstatic pyc_object *get_object(RBuffer *buffer);\nstatic pyc_object *copy_object(pyc_object *object);\nstatic void free_object(pyc_object *object);\n\nstatic ut8 get_ut8(RBuffer *buffer, bool *error) {\n\tut8 ret = 0;\n\tint size = r_buf_read (buffer, &ret, sizeof (ret));\n\tif (size < sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut16 get_ut16(RBuffer *buffer, bool *error) {\n\tut16 ret = 0;\n\n\tint size = r_buf_read (buffer, (ut8 *)&ret, sizeof (ret));\n\tif (size != sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut32 get_ut32(RBuffer *buffer, bool *error) {\n\tut32 ret = 0;\n\tint size = r_buf_read (buffer, (ut8 *)&ret, sizeof (ret));\n\tif (size != sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic st32 get_st32(RBuffer *buffer, bool *error) {\n\tst32 ret = 0;\n\tint size = r_buf_read (buffer, (ut8 *)&ret, sizeof (ret));\n\tif (size < sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic st64 get_st64(RBuffer *buffer, bool *error) {\n\tst64 ret = 0;\n\tint size = r_buf_read (buffer, (ut8 *)&ret, sizeof (ret));\n\tif (size < sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic double get_float64(RBuffer *buffer, bool *error) {\n\tdouble ret = 0;\n\tint size = r_buf_read (buffer, (ut8 *)&ret, sizeof (ret));\n\tif (size < sizeof (ret)) {\n\t\t*error = true;\n\t}\n\treturn ret;\n}\n\nstatic ut8 *get_bytes(RBuffer *buffer, ut32 size) {\n\tut8 *ret = R_NEWS0 (ut8, size + 1);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tif (r_buf_read (buffer, ret, size) < size) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_none_object(void) {\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (ret) {\n\t\tret->type = TYPE_NONE;\n\t\tret->data = strdup (\"None\");\n\t\tif (!ret->data) {\n\t\t\tR_FREE (ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_false_object(void) {\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_FALSE;\n\tret->data = strdup (\"False\");\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_true_object(void) {\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_TRUE;\n\tret->data = strdup (\"True\");\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_int_object(RBuffer *buffer) {\n\tbool error = false;\n\n\tst32 i = get_st32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_INT;\n\tret->data = r_str_newf (\"%d\", i);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_int64_object(RBuffer *buffer) {\n\tbool error = false;\n\tst64 i = get_st64 (buffer, &error);\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (ret) {\n\t\tret->type = TYPE_INT64;\n\t\tret->data = r_str_newf (\"%\"PFMT64d, (st64)i);\n\t\tif (!ret->data) {\n\t\t\tR_FREE (ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* long is used when the number is > MAX_INT64 */\nstatic pyc_object *get_long_object(RBuffer *buffer) {\n\tbool error = false;\n\tbool neg = false;\n\tut32 tmp = 0;\n\tsize_t size;\n\tsize_t i, j = 0, left = 0;\n\tut16 n;\n\tchar *hexstr;\n\tchar digist2hex[] = \"0123456789abcdef\";\n\n\tst32 ndigits = get_st32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_LONG;\n\tif (ndigits < 0) {\n\t\tndigits = -ndigits;\n\t\tneg = true;\n\t}\n\tif (ndigits == 0) {\n\t\tret->data = strdup (\"0x0\");\n\t} else {\n\t\tif (ndigits > 10) {\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize = ndigits * 15;\n\t\tif (size < 0) {\n\t\t\treturn NULL;\n\t\t}\n\t\tsize = (size - 1) / 4 + 1;\n\t\tif (size < 1) {\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tsize += 3 + (neg? 1: 0);\n\t\tj = size - 1;\n\t\thexstr = calloc (size, sizeof (char));\n\t\tif (!hexstr) {\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tfor (i = 0; i < ndigits; i++) {\n\t\t\tn = get_ut16 (buffer, &error);\n\t\t\ttmp |= n << left;\n\t\t\tleft += 15;\n\n\t\t\twhile (left >= 4 && j >= 0) {\n\t\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t\t\ttmp >>= 4;\n\t\t\t\tleft -= 4;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp) {\n\t\t\thexstr[--j] = digist2hex[tmp & 0xf];\n\t\t}\n\n\t\tif (j > 0) {\n\t\t\thexstr[--j] = 'x';\n\t\t}\n\t\tif (j > 0) {\n\t\t\thexstr[--j] = '0';\n\t\t}\n\t\tif (neg && j > 0) {\n\t\t\thexstr[--j] = '-';\n\t\t}\n\n\t\tret->data = &hexstr[j];\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_stringref_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_st32 (buffer, &error);\n\tif (n >= r_list_length (interned_table)) {\n\t\teprintf (\"bad marshal data (string ref out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_STRINGREF;\n\tret->data = r_list_get_n (interned_table, n);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_float_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 size = 0;\n\n\tut8 n = get_ut8 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tut8 *s = malloc (n + 1);\n\tif (!s) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tsize = r_buf_read (buffer, s, n);\n\tif (size != n) {\n\t\tR_FREE (s);\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\ts[n] = '\\0';\n\tret->type = TYPE_FLOAT;\n\tret->data = s;\n\treturn ret;\n}\n\nstatic pyc_object *get_binary_float_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tdouble f;\n\n\tf = get_float64 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_FLOAT;\n\tret->data = r_str_newf (\"%.15g\", f);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_complex_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 size = 0;\n\tst32 n1 = 0;\n\tst32 n2 = 0;\n\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tif ((magic_int & 0xffff) <= 62061) {\n\t\tn1 = get_ut8 (buffer, &error);\n\t} else {\n\t\tn1 = get_st32 (buffer, &error);\n\t}\n\tif (error || n1 < 1) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tut8 *s1 = malloc (n1 + 1);\n\tif (!s1) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tsize = r_buf_read (buffer, s1, n1);\n\tif (size != n1) {\n\t\tR_FREE (s1);\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\ts1[n1] = '\\0';\n\n\tif ((magic_int & 0xffff) <= 62061) {\n\t\tn2 = get_ut8 (buffer, &error);\n\t} else\n\t\tn2 = get_st32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tut8 *s2 = malloc (n2 + 1);\n\tif (!s2) {\n\t\treturn NULL;\n\t}\n\t/* object contain string representation of the number */\n\tsize = r_buf_read (buffer, s2, n2);\n\tif (size != n2) {\n\t\tR_FREE (s1);\n\t\tR_FREE (s2);\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\ts2[n2] = '\\0';\n\n\tret->type = TYPE_COMPLEX;\n\tret->data = r_str_newf (\"%s+%sj\", s1, s2);\n\tR_FREE (s1);\n\tR_FREE (s2);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_binary_complex_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tdouble a, b;\n\n\t//a + bj\n\ta = get_float64 (buffer, &error);\n\tb = get_float64 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_BINARY_COMPLEX;\n\tret->data = r_str_newf (\"%.15g+%.15gj\", a, b);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_string_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (string size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_STRING;\n\tret->data = get_bytes (buffer, n);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_unicode_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (unicode size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tret->type = TYPE_UNICODE;\n\tret->data = get_bytes (buffer, n);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_interned_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (string size out of range)\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_INTERNED;\n\tret->data = get_bytes (buffer, n);\n\t/* add data pointer to interned table */\n\tr_list_append (interned_table, ret->data);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_array_object_generic(RBuffer *buffer, ut32 size) {\n\tpyc_object *tmp = NULL;\n\tpyc_object *ret = NULL;\n\tut32 i = 0;\n\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tfree (ret);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\ttmp = get_object (buffer);\n\t\tif (!tmp) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (!r_list_append (ret->data, tmp)) {\n\t\t\tfree_object (tmp);\n\t\t\tr_list_free (ret->data);\n\t\t\tfree (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ret;\n}\n\n/* small TYPE_SMALL_TUPLE doesn't exist in python2 */\n/* */\nstatic pyc_object *get_small_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut8 n = 0;\n\n\tn = get_ut8 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_SMALL_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_tuple_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (tuple size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_TUPLE;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_list_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = 0;\n\n\tn = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (list size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (ret) {\n\t\tret->type = TYPE_LIST;\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nstatic pyc_object *get_dict_object(RBuffer *buffer) {\n\tpyc_object *key = NULL,\n\t\t   *val = NULL;\n\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->data = r_list_newf ((RListFree)free_object);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\tfor (;;) {\n\t\tkey = get_object (buffer);\n\t\tif (!key) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!r_list_append (ret->data, key)) {\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\tfree_object (key);\n\t\t\treturn NULL;\n\t\t}\n\t\tval = get_object (buffer);\n\t\tif (!val) {\n\t\t\tbreak;\n\t\t}\n\t\tif (!r_list_append (ret->data, val)) {\n\t\t\tfree_object (val);\n\t\t\tr_list_free (ret->data);\n\t\t\tR_FREE (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\tret->type = TYPE_DICT;\n\treturn ret;\n}\n\nstatic pyc_object *get_set_object(RBuffer *buffer) {\n\tpyc_object *ret = NULL;\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (n > ST32_MAX) {\n\t\teprintf (\"bad marshal data (set size out of range)\\n\");\n\t\treturn NULL;\n\t}\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tret = get_array_object_generic (buffer, n);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_SET;\n\treturn ret;\n}\n\nstatic pyc_object *get_ascii_object_generic(RBuffer *buffer, ut32 size, bool interned) {\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_ASCII;\n\tret->data = get_bytes (buffer, size);\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}\n\nstatic pyc_object *get_ascii_object(RBuffer *buffer) {\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic (buffer, n, true);\n}\n\nstatic pyc_object *get_ascii_interned_object(RBuffer *buffer) {\n\tbool error = false;\n\tut32 n = get_ut32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic (buffer, n, true);\n}\n\nstatic pyc_object *get_short_ascii_object(RBuffer *buffer) {\n\tbool error = false;\n\tut8 n = get_ut8 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\treturn get_ascii_object_generic (buffer, n, false);\n}\n\nstatic pyc_object *get_short_ascii_interned_object(RBuffer *buffer) {\n\tbool error = false;\n\tut8 n = get_ut8 (buffer, &error);\n\treturn error? NULL: get_ascii_object_generic (buffer, n, true);\n}\n\nstatic pyc_object *get_ref_object(RBuffer *buffer) {\n\tbool error = false;\n\tut32 index = get_ut32 (buffer, &error);\n\tif (error) {\n\t\treturn NULL;\n\t}\n\tif (index >= r_list_length (refs)) {\n\t\treturn NULL;\n\t}\n\tpyc_object *obj = r_list_get_n (refs, index);\n\treturn obj? copy_object (obj): NULL;\n}\n\nstatic void free_object(pyc_object *object) {\n\tif (!object) {\n\t\treturn;\n\t}\n\tif ((int)object->type == 0) {\n\t\treturn;\n\t}\n\tswitch (object->type) {\n\tcase TYPE_SMALL_TUPLE:\n\tcase TYPE_TUPLE:\n\t\tr_list_free (object->data);\n\t\tbreak;\n\tcase TYPE_STRING:\n\tcase TYPE_TRUE:\n\tcase TYPE_FALSE:\n\tcase TYPE_INT:\n\tcase TYPE_NONE:\n\tcase TYPE_NULL:\n\tcase TYPE_ASCII_INTERNED:\n\tcase TYPE_SHORT_ASCII:\n\tcase TYPE_ASCII:\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tfree (object->data);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\tcase TYPE_CODE_v1: {\n\t\tpyc_code_object *cobj = object->data;\n\t\tfree_object (cobj->code);\n\t\tfree_object (cobj->consts);\n\t\tfree_object (cobj->names);\n\t\tfree_object (cobj->varnames);\n\t\tfree_object (cobj->freevars);\n\t\tfree_object (cobj->cellvars);\n\t\tfree_object (cobj->filename);\n\t\tfree_object (cobj->name);\n\t\tfree_object (cobj->lnotab);\n\t\tfree (object->data);\n\t\tbreak;\n\t}\n\tcase TYPE_REF:\n\t\tfree_object (object->data);\n\t\tbreak;\n\tcase TYPE_SET:\n\tcase TYPE_FROZENSET:\n\tcase TYPE_ELLIPSIS:\n\tcase TYPE_STOPITER:\n\tcase TYPE_BINARY_COMPLEX:\n\tcase TYPE_BINARY_FLOAT:\n\tcase TYPE_COMPLEX:\n\tcase TYPE_STRINGREF:\n\tcase TYPE_DICT:\n\tcase TYPE_FLOAT:\n\tcase TYPE_INT64:\n\tcase TYPE_INTERNED:\n\tcase TYPE_LIST:\n\tcase TYPE_LONG:\n\tcase TYPE_UNICODE:\n\tcase TYPE_UNKNOWN:\n\t\teprintf (\"Free not implemented for type %x\\n\", object->type);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Undefined type in free_object (%x)\\n\", object->type);\n\t\tbreak;\n\t}\n\tfree (object);\n}\n\nstatic pyc_object *copy_object(pyc_object *object) {\n\tpyc_object *copy = R_NEW0 (pyc_object);\n\tif (!copy || !object) {\n\t\tfree (copy);\n\t\treturn NULL;\n\t}\n\tcopy->type = object->type;\n\tif ((int)object->type == 0) {\n\t\t// do nothing\n\t} else\n\tswitch (object->type) {\n\tcase TYPE_NULL:\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\tcase TYPE_SMALL_TUPLE:\n\t\tcopy->data = r_list_clone (object->data);\n\t\tbreak;\n\tcase TYPE_INT:\n\tcase TYPE_INT64:\n\tcase TYPE_NONE:\n\tcase TYPE_TRUE:\n\tcase TYPE_FALSE:\n\tcase TYPE_STRING:\n\tcase TYPE_ASCII:\n\tcase TYPE_SHORT_ASCII:\n\tcase TYPE_ASCII_INTERNED:\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tcopy->data = strdup (object->data);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\tcase TYPE_CODE_v1: {\n\t\tpyc_code_object *src = object->data;\n\t\tpyc_code_object *dst = R_NEW0 (pyc_code_object);\n\t\tif (!dst) {\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy (dst, src, sizeof (*dst));\n\t\tdst->code = copy_object (src->code);\n\t\tdst->consts = copy_object (src->consts);\n\t\tdst->names = copy_object (src->names);\n\t\tdst->varnames = copy_object (src->varnames);\n\t\tdst->freevars = copy_object (src->freevars);\n\t\tdst->cellvars = copy_object (src->cellvars);\n\t\tdst->filename = copy_object (src->filename);\n\t\tdst->name = copy_object (src->name);\n\t\tdst->lnotab = copy_object (src->lnotab);\n\t\tcopy->data = dst;\n\t\tbreak;\n\t}\n\tcase TYPE_REF:\n\t\tcopy->data = copy_object (object->data);\n\t\tbreak;\n\tcase TYPE_ELLIPSIS:\n\tcase TYPE_STOPITER:\n\tcase TYPE_BINARY_COMPLEX:\n\tcase TYPE_BINARY_FLOAT:\n\tcase TYPE_COMPLEX:\n\tcase TYPE_STRINGREF:\n\tcase TYPE_DICT:\n\tcase TYPE_FLOAT:\n\tcase TYPE_FROZENSET:\n\tcase TYPE_INTERNED:\n\tcase TYPE_LIST:\n\tcase TYPE_LONG:\n\tcase TYPE_SET:\n\tcase TYPE_UNICODE:\n\tcase TYPE_UNKNOWN:\n\t\teprintf (\"Copy not implemented for type %x\\n\", object->type);\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Undefined type in copy_object (%x)\\n\", object->type);\n\t\tbreak;\n\t}\n\tif (!copy->data) {\n\t\tR_FREE (copy);\n\t}\n\treturn copy;\n}\n\nstatic pyc_object *get_code_object(RBuffer *buffer) {\n\tbool error = false;\n\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tpyc_code_object *cobj = R_NEW0 (pyc_code_object);\n\tif (!ret || !cobj) {\n\t\tfree (ret);\n\t\tfree (cobj);\n\t\treturn NULL;\n\t}\n\n\t//ret->type = TYPE_CODE_v1;\n\t// support start from v1.0\n\tret->data = cobj;\n\n\tbool v10_to_12 = magic_int_within (magic_int, 39170, 16679, &error); // 1.0.1 - 1.2\n\tbool v13_to_22 = magic_int_within (magic_int, 11913, 60718, &error); // 1.3b1 - 2.2a1\n\tbool v11_to_14 = magic_int_within (magic_int, 39170, 20117, &error); // 1.0.1 - 1.4\n\tbool v15_to_22 = magic_int_within (magic_int, 20121, 60718, &error); // 1.5a1 - 2.2a1\n\tbool v13_to_20 = magic_int_within (magic_int, 11913, 50824, &error); // 1.3b1 - 2.0b1\n\t//bool v21_to_27 = (!v13_to_20) && magic_int_within (magic_int, 60124, 62212, &error);\n\tbool has_posonlyargcount = magic_int_within (magic_int, 3410, 3424, &error); // v3.8.0a4 - latest\n\tif (error) {\n\t\tfree (ret);\n\t\tfree (cobj);\n\t\treturn NULL;\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->argcount = get_ut16 (buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->argcount = 0;\n\t} else {\n\t\tcobj->argcount = get_ut32 (buffer, &error);\n\t}\n\n\tif (has_posonlyargcount) {\n\t\tcobj->posonlyargcount = get_ut32 (buffer, &error); // Included in argcount\n\t} else {\n\t\tcobj->posonlyargcount = 0; // None\n\t}\n\n\tif (((3020 < (magic_int & 0xffff)) && ((magic_int & 0xffff) < 20121)) && (!v11_to_14)) {\n\t\tcobj->kwonlyargcount = get_ut32 (buffer, &error); // Not included in argcount\n\t} else {\n\t\tcobj->kwonlyargcount = 0;\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->nlocals = get_ut16 (buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->nlocals = 0;\n\t} else {\n\t\tcobj->nlocals = get_ut32 (buffer, &error);\n\t}\n\n\tif (v15_to_22) {\n\t\tcobj->stacksize = get_ut16 (buffer, &error);\n\t} else if (v11_to_14 || v10_to_12) {\n\t\tcobj->stacksize = 0;\n\t} else {\n\t\tcobj->stacksize = get_ut32 (buffer, &error);\n\t}\n\n\tif (v13_to_22) {\n\t\tcobj->flags = get_ut16 (buffer, &error);\n\t} else if (v10_to_12) {\n\t\tcobj->flags = 0;\n\t} else {\n\t\tcobj->flags = get_ut32 (buffer, &error);\n\t}\n\n\t//to help disassemble the code\n\tcobj->start_offset = r_buf_tell (buffer) + 5; // 1 from get_object() and 4 from get_string_object()\n\tif (!refs) {\n\t\treturn ret; //return for entried part to get the root object of this file\n\t}\n\tcobj->code = get_object (buffer);\n\tcobj->end_offset = r_buf_tell (buffer);\n\n\tcobj->consts = get_object (buffer);\n\tcobj->names = get_object (buffer);\n\n\tif (v10_to_12) {\n\t\tcobj->varnames = NULL;\n\t} else {\n\t\tcobj->varnames = get_object (buffer);\n\t}\n\n\tif (!(v10_to_12 || v13_to_20)) {\n\t\tcobj->freevars = get_object (buffer);\n\t\tcobj->cellvars = get_object (buffer);\n\t} else {\n\t\tcobj->freevars = NULL;\n\t\tcobj->cellvars = NULL;\n\t}\n\n\tcobj->filename = get_object (buffer);\n\tcobj->name = get_object (buffer);\n\n\tif (v15_to_22) {\n\t\tcobj->firstlineno = get_ut16 (buffer, &error);\n\t} else if (v11_to_14) {\n\t\tcobj->firstlineno = 0;\n\t} else {\n\t\tcobj->firstlineno = get_ut32 (buffer, &error);\n\t}\n\n\tif (v11_to_14) {\n\t\tcobj->lnotab = NULL;\n\t} else {\n\t\tcobj->lnotab = get_object (buffer);\n\t}\n\n\tif (error) {\n\t\tfree_object (cobj->code);\n\t\tfree_object (cobj->consts);\n\t\tfree_object (cobj->names);\n\t\tfree_object (cobj->varnames);\n\t\tfree_object (cobj->freevars);\n\t\tfree_object (cobj->cellvars);\n\t\tfree_object (cobj->filename);\n\t\tfree_object (cobj->name);\n\t\tfree_object (cobj->lnotab);\n\t\tfree (cobj);\n\t\tR_FREE (ret);\n\t\treturn NULL;\n\t}\n\treturn ret;\n}\n\nut64 get_code_object_addr(RBuffer *buffer, ut32 magic) {\n\tmagic_int = magic;\n\tpyc_object *co = get_code_object (buffer);\n\tut64 result = 0;\n\tif (!co) {\n\t\treturn 0;\n\t}\n\n\tpyc_code_object *cobj = co->data;\n\tresult = cobj->start_offset;\n\tfree_object (co);\n\n\treturn result;\n}\n\nstatic pyc_object *get_object(RBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\tut8 code = get_ut8 (buffer, &error);\n\tbool flag = (code & FLAG_REF);\n\tRListIter *ref_idx = NULL;\n\tut8 type = (code & ~FLAG_REF);\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\n\tif (flag) {\n\t\tpyc_object *noneret = get_none_object ();\n\t\tif (noneret) {\n\t\t\tref_idx = r_list_append (refs, noneret);\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase TYPE_NULL:\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase TYPE_TRUE:\n\t\treturn get_true_object ();\n\tcase TYPE_FALSE:\n\t\tfree_object (ret);\n\t\treturn get_false_object ();\n\tcase TYPE_NONE:\n\t\tfree_object (ret);\n\t\treturn get_none_object ();\n\tcase TYPE_REF:\n\t\tfree_object (ret);\n\t\treturn get_ref_object (buffer);\n\tcase TYPE_SMALL_TUPLE:\n\t\tret = get_small_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\t\tret = get_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRING:\n\t\tret = get_string_object (buffer);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v0;\n\t\t}\n\t\tbreak;\n\tcase TYPE_CODE_v1:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v1;\n\t\t}\n\t\tbreak;\n\tcase TYPE_INT:\n\t\tret = get_int_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII_INTERNED:\n\t\tret = get_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII:\n\t\tret = get_short_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII:\n\t\tret = get_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tret = get_short_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_INT64:\n\t\tret = get_int64_object (buffer);\n\t\tbreak;\n\tcase TYPE_INTERNED:\n\t\tret = get_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRINGREF:\n\t\tret = get_stringref_object (buffer);\n\t\tbreak;\n\tcase TYPE_FLOAT:\n\t\tret = get_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_BINARY_FLOAT:\n\t\tret = get_binary_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_COMPLEX:\n\t\tret = get_complex_object (buffer); // behaviour depends on Python version\n\t\tbreak;\n\tcase TYPE_BINARY_COMPLEX:\n\t\tret = get_binary_complex_object (buffer);\n\t\tbreak;\n\tcase TYPE_LIST:\n\t\tret = get_list_object (buffer);\n\t\tbreak;\n\tcase TYPE_LONG:\n\t\tret = get_long_object (buffer);\n\t\tbreak;\n\tcase TYPE_UNICODE:\n\t\tret = get_unicode_object (buffer);\n\t\tbreak;\n\tcase TYPE_DICT:\n\t\tret = get_dict_object (buffer);\n\t\tbreak;\n\tcase TYPE_FROZENSET:\n\tcase TYPE_SET:\n\t\tret = get_set_object (buffer);\n\t\tbreak;\n\tcase TYPE_STOPITER:\n\tcase TYPE_ELLIPSIS:\n\t\tret = R_NEW0 (pyc_object);\n\t\tbreak;\n\tcase TYPE_UNKNOWN:\n\t\teprintf (\"Get not implemented for type 0x%x\\n\", type);\n\t\t// r_list_pop (refs);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase 0:\n\t\t// nop\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Undefined type in get_object (0x%x)\\n\", type);\n\t\t// r_list_pop (refs);\n\t\treturn NULL;\n\t}\n\n\tif (ret && flag && ref_idx) {\n\t\tif (ref_idx->data != ret) {\n\t\t\tfree_object (ref_idx->data);\n\t\t}\n\t\tref_idx->data = copy_object (ret);\n\t}\n\tif (ret) {\n\t\treturn ret;\n\t}\n\tret = get_none_object ();\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tr_list_append (refs, ret);\n\treturn ret;\n}\n\nstatic bool extract_sections_symbols(pyc_object *obj, RList *sections, RList *symbols, RList *cobjs, char *prefix) {\n\tpyc_code_object *cobj = NULL;\n\tRBinSection *section = NULL;\n\tRBinSymbol *symbol = NULL;\n\tRListIter *i = NULL;\n\n\t//each code object is a section\n\tif_true_return (!obj || (obj->type != TYPE_CODE_v1 && obj->type != TYPE_CODE_v0), false);\n\n\tcobj = obj->data;\n\n\tif_true_return (!cobj || !cobj->name, false);\n\tif_true_return (cobj->name->type != TYPE_ASCII && cobj->name->type != TYPE_STRING && cobj->name->type != TYPE_INTERNED, false);\n\tif_true_return (!cobj->name->data, false);\n\tif_true_return (!cobj->consts, false);\n\n\t//add the cobj to objs list\n\tif (!r_list_append (cobjs, cobj)) {\n\t\tgoto fail;\n\t}\n\tsection = R_NEW0 (RBinSection);\n\tsymbol = R_NEW0 (RBinSymbol);\n\tprefix = r_str_newf (\"%s%s%s\", r_str_get (prefix),\n\t\tprefix? \".\": \"\", (const char *)cobj->name->data);\n\tif (!prefix || !section || !symbol) {\n\t\tgoto fail;\n\t}\n\tsection->name = strdup (prefix);\n\tif (!section->name) {\n\t\tgoto fail;\n\t}\n\tsection->paddr = cobj->start_offset;\n\tsection->vaddr = cobj->start_offset;\n\tsection->size = cobj->end_offset - cobj->start_offset;\n\tsection->vsize = cobj->end_offset - cobj->start_offset;\n\tif (!r_list_append (sections, section)) {\n\t\tgoto fail;\n\t}\n\t// start building symbol\n\tsymbol->name = strdup (prefix);\n\t//symbol->bind;\n\tsymbol->type = R_BIN_TYPE_FUNC_STR;\n\tsymbol->size = cobj->end_offset - cobj->start_offset;\n\tsymbol->vaddr = cobj->start_offset;\n\tsymbol->paddr = cobj->start_offset;\n\tsymbol->ordinal = symbols_ordinal++;\n\tif (cobj->consts->type != TYPE_TUPLE && cobj->consts->type != TYPE_SMALL_TUPLE) {\n\t\tgoto fail2;\n\t}\n\tif (!r_list_append (symbols, symbol)) {\n\t\tgoto fail2;\n\t}\n\tr_list_foreach (((RList *)(cobj->consts->data)), i, obj) {\n\t\textract_sections_symbols (obj, sections, symbols, cobjs, prefix);\n\t}\n\tfree (prefix);\n\treturn true;\nfail:\n\tfree (section);\n\tfree (prefix);\n\tfree (symbol);\n\treturn false;\nfail2:\n\tfree (prefix);\n\tfree (symbol);\n\treturn false;\n}\n\nbool get_sections_symbols_from_code_objects(RBuffer *buffer, RList *sections, RList *symbols, RList *cobjs, ut32 magic) {\n\tbool ret;\n\tmagic_int = magic;\n\trefs = r_list_newf (NULL); // (RListFree)free_object);\n\tif (!refs) {\n\t\treturn false;\n\t}\n\tret = extract_sections_symbols (get_object (buffer), sections, symbols, cobjs, NULL);\n\tr_list_free (refs);\n\trefs = NULL;\n\treturn ret;\n}\n"], "filenames": ["libr/bin/format/pyc/marshal.c"], "buggy_code_start_loc": [1101], "buggy_code_end_loc": [1102], "fixing_code_start_loc": [1101], "fixing_code_end_loc": [1102], "type": "CWE-416", "message": "Use After Free in NPM radare2.js prior to 5.6.2.", "other": {"cve": {"id": "CVE-2022-0520", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-08T21:15:19.863", "lastModified": "2022-04-08T13:39:13.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use After Free in NPM radare2.js prior to 5.6.2."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en NPM radare2.js versiones anteriores a 5.6.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.2", "matchCriteriaId": "B0653877-95C4-4D74-A0EA-9C5EFA579627"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/8525ad0b9fd596f4b251bb3d7b114e6dc7ce1ee8", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ce13c371-e5ef-4993-97f3-3d33dcd943a6", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BZTIMAS53YT66FUS4QHQAFRJOBMUFG6D/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/E6YBRQ3UCFWJVSOYIKPVUDASZ544TFND/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/8525ad0b9fd596f4b251bb3d7b114e6dc7ce1ee8"}}