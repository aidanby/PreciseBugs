{"buggy_code": ["/*\n Formatting library for C++\n\n Copyright (c) 2012 - 2016, Victor Zverovich\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// transition helper\n#ifdef FMT_FORMAT_PROVIDE_PRINTF\n#include \"printf.h\"\n#endif\n\n#ifndef FMT_FORMAT_H_\n#define FMT_FORMAT_H_\n\n#define FMT_INCLUDE\n#include <cassert>\n#include <clocale>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <limits>\n#include <memory>\n#include <stdexcept>\n#include <string>\n#include <vector>\n#include <utility>  // for std::pair\n#undef FMT_INCLUDE\n\n// The fmt library version in the form major * 10000 + minor * 100 + patch.\n#define FMT_VERSION 40101\n\n#if defined(__has_include)\n# define FMT_HAS_INCLUDE(x) __has_include(x)\n#else\n# define FMT_HAS_INCLUDE(x) 0\n#endif\n\n#if (FMT_HAS_INCLUDE(<string_view>) && __cplusplus > 201402L) || \\\n    (defined(_MSVC_LANG) && _MSVC_LANG > 201402L && _MSC_VER >= 1910)\n# include <string_view>\n# define FMT_HAS_STRING_VIEW 1\n# define FMT_HAS_EXPERIMENTAL_STRING_VIEW 0\n#else\n# define FMT_HAS_STRING_VIEW 0\n# if (FMT_HAS_INCLUDE(<experimental/string_view>) && __cplusplus >= 201402L)\n#  include <experimental/string_view>\n#  define FMT_HAS_EXPERIMENTAL_STRING_VIEW 1\n# else\n#  define FMT_HAS_EXPERIMENTAL_STRING_VIEW 0\n# endif\n#endif\n\n#if defined _SECURE_SCL && _SECURE_SCL\n# define FMT_SECURE_SCL _SECURE_SCL\n#else\n# define FMT_SECURE_SCL 0\n#endif\n\n#if FMT_SECURE_SCL\n# include <iterator>\n#endif\n\n#ifdef _MSC_VER\n# define FMT_MSC_VER _MSC_VER\n#else\n# define FMT_MSC_VER 0\n#endif\n\n#if FMT_MSC_VER && FMT_MSC_VER <= 1500\ntypedef unsigned __int32 uint32_t;\ntypedef unsigned __int64 uint64_t;\ntypedef __int64          intmax_t;\n#else\n#include <stdint.h>\n#endif\n\n#if !defined(FMT_HEADER_ONLY) && defined(_WIN32)\n# ifdef FMT_EXPORT\n#  define FMT_API __declspec(dllexport)\n# elif defined(FMT_SHARED)\n#  define FMT_API __declspec(dllimport)\n# endif\n#endif\n#ifndef FMT_API\n# define FMT_API\n#endif\n\n#ifdef __GNUC__\n# define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)\n# define FMT_GCC_EXTENSION __extension__\n# if FMT_GCC_VERSION >= 406\n#  pragma GCC diagnostic push\n// Disable the warning about \"long long\" which is sometimes reported even\n// when using __extension__.\n#  pragma GCC diagnostic ignored \"-Wlong-long\"\n// Disable the warning about declaration shadowing because it affects too\n// many valid cases.\n#  pragma GCC diagnostic ignored \"-Wshadow\"\n// Disable the warning about implicit conversions that may change the sign of\n// an integer; silencing it otherwise would require many explicit casts.\n#  pragma GCC diagnostic ignored \"-Wsign-conversion\"\n# endif\n# if __cplusplus >= 201103L || defined __GXX_EXPERIMENTAL_CXX0X__\n#  define FMT_HAS_GXX_CXX11 1\n# endif\n#else\n# define FMT_GCC_VERSION 0\n# define FMT_GCC_EXTENSION\n# define FMT_HAS_GXX_CXX11 0\n#endif\n\n#if defined(__INTEL_COMPILER)\n# define FMT_ICC_VERSION __INTEL_COMPILER\n#elif defined(__ICL)\n# define FMT_ICC_VERSION __ICL\n#endif\n\n#if defined(__clang__) && !defined(FMT_ICC_VERSION)\n# define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)\n# pragma clang diagnostic push\n# pragma clang diagnostic ignored \"-Wdocumentation-unknown-command\"\n# pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\n#ifdef __GNUC_LIBSTD__\n# define FMT_GNUC_LIBSTD_VERSION (__GNUC_LIBSTD__ * 100 + __GNUC_LIBSTD_MINOR__)\n#endif\n\n#ifdef __has_feature\n# define FMT_HAS_FEATURE(x) __has_feature(x)\n#else\n# define FMT_HAS_FEATURE(x) 0\n#endif\n\n#ifdef __has_builtin\n# define FMT_HAS_BUILTIN(x) __has_builtin(x)\n#else\n# define FMT_HAS_BUILTIN(x) 0\n#endif\n\n#ifdef __has_cpp_attribute\n# define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)\n#else\n# define FMT_HAS_CPP_ATTRIBUTE(x) 0\n#endif\n\n#if FMT_HAS_CPP_ATTRIBUTE(maybe_unused)\n# define FMT_HAS_CXX17_ATTRIBUTE_MAYBE_UNUSED\n// VC++ 1910 support /std: option and that will set _MSVC_LANG macro\n// Clang with Microsoft CodeGen doesn't define _MSVC_LANG macro\n#elif defined(_MSVC_LANG) && _MSVC_LANG > 201402 && _MSC_VER >= 1910\n# define FMT_HAS_CXX17_ATTRIBUTE_MAYBE_UNUSED\n#endif\n\n#ifdef FMT_HAS_CXX17_ATTRIBUTE_MAYBE_UNUSED\n# define FMT_MAYBE_UNUSED [[maybe_unused]]\n// g++/clang++ also support [[gnu::unused]]. However, we don't use it.\n#elif defined(__GNUC__)\n# define FMT_MAYBE_UNUSED __attribute__((unused))\n#else\n# define FMT_MAYBE_UNUSED\n#endif\n\n// Use the compiler's attribute noreturn\n#if defined(__MINGW32__) || defined(__MINGW64__)\n# define FMT_NORETURN __attribute__((noreturn))\n#elif FMT_HAS_CPP_ATTRIBUTE(noreturn) && __cplusplus >= 201103L\n# define FMT_NORETURN [[noreturn]]\n#else\n# define FMT_NORETURN\n#endif\n\n#ifndef FMT_USE_VARIADIC_TEMPLATES\n// Variadic templates are available in GCC since version 4.4\n// (http://gcc.gnu.org/projects/cxx0x.html) and in Visual C++\n// since version 2013.\n# define FMT_USE_VARIADIC_TEMPLATES \\\n   (FMT_HAS_FEATURE(cxx_variadic_templates) || \\\n       (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800)\n#endif\n\n#ifndef FMT_USE_RVALUE_REFERENCES\n// Don't use rvalue references when compiling with clang and an old libstdc++\n// as the latter doesn't provide std::move.\n# if defined(FMT_GNUC_LIBSTD_VERSION) && FMT_GNUC_LIBSTD_VERSION <= 402\n#  define FMT_USE_RVALUE_REFERENCES 0\n# else\n#  define FMT_USE_RVALUE_REFERENCES \\\n    (FMT_HAS_FEATURE(cxx_rvalue_references) || \\\n        (FMT_GCC_VERSION >= 403 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1600)\n# endif\n#endif\n\n#if __cplusplus >= 201103L || FMT_MSC_VER >= 1700\n# define FMT_USE_ALLOCATOR_TRAITS 1\n#else\n# define FMT_USE_ALLOCATOR_TRAITS 0\n#endif\n\n// Check if exceptions are disabled.\n#if defined(__GNUC__) && !defined(__EXCEPTIONS)\n# define FMT_EXCEPTIONS 0\n#endif\n#if FMT_MSC_VER && !_HAS_EXCEPTIONS\n# define FMT_EXCEPTIONS 0\n#endif\n#ifndef FMT_EXCEPTIONS\n# define FMT_EXCEPTIONS 1\n#endif\n\n#ifndef FMT_THROW\n# if FMT_EXCEPTIONS\n#  define FMT_THROW(x) throw x\n# else\n#  define FMT_THROW(x) assert(false)\n# endif\n#endif\n\n// Define FMT_USE_NOEXCEPT to make fmt use noexcept (C++11 feature).\n#ifndef FMT_USE_NOEXCEPT\n# define FMT_USE_NOEXCEPT 0\n#endif\n\n#if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \\\n    (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \\\n    FMT_MSC_VER >= 1900\n# define FMT_DETECTED_NOEXCEPT noexcept\n#else\n# define FMT_DETECTED_NOEXCEPT throw()\n#endif\n\n#ifndef FMT_NOEXCEPT\n# if FMT_EXCEPTIONS\n#  define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT\n# else\n#  define FMT_NOEXCEPT\n# endif\n#endif\n\n// This is needed because GCC still uses throw() in its headers when exceptions\n// are disabled.\n#if FMT_GCC_VERSION\n# define FMT_DTOR_NOEXCEPT FMT_DETECTED_NOEXCEPT\n#else\n# define FMT_DTOR_NOEXCEPT FMT_NOEXCEPT\n#endif\n\n#ifndef FMT_OVERRIDE\n# if (defined(FMT_USE_OVERRIDE) && FMT_USE_OVERRIDE) || FMT_HAS_FEATURE(cxx_override) || \\\n   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \\\n   FMT_MSC_VER >= 1900\n#  define FMT_OVERRIDE override\n# else\n#  define FMT_OVERRIDE\n# endif\n#endif\n\n#ifndef FMT_NULL\n# if FMT_HAS_FEATURE(cxx_nullptr) || \\\n   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \\\n   FMT_MSC_VER >= 1600\n#  define FMT_NULL nullptr\n# else\n#  define FMT_NULL NULL\n# endif\n#endif\n\n// A macro to disallow the copy constructor and operator= functions\n// This should be used in the private: declarations for a class\n#ifndef FMT_USE_DELETED_FUNCTIONS\n# define FMT_USE_DELETED_FUNCTIONS 0\n#endif\n\n#if FMT_USE_DELETED_FUNCTIONS || FMT_HAS_FEATURE(cxx_deleted_functions) || \\\n  (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800\n# define FMT_DELETED_OR_UNDEFINED  = delete\n# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \\\n    TypeName(const TypeName&) = delete; \\\n    TypeName& operator=(const TypeName&) = delete\n#else\n# define FMT_DELETED_OR_UNDEFINED\n# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \\\n    TypeName(const TypeName&); \\\n    TypeName& operator=(const TypeName&)\n#endif\n\n#ifndef FMT_USE_DEFAULTED_FUNCTIONS\n# define FMT_USE_DEFAULTED_FUNCTIONS 0\n#endif\n\n#ifndef FMT_DEFAULTED_COPY_CTOR\n# if FMT_USE_DEFAULTED_FUNCTIONS || FMT_HAS_FEATURE(cxx_defaulted_functions) || \\\n   (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800\n#  define FMT_DEFAULTED_COPY_CTOR(TypeName) \\\n    TypeName(const TypeName&) = default;\n# else\n#  define FMT_DEFAULTED_COPY_CTOR(TypeName)\n# endif\n#endif\n\n#ifndef FMT_USE_USER_DEFINED_LITERALS\n// All compilers which support UDLs also support variadic templates. This\n// makes the fmt::literals implementation easier. However, an explicit check\n// for variadic templates is added here just in case.\n// For Intel's compiler both it and the system gcc/msc must support UDLs.\n# if FMT_USE_VARIADIC_TEMPLATES && FMT_USE_RVALUE_REFERENCES && \\\n   (FMT_HAS_FEATURE(cxx_user_literals) || \\\n     (FMT_GCC_VERSION >= 407 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1900) && \\\n   (!defined(FMT_ICC_VERSION) || FMT_ICC_VERSION >= 1500)\n#  define FMT_USE_USER_DEFINED_LITERALS 1\n# else\n#  define FMT_USE_USER_DEFINED_LITERALS 0\n# endif\n#endif\n\n#ifndef FMT_USE_EXTERN_TEMPLATES\n# define FMT_USE_EXTERN_TEMPLATES \\\n    (FMT_CLANG_VERSION >= 209 || (FMT_GCC_VERSION >= 303 && FMT_HAS_GXX_CXX11))\n#endif\n\n#ifdef FMT_HEADER_ONLY\n// If header only do not use extern templates.\n# undef FMT_USE_EXTERN_TEMPLATES\n# define FMT_USE_EXTERN_TEMPLATES 0\n#endif\n\n#ifndef FMT_ASSERT\n# define FMT_ASSERT(condition, message) assert((condition) && message)\n#endif\n\n// __builtin_clz is broken in clang with Microsoft CodeGen:\n// https://github.com/fmtlib/fmt/issues/519\n#ifndef _MSC_VER\n# if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clz)\n#  define FMT_BUILTIN_CLZ(n) __builtin_clz(n)\n# endif\n\n# if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clzll)\n#  define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)\n# endif\n#endif\n\n// Some compilers masquerade as both MSVC and GCC-likes or\n// otherwise support __builtin_clz and __builtin_clzll, so\n// only define FMT_BUILTIN_CLZ using the MSVC intrinsics\n// if the clz and clzll builtins are not available.\n#if FMT_MSC_VER && !defined(FMT_BUILTIN_CLZLL) && !defined(_MANAGED)\n# include <intrin.h>  // _BitScanReverse, _BitScanReverse64\n\nnamespace fmt {\nnamespace internal {\n// avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning\n# ifndef __clang__\n#  pragma intrinsic(_BitScanReverse)\n# endif\ninline uint32_t clz(uint32_t x) {\n  unsigned long r = 0;\n  _BitScanReverse(&r, x);\n\n  assert(x != 0);\n  // Static analysis complains about using uninitialized data\n  // \"r\", but the only way that can happen is if \"x\" is 0,\n  // which the callers guarantee to not happen.\n# pragma warning(suppress: 6102)\n  return 31 - r;\n}\n# define FMT_BUILTIN_CLZ(n) fmt::internal::clz(n)\n\n// avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning\n# if defined(_WIN64) && !defined(__clang__)\n#  pragma intrinsic(_BitScanReverse64)\n# endif\n\ninline uint32_t clzll(uint64_t x) {\n  unsigned long r = 0;\n# ifdef _WIN64\n  _BitScanReverse64(&r, x);\n# else\n  // Scan the high 32 bits.\n  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32)))\n    return 63 - (r + 32);\n\n  // Scan the low 32 bits.\n  _BitScanReverse(&r, static_cast<uint32_t>(x));\n# endif\n\n  assert(x != 0);\n  // Static analysis complains about using uninitialized data\n  // \"r\", but the only way that can happen is if \"x\" is 0,\n  // which the callers guarantee to not happen.\n# pragma warning(suppress: 6102)\n  return 63 - r;\n}\n# define FMT_BUILTIN_CLZLL(n) fmt::internal::clzll(n)\n}\n}\n#endif\n\nnamespace fmt {\nnamespace internal {\nstruct DummyInt {\n  int data[2];\n  operator int() const { return 0; }\n};\ntypedef std::numeric_limits<fmt::internal::DummyInt> FPUtil;\n\n// Dummy implementations of system functions such as signbit and ecvt called\n// if the latter are not available.\ninline DummyInt signbit(...) { return DummyInt(); }\ninline DummyInt _ecvt_s(...) { return DummyInt(); }\ninline DummyInt isinf(...) { return DummyInt(); }\ninline DummyInt _finite(...) { return DummyInt(); }\ninline DummyInt isnan(...) { return DummyInt(); }\ninline DummyInt _isnan(...) { return DummyInt(); }\n\n// A helper function to suppress bogus \"conditional expression is constant\"\n// warnings.\ntemplate <typename T>\ninline T const_check(T value) { return value; }\n}\n}  // namespace fmt\n\nnamespace std {\n// Standard permits specialization of std::numeric_limits. This specialization\n// is used to resolve ambiguity between isinf and std::isinf in glibc:\n// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=48891\n// and the same for isnan and signbit.\ntemplate <>\nclass numeric_limits<fmt::internal::DummyInt> :\n    public std::numeric_limits<int> {\n public:\n  // Portable version of isinf.\n  template <typename T>\n  static bool isinfinity(T x) {\n    using namespace fmt::internal;\n    // The resolution \"priority\" is:\n    // isinf macro > std::isinf > ::isinf > fmt::internal::isinf\n    if (const_check(sizeof(isinf(x)) != sizeof(fmt::internal::DummyInt))) {\n      return isinf(x) != 0;\n    }\n    return !_finite(static_cast<double>(x));\n  }\n\n  // Portable version of isnan.\n  template <typename T>\n  static bool isnotanumber(T x) {\n    using namespace fmt::internal;\n    if (const_check(sizeof(isnan(x)) != sizeof(fmt::internal::DummyInt))) {\n      return isnan(x) != 0;\n    }\n    return _isnan(static_cast<double>(x)) != 0;\n  }\n\n  // Portable version of signbit.\n  static bool isnegative(double x) {\n    using namespace fmt::internal;\n    if (const_check(sizeof(signbit(x)) != sizeof(fmt::internal::DummyInt))) {\n      return signbit(x) != 0;\n    }\n    if (x < 0) return true;\n    if (!isnotanumber(x)) return false;\n    int dec = 0, sign = 0;\n    char buffer[2];  // The buffer size must be >= 2 or _ecvt_s will fail.\n    _ecvt_s(buffer, sizeof(buffer), x, 0, &dec, &sign);\n    return sign != 0;\n  }\n};\n}  // namespace std\n\nnamespace fmt {\n\n// Fix the warning about long long on older versions of GCC\n// that don't support the diagnostic pragma.\nFMT_GCC_EXTENSION typedef long long LongLong;\nFMT_GCC_EXTENSION typedef unsigned long long ULongLong;\n\n#if FMT_USE_RVALUE_REFERENCES\nusing std::move;\n#endif\n\ntemplate <typename Char>\nclass BasicWriter;\n\ntypedef BasicWriter<char> Writer;\ntypedef BasicWriter<wchar_t> WWriter;\n\ntemplate <typename Char>\nclass ArgFormatter;\n\nstruct FormatSpec;\n\ntemplate <typename Impl, typename Char, typename Spec = fmt::FormatSpec>\nclass BasicPrintfArgFormatter;\n\ntemplate <typename CharType,\n          typename ArgFormatter = fmt::ArgFormatter<CharType> >\nclass BasicFormatter;\n\n/**\n  \\rst\n  A string reference. It can be constructed from a C string or\n  ``std::basic_string``.\n\n  You can use one of the following typedefs for common character types:\n\n  +------------+-------------------------+\n  | Type       | Definition              |\n  +============+=========================+\n  | StringRef  | BasicStringRef<char>    |\n  +------------+-------------------------+\n  | WStringRef | BasicStringRef<wchar_t> |\n  +------------+-------------------------+\n\n  This class is most useful as a parameter type to allow passing\n  different types of strings to a function, for example::\n\n    template <typename... Args>\n    std::string format(StringRef format_str, const Args & ... args);\n\n    format(\"{}\", 42);\n    format(std::string(\"{}\"), 42);\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicStringRef {\n private:\n  const Char *data_;\n  std::size_t size_;\n\n public:\n  /** Constructs a string reference object from a C string and a size. */\n  BasicStringRef(const Char *s, std::size_t size) : data_(s), size_(size) {}\n\n  /**\n    \\rst\n    Constructs a string reference object from a C string computing\n    the size with ``std::char_traits<Char>::length``.\n    \\endrst\n   */\n  BasicStringRef(const Char *s)\n    : data_(s), size_(std::char_traits<Char>::length(s)) {}\n\n  /**\n    \\rst\n    Constructs a string reference from a ``std::basic_string`` object.\n    \\endrst\n   */\n  template <typename Allocator>\n  BasicStringRef(\n      const std::basic_string<Char, std::char_traits<Char>, Allocator> &s)\n  : data_(s.c_str()), size_(s.size()) {}\n\n#if FMT_HAS_STRING_VIEW\n  /**\n    \\rst\n    Constructs a string reference from a ``std::basic_string_view`` object.\n    \\endrst\n   */\n  BasicStringRef(\n      const std::basic_string_view<Char, std::char_traits<Char>> &s)\n  : data_(s.data()), size_(s.size()) {}\n\n  /**\n   \\rst\n   Converts a string reference to an ``std::string_view`` object.\n   \\endrst\n  */\n  explicit operator std::basic_string_view<Char>() const FMT_NOEXCEPT {\n    return std::basic_string_view<Char>(data_, size_);\n  }\n#endif\n\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  /**\n  \\rst\n  Constructs a string reference from a ``std::experimental::basic_string_view`` object.\n  \\endrst\n  */\n  BasicStringRef(\n\t  const std::experimental::basic_string_view<Char, std::char_traits<Char>> &s)\n\t  : data_(s.data()), size_(s.size()) {}\n\n  /**\n  \\rst\n  Converts a string reference to an ``std::string_view`` object.\n  \\endrst\n  */\n  explicit operator std::experimental::basic_string_view<Char>() const FMT_NOEXCEPT {\n\t  return std::experimental::basic_string_view<Char>(data_, size_);\n  }\n#endif\n\n  /**\n    \\rst\n    Converts a string reference to an ``std::string`` object.\n    \\endrst\n   */\n  std::basic_string<Char> to_string() const {\n    return std::basic_string<Char>(data_, size_);\n  }\n\n  /** Returns a pointer to the string data. */\n  const Char *data() const { return data_; }\n\n  /** Returns the string size. */\n  std::size_t size() const { return size_; }\n\n  // Lexicographically compare this string reference to other.\n  int compare(BasicStringRef other) const {\n    std::size_t size = size_ < other.size_ ? size_ : other.size_;\n    int result = std::char_traits<Char>::compare(data_, other.data_, size);\n    if (result == 0)\n      result = size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);\n    return result;\n  }\n\n  friend bool operator==(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) == 0;\n  }\n  friend bool operator!=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) != 0;\n  }\n  friend bool operator<(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) < 0;\n  }\n  friend bool operator<=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) <= 0;\n  }\n  friend bool operator>(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) > 0;\n  }\n  friend bool operator>=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) >= 0;\n  }\n};\n\ntypedef BasicStringRef<char> StringRef;\ntypedef BasicStringRef<wchar_t> WStringRef;\n\n/**\n  \\rst\n  A reference to a null terminated string. It can be constructed from a C\n  string or ``std::basic_string``.\n\n  You can use one of the following typedefs for common character types:\n\n  +-------------+--------------------------+\n  | Type        | Definition               |\n  +=============+==========================+\n  | CStringRef  | BasicCStringRef<char>    |\n  +-------------+--------------------------+\n  | WCStringRef | BasicCStringRef<wchar_t> |\n  +-------------+--------------------------+\n\n  This class is most useful as a parameter type to allow passing\n  different types of strings to a function, for example::\n\n    template <typename... Args>\n    std::string format(CStringRef format_str, const Args & ... args);\n\n    format(\"{}\", 42);\n    format(std::string(\"{}\"), 42);\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicCStringRef {\n private:\n  const Char *data_;\n\n public:\n  /** Constructs a string reference object from a C string. */\n  BasicCStringRef(const Char *s) : data_(s) {}\n\n  /**\n    \\rst\n    Constructs a string reference from a ``std::basic_string`` object.\n    \\endrst\n   */\n  template <typename Allocator>\n  BasicCStringRef(\n      const std::basic_string<Char, std::char_traits<Char>, Allocator> &s)\n  : data_(s.c_str()) {}\n\n  /** Returns the pointer to a C string. */\n  const Char *c_str() const { return data_; }\n};\n\ntypedef BasicCStringRef<char> CStringRef;\ntypedef BasicCStringRef<wchar_t> WCStringRef;\n\n/** A formatting error such as invalid format string. */\nclass FormatError : public std::runtime_error {\n public:\n  explicit FormatError(CStringRef message)\n  : std::runtime_error(message.c_str()) {}\n  FormatError(const FormatError &ferr) : std::runtime_error(ferr) {}\n  FMT_API ~FormatError() FMT_DTOR_NOEXCEPT FMT_OVERRIDE;\n};\n\nnamespace internal {\n\n// MakeUnsigned<T>::Type gives an unsigned type corresponding to integer type T.\ntemplate <typename T>\nstruct MakeUnsigned { typedef T Type; };\n\n#define FMT_SPECIALIZE_MAKE_UNSIGNED(T, U) \\\n  template <> \\\n  struct MakeUnsigned<T> { typedef U Type; }\n\nFMT_SPECIALIZE_MAKE_UNSIGNED(char, unsigned char);\nFMT_SPECIALIZE_MAKE_UNSIGNED(signed char, unsigned char);\nFMT_SPECIALIZE_MAKE_UNSIGNED(short, unsigned short);\nFMT_SPECIALIZE_MAKE_UNSIGNED(int, unsigned);\nFMT_SPECIALIZE_MAKE_UNSIGNED(long, unsigned long);\nFMT_SPECIALIZE_MAKE_UNSIGNED(LongLong, ULongLong);\n\n// Casts nonnegative integer to unsigned.\ntemplate <typename Int>\ninline typename MakeUnsigned<Int>::Type to_unsigned(Int value) {\n  FMT_ASSERT(value >= 0, \"negative value\");\n  return static_cast<typename MakeUnsigned<Int>::Type>(value);\n}\n\n// The number of characters to store in the MemoryBuffer object itself\n// to avoid dynamic memory allocation.\nenum { INLINE_BUFFER_SIZE = 500 };\n\n#if FMT_SECURE_SCL\n// Use checked iterator to avoid warnings on MSVC.\ntemplate <typename T>\ninline stdext::checked_array_iterator<T*> make_ptr(T *ptr, std::size_t size) {\n  return stdext::checked_array_iterator<T*>(ptr, size);\n}\n#else\ntemplate <typename T>\ninline T *make_ptr(T *ptr, std::size_t) { return ptr; }\n#endif\n}  // namespace internal\n\n/**\n  \\rst\n  A buffer supporting a subset of ``std::vector``'s operations.\n  \\endrst\n */\ntemplate <typename T>\nclass Buffer {\n private:\n  FMT_DISALLOW_COPY_AND_ASSIGN(Buffer);\n\n protected:\n  T *ptr_;\n  std::size_t size_;\n  std::size_t capacity_;\n\n  Buffer(T *ptr = FMT_NULL, std::size_t capacity = 0)\n    : ptr_(ptr), size_(0), capacity_(capacity) {}\n\n  /**\n    \\rst\n    Increases the buffer capacity to hold at least *size* elements updating\n    ``ptr_`` and ``capacity_``.\n    \\endrst\n   */\n  virtual void grow(std::size_t size) = 0;\n\n public:\n  virtual ~Buffer() {}\n\n  /** Returns the size of this buffer. */\n  std::size_t size() const { return size_; }\n\n  /** Returns the capacity of this buffer. */\n  std::size_t capacity() const { return capacity_; }\n\n  /**\n    Resizes the buffer. If T is a POD type new elements may not be initialized.\n   */\n  void resize(std::size_t new_size) {\n    if (new_size > capacity_)\n      grow(new_size);\n    size_ = new_size;\n  }\n\n  /**\n    \\rst\n    Reserves space to store at least *capacity* elements.\n    \\endrst\n   */\n  void reserve(std::size_t capacity) {\n    if (capacity > capacity_)\n      grow(capacity);\n  }\n\n  void clear() FMT_NOEXCEPT { size_ = 0; }\n\n  void push_back(const T &value) {\n    if (size_ == capacity_)\n      grow(size_ + 1);\n    ptr_[size_++] = value;\n  }\n\n  /** Appends data to the end of the buffer. */\n  template <typename U>\n  void append(const U *begin, const U *end);\n\n  T &operator[](std::size_t index) { return ptr_[index]; }\n  const T &operator[](std::size_t index) const { return ptr_[index]; }\n};\n\ntemplate <typename T>\ntemplate <typename U>\nvoid Buffer<T>::append(const U *begin, const U *end) {\n  FMT_ASSERT(end >= begin, \"negative value\");\n  std::size_t new_size = size_ + static_cast<std::size_t>(end - begin);\n  if (new_size > capacity_)\n    grow(new_size);\n  std::uninitialized_copy(begin, end,\n                          internal::make_ptr(ptr_, capacity_) + size_);\n  size_ = new_size;\n}\n\nnamespace internal {\n\n// A memory buffer for trivially copyable/constructible types with the first\n// SIZE elements stored in the object itself.\ntemplate <typename T, std::size_t SIZE, typename Allocator = std::allocator<T> >\nclass MemoryBuffer : private Allocator, public Buffer<T> {\n private:\n  T data_[SIZE];\n\n  // Deallocate memory allocated by the buffer.\n  void deallocate() {\n    if (this->ptr_ != data_) Allocator::deallocate(this->ptr_, this->capacity_);\n  }\n\n protected:\n  void grow(std::size_t size) FMT_OVERRIDE;\n\n public:\n  explicit MemoryBuffer(const Allocator &alloc = Allocator())\n      : Allocator(alloc), Buffer<T>(data_, SIZE) {}\n  ~MemoryBuffer() FMT_OVERRIDE { deallocate(); }\n\n#if FMT_USE_RVALUE_REFERENCES\n private:\n  // Move data from other to this buffer.\n  void move(MemoryBuffer &other) {\n    Allocator &this_alloc = *this, &other_alloc = other;\n    this_alloc = std::move(other_alloc);\n    this->size_ = other.size_;\n    this->capacity_ = other.capacity_;\n    if (other.ptr_ == other.data_) {\n      this->ptr_ = data_;\n      std::uninitialized_copy(other.data_, other.data_ + this->size_,\n                              make_ptr(data_, this->capacity_));\n    } else {\n      this->ptr_ = other.ptr_;\n      // Set pointer to the inline array so that delete is not called\n      // when deallocating.\n      other.ptr_ = other.data_;\n    }\n  }\n\n public:\n  MemoryBuffer(MemoryBuffer &&other) {\n    move(other);\n  }\n\n  MemoryBuffer &operator=(MemoryBuffer &&other) {\n    assert(this != &other);\n    deallocate();\n    move(other);\n    return *this;\n  }\n#endif\n\n  // Returns a copy of the allocator associated with this buffer.\n  Allocator get_allocator() const { return *this; }\n};\n\ntemplate <typename T, std::size_t SIZE, typename Allocator>\nvoid MemoryBuffer<T, SIZE, Allocator>::grow(std::size_t size) {\n  std::size_t new_capacity = this->capacity_ + this->capacity_ / 2;\n  if (size > new_capacity)\n      new_capacity = size;\n#if FMT_USE_ALLOCATOR_TRAITS\n  T *new_ptr =\n      std::allocator_traits<Allocator>::allocate(*this, new_capacity, FMT_NULL);\n#else\n  T *new_ptr = this->allocate(new_capacity, FMT_NULL);\n#endif\n  // The following code doesn't throw, so the raw pointer above doesn't leak.\n  std::uninitialized_copy(this->ptr_, this->ptr_ + this->size_,\n                          make_ptr(new_ptr, new_capacity));\n  std::size_t old_capacity = this->capacity_;\n  T *old_ptr = this->ptr_;\n  this->capacity_ = new_capacity;\n  this->ptr_ = new_ptr;\n  // deallocate may throw (at least in principle), but it doesn't matter since\n  // the buffer already uses the new storage and will deallocate it in case\n  // of exception.\n  if (old_ptr != data_)\n    Allocator::deallocate(old_ptr, old_capacity);\n}\n\n// A fixed-size buffer.\ntemplate <typename Char>\nclass FixedBuffer : public fmt::Buffer<Char> {\n public:\n  FixedBuffer(Char *array, std::size_t size) : fmt::Buffer<Char>(array, size) {}\n\n protected:\n  FMT_API void grow(std::size_t size) FMT_OVERRIDE;\n};\n\ntemplate <typename Char>\nclass BasicCharTraits {\n public:\n#if FMT_SECURE_SCL\n  typedef stdext::checked_array_iterator<Char*> CharPtr;\n#else\n  typedef Char *CharPtr;\n#endif\n  static Char cast(int value) { return static_cast<Char>(value); }\n};\n\ntemplate <typename Char>\nclass CharTraits;\n\ntemplate <>\nclass CharTraits<char> : public BasicCharTraits<char> {\n private:\n  // Conversion from wchar_t to char is not allowed.\n  static char convert(wchar_t);\n\n public:\n  static char convert(char value) { return value; }\n\n  // Formats a floating-point number.\n  template <typename T>\n  FMT_API static int format_float(char *buffer, std::size_t size,\n      const char *format, unsigned width, int precision, T value);\n};\n\n#if FMT_USE_EXTERN_TEMPLATES\nextern template int CharTraits<char>::format_float<double>\n        (char *buffer, std::size_t size,\n         const char* format, unsigned width, int precision, double value);\nextern template int CharTraits<char>::format_float<long double>\n        (char *buffer, std::size_t size,\n         const char* format, unsigned width, int precision, long double value);\n#endif\n\ntemplate <>\nclass CharTraits<wchar_t> : public BasicCharTraits<wchar_t> {\n public:\n  static wchar_t convert(char value) { return value; }\n  static wchar_t convert(wchar_t value) { return value; }\n\n  template <typename T>\n  FMT_API static int format_float(wchar_t *buffer, std::size_t size,\n      const wchar_t *format, unsigned width, int precision, T value);\n};\n\n#if FMT_USE_EXTERN_TEMPLATES\nextern template int CharTraits<wchar_t>::format_float<double>\n        (wchar_t *buffer, std::size_t size,\n         const wchar_t* format, unsigned width, int precision, double value);\nextern template int CharTraits<wchar_t>::format_float<long double>\n        (wchar_t *buffer, std::size_t size,\n         const wchar_t* format, unsigned width, int precision, long double value);\n#endif\n\n// Checks if a number is negative - used to avoid warnings.\ntemplate <bool IsSigned>\nstruct SignChecker {\n  template <typename T>\n  static bool is_negative(T value) { return value < 0; }\n};\n\ntemplate <>\nstruct SignChecker<false> {\n  template <typename T>\n  static bool is_negative(T) { return false; }\n};\n\n// Returns true if value is negative, false otherwise.\n// Same as (value < 0) but doesn't produce warnings if T is an unsigned type.\ntemplate <typename T>\ninline bool is_negative(T value) {\n  return SignChecker<std::numeric_limits<T>::is_signed>::is_negative(value);\n}\n\n// Selects uint32_t if FitsIn32Bits is true, uint64_t otherwise.\ntemplate <bool FitsIn32Bits>\nstruct TypeSelector { typedef uint32_t Type; };\n\ntemplate <>\nstruct TypeSelector<false> { typedef uint64_t Type; };\n\ntemplate <typename T>\nstruct IntTraits {\n  // Smallest of uint32_t and uint64_t that is large enough to represent\n  // all values of T.\n  typedef typename\n    TypeSelector<std::numeric_limits<T>::digits <= 32>::Type MainType;\n};\n\nFMT_API FMT_NORETURN void report_unknown_type(char code, const char *type);\n\n// Static data is placed in this class template to allow header-only\n// configuration.\ntemplate <typename T = void>\nstruct FMT_API BasicData {\n  static const uint32_t POWERS_OF_10_32[];\n  static const uint64_t POWERS_OF_10_64[];\n  static const char DIGITS[];\n};\n\n#if FMT_USE_EXTERN_TEMPLATES\nextern template struct BasicData<void>;\n#endif\n\ntypedef BasicData<> Data;\n\n#ifdef FMT_BUILTIN_CLZLL\n// Returns the number of decimal digits in n. Leading zeros are not counted\n// except for n == 0 in which case count_digits returns 1.\ninline unsigned count_digits(uint64_t n) {\n  // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10\n  // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.\n  int t = (64 - FMT_BUILTIN_CLZLL(n | 1)) * 1233 >> 12;\n  return to_unsigned(t) - (n < Data::POWERS_OF_10_64[t]) + 1;\n}\n#else\n// Fallback version of count_digits used when __builtin_clz is not available.\ninline unsigned count_digits(uint64_t n) {\n  unsigned count = 1;\n  for (;;) {\n    // Integer division is slow so do it for a group of four digits instead\n    // of for every digit. The idea comes from the talk by Alexandrescu\n    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n    if (n < 10) return count;\n    if (n < 100) return count + 1;\n    if (n < 1000) return count + 2;\n    if (n < 10000) return count + 3;\n    n /= 10000u;\n    count += 4;\n  }\n}\n#endif\n\n#ifdef FMT_BUILTIN_CLZ\n// Optional version of count_digits for better performance on 32-bit platforms.\ninline unsigned count_digits(uint32_t n) {\n  int t = (32 - FMT_BUILTIN_CLZ(n | 1)) * 1233 >> 12;\n  return to_unsigned(t) - (n < Data::POWERS_OF_10_32[t]) + 1;\n}\n#endif\n\n// A functor that doesn't add a thousands separator.\nstruct NoThousandsSep {\n  template <typename Char>\n  void operator()(Char *) {}\n};\n\n// A functor that adds a thousands separator.\nclass ThousandsSep {\n private:\n  fmt::StringRef sep_;\n\n  // Index of a decimal digit with the least significant digit having index 0.\n  unsigned digit_index_;\n\n public:\n  explicit ThousandsSep(fmt::StringRef sep) : sep_(sep), digit_index_(0) {}\n\n  template <typename Char>\n  void operator()(Char *&buffer) {\n    if (++digit_index_ % 3 != 0)\n      return;\n    buffer -= sep_.size();\n    std::uninitialized_copy(sep_.data(), sep_.data() + sep_.size(),\n                            internal::make_ptr(buffer, sep_.size()));\n  }\n};\n\n// Formats a decimal unsigned integer value writing into buffer.\n// thousands_sep is a functor that is called after writing each char to\n// add a thousands separator if necessary.\ntemplate <typename UInt, typename Char, typename ThousandsSep>\ninline void format_decimal(Char *buffer, UInt value, unsigned num_digits,\n                           ThousandsSep thousands_sep) {\n  buffer += num_digits;\n  while (value >= 100) {\n    // Integer division is slow so do it for a group of two digits instead\n    // of for every digit. The idea comes from the talk by Alexandrescu\n    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n    unsigned index = static_cast<unsigned>((value % 100) * 2);\n    value /= 100;\n    *--buffer = Data::DIGITS[index + 1];\n    thousands_sep(buffer);\n    *--buffer = Data::DIGITS[index];\n    thousands_sep(buffer);\n  }\n  if (value < 10) {\n    *--buffer = static_cast<char>('0' + value);\n    return;\n  }\n  unsigned index = static_cast<unsigned>(value * 2);\n  *--buffer = Data::DIGITS[index + 1];\n  thousands_sep(buffer);\n  *--buffer = Data::DIGITS[index];\n}\n\ntemplate <typename UInt, typename Char>\ninline void format_decimal(Char *buffer, UInt value, unsigned num_digits) {\n  format_decimal(buffer, value, num_digits, NoThousandsSep());\n  return;\n}\n\n#ifndef _WIN32\n# define FMT_USE_WINDOWS_H 0\n#elif !defined(FMT_USE_WINDOWS_H)\n# define FMT_USE_WINDOWS_H 1\n#endif\n\n// Define FMT_USE_WINDOWS_H to 0 to disable use of windows.h.\n// All the functionality that relies on it will be disabled too.\n#if FMT_USE_WINDOWS_H\n// A converter from UTF-8 to UTF-16.\n// It is only provided for Windows since other systems support UTF-8 natively.\nclass UTF8ToUTF16 {\n private:\n  MemoryBuffer<wchar_t, INLINE_BUFFER_SIZE> buffer_;\n\n public:\n  FMT_API explicit UTF8ToUTF16(StringRef s);\n  operator WStringRef() const { return WStringRef(&buffer_[0], size()); }\n  size_t size() const { return buffer_.size() - 1; }\n  const wchar_t *c_str() const { return &buffer_[0]; }\n  std::wstring str() const { return std::wstring(&buffer_[0], size()); }\n};\n\n// A converter from UTF-16 to UTF-8.\n// It is only provided for Windows since other systems support UTF-8 natively.\nclass UTF16ToUTF8 {\n private:\n  MemoryBuffer<char, INLINE_BUFFER_SIZE> buffer_;\n\n public:\n  UTF16ToUTF8() {}\n  FMT_API explicit UTF16ToUTF8(WStringRef s);\n  operator StringRef() const { return StringRef(&buffer_[0], size()); }\n  size_t size() const { return buffer_.size() - 1; }\n  const char *c_str() const { return &buffer_[0]; }\n  std::string str() const { return std::string(&buffer_[0], size()); }\n\n  // Performs conversion returning a system error code instead of\n  // throwing exception on conversion error. This method may still throw\n  // in case of memory allocation error.\n  FMT_API int convert(WStringRef s);\n};\n\nFMT_API void format_windows_error(fmt::Writer &out, int error_code,\n                                  fmt::StringRef message) FMT_NOEXCEPT;\n#endif\n\n// A formatting argument value.\nstruct Value {\n  template <typename Char>\n  struct StringValue {\n    const Char *value;\n    std::size_t size;\n  };\n\n  typedef void (*FormatFunc)(\n      void *formatter, const void *arg, void *format_str_ptr);\n\n  struct CustomValue {\n    const void *value;\n    FormatFunc format;\n  };\n\n  union {\n    int int_value;\n    unsigned uint_value;\n    LongLong long_long_value;\n    ULongLong ulong_long_value;\n    double double_value;\n    long double long_double_value;\n    const void *pointer;\n    StringValue<char> string;\n    StringValue<signed char> sstring;\n    StringValue<unsigned char> ustring;\n    StringValue<wchar_t> wstring;\n    CustomValue custom;\n  };\n\n  enum Type {\n    NONE, NAMED_ARG,\n    // Integer types should go first,\n    INT, UINT, LONG_LONG, ULONG_LONG, BOOL, CHAR, LAST_INTEGER_TYPE = CHAR,\n    // followed by floating-point types.\n    DOUBLE, LONG_DOUBLE, LAST_NUMERIC_TYPE = LONG_DOUBLE,\n    CSTRING, STRING, WSTRING, POINTER, CUSTOM\n  };\n};\n\n// A formatting argument. It is a trivially copyable/constructible type to\n// allow storage in internal::MemoryBuffer.\nstruct Arg : Value {\n  Type type;\n};\n\ntemplate <typename Char>\nstruct NamedArg;\ntemplate <typename Char, typename T>\nstruct NamedArgWithType;\n\ntemplate <typename T = void>\nstruct Null {};\n\n// A helper class template to enable or disable overloads taking wide\n// characters and strings in MakeValue.\ntemplate <typename T, typename Char>\nstruct WCharHelper {\n  typedef Null<T> Supported;\n  typedef T Unsupported;\n};\n\ntemplate <typename T>\nstruct WCharHelper<T, wchar_t> {\n  typedef T Supported;\n  typedef Null<T> Unsupported;\n};\n\ntypedef char Yes[1];\ntypedef char No[2];\n\ntemplate <typename T>\nT &get();\n\n// These are non-members to workaround an overload resolution bug in bcc32.\nYes &convert(fmt::ULongLong);\nNo &convert(...);\n\ntemplate <typename T, bool ENABLE_CONVERSION>\nstruct ConvertToIntImpl {\n  enum { value = ENABLE_CONVERSION };\n};\n\ntemplate <typename T, bool ENABLE_CONVERSION>\nstruct ConvertToIntImpl2 {\n  enum { value = false };\n};\n\ntemplate <typename T>\nstruct ConvertToIntImpl2<T, true> {\n  enum {\n    // Don't convert numeric types.\n    value = ConvertToIntImpl<T, !std::numeric_limits<T>::is_specialized>::value\n  };\n};\n\ntemplate <typename T>\nstruct ConvertToInt {\n  enum {\n    enable_conversion = sizeof(fmt::internal::convert(get<T>())) == sizeof(Yes)\n  };\n  enum { value = ConvertToIntImpl2<T, enable_conversion>::value };\n};\n\n#define FMT_DISABLE_CONVERSION_TO_INT(Type) \\\n  template <> \\\n  struct ConvertToInt<Type> {  enum { value = 0 }; }\n\n// Silence warnings about convering float to int.\nFMT_DISABLE_CONVERSION_TO_INT(float);\nFMT_DISABLE_CONVERSION_TO_INT(double);\nFMT_DISABLE_CONVERSION_TO_INT(long double);\n\ntemplate <bool B, class T = void>\nstruct EnableIf {};\n\ntemplate <class T>\nstruct EnableIf<true, T> { typedef T type; };\n\ntemplate <bool B, class T, class F>\nstruct Conditional { typedef T type; };\n\ntemplate <class T, class F>\nstruct Conditional<false, T, F> { typedef F type; };\n\n// For bcc32 which doesn't understand ! in template arguments.\ntemplate <bool>\nstruct Not { enum { value = 0 }; };\n\ntemplate <>\nstruct Not<false> { enum { value = 1 }; };\n\ntemplate <typename T>\nstruct FalseType { enum { value = 0 }; };\n\ntemplate <typename T, T> struct LConvCheck {\n  LConvCheck(int) {}\n};\n\n// Returns the thousands separator for the current locale.\n// We check if ``lconv`` contains ``thousands_sep`` because on Android\n// ``lconv`` is stubbed as an empty struct.\ntemplate <typename LConv>\ninline StringRef thousands_sep(\n    LConv *lc, LConvCheck<char *LConv::*, &LConv::thousands_sep> = 0) {\n  return lc->thousands_sep;\n}\n\ninline fmt::StringRef thousands_sep(...) { return \"\"; }\n\n#define FMT_CONCAT(a, b) a##b\n\n#if FMT_GCC_VERSION >= 303\n# define FMT_UNUSED __attribute__((unused))\n#else\n# define FMT_UNUSED\n#endif\n\n#ifndef FMT_USE_STATIC_ASSERT\n# define FMT_USE_STATIC_ASSERT 0\n#endif\n\n#if FMT_USE_STATIC_ASSERT || FMT_HAS_FEATURE(cxx_static_assert) || \\\n  (FMT_GCC_VERSION >= 403 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1600\n# define FMT_STATIC_ASSERT(cond, message) static_assert(cond, message)\n#else\n# define FMT_CONCAT_(a, b) FMT_CONCAT(a, b)\n# define FMT_STATIC_ASSERT(cond, message) \\\n  typedef int FMT_CONCAT_(Assert, __LINE__)[(cond) ? 1 : -1] FMT_UNUSED\n#endif\n\ntemplate <typename Formatter>\nvoid format_arg(Formatter&, ...) {\n  FMT_STATIC_ASSERT(FalseType<Formatter>::value,\n                    \"Cannot format argument. To enable the use of ostream \"\n                    \"operator<< include fmt/ostream.h. Otherwise provide \"\n                    \"an overload of format_arg.\");\n}\n\n// Makes an Arg object from any type.\ntemplate <typename Formatter>\nclass MakeValue : public Arg {\n public:\n  typedef typename Formatter::Char Char;\n\n private:\n  // The following two methods are private to disallow formatting of\n  // arbitrary pointers. If you want to output a pointer cast it to\n  // \"void *\" or \"const void *\". In particular, this forbids formatting\n  // of \"[const] volatile char *\" which is printed as bool by iostreams.\n  // Do not implement!\n  template <typename T>\n  MakeValue(const T *value);\n  template <typename T>\n  MakeValue(T *value);\n\n  // The following methods are private to disallow formatting of wide\n  // characters and strings into narrow strings as in\n  //   fmt::format(\"{}\", L\"test\");\n  // To fix this, use a wide format string: fmt::format(L\"{}\", L\"test\").\n#if !FMT_MSC_VER || defined(_NATIVE_WCHAR_T_DEFINED)\n  MakeValue(typename WCharHelper<wchar_t, Char>::Unsupported);\n#endif\n  MakeValue(typename WCharHelper<wchar_t *, Char>::Unsupported);\n  MakeValue(typename WCharHelper<const wchar_t *, Char>::Unsupported);\n  MakeValue(typename WCharHelper<const std::wstring &, Char>::Unsupported);\n#if FMT_HAS_STRING_VIEW\n  MakeValue(typename WCharHelper<const std::wstring_view &, Char>::Unsupported);\n#endif\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  MakeValue(typename WCharHelper<const std::experimental::wstring_view &, Char>::Unsupported);\n#endif\n  MakeValue(typename WCharHelper<WStringRef, Char>::Unsupported);\n\n  void set_string(StringRef str) {\n    string.value = str.data();\n    string.size = str.size();\n  }\n\n  void set_string(WStringRef str) {\n    wstring.value = str.data();\n    wstring.size = str.size();\n  }\n\n  // Formats an argument of a custom type, such as a user-defined class.\n  template <typename T>\n  static void format_custom_arg(\n      void *formatter, const void *arg, void *format_str_ptr) {\n    format_arg(*static_cast<Formatter*>(formatter),\n               *static_cast<const Char**>(format_str_ptr),\n               *static_cast<const T*>(arg));\n  }\n\n public:\n  MakeValue() {}\n\n#define FMT_MAKE_VALUE_(Type, field, TYPE, rhs) \\\n  MakeValue(Type value) { field = rhs; } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n#define FMT_MAKE_VALUE(Type, field, TYPE) \\\n  FMT_MAKE_VALUE_(Type, field, TYPE, value)\n\n  FMT_MAKE_VALUE(bool, int_value, BOOL)\n  FMT_MAKE_VALUE(short, int_value, INT)\n  FMT_MAKE_VALUE(unsigned short, uint_value, UINT)\n  FMT_MAKE_VALUE(int, int_value, INT)\n  FMT_MAKE_VALUE(unsigned, uint_value, UINT)\n\n  MakeValue(long value) {\n    // To minimize the number of types we need to deal with, long is\n    // translated either to int or to long long depending on its size.\n    if (const_check(sizeof(long) == sizeof(int)))\n      int_value = static_cast<int>(value);\n    else\n      long_long_value = value;\n  }\n  static uint64_t type(long) {\n    return sizeof(long) == sizeof(int) ? Arg::INT : Arg::LONG_LONG;\n  }\n\n  MakeValue(unsigned long value) {\n    if (const_check(sizeof(unsigned long) == sizeof(unsigned)))\n      uint_value = static_cast<unsigned>(value);\n    else\n      ulong_long_value = value;\n  }\n  static uint64_t type(unsigned long) {\n    return sizeof(unsigned long) == sizeof(unsigned) ?\n          Arg::UINT : Arg::ULONG_LONG;\n  }\n\n  FMT_MAKE_VALUE(LongLong, long_long_value, LONG_LONG)\n  FMT_MAKE_VALUE(ULongLong, ulong_long_value, ULONG_LONG)\n  FMT_MAKE_VALUE(float, double_value, DOUBLE)\n  FMT_MAKE_VALUE(double, double_value, DOUBLE)\n  FMT_MAKE_VALUE(long double, long_double_value, LONG_DOUBLE)\n  FMT_MAKE_VALUE(signed char, int_value, INT)\n  FMT_MAKE_VALUE(unsigned char, uint_value, UINT)\n  FMT_MAKE_VALUE(char, int_value, CHAR)\n\n#if __cplusplus >= 201103L\n  template <\n    typename T,\n    typename = typename std::enable_if<\n      std::is_enum<T>::value && ConvertToInt<T>::value>::type>\n   MakeValue(T value) { int_value = value; }\n\n  template <\n    typename T,\n    typename = typename std::enable_if<\n      std::is_enum<T>::value && ConvertToInt<T>::value>::type>\n  static uint64_t type(T) { return Arg::INT; }\n#endif\n\n#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)\n  MakeValue(typename WCharHelper<wchar_t, Char>::Supported value) {\n    int_value = value;\n  }\n  static uint64_t type(wchar_t) { return Arg::CHAR; }\n#endif\n\n#define FMT_MAKE_STR_VALUE(Type, TYPE) \\\n  MakeValue(Type value) { set_string(value); } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n  FMT_MAKE_VALUE(char *, string.value, CSTRING)\n  FMT_MAKE_VALUE(const char *, string.value, CSTRING)\n  FMT_MAKE_VALUE(signed char *, sstring.value, CSTRING)\n  FMT_MAKE_VALUE(const signed char *, sstring.value, CSTRING)\n  FMT_MAKE_VALUE(unsigned char *, ustring.value, CSTRING)\n  FMT_MAKE_VALUE(const unsigned char *, ustring.value, CSTRING)\n  FMT_MAKE_STR_VALUE(const std::string &, STRING)\n#if FMT_HAS_STRING_VIEW\n  FMT_MAKE_STR_VALUE(const std::string_view &, STRING)\n#endif\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  FMT_MAKE_STR_VALUE(const std::experimental::string_view &, STRING)\n#endif\n  FMT_MAKE_STR_VALUE(StringRef, STRING)\n  FMT_MAKE_VALUE_(CStringRef, string.value, CSTRING, value.c_str())\n\n#define FMT_MAKE_WSTR_VALUE(Type, TYPE) \\\n  MakeValue(typename WCharHelper<Type, Char>::Supported value) { \\\n    set_string(value); \\\n  } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n  FMT_MAKE_WSTR_VALUE(wchar_t *, WSTRING)\n  FMT_MAKE_WSTR_VALUE(const wchar_t *, WSTRING)\n  FMT_MAKE_WSTR_VALUE(const std::wstring &, WSTRING)\n#if FMT_HAS_STRING_VIEW\n  FMT_MAKE_WSTR_VALUE(const std::wstring_view &, WSTRING)\n#endif\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  FMT_MAKE_WSTR_VALUE(const std::experimental::wstring_view &, WSTRING)\n#endif\n  FMT_MAKE_WSTR_VALUE(WStringRef, WSTRING)\n\n  FMT_MAKE_VALUE(void *, pointer, POINTER)\n  FMT_MAKE_VALUE(const void *, pointer, POINTER)\n\n  template <typename T>\n  MakeValue(const T &value,\n            typename EnableIf<Not<\n              ConvertToInt<T>::value>::value, int>::type = 0) {\n    custom.value = &value;\n    custom.format = &format_custom_arg<T>;\n  }\n\n  template <typename T>\n  static typename EnableIf<Not<ConvertToInt<T>::value>::value, uint64_t>::type\n      type(const T &) {\n    return Arg::CUSTOM;\n  }\n\n  // Additional template param `Char_` is needed here because make_type always\n  // uses char.\n  template <typename Char_>\n  MakeValue(const NamedArg<Char_> &value) { pointer = &value; }\n  template <typename Char_, typename T>\n  MakeValue(const NamedArgWithType<Char_, T> &value) { pointer = &value; }\n\n  template <typename Char_>\n  static uint64_t type(const NamedArg<Char_> &) { return Arg::NAMED_ARG; }\n  template <typename Char_, typename T>\n  static uint64_t type(const NamedArgWithType<Char_, T> &) { return Arg::NAMED_ARG; }\n};\n\ntemplate <typename Formatter>\nclass MakeArg : public Arg {\npublic:\n  MakeArg() {\n    type = Arg::NONE;\n  }\n\n  template <typename T>\n  MakeArg(const T &value)\n  : Arg(MakeValue<Formatter>(value)) {\n    type = static_cast<Arg::Type>(MakeValue<Formatter>::type(value));\n  }\n};\n\ntemplate <typename Char>\nstruct NamedArg : Arg {\n  BasicStringRef<Char> name;\n\n  template <typename T>\n  NamedArg(BasicStringRef<Char> argname, const T &value)\n  : Arg(MakeArg< BasicFormatter<Char> >(value)), name(argname) {}\n};\n\ntemplate <typename Char, typename T>\nstruct NamedArgWithType : NamedArg<Char> {\n  NamedArgWithType(BasicStringRef<Char> argname, const T &value)\n  : NamedArg<Char>(argname, value) {}\n};\n\nclass RuntimeError : public std::runtime_error {\n protected:\n  RuntimeError() : std::runtime_error(\"\") {}\n  RuntimeError(const RuntimeError &rerr) : std::runtime_error(rerr) {}\n  FMT_API ~RuntimeError() FMT_DTOR_NOEXCEPT FMT_OVERRIDE;\n};\n\ntemplate <typename Char>\nclass ArgMap;\n}  // namespace internal\n\n/** An argument list. */\nclass ArgList {\n private:\n  // To reduce compiled code size per formatting function call, types of first\n  // MAX_PACKED_ARGS arguments are passed in the types_ field.\n  uint64_t types_;\n  union {\n    // If the number of arguments is less than MAX_PACKED_ARGS, the argument\n    // values are stored in values_, otherwise they are stored in args_.\n    // This is done to reduce compiled code size as storing larger objects\n    // may require more code (at least on x86-64) even if the same amount of\n    // data is actually copied to stack. It saves ~10% on the bloat test.\n    const internal::Value *values_;\n    const internal::Arg *args_;\n  };\n\n  internal::Arg::Type type(unsigned index) const {\n    return type(types_, index);\n  }\n\n  template <typename Char>\n  friend class internal::ArgMap;\n\n public:\n  // Maximum number of arguments with packed types.\n  enum { MAX_PACKED_ARGS = 16 };\n\n  ArgList() : types_(0) {}\n\n  ArgList(ULongLong types, const internal::Value *values)\n  : types_(types), values_(values) {}\n  ArgList(ULongLong types, const internal::Arg *args)\n  : types_(types), args_(args) {}\n\n  uint64_t types() const { return types_; }\n\n  /** Returns the argument at specified index. */\n  internal::Arg operator[](unsigned index) const {\n    using internal::Arg;\n    Arg arg;\n    bool use_values = type(MAX_PACKED_ARGS - 1) == Arg::NONE;\n    if (index < MAX_PACKED_ARGS) {\n      Arg::Type arg_type = type(index);\n      internal::Value &val = arg;\n      if (arg_type != Arg::NONE)\n        val = use_values ? values_[index] : args_[index];\n      arg.type = arg_type;\n      return arg;\n    }\n    if (use_values) {\n      // The index is greater than the number of arguments that can be stored\n      // in values, so return a \"none\" argument.\n      arg.type = Arg::NONE;\n      return arg;\n    }\n    for (unsigned i = MAX_PACKED_ARGS; i <= index; ++i) {\n      if (args_[i].type == Arg::NONE)\n        return args_[i];\n    }\n    return args_[index];\n  }\n\n  static internal::Arg::Type type(uint64_t types, unsigned index) {\n    unsigned shift = index * 4;\n    uint64_t mask = 0xf;\n    return static_cast<internal::Arg::Type>(\n          (types & (mask << shift)) >> shift);\n  }\n};\n\n#define FMT_DISPATCH(call) static_cast<Impl*>(this)->call\n\n/**\n  \\rst\n  An argument visitor based on the `curiously recurring template pattern\n  <http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_.\n\n  To use `~fmt::ArgVisitor` define a subclass that implements some or all of the\n  visit methods with the same signatures as the methods in `~fmt::ArgVisitor`,\n  for example, `~fmt::ArgVisitor::visit_int()`.\n  Pass the subclass as the *Impl* template parameter. Then calling\n  `~fmt::ArgVisitor::visit` for some argument will dispatch to a visit method\n  specific to the argument type. For example, if the argument type is\n  ``double`` then the `~fmt::ArgVisitor::visit_double()` method of a subclass\n  will be called. If the subclass doesn't contain a method with this signature,\n  then a corresponding method of `~fmt::ArgVisitor` will be called.\n\n  **Example**::\n\n    class MyArgVisitor : public fmt::ArgVisitor<MyArgVisitor, void> {\n     public:\n      void visit_int(int value) { fmt::print(\"{}\", value); }\n      void visit_double(double value) { fmt::print(\"{}\", value ); }\n    };\n  \\endrst\n */\ntemplate <typename Impl, typename Result>\nclass ArgVisitor {\n private:\n  typedef internal::Arg Arg;\n\n public:\n  void report_unhandled_arg() {}\n\n  Result visit_unhandled_arg() {\n    FMT_DISPATCH(report_unhandled_arg());\n    return Result();\n  }\n\n  /** Visits an ``int`` argument. **/\n  Result visit_int(int value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits a ``long long`` argument. **/\n  Result visit_long_long(LongLong value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits an ``unsigned`` argument. **/\n  Result visit_uint(unsigned value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits an ``unsigned long long`` argument. **/\n  Result visit_ulong_long(ULongLong value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits a ``bool`` argument. **/\n  Result visit_bool(bool value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits a ``char`` or ``wchar_t`` argument. **/\n  Result visit_char(int value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits an argument of any integral type. **/\n  template <typename T>\n  Result visit_any_int(T) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits a ``double`` argument. **/\n  Result visit_double(double value) {\n    return FMT_DISPATCH(visit_any_double(value));\n  }\n\n  /** Visits a ``long double`` argument. **/\n  Result visit_long_double(long double value) {\n    return FMT_DISPATCH(visit_any_double(value));\n  }\n\n  /** Visits a ``double`` or ``long double`` argument. **/\n  template <typename T>\n  Result visit_any_double(T) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits a null-terminated C string (``const char *``) argument. **/\n  Result visit_cstring(const char *) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits a string argument. **/\n  Result visit_string(Arg::StringValue<char>) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits a wide string argument. **/\n  Result visit_wstring(Arg::StringValue<wchar_t>) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits a pointer argument. **/\n  Result visit_pointer(const void *) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits an argument of a custom (user-defined) type. **/\n  Result visit_custom(Arg::CustomValue) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /**\n    \\rst\n    Visits an argument dispatching to the appropriate visit method based on\n    the argument type. For example, if the argument type is ``double`` then\n    the `~fmt::ArgVisitor::visit_double()` method of the *Impl* class will be\n    called.\n    \\endrst\n   */\n  Result visit(const Arg &arg) {\n    switch (arg.type) {\n    case Arg::NONE:\n    case Arg::NAMED_ARG:\n      FMT_ASSERT(false, \"invalid argument type\");\n      break;\n    case Arg::INT:\n      return FMT_DISPATCH(visit_int(arg.int_value));\n    case Arg::UINT:\n      return FMT_DISPATCH(visit_uint(arg.uint_value));\n    case Arg::LONG_LONG:\n      return FMT_DISPATCH(visit_long_long(arg.long_long_value));\n    case Arg::ULONG_LONG:\n      return FMT_DISPATCH(visit_ulong_long(arg.ulong_long_value));\n    case Arg::BOOL:\n      return FMT_DISPATCH(visit_bool(arg.int_value != 0));\n    case Arg::CHAR:\n      return FMT_DISPATCH(visit_char(arg.int_value));\n    case Arg::DOUBLE:\n      return FMT_DISPATCH(visit_double(arg.double_value));\n    case Arg::LONG_DOUBLE:\n      return FMT_DISPATCH(visit_long_double(arg.long_double_value));\n    case Arg::CSTRING:\n      return FMT_DISPATCH(visit_cstring(arg.string.value));\n    case Arg::STRING:\n      return FMT_DISPATCH(visit_string(arg.string));\n    case Arg::WSTRING:\n      return FMT_DISPATCH(visit_wstring(arg.wstring));\n    case Arg::POINTER:\n      return FMT_DISPATCH(visit_pointer(arg.pointer));\n    case Arg::CUSTOM:\n      return FMT_DISPATCH(visit_custom(arg.custom));\n    }\n    return Result();\n  }\n};\n\nenum Alignment {\n  ALIGN_DEFAULT, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_CENTER, ALIGN_NUMERIC\n};\n\n// Flags.\nenum {\n  SIGN_FLAG = 1, PLUS_FLAG = 2, MINUS_FLAG = 4, HASH_FLAG = 8,\n  CHAR_FLAG = 0x10  // Argument has char type - used in error reporting.\n};\n\n// An empty format specifier.\nstruct EmptySpec {};\n\n// A type specifier.\ntemplate <char TYPE>\nstruct TypeSpec : EmptySpec {\n  Alignment align() const { return ALIGN_DEFAULT; }\n  unsigned width() const { return 0; }\n  int precision() const { return -1; }\n  bool flag(unsigned) const { return false; }\n  char type() const { return TYPE; }\n  char type_prefix() const { return TYPE; }\n  char fill() const { return ' '; }\n};\n\n// A width specifier.\nstruct WidthSpec {\n  unsigned width_;\n  // Fill is always wchar_t and cast to char if necessary to avoid having\n  // two specialization of WidthSpec and its subclasses.\n  wchar_t fill_;\n\n  WidthSpec(unsigned width, wchar_t fill) : width_(width), fill_(fill) {}\n\n  unsigned width() const { return width_; }\n  wchar_t fill() const { return fill_; }\n};\n\n// An alignment specifier.\nstruct AlignSpec : WidthSpec {\n  Alignment align_;\n\n  AlignSpec(unsigned width, wchar_t fill, Alignment align = ALIGN_DEFAULT)\n  : WidthSpec(width, fill), align_(align) {}\n\n  Alignment align() const { return align_; }\n\n  int precision() const { return -1; }\n};\n\n// An alignment and type specifier.\ntemplate <char TYPE>\nstruct AlignTypeSpec : AlignSpec {\n  AlignTypeSpec(unsigned width, wchar_t fill) : AlignSpec(width, fill) {}\n\n  bool flag(unsigned) const { return false; }\n  char type() const { return TYPE; }\n  char type_prefix() const { return TYPE; }\n};\n\n// A full format specifier.\nstruct FormatSpec : AlignSpec {\n  unsigned flags_;\n  int precision_;\n  char type_;\n\n  FormatSpec(\n    unsigned width = 0, char type = 0, wchar_t fill = ' ')\n  : AlignSpec(width, fill), flags_(0), precision_(-1), type_(type) {}\n\n  bool flag(unsigned f) const { return (flags_ & f) != 0; }\n  int precision() const { return precision_; }\n  char type() const { return type_; }\n  char type_prefix() const { return type_; }\n};\n\n// An integer format specifier.\ntemplate <typename T, typename SpecT = TypeSpec<0>, typename Char = char>\nclass IntFormatSpec : public SpecT {\n private:\n  T value_;\n\n public:\n  IntFormatSpec(T val, const SpecT &spec = SpecT())\n  : SpecT(spec), value_(val) {}\n\n  T value() const { return value_; }\n};\n\n// A string format specifier.\ntemplate <typename Char>\nclass StrFormatSpec : public AlignSpec {\n private:\n  const Char *str_;\n\n public:\n  template <typename FillChar>\n  StrFormatSpec(const Char *str, unsigned width, FillChar fill)\n  : AlignSpec(width, fill), str_(str) {\n    internal::CharTraits<Char>::convert(FillChar());\n  }\n\n  const Char *str() const { return str_; }\n};\n\n/**\n  Returns an integer format specifier to format the value in base 2.\n */\nIntFormatSpec<int, TypeSpec<'b'> > bin(int value);\n\n/**\n  Returns an integer format specifier to format the value in base 8.\n */\nIntFormatSpec<int, TypeSpec<'o'> > oct(int value);\n\n/**\n  Returns an integer format specifier to format the value in base 16 using\n  lower-case letters for the digits above 9.\n */\nIntFormatSpec<int, TypeSpec<'x'> > hex(int value);\n\n/**\n  Returns an integer formatter format specifier to format in base 16 using\n  upper-case letters for the digits above 9.\n */\nIntFormatSpec<int, TypeSpec<'X'> > hexu(int value);\n\n/**\n  \\rst\n  Returns an integer format specifier to pad the formatted argument with the\n  fill character to the specified width using the default (right) numeric\n  alignment.\n\n  **Example**::\n\n    MemoryWriter out;\n    out << pad(hex(0xcafe), 8, '0');\n    // out.str() == \"0000cafe\"\n\n  \\endrst\n */\ntemplate <char TYPE_CODE, typename Char>\nIntFormatSpec<int, AlignTypeSpec<TYPE_CODE>, Char> pad(\n    int value, unsigned width, Char fill = ' ');\n\n#define FMT_DEFINE_INT_FORMATTERS(TYPE) \\\ninline IntFormatSpec<TYPE, TypeSpec<'b'> > bin(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'b'> >(value, TypeSpec<'b'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'o'> > oct(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'o'> >(value, TypeSpec<'o'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'x'> > hex(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'x'> >(value, TypeSpec<'x'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'X'> > hexu(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'X'> >(value, TypeSpec<'X'>()); \\\n} \\\n \\\ntemplate <char TYPE_CODE> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> > pad( \\\n    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE> > f, unsigned width) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> >( \\\n      f.value(), AlignTypeSpec<TYPE_CODE>(width, ' ')); \\\n} \\\n \\\n/* For compatibility with older compilers we provide two overloads for pad, */ \\\n/* one that takes a fill character and one that doesn't. In the future this */ \\\n/* can be replaced with one overload making the template argument Char      */ \\\n/* default to char (C++11). */ \\\ntemplate <char TYPE_CODE, typename Char> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char> pad( \\\n    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE>, Char> f, \\\n    unsigned width, Char fill) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char>( \\\n      f.value(), AlignTypeSpec<TYPE_CODE>(width, fill)); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<0> > pad( \\\n    TYPE value, unsigned width) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<0> >( \\\n      value, AlignTypeSpec<0>(width, ' ')); \\\n} \\\n \\\ntemplate <typename Char> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<0>, Char> pad( \\\n   TYPE value, unsigned width, Char fill) { \\\n return IntFormatSpec<TYPE, AlignTypeSpec<0>, Char>( \\\n     value, AlignTypeSpec<0>(width, fill)); \\\n}\n\nFMT_DEFINE_INT_FORMATTERS(int)\nFMT_DEFINE_INT_FORMATTERS(long)\nFMT_DEFINE_INT_FORMATTERS(unsigned)\nFMT_DEFINE_INT_FORMATTERS(unsigned long)\nFMT_DEFINE_INT_FORMATTERS(LongLong)\nFMT_DEFINE_INT_FORMATTERS(ULongLong)\n\n/**\n  \\rst\n  Returns a string formatter that pads the formatted argument with the fill\n  character to the specified width using the default (left) string alignment.\n\n  **Example**::\n\n    std::string s = str(MemoryWriter() << pad(\"abc\", 8));\n    // s == \"abc     \"\n\n  \\endrst\n */\ntemplate <typename Char>\ninline StrFormatSpec<Char> pad(\n    const Char *str, unsigned width, Char fill = ' ') {\n  return StrFormatSpec<Char>(str, width, fill);\n}\n\ninline StrFormatSpec<wchar_t> pad(\n    const wchar_t *str, unsigned width, char fill = ' ') {\n  return StrFormatSpec<wchar_t>(str, width, fill);\n}\n\nnamespace internal {\n\ntemplate <typename Char>\nclass ArgMap {\n private:\n  typedef std::vector<\n    std::pair<fmt::BasicStringRef<Char>, internal::Arg> > MapType;\n  typedef typename MapType::value_type Pair;\n\n  MapType map_;\n\n public:\n  void init(const ArgList &args);\n\n  const internal::Arg *find(const fmt::BasicStringRef<Char> &name) const {\n    // The list is unsorted, so just return the first matching name.\n    for (typename MapType::const_iterator it = map_.begin(), end = map_.end();\n         it != end; ++it) {\n      if (it->first == name)\n        return &it->second;\n    }\n    return FMT_NULL;\n  }\n};\n\ntemplate <typename Char>\nvoid ArgMap<Char>::init(const ArgList &args) {\n  if (!map_.empty())\n    return;\n  typedef internal::NamedArg<Char> NamedArg;\n  const NamedArg *named_arg = FMT_NULL;\n  bool use_values =\n      args.type(ArgList::MAX_PACKED_ARGS - 1) == internal::Arg::NONE;\n  if (use_values) {\n    for (unsigned i = 0;/*nothing*/; ++i) {\n      internal::Arg::Type arg_type = args.type(i);\n      switch (arg_type) {\n      case internal::Arg::NONE:\n        return;\n      case internal::Arg::NAMED_ARG:\n        named_arg = static_cast<const NamedArg*>(args.values_[i].pointer);\n        map_.push_back(Pair(named_arg->name, *named_arg));\n        break;\n      default:\n        /*nothing*/;\n      }\n    }\n    return;\n  }\n  for (unsigned i = 0; i != ArgList::MAX_PACKED_ARGS; ++i) {\n    internal::Arg::Type arg_type = args.type(i);\n    if (arg_type == internal::Arg::NAMED_ARG) {\n      named_arg = static_cast<const NamedArg*>(args.args_[i].pointer);\n      map_.push_back(Pair(named_arg->name, *named_arg));\n    }\n  }\n  for (unsigned i = ArgList::MAX_PACKED_ARGS;/*nothing*/; ++i) {\n    switch (args.args_[i].type) {\n    case internal::Arg::NONE:\n      return;\n    case internal::Arg::NAMED_ARG:\n      named_arg = static_cast<const NamedArg*>(args.args_[i].pointer);\n      map_.push_back(Pair(named_arg->name, *named_arg));\n      break;\n    default:\n      /*nothing*/;\n    }\n  }\n}\n\ntemplate <typename Impl, typename Char, typename Spec = fmt::FormatSpec>\nclass ArgFormatterBase : public ArgVisitor<Impl, void> {\n private:\n  BasicWriter<Char> &writer_;\n  Spec &spec_;\n\n  FMT_DISALLOW_COPY_AND_ASSIGN(ArgFormatterBase);\n\n  void write_pointer(const void *p) {\n    spec_.flags_ = HASH_FLAG;\n    spec_.type_ = 'x';\n    writer_.write_int(reinterpret_cast<uintptr_t>(p), spec_);\n  }\n\n  // workaround MSVC two-phase lookup issue\n  typedef internal::Arg Arg;\n\n protected:\n  BasicWriter<Char> &writer() { return writer_; }\n  Spec &spec() { return spec_; }\n\n  void write(bool value) {\n    const char *str_value = value ? \"true\" : \"false\";\n    Arg::StringValue<char> str = { str_value, std::strlen(str_value) };\n    writer_.write_str(str, spec_);\n  }\n\n  void write(const char *value) {\n    Arg::StringValue<char> str = {value, value ? std::strlen(value) : 0};\n    writer_.write_str(str, spec_);\n  }\n\n public:\n  typedef Spec SpecType;\n\n  ArgFormatterBase(BasicWriter<Char> &w, Spec &s)\n  : writer_(w), spec_(s) {}\n\n  template <typename T>\n  void visit_any_int(T value) { writer_.write_int(value, spec_); }\n\n  template <typename T>\n  void visit_any_double(T value) { writer_.write_double(value, spec_); }\n\n  void visit_bool(bool value) {\n    if (spec_.type_) {\n      visit_any_int(value);\n      return;\n    }\n    write(value);\n  }\n\n  void visit_char(int value) {\n    if (spec_.type_ && spec_.type_ != 'c') {\n      spec_.flags_ |= CHAR_FLAG;\n      writer_.write_int(value, spec_);\n      return;\n    }\n    if (spec_.align_ == ALIGN_NUMERIC || spec_.flags_ != 0)\n      FMT_THROW(FormatError(\"invalid format specifier for char\"));\n    typedef typename BasicWriter<Char>::CharPtr CharPtr;\n    Char fill = internal::CharTraits<Char>::cast(spec_.fill());\n    CharPtr out = CharPtr();\n    const unsigned CHAR_SIZE = 1;\n    if (spec_.width_ > CHAR_SIZE) {\n      out = writer_.grow_buffer(spec_.width_);\n      if (spec_.align_ == ALIGN_RIGHT) {\n        std::uninitialized_fill_n(out, spec_.width_ - CHAR_SIZE, fill);\n        out += spec_.width_ - CHAR_SIZE;\n      } else if (spec_.align_ == ALIGN_CENTER) {\n        out = writer_.fill_padding(out, spec_.width_,\n                                   internal::const_check(CHAR_SIZE), fill);\n      } else {\n        std::uninitialized_fill_n(out + CHAR_SIZE,\n                                  spec_.width_ - CHAR_SIZE, fill);\n      }\n    } else {\n      out = writer_.grow_buffer(CHAR_SIZE);\n    }\n    *out = internal::CharTraits<Char>::cast(value);\n  }\n\n  void visit_cstring(const char *value) {\n    if (spec_.type_ == 'p')\n      return write_pointer(value);\n    write(value);\n  }\n\n  // Qualification with \"internal\" here and below is a workaround for nvcc.\n  void visit_string(internal::Arg::StringValue<char> value) {\n    writer_.write_str(value, spec_);\n  }\n\n  using ArgVisitor<Impl, void>::visit_wstring;\n\n  void visit_wstring(internal::Arg::StringValue<Char> value) {\n    writer_.write_str(value, spec_);\n  }\n\n  void visit_pointer(const void *value) {\n    if (spec_.type_ && spec_.type_ != 'p')\n      report_unknown_type(spec_.type_, \"pointer\");\n    write_pointer(value);\n  }\n};\n\nclass FormatterBase {\n private:\n  ArgList args_;\n  int next_arg_index_;\n\n  // Returns the argument with specified index.\n  FMT_API Arg do_get_arg(unsigned arg_index, const char *&error);\n\n protected:\n  const ArgList &args() const { return args_; }\n\n  explicit FormatterBase(const ArgList &args) {\n    args_ = args;\n    next_arg_index_ = 0;\n  }\n\n  // Returns the next argument.\n  Arg next_arg(const char *&error) {\n    if (next_arg_index_ >= 0)\n      return do_get_arg(internal::to_unsigned(next_arg_index_++), error);\n    error = \"cannot switch from manual to automatic argument indexing\";\n    return Arg();\n  }\n\n  // Checks if manual indexing is used and returns the argument with\n  // specified index.\n  Arg get_arg(unsigned arg_index, const char *&error) {\n    return check_no_auto_index(error) ? do_get_arg(arg_index, error) : Arg();\n  }\n\n  bool check_no_auto_index(const char *&error) {\n    if (next_arg_index_ > 0) {\n      error = \"cannot switch from automatic to manual argument indexing\";\n      return false;\n    }\n    next_arg_index_ = -1;\n    return true;\n  }\n\n  template <typename Char>\n  void write(BasicWriter<Char> &w, const Char *start, const Char *end) {\n    if (start != end)\n      w << BasicStringRef<Char>(start, internal::to_unsigned(end - start));\n  }\n};\n}  // namespace internal\n\n/**\n  \\rst\n  An argument formatter based on the `curiously recurring template pattern\n  <http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_.\n\n  To use `~fmt::BasicArgFormatter` define a subclass that implements some or\n  all of the visit methods with the same signatures as the methods in\n  `~fmt::ArgVisitor`, for example, `~fmt::ArgVisitor::visit_int()`.\n  Pass the subclass as the *Impl* template parameter. When a formatting\n  function processes an argument, it will dispatch to a visit method\n  specific to the argument type. For example, if the argument type is\n  ``double`` then the `~fmt::ArgVisitor::visit_double()` method of a subclass\n  will be called. If the subclass doesn't contain a method with this signature,\n  then a corresponding method of `~fmt::BasicArgFormatter` or its superclass\n  will be called.\n  \\endrst\n */\ntemplate <typename Impl, typename Char, typename Spec = fmt::FormatSpec>\nclass BasicArgFormatter : public internal::ArgFormatterBase<Impl, Char, Spec> {\n private:\n  BasicFormatter<Char, Impl> &formatter_;\n  const Char *format_;\n\n public:\n  /**\n    \\rst\n    Constructs an argument formatter object.\n    *formatter* is a reference to the main formatter object, *spec* contains\n    format specifier information for standard argument types, and *fmt* points\n    to the part of the format string being parsed for custom argument types.\n    \\endrst\n   */\n  BasicArgFormatter(BasicFormatter<Char, Impl> &formatter,\n                    Spec &spec, const Char *fmt)\n  : internal::ArgFormatterBase<Impl, Char, Spec>(formatter.writer(), spec),\n    formatter_(formatter), format_(fmt) {}\n\n  /** Formats an argument of a custom (user-defined) type. */\n  void visit_custom(internal::Arg::CustomValue c) {\n    c.format(&formatter_, c.value, &format_);\n  }\n};\n\n/** The default argument formatter. */\ntemplate <typename Char>\nclass ArgFormatter :\n    public BasicArgFormatter<ArgFormatter<Char>, Char, FormatSpec> {\n public:\n  /** Constructs an argument formatter object. */\n  ArgFormatter(BasicFormatter<Char> &formatter,\n               FormatSpec &spec, const Char *fmt)\n  : BasicArgFormatter<ArgFormatter<Char>,\n                      Char, FormatSpec>(formatter, spec, fmt) {}\n};\n\n/** This template formats data and writes the output to a writer. */\ntemplate <typename CharType, typename ArgFormatter>\nclass BasicFormatter : private internal::FormatterBase {\n public:\n  /** The character type for the output. */\n  typedef CharType Char;\n\n private:\n  BasicWriter<Char> &writer_;\n  internal::ArgMap<Char> map_;\n\n  FMT_DISALLOW_COPY_AND_ASSIGN(BasicFormatter);\n\n  using internal::FormatterBase::get_arg;\n\n  // Checks if manual indexing is used and returns the argument with\n  // specified name.\n  internal::Arg get_arg(BasicStringRef<Char> arg_name, const char *&error);\n\n  // Parses argument index and returns corresponding argument.\n  internal::Arg parse_arg_index(const Char *&s);\n\n  // Parses argument name and returns corresponding argument.\n  internal::Arg parse_arg_name(const Char *&s);\n\n public:\n  /**\n   \\rst\n   Constructs a ``BasicFormatter`` object. References to the arguments and\n   the writer are stored in the formatter object so make sure they have\n   appropriate lifetimes.\n   \\endrst\n   */\n  BasicFormatter(const ArgList &args, BasicWriter<Char> &w)\n    : internal::FormatterBase(args), writer_(w) {}\n\n  /** Returns a reference to the writer associated with this formatter. */\n  BasicWriter<Char> &writer() { return writer_; }\n\n  /** Formats stored arguments and writes the output to the writer. */\n  void format(BasicCStringRef<Char> format_str);\n\n  // Formats a single argument and advances format_str, a format string pointer.\n  const Char *format(const Char *&format_str, const internal::Arg &arg);\n};\n\n// Generates a comma-separated list with results of applying f to\n// numbers 0..n-1.\n# define FMT_GEN(n, f) FMT_GEN##n(f)\n# define FMT_GEN1(f)  f(0)\n# define FMT_GEN2(f)  FMT_GEN1(f),  f(1)\n# define FMT_GEN3(f)  FMT_GEN2(f),  f(2)\n# define FMT_GEN4(f)  FMT_GEN3(f),  f(3)\n# define FMT_GEN5(f)  FMT_GEN4(f),  f(4)\n# define FMT_GEN6(f)  FMT_GEN5(f),  f(5)\n# define FMT_GEN7(f)  FMT_GEN6(f),  f(6)\n# define FMT_GEN8(f)  FMT_GEN7(f),  f(7)\n# define FMT_GEN9(f)  FMT_GEN8(f),  f(8)\n# define FMT_GEN10(f) FMT_GEN9(f),  f(9)\n# define FMT_GEN11(f) FMT_GEN10(f), f(10)\n# define FMT_GEN12(f) FMT_GEN11(f), f(11)\n# define FMT_GEN13(f) FMT_GEN12(f), f(12)\n# define FMT_GEN14(f) FMT_GEN13(f), f(13)\n# define FMT_GEN15(f) FMT_GEN14(f), f(14)\n\nnamespace internal {\ninline uint64_t make_type() { return 0; }\n\ntemplate <typename T>\ninline uint64_t make_type(const T &arg) {\n  return MakeValue< BasicFormatter<char> >::type(arg);\n}\n\ntemplate <std::size_t N, bool/*IsPacked*/= (N < ArgList::MAX_PACKED_ARGS)>\nstruct ArgArray;\n\ntemplate <std::size_t N>\nstruct ArgArray<N, true/*IsPacked*/> {\n  // '+' is used to silence GCC -Wduplicated-branches warning.\n  typedef Value Type[N > 0 ? N : +1];\n\n  template <typename Formatter, typename T>\n  static Value make(const T &value) {\n#ifdef __clang__\n    Value result = MakeValue<Formatter>(value);\n    // Workaround a bug in Apple LLVM version 4.2 (clang-425.0.28) of clang:\n    // https://github.com/fmtlib/fmt/issues/276\n    (void)result.custom.format;\n    return result;\n#else\n    return MakeValue<Formatter>(value);\n#endif\n  }\n};\n\ntemplate <std::size_t N>\nstruct ArgArray<N, false/*IsPacked*/> {\n  typedef Arg Type[N + 1]; // +1 for the list end Arg::NONE\n\n  template <typename Formatter, typename T>\n  static Arg make(const T &value) { return MakeArg<Formatter>(value); }\n};\n\n#if FMT_USE_VARIADIC_TEMPLATES\ntemplate <typename Arg, typename... Args>\ninline uint64_t make_type(const Arg &first, const Args & ... tail) {\n  return make_type(first) | (make_type(tail...) << 4);\n}\n\n#else\n\nstruct ArgType {\n  uint64_t type;\n\n  ArgType() : type(0) {}\n\n  template <typename T>\n  ArgType(const T &arg) : type(make_type(arg)) {}\n};\n\n# define FMT_ARG_TYPE_DEFAULT(n) ArgType t##n = ArgType()\n\ninline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {\n  return t0.type | (t1.type << 4) | (t2.type << 8) | (t3.type << 12) |\n      (t4.type << 16) | (t5.type << 20) | (t6.type << 24) | (t7.type << 28) |\n      (t8.type << 32) | (t9.type << 36) | (t10.type << 40) | (t11.type << 44) |\n      (t12.type << 48) | (t13.type << 52) | (t14.type << 56);\n}\n#endif\n}  // namespace internal\n\n# define FMT_MAKE_TEMPLATE_ARG(n) typename T##n\n# define FMT_MAKE_ARG_TYPE(n) T##n\n# define FMT_MAKE_ARG(n) const T##n &v##n\n# define FMT_ASSIGN_char(n) \\\n  arr[n] = fmt::internal::MakeValue< fmt::BasicFormatter<char> >(v##n)\n# define FMT_ASSIGN_wchar_t(n) \\\n  arr[n] = fmt::internal::MakeValue< fmt::BasicFormatter<wchar_t> >(v##n)\n\n#if FMT_USE_VARIADIC_TEMPLATES\n// Defines a variadic function returning void.\n# define FMT_VARIADIC_VOID(func, arg_type) \\\n  template <typename... Args> \\\n  void func(arg_type arg0, const Args & ... args) { \\\n    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \\\n    typename ArgArray::Type array{ \\\n      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \\\n    func(arg0, fmt::ArgList(fmt::internal::make_type(args...), array)); \\\n  }\n\n// Defines a variadic constructor.\n# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n  template <typename... Args> \\\n  ctor(arg0_type arg0, arg1_type arg1, const Args & ... args) { \\\n    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \\\n    typename ArgArray::Type array{ \\\n      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \\\n    func(arg0, arg1, fmt::ArgList(fmt::internal::make_type(args...), array)); \\\n  }\n\n#else\n\n# define FMT_MAKE_REF(n) \\\n  fmt::internal::MakeValue< fmt::BasicFormatter<Char> >(v##n)\n# define FMT_MAKE_REF2(n) v##n\n\n// Defines a wrapper for a function taking one argument of type arg_type\n// and n additional arguments of arbitrary types.\n# define FMT_WRAP1(func, arg_type, n) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  inline void func(arg_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n    func(arg1, fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \\\n  }\n\n// Emulates a variadic function returning void on a pre-C++11 compiler.\n# define FMT_VARIADIC_VOID(func, arg_type) \\\n  inline void func(arg_type arg) { func(arg, fmt::ArgList()); } \\\n  FMT_WRAP1(func, arg_type, 1) FMT_WRAP1(func, arg_type, 2) \\\n  FMT_WRAP1(func, arg_type, 3) FMT_WRAP1(func, arg_type, 4) \\\n  FMT_WRAP1(func, arg_type, 5) FMT_WRAP1(func, arg_type, 6) \\\n  FMT_WRAP1(func, arg_type, 7) FMT_WRAP1(func, arg_type, 8) \\\n  FMT_WRAP1(func, arg_type, 9) FMT_WRAP1(func, arg_type, 10)\n\n# define FMT_CTOR(ctor, func, arg0_type, arg1_type, n) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  ctor(arg0_type arg0, arg1_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n    func(arg0, arg1, fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \\\n  }\n\n// Emulates a variadic constructor on a pre-C++11 compiler.\n# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 1) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 2) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 3) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 4) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 5) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 6) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 7) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 8) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 9) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 10)\n#endif\n\n// Generates a comma-separated list with results of applying f to pairs\n// (argument, index).\n#define FMT_FOR_EACH1(f, x0) f(x0, 0)\n#define FMT_FOR_EACH2(f, x0, x1) \\\n  FMT_FOR_EACH1(f, x0), f(x1, 1)\n#define FMT_FOR_EACH3(f, x0, x1, x2) \\\n  FMT_FOR_EACH2(f, x0 ,x1), f(x2, 2)\n#define FMT_FOR_EACH4(f, x0, x1, x2, x3) \\\n  FMT_FOR_EACH3(f, x0, x1, x2), f(x3, 3)\n#define FMT_FOR_EACH5(f, x0, x1, x2, x3, x4) \\\n  FMT_FOR_EACH4(f, x0, x1, x2, x3), f(x4, 4)\n#define FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5) \\\n  FMT_FOR_EACH5(f, x0, x1, x2, x3, x4), f(x5, 5)\n#define FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6) \\\n  FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5), f(x6, 6)\n#define FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7) \\\n  FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6), f(x7, 7)\n#define FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8) \\\n  FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7), f(x8, 8)\n#define FMT_FOR_EACH10(f, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) \\\n  FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8), f(x9, 9)\n\n/**\n An error returned by an operating system or a language runtime,\n for example a file opening error.\n*/\nclass SystemError : public internal::RuntimeError {\n private:\n  FMT_API void init(int err_code, CStringRef format_str, ArgList args);\n\n protected:\n  int error_code_;\n\n  typedef char Char;  // For FMT_VARIADIC_CTOR.\n\n  SystemError() {}\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::SystemError` object with a description\n   formatted with `fmt::format_system_error`. *message* and additional\n   arguments passed into the constructor are formatted similarly to\n   `fmt::format`.\n\n   **Example**::\n\n     // This throws a SystemError with the description\n     //   cannot open file 'madeup': No such file or directory\n     // or similar (system message may vary).\n     const char *filename = \"madeup\";\n     std::FILE *file = std::fopen(filename, \"r\");\n     if (!file)\n       throw fmt::SystemError(errno, \"cannot open file '{}'\", filename);\n   \\endrst\n  */\n  SystemError(int error_code, CStringRef message) {\n    init(error_code, message, ArgList());\n  }\n  FMT_DEFAULTED_COPY_CTOR(SystemError)\n  FMT_VARIADIC_CTOR(SystemError, init, int, CStringRef)\n\n  FMT_API ~SystemError() FMT_DTOR_NOEXCEPT FMT_OVERRIDE;\n\n  int error_code() const { return error_code_; }\n};\n\n/**\n  \\rst\n  Formats an error returned by an operating system or a language runtime,\n  for example a file opening error, and writes it to *out* in the following\n  form:\n\n  .. parsed-literal::\n     *<message>*: *<system-message>*\n\n  where *<message>* is the passed message and *<system-message>* is\n  the system message corresponding to the error code.\n  *error_code* is a system error code as given by ``errno``.\n  If *error_code* is not a valid error code such as -1, the system message\n  may look like \"Unknown error -1\" and is platform-dependent.\n  \\endrst\n */\nFMT_API void format_system_error(fmt::Writer &out, int error_code,\n                                 fmt::StringRef message) FMT_NOEXCEPT;\n\n/**\n  \\rst\n  This template provides operations for formatting and writing data into\n  a character stream. The output is stored in a buffer provided by a subclass\n  such as :class:`fmt::BasicMemoryWriter`.\n\n  You can use one of the following typedefs for common character types:\n\n  +---------+----------------------+\n  | Type    | Definition           |\n  +=========+======================+\n  | Writer  | BasicWriter<char>    |\n  +---------+----------------------+\n  | WWriter | BasicWriter<wchar_t> |\n  +---------+----------------------+\n\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicWriter {\n private:\n  // Output buffer.\n  Buffer<Char> &buffer_;\n\n  FMT_DISALLOW_COPY_AND_ASSIGN(BasicWriter);\n\n  typedef typename internal::CharTraits<Char>::CharPtr CharPtr;\n\n#if FMT_SECURE_SCL\n  // Returns pointer value.\n  static Char *get(CharPtr p) { return p.base(); }\n#else\n  static Char *get(Char *p) { return p; }\n#endif\n\n  // Fills the padding around the content and returns the pointer to the\n  // content area.\n  static CharPtr fill_padding(CharPtr buffer,\n      unsigned total_size, std::size_t content_size, wchar_t fill);\n\n  // Grows the buffer by n characters and returns a pointer to the newly\n  // allocated area.\n  CharPtr grow_buffer(std::size_t n) {\n    std::size_t size = buffer_.size();\n    buffer_.resize(size + n);\n    return internal::make_ptr(&buffer_[size], n);\n  }\n\n  // Writes an unsigned decimal integer.\n  template <typename UInt>\n  Char *write_unsigned_decimal(UInt value, unsigned prefix_size = 0) {\n    unsigned num_digits = internal::count_digits(value);\n    Char *ptr = get(grow_buffer(prefix_size + num_digits));\n    internal::format_decimal(ptr + prefix_size, value, num_digits);\n    return ptr;\n  }\n\n  // Writes a decimal integer.\n  template <typename Int>\n  void write_decimal(Int value) {\n    typedef typename internal::IntTraits<Int>::MainType MainType;\n    MainType abs_value = static_cast<MainType>(value);\n    if (internal::is_negative(value)) {\n      abs_value = 0 - abs_value;\n      *write_unsigned_decimal(abs_value, 1) = '-';\n    } else {\n      write_unsigned_decimal(abs_value, 0);\n    }\n  }\n\n  // Prepare a buffer for integer formatting.\n  CharPtr prepare_int_buffer(unsigned num_digits,\n      const EmptySpec &, const char *prefix, unsigned prefix_size) {\n    unsigned size = prefix_size + num_digits;\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n\n  template <typename Spec>\n  CharPtr prepare_int_buffer(unsigned num_digits,\n    const Spec &spec, const char *prefix, unsigned prefix_size);\n\n  // Formats an integer.\n  template <typename T, typename Spec>\n  void write_int(T value, Spec spec);\n\n  // Formats a floating-point number (double or long double).\n  template <typename T, typename Spec>\n  void write_double(T value, const Spec &spec);\n\n  // Writes a formatted string.\n  template <typename StrChar>\n  CharPtr write_str(const StrChar *s, std::size_t size, const AlignSpec &spec);\n\n  template <typename StrChar, typename Spec>\n  void write_str(const internal::Arg::StringValue<StrChar> &str,\n                 const Spec &spec);\n\n  // This following methods are private to disallow writing wide characters\n  // and strings to a char stream. If you want to print a wide string as a\n  // pointer as std::ostream does, cast it to const void*.\n  // Do not implement!\n  void operator<<(typename internal::WCharHelper<wchar_t, Char>::Unsupported);\n  void operator<<(\n      typename internal::WCharHelper<const wchar_t *, Char>::Unsupported);\n\n  // Appends floating-point length specifier to the format string.\n  // The second argument is only used for overload resolution.\n  void append_float_length(Char *&format_ptr, long double) {\n    *format_ptr++ = 'L';\n  }\n\n  template<typename T>\n  void append_float_length(Char *&, T) {}\n\n  template <typename Impl, typename Char_, typename Spec_>\n  friend class internal::ArgFormatterBase;\n\n  template <typename Impl, typename Char_, typename Spec_>\n  friend class BasicPrintfArgFormatter;\n\n protected:\n  /**\n    Constructs a ``BasicWriter`` object.\n   */\n  explicit BasicWriter(Buffer<Char> &b) : buffer_(b) {}\n\n public:\n  /**\n    \\rst\n    Destroys a ``BasicWriter`` object.\n    \\endrst\n   */\n  virtual ~BasicWriter() {}\n\n  /**\n    Returns the total number of characters written.\n   */\n  std::size_t size() const { return buffer_.size(); }\n\n  /**\n    Returns a pointer to the output buffer content. No terminating null\n    character is appended.\n   */\n  const Char *data() const FMT_NOEXCEPT { return &buffer_[0]; }\n\n  /**\n    Returns a pointer to the output buffer content with terminating null\n    character appended.\n   */\n  const Char *c_str() const {\n    std::size_t size = buffer_.size();\n    buffer_.reserve(size + 1);\n    buffer_[size] = '\\0';\n    return &buffer_[0];\n  }\n\n  /**\n    \\rst\n    Returns the content of the output buffer as an `std::string`.\n    \\endrst\n   */\n  std::basic_string<Char> str() const {\n    return std::basic_string<Char>(&buffer_[0], buffer_.size());\n  }\n\n  /**\n    \\rst\n    Writes formatted data.\n\n    *args* is an argument list representing arbitrary arguments.\n\n    **Example**::\n\n       MemoryWriter out;\n       out.write(\"Current point:\\n\");\n       out.write(\"({:+f}, {:+f})\", -3.14, 3.14);\n\n    This will write the following output to the ``out`` object:\n\n    .. code-block:: none\n\n       Current point:\n       (-3.140000, +3.140000)\n\n    The output can be accessed using :func:`data()`, :func:`c_str` or\n    :func:`str` methods.\n\n    See also :ref:`syntax`.\n    \\endrst\n   */\n  void write(BasicCStringRef<Char> format, ArgList args) {\n    BasicFormatter<Char>(args, *this).format(format);\n  }\n  FMT_VARIADIC_VOID(write, BasicCStringRef<Char>)\n\n  BasicWriter &operator<<(int value) {\n    write_decimal(value);\n    return *this;\n  }\n  BasicWriter &operator<<(unsigned value) {\n    return *this << IntFormatSpec<unsigned>(value);\n  }\n  BasicWriter &operator<<(long value) {\n    write_decimal(value);\n    return *this;\n  }\n  BasicWriter &operator<<(unsigned long value) {\n    return *this << IntFormatSpec<unsigned long>(value);\n  }\n  BasicWriter &operator<<(LongLong value) {\n    write_decimal(value);\n    return *this;\n  }\n\n  /**\n    \\rst\n    Formats *value* and writes it to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(ULongLong value) {\n    return *this << IntFormatSpec<ULongLong>(value);\n  }\n\n  BasicWriter &operator<<(double value) {\n    write_double(value, FormatSpec());\n    return *this;\n  }\n\n  /**\n    \\rst\n    Formats *value* using the general format for floating-point numbers\n    (``'g'``) and writes it to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(long double value) {\n    write_double(value, FormatSpec());\n    return *this;\n  }\n\n  /**\n    Writes a character to the stream.\n   */\n  BasicWriter &operator<<(char value) {\n    buffer_.push_back(value);\n    return *this;\n  }\n\n  BasicWriter &operator<<(\n      typename internal::WCharHelper<wchar_t, Char>::Supported value) {\n    buffer_.push_back(value);\n    return *this;\n  }\n\n  /**\n    \\rst\n    Writes *value* to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(fmt::BasicStringRef<Char> value) {\n    const Char *str = value.data();\n    buffer_.append(str, str + value.size());\n    return *this;\n  }\n\n  BasicWriter &operator<<(\n      typename internal::WCharHelper<StringRef, Char>::Supported value) {\n    const char *str = value.data();\n    buffer_.append(str, str + value.size());\n    return *this;\n  }\n\n  template <typename T, typename Spec, typename FillChar>\n  BasicWriter &operator<<(IntFormatSpec<T, Spec, FillChar> spec) {\n    internal::CharTraits<Char>::convert(FillChar());\n    write_int(spec.value(), spec);\n    return *this;\n  }\n\n  template <typename StrChar>\n  BasicWriter &operator<<(const StrFormatSpec<StrChar> &spec) {\n    const StrChar *s = spec.str();\n    write_str(s, std::char_traits<Char>::length(s), spec);\n    return *this;\n  }\n\n  void clear() FMT_NOEXCEPT { buffer_.clear(); }\n\n  Buffer<Char> &buffer() FMT_NOEXCEPT { return buffer_; }\n};\n\ntemplate <typename Char>\ntemplate <typename StrChar>\ntypename BasicWriter<Char>::CharPtr BasicWriter<Char>::write_str(\n      const StrChar *s, std::size_t size, const AlignSpec &spec) {\n  CharPtr out = CharPtr();\n  if (spec.width() > size) {\n    out = grow_buffer(spec.width());\n    Char fill = internal::CharTraits<Char>::cast(spec.fill());\n    if (spec.align() == ALIGN_RIGHT) {\n      std::uninitialized_fill_n(out, spec.width() - size, fill);\n      out += spec.width() - size;\n    } else if (spec.align() == ALIGN_CENTER) {\n      out = fill_padding(out, spec.width(), size, fill);\n    } else {\n      std::uninitialized_fill_n(out + size, spec.width() - size, fill);\n    }\n  } else {\n    out = grow_buffer(size);\n  }\n  std::uninitialized_copy(s, s + size, out);\n  return out;\n}\n\ntemplate <typename Char>\ntemplate <typename StrChar, typename Spec>\nvoid BasicWriter<Char>::write_str(\n    const internal::Arg::StringValue<StrChar> &s, const Spec &spec) {\n  // Check if StrChar is convertible to Char.\n  internal::CharTraits<Char>::convert(StrChar());\n  if (spec.type_ && spec.type_ != 's')\n    internal::report_unknown_type(spec.type_, \"string\");\n  const StrChar *str_value = s.value;\n  std::size_t str_size = s.size;\n  if (str_size == 0) {\n    if (!str_value) {\n      FMT_THROW(FormatError(\"string pointer is null\"));\n    }\n  }\n  std::size_t precision = static_cast<std::size_t>(spec.precision_);\n  if (spec.precision_ >= 0 && precision < str_size)\n    str_size = precision;\n  write_str(str_value, str_size, spec);\n}\n\ntemplate <typename Char>\ntypename BasicWriter<Char>::CharPtr\n  BasicWriter<Char>::fill_padding(\n    CharPtr buffer, unsigned total_size,\n    std::size_t content_size, wchar_t fill) {\n  std::size_t padding = total_size - content_size;\n  std::size_t left_padding = padding / 2;\n  Char fill_char = internal::CharTraits<Char>::cast(fill);\n  std::uninitialized_fill_n(buffer, left_padding, fill_char);\n  buffer += left_padding;\n  CharPtr content = buffer;\n  std::uninitialized_fill_n(buffer + content_size,\n                            padding - left_padding, fill_char);\n  return content;\n}\n\ntemplate <typename Char>\ntemplate <typename Spec>\ntypename BasicWriter<Char>::CharPtr\n  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    // Octal prefix '0' is counted as a digit, so ignore it if precision\n    // is specified.\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size =\n        prefix_size + internal::to_unsigned(spec.precision());\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    CharPtr result = prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size);\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    return result;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::uninitialized_fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::uninitialized_fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}\n\ntemplate <typename Char>\ntemplate <typename T, typename Spec>\nvoid BasicWriter<Char>::write_int(T value, Spec spec) {\n  unsigned prefix_size = 0;\n  typedef typename internal::IntTraits<T>::MainType UnsignedType;\n  UnsignedType abs_value = static_cast<UnsignedType>(value);\n  char prefix[4] = \"\";\n  if (internal::is_negative(value)) {\n    prefix[0] = '-';\n    ++prefix_size;\n    abs_value = 0 - abs_value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    prefix[0] = spec.flag(PLUS_FLAG) ? '+' : ' ';\n    ++prefix_size;\n  }\n  switch (spec.type()) {\n  case 0: case 'd': {\n    unsigned num_digits = internal::count_digits(abs_value);\n    CharPtr p = prepare_int_buffer(num_digits, spec, prefix, prefix_size) + 1;\n    internal::format_decimal(get(p), abs_value, 0);\n    break;\n  }\n  case 'x': case 'X': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG)) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = spec.type_prefix();\n    }\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 4) != 0);\n    Char *p = get(prepare_int_buffer(\n      num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    const char *digits = spec.type() == 'x' ?\n        \"0123456789abcdef\" : \"0123456789ABCDEF\";\n    do {\n      *p-- = digits[n & 0xf];\n    } while ((n >>= 4) != 0);\n    break;\n  }\n  case 'b': case 'B': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG)) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = spec.type_prefix();\n    }\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 1) != 0);\n    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    do {\n      *p-- = static_cast<Char>('0' + (n & 1));\n    } while ((n >>= 1) != 0);\n    break;\n  }\n  case 'o': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG))\n      prefix[prefix_size++] = '0';\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 3) != 0);\n    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    do {\n      *p-- = static_cast<Char>('0' + (n & 7));\n    } while ((n >>= 3) != 0);\n    break;\n  }\n  case 'n': {\n    unsigned num_digits = internal::count_digits(abs_value);\n    fmt::StringRef sep = \"\";\n#if !(defined(ANDROID) || defined(__ANDROID__))\n    sep = internal::thousands_sep(std::localeconv());\n#endif\n    unsigned size = static_cast<unsigned>(\n          num_digits + sep.size() * ((num_digits - 1) / 3));\n    CharPtr p = prepare_int_buffer(size, spec, prefix, prefix_size) + 1;\n    internal::format_decimal(get(p), abs_value, 0, internal::ThousandsSep(sep));\n    break;\n  }\n  default:\n    internal::report_unknown_type(\n      spec.type(), spec.flag(CHAR_FLAG) ? \"char\" : \"integer\");\n    break;\n  }\n}\n\ntemplate <typename Char>\ntemplate <typename T, typename Spec>\nvoid BasicWriter<Char>::write_double(T value, const Spec &spec) {\n  // Check type.\n  char type = spec.type();\n  bool upper = false;\n  switch (type) {\n  case 0:\n    type = 'g';\n    break;\n  case 'e': case 'f': case 'g': case 'a':\n    break;\n  case 'F':\n#if FMT_MSC_VER\n    // MSVC's printf doesn't support 'F'.\n    type = 'f';\n#endif\n    // Fall through.\n  case 'E': case 'G': case 'A':\n    upper = true;\n    break;\n  default:\n    internal::report_unknown_type(type, \"double\");\n    break;\n  }\n\n  char sign = 0;\n  // Use isnegative instead of value < 0 because the latter is always\n  // false for NaN.\n  if (internal::FPUtil::isnegative(static_cast<double>(value))) {\n    sign = '-';\n    value = -value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    sign = spec.flag(PLUS_FLAG) ? '+' : ' ';\n  }\n\n  if (internal::FPUtil::isnotanumber(value)) {\n    // Format NaN ourselves because sprintf's output is not consistent\n    // across platforms.\n    std::size_t nan_size = 4;\n    const char *nan = upper ? \" NAN\" : \" nan\";\n    if (!sign) {\n      --nan_size;\n      ++nan;\n    }\n    CharPtr out = write_str(nan, nan_size, spec);\n    if (sign)\n      *out = sign;\n    return;\n  }\n\n  if (internal::FPUtil::isinfinity(value)) {\n    // Format infinity ourselves because sprintf's output is not consistent\n    // across platforms.\n    std::size_t inf_size = 4;\n    const char *inf = upper ? \" INF\" : \" inf\";\n    if (!sign) {\n      --inf_size;\n      ++inf;\n    }\n    CharPtr out = write_str(inf, inf_size, spec);\n    if (sign)\n      *out = sign;\n    return;\n  }\n\n  std::size_t offset = buffer_.size();\n  unsigned width = spec.width();\n  if (sign) {\n    buffer_.reserve(buffer_.size() + (width > 1u ? width : 1u));\n    if (width > 0)\n      --width;\n    ++offset;\n  }\n\n  // Build format string.\n  enum { MAX_FORMAT_SIZE = 10}; // longest format: %#-*.*Lg\n  Char format[MAX_FORMAT_SIZE];\n  Char *format_ptr = format;\n  *format_ptr++ = '%';\n  unsigned width_for_sprintf = width;\n  if (spec.flag(HASH_FLAG))\n    *format_ptr++ = '#';\n  if (spec.align() == ALIGN_CENTER) {\n    width_for_sprintf = 0;\n  } else {\n    if (spec.align() == ALIGN_LEFT)\n      *format_ptr++ = '-';\n    if (width != 0)\n      *format_ptr++ = '*';\n  }\n  if (spec.precision() >= 0) {\n    *format_ptr++ = '.';\n    *format_ptr++ = '*';\n  }\n\n  append_float_length(format_ptr, value);\n  *format_ptr++ = type;\n  *format_ptr = '\\0';\n\n  // Format using snprintf.\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  unsigned n = 0;\n  Char *start = FMT_NULL;\n  for (;;) {\n    std::size_t buffer_size = buffer_.capacity() - offset;\n#if FMT_MSC_VER\n    // MSVC's vsnprintf_s doesn't work with zero size, so reserve\n    // space for at least one extra character to make the size non-zero.\n    // Note that the buffer's capacity will increase by more than 1.\n    if (buffer_size == 0) {\n      buffer_.reserve(offset + 1);\n      buffer_size = buffer_.capacity() - offset;\n    }\n#endif\n    start = &buffer_[offset];\n    int result = internal::CharTraits<Char>::format_float(\n        start, buffer_size, format, width_for_sprintf, spec.precision(), value);\n    if (result >= 0) {\n      n = internal::to_unsigned(result);\n      if (offset + n < buffer_.capacity())\n        break;  // The buffer is large enough - continue with formatting.\n      buffer_.reserve(offset + n + 1);\n    } else {\n      // If result is negative we ask to increase the capacity by at least 1,\n      // but as std::vector, the buffer grows exponentially.\n      buffer_.reserve(buffer_.capacity() + 1);\n    }\n  }\n  if (sign) {\n    if ((spec.align() != ALIGN_RIGHT && spec.align() != ALIGN_DEFAULT) ||\n        *start != ' ') {\n      *(start - 1) = sign;\n      sign = 0;\n    } else {\n      *(start - 1) = fill;\n    }\n    ++n;\n  }\n  if (spec.align() == ALIGN_CENTER && spec.width() > n) {\n    width = spec.width();\n    CharPtr p = grow_buffer(width);\n    std::memmove(get(p) + (width - n) / 2, get(p), n * sizeof(Char));\n    fill_padding(p, spec.width(), n, fill);\n    return;\n  }\n  if (spec.fill() != ' ' || sign) {\n    while (*start == ' ')\n      *start++ = fill;\n    if (sign)\n      *(start - 1) = sign;\n  }\n  grow_buffer(n);\n}\n\n/**\n  \\rst\n  This class template provides operations for formatting and writing data\n  into a character stream. The output is stored in a memory buffer that grows\n  dynamically.\n\n  You can use one of the following typedefs for common character types\n  and the standard allocator:\n\n  +---------------+-----------------------------------------------------+\n  | Type          | Definition                                          |\n  +===============+=====================================================+\n  | MemoryWriter  | BasicMemoryWriter<char, std::allocator<char>>       |\n  +---------------+-----------------------------------------------------+\n  | WMemoryWriter | BasicMemoryWriter<wchar_t, std::allocator<wchar_t>> |\n  +---------------+-----------------------------------------------------+\n\n  **Example**::\n\n     MemoryWriter out;\n     out << \"The answer is \" << 42 << \"\\n\";\n     out.write(\"({:+f}, {:+f})\", -3.14, 3.14);\n\n  This will write the following output to the ``out`` object:\n\n  .. code-block:: none\n\n     The answer is 42\n     (-3.140000, +3.140000)\n\n  The output can be converted to an ``std::string`` with ``out.str()`` or\n  accessed as a C string with ``out.c_str()``.\n  \\endrst\n */\ntemplate <typename Char, typename Allocator = std::allocator<Char> >\nclass BasicMemoryWriter : public BasicWriter<Char> {\n private:\n  internal::MemoryBuffer<Char, internal::INLINE_BUFFER_SIZE, Allocator> buffer_;\n\n public:\n  explicit BasicMemoryWriter(const Allocator& alloc = Allocator())\n    : BasicWriter<Char>(buffer_), buffer_(alloc) {}\n\n#if FMT_USE_RVALUE_REFERENCES\n  /**\n    \\rst\n    Constructs a :class:`fmt::BasicMemoryWriter` object moving the content\n    of the other object to it.\n    \\endrst\n   */\n  BasicMemoryWriter(BasicMemoryWriter &&other)\n    : BasicWriter<Char>(buffer_), buffer_(std::move(other.buffer_)) {\n  }\n\n  /**\n    \\rst\n    Moves the content of the other ``BasicMemoryWriter`` object to this one.\n    \\endrst\n   */\n  BasicMemoryWriter &operator=(BasicMemoryWriter &&other) {\n    buffer_ = std::move(other.buffer_);\n    return *this;\n  }\n#endif\n};\n\ntypedef BasicMemoryWriter<char> MemoryWriter;\ntypedef BasicMemoryWriter<wchar_t> WMemoryWriter;\n\n/**\n  \\rst\n  This class template provides operations for formatting and writing data\n  into a fixed-size array. For writing into a dynamically growing buffer\n  use :class:`fmt::BasicMemoryWriter`.\n\n  Any write method will throw ``std::runtime_error`` if the output doesn't fit\n  into the array.\n\n  You can use one of the following typedefs for common character types:\n\n  +--------------+---------------------------+\n  | Type         | Definition                |\n  +==============+===========================+\n  | ArrayWriter  | BasicArrayWriter<char>    |\n  +--------------+---------------------------+\n  | WArrayWriter | BasicArrayWriter<wchar_t> |\n  +--------------+---------------------------+\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicArrayWriter : public BasicWriter<Char> {\n private:\n  internal::FixedBuffer<Char> buffer_;\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the\n   given size.\n   \\endrst\n   */\n  BasicArrayWriter(Char *array, std::size_t size)\n    : BasicWriter<Char>(buffer_), buffer_(array, size) {}\n\n  /**\n   \\rst\n   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the\n   size known at compile time.\n   \\endrst\n   */\n  template <std::size_t SIZE>\n  explicit BasicArrayWriter(Char (&array)[SIZE])\n    : BasicWriter<Char>(buffer_), buffer_(array, SIZE) {}\n};\n\ntypedef BasicArrayWriter<char> ArrayWriter;\ntypedef BasicArrayWriter<wchar_t> WArrayWriter;\n\n// Reports a system error without throwing an exception.\n// Can be used to report errors from destructors.\nFMT_API void report_system_error(int error_code,\n                                 StringRef message) FMT_NOEXCEPT;\n\n#if FMT_USE_WINDOWS_H\n\n/** A Windows error. */\nclass WindowsError : public SystemError {\n private:\n  FMT_API void init(int error_code, CStringRef format_str, ArgList args);\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::WindowsError` object with the description\n   of the form\n\n   .. parsed-literal::\n     *<message>*: *<system-message>*\n\n   where *<message>* is the formatted message and *<system-message>* is the\n   system message corresponding to the error code.\n   *error_code* is a Windows error code as given by ``GetLastError``.\n   If *error_code* is not a valid error code such as -1, the system message\n   will look like \"error -1\".\n\n   **Example**::\n\n     // This throws a WindowsError with the description\n     //   cannot open file 'madeup': The system cannot find the file specified.\n     // or similar (system message may vary).\n     const char *filename = \"madeup\";\n     LPOFSTRUCT of = LPOFSTRUCT();\n     HFILE file = OpenFile(filename, &of, OF_READ);\n     if (file == HFILE_ERROR) {\n       throw fmt::WindowsError(GetLastError(),\n                               \"cannot open file '{}'\", filename);\n     }\n   \\endrst\n  */\n  WindowsError(int error_code, CStringRef message) {\n    init(error_code, message, ArgList());\n  }\n  FMT_VARIADIC_CTOR(WindowsError, init, int, CStringRef)\n};\n\n// Reports a Windows error without throwing an exception.\n// Can be used to report errors from destructors.\nFMT_API void report_windows_error(int error_code,\n                                  StringRef message) FMT_NOEXCEPT;\n\n#endif\n\nenum Color { BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE };\n\n/**\n  Formats a string and prints it to stdout using ANSI escape sequences\n  to specify color (experimental).\n  Example:\n    print_colored(fmt::RED, \"Elapsed time: {0:.2f} seconds\", 1.23);\n */\nFMT_API void print_colored(Color c, CStringRef format, ArgList args);\n\n/**\n  \\rst\n  Formats arguments and returns the result as a string.\n\n  **Example**::\n\n    std::string message = format(\"The answer is {}\", 42);\n  \\endrst\n*/\ninline std::string format(CStringRef format_str, ArgList args) {\n  MemoryWriter w;\n  w.write(format_str, args);\n  return w.str();\n}\n\ninline std::wstring format(WCStringRef format_str, ArgList args) {\n  WMemoryWriter w;\n  w.write(format_str, args);\n  return w.str();\n}\n\n/**\n  \\rst\n  Prints formatted data to the file *f*.\n\n  **Example**::\n\n    print(stderr, \"Don't {}!\", \"panic\");\n  \\endrst\n */\nFMT_API void print(std::FILE *f, CStringRef format_str, ArgList args);\n\n/**\n  \\rst\n  Prints formatted data to ``stdout``.\n\n  **Example**::\n\n    print(\"Elapsed time: {0:.2f} seconds\", 1.23);\n  \\endrst\n */\nFMT_API void print(CStringRef format_str, ArgList args);\n\n/**\n  Fast integer formatter.\n */\nclass FormatInt {\n private:\n  // Buffer should be large enough to hold all digits (digits10 + 1),\n  // a sign and a null character.\n  enum {BUFFER_SIZE = std::numeric_limits<ULongLong>::digits10 + 3};\n  mutable char buffer_[BUFFER_SIZE];\n  char *str_;\n\n  // Formats value in reverse and returns the number of digits.\n  char *format_decimal(ULongLong value) {\n    char *buffer_end = buffer_ + BUFFER_SIZE - 1;\n    while (value >= 100) {\n      // Integer division is slow so do it for a group of two digits instead\n      // of for every digit. The idea comes from the talk by Alexandrescu\n      // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n      unsigned index = static_cast<unsigned>((value % 100) * 2);\n      value /= 100;\n      *--buffer_end = internal::Data::DIGITS[index + 1];\n      *--buffer_end = internal::Data::DIGITS[index];\n    }\n    if (value < 10) {\n      *--buffer_end = static_cast<char>('0' + value);\n      return buffer_end;\n    }\n    unsigned index = static_cast<unsigned>(value * 2);\n    *--buffer_end = internal::Data::DIGITS[index + 1];\n    *--buffer_end = internal::Data::DIGITS[index];\n    return buffer_end;\n  }\n\n  void FormatSigned(LongLong value) {\n    ULongLong abs_value = static_cast<ULongLong>(value);\n    bool negative = value < 0;\n    if (negative)\n      abs_value = 0 - abs_value;\n    str_ = format_decimal(abs_value);\n    if (negative)\n      *--str_ = '-';\n  }\n\n public:\n  explicit FormatInt(int value) { FormatSigned(value); }\n  explicit FormatInt(long value) { FormatSigned(value); }\n  explicit FormatInt(LongLong value) { FormatSigned(value); }\n  explicit FormatInt(unsigned value) : str_(format_decimal(value)) {}\n  explicit FormatInt(unsigned long value) : str_(format_decimal(value)) {}\n  explicit FormatInt(ULongLong value) : str_(format_decimal(value)) {}\n\n  /** Returns the number of characters written to the output buffer. */\n  std::size_t size() const {\n    return internal::to_unsigned(buffer_ - str_ + BUFFER_SIZE - 1);\n  }\n\n  /**\n    Returns a pointer to the output buffer content. No terminating null\n    character is appended.\n   */\n  const char *data() const { return str_; }\n\n  /**\n    Returns a pointer to the output buffer content with terminating null\n    character appended.\n   */\n  const char *c_str() const {\n    buffer_[BUFFER_SIZE - 1] = '\\0';\n    return str_;\n  }\n\n  /**\n    \\rst\n    Returns the content of the output buffer as an ``std::string``.\n    \\endrst\n   */\n  std::string str() const { return std::string(str_, size()); }\n};\n\n// Formats a decimal integer value writing into buffer and returns\n// a pointer to the end of the formatted string. This function doesn't\n// write a terminating null character.\ntemplate <typename T>\ninline void format_decimal(char *&buffer, T value) {\n  typedef typename internal::IntTraits<T>::MainType MainType;\n  MainType abs_value = static_cast<MainType>(value);\n  if (internal::is_negative(value)) {\n    *buffer++ = '-';\n    abs_value = 0 - abs_value;\n  }\n  if (abs_value < 100) {\n    if (abs_value < 10) {\n      *buffer++ = static_cast<char>('0' + abs_value);\n      return;\n    }\n    unsigned index = static_cast<unsigned>(abs_value * 2);\n    *buffer++ = internal::Data::DIGITS[index];\n    *buffer++ = internal::Data::DIGITS[index + 1];\n    return;\n  }\n  unsigned num_digits = internal::count_digits(abs_value);\n  internal::format_decimal(buffer, abs_value, num_digits);\n  buffer += num_digits;\n}\n\n/**\n  \\rst\n  Returns a named argument for formatting functions.\n\n  **Example**::\n\n    print(\"Elapsed time: {s:.2f} seconds\", arg(\"s\", 1.23));\n\n  \\endrst\n */\ntemplate <typename T>\ninline internal::NamedArgWithType<char, T> arg(StringRef name, const T &arg) {\n  return internal::NamedArgWithType<char, T>(name, arg);\n}\n\ntemplate <typename T>\ninline internal::NamedArgWithType<wchar_t, T> arg(WStringRef name, const T &arg) {\n  return internal::NamedArgWithType<wchar_t, T>(name, arg);\n}\n\n// The following two functions are deleted intentionally to disable\n// nested named arguments as in ``format(\"{}\", arg(\"a\", arg(\"b\", 42)))``.\ntemplate <typename Char>\nvoid arg(StringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;\ntemplate <typename Char>\nvoid arg(WStringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;\n}\n\n#if FMT_GCC_VERSION\n// Use the system_header pragma to suppress warnings about variadic macros\n// because suppressing -Wvariadic-macros with the diagnostic pragma doesn't\n// work. It is used at the end because we want to suppress as little warnings\n// as possible.\n# pragma GCC system_header\n#endif\n\n// This is used to work around VC++ bugs in handling variadic macros.\n#define FMT_EXPAND(args) args\n\n// Returns the number of arguments.\n// Based on https://groups.google.com/forum/#!topic/comp.std.c/d-6Mj5Lko_s.\n#define FMT_NARG(...) FMT_NARG_(__VA_ARGS__, FMT_RSEQ_N())\n#define FMT_NARG_(...) FMT_EXPAND(FMT_ARG_N(__VA_ARGS__))\n#define FMT_ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define FMT_RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n\n#define FMT_FOR_EACH_(N, f, ...) \\\n  FMT_EXPAND(FMT_CONCAT(FMT_FOR_EACH, N)(f, __VA_ARGS__))\n#define FMT_FOR_EACH(f, ...) \\\n  FMT_EXPAND(FMT_FOR_EACH_(FMT_NARG(__VA_ARGS__), f, __VA_ARGS__))\n\n#define FMT_ADD_ARG_NAME(type, index) type arg##index\n#define FMT_GET_ARG_NAME(type, index) arg##index\n\n#if FMT_USE_VARIADIC_TEMPLATES\n# define FMT_VARIADIC_(Const, Char, ReturnType, func, call, ...) \\\n  template <typename... Args> \\\n  ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n      const Args & ... args) Const { \\\n    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \\\n    typename ArgArray::Type array{ \\\n      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), \\\n      fmt::ArgList(fmt::internal::make_type(args...), array)); \\\n  }\n#else\n// Defines a wrapper for a function taking __VA_ARGS__ arguments\n// and n additional arguments of arbitrary types.\n# define FMT_WRAP(Const, Char, ReturnType, func, call, n, ...) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n      FMT_GEN(n, FMT_MAKE_ARG)) Const { \\\n    fmt::internal::ArgArray<n>::Type arr; \\\n    FMT_GEN(n, FMT_ASSIGN_##Char); \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), arr)); \\\n  }\n\n# define FMT_VARIADIC_(Const, Char, ReturnType, func, call, ...) \\\n  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__)) Const { \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList()); \\\n  } \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 1, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 2, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 3, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 4, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 5, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 6, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 7, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 8, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 9, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 10, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 11, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 12, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 13, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 14, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 15, __VA_ARGS__)\n#endif  // FMT_USE_VARIADIC_TEMPLATES\n\n/**\n  \\rst\n  Defines a variadic function with the specified return type, function name\n  and argument types passed as variable arguments to this macro.\n\n  **Example**::\n\n    void print_error(const char *file, int line, const char *format,\n                     fmt::ArgList args) {\n      fmt::print(\"{}: {}: \", file, line);\n      fmt::print(format, args);\n    }\n    FMT_VARIADIC(void, print_error, const char *, int, const char *)\n\n  ``FMT_VARIADIC`` is used for compatibility with legacy C++ compilers that\n  don't implement variadic templates. You don't have to use this macro if\n  you don't need legacy compiler support and can use variadic templates\n  directly::\n\n    template <typename... Args>\n    void print_error(const char *file, int line, const char *format,\n                     const Args & ... args) {\n      fmt::print(\"{}: {}: \", file, line);\n      fmt::print(format, args...);\n    }\n  \\endrst\n */\n#define FMT_VARIADIC(ReturnType, func, ...) \\\n  FMT_VARIADIC_(, char, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_VARIADIC_CONST(ReturnType, func, ...) \\\n  FMT_VARIADIC_(const, char, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_VARIADIC_W(ReturnType, func, ...) \\\n  FMT_VARIADIC_(, wchar_t, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_VARIADIC_CONST_W(ReturnType, func, ...) \\\n  FMT_VARIADIC_(const, wchar_t, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_CAPTURE_ARG_(id, index) ::fmt::arg(#id, id)\n\n#define FMT_CAPTURE_ARG_W_(id, index) ::fmt::arg(L###id, id)\n\n/**\n  \\rst\n  Convenient macro to capture the arguments' names and values into several\n  ``fmt::arg(name, value)``.\n\n  **Example**::\n\n    int x = 1, y = 2;\n    print(\"point: ({x}, {y})\", FMT_CAPTURE(x, y));\n    // same as:\n    // print(\"point: ({x}, {y})\", arg(\"x\", x), arg(\"y\", y));\n\n  \\endrst\n */\n#define FMT_CAPTURE(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_, __VA_ARGS__)\n\n#define FMT_CAPTURE_W(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_W_, __VA_ARGS__)\n\nnamespace fmt {\nFMT_VARIADIC(std::string, format, CStringRef)\nFMT_VARIADIC_W(std::wstring, format, WCStringRef)\nFMT_VARIADIC(void, print, CStringRef)\nFMT_VARIADIC(void, print, std::FILE *, CStringRef)\nFMT_VARIADIC(void, print_colored, Color, CStringRef)\n\nnamespace internal {\ntemplate <typename Char>\ninline bool is_name_start(Char c) {\n  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || '_' == c;\n}\n\n// Parses an unsigned integer advancing s to the end of the parsed input.\n// This function assumes that the first character of s is a digit.\ntemplate <typename Char>\nunsigned parse_nonnegative_int(const Char *&s) {\n  assert('0' <= *s && *s <= '9');\n  unsigned value = 0;\n  // Convert to unsigned to prevent a warning.\n  unsigned max_int = (std::numeric_limits<int>::max)();\n  unsigned big = max_int / 10;\n  do {\n    // Check for overflow.\n    if (value > big) {\n      value = max_int + 1;\n      break;\n    }\n    value = value * 10 + (*s - '0');\n    ++s;\n  } while ('0' <= *s && *s <= '9');\n  // Convert to unsigned to prevent a warning.\n  if (value > max_int)\n    FMT_THROW(FormatError(\"number is too big\"));\n  return value;\n}\n\ninline void require_numeric_argument(const Arg &arg, char spec) {\n  if (arg.type > Arg::LAST_NUMERIC_TYPE) {\n    std::string message =\n        fmt::format(\"format specifier '{}' requires numeric argument\", spec);\n    FMT_THROW(fmt::FormatError(message));\n  }\n}\n\ntemplate <typename Char>\nvoid check_sign(const Char *&s, const Arg &arg) {\n  char sign = static_cast<char>(*s);\n  require_numeric_argument(arg, sign);\n  if (arg.type == Arg::UINT || arg.type == Arg::ULONG_LONG) {\n    FMT_THROW(FormatError(fmt::format(\n      \"format specifier '{}' requires signed argument\", sign)));\n  }\n  ++s;\n}\n}  // namespace internal\n\ntemplate <typename Char, typename AF>\ninline internal::Arg BasicFormatter<Char, AF>::get_arg(\n    BasicStringRef<Char> arg_name, const char *&error) {\n  if (check_no_auto_index(error)) {\n    map_.init(args());\n    const internal::Arg *arg = map_.find(arg_name);\n    if (arg)\n      return *arg;\n    error = \"argument not found\";\n  }\n  return internal::Arg();\n}\n\ntemplate <typename Char, typename AF>\ninline internal::Arg BasicFormatter<Char, AF>::parse_arg_index(const Char *&s) {\n  const char *error = FMT_NULL;\n  internal::Arg arg = *s < '0' || *s > '9' ?\n        next_arg(error) : get_arg(internal::parse_nonnegative_int(s), error);\n  if (error) {\n    FMT_THROW(FormatError(\n                *s != '}' && *s != ':' ? \"invalid format string\" : error));\n  }\n  return arg;\n}\n\ntemplate <typename Char, typename AF>\ninline internal::Arg BasicFormatter<Char, AF>::parse_arg_name(const Char *&s) {\n  assert(internal::is_name_start(*s));\n  const Char *start = s;\n  Char c;\n  do {\n    c = *++s;\n  } while (internal::is_name_start(c) || ('0' <= c && c <= '9'));\n  const char *error = FMT_NULL;\n  internal::Arg arg = get_arg(BasicStringRef<Char>(start, s - start), error);\n  if (error)\n    FMT_THROW(FormatError(error));\n  return arg;\n}\n\ntemplate <typename Char, typename ArgFormatter>\nconst Char *BasicFormatter<Char, ArgFormatter>::format(\n    const Char *&format_str, const internal::Arg &arg) {\n  using internal::Arg;\n  const Char *s = format_str;\n  typename ArgFormatter::SpecType spec;\n  if (*s == ':') {\n    if (arg.type == Arg::CUSTOM) {\n      arg.custom.format(this, arg.custom.value, &s);\n      return s;\n    }\n    ++s;\n    // Parse fill and alignment.\n    if (Char c = *s) {\n      const Char *p = s + 1;\n      spec.align_ = ALIGN_DEFAULT;\n      do {\n        switch (*p) {\n          case '<':\n            spec.align_ = ALIGN_LEFT;\n            break;\n          case '>':\n            spec.align_ = ALIGN_RIGHT;\n            break;\n          case '=':\n            spec.align_ = ALIGN_NUMERIC;\n            break;\n          case '^':\n            spec.align_ = ALIGN_CENTER;\n            break;\n        }\n        if (spec.align_ != ALIGN_DEFAULT) {\n          if (p != s) {\n            if (c == '}') break;\n            if (c == '{')\n              FMT_THROW(FormatError(\"invalid fill character '{'\"));\n            s += 2;\n            spec.fill_ = c;\n          } else ++s;\n          if (spec.align_ == ALIGN_NUMERIC)\n            require_numeric_argument(arg, '=');\n          break;\n        }\n      } while (--p >= s);\n    }\n\n    // Parse sign.\n    switch (*s) {\n      case '+':\n        check_sign(s, arg);\n        spec.flags_ |= SIGN_FLAG | PLUS_FLAG;\n        break;\n      case '-':\n        check_sign(s, arg);\n        spec.flags_ |= MINUS_FLAG;\n        break;\n      case ' ':\n        check_sign(s, arg);\n        spec.flags_ |= SIGN_FLAG;\n        break;\n    }\n\n    if (*s == '#') {\n      require_numeric_argument(arg, '#');\n      spec.flags_ |= HASH_FLAG;\n      ++s;\n    }\n\n    // Parse zero flag.\n    if (*s == '0') {\n      require_numeric_argument(arg, '0');\n      spec.align_ = ALIGN_NUMERIC;\n      spec.fill_ = '0';\n      ++s;\n    }\n\n    // Parse width.\n    if ('0' <= *s && *s <= '9') {\n      spec.width_ = internal::parse_nonnegative_int(s);\n    } else if (*s == '{') {\n      ++s;\n      Arg width_arg = internal::is_name_start(*s) ?\n            parse_arg_name(s) : parse_arg_index(s);\n      if (*s++ != '}')\n        FMT_THROW(FormatError(\"invalid format string\"));\n      ULongLong value = 0;\n      switch (width_arg.type) {\n      case Arg::INT:\n        if (width_arg.int_value < 0)\n          FMT_THROW(FormatError(\"negative width\"));\n        value = width_arg.int_value;\n        break;\n      case Arg::UINT:\n        value = width_arg.uint_value;\n        break;\n      case Arg::LONG_LONG:\n        if (width_arg.long_long_value < 0)\n          FMT_THROW(FormatError(\"negative width\"));\n        value = width_arg.long_long_value;\n        break;\n      case Arg::ULONG_LONG:\n        value = width_arg.ulong_long_value;\n        break;\n      default:\n        FMT_THROW(FormatError(\"width is not integer\"));\n      }\n      unsigned max_int = (std::numeric_limits<int>::max)();\n      if (value > max_int)\n        FMT_THROW(FormatError(\"number is too big\"));\n      spec.width_ = static_cast<int>(value);\n    }\n\n    // Parse precision.\n    if (*s == '.') {\n      ++s;\n      spec.precision_ = 0;\n      if ('0' <= *s && *s <= '9') {\n        spec.precision_ = internal::parse_nonnegative_int(s);\n      } else if (*s == '{') {\n        ++s;\n        Arg precision_arg = internal::is_name_start(*s) ?\n              parse_arg_name(s) : parse_arg_index(s);\n        if (*s++ != '}')\n          FMT_THROW(FormatError(\"invalid format string\"));\n        ULongLong value = 0;\n        switch (precision_arg.type) {\n          case Arg::INT:\n            if (precision_arg.int_value < 0)\n              FMT_THROW(FormatError(\"negative precision\"));\n            value = precision_arg.int_value;\n            break;\n          case Arg::UINT:\n            value = precision_arg.uint_value;\n            break;\n          case Arg::LONG_LONG:\n            if (precision_arg.long_long_value < 0)\n              FMT_THROW(FormatError(\"negative precision\"));\n            value = precision_arg.long_long_value;\n            break;\n          case Arg::ULONG_LONG:\n            value = precision_arg.ulong_long_value;\n            break;\n          default:\n            FMT_THROW(FormatError(\"precision is not integer\"));\n        }\n        unsigned max_int = (std::numeric_limits<int>::max)();\n        if (value > max_int)\n          FMT_THROW(FormatError(\"number is too big\"));\n        spec.precision_ = static_cast<int>(value);\n      } else {\n        FMT_THROW(FormatError(\"missing precision specifier\"));\n      }\n      if (arg.type <= Arg::LAST_INTEGER_TYPE || arg.type == Arg::POINTER) {\n        FMT_THROW(FormatError(\n            fmt::format(\"precision not allowed in {} format specifier\",\n            arg.type == Arg::POINTER ? \"pointer\" : \"integer\")));\n      }\n    }\n\n    // Parse type.\n    if (*s != '}' && *s)\n      spec.type_ = static_cast<char>(*s++);\n  }\n\n  if (*s++ != '}')\n    FMT_THROW(FormatError(\"missing '}' in format string\"));\n\n  // Format argument.\n  ArgFormatter(*this, spec, s - 1).visit(arg);\n  return s;\n}\n\ntemplate <typename Char, typename AF>\nvoid BasicFormatter<Char, AF>::format(BasicCStringRef<Char> format_str) {\n  const Char *s = format_str.c_str();\n  const Char *start = s;\n  while (*s) {\n    Char c = *s++;\n    if (c != '{' && c != '}') continue;\n    if (*s == c) {\n      write(writer_, start, s);\n      start = ++s;\n      continue;\n    }\n    if (c == '}')\n      FMT_THROW(FormatError(\"unmatched '}' in format string\"));\n    write(writer_, start, s - 1);\n    internal::Arg arg = internal::is_name_start(*s) ?\n          parse_arg_name(s) : parse_arg_index(s);\n    start = s = format(s, arg);\n  }\n  write(writer_, start, s);\n}\n\ntemplate <typename Char, typename It>\nstruct ArgJoin {\n  It first;\n  It last;\n  BasicCStringRef<Char> sep;\n\n  ArgJoin(It first, It last, const BasicCStringRef<Char>& sep) :\n    first(first),\n    last(last),\n    sep(sep) {}\n};\n\ntemplate <typename It>\nArgJoin<char, It> join(It first, It last, const BasicCStringRef<char>& sep) {\n  return ArgJoin<char, It>(first, last, sep);\n}\n\ntemplate <typename It>\nArgJoin<wchar_t, It> join(It first, It last, const BasicCStringRef<wchar_t>& sep) {\n  return ArgJoin<wchar_t, It>(first, last, sep);\n}\n\n#if FMT_HAS_GXX_CXX11\ntemplate <typename Range>\nauto join(const Range& range, const BasicCStringRef<char>& sep)\n    -> ArgJoin<char, decltype(std::begin(range))> {\n  return join(std::begin(range), std::end(range), sep);\n}\n\ntemplate <typename Range>\nauto join(const Range& range, const BasicCStringRef<wchar_t>& sep)\n    -> ArgJoin<wchar_t, decltype(std::begin(range))> {\n  return join(std::begin(range), std::end(range), sep);\n}\n#endif\n\ntemplate <typename ArgFormatter, typename Char, typename It>\nvoid format_arg(fmt::BasicFormatter<Char, ArgFormatter> &f,\n    const Char *&format_str, const ArgJoin<Char, It>& e) {\n  const Char* end = format_str;\n  int brace_level = 1;\n  while (*end) {\n    if (*end == '}' && --brace_level == 0)\n      break;\n    if (*end == '{')\n      ++brace_level;\n    ++end;\n  }\n  if (*end != '}')\n    FMT_THROW(FormatError(\"missing '}' in format string\"));\n\n  It it = e.first;\n  if (it != e.last) {\n    const Char* save = format_str;\n    f.format(format_str, internal::MakeArg<fmt::BasicFormatter<Char, ArgFormatter> >(*it++));\n    while (it != e.last) {\n      f.writer().write(e.sep);\n      format_str = save;\n      f.format(format_str, internal::MakeArg<fmt::BasicFormatter<Char, ArgFormatter> >(*it++));\n    }\n  }\n  format_str = end + 1;\n}\n}  // namespace fmt\n\n#if FMT_USE_USER_DEFINED_LITERALS\nnamespace fmt {\nnamespace internal {\n\ntemplate <typename Char>\nstruct UdlFormat {\n  const Char *str;\n\n  template <typename... Args>\n  auto operator()(Args && ... args) const\n                  -> decltype(format(str, std::forward<Args>(args)...)) {\n    return format(str, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <typename Char>\nstruct UdlArg {\n  const Char *str;\n\n  template <typename T>\n  NamedArgWithType<Char, T> operator=(T &&value) const {\n    return {str, std::forward<T>(value)};\n  }\n};\n\n} // namespace internal\n\ninline namespace literals {\n\n/**\n  \\rst\n  C++11 literal equivalent of :func:`fmt::format`.\n\n  **Example**::\n\n    using namespace fmt::literals;\n    std::string message = \"The answer is {}\"_format(42);\n  \\endrst\n */\ninline internal::UdlFormat<char>\noperator\"\" _format(const char *s, std::size_t) { return {s}; }\ninline internal::UdlFormat<wchar_t>\noperator\"\" _format(const wchar_t *s, std::size_t) { return {s}; }\n\n/**\n  \\rst\n  C++11 literal equivalent of :func:`fmt::arg`.\n\n  **Example**::\n\n    using namespace fmt::literals;\n    print(\"Elapsed time: {s:.2f} seconds\", \"s\"_a=1.23);\n  \\endrst\n */\ninline internal::UdlArg<char>\noperator\"\" _a(const char *s, std::size_t) { return {s}; }\ninline internal::UdlArg<wchar_t>\noperator\"\" _a(const wchar_t *s, std::size_t) { return {s}; }\n\n} // inline namespace literals\n} // namespace fmt\n#endif // FMT_USE_USER_DEFINED_LITERALS\n\n// Restore warnings.\n#if FMT_GCC_VERSION >= 406\n# pragma GCC diagnostic pop\n#endif\n\n#if defined(__clang__) && !defined(FMT_ICC_VERSION)\n# pragma clang diagnostic pop\n#endif\n\n#ifdef FMT_HEADER_ONLY\n# define FMT_FUNC inline\n# include \"format.cc\"\n#else\n# define FMT_FUNC\n#endif\n\n#endif  // FMT_FORMAT_H_\n", "/*\n Formatting library tests.\n\n Copyright (c) 2012-2014, Victor Zverovich\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <cctype>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <cstring>\n#include <memory>\n#include <stdint.h>\n\n#if FMT_USE_TYPE_TRAITS\n# include <type_traits>\n#endif\n\n#include \"gmock/gmock.h\"\n\n// Test that the library compiles if None is defined to 0 as done by xlib.h.\n#define None 0\n\nstruct LocaleMock {\n  static LocaleMock *instance;\n\n  MOCK_METHOD0(localeconv, lconv *());\n} *LocaleMock::instance;\n\nnamespace fmt {\nnamespace std {\nusing namespace ::std;\nlconv *localeconv() {\n  return LocaleMock::instance ?\n        LocaleMock::instance->localeconv() : ::std::localeconv();\n}\n}\n}\n\n#include \"fmt/format.h\"\n\n#include \"util.h\"\n#include \"mock-allocator.h\"\n#include \"gtest-extra.h\"\n\n#undef min\n#undef max\n\nusing std::size_t;\n\nusing fmt::BasicWriter;\nusing fmt::format;\nusing fmt::FormatError;\nusing fmt::StringRef;\nusing fmt::CStringRef;\nusing fmt::MemoryWriter;\nusing fmt::WMemoryWriter;\nusing fmt::pad;\n\nnamespace {\n\n// Format value using the standard library.\ntemplate <typename Char, typename T>\nvoid std_format(const T &value, std::basic_string<Char> &result) {\n  std::basic_ostringstream<Char> os;\n  os << value;\n  result = os.str();\n}\n\n#ifdef __MINGW32__\n// Workaround a bug in formatting long double in MinGW.\nvoid std_format(long double value, std::string &result) {\n  char buffer[100];\n  safe_sprintf(buffer, \"%Lg\", value);\n  result = buffer;\n}\nvoid std_format(long double value, std::wstring &result) {\n  wchar_t buffer[100];\n  swprintf(buffer, L\"%Lg\", value);\n  result = buffer;\n}\n#endif\n\n// Checks if writing value to BasicWriter<Char> produces the same result\n// as writing it to std::basic_ostringstream<Char>.\ntemplate <typename Char, typename T>\n::testing::AssertionResult check_write(const T &value, const char *type) {\n  std::basic_string<Char> actual =\n      (fmt::BasicMemoryWriter<Char>() << value).str();\n  std::basic_string<Char> expected;\n  std_format(value, expected);\n  if (expected == actual)\n    return ::testing::AssertionSuccess();\n  return ::testing::AssertionFailure()\n      << \"Value of: (Writer<\" << type << \">() << value).str()\\n\"\n      << \"  Actual: \" << actual << \"\\n\"\n      << \"Expected: \" << expected << \"\\n\";\n}\n\nstruct AnyWriteChecker {\n  template <typename T>\n  ::testing::AssertionResult operator()(const char *, const T &value) const {\n    ::testing::AssertionResult result = check_write<char>(value, \"char\");\n    return result ? check_write<wchar_t>(value, \"wchar_t\") : result;\n  }\n};\n\ntemplate <typename Char>\nstruct WriteChecker {\n  template <typename T>\n  ::testing::AssertionResult operator()(const char *, const T &value) const {\n    return check_write<Char>(value, \"char\");\n  }\n};\n\n// Checks if writing value to BasicWriter produces the same result\n// as writing it to std::ostringstream both for char and wchar_t.\n#define CHECK_WRITE(value) EXPECT_PRED_FORMAT1(AnyWriteChecker(), value)\n\n#define CHECK_WRITE_CHAR(value) \\\n  EXPECT_PRED_FORMAT1(WriteChecker<char>(), value)\n#define CHECK_WRITE_WCHAR(value) \\\n  EXPECT_PRED_FORMAT1(WriteChecker<wchar_t>(), value)\n}  // namespace\n\nTEST(StringRefTest, Ctor) {\n  EXPECT_STREQ(\"abc\", StringRef(\"abc\").data());\n  EXPECT_EQ(3u, StringRef(\"abc\").size());\n\n  EXPECT_STREQ(\"defg\", StringRef(std::string(\"defg\")).data());\n  EXPECT_EQ(4u, StringRef(std::string(\"defg\")).size());\n\n#if FMT_HAS_STRING_VIEW\n  EXPECT_STREQ(\"hijk\", StringRef(std::string_view(\"hijk\")).data());\n  EXPECT_EQ(4u, StringRef(std::string_view(\"hijk\")).size());\n#endif\n\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  EXPECT_STREQ(\"hijk\", StringRef(std::experimental::string_view(\"hijk\")).data());\n  EXPECT_EQ(4u, StringRef(std::experimental::string_view(\"hijk\")).size());\n#endif\n}\n\nTEST(StringRefTest, ConvertToString) {\n  std::string s = StringRef(\"abc\").to_string();\n  EXPECT_EQ(\"abc\", s);\n\n#if FMT_HAS_STRING_VIEW\n  StringRef str_ref(\"defg\");\n  std::string_view sv = static_cast<std::string_view>(str_ref);\n  EXPECT_EQ(\"defg\", sv);\n#endif\n\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  StringRef str_ref(\"defg\");\n  std::experimental::string_view sv = static_cast<std::experimental::string_view>(str_ref);\n  EXPECT_EQ(\"defg\", sv);\n#endif\n}\n\nTEST(CStringRefTest, Ctor) {\n  EXPECT_STREQ(\"abc\", CStringRef(\"abc\").c_str());\n  EXPECT_STREQ(\"defg\", CStringRef(std::string(\"defg\")).c_str());\n\n#if FMT_HAS_STRING_VIEW\n  EXPECT_STREQ(\"hijk\", CStringRef(std::string_view(\"hijk\")).c_str());\n#endif\n\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  EXPECT_STREQ(\"hijk\", CStringRef(std::experimental::string_view(\"hijk\")).c_str());\n#endif\n}\n\n#if FMT_USE_TYPE_TRAITS\nTEST(WriterTest, NotCopyConstructible) {\n  EXPECT_FALSE(std::is_copy_constructible<BasicWriter<char> >::value);\n}\n\nTEST(WriterTest, NotCopyAssignable) {\n  EXPECT_FALSE(std::is_copy_assignable<BasicWriter<char> >::value);\n}\n#endif\n\nTEST(WriterTest, Ctor) {\n  MemoryWriter w;\n  EXPECT_EQ(0u, w.size());\n  EXPECT_STREQ(\"\", w.c_str());\n  EXPECT_EQ(\"\", w.str());\n}\n\n#if FMT_USE_RVALUE_REFERENCES\n\nvoid check_move_writer(const std::string &str, MemoryWriter &w) {\n  MemoryWriter w2(std::move(w));\n  // Move shouldn't destroy the inline content of the first writer.\n  EXPECT_EQ(str, w.str());\n  EXPECT_EQ(str, w2.str());\n}\n\nTEST(WriterTest, MoveCtor) {\n  MemoryWriter w;\n  w << \"test\";\n  check_move_writer(\"test\", w);\n  // This fills the inline buffer, but doesn't cause dynamic allocation.\n  std::string s;\n  for (int i = 0; i < fmt::internal::INLINE_BUFFER_SIZE; ++i)\n    s += '*';\n  w.clear();\n  w << s;\n  check_move_writer(s, w);\n  const char *inline_buffer_ptr = w.data();\n  // Adding one more character causes the content to move from the inline to\n  // a dynamically allocated buffer.\n  w << '*';\n  MemoryWriter w2(std::move(w));\n  // Move should rip the guts of the first writer.\n  EXPECT_EQ(inline_buffer_ptr, w.data());\n  EXPECT_EQ(s + '*', w2.str());\n}\n\nvoid CheckMoveAssignWriter(const std::string &str, MemoryWriter &w) {\n  MemoryWriter w2;\n  w2 = std::move(w);\n  // Move shouldn't destroy the inline content of the first writer.\n  EXPECT_EQ(str, w.str());\n  EXPECT_EQ(str, w2.str());\n}\n\nTEST(WriterTest, MoveAssignment) {\n  MemoryWriter w;\n  w << \"test\";\n  CheckMoveAssignWriter(\"test\", w);\n  // This fills the inline buffer, but doesn't cause dynamic allocation.\n  std::string s;\n  for (int i = 0; i < fmt::internal::INLINE_BUFFER_SIZE; ++i)\n    s += '*';\n  w.clear();\n  w << s;\n  CheckMoveAssignWriter(s, w);\n  const char *inline_buffer_ptr = w.data();\n  // Adding one more character causes the content to move from the inline to\n  // a dynamically allocated buffer.\n  w << '*';\n  MemoryWriter w2;\n  w2 = std::move(w);\n  // Move should rip the guts of the first writer.\n  EXPECT_EQ(inline_buffer_ptr, w.data());\n  EXPECT_EQ(s + '*', w2.str());\n}\n\n#endif  // FMT_USE_RVALUE_REFERENCES\n\nTEST(WriterTest, Allocator) {\n  typedef testing::StrictMock< MockAllocator<char> > MockAllocator;\n  typedef AllocatorRef<MockAllocator> TestAllocator;\n  MockAllocator alloc;\n  fmt::BasicMemoryWriter<char, TestAllocator> w((TestAllocator(&alloc)));\n  std::size_t size =\n      static_cast<std::size_t>(1.5 * fmt::internal::INLINE_BUFFER_SIZE);\n  std::vector<char> mem(size);\n  EXPECT_CALL(alloc, allocate(size, 0)).WillOnce(testing::Return(&mem[0]));\n  for (int i = 0; i < fmt::internal::INLINE_BUFFER_SIZE + 1; ++i)\n    w << '*';\n  EXPECT_CALL(alloc, deallocate(&mem[0], size));\n}\n\nTEST(WriterTest, Data) {\n  MemoryWriter w;\n  w << 42;\n  EXPECT_EQ(\"42\", std::string(w.data(), w.size()));\n}\n\nTEST(WriterTest, WriteWithoutArgs) {\n  MemoryWriter w;\n  w.write(\"test\");\n  EXPECT_EQ(\"test\", std::string(w.data(), w.size()));\n}\n\nTEST(WriterTest, WriteInt) {\n  CHECK_WRITE(42);\n  CHECK_WRITE(-42);\n  CHECK_WRITE(static_cast<short>(12));\n  CHECK_WRITE(34u);\n  CHECK_WRITE(std::numeric_limits<int>::min());\n  CHECK_WRITE(std::numeric_limits<int>::max());\n  CHECK_WRITE(std::numeric_limits<unsigned>::max());\n}\n\nTEST(WriterTest, WriteLong) {\n  CHECK_WRITE(56l);\n  CHECK_WRITE(78ul);\n  CHECK_WRITE(std::numeric_limits<long>::min());\n  CHECK_WRITE(std::numeric_limits<long>::max());\n  CHECK_WRITE(std::numeric_limits<unsigned long>::max());\n}\n\nTEST(WriterTest, WriteLongLong) {\n  CHECK_WRITE(56ll);\n  CHECK_WRITE(78ull);\n  CHECK_WRITE(std::numeric_limits<long long>::min());\n  CHECK_WRITE(std::numeric_limits<long long>::max());\n  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());\n}\n\nTEST(WriterTest, WriteDouble) {\n  CHECK_WRITE(4.2);\n  CHECK_WRITE(-4.2);\n  CHECK_WRITE(std::numeric_limits<double>::min());\n  CHECK_WRITE(std::numeric_limits<double>::max());\n}\n\nTEST(WriterTest, WriteLongDouble) {\n  CHECK_WRITE(4.2l);\n  CHECK_WRITE_CHAR(-4.2l);\n  std::wstring str;\n  std_format(4.2l, str);\n  if (str[0] != '-')\n    CHECK_WRITE_WCHAR(-4.2l);\n  else\n    fmt::print(\"warning: long double formatting with std::swprintf is broken\");\n  CHECK_WRITE(std::numeric_limits<long double>::min());\n  CHECK_WRITE(std::numeric_limits<long double>::max());\n}\n\nTEST(WriterTest, WriteDoubleAtBufferBoundary) {\n  MemoryWriter writer;\n  for (int i = 0; i < 100; ++i)\n    writer << 1.23456789;\n}\n\nTEST(WriterTest, WriteDoubleWithFilledBuffer) {\n  MemoryWriter writer;\n  // Fill the buffer.\n  for (int i = 0; i < fmt::internal::INLINE_BUFFER_SIZE; ++i)\n    writer << ' ';\n  writer << 1.2;\n  EXPECT_STREQ(\"1.2\", writer.c_str() + fmt::internal::INLINE_BUFFER_SIZE);\n}\n\nTEST(WriterTest, WriteChar) {\n  CHECK_WRITE('a');\n}\n\nTEST(WriterTest, WriteWideChar) {\n  CHECK_WRITE_WCHAR(L'a');\n}\n\nTEST(WriterTest, WriteString) {\n  CHECK_WRITE_CHAR(\"abc\");\n  CHECK_WRITE_WCHAR(\"abc\");\n  // The following line shouldn't compile:\n  //MemoryWriter() << L\"abc\";\n}\n\nTEST(WriterTest, WriteWideString) {\n  CHECK_WRITE_WCHAR(L\"abc\");\n  // The following line shouldn't compile:\n  //fmt::WMemoryWriter() << \"abc\";\n}\n\nTEST(WriterTest, bin) {\n  using fmt::bin;\n  EXPECT_EQ(\"1100101011111110\", (MemoryWriter() << bin(0xcafe)).str());\n  EXPECT_EQ(\"1011101010111110\", (MemoryWriter() << bin(0xbabeu)).str());\n  EXPECT_EQ(\"1101111010101101\", (MemoryWriter() << bin(0xdeadl)).str());\n  EXPECT_EQ(\"1011111011101111\", (MemoryWriter() << bin(0xbeeful)).str());\n  EXPECT_EQ(\"11001010111111101011101010111110\",\n            (MemoryWriter() << bin(0xcafebabell)).str());\n  EXPECT_EQ(\"11011110101011011011111011101111\",\n            (MemoryWriter() << bin(0xdeadbeefull)).str());\n}\n\nTEST(WriterTest, oct) {\n  using fmt::oct;\n  EXPECT_EQ(\"12\", (MemoryWriter() << oct(static_cast<short>(012))).str());\n  EXPECT_EQ(\"12\", (MemoryWriter() << oct(012)).str());\n  EXPECT_EQ(\"34\", (MemoryWriter() << oct(034u)).str());\n  EXPECT_EQ(\"56\", (MemoryWriter() << oct(056l)).str());\n  EXPECT_EQ(\"70\", (MemoryWriter() << oct(070ul)).str());\n  EXPECT_EQ(\"1234\", (MemoryWriter() << oct(01234ll)).str());\n  EXPECT_EQ(\"5670\", (MemoryWriter() << oct(05670ull)).str());\n}\n\nTEST(WriterTest, hex) {\n  using fmt::hex;\n  fmt::IntFormatSpec<int, fmt::TypeSpec<'x'> > (*phex)(int value) = hex;\n  phex(42);\n  // This shouldn't compile:\n  //fmt::IntFormatSpec<short, fmt::TypeSpec<'x'> > (*phex2)(short value) = hex;\n\n  EXPECT_EQ(\"cafe\", (MemoryWriter() << hex(0xcafe)).str());\n  EXPECT_EQ(\"babe\", (MemoryWriter() << hex(0xbabeu)).str());\n  EXPECT_EQ(\"dead\", (MemoryWriter() << hex(0xdeadl)).str());\n  EXPECT_EQ(\"beef\", (MemoryWriter() << hex(0xbeeful)).str());\n  EXPECT_EQ(\"cafebabe\", (MemoryWriter() << hex(0xcafebabell)).str());\n  EXPECT_EQ(\"deadbeef\", (MemoryWriter() << hex(0xdeadbeefull)).str());\n}\n\nTEST(WriterTest, hexu) {\n  using fmt::hexu;\n  EXPECT_EQ(\"CAFE\", (MemoryWriter() << hexu(0xcafe)).str());\n  EXPECT_EQ(\"BABE\", (MemoryWriter() << hexu(0xbabeu)).str());\n  EXPECT_EQ(\"DEAD\", (MemoryWriter() << hexu(0xdeadl)).str());\n  EXPECT_EQ(\"BEEF\", (MemoryWriter() << hexu(0xbeeful)).str());\n  EXPECT_EQ(\"CAFEBABE\", (MemoryWriter() << hexu(0xcafebabell)).str());\n  EXPECT_EQ(\"DEADBEEF\", (MemoryWriter() << hexu(0xdeadbeefull)).str());\n}\n\ntemplate <typename Char>\nBasicWriter<Char> &operator<<(BasicWriter<Char> &f, const Date &d) {\n  return f << d.year() << '-' << d.month() << '-' << d.day();\n}\n\nclass ISO8601DateFormatter {\n const Date *date_;\n\npublic:\n  ISO8601DateFormatter(const Date &d) : date_(&d) {}\n\n  template <typename Char>\n  friend BasicWriter<Char> &operator<<(\n      BasicWriter<Char> &w, const ISO8601DateFormatter &d) {\n    return w << pad(d.date_->year(), 4, '0') << '-'\n        << pad(d.date_->month(), 2, '0') << '-' << pad(d.date_->day(), 2, '0');\n  }\n};\n\nISO8601DateFormatter iso8601(const Date &d) { return ISO8601DateFormatter(d); }\n\nTEST(WriterTest, pad) {\n  using fmt::hex;\n  EXPECT_EQ(\"    cafe\", (MemoryWriter() << pad(hex(0xcafe), 8)).str());\n  EXPECT_EQ(\"    babe\", (MemoryWriter() << pad(hex(0xbabeu), 8)).str());\n  EXPECT_EQ(\"    dead\", (MemoryWriter() << pad(hex(0xdeadl), 8)).str());\n  EXPECT_EQ(\"    beef\", (MemoryWriter() << pad(hex(0xbeeful), 8)).str());\n  EXPECT_EQ(\"    dead\", (MemoryWriter() << pad(hex(0xdeadll), 8)).str());\n  EXPECT_EQ(\"    beef\", (MemoryWriter() << pad(hex(0xbeefull), 8)).str());\n\n  EXPECT_EQ(\"     11\", (MemoryWriter() << pad(11, 7)).str());\n  EXPECT_EQ(\"     22\", (MemoryWriter() << pad(22u, 7)).str());\n  EXPECT_EQ(\"     33\", (MemoryWriter() << pad(33l, 7)).str());\n  EXPECT_EQ(\"     44\", (MemoryWriter() << pad(44ul, 7)).str());\n  EXPECT_EQ(\"     33\", (MemoryWriter() << pad(33ll, 7)).str());\n  EXPECT_EQ(\"     44\", (MemoryWriter() << pad(44ull, 7)).str());\n\n  MemoryWriter w;\n  w.clear();\n  w << pad(42, 5, '0');\n  EXPECT_EQ(\"00042\", w.str());\n  w.clear();\n  w << Date(2012, 12, 9);\n  EXPECT_EQ(\"2012-12-9\", w.str());\n  w.clear();\n  w << iso8601(Date(2012, 1, 9));\n  EXPECT_EQ(\"2012-01-09\", w.str());\n}\n\nTEST(WriterTest, PadString) {\n  EXPECT_EQ(\"test    \", (MemoryWriter() << pad(\"test\", 8)).str());\n  EXPECT_EQ(\"test******\", (MemoryWriter() << pad(\"test\", 10, '*')).str());\n}\n\nTEST(WriterTest, PadWString) {\n  EXPECT_EQ(L\"test    \", (WMemoryWriter() << pad(L\"test\", 8)).str());\n  EXPECT_EQ(L\"test******\", (WMemoryWriter() << pad(L\"test\", 10, '*')).str());\n  EXPECT_EQ(L\"test******\", (WMemoryWriter() << pad(L\"test\", 10, L'*')).str());\n}\n\nTEST(WriterTest, NoConflictWithIOManip) {\n  using namespace std;\n  using namespace fmt;\n  EXPECT_EQ(\"cafe\", (MemoryWriter() << hex(0xcafe)).str());\n  EXPECT_EQ(\"12\", (MemoryWriter() << oct(012)).str());\n}\n\nTEST(WriterTest, Format) {\n  MemoryWriter w;\n  w.write(\"part{0}\", 1);\n  EXPECT_EQ(strlen(\"part1\"), w.size());\n  EXPECT_STREQ(\"part1\", w.c_str());\n  EXPECT_STREQ(\"part1\", w.data());\n  EXPECT_EQ(\"part1\", w.str());\n  w.write(\"part{0}\", 2);\n  EXPECT_EQ(strlen(\"part1part2\"), w.size());\n  EXPECT_STREQ(\"part1part2\", w.c_str());\n  EXPECT_STREQ(\"part1part2\", w.data());\n  EXPECT_EQ(\"part1part2\", w.str());\n}\n\nTEST(WriterTest, WWriter) {\n  EXPECT_EQ(L\"cafe\", (fmt::WMemoryWriter() << fmt::hex(0xcafe)).str());\n}\n\nTEST(ArrayWriterTest, Ctor) {\n  char array[10] = \"garbage\";\n  fmt::ArrayWriter w(array, sizeof(array));\n  EXPECT_EQ(0u, w.size());\n  EXPECT_STREQ(\"\", w.c_str());\n}\n\nTEST(ArrayWriterTest, CompileTimeSizeCtor) {\n  char array[10] = \"garbage\";\n  fmt::ArrayWriter w(array);\n  EXPECT_EQ(0u, w.size());\n  EXPECT_STREQ(\"\", w.c_str());\n  w.write(\"{:10}\", 1);\n}\n\nTEST(ArrayWriterTest, Write) {\n  char array[10];\n  fmt::ArrayWriter w(array, sizeof(array));\n  w.write(\"{}\", 42);\n  EXPECT_EQ(\"42\", w.str());\n}\n\nTEST(ArrayWriterTest, BufferOverflow) {\n  char array[10];\n  fmt::ArrayWriter w(array, sizeof(array));\n  w.write(\"{:10}\", 1);\n  EXPECT_THROW_MSG(w.write(\"{}\", 1), std::runtime_error, \"buffer overflow\");\n}\n\nTEST(ArrayWriterTest, WChar) {\n  wchar_t array[10];\n  fmt::WArrayWriter w(array);\n  w.write(L\"{}\", 42);\n  EXPECT_EQ(L\"42\", w.str());\n}\n\nTEST(FormatterTest, Escape) {\n  EXPECT_EQ(\"{\", format(\"{{\"));\n  EXPECT_EQ(\"before {\", format(\"before {{\"));\n  EXPECT_EQ(\"{ after\", format(\"{{ after\"));\n  EXPECT_EQ(\"before { after\", format(\"before {{ after\"));\n\n  EXPECT_EQ(\"}\", format(\"}}\"));\n  EXPECT_EQ(\"before }\", format(\"before }}\"));\n  EXPECT_EQ(\"} after\", format(\"}} after\"));\n  EXPECT_EQ(\"before } after\", format(\"before }} after\"));\n\n  EXPECT_EQ(\"{}\", format(\"{{}}\"));\n  EXPECT_EQ(\"{42}\", format(\"{{{0}}}\", 42));\n}\n\nTEST(FormatterTest, UnmatchedBraces) {\n  EXPECT_THROW_MSG(format(\"{\"), FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"}\"), FormatError, \"unmatched '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0{}\"), FormatError, \"invalid format string\");\n}\n\nTEST(FormatterTest, NoArgs) {\n  EXPECT_EQ(\"test\", format(\"test\"));\n}\n\nTEST(FormatterTest, ArgsInDifferentPositions) {\n  EXPECT_EQ(\"42\", format(\"{0}\", 42));\n  EXPECT_EQ(\"before 42\", format(\"before {0}\", 42));\n  EXPECT_EQ(\"42 after\", format(\"{0} after\", 42));\n  EXPECT_EQ(\"before 42 after\", format(\"before {0} after\", 42));\n  EXPECT_EQ(\"answer = 42\", format(\"{0} = {1}\", \"answer\", 42));\n  EXPECT_EQ(\"42 is the answer\", format(\"{1} is the {0}\", \"answer\", 42));\n  EXPECT_EQ(\"abracadabra\", format(\"{0}{1}{0}\", \"abra\", \"cad\"));\n}\n\nTEST(FormatterTest, ArgErrors) {\n  EXPECT_THROW_MSG(format(\"{\"), FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{?}\"), FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0\"), FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0}\"), FormatError, \"argument index out of range\");\n\n  char format_str[BUFFER_SIZE];\n  safe_sprintf(format_str, \"{%u\", INT_MAX);\n  EXPECT_THROW_MSG(format(format_str), FormatError, \"invalid format string\");\n  safe_sprintf(format_str, \"{%u}\", INT_MAX);\n  EXPECT_THROW_MSG(format(format_str), FormatError,\n      \"argument index out of range\");\n\n  safe_sprintf(format_str, \"{%u\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str), FormatError, \"number is too big\");\n  safe_sprintf(format_str, \"{%u}\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str), FormatError, \"number is too big\");\n}\n\n#if FMT_USE_VARIADIC_TEMPLATES\ntemplate <int N>\nstruct TestFormat {\n  template <typename... Args>\n  static std::string format(fmt::CStringRef format_str, const Args & ... args) {\n    return TestFormat<N - 1>::format(format_str, N - 1, args...);\n  }\n};\n\ntemplate <>\nstruct TestFormat<0> {\n  template <typename... Args>\n  static std::string format(fmt::CStringRef format_str, const Args & ... args) {\n    return fmt::format(format_str, args...);\n  }\n};\n\nTEST(FormatterTest, ManyArgs) {\n  EXPECT_EQ(\"19\", TestFormat<20>::format(\"{19}\"));\n  EXPECT_THROW_MSG(TestFormat<20>::format(\"{20}\"),\n                   FormatError, \"argument index out of range\");\n  EXPECT_THROW_MSG(TestFormat<21>::format(\"{21}\"),\n                   FormatError, \"argument index out of range\");\n  enum { MAX_PACKED_ARGS = fmt::ArgList::MAX_PACKED_ARGS };\n  std::string format_str = fmt::format(\"{{{}}}\", MAX_PACKED_ARGS + 1);\n  EXPECT_THROW_MSG(TestFormat<MAX_PACKED_ARGS>::format(format_str),\n                   FormatError, \"argument index out of range\");\n}\n#endif\n\nTEST(FormatterTest, NamedArg) {\n  EXPECT_EQ(\"1/a/A\", format(\"{_1}/{a_}/{A_}\", fmt::arg(\"a_\", 'a'),\n                            fmt::arg(\"A_\", \"A\"), fmt::arg(\"_1\", 1)));\n  char a = 'A', b = 'B', c = 'C';\n  EXPECT_EQ(\"BB/AA/CC\", format(\"{1}{b}/{0}{a}/{2}{c}\", FMT_CAPTURE(a, b, c)));\n  EXPECT_EQ(\" A\", format(\"{a:>2}\", FMT_CAPTURE(a)));\n  EXPECT_THROW_MSG(format(\"{a+}\", FMT_CAPTURE(a)), FormatError,\n                   \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{a}\"), FormatError, \"argument not found\");\n  EXPECT_THROW_MSG(format(\"{d}\", FMT_CAPTURE(a, b, c)), FormatError,\n                   \"argument not found\");\n  EXPECT_THROW_MSG(format(\"{a}{}\", FMT_CAPTURE(a)),\n    FormatError, \"cannot switch from manual to automatic argument indexing\");\n  EXPECT_THROW_MSG(format(\"{}{a}\", FMT_CAPTURE(a)),\n    FormatError, \"cannot switch from automatic to manual argument indexing\");\n  EXPECT_EQ(\" -42\", format(\"{0:{width}}\", -42, fmt::arg(\"width\", 4)));\n  EXPECT_EQ(\"st\", format(\"{0:.{precision}}\", \"str\", fmt::arg(\"precision\", 2)));\n  int n = 100;\n  EXPECT_EQ(L\"n=100\", format(L\"n={n}\", FMT_CAPTURE_W(n)));\n}\n\nTEST(FormatterTest, AutoArgIndex) {\n  EXPECT_EQ(\"abc\", format(\"{}{}{}\", 'a', 'b', 'c'));\n  EXPECT_THROW_MSG(format(\"{0}{}\", 'a', 'b'),\n      FormatError, \"cannot switch from manual to automatic argument indexing\");\n  EXPECT_THROW_MSG(format(\"{}{0}\", 'a', 'b'),\n      FormatError, \"cannot switch from automatic to manual argument indexing\");\n  EXPECT_EQ(\"1.2\", format(\"{:.{}}\", 1.2345, 2));\n  EXPECT_THROW_MSG(format(\"{0}:.{}\", 1.2345, 2),\n      FormatError, \"cannot switch from manual to automatic argument indexing\");\n  EXPECT_THROW_MSG(format(\"{:.{0}}\", 1.2345, 2),\n      FormatError, \"cannot switch from automatic to manual argument indexing\");\n  EXPECT_THROW_MSG(format(\"{}\"), FormatError, \"argument index out of range\");\n}\n\nTEST(FormatterTest, EmptySpecs) {\n  EXPECT_EQ(\"42\", format(\"{0:}\", 42));\n}\n\nTEST(FormatterTest, LeftAlign) {\n  EXPECT_EQ(\"42  \", format(\"{0:<4}\", 42));\n  EXPECT_EQ(\"42  \", format(\"{0:<4o}\", 042));\n  EXPECT_EQ(\"42  \", format(\"{0:<4x}\", 0x42));\n  EXPECT_EQ(\"-42  \", format(\"{0:<5}\", -42));\n  EXPECT_EQ(\"42   \", format(\"{0:<5}\", 42u));\n  EXPECT_EQ(\"-42  \", format(\"{0:<5}\", -42l));\n  EXPECT_EQ(\"42   \", format(\"{0:<5}\", 42ul));\n  EXPECT_EQ(\"-42  \", format(\"{0:<5}\", -42ll));\n  EXPECT_EQ(\"42   \", format(\"{0:<5}\", 42ull));\n  EXPECT_EQ(\"-42  \", format(\"{0:<5}\", -42.0));\n  EXPECT_EQ(\"-42  \", format(\"{0:<5}\", -42.0l));\n  EXPECT_EQ(\"c    \", format(\"{0:<5}\", 'c'));\n  EXPECT_EQ(\"abc  \", format(\"{0:<5}\", \"abc\"));\n  EXPECT_EQ(\"0xface  \", format(\"{0:<8}\", reinterpret_cast<void*>(0xface)));\n}\n\nTEST(FormatterTest, RightAlign) {\n  EXPECT_EQ(\"  42\", format(\"{0:>4}\", 42));\n  EXPECT_EQ(\"  42\", format(\"{0:>4o}\", 042));\n  EXPECT_EQ(\"  42\", format(\"{0:>4x}\", 0x42));\n  EXPECT_EQ(\"  -42\", format(\"{0:>5}\", -42));\n  EXPECT_EQ(\"   42\", format(\"{0:>5}\", 42u));\n  EXPECT_EQ(\"  -42\", format(\"{0:>5}\", -42l));\n  EXPECT_EQ(\"   42\", format(\"{0:>5}\", 42ul));\n  EXPECT_EQ(\"  -42\", format(\"{0:>5}\", -42ll));\n  EXPECT_EQ(\"   42\", format(\"{0:>5}\", 42ull));\n  EXPECT_EQ(\"  -42\", format(\"{0:>5}\", -42.0));\n  EXPECT_EQ(\"  -42\", format(\"{0:>5}\", -42.0l));\n  EXPECT_EQ(\"    c\", format(\"{0:>5}\", 'c'));\n  EXPECT_EQ(\"  abc\", format(\"{0:>5}\", \"abc\"));\n  EXPECT_EQ(\"  0xface\", format(\"{0:>8}\", reinterpret_cast<void*>(0xface)));\n}\n\nTEST(FormatterTest, NumericAlign) {\n  EXPECT_EQ(\"  42\", format(\"{0:=4}\", 42));\n  EXPECT_EQ(\"+ 42\", format(\"{0:=+4}\", 42));\n  EXPECT_EQ(\"  42\", format(\"{0:=4o}\", 042));\n  EXPECT_EQ(\"+ 42\", format(\"{0:=+4o}\", 042));\n  EXPECT_EQ(\"  42\", format(\"{0:=4x}\", 0x42));\n  EXPECT_EQ(\"+ 42\", format(\"{0:=+4x}\", 0x42));\n  EXPECT_EQ(\"-  42\", format(\"{0:=5}\", -42));\n  EXPECT_EQ(\"   42\", format(\"{0:=5}\", 42u));\n  EXPECT_EQ(\"-  42\", format(\"{0:=5}\", -42l));\n  EXPECT_EQ(\"   42\", format(\"{0:=5}\", 42ul));\n  EXPECT_EQ(\"-  42\", format(\"{0:=5}\", -42ll));\n  EXPECT_EQ(\"   42\", format(\"{0:=5}\", 42ull));\n  EXPECT_EQ(\"-  42\", format(\"{0:=5}\", -42.0));\n  EXPECT_EQ(\"-  42\", format(\"{0:=5}\", -42.0l));\n  EXPECT_THROW_MSG(format(\"{0:=5\", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0:=5}\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0:=5}\", \"abc\"),\n      FormatError, \"format specifier '=' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0:=8}\", reinterpret_cast<void*>(0xface)),\n      FormatError, \"format specifier '=' requires numeric argument\");\n}\n\nTEST(FormatterTest, CenterAlign) {\n  EXPECT_EQ(\" 42  \", format(\"{0:^5}\", 42));\n  EXPECT_EQ(\" 42  \", format(\"{0:^5o}\", 042));\n  EXPECT_EQ(\" 42  \", format(\"{0:^5x}\", 0x42));\n  EXPECT_EQ(\" -42 \", format(\"{0:^5}\", -42));\n  EXPECT_EQ(\" 42  \", format(\"{0:^5}\", 42u));\n  EXPECT_EQ(\" -42 \", format(\"{0:^5}\", -42l));\n  EXPECT_EQ(\" 42  \", format(\"{0:^5}\", 42ul));\n  EXPECT_EQ(\" -42 \", format(\"{0:^5}\", -42ll));\n  EXPECT_EQ(\" 42  \", format(\"{0:^5}\", 42ull));\n  EXPECT_EQ(\" -42  \", format(\"{0:^6}\", -42.0));\n  EXPECT_EQ(\" -42 \", format(\"{0:^5}\", -42.0l));\n  EXPECT_EQ(\"  c  \", format(\"{0:^5}\", 'c'));\n  EXPECT_EQ(\" abc  \", format(\"{0:^6}\", \"abc\"));\n  EXPECT_EQ(\" 0xface \", format(\"{0:^8}\", reinterpret_cast<void*>(0xface)));\n}\n\nTEST(FormatterTest, Fill) {\n  EXPECT_THROW_MSG(format(\"{0:{<5}\", 'c'),\n      FormatError, \"invalid fill character '{'\");\n  EXPECT_THROW_MSG(format(\"{0:{<5}}\", 'c'),\n      FormatError, \"invalid fill character '{'\");\n  EXPECT_EQ(\"**42\", format(\"{0:*>4}\", 42));\n  EXPECT_EQ(\"**-42\", format(\"{0:*>5}\", -42));\n  EXPECT_EQ(\"***42\", format(\"{0:*>5}\", 42u));\n  EXPECT_EQ(\"**-42\", format(\"{0:*>5}\", -42l));\n  EXPECT_EQ(\"***42\", format(\"{0:*>5}\", 42ul));\n  EXPECT_EQ(\"**-42\", format(\"{0:*>5}\", -42ll));\n  EXPECT_EQ(\"***42\", format(\"{0:*>5}\", 42ull));\n  EXPECT_EQ(\"**-42\", format(\"{0:*>5}\", -42.0));\n  EXPECT_EQ(\"**-42\", format(\"{0:*>5}\", -42.0l));\n  EXPECT_EQ(\"c****\", format(\"{0:*<5}\", 'c'));\n  EXPECT_EQ(\"abc**\", format(\"{0:*<5}\", \"abc\"));\n  EXPECT_EQ(\"**0xface\", format(\"{0:*>8}\", reinterpret_cast<void*>(0xface)));\n}\n\nTEST(FormatterTest, PlusSign) {\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42));\n  EXPECT_EQ(\"-42\", format(\"{0:+}\", -42));\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42));\n  EXPECT_THROW_MSG(format(\"{0:+}\", 42u),\n      FormatError, \"format specifier '+' requires signed argument\");\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42l));\n  EXPECT_THROW_MSG(format(\"{0:+}\", 42ul),\n      FormatError, \"format specifier '+' requires signed argument\");\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42ll));\n  EXPECT_THROW_MSG(format(\"{0:+}\", 42ull),\n      FormatError, \"format specifier '+' requires signed argument\");\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42.0));\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42.0l));\n  EXPECT_THROW_MSG(format(\"{0:+\", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0:+}\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0:+}\", \"abc\"),\n      FormatError, \"format specifier '+' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0:+}\", reinterpret_cast<void*>(0x42)),\n      FormatError, \"format specifier '+' requires numeric argument\");\n}\n\nTEST(FormatterTest, MinusSign) {\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42));\n  EXPECT_EQ(\"-42\", format(\"{0:-}\", -42));\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42));\n  EXPECT_THROW_MSG(format(\"{0:-}\", 42u),\n      FormatError, \"format specifier '-' requires signed argument\");\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42l));\n  EXPECT_THROW_MSG(format(\"{0:-}\", 42ul),\n      FormatError, \"format specifier '-' requires signed argument\");\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42ll));\n  EXPECT_THROW_MSG(format(\"{0:-}\", 42ull),\n      FormatError, \"format specifier '-' requires signed argument\");\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42.0));\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42.0l));\n  EXPECT_THROW_MSG(format(\"{0:-\", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0:-}\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0:-}\", \"abc\"),\n      FormatError, \"format specifier '-' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0:-}\", reinterpret_cast<void*>(0x42)),\n      FormatError, \"format specifier '-' requires numeric argument\");\n}\n\nTEST(FormatterTest, SpaceSign) {\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42));\n  EXPECT_EQ(\"-42\", format(\"{0: }\", -42));\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42));\n  EXPECT_THROW_MSG(format(\"{0: }\", 42u),\n      FormatError, \"format specifier ' ' requires signed argument\");\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42l));\n  EXPECT_THROW_MSG(format(\"{0: }\", 42ul),\n      FormatError, \"format specifier ' ' requires signed argument\");\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42ll));\n  EXPECT_THROW_MSG(format(\"{0: }\", 42ull),\n      FormatError, \"format specifier ' ' requires signed argument\");\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42.0));\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42.0l));\n  EXPECT_THROW_MSG(format(\"{0: \", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0: }\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0: }\", \"abc\"),\n      FormatError, \"format specifier ' ' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0: }\", reinterpret_cast<void*>(0x42)),\n      FormatError, \"format specifier ' ' requires numeric argument\");\n}\n\nTEST(FormatterTest, HashFlag) {\n  EXPECT_EQ(\"42\", format(\"{0:#}\", 42));\n  EXPECT_EQ(\"-42\", format(\"{0:#}\", -42));\n  EXPECT_EQ(\"0b101010\", format(\"{0:#b}\", 42));\n  EXPECT_EQ(\"0B101010\", format(\"{0:#B}\", 42));\n  EXPECT_EQ(\"-0b101010\", format(\"{0:#b}\", -42));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42));\n  EXPECT_EQ(\"0X42\", format(\"{0:#X}\", 0x42));\n  EXPECT_EQ(\"-0x42\", format(\"{0:#x}\", -0x42));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042));\n  EXPECT_EQ(\"-042\", format(\"{0:#o}\", -042));\n  EXPECT_EQ(\"42\", format(\"{0:#}\", 42u));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42u));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042u));\n\n  EXPECT_EQ(\"-42\", format(\"{0:#}\", -42l));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42l));\n  EXPECT_EQ(\"-0x42\", format(\"{0:#x}\", -0x42l));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042l));\n  EXPECT_EQ(\"-042\", format(\"{0:#o}\", -042l));\n  EXPECT_EQ(\"42\", format(\"{0:#}\", 42ul));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42ul));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042ul));\n\n  EXPECT_EQ(\"-42\", format(\"{0:#}\", -42ll));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42ll));\n  EXPECT_EQ(\"-0x42\", format(\"{0:#x}\", -0x42ll));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042ll));\n  EXPECT_EQ(\"-042\", format(\"{0:#o}\", -042ll));\n  EXPECT_EQ(\"42\", format(\"{0:#}\", 42ull));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42ull));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042ull));\n\n  EXPECT_EQ(\"-42.0000\", format(\"{0:#}\", -42.0));\n  EXPECT_EQ(\"-42.0000\", format(\"{0:#}\", -42.0l));\n  EXPECT_THROW_MSG(format(\"{0:#\", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0:#}\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0:#}\", \"abc\"),\n      FormatError, \"format specifier '#' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0:#}\", reinterpret_cast<void*>(0x42)),\n      FormatError, \"format specifier '#' requires numeric argument\");\n}\n\nTEST(FormatterTest, ZeroFlag) {\n  EXPECT_EQ(\"42\", format(\"{0:0}\", 42));\n  EXPECT_EQ(\"-0042\", format(\"{0:05}\", -42));\n  EXPECT_EQ(\"00042\", format(\"{0:05}\", 42u));\n  EXPECT_EQ(\"-0042\", format(\"{0:05}\", -42l));\n  EXPECT_EQ(\"00042\", format(\"{0:05}\", 42ul));\n  EXPECT_EQ(\"-0042\", format(\"{0:05}\", -42ll));\n  EXPECT_EQ(\"00042\", format(\"{0:05}\", 42ull));\n  EXPECT_EQ(\"-0042\", format(\"{0:05}\", -42.0));\n  EXPECT_EQ(\"-0042\", format(\"{0:05}\", -42.0l));\n  EXPECT_THROW_MSG(format(\"{0:0\", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0:05}\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0:05}\", \"abc\"),\n      FormatError, \"format specifier '0' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0:05}\", reinterpret_cast<void*>(0x42)),\n      FormatError, \"format specifier '0' requires numeric argument\");\n}\n\nTEST(FormatterTest, Width) {\n  char format_str[BUFFER_SIZE];\n  safe_sprintf(format_str, \"{0:%u\", UINT_MAX);\n  increment(format_str + 3);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  std::size_t size = std::strlen(format_str);\n  format_str[size] = '}';\n  format_str[size + 1] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n\n  safe_sprintf(format_str, \"{0:%u\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  safe_sprintf(format_str, \"{0:%u}\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  EXPECT_EQ(\" -42\", format(\"{0:4}\", -42));\n  EXPECT_EQ(\"   42\", format(\"{0:5}\", 42u));\n  EXPECT_EQ(\"   -42\", format(\"{0:6}\", -42l));\n  EXPECT_EQ(\"     42\", format(\"{0:7}\", 42ul));\n  EXPECT_EQ(\"   -42\", format(\"{0:6}\", -42ll));\n  EXPECT_EQ(\"     42\", format(\"{0:7}\", 42ull));\n  EXPECT_EQ(\"   -1.23\", format(\"{0:8}\", -1.23));\n  EXPECT_EQ(\"    -1.23\", format(\"{0:9}\", -1.23l));\n  EXPECT_EQ(\"    0xcafe\", format(\"{0:10}\", reinterpret_cast<void*>(0xcafe)));\n  EXPECT_EQ(\"x          \", format(\"{0:11}\", 'x'));\n  EXPECT_EQ(\"str         \", format(\"{0:12}\", \"str\"));\n}\n\nTEST(FormatterTest, RuntimeWidth) {\n  char format_str[BUFFER_SIZE];\n  safe_sprintf(format_str, \"{0:{%u\", UINT_MAX);\n  increment(format_str + 4);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  std::size_t size = std::strlen(format_str);\n  format_str[size] = '}';\n  format_str[size + 1] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  format_str[size + 1] = '}';\n  format_str[size + 2] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n\n  EXPECT_THROW_MSG(format(\"{0:{\", 0),\n      FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0:{}\", 0),\n      FormatError, \"cannot switch from manual to automatic argument indexing\");\n  EXPECT_THROW_MSG(format(\"{0:{?}}\", 0),\n      FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0),\n      FormatError, \"argument index out of range\");\n\n  EXPECT_THROW_MSG(format(\"{0:{0:}}\", 0),\n      FormatError, \"invalid format string\");\n\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, -1),\n      FormatError, \"negative width\");\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, (INT_MAX + 1u)),\n      FormatError, \"number is too big\");\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, -1l),\n      FormatError, \"negative width\");\n  if (fmt::internal::const_check(sizeof(long) > sizeof(int))) {\n    long value = INT_MAX;\n    EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, (value + 1)),\n        FormatError, \"number is too big\");\n  }\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, (INT_MAX + 1ul)),\n      FormatError, \"number is too big\");\n\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, '0'),\n      FormatError, \"width is not integer\");\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, 0.0),\n      FormatError, \"width is not integer\");\n\n  EXPECT_EQ(\" -42\", format(\"{0:{1}}\", -42, 4));\n  EXPECT_EQ(\"   42\", format(\"{0:{1}}\", 42u, 5));\n  EXPECT_EQ(\"   -42\", format(\"{0:{1}}\", -42l, 6));\n  EXPECT_EQ(\"     42\", format(\"{0:{1}}\", 42ul, 7));\n  EXPECT_EQ(\"   -42\", format(\"{0:{1}}\", -42ll, 6));\n  EXPECT_EQ(\"     42\", format(\"{0:{1}}\", 42ull, 7));\n  EXPECT_EQ(\"   -1.23\", format(\"{0:{1}}\", -1.23, 8));\n  EXPECT_EQ(\"    -1.23\", format(\"{0:{1}}\", -1.23l, 9));\n  EXPECT_EQ(\"    0xcafe\",\n            format(\"{0:{1}}\", reinterpret_cast<void*>(0xcafe), 10));\n  EXPECT_EQ(\"x          \", format(\"{0:{1}}\", 'x', 11));\n  EXPECT_EQ(\"str         \", format(\"{0:{1}}\", \"str\", 12));\n}\n\nTEST(FormatterTest, Precision) {\n  char format_str[BUFFER_SIZE];\n  safe_sprintf(format_str, \"{0:.%u\", UINT_MAX);\n  increment(format_str + 4);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  std::size_t size = std::strlen(format_str);\n  format_str[size] = '}';\n  format_str[size + 1] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n\n  safe_sprintf(format_str, \"{0:.%u\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  safe_sprintf(format_str, \"{0:.%u}\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n\n  EXPECT_THROW_MSG(format(\"{0:.\", 0),\n      FormatError, \"missing precision specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.}\", 0),\n      FormatError, \"missing precision specifier\");\n\n  EXPECT_THROW_MSG(format(\"{0:.2\", 0),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42u),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42u),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42l),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42l),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42ul),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42ul),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42ll),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42ll),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42ull),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42ull),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:3.0}\", 'x'),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_EQ(\"1.2\", format(\"{0:.2}\", 1.2345));\n  EXPECT_EQ(\"1.2\", format(\"{0:.2}\", 1.2345l));\n\n  EXPECT_THROW_MSG(format(\"{0:.2}\", reinterpret_cast<void*>(0xcafe)),\n      FormatError, \"precision not allowed in pointer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", reinterpret_cast<void*>(0xcafe)),\n      FormatError, \"precision not allowed in pointer format specifier\");\n\n  EXPECT_EQ(\"st\", format(\"{0:.2}\", \"str\"));\n}\n\nTEST(FormatterTest, RuntimePrecision) {\n  char format_str[BUFFER_SIZE];\n  safe_sprintf(format_str, \"{0:.{%u\", UINT_MAX);\n  increment(format_str + 5);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  std::size_t size = std::strlen(format_str);\n  format_str[size] = '}';\n  format_str[size + 1] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  format_str[size + 1] = '}';\n  format_str[size + 2] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n\n  EXPECT_THROW_MSG(format(\"{0:.{\", 0),\n      FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0:.{}\", 0),\n      FormatError, \"cannot switch from manual to automatic argument indexing\");\n  EXPECT_THROW_MSG(format(\"{0:.{?}}\", 0),\n      FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}\", 0, 0),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0),\n      FormatError, \"argument index out of range\");\n\n  EXPECT_THROW_MSG(format(\"{0:.{0:}}\", 0),\n      FormatError, \"invalid format string\");\n\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, -1),\n      FormatError, \"negative precision\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, (INT_MAX + 1u)),\n      FormatError, \"number is too big\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, -1l),\n      FormatError, \"negative precision\");\n  if (fmt::internal::const_check(sizeof(long) > sizeof(int))) {\n    long value = INT_MAX;\n    EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, (value + 1)),\n        FormatError, \"number is too big\");\n  }\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, (INT_MAX + 1ul)),\n      FormatError, \"number is too big\");\n\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, '0'),\n      FormatError, \"precision is not integer\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, 0.0),\n      FormatError, \"precision is not integer\");\n\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42u, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42u, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42l, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42l, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42ul, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42ul, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42ll, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42ll, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42ull, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42ull, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:3.{1}}\", 'x', 0),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_EQ(\"1.2\", format(\"{0:.{1}}\", 1.2345, 2));\n  EXPECT_EQ(\"1.2\", format(\"{1:.{0}}\", 2, 1.2345l));\n\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", reinterpret_cast<void*>(0xcafe), 2),\n      FormatError, \"precision not allowed in pointer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", reinterpret_cast<void*>(0xcafe), 2),\n      FormatError, \"precision not allowed in pointer format specifier\");\n\n  EXPECT_EQ(\"st\", format(\"{0:.{1}}\", \"str\", 2));\n}\n\ntemplate <typename T>\nvoid check_unknown_types(\n    const T &value, const char *types, const char *type_name) {\n  char format_str[BUFFER_SIZE], message[BUFFER_SIZE];\n  const char *special = \".0123456789}\";\n  for (int i = CHAR_MIN; i <= CHAR_MAX; ++i) {\n    char c = static_cast<char>(i);\n    if (std::strchr(types, c) || std::strchr(special, c) || !c) continue;\n    safe_sprintf(format_str, \"{0:10%c}\", c);\n    if (std::isprint(static_cast<unsigned char>(c))) {\n      safe_sprintf(message, \"unknown format code '%c' for %s\", c, type_name);\n    } else {\n      safe_sprintf(message, \"unknown format code '\\\\x%02x' for %s\", c,\n                   type_name);\n    }\n    EXPECT_THROW_MSG(format(format_str, value), FormatError, message)\n      << format_str << \" \" << message;\n  }\n}\n\nTEST(BoolTest, FormatBool) {\n  EXPECT_EQ(\"true\", format(\"{}\", true));\n  EXPECT_EQ(\"false\", format(\"{}\", false));\n  EXPECT_EQ(\"1\", format(\"{:d}\", true));\n  EXPECT_EQ(\"true \", format(\"{:5}\", true));\n  EXPECT_EQ(L\"true\", format(L\"{}\", true));\n}\n\nTEST(FormatterTest, FormatShort) {\n  short s = 42;\n  EXPECT_EQ(\"42\", format(\"{0:d}\", s));\n  unsigned short us = 42;\n  EXPECT_EQ(\"42\", format(\"{0:d}\", us));\n}\n\nTEST(FormatterTest, FormatInt) {\n  EXPECT_THROW_MSG(format(\"{0:v\", 42),\n      FormatError, \"missing '}' in format string\");\n  check_unknown_types(42, \"bBdoxXn\", \"integer\");\n}\n\nTEST(FormatterTest, FormatBin) {\n  EXPECT_EQ(\"0\", format(\"{0:b}\", 0));\n  EXPECT_EQ(\"101010\", format(\"{0:b}\", 42));\n  EXPECT_EQ(\"101010\", format(\"{0:b}\", 42u));\n  EXPECT_EQ(\"-101010\", format(\"{0:b}\", -42));\n  EXPECT_EQ(\"11000000111001\", format(\"{0:b}\", 12345));\n  EXPECT_EQ(\"10010001101000101011001111000\", format(\"{0:b}\", 0x12345678));\n  EXPECT_EQ(\"10010000101010111100110111101111\", format(\"{0:b}\", 0x90ABCDEF));\n  EXPECT_EQ(\"11111111111111111111111111111111\",\n            format(\"{0:b}\", std::numeric_limits<uint32_t>::max()));\n}\n\nTEST(FormatterTest, FormatDec) {\n  EXPECT_EQ(\"0\", format(\"{0}\", 0));\n  EXPECT_EQ(\"42\", format(\"{0}\", 42));\n  EXPECT_EQ(\"42\", format(\"{0:d}\", 42));\n  EXPECT_EQ(\"42\", format(\"{0}\", 42u));\n  EXPECT_EQ(\"-42\", format(\"{0}\", -42));\n  EXPECT_EQ(\"12345\", format(\"{0}\", 12345));\n  EXPECT_EQ(\"67890\", format(\"{0}\", 67890));\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"%d\", INT_MIN);\n  EXPECT_EQ(buffer, format(\"{0}\", INT_MIN));\n  safe_sprintf(buffer, \"%d\", INT_MAX);\n  EXPECT_EQ(buffer, format(\"{0}\", INT_MAX));\n  safe_sprintf(buffer, \"%u\", UINT_MAX);\n  EXPECT_EQ(buffer, format(\"{0}\", UINT_MAX));\n  safe_sprintf(buffer, \"%ld\", 0 - static_cast<unsigned long>(LONG_MIN));\n  EXPECT_EQ(buffer, format(\"{0}\", LONG_MIN));\n  safe_sprintf(buffer, \"%ld\", LONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0}\", LONG_MAX));\n  safe_sprintf(buffer, \"%lu\", ULONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0}\", ULONG_MAX));\n}\n\nTEST(FormatterTest, FormatHex) {\n  EXPECT_EQ(\"0\", format(\"{0:x}\", 0));\n  EXPECT_EQ(\"42\", format(\"{0:x}\", 0x42));\n  EXPECT_EQ(\"42\", format(\"{0:x}\", 0x42u));\n  EXPECT_EQ(\"-42\", format(\"{0:x}\", -0x42));\n  EXPECT_EQ(\"12345678\", format(\"{0:x}\", 0x12345678));\n  EXPECT_EQ(\"90abcdef\", format(\"{0:x}\", 0x90abcdef));\n  EXPECT_EQ(\"12345678\", format(\"{0:X}\", 0x12345678));\n  EXPECT_EQ(\"90ABCDEF\", format(\"{0:X}\", 0x90ABCDEF));\n\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"-%x\", 0 - static_cast<unsigned>(INT_MIN));\n  EXPECT_EQ(buffer, format(\"{0:x}\", INT_MIN));\n  safe_sprintf(buffer, \"%x\", INT_MAX);\n  EXPECT_EQ(buffer, format(\"{0:x}\", INT_MAX));\n  safe_sprintf(buffer, \"%x\", UINT_MAX);\n  EXPECT_EQ(buffer, format(\"{0:x}\", UINT_MAX));\n  safe_sprintf(buffer, \"-%lx\", 0 - static_cast<unsigned long>(LONG_MIN));\n  EXPECT_EQ(buffer, format(\"{0:x}\", LONG_MIN));\n  safe_sprintf(buffer, \"%lx\", LONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0:x}\", LONG_MAX));\n  safe_sprintf(buffer, \"%lx\", ULONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0:x}\", ULONG_MAX));\n}\n\nTEST(FormatterTest, FormatOct) {\n  EXPECT_EQ(\"0\", format(\"{0:o}\", 0));\n  EXPECT_EQ(\"42\", format(\"{0:o}\", 042));\n  EXPECT_EQ(\"42\", format(\"{0:o}\", 042u));\n  EXPECT_EQ(\"-42\", format(\"{0:o}\", -042));\n  EXPECT_EQ(\"12345670\", format(\"{0:o}\", 012345670));\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"-%o\", 0 - static_cast<unsigned>(INT_MIN));\n  EXPECT_EQ(buffer, format(\"{0:o}\", INT_MIN));\n  safe_sprintf(buffer, \"%o\", INT_MAX);\n  EXPECT_EQ(buffer, format(\"{0:o}\", INT_MAX));\n  safe_sprintf(buffer, \"%o\", UINT_MAX);\n  EXPECT_EQ(buffer, format(\"{0:o}\", UINT_MAX));\n  safe_sprintf(buffer, \"-%lo\", 0 - static_cast<unsigned long>(LONG_MIN));\n  EXPECT_EQ(buffer, format(\"{0:o}\", LONG_MIN));\n  safe_sprintf(buffer, \"%lo\", LONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0:o}\", LONG_MAX));\n  safe_sprintf(buffer, \"%lo\", ULONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0:o}\", ULONG_MAX));\n}\n\nTEST(FormatterTest, FormatIntLocale) {\n  ScopedMock<LocaleMock> mock;\n  lconv lc = lconv();\n  char sep[] = \"--\";\n  lc.thousands_sep = sep;\n  EXPECT_CALL(mock, localeconv()).Times(3).WillRepeatedly(testing::Return(&lc));\n  EXPECT_EQ(\"123\", format(\"{:n}\", 123));\n  EXPECT_EQ(\"1--234\", format(\"{:n}\", 1234));\n  EXPECT_EQ(\"1--234--567\", format(\"{:n}\", 1234567));\n}\n\nstruct ConvertibleToLongLong {\n  operator fmt::LongLong() const {\n    return fmt::LongLong(1) << 32;\n  }\n};\n\nTEST(FormatterTest, FormatConvertibleToLongLong) {\n  EXPECT_EQ(\"100000000\", format(\"{:x}\", ConvertibleToLongLong()));\n}\n\nTEST(FormatterTest, FormatFloat) {\n  EXPECT_EQ(\"392.500000\", format(\"{0:f}\", 392.5f));\n}\n\nTEST(FormatterTest, FormatDouble) {\n  check_unknown_types(1.2, \"eEfFgGaA\", \"double\");\n  EXPECT_EQ(\"0\", format(\"{0:}\", 0.0));\n  EXPECT_EQ(\"0.000000\", format(\"{0:f}\", 0.0));\n  EXPECT_EQ(\"392.65\", format(\"{0:}\", 392.65));\n  EXPECT_EQ(\"392.65\", format(\"{0:g}\", 392.65));\n  EXPECT_EQ(\"392.65\", format(\"{0:G}\", 392.65));\n  EXPECT_EQ(\"392.650000\", format(\"{0:f}\", 392.65));\n  EXPECT_EQ(\"392.650000\", format(\"{0:F}\", 392.65));\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"%e\", 392.65);\n  EXPECT_EQ(buffer, format(\"{0:e}\", 392.65));\n  safe_sprintf(buffer, \"%E\", 392.65);\n  EXPECT_EQ(buffer, format(\"{0:E}\", 392.65));\n  EXPECT_EQ(\"+0000392.6\", format(\"{0:+010.4g}\", 392.65));\n  safe_sprintf(buffer, \"%a\", -42.0);\n  EXPECT_EQ(buffer, format(\"{:a}\", -42.0));\n  safe_sprintf(buffer, \"%A\", -42.0);\n  EXPECT_EQ(buffer, format(\"{:A}\", -42.0));\n}\n\nTEST(FormatterTest, FormatNaN) {\n  double nan = std::numeric_limits<double>::quiet_NaN();\n  EXPECT_EQ(\"nan\", format(\"{}\", nan));\n  EXPECT_EQ(\"+nan\", format(\"{:+}\", nan));\n  EXPECT_EQ(\" nan\", format(\"{: }\", nan));\n  EXPECT_EQ(\"NAN\", format(\"{:F}\", nan));\n  EXPECT_EQ(\"nan    \", format(\"{:<7}\", nan));\n  EXPECT_EQ(\"  nan  \", format(\"{:^7}\", nan));\n  EXPECT_EQ(\"    nan\", format(\"{:>7}\", nan));\n}\n\nTEST(FormatterTest, FormatInfinity) {\n  double inf = std::numeric_limits<double>::infinity();\n  EXPECT_EQ(\"inf\", format(\"{}\", inf));\n  EXPECT_EQ(\"+inf\", format(\"{:+}\", inf));\n  EXPECT_EQ(\"-inf\", format(\"{}\", -inf));\n  EXPECT_EQ(\" inf\", format(\"{: }\", inf));\n  EXPECT_EQ(\"INF\", format(\"{:F}\", inf));\n  EXPECT_EQ(\"inf    \", format(\"{:<7}\", inf));\n  EXPECT_EQ(\"  inf  \", format(\"{:^7}\", inf));\n  EXPECT_EQ(\"    inf\", format(\"{:>7}\", inf));\n}\n\nTEST(FormatterTest, FormatLongDouble) {\n  EXPECT_EQ(\"0\", format(\"{0:}\", 0.0l));\n  EXPECT_EQ(\"0.000000\", format(\"{0:f}\", 0.0l));\n  EXPECT_EQ(\"392.65\", format(\"{0:}\", 392.65l));\n  EXPECT_EQ(\"392.65\", format(\"{0:g}\", 392.65l));\n  EXPECT_EQ(\"392.65\", format(\"{0:G}\", 392.65l));\n  EXPECT_EQ(\"392.650000\", format(\"{0:f}\", 392.65l));\n  EXPECT_EQ(\"392.650000\", format(\"{0:F}\", 392.65l));\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"%Le\", 392.65l);\n  EXPECT_EQ(buffer, format(\"{0:e}\", 392.65l));\n  EXPECT_EQ(\"+0000392.6\", format(\"{0:+010.4g}\", 392.64l));\n}\n\nTEST(FormatterTest, FormatChar) {\n  const char types[] = \"cbBdoxXn\";\n  check_unknown_types('a', types, \"char\");\n  EXPECT_EQ(\"a\", format(\"{0}\", 'a'));\n  EXPECT_EQ(\"z\", format(\"{0:c}\", 'z'));\n  EXPECT_EQ(L\"a\", format(L\"{0}\", 'a'));\n  int n = 'x';\n  for (const char *type = types + 1; *type; ++type) {\n    std::string format_str = fmt::format(\"{{:{}}}\", *type);\n    EXPECT_EQ(fmt::format(format_str, n), fmt::format(format_str, 'x'));\n  }\n  EXPECT_EQ(fmt::format(\"{:02X}\", n), fmt::format(\"{:02X}\", 'x'));\n}\n\nTEST(FormatterTest, FormatUnsignedChar) {\n  EXPECT_EQ(\"42\", format(\"{}\", static_cast<unsigned char>(42)));\n  EXPECT_EQ(\"42\", format(\"{}\", static_cast<uint8_t>(42)));\n}\n\nTEST(FormatterTest, FormatWChar) {\n  EXPECT_EQ(L\"a\", format(L\"{0}\", L'a'));\n  // This shouldn't compile:\n  //format(\"{}\", L'a');\n}\n\nTEST(FormatterTest, FormatCString) {\n  check_unknown_types(\"test\", \"sp\", \"string\");\n  EXPECT_EQ(\"test\", format(\"{0}\", \"test\"));\n  EXPECT_EQ(\"test\", format(\"{0:s}\", \"test\"));\n  char nonconst[] = \"nonconst\";\n  EXPECT_EQ(\"nonconst\", format(\"{0}\", nonconst));\n  EXPECT_THROW_MSG(format(\"{0}\", reinterpret_cast<const char*>(0)),\n      FormatError, \"string pointer is null\");\n}\n\nTEST(FormatterTest, FormatSCharString) {\n  signed char str[] = \"test\";\n  EXPECT_EQ(\"test\", format(\"{0:s}\", str));\n  const signed char *const_str = str;\n  EXPECT_EQ(\"test\", format(\"{0:s}\", const_str));\n}\n\nTEST(FormatterTest, FormatUCharString) {\n  unsigned char str[] = \"test\";\n  EXPECT_EQ(\"test\", format(\"{0:s}\", str));\n  const unsigned char *const_str = str;\n  EXPECT_EQ(\"test\", format(\"{0:s}\", const_str));\n  unsigned char *ptr = str;\n  EXPECT_EQ(\"test\", format(\"{0:s}\", ptr));\n}\n\nTEST(FormatterTest, FormatPointer) {\n  check_unknown_types(reinterpret_cast<void*>(0x1234), \"p\", \"pointer\");\n  EXPECT_EQ(\"0x0\", format(\"{0}\", reinterpret_cast<void*>(0)));\n  EXPECT_EQ(\"0x1234\", format(\"{0}\", reinterpret_cast<void*>(0x1234)));\n  EXPECT_EQ(\"0x1234\", format(\"{0:p}\", reinterpret_cast<void*>(0x1234)));\n  EXPECT_EQ(\"0x\" + std::string(sizeof(void*) * CHAR_BIT / 4, 'f'),\n      format(\"{0}\", reinterpret_cast<void*>(~uintptr_t())));\n}\n\nTEST(FormatterTest, FormatString) {\n  EXPECT_EQ(\"test\", format(\"{0}\", std::string(\"test\")));\n}\n\nTEST(FormatterTest, FormatStringRef) {\n  EXPECT_EQ(\"test\", format(\"{0}\", StringRef(\"test\")));\n}\n\nTEST(FormatterTest, FormatCStringRef) {\n  EXPECT_EQ(\"test\", format(\"{0}\", CStringRef(\"test\")));\n}\n\n#if FMT_HAS_STRING_VIEW\nTEST(FormatterTest, FormatStringView) {\n  EXPECT_EQ(\"test\", format(\"{0}\", std::string_view(\"test\")));\n}\n#endif\n\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\nTEST(FormatterTest, FormatExperimentalStringView) {\n\tEXPECT_EQ(\"test\", format(\"{0}\", std::experimental::string_view(\"test\")));\n}\n#endif\n\nvoid format_arg(fmt::BasicFormatter<char> &f, const char *, const Date &d) {\n  f.writer() << d.year() << '-' << d.month() << '-' << d.day();\n}\n\nTEST(FormatterTest, FormatCustom) {\n  Date date(2012, 12, 9);\n  EXPECT_THROW_MSG(fmt::format(\"{:s}\", date), FormatError,\n                   \"unmatched '}' in format string\");\n}\n\nclass Answer {};\n\ntemplate <typename Char>\nvoid format_arg(fmt::BasicFormatter<Char> &f, const Char *, Answer) {\n  f.writer() << \"42\";\n}\n\nTEST(FormatterTest, CustomFormat) {\n  EXPECT_EQ(\"42\", format(\"{0}\", Answer()));\n}\n\nTEST(FormatterTest, WideFormatString) {\n  EXPECT_EQ(L\"42\", format(L\"{}\", 42));\n  EXPECT_EQ(L\"4.2\", format(L\"{}\", 4.2));\n  EXPECT_EQ(L\"abc\", format(L\"{}\", L\"abc\"));\n  EXPECT_EQ(L\"z\", format(L\"{}\", L'z'));\n}\n\nTEST(FormatterTest, FormatStringFromSpeedTest) {\n  EXPECT_EQ(\"1.2340000000:0042:+3.13:str:0x3e8:X:%\",\n      format(\"{0:0.10f}:{1:04}:{2:+g}:{3}:{4}:{5}:%\",\n          1.234, 42, 3.13, \"str\", reinterpret_cast<void*>(1000), 'X'));\n}\n\nTEST(FormatterTest, FormatExamples) {\n  using fmt::hex;\n  EXPECT_EQ(\"0000cafe\", (MemoryWriter() << pad(hex(0xcafe), 8, '0')).str());\n\n  std::string message = format(\"The answer is {}\", 42);\n  EXPECT_EQ(\"The answer is 42\", message);\n\n  EXPECT_EQ(\"42\", format(\"{}\", 42));\n  EXPECT_EQ(\"42\", format(std::string(\"{}\"), 42));\n\n  MemoryWriter out;\n  out << \"The answer is \" << 42 << \"\\n\";\n  out.write(\"({:+f}, {:+f})\", -3.14, 3.14);\n  EXPECT_EQ(\"The answer is 42\\n(-3.140000, +3.140000)\", out.str());\n\n  {\n    MemoryWriter writer;\n    for (int i = 0; i < 10; i++)\n      writer.write(\"{}\", i);\n    std::string s = writer.str(); // s == 0123456789\n    EXPECT_EQ(\"0123456789\", s);\n  }\n\n  const char *filename = \"nonexistent\";\n  FILE *ftest = safe_fopen(filename, \"r\");\n  if (ftest) fclose(ftest);\n  int error_code = errno;\n  EXPECT_TRUE(ftest == 0);\n  EXPECT_SYSTEM_ERROR({\n    FILE *f = safe_fopen(filename, \"r\");\n    if (!f)\n      throw fmt::SystemError(errno, \"Cannot open file '{}'\", filename);\n    fclose(f);\n  }, error_code, \"Cannot open file 'nonexistent'\");\n}\n\nTEST(FormatterTest, Examples) {\n  EXPECT_EQ(\"First, thou shalt count to three\",\n      format(\"First, thou shalt count to {0}\", \"three\"));\n  EXPECT_EQ(\"Bring me a shrubbery\",\n      format(\"Bring me a {}\", \"shrubbery\"));\n  EXPECT_EQ(\"From 1 to 3\", format(\"From {} to {}\", 1, 3));\n\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"%03.2f\", -1.2);\n  EXPECT_EQ(buffer, format(\"{:03.2f}\", -1.2));\n\n  EXPECT_EQ(\"a, b, c\", format(\"{0}, {1}, {2}\", 'a', 'b', 'c'));\n  EXPECT_EQ(\"a, b, c\", format(\"{}, {}, {}\", 'a', 'b', 'c'));\n  EXPECT_EQ(\"c, b, a\", format(\"{2}, {1}, {0}\", 'a', 'b', 'c'));\n  EXPECT_EQ(\"abracadabra\", format(\"{0}{1}{0}\", \"abra\", \"cad\"));\n\n  EXPECT_EQ(\"left aligned                  \",\n      format(\"{:<30}\", \"left aligned\"));\n  EXPECT_EQ(\"                 right aligned\",\n      format(\"{:>30}\", \"right aligned\"));\n  EXPECT_EQ(\"           centered           \",\n      format(\"{:^30}\", \"centered\"));\n  EXPECT_EQ(\"***********centered***********\",\n      format(\"{:*^30}\", \"centered\"));\n\n  EXPECT_EQ(\"+3.140000; -3.140000\",\n      format(\"{:+f}; {:+f}\", 3.14, -3.14));\n  EXPECT_EQ(\" 3.140000; -3.140000\",\n      format(\"{: f}; {: f}\", 3.14, -3.14));\n  EXPECT_EQ(\"3.140000; -3.140000\",\n      format(\"{:-f}; {:-f}\", 3.14, -3.14));\n\n  EXPECT_EQ(\"int: 42;  hex: 2a;  oct: 52\",\n      format(\"int: {0:d};  hex: {0:x};  oct: {0:o}\", 42));\n  EXPECT_EQ(\"int: 42;  hex: 0x2a;  oct: 052\",\n      format(\"int: {0:d};  hex: {0:#x};  oct: {0:#o}\", 42));\n\n  EXPECT_EQ(\"The answer is 42\", format(\"The answer is {}\", 42));\n  EXPECT_THROW_MSG(\n    format(\"The answer is {:d}\", \"forty-two\"), FormatError,\n    \"unknown format code 'd' for string\");\n\n  EXPECT_EQ(L\"Cyrillic letter \\x42e\",\n    format(L\"Cyrillic letter {}\", L'\\x42e'));\n\n  EXPECT_WRITE(stdout,\n      fmt::print(\"{}\", std::numeric_limits<double>::infinity()), \"inf\");\n}\n\nTEST(FormatIntTest, Data) {\n  fmt::FormatInt format_int(42);\n  EXPECT_EQ(\"42\", std::string(format_int.data(), format_int.size()));\n}\n\nTEST(FormatIntTest, FormatInt) {\n  EXPECT_EQ(\"42\", fmt::FormatInt(42).str());\n  EXPECT_EQ(2u, fmt::FormatInt(42).size());\n  EXPECT_EQ(\"-42\", fmt::FormatInt(-42).str());\n  EXPECT_EQ(3u, fmt::FormatInt(-42).size());\n  EXPECT_EQ(\"42\", fmt::FormatInt(42ul).str());\n  EXPECT_EQ(\"-42\", fmt::FormatInt(-42l).str());\n  EXPECT_EQ(\"42\", fmt::FormatInt(42ull).str());\n  EXPECT_EQ(\"-42\", fmt::FormatInt(-42ll).str());\n  std::ostringstream os;\n  os << std::numeric_limits<int64_t>::max();\n  EXPECT_EQ(os.str(),\n            fmt::FormatInt(std::numeric_limits<int64_t>::max()).str());\n}\n\ntemplate <typename T>\nstd::string format_decimal(T value) {\n  char buffer[10];\n  char *ptr = buffer;\n  fmt::format_decimal(ptr, value);\n  return std::string(buffer, ptr);\n}\n\nTEST(FormatIntTest, FormatDec) {\n  EXPECT_EQ(\"-42\", format_decimal(static_cast<signed char>(-42)));\n  EXPECT_EQ(\"-42\", format_decimal(static_cast<short>(-42)));\n  std::ostringstream os;\n  os << std::numeric_limits<unsigned short>::max();\n  EXPECT_EQ(os.str(),\n            format_decimal(std::numeric_limits<unsigned short>::max()));\n  EXPECT_EQ(\"1\", format_decimal(1));\n  EXPECT_EQ(\"-1\", format_decimal(-1));\n  EXPECT_EQ(\"42\", format_decimal(42));\n  EXPECT_EQ(\"-42\", format_decimal(-42));\n  EXPECT_EQ(\"42\", format_decimal(42l));\n  EXPECT_EQ(\"42\", format_decimal(42ul));\n  EXPECT_EQ(\"42\", format_decimal(42ll));\n  EXPECT_EQ(\"42\", format_decimal(42ull));\n}\n\nTEST(FormatTest, Print) {\n#if FMT_USE_FILE_DESCRIPTORS\n  EXPECT_WRITE(stdout, fmt::print(\"Don't {}!\", \"panic\"), \"Don't panic!\");\n  EXPECT_WRITE(stderr,\n      fmt::print(stderr, \"Don't {}!\", \"panic\"), \"Don't panic!\");\n#endif\n}\n\n#if FMT_USE_FILE_DESCRIPTORS\nTEST(FormatTest, PrintColored) {\n  EXPECT_WRITE(stdout, fmt::print_colored(fmt::RED, \"Hello, {}!\\n\", \"world\"),\n    \"\\x1b[31mHello, world!\\n\\x1b[0m\");\n}\n#endif\n\nTEST(FormatTest, Variadic) {\n  EXPECT_EQ(\"abc1\", format(\"{}c{}\", \"ab\", 1));\n  EXPECT_EQ(L\"abc1\", format(L\"{}c{}\", L\"ab\", 1));\n}\n\nTEST(FormatTest, JoinArg) {\n  using fmt::join;\n  int v1[3] = { 1, 2, 3 };\n  std::vector<float> v2;\n  v2.push_back(1.2f);\n  v2.push_back(3.4f);\n\n  EXPECT_EQ(\"(1, 2, 3)\", format(\"({})\", join(v1, v1 + 3, \", \")));\n  EXPECT_EQ(\"(1)\", format(\"({})\", join(v1, v1 + 1, \", \")));\n  EXPECT_EQ(\"()\", format(\"({})\", join(v1, v1, \", \")));\n  EXPECT_EQ(\"(001, 002, 003)\", format(\"({:03})\", join(v1, v1 + 3, \", \")));\n  EXPECT_EQ(\"(+01.20, +03.40)\",\n            format(\"({:+06.2f})\", join(v2.begin(), v2.end(), \", \")));\n\n  EXPECT_EQ(L\"(1, 2, 3)\", format(L\"({})\", join(v1, v1 + 3, L\", \")));\n  EXPECT_EQ(\"1, 2, 3\", format(\"{0:{1}}\", join(v1, v1 + 3, \", \"), 1)); \n\n#if FMT_HAS_GXX_CXX11\n  EXPECT_EQ(\"(1, 2, 3)\", format(\"({})\", join(v1, \", \")));\n  EXPECT_EQ(\"(+01.20, +03.40)\", format(\"({:+06.2f})\", join(v2, \", \")));\n#endif\n}\n\ntemplate <typename T>\nstd::string str(const T &value) {\n  return fmt::format(\"{}\", value);\n}\n\nTEST(StrTest, Convert) {\n  EXPECT_EQ(\"42\", str(42));\n  std::string s = str(Date(2012, 12, 9));\n  EXPECT_EQ(\"2012-12-9\", s);\n}\n\nstd::string format_message(int id, const char *format,\n    const fmt::ArgList &args) {\n  MemoryWriter w;\n  w.write(\"[{}] \", id);\n  w.write(format, args);\n  return w.str();\n}\n\nFMT_VARIADIC(std::string, format_message, int, const char *)\n\nTEST(FormatTest, FormatMessageExample) {\n  EXPECT_EQ(\"[42] something happened\",\n      format_message(42, \"{} happened\", \"something\"));\n}\n\nclass test_class\n{\npublic:\n  std::string format_message(int id, const char *format,const fmt::ArgList &args) const {\n    MemoryWriter w;\n    w.write(\"[{}] \", id);\n    w.write(format, args);\n    return w.str();\n  }\n  FMT_VARIADIC_CONST(std::string, format_message, int, const char *)\n};\n\nTEST(FormatTest, ConstFormatMessage) {\n  test_class c;\n  EXPECT_EQ(\"[42] something happened\",\n    c.format_message(42, \"{} happened\", \"something\"));\n}\n\n#if FMT_USE_VARIADIC_TEMPLATES\ntemplate<typename... Args>\nvoid print_error(const char *file, int line, const char *format,\n                 const Args & ... args) {\n  fmt::print(\"{}: {}: \", file, line);\n  fmt::print(format, args...);\n}\n#endif\n\nTEST(FormatTest, MaxArgs) {\n  EXPECT_EQ(\"0123456789abcde\",\n            fmt::format(\"{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}\",\n                        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e'));\n}\n\n#if FMT_USE_USER_DEFINED_LITERALS\n// Passing user-defined literals directly to EXPECT_EQ causes problems\n// with macro argument stringification (#) on some versions of GCC.\n// Workaround: Assing the UDL result to a variable before the macro.\n\nusing namespace fmt::literals;\n\nTEST(LiteralsTest, Format) {\n  auto udl_format = \"{}c{}\"_format(\"ab\", 1);\n  EXPECT_EQ(format(\"{}c{}\", \"ab\", 1), udl_format);\n  auto udl_format_w = L\"{}c{}\"_format(L\"ab\", 1);\n  EXPECT_EQ(format(L\"{}c{}\", L\"ab\", 1), udl_format_w);\n}\n\nTEST(LiteralsTest, NamedArg) {\n  auto udl_a = format(\"{first}{second}{first}{third}\",\n                      \"first\"_a=\"abra\", \"second\"_a=\"cad\", \"third\"_a=99);\n  EXPECT_EQ(format(\"{first}{second}{first}{third}\",\n                   fmt::arg(\"first\", \"abra\"), fmt::arg(\"second\", \"cad\"),\n                   fmt::arg(\"third\", 99)),\n            udl_a);\n  auto udl_a_w = format(L\"{first}{second}{first}{third}\",\n                        L\"first\"_a=L\"abra\", L\"second\"_a=L\"cad\", L\"third\"_a=99);\n  EXPECT_EQ(format(L\"{first}{second}{first}{third}\",\n                   fmt::arg(L\"first\", L\"abra\"), fmt::arg(L\"second\", L\"cad\"),\n                   fmt::arg(L\"third\", 99)),\n            udl_a_w);\n}\n#endif // FMT_USE_USER_DEFINED_LITERALS\n\nenum TestEnum { A };\n\nTEST(FormatTest, Enum) {\n  EXPECT_EQ(\"0\", fmt::format(\"{}\", A));\n}\n\n#if __cplusplus >= 201103L\nenum TestFixedEnum : short { B };\n\nTEST(FormatTest, FixedEnum) {\n  EXPECT_EQ(\"0\", fmt::format(\"{}\", B));\n}\n#endif\n\nclass MockArgFormatter :\n    public fmt::internal::ArgFormatterBase<MockArgFormatter, char> {\n public:\n  typedef fmt::internal::ArgFormatterBase<MockArgFormatter, char> Base;\n\n  MockArgFormatter(fmt::BasicFormatter<char, MockArgFormatter> &f,\n                   fmt::FormatSpec &s, const char *)\n    : fmt::internal::ArgFormatterBase<MockArgFormatter, char>(f.writer(), s) {\n    EXPECT_CALL(*this, visit_int(42));\n  }\n\n  MOCK_METHOD1(visit_int, void (int value));\n};\n\nvoid custom_format(const char *format_str, fmt::ArgList args) {\n  fmt::MemoryWriter writer;\n  fmt::BasicFormatter<char, MockArgFormatter> formatter(args, writer);\n  formatter.format(format_str);\n}\nFMT_VARIADIC(void, custom_format, const char *)\n\nTEST(FormatTest, CustomArgFormatter) {\n  custom_format(\"{}\", 42);\n}\n\nvoid convert(int);\n\n// Check if there is no collision with convert function in the global namespace.\nTEST(FormatTest, ConvertCollision) {\n  fmt::format(\"{}\", 42);\n}\n"], "fixing_code": ["/*\n Formatting library for C++\n\n Copyright (c) 2012 - 2016, Victor Zverovich\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// transition helper\n#ifdef FMT_FORMAT_PROVIDE_PRINTF\n#include \"printf.h\"\n#endif\n\n#ifndef FMT_FORMAT_H_\n#define FMT_FORMAT_H_\n\n#define FMT_INCLUDE\n#include <cassert>\n#include <clocale>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <limits>\n#include <memory>\n#include <stdexcept>\n#include <string>\n#include <vector>\n#include <utility>  // for std::pair\n#undef FMT_INCLUDE\n\n// The fmt library version in the form major * 10000 + minor * 100 + patch.\n#define FMT_VERSION 40101\n\n#if defined(__has_include)\n# define FMT_HAS_INCLUDE(x) __has_include(x)\n#else\n# define FMT_HAS_INCLUDE(x) 0\n#endif\n\n#if (FMT_HAS_INCLUDE(<string_view>) && __cplusplus > 201402L) || \\\n    (defined(_MSVC_LANG) && _MSVC_LANG > 201402L && _MSC_VER >= 1910)\n# include <string_view>\n# define FMT_HAS_STRING_VIEW 1\n# define FMT_HAS_EXPERIMENTAL_STRING_VIEW 0\n#else\n# define FMT_HAS_STRING_VIEW 0\n# if (FMT_HAS_INCLUDE(<experimental/string_view>) && __cplusplus >= 201402L)\n#  include <experimental/string_view>\n#  define FMT_HAS_EXPERIMENTAL_STRING_VIEW 1\n# else\n#  define FMT_HAS_EXPERIMENTAL_STRING_VIEW 0\n# endif\n#endif\n\n#if defined _SECURE_SCL && _SECURE_SCL\n# define FMT_SECURE_SCL _SECURE_SCL\n#else\n# define FMT_SECURE_SCL 0\n#endif\n\n#if FMT_SECURE_SCL\n# include <iterator>\n#endif\n\n#ifdef _MSC_VER\n# define FMT_MSC_VER _MSC_VER\n#else\n# define FMT_MSC_VER 0\n#endif\n\n#if FMT_MSC_VER && FMT_MSC_VER <= 1500\ntypedef unsigned __int32 uint32_t;\ntypedef unsigned __int64 uint64_t;\ntypedef __int64          intmax_t;\n#else\n#include <stdint.h>\n#endif\n\n#if !defined(FMT_HEADER_ONLY) && defined(_WIN32)\n# ifdef FMT_EXPORT\n#  define FMT_API __declspec(dllexport)\n# elif defined(FMT_SHARED)\n#  define FMT_API __declspec(dllimport)\n# endif\n#endif\n#ifndef FMT_API\n# define FMT_API\n#endif\n\n#ifdef __GNUC__\n# define FMT_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)\n# define FMT_GCC_EXTENSION __extension__\n# if FMT_GCC_VERSION >= 406\n#  pragma GCC diagnostic push\n// Disable the warning about \"long long\" which is sometimes reported even\n// when using __extension__.\n#  pragma GCC diagnostic ignored \"-Wlong-long\"\n// Disable the warning about declaration shadowing because it affects too\n// many valid cases.\n#  pragma GCC diagnostic ignored \"-Wshadow\"\n// Disable the warning about implicit conversions that may change the sign of\n// an integer; silencing it otherwise would require many explicit casts.\n#  pragma GCC diagnostic ignored \"-Wsign-conversion\"\n# endif\n# if __cplusplus >= 201103L || defined __GXX_EXPERIMENTAL_CXX0X__\n#  define FMT_HAS_GXX_CXX11 1\n# endif\n#else\n# define FMT_GCC_VERSION 0\n# define FMT_GCC_EXTENSION\n# define FMT_HAS_GXX_CXX11 0\n#endif\n\n#if defined(__INTEL_COMPILER)\n# define FMT_ICC_VERSION __INTEL_COMPILER\n#elif defined(__ICL)\n# define FMT_ICC_VERSION __ICL\n#endif\n\n#if defined(__clang__) && !defined(FMT_ICC_VERSION)\n# define FMT_CLANG_VERSION (__clang_major__ * 100 + __clang_minor__)\n# pragma clang diagnostic push\n# pragma clang diagnostic ignored \"-Wdocumentation-unknown-command\"\n# pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\n#ifdef __GNUC_LIBSTD__\n# define FMT_GNUC_LIBSTD_VERSION (__GNUC_LIBSTD__ * 100 + __GNUC_LIBSTD_MINOR__)\n#endif\n\n#ifdef __has_feature\n# define FMT_HAS_FEATURE(x) __has_feature(x)\n#else\n# define FMT_HAS_FEATURE(x) 0\n#endif\n\n#ifdef __has_builtin\n# define FMT_HAS_BUILTIN(x) __has_builtin(x)\n#else\n# define FMT_HAS_BUILTIN(x) 0\n#endif\n\n#ifdef __has_cpp_attribute\n# define FMT_HAS_CPP_ATTRIBUTE(x) __has_cpp_attribute(x)\n#else\n# define FMT_HAS_CPP_ATTRIBUTE(x) 0\n#endif\n\n#if FMT_HAS_CPP_ATTRIBUTE(maybe_unused)\n# define FMT_HAS_CXX17_ATTRIBUTE_MAYBE_UNUSED\n// VC++ 1910 support /std: option and that will set _MSVC_LANG macro\n// Clang with Microsoft CodeGen doesn't define _MSVC_LANG macro\n#elif defined(_MSVC_LANG) && _MSVC_LANG > 201402 && _MSC_VER >= 1910\n# define FMT_HAS_CXX17_ATTRIBUTE_MAYBE_UNUSED\n#endif\n\n#ifdef FMT_HAS_CXX17_ATTRIBUTE_MAYBE_UNUSED\n# define FMT_MAYBE_UNUSED [[maybe_unused]]\n// g++/clang++ also support [[gnu::unused]]. However, we don't use it.\n#elif defined(__GNUC__)\n# define FMT_MAYBE_UNUSED __attribute__((unused))\n#else\n# define FMT_MAYBE_UNUSED\n#endif\n\n// Use the compiler's attribute noreturn\n#if defined(__MINGW32__) || defined(__MINGW64__)\n# define FMT_NORETURN __attribute__((noreturn))\n#elif FMT_HAS_CPP_ATTRIBUTE(noreturn) && __cplusplus >= 201103L\n# define FMT_NORETURN [[noreturn]]\n#else\n# define FMT_NORETURN\n#endif\n\n#ifndef FMT_USE_VARIADIC_TEMPLATES\n// Variadic templates are available in GCC since version 4.4\n// (http://gcc.gnu.org/projects/cxx0x.html) and in Visual C++\n// since version 2013.\n# define FMT_USE_VARIADIC_TEMPLATES \\\n   (FMT_HAS_FEATURE(cxx_variadic_templates) || \\\n       (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800)\n#endif\n\n#ifndef FMT_USE_RVALUE_REFERENCES\n// Don't use rvalue references when compiling with clang and an old libstdc++\n// as the latter doesn't provide std::move.\n# if defined(FMT_GNUC_LIBSTD_VERSION) && FMT_GNUC_LIBSTD_VERSION <= 402\n#  define FMT_USE_RVALUE_REFERENCES 0\n# else\n#  define FMT_USE_RVALUE_REFERENCES \\\n    (FMT_HAS_FEATURE(cxx_rvalue_references) || \\\n        (FMT_GCC_VERSION >= 403 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1600)\n# endif\n#endif\n\n#if __cplusplus >= 201103L || FMT_MSC_VER >= 1700\n# define FMT_USE_ALLOCATOR_TRAITS 1\n#else\n# define FMT_USE_ALLOCATOR_TRAITS 0\n#endif\n\n// Check if exceptions are disabled.\n#if defined(__GNUC__) && !defined(__EXCEPTIONS)\n# define FMT_EXCEPTIONS 0\n#endif\n#if FMT_MSC_VER && !_HAS_EXCEPTIONS\n# define FMT_EXCEPTIONS 0\n#endif\n#ifndef FMT_EXCEPTIONS\n# define FMT_EXCEPTIONS 1\n#endif\n\n#ifndef FMT_THROW\n# if FMT_EXCEPTIONS\n#  define FMT_THROW(x) throw x\n# else\n#  define FMT_THROW(x) assert(false)\n# endif\n#endif\n\n// Define FMT_USE_NOEXCEPT to make fmt use noexcept (C++11 feature).\n#ifndef FMT_USE_NOEXCEPT\n# define FMT_USE_NOEXCEPT 0\n#endif\n\n#if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \\\n    (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \\\n    FMT_MSC_VER >= 1900\n# define FMT_DETECTED_NOEXCEPT noexcept\n#else\n# define FMT_DETECTED_NOEXCEPT throw()\n#endif\n\n#ifndef FMT_NOEXCEPT\n# if FMT_EXCEPTIONS\n#  define FMT_NOEXCEPT FMT_DETECTED_NOEXCEPT\n# else\n#  define FMT_NOEXCEPT\n# endif\n#endif\n\n// This is needed because GCC still uses throw() in its headers when exceptions\n// are disabled.\n#if FMT_GCC_VERSION\n# define FMT_DTOR_NOEXCEPT FMT_DETECTED_NOEXCEPT\n#else\n# define FMT_DTOR_NOEXCEPT FMT_NOEXCEPT\n#endif\n\n#ifndef FMT_OVERRIDE\n# if (defined(FMT_USE_OVERRIDE) && FMT_USE_OVERRIDE) || FMT_HAS_FEATURE(cxx_override) || \\\n   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \\\n   FMT_MSC_VER >= 1900\n#  define FMT_OVERRIDE override\n# else\n#  define FMT_OVERRIDE\n# endif\n#endif\n\n#ifndef FMT_NULL\n# if FMT_HAS_FEATURE(cxx_nullptr) || \\\n   (FMT_GCC_VERSION >= 408 && FMT_HAS_GXX_CXX11) || \\\n   FMT_MSC_VER >= 1600\n#  define FMT_NULL nullptr\n# else\n#  define FMT_NULL NULL\n# endif\n#endif\n\n// A macro to disallow the copy constructor and operator= functions\n// This should be used in the private: declarations for a class\n#ifndef FMT_USE_DELETED_FUNCTIONS\n# define FMT_USE_DELETED_FUNCTIONS 0\n#endif\n\n#if FMT_USE_DELETED_FUNCTIONS || FMT_HAS_FEATURE(cxx_deleted_functions) || \\\n  (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800\n# define FMT_DELETED_OR_UNDEFINED  = delete\n# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \\\n    TypeName(const TypeName&) = delete; \\\n    TypeName& operator=(const TypeName&) = delete\n#else\n# define FMT_DELETED_OR_UNDEFINED\n# define FMT_DISALLOW_COPY_AND_ASSIGN(TypeName) \\\n    TypeName(const TypeName&); \\\n    TypeName& operator=(const TypeName&)\n#endif\n\n#ifndef FMT_USE_DEFAULTED_FUNCTIONS\n# define FMT_USE_DEFAULTED_FUNCTIONS 0\n#endif\n\n#ifndef FMT_DEFAULTED_COPY_CTOR\n# if FMT_USE_DEFAULTED_FUNCTIONS || FMT_HAS_FEATURE(cxx_defaulted_functions) || \\\n   (FMT_GCC_VERSION >= 404 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1800\n#  define FMT_DEFAULTED_COPY_CTOR(TypeName) \\\n    TypeName(const TypeName&) = default;\n# else\n#  define FMT_DEFAULTED_COPY_CTOR(TypeName)\n# endif\n#endif\n\n#ifndef FMT_USE_USER_DEFINED_LITERALS\n// All compilers which support UDLs also support variadic templates. This\n// makes the fmt::literals implementation easier. However, an explicit check\n// for variadic templates is added here just in case.\n// For Intel's compiler both it and the system gcc/msc must support UDLs.\n# if FMT_USE_VARIADIC_TEMPLATES && FMT_USE_RVALUE_REFERENCES && \\\n   (FMT_HAS_FEATURE(cxx_user_literals) || \\\n     (FMT_GCC_VERSION >= 407 && FMT_HAS_GXX_CXX11) || FMT_MSC_VER >= 1900) && \\\n   (!defined(FMT_ICC_VERSION) || FMT_ICC_VERSION >= 1500)\n#  define FMT_USE_USER_DEFINED_LITERALS 1\n# else\n#  define FMT_USE_USER_DEFINED_LITERALS 0\n# endif\n#endif\n\n#ifndef FMT_USE_EXTERN_TEMPLATES\n# define FMT_USE_EXTERN_TEMPLATES \\\n    (FMT_CLANG_VERSION >= 209 || (FMT_GCC_VERSION >= 303 && FMT_HAS_GXX_CXX11))\n#endif\n\n#ifdef FMT_HEADER_ONLY\n// If header only do not use extern templates.\n# undef FMT_USE_EXTERN_TEMPLATES\n# define FMT_USE_EXTERN_TEMPLATES 0\n#endif\n\n#ifndef FMT_ASSERT\n# define FMT_ASSERT(condition, message) assert((condition) && message)\n#endif\n\n// __builtin_clz is broken in clang with Microsoft CodeGen:\n// https://github.com/fmtlib/fmt/issues/519\n#ifndef _MSC_VER\n# if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clz)\n#  define FMT_BUILTIN_CLZ(n) __builtin_clz(n)\n# endif\n\n# if FMT_GCC_VERSION >= 400 || FMT_HAS_BUILTIN(__builtin_clzll)\n#  define FMT_BUILTIN_CLZLL(n) __builtin_clzll(n)\n# endif\n#endif\n\n// Some compilers masquerade as both MSVC and GCC-likes or\n// otherwise support __builtin_clz and __builtin_clzll, so\n// only define FMT_BUILTIN_CLZ using the MSVC intrinsics\n// if the clz and clzll builtins are not available.\n#if FMT_MSC_VER && !defined(FMT_BUILTIN_CLZLL) && !defined(_MANAGED)\n# include <intrin.h>  // _BitScanReverse, _BitScanReverse64\n\nnamespace fmt {\nnamespace internal {\n// avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning\n# ifndef __clang__\n#  pragma intrinsic(_BitScanReverse)\n# endif\ninline uint32_t clz(uint32_t x) {\n  unsigned long r = 0;\n  _BitScanReverse(&r, x);\n\n  assert(x != 0);\n  // Static analysis complains about using uninitialized data\n  // \"r\", but the only way that can happen is if \"x\" is 0,\n  // which the callers guarantee to not happen.\n# pragma warning(suppress: 6102)\n  return 31 - r;\n}\n# define FMT_BUILTIN_CLZ(n) fmt::internal::clz(n)\n\n// avoid Clang with Microsoft CodeGen's -Wunknown-pragmas warning\n# if defined(_WIN64) && !defined(__clang__)\n#  pragma intrinsic(_BitScanReverse64)\n# endif\n\ninline uint32_t clzll(uint64_t x) {\n  unsigned long r = 0;\n# ifdef _WIN64\n  _BitScanReverse64(&r, x);\n# else\n  // Scan the high 32 bits.\n  if (_BitScanReverse(&r, static_cast<uint32_t>(x >> 32)))\n    return 63 - (r + 32);\n\n  // Scan the low 32 bits.\n  _BitScanReverse(&r, static_cast<uint32_t>(x));\n# endif\n\n  assert(x != 0);\n  // Static analysis complains about using uninitialized data\n  // \"r\", but the only way that can happen is if \"x\" is 0,\n  // which the callers guarantee to not happen.\n# pragma warning(suppress: 6102)\n  return 63 - r;\n}\n# define FMT_BUILTIN_CLZLL(n) fmt::internal::clzll(n)\n}\n}\n#endif\n\nnamespace fmt {\nnamespace internal {\nstruct DummyInt {\n  int data[2];\n  operator int() const { return 0; }\n};\ntypedef std::numeric_limits<fmt::internal::DummyInt> FPUtil;\n\n// Dummy implementations of system functions such as signbit and ecvt called\n// if the latter are not available.\ninline DummyInt signbit(...) { return DummyInt(); }\ninline DummyInt _ecvt_s(...) { return DummyInt(); }\ninline DummyInt isinf(...) { return DummyInt(); }\ninline DummyInt _finite(...) { return DummyInt(); }\ninline DummyInt isnan(...) { return DummyInt(); }\ninline DummyInt _isnan(...) { return DummyInt(); }\n\n// A helper function to suppress bogus \"conditional expression is constant\"\n// warnings.\ntemplate <typename T>\ninline T const_check(T value) { return value; }\n}\n}  // namespace fmt\n\nnamespace std {\n// Standard permits specialization of std::numeric_limits. This specialization\n// is used to resolve ambiguity between isinf and std::isinf in glibc:\n// https://gcc.gnu.org/bugzilla/show_bug.cgi?id=48891\n// and the same for isnan and signbit.\ntemplate <>\nclass numeric_limits<fmt::internal::DummyInt> :\n    public std::numeric_limits<int> {\n public:\n  // Portable version of isinf.\n  template <typename T>\n  static bool isinfinity(T x) {\n    using namespace fmt::internal;\n    // The resolution \"priority\" is:\n    // isinf macro > std::isinf > ::isinf > fmt::internal::isinf\n    if (const_check(sizeof(isinf(x)) != sizeof(fmt::internal::DummyInt))) {\n      return isinf(x) != 0;\n    }\n    return !_finite(static_cast<double>(x));\n  }\n\n  // Portable version of isnan.\n  template <typename T>\n  static bool isnotanumber(T x) {\n    using namespace fmt::internal;\n    if (const_check(sizeof(isnan(x)) != sizeof(fmt::internal::DummyInt))) {\n      return isnan(x) != 0;\n    }\n    return _isnan(static_cast<double>(x)) != 0;\n  }\n\n  // Portable version of signbit.\n  static bool isnegative(double x) {\n    using namespace fmt::internal;\n    if (const_check(sizeof(signbit(x)) != sizeof(fmt::internal::DummyInt))) {\n      return signbit(x) != 0;\n    }\n    if (x < 0) return true;\n    if (!isnotanumber(x)) return false;\n    int dec = 0, sign = 0;\n    char buffer[2];  // The buffer size must be >= 2 or _ecvt_s will fail.\n    _ecvt_s(buffer, sizeof(buffer), x, 0, &dec, &sign);\n    return sign != 0;\n  }\n};\n}  // namespace std\n\nnamespace fmt {\n\n// Fix the warning about long long on older versions of GCC\n// that don't support the diagnostic pragma.\nFMT_GCC_EXTENSION typedef long long LongLong;\nFMT_GCC_EXTENSION typedef unsigned long long ULongLong;\n\n#if FMT_USE_RVALUE_REFERENCES\nusing std::move;\n#endif\n\ntemplate <typename Char>\nclass BasicWriter;\n\ntypedef BasicWriter<char> Writer;\ntypedef BasicWriter<wchar_t> WWriter;\n\ntemplate <typename Char>\nclass ArgFormatter;\n\nstruct FormatSpec;\n\ntemplate <typename Impl, typename Char, typename Spec = fmt::FormatSpec>\nclass BasicPrintfArgFormatter;\n\ntemplate <typename CharType,\n          typename ArgFormatter = fmt::ArgFormatter<CharType> >\nclass BasicFormatter;\n\n/**\n  \\rst\n  A string reference. It can be constructed from a C string or\n  ``std::basic_string``.\n\n  You can use one of the following typedefs for common character types:\n\n  +------------+-------------------------+\n  | Type       | Definition              |\n  +============+=========================+\n  | StringRef  | BasicStringRef<char>    |\n  +------------+-------------------------+\n  | WStringRef | BasicStringRef<wchar_t> |\n  +------------+-------------------------+\n\n  This class is most useful as a parameter type to allow passing\n  different types of strings to a function, for example::\n\n    template <typename... Args>\n    std::string format(StringRef format_str, const Args & ... args);\n\n    format(\"{}\", 42);\n    format(std::string(\"{}\"), 42);\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicStringRef {\n private:\n  const Char *data_;\n  std::size_t size_;\n\n public:\n  /** Constructs a string reference object from a C string and a size. */\n  BasicStringRef(const Char *s, std::size_t size) : data_(s), size_(size) {}\n\n  /**\n    \\rst\n    Constructs a string reference object from a C string computing\n    the size with ``std::char_traits<Char>::length``.\n    \\endrst\n   */\n  BasicStringRef(const Char *s)\n    : data_(s), size_(std::char_traits<Char>::length(s)) {}\n\n  /**\n    \\rst\n    Constructs a string reference from a ``std::basic_string`` object.\n    \\endrst\n   */\n  template <typename Allocator>\n  BasicStringRef(\n      const std::basic_string<Char, std::char_traits<Char>, Allocator> &s)\n  : data_(s.c_str()), size_(s.size()) {}\n\n#if FMT_HAS_STRING_VIEW\n  /**\n    \\rst\n    Constructs a string reference from a ``std::basic_string_view`` object.\n    \\endrst\n   */\n  BasicStringRef(\n      const std::basic_string_view<Char, std::char_traits<Char>> &s)\n  : data_(s.data()), size_(s.size()) {}\n\n  /**\n   \\rst\n   Converts a string reference to an ``std::string_view`` object.\n   \\endrst\n  */\n  explicit operator std::basic_string_view<Char>() const FMT_NOEXCEPT {\n    return std::basic_string_view<Char>(data_, size_);\n  }\n#endif\n\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  /**\n  \\rst\n  Constructs a string reference from a ``std::experimental::basic_string_view`` object.\n  \\endrst\n  */\n  BasicStringRef(\n\t  const std::experimental::basic_string_view<Char, std::char_traits<Char>> &s)\n\t  : data_(s.data()), size_(s.size()) {}\n\n  /**\n  \\rst\n  Converts a string reference to an ``std::string_view`` object.\n  \\endrst\n  */\n  explicit operator std::experimental::basic_string_view<Char>() const FMT_NOEXCEPT {\n\t  return std::experimental::basic_string_view<Char>(data_, size_);\n  }\n#endif\n\n  /**\n    \\rst\n    Converts a string reference to an ``std::string`` object.\n    \\endrst\n   */\n  std::basic_string<Char> to_string() const {\n    return std::basic_string<Char>(data_, size_);\n  }\n\n  /** Returns a pointer to the string data. */\n  const Char *data() const { return data_; }\n\n  /** Returns the string size. */\n  std::size_t size() const { return size_; }\n\n  // Lexicographically compare this string reference to other.\n  int compare(BasicStringRef other) const {\n    std::size_t size = size_ < other.size_ ? size_ : other.size_;\n    int result = std::char_traits<Char>::compare(data_, other.data_, size);\n    if (result == 0)\n      result = size_ == other.size_ ? 0 : (size_ < other.size_ ? -1 : 1);\n    return result;\n  }\n\n  friend bool operator==(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) == 0;\n  }\n  friend bool operator!=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) != 0;\n  }\n  friend bool operator<(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) < 0;\n  }\n  friend bool operator<=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) <= 0;\n  }\n  friend bool operator>(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) > 0;\n  }\n  friend bool operator>=(BasicStringRef lhs, BasicStringRef rhs) {\n    return lhs.compare(rhs) >= 0;\n  }\n};\n\ntypedef BasicStringRef<char> StringRef;\ntypedef BasicStringRef<wchar_t> WStringRef;\n\n/**\n  \\rst\n  A reference to a null terminated string. It can be constructed from a C\n  string or ``std::basic_string``.\n\n  You can use one of the following typedefs for common character types:\n\n  +-------------+--------------------------+\n  | Type        | Definition               |\n  +=============+==========================+\n  | CStringRef  | BasicCStringRef<char>    |\n  +-------------+--------------------------+\n  | WCStringRef | BasicCStringRef<wchar_t> |\n  +-------------+--------------------------+\n\n  This class is most useful as a parameter type to allow passing\n  different types of strings to a function, for example::\n\n    template <typename... Args>\n    std::string format(CStringRef format_str, const Args & ... args);\n\n    format(\"{}\", 42);\n    format(std::string(\"{}\"), 42);\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicCStringRef {\n private:\n  const Char *data_;\n\n public:\n  /** Constructs a string reference object from a C string. */\n  BasicCStringRef(const Char *s) : data_(s) {}\n\n  /**\n    \\rst\n    Constructs a string reference from a ``std::basic_string`` object.\n    \\endrst\n   */\n  template <typename Allocator>\n  BasicCStringRef(\n      const std::basic_string<Char, std::char_traits<Char>, Allocator> &s)\n  : data_(s.c_str()) {}\n\n  /** Returns the pointer to a C string. */\n  const Char *c_str() const { return data_; }\n};\n\ntypedef BasicCStringRef<char> CStringRef;\ntypedef BasicCStringRef<wchar_t> WCStringRef;\n\n/** A formatting error such as invalid format string. */\nclass FormatError : public std::runtime_error {\n public:\n  explicit FormatError(CStringRef message)\n  : std::runtime_error(message.c_str()) {}\n  FormatError(const FormatError &ferr) : std::runtime_error(ferr) {}\n  FMT_API ~FormatError() FMT_DTOR_NOEXCEPT FMT_OVERRIDE;\n};\n\nnamespace internal {\n\n// MakeUnsigned<T>::Type gives an unsigned type corresponding to integer type T.\ntemplate <typename T>\nstruct MakeUnsigned { typedef T Type; };\n\n#define FMT_SPECIALIZE_MAKE_UNSIGNED(T, U) \\\n  template <> \\\n  struct MakeUnsigned<T> { typedef U Type; }\n\nFMT_SPECIALIZE_MAKE_UNSIGNED(char, unsigned char);\nFMT_SPECIALIZE_MAKE_UNSIGNED(signed char, unsigned char);\nFMT_SPECIALIZE_MAKE_UNSIGNED(short, unsigned short);\nFMT_SPECIALIZE_MAKE_UNSIGNED(int, unsigned);\nFMT_SPECIALIZE_MAKE_UNSIGNED(long, unsigned long);\nFMT_SPECIALIZE_MAKE_UNSIGNED(LongLong, ULongLong);\n\n// Casts nonnegative integer to unsigned.\ntemplate <typename Int>\ninline typename MakeUnsigned<Int>::Type to_unsigned(Int value) {\n  FMT_ASSERT(value >= 0, \"negative value\");\n  return static_cast<typename MakeUnsigned<Int>::Type>(value);\n}\n\n// The number of characters to store in the MemoryBuffer object itself\n// to avoid dynamic memory allocation.\nenum { INLINE_BUFFER_SIZE = 500 };\n\n#if FMT_SECURE_SCL\n// Use checked iterator to avoid warnings on MSVC.\ntemplate <typename T>\ninline stdext::checked_array_iterator<T*> make_ptr(T *ptr, std::size_t size) {\n  return stdext::checked_array_iterator<T*>(ptr, size);\n}\n#else\ntemplate <typename T>\ninline T *make_ptr(T *ptr, std::size_t) { return ptr; }\n#endif\n}  // namespace internal\n\n/**\n  \\rst\n  A buffer supporting a subset of ``std::vector``'s operations.\n  \\endrst\n */\ntemplate <typename T>\nclass Buffer {\n private:\n  FMT_DISALLOW_COPY_AND_ASSIGN(Buffer);\n\n protected:\n  T *ptr_;\n  std::size_t size_;\n  std::size_t capacity_;\n\n  Buffer(T *ptr = FMT_NULL, std::size_t capacity = 0)\n    : ptr_(ptr), size_(0), capacity_(capacity) {}\n\n  /**\n    \\rst\n    Increases the buffer capacity to hold at least *size* elements updating\n    ``ptr_`` and ``capacity_``.\n    \\endrst\n   */\n  virtual void grow(std::size_t size) = 0;\n\n public:\n  virtual ~Buffer() {}\n\n  /** Returns the size of this buffer. */\n  std::size_t size() const { return size_; }\n\n  /** Returns the capacity of this buffer. */\n  std::size_t capacity() const { return capacity_; }\n\n  /**\n    Resizes the buffer. If T is a POD type new elements may not be initialized.\n   */\n  void resize(std::size_t new_size) {\n    if (new_size > capacity_)\n      grow(new_size);\n    size_ = new_size;\n  }\n\n  /**\n    \\rst\n    Reserves space to store at least *capacity* elements.\n    \\endrst\n   */\n  void reserve(std::size_t capacity) {\n    if (capacity > capacity_)\n      grow(capacity);\n  }\n\n  void clear() FMT_NOEXCEPT { size_ = 0; }\n\n  void push_back(const T &value) {\n    if (size_ == capacity_)\n      grow(size_ + 1);\n    ptr_[size_++] = value;\n  }\n\n  /** Appends data to the end of the buffer. */\n  template <typename U>\n  void append(const U *begin, const U *end);\n\n  T &operator[](std::size_t index) { return ptr_[index]; }\n  const T &operator[](std::size_t index) const { return ptr_[index]; }\n};\n\ntemplate <typename T>\ntemplate <typename U>\nvoid Buffer<T>::append(const U *begin, const U *end) {\n  FMT_ASSERT(end >= begin, \"negative value\");\n  std::size_t new_size = size_ + static_cast<std::size_t>(end - begin);\n  if (new_size > capacity_)\n    grow(new_size);\n  std::uninitialized_copy(begin, end,\n                          internal::make_ptr(ptr_, capacity_) + size_);\n  size_ = new_size;\n}\n\nnamespace internal {\n\n// A memory buffer for trivially copyable/constructible types with the first\n// SIZE elements stored in the object itself.\ntemplate <typename T, std::size_t SIZE, typename Allocator = std::allocator<T> >\nclass MemoryBuffer : private Allocator, public Buffer<T> {\n private:\n  T data_[SIZE];\n\n  // Deallocate memory allocated by the buffer.\n  void deallocate() {\n    if (this->ptr_ != data_) Allocator::deallocate(this->ptr_, this->capacity_);\n  }\n\n protected:\n  void grow(std::size_t size) FMT_OVERRIDE;\n\n public:\n  explicit MemoryBuffer(const Allocator &alloc = Allocator())\n      : Allocator(alloc), Buffer<T>(data_, SIZE) {}\n  ~MemoryBuffer() FMT_OVERRIDE { deallocate(); }\n\n#if FMT_USE_RVALUE_REFERENCES\n private:\n  // Move data from other to this buffer.\n  void move(MemoryBuffer &other) {\n    Allocator &this_alloc = *this, &other_alloc = other;\n    this_alloc = std::move(other_alloc);\n    this->size_ = other.size_;\n    this->capacity_ = other.capacity_;\n    if (other.ptr_ == other.data_) {\n      this->ptr_ = data_;\n      std::uninitialized_copy(other.data_, other.data_ + this->size_,\n                              make_ptr(data_, this->capacity_));\n    } else {\n      this->ptr_ = other.ptr_;\n      // Set pointer to the inline array so that delete is not called\n      // when deallocating.\n      other.ptr_ = other.data_;\n    }\n  }\n\n public:\n  MemoryBuffer(MemoryBuffer &&other) {\n    move(other);\n  }\n\n  MemoryBuffer &operator=(MemoryBuffer &&other) {\n    assert(this != &other);\n    deallocate();\n    move(other);\n    return *this;\n  }\n#endif\n\n  // Returns a copy of the allocator associated with this buffer.\n  Allocator get_allocator() const { return *this; }\n};\n\ntemplate <typename T, std::size_t SIZE, typename Allocator>\nvoid MemoryBuffer<T, SIZE, Allocator>::grow(std::size_t size) {\n  std::size_t new_capacity = this->capacity_ + this->capacity_ / 2;\n  if (size > new_capacity)\n      new_capacity = size;\n#if FMT_USE_ALLOCATOR_TRAITS\n  T *new_ptr =\n      std::allocator_traits<Allocator>::allocate(*this, new_capacity, FMT_NULL);\n#else\n  T *new_ptr = this->allocate(new_capacity, FMT_NULL);\n#endif\n  // The following code doesn't throw, so the raw pointer above doesn't leak.\n  std::uninitialized_copy(this->ptr_, this->ptr_ + this->size_,\n                          make_ptr(new_ptr, new_capacity));\n  std::size_t old_capacity = this->capacity_;\n  T *old_ptr = this->ptr_;\n  this->capacity_ = new_capacity;\n  this->ptr_ = new_ptr;\n  // deallocate may throw (at least in principle), but it doesn't matter since\n  // the buffer already uses the new storage and will deallocate it in case\n  // of exception.\n  if (old_ptr != data_)\n    Allocator::deallocate(old_ptr, old_capacity);\n}\n\n// A fixed-size buffer.\ntemplate <typename Char>\nclass FixedBuffer : public fmt::Buffer<Char> {\n public:\n  FixedBuffer(Char *array, std::size_t size) : fmt::Buffer<Char>(array, size) {}\n\n protected:\n  FMT_API void grow(std::size_t size) FMT_OVERRIDE;\n};\n\ntemplate <typename Char>\nclass BasicCharTraits {\n public:\n#if FMT_SECURE_SCL\n  typedef stdext::checked_array_iterator<Char*> CharPtr;\n#else\n  typedef Char *CharPtr;\n#endif\n  static Char cast(int value) { return static_cast<Char>(value); }\n};\n\ntemplate <typename Char>\nclass CharTraits;\n\ntemplate <>\nclass CharTraits<char> : public BasicCharTraits<char> {\n private:\n  // Conversion from wchar_t to char is not allowed.\n  static char convert(wchar_t);\n\n public:\n  static char convert(char value) { return value; }\n\n  // Formats a floating-point number.\n  template <typename T>\n  FMT_API static int format_float(char *buffer, std::size_t size,\n      const char *format, unsigned width, int precision, T value);\n};\n\n#if FMT_USE_EXTERN_TEMPLATES\nextern template int CharTraits<char>::format_float<double>\n        (char *buffer, std::size_t size,\n         const char* format, unsigned width, int precision, double value);\nextern template int CharTraits<char>::format_float<long double>\n        (char *buffer, std::size_t size,\n         const char* format, unsigned width, int precision, long double value);\n#endif\n\ntemplate <>\nclass CharTraits<wchar_t> : public BasicCharTraits<wchar_t> {\n public:\n  static wchar_t convert(char value) { return value; }\n  static wchar_t convert(wchar_t value) { return value; }\n\n  template <typename T>\n  FMT_API static int format_float(wchar_t *buffer, std::size_t size,\n      const wchar_t *format, unsigned width, int precision, T value);\n};\n\n#if FMT_USE_EXTERN_TEMPLATES\nextern template int CharTraits<wchar_t>::format_float<double>\n        (wchar_t *buffer, std::size_t size,\n         const wchar_t* format, unsigned width, int precision, double value);\nextern template int CharTraits<wchar_t>::format_float<long double>\n        (wchar_t *buffer, std::size_t size,\n         const wchar_t* format, unsigned width, int precision, long double value);\n#endif\n\n// Checks if a number is negative - used to avoid warnings.\ntemplate <bool IsSigned>\nstruct SignChecker {\n  template <typename T>\n  static bool is_negative(T value) { return value < 0; }\n};\n\ntemplate <>\nstruct SignChecker<false> {\n  template <typename T>\n  static bool is_negative(T) { return false; }\n};\n\n// Returns true if value is negative, false otherwise.\n// Same as (value < 0) but doesn't produce warnings if T is an unsigned type.\ntemplate <typename T>\ninline bool is_negative(T value) {\n  return SignChecker<std::numeric_limits<T>::is_signed>::is_negative(value);\n}\n\n// Selects uint32_t if FitsIn32Bits is true, uint64_t otherwise.\ntemplate <bool FitsIn32Bits>\nstruct TypeSelector { typedef uint32_t Type; };\n\ntemplate <>\nstruct TypeSelector<false> { typedef uint64_t Type; };\n\ntemplate <typename T>\nstruct IntTraits {\n  // Smallest of uint32_t and uint64_t that is large enough to represent\n  // all values of T.\n  typedef typename\n    TypeSelector<std::numeric_limits<T>::digits <= 32>::Type MainType;\n};\n\nFMT_API FMT_NORETURN void report_unknown_type(char code, const char *type);\n\n// Static data is placed in this class template to allow header-only\n// configuration.\ntemplate <typename T = void>\nstruct FMT_API BasicData {\n  static const uint32_t POWERS_OF_10_32[];\n  static const uint64_t POWERS_OF_10_64[];\n  static const char DIGITS[];\n};\n\n#if FMT_USE_EXTERN_TEMPLATES\nextern template struct BasicData<void>;\n#endif\n\ntypedef BasicData<> Data;\n\n#ifdef FMT_BUILTIN_CLZLL\n// Returns the number of decimal digits in n. Leading zeros are not counted\n// except for n == 0 in which case count_digits returns 1.\ninline unsigned count_digits(uint64_t n) {\n  // Based on http://graphics.stanford.edu/~seander/bithacks.html#IntegerLog10\n  // and the benchmark https://github.com/localvoid/cxx-benchmark-count-digits.\n  int t = (64 - FMT_BUILTIN_CLZLL(n | 1)) * 1233 >> 12;\n  return to_unsigned(t) - (n < Data::POWERS_OF_10_64[t]) + 1;\n}\n#else\n// Fallback version of count_digits used when __builtin_clz is not available.\ninline unsigned count_digits(uint64_t n) {\n  unsigned count = 1;\n  for (;;) {\n    // Integer division is slow so do it for a group of four digits instead\n    // of for every digit. The idea comes from the talk by Alexandrescu\n    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n    if (n < 10) return count;\n    if (n < 100) return count + 1;\n    if (n < 1000) return count + 2;\n    if (n < 10000) return count + 3;\n    n /= 10000u;\n    count += 4;\n  }\n}\n#endif\n\n#ifdef FMT_BUILTIN_CLZ\n// Optional version of count_digits for better performance on 32-bit platforms.\ninline unsigned count_digits(uint32_t n) {\n  int t = (32 - FMT_BUILTIN_CLZ(n | 1)) * 1233 >> 12;\n  return to_unsigned(t) - (n < Data::POWERS_OF_10_32[t]) + 1;\n}\n#endif\n\n// A functor that doesn't add a thousands separator.\nstruct NoThousandsSep {\n  template <typename Char>\n  void operator()(Char *) {}\n};\n\n// A functor that adds a thousands separator.\nclass ThousandsSep {\n private:\n  fmt::StringRef sep_;\n\n  // Index of a decimal digit with the least significant digit having index 0.\n  unsigned digit_index_;\n\n public:\n  explicit ThousandsSep(fmt::StringRef sep) : sep_(sep), digit_index_(0) {}\n\n  template <typename Char>\n  void operator()(Char *&buffer) {\n    if (++digit_index_ % 3 != 0)\n      return;\n    buffer -= sep_.size();\n    std::uninitialized_copy(sep_.data(), sep_.data() + sep_.size(),\n                            internal::make_ptr(buffer, sep_.size()));\n  }\n};\n\n// Formats a decimal unsigned integer value writing into buffer.\n// thousands_sep is a functor that is called after writing each char to\n// add a thousands separator if necessary.\ntemplate <typename UInt, typename Char, typename ThousandsSep>\ninline void format_decimal(Char *buffer, UInt value, unsigned num_digits,\n                           ThousandsSep thousands_sep) {\n  buffer += num_digits;\n  while (value >= 100) {\n    // Integer division is slow so do it for a group of two digits instead\n    // of for every digit. The idea comes from the talk by Alexandrescu\n    // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n    unsigned index = static_cast<unsigned>((value % 100) * 2);\n    value /= 100;\n    *--buffer = Data::DIGITS[index + 1];\n    thousands_sep(buffer);\n    *--buffer = Data::DIGITS[index];\n    thousands_sep(buffer);\n  }\n  if (value < 10) {\n    *--buffer = static_cast<char>('0' + value);\n    return;\n  }\n  unsigned index = static_cast<unsigned>(value * 2);\n  *--buffer = Data::DIGITS[index + 1];\n  thousands_sep(buffer);\n  *--buffer = Data::DIGITS[index];\n}\n\ntemplate <typename UInt, typename Char>\ninline void format_decimal(Char *buffer, UInt value, unsigned num_digits) {\n  format_decimal(buffer, value, num_digits, NoThousandsSep());\n  return;\n}\n\n#ifndef _WIN32\n# define FMT_USE_WINDOWS_H 0\n#elif !defined(FMT_USE_WINDOWS_H)\n# define FMT_USE_WINDOWS_H 1\n#endif\n\n// Define FMT_USE_WINDOWS_H to 0 to disable use of windows.h.\n// All the functionality that relies on it will be disabled too.\n#if FMT_USE_WINDOWS_H\n// A converter from UTF-8 to UTF-16.\n// It is only provided for Windows since other systems support UTF-8 natively.\nclass UTF8ToUTF16 {\n private:\n  MemoryBuffer<wchar_t, INLINE_BUFFER_SIZE> buffer_;\n\n public:\n  FMT_API explicit UTF8ToUTF16(StringRef s);\n  operator WStringRef() const { return WStringRef(&buffer_[0], size()); }\n  size_t size() const { return buffer_.size() - 1; }\n  const wchar_t *c_str() const { return &buffer_[0]; }\n  std::wstring str() const { return std::wstring(&buffer_[0], size()); }\n};\n\n// A converter from UTF-16 to UTF-8.\n// It is only provided for Windows since other systems support UTF-8 natively.\nclass UTF16ToUTF8 {\n private:\n  MemoryBuffer<char, INLINE_BUFFER_SIZE> buffer_;\n\n public:\n  UTF16ToUTF8() {}\n  FMT_API explicit UTF16ToUTF8(WStringRef s);\n  operator StringRef() const { return StringRef(&buffer_[0], size()); }\n  size_t size() const { return buffer_.size() - 1; }\n  const char *c_str() const { return &buffer_[0]; }\n  std::string str() const { return std::string(&buffer_[0], size()); }\n\n  // Performs conversion returning a system error code instead of\n  // throwing exception on conversion error. This method may still throw\n  // in case of memory allocation error.\n  FMT_API int convert(WStringRef s);\n};\n\nFMT_API void format_windows_error(fmt::Writer &out, int error_code,\n                                  fmt::StringRef message) FMT_NOEXCEPT;\n#endif\n\n// A formatting argument value.\nstruct Value {\n  template <typename Char>\n  struct StringValue {\n    const Char *value;\n    std::size_t size;\n  };\n\n  typedef void (*FormatFunc)(\n      void *formatter, const void *arg, void *format_str_ptr);\n\n  struct CustomValue {\n    const void *value;\n    FormatFunc format;\n  };\n\n  union {\n    int int_value;\n    unsigned uint_value;\n    LongLong long_long_value;\n    ULongLong ulong_long_value;\n    double double_value;\n    long double long_double_value;\n    const void *pointer;\n    StringValue<char> string;\n    StringValue<signed char> sstring;\n    StringValue<unsigned char> ustring;\n    StringValue<wchar_t> wstring;\n    CustomValue custom;\n  };\n\n  enum Type {\n    NONE, NAMED_ARG,\n    // Integer types should go first,\n    INT, UINT, LONG_LONG, ULONG_LONG, BOOL, CHAR, LAST_INTEGER_TYPE = CHAR,\n    // followed by floating-point types.\n    DOUBLE, LONG_DOUBLE, LAST_NUMERIC_TYPE = LONG_DOUBLE,\n    CSTRING, STRING, WSTRING, POINTER, CUSTOM\n  };\n};\n\n// A formatting argument. It is a trivially copyable/constructible type to\n// allow storage in internal::MemoryBuffer.\nstruct Arg : Value {\n  Type type;\n};\n\ntemplate <typename Char>\nstruct NamedArg;\ntemplate <typename Char, typename T>\nstruct NamedArgWithType;\n\ntemplate <typename T = void>\nstruct Null {};\n\n// A helper class template to enable or disable overloads taking wide\n// characters and strings in MakeValue.\ntemplate <typename T, typename Char>\nstruct WCharHelper {\n  typedef Null<T> Supported;\n  typedef T Unsupported;\n};\n\ntemplate <typename T>\nstruct WCharHelper<T, wchar_t> {\n  typedef T Supported;\n  typedef Null<T> Unsupported;\n};\n\ntypedef char Yes[1];\ntypedef char No[2];\n\ntemplate <typename T>\nT &get();\n\n// These are non-members to workaround an overload resolution bug in bcc32.\nYes &convert(fmt::ULongLong);\nNo &convert(...);\n\ntemplate <typename T, bool ENABLE_CONVERSION>\nstruct ConvertToIntImpl {\n  enum { value = ENABLE_CONVERSION };\n};\n\ntemplate <typename T, bool ENABLE_CONVERSION>\nstruct ConvertToIntImpl2 {\n  enum { value = false };\n};\n\ntemplate <typename T>\nstruct ConvertToIntImpl2<T, true> {\n  enum {\n    // Don't convert numeric types.\n    value = ConvertToIntImpl<T, !std::numeric_limits<T>::is_specialized>::value\n  };\n};\n\ntemplate <typename T>\nstruct ConvertToInt {\n  enum {\n    enable_conversion = sizeof(fmt::internal::convert(get<T>())) == sizeof(Yes)\n  };\n  enum { value = ConvertToIntImpl2<T, enable_conversion>::value };\n};\n\n#define FMT_DISABLE_CONVERSION_TO_INT(Type) \\\n  template <> \\\n  struct ConvertToInt<Type> {  enum { value = 0 }; }\n\n// Silence warnings about convering float to int.\nFMT_DISABLE_CONVERSION_TO_INT(float);\nFMT_DISABLE_CONVERSION_TO_INT(double);\nFMT_DISABLE_CONVERSION_TO_INT(long double);\n\ntemplate <bool B, class T = void>\nstruct EnableIf {};\n\ntemplate <class T>\nstruct EnableIf<true, T> { typedef T type; };\n\ntemplate <bool B, class T, class F>\nstruct Conditional { typedef T type; };\n\ntemplate <class T, class F>\nstruct Conditional<false, T, F> { typedef F type; };\n\n// For bcc32 which doesn't understand ! in template arguments.\ntemplate <bool>\nstruct Not { enum { value = 0 }; };\n\ntemplate <>\nstruct Not<false> { enum { value = 1 }; };\n\ntemplate <typename T>\nstruct FalseType { enum { value = 0 }; };\n\ntemplate <typename T, T> struct LConvCheck {\n  LConvCheck(int) {}\n};\n\n// Returns the thousands separator for the current locale.\n// We check if ``lconv`` contains ``thousands_sep`` because on Android\n// ``lconv`` is stubbed as an empty struct.\ntemplate <typename LConv>\ninline StringRef thousands_sep(\n    LConv *lc, LConvCheck<char *LConv::*, &LConv::thousands_sep> = 0) {\n  return lc->thousands_sep;\n}\n\ninline fmt::StringRef thousands_sep(...) { return \"\"; }\n\n#define FMT_CONCAT(a, b) a##b\n\n#if FMT_GCC_VERSION >= 303\n# define FMT_UNUSED __attribute__((unused))\n#else\n# define FMT_UNUSED\n#endif\n\n#ifndef FMT_USE_STATIC_ASSERT\n# define FMT_USE_STATIC_ASSERT 0\n#endif\n\n#if FMT_USE_STATIC_ASSERT || FMT_HAS_FEATURE(cxx_static_assert) || \\\n  (FMT_GCC_VERSION >= 403 && FMT_HAS_GXX_CXX11) || _MSC_VER >= 1600\n# define FMT_STATIC_ASSERT(cond, message) static_assert(cond, message)\n#else\n# define FMT_CONCAT_(a, b) FMT_CONCAT(a, b)\n# define FMT_STATIC_ASSERT(cond, message) \\\n  typedef int FMT_CONCAT_(Assert, __LINE__)[(cond) ? 1 : -1] FMT_UNUSED\n#endif\n\ntemplate <typename Formatter>\nvoid format_arg(Formatter&, ...) {\n  FMT_STATIC_ASSERT(FalseType<Formatter>::value,\n                    \"Cannot format argument. To enable the use of ostream \"\n                    \"operator<< include fmt/ostream.h. Otherwise provide \"\n                    \"an overload of format_arg.\");\n}\n\n// Makes an Arg object from any type.\ntemplate <typename Formatter>\nclass MakeValue : public Arg {\n public:\n  typedef typename Formatter::Char Char;\n\n private:\n  // The following two methods are private to disallow formatting of\n  // arbitrary pointers. If you want to output a pointer cast it to\n  // \"void *\" or \"const void *\". In particular, this forbids formatting\n  // of \"[const] volatile char *\" which is printed as bool by iostreams.\n  // Do not implement!\n  template <typename T>\n  MakeValue(const T *value);\n  template <typename T>\n  MakeValue(T *value);\n\n  // The following methods are private to disallow formatting of wide\n  // characters and strings into narrow strings as in\n  //   fmt::format(\"{}\", L\"test\");\n  // To fix this, use a wide format string: fmt::format(L\"{}\", L\"test\").\n#if !FMT_MSC_VER || defined(_NATIVE_WCHAR_T_DEFINED)\n  MakeValue(typename WCharHelper<wchar_t, Char>::Unsupported);\n#endif\n  MakeValue(typename WCharHelper<wchar_t *, Char>::Unsupported);\n  MakeValue(typename WCharHelper<const wchar_t *, Char>::Unsupported);\n  MakeValue(typename WCharHelper<const std::wstring &, Char>::Unsupported);\n#if FMT_HAS_STRING_VIEW\n  MakeValue(typename WCharHelper<const std::wstring_view &, Char>::Unsupported);\n#endif\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  MakeValue(typename WCharHelper<const std::experimental::wstring_view &, Char>::Unsupported);\n#endif\n  MakeValue(typename WCharHelper<WStringRef, Char>::Unsupported);\n\n  void set_string(StringRef str) {\n    string.value = str.data();\n    string.size = str.size();\n  }\n\n  void set_string(WStringRef str) {\n    wstring.value = str.data();\n    wstring.size = str.size();\n  }\n\n  // Formats an argument of a custom type, such as a user-defined class.\n  template <typename T>\n  static void format_custom_arg(\n      void *formatter, const void *arg, void *format_str_ptr) {\n    format_arg(*static_cast<Formatter*>(formatter),\n               *static_cast<const Char**>(format_str_ptr),\n               *static_cast<const T*>(arg));\n  }\n\n public:\n  MakeValue() {}\n\n#define FMT_MAKE_VALUE_(Type, field, TYPE, rhs) \\\n  MakeValue(Type value) { field = rhs; } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n#define FMT_MAKE_VALUE(Type, field, TYPE) \\\n  FMT_MAKE_VALUE_(Type, field, TYPE, value)\n\n  FMT_MAKE_VALUE(bool, int_value, BOOL)\n  FMT_MAKE_VALUE(short, int_value, INT)\n  FMT_MAKE_VALUE(unsigned short, uint_value, UINT)\n  FMT_MAKE_VALUE(int, int_value, INT)\n  FMT_MAKE_VALUE(unsigned, uint_value, UINT)\n\n  MakeValue(long value) {\n    // To minimize the number of types we need to deal with, long is\n    // translated either to int or to long long depending on its size.\n    if (const_check(sizeof(long) == sizeof(int)))\n      int_value = static_cast<int>(value);\n    else\n      long_long_value = value;\n  }\n  static uint64_t type(long) {\n    return sizeof(long) == sizeof(int) ? Arg::INT : Arg::LONG_LONG;\n  }\n\n  MakeValue(unsigned long value) {\n    if (const_check(sizeof(unsigned long) == sizeof(unsigned)))\n      uint_value = static_cast<unsigned>(value);\n    else\n      ulong_long_value = value;\n  }\n  static uint64_t type(unsigned long) {\n    return sizeof(unsigned long) == sizeof(unsigned) ?\n          Arg::UINT : Arg::ULONG_LONG;\n  }\n\n  FMT_MAKE_VALUE(LongLong, long_long_value, LONG_LONG)\n  FMT_MAKE_VALUE(ULongLong, ulong_long_value, ULONG_LONG)\n  FMT_MAKE_VALUE(float, double_value, DOUBLE)\n  FMT_MAKE_VALUE(double, double_value, DOUBLE)\n  FMT_MAKE_VALUE(long double, long_double_value, LONG_DOUBLE)\n  FMT_MAKE_VALUE(signed char, int_value, INT)\n  FMT_MAKE_VALUE(unsigned char, uint_value, UINT)\n  FMT_MAKE_VALUE(char, int_value, CHAR)\n\n#if __cplusplus >= 201103L\n  template <\n    typename T,\n    typename = typename std::enable_if<\n      std::is_enum<T>::value && ConvertToInt<T>::value>::type>\n   MakeValue(T value) { int_value = value; }\n\n  template <\n    typename T,\n    typename = typename std::enable_if<\n      std::is_enum<T>::value && ConvertToInt<T>::value>::type>\n  static uint64_t type(T) { return Arg::INT; }\n#endif\n\n#if !defined(_MSC_VER) || defined(_NATIVE_WCHAR_T_DEFINED)\n  MakeValue(typename WCharHelper<wchar_t, Char>::Supported value) {\n    int_value = value;\n  }\n  static uint64_t type(wchar_t) { return Arg::CHAR; }\n#endif\n\n#define FMT_MAKE_STR_VALUE(Type, TYPE) \\\n  MakeValue(Type value) { set_string(value); } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n  FMT_MAKE_VALUE(char *, string.value, CSTRING)\n  FMT_MAKE_VALUE(const char *, string.value, CSTRING)\n  FMT_MAKE_VALUE(signed char *, sstring.value, CSTRING)\n  FMT_MAKE_VALUE(const signed char *, sstring.value, CSTRING)\n  FMT_MAKE_VALUE(unsigned char *, ustring.value, CSTRING)\n  FMT_MAKE_VALUE(const unsigned char *, ustring.value, CSTRING)\n  FMT_MAKE_STR_VALUE(const std::string &, STRING)\n#if FMT_HAS_STRING_VIEW\n  FMT_MAKE_STR_VALUE(const std::string_view &, STRING)\n#endif\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  FMT_MAKE_STR_VALUE(const std::experimental::string_view &, STRING)\n#endif\n  FMT_MAKE_STR_VALUE(StringRef, STRING)\n  FMT_MAKE_VALUE_(CStringRef, string.value, CSTRING, value.c_str())\n\n#define FMT_MAKE_WSTR_VALUE(Type, TYPE) \\\n  MakeValue(typename WCharHelper<Type, Char>::Supported value) { \\\n    set_string(value); \\\n  } \\\n  static uint64_t type(Type) { return Arg::TYPE; }\n\n  FMT_MAKE_WSTR_VALUE(wchar_t *, WSTRING)\n  FMT_MAKE_WSTR_VALUE(const wchar_t *, WSTRING)\n  FMT_MAKE_WSTR_VALUE(const std::wstring &, WSTRING)\n#if FMT_HAS_STRING_VIEW\n  FMT_MAKE_WSTR_VALUE(const std::wstring_view &, WSTRING)\n#endif\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  FMT_MAKE_WSTR_VALUE(const std::experimental::wstring_view &, WSTRING)\n#endif\n  FMT_MAKE_WSTR_VALUE(WStringRef, WSTRING)\n\n  FMT_MAKE_VALUE(void *, pointer, POINTER)\n  FMT_MAKE_VALUE(const void *, pointer, POINTER)\n\n  template <typename T>\n  MakeValue(const T &value,\n            typename EnableIf<Not<\n              ConvertToInt<T>::value>::value, int>::type = 0) {\n    custom.value = &value;\n    custom.format = &format_custom_arg<T>;\n  }\n\n  template <typename T>\n  static typename EnableIf<Not<ConvertToInt<T>::value>::value, uint64_t>::type\n      type(const T &) {\n    return Arg::CUSTOM;\n  }\n\n  // Additional template param `Char_` is needed here because make_type always\n  // uses char.\n  template <typename Char_>\n  MakeValue(const NamedArg<Char_> &value) { pointer = &value; }\n  template <typename Char_, typename T>\n  MakeValue(const NamedArgWithType<Char_, T> &value) { pointer = &value; }\n\n  template <typename Char_>\n  static uint64_t type(const NamedArg<Char_> &) { return Arg::NAMED_ARG; }\n  template <typename Char_, typename T>\n  static uint64_t type(const NamedArgWithType<Char_, T> &) { return Arg::NAMED_ARG; }\n};\n\ntemplate <typename Formatter>\nclass MakeArg : public Arg {\npublic:\n  MakeArg() {\n    type = Arg::NONE;\n  }\n\n  template <typename T>\n  MakeArg(const T &value)\n  : Arg(MakeValue<Formatter>(value)) {\n    type = static_cast<Arg::Type>(MakeValue<Formatter>::type(value));\n  }\n};\n\ntemplate <typename Char>\nstruct NamedArg : Arg {\n  BasicStringRef<Char> name;\n\n  template <typename T>\n  NamedArg(BasicStringRef<Char> argname, const T &value)\n  : Arg(MakeArg< BasicFormatter<Char> >(value)), name(argname) {}\n};\n\ntemplate <typename Char, typename T>\nstruct NamedArgWithType : NamedArg<Char> {\n  NamedArgWithType(BasicStringRef<Char> argname, const T &value)\n  : NamedArg<Char>(argname, value) {}\n};\n\nclass RuntimeError : public std::runtime_error {\n protected:\n  RuntimeError() : std::runtime_error(\"\") {}\n  RuntimeError(const RuntimeError &rerr) : std::runtime_error(rerr) {}\n  FMT_API ~RuntimeError() FMT_DTOR_NOEXCEPT FMT_OVERRIDE;\n};\n\ntemplate <typename Char>\nclass ArgMap;\n}  // namespace internal\n\n/** An argument list. */\nclass ArgList {\n private:\n  // To reduce compiled code size per formatting function call, types of first\n  // MAX_PACKED_ARGS arguments are passed in the types_ field.\n  uint64_t types_;\n  union {\n    // If the number of arguments is less than MAX_PACKED_ARGS, the argument\n    // values are stored in values_, otherwise they are stored in args_.\n    // This is done to reduce compiled code size as storing larger objects\n    // may require more code (at least on x86-64) even if the same amount of\n    // data is actually copied to stack. It saves ~10% on the bloat test.\n    const internal::Value *values_;\n    const internal::Arg *args_;\n  };\n\n  internal::Arg::Type type(unsigned index) const {\n    return type(types_, index);\n  }\n\n  template <typename Char>\n  friend class internal::ArgMap;\n\n public:\n  // Maximum number of arguments with packed types.\n  enum { MAX_PACKED_ARGS = 16 };\n\n  ArgList() : types_(0) {}\n\n  ArgList(ULongLong types, const internal::Value *values)\n  : types_(types), values_(values) {}\n  ArgList(ULongLong types, const internal::Arg *args)\n  : types_(types), args_(args) {}\n\n  uint64_t types() const { return types_; }\n\n  /** Returns the argument at specified index. */\n  internal::Arg operator[](unsigned index) const {\n    using internal::Arg;\n    Arg arg;\n    bool use_values = type(MAX_PACKED_ARGS - 1) == Arg::NONE;\n    if (index < MAX_PACKED_ARGS) {\n      Arg::Type arg_type = type(index);\n      internal::Value &val = arg;\n      if (arg_type != Arg::NONE)\n        val = use_values ? values_[index] : args_[index];\n      arg.type = arg_type;\n      return arg;\n    }\n    if (use_values) {\n      // The index is greater than the number of arguments that can be stored\n      // in values, so return a \"none\" argument.\n      arg.type = Arg::NONE;\n      return arg;\n    }\n    for (unsigned i = MAX_PACKED_ARGS; i <= index; ++i) {\n      if (args_[i].type == Arg::NONE)\n        return args_[i];\n    }\n    return args_[index];\n  }\n\n  static internal::Arg::Type type(uint64_t types, unsigned index) {\n    unsigned shift = index * 4;\n    uint64_t mask = 0xf;\n    return static_cast<internal::Arg::Type>(\n          (types & (mask << shift)) >> shift);\n  }\n};\n\n#define FMT_DISPATCH(call) static_cast<Impl*>(this)->call\n\n/**\n  \\rst\n  An argument visitor based on the `curiously recurring template pattern\n  <http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_.\n\n  To use `~fmt::ArgVisitor` define a subclass that implements some or all of the\n  visit methods with the same signatures as the methods in `~fmt::ArgVisitor`,\n  for example, `~fmt::ArgVisitor::visit_int()`.\n  Pass the subclass as the *Impl* template parameter. Then calling\n  `~fmt::ArgVisitor::visit` for some argument will dispatch to a visit method\n  specific to the argument type. For example, if the argument type is\n  ``double`` then the `~fmt::ArgVisitor::visit_double()` method of a subclass\n  will be called. If the subclass doesn't contain a method with this signature,\n  then a corresponding method of `~fmt::ArgVisitor` will be called.\n\n  **Example**::\n\n    class MyArgVisitor : public fmt::ArgVisitor<MyArgVisitor, void> {\n     public:\n      void visit_int(int value) { fmt::print(\"{}\", value); }\n      void visit_double(double value) { fmt::print(\"{}\", value ); }\n    };\n  \\endrst\n */\ntemplate <typename Impl, typename Result>\nclass ArgVisitor {\n private:\n  typedef internal::Arg Arg;\n\n public:\n  void report_unhandled_arg() {}\n\n  Result visit_unhandled_arg() {\n    FMT_DISPATCH(report_unhandled_arg());\n    return Result();\n  }\n\n  /** Visits an ``int`` argument. **/\n  Result visit_int(int value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits a ``long long`` argument. **/\n  Result visit_long_long(LongLong value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits an ``unsigned`` argument. **/\n  Result visit_uint(unsigned value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits an ``unsigned long long`` argument. **/\n  Result visit_ulong_long(ULongLong value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits a ``bool`` argument. **/\n  Result visit_bool(bool value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits a ``char`` or ``wchar_t`` argument. **/\n  Result visit_char(int value) {\n    return FMT_DISPATCH(visit_any_int(value));\n  }\n\n  /** Visits an argument of any integral type. **/\n  template <typename T>\n  Result visit_any_int(T) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits a ``double`` argument. **/\n  Result visit_double(double value) {\n    return FMT_DISPATCH(visit_any_double(value));\n  }\n\n  /** Visits a ``long double`` argument. **/\n  Result visit_long_double(long double value) {\n    return FMT_DISPATCH(visit_any_double(value));\n  }\n\n  /** Visits a ``double`` or ``long double`` argument. **/\n  template <typename T>\n  Result visit_any_double(T) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits a null-terminated C string (``const char *``) argument. **/\n  Result visit_cstring(const char *) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits a string argument. **/\n  Result visit_string(Arg::StringValue<char>) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits a wide string argument. **/\n  Result visit_wstring(Arg::StringValue<wchar_t>) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits a pointer argument. **/\n  Result visit_pointer(const void *) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /** Visits an argument of a custom (user-defined) type. **/\n  Result visit_custom(Arg::CustomValue) {\n    return FMT_DISPATCH(visit_unhandled_arg());\n  }\n\n  /**\n    \\rst\n    Visits an argument dispatching to the appropriate visit method based on\n    the argument type. For example, if the argument type is ``double`` then\n    the `~fmt::ArgVisitor::visit_double()` method of the *Impl* class will be\n    called.\n    \\endrst\n   */\n  Result visit(const Arg &arg) {\n    switch (arg.type) {\n    case Arg::NONE:\n    case Arg::NAMED_ARG:\n      FMT_ASSERT(false, \"invalid argument type\");\n      break;\n    case Arg::INT:\n      return FMT_DISPATCH(visit_int(arg.int_value));\n    case Arg::UINT:\n      return FMT_DISPATCH(visit_uint(arg.uint_value));\n    case Arg::LONG_LONG:\n      return FMT_DISPATCH(visit_long_long(arg.long_long_value));\n    case Arg::ULONG_LONG:\n      return FMT_DISPATCH(visit_ulong_long(arg.ulong_long_value));\n    case Arg::BOOL:\n      return FMT_DISPATCH(visit_bool(arg.int_value != 0));\n    case Arg::CHAR:\n      return FMT_DISPATCH(visit_char(arg.int_value));\n    case Arg::DOUBLE:\n      return FMT_DISPATCH(visit_double(arg.double_value));\n    case Arg::LONG_DOUBLE:\n      return FMT_DISPATCH(visit_long_double(arg.long_double_value));\n    case Arg::CSTRING:\n      return FMT_DISPATCH(visit_cstring(arg.string.value));\n    case Arg::STRING:\n      return FMT_DISPATCH(visit_string(arg.string));\n    case Arg::WSTRING:\n      return FMT_DISPATCH(visit_wstring(arg.wstring));\n    case Arg::POINTER:\n      return FMT_DISPATCH(visit_pointer(arg.pointer));\n    case Arg::CUSTOM:\n      return FMT_DISPATCH(visit_custom(arg.custom));\n    }\n    return Result();\n  }\n};\n\nenum Alignment {\n  ALIGN_DEFAULT, ALIGN_LEFT, ALIGN_RIGHT, ALIGN_CENTER, ALIGN_NUMERIC\n};\n\n// Flags.\nenum {\n  SIGN_FLAG = 1, PLUS_FLAG = 2, MINUS_FLAG = 4, HASH_FLAG = 8,\n  CHAR_FLAG = 0x10  // Argument has char type - used in error reporting.\n};\n\n// An empty format specifier.\nstruct EmptySpec {};\n\n// A type specifier.\ntemplate <char TYPE>\nstruct TypeSpec : EmptySpec {\n  Alignment align() const { return ALIGN_DEFAULT; }\n  unsigned width() const { return 0; }\n  int precision() const { return -1; }\n  bool flag(unsigned) const { return false; }\n  char type() const { return TYPE; }\n  char type_prefix() const { return TYPE; }\n  char fill() const { return ' '; }\n};\n\n// A width specifier.\nstruct WidthSpec {\n  unsigned width_;\n  // Fill is always wchar_t and cast to char if necessary to avoid having\n  // two specialization of WidthSpec and its subclasses.\n  wchar_t fill_;\n\n  WidthSpec(unsigned width, wchar_t fill) : width_(width), fill_(fill) {}\n\n  unsigned width() const { return width_; }\n  wchar_t fill() const { return fill_; }\n};\n\n// An alignment specifier.\nstruct AlignSpec : WidthSpec {\n  Alignment align_;\n\n  AlignSpec(unsigned width, wchar_t fill, Alignment align = ALIGN_DEFAULT)\n  : WidthSpec(width, fill), align_(align) {}\n\n  Alignment align() const { return align_; }\n\n  int precision() const { return -1; }\n};\n\n// An alignment and type specifier.\ntemplate <char TYPE>\nstruct AlignTypeSpec : AlignSpec {\n  AlignTypeSpec(unsigned width, wchar_t fill) : AlignSpec(width, fill) {}\n\n  bool flag(unsigned) const { return false; }\n  char type() const { return TYPE; }\n  char type_prefix() const { return TYPE; }\n};\n\n// A full format specifier.\nstruct FormatSpec : AlignSpec {\n  unsigned flags_;\n  int precision_;\n  char type_;\n\n  FormatSpec(\n    unsigned width = 0, char type = 0, wchar_t fill = ' ')\n  : AlignSpec(width, fill), flags_(0), precision_(-1), type_(type) {}\n\n  bool flag(unsigned f) const { return (flags_ & f) != 0; }\n  int precision() const { return precision_; }\n  char type() const { return type_; }\n  char type_prefix() const { return type_; }\n};\n\n// An integer format specifier.\ntemplate <typename T, typename SpecT = TypeSpec<0>, typename Char = char>\nclass IntFormatSpec : public SpecT {\n private:\n  T value_;\n\n public:\n  IntFormatSpec(T val, const SpecT &spec = SpecT())\n  : SpecT(spec), value_(val) {}\n\n  T value() const { return value_; }\n};\n\n// A string format specifier.\ntemplate <typename Char>\nclass StrFormatSpec : public AlignSpec {\n private:\n  const Char *str_;\n\n public:\n  template <typename FillChar>\n  StrFormatSpec(const Char *str, unsigned width, FillChar fill)\n  : AlignSpec(width, fill), str_(str) {\n    internal::CharTraits<Char>::convert(FillChar());\n  }\n\n  const Char *str() const { return str_; }\n};\n\n/**\n  Returns an integer format specifier to format the value in base 2.\n */\nIntFormatSpec<int, TypeSpec<'b'> > bin(int value);\n\n/**\n  Returns an integer format specifier to format the value in base 8.\n */\nIntFormatSpec<int, TypeSpec<'o'> > oct(int value);\n\n/**\n  Returns an integer format specifier to format the value in base 16 using\n  lower-case letters for the digits above 9.\n */\nIntFormatSpec<int, TypeSpec<'x'> > hex(int value);\n\n/**\n  Returns an integer formatter format specifier to format in base 16 using\n  upper-case letters for the digits above 9.\n */\nIntFormatSpec<int, TypeSpec<'X'> > hexu(int value);\n\n/**\n  \\rst\n  Returns an integer format specifier to pad the formatted argument with the\n  fill character to the specified width using the default (right) numeric\n  alignment.\n\n  **Example**::\n\n    MemoryWriter out;\n    out << pad(hex(0xcafe), 8, '0');\n    // out.str() == \"0000cafe\"\n\n  \\endrst\n */\ntemplate <char TYPE_CODE, typename Char>\nIntFormatSpec<int, AlignTypeSpec<TYPE_CODE>, Char> pad(\n    int value, unsigned width, Char fill = ' ');\n\n#define FMT_DEFINE_INT_FORMATTERS(TYPE) \\\ninline IntFormatSpec<TYPE, TypeSpec<'b'> > bin(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'b'> >(value, TypeSpec<'b'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'o'> > oct(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'o'> >(value, TypeSpec<'o'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'x'> > hex(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'x'> >(value, TypeSpec<'x'>()); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, TypeSpec<'X'> > hexu(TYPE value) { \\\n  return IntFormatSpec<TYPE, TypeSpec<'X'> >(value, TypeSpec<'X'>()); \\\n} \\\n \\\ntemplate <char TYPE_CODE> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> > pad( \\\n    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE> > f, unsigned width) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE> >( \\\n      f.value(), AlignTypeSpec<TYPE_CODE>(width, ' ')); \\\n} \\\n \\\n/* For compatibility with older compilers we provide two overloads for pad, */ \\\n/* one that takes a fill character and one that doesn't. In the future this */ \\\n/* can be replaced with one overload making the template argument Char      */ \\\n/* default to char (C++11). */ \\\ntemplate <char TYPE_CODE, typename Char> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char> pad( \\\n    IntFormatSpec<TYPE, TypeSpec<TYPE_CODE>, Char> f, \\\n    unsigned width, Char fill) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char>( \\\n      f.value(), AlignTypeSpec<TYPE_CODE>(width, fill)); \\\n} \\\n \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<0> > pad( \\\n    TYPE value, unsigned width) { \\\n  return IntFormatSpec<TYPE, AlignTypeSpec<0> >( \\\n      value, AlignTypeSpec<0>(width, ' ')); \\\n} \\\n \\\ntemplate <typename Char> \\\ninline IntFormatSpec<TYPE, AlignTypeSpec<0>, Char> pad( \\\n   TYPE value, unsigned width, Char fill) { \\\n return IntFormatSpec<TYPE, AlignTypeSpec<0>, Char>( \\\n     value, AlignTypeSpec<0>(width, fill)); \\\n}\n\nFMT_DEFINE_INT_FORMATTERS(int)\nFMT_DEFINE_INT_FORMATTERS(long)\nFMT_DEFINE_INT_FORMATTERS(unsigned)\nFMT_DEFINE_INT_FORMATTERS(unsigned long)\nFMT_DEFINE_INT_FORMATTERS(LongLong)\nFMT_DEFINE_INT_FORMATTERS(ULongLong)\n\n/**\n  \\rst\n  Returns a string formatter that pads the formatted argument with the fill\n  character to the specified width using the default (left) string alignment.\n\n  **Example**::\n\n    std::string s = str(MemoryWriter() << pad(\"abc\", 8));\n    // s == \"abc     \"\n\n  \\endrst\n */\ntemplate <typename Char>\ninline StrFormatSpec<Char> pad(\n    const Char *str, unsigned width, Char fill = ' ') {\n  return StrFormatSpec<Char>(str, width, fill);\n}\n\ninline StrFormatSpec<wchar_t> pad(\n    const wchar_t *str, unsigned width, char fill = ' ') {\n  return StrFormatSpec<wchar_t>(str, width, fill);\n}\n\nnamespace internal {\n\ntemplate <typename Char>\nclass ArgMap {\n private:\n  typedef std::vector<\n    std::pair<fmt::BasicStringRef<Char>, internal::Arg> > MapType;\n  typedef typename MapType::value_type Pair;\n\n  MapType map_;\n\n public:\n  void init(const ArgList &args);\n\n  const internal::Arg *find(const fmt::BasicStringRef<Char> &name) const {\n    // The list is unsorted, so just return the first matching name.\n    for (typename MapType::const_iterator it = map_.begin(), end = map_.end();\n         it != end; ++it) {\n      if (it->first == name)\n        return &it->second;\n    }\n    return FMT_NULL;\n  }\n};\n\ntemplate <typename Char>\nvoid ArgMap<Char>::init(const ArgList &args) {\n  if (!map_.empty())\n    return;\n  typedef internal::NamedArg<Char> NamedArg;\n  const NamedArg *named_arg = FMT_NULL;\n  bool use_values =\n      args.type(ArgList::MAX_PACKED_ARGS - 1) == internal::Arg::NONE;\n  if (use_values) {\n    for (unsigned i = 0;/*nothing*/; ++i) {\n      internal::Arg::Type arg_type = args.type(i);\n      switch (arg_type) {\n      case internal::Arg::NONE:\n        return;\n      case internal::Arg::NAMED_ARG:\n        named_arg = static_cast<const NamedArg*>(args.values_[i].pointer);\n        map_.push_back(Pair(named_arg->name, *named_arg));\n        break;\n      default:\n        /*nothing*/;\n      }\n    }\n    return;\n  }\n  for (unsigned i = 0; i != ArgList::MAX_PACKED_ARGS; ++i) {\n    internal::Arg::Type arg_type = args.type(i);\n    if (arg_type == internal::Arg::NAMED_ARG) {\n      named_arg = static_cast<const NamedArg*>(args.args_[i].pointer);\n      map_.push_back(Pair(named_arg->name, *named_arg));\n    }\n  }\n  for (unsigned i = ArgList::MAX_PACKED_ARGS;/*nothing*/; ++i) {\n    switch (args.args_[i].type) {\n    case internal::Arg::NONE:\n      return;\n    case internal::Arg::NAMED_ARG:\n      named_arg = static_cast<const NamedArg*>(args.args_[i].pointer);\n      map_.push_back(Pair(named_arg->name, *named_arg));\n      break;\n    default:\n      /*nothing*/;\n    }\n  }\n}\n\ntemplate <typename Impl, typename Char, typename Spec = fmt::FormatSpec>\nclass ArgFormatterBase : public ArgVisitor<Impl, void> {\n private:\n  BasicWriter<Char> &writer_;\n  Spec &spec_;\n\n  FMT_DISALLOW_COPY_AND_ASSIGN(ArgFormatterBase);\n\n  void write_pointer(const void *p) {\n    spec_.flags_ = HASH_FLAG;\n    spec_.type_ = 'x';\n    writer_.write_int(reinterpret_cast<uintptr_t>(p), spec_);\n  }\n\n  // workaround MSVC two-phase lookup issue\n  typedef internal::Arg Arg;\n\n protected:\n  BasicWriter<Char> &writer() { return writer_; }\n  Spec &spec() { return spec_; }\n\n  void write(bool value) {\n    const char *str_value = value ? \"true\" : \"false\";\n    Arg::StringValue<char> str = { str_value, std::strlen(str_value) };\n    writer_.write_str(str, spec_);\n  }\n\n  void write(const char *value) {\n    Arg::StringValue<char> str = {value, value ? std::strlen(value) : 0};\n    writer_.write_str(str, spec_);\n  }\n\n public:\n  typedef Spec SpecType;\n\n  ArgFormatterBase(BasicWriter<Char> &w, Spec &s)\n  : writer_(w), spec_(s) {}\n\n  template <typename T>\n  void visit_any_int(T value) { writer_.write_int(value, spec_); }\n\n  template <typename T>\n  void visit_any_double(T value) { writer_.write_double(value, spec_); }\n\n  void visit_bool(bool value) {\n    if (spec_.type_) {\n      visit_any_int(value);\n      return;\n    }\n    write(value);\n  }\n\n  void visit_char(int value) {\n    if (spec_.type_ && spec_.type_ != 'c') {\n      spec_.flags_ |= CHAR_FLAG;\n      writer_.write_int(value, spec_);\n      return;\n    }\n    if (spec_.align_ == ALIGN_NUMERIC || spec_.flags_ != 0)\n      FMT_THROW(FormatError(\"invalid format specifier for char\"));\n    typedef typename BasicWriter<Char>::CharPtr CharPtr;\n    Char fill = internal::CharTraits<Char>::cast(spec_.fill());\n    CharPtr out = CharPtr();\n    const unsigned CHAR_SIZE = 1;\n    if (spec_.width_ > CHAR_SIZE) {\n      out = writer_.grow_buffer(spec_.width_);\n      if (spec_.align_ == ALIGN_RIGHT) {\n        std::uninitialized_fill_n(out, spec_.width_ - CHAR_SIZE, fill);\n        out += spec_.width_ - CHAR_SIZE;\n      } else if (spec_.align_ == ALIGN_CENTER) {\n        out = writer_.fill_padding(out, spec_.width_,\n                                   internal::const_check(CHAR_SIZE), fill);\n      } else {\n        std::uninitialized_fill_n(out + CHAR_SIZE,\n                                  spec_.width_ - CHAR_SIZE, fill);\n      }\n    } else {\n      out = writer_.grow_buffer(CHAR_SIZE);\n    }\n    *out = internal::CharTraits<Char>::cast(value);\n  }\n\n  void visit_cstring(const char *value) {\n    if (spec_.type_ == 'p')\n      return write_pointer(value);\n    write(value);\n  }\n\n  // Qualification with \"internal\" here and below is a workaround for nvcc.\n  void visit_string(internal::Arg::StringValue<char> value) {\n    writer_.write_str(value, spec_);\n  }\n\n  using ArgVisitor<Impl, void>::visit_wstring;\n\n  void visit_wstring(internal::Arg::StringValue<Char> value) {\n    writer_.write_str(value, spec_);\n  }\n\n  void visit_pointer(const void *value) {\n    if (spec_.type_ && spec_.type_ != 'p')\n      report_unknown_type(spec_.type_, \"pointer\");\n    write_pointer(value);\n  }\n};\n\nclass FormatterBase {\n private:\n  ArgList args_;\n  int next_arg_index_;\n\n  // Returns the argument with specified index.\n  FMT_API Arg do_get_arg(unsigned arg_index, const char *&error);\n\n protected:\n  const ArgList &args() const { return args_; }\n\n  explicit FormatterBase(const ArgList &args) {\n    args_ = args;\n    next_arg_index_ = 0;\n  }\n\n  // Returns the next argument.\n  Arg next_arg(const char *&error) {\n    if (next_arg_index_ >= 0)\n      return do_get_arg(internal::to_unsigned(next_arg_index_++), error);\n    error = \"cannot switch from manual to automatic argument indexing\";\n    return Arg();\n  }\n\n  // Checks if manual indexing is used and returns the argument with\n  // specified index.\n  Arg get_arg(unsigned arg_index, const char *&error) {\n    return check_no_auto_index(error) ? do_get_arg(arg_index, error) : Arg();\n  }\n\n  bool check_no_auto_index(const char *&error) {\n    if (next_arg_index_ > 0) {\n      error = \"cannot switch from automatic to manual argument indexing\";\n      return false;\n    }\n    next_arg_index_ = -1;\n    return true;\n  }\n\n  template <typename Char>\n  void write(BasicWriter<Char> &w, const Char *start, const Char *end) {\n    if (start != end)\n      w << BasicStringRef<Char>(start, internal::to_unsigned(end - start));\n  }\n};\n}  // namespace internal\n\n/**\n  \\rst\n  An argument formatter based on the `curiously recurring template pattern\n  <http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern>`_.\n\n  To use `~fmt::BasicArgFormatter` define a subclass that implements some or\n  all of the visit methods with the same signatures as the methods in\n  `~fmt::ArgVisitor`, for example, `~fmt::ArgVisitor::visit_int()`.\n  Pass the subclass as the *Impl* template parameter. When a formatting\n  function processes an argument, it will dispatch to a visit method\n  specific to the argument type. For example, if the argument type is\n  ``double`` then the `~fmt::ArgVisitor::visit_double()` method of a subclass\n  will be called. If the subclass doesn't contain a method with this signature,\n  then a corresponding method of `~fmt::BasicArgFormatter` or its superclass\n  will be called.\n  \\endrst\n */\ntemplate <typename Impl, typename Char, typename Spec = fmt::FormatSpec>\nclass BasicArgFormatter : public internal::ArgFormatterBase<Impl, Char, Spec> {\n private:\n  BasicFormatter<Char, Impl> &formatter_;\n  const Char *format_;\n\n public:\n  /**\n    \\rst\n    Constructs an argument formatter object.\n    *formatter* is a reference to the main formatter object, *spec* contains\n    format specifier information for standard argument types, and *fmt* points\n    to the part of the format string being parsed for custom argument types.\n    \\endrst\n   */\n  BasicArgFormatter(BasicFormatter<Char, Impl> &formatter,\n                    Spec &spec, const Char *fmt)\n  : internal::ArgFormatterBase<Impl, Char, Spec>(formatter.writer(), spec),\n    formatter_(formatter), format_(fmt) {}\n\n  /** Formats an argument of a custom (user-defined) type. */\n  void visit_custom(internal::Arg::CustomValue c) {\n    c.format(&formatter_, c.value, &format_);\n  }\n};\n\n/** The default argument formatter. */\ntemplate <typename Char>\nclass ArgFormatter :\n    public BasicArgFormatter<ArgFormatter<Char>, Char, FormatSpec> {\n public:\n  /** Constructs an argument formatter object. */\n  ArgFormatter(BasicFormatter<Char> &formatter,\n               FormatSpec &spec, const Char *fmt)\n  : BasicArgFormatter<ArgFormatter<Char>,\n                      Char, FormatSpec>(formatter, spec, fmt) {}\n};\n\n/** This template formats data and writes the output to a writer. */\ntemplate <typename CharType, typename ArgFormatter>\nclass BasicFormatter : private internal::FormatterBase {\n public:\n  /** The character type for the output. */\n  typedef CharType Char;\n\n private:\n  BasicWriter<Char> &writer_;\n  internal::ArgMap<Char> map_;\n\n  FMT_DISALLOW_COPY_AND_ASSIGN(BasicFormatter);\n\n  using internal::FormatterBase::get_arg;\n\n  // Checks if manual indexing is used and returns the argument with\n  // specified name.\n  internal::Arg get_arg(BasicStringRef<Char> arg_name, const char *&error);\n\n  // Parses argument index and returns corresponding argument.\n  internal::Arg parse_arg_index(const Char *&s);\n\n  // Parses argument name and returns corresponding argument.\n  internal::Arg parse_arg_name(const Char *&s);\n\n public:\n  /**\n   \\rst\n   Constructs a ``BasicFormatter`` object. References to the arguments and\n   the writer are stored in the formatter object so make sure they have\n   appropriate lifetimes.\n   \\endrst\n   */\n  BasicFormatter(const ArgList &args, BasicWriter<Char> &w)\n    : internal::FormatterBase(args), writer_(w) {}\n\n  /** Returns a reference to the writer associated with this formatter. */\n  BasicWriter<Char> &writer() { return writer_; }\n\n  /** Formats stored arguments and writes the output to the writer. */\n  void format(BasicCStringRef<Char> format_str);\n\n  // Formats a single argument and advances format_str, a format string pointer.\n  const Char *format(const Char *&format_str, const internal::Arg &arg);\n};\n\n// Generates a comma-separated list with results of applying f to\n// numbers 0..n-1.\n# define FMT_GEN(n, f) FMT_GEN##n(f)\n# define FMT_GEN1(f)  f(0)\n# define FMT_GEN2(f)  FMT_GEN1(f),  f(1)\n# define FMT_GEN3(f)  FMT_GEN2(f),  f(2)\n# define FMT_GEN4(f)  FMT_GEN3(f),  f(3)\n# define FMT_GEN5(f)  FMT_GEN4(f),  f(4)\n# define FMT_GEN6(f)  FMT_GEN5(f),  f(5)\n# define FMT_GEN7(f)  FMT_GEN6(f),  f(6)\n# define FMT_GEN8(f)  FMT_GEN7(f),  f(7)\n# define FMT_GEN9(f)  FMT_GEN8(f),  f(8)\n# define FMT_GEN10(f) FMT_GEN9(f),  f(9)\n# define FMT_GEN11(f) FMT_GEN10(f), f(10)\n# define FMT_GEN12(f) FMT_GEN11(f), f(11)\n# define FMT_GEN13(f) FMT_GEN12(f), f(12)\n# define FMT_GEN14(f) FMT_GEN13(f), f(13)\n# define FMT_GEN15(f) FMT_GEN14(f), f(14)\n\nnamespace internal {\ninline uint64_t make_type() { return 0; }\n\ntemplate <typename T>\ninline uint64_t make_type(const T &arg) {\n  return MakeValue< BasicFormatter<char> >::type(arg);\n}\n\ntemplate <std::size_t N, bool/*IsPacked*/= (N < ArgList::MAX_PACKED_ARGS)>\nstruct ArgArray;\n\ntemplate <std::size_t N>\nstruct ArgArray<N, true/*IsPacked*/> {\n  // '+' is used to silence GCC -Wduplicated-branches warning.\n  typedef Value Type[N > 0 ? N : +1];\n\n  template <typename Formatter, typename T>\n  static Value make(const T &value) {\n#ifdef __clang__\n    Value result = MakeValue<Formatter>(value);\n    // Workaround a bug in Apple LLVM version 4.2 (clang-425.0.28) of clang:\n    // https://github.com/fmtlib/fmt/issues/276\n    (void)result.custom.format;\n    return result;\n#else\n    return MakeValue<Formatter>(value);\n#endif\n  }\n};\n\ntemplate <std::size_t N>\nstruct ArgArray<N, false/*IsPacked*/> {\n  typedef Arg Type[N + 1]; // +1 for the list end Arg::NONE\n\n  template <typename Formatter, typename T>\n  static Arg make(const T &value) { return MakeArg<Formatter>(value); }\n};\n\n#if FMT_USE_VARIADIC_TEMPLATES\ntemplate <typename Arg, typename... Args>\ninline uint64_t make_type(const Arg &first, const Args & ... tail) {\n  return make_type(first) | (make_type(tail...) << 4);\n}\n\n#else\n\nstruct ArgType {\n  uint64_t type;\n\n  ArgType() : type(0) {}\n\n  template <typename T>\n  ArgType(const T &arg) : type(make_type(arg)) {}\n};\n\n# define FMT_ARG_TYPE_DEFAULT(n) ArgType t##n = ArgType()\n\ninline uint64_t make_type(FMT_GEN15(FMT_ARG_TYPE_DEFAULT)) {\n  return t0.type | (t1.type << 4) | (t2.type << 8) | (t3.type << 12) |\n      (t4.type << 16) | (t5.type << 20) | (t6.type << 24) | (t7.type << 28) |\n      (t8.type << 32) | (t9.type << 36) | (t10.type << 40) | (t11.type << 44) |\n      (t12.type << 48) | (t13.type << 52) | (t14.type << 56);\n}\n#endif\n}  // namespace internal\n\n# define FMT_MAKE_TEMPLATE_ARG(n) typename T##n\n# define FMT_MAKE_ARG_TYPE(n) T##n\n# define FMT_MAKE_ARG(n) const T##n &v##n\n# define FMT_ASSIGN_char(n) \\\n  arr[n] = fmt::internal::MakeValue< fmt::BasicFormatter<char> >(v##n)\n# define FMT_ASSIGN_wchar_t(n) \\\n  arr[n] = fmt::internal::MakeValue< fmt::BasicFormatter<wchar_t> >(v##n)\n\n#if FMT_USE_VARIADIC_TEMPLATES\n// Defines a variadic function returning void.\n# define FMT_VARIADIC_VOID(func, arg_type) \\\n  template <typename... Args> \\\n  void func(arg_type arg0, const Args & ... args) { \\\n    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \\\n    typename ArgArray::Type array{ \\\n      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \\\n    func(arg0, fmt::ArgList(fmt::internal::make_type(args...), array)); \\\n  }\n\n// Defines a variadic constructor.\n# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n  template <typename... Args> \\\n  ctor(arg0_type arg0, arg1_type arg1, const Args & ... args) { \\\n    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \\\n    typename ArgArray::Type array{ \\\n      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \\\n    func(arg0, arg1, fmt::ArgList(fmt::internal::make_type(args...), array)); \\\n  }\n\n#else\n\n# define FMT_MAKE_REF(n) \\\n  fmt::internal::MakeValue< fmt::BasicFormatter<Char> >(v##n)\n# define FMT_MAKE_REF2(n) v##n\n\n// Defines a wrapper for a function taking one argument of type arg_type\n// and n additional arguments of arbitrary types.\n# define FMT_WRAP1(func, arg_type, n) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  inline void func(arg_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n    func(arg1, fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \\\n  }\n\n// Emulates a variadic function returning void on a pre-C++11 compiler.\n# define FMT_VARIADIC_VOID(func, arg_type) \\\n  inline void func(arg_type arg) { func(arg, fmt::ArgList()); } \\\n  FMT_WRAP1(func, arg_type, 1) FMT_WRAP1(func, arg_type, 2) \\\n  FMT_WRAP1(func, arg_type, 3) FMT_WRAP1(func, arg_type, 4) \\\n  FMT_WRAP1(func, arg_type, 5) FMT_WRAP1(func, arg_type, 6) \\\n  FMT_WRAP1(func, arg_type, 7) FMT_WRAP1(func, arg_type, 8) \\\n  FMT_WRAP1(func, arg_type, 9) FMT_WRAP1(func, arg_type, 10)\n\n# define FMT_CTOR(ctor, func, arg0_type, arg1_type, n) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  ctor(arg0_type arg0, arg1_type arg1, FMT_GEN(n, FMT_MAKE_ARG)) { \\\n    const fmt::internal::ArgArray<n>::Type array = {FMT_GEN(n, FMT_MAKE_REF)}; \\\n    func(arg0, arg1, fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), array)); \\\n  }\n\n// Emulates a variadic constructor on a pre-C++11 compiler.\n# define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 1) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 2) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 3) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 4) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 5) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 6) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 7) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 8) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 9) \\\n  FMT_CTOR(ctor, func, arg0_type, arg1_type, 10)\n#endif\n\n// Generates a comma-separated list with results of applying f to pairs\n// (argument, index).\n#define FMT_FOR_EACH1(f, x0) f(x0, 0)\n#define FMT_FOR_EACH2(f, x0, x1) \\\n  FMT_FOR_EACH1(f, x0), f(x1, 1)\n#define FMT_FOR_EACH3(f, x0, x1, x2) \\\n  FMT_FOR_EACH2(f, x0 ,x1), f(x2, 2)\n#define FMT_FOR_EACH4(f, x0, x1, x2, x3) \\\n  FMT_FOR_EACH3(f, x0, x1, x2), f(x3, 3)\n#define FMT_FOR_EACH5(f, x0, x1, x2, x3, x4) \\\n  FMT_FOR_EACH4(f, x0, x1, x2, x3), f(x4, 4)\n#define FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5) \\\n  FMT_FOR_EACH5(f, x0, x1, x2, x3, x4), f(x5, 5)\n#define FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6) \\\n  FMT_FOR_EACH6(f, x0, x1, x2, x3, x4, x5), f(x6, 6)\n#define FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7) \\\n  FMT_FOR_EACH7(f, x0, x1, x2, x3, x4, x5, x6), f(x7, 7)\n#define FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8) \\\n  FMT_FOR_EACH8(f, x0, x1, x2, x3, x4, x5, x6, x7), f(x8, 8)\n#define FMT_FOR_EACH10(f, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) \\\n  FMT_FOR_EACH9(f, x0, x1, x2, x3, x4, x5, x6, x7, x8), f(x9, 9)\n\n/**\n An error returned by an operating system or a language runtime,\n for example a file opening error.\n*/\nclass SystemError : public internal::RuntimeError {\n private:\n  FMT_API void init(int err_code, CStringRef format_str, ArgList args);\n\n protected:\n  int error_code_;\n\n  typedef char Char;  // For FMT_VARIADIC_CTOR.\n\n  SystemError() {}\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::SystemError` object with a description\n   formatted with `fmt::format_system_error`. *message* and additional\n   arguments passed into the constructor are formatted similarly to\n   `fmt::format`.\n\n   **Example**::\n\n     // This throws a SystemError with the description\n     //   cannot open file 'madeup': No such file or directory\n     // or similar (system message may vary).\n     const char *filename = \"madeup\";\n     std::FILE *file = std::fopen(filename, \"r\");\n     if (!file)\n       throw fmt::SystemError(errno, \"cannot open file '{}'\", filename);\n   \\endrst\n  */\n  SystemError(int error_code, CStringRef message) {\n    init(error_code, message, ArgList());\n  }\n  FMT_DEFAULTED_COPY_CTOR(SystemError)\n  FMT_VARIADIC_CTOR(SystemError, init, int, CStringRef)\n\n  FMT_API ~SystemError() FMT_DTOR_NOEXCEPT FMT_OVERRIDE;\n\n  int error_code() const { return error_code_; }\n};\n\n/**\n  \\rst\n  Formats an error returned by an operating system or a language runtime,\n  for example a file opening error, and writes it to *out* in the following\n  form:\n\n  .. parsed-literal::\n     *<message>*: *<system-message>*\n\n  where *<message>* is the passed message and *<system-message>* is\n  the system message corresponding to the error code.\n  *error_code* is a system error code as given by ``errno``.\n  If *error_code* is not a valid error code such as -1, the system message\n  may look like \"Unknown error -1\" and is platform-dependent.\n  \\endrst\n */\nFMT_API void format_system_error(fmt::Writer &out, int error_code,\n                                 fmt::StringRef message) FMT_NOEXCEPT;\n\n/**\n  \\rst\n  This template provides operations for formatting and writing data into\n  a character stream. The output is stored in a buffer provided by a subclass\n  such as :class:`fmt::BasicMemoryWriter`.\n\n  You can use one of the following typedefs for common character types:\n\n  +---------+----------------------+\n  | Type    | Definition           |\n  +=========+======================+\n  | Writer  | BasicWriter<char>    |\n  +---------+----------------------+\n  | WWriter | BasicWriter<wchar_t> |\n  +---------+----------------------+\n\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicWriter {\n private:\n  // Output buffer.\n  Buffer<Char> &buffer_;\n\n  FMT_DISALLOW_COPY_AND_ASSIGN(BasicWriter);\n\n  typedef typename internal::CharTraits<Char>::CharPtr CharPtr;\n\n#if FMT_SECURE_SCL\n  // Returns pointer value.\n  static Char *get(CharPtr p) { return p.base(); }\n#else\n  static Char *get(Char *p) { return p; }\n#endif\n\n  // Fills the padding around the content and returns the pointer to the\n  // content area.\n  static CharPtr fill_padding(CharPtr buffer,\n      unsigned total_size, std::size_t content_size, wchar_t fill);\n\n  // Grows the buffer by n characters and returns a pointer to the newly\n  // allocated area.\n  CharPtr grow_buffer(std::size_t n) {\n    std::size_t size = buffer_.size();\n    buffer_.resize(size + n);\n    return internal::make_ptr(&buffer_[size], n);\n  }\n\n  // Writes an unsigned decimal integer.\n  template <typename UInt>\n  Char *write_unsigned_decimal(UInt value, unsigned prefix_size = 0) {\n    unsigned num_digits = internal::count_digits(value);\n    Char *ptr = get(grow_buffer(prefix_size + num_digits));\n    internal::format_decimal(ptr + prefix_size, value, num_digits);\n    return ptr;\n  }\n\n  // Writes a decimal integer.\n  template <typename Int>\n  void write_decimal(Int value) {\n    typedef typename internal::IntTraits<Int>::MainType MainType;\n    MainType abs_value = static_cast<MainType>(value);\n    if (internal::is_negative(value)) {\n      abs_value = 0 - abs_value;\n      *write_unsigned_decimal(abs_value, 1) = '-';\n    } else {\n      write_unsigned_decimal(abs_value, 0);\n    }\n  }\n\n  // Prepare a buffer for integer formatting.\n  CharPtr prepare_int_buffer(unsigned num_digits,\n      const EmptySpec &, const char *prefix, unsigned prefix_size) {\n    unsigned size = prefix_size + num_digits;\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n\n  template <typename Spec>\n  CharPtr prepare_int_buffer(unsigned num_digits,\n    const Spec &spec, const char *prefix, unsigned prefix_size);\n\n  // Formats an integer.\n  template <typename T, typename Spec>\n  void write_int(T value, Spec spec);\n\n  // Formats a floating-point number (double or long double).\n  template <typename T, typename Spec>\n  void write_double(T value, const Spec &spec);\n\n  // Writes a formatted string.\n  template <typename StrChar>\n  CharPtr write_str(const StrChar *s, std::size_t size, const AlignSpec &spec);\n\n  template <typename StrChar, typename Spec>\n  void write_str(const internal::Arg::StringValue<StrChar> &str,\n                 const Spec &spec);\n\n  // This following methods are private to disallow writing wide characters\n  // and strings to a char stream. If you want to print a wide string as a\n  // pointer as std::ostream does, cast it to const void*.\n  // Do not implement!\n  void operator<<(typename internal::WCharHelper<wchar_t, Char>::Unsupported);\n  void operator<<(\n      typename internal::WCharHelper<const wchar_t *, Char>::Unsupported);\n\n  // Appends floating-point length specifier to the format string.\n  // The second argument is only used for overload resolution.\n  void append_float_length(Char *&format_ptr, long double) {\n    *format_ptr++ = 'L';\n  }\n\n  template<typename T>\n  void append_float_length(Char *&, T) {}\n\n  template <typename Impl, typename Char_, typename Spec_>\n  friend class internal::ArgFormatterBase;\n\n  template <typename Impl, typename Char_, typename Spec_>\n  friend class BasicPrintfArgFormatter;\n\n protected:\n  /**\n    Constructs a ``BasicWriter`` object.\n   */\n  explicit BasicWriter(Buffer<Char> &b) : buffer_(b) {}\n\n public:\n  /**\n    \\rst\n    Destroys a ``BasicWriter`` object.\n    \\endrst\n   */\n  virtual ~BasicWriter() {}\n\n  /**\n    Returns the total number of characters written.\n   */\n  std::size_t size() const { return buffer_.size(); }\n\n  /**\n    Returns a pointer to the output buffer content. No terminating null\n    character is appended.\n   */\n  const Char *data() const FMT_NOEXCEPT { return &buffer_[0]; }\n\n  /**\n    Returns a pointer to the output buffer content with terminating null\n    character appended.\n   */\n  const Char *c_str() const {\n    std::size_t size = buffer_.size();\n    buffer_.reserve(size + 1);\n    buffer_[size] = '\\0';\n    return &buffer_[0];\n  }\n\n  /**\n    \\rst\n    Returns the content of the output buffer as an `std::string`.\n    \\endrst\n   */\n  std::basic_string<Char> str() const {\n    return std::basic_string<Char>(&buffer_[0], buffer_.size());\n  }\n\n  /**\n    \\rst\n    Writes formatted data.\n\n    *args* is an argument list representing arbitrary arguments.\n\n    **Example**::\n\n       MemoryWriter out;\n       out.write(\"Current point:\\n\");\n       out.write(\"({:+f}, {:+f})\", -3.14, 3.14);\n\n    This will write the following output to the ``out`` object:\n\n    .. code-block:: none\n\n       Current point:\n       (-3.140000, +3.140000)\n\n    The output can be accessed using :func:`data()`, :func:`c_str` or\n    :func:`str` methods.\n\n    See also :ref:`syntax`.\n    \\endrst\n   */\n  void write(BasicCStringRef<Char> format, ArgList args) {\n    BasicFormatter<Char>(args, *this).format(format);\n  }\n  FMT_VARIADIC_VOID(write, BasicCStringRef<Char>)\n\n  BasicWriter &operator<<(int value) {\n    write_decimal(value);\n    return *this;\n  }\n  BasicWriter &operator<<(unsigned value) {\n    return *this << IntFormatSpec<unsigned>(value);\n  }\n  BasicWriter &operator<<(long value) {\n    write_decimal(value);\n    return *this;\n  }\n  BasicWriter &operator<<(unsigned long value) {\n    return *this << IntFormatSpec<unsigned long>(value);\n  }\n  BasicWriter &operator<<(LongLong value) {\n    write_decimal(value);\n    return *this;\n  }\n\n  /**\n    \\rst\n    Formats *value* and writes it to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(ULongLong value) {\n    return *this << IntFormatSpec<ULongLong>(value);\n  }\n\n  BasicWriter &operator<<(double value) {\n    write_double(value, FormatSpec());\n    return *this;\n  }\n\n  /**\n    \\rst\n    Formats *value* using the general format for floating-point numbers\n    (``'g'``) and writes it to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(long double value) {\n    write_double(value, FormatSpec());\n    return *this;\n  }\n\n  /**\n    Writes a character to the stream.\n   */\n  BasicWriter &operator<<(char value) {\n    buffer_.push_back(value);\n    return *this;\n  }\n\n  BasicWriter &operator<<(\n      typename internal::WCharHelper<wchar_t, Char>::Supported value) {\n    buffer_.push_back(value);\n    return *this;\n  }\n\n  /**\n    \\rst\n    Writes *value* to the stream.\n    \\endrst\n   */\n  BasicWriter &operator<<(fmt::BasicStringRef<Char> value) {\n    const Char *str = value.data();\n    buffer_.append(str, str + value.size());\n    return *this;\n  }\n\n  BasicWriter &operator<<(\n      typename internal::WCharHelper<StringRef, Char>::Supported value) {\n    const char *str = value.data();\n    buffer_.append(str, str + value.size());\n    return *this;\n  }\n\n  template <typename T, typename Spec, typename FillChar>\n  BasicWriter &operator<<(IntFormatSpec<T, Spec, FillChar> spec) {\n    internal::CharTraits<Char>::convert(FillChar());\n    write_int(spec.value(), spec);\n    return *this;\n  }\n\n  template <typename StrChar>\n  BasicWriter &operator<<(const StrFormatSpec<StrChar> &spec) {\n    const StrChar *s = spec.str();\n    write_str(s, std::char_traits<Char>::length(s), spec);\n    return *this;\n  }\n\n  void clear() FMT_NOEXCEPT { buffer_.clear(); }\n\n  Buffer<Char> &buffer() FMT_NOEXCEPT { return buffer_; }\n};\n\ntemplate <typename Char>\ntemplate <typename StrChar>\ntypename BasicWriter<Char>::CharPtr BasicWriter<Char>::write_str(\n      const StrChar *s, std::size_t size, const AlignSpec &spec) {\n  CharPtr out = CharPtr();\n  if (spec.width() > size) {\n    out = grow_buffer(spec.width());\n    Char fill = internal::CharTraits<Char>::cast(spec.fill());\n    if (spec.align() == ALIGN_RIGHT) {\n      std::uninitialized_fill_n(out, spec.width() - size, fill);\n      out += spec.width() - size;\n    } else if (spec.align() == ALIGN_CENTER) {\n      out = fill_padding(out, spec.width(), size, fill);\n    } else {\n      std::uninitialized_fill_n(out + size, spec.width() - size, fill);\n    }\n  } else {\n    out = grow_buffer(size);\n  }\n  std::uninitialized_copy(s, s + size, out);\n  return out;\n}\n\ntemplate <typename Char>\ntemplate <typename StrChar, typename Spec>\nvoid BasicWriter<Char>::write_str(\n    const internal::Arg::StringValue<StrChar> &s, const Spec &spec) {\n  // Check if StrChar is convertible to Char.\n  internal::CharTraits<Char>::convert(StrChar());\n  if (spec.type_ && spec.type_ != 's')\n    internal::report_unknown_type(spec.type_, \"string\");\n  const StrChar *str_value = s.value;\n  std::size_t str_size = s.size;\n  if (str_size == 0) {\n    if (!str_value) {\n      FMT_THROW(FormatError(\"string pointer is null\"));\n    }\n  }\n  std::size_t precision = static_cast<std::size_t>(spec.precision_);\n  if (spec.precision_ >= 0 && precision < str_size)\n    str_size = precision;\n  write_str(str_value, str_size, spec);\n}\n\ntemplate <typename Char>\ntypename BasicWriter<Char>::CharPtr\n  BasicWriter<Char>::fill_padding(\n    CharPtr buffer, unsigned total_size,\n    std::size_t content_size, wchar_t fill) {\n  std::size_t padding = total_size - content_size;\n  std::size_t left_padding = padding / 2;\n  Char fill_char = internal::CharTraits<Char>::cast(fill);\n  std::uninitialized_fill_n(buffer, left_padding, fill_char);\n  buffer += left_padding;\n  CharPtr content = buffer;\n  std::uninitialized_fill_n(buffer + content_size,\n                            padding - left_padding, fill_char);\n  return content;\n}\n\ntemplate <typename Char>\ntemplate <typename Spec>\ntypename BasicWriter<Char>::CharPtr\n  BasicWriter<Char>::prepare_int_buffer(\n    unsigned num_digits, const Spec &spec,\n    const char *prefix, unsigned prefix_size) {\n  unsigned width = spec.width();\n  Alignment align = spec.align();\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  if (spec.precision() > static_cast<int>(num_digits)) {\n    // Octal prefix '0' is counted as a digit, so ignore it if precision\n    // is specified.\n    if (prefix_size > 0 && prefix[prefix_size - 1] == '0')\n      --prefix_size;\n    unsigned number_size =\n        prefix_size + internal::to_unsigned(spec.precision());\n    AlignSpec subspec(number_size, '0', ALIGN_NUMERIC);\n    if (number_size >= width)\n      return prepare_int_buffer(num_digits, subspec, prefix, prefix_size);\n    buffer_.reserve(width);\n    unsigned fill_size = width - number_size;\n    if (align != ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    std::ptrdiff_t offset = get(prepare_int_buffer(\n        num_digits, subspec, prefix, prefix_size)) - &buffer_[0];\n    if (align == ALIGN_LEFT) {\n      CharPtr p = grow_buffer(fill_size);\n      std::uninitialized_fill(p, p + fill_size, fill);\n    }\n    return internal::make_ptr(&buffer_[0], buffer_.size()) + offset;\n  }\n  unsigned size = prefix_size + num_digits;\n  if (width <= size) {\n    CharPtr p = grow_buffer(size);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    return p + size - 1;\n  }\n  CharPtr p = grow_buffer(width);\n  CharPtr end = p + width;\n  if (align == ALIGN_LEFT) {\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n    std::uninitialized_fill(p, end, fill);\n  } else if (align == ALIGN_CENTER) {\n    p = fill_padding(p, width, size, fill);\n    std::uninitialized_copy(prefix, prefix + prefix_size, p);\n    p += size;\n  } else {\n    if (align == ALIGN_NUMERIC) {\n      if (prefix_size != 0) {\n        p = std::uninitialized_copy(prefix, prefix + prefix_size, p);\n        size -= prefix_size;\n      }\n    } else {\n      std::uninitialized_copy(prefix, prefix + prefix_size, end - size);\n    }\n    std::uninitialized_fill(p, end - size, fill);\n    p = end;\n  }\n  return p - 1;\n}\n\ntemplate <typename Char>\ntemplate <typename T, typename Spec>\nvoid BasicWriter<Char>::write_int(T value, Spec spec) {\n  unsigned prefix_size = 0;\n  typedef typename internal::IntTraits<T>::MainType UnsignedType;\n  UnsignedType abs_value = static_cast<UnsignedType>(value);\n  char prefix[4] = \"\";\n  if (internal::is_negative(value)) {\n    prefix[0] = '-';\n    ++prefix_size;\n    abs_value = 0 - abs_value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    prefix[0] = spec.flag(PLUS_FLAG) ? '+' : ' ';\n    ++prefix_size;\n  }\n  switch (spec.type()) {\n  case 0: case 'd': {\n    unsigned num_digits = internal::count_digits(abs_value);\n    CharPtr p = prepare_int_buffer(num_digits, spec, prefix, prefix_size) + 1;\n    internal::format_decimal(get(p), abs_value, 0);\n    break;\n  }\n  case 'x': case 'X': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG)) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = spec.type_prefix();\n    }\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 4) != 0);\n    Char *p = get(prepare_int_buffer(\n      num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    const char *digits = spec.type() == 'x' ?\n        \"0123456789abcdef\" : \"0123456789ABCDEF\";\n    do {\n      *p-- = digits[n & 0xf];\n    } while ((n >>= 4) != 0);\n    break;\n  }\n  case 'b': case 'B': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG)) {\n      prefix[prefix_size++] = '0';\n      prefix[prefix_size++] = spec.type_prefix();\n    }\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 1) != 0);\n    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    do {\n      *p-- = static_cast<Char>('0' + (n & 1));\n    } while ((n >>= 1) != 0);\n    break;\n  }\n  case 'o': {\n    UnsignedType n = abs_value;\n    if (spec.flag(HASH_FLAG))\n      prefix[prefix_size++] = '0';\n    unsigned num_digits = 0;\n    do {\n      ++num_digits;\n    } while ((n >>= 3) != 0);\n    Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));\n    n = abs_value;\n    do {\n      *p-- = static_cast<Char>('0' + (n & 7));\n    } while ((n >>= 3) != 0);\n    break;\n  }\n  case 'n': {\n    unsigned num_digits = internal::count_digits(abs_value);\n    fmt::StringRef sep = \"\";\n#if !(defined(ANDROID) || defined(__ANDROID__))\n    sep = internal::thousands_sep(std::localeconv());\n#endif\n    unsigned size = static_cast<unsigned>(\n          num_digits + sep.size() * ((num_digits - 1) / 3));\n    CharPtr p = prepare_int_buffer(size, spec, prefix, prefix_size) + 1;\n    internal::format_decimal(get(p), abs_value, 0, internal::ThousandsSep(sep));\n    break;\n  }\n  default:\n    internal::report_unknown_type(\n      spec.type(), spec.flag(CHAR_FLAG) ? \"char\" : \"integer\");\n    break;\n  }\n}\n\ntemplate <typename Char>\ntemplate <typename T, typename Spec>\nvoid BasicWriter<Char>::write_double(T value, const Spec &spec) {\n  // Check type.\n  char type = spec.type();\n  bool upper = false;\n  switch (type) {\n  case 0:\n    type = 'g';\n    break;\n  case 'e': case 'f': case 'g': case 'a':\n    break;\n  case 'F':\n#if FMT_MSC_VER\n    // MSVC's printf doesn't support 'F'.\n    type = 'f';\n#endif\n    // Fall through.\n  case 'E': case 'G': case 'A':\n    upper = true;\n    break;\n  default:\n    internal::report_unknown_type(type, \"double\");\n    break;\n  }\n\n  char sign = 0;\n  // Use isnegative instead of value < 0 because the latter is always\n  // false for NaN.\n  if (internal::FPUtil::isnegative(static_cast<double>(value))) {\n    sign = '-';\n    value = -value;\n  } else if (spec.flag(SIGN_FLAG)) {\n    sign = spec.flag(PLUS_FLAG) ? '+' : ' ';\n  }\n\n  if (internal::FPUtil::isnotanumber(value)) {\n    // Format NaN ourselves because sprintf's output is not consistent\n    // across platforms.\n    std::size_t nan_size = 4;\n    const char *nan = upper ? \" NAN\" : \" nan\";\n    if (!sign) {\n      --nan_size;\n      ++nan;\n    }\n    CharPtr out = write_str(nan, nan_size, spec);\n    if (sign)\n      *out = sign;\n    return;\n  }\n\n  if (internal::FPUtil::isinfinity(value)) {\n    // Format infinity ourselves because sprintf's output is not consistent\n    // across platforms.\n    std::size_t inf_size = 4;\n    const char *inf = upper ? \" INF\" : \" inf\";\n    if (!sign) {\n      --inf_size;\n      ++inf;\n    }\n    CharPtr out = write_str(inf, inf_size, spec);\n    if (sign)\n      *out = sign;\n    return;\n  }\n\n  std::size_t offset = buffer_.size();\n  unsigned width = spec.width();\n  if (sign) {\n    buffer_.reserve(buffer_.size() + (width > 1u ? width : 1u));\n    if (width > 0)\n      --width;\n    ++offset;\n  }\n\n  // Build format string.\n  enum { MAX_FORMAT_SIZE = 10}; // longest format: %#-*.*Lg\n  Char format[MAX_FORMAT_SIZE];\n  Char *format_ptr = format;\n  *format_ptr++ = '%';\n  unsigned width_for_sprintf = width;\n  if (spec.flag(HASH_FLAG))\n    *format_ptr++ = '#';\n  if (spec.align() == ALIGN_CENTER) {\n    width_for_sprintf = 0;\n  } else {\n    if (spec.align() == ALIGN_LEFT)\n      *format_ptr++ = '-';\n    if (width != 0)\n      *format_ptr++ = '*';\n  }\n  if (spec.precision() >= 0) {\n    *format_ptr++ = '.';\n    *format_ptr++ = '*';\n  }\n\n  append_float_length(format_ptr, value);\n  *format_ptr++ = type;\n  *format_ptr = '\\0';\n\n  // Format using snprintf.\n  Char fill = internal::CharTraits<Char>::cast(spec.fill());\n  unsigned n = 0;\n  Char *start = FMT_NULL;\n  for (;;) {\n    std::size_t buffer_size = buffer_.capacity() - offset;\n#if FMT_MSC_VER\n    // MSVC's vsnprintf_s doesn't work with zero size, so reserve\n    // space for at least one extra character to make the size non-zero.\n    // Note that the buffer's capacity will increase by more than 1.\n    if (buffer_size == 0) {\n      buffer_.reserve(offset + 1);\n      buffer_size = buffer_.capacity() - offset;\n    }\n#endif\n    start = &buffer_[offset];\n    int result = internal::CharTraits<Char>::format_float(\n        start, buffer_size, format, width_for_sprintf, spec.precision(), value);\n    if (result >= 0) {\n      n = internal::to_unsigned(result);\n      if (offset + n < buffer_.capacity())\n        break;  // The buffer is large enough - continue with formatting.\n      buffer_.reserve(offset + n + 1);\n    } else {\n      // If result is negative we ask to increase the capacity by at least 1,\n      // but as std::vector, the buffer grows exponentially.\n      buffer_.reserve(buffer_.capacity() + 1);\n    }\n  }\n  if (sign) {\n    if ((spec.align() != ALIGN_RIGHT && spec.align() != ALIGN_DEFAULT) ||\n        *start != ' ') {\n      *(start - 1) = sign;\n      sign = 0;\n    } else {\n      *(start - 1) = fill;\n    }\n    ++n;\n  }\n  if (spec.align() == ALIGN_CENTER && spec.width() > n) {\n    width = spec.width();\n    CharPtr p = grow_buffer(width);\n    std::memmove(get(p) + (width - n) / 2, get(p), n * sizeof(Char));\n    fill_padding(p, spec.width(), n, fill);\n    return;\n  }\n  if (spec.fill() != ' ' || sign) {\n    while (*start == ' ')\n      *start++ = fill;\n    if (sign)\n      *(start - 1) = sign;\n  }\n  grow_buffer(n);\n}\n\n/**\n  \\rst\n  This class template provides operations for formatting and writing data\n  into a character stream. The output is stored in a memory buffer that grows\n  dynamically.\n\n  You can use one of the following typedefs for common character types\n  and the standard allocator:\n\n  +---------------+-----------------------------------------------------+\n  | Type          | Definition                                          |\n  +===============+=====================================================+\n  | MemoryWriter  | BasicMemoryWriter<char, std::allocator<char>>       |\n  +---------------+-----------------------------------------------------+\n  | WMemoryWriter | BasicMemoryWriter<wchar_t, std::allocator<wchar_t>> |\n  +---------------+-----------------------------------------------------+\n\n  **Example**::\n\n     MemoryWriter out;\n     out << \"The answer is \" << 42 << \"\\n\";\n     out.write(\"({:+f}, {:+f})\", -3.14, 3.14);\n\n  This will write the following output to the ``out`` object:\n\n  .. code-block:: none\n\n     The answer is 42\n     (-3.140000, +3.140000)\n\n  The output can be converted to an ``std::string`` with ``out.str()`` or\n  accessed as a C string with ``out.c_str()``.\n  \\endrst\n */\ntemplate <typename Char, typename Allocator = std::allocator<Char> >\nclass BasicMemoryWriter : public BasicWriter<Char> {\n private:\n  internal::MemoryBuffer<Char, internal::INLINE_BUFFER_SIZE, Allocator> buffer_;\n\n public:\n  explicit BasicMemoryWriter(const Allocator& alloc = Allocator())\n    : BasicWriter<Char>(buffer_), buffer_(alloc) {}\n\n#if FMT_USE_RVALUE_REFERENCES\n  /**\n    \\rst\n    Constructs a :class:`fmt::BasicMemoryWriter` object moving the content\n    of the other object to it.\n    \\endrst\n   */\n  BasicMemoryWriter(BasicMemoryWriter &&other)\n    : BasicWriter<Char>(buffer_), buffer_(std::move(other.buffer_)) {\n  }\n\n  /**\n    \\rst\n    Moves the content of the other ``BasicMemoryWriter`` object to this one.\n    \\endrst\n   */\n  BasicMemoryWriter &operator=(BasicMemoryWriter &&other) {\n    buffer_ = std::move(other.buffer_);\n    return *this;\n  }\n#endif\n};\n\ntypedef BasicMemoryWriter<char> MemoryWriter;\ntypedef BasicMemoryWriter<wchar_t> WMemoryWriter;\n\n/**\n  \\rst\n  This class template provides operations for formatting and writing data\n  into a fixed-size array. For writing into a dynamically growing buffer\n  use :class:`fmt::BasicMemoryWriter`.\n\n  Any write method will throw ``std::runtime_error`` if the output doesn't fit\n  into the array.\n\n  You can use one of the following typedefs for common character types:\n\n  +--------------+---------------------------+\n  | Type         | Definition                |\n  +==============+===========================+\n  | ArrayWriter  | BasicArrayWriter<char>    |\n  +--------------+---------------------------+\n  | WArrayWriter | BasicArrayWriter<wchar_t> |\n  +--------------+---------------------------+\n  \\endrst\n */\ntemplate <typename Char>\nclass BasicArrayWriter : public BasicWriter<Char> {\n private:\n  internal::FixedBuffer<Char> buffer_;\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the\n   given size.\n   \\endrst\n   */\n  BasicArrayWriter(Char *array, std::size_t size)\n    : BasicWriter<Char>(buffer_), buffer_(array, size) {}\n\n  /**\n   \\rst\n   Constructs a :class:`fmt::BasicArrayWriter` object for *array* of the\n   size known at compile time.\n   \\endrst\n   */\n  template <std::size_t SIZE>\n  explicit BasicArrayWriter(Char (&array)[SIZE])\n    : BasicWriter<Char>(buffer_), buffer_(array, SIZE) {}\n};\n\ntypedef BasicArrayWriter<char> ArrayWriter;\ntypedef BasicArrayWriter<wchar_t> WArrayWriter;\n\n// Reports a system error without throwing an exception.\n// Can be used to report errors from destructors.\nFMT_API void report_system_error(int error_code,\n                                 StringRef message) FMT_NOEXCEPT;\n\n#if FMT_USE_WINDOWS_H\n\n/** A Windows error. */\nclass WindowsError : public SystemError {\n private:\n  FMT_API void init(int error_code, CStringRef format_str, ArgList args);\n\n public:\n  /**\n   \\rst\n   Constructs a :class:`fmt::WindowsError` object with the description\n   of the form\n\n   .. parsed-literal::\n     *<message>*: *<system-message>*\n\n   where *<message>* is the formatted message and *<system-message>* is the\n   system message corresponding to the error code.\n   *error_code* is a Windows error code as given by ``GetLastError``.\n   If *error_code* is not a valid error code such as -1, the system message\n   will look like \"error -1\".\n\n   **Example**::\n\n     // This throws a WindowsError with the description\n     //   cannot open file 'madeup': The system cannot find the file specified.\n     // or similar (system message may vary).\n     const char *filename = \"madeup\";\n     LPOFSTRUCT of = LPOFSTRUCT();\n     HFILE file = OpenFile(filename, &of, OF_READ);\n     if (file == HFILE_ERROR) {\n       throw fmt::WindowsError(GetLastError(),\n                               \"cannot open file '{}'\", filename);\n     }\n   \\endrst\n  */\n  WindowsError(int error_code, CStringRef message) {\n    init(error_code, message, ArgList());\n  }\n  FMT_VARIADIC_CTOR(WindowsError, init, int, CStringRef)\n};\n\n// Reports a Windows error without throwing an exception.\n// Can be used to report errors from destructors.\nFMT_API void report_windows_error(int error_code,\n                                  StringRef message) FMT_NOEXCEPT;\n\n#endif\n\nenum Color { BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE };\n\n/**\n  Formats a string and prints it to stdout using ANSI escape sequences\n  to specify color (experimental).\n  Example:\n    print_colored(fmt::RED, \"Elapsed time: {0:.2f} seconds\", 1.23);\n */\nFMT_API void print_colored(Color c, CStringRef format, ArgList args);\n\n/**\n  \\rst\n  Formats arguments and returns the result as a string.\n\n  **Example**::\n\n    std::string message = format(\"The answer is {}\", 42);\n  \\endrst\n*/\ninline std::string format(CStringRef format_str, ArgList args) {\n  MemoryWriter w;\n  w.write(format_str, args);\n  return w.str();\n}\n\ninline std::wstring format(WCStringRef format_str, ArgList args) {\n  WMemoryWriter w;\n  w.write(format_str, args);\n  return w.str();\n}\n\n/**\n  \\rst\n  Prints formatted data to the file *f*.\n\n  **Example**::\n\n    print(stderr, \"Don't {}!\", \"panic\");\n  \\endrst\n */\nFMT_API void print(std::FILE *f, CStringRef format_str, ArgList args);\n\n/**\n  \\rst\n  Prints formatted data to ``stdout``.\n\n  **Example**::\n\n    print(\"Elapsed time: {0:.2f} seconds\", 1.23);\n  \\endrst\n */\nFMT_API void print(CStringRef format_str, ArgList args);\n\n/**\n  Fast integer formatter.\n */\nclass FormatInt {\n private:\n  // Buffer should be large enough to hold all digits (digits10 + 1),\n  // a sign and a null character.\n  enum {BUFFER_SIZE = std::numeric_limits<ULongLong>::digits10 + 3};\n  mutable char buffer_[BUFFER_SIZE];\n  char *str_;\n\n  // Formats value in reverse and returns the number of digits.\n  char *format_decimal(ULongLong value) {\n    char *buffer_end = buffer_ + BUFFER_SIZE - 1;\n    while (value >= 100) {\n      // Integer division is slow so do it for a group of two digits instead\n      // of for every digit. The idea comes from the talk by Alexandrescu\n      // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n      unsigned index = static_cast<unsigned>((value % 100) * 2);\n      value /= 100;\n      *--buffer_end = internal::Data::DIGITS[index + 1];\n      *--buffer_end = internal::Data::DIGITS[index];\n    }\n    if (value < 10) {\n      *--buffer_end = static_cast<char>('0' + value);\n      return buffer_end;\n    }\n    unsigned index = static_cast<unsigned>(value * 2);\n    *--buffer_end = internal::Data::DIGITS[index + 1];\n    *--buffer_end = internal::Data::DIGITS[index];\n    return buffer_end;\n  }\n\n  void FormatSigned(LongLong value) {\n    ULongLong abs_value = static_cast<ULongLong>(value);\n    bool negative = value < 0;\n    if (negative)\n      abs_value = 0 - abs_value;\n    str_ = format_decimal(abs_value);\n    if (negative)\n      *--str_ = '-';\n  }\n\n public:\n  explicit FormatInt(int value) { FormatSigned(value); }\n  explicit FormatInt(long value) { FormatSigned(value); }\n  explicit FormatInt(LongLong value) { FormatSigned(value); }\n  explicit FormatInt(unsigned value) : str_(format_decimal(value)) {}\n  explicit FormatInt(unsigned long value) : str_(format_decimal(value)) {}\n  explicit FormatInt(ULongLong value) : str_(format_decimal(value)) {}\n\n  /** Returns the number of characters written to the output buffer. */\n  std::size_t size() const {\n    return internal::to_unsigned(buffer_ - str_ + BUFFER_SIZE - 1);\n  }\n\n  /**\n    Returns a pointer to the output buffer content. No terminating null\n    character is appended.\n   */\n  const char *data() const { return str_; }\n\n  /**\n    Returns a pointer to the output buffer content with terminating null\n    character appended.\n   */\n  const char *c_str() const {\n    buffer_[BUFFER_SIZE - 1] = '\\0';\n    return str_;\n  }\n\n  /**\n    \\rst\n    Returns the content of the output buffer as an ``std::string``.\n    \\endrst\n   */\n  std::string str() const { return std::string(str_, size()); }\n};\n\n// Formats a decimal integer value writing into buffer and returns\n// a pointer to the end of the formatted string. This function doesn't\n// write a terminating null character.\ntemplate <typename T>\ninline void format_decimal(char *&buffer, T value) {\n  typedef typename internal::IntTraits<T>::MainType MainType;\n  MainType abs_value = static_cast<MainType>(value);\n  if (internal::is_negative(value)) {\n    *buffer++ = '-';\n    abs_value = 0 - abs_value;\n  }\n  if (abs_value < 100) {\n    if (abs_value < 10) {\n      *buffer++ = static_cast<char>('0' + abs_value);\n      return;\n    }\n    unsigned index = static_cast<unsigned>(abs_value * 2);\n    *buffer++ = internal::Data::DIGITS[index];\n    *buffer++ = internal::Data::DIGITS[index + 1];\n    return;\n  }\n  unsigned num_digits = internal::count_digits(abs_value);\n  internal::format_decimal(buffer, abs_value, num_digits);\n  buffer += num_digits;\n}\n\n/**\n  \\rst\n  Returns a named argument for formatting functions.\n\n  **Example**::\n\n    print(\"Elapsed time: {s:.2f} seconds\", arg(\"s\", 1.23));\n\n  \\endrst\n */\ntemplate <typename T>\ninline internal::NamedArgWithType<char, T> arg(StringRef name, const T &arg) {\n  return internal::NamedArgWithType<char, T>(name, arg);\n}\n\ntemplate <typename T>\ninline internal::NamedArgWithType<wchar_t, T> arg(WStringRef name, const T &arg) {\n  return internal::NamedArgWithType<wchar_t, T>(name, arg);\n}\n\n// The following two functions are deleted intentionally to disable\n// nested named arguments as in ``format(\"{}\", arg(\"a\", arg(\"b\", 42)))``.\ntemplate <typename Char>\nvoid arg(StringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;\ntemplate <typename Char>\nvoid arg(WStringRef, const internal::NamedArg<Char>&) FMT_DELETED_OR_UNDEFINED;\n}\n\n#if FMT_GCC_VERSION\n// Use the system_header pragma to suppress warnings about variadic macros\n// because suppressing -Wvariadic-macros with the diagnostic pragma doesn't\n// work. It is used at the end because we want to suppress as little warnings\n// as possible.\n# pragma GCC system_header\n#endif\n\n// This is used to work around VC++ bugs in handling variadic macros.\n#define FMT_EXPAND(args) args\n\n// Returns the number of arguments.\n// Based on https://groups.google.com/forum/#!topic/comp.std.c/d-6Mj5Lko_s.\n#define FMT_NARG(...) FMT_NARG_(__VA_ARGS__, FMT_RSEQ_N())\n#define FMT_NARG_(...) FMT_EXPAND(FMT_ARG_N(__VA_ARGS__))\n#define FMT_ARG_N(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10, N, ...) N\n#define FMT_RSEQ_N() 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n\n#define FMT_FOR_EACH_(N, f, ...) \\\n  FMT_EXPAND(FMT_CONCAT(FMT_FOR_EACH, N)(f, __VA_ARGS__))\n#define FMT_FOR_EACH(f, ...) \\\n  FMT_EXPAND(FMT_FOR_EACH_(FMT_NARG(__VA_ARGS__), f, __VA_ARGS__))\n\n#define FMT_ADD_ARG_NAME(type, index) type arg##index\n#define FMT_GET_ARG_NAME(type, index) arg##index\n\n#if FMT_USE_VARIADIC_TEMPLATES\n# define FMT_VARIADIC_(Const, Char, ReturnType, func, call, ...) \\\n  template <typename... Args> \\\n  ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n      const Args & ... args) Const { \\\n    typedef fmt::internal::ArgArray<sizeof...(Args)> ArgArray; \\\n    typename ArgArray::Type array{ \\\n      ArgArray::template make<fmt::BasicFormatter<Char> >(args)...}; \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), \\\n      fmt::ArgList(fmt::internal::make_type(args...), array)); \\\n  }\n#else\n// Defines a wrapper for a function taking __VA_ARGS__ arguments\n// and n additional arguments of arbitrary types.\n# define FMT_WRAP(Const, Char, ReturnType, func, call, n, ...) \\\n  template <FMT_GEN(n, FMT_MAKE_TEMPLATE_ARG)> \\\n  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__), \\\n      FMT_GEN(n, FMT_MAKE_ARG)) Const { \\\n    fmt::internal::ArgArray<n>::Type arr; \\\n    FMT_GEN(n, FMT_ASSIGN_##Char); \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList( \\\n      fmt::internal::make_type(FMT_GEN(n, FMT_MAKE_REF2)), arr)); \\\n  }\n\n# define FMT_VARIADIC_(Const, Char, ReturnType, func, call, ...) \\\n  inline ReturnType func(FMT_FOR_EACH(FMT_ADD_ARG_NAME, __VA_ARGS__)) Const { \\\n    call(FMT_FOR_EACH(FMT_GET_ARG_NAME, __VA_ARGS__), fmt::ArgList()); \\\n  } \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 1, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 2, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 3, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 4, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 5, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 6, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 7, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 8, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 9, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 10, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 11, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 12, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 13, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 14, __VA_ARGS__) \\\n  FMT_WRAP(Const, Char, ReturnType, func, call, 15, __VA_ARGS__)\n#endif  // FMT_USE_VARIADIC_TEMPLATES\n\n/**\n  \\rst\n  Defines a variadic function with the specified return type, function name\n  and argument types passed as variable arguments to this macro.\n\n  **Example**::\n\n    void print_error(const char *file, int line, const char *format,\n                     fmt::ArgList args) {\n      fmt::print(\"{}: {}: \", file, line);\n      fmt::print(format, args);\n    }\n    FMT_VARIADIC(void, print_error, const char *, int, const char *)\n\n  ``FMT_VARIADIC`` is used for compatibility with legacy C++ compilers that\n  don't implement variadic templates. You don't have to use this macro if\n  you don't need legacy compiler support and can use variadic templates\n  directly::\n\n    template <typename... Args>\n    void print_error(const char *file, int line, const char *format,\n                     const Args & ... args) {\n      fmt::print(\"{}: {}: \", file, line);\n      fmt::print(format, args...);\n    }\n  \\endrst\n */\n#define FMT_VARIADIC(ReturnType, func, ...) \\\n  FMT_VARIADIC_(, char, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_VARIADIC_CONST(ReturnType, func, ...) \\\n  FMT_VARIADIC_(const, char, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_VARIADIC_W(ReturnType, func, ...) \\\n  FMT_VARIADIC_(, wchar_t, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_VARIADIC_CONST_W(ReturnType, func, ...) \\\n  FMT_VARIADIC_(const, wchar_t, ReturnType, func, return func, __VA_ARGS__)\n\n#define FMT_CAPTURE_ARG_(id, index) ::fmt::arg(#id, id)\n\n#define FMT_CAPTURE_ARG_W_(id, index) ::fmt::arg(L###id, id)\n\n/**\n  \\rst\n  Convenient macro to capture the arguments' names and values into several\n  ``fmt::arg(name, value)``.\n\n  **Example**::\n\n    int x = 1, y = 2;\n    print(\"point: ({x}, {y})\", FMT_CAPTURE(x, y));\n    // same as:\n    // print(\"point: ({x}, {y})\", arg(\"x\", x), arg(\"y\", y));\n\n  \\endrst\n */\n#define FMT_CAPTURE(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_, __VA_ARGS__)\n\n#define FMT_CAPTURE_W(...) FMT_FOR_EACH(FMT_CAPTURE_ARG_W_, __VA_ARGS__)\n\nnamespace fmt {\nFMT_VARIADIC(std::string, format, CStringRef)\nFMT_VARIADIC_W(std::wstring, format, WCStringRef)\nFMT_VARIADIC(void, print, CStringRef)\nFMT_VARIADIC(void, print, std::FILE *, CStringRef)\nFMT_VARIADIC(void, print_colored, Color, CStringRef)\n\nnamespace internal {\ntemplate <typename Char>\ninline bool is_name_start(Char c) {\n  return ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || '_' == c;\n}\n\n// Parses an unsigned integer advancing s to the end of the parsed input.\n// This function assumes that the first character of s is a digit.\ntemplate <typename Char>\nunsigned parse_nonnegative_int(const Char *&s) {\n  assert('0' <= *s && *s <= '9');\n  unsigned value = 0;\n  // Convert to unsigned to prevent a warning.\n  unsigned max_int = (std::numeric_limits<int>::max)();\n  unsigned big = max_int / 10;\n  do {\n    // Check for overflow.\n    if (value > big) {\n      value = max_int + 1;\n      break;\n    }\n    value = value * 10 + (*s - '0');\n    ++s;\n  } while ('0' <= *s && *s <= '9');\n  // Convert to unsigned to prevent a warning.\n  if (value > max_int)\n    FMT_THROW(FormatError(\"number is too big\"));\n  return value;\n}\n\ninline void require_numeric_argument(const Arg &arg, char spec) {\n  if (arg.type > Arg::LAST_NUMERIC_TYPE) {\n    std::string message =\n        fmt::format(\"format specifier '{}' requires numeric argument\", spec);\n    FMT_THROW(fmt::FormatError(message));\n  }\n}\n\ntemplate <typename Char>\nvoid check_sign(const Char *&s, const Arg &arg) {\n  char sign = static_cast<char>(*s);\n  require_numeric_argument(arg, sign);\n  if (arg.type == Arg::UINT || arg.type == Arg::ULONG_LONG) {\n    FMT_THROW(FormatError(fmt::format(\n      \"format specifier '{}' requires signed argument\", sign)));\n  }\n  ++s;\n}\n}  // namespace internal\n\ntemplate <typename Char, typename AF>\ninline internal::Arg BasicFormatter<Char, AF>::get_arg(\n    BasicStringRef<Char> arg_name, const char *&error) {\n  if (check_no_auto_index(error)) {\n    map_.init(args());\n    const internal::Arg *arg = map_.find(arg_name);\n    if (arg)\n      return *arg;\n    error = \"argument not found\";\n  }\n  return internal::Arg();\n}\n\ntemplate <typename Char, typename AF>\ninline internal::Arg BasicFormatter<Char, AF>::parse_arg_index(const Char *&s) {\n  const char *error = FMT_NULL;\n  internal::Arg arg = *s < '0' || *s > '9' ?\n        next_arg(error) : get_arg(internal::parse_nonnegative_int(s), error);\n  if (error) {\n    FMT_THROW(FormatError(\n                *s != '}' && *s != ':' ? \"invalid format string\" : error));\n  }\n  return arg;\n}\n\ntemplate <typename Char, typename AF>\ninline internal::Arg BasicFormatter<Char, AF>::parse_arg_name(const Char *&s) {\n  assert(internal::is_name_start(*s));\n  const Char *start = s;\n  Char c;\n  do {\n    c = *++s;\n  } while (internal::is_name_start(c) || ('0' <= c && c <= '9'));\n  const char *error = FMT_NULL;\n  internal::Arg arg = get_arg(BasicStringRef<Char>(start, s - start), error);\n  if (error)\n    FMT_THROW(FormatError(error));\n  return arg;\n}\n\ntemplate <typename Char, typename ArgFormatter>\nconst Char *BasicFormatter<Char, ArgFormatter>::format(\n    const Char *&format_str, const internal::Arg &arg) {\n  using internal::Arg;\n  const Char *s = format_str;\n  typename ArgFormatter::SpecType spec;\n  if (*s == ':') {\n    if (arg.type == Arg::CUSTOM) {\n      arg.custom.format(this, arg.custom.value, &s);\n      return s;\n    }\n    ++s;\n    // Parse fill and alignment.\n    if (Char c = *s) {\n      const Char *p = s + 1;\n      spec.align_ = ALIGN_DEFAULT;\n      do {\n        switch (*p) {\n          case '<':\n            spec.align_ = ALIGN_LEFT;\n            break;\n          case '>':\n            spec.align_ = ALIGN_RIGHT;\n            break;\n          case '=':\n            spec.align_ = ALIGN_NUMERIC;\n            break;\n          case '^':\n            spec.align_ = ALIGN_CENTER;\n            break;\n        }\n        if (spec.align_ != ALIGN_DEFAULT) {\n          if (p != s) {\n            if (c == '}') break;\n            if (c == '{')\n              FMT_THROW(FormatError(\"invalid fill character '{'\"));\n            s += 2;\n            spec.fill_ = c;\n          } else ++s;\n          if (spec.align_ == ALIGN_NUMERIC)\n            require_numeric_argument(arg, '=');\n          break;\n        }\n      } while (--p >= s);\n    }\n\n    // Parse sign.\n    switch (*s) {\n      case '+':\n        check_sign(s, arg);\n        spec.flags_ |= SIGN_FLAG | PLUS_FLAG;\n        break;\n      case '-':\n        check_sign(s, arg);\n        spec.flags_ |= MINUS_FLAG;\n        break;\n      case ' ':\n        check_sign(s, arg);\n        spec.flags_ |= SIGN_FLAG;\n        break;\n    }\n\n    if (*s == '#') {\n      require_numeric_argument(arg, '#');\n      spec.flags_ |= HASH_FLAG;\n      ++s;\n    }\n\n    // Parse zero flag.\n    if (*s == '0') {\n      require_numeric_argument(arg, '0');\n      spec.align_ = ALIGN_NUMERIC;\n      spec.fill_ = '0';\n      ++s;\n    }\n\n    // Parse width.\n    if ('0' <= *s && *s <= '9') {\n      spec.width_ = internal::parse_nonnegative_int(s);\n    } else if (*s == '{') {\n      ++s;\n      Arg width_arg = internal::is_name_start(*s) ?\n            parse_arg_name(s) : parse_arg_index(s);\n      if (*s++ != '}')\n        FMT_THROW(FormatError(\"invalid format string\"));\n      ULongLong value = 0;\n      switch (width_arg.type) {\n      case Arg::INT:\n        if (width_arg.int_value < 0)\n          FMT_THROW(FormatError(\"negative width\"));\n        value = width_arg.int_value;\n        break;\n      case Arg::UINT:\n        value = width_arg.uint_value;\n        break;\n      case Arg::LONG_LONG:\n        if (width_arg.long_long_value < 0)\n          FMT_THROW(FormatError(\"negative width\"));\n        value = width_arg.long_long_value;\n        break;\n      case Arg::ULONG_LONG:\n        value = width_arg.ulong_long_value;\n        break;\n      default:\n        FMT_THROW(FormatError(\"width is not integer\"));\n      }\n      unsigned max_int = (std::numeric_limits<int>::max)();\n      if (value > max_int)\n        FMT_THROW(FormatError(\"number is too big\"));\n      spec.width_ = static_cast<int>(value);\n    }\n\n    // Parse precision.\n    if (*s == '.') {\n      ++s;\n      spec.precision_ = 0;\n      if ('0' <= *s && *s <= '9') {\n        spec.precision_ = internal::parse_nonnegative_int(s);\n      } else if (*s == '{') {\n        ++s;\n        Arg precision_arg = internal::is_name_start(*s) ?\n              parse_arg_name(s) : parse_arg_index(s);\n        if (*s++ != '}')\n          FMT_THROW(FormatError(\"invalid format string\"));\n        ULongLong value = 0;\n        switch (precision_arg.type) {\n          case Arg::INT:\n            if (precision_arg.int_value < 0)\n              FMT_THROW(FormatError(\"negative precision\"));\n            value = precision_arg.int_value;\n            break;\n          case Arg::UINT:\n            value = precision_arg.uint_value;\n            break;\n          case Arg::LONG_LONG:\n            if (precision_arg.long_long_value < 0)\n              FMT_THROW(FormatError(\"negative precision\"));\n            value = precision_arg.long_long_value;\n            break;\n          case Arg::ULONG_LONG:\n            value = precision_arg.ulong_long_value;\n            break;\n          default:\n            FMT_THROW(FormatError(\"precision is not integer\"));\n        }\n        unsigned max_int = (std::numeric_limits<int>::max)();\n        if (value > max_int)\n          FMT_THROW(FormatError(\"number is too big\"));\n        spec.precision_ = static_cast<int>(value);\n      } else {\n        FMT_THROW(FormatError(\"missing precision specifier\"));\n      }\n      if (arg.type <= Arg::LAST_INTEGER_TYPE || arg.type == Arg::POINTER) {\n        FMT_THROW(FormatError(\n            fmt::format(\"precision not allowed in {} format specifier\",\n            arg.type == Arg::POINTER ? \"pointer\" : \"integer\")));\n      }\n    }\n\n    // Parse type.\n    if (*s != '}' && *s)\n      spec.type_ = static_cast<char>(*s++);\n  }\n\n  if (*s++ != '}')\n    FMT_THROW(FormatError(\"missing '}' in format string\"));\n\n  // Format argument.\n  ArgFormatter(*this, spec, s - 1).visit(arg);\n  return s;\n}\n\ntemplate <typename Char, typename AF>\nvoid BasicFormatter<Char, AF>::format(BasicCStringRef<Char> format_str) {\n  const Char *s = format_str.c_str();\n  const Char *start = s;\n  while (*s) {\n    Char c = *s++;\n    if (c != '{' && c != '}') continue;\n    if (*s == c) {\n      write(writer_, start, s);\n      start = ++s;\n      continue;\n    }\n    if (c == '}')\n      FMT_THROW(FormatError(\"unmatched '}' in format string\"));\n    write(writer_, start, s - 1);\n    internal::Arg arg = internal::is_name_start(*s) ?\n          parse_arg_name(s) : parse_arg_index(s);\n    start = s = format(s, arg);\n  }\n  write(writer_, start, s);\n}\n\ntemplate <typename Char, typename It>\nstruct ArgJoin {\n  It first;\n  It last;\n  BasicCStringRef<Char> sep;\n\n  ArgJoin(It first, It last, const BasicCStringRef<Char>& sep) :\n    first(first),\n    last(last),\n    sep(sep) {}\n};\n\ntemplate <typename It>\nArgJoin<char, It> join(It first, It last, const BasicCStringRef<char>& sep) {\n  return ArgJoin<char, It>(first, last, sep);\n}\n\ntemplate <typename It>\nArgJoin<wchar_t, It> join(It first, It last, const BasicCStringRef<wchar_t>& sep) {\n  return ArgJoin<wchar_t, It>(first, last, sep);\n}\n\n#if FMT_HAS_GXX_CXX11\ntemplate <typename Range>\nauto join(const Range& range, const BasicCStringRef<char>& sep)\n    -> ArgJoin<char, decltype(std::begin(range))> {\n  return join(std::begin(range), std::end(range), sep);\n}\n\ntemplate <typename Range>\nauto join(const Range& range, const BasicCStringRef<wchar_t>& sep)\n    -> ArgJoin<wchar_t, decltype(std::begin(range))> {\n  return join(std::begin(range), std::end(range), sep);\n}\n#endif\n\ntemplate <typename ArgFormatter, typename Char, typename It>\nvoid format_arg(fmt::BasicFormatter<Char, ArgFormatter> &f,\n    const Char *&format_str, const ArgJoin<Char, It>& e) {\n  const Char* end = format_str;\n  int brace_level = 1;\n  while (*end) {\n    if (*end == '}' && --brace_level == 0)\n      break;\n    if (*end == '{')\n      ++brace_level;\n    ++end;\n  }\n  if (*end != '}')\n    FMT_THROW(FormatError(\"missing '}' in format string\"));\n\n  It it = e.first;\n  if (it != e.last) {\n    const Char* save = format_str;\n    f.format(format_str, internal::MakeArg<fmt::BasicFormatter<Char, ArgFormatter> >(*it++));\n    while (it != e.last) {\n      f.writer().write(e.sep);\n      format_str = save;\n      f.format(format_str, internal::MakeArg<fmt::BasicFormatter<Char, ArgFormatter> >(*it++));\n    }\n  }\n  format_str = end + 1;\n}\n}  // namespace fmt\n\n#if FMT_USE_USER_DEFINED_LITERALS\nnamespace fmt {\nnamespace internal {\n\ntemplate <typename Char>\nstruct UdlFormat {\n  const Char *str;\n\n  template <typename... Args>\n  auto operator()(Args && ... args) const\n                  -> decltype(format(str, std::forward<Args>(args)...)) {\n    return format(str, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <typename Char>\nstruct UdlArg {\n  const Char *str;\n\n  template <typename T>\n  NamedArgWithType<Char, T> operator=(T &&value) const {\n    return {str, std::forward<T>(value)};\n  }\n};\n\n} // namespace internal\n\ninline namespace literals {\n\n/**\n  \\rst\n  C++11 literal equivalent of :func:`fmt::format`.\n\n  **Example**::\n\n    using namespace fmt::literals;\n    std::string message = \"The answer is {}\"_format(42);\n  \\endrst\n */\ninline internal::UdlFormat<char>\noperator\"\" _format(const char *s, std::size_t) { return {s}; }\ninline internal::UdlFormat<wchar_t>\noperator\"\" _format(const wchar_t *s, std::size_t) { return {s}; }\n\n/**\n  \\rst\n  C++11 literal equivalent of :func:`fmt::arg`.\n\n  **Example**::\n\n    using namespace fmt::literals;\n    print(\"Elapsed time: {s:.2f} seconds\", \"s\"_a=1.23);\n  \\endrst\n */\ninline internal::UdlArg<char>\noperator\"\" _a(const char *s, std::size_t) { return {s}; }\ninline internal::UdlArg<wchar_t>\noperator\"\" _a(const wchar_t *s, std::size_t) { return {s}; }\n\n} // inline namespace literals\n} // namespace fmt\n#endif // FMT_USE_USER_DEFINED_LITERALS\n\n// Restore warnings.\n#if FMT_GCC_VERSION >= 406\n# pragma GCC diagnostic pop\n#endif\n\n#if defined(__clang__) && !defined(FMT_ICC_VERSION)\n# pragma clang diagnostic pop\n#endif\n\n#ifdef FMT_HEADER_ONLY\n# define FMT_FUNC inline\n# include \"format.cc\"\n#else\n# define FMT_FUNC\n#endif\n\n#endif  // FMT_FORMAT_H_\n", "/*\n Formatting library tests.\n\n Copyright (c) 2012-2014, Victor Zverovich\n All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n 2. Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\n THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\n ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <cctype>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <cstring>\n#include <memory>\n#include <stdint.h>\n\n#if FMT_USE_TYPE_TRAITS\n# include <type_traits>\n#endif\n\n#include \"gmock/gmock.h\"\n\n// Test that the library compiles if None is defined to 0 as done by xlib.h.\n#define None 0\n\nstruct LocaleMock {\n  static LocaleMock *instance;\n\n  MOCK_METHOD0(localeconv, lconv *());\n} *LocaleMock::instance;\n\nnamespace fmt {\nnamespace std {\nusing namespace ::std;\nlconv *localeconv() {\n  return LocaleMock::instance ?\n        LocaleMock::instance->localeconv() : ::std::localeconv();\n}\n}\n}\n\n#include \"fmt/format.h\"\n\n#include \"util.h\"\n#include \"mock-allocator.h\"\n#include \"gtest-extra.h\"\n\n#undef min\n#undef max\n\nusing std::size_t;\n\nusing fmt::BasicWriter;\nusing fmt::format;\nusing fmt::FormatError;\nusing fmt::StringRef;\nusing fmt::CStringRef;\nusing fmt::MemoryWriter;\nusing fmt::WMemoryWriter;\nusing fmt::pad;\n\nnamespace {\n\n// Format value using the standard library.\ntemplate <typename Char, typename T>\nvoid std_format(const T &value, std::basic_string<Char> &result) {\n  std::basic_ostringstream<Char> os;\n  os << value;\n  result = os.str();\n}\n\n#ifdef __MINGW32__\n// Workaround a bug in formatting long double in MinGW.\nvoid std_format(long double value, std::string &result) {\n  char buffer[100];\n  safe_sprintf(buffer, \"%Lg\", value);\n  result = buffer;\n}\nvoid std_format(long double value, std::wstring &result) {\n  wchar_t buffer[100];\n  swprintf(buffer, L\"%Lg\", value);\n  result = buffer;\n}\n#endif\n\n// Checks if writing value to BasicWriter<Char> produces the same result\n// as writing it to std::basic_ostringstream<Char>.\ntemplate <typename Char, typename T>\n::testing::AssertionResult check_write(const T &value, const char *type) {\n  std::basic_string<Char> actual =\n      (fmt::BasicMemoryWriter<Char>() << value).str();\n  std::basic_string<Char> expected;\n  std_format(value, expected);\n  if (expected == actual)\n    return ::testing::AssertionSuccess();\n  return ::testing::AssertionFailure()\n      << \"Value of: (Writer<\" << type << \">() << value).str()\\n\"\n      << \"  Actual: \" << actual << \"\\n\"\n      << \"Expected: \" << expected << \"\\n\";\n}\n\nstruct AnyWriteChecker {\n  template <typename T>\n  ::testing::AssertionResult operator()(const char *, const T &value) const {\n    ::testing::AssertionResult result = check_write<char>(value, \"char\");\n    return result ? check_write<wchar_t>(value, \"wchar_t\") : result;\n  }\n};\n\ntemplate <typename Char>\nstruct WriteChecker {\n  template <typename T>\n  ::testing::AssertionResult operator()(const char *, const T &value) const {\n    return check_write<Char>(value, \"char\");\n  }\n};\n\n// Checks if writing value to BasicWriter produces the same result\n// as writing it to std::ostringstream both for char and wchar_t.\n#define CHECK_WRITE(value) EXPECT_PRED_FORMAT1(AnyWriteChecker(), value)\n\n#define CHECK_WRITE_CHAR(value) \\\n  EXPECT_PRED_FORMAT1(WriteChecker<char>(), value)\n#define CHECK_WRITE_WCHAR(value) \\\n  EXPECT_PRED_FORMAT1(WriteChecker<wchar_t>(), value)\n}  // namespace\n\nTEST(StringRefTest, Ctor) {\n  EXPECT_STREQ(\"abc\", StringRef(\"abc\").data());\n  EXPECT_EQ(3u, StringRef(\"abc\").size());\n\n  EXPECT_STREQ(\"defg\", StringRef(std::string(\"defg\")).data());\n  EXPECT_EQ(4u, StringRef(std::string(\"defg\")).size());\n\n#if FMT_HAS_STRING_VIEW\n  EXPECT_STREQ(\"hijk\", StringRef(std::string_view(\"hijk\")).data());\n  EXPECT_EQ(4u, StringRef(std::string_view(\"hijk\")).size());\n#endif\n\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  EXPECT_STREQ(\"hijk\", StringRef(std::experimental::string_view(\"hijk\")).data());\n  EXPECT_EQ(4u, StringRef(std::experimental::string_view(\"hijk\")).size());\n#endif\n}\n\nTEST(StringRefTest, ConvertToString) {\n  std::string s = StringRef(\"abc\").to_string();\n  EXPECT_EQ(\"abc\", s);\n\n#if FMT_HAS_STRING_VIEW\n  StringRef str_ref(\"defg\");\n  std::string_view sv = static_cast<std::string_view>(str_ref);\n  EXPECT_EQ(\"defg\", sv);\n#endif\n\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  StringRef str_ref(\"defg\");\n  std::experimental::string_view sv = static_cast<std::experimental::string_view>(str_ref);\n  EXPECT_EQ(\"defg\", sv);\n#endif\n}\n\nTEST(CStringRefTest, Ctor) {\n  EXPECT_STREQ(\"abc\", CStringRef(\"abc\").c_str());\n  EXPECT_STREQ(\"defg\", CStringRef(std::string(\"defg\")).c_str());\n\n#if FMT_HAS_STRING_VIEW\n  EXPECT_STREQ(\"hijk\", CStringRef(std::string_view(\"hijk\")).c_str());\n#endif\n\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\n  EXPECT_STREQ(\"hijk\", CStringRef(std::experimental::string_view(\"hijk\")).c_str());\n#endif\n}\n\n#if FMT_USE_TYPE_TRAITS\nTEST(WriterTest, NotCopyConstructible) {\n  EXPECT_FALSE(std::is_copy_constructible<BasicWriter<char> >::value);\n}\n\nTEST(WriterTest, NotCopyAssignable) {\n  EXPECT_FALSE(std::is_copy_assignable<BasicWriter<char> >::value);\n}\n#endif\n\nTEST(WriterTest, Ctor) {\n  MemoryWriter w;\n  EXPECT_EQ(0u, w.size());\n  EXPECT_STREQ(\"\", w.c_str());\n  EXPECT_EQ(\"\", w.str());\n}\n\n#if FMT_USE_RVALUE_REFERENCES\n\nvoid check_move_writer(const std::string &str, MemoryWriter &w) {\n  MemoryWriter w2(std::move(w));\n  // Move shouldn't destroy the inline content of the first writer.\n  EXPECT_EQ(str, w.str());\n  EXPECT_EQ(str, w2.str());\n}\n\nTEST(WriterTest, MoveCtor) {\n  MemoryWriter w;\n  w << \"test\";\n  check_move_writer(\"test\", w);\n  // This fills the inline buffer, but doesn't cause dynamic allocation.\n  std::string s;\n  for (int i = 0; i < fmt::internal::INLINE_BUFFER_SIZE; ++i)\n    s += '*';\n  w.clear();\n  w << s;\n  check_move_writer(s, w);\n  const char *inline_buffer_ptr = w.data();\n  // Adding one more character causes the content to move from the inline to\n  // a dynamically allocated buffer.\n  w << '*';\n  MemoryWriter w2(std::move(w));\n  // Move should rip the guts of the first writer.\n  EXPECT_EQ(inline_buffer_ptr, w.data());\n  EXPECT_EQ(s + '*', w2.str());\n}\n\nvoid CheckMoveAssignWriter(const std::string &str, MemoryWriter &w) {\n  MemoryWriter w2;\n  w2 = std::move(w);\n  // Move shouldn't destroy the inline content of the first writer.\n  EXPECT_EQ(str, w.str());\n  EXPECT_EQ(str, w2.str());\n}\n\nTEST(WriterTest, MoveAssignment) {\n  MemoryWriter w;\n  w << \"test\";\n  CheckMoveAssignWriter(\"test\", w);\n  // This fills the inline buffer, but doesn't cause dynamic allocation.\n  std::string s;\n  for (int i = 0; i < fmt::internal::INLINE_BUFFER_SIZE; ++i)\n    s += '*';\n  w.clear();\n  w << s;\n  CheckMoveAssignWriter(s, w);\n  const char *inline_buffer_ptr = w.data();\n  // Adding one more character causes the content to move from the inline to\n  // a dynamically allocated buffer.\n  w << '*';\n  MemoryWriter w2;\n  w2 = std::move(w);\n  // Move should rip the guts of the first writer.\n  EXPECT_EQ(inline_buffer_ptr, w.data());\n  EXPECT_EQ(s + '*', w2.str());\n}\n\n#endif  // FMT_USE_RVALUE_REFERENCES\n\nTEST(WriterTest, Allocator) {\n  typedef testing::StrictMock< MockAllocator<char> > MockAllocator;\n  typedef AllocatorRef<MockAllocator> TestAllocator;\n  MockAllocator alloc;\n  fmt::BasicMemoryWriter<char, TestAllocator> w((TestAllocator(&alloc)));\n  std::size_t size =\n      static_cast<std::size_t>(1.5 * fmt::internal::INLINE_BUFFER_SIZE);\n  std::vector<char> mem(size);\n  EXPECT_CALL(alloc, allocate(size, 0)).WillOnce(testing::Return(&mem[0]));\n  for (int i = 0; i < fmt::internal::INLINE_BUFFER_SIZE + 1; ++i)\n    w << '*';\n  EXPECT_CALL(alloc, deallocate(&mem[0], size));\n}\n\nTEST(WriterTest, Data) {\n  MemoryWriter w;\n  w << 42;\n  EXPECT_EQ(\"42\", std::string(w.data(), w.size()));\n}\n\nTEST(WriterTest, WriteWithoutArgs) {\n  MemoryWriter w;\n  w.write(\"test\");\n  EXPECT_EQ(\"test\", std::string(w.data(), w.size()));\n}\n\nTEST(WriterTest, WriteInt) {\n  CHECK_WRITE(42);\n  CHECK_WRITE(-42);\n  CHECK_WRITE(static_cast<short>(12));\n  CHECK_WRITE(34u);\n  CHECK_WRITE(std::numeric_limits<int>::min());\n  CHECK_WRITE(std::numeric_limits<int>::max());\n  CHECK_WRITE(std::numeric_limits<unsigned>::max());\n}\n\nTEST(WriterTest, WriteLong) {\n  CHECK_WRITE(56l);\n  CHECK_WRITE(78ul);\n  CHECK_WRITE(std::numeric_limits<long>::min());\n  CHECK_WRITE(std::numeric_limits<long>::max());\n  CHECK_WRITE(std::numeric_limits<unsigned long>::max());\n}\n\nTEST(WriterTest, WriteLongLong) {\n  CHECK_WRITE(56ll);\n  CHECK_WRITE(78ull);\n  CHECK_WRITE(std::numeric_limits<long long>::min());\n  CHECK_WRITE(std::numeric_limits<long long>::max());\n  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());\n}\n\nTEST(WriterTest, WriteDouble) {\n  CHECK_WRITE(4.2);\n  CHECK_WRITE(-4.2);\n  CHECK_WRITE(std::numeric_limits<double>::min());\n  CHECK_WRITE(std::numeric_limits<double>::max());\n}\n\nTEST(WriterTest, WriteLongDouble) {\n  CHECK_WRITE(4.2l);\n  CHECK_WRITE_CHAR(-4.2l);\n  std::wstring str;\n  std_format(4.2l, str);\n  if (str[0] != '-')\n    CHECK_WRITE_WCHAR(-4.2l);\n  else\n    fmt::print(\"warning: long double formatting with std::swprintf is broken\");\n  CHECK_WRITE(std::numeric_limits<long double>::min());\n  CHECK_WRITE(std::numeric_limits<long double>::max());\n}\n\nTEST(WriterTest, WriteDoubleAtBufferBoundary) {\n  MemoryWriter writer;\n  for (int i = 0; i < 100; ++i)\n    writer << 1.23456789;\n}\n\nTEST(WriterTest, WriteDoubleWithFilledBuffer) {\n  MemoryWriter writer;\n  // Fill the buffer.\n  for (int i = 0; i < fmt::internal::INLINE_BUFFER_SIZE; ++i)\n    writer << ' ';\n  writer << 1.2;\n  EXPECT_STREQ(\"1.2\", writer.c_str() + fmt::internal::INLINE_BUFFER_SIZE);\n}\n\nTEST(WriterTest, WriteChar) {\n  CHECK_WRITE('a');\n}\n\nTEST(WriterTest, WriteWideChar) {\n  CHECK_WRITE_WCHAR(L'a');\n}\n\nTEST(WriterTest, WriteString) {\n  CHECK_WRITE_CHAR(\"abc\");\n  CHECK_WRITE_WCHAR(\"abc\");\n  // The following line shouldn't compile:\n  //MemoryWriter() << L\"abc\";\n}\n\nTEST(WriterTest, WriteWideString) {\n  CHECK_WRITE_WCHAR(L\"abc\");\n  // The following line shouldn't compile:\n  //fmt::WMemoryWriter() << \"abc\";\n}\n\nTEST(WriterTest, bin) {\n  using fmt::bin;\n  EXPECT_EQ(\"1100101011111110\", (MemoryWriter() << bin(0xcafe)).str());\n  EXPECT_EQ(\"1011101010111110\", (MemoryWriter() << bin(0xbabeu)).str());\n  EXPECT_EQ(\"1101111010101101\", (MemoryWriter() << bin(0xdeadl)).str());\n  EXPECT_EQ(\"1011111011101111\", (MemoryWriter() << bin(0xbeeful)).str());\n  EXPECT_EQ(\"11001010111111101011101010111110\",\n            (MemoryWriter() << bin(0xcafebabell)).str());\n  EXPECT_EQ(\"11011110101011011011111011101111\",\n            (MemoryWriter() << bin(0xdeadbeefull)).str());\n}\n\nTEST(WriterTest, oct) {\n  using fmt::oct;\n  EXPECT_EQ(\"12\", (MemoryWriter() << oct(static_cast<short>(012))).str());\n  EXPECT_EQ(\"12\", (MemoryWriter() << oct(012)).str());\n  EXPECT_EQ(\"34\", (MemoryWriter() << oct(034u)).str());\n  EXPECT_EQ(\"56\", (MemoryWriter() << oct(056l)).str());\n  EXPECT_EQ(\"70\", (MemoryWriter() << oct(070ul)).str());\n  EXPECT_EQ(\"1234\", (MemoryWriter() << oct(01234ll)).str());\n  EXPECT_EQ(\"5670\", (MemoryWriter() << oct(05670ull)).str());\n}\n\nTEST(WriterTest, hex) {\n  using fmt::hex;\n  fmt::IntFormatSpec<int, fmt::TypeSpec<'x'> > (*phex)(int value) = hex;\n  phex(42);\n  // This shouldn't compile:\n  //fmt::IntFormatSpec<short, fmt::TypeSpec<'x'> > (*phex2)(short value) = hex;\n\n  EXPECT_EQ(\"cafe\", (MemoryWriter() << hex(0xcafe)).str());\n  EXPECT_EQ(\"babe\", (MemoryWriter() << hex(0xbabeu)).str());\n  EXPECT_EQ(\"dead\", (MemoryWriter() << hex(0xdeadl)).str());\n  EXPECT_EQ(\"beef\", (MemoryWriter() << hex(0xbeeful)).str());\n  EXPECT_EQ(\"cafebabe\", (MemoryWriter() << hex(0xcafebabell)).str());\n  EXPECT_EQ(\"deadbeef\", (MemoryWriter() << hex(0xdeadbeefull)).str());\n}\n\nTEST(WriterTest, hexu) {\n  using fmt::hexu;\n  EXPECT_EQ(\"CAFE\", (MemoryWriter() << hexu(0xcafe)).str());\n  EXPECT_EQ(\"BABE\", (MemoryWriter() << hexu(0xbabeu)).str());\n  EXPECT_EQ(\"DEAD\", (MemoryWriter() << hexu(0xdeadl)).str());\n  EXPECT_EQ(\"BEEF\", (MemoryWriter() << hexu(0xbeeful)).str());\n  EXPECT_EQ(\"CAFEBABE\", (MemoryWriter() << hexu(0xcafebabell)).str());\n  EXPECT_EQ(\"DEADBEEF\", (MemoryWriter() << hexu(0xdeadbeefull)).str());\n}\n\ntemplate <typename Char>\nBasicWriter<Char> &operator<<(BasicWriter<Char> &f, const Date &d) {\n  return f << d.year() << '-' << d.month() << '-' << d.day();\n}\n\nclass ISO8601DateFormatter {\n const Date *date_;\n\npublic:\n  ISO8601DateFormatter(const Date &d) : date_(&d) {}\n\n  template <typename Char>\n  friend BasicWriter<Char> &operator<<(\n      BasicWriter<Char> &w, const ISO8601DateFormatter &d) {\n    return w << pad(d.date_->year(), 4, '0') << '-'\n        << pad(d.date_->month(), 2, '0') << '-' << pad(d.date_->day(), 2, '0');\n  }\n};\n\nISO8601DateFormatter iso8601(const Date &d) { return ISO8601DateFormatter(d); }\n\nTEST(WriterTest, pad) {\n  using fmt::hex;\n  EXPECT_EQ(\"    cafe\", (MemoryWriter() << pad(hex(0xcafe), 8)).str());\n  EXPECT_EQ(\"    babe\", (MemoryWriter() << pad(hex(0xbabeu), 8)).str());\n  EXPECT_EQ(\"    dead\", (MemoryWriter() << pad(hex(0xdeadl), 8)).str());\n  EXPECT_EQ(\"    beef\", (MemoryWriter() << pad(hex(0xbeeful), 8)).str());\n  EXPECT_EQ(\"    dead\", (MemoryWriter() << pad(hex(0xdeadll), 8)).str());\n  EXPECT_EQ(\"    beef\", (MemoryWriter() << pad(hex(0xbeefull), 8)).str());\n\n  EXPECT_EQ(\"     11\", (MemoryWriter() << pad(11, 7)).str());\n  EXPECT_EQ(\"     22\", (MemoryWriter() << pad(22u, 7)).str());\n  EXPECT_EQ(\"     33\", (MemoryWriter() << pad(33l, 7)).str());\n  EXPECT_EQ(\"     44\", (MemoryWriter() << pad(44ul, 7)).str());\n  EXPECT_EQ(\"     33\", (MemoryWriter() << pad(33ll, 7)).str());\n  EXPECT_EQ(\"     44\", (MemoryWriter() << pad(44ull, 7)).str());\n\n  MemoryWriter w;\n  w.clear();\n  w << pad(42, 5, '0');\n  EXPECT_EQ(\"00042\", w.str());\n  w.clear();\n  w << Date(2012, 12, 9);\n  EXPECT_EQ(\"2012-12-9\", w.str());\n  w.clear();\n  w << iso8601(Date(2012, 1, 9));\n  EXPECT_EQ(\"2012-01-09\", w.str());\n}\n\nTEST(WriterTest, PadString) {\n  EXPECT_EQ(\"test    \", (MemoryWriter() << pad(\"test\", 8)).str());\n  EXPECT_EQ(\"test******\", (MemoryWriter() << pad(\"test\", 10, '*')).str());\n}\n\nTEST(WriterTest, PadWString) {\n  EXPECT_EQ(L\"test    \", (WMemoryWriter() << pad(L\"test\", 8)).str());\n  EXPECT_EQ(L\"test******\", (WMemoryWriter() << pad(L\"test\", 10, '*')).str());\n  EXPECT_EQ(L\"test******\", (WMemoryWriter() << pad(L\"test\", 10, L'*')).str());\n}\n\nTEST(WriterTest, NoConflictWithIOManip) {\n  using namespace std;\n  using namespace fmt;\n  EXPECT_EQ(\"cafe\", (MemoryWriter() << hex(0xcafe)).str());\n  EXPECT_EQ(\"12\", (MemoryWriter() << oct(012)).str());\n}\n\nTEST(WriterTest, Format) {\n  MemoryWriter w;\n  w.write(\"part{0}\", 1);\n  EXPECT_EQ(strlen(\"part1\"), w.size());\n  EXPECT_STREQ(\"part1\", w.c_str());\n  EXPECT_STREQ(\"part1\", w.data());\n  EXPECT_EQ(\"part1\", w.str());\n  w.write(\"part{0}\", 2);\n  EXPECT_EQ(strlen(\"part1part2\"), w.size());\n  EXPECT_STREQ(\"part1part2\", w.c_str());\n  EXPECT_STREQ(\"part1part2\", w.data());\n  EXPECT_EQ(\"part1part2\", w.str());\n}\n\nTEST(WriterTest, WWriter) {\n  EXPECT_EQ(L\"cafe\", (fmt::WMemoryWriter() << fmt::hex(0xcafe)).str());\n}\n\nTEST(ArrayWriterTest, Ctor) {\n  char array[10] = \"garbage\";\n  fmt::ArrayWriter w(array, sizeof(array));\n  EXPECT_EQ(0u, w.size());\n  EXPECT_STREQ(\"\", w.c_str());\n}\n\nTEST(ArrayWriterTest, CompileTimeSizeCtor) {\n  char array[10] = \"garbage\";\n  fmt::ArrayWriter w(array);\n  EXPECT_EQ(0u, w.size());\n  EXPECT_STREQ(\"\", w.c_str());\n  w.write(\"{:10}\", 1);\n}\n\nTEST(ArrayWriterTest, Write) {\n  char array[10];\n  fmt::ArrayWriter w(array, sizeof(array));\n  w.write(\"{}\", 42);\n  EXPECT_EQ(\"42\", w.str());\n}\n\nTEST(ArrayWriterTest, BufferOverflow) {\n  char array[10];\n  fmt::ArrayWriter w(array, sizeof(array));\n  w.write(\"{:10}\", 1);\n  EXPECT_THROW_MSG(w.write(\"{}\", 1), std::runtime_error, \"buffer overflow\");\n}\n\nTEST(ArrayWriterTest, WChar) {\n  wchar_t array[10];\n  fmt::WArrayWriter w(array);\n  w.write(L\"{}\", 42);\n  EXPECT_EQ(L\"42\", w.str());\n}\n\nTEST(FormatterTest, Escape) {\n  EXPECT_EQ(\"{\", format(\"{{\"));\n  EXPECT_EQ(\"before {\", format(\"before {{\"));\n  EXPECT_EQ(\"{ after\", format(\"{{ after\"));\n  EXPECT_EQ(\"before { after\", format(\"before {{ after\"));\n\n  EXPECT_EQ(\"}\", format(\"}}\"));\n  EXPECT_EQ(\"before }\", format(\"before }}\"));\n  EXPECT_EQ(\"} after\", format(\"}} after\"));\n  EXPECT_EQ(\"before } after\", format(\"before }} after\"));\n\n  EXPECT_EQ(\"{}\", format(\"{{}}\"));\n  EXPECT_EQ(\"{42}\", format(\"{{{0}}}\", 42));\n}\n\nTEST(FormatterTest, UnmatchedBraces) {\n  EXPECT_THROW_MSG(format(\"{\"), FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"}\"), FormatError, \"unmatched '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0{}\"), FormatError, \"invalid format string\");\n}\n\nTEST(FormatterTest, NoArgs) {\n  EXPECT_EQ(\"test\", format(\"test\"));\n}\n\nTEST(FormatterTest, ArgsInDifferentPositions) {\n  EXPECT_EQ(\"42\", format(\"{0}\", 42));\n  EXPECT_EQ(\"before 42\", format(\"before {0}\", 42));\n  EXPECT_EQ(\"42 after\", format(\"{0} after\", 42));\n  EXPECT_EQ(\"before 42 after\", format(\"before {0} after\", 42));\n  EXPECT_EQ(\"answer = 42\", format(\"{0} = {1}\", \"answer\", 42));\n  EXPECT_EQ(\"42 is the answer\", format(\"{1} is the {0}\", \"answer\", 42));\n  EXPECT_EQ(\"abracadabra\", format(\"{0}{1}{0}\", \"abra\", \"cad\"));\n}\n\nTEST(FormatterTest, ArgErrors) {\n  EXPECT_THROW_MSG(format(\"{\"), FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{?}\"), FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0\"), FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0}\"), FormatError, \"argument index out of range\");\n\n  char format_str[BUFFER_SIZE];\n  safe_sprintf(format_str, \"{%u\", INT_MAX);\n  EXPECT_THROW_MSG(format(format_str), FormatError, \"invalid format string\");\n  safe_sprintf(format_str, \"{%u}\", INT_MAX);\n  EXPECT_THROW_MSG(format(format_str), FormatError,\n      \"argument index out of range\");\n\n  safe_sprintf(format_str, \"{%u\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str), FormatError, \"number is too big\");\n  safe_sprintf(format_str, \"{%u}\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str), FormatError, \"number is too big\");\n}\n\n#if FMT_USE_VARIADIC_TEMPLATES\ntemplate <int N>\nstruct TestFormat {\n  template <typename... Args>\n  static std::string format(fmt::CStringRef format_str, const Args & ... args) {\n    return TestFormat<N - 1>::format(format_str, N - 1, args...);\n  }\n};\n\ntemplate <>\nstruct TestFormat<0> {\n  template <typename... Args>\n  static std::string format(fmt::CStringRef format_str, const Args & ... args) {\n    return fmt::format(format_str, args...);\n  }\n};\n\nTEST(FormatterTest, ManyArgs) {\n  EXPECT_EQ(\"19\", TestFormat<20>::format(\"{19}\"));\n  EXPECT_THROW_MSG(TestFormat<20>::format(\"{20}\"),\n                   FormatError, \"argument index out of range\");\n  EXPECT_THROW_MSG(TestFormat<21>::format(\"{21}\"),\n                   FormatError, \"argument index out of range\");\n  enum { MAX_PACKED_ARGS = fmt::ArgList::MAX_PACKED_ARGS };\n  std::string format_str = fmt::format(\"{{{}}}\", MAX_PACKED_ARGS + 1);\n  EXPECT_THROW_MSG(TestFormat<MAX_PACKED_ARGS>::format(format_str),\n                   FormatError, \"argument index out of range\");\n}\n#endif\n\nTEST(FormatterTest, NamedArg) {\n  EXPECT_EQ(\"1/a/A\", format(\"{_1}/{a_}/{A_}\", fmt::arg(\"a_\", 'a'),\n                            fmt::arg(\"A_\", \"A\"), fmt::arg(\"_1\", 1)));\n  char a = 'A', b = 'B', c = 'C';\n  EXPECT_EQ(\"BB/AA/CC\", format(\"{1}{b}/{0}{a}/{2}{c}\", FMT_CAPTURE(a, b, c)));\n  EXPECT_EQ(\" A\", format(\"{a:>2}\", FMT_CAPTURE(a)));\n  EXPECT_THROW_MSG(format(\"{a+}\", FMT_CAPTURE(a)), FormatError,\n                   \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{a}\"), FormatError, \"argument not found\");\n  EXPECT_THROW_MSG(format(\"{d}\", FMT_CAPTURE(a, b, c)), FormatError,\n                   \"argument not found\");\n  EXPECT_THROW_MSG(format(\"{a}{}\", FMT_CAPTURE(a)),\n    FormatError, \"cannot switch from manual to automatic argument indexing\");\n  EXPECT_THROW_MSG(format(\"{}{a}\", FMT_CAPTURE(a)),\n    FormatError, \"cannot switch from automatic to manual argument indexing\");\n  EXPECT_EQ(\" -42\", format(\"{0:{width}}\", -42, fmt::arg(\"width\", 4)));\n  EXPECT_EQ(\"st\", format(\"{0:.{precision}}\", \"str\", fmt::arg(\"precision\", 2)));\n  int n = 100;\n  EXPECT_EQ(L\"n=100\", format(L\"n={n}\", FMT_CAPTURE_W(n)));\n}\n\nTEST(FormatterTest, AutoArgIndex) {\n  EXPECT_EQ(\"abc\", format(\"{}{}{}\", 'a', 'b', 'c'));\n  EXPECT_THROW_MSG(format(\"{0}{}\", 'a', 'b'),\n      FormatError, \"cannot switch from manual to automatic argument indexing\");\n  EXPECT_THROW_MSG(format(\"{}{0}\", 'a', 'b'),\n      FormatError, \"cannot switch from automatic to manual argument indexing\");\n  EXPECT_EQ(\"1.2\", format(\"{:.{}}\", 1.2345, 2));\n  EXPECT_THROW_MSG(format(\"{0}:.{}\", 1.2345, 2),\n      FormatError, \"cannot switch from manual to automatic argument indexing\");\n  EXPECT_THROW_MSG(format(\"{:.{0}}\", 1.2345, 2),\n      FormatError, \"cannot switch from automatic to manual argument indexing\");\n  EXPECT_THROW_MSG(format(\"{}\"), FormatError, \"argument index out of range\");\n}\n\nTEST(FormatterTest, EmptySpecs) {\n  EXPECT_EQ(\"42\", format(\"{0:}\", 42));\n}\n\nTEST(FormatterTest, LeftAlign) {\n  EXPECT_EQ(\"42  \", format(\"{0:<4}\", 42));\n  EXPECT_EQ(\"42  \", format(\"{0:<4o}\", 042));\n  EXPECT_EQ(\"42  \", format(\"{0:<4x}\", 0x42));\n  EXPECT_EQ(\"-42  \", format(\"{0:<5}\", -42));\n  EXPECT_EQ(\"42   \", format(\"{0:<5}\", 42u));\n  EXPECT_EQ(\"-42  \", format(\"{0:<5}\", -42l));\n  EXPECT_EQ(\"42   \", format(\"{0:<5}\", 42ul));\n  EXPECT_EQ(\"-42  \", format(\"{0:<5}\", -42ll));\n  EXPECT_EQ(\"42   \", format(\"{0:<5}\", 42ull));\n  EXPECT_EQ(\"-42  \", format(\"{0:<5}\", -42.0));\n  EXPECT_EQ(\"-42  \", format(\"{0:<5}\", -42.0l));\n  EXPECT_EQ(\"c    \", format(\"{0:<5}\", 'c'));\n  EXPECT_EQ(\"abc  \", format(\"{0:<5}\", \"abc\"));\n  EXPECT_EQ(\"0xface  \", format(\"{0:<8}\", reinterpret_cast<void*>(0xface)));\n}\n\nTEST(FormatterTest, RightAlign) {\n  EXPECT_EQ(\"  42\", format(\"{0:>4}\", 42));\n  EXPECT_EQ(\"  42\", format(\"{0:>4o}\", 042));\n  EXPECT_EQ(\"  42\", format(\"{0:>4x}\", 0x42));\n  EXPECT_EQ(\"  -42\", format(\"{0:>5}\", -42));\n  EXPECT_EQ(\"   42\", format(\"{0:>5}\", 42u));\n  EXPECT_EQ(\"  -42\", format(\"{0:>5}\", -42l));\n  EXPECT_EQ(\"   42\", format(\"{0:>5}\", 42ul));\n  EXPECT_EQ(\"  -42\", format(\"{0:>5}\", -42ll));\n  EXPECT_EQ(\"   42\", format(\"{0:>5}\", 42ull));\n  EXPECT_EQ(\"  -42\", format(\"{0:>5}\", -42.0));\n  EXPECT_EQ(\"  -42\", format(\"{0:>5}\", -42.0l));\n  EXPECT_EQ(\"    c\", format(\"{0:>5}\", 'c'));\n  EXPECT_EQ(\"  abc\", format(\"{0:>5}\", \"abc\"));\n  EXPECT_EQ(\"  0xface\", format(\"{0:>8}\", reinterpret_cast<void*>(0xface)));\n}\n\nTEST(FormatterTest, NumericAlign) {\n  EXPECT_EQ(\"  42\", format(\"{0:=4}\", 42));\n  EXPECT_EQ(\"+ 42\", format(\"{0:=+4}\", 42));\n  EXPECT_EQ(\"  42\", format(\"{0:=4o}\", 042));\n  EXPECT_EQ(\"+ 42\", format(\"{0:=+4o}\", 042));\n  EXPECT_EQ(\"  42\", format(\"{0:=4x}\", 0x42));\n  EXPECT_EQ(\"+ 42\", format(\"{0:=+4x}\", 0x42));\n  EXPECT_EQ(\"-  42\", format(\"{0:=5}\", -42));\n  EXPECT_EQ(\"   42\", format(\"{0:=5}\", 42u));\n  EXPECT_EQ(\"-  42\", format(\"{0:=5}\", -42l));\n  EXPECT_EQ(\"   42\", format(\"{0:=5}\", 42ul));\n  EXPECT_EQ(\"-  42\", format(\"{0:=5}\", -42ll));\n  EXPECT_EQ(\"   42\", format(\"{0:=5}\", 42ull));\n  EXPECT_EQ(\"-  42\", format(\"{0:=5}\", -42.0));\n  EXPECT_EQ(\"-  42\", format(\"{0:=5}\", -42.0l));\n  EXPECT_THROW_MSG(format(\"{0:=5\", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0:=5}\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0:=5}\", \"abc\"),\n      FormatError, \"format specifier '=' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0:=8}\", reinterpret_cast<void*>(0xface)),\n      FormatError, \"format specifier '=' requires numeric argument\");\n}\n\nTEST(FormatterTest, CenterAlign) {\n  EXPECT_EQ(\" 42  \", format(\"{0:^5}\", 42));\n  EXPECT_EQ(\" 42  \", format(\"{0:^5o}\", 042));\n  EXPECT_EQ(\" 42  \", format(\"{0:^5x}\", 0x42));\n  EXPECT_EQ(\" -42 \", format(\"{0:^5}\", -42));\n  EXPECT_EQ(\" 42  \", format(\"{0:^5}\", 42u));\n  EXPECT_EQ(\" -42 \", format(\"{0:^5}\", -42l));\n  EXPECT_EQ(\" 42  \", format(\"{0:^5}\", 42ul));\n  EXPECT_EQ(\" -42 \", format(\"{0:^5}\", -42ll));\n  EXPECT_EQ(\" 42  \", format(\"{0:^5}\", 42ull));\n  EXPECT_EQ(\" -42  \", format(\"{0:^6}\", -42.0));\n  EXPECT_EQ(\" -42 \", format(\"{0:^5}\", -42.0l));\n  EXPECT_EQ(\"  c  \", format(\"{0:^5}\", 'c'));\n  EXPECT_EQ(\" abc  \", format(\"{0:^6}\", \"abc\"));\n  EXPECT_EQ(\" 0xface \", format(\"{0:^8}\", reinterpret_cast<void*>(0xface)));\n}\n\nTEST(FormatterTest, Fill) {\n  EXPECT_THROW_MSG(format(\"{0:{<5}\", 'c'),\n      FormatError, \"invalid fill character '{'\");\n  EXPECT_THROW_MSG(format(\"{0:{<5}}\", 'c'),\n      FormatError, \"invalid fill character '{'\");\n  EXPECT_EQ(\"**42\", format(\"{0:*>4}\", 42));\n  EXPECT_EQ(\"**-42\", format(\"{0:*>5}\", -42));\n  EXPECT_EQ(\"***42\", format(\"{0:*>5}\", 42u));\n  EXPECT_EQ(\"**-42\", format(\"{0:*>5}\", -42l));\n  EXPECT_EQ(\"***42\", format(\"{0:*>5}\", 42ul));\n  EXPECT_EQ(\"**-42\", format(\"{0:*>5}\", -42ll));\n  EXPECT_EQ(\"***42\", format(\"{0:*>5}\", 42ull));\n  EXPECT_EQ(\"**-42\", format(\"{0:*>5}\", -42.0));\n  EXPECT_EQ(\"**-42\", format(\"{0:*>5}\", -42.0l));\n  EXPECT_EQ(\"c****\", format(\"{0:*<5}\", 'c'));\n  EXPECT_EQ(\"abc**\", format(\"{0:*<5}\", \"abc\"));\n  EXPECT_EQ(\"**0xface\", format(\"{0:*>8}\", reinterpret_cast<void*>(0xface)));\n}\n\nTEST(FormatterTest, PlusSign) {\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42));\n  EXPECT_EQ(\"-42\", format(\"{0:+}\", -42));\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42));\n  EXPECT_THROW_MSG(format(\"{0:+}\", 42u),\n      FormatError, \"format specifier '+' requires signed argument\");\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42l));\n  EXPECT_THROW_MSG(format(\"{0:+}\", 42ul),\n      FormatError, \"format specifier '+' requires signed argument\");\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42ll));\n  EXPECT_THROW_MSG(format(\"{0:+}\", 42ull),\n      FormatError, \"format specifier '+' requires signed argument\");\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42.0));\n  EXPECT_EQ(\"+42\", format(\"{0:+}\", 42.0l));\n  EXPECT_THROW_MSG(format(\"{0:+\", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0:+}\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0:+}\", \"abc\"),\n      FormatError, \"format specifier '+' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0:+}\", reinterpret_cast<void*>(0x42)),\n      FormatError, \"format specifier '+' requires numeric argument\");\n}\n\nTEST(FormatterTest, MinusSign) {\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42));\n  EXPECT_EQ(\"-42\", format(\"{0:-}\", -42));\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42));\n  EXPECT_THROW_MSG(format(\"{0:-}\", 42u),\n      FormatError, \"format specifier '-' requires signed argument\");\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42l));\n  EXPECT_THROW_MSG(format(\"{0:-}\", 42ul),\n      FormatError, \"format specifier '-' requires signed argument\");\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42ll));\n  EXPECT_THROW_MSG(format(\"{0:-}\", 42ull),\n      FormatError, \"format specifier '-' requires signed argument\");\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42.0));\n  EXPECT_EQ(\"42\", format(\"{0:-}\", 42.0l));\n  EXPECT_THROW_MSG(format(\"{0:-\", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0:-}\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0:-}\", \"abc\"),\n      FormatError, \"format specifier '-' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0:-}\", reinterpret_cast<void*>(0x42)),\n      FormatError, \"format specifier '-' requires numeric argument\");\n}\n\nTEST(FormatterTest, SpaceSign) {\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42));\n  EXPECT_EQ(\"-42\", format(\"{0: }\", -42));\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42));\n  EXPECT_THROW_MSG(format(\"{0: }\", 42u),\n      FormatError, \"format specifier ' ' requires signed argument\");\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42l));\n  EXPECT_THROW_MSG(format(\"{0: }\", 42ul),\n      FormatError, \"format specifier ' ' requires signed argument\");\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42ll));\n  EXPECT_THROW_MSG(format(\"{0: }\", 42ull),\n      FormatError, \"format specifier ' ' requires signed argument\");\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42.0));\n  EXPECT_EQ(\" 42\", format(\"{0: }\", 42.0l));\n  EXPECT_THROW_MSG(format(\"{0: \", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0: }\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0: }\", \"abc\"),\n      FormatError, \"format specifier ' ' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0: }\", reinterpret_cast<void*>(0x42)),\n      FormatError, \"format specifier ' ' requires numeric argument\");\n}\n\nTEST(FormatterTest, HashFlag) {\n  EXPECT_EQ(\"42\", format(\"{0:#}\", 42));\n  EXPECT_EQ(\"-42\", format(\"{0:#}\", -42));\n  EXPECT_EQ(\"0b101010\", format(\"{0:#b}\", 42));\n  EXPECT_EQ(\"0B101010\", format(\"{0:#B}\", 42));\n  EXPECT_EQ(\"-0b101010\", format(\"{0:#b}\", -42));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42));\n  EXPECT_EQ(\"0X42\", format(\"{0:#X}\", 0x42));\n  EXPECT_EQ(\"-0x42\", format(\"{0:#x}\", -0x42));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042));\n  EXPECT_EQ(\"-042\", format(\"{0:#o}\", -042));\n  EXPECT_EQ(\"42\", format(\"{0:#}\", 42u));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42u));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042u));\n\n  EXPECT_EQ(\"-42\", format(\"{0:#}\", -42l));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42l));\n  EXPECT_EQ(\"-0x42\", format(\"{0:#x}\", -0x42l));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042l));\n  EXPECT_EQ(\"-042\", format(\"{0:#o}\", -042l));\n  EXPECT_EQ(\"42\", format(\"{0:#}\", 42ul));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42ul));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042ul));\n\n  EXPECT_EQ(\"-42\", format(\"{0:#}\", -42ll));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42ll));\n  EXPECT_EQ(\"-0x42\", format(\"{0:#x}\", -0x42ll));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042ll));\n  EXPECT_EQ(\"-042\", format(\"{0:#o}\", -042ll));\n  EXPECT_EQ(\"42\", format(\"{0:#}\", 42ull));\n  EXPECT_EQ(\"0x42\", format(\"{0:#x}\", 0x42ull));\n  EXPECT_EQ(\"042\", format(\"{0:#o}\", 042ull));\n\n  EXPECT_EQ(\"-42.0000\", format(\"{0:#}\", -42.0));\n  EXPECT_EQ(\"-42.0000\", format(\"{0:#}\", -42.0l));\n  EXPECT_THROW_MSG(format(\"{0:#\", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0:#}\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0:#}\", \"abc\"),\n      FormatError, \"format specifier '#' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0:#}\", reinterpret_cast<void*>(0x42)),\n      FormatError, \"format specifier '#' requires numeric argument\");\n}\n\nTEST(FormatterTest, ZeroFlag) {\n  EXPECT_EQ(\"42\", format(\"{0:0}\", 42));\n  EXPECT_EQ(\"-0042\", format(\"{0:05}\", -42));\n  EXPECT_EQ(\"00042\", format(\"{0:05}\", 42u));\n  EXPECT_EQ(\"-0042\", format(\"{0:05}\", -42l));\n  EXPECT_EQ(\"00042\", format(\"{0:05}\", 42ul));\n  EXPECT_EQ(\"-0042\", format(\"{0:05}\", -42ll));\n  EXPECT_EQ(\"00042\", format(\"{0:05}\", 42ull));\n  EXPECT_EQ(\"-0042\", format(\"{0:05}\", -42.0));\n  EXPECT_EQ(\"-0042\", format(\"{0:05}\", -42.0l));\n  EXPECT_THROW_MSG(format(\"{0:0\", 'c'),\n      FormatError, \"missing '}' in format string\");\n  EXPECT_THROW_MSG(format(\"{0:05}\", 'c'),\n      FormatError, \"invalid format specifier for char\");\n  EXPECT_THROW_MSG(format(\"{0:05}\", \"abc\"),\n      FormatError, \"format specifier '0' requires numeric argument\");\n  EXPECT_THROW_MSG(format(\"{0:05}\", reinterpret_cast<void*>(0x42)),\n      FormatError, \"format specifier '0' requires numeric argument\");\n}\n\nTEST(FormatterTest, Width) {\n  char format_str[BUFFER_SIZE];\n  safe_sprintf(format_str, \"{0:%u\", UINT_MAX);\n  increment(format_str + 3);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  std::size_t size = std::strlen(format_str);\n  format_str[size] = '}';\n  format_str[size + 1] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n\n  safe_sprintf(format_str, \"{0:%u\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  safe_sprintf(format_str, \"{0:%u}\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  EXPECT_EQ(\" -42\", format(\"{0:4}\", -42));\n  EXPECT_EQ(\"   42\", format(\"{0:5}\", 42u));\n  EXPECT_EQ(\"   -42\", format(\"{0:6}\", -42l));\n  EXPECT_EQ(\"     42\", format(\"{0:7}\", 42ul));\n  EXPECT_EQ(\"   -42\", format(\"{0:6}\", -42ll));\n  EXPECT_EQ(\"     42\", format(\"{0:7}\", 42ull));\n  EXPECT_EQ(\"   -1.23\", format(\"{0:8}\", -1.23));\n  EXPECT_EQ(\"    -1.23\", format(\"{0:9}\", -1.23l));\n  EXPECT_EQ(\"    0xcafe\", format(\"{0:10}\", reinterpret_cast<void*>(0xcafe)));\n  EXPECT_EQ(\"x          \", format(\"{0:11}\", 'x'));\n  EXPECT_EQ(\"str         \", format(\"{0:12}\", \"str\"));\n}\n\nTEST(FormatterTest, RuntimeWidth) {\n  char format_str[BUFFER_SIZE];\n  safe_sprintf(format_str, \"{0:{%u\", UINT_MAX);\n  increment(format_str + 4);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  std::size_t size = std::strlen(format_str);\n  format_str[size] = '}';\n  format_str[size + 1] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  format_str[size + 1] = '}';\n  format_str[size + 2] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n\n  EXPECT_THROW_MSG(format(\"{0:{\", 0),\n      FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0:{}\", 0),\n      FormatError, \"cannot switch from manual to automatic argument indexing\");\n  EXPECT_THROW_MSG(format(\"{0:{?}}\", 0),\n      FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0),\n      FormatError, \"argument index out of range\");\n\n  EXPECT_THROW_MSG(format(\"{0:{0:}}\", 0),\n      FormatError, \"invalid format string\");\n\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, -1),\n      FormatError, \"negative width\");\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, (INT_MAX + 1u)),\n      FormatError, \"number is too big\");\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, -1l),\n      FormatError, \"negative width\");\n  if (fmt::internal::const_check(sizeof(long) > sizeof(int))) {\n    long value = INT_MAX;\n    EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, (value + 1)),\n        FormatError, \"number is too big\");\n  }\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, (INT_MAX + 1ul)),\n      FormatError, \"number is too big\");\n\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, '0'),\n      FormatError, \"width is not integer\");\n  EXPECT_THROW_MSG(format(\"{0:{1}}\", 0, 0.0),\n      FormatError, \"width is not integer\");\n\n  EXPECT_EQ(\" -42\", format(\"{0:{1}}\", -42, 4));\n  EXPECT_EQ(\"   42\", format(\"{0:{1}}\", 42u, 5));\n  EXPECT_EQ(\"   -42\", format(\"{0:{1}}\", -42l, 6));\n  EXPECT_EQ(\"     42\", format(\"{0:{1}}\", 42ul, 7));\n  EXPECT_EQ(\"   -42\", format(\"{0:{1}}\", -42ll, 6));\n  EXPECT_EQ(\"     42\", format(\"{0:{1}}\", 42ull, 7));\n  EXPECT_EQ(\"   -1.23\", format(\"{0:{1}}\", -1.23, 8));\n  EXPECT_EQ(\"    -1.23\", format(\"{0:{1}}\", -1.23l, 9));\n  EXPECT_EQ(\"    0xcafe\",\n            format(\"{0:{1}}\", reinterpret_cast<void*>(0xcafe), 10));\n  EXPECT_EQ(\"x          \", format(\"{0:{1}}\", 'x', 11));\n  EXPECT_EQ(\"str         \", format(\"{0:{1}}\", \"str\", 12));\n}\n\nTEST(FormatterTest, Precision) {\n  char format_str[BUFFER_SIZE];\n  safe_sprintf(format_str, \"{0:.%u\", UINT_MAX);\n  increment(format_str + 4);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  std::size_t size = std::strlen(format_str);\n  format_str[size] = '}';\n  format_str[size + 1] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n\n  safe_sprintf(format_str, \"{0:.%u\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  safe_sprintf(format_str, \"{0:.%u}\", INT_MAX + 1u);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n\n  EXPECT_THROW_MSG(format(\"{0:.\", 0),\n      FormatError, \"missing precision specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.}\", 0),\n      FormatError, \"missing precision specifier\");\n\n  EXPECT_THROW_MSG(format(\"{0:.2\", 0),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42u),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42u),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42l),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42l),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42ul),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42ul),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42ll),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42ll),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2}\", 42ull),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", 42ull),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:3.0}\", 'x'),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_EQ(\"1.2\", format(\"{0:.2}\", 1.2345));\n  EXPECT_EQ(\"1.2\", format(\"{0:.2}\", 1.2345l));\n\n  EXPECT_THROW_MSG(format(\"{0:.2}\", reinterpret_cast<void*>(0xcafe)),\n      FormatError, \"precision not allowed in pointer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.2f}\", reinterpret_cast<void*>(0xcafe)),\n      FormatError, \"precision not allowed in pointer format specifier\");\n\n  EXPECT_EQ(\"st\", format(\"{0:.2}\", \"str\"));\n}\n\nTEST(FormatterTest, RuntimePrecision) {\n  char format_str[BUFFER_SIZE];\n  safe_sprintf(format_str, \"{0:.{%u\", UINT_MAX);\n  increment(format_str + 5);\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  std::size_t size = std::strlen(format_str);\n  format_str[size] = '}';\n  format_str[size + 1] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n  format_str[size + 1] = '}';\n  format_str[size + 2] = 0;\n  EXPECT_THROW_MSG(format(format_str, 0), FormatError, \"number is too big\");\n\n  EXPECT_THROW_MSG(format(\"{0:.{\", 0),\n      FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0:.{}\", 0),\n      FormatError, \"cannot switch from manual to automatic argument indexing\");\n  EXPECT_THROW_MSG(format(\"{0:.{?}}\", 0),\n      FormatError, \"invalid format string\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}\", 0, 0),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0),\n      FormatError, \"argument index out of range\");\n\n  EXPECT_THROW_MSG(format(\"{0:.{0:}}\", 0),\n      FormatError, \"invalid format string\");\n\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, -1),\n      FormatError, \"negative precision\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, (INT_MAX + 1u)),\n      FormatError, \"number is too big\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, -1l),\n      FormatError, \"negative precision\");\n  if (fmt::internal::const_check(sizeof(long) > sizeof(int))) {\n    long value = INT_MAX;\n    EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, (value + 1)),\n        FormatError, \"number is too big\");\n  }\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, (INT_MAX + 1ul)),\n      FormatError, \"number is too big\");\n\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, '0'),\n      FormatError, \"precision is not integer\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 0, 0.0),\n      FormatError, \"precision is not integer\");\n\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42u, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42u, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42l, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42l, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42ul, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42ul, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42ll, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42ll, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", 42ull, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", 42ull, 2),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:3.{1}}\", 'x', 0),\n      FormatError, \"precision not allowed in integer format specifier\");\n  EXPECT_EQ(\"1.2\", format(\"{0:.{1}}\", 1.2345, 2));\n  EXPECT_EQ(\"1.2\", format(\"{1:.{0}}\", 2, 1.2345l));\n\n  EXPECT_THROW_MSG(format(\"{0:.{1}}\", reinterpret_cast<void*>(0xcafe), 2),\n      FormatError, \"precision not allowed in pointer format specifier\");\n  EXPECT_THROW_MSG(format(\"{0:.{1}f}\", reinterpret_cast<void*>(0xcafe), 2),\n      FormatError, \"precision not allowed in pointer format specifier\");\n\n  EXPECT_EQ(\"st\", format(\"{0:.{1}}\", \"str\", 2));\n}\n\ntemplate <typename T>\nvoid check_unknown_types(\n    const T &value, const char *types, const char *type_name) {\n  char format_str[BUFFER_SIZE], message[BUFFER_SIZE];\n  const char *special = \".0123456789}\";\n  for (int i = CHAR_MIN; i <= CHAR_MAX; ++i) {\n    char c = static_cast<char>(i);\n    if (std::strchr(types, c) || std::strchr(special, c) || !c) continue;\n    safe_sprintf(format_str, \"{0:10%c}\", c);\n    if (std::isprint(static_cast<unsigned char>(c))) {\n      safe_sprintf(message, \"unknown format code '%c' for %s\", c, type_name);\n    } else {\n      safe_sprintf(message, \"unknown format code '\\\\x%02x' for %s\", c,\n                   type_name);\n    }\n    EXPECT_THROW_MSG(format(format_str, value), FormatError, message)\n      << format_str << \" \" << message;\n  }\n}\n\nTEST(BoolTest, FormatBool) {\n  EXPECT_EQ(\"true\", format(\"{}\", true));\n  EXPECT_EQ(\"false\", format(\"{}\", false));\n  EXPECT_EQ(\"1\", format(\"{:d}\", true));\n  EXPECT_EQ(\"true \", format(\"{:5}\", true));\n  EXPECT_EQ(L\"true\", format(L\"{}\", true));\n}\n\nTEST(FormatterTest, FormatShort) {\n  short s = 42;\n  EXPECT_EQ(\"42\", format(\"{0:d}\", s));\n  unsigned short us = 42;\n  EXPECT_EQ(\"42\", format(\"{0:d}\", us));\n}\n\nTEST(FormatterTest, FormatInt) {\n  EXPECT_THROW_MSG(format(\"{0:v\", 42),\n      FormatError, \"missing '}' in format string\");\n  check_unknown_types(42, \"bBdoxXn\", \"integer\");\n}\n\nTEST(FormatterTest, FormatBin) {\n  EXPECT_EQ(\"0\", format(\"{0:b}\", 0));\n  EXPECT_EQ(\"101010\", format(\"{0:b}\", 42));\n  EXPECT_EQ(\"101010\", format(\"{0:b}\", 42u));\n  EXPECT_EQ(\"-101010\", format(\"{0:b}\", -42));\n  EXPECT_EQ(\"11000000111001\", format(\"{0:b}\", 12345));\n  EXPECT_EQ(\"10010001101000101011001111000\", format(\"{0:b}\", 0x12345678));\n  EXPECT_EQ(\"10010000101010111100110111101111\", format(\"{0:b}\", 0x90ABCDEF));\n  EXPECT_EQ(\"11111111111111111111111111111111\",\n            format(\"{0:b}\", std::numeric_limits<uint32_t>::max()));\n}\n\nTEST(FormatterTest, FormatDec) {\n  EXPECT_EQ(\"0\", format(\"{0}\", 0));\n  EXPECT_EQ(\"42\", format(\"{0}\", 42));\n  EXPECT_EQ(\"42\", format(\"{0:d}\", 42));\n  EXPECT_EQ(\"42\", format(\"{0}\", 42u));\n  EXPECT_EQ(\"-42\", format(\"{0}\", -42));\n  EXPECT_EQ(\"12345\", format(\"{0}\", 12345));\n  EXPECT_EQ(\"67890\", format(\"{0}\", 67890));\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"%d\", INT_MIN);\n  EXPECT_EQ(buffer, format(\"{0}\", INT_MIN));\n  safe_sprintf(buffer, \"%d\", INT_MAX);\n  EXPECT_EQ(buffer, format(\"{0}\", INT_MAX));\n  safe_sprintf(buffer, \"%u\", UINT_MAX);\n  EXPECT_EQ(buffer, format(\"{0}\", UINT_MAX));\n  safe_sprintf(buffer, \"%ld\", 0 - static_cast<unsigned long>(LONG_MIN));\n  EXPECT_EQ(buffer, format(\"{0}\", LONG_MIN));\n  safe_sprintf(buffer, \"%ld\", LONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0}\", LONG_MAX));\n  safe_sprintf(buffer, \"%lu\", ULONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0}\", ULONG_MAX));\n}\n\nTEST(FormatterTest, FormatHex) {\n  EXPECT_EQ(\"0\", format(\"{0:x}\", 0));\n  EXPECT_EQ(\"42\", format(\"{0:x}\", 0x42));\n  EXPECT_EQ(\"42\", format(\"{0:x}\", 0x42u));\n  EXPECT_EQ(\"-42\", format(\"{0:x}\", -0x42));\n  EXPECT_EQ(\"12345678\", format(\"{0:x}\", 0x12345678));\n  EXPECT_EQ(\"90abcdef\", format(\"{0:x}\", 0x90abcdef));\n  EXPECT_EQ(\"12345678\", format(\"{0:X}\", 0x12345678));\n  EXPECT_EQ(\"90ABCDEF\", format(\"{0:X}\", 0x90ABCDEF));\n\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"-%x\", 0 - static_cast<unsigned>(INT_MIN));\n  EXPECT_EQ(buffer, format(\"{0:x}\", INT_MIN));\n  safe_sprintf(buffer, \"%x\", INT_MAX);\n  EXPECT_EQ(buffer, format(\"{0:x}\", INT_MAX));\n  safe_sprintf(buffer, \"%x\", UINT_MAX);\n  EXPECT_EQ(buffer, format(\"{0:x}\", UINT_MAX));\n  safe_sprintf(buffer, \"-%lx\", 0 - static_cast<unsigned long>(LONG_MIN));\n  EXPECT_EQ(buffer, format(\"{0:x}\", LONG_MIN));\n  safe_sprintf(buffer, \"%lx\", LONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0:x}\", LONG_MAX));\n  safe_sprintf(buffer, \"%lx\", ULONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0:x}\", ULONG_MAX));\n}\n\nTEST(FormatterTest, FormatOct) {\n  EXPECT_EQ(\"0\", format(\"{0:o}\", 0));\n  EXPECT_EQ(\"42\", format(\"{0:o}\", 042));\n  EXPECT_EQ(\"42\", format(\"{0:o}\", 042u));\n  EXPECT_EQ(\"-42\", format(\"{0:o}\", -042));\n  EXPECT_EQ(\"12345670\", format(\"{0:o}\", 012345670));\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"-%o\", 0 - static_cast<unsigned>(INT_MIN));\n  EXPECT_EQ(buffer, format(\"{0:o}\", INT_MIN));\n  safe_sprintf(buffer, \"%o\", INT_MAX);\n  EXPECT_EQ(buffer, format(\"{0:o}\", INT_MAX));\n  safe_sprintf(buffer, \"%o\", UINT_MAX);\n  EXPECT_EQ(buffer, format(\"{0:o}\", UINT_MAX));\n  safe_sprintf(buffer, \"-%lo\", 0 - static_cast<unsigned long>(LONG_MIN));\n  EXPECT_EQ(buffer, format(\"{0:o}\", LONG_MIN));\n  safe_sprintf(buffer, \"%lo\", LONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0:o}\", LONG_MAX));\n  safe_sprintf(buffer, \"%lo\", ULONG_MAX);\n  EXPECT_EQ(buffer, format(\"{0:o}\", ULONG_MAX));\n}\n\nTEST(FormatterTest, FormatIntLocale) {\n  ScopedMock<LocaleMock> mock;\n  lconv lc = lconv();\n  char sep[] = \"--\";\n  lc.thousands_sep = sep;\n  EXPECT_CALL(mock, localeconv()).Times(3).WillRepeatedly(testing::Return(&lc));\n  EXPECT_EQ(\"123\", format(\"{:n}\", 123));\n  EXPECT_EQ(\"1--234\", format(\"{:n}\", 1234));\n  EXPECT_EQ(\"1--234--567\", format(\"{:n}\", 1234567));\n}\n\nstruct ConvertibleToLongLong {\n  operator fmt::LongLong() const {\n    return fmt::LongLong(1) << 32;\n  }\n};\n\nTEST(FormatterTest, FormatConvertibleToLongLong) {\n  EXPECT_EQ(\"100000000\", format(\"{:x}\", ConvertibleToLongLong()));\n}\n\nTEST(FormatterTest, FormatFloat) {\n  EXPECT_EQ(\"392.500000\", format(\"{0:f}\", 392.5f));\n}\n\nTEST(FormatterTest, FormatDouble) {\n  check_unknown_types(1.2, \"eEfFgGaA\", \"double\");\n  EXPECT_EQ(\"0\", format(\"{0:}\", 0.0));\n  EXPECT_EQ(\"0.000000\", format(\"{0:f}\", 0.0));\n  EXPECT_EQ(\"392.65\", format(\"{0:}\", 392.65));\n  EXPECT_EQ(\"392.65\", format(\"{0:g}\", 392.65));\n  EXPECT_EQ(\"392.65\", format(\"{0:G}\", 392.65));\n  EXPECT_EQ(\"392.650000\", format(\"{0:f}\", 392.65));\n  EXPECT_EQ(\"392.650000\", format(\"{0:F}\", 392.65));\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"%e\", 392.65);\n  EXPECT_EQ(buffer, format(\"{0:e}\", 392.65));\n  safe_sprintf(buffer, \"%E\", 392.65);\n  EXPECT_EQ(buffer, format(\"{0:E}\", 392.65));\n  EXPECT_EQ(\"+0000392.6\", format(\"{0:+010.4g}\", 392.65));\n  safe_sprintf(buffer, \"%a\", -42.0);\n  EXPECT_EQ(buffer, format(\"{:a}\", -42.0));\n  safe_sprintf(buffer, \"%A\", -42.0);\n  EXPECT_EQ(buffer, format(\"{:A}\", -42.0));\n}\n\nTEST(FormatterTest, FormatNaN) {\n  double nan = std::numeric_limits<double>::quiet_NaN();\n  EXPECT_EQ(\"nan\", format(\"{}\", nan));\n  EXPECT_EQ(\"+nan\", format(\"{:+}\", nan));\n  EXPECT_EQ(\" nan\", format(\"{: }\", nan));\n  EXPECT_EQ(\"NAN\", format(\"{:F}\", nan));\n  EXPECT_EQ(\"nan    \", format(\"{:<7}\", nan));\n  EXPECT_EQ(\"  nan  \", format(\"{:^7}\", nan));\n  EXPECT_EQ(\"    nan\", format(\"{:>7}\", nan));\n}\n\nTEST(FormatterTest, FormatInfinity) {\n  double inf = std::numeric_limits<double>::infinity();\n  EXPECT_EQ(\"inf\", format(\"{}\", inf));\n  EXPECT_EQ(\"+inf\", format(\"{:+}\", inf));\n  EXPECT_EQ(\"-inf\", format(\"{}\", -inf));\n  EXPECT_EQ(\" inf\", format(\"{: }\", inf));\n  EXPECT_EQ(\"INF\", format(\"{:F}\", inf));\n  EXPECT_EQ(\"inf    \", format(\"{:<7}\", inf));\n  EXPECT_EQ(\"  inf  \", format(\"{:^7}\", inf));\n  EXPECT_EQ(\"    inf\", format(\"{:>7}\", inf));\n}\n\nTEST(FormatterTest, FormatLongDouble) {\n  EXPECT_EQ(\"0\", format(\"{0:}\", 0.0l));\n  EXPECT_EQ(\"0.000000\", format(\"{0:f}\", 0.0l));\n  EXPECT_EQ(\"392.65\", format(\"{0:}\", 392.65l));\n  EXPECT_EQ(\"392.65\", format(\"{0:g}\", 392.65l));\n  EXPECT_EQ(\"392.65\", format(\"{0:G}\", 392.65l));\n  EXPECT_EQ(\"392.650000\", format(\"{0:f}\", 392.65l));\n  EXPECT_EQ(\"392.650000\", format(\"{0:F}\", 392.65l));\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"%Le\", 392.65l);\n  EXPECT_EQ(buffer, format(\"{0:e}\", 392.65l));\n  EXPECT_EQ(\"+0000392.6\", format(\"{0:+010.4g}\", 392.64l));\n}\n\nTEST(FormatterTest, FormatChar) {\n  const char types[] = \"cbBdoxXn\";\n  check_unknown_types('a', types, \"char\");\n  EXPECT_EQ(\"a\", format(\"{0}\", 'a'));\n  EXPECT_EQ(\"z\", format(\"{0:c}\", 'z'));\n  EXPECT_EQ(L\"a\", format(L\"{0}\", 'a'));\n  int n = 'x';\n  for (const char *type = types + 1; *type; ++type) {\n    std::string format_str = fmt::format(\"{{:{}}}\", *type);\n    EXPECT_EQ(fmt::format(format_str, n), fmt::format(format_str, 'x'));\n  }\n  EXPECT_EQ(fmt::format(\"{:02X}\", n), fmt::format(\"{:02X}\", 'x'));\n}\n\nTEST(FormatterTest, FormatUnsignedChar) {\n  EXPECT_EQ(\"42\", format(\"{}\", static_cast<unsigned char>(42)));\n  EXPECT_EQ(\"42\", format(\"{}\", static_cast<uint8_t>(42)));\n}\n\nTEST(FormatterTest, FormatWChar) {\n  EXPECT_EQ(L\"a\", format(L\"{0}\", L'a'));\n  // This shouldn't compile:\n  //format(\"{}\", L'a');\n}\n\nTEST(FormatterTest, FormatCString) {\n  check_unknown_types(\"test\", \"sp\", \"string\");\n  EXPECT_EQ(\"test\", format(\"{0}\", \"test\"));\n  EXPECT_EQ(\"test\", format(\"{0:s}\", \"test\"));\n  char nonconst[] = \"nonconst\";\n  EXPECT_EQ(\"nonconst\", format(\"{0}\", nonconst));\n  EXPECT_THROW_MSG(format(\"{0}\", reinterpret_cast<const char*>(0)),\n      FormatError, \"string pointer is null\");\n}\n\nTEST(FormatterTest, FormatSCharString) {\n  signed char str[] = \"test\";\n  EXPECT_EQ(\"test\", format(\"{0:s}\", str));\n  const signed char *const_str = str;\n  EXPECT_EQ(\"test\", format(\"{0:s}\", const_str));\n}\n\nTEST(FormatterTest, FormatUCharString) {\n  unsigned char str[] = \"test\";\n  EXPECT_EQ(\"test\", format(\"{0:s}\", str));\n  const unsigned char *const_str = str;\n  EXPECT_EQ(\"test\", format(\"{0:s}\", const_str));\n  unsigned char *ptr = str;\n  EXPECT_EQ(\"test\", format(\"{0:s}\", ptr));\n}\n\nTEST(FormatterTest, FormatPointer) {\n  check_unknown_types(reinterpret_cast<void*>(0x1234), \"p\", \"pointer\");\n  EXPECT_EQ(\"0x0\", format(\"{0}\", reinterpret_cast<void*>(0)));\n  EXPECT_EQ(\"0x1234\", format(\"{0}\", reinterpret_cast<void*>(0x1234)));\n  EXPECT_EQ(\"0x1234\", format(\"{0:p}\", reinterpret_cast<void*>(0x1234)));\n  EXPECT_EQ(\"0x\" + std::string(sizeof(void*) * CHAR_BIT / 4, 'f'),\n      format(\"{0}\", reinterpret_cast<void*>(~uintptr_t())));\n}\n\nTEST(FormatterTest, FormatString) {\n  EXPECT_EQ(\"test\", format(\"{0}\", std::string(\"test\")));\n}\n\nTEST(FormatterTest, FormatStringRef) {\n  EXPECT_EQ(\"test\", format(\"{0}\", StringRef(\"test\")));\n}\n\nTEST(FormatterTest, FormatCStringRef) {\n  EXPECT_EQ(\"test\", format(\"{0}\", CStringRef(\"test\")));\n}\n\n#if FMT_HAS_STRING_VIEW\nTEST(FormatterTest, FormatStringView) {\n  EXPECT_EQ(\"test\", format(\"{0}\", std::string_view(\"test\")));\n}\n#endif\n\n#if FMT_HAS_EXPERIMENTAL_STRING_VIEW\nTEST(FormatterTest, FormatExperimentalStringView) {\n\tEXPECT_EQ(\"test\", format(\"{0}\", std::experimental::string_view(\"test\")));\n}\n#endif\n\nvoid format_arg(fmt::BasicFormatter<char> &f, const char *, const Date &d) {\n  f.writer() << d.year() << '-' << d.month() << '-' << d.day();\n}\n\nTEST(FormatterTest, FormatCustom) {\n  Date date(2012, 12, 9);\n  EXPECT_THROW_MSG(fmt::format(\"{:s}\", date), FormatError,\n                   \"unmatched '}' in format string\");\n}\n\nclass Answer {};\n\ntemplate <typename Char>\nvoid format_arg(fmt::BasicFormatter<Char> &f, const Char *, Answer) {\n  f.writer() << \"42\";\n}\n\nTEST(FormatterTest, CustomFormat) {\n  EXPECT_EQ(\"42\", format(\"{0}\", Answer()));\n}\n\nTEST(FormatterTest, WideFormatString) {\n  EXPECT_EQ(L\"42\", format(L\"{}\", 42));\n  EXPECT_EQ(L\"4.2\", format(L\"{}\", 4.2));\n  EXPECT_EQ(L\"abc\", format(L\"{}\", L\"abc\"));\n  EXPECT_EQ(L\"z\", format(L\"{}\", L'z'));\n}\n\nTEST(FormatterTest, FormatStringFromSpeedTest) {\n  EXPECT_EQ(\"1.2340000000:0042:+3.13:str:0x3e8:X:%\",\n      format(\"{0:0.10f}:{1:04}:{2:+g}:{3}:{4}:{5}:%\",\n          1.234, 42, 3.13, \"str\", reinterpret_cast<void*>(1000), 'X'));\n}\n\nTEST(FormatterTest, FormatExamples) {\n  using fmt::hex;\n  EXPECT_EQ(\"0000cafe\", (MemoryWriter() << pad(hex(0xcafe), 8, '0')).str());\n\n  std::string message = format(\"The answer is {}\", 42);\n  EXPECT_EQ(\"The answer is 42\", message);\n\n  EXPECT_EQ(\"42\", format(\"{}\", 42));\n  EXPECT_EQ(\"42\", format(std::string(\"{}\"), 42));\n\n  MemoryWriter out;\n  out << \"The answer is \" << 42 << \"\\n\";\n  out.write(\"({:+f}, {:+f})\", -3.14, 3.14);\n  EXPECT_EQ(\"The answer is 42\\n(-3.140000, +3.140000)\", out.str());\n\n  {\n    MemoryWriter writer;\n    for (int i = 0; i < 10; i++)\n      writer.write(\"{}\", i);\n    std::string s = writer.str(); // s == 0123456789\n    EXPECT_EQ(\"0123456789\", s);\n  }\n\n  const char *filename = \"nonexistent\";\n  FILE *ftest = safe_fopen(filename, \"r\");\n  if (ftest) fclose(ftest);\n  int error_code = errno;\n  EXPECT_TRUE(ftest == 0);\n  EXPECT_SYSTEM_ERROR({\n    FILE *f = safe_fopen(filename, \"r\");\n    if (!f)\n      throw fmt::SystemError(errno, \"Cannot open file '{}'\", filename);\n    fclose(f);\n  }, error_code, \"Cannot open file 'nonexistent'\");\n}\n\nTEST(FormatterTest, Examples) {\n  EXPECT_EQ(\"First, thou shalt count to three\",\n      format(\"First, thou shalt count to {0}\", \"three\"));\n  EXPECT_EQ(\"Bring me a shrubbery\",\n      format(\"Bring me a {}\", \"shrubbery\"));\n  EXPECT_EQ(\"From 1 to 3\", format(\"From {} to {}\", 1, 3));\n\n  char buffer[BUFFER_SIZE];\n  safe_sprintf(buffer, \"%03.2f\", -1.2);\n  EXPECT_EQ(buffer, format(\"{:03.2f}\", -1.2));\n\n  EXPECT_EQ(\"a, b, c\", format(\"{0}, {1}, {2}\", 'a', 'b', 'c'));\n  EXPECT_EQ(\"a, b, c\", format(\"{}, {}, {}\", 'a', 'b', 'c'));\n  EXPECT_EQ(\"c, b, a\", format(\"{2}, {1}, {0}\", 'a', 'b', 'c'));\n  EXPECT_EQ(\"abracadabra\", format(\"{0}{1}{0}\", \"abra\", \"cad\"));\n\n  EXPECT_EQ(\"left aligned                  \",\n      format(\"{:<30}\", \"left aligned\"));\n  EXPECT_EQ(\"                 right aligned\",\n      format(\"{:>30}\", \"right aligned\"));\n  EXPECT_EQ(\"           centered           \",\n      format(\"{:^30}\", \"centered\"));\n  EXPECT_EQ(\"***********centered***********\",\n      format(\"{:*^30}\", \"centered\"));\n\n  EXPECT_EQ(\"+3.140000; -3.140000\",\n      format(\"{:+f}; {:+f}\", 3.14, -3.14));\n  EXPECT_EQ(\" 3.140000; -3.140000\",\n      format(\"{: f}; {: f}\", 3.14, -3.14));\n  EXPECT_EQ(\"3.140000; -3.140000\",\n      format(\"{:-f}; {:-f}\", 3.14, -3.14));\n\n  EXPECT_EQ(\"int: 42;  hex: 2a;  oct: 52\",\n      format(\"int: {0:d};  hex: {0:x};  oct: {0:o}\", 42));\n  EXPECT_EQ(\"int: 42;  hex: 0x2a;  oct: 052\",\n      format(\"int: {0:d};  hex: {0:#x};  oct: {0:#o}\", 42));\n\n  EXPECT_EQ(\"The answer is 42\", format(\"The answer is {}\", 42));\n  EXPECT_THROW_MSG(\n    format(\"The answer is {:d}\", \"forty-two\"), FormatError,\n    \"unknown format code 'd' for string\");\n\n  EXPECT_EQ(L\"Cyrillic letter \\x42e\",\n    format(L\"Cyrillic letter {}\", L'\\x42e'));\n\n  EXPECT_WRITE(stdout,\n      fmt::print(\"{}\", std::numeric_limits<double>::infinity()), \"inf\");\n}\n\nTEST(FormatIntTest, Data) {\n  fmt::FormatInt format_int(42);\n  EXPECT_EQ(\"42\", std::string(format_int.data(), format_int.size()));\n}\n\nTEST(FormatIntTest, FormatInt) {\n  EXPECT_EQ(\"42\", fmt::FormatInt(42).str());\n  EXPECT_EQ(2u, fmt::FormatInt(42).size());\n  EXPECT_EQ(\"-42\", fmt::FormatInt(-42).str());\n  EXPECT_EQ(3u, fmt::FormatInt(-42).size());\n  EXPECT_EQ(\"42\", fmt::FormatInt(42ul).str());\n  EXPECT_EQ(\"-42\", fmt::FormatInt(-42l).str());\n  EXPECT_EQ(\"42\", fmt::FormatInt(42ull).str());\n  EXPECT_EQ(\"-42\", fmt::FormatInt(-42ll).str());\n  std::ostringstream os;\n  os << std::numeric_limits<int64_t>::max();\n  EXPECT_EQ(os.str(),\n            fmt::FormatInt(std::numeric_limits<int64_t>::max()).str());\n}\n\ntemplate <typename T>\nstd::string format_decimal(T value) {\n  char buffer[10];\n  char *ptr = buffer;\n  fmt::format_decimal(ptr, value);\n  return std::string(buffer, ptr);\n}\n\nTEST(FormatIntTest, FormatDec) {\n  EXPECT_EQ(\"-42\", format_decimal(static_cast<signed char>(-42)));\n  EXPECT_EQ(\"-42\", format_decimal(static_cast<short>(-42)));\n  std::ostringstream os;\n  os << std::numeric_limits<unsigned short>::max();\n  EXPECT_EQ(os.str(),\n            format_decimal(std::numeric_limits<unsigned short>::max()));\n  EXPECT_EQ(\"1\", format_decimal(1));\n  EXPECT_EQ(\"-1\", format_decimal(-1));\n  EXPECT_EQ(\"42\", format_decimal(42));\n  EXPECT_EQ(\"-42\", format_decimal(-42));\n  EXPECT_EQ(\"42\", format_decimal(42l));\n  EXPECT_EQ(\"42\", format_decimal(42ul));\n  EXPECT_EQ(\"42\", format_decimal(42ll));\n  EXPECT_EQ(\"42\", format_decimal(42ull));\n}\n\nTEST(FormatTest, Print) {\n#if FMT_USE_FILE_DESCRIPTORS\n  EXPECT_WRITE(stdout, fmt::print(\"Don't {}!\", \"panic\"), \"Don't panic!\");\n  EXPECT_WRITE(stderr,\n      fmt::print(stderr, \"Don't {}!\", \"panic\"), \"Don't panic!\");\n#endif\n}\n\n#if FMT_USE_FILE_DESCRIPTORS\nTEST(FormatTest, PrintColored) {\n  EXPECT_WRITE(stdout, fmt::print_colored(fmt::RED, \"Hello, {}!\\n\", \"world\"),\n    \"\\x1b[31mHello, world!\\n\\x1b[0m\");\n}\n#endif\n\nTEST(FormatTest, Variadic) {\n  EXPECT_EQ(\"abc1\", format(\"{}c{}\", \"ab\", 1));\n  EXPECT_EQ(L\"abc1\", format(L\"{}c{}\", L\"ab\", 1));\n}\n\nTEST(FormatTest, JoinArg) {\n  using fmt::join;\n  int v1[3] = { 1, 2, 3 };\n  std::vector<float> v2;\n  v2.push_back(1.2f);\n  v2.push_back(3.4f);\n\n  EXPECT_EQ(\"(1, 2, 3)\", format(\"({})\", join(v1, v1 + 3, \", \")));\n  EXPECT_EQ(\"(1)\", format(\"({})\", join(v1, v1 + 1, \", \")));\n  EXPECT_EQ(\"()\", format(\"({})\", join(v1, v1, \", \")));\n  EXPECT_EQ(\"(001, 002, 003)\", format(\"({:03})\", join(v1, v1 + 3, \", \")));\n  EXPECT_EQ(\"(+01.20, +03.40)\",\n            format(\"({:+06.2f})\", join(v2.begin(), v2.end(), \", \")));\n\n  EXPECT_EQ(L\"(1, 2, 3)\", format(L\"({})\", join(v1, v1 + 3, L\", \")));\n  EXPECT_EQ(\"1, 2, 3\", format(\"{0:{1}}\", join(v1, v1 + 3, \", \"), 1)); \n\n#if FMT_HAS_GXX_CXX11\n  EXPECT_EQ(\"(1, 2, 3)\", format(\"({})\", join(v1, \", \")));\n  EXPECT_EQ(\"(+01.20, +03.40)\", format(\"({:+06.2f})\", join(v2, \", \")));\n#endif\n}\n\ntemplate <typename T>\nstd::string str(const T &value) {\n  return fmt::format(\"{}\", value);\n}\n\nTEST(StrTest, Convert) {\n  EXPECT_EQ(\"42\", str(42));\n  std::string s = str(Date(2012, 12, 9));\n  EXPECT_EQ(\"2012-12-9\", s);\n}\n\nstd::string format_message(int id, const char *format,\n    const fmt::ArgList &args) {\n  MemoryWriter w;\n  w.write(\"[{}] \", id);\n  w.write(format, args);\n  return w.str();\n}\n\nFMT_VARIADIC(std::string, format_message, int, const char *)\n\nTEST(FormatTest, FormatMessageExample) {\n  EXPECT_EQ(\"[42] something happened\",\n      format_message(42, \"{} happened\", \"something\"));\n}\n\nclass test_class\n{\npublic:\n  std::string format_message(int id, const char *format,const fmt::ArgList &args) const {\n    MemoryWriter w;\n    w.write(\"[{}] \", id);\n    w.write(format, args);\n    return w.str();\n  }\n  FMT_VARIADIC_CONST(std::string, format_message, int, const char *)\n};\n\nTEST(FormatTest, ConstFormatMessage) {\n  test_class c;\n  EXPECT_EQ(\"[42] something happened\",\n    c.format_message(42, \"{} happened\", \"something\"));\n}\n\n#if FMT_USE_VARIADIC_TEMPLATES\ntemplate<typename... Args>\nvoid print_error(const char *file, int line, const char *format,\n                 const Args & ... args) {\n  fmt::print(\"{}: {}: \", file, line);\n  fmt::print(format, args...);\n}\n#endif\n\nTEST(FormatTest, MaxArgs) {\n  EXPECT_EQ(\"0123456789abcde\",\n            fmt::format(\"{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}\",\n                        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'b', 'c', 'd', 'e'));\n}\n\n#if FMT_USE_USER_DEFINED_LITERALS\n// Passing user-defined literals directly to EXPECT_EQ causes problems\n// with macro argument stringification (#) on some versions of GCC.\n// Workaround: Assing the UDL result to a variable before the macro.\n\nusing namespace fmt::literals;\n\nTEST(LiteralsTest, Format) {\n  auto udl_format = \"{}c{}\"_format(\"ab\", 1);\n  EXPECT_EQ(format(\"{}c{}\", \"ab\", 1), udl_format);\n  auto udl_format_w = L\"{}c{}\"_format(L\"ab\", 1);\n  EXPECT_EQ(format(L\"{}c{}\", L\"ab\", 1), udl_format_w);\n}\n\nTEST(LiteralsTest, NamedArg) {\n  auto udl_a = format(\"{first}{second}{first}{third}\",\n                      \"first\"_a=\"abra\", \"second\"_a=\"cad\", \"third\"_a=99);\n  EXPECT_EQ(format(\"{first}{second}{first}{third}\",\n                   fmt::arg(\"first\", \"abra\"), fmt::arg(\"second\", \"cad\"),\n                   fmt::arg(\"third\", 99)),\n            udl_a);\n  auto udl_a_w = format(L\"{first}{second}{first}{third}\",\n                        L\"first\"_a=L\"abra\", L\"second\"_a=L\"cad\", L\"third\"_a=99);\n  EXPECT_EQ(format(L\"{first}{second}{first}{third}\",\n                   fmt::arg(L\"first\", L\"abra\"), fmt::arg(L\"second\", L\"cad\"),\n                   fmt::arg(L\"third\", 99)),\n            udl_a_w);\n}\n#endif // FMT_USE_USER_DEFINED_LITERALS\n\nenum TestEnum { A };\n\nTEST(FormatTest, Enum) {\n  EXPECT_EQ(\"0\", fmt::format(\"{}\", A));\n}\n\n#if __cplusplus >= 201103L\nenum TestFixedEnum : short { B };\n\nTEST(FormatTest, FixedEnum) {\n  EXPECT_EQ(\"0\", fmt::format(\"{}\", B));\n}\n#endif\n\nclass MockArgFormatter :\n    public fmt::internal::ArgFormatterBase<MockArgFormatter, char> {\n public:\n  typedef fmt::internal::ArgFormatterBase<MockArgFormatter, char> Base;\n\n  MockArgFormatter(fmt::BasicFormatter<char, MockArgFormatter> &f,\n                   fmt::FormatSpec &s, const char *)\n    : fmt::internal::ArgFormatterBase<MockArgFormatter, char>(f.writer(), s) {\n    EXPECT_CALL(*this, visit_int(42));\n  }\n\n  MOCK_METHOD1(visit_int, void (int value));\n};\n\nvoid custom_format(const char *format_str, fmt::ArgList args) {\n  fmt::MemoryWriter writer;\n  fmt::BasicFormatter<char, MockArgFormatter> formatter(args, writer);\n  formatter.format(format_str);\n}\nFMT_VARIADIC(void, custom_format, const char *)\n\nTEST(FormatTest, CustomArgFormatter) {\n  custom_format(\"{}\", 42);\n}\n\nvoid convert(int);\n\n// Check if there is no collision with convert function in the global namespace.\nTEST(FormatTest, ConvertCollision) {\n  fmt::format(\"{}\", 42);\n}\n\nTEST(FormatTest, Regression) {\n  fmt::format(\"...........{:<77777.7p}\", \"foo\");\n}\n"], "filenames": ["fmt/format.h", "test/format-test.cc"], "buggy_code_start_loc": [3003, 1763], "buggy_code_end_loc": [3010, 1763], "fixing_code_start_loc": [3003, 1764], "fixing_code_end_loc": [3010, 1768], "type": "CWE-134", "message": "fmtlib version prior to version 4.1.0 (before commit 0555cea5fc0bf890afe0071a558e44625a34ba85) contains a Memory corruption (SIGSEGV), CWE-134 vulnerability in fmt::print() library function that can result in Denial of Service. This attack appear to be exploitable via Specifying an invalid format specifier in the fmt::print() function results in a SIGSEGV (memory corruption, invalid write). This vulnerability appears to have been fixed in after commit 8cf30aa2be256eba07bb1cefb998c52326e846e7.", "other": {"cve": {"id": "CVE-2018-1000052", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-09T23:29:01.837", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "fmtlib version prior to version 4.1.0 (before commit 0555cea5fc0bf890afe0071a558e44625a34ba85) contains a Memory corruption (SIGSEGV), CWE-134 vulnerability in fmt::print() library function that can result in Denial of Service. This attack appear to be exploitable via Specifying an invalid format specifier in the fmt::print() function results in a SIGSEGV (memory corruption, invalid write). This vulnerability appears to have been fixed in after commit 8cf30aa2be256eba07bb1cefb998c52326e846e7."}, {"lang": "es", "value": "fmtlib, en versiones anteriores a la 4.1.0 (antes del commit con ID 0555cea5fc0bf890afe0071a558e44625a34ba85), contiene una vulnerabilidad CWE-134 de corrupci\u00f3n de memoria (SIGSEGV) en la funci\u00f3n de biblioteca fmt::print() que puede resultar en una denegaci\u00f3n de servicio (DoS). El ataque parece ser explotable mediante la especificaci\u00f3n de un especificador con formato inv\u00e1lido en la funci\u00f3n fmt::print(), lo que resulta en un SIGSEGV (corrupci\u00f3n de memoria y escritura inv\u00e1lida). Parece ser que la vulnerabilidad se ha solucionado tras el commit con ID 8cf30aa2be256eba07bb1cefb998c52326e846e7."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-134"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:fmt:fmt:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.1.0", "matchCriteriaId": "353F293D-0F46-4DFB-89DC-27B50ABB2066"}]}]}], "references": [{"url": "https://github.com/fmtlib/fmt/commit/8cf30aa2be256eba07bb1cefb998c52326e846e7", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/fmtlib/fmt/issues/642", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/fmtlib/fmt/commit/8cf30aa2be256eba07bb1cefb998c52326e846e7"}}