{"buggy_code": ["/**\n * @module node-opcua-server\n */\n// tslint:disable:no-console\n\nimport { EventEmitter } from \"events\";\nimport * as chalk from \"chalk\";\n\nimport { AddressSpace, BaseNode, Duration, UAObjectType } from \"node-opcua-address-space\";\nimport { checkSelectClauses } from \"node-opcua-address-space\";\nimport { SessionContext } from \"node-opcua-address-space\";\nimport { assert } from \"node-opcua-assert\";\nimport { Byte, UInt32 } from \"node-opcua-basic-types\";\nimport { SubscriptionDiagnosticsDataType } from \"node-opcua-common\";\nimport { NodeClass, AttributeIds, isValidDataEncoding } from \"node-opcua-data-model\";\nimport { TimestampsToReturn } from \"node-opcua-data-value\";\nimport { checkDebugFlag, make_debugLog, make_warningLog } from \"node-opcua-debug\";\nimport { NodeId } from \"node-opcua-nodeid\";\nimport { ObjectRegistry } from \"node-opcua-object-registry\";\nimport { SequenceNumberGenerator } from \"node-opcua-secure-channel\";\nimport { EventFilter } from \"node-opcua-service-filter\";\nimport { AggregateFilter } from \"node-opcua-service-subscription\";\nimport {\n    DataChangeNotification,\n    EventNotificationList,\n    MonitoringMode,\n    MonitoredItemCreateResult,\n    MonitoredItemNotification,\n    PublishResponse,\n    NotificationMessage,\n    StatusChangeNotification,\n    DataChangeFilter,\n    MonitoredItemCreateRequest\n} from \"node-opcua-service-subscription\";\nimport { StatusCode, StatusCodes } from \"node-opcua-status-code\";\nimport { AggregateFilterResult, ContentFilterResult, EventFieldList, EventFilterResult, NotificationData } from \"node-opcua-types\";\nimport { Queue } from \"./queue\";\n\nimport { MonitoredItem, MonitoredItemOptions, QueueItem } from \"./monitored_item\";\nimport { ServerSession } from \"./server_session\";\nimport { validateFilter } from \"./validate_filter\";\nimport { IServerSidePublishEngine, TransferredSubscription } from \"./i_server_side_publish_engine\";\n\nconst debugLog = make_debugLog(__filename);\nconst doDebug = checkDebugFlag(__filename);\nconst warningLog = make_warningLog(__filename);\nconst maxNotificationMessagesInQueue = 100;\n\nexport interface SubscriptionDiagnosticsDataTypePriv extends SubscriptionDiagnosticsDataType {\n    $subscription: Subscription;\n}\n\nexport enum SubscriptionState {\n    CLOSED = 1, // The Subscription has not yet been created or has terminated.\n    CREATING = 2, // The Subscription is being created\n    NORMAL = 3, // The Subscription is cyclically checking for Notifications from its MonitoredItems.\n    // The keep-alive counter is not used in this state.\n    LATE = 4, // The publishing timer has expired and there are Notifications available or a keep-alive Message is\n    // ready to be sent, but there are no Publish requests queued. When in this state, the next Publish\n    // request is processed when it is received. The keep-alive counter is not used in this state.\n    KEEPALIVE = 5, // The Subscription is cyclically checking for Notification\n    // alive counter to count down to 0 from its maximum.\n    TERMINATED = 6\n}\n\nfunction _adjust_publishing_interval(publishingInterval?: number): number {\n    publishingInterval =\n        publishingInterval === undefined || Number.isNaN(publishingInterval)\n            ? Subscription.defaultPublishingInterval\n            : publishingInterval;\n    publishingInterval = Math.max(publishingInterval, Subscription.minimumPublishingInterval);\n    publishingInterval = Math.min(publishingInterval, Subscription.maximumPublishingInterval);\n    return publishingInterval;\n}\n\nconst minimumMaxKeepAliveCount = 2;\nconst maximumMaxKeepAliveCount = 12000;\n\nfunction _adjust_maxKeepAliveCount(maxKeepAliveCount?: number /*,publishingInterval*/): number {\n    maxKeepAliveCount = maxKeepAliveCount || minimumMaxKeepAliveCount;\n    maxKeepAliveCount = Math.max(maxKeepAliveCount, minimumMaxKeepAliveCount);\n    maxKeepAliveCount = Math.min(maxKeepAliveCount, maximumMaxKeepAliveCount);\n    return maxKeepAliveCount;\n}\n\nfunction _adjust_lifeTimeCount(lifeTimeCount: number, maxKeepAliveCount: number, publishingInterval: number): number {\n    lifeTimeCount = lifeTimeCount || 1;\n\n    // let's make sure that lifeTimeCount is at least three time maxKeepAliveCount\n    // Note : the specs say ( part 3  - CreateSubscriptionParameter )\n    //        \"The lifetime count shall be a minimum of three times the keep keep-alive count.\"\n    lifeTimeCount = Math.max(lifeTimeCount, maxKeepAliveCount * 3);\n\n    const minTicks = Math.ceil(Subscription.minimumLifetimeDuration / publishingInterval);\n    const maxTicks = Math.floor(Subscription.maximumLifetimeDuration / publishingInterval);\n\n    lifeTimeCount = Math.max(minTicks, lifeTimeCount);\n    lifeTimeCount = Math.min(maxTicks, lifeTimeCount);\n    return lifeTimeCount;\n}\n\nfunction _adjust_publishingEnable(publishingEnabled?: boolean | null): boolean {\n    return publishingEnabled === null || publishingEnabled === undefined ? true : !!publishingEnabled;\n}\n\nfunction _adjust_maxNotificationsPerPublish(maxNotificationsPerPublish?: number): number {\n    assert(Subscription.maxNotificationPerPublishHighLimit > 0, \"Subscription.maxNotificationPerPublishHighLimit must be positive\");\n\n    maxNotificationsPerPublish = maxNotificationsPerPublish || 0;\n    assert(typeof maxNotificationsPerPublish === \"number\");\n\n    // must be strictly positive\n    maxNotificationsPerPublish = maxNotificationsPerPublish >= 0 ? maxNotificationsPerPublish : 0;\n\n    if (maxNotificationsPerPublish === 0) {\n        // if zero then => use our HighLimit\n        maxNotificationsPerPublish = Subscription.maxNotificationPerPublishHighLimit;\n    } else {\n        // if not zero then should be capped by maxNotificationPerPublishHighLimit\n        maxNotificationsPerPublish = Math.min(Subscription.maxNotificationPerPublishHighLimit, maxNotificationsPerPublish);\n    }\n\n    assert(maxNotificationsPerPublish !== 0 && maxNotificationsPerPublish <= Subscription.maxNotificationPerPublishHighLimit);\n    return maxNotificationsPerPublish;\n}\n\nfunction w(s: string | number, length: number): string {\n    return (\"000\" + s).padStart(length);\n}\n\nfunction t(d: Date): string {\n    return w(d.getHours(), 2) + \":\" + w(d.getMinutes(), 2) + \":\" + w(d.getSeconds(), 2) + \":\" + w(d.getMilliseconds(), 3);\n}\n\nfunction _getSequenceNumbers(arr: NotificationMessage[]): number[] {\n    return arr.map((notificationMessage) => notificationMessage.sequenceNumber);\n}\n\nfunction analyseEventFilterResult(node: BaseNode, eventFilter: EventFilter): EventFilterResult {\n    /* istanbul ignore next */\n    if (!(eventFilter instanceof EventFilter)) {\n        throw new Error(\"Internal Error\");\n    }\n\n    const selectClauseResults = checkSelectClauses(node as UAObjectType, eventFilter.selectClauses || []);\n\n    const whereClauseResult = new ContentFilterResult();\n\n    return new EventFilterResult({\n        selectClauseDiagnosticInfos: [],\n        selectClauseResults,\n        whereClauseResult\n    });\n}\n\nfunction analyseDataChangeFilterResult(node: BaseNode, dataChangeFilter: DataChangeFilter): null {\n    assert(dataChangeFilter instanceof DataChangeFilter);\n    // the opcua specification doesn't provide dataChangeFilterResult\n    return null;\n}\n\nfunction analyseAggregateFilterResult(node: BaseNode, aggregateFilter: AggregateFilter): AggregateFilterResult {\n    assert(aggregateFilter instanceof AggregateFilter);\n    return new AggregateFilterResult({});\n}\n\nfunction _process_filter(node: BaseNode, filter: any): EventFilterResult | AggregateFilterResult | null {\n    if (!filter) {\n        return null;\n    }\n\n    if (filter instanceof EventFilter) {\n        return analyseEventFilterResult(node, filter);\n    } else if (filter instanceof DataChangeFilter) {\n        return analyseDataChangeFilterResult(node, filter);\n    } else if (filter instanceof AggregateFilter) {\n        return analyseAggregateFilterResult(node, filter);\n    }\n    // istanbul ignore next\n    throw new Error(\"invalid filter\");\n}\n\n/**\n * @private\n */\nfunction createSubscriptionDiagnostics(subscription: Subscription): SubscriptionDiagnosticsDataTypePriv {\n    assert(subscription instanceof Subscription);\n\n    const subscriptionDiagnostics = new SubscriptionDiagnosticsDataType({});\n\n    const subscription_subscriptionDiagnostics = subscriptionDiagnostics as SubscriptionDiagnosticsDataTypePriv as any;\n    subscription_subscriptionDiagnostics.$subscription = subscription;\n    // \"sessionId\"\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"sessionId\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): NodeId {\n            if (!this.$subscription) {\n                return NodeId.nullNodeId;\n            }\n            return this.$subscription.getSessionId();\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"subscriptionId\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.id;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\"priority\", function (this: SubscriptionDiagnosticsDataTypePriv): number {\n        if (!this.$subscription) {\n            return 0;\n        }\n        return this.$subscription.priority;\n    });\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"publishingInterval\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.publishingInterval;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\"maxLifetimeCount\", function (this: SubscriptionDiagnosticsDataTypePriv) {\n        return this.$subscription.lifeTimeCount;\n    });\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"maxKeepAliveCount\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.maxKeepAliveCount;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"maxNotificationsPerPublish\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.maxNotificationsPerPublish;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"publishingEnabled\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): boolean {\n            if (!this.$subscription) {\n                return false;\n            }\n            return this.$subscription.publishingEnabled;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"monitoredItemCount\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.monitoredItemCount;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"nextSequenceNumber\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription._get_future_sequence_number();\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"disabledMonitoredItemCount\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.disabledMonitoredItemCount;\n        }\n    );\n\n    /* those member of self.subscriptionDiagnostics are handled directly\n\n   modifyCount\n   enableCount,\n   disableCount,\n   republishRequestCount,\n   notificationsCount,\n   publishRequestCount,\n   dataChangeNotificationsCount,\n   eventNotificationsCount,\n  */\n\n    /*\n   those members are not updated yet in the code :\n   \"republishMessageRequestCount\",\n   \"republishMessageCount\",\n   \"transferRequestCount\",\n   \"transferredToAltClientCount\",\n   \"transferredToSameClientCount\",\n   \"latePublishRequestCount\",\n   \"unacknowledgedMessageCount\",\n   \"discardedMessageCount\",\n   \"monitoringQueueOverflowCount\",\n   \"eventQueueOverFlowCount\"\n   */\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"currentKeepAliveCount\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.currentKeepAliveCount;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"currentLifetimeCount\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.currentLifetimeCount;\n        }\n    );\n    // add object in Variable SubscriptionDiagnosticArray (i=2290) ( Array of SubscriptionDiagnostics)\n    // add properties in Variable to reflect\n    return subscriptionDiagnostics as SubscriptionDiagnosticsDataTypePriv;\n}\n\ninterface IGlobalMonitoredItemCounter {\n    totalMonitoredItemCount: number;\n}\n\nexport interface SubscriptionOptions {\n    sessionId?: NodeId;\n    /**\n     * (default:1000) the publishing interval.\n     */\n    publishingInterval?: number;\n    /**\n     * (default:10) the max Life Time Count\n     */\n    maxKeepAliveCount?: number;\n\n    lifeTimeCount?: number;\n    /**\n     * (default:true)\n     */\n    publishingEnabled?: boolean;\n    /**\n     * (default:0)\n     */\n    maxNotificationsPerPublish?: number;\n    /**\n     * subscription priority Byte:(0-255)\n     */\n    priority?: number;\n\n    publishEngine?: IServerSidePublishEngine;\n    /**\n     *  a unique identifier\n     */\n    id?: number;\n\n    serverCapabilities: ServerCapabilitiesPartial;\n    globalCounter: IGlobalMonitoredItemCounter;\n}\n\nlet g_monitoredItemId = Math.ceil(Math.random() * 100000);\n\nfunction getNextMonitoredItemId() {\n    return g_monitoredItemId++;\n}\n\n// function myFilter<T>(t1: any, chunk: any[]): T[] {\n//     return chunk.filter(filter_instanceof.bind(null, t1));\n// }\n\n// function makeNotificationData(notifications_chunk: QueueItem): NotificationData {\n//     const dataChangedNotificationData = myFilter<MonitoredItemNotification>(MonitoredItemNotification, notifications_chunk);\n//     const eventNotificationListData = myFilter<EventFieldList>(EventFieldList, notifications_chunk);\n\n//     assert(notifications_chunk.length === dataChangedNotificationData.length + eventNotificationListData.length);\n\n//     const notifications: (DataChangeNotification | EventNotificationList)[] = [];\n\n//     // add dataChangeNotification\n//     if (dataChangedNotificationData.length) {\n//         const dataChangeNotification = new DataChangeNotification({\n//             diagnosticInfos: [],\n//             monitoredItems: dataChangedNotificationData\n//         });\n//         notifications.push(dataChangeNotification);\n//     }\n\n//     // add dataChangeNotification\n//     if (eventNotificationListData.length) {\n//         const eventNotificationList = new EventNotificationList({\n//             events: eventNotificationListData\n//         });\n//         notifications.push(eventNotificationList);\n//     }\n//     return notifications.length === 0 ? null : notifications;\n// }\nconst INVALID_ID = -1;\n\nexport type Notification = DataChangeNotification | EventNotificationList | StatusChangeNotification;\nexport type Counter = number;\n\nexport interface ModifySubscriptionParameters {\n    /**\n     *     requestedPublishingInterval =0 means fastest possible\n     */\n    requestedPublishingInterval?: Duration;\n    /*\n     * requestedLifetimeCount=0 means no change\n     */\n    requestedLifetimeCount?: Counter;\n    /**\n     * requestedMaxKeepAliveCount  ===0 means no change\n     */\n    requestedMaxKeepAliveCount?: Counter;\n    maxNotificationsPerPublish?: Counter;\n    priority?: Byte;\n}\n\nexport interface GetMonitoredItemsResult {\n    /**\n     * array of serverHandles for all MonitoredItems of the subscription\n     * identified by subscriptionId.\n     */\n    serverHandles: Uint32Array;\n    /**\n     *  array of clientHandles for all MonitoredItems of the subscription\n     *  identified by subscriptionId.\n     */\n    clientHandles: Uint32Array;\n    statusCode: StatusCode;\n}\n\nexport interface InternalNotification {\n    monitoredItemId?: number;\n    notification: QueueItem | StatusChangeNotification;\n    publishTime: Date;\n    start_tick: number;\n}\n\nexport interface InternalCreateMonitoredItemResult {\n    monitoredItem?: MonitoredItem;\n    monitoredItemCreateRequest: MonitoredItemCreateRequest;\n    createResult: MonitoredItemCreateResult;\n}\n\nexport interface MonitoredItemBase {\n    node: any | null;\n}\nexport type CreateMonitoredItemHook = (subscription: Subscription, monitoredItem: MonitoredItemBase) => Promise<StatusCode>;\nexport type DeleteMonitoredItemHook = (subscription: Subscription, monitoredItem: MonitoredItemBase) => Promise<StatusCode>;\n\nexport interface ServerCapabilitiesPartial {\n    maxMonitoredItems: UInt32;\n    maxMonitoredItemsPerSubscription: UInt32;\n}\n\n/**\n * The Subscription class used in the OPCUA server side.\n */\nexport class Subscription extends EventEmitter {\n    public static minimumPublishingInterval = 50; // fastest possible\n    public static defaultPublishingInterval = 1000; // one second\n    public static maximumPublishingInterval: number = 1000 * 60; // one minute\n    public static maxNotificationPerPublishHighLimit = 1000;\n    public static minimumLifetimeDuration = 5 * 1000; //  // we want 2 seconds minimum lifetime for any subscription\n    public static maximumLifetimeDuration = 60 * 60 * 1000; // 1 hour\n\n    /**\n     * maximum number of monitored item in a subscription to be used\n     * when serverCapacity.maxMonitoredItems and serverCapacity.maxMonitoredItemsPerSubscription are not set.\n     */\n    public static defaultMaxMonitoredItemCount = 20000;\n\n    /**\n     * @deprecated use serverCapacity.maxMonitoredItems and serverCapacity.maxMonitoredItemsPerSubscription instead\n     */\n    protected static get maxMonitoredItemCount() {\n        return Subscription.defaultMaxMonitoredItemCount;\n    }\n\n    public static registry = new ObjectRegistry();\n\n    public publishEngine?: IServerSidePublishEngine;\n    public id: number;\n    public priority: number;\n    /**\n     * the Subscription publishing interval\n     * @default 1000\n     */\n    public publishingInterval: number;\n    /**\n     * The keep alive count defines how many times the publish interval need to\n     * expires without having notifications available before the server send an\n     * empty message.\n     * OPCUA Spec says: a value of 0 is invalid.\n     * @default 10\n     *\n     */\n    public maxKeepAliveCount: number;\n    /**\n     * The life time count defines how many times the publish interval expires without\n     * having a connection to the client to deliver data.\n     * If the life time count reaches maxKeepAliveCount, the subscription will\n     * automatically terminate.\n     * OPCUA Spec: The life-time count shall be a minimum of three times the keep keep-alive count.\n     *\n     * Note: this has to be interpreted as without having a PublishRequest available\n     * @default 1\n     */\n    public lifeTimeCount: number;\n    /**\n     * The maximum number of notifications that the Client wishes to receive in a\n     * single Publish response. A value of zero indicates that there is no limit.\n     * The number of notifications per Publish is the sum of monitoredItems in the\n     * DataChangeNotification and events in the EventNotificationList.\n     *\n     * @property maxNotificationsPerPublish\n     * @default 0\n     */\n    public maxNotificationsPerPublish: number;\n    public publishingEnabled: boolean;\n    public subscriptionDiagnostics: SubscriptionDiagnosticsDataTypePriv;\n    public publishIntervalCount: number;\n    /**\n     *  number of monitored Item\n     */\n    public monitoredItemIdCounter: number;\n\n    private _state: SubscriptionState = -1 as SubscriptionState;\n    public set state(value: SubscriptionState) {\n        if (this._state !== value) {\n            this._state = value;\n            this.emit(\"stateChanged\", value);\n        }\n    }\n    public get state(): SubscriptionState {\n        return this._state;\n    }\n\n    public messageSent: boolean;\n    public $session?: ServerSession;\n\n    public get sessionId(): NodeId {\n        return this.$session ? this.$session.nodeId : NodeId.nullNodeId;\n    }\n\n    public get currentLifetimeCount(): number {\n        return this._life_time_counter;\n    }\n    public get currentKeepAliveCount(): number {\n        return this._keep_alive_counter;\n    }\n\n    private _life_time_counter: number;\n    private _keep_alive_counter = 0;\n    private _pending_notifications: Queue<InternalNotification>;\n    private _sent_notification_messages: NotificationMessage[];\n    private readonly _sequence_number_generator: SequenceNumberGenerator;\n    private readonly monitoredItems: { [key: number]: MonitoredItem };\n    private timerId: any;\n    private _hasUncollectedMonitoredItemNotifications = false;\n\n    private globalCounter: IGlobalMonitoredItemCounter;\n    private serverCapabilities: ServerCapabilitiesPartial;\n\n    constructor(options: SubscriptionOptions) {\n        super();\n\n        options = options || {};\n\n        Subscription.registry.register(this);\n\n        assert(this.sessionId instanceof NodeId, \"expecting a sessionId NodeId\");\n\n        this.publishEngine = options.publishEngine!;\n\n        this.id = options.id || INVALID_ID;\n\n        this.priority = options.priority || 0;\n\n        this.publishingInterval = _adjust_publishing_interval(options.publishingInterval);\n\n        this.maxKeepAliveCount = _adjust_maxKeepAliveCount(options.maxKeepAliveCount); // , this.publishingInterval);\n\n        this.resetKeepAliveCounter();\n\n        this.lifeTimeCount = _adjust_lifeTimeCount(options.lifeTimeCount || 0, this.maxKeepAliveCount, this.publishingInterval);\n\n        this.maxNotificationsPerPublish = _adjust_maxNotificationsPerPublish(options.maxNotificationsPerPublish);\n\n        this._life_time_counter = 0;\n        this.resetLifeTimeCounter();\n\n        // notification message that are ready to be sent to the client\n        this._pending_notifications = new Queue<InternalNotification>();\n\n        this._sent_notification_messages = [];\n\n        this._sequence_number_generator = new SequenceNumberGenerator();\n\n        // initial state of the subscription\n        this.state = SubscriptionState.CREATING;\n\n        this.publishIntervalCount = 0;\n\n        this.monitoredItems = {}; // monitored item map\n\n        this.monitoredItemIdCounter = 0;\n\n        this.publishingEnabled = _adjust_publishingEnable(options.publishingEnabled);\n\n        this.subscriptionDiagnostics = createSubscriptionDiagnostics(this);\n\n        // A boolean value that is set to TRUE to mean that either a NotificationMessage or a keep-alive\n        // Message has been sent on the Subscription. It is a flag that is used to ensure that either a\n        // NotificationMessage or a keep-alive Message is sent out the first time the publishing\n        // timer expires.\n        this.messageSent = false;\n\n        this.timerId = null;\n        this._start_timer();\n\n        debugLog(chalk.green(`creating subscription ${this.id}`));\n\n        this.serverCapabilities = options.serverCapabilities;\n        this.serverCapabilities.maxMonitoredItems =\n            this.serverCapabilities.maxMonitoredItems || Subscription.defaultMaxMonitoredItemCount;\n        this.serverCapabilities.maxMonitoredItemsPerSubscription =\n            this.serverCapabilities.maxMonitoredItemsPerSubscription || Subscription.defaultMaxMonitoredItemCount;\n        this.globalCounter = options.globalCounter;\n    }\n\n    public getSessionId(): NodeId {\n        return this.sessionId;\n    }\n\n    public toString(): string {\n        let str = \"Subscription:\\n\";\n        str += \"  subscriptionId          \" + this.id + \"\\n\";\n        str += \"  sessionId          \" + this.getSessionId().toString() + \"\\n\";\n\n        str += \"  publishingEnabled  \" + this.publishingEnabled + \"\\n\";\n        str += \"  maxKeepAliveCount  \" + this.maxKeepAliveCount + \"\\n\";\n        str += \"  publishingInterval \" + this.publishingInterval + \"\\n\";\n        str += \"  lifeTimeCount      \" + this.lifeTimeCount + \"\\n\";\n        str += \"  maxKeepAliveCount  \" + this.maxKeepAliveCount + \"\\n\";\n        return str;\n    }\n\n    /**\n     * modify subscription parameters\n     * @param param\n     */\n    public modify(param: ModifySubscriptionParameters): void {\n        // update diagnostic counter\n        this.subscriptionDiagnostics.modifyCount += 1;\n\n        const publishingInterval_old = this.publishingInterval;\n\n        param.requestedPublishingInterval = param.requestedPublishingInterval || 0;\n        param.requestedMaxKeepAliveCount = param.requestedMaxKeepAliveCount || this.maxKeepAliveCount;\n        param.requestedLifetimeCount = param.requestedLifetimeCount || this.lifeTimeCount;\n\n        this.publishingInterval = _adjust_publishing_interval(param.requestedPublishingInterval);\n        this.maxKeepAliveCount = _adjust_maxKeepAliveCount(param.requestedMaxKeepAliveCount);\n\n        this.lifeTimeCount = _adjust_lifeTimeCount(param.requestedLifetimeCount, this.maxKeepAliveCount, this.publishingInterval);\n\n        this.maxNotificationsPerPublish = _adjust_maxNotificationsPerPublish(param.maxNotificationsPerPublish || 0);\n        this.priority = param.priority || 0;\n\n        this.resetLifeTimeAndKeepAliveCounters();\n\n        if (publishingInterval_old !== this.publishingInterval) {\n            // todo\n        }\n        this._stop_timer();\n        this._start_timer();\n    }\n\n    /**\n     * set publishing mode\n     * @param publishingEnabled\n     */\n    public setPublishingMode(publishingEnabled: boolean): StatusCode {\n        this.publishingEnabled = !!publishingEnabled;\n        // update diagnostics\n        if (this.publishingEnabled) {\n            this.subscriptionDiagnostics.enableCount += 1;\n        } else {\n            this.subscriptionDiagnostics.disableCount += 1;\n        }\n\n        this.resetLifeTimeCounter();\n\n        if (!publishingEnabled && this.state !== SubscriptionState.CLOSED) {\n            this.state = SubscriptionState.NORMAL;\n        }\n        return StatusCodes.Good;\n    }\n\n    /**\n     * @private\n     */\n    public get keepAliveCounterHasExpired(): boolean {\n        return this._keep_alive_counter >= this.maxKeepAliveCount || this.state === SubscriptionState.LATE;\n    }\n\n    /**\n     * Reset the Lifetime Counter Variable to the value specified for the lifetime of a Subscription in\n     * the CreateSubscription Service( 5.13.2).\n     * @private\n     */\n    public resetLifeTimeCounter(): void {\n        this._life_time_counter = 0;\n    }\n\n    /**\n     * @private\n     */\n    public increaseLifeTimeCounter(): void {\n        this._life_time_counter += 1;\n        if (this._life_time_counter >= this.lifeTimeCount) {\n           this.emit(\"lifeTimeExpired\");\n        }\n        this.emit(\"lifeTimeCounterChanged\", this._life_time_counter);\n    }\n\n    /**\n     *  True if the subscription life time has expired.\n     *\n     */\n    public get lifeTimeHasExpired(): boolean {\n        assert(this.lifeTimeCount > 0);\n        return this._life_time_counter >= this.lifeTimeCount;\n    }\n\n    /**\n     * number of milliseconds before this subscription times out (lifeTimeHasExpired === true);\n     */\n    public get timeToExpiration(): number {\n        return (this.lifeTimeCount - this._life_time_counter) * this.publishingInterval;\n    }\n\n    public get timeToKeepAlive(): number {\n        return (this.maxKeepAliveCount - this._keep_alive_counter) * this.publishingInterval;\n    }\n\n    /**\n     * Terminates the subscription.\n     * Calling this method will also remove any monitored items.\n     *\n     */\n    public terminate(): void {\n        assert(arguments.length === 0);\n        debugLog(\"Subscription#terminate status\", SubscriptionState[this.state]);\n\n        if (this.state === SubscriptionState.CLOSED) {\n            // todo verify if asserting is required here\n            return;\n        }\n\n        // stop timer\n        this._stop_timer();\n\n        debugLog(\"terminating Subscription  \", this.id, \" with \", this.monitoredItemCount, \" monitored items\");\n\n        // dispose all monitoredItem\n        const keys = Object.keys(this.monitoredItems);\n\n        for (const key of keys) {\n            const status = this.removeMonitoredItem(parseInt(key, 10));\n            assert(status === StatusCodes.Good);\n        }\n        assert(this.monitoredItemCount === 0);\n\n        if (this.$session) {\n            this.$session._unexposeSubscriptionDiagnostics(this);\n        }\n        this.state = SubscriptionState.CLOSED;\n\n        /**\n         * notify the subscription owner that the subscription has been terminated.\n         * @event \"terminated\"\n         */\n        this.emit(\"terminated\");\n        if (this.publishEngine) {\n            this.publishEngine.on_close_subscription(this);\n        }\n    }\n\n    public setTriggering(\n        triggeringItemId: number,\n        linksToAdd: number[] | null,\n        linksToRemove: number[] | null\n    ): { statusCode: StatusCode; addResults: StatusCode[]; removeResults: StatusCode[] } {\n        /** Bad_NothingToDo, Bad_TooManyOperations,Bad_SubscriptionIdInvalid, Bad_MonitoredItemIdInvalid */\n        linksToAdd = linksToAdd || [];\n        linksToRemove = linksToRemove || [];\n\n        if (linksToAdd.length === 0 && linksToRemove.length === 0) {\n            return { statusCode: StatusCodes.BadNothingToDo, addResults: [], removeResults: [] };\n        }\n        const triggeringItem = this.getMonitoredItem(triggeringItemId);\n\n        const monitoredItemsToAdd = linksToAdd.map((id) => this.getMonitoredItem(id));\n        const monitoredItemsToRemove = linksToRemove.map((id) => this.getMonitoredItem(id));\n\n        if (!triggeringItem) {\n            const removeResults1: StatusCode[] = monitoredItemsToRemove.map((m) =>\n                m ? StatusCodes.Good : StatusCodes.BadMonitoredItemIdInvalid\n            );\n            const addResults1: StatusCode[] = monitoredItemsToAdd.map((m) =>\n                m ? StatusCodes.Good : StatusCodes.BadMonitoredItemIdInvalid\n            );\n            return {\n                statusCode: StatusCodes.BadMonitoredItemIdInvalid,\n\n                addResults: addResults1,\n                removeResults: removeResults1\n            };\n        }\n        //\n        // note: it seems that CTT imposed that we do remove before add\n        const removeResults = monitoredItemsToRemove.map((m) =>\n            !m ? StatusCodes.BadMonitoredItemIdInvalid : triggeringItem.removeLinkItem(m.monitoredItemId)\n        );\n        const addResults = monitoredItemsToAdd.map((m) =>\n            !m ? StatusCodes.BadMonitoredItemIdInvalid : triggeringItem.addLinkItem(m.monitoredItemId)\n        );\n\n        const statusCode: StatusCode = StatusCodes.Good;\n\n        // do binding\n\n        return {\n            statusCode,\n\n            addResults,\n            removeResults\n        };\n    }\n    public dispose(): void {\n        if (doDebug) {\n            debugLog(\"Subscription#dispose\", this.id, this.monitoredItemCount);\n        }\n\n        assert(this.monitoredItemCount === 0, \"MonitoredItems haven't been  deleted first !!!\");\n        assert(this.timerId === null, \"Subscription timer haven't been terminated\");\n\n        if (this.subscriptionDiagnostics) {\n            (this.subscriptionDiagnostics as SubscriptionDiagnosticsDataTypePriv).$subscription = null as any as Subscription;\n        }\n\n        this.publishEngine = undefined;\n        this._pending_notifications.clear();\n        this._sent_notification_messages = [];\n\n        this.$session = undefined;\n        this.removeAllListeners();\n\n        Subscription.registry.unregister(this);\n    }\n\n    public get aborted(): boolean {\n        const session = this.$session;\n        if (!session) {\n            return true;\n        }\n        return session.aborted;\n    }\n\n    /**\n     * number of pending notifications\n     */\n    public get pendingNotificationsCount(): number {\n        return this._pending_notifications ? this._pending_notifications.size : 0;\n    }\n\n    /**\n     * is 'true' if there are pending notifications for this subscription. (i.e moreNotifications)\n     */\n    public get hasPendingNotifications(): boolean {\n        return this.pendingNotificationsCount > 0;\n    }\n\n    /**\n     * number of sent notifications\n     */\n    public get sentNotificationMessageCount(): number {\n        return this._sent_notification_messages.length;\n    }\n\n    /**\n     * @internal\n     */\n    public _flushSentNotifications(): NotificationMessage[] {\n        const tmp = this._sent_notification_messages;\n        this._sent_notification_messages = [];\n        return tmp;\n    }\n    /**\n     * number of monitored items handled by this subscription\n     */\n    public get monitoredItemCount(): number {\n        return Object.keys(this.monitoredItems).length;\n    }\n\n    /**\n     * number of disabled monitored items.\n     */\n    public get disabledMonitoredItemCount(): number {\n        return Object.values(this.monitoredItems).reduce((cumul: any, monitoredItem: MonitoredItem) => {\n            return cumul + (monitoredItem.monitoringMode === MonitoringMode.Disabled ? 1 : 0);\n        }, 0);\n    }\n\n    /**\n     * The number of unacknowledged messages saved in the republish queue.\n     */\n    public get unacknowledgedMessageCount(): number {\n        return this.subscriptionDiagnostics.unacknowledgedMessageCount;\n    }\n\n    /**\n     * adjust monitored item sampling interval\n     *  - an samplingInterval ===0 means that we use a event-base model ( no sampling)\n     *  - otherwise the sampling is adjusted\n     * @private\n     */\n    public adjustSamplingInterval(samplingInterval: number, node: BaseNode): number {\n        if (samplingInterval < 0) {\n            // - The value -1 indicates that the default sampling interval defined by the publishing\n            //   interval of the Subscription is requested.\n            // - Any negative number is interpreted as -1.\n            samplingInterval = this.publishingInterval;\n        } else if (samplingInterval === 0) {\n            // OPCUA 1.0.3 Part 4 - 5.12.1.2\n            // The value 0 indicates that the Server should use the fastest practical rate.\n\n            // The fastest supported sampling interval may be equal to 0, which indicates\n            // that the data item is exception-based rather than being sampled at some period.\n            // An exception-based model means that the underlying system does not require\n            // sampling and reports data changes.\n\n            const dataValueSamplingInterval = node.readAttribute(\n                SessionContext.defaultContext,\n                AttributeIds.MinimumSamplingInterval\n            );\n\n            // TODO if attributeId === AttributeIds.Value : sampling interval required here\n            if (dataValueSamplingInterval.statusCode === StatusCodes.Good) {\n                // node provides a Minimum sampling interval ...\n                samplingInterval = dataValueSamplingInterval.value.value;\n                assert(samplingInterval >= 0 && samplingInterval <= MonitoredItem.maximumSamplingInterval);\n\n                // note : at this stage, a samplingInterval===0 means that the data item is really exception-based\n            }\n        } else if (samplingInterval < MonitoredItem.minimumSamplingInterval) {\n            samplingInterval = MonitoredItem.minimumSamplingInterval;\n        } else if (samplingInterval > MonitoredItem.maximumSamplingInterval) {\n            // If the requested samplingInterval is higher than the\n            // maximum sampling interval supported by the Server, the maximum sampling\n            // interval is returned.\n            samplingInterval = MonitoredItem.maximumSamplingInterval;\n        }\n\n        const node_minimumSamplingInterval =\n            node && (node as any).minimumSamplingInterval ? (node as any).minimumSamplingInterval : 0;\n\n        samplingInterval = Math.max(samplingInterval, node_minimumSamplingInterval);\n\n        return samplingInterval;\n    }\n\n    /**\n     * create a monitored item\n     * @param addressSpace - address space\n     * @param timestampsToReturn  - the timestamp to return\n     * @param monitoredItemCreateRequest - the parameters describing the monitored Item to create\n     */\n    public preCreateMonitoredItem(\n        addressSpace: AddressSpace,\n        timestampsToReturn: TimestampsToReturn,\n        monitoredItemCreateRequest: MonitoredItemCreateRequest\n    ): InternalCreateMonitoredItemResult {\n        assert(monitoredItemCreateRequest instanceof MonitoredItemCreateRequest);\n\n        function handle_error(statusCode: StatusCode): InternalCreateMonitoredItemResult {\n            return {\n                createResult: new MonitoredItemCreateResult({ statusCode }),\n                monitoredItemCreateRequest\n            };\n        }\n\n        const itemToMonitor = monitoredItemCreateRequest.itemToMonitor;\n\n        const node = addressSpace.findNode(itemToMonitor.nodeId);\n        if (!node) {\n            return handle_error(StatusCodes.BadNodeIdUnknown);\n        }\n\n        if (itemToMonitor.attributeId === AttributeIds.Value && !(node.nodeClass === NodeClass.Variable)) {\n            // AttributeIds.Value is only valid for monitoring value of UAVariables.\n            return handle_error(StatusCodes.BadAttributeIdInvalid);\n        }\n\n        if (itemToMonitor.attributeId === AttributeIds.INVALID) {\n            return handle_error(StatusCodes.BadAttributeIdInvalid);\n        }\n\n        if (!itemToMonitor.indexRange.isValid()) {\n            return handle_error(StatusCodes.BadIndexRangeInvalid);\n        }\n\n        // check dataEncoding applies only on Values\n        if (itemToMonitor.dataEncoding.name && itemToMonitor.attributeId !== AttributeIds.Value) {\n            return handle_error(StatusCodes.BadDataEncodingInvalid);\n        }\n\n        // check dataEncoding\n        if (!isValidDataEncoding(itemToMonitor.dataEncoding)) {\n            return handle_error(StatusCodes.BadDataEncodingUnsupported);\n        }\n\n        // check that item can be read by current user session\n\n        // filter\n        const requestedParameters = monitoredItemCreateRequest.requestedParameters;\n        const filter = requestedParameters.filter;\n        const statusCodeFilter = validateFilter(filter, itemToMonitor, node);\n        if (statusCodeFilter !== StatusCodes.Good) {\n            return handle_error(statusCodeFilter);\n        }\n\n        // do we have enough room for new monitored items ?\n        if (this.monitoredItemCount >= this.serverCapabilities.maxMonitoredItemsPerSubscription) {\n            return handle_error(StatusCodes.BadTooManyMonitoredItems);\n        }\n\n        if (this.globalCounter.totalMonitoredItemCount >= this.serverCapabilities.maxMonitoredItems) {\n            return handle_error(StatusCodes.BadTooManyMonitoredItems);\n        }\n\n        const createResult = this._createMonitoredItemStep2(timestampsToReturn, monitoredItemCreateRequest, node);\n\n        assert(createResult.statusCode === StatusCodes.Good);\n\n        const monitoredItem = this.getMonitoredItem(createResult.monitoredItemId);\n        // istanbul ignore next\n        if (!monitoredItem) {\n            throw new Error(\"internal error\");\n        }\n\n        // TODO: fix old way to set node. !!!!\n        monitoredItem.setNode(node);\n\n        this.emit(\"monitoredItem\", monitoredItem, itemToMonitor);\n\n        return { monitoredItem, monitoredItemCreateRequest, createResult };\n    }\n\n    public async applyOnMonitoredItem(functor: (monitoredItem: MonitoredItem) => Promise<void>): Promise<void> {\n        for (const m of Object.values(this.monitoredItems)) {\n            await functor(m);\n        }\n    }\n\n    public postCreateMonitoredItem(\n        monitoredItem: MonitoredItem,\n        monitoredItemCreateRequest: MonitoredItemCreateRequest,\n        createResult: MonitoredItemCreateResult\n    ): void {\n        this._createMonitoredItemStep3(monitoredItem, monitoredItemCreateRequest);\n    }\n\n    public createMonitoredItem(\n        addressSpace: AddressSpace,\n        timestampsToReturn: TimestampsToReturn,\n        monitoredItemCreateRequest: MonitoredItemCreateRequest\n    ): MonitoredItemCreateResult {\n        const { monitoredItem, createResult } = this.preCreateMonitoredItem(\n            addressSpace,\n            timestampsToReturn,\n            monitoredItemCreateRequest\n        );\n        this.postCreateMonitoredItem(monitoredItem!, monitoredItemCreateRequest, createResult);\n        return createResult;\n    }\n    /**\n     * get a monitoredItem by Id.\n     * @param monitoredItemId : the id of the monitored item to get.\n     * @return the monitored item matching monitoredItemId\n     */\n    public getMonitoredItem(monitoredItemId: number): MonitoredItem | null {\n        return this.monitoredItems[monitoredItemId] || null;\n    }\n\n    /**\n     * remove a monitored Item from the subscription.\n     * @param monitoredItemId : the id of the monitored item to get.\n     */\n    public removeMonitoredItem(monitoredItemId: number): StatusCode {\n        debugLog(\"Removing monitoredIem \", monitoredItemId);\n        if (!Object.prototype.hasOwnProperty.call(this.monitoredItems, monitoredItemId.toString())) {\n            return StatusCodes.BadMonitoredItemIdInvalid;\n        }\n\n        const monitoredItem = this.monitoredItems[monitoredItemId];\n\n        monitoredItem.terminate();\n\n        monitoredItem.dispose();\n\n        /**\n         *\n         * notify that a monitored item has been removed from the subscription\n         * @param monitoredItem {MonitoredItem}\n         */\n        this.emit(\"removeMonitoredItem\", monitoredItem);\n\n        delete this.monitoredItems[monitoredItemId];\n        this.globalCounter.totalMonitoredItemCount -= 1;\n\n        this._removePendingNotificationsFor(monitoredItemId);\n        // flush pending notifications\n        // assert(this._pending_notifications.size === 0);\n        return StatusCodes.Good;\n    }\n\n    /**\n     * rue if monitored Item have uncollected Notifications\n     */\n    public get hasUncollectedMonitoredItemNotifications(): boolean {\n        if (this._hasUncollectedMonitoredItemNotifications) {\n            return true;\n        }\n        const keys = Object.keys(this.monitoredItems);\n        const n = keys.length;\n        for (let i = 0; i < n; i++) {\n            const key = parseInt(keys[i], 10);\n            const monitoredItem = this.monitoredItems[key];\n            if (monitoredItem.hasMonitoredItemNotifications) {\n                this._hasUncollectedMonitoredItemNotifications = true;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public get subscriptionId(): number {\n        return this.id;\n    }\n\n    public getMessageForSequenceNumber(sequenceNumber: number): NotificationMessage | null {\n        const notification_message = this._sent_notification_messages.find((e) => e.sequenceNumber === sequenceNumber);\n        return notification_message || null;\n    }\n\n    /**\n     * returns true if the notification has expired\n     * @param notification\n     */\n    public notificationHasExpired(notification: { start_tick: number }): boolean {\n        assert(Object.prototype.hasOwnProperty.call(notification, \"start_tick\"));\n        assert(isFinite(notification.start_tick + this.maxKeepAliveCount));\n        return notification.start_tick + this.maxKeepAliveCount < this.publishIntervalCount;\n    }\n\n    /**\n     *  returns in an array the sequence numbers of the notifications that have been sent\n     *  and that haven't been acknowledged yet.\n     */\n    public getAvailableSequenceNumbers(): number[] {\n        const availableSequenceNumbers = _getSequenceNumbers(this._sent_notification_messages);\n        return availableSequenceNumbers;\n    }\n\n    /**\n     * acknowledges a notification identified by its sequence number\n     */\n    public acknowledgeNotification(sequenceNumber: number): StatusCode {\n        debugLog(\"acknowledgeNotification \", sequenceNumber);\n        let foundIndex = -1;\n        this._sent_notification_messages.forEach((e: NotificationMessage, index: number) => {\n            if (e.sequenceNumber === sequenceNumber) {\n                foundIndex = index;\n            }\n        });\n\n        if (foundIndex === -1) {\n            if (doDebug) {\n                debugLog(chalk.red(\"acknowledging sequence FAILED !!! \"), chalk.cyan(sequenceNumber.toString()));\n            }\n            return StatusCodes.BadSequenceNumberUnknown;\n        } else {\n            if (doDebug) {\n                debugLog(chalk.yellow(\"acknowledging sequence \"), chalk.cyan(sequenceNumber.toString()));\n            }\n            this._sent_notification_messages.splice(foundIndex, 1);\n            this.subscriptionDiagnostics.unacknowledgedMessageCount--;\n            return StatusCodes.Good;\n        }\n    }\n\n    /**\n     * getMonitoredItems is used to get information about monitored items of a subscription.Its intended\n     * use is defined in Part 4. This method is the implementation of the Standard OPCUA GetMonitoredItems Method.\n     * from spec:\n     * This method can be used to get the  list of monitored items in a subscription if CreateMonitoredItems\n     * failed due to a network interruption and the client does not know if the creation succeeded in the server.\n     *\n     */\n    public getMonitoredItems(): GetMonitoredItemsResult {\n        const monitoredItems = Object.keys(this.monitoredItems);\n        const monitoredItemCount = monitoredItems.length;\n        const result: GetMonitoredItemsResult = {\n            clientHandles: new Uint32Array(monitoredItemCount),\n            serverHandles: new Uint32Array(monitoredItemCount),\n            statusCode: StatusCodes.Good\n        };\n        for (let index = 0; index < monitoredItemCount; index++) {\n            const monitoredItemId = monitoredItems[index];\n            const serverHandle = parseInt(monitoredItemId, 10);\n            const monitoredItem = this.getMonitoredItem(serverHandle)!;\n            result.clientHandles[index] = monitoredItem.clientHandle;\n            // TODO:  serverHandle is defined anywhere in the OPCUA Specification 1.02\n            //        I am not sure what shall be reported for serverHandle...\n            //        using monitoredItem.monitoredItemId instead...\n            //        May be a clarification in the OPCUA Spec is required.\n            result.serverHandles[index] = serverHandle;\n        }\n        return result;\n    }\n\n    /**\n     * @private\n     */\n    public async resendInitialValues(): Promise<void> {\n        const promises: Promise<void>[] = [];\n        for (const monitoredItem of Object.values(this.monitoredItems)) {\n            assert(monitoredItem.clientHandle !== 4294967295);\n            promises.push(monitoredItem.resendInitialValues());\n        }\n        await Promise.all(promises);\n        this._harvestMonitoredItems();\n    }\n\n    /**\n     * @private\n     */\n    public notifyTransfer(): void {\n        // OPCUA UA Spec 1.0.3 : part 3 - page 82 - 5.13.7 TransferSubscriptions:\n        // If the Server transfers the Subscription to the new Session, the Server shall issue\n        // a StatusChangeNotification notificationMessage with the status code\n        // Good_SubscriptionTransferred to the old Session.\n        debugLog(chalk.red(\" Subscription => Notifying Transfer                                  \"));\n\n        const notificationData = new StatusChangeNotification({\n            status: StatusCodes.GoodSubscriptionTransferred\n        });\n\n        if (this.publishEngine!.pendingPublishRequestCount) {\n            // the GoodSubscriptionTransferred can be processed immediately\n            this._addNotificationMessage(notificationData);\n            debugLog(chalk.red(\"pendingPublishRequestCount\"), this.publishEngine?.pendingPublishRequestCount);\n            this._publish_pending_notifications();\n        } else {\n            debugLog(chalk.red(\"Cannot  send GoodSubscriptionTransferred => lets create a TransferredSubscription \"));\n            const ts = new TransferredSubscription({\n                generator: this._sequence_number_generator,\n                id: this.id,\n                publishEngine: this.publishEngine\n            });\n\n            ts._pending_notification = notificationData;\n            (this.publishEngine as any)._closed_subscriptions.push(ts);\n        }\n    }\n\n    /**\n     *\n     *  the server invokes the resetLifeTimeAndKeepAliveCounters method of the subscription\n     *  when the server  has send a Publish Response, so that the subscription\n     *  can reset its life time counter.\n     *\n     * @private\n     */\n    public resetLifeTimeAndKeepAliveCounters(): void {\n        this.resetLifeTimeCounter();\n        this.resetKeepAliveCounter();\n    }\n\n    private _updateCounters(notificationMessage: NotificationMessage) {\n        for (const notificationData of notificationMessage.notificationData || []) {\n            // update diagnostics\n            if (notificationData instanceof DataChangeNotification) {\n                const nbNotifs = notificationData.monitoredItems!.length;\n                this.subscriptionDiagnostics.dataChangeNotificationsCount += nbNotifs;\n                this.subscriptionDiagnostics.notificationsCount += nbNotifs;\n            } else if (notificationData instanceof EventNotificationList) {\n                const nbNotifs = notificationData.events!.length;\n                this.subscriptionDiagnostics.eventNotificationsCount += nbNotifs;\n                this.subscriptionDiagnostics.notificationsCount += nbNotifs;\n            } else {\n                assert(notificationData instanceof StatusChangeNotification);\n                // TODO\n                // note: :there is no way to count StatusChangeNotifications in opcua yet.\n            }\n        }\n    }\n    /**\n     *  _publish_pending_notifications send a \"notification\" event:\n     *\n     * @private\n     * @precondition\n     *     - pendingPublishRequestCount > 0\n     */\n    public _publish_pending_notifications(): void {\n        const publishEngine = this.publishEngine!;\n        const subscriptionId = this.id;\n        // preconditions\n        assert(publishEngine!.pendingPublishRequestCount > 0);\n        assert(this.hasPendingNotifications);\n\n        const notificationMessage = this._popNotificationToSend();\n        if (notificationMessage.notificationData!.length === 0) {\n            return; // nothing to do\n        }\n        const moreNotifications = this.hasPendingNotifications;\n\n        this.emit(\"notification\", notificationMessage);\n        // Update counters ....\n        this._updateCounters(notificationMessage);\n\n        assert(Object.prototype.hasOwnProperty.call(notificationMessage, \"sequenceNumber\"));\n        assert(Object.prototype.hasOwnProperty.call(notificationMessage, \"notificationData\"));\n        // update diagnostics\n        this.subscriptionDiagnostics.publishRequestCount += 1;\n\n        const response = new PublishResponse({\n            moreNotifications,\n            notificationMessage: {\n                notificationData: notificationMessage.notificationData,\n                sequenceNumber: this._get_next_sequence_number()\n            },\n            subscriptionId\n        });\n\n        this._sent_notification_messages.push(response.notificationMessage);\n\n        // get available sequence number;\n        const availableSequenceNumbers = this.getAvailableSequenceNumbers();\n        assert(\n            !response.notificationMessage ||\n                availableSequenceNumbers[availableSequenceNumbers.length - 1] === response.notificationMessage.sequenceNumber\n        );\n        response.availableSequenceNumbers = availableSequenceNumbers;\n\n        publishEngine._send_response(this, response);\n\n        this.messageSent = true;\n\n        this.subscriptionDiagnostics.unacknowledgedMessageCount++;\n\n        this.resetLifeTimeAndKeepAliveCounters();\n\n        if (doDebug) {\n            debugLog(\n                \"Subscription sending a notificationMessage subscriptionId=\",\n                subscriptionId,\n                \"sequenceNumber = \",\n                notificationMessage.sequenceNumber.toString(),\n                notificationMessage.notificationData?.map((x) => x?.constructor.name).join(\" \")\n            );\n            // debugLog(notificationMessage.toString());\n        }\n\n        if (this.state !== SubscriptionState.CLOSED) {\n            assert(notificationMessage.notificationData!.length > 0, \"We are not expecting a keep-alive message here\");\n            this.state = SubscriptionState.NORMAL;\n            debugLog(\"subscription \" + this.id + chalk.bgYellow(\" set to NORMAL\"));\n        }\n    }\n\n    public process_subscription(): void {\n        assert(this.publishEngine!.pendingPublishRequestCount > 0);\n\n        if (!this.publishingEnabled) {\n            // no publish to do, except keep alive\n            debugLog(\"    -> no publish to do, except keep alive\");\n            this._process_keepAlive();\n            return;\n        }\n\n        if (!this.hasPendingNotifications && this.hasUncollectedMonitoredItemNotifications) {\n            // collect notification from monitored items\n            this._harvestMonitoredItems();\n        }\n\n        // let process them first\n        if (this.hasPendingNotifications) {\n            this._publish_pending_notifications();\n\n            if (this.state === SubscriptionState.NORMAL && this.hasPendingNotifications) {\n                // istanbul ignore next\n                if (doDebug) {\n                    debugLog(\"    -> pendingPublishRequestCount > 0 \" + \"&& normal state => re-trigger tick event immediately \");\n                }\n\n                // let process an new publish request\n                setImmediate(this._tick.bind(this));\n            }\n        } else {\n            this._process_keepAlive();\n        }\n    }\n\n    public _get_future_sequence_number(): number {\n        return this._sequence_number_generator ? this._sequence_number_generator.future() : 0;\n    }\n\n    private _process_keepAlive() {\n        this.increaseKeepAliveCounter();\n\n        if (this.keepAliveCounterHasExpired) {\n            debugLog(`     ->  _process_keepAlive => keepAliveCounterHasExpired`);\n            if (this._sendKeepAliveResponse()) {\n                this.resetLifeTimeAndKeepAliveCounters();\n            } else {\n                debugLog(\n                    \"     -> subscription.state === LATE , \" +\n                        \"because keepAlive Response cannot be send due to lack of PublishRequest\"\n                );\n                if (this.messageSent || this.keepAliveCounterHasExpired) {\n                    this.state = SubscriptionState.LATE;\n                }\n            }\n        }\n    }\n\n    private _stop_timer() {\n        if (this.timerId) {\n            debugLog(chalk.bgWhite.blue(\"Subscription#_stop_timer subscriptionId=\"), this.id);\n            clearInterval(this.timerId);\n            this.timerId = null;\n        }\n    }\n\n    private _start_timer() {\n        debugLog(\n            chalk.bgWhite.blue(\"Subscription#_start_timer  subscriptionId=\"),\n            this.id,\n            \" publishingInterval = \",\n            this.publishingInterval\n        );\n\n        assert(this.timerId === null);\n        // from the spec:\n        // When a Subscription is created, the first Message is sent at the end of the first publishing cycle to\n        // inform the Client that the Subscription is operational. A NotificationMessage is sent if there are\n        // Notifications ready to be reported. If there are none, a keep-alive Message is sent instead that\n        // contains a sequence number of 1, indicating that the first NotificationMessage has not yet been sent.\n        // This is the only time a keep-alive Message is sent without waiting for the maximum keep-alive count\n        // to be reached, as specified in (f) above.\n\n        // make sure that a keep-alive Message will be send at the end of the first publishing cycle\n        // if there are no Notifications ready.\n        this._keep_alive_counter = 0; // this.maxKeepAliveCount;\n        assert(this.messageSent === false);\n        assert(this.state === SubscriptionState.CREATING);\n\n        assert(this.publishingInterval >= Subscription.minimumPublishingInterval);\n        this.timerId = setInterval(this._tick.bind(this), this.publishingInterval);\n    }\n\n    // counter\n    private _get_next_sequence_number(): number {\n        return this._sequence_number_generator ? this._sequence_number_generator.next() : 0;\n    }\n\n    /**\n     * @private\n     */\n    private _tick() {\n        // istanbul ignore next\n        if (doDebug) {\n            debugLog(`Subscription#_tick id ${this.id} aborted=${this.aborted} state=${SubscriptionState[this.state]}`);\n        }\n        if (this.state === SubscriptionState.CLOSED) {\n            warningLog(`Warning: Subscription#_tick id ${this.id}  called while subscription is CLOSED`);\n            return;\n        }\n\n        this.discardOldSentNotifications();\n\n        // istanbul ignore next\n        if (doDebug) {\n            debugLog(\n                t(new Date()) + \"  \" + this._life_time_counter + \"/\" + this.lifeTimeCount + chalk.cyan(\"   Subscription#_tick\"),\n                \"  processing subscriptionId=\",\n                this.id,\n                \"hasUncollectedMonitoredItemNotifications = \",\n                this.hasUncollectedMonitoredItemNotifications,\n                \" publishingIntervalCount =\",\n                this.publishIntervalCount\n            );\n        }\n\n        // give a chance to the publish engine to cancel timed out publish requests\n        this.publishEngine!._on_tick();\n\n        this.publishIntervalCount += 1;\n\n        if (this.state === SubscriptionState.LATE) {\n            this.increaseLifeTimeCounter();\n        }\n\n        if (this.lifeTimeHasExpired) {\n            /* istanbul ignore next */\n            doDebug && debugLog(chalk.red.bold(`Subscription ${this.id} has expired !!!!! => Terminating`));\n\n            /**\n             * notify the subscription owner that the subscription has expired by exceeding its life time.\n             * @event expired\n             *\n             */\n            this.emit(\"expired\");\n\n            // notify new terminated status only when subscription has timeout.\n            doDebug && debugLog(\"adding StatusChangeNotification notification message for BadTimeout subscription = \", this.id);\n            this._addNotificationMessage(new StatusChangeNotification({ status: StatusCodes.BadTimeout }));\n\n            // kill timer and delete monitored items and transfer pending notification messages\n            this.terminate();\n\n            return;\n        }\n\n        const publishEngine = this.publishEngine!;\n\n        // istanbul ignore next\n        doDebug && debugLog(\"Subscription#_tick  self._pending_notifications= \", this._pending_notifications.size);\n\n        if (\n            publishEngine.pendingPublishRequestCount === 0 &&\n            (this.hasPendingNotifications || this.hasUncollectedMonitoredItemNotifications)\n        ) {\n            // istanbul ignore next\n            doDebug &&\n                debugLog(\n                    \"subscription set to LATE  hasPendingNotifications = \",\n                    this.hasPendingNotifications,\n                    \" hasUncollectedMonitoredItemNotifications =\",\n                    this.hasUncollectedMonitoredItemNotifications\n                );\n\n            this.state = SubscriptionState.LATE;\n            return;\n        }\n\n        if (publishEngine.pendingPublishRequestCount > 0) {\n            if (this.hasPendingNotifications) {\n                // simply pop pending notification and send it\n                this.process_subscription();\n            } else if (this.hasUncollectedMonitoredItemNotifications) {\n                this.process_subscription();\n            } else {\n                this._process_keepAlive();\n            }\n        } else {\n            if (this.state !== SubscriptionState.LATE) {\n                this._process_keepAlive();\n            } else {\n                this.resetKeepAliveCounter();\n            }\n        }\n    }\n\n    /**\n     * @private\n     */\n    private _sendKeepAliveResponse(): boolean {\n        const future_sequence_number = this._get_future_sequence_number();\n\n        if (this.publishEngine!.send_keep_alive_response(this.id, future_sequence_number)) {\n            this.messageSent = true;\n            // istanbul ignore next\n            doDebug &&\n                debugLog(\n                    `    -> Subscription#_sendKeepAliveResponse subscriptionId ${this.id} future_sequence_number ${future_sequence_number}`\n                );\n            /**\n             * notify the subscription owner that a keepalive message has to be sent.\n             * @event keepalive\n             *\n             */\n            this.emit(\"keepalive\", future_sequence_number);\n            this.state = SubscriptionState.KEEPALIVE;\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Reset the Lifetime Counter Variable to the value specified for the lifetime of a Subscription in\n     * the CreateSubscription Service( 5.13.2).\n     * @private\n     */\n    private resetKeepAliveCounter(): void {\n        this._keep_alive_counter = 0;\n\n        // istanbul ignore next\n        doDebug &&\n            debugLog(\n                \"     -> subscriptionId\",\n                this.id,\n                \" Resetting keepAliveCounter = \",\n                this._keep_alive_counter,\n                this.maxKeepAliveCount\n            );\n    }\n\n    /**\n     * @private\n     */\n    private increaseKeepAliveCounter() {\n        this._keep_alive_counter += 1;\n\n        // istanbul ignore next\n        doDebug &&\n            debugLog(\n                \"     -> subscriptionId\",\n                this.id,\n                \" Increasing keepAliveCounter = \",\n                this._keep_alive_counter,\n                this.maxKeepAliveCount\n            );\n    }\n\n    /**\n     * @private\n     */\n    private _addNotificationMessage(notificationData: QueueItem | StatusChangeNotification, monitoredItemId?: number) {\n        // istanbul ignore next\n        doDebug && debugLog(chalk.yellow(\"Subscription#_addNotificationMessage\"), notificationData.toString());\n\n        this._pending_notifications.push({\n            monitoredItemId,\n            notification: notificationData,\n            publishTime: new Date(),\n            start_tick: this.publishIntervalCount\n        });\n    }\n\n    /**\n     * @internal\n     * @param monitoredItemId\n     */\n    private _removePendingNotificationsFor(monitoredItemId: number) {\n        const nbRemovedNotification = this._pending_notifications.filterOut((e) => e.monitoredItemId === monitoredItemId);\n        doDebug && debugLog(`Removed ${nbRemovedNotification} notifications`);\n    }\n    /**\n     * Extract the next Notification that is ready to be sent to the client.\n     * @return the Notification to send._pending_notifications\n     */\n    private _popNotificationToSend(): NotificationMessage {\n        assert(this._pending_notifications.size > 0);\n\n        const notificationMessage = new NotificationMessage({\n            sequenceNumber: 0xffffffff,\n            notificationData: [],\n            publishTime: new Date()\n        }); //\n\n        const dataChangeNotifications: DataChangeNotification = new DataChangeNotification({\n            monitoredItems: []\n        });\n        const eventNotificationList: EventNotificationList = new EventNotificationList({\n            events: []\n        });\n\n        let statusChangeNotification: StatusChangeNotification | undefined;\n\n        let i = 0;\n        let hasEventFieldList = 0;\n        let hasMonitoredItemNotification = 0;\n        const m = this.maxNotificationsPerPublish;\n        while (i < m && this._pending_notifications.size > 0) {\n            if (hasEventFieldList || hasMonitoredItemNotification) {\n                const notification1 = this._pending_notifications.first()!.notification;\n                if (notification1 instanceof StatusChangeNotification) {\n                    break;\n                }\n            }\n            const notification = this._pending_notifications.shift()!.notification;\n            if (notification instanceof MonitoredItemNotification) {\n                assert(notification.clientHandle !== 4294967295);\n                dataChangeNotifications.monitoredItems!.push(notification);\n                hasMonitoredItemNotification = 1;\n            } else if (notification instanceof EventFieldList) {\n                eventNotificationList.events!.push(notification);\n                hasEventFieldList = 1;\n            } else if (notification instanceof StatusChangeNotification) {\n                // to do\n                statusChangeNotification = notification;\n                break;\n            }\n            i += 1;\n        }\n\n        if (dataChangeNotifications.monitoredItems!.length) {\n            notificationMessage.notificationData!.push(dataChangeNotifications);\n        }\n        if (eventNotificationList.events!.length) {\n            notificationMessage.notificationData!.push(eventNotificationList);\n        }\n        if (statusChangeNotification) {\n            notificationMessage.notificationData!.push(statusChangeNotification);\n        }\n        return notificationMessage;\n    }\n\n    /**\n     * discardOldSentNotification find all sent notification message that have expired keep-alive\n     * and destroy them.\n     * @private\n     *\n     * Subscriptions maintain a retransmission queue of sent  NotificationMessages.\n     * NotificationMessages are retained in this queue until they are acknowledged or until they have\n     * been in the queue for a minimum of one keep-alive interval.\n     *\n     */\n    private discardOldSentNotifications() {\n        // Sessions maintain a retransmission queue of sent NotificationMessages. NotificationMessages\n        // are retained in this queue until they are acknowledged. The Session shall maintain a\n        // retransmission queue size of at least two times the number of Publish requests per Session the\n        // Server supports.  Clients are required to acknowledge NotificationMessages as they are received. In the\n        // case of a retransmission queue overflow, the oldest sent NotificationMessage gets deleted. If a\n        // Subscription is transferred to another Session, the queued NotificationMessages for this\n        // Subscription are moved from the old to the new Session.\n        if (maxNotificationMessagesInQueue <= this._sent_notification_messages.length) {\n            doDebug && debugLog(\"discardOldSentNotifications = \", this._sent_notification_messages.length);\n            this._sent_notification_messages.splice(this._sent_notification_messages.length - maxNotificationMessagesInQueue);\n        }\n    }\n\n    /**\n     * @param timestampsToReturn\n     * @param monitoredItemCreateRequest\n     * @param node\n     * @private\n     */\n    private _createMonitoredItemStep2(\n        timestampsToReturn: TimestampsToReturn,\n        monitoredItemCreateRequest: MonitoredItemCreateRequest,\n        node: BaseNode\n    ): MonitoredItemCreateResult {\n        // note : most of the parameter inconsistencies shall have been handled by the caller\n        // any error here will raise an assert here\n\n        assert(monitoredItemCreateRequest instanceof MonitoredItemCreateRequest);\n        const itemToMonitor = monitoredItemCreateRequest.itemToMonitor;\n\n        // xx check if attribute Id invalid (we only support Value or EventNotifier )\n        // xx assert(itemToMonitor.attributeId !== AttributeIds.INVALID);\n\n        this.monitoredItemIdCounter += 1;\n\n        const monitoredItemId = getNextMonitoredItemId();\n\n        const requestedParameters = monitoredItemCreateRequest.requestedParameters;\n\n        // adjust requestedParameters.samplingInterval\n        requestedParameters.samplingInterval = this.adjustSamplingInterval(requestedParameters.samplingInterval, node);\n\n        // reincorporate monitoredItemId and itemToMonitor into the requestedParameters\n        const options = requestedParameters as any as MonitoredItemOptions;\n\n        options.monitoredItemId = monitoredItemId;\n        options.itemToMonitor = itemToMonitor;\n\n        const monitoredItem = new MonitoredItem(options);\n        monitoredItem.timestampsToReturn = timestampsToReturn;\n        monitoredItem.$subscription = this;\n\n        assert(monitoredItem.monitoredItemId === monitoredItemId);\n\n        this.monitoredItems[monitoredItemId] = monitoredItem;\n        this.globalCounter.totalMonitoredItemCount += 1;\n\n        assert(monitoredItem.clientHandle !== 4294967295);\n\n        const filterResult = _process_filter(node, requestedParameters.filter);\n\n        const monitoredItemCreateResult = new MonitoredItemCreateResult({\n            filterResult,\n            monitoredItemId,\n            revisedQueueSize: monitoredItem.queueSize,\n            revisedSamplingInterval: monitoredItem.samplingInterval,\n            statusCode: StatusCodes.Good\n        });\n\n        // this.emit(\"monitoredItem\", monitoredItem, itemToMonitor);\n        return monitoredItemCreateResult;\n    }\n\n    /**\n     *\n     * @param monitoredItem\n     * @param monitoredItemCreateRequest\n     * @private\n     */\n    public _createMonitoredItemStep3(\n        monitoredItem: MonitoredItem | null,\n        monitoredItemCreateRequest: MonitoredItemCreateRequest\n    ): void {\n        if (!monitoredItem) {\n            return;\n        }\n        assert(monitoredItem.monitoringMode === MonitoringMode.Invalid);\n        assert(typeof monitoredItem.samplingFunc === \"function\", \" expecting a sampling function here\");\n        const monitoringMode = monitoredItemCreateRequest.monitoringMode; // Disabled, Sampling, Reporting\n        monitoredItem.setMonitoringMode(monitoringMode);\n    }\n\n    private _harvestMonitoredItems() {\n        for (const monitoredItem of Object.values(this.monitoredItems)) {\n            const notifications_chunks = monitoredItem.extractMonitoredItemNotifications();\n            for (const chunk of notifications_chunks) {\n                this._addNotificationMessage(chunk, monitoredItem.monitoredItemId);\n            }\n        }\n        this._hasUncollectedMonitoredItemNotifications = false;\n    }\n}\n\nassert(Subscription.maximumPublishingInterval < 2147483647, \"maximumPublishingInterval cannot exceed (2**31-1) ms \");\n", "/* eslint-disable max-statements */\n/* global: require,describe,it,before,beforeEach,after,afterEach */\n\"use strict\";\n\nconst should = require(\"should\");\nconst sinon = require(\"sinon\");\n\nconst { StatusCodes } = require(\"node-opcua-status-code\");\nconst { AttributeIds } = require(\"node-opcua-data-model\");\nconst { SessionContext } = require(\"node-opcua-address-space\");\nconst { DataValue } = require(\"node-opcua-data-value\");\nconst { TimestampsToReturn } = require(\"node-opcua-service-read\");\nconst { DataType } = require(\"node-opcua-variant\");\nconst {\n    MonitoredItemCreateRequest,\n    DataChangeNotification,\n    MonitoringMode,\n    PublishRequest\n} = require(\"node-opcua-service-subscription\");\nconst { get_mini_nodeset_filename } = require(\"node-opcua-address-space/testHelpers\");\n\nconst {\n    Subscription,\n    SubscriptionState,\n    MonitoredItem,\n    ServerEngine,\n    ServerSidePublishEngine,\n    installSubscriptionMonitoring\n} = require(\"..\");\nconst add_mock_monitored_item = require(\"./helper\").add_mock_monitored_item;\n\nconst { getFakePublishEngine } = require(\"./helper_fake_publish_engine\");\n\nconst mini_nodeset_filename = get_mini_nodeset_filename();\nlet fake_publish_engine = {};\n\nconst fakeNotificationData = [new DataChangeNotification()];\n\nfunction reconstruct_fake_publish_engine() {\n    fake_publish_engine = getFakePublishEngine();\n}\n\n// eslint-disable-next-line import/order\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\ndescribe(\"Subscriptions\", function () {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const test = this;\n    beforeEach(function () {\n        test.clock = sinon.useFakeTimers();\n        reconstruct_fake_publish_engine();\n    });\n\n    afterEach(function () {\n        test.clock.restore();\n    });\n\n    it(\"T1 - a subscription will make sure that lifeTimeCount is at least 3 times maxKeepAliveCount\", function () {\n        {\n            const subscription1 = new Subscription({\n                publishingInterval: 1000,\n                maxKeepAliveCount: 20,\n                lifeTimeCount: 60, // at least 3 times maxKeepAliveCount\n                //\n                publishEngine: fake_publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n            subscription1.maxKeepAliveCount.should.eql(20);\n            subscription1.lifeTimeCount.should.eql(\n                60,\n                \"lifeTimeCount shall be unchanged because it is at least 3 times maxKeepAliveCount\"\n            );\n\n            subscription1.terminate();\n            subscription1.dispose();\n        }\n        {\n            const subscription2 = new Subscription({\n                publishingInterval: 1000,\n                maxKeepAliveCount: 20,\n                lifeTimeCount: 1, // IS NOT at least 3 times maxKeepAliveCount\n                //\n                publishEngine: fake_publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n            subscription2.maxKeepAliveCount.should.eql(20);\n            subscription2.lifeTimeCount.should.eql(60, \"lifeTimeCount must be adjusted to be at least 3 times maxKeepAliveCount\");\n            subscription2.terminate();\n            subscription2.dispose();\n        }\n    });\n\n    it(\"T2 - when a Subscription is created, the first Message is sent at the end of the first publishing cycle to inform the Client that the Subscription is operational. - Case 1 : PublishRequest in Queue &  no notification available\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            lifeTimeCount: 60, // at least 3 times maxKeepAliveCount\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        // pretend we have received 10 PublishRequest from client\n        fake_publish_engine.pendingPublishRequestCount = 10;\n\n        subscription.maxKeepAliveCount.should.eql(20);\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(1, \" the initial max Keep alive \");\n\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n        subscription._keep_alive_counter.should.eql(0);\n\n        test.clock.tick(subscription.publishingInterval);\n\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(1, \" the initial max Keep alive \");\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n        subscription._keep_alive_counter.should.eql(1);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription._keep_alive_counter.should.eql(2);\n\n        test.clock.tick(subscription.publishingInterval * 22);\n\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(2);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        test.clock.tick(subscription.publishingInterval * 22);\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(3);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T3 - when a Subscription is created, the first Message is sent at the end of the first publishing cycle to inform the Client that the Subscription is operational. - Case 2 : NoPublishRequest in Queue &  no notification available\", function () {\n        const subscription = new Subscription({\n            id: 1000,\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            lifeTimeCount: 60, // at least 3 times maxKeepAliveCount\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.maxKeepAliveCount.should.eql(20);\n\n        // pretend we have NO PublishRequest from client\n        fake_publish_engine.pendingPublishRequestCount = 0;\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        // pretend we now have many PublishRequest\n        fake_publish_engine.pendingPublishRequestCount = 10;\n\n        test.clock.tick(10);\n        subscription.process_subscription();\n\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(1);\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(2);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T4 - a subscription that have a new notification ready at the end of the  publishingInterval shall send notifications and no keepalive\", function () {\n        const subscription = new Subscription({\n            id: 1000,\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            lifeTimeCount: 60, // at least 3 times maxKeepAliveCount\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        // pretend we have received 10 PublishRequest from client\n        fake_publish_engine.pendingPublishRequestCount = 10;\n        subscription.maxKeepAliveCount.should.eql(20);\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount - 1));\n\n        notification_event_spy.callCount.should.be.greaterThan(2);\n        keepalive_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount + 1));\n        keepalive_event_spy.callCount.should.equal(1);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T5 - a subscription that have only some notification ready before max_keepalive_count expired shall send notifications and no keepalive\", function () {\n        fake_publish_engine.pendingPublishRequestCount.should.eql(0);\n\n        // pretend we have received 10 PublishRequest from client\n        fake_publish_engine.pendingPublishRequestCount = 10;\n\n        const subscription = new Subscription({\n            publishingInterval: 1000, // 1 second interval\n            lifeTimeCount: 100000, // very long lifeTimeCount not to be bother by client not pinging us\n            maxKeepAliveCount: 4,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        /* pretend that we do not have a notification ready */\n        //xx monitoredItem.simulateMonitoredItemAddingNotification();\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        // no notification ready, during 7 x publishinInterval - (keep alve is after 4)\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n\n        notification_event_spy.callCount.should.equal(1);\n        keepalive_event_spy.callCount.should.equal(1);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(2);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n\n        notification_event_spy.callCount.should.equal(2);\n        keepalive_event_spy.callCount.should.equal(2);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        // a other notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(3);\n        keepalive_event_spy.callCount.should.equal(2);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(3);\n        keepalive_event_spy.callCount.should.equal(2);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(3);\n        keepalive_event_spy.callCount.should.equal(2);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(3);\n        keepalive_event_spy.callCount.should.equal(2);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(3);\n        keepalive_event_spy.callCount.should.equal(3);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    describe(\"T6 - a subscription shall send its first notification as soon as the publish request is available\", function () {\n        let addressSpace, namespace;\n        let someVariableNode;\n        let engine;\n\n        function add_mock_monitored_item2(subscription, someVariableNode) {\n            const monitoredItemCreateRequest = new MonitoredItemCreateRequest({\n                itemToMonitor: { nodeId: someVariableNode },\n                monitoringMode: MonitoringMode.Reporting,\n                requestedParameters: {\n                    clientHandle: 123,\n                    queueSize: 10,\n                    samplingInterval: 200\n                }\n            });\n            const createResult = subscription.createMonitoredItem(\n                addressSpace,\n                TimestampsToReturn.Both,\n                monitoredItemCreateRequest\n            );\n            const monitoredItem = subscription.getMonitoredItem(createResult.monitoredItemId);\n\n            return monitoredItem;\n        }\n\n        before(function (done) {\n            engine = new ServerEngine();\n            engine.initialize({ nodeset_filename: mini_nodeset_filename }, function () {\n                addressSpace = engine.addressSpace;\n                namespace = addressSpace.getOwnNamespace();\n\n                const node = namespace.addVariable({\n                    componentOf: \"RootFolder\",\n                    browseName: \"SomeVariable\",\n                    dataType: \"UInt32\",\n                    value: { dataType: DataType.UInt32, value: 0 }\n                });\n                someVariableNode = node.nodeId;\n                done();\n            });\n        });\n        after(async () => {\n            await engine.shutdown();\n            engine = null;\n        });\n\n        let publish_engine;\n\n        function simulate_client_adding_publish_request(publishEngine, callback) {\n            const publishRequest = new PublishRequest({});\n            publishEngine._on_PublishRequest(publishRequest, callback);\n            test.clock.tick(0);\n        }\n\n        let subscription;\n        let notification_event_spy, keepalive_event_spy, expire_event_spy;\n\n        beforeEach(function () {\n            publish_engine = new ServerSidePublishEngine();\n            subscription = new Subscription({\n                id: 1000,\n                publishingInterval: 100,\n                maxKeepAliveCount: 10,\n                lifeTimeCount: 30,\n                publishingEnabled: true,\n                publishEngine: publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n            publish_engine.add_subscription(subscription);\n\n            notification_event_spy = sinon.spy();\n            keepalive_event_spy = sinon.spy();\n            expire_event_spy = sinon.spy();\n            subscription.on(\"notification\", notification_event_spy);\n            subscription.on(\"keepalive\", keepalive_event_spy);\n            subscription.on(\"expired\", expire_event_spy);\n\n            subscription.on(\"monitoredItem\", function (monitoredItem) {\n                monitoredItem.samplingFunc = function () {\n                    /**  */\n                };\n            });\n        });\n\n        afterEach(function (done) {\n            subscription.on(\"terminated\", function () {\n                done();\n            });\n            subscription.terminate();\n            subscription.dispose();\n            subscription = null;\n            publish_engine.shutdown();\n            publish_engine.dispose();\n        });\n\n        it(\" - case 1 - publish Request arrives before first publishInterval is over \", async () => {\n            // in this case the subscription received a first publish request before the first tick is processed\n\n            simulate_client_adding_publish_request(subscription.publishEngine);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n            keepalive_event_spy.callCount.should.eql(0);\n\n            test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount - 1));\n            subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n            keepalive_event_spy.callCount.should.eql(1);\n\n            test.clock.tick((subscription.publishingInterval * subscription.maxKeepAliveCount) / 2);\n            keepalive_event_spy.callCount.should.eql(1);\n            subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(1);\n\n            test.clock.tick((subscription.publishingInterval * subscription.maxKeepAliveCount) / 2);\n            subscription.state.should.eql(SubscriptionState.LATE);\n        });\n\n        it(\" - case 2 - publish Request arrives late (after first publishInterval is over)\", async () => {\n            // now simulate some data change\n            test.clock.tick((subscription.publishingInterval * subscription.maxKeepAliveCount) / 2);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n            keepalive_event_spy.callCount.should.eql(0);\n\n            simulate_client_adding_publish_request(subscription.publishEngine);\n\n            keepalive_event_spy.callCount.should.eql(0);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n            subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n            keepalive_event_spy.callCount.should.eql(1);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(1);\n        });\n\n        it(\" - case 3 - publish Request arrives late (after first publishInterval is over)\", function () {\n            const monitoredItem = add_mock_monitored_item2(subscription, someVariableNode);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            // now simulate some data change\n            monitoredItem.recordValue(new DataValue({ value: { dataType: DataType.UInt32, value: 1000 } }));\n\n            notification_event_spy.callCount.should.eql(0);\n            simulate_client_adding_publish_request(subscription.publishEngine);\n\n            subscription.state.should.eql(SubscriptionState.NORMAL); // Back to Normal\n            notification_event_spy.callCount.should.eql(1);\n\n            test.clock.tick(subscription.publishingInterval);\n            notification_event_spy.callCount.should.eql(1);\n            subscription.state.should.eql(SubscriptionState.NORMAL); // Back to Normal\n            keepalive_event_spy.callCount.should.eql(0);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n        });\n\n        it(\" - case 4 - publish Request arrives late (after first publishInterval is over)\", function () {\n            const monitoredItem = add_mock_monitored_item2(subscription, someVariableNode);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            // now simulate some data change\n            monitoredItem.recordValue(new DataValue({ value: { dataType: DataType.UInt32, value: 1000 } }));\n\n            notification_event_spy.callCount.should.eql(0);\n            simulate_client_adding_publish_request(subscription.publishEngine);\n\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n            notification_event_spy.callCount.should.eql(1);\n\n            test.clock.tick(subscription.publishingInterval);\n            notification_event_spy.callCount.should.eql(1);\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n            keepalive_event_spy.callCount.should.eql(0);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n        });\n\n        it(\" - case 4 (with monitoredItem - 3x value writes) - publish Request arrives late (after first publishInterval is over)\", function () {\n            const monitoredItem = add_mock_monitored_item2(subscription, someVariableNode);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            // now simulate some data change\n            monitoredItem.recordValue(new DataValue({ value: { dataType: DataType.UInt32, value: 1000 } }));\n            notification_event_spy.callCount.should.eql(0);\n\n            simulate_client_adding_publish_request(subscription.publishEngine);\n            notification_event_spy.callCount.should.eql(1);\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            monitoredItem.recordValue(new DataValue({ value: { dataType: DataType.UInt32, value: 1001 } }));\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.state.should.eql(SubscriptionState.LATE);\n\n            simulate_client_adding_publish_request(subscription.publishEngine);\n            test.clock.tick(subscription.publishingInterval);\n\n            notification_event_spy.callCount.should.eql(2);\n            subscription.hasPendingNotifications.should.eql(false);\n            subscription.hasUncollectedMonitoredItemNotifications.should.eql(false);\n\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            monitoredItem.recordValue(new DataValue({ value: { dataType: DataType.UInt32, value: 1002 } }));\n\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            test.clock.tick(subscription.publishingInterval);\n            simulate_client_adding_publish_request(subscription.publishEngine);\n\n            test.clock.tick(subscription.publishingInterval);\n            notification_event_spy.callCount.should.eql(3);\n\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n            keepalive_event_spy.callCount.should.eql(0);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n        });\n    });\n\n    it(\"T7 - a subscription that hasn't been pinged by client within the lifetime interval shall terminate\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 250,\n            maxKeepAliveCount: 3,\n            lifeTimeCount: 30,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        false && installSubscriptionMonitoring(subscription);\n\n        subscription.publishingInterval.should.eql(250);\n        subscription.maxKeepAliveCount.should.eql(3);\n        subscription.lifeTimeCount.should.eql(30);\n\n        const expire_event_spy = sinon.spy();\n        subscription.on(\"expired\", expire_event_spy);\n        const terminate_spy = sinon.spy(subscription, \"terminate\");\n\n        subscription.state.should.eql(SubscriptionState.CREATING);\n        subscription.currentLifetimeCount.should.eql(0);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.lifeTimeCount - 3));\n     \n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n\n        test.clock.tick(subscription.publishingInterval * 3);\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n\n        terminate_spy.callCount.should.equal(1);\n        expire_event_spy.callCount.should.equal(1);\n        subscription.state.should.eql(SubscriptionState.CLOSED);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T8 - a subscription that has been pinged by client before the lifetime expiration shall not terminate\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const expire_event_spy = sinon.spy();\n        subscription.on(\"expired\", expire_event_spy);\n        const terminate_spy = sinon.spy(subscription, \"terminate\");\n\n        test.clock.tick(subscription.publishingInterval * (subscription.lifeTimeCount - 2));\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n\n        subscription.resetLifeTimeAndKeepAliveCounters();\n\n        test.clock.tick(subscription.publishingInterval * 4);\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.lifeTimeCount + 2));\n        terminate_spy.callCount.should.equal(1);\n        expire_event_spy.callCount.should.equal(1);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T9 - a subscription that has no notification within maxKeepAliveCount shall send a keepalive signal \", function () {\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 1000,\n            lifeTimeCount: 100000, // very large lifetime not to be bother by client not pinging us\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const expire_event_spy = sinon.spy();\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        subscription.on(\"expired\", expire_event_spy);\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n\n        const terminate_spy = sinon.spy(subscription, \"terminate\");\n\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount - 5));\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(0);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount + 5));\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(2);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount + 3));\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(3);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T10 - a subscription shall maintain a retransmission queue of pending NotificationMessages.\", function () {\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            maxNotificationsPerPublish: 2, //\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        subscription.maxNotificationsPerPublish.should.eql(2);\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        subscription.pendingNotificationsCount.should.equal(0);\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        // pretend we have received  PublishRequest from client\n        fake_publish_engine.pendingPublishRequestCount = 4;\n        test.clock.tick(subscription.publishingInterval);\n\n        subscription.sentNotificationMessageCount.should.equal(1);\n\n        subscription.pendingNotificationsCount.should.equal(7);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    //OPC Unified Architecture, Part 4 74 Release 1.01\n    it(\"T11 - a subscription shall maintain a retransmission queue of sent NotificationMessages.\", function () {\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        fake_publish_engine.pendingPublishRequestCount = 10;\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        subscription.pendingNotificationsCount.should.equal(0);\n        subscription.sentNotificationMessageCount.should.equal(0);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.pendingNotificationsCount.should.equal(0);\n        subscription.sentNotificationMessageCount.should.equal(1);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n        subscription.pendingNotificationsCount.should.equal(0);\n        subscription.sentNotificationMessageCount.should.equal(2);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    describe(\"T12 - NotificationMessages are retained in this queue until they are acknowledged or until they have been in the queue for a minimum of one keep-alive interval.\", function () {\n        it(\"T12-1 a NotificationMessage is retained in this queue until it is acknowledged\", function () {\n            const subscription = new Subscription({\n                id: 1234,\n                publishingInterval: 1000,\n                lifeTimeCount: 1000,\n                maxKeepAliveCount: 20,\n                //\n                publishEngine: fake_publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n\n            const _send_response_spy = sinon.spy(fake_publish_engine, \"_send_response\");\n            const monitoredItem = add_mock_monitored_item(subscription);\n\n            monitoredItem.simulateMonitoredItemAddingNotification();\n            monitoredItem.simulateMonitoredItemAddingNotification();\n            subscription.sentNotificationMessageCount.should.equal(0);\n\n            // pretend that we have 10 PublishRequest waiting in the queue\n            fake_publish_engine.pendingPublishRequestCount = 10;\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.sentNotificationMessageCount.should.equal(1);\n\n            fake_publish_engine.pendingPublishRequestCount.should.eql(9);\n\n            _send_response_spy.callCount.should.equal(1);\n\n            monitoredItem.simulateMonitoredItemAddingNotification();\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.sentNotificationMessageCount.should.equal(2);\n\n            const notification1 = _send_response_spy.getCall(0).args[1].notificationMessage;\n            notification1.sequenceNumber.should.eql(1);\n\n            const notification2 = _send_response_spy.getCall(1).args[1].notificationMessage;\n            notification2.sequenceNumber.should.eql(2);\n\n            subscription.acknowledgeNotification(notification2.sequenceNumber);\n            subscription.sentNotificationMessageCount.should.equal(1);\n\n            subscription.acknowledgeNotification(notification1.sequenceNumber);\n            subscription.sentNotificationMessageCount.should.equal(0);\n\n            subscription.terminate();\n            subscription.dispose();\n        });\n\n        it(\"T12-2 A notificationMessage that hasn't been acknowledge should be accessiblef for republish\", function () {\n            fake_publish_engine.pendingPublishRequestCount = 10;\n\n            const send_response_spy = sinon.spy(fake_publish_engine, \"_send_response\");\n\n            //#getMessageForSequenceNumber\n            const subscription = new Subscription({\n                id: 1234,\n                publishingInterval: 1000,\n                lifeTimeCount: 1000,\n                maxKeepAliveCount: 20,\n                //\n                publishEngine: fake_publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n\n            const monitoredItem = add_mock_monitored_item(subscription);\n\n            should(subscription.getMessageForSequenceNumber(35)).eql(null);\n\n            monitoredItem.simulateMonitoredItemAddingNotification();\n            monitoredItem.simulateMonitoredItemAddingNotification();\n\n            subscription.sentNotificationMessageCount.should.equal(0);\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.sentNotificationMessageCount.should.equal(1);\n\n            const notification1 = send_response_spy.getCall(0).args[1].notificationMessage;\n            notification1.sequenceNumber.should.eql(1);\n            const seqNum = notification1.sequenceNumber;\n\n            //\n            const message = subscription.getMessageForSequenceNumber(seqNum);\n            message.sequenceNumber.should.eql(seqNum);\n\n            subscription.terminate();\n            subscription.dispose();\n        });\n\n        it(\"T12-3 - 1.02 the server shall retain a maximum number of un-acknowledged NotificationMessage until they are acknowledged\", function () {\n            // TODO\n        });\n\n        xit(\"T12-4 - 1.01 a NotificationMessage is retained until it has been in the queue for a minimum of one keep-alive interval.\", function () {\n            // this conforms to OPC UA specifciation 1.01 and is now obsolete as behavior has been chanded in 1.02\n\n            const subscription = new Subscription({\n                id: 1234,\n                publishingInterval: 1000,\n                lifeTimeCount: 1000,\n                maxKeepAliveCount: 20,\n                //\n                publishEngine: fake_publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n            // create a notification at t=0\n            subscription.addNotificationMessage(fakeNotificationData);\n            subscription._popNotificationToSend();\n            subscription.sentNotificationMessageCount.should.equal(1);\n\n            test.clock.tick(1000 * 5);\n            // create a notification at t=1000*5\n            subscription.addNotificationMessage(fakeNotificationData);\n            subscription._popNotificationToSend();\n            subscription.sentNotificationMessageCount.should.equal(2);\n\n            test.clock.tick(1000 * 20);\n            // now check that at t=1000*25 , old notification has been discarded\n            subscription.sentNotificationMessageCount.should.equal(1);\n\n            test.clock.tick(1000 * 100);\n            // now check that at t=1000*100 , old notification has been discarded\n            subscription.sentNotificationMessageCount.should.equal(0);\n\n            subscription.terminate();\n            subscription.dispose();\n        });\n    });\n\n    it(\"T13 - a subscription that have no monitored items shall not terminate if client has sent enough PublishRequest\", function () {\n        // pretend there is plenty of PublishRequest in publish engine\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 100,\n            maxKeepAliveCount: 20,\n            lifeTimeCount: 10,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        subscription.maxKeepAliveCount.should.eql(20);\n        subscription.publishingInterval.should.eql(100);\n\n        test.clock.tick(6 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n\n        subscription.publishIntervalCount.should.equal(\n            120,\n            \" 3000 ms with a publishingInterval: 100 ms means publishIntervalCount = 30\"\n        );\n\n        expire_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(6);\n        notification_event_spy.callCount.should.equal(0);\n\n        test.clock.tick(6 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        expire_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(12);\n        notification_event_spy.callCount.should.equal(0);\n\n        test.clock.tick(6 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        expire_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(18);\n        notification_event_spy.callCount.should.equal(0);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T14 - a subscription send a first message at the end of the first publishing cycle without waiting for the maximum  count to be reached\", function () {\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        /**\n         * When a Subscription is created, the first Message is sent at the end of the first publishing cycle to\n         * inform the Client that the Subscription is operational. A Notification Message is sent if there are\n         * Notifications ready to be reported. If there are none, a keep-alive Message is sent instead that\n         * contains a sequence number of 1, indicating that the first Notification Message has not yet been\n         * sent. This is the only time a keep-alive Message is sent without waiting for the maximum keep-alive\n         * count to be reached, as specified in (f) above.\n         *\n         */\n        const subscription = new Subscription({\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // pretend that we already have notification messages\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        test.clock.tick(200);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(0);\n\n        test.clock.tick(1000);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(1);\n\n        test.clock.tick(1000);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(1);\n\n        test.clock.tick(30000);\n        keepalive_event_spy.callCount.should.equal(1);\n        notification_event_spy.callCount.should.eql(1);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T15 - the first Notification Message sent on a Subscription has a sequence number of 1.\", function () {\n        const subscription = new Subscription({\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription._get_future_sequence_number().should.equal(1);\n        subscription._get_next_sequence_number().should.equal(1);\n        subscription._get_next_sequence_number().should.equal(2);\n        subscription._get_next_sequence_number().should.equal(3);\n        subscription._get_future_sequence_number().should.equal(4);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T16 - should return BadMonitorItemInvalid when trying to remove a monitored item that doesn't exist\", function () {\n        const subscription = new Subscription({\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.removeMonitoredItem(26).should.eql(StatusCodes.BadMonitoredItemIdInvalid);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    xit(\"closing a Subscription causes its MonitoredItems to be deleted. \", function () {\n        /** */\n    });\n});\n\ndescribe(\"Subscription#setPublishingMode\", function () {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const test = this;\n    beforeEach(function () {\n        test.clock = sinon.useFakeTimers();\n        reconstruct_fake_publish_engine();\n    });\n\n    afterEach(function () {\n        test.clock.restore();\n    });\n    it(\"W1 - a subscription created with publishingEnabled=true shall emit notification\", function (done) {\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 100,\n            maxKeepAliveCount: 5,\n            lifeTimeCount: 10,\n            publishingEnabled: true, //  PUBLISHING IS ENABLED !!!\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // pretend that we already have notification messages\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        test.clock.tick(subscription.publishingInterval * 4);\n\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(1); // all notif shall be compressed into one message\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        notification_event_spy.callCount.should.be.greaterThan(4);\n\n        subscription.terminate();\n        subscription.dispose();\n\n        done();\n    });\n\n    it(\"W2 - a subscription created with publishingEnabled=false shall not emit notification (but keepalive)\", function (done) {\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 100,\n            maxKeepAliveCount: 5,\n            lifeTimeCount: 10,\n\n            publishingEnabled: false, //  PUBLISHING IS DISABLED !!!\n\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(5);\n        notification_event_spy.callCount.should.eql(0);\n\n        subscription.terminate();\n        subscription.dispose();\n        done();\n    });\n\n    it(\"W3 - a publishing subscription can be disabled and re-enabled\", function (done) {\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 100,\n            maxKeepAliveCount: 5,\n            lifeTimeCount: 10,\n            publishingEnabled: true, //  PUBLISHING IS ENABLED !!!\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // the monitoredItem provides a new notification every 50ms\n        function push_some_notification() {\n            monitoredItem.simulateMonitoredItemAddingNotification();\n        }\n        const t = setInterval(push_some_notification, 50);\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        test.clock.tick(subscription.publishingInterval * 22);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.be.greaterThan(20);\n\n        // now disable\n        subscription.setPublishingMode(false);\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(4);\n        notification_event_spy.callCount.should.be.greaterThan(20);\n\n        subscription.setPublishingMode(true);\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(4);\n        notification_event_spy.callCount.should.be.greaterThan(40);\n\n        clearInterval(t);\n\n        subscription.terminate();\n        subscription.dispose();\n        done();\n    });\n\n    it(\"W4 - a disabled subscription shall continue to send keep-alive notifications\", function (done) {\n        // What the specs say:\n        // Publishing by a Subscription may be enabled or disabled by the Client when created, or\n        // subsequently using the SetPublishingMode Service. Disabling causes the Subscription to\n        // cease sending NotificationMessages to the Client. However, the Subscription continues\n        // to execute cyclically and continues to send keep-alive Messages to the Client.\n\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 100,\n            maxKeepAliveCount: 5,\n            lifeTimeCount: 10,\n            publishingEnabled: false, //  PUBLISHING IS DISABLED !!!\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // the monitoredItem provides a new notification every 50ms\n        function push_some_notification() {\n            monitoredItem.simulateMonitoredItemAddingNotification();\n        }\n        const t = setInterval(push_some_notification, 50);\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(4); // 2000 = 4*5*100\n        notification_event_spy.callCount.should.be.equal(0);\n\n        subscription.setPublishingMode(true);\n\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(4);\n        notification_event_spy.callCount.should.be.greaterThan(19);\n        const nb = notification_event_spy.callCount;\n\n        subscription.setPublishingMode(false);\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(8);\n        notification_event_spy.callCount.should.be.equal(nb);\n\n        clearInterval(t);\n\n        subscription.terminate();\n        subscription.dispose();\n        done();\n    });\n});\n\ndescribe(\"Subscription#adjustSamplingInterval\", function () {\n    beforeEach(function () {\n        //xx        test.clock = sinon.useFakeTimers();\n        reconstruct_fake_publish_engine();\n    });\n\n    it(\"should have a minimum sampling interval, with a strictly positive value ( which is the fastest possible rate)\", function () {\n        MonitoredItem.minimumSamplingInterval.should.be.greaterThan(4);\n    });\n\n    it(\"should have a default sampling interval, greater than minimumSamplingInterval \", function () {\n        MonitoredItem.defaultSamplingInterval.should.be.greaterThan(MonitoredItem.minimumSamplingInterval);\n    });\n\n    it(\"should have a maximum sampling interval, greater than defaultSamplingInterval \", function () {\n        MonitoredItem.maximumSamplingInterval.should.be.greaterThan(MonitoredItem.defaultSamplingInterval);\n    });\n\n    it(\"should adjust sampling interval to subscription publish interval when requested sampling interval === -1\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        subscription.adjustSamplingInterval(-1).should.eql(subscription.publishingInterval);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    const fake_node = {\n        readAttribute: function (context, attributeId) {\n            context.should.be.instanceOf(SessionContext);\n            attributeId.should.eql(AttributeIds.MinimumSamplingInterval);\n            return new DataValue({ value: { dataType: DataType.Double, value: 0.0 } });\n        }\n    };\n\n    it(\"should adjust sampling interval to subscription publish interval when requested sampling interval is a negative value !== -1\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.adjustSamplingInterval(-2, fake_node).should.eql(subscription.publishingInterval);\n        subscription.adjustSamplingInterval(-0.02, fake_node).should.eql(subscription.publishingInterval);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"should leave sampling interval to 0 when requested sampling interval === 0 ( 0 means Event Based mode)\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.adjustSamplingInterval(0, fake_node).should.eql(0);\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"should adjust sampling interval to minimum when requested sampling interval === 1\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.adjustSamplingInterval(1, fake_node).should.eql(MonitoredItem.minimumSamplingInterval);\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"should adjust sampling interval to maximum when requested sampling interval is too high\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.adjustSamplingInterval(1e10, fake_node).should.eql(MonitoredItem.maximumSamplingInterval);\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"should return an unmodified sampling interval when requested sampling is in valid range\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        const someValidSamplingInterval = (MonitoredItem.maximumSamplingInterval + MonitoredItem.minimumSamplingInterval) / 2.0;\n        subscription.adjustSamplingInterval(someValidSamplingInterval, fake_node).should.eql(someValidSamplingInterval);\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"should adjust sampling interval the minimumSamplingInterval when requested sampling is too low\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        const someVeryLowSamplingInterval = 1;\n        subscription\n            .adjustSamplingInterval(someVeryLowSamplingInterval, fake_node)\n            .should.eql(MonitoredItem.minimumSamplingInterval);\n        subscription.terminate();\n        subscription.dispose();\n    });\n});\n"], "fixing_code": ["/**\n * @module node-opcua-server\n */\n// tslint:disable:no-console\n\nimport { EventEmitter } from \"events\";\nimport * as chalk from \"chalk\";\n\nimport { AddressSpace, BaseNode, Duration, UAObjectType } from \"node-opcua-address-space\";\nimport { checkSelectClauses } from \"node-opcua-address-space\";\nimport { SessionContext } from \"node-opcua-address-space\";\nimport { assert } from \"node-opcua-assert\";\nimport { Byte, UInt32 } from \"node-opcua-basic-types\";\nimport { SubscriptionDiagnosticsDataType } from \"node-opcua-common\";\nimport { NodeClass, AttributeIds, isValidDataEncoding } from \"node-opcua-data-model\";\nimport { TimestampsToReturn } from \"node-opcua-data-value\";\nimport { checkDebugFlag, make_debugLog, make_warningLog } from \"node-opcua-debug\";\nimport { NodeId } from \"node-opcua-nodeid\";\nimport { ObjectRegistry } from \"node-opcua-object-registry\";\nimport { SequenceNumberGenerator } from \"node-opcua-secure-channel\";\nimport { EventFilter } from \"node-opcua-service-filter\";\nimport { AggregateFilter } from \"node-opcua-service-subscription\";\nimport {\n    DataChangeNotification,\n    EventNotificationList,\n    MonitoringMode,\n    MonitoredItemCreateResult,\n    MonitoredItemNotification,\n    PublishResponse,\n    NotificationMessage,\n    StatusChangeNotification,\n    DataChangeFilter,\n    MonitoredItemCreateRequest\n} from \"node-opcua-service-subscription\";\nimport { StatusCode, StatusCodes } from \"node-opcua-status-code\";\nimport { AggregateFilterResult, ContentFilterResult, EventFieldList, EventFilterResult, NotificationData } from \"node-opcua-types\";\nimport { Queue } from \"./queue\";\n\nimport { MonitoredItem, MonitoredItemOptions, QueueItem } from \"./monitored_item\";\nimport { ServerSession } from \"./server_session\";\nimport { validateFilter } from \"./validate_filter\";\nimport { IServerSidePublishEngine, TransferredSubscription } from \"./i_server_side_publish_engine\";\n\nconst debugLog = make_debugLog(__filename);\nconst doDebug = checkDebugFlag(__filename);\nconst warningLog = make_warningLog(__filename);\nconst maxNotificationMessagesInQueue = 100;\n\nexport interface SubscriptionDiagnosticsDataTypePriv extends SubscriptionDiagnosticsDataType {\n    $subscription: Subscription;\n}\n\nexport enum SubscriptionState {\n    CLOSED = 1, // The Subscription has not yet been created or has terminated.\n    CREATING = 2, // The Subscription is being created\n    NORMAL = 3, // The Subscription is cyclically checking for Notifications from its MonitoredItems.\n    // The keep-alive counter is not used in this state.\n    LATE = 4, // The publishing timer has expired and there are Notifications available or a keep-alive Message is\n    // ready to be sent, but there are no Publish requests queued. When in this state, the next Publish\n    // request is processed when it is received. The keep-alive counter is not used in this state.\n    KEEPALIVE = 5, // The Subscription is cyclically checking for Notification\n    // alive counter to count down to 0 from its maximum.\n    TERMINATED = 6\n}\n\nfunction _adjust_publishing_interval(publishingInterval?: number): number {\n    publishingInterval =\n        publishingInterval === undefined || Number.isNaN(publishingInterval)\n            ? Subscription.defaultPublishingInterval\n            : publishingInterval;\n    publishingInterval = Math.max(publishingInterval, Subscription.minimumPublishingInterval);\n    publishingInterval = Math.min(publishingInterval, Subscription.maximumPublishingInterval);\n    return publishingInterval;\n}\n\nconst minimumMaxKeepAliveCount = 2;\nconst maximumMaxKeepAliveCount = 12000;\n\nfunction _adjust_maxKeepAliveCount(maxKeepAliveCount?: number /*,publishingInterval*/): number {\n    maxKeepAliveCount = maxKeepAliveCount || minimumMaxKeepAliveCount;\n    maxKeepAliveCount = Math.max(maxKeepAliveCount, minimumMaxKeepAliveCount);\n    maxKeepAliveCount = Math.min(maxKeepAliveCount, maximumMaxKeepAliveCount);\n    return maxKeepAliveCount;\n}\n\nfunction _adjust_lifeTimeCount(lifeTimeCount: number, maxKeepAliveCount: number, publishingInterval: number): number {\n    lifeTimeCount = lifeTimeCount || 1;\n\n    // let's make sure that lifeTimeCount is at least three time maxKeepAliveCount\n    // Note : the specs say ( part 3  - CreateSubscriptionParameter )\n    //        \"The lifetime count shall be a minimum of three times the keep keep-alive count.\"\n    lifeTimeCount = Math.max(lifeTimeCount, maxKeepAliveCount * 3);\n\n    const minTicks = Math.ceil(Subscription.minimumLifetimeDuration / publishingInterval);\n    const maxTicks = Math.floor(Subscription.maximumLifetimeDuration / publishingInterval);\n\n    lifeTimeCount = Math.max(minTicks, lifeTimeCount);\n    lifeTimeCount = Math.min(maxTicks, lifeTimeCount);\n    return lifeTimeCount;\n}\n\nfunction _adjust_publishingEnable(publishingEnabled?: boolean | null): boolean {\n    return publishingEnabled === null || publishingEnabled === undefined ? true : !!publishingEnabled;\n}\n\nfunction _adjust_maxNotificationsPerPublish(maxNotificationsPerPublish?: number): number {\n    assert(Subscription.maxNotificationPerPublishHighLimit > 0, \"Subscription.maxNotificationPerPublishHighLimit must be positive\");\n\n    maxNotificationsPerPublish = maxNotificationsPerPublish || 0;\n    assert(typeof maxNotificationsPerPublish === \"number\");\n\n    // must be strictly positive\n    maxNotificationsPerPublish = maxNotificationsPerPublish >= 0 ? maxNotificationsPerPublish : 0;\n\n    if (maxNotificationsPerPublish === 0) {\n        // if zero then => use our HighLimit\n        maxNotificationsPerPublish = Subscription.maxNotificationPerPublishHighLimit;\n    } else {\n        // if not zero then should be capped by maxNotificationPerPublishHighLimit\n        maxNotificationsPerPublish = Math.min(Subscription.maxNotificationPerPublishHighLimit, maxNotificationsPerPublish);\n    }\n\n    assert(maxNotificationsPerPublish !== 0 && maxNotificationsPerPublish <= Subscription.maxNotificationPerPublishHighLimit);\n    return maxNotificationsPerPublish;\n}\n\nfunction w(s: string | number, length: number): string {\n    return (\"000\" + s).padStart(length);\n}\n\nfunction t(d: Date): string {\n    return w(d.getHours(), 2) + \":\" + w(d.getMinutes(), 2) + \":\" + w(d.getSeconds(), 2) + \":\" + w(d.getMilliseconds(), 3);\n}\n\nfunction _getSequenceNumbers(arr: NotificationMessage[]): number[] {\n    return arr.map((notificationMessage) => notificationMessage.sequenceNumber);\n}\n\nfunction analyseEventFilterResult(node: BaseNode, eventFilter: EventFilter): EventFilterResult {\n    /* istanbul ignore next */\n    if (!(eventFilter instanceof EventFilter)) {\n        throw new Error(\"Internal Error\");\n    }\n\n    const selectClauseResults = checkSelectClauses(node as UAObjectType, eventFilter.selectClauses || []);\n\n    const whereClauseResult = new ContentFilterResult();\n\n    return new EventFilterResult({\n        selectClauseDiagnosticInfos: [],\n        selectClauseResults,\n        whereClauseResult\n    });\n}\n\nfunction analyseDataChangeFilterResult(node: BaseNode, dataChangeFilter: DataChangeFilter): null {\n    assert(dataChangeFilter instanceof DataChangeFilter);\n    // the opcua specification doesn't provide dataChangeFilterResult\n    return null;\n}\n\nfunction analyseAggregateFilterResult(node: BaseNode, aggregateFilter: AggregateFilter): AggregateFilterResult {\n    assert(aggregateFilter instanceof AggregateFilter);\n    return new AggregateFilterResult({});\n}\n\nfunction _process_filter(node: BaseNode, filter: any): EventFilterResult | AggregateFilterResult | null {\n    if (!filter) {\n        return null;\n    }\n\n    if (filter instanceof EventFilter) {\n        return analyseEventFilterResult(node, filter);\n    } else if (filter instanceof DataChangeFilter) {\n        return analyseDataChangeFilterResult(node, filter);\n    } else if (filter instanceof AggregateFilter) {\n        return analyseAggregateFilterResult(node, filter);\n    }\n    // istanbul ignore next\n    throw new Error(\"invalid filter\");\n}\n\n/**\n * @private\n */\nfunction createSubscriptionDiagnostics(subscription: Subscription): SubscriptionDiagnosticsDataTypePriv {\n    assert(subscription instanceof Subscription);\n\n    const subscriptionDiagnostics = new SubscriptionDiagnosticsDataType({});\n\n    const subscription_subscriptionDiagnostics = subscriptionDiagnostics as SubscriptionDiagnosticsDataTypePriv as any;\n    subscription_subscriptionDiagnostics.$subscription = subscription;\n    // \"sessionId\"\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"sessionId\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): NodeId {\n            if (!this.$subscription) {\n                return NodeId.nullNodeId;\n            }\n            return this.$subscription.getSessionId();\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"subscriptionId\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.id;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\"priority\", function (this: SubscriptionDiagnosticsDataTypePriv): number {\n        if (!this.$subscription) {\n            return 0;\n        }\n        return this.$subscription.priority;\n    });\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"publishingInterval\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.publishingInterval;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\"maxLifetimeCount\", function (this: SubscriptionDiagnosticsDataTypePriv) {\n        return this.$subscription.lifeTimeCount;\n    });\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"maxKeepAliveCount\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.maxKeepAliveCount;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"maxNotificationsPerPublish\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.maxNotificationsPerPublish;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"publishingEnabled\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): boolean {\n            if (!this.$subscription) {\n                return false;\n            }\n            return this.$subscription.publishingEnabled;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"monitoredItemCount\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.monitoredItemCount;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"nextSequenceNumber\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription._get_future_sequence_number();\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"disabledMonitoredItemCount\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.disabledMonitoredItemCount;\n        }\n    );\n\n    /* those member of self.subscriptionDiagnostics are handled directly\n\n   modifyCount\n   enableCount,\n   disableCount,\n   republishRequestCount,\n   notificationsCount,\n   publishRequestCount,\n   dataChangeNotificationsCount,\n   eventNotificationsCount,\n  */\n\n    /*\n   those members are not updated yet in the code :\n   \"republishMessageRequestCount\",\n   \"republishMessageCount\",\n   \"transferRequestCount\",\n   \"transferredToAltClientCount\",\n   \"transferredToSameClientCount\",\n   \"latePublishRequestCount\",\n   \"unacknowledgedMessageCount\",\n   \"discardedMessageCount\",\n   \"monitoringQueueOverflowCount\",\n   \"eventQueueOverFlowCount\"\n   */\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"currentKeepAliveCount\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.currentKeepAliveCount;\n        }\n    );\n    subscription_subscriptionDiagnostics.__defineGetter__(\n        \"currentLifetimeCount\",\n        function (this: SubscriptionDiagnosticsDataTypePriv): number {\n            if (!this.$subscription) {\n                return 0;\n            }\n            return this.$subscription.currentLifetimeCount;\n        }\n    );\n    // add object in Variable SubscriptionDiagnosticArray (i=2290) ( Array of SubscriptionDiagnostics)\n    // add properties in Variable to reflect\n    return subscriptionDiagnostics as SubscriptionDiagnosticsDataTypePriv;\n}\n\ninterface IGlobalMonitoredItemCounter {\n    totalMonitoredItemCount: number;\n}\n\nexport interface SubscriptionOptions {\n    sessionId?: NodeId;\n    /**\n     * (default:1000) the publishing interval.\n     */\n    publishingInterval?: number;\n    /**\n     * (default:10) the max Life Time Count\n     */\n    maxKeepAliveCount?: number;\n\n    lifeTimeCount?: number;\n    /**\n     * (default:true)\n     */\n    publishingEnabled?: boolean;\n    /**\n     * (default:0)\n     */\n    maxNotificationsPerPublish?: number;\n    /**\n     * subscription priority Byte:(0-255)\n     */\n    priority?: number;\n\n    publishEngine?: IServerSidePublishEngine;\n    /**\n     *  a unique identifier\n     */\n    id?: number;\n\n    serverCapabilities: ServerCapabilitiesPartial;\n    globalCounter: IGlobalMonitoredItemCounter;\n}\n\nlet g_monitoredItemId = Math.ceil(Math.random() * 100000);\n\nfunction getNextMonitoredItemId() {\n    return g_monitoredItemId++;\n}\n\n// function myFilter<T>(t1: any, chunk: any[]): T[] {\n//     return chunk.filter(filter_instanceof.bind(null, t1));\n// }\n\n// function makeNotificationData(notifications_chunk: QueueItem): NotificationData {\n//     const dataChangedNotificationData = myFilter<MonitoredItemNotification>(MonitoredItemNotification, notifications_chunk);\n//     const eventNotificationListData = myFilter<EventFieldList>(EventFieldList, notifications_chunk);\n\n//     assert(notifications_chunk.length === dataChangedNotificationData.length + eventNotificationListData.length);\n\n//     const notifications: (DataChangeNotification | EventNotificationList)[] = [];\n\n//     // add dataChangeNotification\n//     if (dataChangedNotificationData.length) {\n//         const dataChangeNotification = new DataChangeNotification({\n//             diagnosticInfos: [],\n//             monitoredItems: dataChangedNotificationData\n//         });\n//         notifications.push(dataChangeNotification);\n//     }\n\n//     // add dataChangeNotification\n//     if (eventNotificationListData.length) {\n//         const eventNotificationList = new EventNotificationList({\n//             events: eventNotificationListData\n//         });\n//         notifications.push(eventNotificationList);\n//     }\n//     return notifications.length === 0 ? null : notifications;\n// }\nconst INVALID_ID = -1;\n\nexport type Notification = DataChangeNotification | EventNotificationList | StatusChangeNotification;\nexport type Counter = number;\n\nexport interface ModifySubscriptionParameters {\n    /**\n     *     requestedPublishingInterval =0 means fastest possible\n     */\n    requestedPublishingInterval?: Duration;\n    /*\n     * requestedLifetimeCount=0 means no change\n     */\n    requestedLifetimeCount?: Counter;\n    /**\n     * requestedMaxKeepAliveCount  ===0 means no change\n     */\n    requestedMaxKeepAliveCount?: Counter;\n    maxNotificationsPerPublish?: Counter;\n    priority?: Byte;\n}\n\nexport interface GetMonitoredItemsResult {\n    /**\n     * array of serverHandles for all MonitoredItems of the subscription\n     * identified by subscriptionId.\n     */\n    serverHandles: Uint32Array;\n    /**\n     *  array of clientHandles for all MonitoredItems of the subscription\n     *  identified by subscriptionId.\n     */\n    clientHandles: Uint32Array;\n    statusCode: StatusCode;\n}\n\nexport interface InternalNotification {\n    monitoredItemId?: number;\n    notification: QueueItem | StatusChangeNotification;\n    publishTime: Date;\n    start_tick: number;\n}\n\nexport interface InternalCreateMonitoredItemResult {\n    monitoredItem?: MonitoredItem;\n    monitoredItemCreateRequest: MonitoredItemCreateRequest;\n    createResult: MonitoredItemCreateResult;\n}\n\nexport interface MonitoredItemBase {\n    node: any | null;\n}\nexport type CreateMonitoredItemHook = (subscription: Subscription, monitoredItem: MonitoredItemBase) => Promise<StatusCode>;\nexport type DeleteMonitoredItemHook = (subscription: Subscription, monitoredItem: MonitoredItemBase) => Promise<StatusCode>;\n\nexport interface ServerCapabilitiesPartial {\n    maxMonitoredItems: UInt32;\n    maxMonitoredItemsPerSubscription: UInt32;\n}\n\n/**\n * The Subscription class used in the OPCUA server side.\n */\nexport class Subscription extends EventEmitter {\n    public static minimumPublishingInterval = 50; // fastest possible\n    public static defaultPublishingInterval = 1000; // one second\n    public static maximumPublishingInterval: number = 1000 * 60; // one minute\n    public static maxNotificationPerPublishHighLimit = 1000;\n    public static minimumLifetimeDuration = 5 * 1000; //  // we want 2 seconds minimum lifetime for any subscription\n    public static maximumLifetimeDuration = 60 * 60 * 1000; // 1 hour\n\n    /**\n     * maximum number of monitored item in a subscription to be used\n     * when serverCapacity.maxMonitoredItems and serverCapacity.maxMonitoredItemsPerSubscription are not set.\n     */\n    public static defaultMaxMonitoredItemCount = 20000;\n\n    /**\n     * @deprecated use serverCapacity.maxMonitoredItems and serverCapacity.maxMonitoredItemsPerSubscription instead\n     */\n    protected static get maxMonitoredItemCount() {\n        return Subscription.defaultMaxMonitoredItemCount;\n    }\n\n    public static registry = new ObjectRegistry();\n\n    public publishEngine?: IServerSidePublishEngine;\n    public id: number;\n    public priority: number;\n    /**\n     * the Subscription publishing interval\n     * @default 1000\n     */\n    public publishingInterval: number;\n    /**\n     * The keep alive count defines how many times the publish interval need to\n     * expires without having notifications available before the server send an\n     * empty message.\n     * OPCUA Spec says: a value of 0 is invalid.\n     * @default 10\n     *\n     */\n    public maxKeepAliveCount: number;\n    /**\n     * The life time count defines how many times the publish interval expires without\n     * having a connection to the client to deliver data.\n     * If the life time count reaches maxKeepAliveCount, the subscription will\n     * automatically terminate.\n     * OPCUA Spec: The life-time count shall be a minimum of three times the keep keep-alive count.\n     *\n     * Note: this has to be interpreted as without having a PublishRequest available\n     * @default 1\n     */\n    public lifeTimeCount: number;\n    /**\n     * The maximum number of notifications that the Client wishes to receive in a\n     * single Publish response. A value of zero indicates that there is no limit.\n     * The number of notifications per Publish is the sum of monitoredItems in the\n     * DataChangeNotification and events in the EventNotificationList.\n     *\n     * @property maxNotificationsPerPublish\n     * @default 0\n     */\n    public maxNotificationsPerPublish: number;\n    public publishingEnabled: boolean;\n    public subscriptionDiagnostics: SubscriptionDiagnosticsDataTypePriv;\n    public publishIntervalCount: number;\n    /**\n     *  number of monitored Item\n     */\n    public monitoredItemIdCounter: number;\n\n    private _state: SubscriptionState = -1 as SubscriptionState;\n    public set state(value: SubscriptionState) {\n        if (this._state !== value) {\n            this._state = value;\n            this.emit(\"stateChanged\", value);\n        }\n    }\n    public get state(): SubscriptionState {\n        return this._state;\n    }\n\n    public messageSent: boolean;\n    public $session?: ServerSession;\n\n    public get sessionId(): NodeId {\n        return this.$session ? this.$session.nodeId : NodeId.nullNodeId;\n    }\n\n    public get currentLifetimeCount(): number {\n        return this._life_time_counter;\n    }\n    public get currentKeepAliveCount(): number {\n        return this._keep_alive_counter;\n    }\n\n    private _life_time_counter: number;\n    private _keep_alive_counter = 0;\n    private _pending_notifications: Queue<InternalNotification>;\n    private _sent_notification_messages: NotificationMessage[];\n    private readonly _sequence_number_generator: SequenceNumberGenerator;\n    private readonly monitoredItems: { [key: number]: MonitoredItem };\n    private timerId: any;\n    private _hasUncollectedMonitoredItemNotifications = false;\n\n    private globalCounter: IGlobalMonitoredItemCounter;\n    private serverCapabilities: ServerCapabilitiesPartial;\n\n    constructor(options: SubscriptionOptions) {\n        super();\n\n        options = options || {};\n\n        Subscription.registry.register(this);\n\n        assert(this.sessionId instanceof NodeId, \"expecting a sessionId NodeId\");\n\n        this.publishEngine = options.publishEngine!;\n\n        this.id = options.id || INVALID_ID;\n\n        this.priority = options.priority || 0;\n\n        this.publishingInterval = _adjust_publishing_interval(options.publishingInterval);\n\n        this.maxKeepAliveCount = _adjust_maxKeepAliveCount(options.maxKeepAliveCount); // , this.publishingInterval);\n\n        this.resetKeepAliveCounter();\n\n        this.lifeTimeCount = _adjust_lifeTimeCount(options.lifeTimeCount || 0, this.maxKeepAliveCount, this.publishingInterval);\n\n        this.maxNotificationsPerPublish = _adjust_maxNotificationsPerPublish(options.maxNotificationsPerPublish);\n\n        this._life_time_counter = 0;\n        this.resetLifeTimeCounter();\n\n        // notification message that are ready to be sent to the client\n        this._pending_notifications = new Queue<InternalNotification>();\n\n        this._sent_notification_messages = [];\n\n        this._sequence_number_generator = new SequenceNumberGenerator();\n\n        // initial state of the subscription\n        this.state = SubscriptionState.CREATING;\n\n        this.publishIntervalCount = 0;\n\n        this.monitoredItems = {}; // monitored item map\n\n        this.monitoredItemIdCounter = 0;\n\n        this.publishingEnabled = _adjust_publishingEnable(options.publishingEnabled);\n\n        this.subscriptionDiagnostics = createSubscriptionDiagnostics(this);\n\n        // A boolean value that is set to TRUE to mean that either a NotificationMessage or a keep-alive\n        // Message has been sent on the Subscription. It is a flag that is used to ensure that either a\n        // NotificationMessage or a keep-alive Message is sent out the first time the publishing\n        // timer expires.\n        this.messageSent = false;\n\n        this.timerId = null;\n        this._start_timer({ firstTime: true });\n\n        debugLog(chalk.green(`creating subscription ${this.id}`));\n\n        this.serverCapabilities = options.serverCapabilities;\n        this.serverCapabilities.maxMonitoredItems =\n            this.serverCapabilities.maxMonitoredItems || Subscription.defaultMaxMonitoredItemCount;\n        this.serverCapabilities.maxMonitoredItemsPerSubscription =\n            this.serverCapabilities.maxMonitoredItemsPerSubscription || Subscription.defaultMaxMonitoredItemCount;\n        this.globalCounter = options.globalCounter;\n    }\n\n    public getSessionId(): NodeId {\n        return this.sessionId;\n    }\n\n    public toString(): string {\n        let str = \"Subscription:\\n\";\n        str += \"  subscriptionId          \" + this.id + \"\\n\";\n        str += \"  sessionId          \" + this.getSessionId().toString() + \"\\n\";\n\n        str += \"  publishingEnabled  \" + this.publishingEnabled + \"\\n\";\n        str += \"  maxKeepAliveCount  \" + this.maxKeepAliveCount + \"\\n\";\n        str += \"  publishingInterval \" + this.publishingInterval + \"\\n\";\n        str += \"  lifeTimeCount      \" + this.lifeTimeCount + \"\\n\";\n        str += \"  maxKeepAliveCount  \" + this.maxKeepAliveCount + \"\\n\";\n        return str;\n    }\n\n    /**\n     * modify subscription parameters\n     * @param param\n     */\n    public modify(param: ModifySubscriptionParameters): void {\n        // update diagnostic counter\n        this.subscriptionDiagnostics.modifyCount += 1;\n\n        const publishingInterval_old = this.publishingInterval;\n\n        param.requestedPublishingInterval = param.requestedPublishingInterval || 0;\n        param.requestedMaxKeepAliveCount = param.requestedMaxKeepAliveCount || this.maxKeepAliveCount;\n        param.requestedLifetimeCount = param.requestedLifetimeCount || this.lifeTimeCount;\n\n        this.publishingInterval = _adjust_publishing_interval(param.requestedPublishingInterval);\n        this.maxKeepAliveCount = _adjust_maxKeepAliveCount(param.requestedMaxKeepAliveCount);\n\n        this.lifeTimeCount = _adjust_lifeTimeCount(param.requestedLifetimeCount, this.maxKeepAliveCount, this.publishingInterval);\n\n        this.maxNotificationsPerPublish = _adjust_maxNotificationsPerPublish(param.maxNotificationsPerPublish || 0);\n        this.priority = param.priority || 0;\n\n        this.resetLifeTimeAndKeepAliveCounters();\n\n        if (publishingInterval_old !== this.publishingInterval) {\n            // todo\n        }\n        this._stop_timer();\n        this._start_timer({ firstTime: false });\n    }\n\n    /**\n     * set publishing mode\n     * @param publishingEnabled\n     */\n    public setPublishingMode(publishingEnabled: boolean): StatusCode {\n        this.publishingEnabled = !!publishingEnabled;\n        // update diagnostics\n        if (this.publishingEnabled) {\n            this.subscriptionDiagnostics.enableCount += 1;\n        } else {\n            this.subscriptionDiagnostics.disableCount += 1;\n        }\n\n        this.resetLifeTimeCounter();\n\n        if (!publishingEnabled && this.state !== SubscriptionState.CLOSED) {\n            this.state = SubscriptionState.NORMAL;\n        }\n        return StatusCodes.Good;\n    }\n\n    /**\n     * @private\n     */\n    public get keepAliveCounterHasExpired(): boolean {\n        return this._keep_alive_counter >= this.maxKeepAliveCount || this.state === SubscriptionState.LATE;\n    }\n\n    /**\n     * Reset the Lifetime Counter Variable to the value specified for the lifetime of a Subscription in\n     * the CreateSubscription Service( 5.13.2).\n     * @private\n     */\n    public resetLifeTimeCounter(): void {\n        this._life_time_counter = 0;\n    }\n\n    /**\n     * @private\n     */\n    public increaseLifeTimeCounter(): void {\n        this._life_time_counter += 1;\n        if (this._life_time_counter >= this.lifeTimeCount) {\n            this.emit(\"lifeTimeExpired\");\n        }\n        this.emit(\"lifeTimeCounterChanged\", this._life_time_counter);\n    }\n\n    /**\n     *  True if the subscription life time has expired.\n     *\n     */\n    public get lifeTimeHasExpired(): boolean {\n        assert(this.lifeTimeCount > 0);\n        return this._life_time_counter >= this.lifeTimeCount;\n    }\n\n    /**\n     * number of milliseconds before this subscription times out (lifeTimeHasExpired === true);\n     */\n    public get timeToExpiration(): number {\n        return (this.lifeTimeCount - this._life_time_counter) * this.publishingInterval;\n    }\n\n    public get timeToKeepAlive(): number {\n        return (this.maxKeepAliveCount - this._keep_alive_counter) * this.publishingInterval;\n    }\n\n    /**\n     * Terminates the subscription.\n     * Calling this method will also remove any monitored items.\n     *\n     */\n    public terminate(): void {\n        assert(arguments.length === 0);\n        debugLog(\"Subscription#terminate status\", SubscriptionState[this.state]);\n\n        if (this.state === SubscriptionState.CLOSED) {\n            // todo verify if asserting is required here\n            return;\n        }\n\n        // stop timer\n        this._stop_timer();\n\n        debugLog(\"terminating Subscription  \", this.id, \" with \", this.monitoredItemCount, \" monitored items\");\n\n        // dispose all monitoredItem\n        const keys = Object.keys(this.monitoredItems);\n\n        for (const key of keys) {\n            const status = this.removeMonitoredItem(parseInt(key, 10));\n            assert(status === StatusCodes.Good);\n        }\n        assert(this.monitoredItemCount === 0);\n\n        if (this.$session) {\n            this.$session._unexposeSubscriptionDiagnostics(this);\n        }\n        this.state = SubscriptionState.CLOSED;\n\n        /**\n         * notify the subscription owner that the subscription has been terminated.\n         * @event \"terminated\"\n         */\n        this.emit(\"terminated\");\n        if (this.publishEngine) {\n            this.publishEngine.on_close_subscription(this);\n        }\n    }\n\n    public setTriggering(\n        triggeringItemId: number,\n        linksToAdd: number[] | null,\n        linksToRemove: number[] | null\n    ): { statusCode: StatusCode; addResults: StatusCode[]; removeResults: StatusCode[] } {\n        /** Bad_NothingToDo, Bad_TooManyOperations,Bad_SubscriptionIdInvalid, Bad_MonitoredItemIdInvalid */\n        linksToAdd = linksToAdd || [];\n        linksToRemove = linksToRemove || [];\n\n        if (linksToAdd.length === 0 && linksToRemove.length === 0) {\n            return { statusCode: StatusCodes.BadNothingToDo, addResults: [], removeResults: [] };\n        }\n        const triggeringItem = this.getMonitoredItem(triggeringItemId);\n\n        const monitoredItemsToAdd = linksToAdd.map((id) => this.getMonitoredItem(id));\n        const monitoredItemsToRemove = linksToRemove.map((id) => this.getMonitoredItem(id));\n\n        if (!triggeringItem) {\n            const removeResults1: StatusCode[] = monitoredItemsToRemove.map((m) =>\n                m ? StatusCodes.Good : StatusCodes.BadMonitoredItemIdInvalid\n            );\n            const addResults1: StatusCode[] = monitoredItemsToAdd.map((m) =>\n                m ? StatusCodes.Good : StatusCodes.BadMonitoredItemIdInvalid\n            );\n            return {\n                statusCode: StatusCodes.BadMonitoredItemIdInvalid,\n\n                addResults: addResults1,\n                removeResults: removeResults1\n            };\n        }\n        //\n        // note: it seems that CTT imposed that we do remove before add\n        const removeResults = monitoredItemsToRemove.map((m) =>\n            !m ? StatusCodes.BadMonitoredItemIdInvalid : triggeringItem.removeLinkItem(m.monitoredItemId)\n        );\n        const addResults = monitoredItemsToAdd.map((m) =>\n            !m ? StatusCodes.BadMonitoredItemIdInvalid : triggeringItem.addLinkItem(m.monitoredItemId)\n        );\n\n        const statusCode: StatusCode = StatusCodes.Good;\n\n        // do binding\n\n        return {\n            statusCode,\n\n            addResults,\n            removeResults\n        };\n    }\n    public dispose(): void {\n        if (doDebug) {\n            debugLog(\"Subscription#dispose\", this.id, this.monitoredItemCount);\n        }\n\n        assert(this.monitoredItemCount === 0, \"MonitoredItems haven't been  deleted first !!!\");\n        assert(this.timerId === null, \"Subscription timer haven't been terminated\");\n\n        if (this.subscriptionDiagnostics) {\n            (this.subscriptionDiagnostics as SubscriptionDiagnosticsDataTypePriv).$subscription = null as any as Subscription;\n        }\n\n        this.publishEngine = undefined;\n        this._pending_notifications.clear();\n        this._sent_notification_messages = [];\n\n        this.$session = undefined;\n        this.removeAllListeners();\n\n        Subscription.registry.unregister(this);\n    }\n\n    public get aborted(): boolean {\n        const session = this.$session;\n        if (!session) {\n            return true;\n        }\n        return session.aborted;\n    }\n\n    /**\n     * number of pending notifications\n     */\n    public get pendingNotificationsCount(): number {\n        return this._pending_notifications ? this._pending_notifications.size : 0;\n    }\n\n    /**\n     * is 'true' if there are pending notifications for this subscription. (i.e moreNotifications)\n     */\n    public get hasPendingNotifications(): boolean {\n        return this.pendingNotificationsCount > 0;\n    }\n\n    /**\n     * number of sent notifications\n     */\n    public get sentNotificationMessageCount(): number {\n        return this._sent_notification_messages.length;\n    }\n\n    /**\n     * @internal\n     */\n    public _flushSentNotifications(): NotificationMessage[] {\n        const tmp = this._sent_notification_messages;\n        this._sent_notification_messages = [];\n        return tmp;\n    }\n    /**\n     * number of monitored items handled by this subscription\n     */\n    public get monitoredItemCount(): number {\n        return Object.keys(this.monitoredItems).length;\n    }\n\n    /**\n     * number of disabled monitored items.\n     */\n    public get disabledMonitoredItemCount(): number {\n        return Object.values(this.monitoredItems).reduce((cumul: any, monitoredItem: MonitoredItem) => {\n            return cumul + (monitoredItem.monitoringMode === MonitoringMode.Disabled ? 1 : 0);\n        }, 0);\n    }\n\n    /**\n     * The number of unacknowledged messages saved in the republish queue.\n     */\n    public get unacknowledgedMessageCount(): number {\n        return this.subscriptionDiagnostics.unacknowledgedMessageCount;\n    }\n\n    /**\n     * adjust monitored item sampling interval\n     *  - an samplingInterval ===0 means that we use a event-base model ( no sampling)\n     *  - otherwise the sampling is adjusted\n     * @private\n     */\n    public adjustSamplingInterval(samplingInterval: number, node: BaseNode): number {\n        if (samplingInterval < 0) {\n            // - The value -1 indicates that the default sampling interval defined by the publishing\n            //   interval of the Subscription is requested.\n            // - Any negative number is interpreted as -1.\n            samplingInterval = this.publishingInterval;\n        } else if (samplingInterval === 0) {\n            // OPCUA 1.0.3 Part 4 - 5.12.1.2\n            // The value 0 indicates that the Server should use the fastest practical rate.\n\n            // The fastest supported sampling interval may be equal to 0, which indicates\n            // that the data item is exception-based rather than being sampled at some period.\n            // An exception-based model means that the underlying system does not require\n            // sampling and reports data changes.\n\n            const dataValueSamplingInterval = node.readAttribute(\n                SessionContext.defaultContext,\n                AttributeIds.MinimumSamplingInterval\n            );\n\n            // TODO if attributeId === AttributeIds.Value : sampling interval required here\n            if (dataValueSamplingInterval.statusCode === StatusCodes.Good) {\n                // node provides a Minimum sampling interval ...\n                samplingInterval = dataValueSamplingInterval.value.value;\n                assert(samplingInterval >= 0 && samplingInterval <= MonitoredItem.maximumSamplingInterval);\n\n                // note : at this stage, a samplingInterval===0 means that the data item is really exception-based\n            }\n        } else if (samplingInterval < MonitoredItem.minimumSamplingInterval) {\n            samplingInterval = MonitoredItem.minimumSamplingInterval;\n        } else if (samplingInterval > MonitoredItem.maximumSamplingInterval) {\n            // If the requested samplingInterval is higher than the\n            // maximum sampling interval supported by the Server, the maximum sampling\n            // interval is returned.\n            samplingInterval = MonitoredItem.maximumSamplingInterval;\n        }\n\n        const node_minimumSamplingInterval =\n            node && (node as any).minimumSamplingInterval ? (node as any).minimumSamplingInterval : 0;\n\n        samplingInterval = Math.max(samplingInterval, node_minimumSamplingInterval);\n\n        return samplingInterval;\n    }\n\n    /**\n     * create a monitored item\n     * @param addressSpace - address space\n     * @param timestampsToReturn  - the timestamp to return\n     * @param monitoredItemCreateRequest - the parameters describing the monitored Item to create\n     */\n    public preCreateMonitoredItem(\n        addressSpace: AddressSpace,\n        timestampsToReturn: TimestampsToReturn,\n        monitoredItemCreateRequest: MonitoredItemCreateRequest\n    ): InternalCreateMonitoredItemResult {\n        assert(monitoredItemCreateRequest instanceof MonitoredItemCreateRequest);\n\n        function handle_error(statusCode: StatusCode): InternalCreateMonitoredItemResult {\n            return {\n                createResult: new MonitoredItemCreateResult({ statusCode }),\n                monitoredItemCreateRequest\n            };\n        }\n\n        const itemToMonitor = monitoredItemCreateRequest.itemToMonitor;\n\n        const node = addressSpace.findNode(itemToMonitor.nodeId);\n        if (!node) {\n            return handle_error(StatusCodes.BadNodeIdUnknown);\n        }\n\n        if (itemToMonitor.attributeId === AttributeIds.Value && !(node.nodeClass === NodeClass.Variable)) {\n            // AttributeIds.Value is only valid for monitoring value of UAVariables.\n            return handle_error(StatusCodes.BadAttributeIdInvalid);\n        }\n\n        if (itemToMonitor.attributeId === AttributeIds.INVALID) {\n            return handle_error(StatusCodes.BadAttributeIdInvalid);\n        }\n\n        if (!itemToMonitor.indexRange.isValid()) {\n            return handle_error(StatusCodes.BadIndexRangeInvalid);\n        }\n\n        // check dataEncoding applies only on Values\n        if (itemToMonitor.dataEncoding.name && itemToMonitor.attributeId !== AttributeIds.Value) {\n            return handle_error(StatusCodes.BadDataEncodingInvalid);\n        }\n\n        // check dataEncoding\n        if (!isValidDataEncoding(itemToMonitor.dataEncoding)) {\n            return handle_error(StatusCodes.BadDataEncodingUnsupported);\n        }\n\n        // check that item can be read by current user session\n\n        // filter\n        const requestedParameters = monitoredItemCreateRequest.requestedParameters;\n        const filter = requestedParameters.filter;\n        const statusCodeFilter = validateFilter(filter, itemToMonitor, node);\n        if (statusCodeFilter !== StatusCodes.Good) {\n            return handle_error(statusCodeFilter);\n        }\n\n        // do we have enough room for new monitored items ?\n        if (this.monitoredItemCount >= this.serverCapabilities.maxMonitoredItemsPerSubscription) {\n            return handle_error(StatusCodes.BadTooManyMonitoredItems);\n        }\n\n        if (this.globalCounter.totalMonitoredItemCount >= this.serverCapabilities.maxMonitoredItems) {\n            return handle_error(StatusCodes.BadTooManyMonitoredItems);\n        }\n\n        const createResult = this._createMonitoredItemStep2(timestampsToReturn, monitoredItemCreateRequest, node);\n\n        assert(createResult.statusCode === StatusCodes.Good);\n\n        const monitoredItem = this.getMonitoredItem(createResult.monitoredItemId);\n        // istanbul ignore next\n        if (!monitoredItem) {\n            throw new Error(\"internal error\");\n        }\n\n        // TODO: fix old way to set node. !!!!\n        monitoredItem.setNode(node);\n\n        this.emit(\"monitoredItem\", monitoredItem, itemToMonitor);\n\n        return { monitoredItem, monitoredItemCreateRequest, createResult };\n    }\n\n    public async applyOnMonitoredItem(functor: (monitoredItem: MonitoredItem) => Promise<void>): Promise<void> {\n        for (const m of Object.values(this.monitoredItems)) {\n            await functor(m);\n        }\n    }\n\n    public postCreateMonitoredItem(\n        monitoredItem: MonitoredItem,\n        monitoredItemCreateRequest: MonitoredItemCreateRequest,\n        createResult: MonitoredItemCreateResult\n    ): void {\n        this._createMonitoredItemStep3(monitoredItem, monitoredItemCreateRequest);\n    }\n\n    public createMonitoredItem(\n        addressSpace: AddressSpace,\n        timestampsToReturn: TimestampsToReturn,\n        monitoredItemCreateRequest: MonitoredItemCreateRequest\n    ): MonitoredItemCreateResult {\n        const { monitoredItem, createResult } = this.preCreateMonitoredItem(\n            addressSpace,\n            timestampsToReturn,\n            monitoredItemCreateRequest\n        );\n        this.postCreateMonitoredItem(monitoredItem!, monitoredItemCreateRequest, createResult);\n        return createResult;\n    }\n    /**\n     * get a monitoredItem by Id.\n     * @param monitoredItemId : the id of the monitored item to get.\n     * @return the monitored item matching monitoredItemId\n     */\n    public getMonitoredItem(monitoredItemId: number): MonitoredItem | null {\n        return this.monitoredItems[monitoredItemId] || null;\n    }\n\n    /**\n     * remove a monitored Item from the subscription.\n     * @param monitoredItemId : the id of the monitored item to get.\n     */\n    public removeMonitoredItem(monitoredItemId: number): StatusCode {\n        debugLog(\"Removing monitoredIem \", monitoredItemId);\n        if (!Object.prototype.hasOwnProperty.call(this.monitoredItems, monitoredItemId.toString())) {\n            return StatusCodes.BadMonitoredItemIdInvalid;\n        }\n\n        const monitoredItem = this.monitoredItems[monitoredItemId];\n\n        monitoredItem.terminate();\n\n        monitoredItem.dispose();\n\n        /**\n         *\n         * notify that a monitored item has been removed from the subscription\n         * @param monitoredItem {MonitoredItem}\n         */\n        this.emit(\"removeMonitoredItem\", monitoredItem);\n\n        delete this.monitoredItems[monitoredItemId];\n        this.globalCounter.totalMonitoredItemCount -= 1;\n\n        this._removePendingNotificationsFor(monitoredItemId);\n        // flush pending notifications\n        // assert(this._pending_notifications.size === 0);\n        return StatusCodes.Good;\n    }\n\n    /**\n     * rue if monitored Item have uncollected Notifications\n     */\n    public get hasUncollectedMonitoredItemNotifications(): boolean {\n        if (this._hasUncollectedMonitoredItemNotifications) {\n            return true;\n        }\n        const keys = Object.keys(this.monitoredItems);\n        const n = keys.length;\n        for (let i = 0; i < n; i++) {\n            const key = parseInt(keys[i], 10);\n            const monitoredItem = this.monitoredItems[key];\n            if (monitoredItem.hasMonitoredItemNotifications) {\n                this._hasUncollectedMonitoredItemNotifications = true;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public get subscriptionId(): number {\n        return this.id;\n    }\n\n    public getMessageForSequenceNumber(sequenceNumber: number): NotificationMessage | null {\n        const notification_message = this._sent_notification_messages.find((e) => e.sequenceNumber === sequenceNumber);\n        return notification_message || null;\n    }\n\n    /**\n     * returns true if the notification has expired\n     * @param notification\n     */\n    public notificationHasExpired(notification: { start_tick: number }): boolean {\n        assert(Object.prototype.hasOwnProperty.call(notification, \"start_tick\"));\n        assert(isFinite(notification.start_tick + this.maxKeepAliveCount));\n        return notification.start_tick + this.maxKeepAliveCount < this.publishIntervalCount;\n    }\n\n    /**\n     *  returns in an array the sequence numbers of the notifications that have been sent\n     *  and that haven't been acknowledged yet.\n     */\n    public getAvailableSequenceNumbers(): number[] {\n        const availableSequenceNumbers = _getSequenceNumbers(this._sent_notification_messages);\n        return availableSequenceNumbers;\n    }\n\n    /**\n     * acknowledges a notification identified by its sequence number\n     */\n    public acknowledgeNotification(sequenceNumber: number): StatusCode {\n        debugLog(\"acknowledgeNotification \", sequenceNumber);\n        let foundIndex = -1;\n        this._sent_notification_messages.forEach((e: NotificationMessage, index: number) => {\n            if (e.sequenceNumber === sequenceNumber) {\n                foundIndex = index;\n            }\n        });\n\n        if (foundIndex === -1) {\n            if (doDebug) {\n                debugLog(chalk.red(\"acknowledging sequence FAILED !!! \"), chalk.cyan(sequenceNumber.toString()));\n            }\n            return StatusCodes.BadSequenceNumberUnknown;\n        } else {\n            if (doDebug) {\n                debugLog(chalk.yellow(\"acknowledging sequence \"), chalk.cyan(sequenceNumber.toString()));\n            }\n            this._sent_notification_messages.splice(foundIndex, 1);\n            this.subscriptionDiagnostics.unacknowledgedMessageCount--;\n            return StatusCodes.Good;\n        }\n    }\n\n    /**\n     * getMonitoredItems is used to get information about monitored items of a subscription.Its intended\n     * use is defined in Part 4. This method is the implementation of the Standard OPCUA GetMonitoredItems Method.\n     * from spec:\n     * This method can be used to get the  list of monitored items in a subscription if CreateMonitoredItems\n     * failed due to a network interruption and the client does not know if the creation succeeded in the server.\n     *\n     */\n    public getMonitoredItems(): GetMonitoredItemsResult {\n        const monitoredItems = Object.keys(this.monitoredItems);\n        const monitoredItemCount = monitoredItems.length;\n        const result: GetMonitoredItemsResult = {\n            clientHandles: new Uint32Array(monitoredItemCount),\n            serverHandles: new Uint32Array(monitoredItemCount),\n            statusCode: StatusCodes.Good\n        };\n        for (let index = 0; index < monitoredItemCount; index++) {\n            const monitoredItemId = monitoredItems[index];\n            const serverHandle = parseInt(monitoredItemId, 10);\n            const monitoredItem = this.getMonitoredItem(serverHandle)!;\n            result.clientHandles[index] = monitoredItem.clientHandle;\n            // TODO:  serverHandle is defined anywhere in the OPCUA Specification 1.02\n            //        I am not sure what shall be reported for serverHandle...\n            //        using monitoredItem.monitoredItemId instead...\n            //        May be a clarification in the OPCUA Spec is required.\n            result.serverHandles[index] = serverHandle;\n        }\n        return result;\n    }\n\n    /**\n     * @private\n     */\n    public async resendInitialValues(): Promise<void> {\n        const promises: Promise<void>[] = [];\n        for (const monitoredItem of Object.values(this.monitoredItems)) {\n            assert(monitoredItem.clientHandle !== 4294967295);\n            promises.push(monitoredItem.resendInitialValues());\n        }\n        await Promise.all(promises);\n        this._harvestMonitoredItems();\n    }\n\n    /**\n     * @private\n     */\n    public notifyTransfer(): void {\n        // OPCUA UA Spec 1.0.3 : part 3 - page 82 - 5.13.7 TransferSubscriptions:\n        // If the Server transfers the Subscription to the new Session, the Server shall issue\n        // a StatusChangeNotification notificationMessage with the status code\n        // Good_SubscriptionTransferred to the old Session.\n        debugLog(chalk.red(\" Subscription => Notifying Transfer                                  \"));\n\n        const notificationData = new StatusChangeNotification({\n            status: StatusCodes.GoodSubscriptionTransferred\n        });\n\n        if (this.publishEngine!.pendingPublishRequestCount) {\n            // the GoodSubscriptionTransferred can be processed immediately\n            this._addNotificationMessage(notificationData);\n            debugLog(chalk.red(\"pendingPublishRequestCount\"), this.publishEngine?.pendingPublishRequestCount);\n            this._publish_pending_notifications();\n        } else {\n            debugLog(chalk.red(\"Cannot  send GoodSubscriptionTransferred => lets create a TransferredSubscription \"));\n            const ts = new TransferredSubscription({\n                generator: this._sequence_number_generator,\n                id: this.id,\n                publishEngine: this.publishEngine\n            });\n\n            ts._pending_notification = notificationData;\n            (this.publishEngine as any)._closed_subscriptions.push(ts);\n        }\n    }\n\n    /**\n     *\n     *  the server invokes the resetLifeTimeAndKeepAliveCounters method of the subscription\n     *  when the server  has send a Publish Response, so that the subscription\n     *  can reset its life time counter.\n     *\n     * @private\n     */\n    public resetLifeTimeAndKeepAliveCounters(): void {\n        this.resetLifeTimeCounter();\n        this.resetKeepAliveCounter();\n    }\n\n    private _updateCounters(notificationMessage: NotificationMessage) {\n        for (const notificationData of notificationMessage.notificationData || []) {\n            // update diagnostics\n            if (notificationData instanceof DataChangeNotification) {\n                const nbNotifs = notificationData.monitoredItems!.length;\n                this.subscriptionDiagnostics.dataChangeNotificationsCount += nbNotifs;\n                this.subscriptionDiagnostics.notificationsCount += nbNotifs;\n            } else if (notificationData instanceof EventNotificationList) {\n                const nbNotifs = notificationData.events!.length;\n                this.subscriptionDiagnostics.eventNotificationsCount += nbNotifs;\n                this.subscriptionDiagnostics.notificationsCount += nbNotifs;\n            } else {\n                assert(notificationData instanceof StatusChangeNotification);\n                // TODO\n                // note: :there is no way to count StatusChangeNotifications in opcua yet.\n            }\n        }\n    }\n    /**\n     *  _publish_pending_notifications send a \"notification\" event:\n     *\n     * @private\n     * @precondition\n     *     - pendingPublishRequestCount > 0\n     */\n    public _publish_pending_notifications(): void {\n        const publishEngine = this.publishEngine!;\n        const subscriptionId = this.id;\n        // preconditions\n        assert(publishEngine!.pendingPublishRequestCount > 0);\n        assert(this.hasPendingNotifications);\n\n        const notificationMessage = this._popNotificationToSend();\n        if (notificationMessage.notificationData!.length === 0) {\n            return; // nothing to do\n        }\n        const moreNotifications = this.hasPendingNotifications;\n\n        this.emit(\"notification\", notificationMessage);\n        // Update counters ....\n        this._updateCounters(notificationMessage);\n\n        assert(Object.prototype.hasOwnProperty.call(notificationMessage, \"sequenceNumber\"));\n        assert(Object.prototype.hasOwnProperty.call(notificationMessage, \"notificationData\"));\n        // update diagnostics\n        this.subscriptionDiagnostics.publishRequestCount += 1;\n\n        const response = new PublishResponse({\n            moreNotifications,\n            notificationMessage: {\n                notificationData: notificationMessage.notificationData,\n                sequenceNumber: this._get_next_sequence_number()\n            },\n            subscriptionId\n        });\n\n        this._sent_notification_messages.push(response.notificationMessage);\n\n        // get available sequence number;\n        const availableSequenceNumbers = this.getAvailableSequenceNumbers();\n        assert(\n            !response.notificationMessage ||\n                availableSequenceNumbers[availableSequenceNumbers.length - 1] === response.notificationMessage.sequenceNumber\n        );\n        response.availableSequenceNumbers = availableSequenceNumbers;\n\n        publishEngine._send_response(this, response);\n\n        this.messageSent = true;\n\n        this.subscriptionDiagnostics.unacknowledgedMessageCount++;\n\n        this.resetLifeTimeAndKeepAliveCounters();\n\n        if (doDebug) {\n            debugLog(\n                \"Subscription sending a notificationMessage subscriptionId=\",\n                subscriptionId,\n                \"sequenceNumber = \",\n                notificationMessage.sequenceNumber.toString(),\n                notificationMessage.notificationData?.map((x) => x?.constructor.name).join(\" \")\n            );\n            // debugLog(notificationMessage.toString());\n        }\n\n        if (this.state !== SubscriptionState.CLOSED) {\n            assert(notificationMessage.notificationData!.length > 0, \"We are not expecting a keep-alive message here\");\n            this.state = SubscriptionState.NORMAL;\n            debugLog(\"subscription \" + this.id + chalk.bgYellow(\" set to NORMAL\"));\n        }\n    }\n\n    public process_subscription(): void {\n        assert(this.publishEngine!.pendingPublishRequestCount > 0);\n\n        if (!this.publishingEnabled) {\n            // no publish to do, except keep alive\n            debugLog(\"    -> no publish to do, except keep alive\");\n            this._process_keepAlive();\n            return;\n        }\n\n        if (!this.hasPendingNotifications && this.hasUncollectedMonitoredItemNotifications) {\n            // collect notification from monitored items\n            this._harvestMonitoredItems();\n        }\n\n        // let process them first\n        if (this.hasPendingNotifications) {\n            this._publish_pending_notifications();\n\n            if (this.state === SubscriptionState.NORMAL && this.hasPendingNotifications) {\n                // istanbul ignore next\n                if (doDebug) {\n                    debugLog(\"    -> pendingPublishRequestCount > 0 \" + \"&& normal state => re-trigger tick event immediately \");\n                }\n\n                // let process an new publish request\n                setImmediate(this._tick.bind(this));\n            }\n        } else {\n            this._process_keepAlive();\n        }\n    }\n\n    public _get_future_sequence_number(): number {\n        return this._sequence_number_generator ? this._sequence_number_generator.future() : 0;\n    }\n\n    private _process_keepAlive() {\n        this.increaseKeepAliveCounter();\n\n        if (this.keepAliveCounterHasExpired) {\n            debugLog(`     ->  _process_keepAlive => keepAliveCounterHasExpired`);\n            if (this._sendKeepAliveResponse()) {\n                this.resetLifeTimeAndKeepAliveCounters();\n            } else {\n                debugLog(\n                    \"     -> subscription.state === LATE , \" +\n                        \"because keepAlive Response cannot be send due to lack of PublishRequest\"\n                );\n                if (this.messageSent || this.keepAliveCounterHasExpired) {\n                    this.state = SubscriptionState.LATE;\n                }\n            }\n        }\n    }\n\n    private _stop_timer() {\n        if (this.timerId) {\n            debugLog(chalk.bgWhite.blue(\"Subscription#_stop_timer subscriptionId=\"), this.id);\n            clearInterval(this.timerId);\n            this.timerId = null;\n        }\n    }\n\n    private _start_timer({ firstTime }: { firstTime: boolean }) {\n        debugLog(\n            chalk.bgWhite.blue(\"Subscription#_start_timer  subscriptionId=\"),\n            this.id,\n            \" publishingInterval = \",\n            this.publishingInterval\n        );\n\n        assert(this.timerId === null);\n        // from the spec:\n        // When a Subscription is created, the first Message is sent at the end of the first publishing cycle to\n        // inform the Client that the Subscription is operational. A NotificationMessage is sent if there are\n        // Notifications ready to be reported. If there are none, a keep-alive Message is sent instead that\n        // contains a sequence number of 1, indicating that the first NotificationMessage has not yet been sent.\n        // This is the only time a keep-alive Message is sent without waiting for the maximum keep-alive count\n        // to be reached, as specified in (f) above.\n\n        // make sure that a keep-alive Message will be send at the end of the first publishing cycle\n        // if there are no Notifications ready.\n        this._keep_alive_counter = 0; // this.maxKeepAliveCount;\n\n        if (firstTime) {\n            assert(this.messageSent === false);\n            assert(this.state === SubscriptionState.CREATING);\n        }\n\n        assert(this.publishingInterval >= Subscription.minimumPublishingInterval);\n        this.timerId = setInterval(this._tick.bind(this), this.publishingInterval);\n    }\n\n    // counter\n    private _get_next_sequence_number(): number {\n        return this._sequence_number_generator ? this._sequence_number_generator.next() : 0;\n    }\n\n    /**\n     * @private\n     */\n    private _tick() {\n        // istanbul ignore next\n        if (doDebug) {\n            debugLog(`Subscription#_tick id ${this.id} aborted=${this.aborted} state=${SubscriptionState[this.state]}`);\n        }\n        if (this.state === SubscriptionState.CLOSED) {\n            warningLog(`Warning: Subscription#_tick id ${this.id}  called while subscription is CLOSED`);\n            return;\n        }\n\n        this.discardOldSentNotifications();\n\n        // istanbul ignore next\n        if (doDebug) {\n            debugLog(\n                t(new Date()) + \"  \" + this._life_time_counter + \"/\" + this.lifeTimeCount + chalk.cyan(\"   Subscription#_tick\"),\n                \"  processing subscriptionId=\",\n                this.id,\n                \"hasUncollectedMonitoredItemNotifications = \",\n                this.hasUncollectedMonitoredItemNotifications,\n                \" publishingIntervalCount =\",\n                this.publishIntervalCount\n            );\n        }\n\n        // give a chance to the publish engine to cancel timed out publish requests\n        this.publishEngine!._on_tick();\n\n        this.publishIntervalCount += 1;\n\n        if (this.state === SubscriptionState.LATE) {\n            this.increaseLifeTimeCounter();\n        }\n\n        if (this.lifeTimeHasExpired) {\n            /* istanbul ignore next */\n            doDebug && debugLog(chalk.red.bold(`Subscription ${this.id} has expired !!!!! => Terminating`));\n\n            /**\n             * notify the subscription owner that the subscription has expired by exceeding its life time.\n             * @event expired\n             *\n             */\n            this.emit(\"expired\");\n\n            // notify new terminated status only when subscription has timeout.\n            doDebug && debugLog(\"adding StatusChangeNotification notification message for BadTimeout subscription = \", this.id);\n            this._addNotificationMessage(new StatusChangeNotification({ status: StatusCodes.BadTimeout }));\n\n            // kill timer and delete monitored items and transfer pending notification messages\n            this.terminate();\n\n            return;\n        }\n\n        const publishEngine = this.publishEngine!;\n\n        // istanbul ignore next\n        doDebug && debugLog(\"Subscription#_tick  self._pending_notifications= \", this._pending_notifications.size);\n\n        if (\n            publishEngine.pendingPublishRequestCount === 0 &&\n            (this.hasPendingNotifications || this.hasUncollectedMonitoredItemNotifications)\n        ) {\n            // istanbul ignore next\n            doDebug &&\n                debugLog(\n                    \"subscription set to LATE  hasPendingNotifications = \",\n                    this.hasPendingNotifications,\n                    \" hasUncollectedMonitoredItemNotifications =\",\n                    this.hasUncollectedMonitoredItemNotifications\n                );\n\n            this.state = SubscriptionState.LATE;\n            return;\n        }\n\n        if (publishEngine.pendingPublishRequestCount > 0) {\n            if (this.hasPendingNotifications) {\n                // simply pop pending notification and send it\n                this.process_subscription();\n            } else if (this.hasUncollectedMonitoredItemNotifications) {\n                this.process_subscription();\n            } else {\n                this._process_keepAlive();\n            }\n        } else {\n            if (this.state !== SubscriptionState.LATE) {\n                this._process_keepAlive();\n            } else {\n                this.resetKeepAliveCounter();\n            }\n        }\n    }\n\n    /**\n     * @private\n     */\n    private _sendKeepAliveResponse(): boolean {\n        const future_sequence_number = this._get_future_sequence_number();\n\n        if (this.publishEngine!.send_keep_alive_response(this.id, future_sequence_number)) {\n            this.messageSent = true;\n            // istanbul ignore next\n            doDebug &&\n                debugLog(\n                    `    -> Subscription#_sendKeepAliveResponse subscriptionId ${this.id} future_sequence_number ${future_sequence_number}`\n                );\n            /**\n             * notify the subscription owner that a keepalive message has to be sent.\n             * @event keepalive\n             *\n             */\n            this.emit(\"keepalive\", future_sequence_number);\n            this.state = SubscriptionState.KEEPALIVE;\n\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Reset the Lifetime Counter Variable to the value specified for the lifetime of a Subscription in\n     * the CreateSubscription Service( 5.13.2).\n     * @private\n     */\n    private resetKeepAliveCounter(): void {\n        this._keep_alive_counter = 0;\n\n        // istanbul ignore next\n        doDebug &&\n            debugLog(\n                \"     -> subscriptionId\",\n                this.id,\n                \" Resetting keepAliveCounter = \",\n                this._keep_alive_counter,\n                this.maxKeepAliveCount\n            );\n    }\n\n    /**\n     * @private\n     */\n    private increaseKeepAliveCounter() {\n        this._keep_alive_counter += 1;\n\n        // istanbul ignore next\n        doDebug &&\n            debugLog(\n                \"     -> subscriptionId\",\n                this.id,\n                \" Increasing keepAliveCounter = \",\n                this._keep_alive_counter,\n                this.maxKeepAliveCount\n            );\n    }\n\n    /**\n     * @private\n     */\n    private _addNotificationMessage(notificationData: QueueItem | StatusChangeNotification, monitoredItemId?: number) {\n        // istanbul ignore next\n        doDebug && debugLog(chalk.yellow(\"Subscription#_addNotificationMessage\"), notificationData.toString());\n\n        this._pending_notifications.push({\n            monitoredItemId,\n            notification: notificationData,\n            publishTime: new Date(),\n            start_tick: this.publishIntervalCount\n        });\n    }\n\n    /**\n     * @internal\n     * @param monitoredItemId\n     */\n    private _removePendingNotificationsFor(monitoredItemId: number) {\n        const nbRemovedNotification = this._pending_notifications.filterOut((e) => e.monitoredItemId === monitoredItemId);\n        doDebug && debugLog(`Removed ${nbRemovedNotification} notifications`);\n    }\n    /**\n     * Extract the next Notification that is ready to be sent to the client.\n     * @return the Notification to send._pending_notifications\n     */\n    private _popNotificationToSend(): NotificationMessage {\n        assert(this._pending_notifications.size > 0);\n\n        const notificationMessage = new NotificationMessage({\n            sequenceNumber: 0xffffffff,\n            notificationData: [],\n            publishTime: new Date()\n        }); //\n\n        const dataChangeNotifications: DataChangeNotification = new DataChangeNotification({\n            monitoredItems: []\n        });\n        const eventNotificationList: EventNotificationList = new EventNotificationList({\n            events: []\n        });\n\n        let statusChangeNotification: StatusChangeNotification | undefined;\n\n        let i = 0;\n        let hasEventFieldList = 0;\n        let hasMonitoredItemNotification = 0;\n        const m = this.maxNotificationsPerPublish;\n        while (i < m && this._pending_notifications.size > 0) {\n            if (hasEventFieldList || hasMonitoredItemNotification) {\n                const notification1 = this._pending_notifications.first()!.notification;\n                if (notification1 instanceof StatusChangeNotification) {\n                    break;\n                }\n            }\n            const notification = this._pending_notifications.shift()!.notification;\n            if (notification instanceof MonitoredItemNotification) {\n                assert(notification.clientHandle !== 4294967295);\n                dataChangeNotifications.monitoredItems!.push(notification);\n                hasMonitoredItemNotification = 1;\n            } else if (notification instanceof EventFieldList) {\n                eventNotificationList.events!.push(notification);\n                hasEventFieldList = 1;\n            } else if (notification instanceof StatusChangeNotification) {\n                // to do\n                statusChangeNotification = notification;\n                break;\n            }\n            i += 1;\n        }\n\n        if (dataChangeNotifications.monitoredItems!.length) {\n            notificationMessage.notificationData!.push(dataChangeNotifications);\n        }\n        if (eventNotificationList.events!.length) {\n            notificationMessage.notificationData!.push(eventNotificationList);\n        }\n        if (statusChangeNotification) {\n            notificationMessage.notificationData!.push(statusChangeNotification);\n        }\n        return notificationMessage;\n    }\n\n    /**\n     * discardOldSentNotification find all sent notification message that have expired keep-alive\n     * and destroy them.\n     * @private\n     *\n     * Subscriptions maintain a retransmission queue of sent  NotificationMessages.\n     * NotificationMessages are retained in this queue until they are acknowledged or until they have\n     * been in the queue for a minimum of one keep-alive interval.\n     *\n     */\n    private discardOldSentNotifications() {\n        // Sessions maintain a retransmission queue of sent NotificationMessages. NotificationMessages\n        // are retained in this queue until they are acknowledged. The Session shall maintain a\n        // retransmission queue size of at least two times the number of Publish requests per Session the\n        // Server supports.  Clients are required to acknowledge NotificationMessages as they are received. In the\n        // case of a retransmission queue overflow, the oldest sent NotificationMessage gets deleted. If a\n        // Subscription is transferred to another Session, the queued NotificationMessages for this\n        // Subscription are moved from the old to the new Session.\n        if (maxNotificationMessagesInQueue <= this._sent_notification_messages.length) {\n            doDebug && debugLog(\"discardOldSentNotifications = \", this._sent_notification_messages.length);\n            this._sent_notification_messages.splice(this._sent_notification_messages.length - maxNotificationMessagesInQueue);\n        }\n    }\n\n    /**\n     * @param timestampsToReturn\n     * @param monitoredItemCreateRequest\n     * @param node\n     * @private\n     */\n    private _createMonitoredItemStep2(\n        timestampsToReturn: TimestampsToReturn,\n        monitoredItemCreateRequest: MonitoredItemCreateRequest,\n        node: BaseNode\n    ): MonitoredItemCreateResult {\n        // note : most of the parameter inconsistencies shall have been handled by the caller\n        // any error here will raise an assert here\n\n        assert(monitoredItemCreateRequest instanceof MonitoredItemCreateRequest);\n        const itemToMonitor = monitoredItemCreateRequest.itemToMonitor;\n\n        // xx check if attribute Id invalid (we only support Value or EventNotifier )\n        // xx assert(itemToMonitor.attributeId !== AttributeIds.INVALID);\n\n        this.monitoredItemIdCounter += 1;\n\n        const monitoredItemId = getNextMonitoredItemId();\n\n        const requestedParameters = monitoredItemCreateRequest.requestedParameters;\n\n        // adjust requestedParameters.samplingInterval\n        requestedParameters.samplingInterval = this.adjustSamplingInterval(requestedParameters.samplingInterval, node);\n\n        // reincorporate monitoredItemId and itemToMonitor into the requestedParameters\n        const options = requestedParameters as any as MonitoredItemOptions;\n\n        options.monitoredItemId = monitoredItemId;\n        options.itemToMonitor = itemToMonitor;\n\n        const monitoredItem = new MonitoredItem(options);\n        monitoredItem.timestampsToReturn = timestampsToReturn;\n        monitoredItem.$subscription = this;\n\n        assert(monitoredItem.monitoredItemId === monitoredItemId);\n\n        this.monitoredItems[monitoredItemId] = monitoredItem;\n        this.globalCounter.totalMonitoredItemCount += 1;\n\n        assert(monitoredItem.clientHandle !== 4294967295);\n\n        const filterResult = _process_filter(node, requestedParameters.filter);\n\n        const monitoredItemCreateResult = new MonitoredItemCreateResult({\n            filterResult,\n            monitoredItemId,\n            revisedQueueSize: monitoredItem.queueSize,\n            revisedSamplingInterval: monitoredItem.samplingInterval,\n            statusCode: StatusCodes.Good\n        });\n\n        // this.emit(\"monitoredItem\", monitoredItem, itemToMonitor);\n        return monitoredItemCreateResult;\n    }\n\n    /**\n     *\n     * @param monitoredItem\n     * @param monitoredItemCreateRequest\n     * @private\n     */\n    public _createMonitoredItemStep3(\n        monitoredItem: MonitoredItem | null,\n        monitoredItemCreateRequest: MonitoredItemCreateRequest\n    ): void {\n        if (!monitoredItem) {\n            return;\n        }\n        assert(monitoredItem.monitoringMode === MonitoringMode.Invalid);\n        assert(typeof monitoredItem.samplingFunc === \"function\", \" expecting a sampling function here\");\n        const monitoringMode = monitoredItemCreateRequest.monitoringMode; // Disabled, Sampling, Reporting\n        monitoredItem.setMonitoringMode(monitoringMode);\n    }\n\n    private _harvestMonitoredItems() {\n        for (const monitoredItem of Object.values(this.monitoredItems)) {\n            const notifications_chunks = monitoredItem.extractMonitoredItemNotifications();\n            for (const chunk of notifications_chunks) {\n                this._addNotificationMessage(chunk, monitoredItem.monitoredItemId);\n            }\n        }\n        this._hasUncollectedMonitoredItemNotifications = false;\n    }\n}\n\nassert(Subscription.maximumPublishingInterval < 2147483647, \"maximumPublishingInterval cannot exceed (2**31-1) ms \");\n", "/* eslint-disable max-statements */\n/* global: require,describe,it,before,beforeEach,after,afterEach */\n\"use strict\";\n\nconst should = require(\"should\");\nconst sinon = require(\"sinon\");\n\nconst { StatusCodes } = require(\"node-opcua-status-code\");\nconst { AttributeIds } = require(\"node-opcua-data-model\");\nconst { SessionContext } = require(\"node-opcua-address-space\");\nconst { DataValue } = require(\"node-opcua-data-value\");\nconst { TimestampsToReturn } = require(\"node-opcua-service-read\");\nconst { DataType } = require(\"node-opcua-variant\");\nconst {\n    MonitoredItemCreateRequest,\n    DataChangeNotification,\n    MonitoringMode,\n    PublishRequest\n} = require(\"node-opcua-service-subscription\");\nconst { get_mini_nodeset_filename } = require(\"node-opcua-address-space/testHelpers\");\n\nconst {\n    Subscription,\n    SubscriptionState,\n    MonitoredItem,\n    ServerEngine,\n    ServerSidePublishEngine,\n    installSubscriptionMonitoring\n} = require(\"..\");\nconst add_mock_monitored_item = require(\"./helper\").add_mock_monitored_item;\n\nconst { getFakePublishEngine } = require(\"./helper_fake_publish_engine\");\n\nconst mini_nodeset_filename = get_mini_nodeset_filename();\nlet fake_publish_engine = {};\n\nconst fakeNotificationData = [new DataChangeNotification()];\n\nfunction reconstruct_fake_publish_engine() {\n    fake_publish_engine = getFakePublishEngine();\n}\n\n// eslint-disable-next-line import/order\nconst describe = require(\"node-opcua-leak-detector\").describeWithLeakDetector;\ndescribe(\"Subscriptions\", function () {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const test = this;\n    beforeEach(function () {\n        test.clock = sinon.useFakeTimers();\n        reconstruct_fake_publish_engine();\n    });\n\n    afterEach(function () {\n        test.clock.restore();\n    });\n\n    it(\"T1 - a subscription will make sure that lifeTimeCount is at least 3 times maxKeepAliveCount\", function () {\n        {\n            const subscription1 = new Subscription({\n                publishingInterval: 1000,\n                maxKeepAliveCount: 20,\n                lifeTimeCount: 60, // at least 3 times maxKeepAliveCount\n                //\n                publishEngine: fake_publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n            subscription1.maxKeepAliveCount.should.eql(20);\n            subscription1.lifeTimeCount.should.eql(\n                60,\n                \"lifeTimeCount shall be unchanged because it is at least 3 times maxKeepAliveCount\"\n            );\n\n            subscription1.terminate();\n            subscription1.dispose();\n        }\n        {\n            const subscription2 = new Subscription({\n                publishingInterval: 1000,\n                maxKeepAliveCount: 20,\n                lifeTimeCount: 1, // IS NOT at least 3 times maxKeepAliveCount\n                //\n                publishEngine: fake_publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n            subscription2.maxKeepAliveCount.should.eql(20);\n            subscription2.lifeTimeCount.should.eql(60, \"lifeTimeCount must be adjusted to be at least 3 times maxKeepAliveCount\");\n            subscription2.terminate();\n            subscription2.dispose();\n        }\n    });\n\n    it(\"T2 - when a Subscription is created, the first Message is sent at the end of the first publishing cycle to inform the Client that the Subscription is operational. - Case 1 : PublishRequest in Queue &  no notification available\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            lifeTimeCount: 60, // at least 3 times maxKeepAliveCount\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        // pretend we have received 10 PublishRequest from client\n        fake_publish_engine.pendingPublishRequestCount = 10;\n\n        subscription.maxKeepAliveCount.should.eql(20);\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(1, \" the initial max Keep alive \");\n\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n        subscription._keep_alive_counter.should.eql(0);\n\n        test.clock.tick(subscription.publishingInterval);\n\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(1, \" the initial max Keep alive \");\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n        subscription._keep_alive_counter.should.eql(1);\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription._keep_alive_counter.should.eql(2);\n\n        test.clock.tick(subscription.publishingInterval * 22);\n\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(2);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        test.clock.tick(subscription.publishingInterval * 22);\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(3);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T3 - when a Subscription is created, the first Message is sent at the end of the first publishing cycle to inform the Client that the Subscription is operational. - Case 2 : NoPublishRequest in Queue &  no notification available\", function () {\n        const subscription = new Subscription({\n            id: 1000,\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            lifeTimeCount: 60, // at least 3 times maxKeepAliveCount\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.maxKeepAliveCount.should.eql(20);\n\n        // pretend we have NO PublishRequest from client\n        fake_publish_engine.pendingPublishRequestCount = 0;\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        // pretend we now have many PublishRequest\n        fake_publish_engine.pendingPublishRequestCount = 10;\n\n        test.clock.tick(10);\n        subscription.process_subscription();\n\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(1);\n\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n\n        notification_event_spy.callCount.should.be.equal(0);\n        keepalive_event_spy.callCount.should.equal(2);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T4 - a subscription that have a new notification ready at the end of the  publishingInterval shall send notifications and no keepalive\", function () {\n        const subscription = new Subscription({\n            id: 1000,\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            lifeTimeCount: 60, // at least 3 times maxKeepAliveCount\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        // pretend we have received 10 PublishRequest from client\n        fake_publish_engine.pendingPublishRequestCount = 10;\n        subscription.maxKeepAliveCount.should.eql(20);\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount - 1));\n\n        notification_event_spy.callCount.should.be.greaterThan(2);\n        keepalive_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount + 1));\n        keepalive_event_spy.callCount.should.equal(1);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T5 - a subscription that have only some notification ready before max_keepalive_count expired shall send notifications and no keepalive\", function () {\n        fake_publish_engine.pendingPublishRequestCount.should.eql(0);\n\n        // pretend we have received 10 PublishRequest from client\n        fake_publish_engine.pendingPublishRequestCount = 10;\n\n        const subscription = new Subscription({\n            publishingInterval: 1000, // 1 second interval\n            lifeTimeCount: 100000, // very long lifeTimeCount not to be bother by client not pinging us\n            maxKeepAliveCount: 4,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        subscription.state.should.eql(SubscriptionState.CREATING);\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        /* pretend that we do not have a notification ready */\n        //xx monitoredItem.simulateMonitoredItemAddingNotification();\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        // no notification ready, during 7 x publishinInterval - (keep alve is after 4)\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n\n        notification_event_spy.callCount.should.equal(1);\n        keepalive_event_spy.callCount.should.equal(1);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(2);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n        test.clock.tick(subscription.publishingInterval);\n\n        notification_event_spy.callCount.should.equal(2);\n        keepalive_event_spy.callCount.should.equal(2);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        // a other notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(3);\n        keepalive_event_spy.callCount.should.equal(2);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(3);\n        keepalive_event_spy.callCount.should.equal(2);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(3);\n        keepalive_event_spy.callCount.should.equal(2);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(3);\n        keepalive_event_spy.callCount.should.equal(2);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.NORMAL);\n\n        test.clock.tick(subscription.publishingInterval);\n        notification_event_spy.callCount.should.equal(3);\n        keepalive_event_spy.callCount.should.equal(3);\n        expire_event_spy.callCount.should.equal(0);\n        subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    describe(\"T6 - a subscription shall send its first notification as soon as the publish request is available\", function () {\n        let addressSpace, namespace;\n        let someVariableNode;\n        let engine;\n\n        function add_mock_monitored_item2(subscription, someVariableNode) {\n            const monitoredItemCreateRequest = new MonitoredItemCreateRequest({\n                itemToMonitor: { nodeId: someVariableNode },\n                monitoringMode: MonitoringMode.Reporting,\n                requestedParameters: {\n                    clientHandle: 123,\n                    queueSize: 10,\n                    samplingInterval: 200\n                }\n            });\n            const createResult = subscription.createMonitoredItem(\n                addressSpace,\n                TimestampsToReturn.Both,\n                monitoredItemCreateRequest\n            );\n            const monitoredItem = subscription.getMonitoredItem(createResult.monitoredItemId);\n\n            return monitoredItem;\n        }\n\n        before(function (done) {\n            engine = new ServerEngine();\n            engine.initialize({ nodeset_filename: mini_nodeset_filename }, function () {\n                addressSpace = engine.addressSpace;\n                namespace = addressSpace.getOwnNamespace();\n\n                const node = namespace.addVariable({\n                    componentOf: \"RootFolder\",\n                    browseName: \"SomeVariable\",\n                    dataType: \"UInt32\",\n                    value: { dataType: DataType.UInt32, value: 0 }\n                });\n                someVariableNode = node.nodeId;\n                done();\n            });\n        });\n        after(async () => {\n            await engine.shutdown();\n            engine = null;\n        });\n\n        let publish_engine;\n\n        function simulate_client_adding_publish_request(publishEngine, callback) {\n            const publishRequest = new PublishRequest({});\n            publishEngine._on_PublishRequest(publishRequest, callback);\n            test.clock.tick(0);\n        }\n\n        let subscription;\n        let notification_event_spy, keepalive_event_spy, expire_event_spy;\n\n        beforeEach(function () {\n            publish_engine = new ServerSidePublishEngine();\n            subscription = new Subscription({\n                id: 1000,\n                publishingInterval: 100,\n                maxKeepAliveCount: 10,\n                lifeTimeCount: 30,\n                publishingEnabled: true,\n                publishEngine: publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n            publish_engine.add_subscription(subscription);\n\n            notification_event_spy = sinon.spy();\n            keepalive_event_spy = sinon.spy();\n            expire_event_spy = sinon.spy();\n            subscription.on(\"notification\", notification_event_spy);\n            subscription.on(\"keepalive\", keepalive_event_spy);\n            subscription.on(\"expired\", expire_event_spy);\n\n            subscription.on(\"monitoredItem\", function (monitoredItem) {\n                monitoredItem.samplingFunc = function () {\n                    /**  */\n                };\n            });\n        });\n\n        afterEach(function (done) {\n            subscription.on(\"terminated\", function () {\n                done();\n            });\n            subscription.terminate();\n            subscription.dispose();\n            subscription = null;\n            publish_engine.shutdown();\n            publish_engine.dispose();\n        });\n\n        it(\" - case 1 - publish Request arrives before first publishInterval is over \", async () => {\n            // in this case the subscription received a first publish request before the first tick is processed\n\n            simulate_client_adding_publish_request(subscription.publishEngine);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n            keepalive_event_spy.callCount.should.eql(0);\n\n            test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount - 1));\n            subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n            keepalive_event_spy.callCount.should.eql(1);\n\n            test.clock.tick((subscription.publishingInterval * subscription.maxKeepAliveCount) / 2);\n            keepalive_event_spy.callCount.should.eql(1);\n            subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(1);\n\n            test.clock.tick((subscription.publishingInterval * subscription.maxKeepAliveCount) / 2);\n            subscription.state.should.eql(SubscriptionState.LATE);\n        });\n\n        it(\" - case 2 - publish Request arrives late (after first publishInterval is over)\", async () => {\n            // now simulate some data change\n            test.clock.tick((subscription.publishingInterval * subscription.maxKeepAliveCount) / 2);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n            keepalive_event_spy.callCount.should.eql(0);\n\n            simulate_client_adding_publish_request(subscription.publishEngine);\n\n            keepalive_event_spy.callCount.should.eql(0);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n            subscription.state.should.eql(SubscriptionState.KEEPALIVE);\n\n            keepalive_event_spy.callCount.should.eql(1);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(1);\n        });\n\n        it(\" - case 3 - publish Request arrives late (after first publishInterval is over)\", function () {\n            const monitoredItem = add_mock_monitored_item2(subscription, someVariableNode);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            // now simulate some data change\n            monitoredItem.recordValue(new DataValue({ value: { dataType: DataType.UInt32, value: 1000 } }));\n\n            notification_event_spy.callCount.should.eql(0);\n            simulate_client_adding_publish_request(subscription.publishEngine);\n\n            subscription.state.should.eql(SubscriptionState.NORMAL); // Back to Normal\n            notification_event_spy.callCount.should.eql(1);\n\n            test.clock.tick(subscription.publishingInterval);\n            notification_event_spy.callCount.should.eql(1);\n            subscription.state.should.eql(SubscriptionState.NORMAL); // Back to Normal\n            keepalive_event_spy.callCount.should.eql(0);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n        });\n\n        it(\" - case 4 - publish Request arrives late (after first publishInterval is over)\", function () {\n            const monitoredItem = add_mock_monitored_item2(subscription, someVariableNode);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            // now simulate some data change\n            monitoredItem.recordValue(new DataValue({ value: { dataType: DataType.UInt32, value: 1000 } }));\n\n            notification_event_spy.callCount.should.eql(0);\n            simulate_client_adding_publish_request(subscription.publishEngine);\n\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n            notification_event_spy.callCount.should.eql(1);\n\n            test.clock.tick(subscription.publishingInterval);\n            notification_event_spy.callCount.should.eql(1);\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n            keepalive_event_spy.callCount.should.eql(0);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n        });\n\n        it(\" - case 4 (with monitoredItem - 3x value writes) - publish Request arrives late (after first publishInterval is over)\", function () {\n            const monitoredItem = add_mock_monitored_item2(subscription, someVariableNode);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n            subscription.state.should.eql(SubscriptionState.CREATING);\n\n            // now simulate some data change\n            monitoredItem.recordValue(new DataValue({ value: { dataType: DataType.UInt32, value: 1000 } }));\n            notification_event_spy.callCount.should.eql(0);\n\n            simulate_client_adding_publish_request(subscription.publishEngine);\n            notification_event_spy.callCount.should.eql(1);\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            monitoredItem.recordValue(new DataValue({ value: { dataType: DataType.UInt32, value: 1001 } }));\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.state.should.eql(SubscriptionState.LATE);\n\n            simulate_client_adding_publish_request(subscription.publishEngine);\n            test.clock.tick(subscription.publishingInterval);\n\n            notification_event_spy.callCount.should.eql(2);\n            subscription.hasPendingNotifications.should.eql(false);\n            subscription.hasUncollectedMonitoredItemNotifications.should.eql(false);\n\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            monitoredItem.recordValue(new DataValue({ value: { dataType: DataType.UInt32, value: 1002 } }));\n\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n\n            test.clock.tick(subscription.publishingInterval);\n            simulate_client_adding_publish_request(subscription.publishEngine);\n\n            test.clock.tick(subscription.publishingInterval);\n            notification_event_spy.callCount.should.eql(3);\n\n            subscription.state.should.eql(SubscriptionState.NORMAL);\n            keepalive_event_spy.callCount.should.eql(0);\n\n            test.clock.tick(subscription.publishingInterval);\n            keepalive_event_spy.callCount.should.eql(0);\n        });\n    });\n\n    it(\"T7 - a subscription that hasn't been pinged by client within the lifetime interval shall terminate\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 250,\n            maxKeepAliveCount: 3,\n            lifeTimeCount: 30,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        false && installSubscriptionMonitoring(subscription);\n\n        subscription.publishingInterval.should.eql(250);\n        subscription.maxKeepAliveCount.should.eql(3);\n        subscription.lifeTimeCount.should.eql(30);\n\n        const expire_event_spy = sinon.spy();\n        subscription.on(\"expired\", expire_event_spy);\n        const terminate_spy = sinon.spy(subscription, \"terminate\");\n\n        subscription.state.should.eql(SubscriptionState.CREATING);\n        subscription.currentLifetimeCount.should.eql(0);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.lifeTimeCount - 3));\n     \n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n\n        test.clock.tick(subscription.publishingInterval * 3);\n        test.clock.tick(subscription.publishingInterval * subscription.maxKeepAliveCount);\n\n        terminate_spy.callCount.should.equal(1);\n        expire_event_spy.callCount.should.equal(1);\n        subscription.state.should.eql(SubscriptionState.CLOSED);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T8 - a subscription that has been pinged by client before the lifetime expiration shall not terminate\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const expire_event_spy = sinon.spy();\n        subscription.on(\"expired\", expire_event_spy);\n        const terminate_spy = sinon.spy(subscription, \"terminate\");\n\n        test.clock.tick(subscription.publishingInterval * (subscription.lifeTimeCount - 2));\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n\n        subscription.resetLifeTimeAndKeepAliveCounters();\n\n        test.clock.tick(subscription.publishingInterval * 4);\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.lifeTimeCount + 2));\n        terminate_spy.callCount.should.equal(1);\n        expire_event_spy.callCount.should.equal(1);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T9 - a subscription that has no notification within maxKeepAliveCount shall send a keepalive signal \", function () {\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 1000,\n            lifeTimeCount: 100000, // very large lifetime not to be bother by client not pinging us\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const expire_event_spy = sinon.spy();\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        subscription.on(\"expired\", expire_event_spy);\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n\n        const terminate_spy = sinon.spy(subscription, \"terminate\");\n\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount - 5));\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(0);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount + 5));\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(2);\n\n        test.clock.tick(subscription.publishingInterval * (subscription.maxKeepAliveCount + 3));\n\n        terminate_spy.callCount.should.equal(0);\n        expire_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(3);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T10 - a subscription shall maintain a retransmission queue of pending NotificationMessages.\", function () {\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            maxNotificationsPerPublish: 2, //\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        subscription.maxNotificationsPerPublish.should.eql(2);\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        subscription.pendingNotificationsCount.should.equal(0);\n        test.clock.tick(subscription.publishingInterval);\n        subscription.state.should.eql(SubscriptionState.LATE);\n\n        // pretend we have received  PublishRequest from client\n        fake_publish_engine.pendingPublishRequestCount = 4;\n        test.clock.tick(subscription.publishingInterval);\n\n        subscription.sentNotificationMessageCount.should.equal(1);\n\n        subscription.pendingNotificationsCount.should.equal(7);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    //OPC Unified Architecture, Part 4 74 Release 1.01\n    it(\"T11 - a subscription shall maintain a retransmission queue of sent NotificationMessages.\", function () {\n        const subscription = new Subscription({\n            id: 1234,\n            publishingInterval: 1000,\n            lifeTimeCount: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        fake_publish_engine.pendingPublishRequestCount = 10;\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        subscription.pendingNotificationsCount.should.equal(0);\n        subscription.sentNotificationMessageCount.should.equal(0);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        test.clock.tick(subscription.publishingInterval);\n        subscription.pendingNotificationsCount.should.equal(0);\n        subscription.sentNotificationMessageCount.should.equal(1);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n        subscription.pendingNotificationsCount.should.equal(0);\n        subscription.sentNotificationMessageCount.should.equal(2);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    describe(\"T12 - NotificationMessages are retained in this queue until they are acknowledged or until they have been in the queue for a minimum of one keep-alive interval.\", function () {\n        it(\"T12-1 a NotificationMessage is retained in this queue until it is acknowledged\", function () {\n            const subscription = new Subscription({\n                id: 1234,\n                publishingInterval: 1000,\n                lifeTimeCount: 1000,\n                maxKeepAliveCount: 20,\n                //\n                publishEngine: fake_publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n\n            const _send_response_spy = sinon.spy(fake_publish_engine, \"_send_response\");\n            const monitoredItem = add_mock_monitored_item(subscription);\n\n            monitoredItem.simulateMonitoredItemAddingNotification();\n            monitoredItem.simulateMonitoredItemAddingNotification();\n            subscription.sentNotificationMessageCount.should.equal(0);\n\n            // pretend that we have 10 PublishRequest waiting in the queue\n            fake_publish_engine.pendingPublishRequestCount = 10;\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.sentNotificationMessageCount.should.equal(1);\n\n            fake_publish_engine.pendingPublishRequestCount.should.eql(9);\n\n            _send_response_spy.callCount.should.equal(1);\n\n            monitoredItem.simulateMonitoredItemAddingNotification();\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.sentNotificationMessageCount.should.equal(2);\n\n            const notification1 = _send_response_spy.getCall(0).args[1].notificationMessage;\n            notification1.sequenceNumber.should.eql(1);\n\n            const notification2 = _send_response_spy.getCall(1).args[1].notificationMessage;\n            notification2.sequenceNumber.should.eql(2);\n\n            subscription.acknowledgeNotification(notification2.sequenceNumber);\n            subscription.sentNotificationMessageCount.should.equal(1);\n\n            subscription.acknowledgeNotification(notification1.sequenceNumber);\n            subscription.sentNotificationMessageCount.should.equal(0);\n\n            subscription.terminate();\n            subscription.dispose();\n        });\n\n        it(\"T12-2 A notificationMessage that hasn't been acknowledge should be accessiblef for republish\", function () {\n            fake_publish_engine.pendingPublishRequestCount = 10;\n\n            const send_response_spy = sinon.spy(fake_publish_engine, \"_send_response\");\n\n            //#getMessageForSequenceNumber\n            const subscription = new Subscription({\n                id: 1234,\n                publishingInterval: 1000,\n                lifeTimeCount: 1000,\n                maxKeepAliveCount: 20,\n                //\n                publishEngine: fake_publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n\n            const monitoredItem = add_mock_monitored_item(subscription);\n\n            should(subscription.getMessageForSequenceNumber(35)).eql(null);\n\n            monitoredItem.simulateMonitoredItemAddingNotification();\n            monitoredItem.simulateMonitoredItemAddingNotification();\n\n            subscription.sentNotificationMessageCount.should.equal(0);\n\n            test.clock.tick(subscription.publishingInterval);\n            subscription.sentNotificationMessageCount.should.equal(1);\n\n            const notification1 = send_response_spy.getCall(0).args[1].notificationMessage;\n            notification1.sequenceNumber.should.eql(1);\n            const seqNum = notification1.sequenceNumber;\n\n            //\n            const message = subscription.getMessageForSequenceNumber(seqNum);\n            message.sequenceNumber.should.eql(seqNum);\n\n            subscription.terminate();\n            subscription.dispose();\n        });\n\n        it(\"T12-3 - 1.02 the server shall retain a maximum number of un-acknowledged NotificationMessage until they are acknowledged\", function () {\n            // TODO\n        });\n\n        xit(\"T12-4 - 1.01 a NotificationMessage is retained until it has been in the queue for a minimum of one keep-alive interval.\", function () {\n            // this conforms to OPC UA specifciation 1.01 and is now obsolete as behavior has been chanded in 1.02\n\n            const subscription = new Subscription({\n                id: 1234,\n                publishingInterval: 1000,\n                lifeTimeCount: 1000,\n                maxKeepAliveCount: 20,\n                //\n                publishEngine: fake_publish_engine,\n                globalCounter: { totalMonitoredItemCount: 0 },\n                serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n            });\n            // create a notification at t=0\n            subscription.addNotificationMessage(fakeNotificationData);\n            subscription._popNotificationToSend();\n            subscription.sentNotificationMessageCount.should.equal(1);\n\n            test.clock.tick(1000 * 5);\n            // create a notification at t=1000*5\n            subscription.addNotificationMessage(fakeNotificationData);\n            subscription._popNotificationToSend();\n            subscription.sentNotificationMessageCount.should.equal(2);\n\n            test.clock.tick(1000 * 20);\n            // now check that at t=1000*25 , old notification has been discarded\n            subscription.sentNotificationMessageCount.should.equal(1);\n\n            test.clock.tick(1000 * 100);\n            // now check that at t=1000*100 , old notification has been discarded\n            subscription.sentNotificationMessageCount.should.equal(0);\n\n            subscription.terminate();\n            subscription.dispose();\n        });\n    });\n\n    it(\"T13 - a subscription that have no monitored items shall not terminate if client has sent enough PublishRequest\", function () {\n        // pretend there is plenty of PublishRequest in publish engine\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 100,\n            maxKeepAliveCount: 20,\n            lifeTimeCount: 10,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        subscription.maxKeepAliveCount.should.eql(20);\n        subscription.publishingInterval.should.eql(100);\n\n        test.clock.tick(6 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n\n        subscription.publishIntervalCount.should.equal(\n            120,\n            \" 3000 ms with a publishingInterval: 100 ms means publishIntervalCount = 30\"\n        );\n\n        expire_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(6);\n        notification_event_spy.callCount.should.equal(0);\n\n        test.clock.tick(6 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        expire_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(12);\n        notification_event_spy.callCount.should.equal(0);\n\n        test.clock.tick(6 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        expire_event_spy.callCount.should.equal(0);\n        keepalive_event_spy.callCount.should.equal(18);\n        notification_event_spy.callCount.should.equal(0);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T14 - a subscription send a first message at the end of the first publishing cycle without waiting for the maximum  count to be reached\", function () {\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        /**\n         * When a Subscription is created, the first Message is sent at the end of the first publishing cycle to\n         * inform the Client that the Subscription is operational. A Notification Message is sent if there are\n         * Notifications ready to be reported. If there are none, a keep-alive Message is sent instead that\n         * contains a sequence number of 1, indicating that the first Notification Message has not yet been\n         * sent. This is the only time a keep-alive Message is sent without waiting for the maximum keep-alive\n         * count to be reached, as specified in (f) above.\n         *\n         */\n        const subscription = new Subscription({\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // pretend that we already have notification messages\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        test.clock.tick(200);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(0);\n\n        test.clock.tick(1000);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(1);\n\n        test.clock.tick(1000);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(1);\n\n        test.clock.tick(30000);\n        keepalive_event_spy.callCount.should.equal(1);\n        notification_event_spy.callCount.should.eql(1);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T15 - the first Notification Message sent on a Subscription has a sequence number of 1.\", function () {\n        const subscription = new Subscription({\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription._get_future_sequence_number().should.equal(1);\n        subscription._get_next_sequence_number().should.equal(1);\n        subscription._get_next_sequence_number().should.equal(2);\n        subscription._get_next_sequence_number().should.equal(3);\n        subscription._get_future_sequence_number().should.equal(4);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T16 - should return BadMonitorItemInvalid when trying to remove a monitored item that doesn't exist\", function () {\n        const subscription = new Subscription({\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.removeMonitoredItem(26).should.eql(StatusCodes.BadMonitoredItemIdInvalid);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"T17 - should be possible to  modify subscription publishing interval\", function(){\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        /**\n         * When a Subscription is created, the first Message is sent at the end of the first publishing cycle to\n         * inform the Client that the Subscription is operational. A Notification Message is sent if there are\n         * Notifications ready to be reported. If there are none, a keep-alive Message is sent instead that\n         * contains a sequence number of 1, indicating that the first Notification Message has not yet been\n         * sent. This is the only time a keep-alive Message is sent without waiting for the maximum keep-alive\n         * count to be reached, as specified in (f) above.\n         *\n         */\n        const subscription = new Subscription({\n            publishingInterval: 1000,\n            maxKeepAliveCount: 20,\n            //\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // pretend that we already have notification messages\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        test.clock.tick(200);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(0);\n\n        test.clock.tick(1000);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(1);\n\n        test.clock.tick(1000);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(1);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        // now change the publishin Intervale\n        subscription.modify({ requestedPublishingInterval: 2000});\n       \n        test.clock.tick(1000);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(1);\n\n        test.clock.tick(1010);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(2);\n\n        subscription.terminate();\n        subscription.dispose();\n\n    });\n\n\n    xit(\"closing a Subscription causes its MonitoredItems to be deleted. \", function () {\n        /** */\n    });\n});\n\ndescribe(\"Subscription#setPublishingMode\", function () {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const test = this;\n    beforeEach(function () {\n        test.clock = sinon.useFakeTimers();\n        reconstruct_fake_publish_engine();\n    });\n\n    afterEach(function () {\n        test.clock.restore();\n    });\n    it(\"W1 - a subscription created with publishingEnabled=true shall emit notification\", function (done) {\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 100,\n            maxKeepAliveCount: 5,\n            lifeTimeCount: 10,\n            publishingEnabled: true, //  PUBLISHING IS ENABLED !!!\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // pretend that we already have notification messages\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        // a notification finally arrived !\n        monitoredItem.simulateMonitoredItemAddingNotification();\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        test.clock.tick(subscription.publishingInterval * 4);\n\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.eql(1); // all notif shall be compressed into one message\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        notification_event_spy.callCount.should.be.greaterThan(4);\n\n        subscription.terminate();\n        subscription.dispose();\n\n        done();\n    });\n\n    it(\"W2 - a subscription created with publishingEnabled=false shall not emit notification (but keepalive)\", function (done) {\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 100,\n            maxKeepAliveCount: 5,\n            lifeTimeCount: 10,\n\n            publishingEnabled: false, //  PUBLISHING IS DISABLED !!!\n\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        monitoredItem.simulateMonitoredItemAddingNotification();\n        test.clock.tick(subscription.publishingInterval);\n\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(5);\n        notification_event_spy.callCount.should.eql(0);\n\n        subscription.terminate();\n        subscription.dispose();\n        done();\n    });\n\n    it(\"W3 - a publishing subscription can be disabled and re-enabled\", function (done) {\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 100,\n            maxKeepAliveCount: 5,\n            lifeTimeCount: 10,\n            publishingEnabled: true, //  PUBLISHING IS ENABLED !!!\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // the monitoredItem provides a new notification every 50ms\n        function push_some_notification() {\n            monitoredItem.simulateMonitoredItemAddingNotification();\n        }\n        const t = setInterval(push_some_notification, 50);\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        test.clock.tick(subscription.publishingInterval * 22);\n        keepalive_event_spy.callCount.should.equal(0);\n        notification_event_spy.callCount.should.be.greaterThan(20);\n\n        // now disable\n        subscription.setPublishingMode(false);\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(4);\n        notification_event_spy.callCount.should.be.greaterThan(20);\n\n        subscription.setPublishingMode(true);\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(4);\n        notification_event_spy.callCount.should.be.greaterThan(40);\n\n        clearInterval(t);\n\n        subscription.terminate();\n        subscription.dispose();\n        done();\n    });\n\n    it(\"W4 - a disabled subscription shall continue to send keep-alive notifications\", function (done) {\n        // What the specs say:\n        // Publishing by a Subscription may be enabled or disabled by the Client when created, or\n        // subsequently using the SetPublishingMode Service. Disabling causes the Subscription to\n        // cease sending NotificationMessages to the Client. However, the Subscription continues\n        // to execute cyclically and continues to send keep-alive Messages to the Client.\n\n        // pretend the client has sent many pending PublishRequests\n        fake_publish_engine.pendingPublishRequestCount = 1000;\n\n        const subscription = new Subscription({\n            publishingInterval: 100,\n            maxKeepAliveCount: 5,\n            lifeTimeCount: 10,\n            publishingEnabled: false, //  PUBLISHING IS DISABLED !!!\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        const monitoredItem = add_mock_monitored_item(subscription);\n\n        // the monitoredItem provides a new notification every 50ms\n        function push_some_notification() {\n            monitoredItem.simulateMonitoredItemAddingNotification();\n        }\n        const t = setInterval(push_some_notification, 50);\n\n        const notification_event_spy = sinon.spy();\n        const keepalive_event_spy = sinon.spy();\n        const expire_event_spy = sinon.spy();\n\n        subscription.on(\"notification\", notification_event_spy);\n        subscription.on(\"keepalive\", keepalive_event_spy);\n        subscription.on(\"expired\", expire_event_spy);\n\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(4); // 2000 = 4*5*100\n        notification_event_spy.callCount.should.be.equal(0);\n\n        subscription.setPublishingMode(true);\n\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(4);\n        notification_event_spy.callCount.should.be.greaterThan(19);\n        const nb = notification_event_spy.callCount;\n\n        subscription.setPublishingMode(false);\n        test.clock.tick(4 * subscription.publishingInterval * subscription.maxKeepAliveCount);\n        keepalive_event_spy.callCount.should.equal(8);\n        notification_event_spy.callCount.should.be.equal(nb);\n\n        clearInterval(t);\n\n        subscription.terminate();\n        subscription.dispose();\n        done();\n    });\n});\n\ndescribe(\"Subscription#adjustSamplingInterval\", function () {\n    beforeEach(function () {\n        //xx        test.clock = sinon.useFakeTimers();\n        reconstruct_fake_publish_engine();\n    });\n\n    it(\"should have a minimum sampling interval, with a strictly positive value ( which is the fastest possible rate)\", function () {\n        MonitoredItem.minimumSamplingInterval.should.be.greaterThan(4);\n    });\n\n    it(\"should have a default sampling interval, greater than minimumSamplingInterval \", function () {\n        MonitoredItem.defaultSamplingInterval.should.be.greaterThan(MonitoredItem.minimumSamplingInterval);\n    });\n\n    it(\"should have a maximum sampling interval, greater than defaultSamplingInterval \", function () {\n        MonitoredItem.maximumSamplingInterval.should.be.greaterThan(MonitoredItem.defaultSamplingInterval);\n    });\n\n    it(\"should adjust sampling interval to subscription publish interval when requested sampling interval === -1\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n\n        subscription.adjustSamplingInterval(-1).should.eql(subscription.publishingInterval);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    const fake_node = {\n        readAttribute: function (context, attributeId) {\n            context.should.be.instanceOf(SessionContext);\n            attributeId.should.eql(AttributeIds.MinimumSamplingInterval);\n            return new DataValue({ value: { dataType: DataType.Double, value: 0.0 } });\n        }\n    };\n\n    it(\"should adjust sampling interval to subscription publish interval when requested sampling interval is a negative value !== -1\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.adjustSamplingInterval(-2, fake_node).should.eql(subscription.publishingInterval);\n        subscription.adjustSamplingInterval(-0.02, fake_node).should.eql(subscription.publishingInterval);\n\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"should leave sampling interval to 0 when requested sampling interval === 0 ( 0 means Event Based mode)\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.adjustSamplingInterval(0, fake_node).should.eql(0);\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"should adjust sampling interval to minimum when requested sampling interval === 1\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.adjustSamplingInterval(1, fake_node).should.eql(MonitoredItem.minimumSamplingInterval);\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"should adjust sampling interval to maximum when requested sampling interval is too high\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        subscription.adjustSamplingInterval(1e10, fake_node).should.eql(MonitoredItem.maximumSamplingInterval);\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"should return an unmodified sampling interval when requested sampling is in valid range\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        const someValidSamplingInterval = (MonitoredItem.maximumSamplingInterval + MonitoredItem.minimumSamplingInterval) / 2.0;\n        subscription.adjustSamplingInterval(someValidSamplingInterval, fake_node).should.eql(someValidSamplingInterval);\n        subscription.terminate();\n        subscription.dispose();\n    });\n\n    it(\"should adjust sampling interval the minimumSamplingInterval when requested sampling is too low\", function () {\n        const subscription = new Subscription({\n            publishingInterval: 1234,\n            publishEngine: fake_publish_engine,\n            globalCounter: { totalMonitoredItemCount: 0 },\n            serverCapabilities: { maxMonitoredItems: 10000, maxMonitoredItemsPerSubscription: 1000 }\n        });\n        const someVeryLowSamplingInterval = 1;\n        subscription\n            .adjustSamplingInterval(someVeryLowSamplingInterval, fake_node)\n            .should.eql(MonitoredItem.minimumSamplingInterval);\n        subscription.terminate();\n        subscription.dispose();\n    });\n});\n"], "filenames": ["packages/node-opcua-server/source/server_subscription.ts", "packages/node-opcua-server/test/test_subscription.js"], "buggy_code_start_loc": [632, 1064], "buggy_code_end_loc": [1483, 1064], "fixing_code_start_loc": [632, 1065], "fixing_code_end_loc": [1486, 1130], "type": "CWE-400", "message": "The package node-opcua before 2.74.0 are vulnerable to Denial of Service (DoS) when bypassing the limitations for excessive memory consumption by sending multiple CloseSession requests with the deleteSubscription parameter equal to False.", "other": {"cve": {"id": "CVE-2022-24375", "sourceIdentifier": "report@snyk.io", "published": "2022-08-24T05:15:07.230", "lastModified": "2022-08-26T12:52:37.200", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The package node-opcua before 2.74.0 are vulnerable to Denial of Service (DoS) when bypassing the limitations for excessive memory consumption by sending multiple CloseSession requests with the deleteSubscription parameter equal to False."}, {"lang": "es", "value": "El paquete node-opcua versiones anteriores a 2.74.0, es vulnerable a una Denegaci\u00f3n de Servicio (DoS) cuando omite las limitaciones por consumo excesivo de memoria mediante el env\u00edo de m\u00faltiples peticiones CloseSession con el par\u00e1metro deleteSubscription igual a False."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:node-opcua_project:node-opcua:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.74.0", "matchCriteriaId": "900AECE1-5AD5-4065-AE88-E02D6885B83C"}]}]}], "references": [{"url": "https://github.com/node-opcua/node-opcua/commit/3fd46ec156e7718a506be41f3916310b6bdd0407", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/node-opcua/node-opcua/commit/7b5044b3f5866fbedc3efabd05e407352c07bd2f", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/node-opcua/node-opcua/pull/1182", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.snyk.io/vuln/SNYK-JS-NODEOPCUA-2988725", "source": "report@snyk.io", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/node-opcua/node-opcua/commit/3fd46ec156e7718a506be41f3916310b6bdd0407"}}